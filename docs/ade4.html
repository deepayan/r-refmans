<!DOCTYPE html><html><head><title>Help for package ade4</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ade4}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ade4-package'><p>The ade4 package</p></a></li>
<li><a href='#abouheif.eg'><p>Phylogenies and quantitative traits from Abouheif</p></a></li>
<li><a href='#acacia'><p>Spatial pattern analysis in plant communities</p></a></li>
<li><a href='#add.scatter'><p>Add graphics to an existing plot</p></a></li>
<li><a href='#ade4-internal'><p>Internal ade4 functions</p></a></li>
<li><a href='#adegraphicsLoaded'><p>Utility function to test if the package adegraphics is loaded</p></a></li>
<li><a href='#aminoacyl'><p>Codon usage</p></a></li>
<li><a href='#amova'><p>Analysis of molecular variance</p></a></li>
<li><a href='#apis108'><p>Allelic frequencies in ten honeybees populations at eight microsatellites loci</p></a></li>
<li><a href='#apqe'><p>Apportionment of Quadratic Entropy</p></a></li>
<li><a href='#aravo'><p>Distribution of Alpine plants in Aravo (Valloire, France)</p></a></li>
<li><a href='#ardeche'><p>Fauna Table with double (row and column) partitioning</p></a></li>
<li><a href='#area.plot'><p>Graphical Display of Areas</p></a></li>
<li><a href='#arrival'><p>Arrivals at an intensive care unit</p></a></li>
<li><a href='#as.taxo'><p>Taxonomy</p></a></li>
<li><a href='#atlas'><p>Small Ecological Dataset</p></a></li>
<li><a href='#atya'><p>Genetic variability of Cacadors</p></a></li>
<li><a href='#avijons'><p>Bird species distribution</p></a></li>
<li><a href='#avimedi'><p>Fauna Table for Constrained Ordinations</p></a></li>
<li><a href='#aviurba'><p>Ecological Tables Triplet</p></a></li>
<li><a href='#bacteria'><p>Genomes of 43 Bacteria</p></a></li>
<li><a href='#banque'><p>Table of Factors</p></a></li>
<li><a href='#baran95'><p>African Estuary Fishes</p></a></li>
<li><a href='#bca'><p>Between-Class Analysis</p></a></li>
<li><a href='#bca.coinertia'><p>Between-class coinertia analysis</p></a></li>
<li><a href='#bca.rlq'>
<p>Between-Class RLQ analysis</p></a></li>
<li><a href='#between'><p>Between-Class Analysis</p></a></li>
<li><a href='#bf88'><p>Cubic Ecological Data</p></a></li>
<li><a href='#bicenter.wt'><p>Double Weighted Centring</p></a></li>
<li><a href='#bordeaux'><p>Wine Tasting</p></a></li>
<li><a href='#bsetal97'><p>Ecological and Biological Traits</p></a></li>
<li><a href='#buech'><p>Buech basin</p></a></li>
<li><a href='#butterfly'><p>Genetics-Ecology-Environment Triple</p></a></li>
<li><a href='#bwca.dpcoa'>
<p>Between- and within-class double principal coordinate analysis</p></a></li>
<li><a href='#cailliez'><p>Transformation to make Euclidean a distance matrix</p></a></li>
<li><a href='#capitales'><p>Road Distances</p></a></li>
<li><a href='#carni19'><p>Phylogeny and quantative trait of carnivora</p></a></li>
<li><a href='#carni70'><p>Phylogeny and quantitative traits of carnivora</p></a></li>
<li><a href='#carniherbi49'><p>Taxonomy, phylogenies and quantitative traits of carnivora and herbivora</p></a></li>
<li><a href='#casitas'><p>Enzymatic polymorphism in Mus musculus</p></a></li>
<li><a href='#chatcat'><p>Qualitative Weighted Variables</p></a></li>
<li><a href='#chats'><p>Pair of Variables</p></a></li>
<li><a href='#chazeb'><p>Charolais-Zebus</p></a></li>
<li><a href='#chevaine'><p>Enzymatic polymorphism in Leuciscus cephalus</p></a></li>
<li><a href='#chickenk'><p>Veterinary epidemiological study to assess the risk factors for losses in broiler chickens</p></a></li>
<li><a href='#clementines'><p>Fruit Production</p></a></li>
<li><a href='#cnc2003'><p>Frequenting movie theaters in France in 2003</p></a></li>
<li><a href='#coinertia'><p>Coinertia Analysis</p></a></li>
<li><a href='#coleo'><p>Table of Fuzzy Biological Traits</p></a></li>
<li><a href='#combine.4thcorner'><p>Functions to combine and adjust the outputs 3-table methods</p></a></li>
<li><a href='#corkdist'><p>Tests of randomization between distances applied to 'kdist' objetcs</p></a></li>
<li><a href='#corvus'><p>Corvus morphology</p></a></li>
<li><a href='#costatis'><p>STATIS and Co-Inertia : Analysis of a series of paired ecological tables</p></a></li>
<li><a href='#costatis.randtest'><p>Monte-Carlo test on a Costatis analysis (in C).</p></a></li>
<li><a href='#dagnelie.test'><p>Dagnelie multinormality test</p></a></li>
<li><a href='#Deprecated functions'><p>Deprecated functions in ade4</p></a></li>
<li><a href='#deug'><p>Exam marks for some students</p></a></li>
<li><a href='#disc'><p>Rao's dissimilarity coefficient</p></a></li>
<li><a href='#discrimin'><p>Linear Discriminant Analysis (descriptive statistic)</p></a></li>
<li><a href='#discrimin.coa'><p>Discriminant Correspondence Analysis</p></a></li>
<li><a href='#dist.binary'><p>Computation of Distance Matrices for Binary Data</p></a></li>
<li><a href='#dist.dudi'><p>Computation of the Distance Matrix from a Statistical Triplet</p></a></li>
<li><a href='#dist.ktab'><p>Mixed-variables coefficient of distance</p></a></li>
<li><a href='#dist.neig'><p>Computation of the Distance Matrix associated to a Neighbouring Graph</p></a></li>
<li><a href='#dist.prop'><p>Computation of Distance Matrices of Percentage Data</p></a></li>
<li><a href='#dist.quant'><p>Computation of Distance Matrices on Quantitative Variables</p></a></li>
<li><a href='#divc'><p>Rao's diversity coefficient also called quadratic entropy</p></a></li>
<li><a href='#divcmax'><p>Maximal value of Rao's diversity coefficient also called</p>
quadratic entropy</a></li>
<li><a href='#dotchart.phylog'><p>Representation of many quantitative variables in front of a phylogenetic tree</p></a></li>
<li><a href='#dotcircle'><p>Representation of n values on a circle</p></a></li>
<li><a href='#doubs'><p>Pair of Ecological Tables</p></a></li>
<li><a href='#dpcoa'><p>Double principal coordinate analysis</p></a></li>
<li><a href='#dudi'><p>Duality Diagram</p></a></li>
<li><a href='#dudi.acm'><p>Multiple Correspondence Analysis</p></a></li>
<li><a href='#dudi.coa'><p>Correspondence Analysis</p></a></li>
<li><a href='#dudi.dec'><p>Decentred Correspondence Analysis</p></a></li>
<li><a href='#dudi.fca'><p>Fuzzy Correspondence Analysis and Fuzzy Principal Components Analysis</p></a></li>
<li><a href='#dudi.hillsmith'><p> Ordination of Tables mixing quantitative variables and factors</p></a></li>
<li><a href='#dudi.mix'><p>Ordination of Tables mixing quantitative variables and factors</p></a></li>
<li><a href='#dudi.nsc'><p>Non symmetric correspondence analysis</p></a></li>
<li><a href='#dudi.pca'><p>Principal Component Analysis</p></a></li>
<li><a href='#dudi.pco'><p>Principal Coordinates Analysis</p></a></li>
<li><a href='#dunedata'><p>Dune Meadow Data</p></a></li>
<li><a href='#ecg'><p>Electrocardiogram data</p></a></li>
<li><a href='#ecomor'><p>Ecomorphological Convergence</p></a></li>
<li><a href='#elec88'><p>Electoral Data</p></a></li>
<li><a href='#escopage'><p>K-tables of wine-tasting</p></a></li>
<li><a href='#euro123'><p>Triangular Data</p></a></li>
<li><a href='#fission'><p>Fission pattern and heritable morphological traits</p></a></li>
<li><a href='#foucart'><p>K-tables Correspondence Analysis with the same rows and the same columns</p></a></li>
<li><a href='#fourthcorner'><p> Functions to compute the fourth-corner statistic</p></a></li>
<li><a href='#friday87'><p>Faunistic K-tables</p></a></li>
<li><a href='#fruits'><p>Pair of Tables</p></a></li>
<li><a href='#gearymoran'><p>Moran's I and Geary'c randomization tests for spatial and phylogenetic autocorrelation</p></a></li>
<li><a href='#ggtortoises'><p>Microsatellites of Galapagos tortoises populations</p></a></li>
<li><a href='#granulo'><p>Granulometric Curves</p></a></li>
<li><a href='#gridrowcol'><p>Complete regular grid analysis</p></a></li>
<li><a href='#hdpg'><p>Genetic Variation In Human Populations</p></a></li>
<li><a href='#houmousr'><p>Morphometric data set</p></a></li>
<li><a href='#housetasks'><p>Contingency Table</p></a></li>
<li><a href='#humDNAm'><p>human mitochondrial DNA restriction data</p></a></li>
<li><a href='#ichtyo'><p>Point sampling of fish community</p></a></li>
<li><a href='#inertia.dudi'><p>Decomposition of inertia (i.e. contributions) in multivariate methods</p></a></li>
<li><a href='#irishdata'><p>Geary's Irish Data</p></a></li>
<li><a href='#is.euclid'><p>Is a Distance Matrix Euclidean?</p></a></li>
<li><a href='#julliot'><p>Seed dispersal</p></a></li>
<li><a href='#jv73'><p>K-tables Multi-Regions</p></a></li>
<li><a href='#kcponds'><p>Ponds in a nature reserve</p></a></li>
<li><a href='#kdist'><p>the class of objects 'kdist' (K distance matrices)</p></a></li>
<li><a href='#kdist2ktab'><p> Transformation of K distance matrices (object 'kdist') into K Euclidean representations (object 'ktab')</p></a></li>
<li><a href='#kdisteuclid'><p>a way to obtain Euclidean distance matrices</p></a></li>
<li><a href='#kplot'><p>Generic Function for Multiple Graphs in a K-tables Analysis</p></a></li>
<li><a href='#kplot.foucart'><p>Multiple Graphs for the Foucart's Correspondence Analysis</p></a></li>
<li><a href='#kplot.mcoa'><p>Multiple Graphs for a Multiple Co-inertia Analysis</p></a></li>
<li><a href='#kplot.mfa'><p>Multiple Graphs for a Multiple Factorial Analysis</p></a></li>
<li><a href='#kplot.pta'><p>Multiple Graphs for a Partial Triadic Analysis</p></a></li>
<li><a href='#kplot.sepan'><p>Multiple Graphs for Separated Analyses in a K-tables</p></a></li>
<li><a href='#kplot.statis'><p>Multiple Graphs of a STATIS Analysis</p></a></li>
<li><a href='#krandtest'><p>Class of the Permutation Tests (in C).</p></a></li>
<li><a href='#ktab'><p>the class of objects 'ktab' (K-tables)</p></a></li>
<li><a href='#ktab.data.frame'><p>Creation of K-tables from a data frame</p></a></li>
<li><a href='#ktab.list.df'><p>Creating a K-tables from a list of data frames.</p></a></li>
<li><a href='#ktab.list.dudi'><p>Creation of a K-tables from a list of duality diagrams</p></a></li>
<li><a href='#ktab.match2ktabs'><p>STATIS and Co-Inertia : Analysis of a series of paired ecological tables</p></a></li>
<li><a href='#ktab.within'><p>Process to go from a Within Analysis to a K-tables</p></a></li>
<li><a href='#lascaux'><p>Genetic/Environment and types of variables</p></a></li>
<li><a href='#lingoes'><p>Transformation of a Distance Matrix for becoming Euclidean</p></a></li>
<li><a href='#lizards'><p>Phylogeny and quantitative traits of lizards</p></a></li>
<li><a href='#loocv.between'>
<p>Leave-one-out cross-validation for a <code>bca</code></p></a></li>
<li><a href='#loocv.discrimin'>
<p>Leave-one-out cross-validation for a <code>discrimin</code> analysis</p></a></li>
<li><a href='#loocv.dudi'>
<p>Leave-one-out cross-validation for a <code>dudi</code></p></a></li>
<li><a href='#macaca'><p>Landmarks</p></a></li>
<li><a href='#macon'><p>Wine Tasting</p></a></li>
<li><a href='#macroloire'><p>Assemblages of Macroinvertebrates in the Loire River (France)</p></a></li>
<li><a href='#mafragh'><p>Phyto-Ecological Survey</p></a></li>
<li><a href='#mantel.randtest'><p>Mantel test (correlation between two distance matrices (in C).)</p></a></li>
<li><a href='#mantel.rtest'><p>Mantel test (correlation between two distance matrices (in R).)</p></a></li>
<li><a href='#maples'><p>Phylogeny and quantitative traits of flowers</p></a></li>
<li><a href='#mariages'><p>Correspondence Analysis Table</p></a></li>
<li><a href='#mbpcaiv'><p>Multiblock principal component analysis with instrumental variables</p></a></li>
<li><a href='#mbpls'><p>Multiblock partial least squares</p></a></li>
<li><a href='#mcoa'><p>Multiple CO-inertia Analysis</p></a></li>
<li><a href='#mdpcoa'><p>Multiple Double Principal Coordinate Analysis</p></a></li>
<li><a href='#meau'><p>Ecological Data : sites-variables, sites-species, where and when</p></a></li>
<li><a href='#meaudret'><p>Ecological Data : sites-variables, sites-species, where and when</p></a></li>
<li><a href='#mfa'><p>Multiple Factorial Analysis</p></a></li>
<li><a href='#microsatt'><p>Genetic Relationships between cattle breeds with microsatellites</p></a></li>
<li><a href='#mjrochet'><p>Phylogeny and quantitative traits of teleos fishes</p></a></li>
<li><a href='#mld'><p>Multi Level Decomposition of unidimensional data</p></a></li>
<li><a href='#mollusc'><p>Faunistic Communities and Sampling Experiment</p></a></li>
<li><a href='#monde84'><p>Global State of the World in 1984</p></a></li>
<li><a href='#morphosport'><p>Athletes' Morphology</p></a></li>
<li><a href='#mstree'><p>Minimal Spanning Tree</p></a></li>
<li><a href='#multiblock'><p>Display and summarize multiblock objects</p></a></li>
<li><a href='#multispati'><p>Multivariate spatial analysis</p></a></li>
<li><a href='#multispati.randtest'><p>Multivariate spatial autocorrelation test (in C)</p></a></li>
<li><a href='#multispati.rtest'><p>Multivariate spatial autocorrelation test</p></a></li>
<li><a href='#neig'><p>Neighbourhood Graphs</p></a></li>
<li><a href='#newick.eg'><p>Phylogenetic trees in Newick format</p></a></li>
<li><a href='#newick2phylog'><p>Create phylogeny</p></a></li>
<li><a href='#niche'><p>Method to Analyse a pair of tables : Environmental and Faunistic Data</p></a></li>
<li><a href='#nipals'><p>Non-linear Iterative Partial Least Squares (NIPALS) algorithm</p></a></li>
<li><a href='#njplot'><p>Phylogeny and trait of bacteria</p></a></li>
<li><a href='#olympic'><p>Olympic Decathlon</p></a></li>
<li><a href='#oribatid'><p>Oribatid mite</p></a></li>
<li><a href='#originality'><p>Originality of a species</p></a></li>
<li><a href='#orthobasis'><p>Orthonormal basis for orthonormal transform</p></a></li>
<li><a href='#ours'><p>A table of Qualitative Variables</p></a></li>
<li><a href='#palm'><p>Phylogenetic and quantitative traits of amazonian palm trees</p></a></li>
<li><a href='#pap'><p>Taxonomy and quantitative traits of carnivora</p></a></li>
<li><a href='#pcaiv'><p>Principal component analysis with respect to instrumental variables</p></a></li>
<li><a href='#pcaivortho'><p>Principal Component Analysis with respect to orthogonal instrumental variables</p></a></li>
<li><a href='#pcoscaled'><p>Simplified Analysis in Principal Coordinates</p></a></li>
<li><a href='#pcw'><p>Distribution of of tropical trees along the Panama canal</p></a></li>
<li><a href='#perthi02'><p>Contingency Table with a partition in Molecular Biology</p></a></li>
<li><a href='#phylog'><p>Phylogeny</p></a></li>
<li><a href='#PI2newick'><p>Import data files from Phylogenetic Independance Package</p></a></li>
<li><a href='#piosphere'>
<p>Plant traits response to grazing</p></a></li>
<li><a href='#plot.phylog'><p>Plot phylogenies</p></a></li>
<li><a href='#presid2002'><p>Results of the French presidential elections of 2002</p></a></li>
<li><a href='#procella'><p>Phylogeny and quantitative traits of birds</p></a></li>
<li><a href='#procuste'><p>Simple Procruste Rotation between two sets of points</p></a></li>
<li><a href='#procuste.randtest'>
<p>Monte-Carlo Test on the sum of the singular values of a procustean rotation (in C).</p></a></li>
<li><a href='#procuste.rtest'>
<p>Monte-Carlo Test on the sum of the singular values of a procustean rotation (in R).</p></a></li>
<li><a href='#pta'><p>Partial Triadic Analysis of a K-tables</p></a></li>
<li><a href='#quasieuclid'><p>Transformation of a distance matrice to a Euclidean one</p></a></li>
<li><a href='#randboot'><p>Bootstrap simulations</p></a></li>
<li><a href='#randboot.multiblock'><p>Bootstraped simulations for multiblock methods</p></a></li>
<li><a href='#randtest'><p>Class of the Permutation Tests (in C).</p></a></li>
<li><a href='#randtest.amova'>
<p>Permutation tests on an analysis of molecular variance (in C).</p></a></li>
<li><a href='#randtest.between'><p>Monte-Carlo Test on the between-groups inertia percentage (in C).</p></a></li>
<li><a href='#randtest.coinertia'><p>Monte-Carlo test on a Co-inertia analysis (in C).</p></a></li>
<li><a href='#randtest.discrimin'>
<p>Monte-Carlo Test on a Discriminant Analysis (in C).</p></a></li>
<li><a href='#randtest.dpcoa'>
<p>Permutation test for double principal coordinate analysis (DPCoA)</p></a></li>
<li><a href='#randtest.pcaiv'><p>Monte-Carlo Test on the percentage of explained (i.e.</p>
constrained) inertia</a></li>
<li><a href='#randxval'><p>Two-fold cross-validation</p></a></li>
<li><a href='#rankrock'><p>Ordination Table</p></a></li>
<li><a href='#reconst'><p>Reconstitution of Data from a Duality Diagram</p></a></li>
<li><a href='#rhizobium'><p>Genetic structure of two nitrogen fixing bacteria influenced</p>
by geographical isolation and host specialization</a></li>
<li><a href='#rhone'><p>Physico-Chemistry Data</p></a></li>
<li><a href='#rlq'><p>RLQ analysis</p></a></li>
<li><a href='#rpjdl'><p>Avifauna and Vegetation</p></a></li>
<li><a href='#rtest'><p>Class of the Permutation Tests (in R).</p></a></li>
<li><a href='#rtest.between'><p>Monte-Carlo Test on the between-groups inertia percentage (in R).</p></a></li>
<li><a href='#rtest.discrimin'>
<p>Monte-Carlo Test on a Discriminant Analysis (in R).</p></a></li>
<li><a href='#RV.randtest'><p>Monte-Carlo Test on the sum of eigenvalues of a co-inertia analysis (in C++ with Rcpp).</p></a></li>
<li><a href='#RV.rtest'><p>Monte-Carlo Test on the sum of eigenvalues of a co-inertia analysis (in R).</p></a></li>
<li><a href='#RVdist.randtest'><p>Tests of randomization on the correlation between two distance matrices (in R).</p></a></li>
<li><a href='#RVintra.randtest'><p>Monte-Carlo Test on the sum of eigenvalues of a within-class co-inertia analysis (in C++ with Rcpp).</p></a></li>
<li><a href='#s.arrow'><p>Plot of the factorial maps for the projection of a vector basis</p></a></li>
<li><a href='#s.chull'><p>Plot of the factorial maps with polygons of contour by level of a factor</p></a></li>
<li><a href='#s.class'><p>Plot of factorial maps with representation of point classes</p></a></li>
<li><a href='#s.corcircle'><p>Plot of the factorial maps of a correlation circle</p></a></li>
<li><a href='#s.distri'><p>Plot of a frequency distribution</p></a></li>
<li><a href='#s.hist'><p>Display of a scatterplot and its two marginal histograms</p></a></li>
<li><a href='#s.image'><p> Graph of a variable using image and contour</p></a></li>
<li><a href='#s.kde2d'><p> Scatter Plot with Kernel Density Estimate</p></a></li>
<li><a href='#s.label'><p>Scatter Plot</p></a></li>
<li><a href='#s.logo'><p>Representation of an object in a graph by a picture</p></a></li>
<li><a href='#s.match'><p>Plot of Paired Coordinates</p></a></li>
<li><a href='#s.match.class'><p>Scatterplot of two sets of coordinates and a partionning into classes</p></a></li>
<li><a href='#s.multinom'><p>Graph of frequency profiles (useful for instance in genetic)</p></a></li>
<li><a href='#s.traject'><p>Trajectory Plot</p></a></li>
<li><a href='#s.value'><p>Representation of a value in a graph</p></a></li>
<li><a href='#santacatalina'><p>Indirect Ordination</p></a></li>
<li><a href='#sarcelles'><p>Array of Recapture of Rings</p></a></li>
<li><a href='#scalewt'><p>Compute or scale data using (weighted) means, variances and</p>
covariances (possibly for the levels of a factor)</a></li>
<li><a href='#scatter'><p>Graphical representation of the outputs of a multivariate analysis</p></a></li>
<li><a href='#scatter.acm'><p>Plot of the factorial maps in a Multiple Correspondence Analysis</p></a></li>
<li><a href='#scatter.coa'><p>Plot of the factorial maps for a correspondence analysis</p></a></li>
<li><a href='#scatter.dudi'><p>Plot of the Factorial Maps</p></a></li>
<li><a href='#scatter.fca'><p>Plot of the factorial maps for a fuzzy correspondence analysis</p></a></li>
<li><a href='#scatterutil'><p>Graphical utility functions</p></a></li>
<li><a href='#sco.boxplot'><p>Representation of the link between a variable and a set of qualitative variables</p></a></li>
<li><a href='#sco.class'><p>1D plot of a numeric score and a factor with labels</p></a></li>
<li><a href='#sco.distri'><p>Representation by mean- standard deviation of a set of weight distributions on a numeric score</p></a></li>
<li><a href='#sco.gauss'><p>Relationships between one score and qualitative variables</p></a></li>
<li><a href='#sco.label'><p>1D plot of a numeric score with labels</p></a></li>
<li><a href='#sco.match'><p>1D plot of a pair of numeric scores with labels</p></a></li>
<li><a href='#sco.quant'><p>Graph to Analyse the Relation between a Score and Quantitative Variables</p></a></li>
<li><a href='#score'><p>Graphs for One Dimension</p></a></li>
<li><a href='#score.acm'><p>Graphs to study one factor in a Multiple Correspondence Analysis</p></a></li>
<li><a href='#score.coa'><p>Reciprocal scaling after a correspondence analysis</p></a></li>
<li><a href='#score.mix'><p>Graphs to Analyse a factor in a Mixed Analysis</p></a></li>
<li><a href='#score.pca'><p>Graphs to Analyse a factor in PCA</p></a></li>
<li><a href='#seconde'><p>Students and  Subjects</p></a></li>
<li><a href='#sepan'><p>Separated Analyses in a K-tables</p></a></li>
<li><a href='#skulls'><p>Morphometric Evolution</p></a></li>
<li><a href='#statico'><p>STATIS and Co-Inertia : Analysis of a series of paired ecological tables</p></a></li>
<li><a href='#statico.krandtest'><p>Monte-Carlo test on a Statico analysis (in C).</p></a></li>
<li><a href='#statis'><p>STATIS, a method for analysing K-tables</p></a></li>
<li><a href='#steppe'><p>Transect in the Vegetation</p></a></li>
<li><a href='#supcol'><p>Projections of Supplementary Columns</p></a></li>
<li><a href='#supdist'>
<p>Projection of additional items in a PCO analysis</p></a></li>
<li><a href='#suprow'><p>Projections of Supplementary Rows</p></a></li>
<li><a href='#suprow.pta'>
<p>Projections of Supplementary Rows for a Partial Triadic Analysis of K-tables</p></a></li>
<li><a href='#symbols.phylog'><p>Representation of a quantitative variable in front of a phylogenetic tree</p></a></li>
<li><a href='#syndicats'><p>Two Questions asked on a Sample of 1000 Respondents</p></a></li>
<li><a href='#t3012'><p>Average temperatures of 30 French cities</p></a></li>
<li><a href='#table.cont'><p>Plot of Contingency Tables</p></a></li>
<li><a href='#table.dist'><p>Graph Display for Distance Matrices</p></a></li>
<li><a href='#table.paint'><p>Plot of the arrays by grey levels</p></a></li>
<li><a href='#table.phylog'><p>Plot arrays in front of a phylogenetic tree</p></a></li>
<li><a href='#table.value'><p>Plot of the Arrays</p></a></li>
<li><a href='#tarentaise'><p>Mountain Avifauna</p></a></li>
<li><a href='#taxo.eg'><p>Examples of taxonomy</p></a></li>
<li><a href='#testdim'><p> Function to perform a test of dimensionality</p></a></li>
<li><a href='#testdim.multiblock'><p>Selection of the number of dimension by two-fold cross-validation for multiblock methods</p></a></li>
<li><a href='#tintoodiel'><p>Tinto and Odiel estuary geochemistry</p></a></li>
<li><a href='#tithonia'><p>Phylogeny and quantitative traits of flowers</p></a></li>
<li><a href='#tortues'><p>Morphological Study of the Painted Turtle</p></a></li>
<li><a href='#toxicity'><p>Homogeneous Table</p></a></li>
<li><a href='#triangle.class'><p> Triangular Representation and Groups of points</p></a></li>
<li><a href='#triangle.plot'><p>Triangular Plotting</p></a></li>
<li><a href='#trichometeo'><p>Pair of Ecological Data</p></a></li>
<li><a href='#ungulates'><p>Phylogeny and quantitative traits of ungulates.</p></a></li>
<li><a href='#uniquewt.df'><p>Elimination of Duplicated Rows in a Array</p></a></li>
<li><a href='#variance.phylog'><p>The phylogenetic ANOVA</p></a></li>
<li><a href='#varipart'><p>Partition of the variation of a response multivariate table by 2 explanatory tables</p></a></li>
<li><a href='#vegtf'><p>Vegetation in Trois-Fontaines</p></a></li>
<li><a href='#veuvage'><p>Example for Centring in PCA</p></a></li>
<li><a href='#wca'><p>Within-Class Analysis</p></a></li>
<li><a href='#wca.coinertia'><p>Within-class coinertia analysis</p></a></li>
<li><a href='#wca.rlq'>
<p>Within-Class RLQ analysis</p></a></li>
<li><a href='#westafrica'><p>Freshwater fish zoogeography in west Africa</p></a></li>
<li><a href='#within'><p>Within-Class Analysis</p></a></li>
<li><a href='#withinpca'><p>Normed within principal component analysis</p></a></li>
<li><a href='#witwit.coa'><p>Internal Correspondence Analysis</p></a></li>
<li><a href='#woangers'><p>Plant assemblages in woodlands of the conurbation of Angers (France)</p></a></li>
<li><a href='#worksurv'><p>French Worker Survey (1970)</p></a></li>
<li><a href='#yanomama'><p>Distance Matrices</p></a></li>
<li><a href='#zealand'><p>Road distances in New-Zealand</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.7-22</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Ecological Data: Exploratory and Euclidean Methods
in Environmental Sciences</td>
</tr>
<tr>
<td>Author:</td>
<td>Stéphane Dray &lt;stephane.dray@univ-lyon1.fr&gt;, Anne-Béatrice Dufour &lt;anne-beatrice.dufour@univ-lyon1.fr&gt;, and Jean Thioulouse &lt;jean.thioulouse@univ-lyon1.fr&gt;, with contributions from Thibaut Jombart, Sandrine Pavoine, Jean R. Lobry, Sébastien Ollier, Daniel Borcard, Pierre Legendre, Stéphanie Bougeard and Aurélie Siberchicot. Based on earlier work by Daniel Chessel.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aurélie Siberchicot &lt;aurelie.siberchicot@univ-lyon1.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, methods, stats, utils, MASS, pixmap, sp,
Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ade4TkGUI, adegraphics, adephylo, ape, CircStats, deldir,
lattice, spdep, splancs, waveslim, progress, foreach, parallel,
doParallel, iterators</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for multivariate data analysis. Several methods are provided for the analysis (i.e., ordination) of one-table (e.g., principal component analysis, correspondence analysis), two-table (e.g., coinertia analysis, redundancy analysis), three-table (e.g., RLQ analysis) and K-table (e.g., STATIS, multiple coinertia analysis). The philosophy of the package is described in Dray and Dufour (2007) &lt;<a href="https://doi.org/10.18637%2Fjss.v022.i04">doi:10.18637/jss.v022.i04</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://pbil.univ-lyon1.fr/ADE-4/">http://pbil.univ-lyon1.fr/ADE-4/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sdray/ade4/issues">https://github.com/sdray/ade4/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-30 07:58:06 UTC; siberchicot</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-06 14:32:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='ade4-package'>The ade4 package</h2><span id='topic+ade4-package'></span><span id='topic+ade4'></span>

<h3>Description</h3>

<p>This package is developed in the Biometry and Evolutionary Biology Lab (UMR CNRS 5558) - University Lyon 1. 
It contains Data Analysis functions to analyse Ecological and Environmental data in the framework of Euclidean Exploratory methods, hence the name ade4.<br />
</p>
<p>ade4 is characterized by (1) the implementation of graphical and statistical functions, (2) the availability of numerical data, (3) the redaction of technical and thematic documentation and (4) the inclusion of bibliographic references. <br />
</p>
<p>To cite ade4, please use <code>citation("ade4")</code>.
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray, Anne-Béatrice Dufour, and Jean Thioulouse. Contributions from Daniel Borcard, Stéphanie Bougeard, Thibaut Jombart, Pierre Legendre, Jean R. Lobry, Sébastien Ollier, Sandrine Pavoine and Aurélie Siberchicot. Based on earlier work by Daniel Chessel.</p>


<h3>References</h3>

<p>Dray S and Dufour A (2007). “The ade4 Package: Implementing the Duality Diagram for Ecologists.”
_Journal of Statistical Software_, *22*(4), pp. 1-20. doi: 10.18637/jss.v022.i04 (URL:
http://doi.org/10.18637/jss.v022.i04).
</p>
<p>See ade4 website: <a href="http://pbil.univ-lyon1.fr/ADE-4/">http://pbil.univ-lyon1.fr/ADE-4/</a>
</p>


<h3>See Also</h3>

<p><code>ade4TkGUI</code>, <code>adegenet</code>, <code>adehabitat</code>, <code>adegraphics</code></p>

<hr>
<h2 id='abouheif.eg'>Phylogenies and quantitative traits from Abouheif</h2><span id='topic+abouheif.eg'></span>

<h3>Description</h3>

<p>This data set gathers three phylogenies with three sets of traits as reported by Abouheif (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(abouheif.eg)</code></pre>


<h3>Format</h3>

<p><code>abouheif.eg</code> is a list containing the 6 following objects :  
</p>

<dl>
<dt>tre1</dt><dd><p>is a character string giving the first phylogenetic tree made up of 8 leaves.</p>
</dd>  
<dt>vec1</dt><dd><p>is a numeric vector with 8 values.</p>
</dd> 
<dt>tre2</dt><dd><p>is a character string giving the second phylogenetic tree made up of 7 leaves.</p>
</dd>
<dt>vec2</dt><dd><p>is a numeric vector with 7 values.</p>
</dd> 
<dt>tre3</dt><dd><p>is a character string giving the third phylogenetic tree made up of 15 leaves.</p>
</dd>
<dt>vec3</dt><dd><p>is a numeric vector with 15 values.</p>
</dd> 
</dl>


<h3>Source</h3>

<p>Data taken from the phylogenetic independence program developped by Ehab Abouheif
</p>


<h3>References</h3>

<p>Abouheif, E. (1999) A method for testing the assumption of phylogenetic independence in comparative data. <em>Evolutionary Ecology Research</em>, <b>1</b>, 895&ndash;909.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abouheif.eg)
par(mfrow=c(2,2))
symbols.phylog(newick2phylog(abouheif.eg$tre1), abouheif.eg$vec1,
 sub = "Body Mass (kg)", csi = 2, csub = 2)
symbols.phylog(newick2phylog(abouheif.eg$tre2), abouheif.eg$vec2,
 sub = "Body Mass (kg)", csi = 2, csub = 2)
dotchart.phylog(newick2phylog(abouheif.eg$tre1), abouheif.eg$vec1,
 sub = "Body Mass (kg)", cdot = 2, cnod = 1, possub = "topleft",
  csub = 2, ceti = 1.5)
dotchart.phylog(newick2phylog(abouheif.eg$tre2), abouheif.eg$vec2,
 sub = "Body Mass (kg)", cdot = 2, cnod = 1, possub = "topleft",
  csub = 2, ceti = 1.5)
par(mfrow = c(1,1))

w.phy=newick2phylog(abouheif.eg$tre3)
dotchart.phylog(w.phy,abouheif.eg$vec3, clabel.n = 1)
</code></pre>

<hr>
<h2 id='acacia'>Spatial pattern analysis in plant communities</h2><span id='topic+acacia'></span>

<h3>Description</h3>

<p>Counts of individuals of <em>Acacia ehrenbergiana</em> from five parallel transects of 32 quadrats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(acacia)</code></pre>


<h3>Format</h3>

<p><code>acacia</code> is a data frame with 15 variables :<br />
se.T1, se.T2, se.T3, se.T4, se.T5 are five numeric vectors containing quadrats counts of 
seedlings from transects 1 to 5 respectively;<br />
sm.T1, sm.T2, sm.T3, sm.T4, sm.T5 are five numeric vectors containing quadrats counts of
small trees (crown &lt; 1 <code class="reqn">m^{2}</code> in canopy) of transects 1 to 5 respectively; <br />
la.T1, la.T2, la.T3, la.T4, la.T5 are five numeric vectors containing quadrats counts of 
trees with large crown (crown &gt; 1 <code class="reqn">m^{2}</code> in canopy) of transects 1 to 5 respectively.
</p>


<h3>Source</h3>

<p>Greig-Smith, P. and Chadwick, M.J. (1965) Data on pattern within plant communities. III. <em>Acacia-Capparis</em> 
semi-desert scrub in the Sudan. <em>Journal of Ecology</em>, <b>53</b>, 465&ndash;474.
</p>


<h3>References</h3>

<p>Hill, M.O. (1973) The intensity of spatial pattern in plant communities. <em>Journal of Ecology</em>, <b>61</b>, 225&ndash;235.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(acacia)
if(adegraphicsLoaded()) {
  gg &lt;- s1d.barchart(acacia, p1d.horizontal = FALSE, psub.position = "topleft", 
    plabels.cex = 0, ylim = c(0,20))
} else {
  par(mfcol = c(5, 3))
  par(mar = c(2, 2, 2, 2))
  for(k in 1:15) {
    barplot(acacia[, k], ylim = c(0, 20), col = grey(0.8))
    ade4:::scatterutil.sub(names(acacia)[k], 1.5, "topleft")
  }
  par(mfcol = c(1, 1))
}
</code></pre>

<hr>
<h2 id='add.scatter'>Add graphics to an existing plot</h2><span id='topic+add.scatter'></span><span id='topic+add.scatter.eig'></span>

<h3>Description</h3>

<p><code>add.scatter</code> is a function which defines a new plot area within an existing plot and displays an additional graphic inside this area. The additional graphic is determined by a function which is the first argument taken by <code>add.scatter</code>. It can be used in various ways, for instance to add a screeplot to an ordination scatterplot (<code>add.scatter.eig</code>).<br />
The function <code>add.scatter.eig</code> uses the following colors: black (represented axes), grey(axes retained in the analysis) and white (others).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.scatter(func,posi = c("bottomleft","bottomright","topleft","topright"),
ratio = 0.2, inset = 0.01, bg.col = 'white')
add.scatter.eig(w, nf = NULL, xax, yax, posi = "bottomleft", ratio =
.25, inset = 0.01, sub = "Eigenvalues", csub = 2 * ratio)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.scatter_+3A_func">func</code></td>
<td>
<p>an - evaluated - function producing a graphic</p>
</td></tr>
<tr><td><code id="add.scatter_+3A_posi">posi</code></td>
<td>
<p>a character vector (only its first element being
considered) giving the position of the added graph. Possible values
are &quot;bottomleft&quot; (=&quot;bottom&quot;),&quot;bottomright&quot;,&quot;topleft&quot;
(=&quot;top&quot;),&quot;topright&quot;, and &quot;none&quot; (no plot).</p>
</td></tr>
<tr><td><code id="add.scatter_+3A_ratio">ratio</code></td>
<td>
<p>the size of the added graph in proportion of the current
plot region</p>
</td></tr>
<tr><td><code id="add.scatter_+3A_inset">inset</code></td>
<td>
<p>the inset from which the graph is drawn, in proportion of the whole
plot region. Can be a vector of length 2, giving the inset in x and y. If atomic, same inset is
used in x and y</p>
</td></tr>
<tr><td><code id="add.scatter_+3A_bg.col">bg.col</code></td>
<td>
<p>the color of the background of the added graph</p>
</td></tr>
<tr><td><code id="add.scatter_+3A_w">w</code></td>
<td>
<p>numeric vector of eigenvalues</p>
</td></tr>
<tr><td><code id="add.scatter_+3A_nf">nf</code></td>
<td>
<p>the number of retained factors, NULL if not provided</p>
</td></tr>
<tr><td><code id="add.scatter_+3A_xax">xax</code></td>
<td>
<p>first represented axis</p>
</td></tr>
<tr><td><code id="add.scatter_+3A_yax">yax</code></td>
<td>
<p>second represented axis</p>
</td></tr>
<tr><td><code id="add.scatter_+3A_sub">sub</code></td>
<td>
<p>title of the screeplot</p>
</td></tr>
<tr><td><code id="add.scatter_+3A_csub">csub</code></td>
<td>
<p>size of the screeplot title</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add.scatter</code> uses <code>par("plt")</code> to redefine the new plot region.
As stated in <code>par</code> documentation, this produces to (sometimes
surprising) interactions with other parameters such as &quot;mar&quot;.
In particular, such interactions are likely to reset the plot region
by default which would cause the additional graphic to take the whole
plot region. To avoid such inconvenient, add <code>par([other
    options], plt=par("plt"))</code> when using <code>par</code> in your graphical
function (argument <code>func</code>).
</p>


<h3>Value</h3>

<p>The matched call (invisible).
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+scatter">scatter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(microsatt)
  w &lt;- dudi.coa(data.frame(t(microsatt$tab)), scann = FALSE, nf = 3)
    
  if(adegraphicsLoaded()) {
    a1 &lt;- rnorm(100)
    b1 &lt;- s1d.barchart(sort(a1), p1d.horizontal = FALSE, plot = FALSE)
    h1 &lt;- s1d.hist(a1, pgrid.draw = FALSE, porigin.draw = FALSE, pbackground.col = "grey", 
      plot = FALSE, ppoly.col = "white", ppoly.alpha = 1)
    g1 &lt;- insert(h1, b1, posi = "topleft", plot = FALSE)
  
    a2 &lt;- rnorm(100)
    b2 &lt;- s1d.barchart(sort(a2), p1d.horizontal = FALSE, plot = FALSE)
    h2 &lt;- s1d.hist(a2, pgrid.draw = FALSE, porigin.draw = FALSE, pbackground.col = "grey", 
      plot = FALSE, ppoly.col = "white", ppoly.alpha = 1)
    g2 &lt;- insert(h2, b2, posi = "topleft", inset = c(0.25, 0.01), plot = FALSE)
  
    a3 &lt;- rnorm(100)
    b3 &lt;- s1d.barchart(sort(a3), p1d.horizontal = FALSE, plot = FALSE)
    h3 &lt;- s1d.hist(a3, pgrid.draw = FALSE, porigin.draw = FALSE, pbackground.col = "grey", 
      plot = FALSE, ppoly.col = "white", ppoly.alpha = 1)
    g3 &lt;- insert(h3, b3, posi = "bottomleft", inset = 0.4, ratio = 0.2, plot = FALSE)
  
    a4 &lt;- rnorm(100)
    b4 &lt;- s1d.barchart(sort(a4), p1d.horizontal = FALSE, plot = FALSE)
    h4 &lt;- s1d.hist(a4, pgrid.draw = FALSE, porigin.draw = FALSE, pbackground.col = "grey", 
      plot = FALSE, ppoly.col = "white", ppoly.alpha = 1)
    g4 &lt;- insert(h3, b3, posi = "bottomright", ratio = 0.3, plot = FALSE)
    
    G1 &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2), plot = TRUE)
    
    g5 &lt;- s.label(w$co, plot = FALSE)
    g6 &lt;- plotEig(w$eig, w$nf, psub = list(text = "Eigenvalues"), 
      pbackground = list(box = TRUE), plot = FALSE)
    G2 &lt;- insert(g6, g5, posi = "bottomright", ratio = 0.25)

  } else {
    par(mfrow=c(2,2))
    f1 &lt;- function(a){
      opar=par("mar","xaxt","yaxt","plt")
      on.exit(par(opar))
      par(mar=rep(.1,4),xaxt="n",yaxt="n",plt=par("plt"))
    
      hist(a,xlab="",ylab="",main="",col="white",proba=TRUE)
      lines(seq(-4,4,le=50),dnorm(seq(-4,4,le=50)),col="red")
    }
    
    a &lt;- rnorm(100)
    barplot(sort(a))
    add.scatter(f1(a),posi="topleft",bg.col="grey")
    
    a &lt;- rnorm(100)
    barplot(sort(a))
    add.scatter(f1(a),posi="topleft",bg.col="grey",inset=c(.25,.01))
    
    a &lt;- rnorm(100)
    barplot(sort(a))
    add.scatter(f1(a),posi="topleft",bg.col="grey",inset=.25,ratio=.1)
    
    a &lt;- rnorm(100)
    barplot(sort(a))
    add.scatter(f1(a),posi="bottomright",bg.col="grey",ratio=.3)
    par(mfrow=c(1,1))
    
    s.label(w$co)
    add.scatter.eig(w$eig,w$nf,posi="bottomright",1,2)
  }
</code></pre>

<hr>
<h2 id='ade4-internal'>Internal ade4 functions</h2><span id='topic+testdiscrimin'></span><span id='topic+testertrace'></span><span id='topic+testertracenu'></span><span id='topic+testertracenubis'></span><span id='topic+testinter'></span><span id='topic+testprocuste'></span><span id='topic+testmantel'></span><span id='topic+testertracerlq'></span><span id='topic+testamova'></span><span id='topic+dudi.type'></span><span id='topic+fac2disj'></span><span id='topic+RVrandtestCpp'></span><span id='topic+RVintrarandtestCpp'></span><span id='topic+procusterandtestCpp'></span><span id='topic+testinterCpp'></span><span id='topic+inerbetweenCpp'></span><span id='topic+testmantelCpp'></span><span id='topic+betweenvarCpp'></span><span id='topic+testdiscriminCpp'></span><span id='topic+testertraceCpp'></span><span id='topic+testertracenuCpp'></span><span id='topic+testertracenubisCpp'></span>

<h3>Description</h3>

<p>Internal ade4 functions
</p>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='adegraphicsLoaded'>Utility function to test if the package adegraphics is loaded</h2><span id='topic+adegraphicsLoaded'></span>

<h3>Description</h3>

<p>This function check if the package adegraphics is loaded. Mainly used to run examples using either ade4 or adegraphics function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adegraphicsLoaded()
</code></pre>


<h3>Value</h3>

<p>A logical</p>


<h3>Author(s)</h3>

<p>Stéphane Dray (<a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>)</p>

<hr>
<h2 id='aminoacyl'>Codon usage</h2><span id='topic+aminoacyl'></span>

<h3>Description</h3>

<p><code>aminoacyl</code> is a list containing the codon counts of 36 genes encoding yeast aminoacyl-tRNA-synthetase(S.Cerevisiae).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(aminoacyl)</code></pre>


<h3>Format</h3>

<p><code>aminoacyl</code> is a list containing the 5 following objects:  
</p>
     
<dl>
<dt>genes</dt><dd><p>is a vector giving the gene names.</p>
</dd> 
<dt>localisation</dt><dd><p>is a vector giving the cellular localisation
of the proteins (M = mitochondrial, C = cytoplasmic,
I = indetermined, CI = cyto and mito).</p>
</dd>    
<dt>codon</dt><dd><p>is a vector containing the 64 triplets.</p>
</dd>
<dt>AA</dt><dd><p>is a factor giving the amino acid names for each codon.</p>
</dd>
<dt>usage.codon</dt><dd><p>is a dataframe containing the codon counts for each gene.</p>
</dd>
</dl>
 


<h3>Source</h3>

<p>Data prepared by D. Charif <a href="mailto:Delphine.Charif@versailles.inra.fr">Delphine.Charif@versailles.inra.fr</a> starting from:<br />
<a href="http://www.expasy.org/sprot/">http://www.expasy.org/sprot/</a>
</p>


<h3>References</h3>

<p>Chiapello H., Olivier E., Landes-Devauchelle C., Nitschké P. and Risler J.L (1999) 
Codon usage as a tool to predict the cellular localisation of eukariotic ribosomal 
proteins and aminoacyl-tRNA synthetases. <em>Nucleic Acids Res.</em>, <b>27</b>, 14, 2848&ndash;2851.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aminoacyl)
aminoacyl$genes
aminoacyl$usage.codon
dudi.coa(aminoacyl$usage.codon, scannf = FALSE)
</code></pre>

<hr>
<h2 id='amova'>Analysis of molecular variance</h2><span id='topic+amova'></span><span id='topic+print.amova'></span>

<h3>Description</h3>

<p>The analysis of molecular variance tests the differences among population and/or groups of populations
in a way similar to ANOVA. It includes evolutionary distances among alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amova(samples, distances, structures)
## S3 method for class 'amova'
print(x, full = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amova_+3A_samples">samples</code></td>
<td>
<p>a data frame with haplotypes (or genotypes) as rows, populations as columns
and abundance as entries</p>
</td></tr>
<tr><td><code id="amova_+3A_distances">distances</code></td>
<td>
<p>an object of class <code>dist</code> computed from Euclidean distance.
If <code>distances</code> is null, equidistances are used.</p>
</td></tr>
<tr><td><code id="amova_+3A_structures">structures</code></td>
<td>
<p>a data frame containing, in the jth row and the kth column,
the name of the group of level k to which the jth population belongs</p>
</td></tr>
<tr><td><code id="amova_+3A_x">x</code></td>
<td>
<p>an object of class <code>amova</code></p>
</td></tr>
<tr><td><code id="amova_+3A_full">full</code></td>
<td>
<p>a logical value indicating whether the original data ('distances', 'samples', 'structures')
should be printed</p>
</td></tr>
<tr><td><code id="amova_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>amova</code>
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>call</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>a data frame with the degrees of freedom, the sums of squares, and the mean squares.
Rows represent levels of variability.</p>
</td></tr>
<tr><td><code>componentsofcovariance</code></td>
<td>
<p>a data frame containing the components
of covariance and their contribution to the total covariance</p>
</td></tr>
<tr><td><code>statphi</code></td>
<td>
<p>a data frame containing the phi-statistics</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sandrine Pavoine <a href="mailto:pavoine@mnhn.fr">pavoine@mnhn.fr</a>
</p>


<h3>References</h3>

<p>Excoffier, L., Smouse, P.E. and Quattro, J.M. (1992) Analysis of molecular variance inferred
from metric distances among DNA haplotypes: application to human mitochondrial DNA restriction
data. <em>Genetics</em>, <b>131</b>, 479&ndash;491.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randtest.amova">randtest.amova</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humDNAm)
amovahum &lt;- amova(humDNAm$samples, sqrt(humDNAm$distances), humDNAm$structures)
amovahum
</code></pre>

<hr>
<h2 id='apis108'>Allelic frequencies in ten honeybees populations at eight microsatellites loci</h2><span id='topic+apis108'></span>

<h3>Description</h3>

<p>This data set gives the occurences for the allelic form on 8 loci in 10 populations of honeybees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(apis108)</code></pre>


<h3>Format</h3>

<p>A data frame containing 180 rows (allelic forms on 8 loci) and 10 columns (populations of honeybees : El.Hermel, Al.Hoceima, 
Nimba, Celinda, Pretoria, Chalkidiki, Forli, Valenciennes, Umea and Seville).
</p>


<h3>Source</h3>

<p><a href="http://www1.montpellier.inra.fr/URLB/apis/libanfreq.pdf">http://www1.montpellier.inra.fr/URLB/apis/libanfreq.pdf</a><br />
</p>
<p>Franck P., Garnery L., Solignac M. and Cornuet J.M. (2000) Molecular confirmation of a fourth lineage in honeybees from the Near-East. 
<em>Apidologie</em>, <b>31</b>, 167&ndash;180.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(apis108)
str(apis108)
names(apis108)
</code></pre>

<hr>
<h2 id='apqe'>Apportionment of Quadratic Entropy</h2><span id='topic+apqe'></span><span id='topic+print.apqe'></span>

<h3>Description</h3>

<p>The hierarchical apportionment of quadratic entropy defined by Rao (1982).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apqe(samples, dis = NULL, structures)
## S3 method for class 'apqe'
print(x, full = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apqe_+3A_samples">samples</code></td>
<td>
<p>a data frame with haplotypes (or genotypes) as rows, populations as columns
and abundance or presence-absence as entries</p>
</td></tr>
<tr><td><code id="apqe_+3A_dis">dis</code></td>
<td>
<p>an object of class <code>dist</code> computed from Euclidean distance.
If <code>dis</code> is null, equidistances are used.</p>
</td></tr>
<tr><td><code id="apqe_+3A_structures">structures</code></td>
<td>
<p>a data frame that contains, in the jth row and the kth column,
the name of the group of level k to which the jth population belongs</p>
</td></tr>
<tr><td><code id="apqe_+3A_x">x</code></td>
<td>
<p>an object of class <code>apqe</code></p>
</td></tr>
<tr><td><code id="apqe_+3A_full">full</code></td>
<td>
<p>a logical value that indicates whether the original data ('distances', 'samples', 'structures')
should be printed</p>
</td></tr>
<tr><td><code id="apqe_+3A_...">...</code></td>
<td>
<p><code>...</code> further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>apqe</code>
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>call</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>a data frame that contains the components of diversity.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sandrine Pavoine <a href="mailto:pavoine@mnhn.fr">pavoine@mnhn.fr</a>
</p>


<h3>References</h3>

<p>Rao, C.R. (1982) Diversity: its measurement, decomposition, apportionment and analysis. 
<em>Sankhya: The Indian Journal of Statistics</em>, <b>A44</b>, 1&ndash;22.
</p>
<p>Pavoine S. and Dolédec S. (2005) The apportionment of quadratic entropy: 
a useful alternative for partitioning diversity in ecological data. 
<em>Environmental and Ecological Statistics</em>, <b>12</b>, 125&ndash;138.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecomor)
ecomor.phylog &lt;- taxo2phylog(ecomor$taxo)
apqe(ecomor$habitat, ecomor.phylog$Wdist)
</code></pre>

<hr>
<h2 id='aravo'>Distribution of Alpine plants in Aravo (Valloire, France)</h2><span id='topic+aravo'></span>

<h3>Description</h3>

<p>This dataset describe the distribution of 82 species of
Alpine plants in 75 sites. Species traits and environmental variables
are also measured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(aravo)</code></pre>


<h3>Format</h3>

<p><code>aravo</code> is a list containing the following objects :
</p>

<dl>
<dt>spe</dt><dd><p>is a data.frame with the abundance values of 82 species (columns)
in 75 sites (rows).</p>
</dd>
<dt>env</dt><dd><p>is a data.frame with the measurements of 6 environmental
variables for the sites.</p>
</dd> 
<dt>traits</dt><dd><p>is data.frame with the measurements of 8 traits for the species.</p>
</dd>
<dt>spe.names</dt><dd><p>is a vector with full species names.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The environmental variables are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    Aspect </td><td style="text-align: left;">	Relative south aspect (opposite of the sine of aspect
    with flat coded 0)</td>
</tr>
<tr>
 <td style="text-align: left;">
    Slope </td><td style="text-align: left;">	Slope inclination (degrees)</td>
</tr>
<tr>
 <td style="text-align: left;">
    Form </td><td style="text-align: left;">	Microtopographic landform index: 1 (convexity); 2
    (convex slope); 3 (right slope); 4 (concave slope); 5 (concavity) </td>
</tr>
<tr>
 <td style="text-align: left;">
    Snow </td><td style="text-align: left;">	Mean snowmelt date (Julian day) averaged over 1997-1999 </td>
</tr>
<tr>
 <td style="text-align: left;">
    PhysD </td><td style="text-align: left;">	Physical disturbance, i.e., percentage of unvegetated
    soil due to physical processes </td>
</tr>
<tr>
 <td style="text-align: left;">
    ZoogD </td><td style="text-align: left;">	Zoogenic disturbance, i.e., quantity of unvegetated soil
    due to marmot activity: no; some; high
  </td>
</tr>

</table>

<p>The species traits for the plants are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    Height 	</td><td style="text-align: left;"> Vegetative height (cm) </td>
</tr>
<tr>
 <td style="text-align: left;">
    Spread 	</td><td style="text-align: left;"> Maximum lateral spread of clonal plants (cm)</td>
</tr>
<tr>
 <td style="text-align: left;">
    Angle 	</td><td style="text-align: left;"> Leaf elevation angle estimated at the middle of the lamina</td>
</tr>
<tr>
 <td style="text-align: left;">
    Area 	</td><td style="text-align: left;"> Area of a single leaf</td>
</tr>
<tr>
 <td style="text-align: left;">
    Thick 	</td><td style="text-align: left;"> Maximum thickness of a leaf cross section (avoiding the midrib)</td>
</tr>
<tr>
 <td style="text-align: left;">
    SLA 	</td><td style="text-align: left;"> Specific leaf area</td>
</tr>
<tr>
 <td style="text-align: left;">
    Nmass 	</td><td style="text-align: left;"> Mass-based leaf nitrogen content</td>
</tr>
<tr>
 <td style="text-align: left;">
    Seed 	</td><td style="text-align: left;"> Seed mass
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Choler, P. (2005)
Consistent shifts in Alpine plant traits along a mesotopographical gradient.
<em>Arctic, Antarctic, and Alpine Research</em>, <b>37</b>,444&ndash;453.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aravo)
coa1 &lt;- dudi.coa(aravo$spe, scannf = FALSE, nf = 2)
dudienv &lt;- dudi.hillsmith(aravo$env, scannf = FALSE, nf = 2, row.w = coa1$lw)
duditrait &lt;- dudi.pca(aravo$traits, scannf = FALSE, nf = 2, row.w = coa1$cw)
rlq1 &lt;- rlq(dudienv, coa1, duditrait, scannf = FALSE, nf = 2)
plot(rlq1)
</code></pre>

<hr>
<h2 id='ardeche'>Fauna Table with double (row and column) partitioning</h2><span id='topic+ardeche'></span>

<h3>Description</h3>

<p>This data set gives information about species of benthic macroinvertebrates in different sites and dates. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ardeche)</code></pre>


<h3>Format</h3>

<p><code>ardeche</code> is a list with 6 components.
</p>

<dl>
<dt>tab</dt><dd><p>is a data frame containing fauna table with 43 species (rows) and 35 samples (columns).</p>
</dd>
<dt>col.blocks</dt><dd><p>is a vector containing the repartition of samples for the 6 dates : july 1982, august 1982, 
november 1982, february 1983, april 1983 and july 1983.</p>
</dd>
<dt>row.blocks</dt><dd><p>is a vector containing the repartition of species in the 4 groups defining the species order.</p>
</dd>
<dt>dat.fac</dt><dd><p>is a date factor for samples (6 dates).</p>
</dd>
<dt>sta.fac</dt><dd><p>is a site factor for samples (6 sites).</p>
</dd>
<dt>esp.fac</dt><dd><p>is a species order factor (Ephemeroptera, Plecoptera, Coleoptera, Trichoptera).</p>
</dd>
</dl>



<h3>Details</h3>

<p>The columns of the data frame <code>ardeche$tab</code> define the samples by a number between 1 and 6 (the date) 
and a letter between A and F (the site).
</p>


<h3>Source</h3>

<p>Cazes, P., Chessel, D., and Dolédec, S. (1988) L'analyse des correspondances internes d'un tableau partitionné :
son usage en hydrobiologie. <em>Revue de Statistique Appliquée</em>, <b>36</b>, 39&ndash;54.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ardeche)
dudi1 &lt;- dudi.coa(ardeche$tab, scan = FALSE)
s.class(dudi1$co, ardeche$dat.fac)
if(adegraphicsLoaded()) {
  s.label(dudi1$co, plab.cex = 0.5, add = TRUE)
} else {
  s.label(dudi1$co, clab = 0.5, add.p = TRUE)
}
</code></pre>

<hr>
<h2 id='area.plot'>Graphical Display of Areas</h2><span id='topic+area.plot'></span><span id='topic+poly2area'></span><span id='topic+area2poly'></span><span id='topic+area2link'></span><span id='topic+area.util.contour'></span><span id='topic+area.util.xy'></span><span id='topic+area.util.class'></span>

<h3>Description</h3>

<p>'area' is a data frame with three variables.<br />
The first variable is a factor defining the polygons.<br />
The second and third variables are the xy coordinates of the
polygon vertices in the order where they are found.
</p>
<p>area.plot : grey levels areas mapping
</p>
<p>poly2area takes an object of class 'polylist' (maptools package) and returns a data frame of type area.<br />
area2poly takes an object of type 'area' and returns a list of class 'polylist'<br />
area2link takes an object of type 'area' and returns a proximity matrix which terms are given by 
the length of the frontier between two polygons. <br />
area.util.contour,area.util.xy and area.util.class are three utility functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area.plot(x, center = NULL, values = NULL, graph = NULL, lwdgraph = 2,
nclasslegend = 8, clegend = 0.75, sub = "", csub = 1, 
possub = "topleft", cpoint = 0, label = NULL, clabel = 0, ...)

area2poly(area)
poly2area(polys)
area2link(area)
area.util.contour(area)
area.util.xy(area)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area.plot_+3A_x">x</code></td>
<td>
<p>a data frame with three variables</p>
</td></tr>
<tr><td><code id="area.plot_+3A_center">center</code></td>
<td>
<p>a matrix with the same row number as x and two columns, the coordinates
of polygone centers. If NULL, it is computed with <code>area.util.xy</code></p>
</td></tr>
<tr><td><code id="area.plot_+3A_values">values</code></td>
<td>
<p>if not NULL, a vector which values will be mapped to grey levels.
The values must be in the same order as the values in <code>unique(x.area[,1])</code></p>
</td></tr>
<tr><td><code id="area.plot_+3A_graph">graph</code></td>
<td>
<p>if not NULL, <code>graph</code> is a neighbouring graph (object of class &quot;neig&quot;) between polygons</p>
</td></tr>
<tr><td><code id="area.plot_+3A_lwdgraph">lwdgraph</code></td>
<td>
<p>a line width to draw the neighbouring graph</p>
</td></tr>
<tr><td><code id="area.plot_+3A_nclasslegend">nclasslegend</code></td>
<td>
<p>if <code>value</code> not NULL, a number of classes for the legend</p>
</td></tr>
<tr><td><code id="area.plot_+3A_clegend">clegend</code></td>
<td>
<p>if not NULL, a character size for the legend, used with <code>par("cex")*clegend</code></p>
</td></tr>
<tr><td><code id="area.plot_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as sub-title</p>
</td></tr>
<tr><td><code id="area.plot_+3A_csub">csub</code></td>
<td>
<p>a character size for the sub-titles, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="area.plot_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-titles position 
(&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="area.plot_+3A_cpoint">cpoint</code></td>
<td>
<p>if positive, a character size for drawing the polygons vertices (check up),
used with <code>par("cex")*cpoint</code></p>
</td></tr>
<tr><td><code id="area.plot_+3A_label">label</code></td>
<td>
<p>if not NULL, by default the levels of the factor that define the polygons
are used as labels. To change this value, use label. These labels must be in the same order than
<code>unique(x.area[,1])</code></p>
</td></tr>
<tr><td><code id="area.plot_+3A_clabel">clabel</code></td>
<td>
<p>if not NULL, a character size for the polygon labels, <br />
used with <code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="area.plot_+3A_polys">polys</code></td>
<td>
<p>a list belonging to the 'polylist' class in the spdep package</p>
</td></tr>
<tr><td><code id="area.plot_+3A_area">area</code></td>
<td>
<p>a data frame of class 'area'</p>
</td></tr>
<tr><td><code id="area.plot_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>poly2area returns a data frame 'factor,x,y'. <br />
area2poly returns a list of class <code>polylist</code>. <br />
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(elec88)
par(mfrow = c(2, 2))
area.plot(elec88$area, cpoint = 1)
area.plot(elec88$area, lab = elec88$lab$dep, clab = 0.75)
area.plot(elec88$area, clab = 0.75)
# elec88$neig &lt;- neig(area = elec88$area)
area.plot(elec88$area, graph = elec88$neig, sub = "Neighbourhood graph", possub = "topright")
par(mfrow = c(1, 1))

## Not run: 
    par(mfrow = c(3, 3))
    for(i in 1:9) {
      x &lt;- elec88$tab[,i]
      area.plot(elec88$area, val = x, sub = names(elec88$tab)[i], csub = 3, cleg = 1.5)
    }
    par(mfrow = c(1, 1))
    
    if(adegraphicsLoaded()) {
      if(requireNamespace("sp", quietly = TRUE)) {
        s.value(elec88$xy, elec88$tab, Sp = elec88$Spatial,
          method = "color", psub.text = names(elec88$tab), psub.cex = 3, 
          pSp.col = "white", pgrid.draw = FALSE, porigin.include = FALSE)
      }
    } else {
      par(mfrow = c(3, 3))
      for(i in 1:9) {
        x &lt;- elec88$tab[, i]
        s.value(elec88$xy, elec88$tab[, i], contour = elec88$contour,
         meth = "greylevel", sub = names(elec88$tab)[i], csub = 3, 
         cleg = 1.5, incl = FALSE)
        }
      par(mfrow = c(1, 1))
    }
    
    if(!adegraphicsLoaded()) {
      data(irishdata)
      par(mfrow = c(2, 2))
      w &lt;- ade4:::area.util.contour(irishdata$area)
      xy &lt;- ade4:::area.util.xy(irishdata$area)
      area.plot(irishdata$area, cpoint = 1)
      apply(w, 1, function(x) segments(x[1], x[2], x[3], x[4], lwd = 3))
      area.plot(irishdata$area, clabel = 1)
      s.label(xy, area = irishdata$area, incl = FALSE, clab = 0, 
        cpoi = 3, addax = FALSE, contour = w)
      s.label(xy, area = irishdata$area, incl = FALSE, 
        addax = FALSE, contour = w)
      par(mfrow = c(1, 1))

    }

## End(Not run)

data(irishdata)
w &lt;- irishdata$area[c(42:53, 18:25), ]
w
w$poly &lt;- as.factor(as.character(w$poly))
area.plot(w, clab = 2)
 
points(68, 59, pch = 20, col = "red", cex = 3)
points(68, 35, pch = 20, col = "red", cex = 3)
points(45, 12, pch = 20, col = "red", cex = 3)
sqrt((59 - 35) ^ 2) + sqrt((68 - 45) ^ 2 + (35 - 12) ^ 2)
area2link(w)
</code></pre>

<hr>
<h2 id='arrival'>Arrivals at an intensive care unit</h2><span id='topic+arrival'></span>

<h3>Description</h3>

<p>This data set gives arrival times of 254 patients at an intensive care unit during one day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(arrival)</code></pre>


<h3>Format</h3>

<p><code>arrival</code> is a list containing the 2 following objects : 
</p>
 
<dl>
<dt>times</dt><dd><p>is a vector giving the arrival times in the form HH:MM</p>
</dd> 
<dt>hours</dt><dd><p>is a vector giving the number of arrivals per hour for the day considered</p>
</dd>
</dl>


<h3>Source</h3>

<p>Data taken from the Oriana software developped by Warren L. Kovach <a href="mailto:sales@kovcomp.com">sales@kovcomp.com</a> starting from <a href="https://www.kovcomp.co.uk/oriana/index.html">https://www.kovcomp.co.uk/oriana/index.html</a>.
</p>


<h3>References</h3>

<p>Fisher, N. I. (1993) <em>Statistical Analysis of Circular Data</em>. Cambridge University Press. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arrival)
dotcircle(arrival$hours, pi/2 + pi/12)
</code></pre>

<hr>
<h2 id='as.taxo'>Taxonomy</h2><span id='topic+as.taxo'></span><span id='topic+dist.taxo'></span>

<h3>Description</h3>

<p>The function <code>as.taxo</code> creates an object of class <code>taxo</code> that is a sub-class of <code>data.frame</code>.
Each column of the data frame must be a factor corresponding to a level <em>j</em> of the taxonomy (genus, family, ...).
The levels of factor <em>j</em> define some classes that must be completly included in classes of factor <em>j+1</em>.<br />
A factor with exactly one level is not allowed. A factor with exactly one individual in each level is not allowed.
The function <code>dist.taxo</code> compute taxonomic distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.taxo(df)
dist.taxo(taxo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.taxo_+3A_df">df</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="as.taxo_+3A_taxo">taxo</code></td>
<td>
<p>a data frame of class <code>taxo</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.taxo</code> returns a data frame of class <code>taxo</code>.
<code>dist.taxo</code> returns a numeric of class <code>dist</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+taxo2phylog">taxo2phylog</a></code> to transform an object of class <code>taxo</code> into an object of class <code>phylog</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(taxo.eg)
tax &lt;- as.taxo(taxo.eg[[1]])
tax.phy &lt;- taxo2phylog(as.taxo(taxo.eg[[1]]),add.tools=TRUE)
par(mfrow = c(1,2))
plot(tax.phy, clabel.l = 1.25, clabel.n = 1.25, f = 0.75)
plot(taxo2phylog(as.taxo(taxo.eg[[1]][sample(15),])),
 clabel.l = 1.25, clabel.n = 1.25, f = 0.75)
par(mfrow = c(1,1))
all(dist.taxo(tax)==tax.phy$Wdist)
</code></pre>

<hr>
<h2 id='atlas'>Small Ecological Dataset</h2><span id='topic+atlas'></span>

<h3>Description</h3>

<p><code>atlas</code> is a list containing three kinds of information about 23 regions (The French Alps) : <br />
geographical coordinates, meteorology and bird presences.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(atlas)</code></pre>


<h3>Format</h3>

<p><code>atlas</code> is a list of 9 components:
</p>

<dl>
<dt>area</dt><dd><p>is a convex hull of 23 geographical regions.</p>
</dd>
<dt>xy</dt><dd><p>are the coordinates of the region centers and altitude (in meters).</p>
</dd>
<dt>names.district</dt><dd><p>is a vector of region names.</p>
</dd>
<dt>meteo</dt><dd><p>is a data frame with 7 variables: min and max temperature in january; 
min and max temperature in july; january, july and total rainfalls.</p>
</dd>
<dt>birds</dt><dd><p>is a data frame with 15 variables (species).</p>
</dd>
<dt>contour</dt><dd><p>is a data frame with 4 variables (x1, y1, x2, y2) for the contour display of The French Alps.</p>
</dd>
<dt>alti</dt><dd><p>is a data frame with 3 variables altitude in percentage [0,800], ]800,1500] and ]1500,5000].</p>
</dd>
<dt>Spatial</dt><dd><p>is the map of the 23 regions of The French Alps (an object of the class <code>SpatialPolygons</code> of <code>sp</code>).</p>
</dd>
<dt>Spatial.contour</dt><dd><p>is the contour of the map of the 23 regions of the French Alps (an object of the class <code>SpatialPolygons</code> of <code>sp</code>).</p>
</dd>
</dl>


<h3>Source</h3>

<p>Extract from: <br />
Lebreton, Ph. (1977) Les oiseaux nicheurs rhonalpins. <em>Atlas ornithologique Rhone-Alpes</em>.
Centre Ornithologique Rhone-Alpes, Universite Lyon 1, 69621 Villeurbanne. 
Direction de la Protection de la Nature, Ministere de la Qualite de la Vie. 1&ndash;354.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(atlas)
if(adegraphicsLoaded()) {
  if(requireNamespace("sp", quietly = TRUE)) {
    g11 &lt;- s.Spatial(atlas$Spatial, pSp.col = "white", plot = FALSE)
    g12 &lt;- s.label(atlas$area[, 2:3], plabels.cex = 0, plot = FALSE)
    g1 &lt;- superpose(g11, g12, plot = FALSE)
    g2 &lt;- s.label(atlas$xy, lab = atlas$names.district, Sp = atlas$Spatial, 
      pgrid.dra = FALSE, pSp.col = "white", plot = FALSE)
    obj3 &lt;- sp::SpatialPolygonsDataFrame(Sr = atlas$Spatial, data = atlas$meteo)
    g3 &lt;- s.Spatial(obj3[, 1], nclass = 12, psub = list(position = "topleft", 
      text = "Temp Mini January", cex = 2), plot = FALSE)
    g4 &lt;- s.corcircle((dudi.pca(atlas$meteo, scann = FALSE)$co), plabels.cex = 1, plot = FALSE)
    G1 &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  
    obj5 &lt;- sp::SpatialPolygonsDataFrame(Sr = atlas$Spatial, 
      data = dudi.pca(atlas$meteo, scann = FALSE)$li)
    g5 &lt;- s.Spatial(obj5[, 1], nclass = 12, psub = list(position = "topleft", 
      text = "Principal Component Analysis analysis", cex = 1.5), plot = FALSE)
    coa1 &lt;- dudi.coa(atlas$birds, scann = FALSE, nf = 1)
    obj6 &lt;- sp::SpatialPolygonsDataFrame(Sr = atlas$Spatial, data = coa1$li)
    g6 &lt;- s.Spatial(obj6[, 1], nclass = 12, psub = list(position = "topleft", 
      text = "Correspondence analysis", cex = 1.5), plot = FALSE)
    g7 &lt;- s.value(atlas$xy, coa1$li$Axis1, Sp = atlas$Spatial.contour, ppoints.cex = 2, 
      porigin.include = FALSE, paxes.draw = FALSE, pSp.col = "white", plot = FALSE)
    g8 &lt;- triangle.label(atlas$alti, plabels.cex = 0, plot = FALSE)
    G2 &lt;- ADEgS(list(g5, g6, g7, g8), layout = c(2, 2))
  
  }
} else {
  op &lt;- par(no.readonly = TRUE) 
  par(mfrow = c(2, 2))
  area.plot(atlas$area, cpoin = 1.5)
  area.plot(atlas$area, lab = atlas$names.district, clab = 1)
  x &lt;- atlas$meteo$mini.jan
  
  names(x) &lt;- row.names(atlas$meteo)
  area.plot(atlas$area, val = x, ncl = 12, sub = "Temp Mini January", csub = 2, cleg = 1)
  s.corcircle((dudi.pca(atlas$meteo, scann = FALSE)$co), clab = 1)
  
  area.plot(atlas$area, val = dudi.pca(atlas$meteo,scann=FALSE)$li[, 1], ncl = 12, 
    sub = "Principal Component Analysis analysis", csub = 1.5, cleg = 1)
  birds.coa &lt;- dudi.coa(atlas$birds, sca = FALSE, nf = 1)
  x &lt;- birds.coa$li$Axis1
  area.plot(atlas$area, val = x, ncl = 12, sub = "Correspondence analysis", csub = 1.5, cleg = 1)
  
  s.value(atlas$xy, x, contour = atlas$contour, csi = 2, incl = FALSE, addax = FALSE)
  triangle.plot(atlas$alti)
  par(op)
  par(mfrow = c(1, 1))}
</code></pre>

<hr>
<h2 id='atya'>Genetic variability of Cacadors</h2><span id='topic+atya'></span>

<h3>Description</h3>

<p>This data set contains information about genetic variability of 
<em>Atya innocous</em> and <em>Atya scabra</em> in Guadeloupe (France).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(atya)</code></pre>


<h3>Format</h3>

<p><code>atya</code> is a list with the following components:
</p>

<dl>
<dt>xy</dt><dd><p>a data frame with the coordinates of the 31 sites</p>
</dd>
<dt>gen</dt><dd><p>a data frame with 22 variables collected on 31 sites</p>
</dd>
<dt>neig</dt><dd><p>an object of class <code>neig</code></p>
</dd>
<dt>nb</dt><dd><p>a neighborhood object (class <code>nb</code> defined in package <code>spdep</code>)</p>
</dd>
</dl>


<h3>Source</h3>

<p>Fievet, E., Eppe, F. and Dolédec, S. (2001) Etude de la variabilité 
morphométrique et génétique des populations de Cacadors (<em>Atya innocous</em>
et <em>Atya scabra</em>) de l'île de Basse-Terre. Direction Régionale de 
L'Environnement Guadeloupe, Laboratoire des hydrosystèmes fluviaux,
Université Lyon 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(atya)
if(requireNamespace("pixmap", quietly = TRUE)) {
  atya.digi &lt;- pixmap::read.pnm(system.file("pictures/atyadigi.pnm",
      package = "ade4"))
  atya.carto &lt;- pixmap::read.pnm(system.file("pictures/atyacarto.pnm",
      package = "ade4"))
  par(mfrow = c(1, 2))
  pixmap:::plot(atya.digi)
  pixmap:::plot(atya.carto)
  points(atya$xy, pch = 20, cex = 2)
}
if(requireNamespace("spdep", quietly = TRUE)) {
  plot(neig2nb(atya$neig), atya$xy, col = "red", add = TRUE, lwd = 2)
  par(mfrow = c(1,1))
}

## End(Not run)</code></pre>

<hr>
<h2 id='avijons'>Bird species distribution</h2><span id='topic+avijons'></span>

<h3>Description</h3>

<p>This data set contains information about spatial distribution of bird species 
in a zone surrounding the river Rhône near Lyon (France).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(avijons)</code></pre>


<h3>Format</h3>

<p><code>avijons</code> is a list with the following components:
</p>
 
<dl>
<dt>xy</dt><dd><p>a data frame with the coordinates of the sites</p>
</dd>
<dt>area</dt><dd><p>an object of class <code>area</code></p>
</dd>
<dt>fau</dt><dd><p>a data frame with the abundance of 64 bird species in 91 sites</p>
</dd>
<dt>spe.names.fr</dt><dd><p>a vector of strings of character with the species names in french</p>
</dd>
<dt>Spatial</dt><dd><p>an object of the class <code>SpatialPolygons</code> of <code>sp</code>,
containing the map</p>
</dd>
</dl>


<h3>Source</h3>

<p>Bournaud, M., Amoros, C., Chessel, D., Coulet, M., Doledec, S., Michelot, J.L., 
Pautou, G., Rostan, J.C., Tachet, H. and Thioulouse, J. (1990). <em>Peuplements 
d'oiseaux et propriétés des écocomplexes de la plaine du Rhône : descripteurs 
de fonctionnement global et gestion des berges.</em> Rapport programme S.R.E.T.I.E., 
Ministère de l'Environnement CORA et URA CNRS 367, Univ. Lyon I. 
</p>


<h3>References</h3>

<p>Thioulouse, J., Chessel, D. and Champely, S. (1995) Multivariate analysis of 
spatial patterns: a unified approach to local and global structures. 
<em>Environmental and Ecological Statistics</em>, <b>2</b>, 1&ndash;14.
</p>
<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps051.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps051.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(avijons)
w1 &lt;- dudi.coa(avijons$fau, scannf = FALSE)$li
area.plot(avijons$area, center = avijons$xy, val = w1[, 1], clab = 0.75, 
  sub = "CA Axis 1", csub = 3)
  
## Not run: 
data(avijons)
if(!adegraphicsLoaded()) {
  if(requireNamespace("pixmap", quietly = TRUE)) {
    pnm.eau &lt;- pixmap::read.pnm(system.file("pictures/avijonseau.pnm", package = "ade4"))
    pnm.rou &lt;- pixmap::read.pnm(system.file("pictures/avijonsrou.pnm", package = "ade4"))
    pnm.veg &lt;- pixmap::read.pnm(system.file("pictures/avijonsveg.pnm", package = "ade4"))
    pnm.vil &lt;- pixmap::read.pnm(system.file("pictures/avijonsvil.pnm", package = "ade4"))
    jons.coa &lt;- dudi.coa(avijons$fau, scan = FALSE, nf = 4)
    
    par(mfcol = c(3, 2))
    s.value(avijons$xy, jons.coa$li[, 1], pixmap = pnm.rou, inclu = FALSE,
      grid = FALSE, addax = FALSE, cleg = 0, sub = "F1+ROADS", csub = 3)
    s.value(avijons$xy, jons.coa$li[, 1], pixmap = pnm.veg, inclu = FALSE,
      grid = FALSE, addax = FALSE, cleg = 0, sub = "F1+TREES", csub = 3)
    s.value(avijons$xy, jons.coa$li[, 1], pixmap = pnm.eau, inclu = FALSE,
      grid = FALSE, addax = FALSE, cleg = 0, sub = "F1+WATER", csub = 3)
    s.value(avijons$xy, jons.coa$li[, 2], pixmap = pnm.rou, inclu = FALSE,
      grid = FALSE, addax = FALSE, cleg = 0, sub = "F2+ROADS", csub = 3)
    s.value(avijons$xy, jons.coa$li[, 2], pixmap = pnm.veg, inclu = FALSE,
      grid = FALSE, addax = FALSE, cleg = 0, sub = "F2+TREES", csub = 3)
    s.value(avijons$xy, jons.coa$li[, 2], pixmap = pnm.eau, inclu = FALSE,
      grid = FALSE, addax = FALSE, cleg = 0, sub = "F2+WATER", csub = 3)
    par(mfrow = c(1, 1))
  }

  if(requireNamespace("spdep", quietly = TRUE) &amp; 
    requireNamespace("pixmap", quietly = TRUE)) {
    
    link1 &lt;- area2link(avijons$area)
    lw1 &lt;- apply(link1, 1, function(x) x[x &gt; 0])
    neig1 &lt;- neig(mat01 = 1*(link1 &gt; 0))
    nb1 &lt;- neig2nb(neig1)
    listw1 &lt;- spdep::nb2listw(nb1,lw1)
    jons.ms &lt;- multispati(jons.coa, listw1, scan = FALSE, nfp = 3, nfn = 2)
    summary(jons.ms)
    par(mfrow = c(2, 2))
    barplot(jons.coa$eig)
    barplot(jons.ms$eig)
    s.corcircle(jons.ms$as)
    plot(jons.coa$li[, 1], jons.ms$li[, 1])
    par(mfrow = c(1, 1))

    par(mfcol = c(3, 2))
    s.value(avijons$xy, jons.ms$li[, 1], pixmap = pnm.rou, inclu = FALSE,
      grid = FALSE, addax = FALSE, cleg = 0, sub = "F1+ROADS", csub = 3)
    s.value(avijons$xy, jons.ms$li[, 1], pixmap = pnm.veg, inclu = FALSE,
      grid = FALSE, addax = FALSE, cleg = 0, sub = "F1+TREES", csub = 3)
    s.value(avijons$xy, jons.ms$li[, 1], pixmap = pnm.eau, inclu = FALSE,
      grid = FALSE, addax = FALSE, cleg = 0, sub = "F1+WATER", csub = 3)
    s.value(avijons$xy, jons.ms$li[, 2], pixmap = pnm.rou, inclu = FALSE,
      grid = FALSE, addax = FALSE, cleg = 0, sub = "F2+ROADS", csub = 3)
    s.value(avijons$xy, jons.ms$li[, 2], pixmap = pnm.veg, inclu = FALSE,
      grid = FALSE, addax = FALSE, cleg = 0, sub = "F2+TREES", csub = 3)
    s.value(avijons$xy, jons.ms$li[, 2], pixmap = pnm.eau, inclu = FALSE,
      grid = FALSE, addax = FALSE, cleg = 0, sub = "F2+WATER", csub = 3)
    par(mfrow = c(1, 1))
}}
## End(Not run)</code></pre>

<hr>
<h2 id='avimedi'>Fauna Table for Constrained Ordinations</h2><span id='topic+avimedi'></span>

<h3>Description</h3>

<p><code>avimedi</code> is a list containing the information about 302 sites : <br />
frequencies of 51 bird species ; two factors (habitats and Mediterranean origin). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(avimedi)</code></pre>


<h3>Format</h3>

<p>This list contains the following objects:
</p>

<dl>
<dt>fau</dt><dd><p>is a data frame 302 sites - 51 bird species. </p>
</dd>
<dt>plan</dt><dd><p>is a data frame 302 sites - 2 factors : <code>reg</code> with two levels Provence (<code>Pr</code>, 
South of France) and Corsica (<code>Co</code>) ;
<code>str</code> with six levels describing the vegetation from a very low matorral (1) up to a mature forest of holm oaks (6).</p>
</dd>
<dt>nomesp</dt><dd><p>is a vector 51 latin names. </p>
</dd>
</dl>



<h3>Source</h3>

<p>Blondel, J., Chessel, D., &amp; Frochot, B. (1988)
Bird species impoverishment, niche expansion, and density inflation in mediterranean island habitats.
<em>Ecology</em>, <b>69</b>, 1899&ndash;1917.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(avimedi)
coa1 &lt;- dudi.coa(avimedi$fau, scan = FALSE, nf = 3)
bet1 &lt;- bca(coa1, avimedi$plan$str, scan = FALSE)
wit1 &lt;- wca(coa1, avimedi$plan$reg, scan=FALSE)
pcaiv1 &lt;- pcaiv(coa1, avimedi$plan, scan = FALSE)
    
if(adegraphicsLoaded()) {
  g1 &lt;- s.class(coa1$li, avimedi$plan$str:avimedi$plan$reg, 
    psub.text = "Correspondences Analysis", plot = FALSE)
  g2 &lt;- s.class(bet1$ls, avimedi$plan$str, psub.text = "Between Analysis", plot = FALSE)
  g3 &lt;- s.class(wit1$li, avimedi$plan$str, psub.text = "Within Analysis", plot = FALSE)

  g41 &lt;- s.match(pcaiv1$li, pcaiv1$ls, plabels.cex = 0, 
    psub.text = "Canonical Correspondences Analysis", plot = FALSE)
  g42 &lt;- s.class(pcaiv1$li, avimedi$plan$str:avimedi$plan$reg, plot = FALSE)
  g4 &lt;- superpose(g41, g42, plot = FALSE)
  
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))

} else {
  par(mfrow = c(2,2))
  s.class(coa1$li,avimedi$plan$str:avimedi$plan$reg,
      sub = "Correspondences Analysis")
  s.class(bet1$ls, avimedi$plan$str,
      sub = "Between Analysis")
  s.class(wit1$li, avimedi$plan$str,
      sub = "Within Analysis")
  s.match(pcaiv1$li, pcaiv1$ls, clab = 0,
      sub = "Canonical Correspondences Analysis")
  s.class(pcaiv1$li, avimedi$plan$str:avimedi$plan$reg, 
      add.plot = TRUE)
  par(mfrow=c(1,1))
}

## End(Not run)</code></pre>

<hr>
<h2 id='aviurba'>Ecological Tables Triplet</h2><span id='topic+aviurba'></span>

<h3>Description</h3>

<p>This data set is a list of information about 51 sites : bird species and environmental variables. <br />
A data frame contains biological traits for each species. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(aviurba)</code></pre>


<h3>Format</h3>

<p>This list contains the following objects:
</p>

<dl>
<dt>fau</dt><dd><p>is a data frame 51 sites 40 bird species. </p>
</dd>
<dt>mil</dt><dd><p>is a data frame 51 sites 11 environmental variables (see details). </p>
</dd>
<dt>traits</dt><dd><p>is a data frame 40 species 4 biological traits (see details).</p>
</dd>
<dt>species.names.fr</dt><dd><p>is a vector of the species names in french. </p>
</dd>
<dt>species.names.la</dt><dd><p>is a vector of the species names in latin. </p>
</dd>
<dt>species.family</dt><dd><p>is a factor : the species families. </p>
</dd>
</dl>



<h3>Details</h3>

<p><code>aviurba$mil</code> contains for each site, 11 habitat attributes describing the degree of urbanization.
The presence or absence of farms or villages, small buildings, high buildings, industry, fields, grassland, scrubby areas,
deciduous woods, coniferous woods, noisy area are noticed. At least, the vegetation cover (variable 11) is a factor with 8 levels
from a minimum cover (R5) up to a maximum (R100).<br />
</p>
<p><code>aviurba$traits</code> contains four factors : feeding habit (insectivor, granivore, omnivore), feeding stratum (ground, aerial, foliage and scrub),
breeding stratum (ground, building, scrub, foliage) and migration strategy (resident, migrant).
</p>


<h3>Source</h3>

<p>Dolédec, S., Chessel, D., Ter Braak,C. J. F. and Champely S. (1996)
Matching species traits to environmental variables: a new three-table ordination method.
<em>Environmental and Ecological Statistics</em>, <b>3</b>, 143&ndash;166.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aviurba)
a1 &lt;- dudi.coa(aviurba$fau, scan = FALSE, nf=4)
a2 &lt;- dudi.acm(aviurba$mil, row.w = a1$lw, scan = FALSE, nf = 4)
plot(coinertia(a1, a2, scan = FALSE))
</code></pre>

<hr>
<h2 id='bacteria'>Genomes of 43 Bacteria</h2><span id='topic+bacteria'></span>

<h3>Description</h3>

<p><code>bacteria</code> is a list containing 43 species and genomic informations : codons, amino acid and bases. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bacteria)</code></pre>


<h3>Format</h3>

<p>This list contains the following objects:
</p>

<dl>
<dt>code</dt><dd><p>is a factor with the amino acid names for each codon. </p>
</dd>
<dt>espcodon</dt><dd><p>is a data frame 43 species 64 codons. </p>
</dd>
<dt>espaa</dt><dd><p>is a data frame 43 species 21 amino acid. </p>
</dd>
<dt>espbase</dt><dd><p>is a data frame 43 species 4 bases. </p>
</dd>
</dl>



<h3>Source</h3>

<p>Data prepared by J. Lobry <a href="mailto:Jean.Lobry@univ-lyon1.fr">Jean.Lobry@univ-lyon1.fr</a> starting from <a href="https://www.jcvi.org/">https://www.jcvi.org/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bacteria)
names(bacteria$espcodon)
names(bacteria$espaa)
names(bacteria$espbase)
sum(bacteria$espcodon) # 22,619,749 codons

if(adegraphicsLoaded()) {
  g &lt;- scatter(dudi.coa(bacteria$espcodon, scann = FALSE), 
    posi = "bottomleft")
} else {
  scatter(dudi.coa(bacteria$espcodon, scann = FALSE), 
    posi = "bottom")
}</code></pre>

<hr>
<h2 id='banque'>Table of Factors</h2><span id='topic+banque'></span>

<h3>Description</h3>

<p><code>banque</code> gives the results of a bank survey onto 810 customers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(banque)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<ol>
<li><p> csp: &quot;Socio-professional categories&quot; a factor with levels 
</p>

<ul>
<li> <p><code>agric</code> Farmers 
</p>
</li>
<li> <p><code>artis</code> Craftsmen, Shopkeepers, Company directors 
</p>
</li>
<li> <p><code>cadsu</code> Executives and higher intellectual professions 
</p>
</li>
<li> <p><code>inter</code> Intermediate professions 
</p>
</li>
<li> <p><code>emplo</code> Other white-collar workers 
</p>
</li>
<li> <p><code>ouvri</code> Manual workers 
</p>
</li>
<li> <p><code>retra</code> Pensionners 
</p>
</li>
<li> <p><code>inact</code> Non working population 
</p>
</li>
<li> <p><code>etudi</code> Students</p>
</li></ul>
 
</li>
<li><p> duree: &quot;Time relations with the customer&quot; a factor with levels 
</p>

<ul>
<li> <p><code>dm2</code> &lt;2 years 
</p>
</li>
<li> <p><code>d24</code> [2 years, 4 years[ 
</p>
</li>
<li> <p><code>d48</code> [4 years, 8 years[ 
</p>
</li>
<li> <p><code>d812</code> [8 years, 12 years[ 
</p>
</li>
<li> <p><code>dp12</code> &gt;= 12 years</p>
</li></ul>

</li>
<li><p> oppo: &quot;Stopped a check?&quot; a factor with levels
</p>

<ul>
<li> <p><code>non</code> no 
</p>
</li>
<li> <p><code>oui</code> yes</p>
</li></ul>

</li>
<li><p> age: &quot;Customer's age&quot; a factor with levels 
</p>

<ul>
<li> <p><code>ai25</code> [18 years, 25 years[ 
</p>
</li>
<li> <p><code>ai35</code> [25 years, 35 years[
</p>
</li>
<li> <p><code>ai45</code> [35 years, 45 years[ 
</p>
</li>
<li> <p><code>ai55</code> [45 years, 55 years[ 
</p>
</li>
<li> <p><code>ai75</code> [55 years, 75 years[</p>
</li></ul>

</li>
<li><p> sexe: &quot;Customer's gender&quot; a factor with levels 
</p>

<ul>
<li> <p><code>hom</code> Male 
</p>
</li>
<li> <p><code>fem</code> Female</p>
</li></ul>

</li>
<li><p> interdit: &quot;No checkbook allowed&quot; a factor with levels
</p>

<ul>
<li> <p><code>non</code> no 
</p>
</li>
<li> <p><code>oui</code> yes </p>
</li></ul>

</li>
<li><p> cableue: &quot;Possess a bank card?&quot; a factor with levels 
</p>

<ul>
<li> <p><code>non</code> no 
</p>
</li>
<li> <p><code>oui</code> yes </p>
</li></ul>

</li>
<li><p> assurvi: &quot;Contrat of life insurance?&quot; a factor with levels 
</p>

<ul>
<li> <p><code>non</code> no<br />
</p>
</li>
<li> <p><code>oui</code> yes</p>
</li></ul>

</li>
<li><p> soldevu: &quot;Balance of the current accounts&quot; a factor with levels 
</p>

<ul>
<li> <p><code>p4</code> credit balance &gt; 20000 
</p>
</li>
<li> <p><code>p3</code> credit balance 12000-20000 
</p>
</li>
<li> <p><code>p2</code> credit balance 4000-120000 
</p>
</li>
<li> <p><code>p1</code> credit balance &gt;0-4000 
</p>
</li>
<li> <p><code>n1</code> debit balance  0-4000 
</p>
</li>
<li> <p><code>n2</code> debit balance &gt;4000  </p>
</li></ul>

</li>
<li><p> eparlog: &quot;Savings and loan association account amount&quot; a factor with levels 
</p>

<ul>
<li> <p><code>for</code> &gt; 20000 
</p>
</li>
<li> <p><code>fai</code> &gt;0 and &lt;20000 
</p>
</li>
<li> <p><code>nul</code> nulle  </p>
</li></ul>

</li>
<li><p> eparliv: &quot;Savings bank amount&quot; a factor with levels 
</p>

<ul>
<li> <p><code>for</code> &gt; 20000 
</p>
</li>
<li> <p><code>fai</code> &gt;0 and &lt;20000 
</p>
</li>
<li> <p><code>nul</code> nulle  </p>
</li></ul>

</li>
<li><p> credhab: &quot;Home loan owner&quot; a factor with levels 
</p>

<ul>
<li> <p><code>non</code> no 
</p>
</li>
<li> <p><code>oui</code> yes  </p>
</li></ul>

</li>
<li><p> credcon: &quot;Consumer credit amount&quot; a factor with levels 
</p>

<ul>
<li> <p><code>nul</code> none 
</p>
</li>
<li> <p><code>fai</code> &gt;0 and &lt;20000 
</p>
</li>
<li> <p><code>for</code> &gt; 20000  </p>
</li></ul>

</li>
<li><p> versesp: &quot;Check deposits&quot; a factor with levels 
</p>

<ul>
<li> <p><code>oui</code> yes 
</p>
</li>
<li> <p><code>non</code> no  </p>
</li></ul>

</li>
<li><p> retresp: &quot;Cash withdrawals&quot; a factor with levels 
</p>

<ul>
<li> <p><code>fai</code> &lt; 2000 
</p>
</li>
<li> <p><code>moy</code> 2000-5000 
</p>
</li>
<li> <p><code>for</code> &gt; 5000  </p>
</li></ul>

</li>
<li><p> remiche: &quot;Endorsed checks amount&quot; a factor with levels 
</p>

<ul>
<li> <p><code>for</code> &gt;10000 
</p>
</li>
<li> <p><code>moy</code> 10000-5000 
</p>
</li>
<li> <p><code>fai</code> 1-5000 
</p>
</li>
<li> <p><code>nul</code> none  </p>
</li></ul>

</li>
<li><p> preltre: &quot;Treasury Department tax deductions&quot; a factor with levels 
</p>

<ul>
<li> <p><code>nul</code> none 
</p>
</li>
<li> <p><code>fai</code> &lt;1000 
</p>
</li>
<li> <p><code>moy</code> &gt;1000  </p>
</li></ul>

</li>
<li><p> prelfin: &quot;Financial institution deductions&quot; a factor with levels 
</p>

<ul>
<li> <p><code>nul</code> none 
</p>
</li>
<li> <p><code>fai</code> &lt;1000 
</p>
</li>
<li> <p><code>moy</code> &gt;1000  </p>
</li></ul>

</li>
<li><p> viredeb: &quot;Debit transfer amount&quot; a factor with levels 
</p>

<ul>
<li> <p><code>nul</code> none 
</p>
</li>
<li> <p><code>fai</code> &lt;2500 
</p>
</li>
<li> <p><code>moy</code> 2500-5000 
</p>
</li>
<li> <p><code>for</code> &gt;5000</p>
</li></ul>

</li>
<li><p> virecre: &quot;Credit transfer amount&quot; a factor with levels 
</p>

<ul>
<li> <p><code>for</code> &gt;10000 
</p>
</li>
<li> <p><code>moy</code> 10000-5000 
</p>
</li>
<li> <p><code>fai</code> &lt;5000 
</p>
</li>
<li> <p><code>nul</code> aucun</p>
</li></ul>

</li>
<li><p> porttit: &quot;Securities portfolio estimations&quot; a factor with levels 
</p>

<ul>
<li> <p><code>nul</code> none 
</p>
</li>
<li> <p><code>fai</code> &lt; 20000 
</p>
</li>
<li> <p><code>moy</code> 20000-100000 
</p>
</li>
<li> <p><code>for</code> &gt;100000</p>
</li></ul>

</li></ol>



<h3>Source</h3>

<p>anonymous
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(banque)
banque.acm &lt;- dudi.acm(banque, scannf = FALSE, nf = 3)
apply(banque.acm$cr, 2, mean)
banque.acm$eig[1:banque.acm$nf] # the same thing

if(adegraphicsLoaded()) {
  g &lt;- s.arrow(banque.acm$c1, plabels.cex = 0.75)
} else {
  s.arrow(banque.acm$c1, clab = 0.75)
}</code></pre>

<hr>
<h2 id='baran95'>African Estuary Fishes</h2><span id='topic+baran95'></span>

<h3>Description</h3>

<p>This data set is a list containing relations between sites and fish species linked to dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(baran95)</code></pre>


<h3>Format</h3>

<p>This list contains the following objects:
</p>

<dl>
<dt>fau</dt><dd><p>is a data frame 95 seinings and 33 fish species. </p>
</dd>
<dt>plan</dt><dd><p>is a data frame 2 factors : date and site. The <code>date</code> has 6 levels (april 1993, june 1993, 
august 1993, october 1993, december 1993 and february 1994) and the <code>sites</code> are defined by 4 distances to the
Atlantic Ocean (km03, km17, km33 and km46). </p>
</dd>
<dt>species.names</dt><dd><p>is a vector of species latin names. </p>
</dd>
</dl>



<h3>Source</h3>

<p>Baran, E. (1995) <em>Dynamique spatio-temporelle des peuplements de Poissons estuariens en Guinée (Afrique de l'Ouest)</em>.
Thèse de Doctorat, Université de Bretagne Occidentale. 
Data collected by net fishing sampling in the Fatala river estuary.
</p>


<h3>References</h3>

<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps027.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps027.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(baran95)
w &lt;- dudi.pca(log(baran95$fau + 1), scal = FALSE, scann = FALSE, 
    nf = 3)
w1 &lt;- wca(w, baran95$plan$date, scann = FALSE)
fatala &lt;- ktab.within(w1)
stat1 &lt;- statis(fatala, scan = FALSE, nf = 3)
mfa1 &lt;- mfa(fatala, scan = FALSE, nf = 3)

if(adegraphicsLoaded()) {
  g1 &lt;- s.class(stat1$C.Co, baran95$plan$site, facets = baran95$plan$date, 
    pellipses.axes.draw = FALSE, ppoints.cex = 0.5, plot = FALSE)
  n1 &lt;- length(g1@ADEglist)
  g2 &lt;- ADEgS(lapply(1:n1, function(i) s.label(stat1$C.Co, plabels.cex = 0, 
    ppoints.cex = 0.5, plot = FALSE)), positions = g1@positions, plot = FALSE)
  G1 &lt;- superpose(g2, g1, plot = TRUE)
    
  G2 &lt;- kplot(stat1, arrow = FALSE, traject = FALSE, class = baran95$plan$site, 
    col.plabels.cex = 0, ppoints.cex = 0.5)
  
  g3 &lt;- s.class(mfa1$co, baran95$plan$site, facets = baran95$plan$date, 
    pellipses.axes.draw = FALSE, ppoints.cex = 0.5, plot = FALSE)
  n2 &lt;- length(g3@ADEglist)
  g4 &lt;- ADEgS(lapply(1:n2, function(i) s.label(mfa1$co, plabels.cex = 0, 
    ppoints.cex = 0.5, plot = FALSE)), positions = g3@positions, plot = FALSE)
  G3 &lt;- superpose(g4, g3, plot = TRUE)
    
} else {
  par(mfrow = c(3, 2))
  w2 &lt;- split(stat1$C.Co, baran95$plan$date)
  w3 &lt;- split(baran95$plan$site, baran95$plan$date)
  for (j in 1:6) {
    s.label(stat1$C.Co[,1:2], clab = 0, sub = tab.names(fatala)[j], csub = 3)
    s.class(w2[[j]][, 1:2], w3[[j]], clab = 2, axese = FALSE, add.plot = TRUE)
  }
  par(mfrow = c(1, 1))
  
  kplot(stat1, arrow = FALSE, traj = FALSE, clab = 2, uni = TRUE, 
    class = baran95$plan$site) #simpler
    
  par(mfrow = c(3, 2))
  w4 &lt;- split(mfa1$co, baran95$plan$date)
  for (j in 1:6) {
    s.label(mfa1$co[, 1:2], clab = 0, sub = tab.names(fatala)[j], csub = 3)
    s.class(w4[[j]][, 1:2], w3[[j]], clab = 2, axese = FALSE, add.plot = TRUE)
  }
  par(mfrow = c(1, 1))
}
</code></pre>

<hr>
<h2 id='bca'>Between-Class Analysis</h2><span id='topic+bca'></span><span id='topic+bca.dudi'></span>

<h3>Description</h3>

<p>Performs a particular case of a Principal Component Analysis with
respect to Instrumental Variables (pcaiv), in which there is only a
single factor as explanatory variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dudi'
bca(x, fac, scannf = TRUE, nf = 2, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bca_+3A_x">x</code></td>
<td>
<p>a duality diagram, object of class <code><a href="#topic+dudi">dudi</a></code> from
one of the functions <code>dudi.coa</code>, <code>dudi.pca</code>,...</p>
</td></tr>
<tr><td><code id="bca_+3A_fac">fac</code></td>
<td>
<p>a factor partitioning the rows of <code>dudi$tab</code> in classes</p>
</td></tr>
<tr><td><code id="bca_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues barplot should be displayed</p>
</td></tr>
<tr><td><code id="bca_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, a numeric value indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="bca_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code><a href="#topic+dudi">dudi</a></code>, subclass 'between' containing
</p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>a data frame class-variables containing the means per class
for each variable</p>
</td></tr>
<tr><td><code>cw</code></td>
<td>
<p>a numeric vector of the column weigths</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>a numeric vector of the class weigths</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a numeric vector with all the eigenvalues</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the rank of the analysis</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>an integer value indicating the number of kept axes</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>a data frame with the column normed scores</p>
</td></tr>
<tr><td><code>l1</code></td>
<td>
<p>a data frame with the class normed scores</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>a data frame  with the column coordinates</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>a data frame with the class coordinates</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matching call</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>the bewteen-class inertia percentage</p>
</td></tr>
<tr><td><code>ls</code></td>
<td>
<p>a data frame with the row coordinates</p>
</td></tr>
<tr><td><code>as</code></td>
<td>
<p>a data frame containing the projection of inertia axes onto between axes</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To avoid conflict names with the <code>base:::within</code> function, the
function <code>within</code> is now deprecated and removed. To be
consistent, the <code>between</code> function is also deprecated and
is replaced by the method <code>bca.dudi</code> of the new generic <code>bca</code> function. 
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Dolédec, S. and Chessel, D. (1987) Rythmes saisonniers et composantes stationnelles 
en milieu aquatique I- Description d'un plan d'observations complet par 
projection de variables. <em>Acta Oecologica, Oecologia Generalis</em>, <b>8</b>, 3, 403&ndash;426.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
pca1 &lt;- dudi.pca(meaudret$env, scan = FALSE, nf = 4)
pca2 &lt;- dudi.pca(meaudret$spe, scal = FALSE, scan = FALSE, nf = 4)
bet1 &lt;- bca(pca1, meaudret$design$site, scan = FALSE, nf = 2)
bet2 &lt;- bca(pca2, meaudret$design$site, scan = FALSE, nf = 2)
  
if(adegraphicsLoaded()) {
  g1 &lt;- s.class(pca1$li, meaudret$design$site, psub.text = "Principal Component Analysis (env)",
    plot = FALSE)
  g2 &lt;- s.class(pca2$li, meaudret$design$site, psub.text = "Principal Component Analysis (spe)",
    plot = FALSE)
  g3 &lt;- s.class(bet1$ls, meaudret$design$site, psub.text = "Between sites PCA (env)", plot = FALSE)
  g4 &lt;- s.class(bet2$ls, meaudret$design$site, psub.text = "Between sites PCA (spe)", plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  
} else {
  par(mfrow = c(2, 2))
  s.class(pca1$li, meaudret$design$site, sub = "Principal Component Analysis (env)", csub = 1.75)
  s.class(pca2$li, meaudret$design$site, sub = "Principal Component Analysis (spe)", csub = 1.75)
  s.class(bet1$ls, meaudret$design$site, sub = "Between sites PCA (env)", csub = 1.75)
  s.class(bet2$ls, meaudret$design$site, sub = "Between sites PCA (spe)", csub = 1.75)
  par(mfrow = c(1, 1))
}

coib &lt;- coinertia(bet1, bet2, scann = FALSE)
plot(coib)
</code></pre>

<hr>
<h2 id='bca.coinertia'>Between-class coinertia analysis</h2><span id='topic+bca.coinertia'></span>

<h3>Description</h3>

<p>Performs a between-class analysis after a coinertia analysis</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coinertia'
bca(x, fac, scannf = TRUE, nf = 2, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bca.coinertia_+3A_x">x</code></td>
<td>
<p>a coinertia analysis (object of class <a href="#topic+coinertia">coinertia</a>)
obtained by the function <a href="#topic+coinertia">coinertia</a></p>
</td></tr>
<tr><td><code id="bca.coinertia_+3A_fac">fac</code></td>
<td>
<p>a factor partitioning the rows in classes</p>
</td></tr>
<tr><td><code id="bca.coinertia_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues barplot should be displayed</p>
</td></tr>
<tr><td><code id="bca.coinertia_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="bca.coinertia_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This analysis is equivalent to do a between-class analysis on each
initial dudi, and a coinertia analysis on the two between analyses. 
This function returns additional outputs for the interpretation.
</p>


<h3>Value</h3>

<p>An object of the class <code>betcoi</code>. Outputs are described by the
<code>print</code> function
</p>


<h3>Note</h3>

<p>To avoid conflict names with the <code>base:::within</code> function, the
function <code>within</code> is now deprecated and removed. To be
consistent, the <code>betweencoinertia</code> function is also deprecated and
is replaced by the method <code>bca.coinertia</code> of the new generic <code>bca</code> function. 
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a> and Jean Thioulouse <a href="mailto:jean.thioulouse@univ-lyon1.fr">jean.thioulouse@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Franquet E., Doledec S., and Chessel D. (1995) Using multivariate analyses for 
separating spatial and temporal effects within species-environment relationships. 
<em>Hydrobiologia</em>, <b>300</b>, 425&ndash;431.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coinertia">coinertia</a></code>, <code><a href="#topic+bca">bca</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
pca1 &lt;- dudi.pca(meaudret$env, scan = FALSE, nf = 4)
pca2 &lt;- dudi.pca(meaudret$spe, scal = FALSE, scan = FALSE, nf = 4)
   
bet1 &lt;- bca(pca1, meaudret$design$site, scan = FALSE, nf = 2)
bet2 &lt;- bca(pca2, meaudret$design$site, scan = FALSE, nf = 2)
coib &lt;- coinertia(bet1, bet2, scannf = FALSE)

coi &lt;- coinertia(pca1, pca2, scannf = FALSE, nf = 3)
coi.b &lt;- bca(coi,meaudret$design$site, scannf = FALSE)
## coib and coi.b are equivalent

plot(coi.b)
</code></pre>

<hr>
<h2 id='bca.rlq'>
Between-Class RLQ analysis
</h2><span id='topic+bca.rlq'></span><span id='topic+plot.betrlq'></span><span id='topic+print.betrlq'></span>

<h3>Description</h3>

<p>Performs a particular RLQ analysis where a partition of sites (rows of
R) is taken into account. The between-class RLQ analysis search for
linear combinations of traits and environmental variables maximizing the
covariances between the traits and the average environmental conditions of classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rlq'
bca(x, fac, scannf = TRUE, nf = 2, ...)
## S3 method for class 'betrlq'
plot(x, xax = 1, yax = 2, ...)
## S3 method for class 'betrlq'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bca.rlq_+3A_x">x</code></td>
<td>
<p>an object of class rlq (created by the <code>rlq</code> function)
for the <code>bca.rlq</code> function. An object of class <code>betrlq</code> for
the <code>print</code> and <code>plot</code> functions</p>
</td></tr>
<tr><td><code id="bca.rlq_+3A_fac">fac</code></td>
<td>
<p>a factor partitioning the rows of R</p>
</td></tr>
<tr><td><code id="bca.rlq_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="bca.rlq_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="bca.rlq_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="bca.rlq_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="bca.rlq_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>bca.rlq</code> function returns an object of class 'betrlq'
(sub-class of 'dudi'). See the outputs of the <code>print</code> function
for more details.
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Wesuls, D., Oldeland, J. and Dray, S. (2012) Disentangling plant trait
responses to livestock grazing from spatio-temporal variation: the
partial RLQ approach. <em>Journal of Vegetation Science</em>, <b>23</b>, 98&ndash;113.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rlq">rlq</a></code>, <code><a href="#topic+bca">bca</a></code>, <code><a href="#topic+wca.rlq">wca.rlq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(piosphere)
afcL &lt;- dudi.coa(log(piosphere$veg + 1), scannf = FALSE)
acpR &lt;- dudi.pca(piosphere$env, scannf = FALSE, row.w = afcL$lw)
acpQ &lt;- dudi.hillsmith(piosphere$traits, scannf = FALSE, row.w =
  afcL$cw)
rlq1 &lt;- rlq(acpR, afcL, acpQ, scannf = FALSE)

brlq1 &lt;- bca(rlq1, fac = piosphere$habitat, scannf = FALSE)
brlq1
plot(brlq1)
</code></pre>

<hr>
<h2 id='between'>Between-Class Analysis</h2><span id='topic+summary.between'></span><span id='topic+print.between'></span><span id='topic+plot.between'></span><span id='topic+print.betcoi'></span><span id='topic+plot.betcoi'></span>

<h3>Description</h3>

<p>Outputs and graphical representations of the results of a between-class analysis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'between'
plot(x, xax = 1, yax = 2, ...) 
## S3 method for class 'between'
print(x, ...)
## S3 method for class 'betcoi'
plot(x, xax = 1, yax = 2, ...)
## S3 method for class 'betcoi'
print(x, ...)
## S3 method for class 'between'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="between_+3A_x">x</code>, <code id="between_+3A_object">object</code></td>
<td>
<p>an object of class <code>between</code> or <code>betcoi</code></p>
</td></tr>
<tr><td><code id="between_+3A_xax">xax</code>, <code id="between_+3A_yax">yax</code></td>
<td>
<p>the column index of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="between_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a><br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Dolédec, S. and Chessel, D. (1987) Rythmes saisonniers et composantes stationnelles en milieu aquatique
I- Description d'un plan d'observations complet par projection de variables. <em>Acta Oecologica, Oecologia Generalis</em>, <b>8</b>, 3, 403&ndash;426.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bca.dudi">bca.dudi</a></code>, <code><a href="#topic+bca.coinertia">bca.coinertia</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)

pca1 &lt;- dudi.pca(meaudret$env, scan = FALSE, nf = 4)
pca2 &lt;- dudi.pca(meaudret$spe, scal = FALSE, scan = FALSE, nf = 4)
bet1 &lt;- bca(pca1, meaudret$design$site, scan = FALSE, nf = 2)
bet2 &lt;- bca(pca2, meaudret$design$site, scan = FALSE, nf = 2)

if(adegraphicsLoaded()) {
  g1 &lt;- s.class(pca1$li, meaudret$design$site, psub.text = "Principal Component Analysis (env)", 
    plot = FALSE)
  g2 &lt;- s.class(pca2$li, meaudret$design$site, psub.text = "Principal Component Analysis (spe)", 
    plot = FALSE)
  g3 &lt;- s.class(bet1$ls, meaudret$design$site, psub.text = "Between sites PCA (env)", 
    plot = FALSE)
  g4 &lt;- s.class(bet2$ls, meaudret$design$site, psub.text = "Between sites PCA (spe)", 
    plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  
} else {
  par(mfrow = c(2, 2))
  s.class(pca1$li, meaudret$design$site, sub = "Principal Component Analysis (env)", csub = 1.75)
  s.class(pca2$li, meaudret$design$site, sub = "Principal Component Analysis (spe)", csub = 1.75)
  s.class(bet1$ls, meaudret$design$site, sub = "Between sites PCA (env)", csub = 1.75)
  s.class(bet2$ls, meaudret$design$site, sub = "Between sites PCA (spe)", csub = 1.75)
  par(mfrow = c(1,1))
}

coib &lt;- coinertia(bet1, bet2, scann = FALSE)
plot(coib)
</code></pre>

<hr>
<h2 id='bf88'>Cubic Ecological Data</h2><span id='topic+bf88'></span>

<h3>Description</h3>

<p><code>bf88</code> is a list of 6 data frames corresponding to 6 stages of vegetation. <br />
Each data frame gives some bird species informations for 4 counties. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bf88)</code></pre>


<h3>Format</h3>

<p>A list of six data frames with 79 rows (bird species) and 4 columns (counties).<br />
The 6 arrays (S1 to S6) are the 6 stages of vegetation.<br />
The attribut 'nomesp' of this list is a vector of species French names. 
</p>


<h3>Source</h3>

<p>Blondel, J. and Farre, H. (1988) 
The convergent trajectories of bird communities along ecological successions in european forests. 
<em>Oecologia</em> (Berlin), <b>75</b>, 83&ndash;93.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bf88)
fou1 &lt;- foucart(bf88, scann = FALSE, nf = 3)
fou1

if(adegraphicsLoaded()) {
  g1 &lt;- scatter(fou1, plot = FALSE)
  g2 &lt;- s.traject(fou1$Tco, fou1$TC[, 1], plines.lty = 1:length(levels(fou1$TC[, 1])), plot = FALSE)
  g3 &lt;- s.traject(fou1$Tco, fou1$TC[, 2], plines.lty = 1:length(levels(fou1$TC[, 2])), plot = FALSE)
  g41 &lt;- s.label(fou1$Tco, plot = FALSE)
  g42 &lt;- s.label(fou1$co, plab.cex = 2, plot = FALSE)
  g4 &lt;- superpose(g41, g42, plot = FALSE)
  G1 &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  
  G2 &lt;- kplot(fou1, row.plab.cex = 0, psub.cex = 2)

} else {
  par(mfrow = c(2,2))
  scatter(fou1)
  s.traject(fou1$Tco, fou1$TC[, 1])
  s.traject(fou1$Tco, fou1$TC[, 2])
  s.label(fou1$Tco)
  s.label(fou1$co, add.p = TRUE, clab = 2)
  par(mfrow = c(1, 1))
  kplot(fou1, clab.c = 2, clab.r = 0, csub = 3)
}</code></pre>

<hr>
<h2 id='bicenter.wt'>Double Weighted Centring</h2><span id='topic+bicenter.wt'></span>

<h3>Description</h3>

<p>This function creates a doubly centred matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bicenter.wt(X, row.wt = rep(1, nrow(X)), col.wt = rep(1, ncol(X)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bicenter.wt_+3A_x">X</code></td>
<td>
<p>a matrix with n rows and p columns</p>
</td></tr>
<tr><td><code id="bicenter.wt_+3A_row.wt">row.wt</code></td>
<td>
<p>a vector of positive or null weights of length n</p>
</td></tr>
<tr><td><code id="bicenter.wt_+3A_col.wt">col.wt</code></td>
<td>
<p>a vector of positive or null weights of length p</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a doubly centred matrix
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- matrix(1:6, 3, 2)
bicenter.wt(w, c(0.2,0.6,0.2), c(0.3,0.7))

w &lt;- matrix(1:20, 5, 4)
sum(bicenter.wt(w, runif(5), runif(4))^2)
</code></pre>

<hr>
<h2 id='bordeaux'>Wine Tasting</h2><span id='topic+bordeaux'></span>

<h3>Description</h3>

<p>The <code>bordeaux</code> data frame gives the opinions of 200 judges in a blind tasting of five different types of claret 
(red wine from the Bordeaux area in the south western parts of France).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bordeaux)</code></pre>


<h3>Format</h3>

<p>This data frame has 5 rows (the wines) and 4 columns (the judgements) divided in excellent,
good, mediocre and boring.
</p>


<h3>Source</h3>

<p>van Rijckevorsel, J. (1987) <em>The application of fuzzy coding and horseshoes in multiple correspondence analysis</em>.
DSWO Press, Leiden (p. 32)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bordeaux)
bordeaux
score(dudi.coa(bordeaux, scan = FALSE))
</code></pre>

<hr>
<h2 id='bsetal97'>Ecological and Biological Traits</h2><span id='topic+bsetal97'></span>

<h3>Description</h3>

<p>This data set gives ecological and biological characteristics of 131 species of aquatic insects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bsetal97)</code></pre>


<h3>Format</h3>

<p><code>bsetal97</code> is a list of 8 components.<br />
</p>

<dl>
<dt>species.names</dt><dd><p>is a vector of the names of aquatic insects.</p>
</dd>
<dt>taxo</dt><dd><p>is a data frame containing the taxonomy of species: genus, family and order. </p>
</dd>
<dt>biol</dt><dd><p>is a data frame containing 10 biological traits for a total of 41 modalities. </p>
</dd>
<dt>biol.blo</dt><dd><p>is a vector of the numbers of items for each biological trait. </p>
</dd>
<dt>biol.blo.names</dt><dd><p>is a vector of the names of the biological traits. </p>
</dd>
<dt>ecol</dt><dd><p>is a data frame with 7 ecological traits for a total of 34 modalities. </p>
</dd>
<dt>ecol.blo</dt><dd><p>is a vector of the numbers of items for each ecological trait. </p>
</dd>
<dt>ecol.blo.names</dt><dd><p>is a vector of the names of the ecological traits. </p>
</dd>
</dl>



<h3>Details</h3>

<p>The 10 variables of the data frame <code>bsetal97$biol</code> are called in <code>bsetal97$biol.blo.names</code> 
and the number of modalities per variable given in <code>bsetal97$biol.blo</code>. The variables are:
female size - the body length from the front of the head to the end of the abdomen (7 length modalities),
egg length - the egg size (6 modalities), egg number - count of eggs actually oviposited, 
generations per year (3 modalities: <code class="reqn">\leq 1</code>, 2, &gt; 2), 
oviposition period - the length of time during which oviposition occurred (3 modalities: <code class="reqn">\leq 2</code> months, 
between 2 and 5 months, &gt; 5 months), incubation time - the time between oviposition and hatching of the larvae 
(3 modalities: <code class="reqn">\leq 4</code> weeks, between 4 and 12 weeks, &gt; 12 weeks), egg shape (1-spherical, 2-oval, 3-cylindrical),
egg attachment - physiological feature of the egg and of the female (4 modalities), clutch structure (1-single eggs, 2-grouped eggs, 
3-egg masses), clutch number (3 modalities : 1, 2, &gt; 2).
</p>
<p>The 7 variables of the data frame <code>bsetal97$ecol</code> are called in <code>bsetal97$ecol.blo.names</code> 
and the number of modalities per variable given in <code>bsetal97$ecol.blo</code>. The variables are:
oviposition site - position relative to the water (7 modalities), substratum type for eggs - the substratum to which 
the eggs are definitely attached (6 modalities), egg deposition - the position of the eggs during the oviposition process (4 modalities),
gross habitat - the general habitat use of the species such as temporary waters or estuaries (8 modalities), saturation variance -
the exposure of eggs to the risk of dessication (2 modalities), time of day  (1-morning, 2-day, 3-evening, 4-night), 
season -  time of the year (1-Spring, 2-Summer, 3-Automn).
</p>


<h3>Source</h3>

<p>Statzner, B., Hoppenhaus, K., Arens, M.-F. and Richoux, P. (1997) 
Reproductive traits, habitat use and templet theory: a synthesis of world-wide data on aquatic insects.
<em>Freshwater Biology</em>, <b>38</b>, 109&ndash;135.
</p>


<h3>References</h3>

<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps029.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps029.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bsetal97)
X &lt;- prep.fuzzy.var(bsetal97$biol, bsetal97$biol.blo)
Y &lt;- prep.fuzzy.var(bsetal97$ecol, bsetal97$ecol.blo)
plot(coinertia(dudi.fca(X, scan = FALSE), 
    dudi.fca(Y, scan = FALSE), scan = FALSE))
</code></pre>

<hr>
<h2 id='buech'>Buech basin</h2><span id='topic+buech'></span>

<h3>Description</h3>

<p>This data set contains informations about Buech basin characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(buech)</code></pre>


<h3>Format</h3>

<p><code>buech</code> is a list with the following components:
</p>

<dl>
<dt>tab1</dt><dd><p>a data frame with 10 environmental variables collected on 31 sites in Juin (1984)</p>
</dd>
<dt>tab2</dt><dd><p>a data frame with 10 environmental variables collected on 31 sites in September (1984)</p>
</dd>
<dt>xy</dt><dd><p>a data frame with the coordinates of the sites</p>
</dd>
<dt>neig</dt><dd><p>an object of class <code>neig</code></p>
</dd>
<dt>contour</dt><dd><p>a data frame for background map</p>
</dd>
<dt>nb</dt><dd><p>the neighbouring graph between sites, object of the class <code>nb</code></p>
</dd>
<dt>Spatial</dt><dd><p>an object of the class <code>SpatialPolygons</code> of <code>sp</code>,
containing the map</p>
</dd>
</dl>


<h3>Details</h3>

<p>Variables of <code>buech$tab1</code> and <code>buech$tab2</code> are the following ones:<br /> 
pH ; 
Conductivity (<code class="reqn">\mu</code> S/cm) ; 
Carbonate (water hardness (mg/l CaCO3)) ;
hardness (total water hardness (mg/l CaCO3)) ; 
Bicarbonate (alcalinity (mg/l HCO3-)) ;
Chloride (alcalinity (mg/l Cl-)) ; 
Suspens (particles in suspension (mg/l)) ;
Organic (organic particles (mg/l)) ; 
Nitrate (nitrate rate (mg/l NO3-)) ;
Ammonia (amoniac rate (mg/l NH4-))
</p>


<h3>Source</h3>

<p>Vespini, F. (1985) <em>Contribution à l'étude hydrobiologique du Buech, 
rivière non aménagée de Haute-Provence</em>. Thèse de troisième cycle, 
Université de Provence.
</p>
<p>Vespini, F., Légier, P. and Champeau, A. (1987) Ecologie d'une rivière non 
aménagée des Alpes du Sud : Le Buëch (France) I. Evolution longitudinale des 
descripteurs physiques et chimiques. 
<em>Annales de Limnologie</em>, <b>23</b>, 151&ndash;164.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(buech)
if(adegraphicsLoaded()) {
  if(requireNamespace("sp", quietly = TRUE)) {
    g1 &lt;- s.label(buech$xy, Sp = buech$Spatial, nb = buech$nb, 
      pSp.col = "transparent", plot = FALSE)
    g2 &lt;- s.value(buech$xy, buech$tab2$Suspens - buech$tab1$Suspens, 
      Sp = buech$Spatial, nb = buech$nb, pSp.col = "transparent", plot = FALSE)
    G &lt;- cbindADEg(g1, g2, plot = TRUE)
  }
} else {
  par(mfrow = c(1,2))
  s.label(buech$xy, contour = buech$contour, neig = buech$neig)
  s.value(buech$xy, buech$tab2$Suspens - buech$tab1$Suspens,
    contour = buech$contour, neig = buech$neig, csi = 3)
  par(mfrow = c(1,1))
}</code></pre>

<hr>
<h2 id='butterfly'>Genetics-Ecology-Environment Triple</h2><span id='topic+butterfly'></span>

<h3>Description</h3>

<p>This data set contains environmental and genetics informations about 16 
<em>Euphydryas editha</em> butterfly colonies studied in California and Oregon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(butterfly)</code></pre>


<h3>Format</h3>

<p><code>butterfly</code> is a list with the following components:
</p>

<dl>
<dt>xy</dt><dd><p>a data frame with the two coordinates of the 16 <em>Euphydryas 
editha</em> butterfly colonies</p>
</dd>
<dt>envir</dt><dd><p>a environmental data frame of  16 sites - 4 variables</p>
</dd>
<dt>genet</dt><dd><p>a genetics data frame of 16 sites - 6 allele frequencies</p>
</dd>
<dt>contour</dt><dd><p>a data frame for background map (California map)</p>
</dd>
<dt>Spatial</dt><dd><p>an object of the class <code>SpatialPolygons</code> of <code>sp</code>,
containing the map</p>
</dd>
</dl>


<h3>Source</h3>

<p>McKechnie, S.W., Ehrlich, P.R. and White, R.R. (1975). Population genetics of 
Euphydryas butterflies. I. Genetic variation and the neutrality hypothesis. 
<em>Genetics</em>, <b>81</b>, 571&ndash;594.
</p>


<h3>References</h3>

<p>Manly, B.F. (1994) <em>Multivariate Statistical Methods. A primer.</em>
Second edition. Chapman &amp; Hall, London. 1&ndash;215.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(butterfly)

if(adegraphicsLoaded()) {
  if(requireNamespace("sp", quietly = TRUE)) {
    g1 &lt;- s.label(butterfly$xy, Sp = butterfly$Spatial, pSp.col = "white", 
      porigin.include = FALSE, plot = FALSE)
    g2 &lt;- table.value(dist(butterfly$xy), plot = FALSE)
    g3 &lt;- s.value(butterfly$xy, dudi.pca(butterfly$envir, scan = FALSE)$li[, 1], 
      Sp = butterfly$Spatial, pori.inc = FALSE, pSp.col = "transparent", ppoints.cex = 2, 
        plot = FALSE)
    ## mt &lt;- mantel.randtest(dist(butterfly$xy), dist(butterfly$gen), 99)
    G &lt;- ADEgS(list(g1, g2, g3), layout = c(2, 2), plot = TRUE)
  }
} else {
  par(mfrow = c(2, 2))
  s.label(butterfly$xy, contour = butterfly$contour, inc = FALSE)
  table.dist(dist(butterfly$xy), labels = row.names(butterfly$xy)) # depends of mva
  s.value(butterfly$xy, dudi.pca(butterfly$envir, scan = FALSE)$li[,1], 
      contour = butterfly$contour, inc = FALSE, csi = 3)
  plot(mantel.randtest(dist(butterfly$xy), dist(butterfly$gen), 99),
      main = "genetic/spatial")
  par(mfrow = c(1,1))
}</code></pre>

<hr>
<h2 id='bwca.dpcoa'>
Between- and within-class double principal coordinate analysis
</h2><span id='topic+bwca.dpcoa'></span><span id='topic+bca.dpcoa'></span><span id='topic+wca.dpcoa'></span><span id='topic+randtest.betwit'></span><span id='topic+summary.betwit'></span><span id='topic+print.witdpcoa'></span><span id='topic+print.betdpcoa'></span>

<h3>Description</h3>

<p>These functions allow to study the variations in diversity among communities (as in dpcoa) taking into account a partition in classes 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwca.dpcoa(x, fac, cofac, scannf = TRUE, nf = 2, ...)
## S3 method for class 'dpcoa'
bca(x, fac, scannf = TRUE, nf = 2, ...) 
## S3 method for class 'dpcoa'
wca(x, fac, scannf = TRUE, nf = 2, ...) 
## S3 method for class 'betwit'
randtest(xtest, nrepet = 999, ...)
## S3 method for class 'betwit'
summary(object, ...)
## S3 method for class 'witdpcoa'
print(x, ...)
## S3 method for class 'betdpcoa'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwca.dpcoa_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+dpcoa">dpcoa</a></code></p>
</td></tr>
<tr><td><code id="bwca.dpcoa_+3A_fac">fac</code></td>
<td>
<p>a factor partitioning the collections in classes</p>
</td></tr>
<tr><td><code id="bwca.dpcoa_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues barplot should be displayed</p>
</td></tr>
<tr><td><code id="bwca.dpcoa_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, a numeric value indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="bwca.dpcoa_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="bwca.dpcoa_+3A_cofac">cofac</code></td>
<td>
<p>a cofactor partitioning the collections in classes used as a covariable</p>
</td></tr>
<tr><td><code id="bwca.dpcoa_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="bwca.dpcoa_+3A_xtest">xtest</code>, <code id="bwca.dpcoa_+3A_object">object</code></td>
<td>
<p>an object of class <code>betwit</code> created by a call to the function <code>bwca.dpcoa</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Objects of class <code>betdpcoa</code>, <code>witdpcoa</code> or <code>betwit</code>
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Dray, S., Pavoine, S. and Aguirre de Carcer, D. (2015) Considering external information to improve the phylogenetic comparison of microbial communities: a new approach based on constrained Double Principal Coordinates Analysis (cDPCoA). <em>Molecular Ecology Resources</em>, <b>15</b>, 242&ndash;249. doi:10.1111/1755-0998.12300
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpcoa">dpcoa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## First example of Dray et al (2015) paper

con &lt;- url("https://pbil.univ-lyon1.fr/datasets/dray/MER2014/soilmicrob.rda")
load(con)
close(con)

## Partial CCA
coa &lt;- dudi.coa(soilmicrob$OTU, scannf = FALSE)
wcoa &lt;- wca(coa, soilmicrob$env$pH, scannf = FALSE)
wbcoa &lt;- bca(wcoa,soilmicrob$env$VegType, scannf = FALSE)

## Classical DPCoA
dp &lt;- dpcoa(soilmicrob$OTU, soilmicrob$dphy, RaoDecomp = FALSE, scannf = FALSE)

## Between DPCoA (focus on the effect of vegetation type)
bdp &lt;- bca(dp, fac = soilmicrob$env$VegType , scannf = FALSE)
bdp$ratio ## 0.2148972
randtest(bdp) ## p = 0.001

## Within DPCoA (remove the effect of pH)
wdp &lt;- wca(dp, fac = soilmicrob$env$pH, scannf = FALSE)
wdp$ratio ## 0.5684348

## Between Within-DPCoA (remove the effect of pH and focus on vegetation type)
wbdp &lt;- bwca.dpcoa(dp, fac = soilmicrob$env$VegType, cofac =  soilmicrob$env$pH, scannf = FALSE)
wbdp$ratio ## 0.05452813
randtest(wbdp) ## p = 0.001

## End(Not run)
</code></pre>

<hr>
<h2 id='cailliez'>Transformation to make Euclidean a distance matrix</h2><span id='topic+cailliez'></span>

<h3>Description</h3>

<p>This function computes the smallest positive constant that makes Euclidean a distance matrix
and applies it. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cailliez(distmat, print = FALSE, tol = 1e-07, cor.zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cailliez_+3A_distmat">distmat</code></td>
<td>
<p>an object of class <code>dist</code></p>
</td></tr>
<tr><td><code id="cailliez_+3A_print">print</code></td>
<td>
<p>if TRUE, prints the eigenvalues of the matrix</p>
</td></tr>
<tr><td><code id="cailliez_+3A_tol">tol</code></td>
<td>
<p>a tolerance threshold for zero</p>
</td></tr>
<tr><td><code id="cailliez_+3A_cor.zero">cor.zero</code></td>
<td>
<p>if TRUE, zero distances are not modified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>dist</code> containing a Euclidean distance matrix.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Cailliez, F. (1983) The analytical solution of the additive constant problem. <em>Psychometrika</em>, <b>48</b>, 305&ndash;310.<br />
</p>
<p>Legendre, P. and Anderson, M.J. (1999) Distance-based redundancy analysis: testing multispecies responses in multifactorial ecological experiments. <em>Ecological Monographs</em>, <b>69</b>, 1&ndash;24.<br />
</p>
<p>Legendre, P., and Legendre, L. (1998) <em>Numerical ecology</em>, 2nd English edition edition. Elsevier Science BV, Amsterdam.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(capitales)
d0 &lt;- capitales$dist
is.euclid(d0) # FALSE
d1 &lt;- cailliez(d0, TRUE)
# Cailliez constant = 2429.87867 
is.euclid(d1) # TRUE
plot(d0, d1)
abline(lm(unclass(d1)~unclass(d0)))
print(coefficients(lm(unclass(d1)~unclass(d0))), dig = 8) # d1 = d + Cte
is.euclid(d0 + 2428) # FALSE
is.euclid(d0 + 2430) # TRUE the smallest constant
</code></pre>

<hr>
<h2 id='capitales'>Road Distances</h2><span id='topic+capitales'></span>

<h3>Description</h3>

<p>This data set gives the road distances between 15 European capitals and their
coordinates. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(capitales)</code></pre>


<h3>Format</h3>

<p><code>capitales</code> is a list with the following components:
</p>

<dl>
<dt>xy</dt><dd><p>a data frame containing the coordinates of capitals</p>
</dd>
<dt>area</dt><dd><p>a data frame containing three variables, designed to be used 
in area.plot function</p>
</dd>
<dt>logo</dt><dd><p>a list of pixmap objects, each one symbolizing a
capital</p>
</dd>
<dt>Spatial</dt><dd><p>an object of the class <code>SpatialPolygons</code> of <code>sp</code>,
containing the map</p>
</dd>
<dt>dist</dt><dd><p>a dist object the road distances between 15 European capitals</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(capitales)
attr(capitales$dist, "Labels")
index &lt;- pmatch(tolower(attr(capitales$dist, "Labels")), names(capitales$logo))
w1 &lt;- capitales$area

if(adegraphicsLoaded()) {
  if(requireNamespace("sp", quietly = TRUE)) {
    g1 &lt;- s.label(capitales$xy, lab = rownames(capitales$xy), porigin.include = FALSE, 
      plot = FALSE)
    g2 &lt;- s.logo(capitales$xy[sort(rownames(capitales$xy)), ], capitales$logo, 
      Sp = capitales$Spatial, pbackground.col = "lightblue", pSp.col = "white", pgrid.draw = FALSE, 
      plot = FALSE)
    g3 &lt;- table.value(capitales$dist, ptable.margin = list(b = 5, l = 5, t = 15, r = 15), 
      ptable.x.tck = 3, ptable.y.tck = 3, plot = FALSE)
    g4 &lt;- s.logo(pcoscaled(lingoes(capitales$dist)), capitales$logo[index], plot = FALSE) 
    
    G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  }
  
} else {
  if(requireNamespace("pixmap", quietly = TRUE)) {
    par(mfrow = c(2, 2))
    s.label(capitales$xy, lab = attr(capitales$dist, "Labels"), include.origin = FALSE)
    area.plot(w1)
  	rect(min(w1$x), min(w1$y), max(w1$x), max(w1$y), col = "lightblue")
  	invisible(lapply(split(w1, w1$id), function(x) polygon(x[, -1], col = "white")))
  	s.logo(capitales$xy, capitales$logo, klogo = index, add.plot = TRUE, 
  	 include.origin = FALSE, clogo = 0.5) # depends on pixmap
    table.dist(capitales$dist, lab = attr(capitales$dist, "Labels")) # depends on mva
    s.logo(pcoscaled(lingoes(capitales$dist)), capitales$logo, klogo = index, clogo = 0.5) 
      # depends on pixmap
    par(mfrow = c(1, 1))
  }
  }
</code></pre>

<hr>
<h2 id='carni19'>Phylogeny and quantative trait of carnivora</h2><span id='topic+carni19'></span>

<h3>Description</h3>

<p>This data set describes the phylogeny of carnivora as reported by Diniz-Filho et al. (1998). It also gives the body mass of these 19 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(carni19)</code></pre>


<h3>Format</h3>

<p><code>carni19</code> is a list containing the 2 following objects : 
</p>
     
<dl>
<dt>tre</dt><dd><p>is a character string giving the phylogenetic tree in Newick format.</p>
</dd> 
<dt>bm</dt><dd><p>is a numeric vector which values correspond to the body mass of the 19 species (log scale).</p>
</dd>
</dl>


<h3>Source</h3>

<p>Diniz-Filho, J. A. F., de Sant'Ana, C.E.R. and Bini, L.M. (1998) 
An eigenvector method for estimating phylogenetic inertia. <em>Evolution</em>, <b>52</b>, 1247&ndash;1262.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carni19)
carni19.phy &lt;- newick2phylog(carni19$tre)
par(mfrow = c(1,2))
symbols.phylog(carni19.phy,carni19$bm-mean(carni19$bm))
dotchart.phylog(carni19.phy, carni19$bm, clabel.l=0.75)
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='carni70'>Phylogeny and quantitative traits of carnivora</h2><span id='topic+carni70'></span>

<h3>Description</h3>

<p>This data set describes the phylogeny of 70 carnivora as reported by Diniz-Filho and Torres (2002). It also gives the geographic range size and body size corresponding to these 70 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(carni70)</code></pre>


<h3>Format</h3>

<p><code>carni70</code> is a list containing the 2 following objects: 
</p>

<dl>
<dt>tre</dt><dd><p>is a character string giving the phylogenetic tree in Newick format.
Branch lengths are expressed as divergence times (millions of years)</p>
</dd> 
<dt>tab</dt><dd><p>is a data frame with 70 species and two traits: size (body size (kg)) ; range (geographic range size (km)).</p>
</dd>    
</dl>


<h3>Source</h3>

<p>Diniz-Filho, J. A. F., and N. M. Tôrres. (2002) Phylogenetic comparative methods and the 
geographic range size-body size relationship in new world terrestrial carnivora. <em>Evolutionary Ecology</em>, <b>16</b>, 351&ndash;367.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (requireNamespace("adephylo", quietly = TRUE) &amp; requireNamespace("ape", quietly = TRUE)) {
  data(carni70)
  carni70.phy &lt;- newick2phylog(carni70$tre)
  plot(carni70.phy)
  
  size &lt;- scalewt(log(carni70$tab))[,1]
  names(size) &lt;- row.names(carni70$tab)
  symbols.phylog(carni70.phy,size)
  
  tre &lt;- ape::read.tree(text = carni70$tre)
  adephylo::orthogram(size, tre = tre)
  
  yrange &lt;- scalewt(carni70$tab[,2])
  names(yrange) &lt;- row.names(carni70$tab)
  symbols.phylog(carni70.phy,yrange)
  adephylo::orthogram(as.vector(yrange), tre = tre)
  
  if(adegraphicsLoaded()) {
    g1 &lt;- s.label(cbind.data.frame(size, yrange), plabel.cex = 0)
    g2 &lt;- addhist(g1)
  } else {
    s.hist(cbind.data.frame(size, yrange), clabel = 0)
  }
}
## End(Not run)</code></pre>

<hr>
<h2 id='carniherbi49'>Taxonomy, phylogenies and quantitative traits of carnivora and herbivora</h2><span id='topic+carniherbi49'></span>

<h3>Description</h3>

<p>This data set describes the taxonomic and phylogenetic relationships of 49 carnivora and herbivora species as reported by Garland and Janis (1993) and Garland et al. (1993). It also gives seven traits corresponding to these 49 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(carniherbi49)</code></pre>


<h3>Format</h3>

<p><code>carniherbi49</code> is a list containing the 5 following objects : 
</p>

<dl>
<dt>taxo</dt><dd><p>is a data frame with 49 species and 2 columns : 'fam', a factor family with 14 levels  
and 'ord', a factor order with 3 levels.</p>
</dd>
<dt>tre1</dt><dd><p>is a character string giving the phylogenetic tree in Newick format as reported by Garland et al. (1993).</p>
</dd>      
<dt>tre2</dt><dd><p>is a character string giving the phylogenetic tree in Newick format as reported by Garland and Janis (1993).</p>
</dd>      
<dt>tab1</dt><dd><p>is a data frame with 49 species and 2 traits: 'bodymass' (body mass (kg)) and 'homerange' (home range (km)).</p>
</dd>  
<dt>tab2</dt><dd><p>is a data frame with 49 species and 5 traits: 'clade' (dietary with two levels <code>Carnivore</code> 
and <code>Herbivore</code>), 'runningspeed' (maximal sprint running speed (km/h)), 'bodymass' (body mass (kg)),
'hindlength' (hind limb length (cm)) and 'mtfratio' (metatarsal/femur ratio).</p>
</dd>  
</dl>


<h3>Source</h3>

<p>Garland, T., Dickerman, A. W., Janis, C. M. and Jones, J. A. (1993) Phylogenetic analysis of covariance by computer simulation. 
<em>Systematics Biology</em>, <b>42</b>, 265&ndash;292. 
</p>
<p>Garland, T. J. and Janis, C.M. (1993) Does metatarsal-femur ratio predict maximal running speed in cursorial mammals? 
<em>Journal of Zoology</em>, <b>229</b>, 133&ndash;151.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(carniherbi49)
par(mfrow=c(1,3))
plot(newick2phylog(carniherbi49$tre1), clabel.leaves = 0,
 f.phylog = 2, sub ="article 1")
plot(newick2phylog(carniherbi49$tre2), clabel.leaves = 0,
 f.phylog = 2, sub = "article 2")
taxo &lt;- as.taxo(carniherbi49$taxo)
plot(taxo2phylog(taxo), clabel.nodes = 1.2, clabel.leaves = 1.2)
par(mfrow = c(1,1))

## End(Not run)</code></pre>

<hr>
<h2 id='casitas'>Enzymatic polymorphism in Mus musculus</h2><span id='topic+casitas'></span>

<h3>Description</h3>

<p>This data set is a data frame with 74 rows (mice) and 15 columns (loci enzymatic polymorphism of the DNA mitochondrial). 
Each value contains 6 characters coding for two allelles. The missing values are coding by '000000'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(casitas)</code></pre>


<h3>Format</h3>

<p>The 74 individuals of  <code>casitas</code> belong to 4 groups:
</p>

<dl>
<dt>1</dt><dd><p>24 mice of the sub-species <em>Mus musculus domesticus</em></p>
</dd>
<dt>2</dt><dd><p>11 mice of the sub-species <em>Mus musculus castaneus</em></p>
</dd>
<dt>3</dt><dd><p>9 mice of the sub-species <em>Mus musculus musculus</em></p>
</dd>
<dt>4</dt><dd><p>30 mice from a population of the lake Casitas (California)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Exemple du logiciel GENETIX.
Belkhir k. et al. GENETIX, logiciel sous WindowsTM pour la génétique des populations. 
Laboratoire Génome, Populations, Interactions CNRS UMR 5000, Université de Montpellier II, Montpellier (France). <br />
<a href="https://kimura.univ-montp2.fr/genetix/">https://kimura.univ-montp2.fr/genetix/</a>
</p>


<h3>References</h3>

<p>Orth, A., T. Adama, W. Din and F. Bonhomme. (1998) Hybridation naturelle entre deux sous espèces de souris domestique 
<em>Mus musculus domesticus</em> et <em>Mus musculus castaneus</em> près de Lake Casitas (Californie). <em>Genome</em>, <b>41</b>, 104&ndash;110.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(casitas)
str(casitas)
names(casitas)
</code></pre>

<hr>
<h2 id='chatcat'>Qualitative Weighted Variables</h2><span id='topic+chatcat'></span>

<h3>Description</h3>

<p>This data set gives the age, the fecundity and the number of litters for 26 groups of cats. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chatcat)</code></pre>


<h3>Format</h3>

<p><code>chatcat</code> is a list of two objects :
</p>

<dl>
<dt>tab</dt><dd><p>is a data frame with 3 factors (age, feco, nport). </p>
</dd>
<dt>eff</dt><dd><p>is a vector of numbers. </p>
</dd>
</dl>



<h3>Details</h3>

<p>One row of <code>tab</code> corresponds to one group of cats.<br />
The value in <code>eff</code> is the number of cats in this group.
</p>


<h3>Source</h3>

<p>Pontier, D. (1984)
<em>Contribution à la biologie et à la génétique des populations de chats domestiques (Felis catus).</em>
Thèse de 3ème cycle. Université Lyon 1, p. 67.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chatcat)
summary(chatcat$tab)
w &lt;- acm.disjonctif(chatcat$tab) #  Disjonctive table
names(w) &lt;- c(paste("A", 1:5, sep = ""), paste("B", 1:5, sep = ""), 
    paste("C", 1:2, sep = ""))
w &lt;- t(w*chatcat$num)
w &lt;- data.frame(w)
w # BURT table
</code></pre>

<hr>
<h2 id='chats'>Pair of Variables</h2><span id='topic+chats'></span>

<h3>Description</h3>

<p>This data set is a contingency table of age classes and fecundity classes of cats <em>Felis catus</em>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chats)</code></pre>


<h3>Format</h3>

<p><code>chats</code> is a data frame with 8 rows and 8 columns.<br />
The 8 rows are age classes (age1, ..., age8).<br />
The 8 columns are fecundity classes (f0, f12, f34, ..., fcd).<br />
The values are cats numbers (contingency table).
</p>


<h3>Source</h3>

<p>Legay, J.M. and Pontier, D. (1985)
Relation âge-fécondité dans les populations de Chats domestiques, Felis catus.
<em>Mammalia</em>, <b>49</b>, 395&ndash;402.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chats)
chatsw &lt;- as.table(t(chats))
chatscoa &lt;- dudi.coa(data.frame(t(chats)), scann = FALSE)

if(adegraphicsLoaded()) {
  g1 &lt;- table.value(chatsw, ppoints.cex = 1.3, meanX = TRUE, ablineX = TRUE, plabel.cex = 1.5, 
    plot = FALSE)
  g2 &lt;- table.value(chatsw, ppoints.cex = 1.3, meanY = TRUE, ablineY = TRUE, plabel.cex = 1.5, 
    plot = FALSE)
  g3 &lt;- table.value(chatsw, ppoints.cex = 1.3, coordsx = chatscoa$c1[,
  1], coordsy = chatscoa$l1[, 1], meanX = TRUE, ablineX = TRUE, plot = FALSE)
  g4 &lt;- table.value(chatsw, ppoints.cex = 1.3, meanY = TRUE, ablineY = TRUE, 
    coordsx = chatscoa$c1[, 1], coordsy = chatscoa$l1[, 1], plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))

} else {
  par(mfrow = c(2, 2))
  table.cont(chatsw, abmean.x = TRUE, csi = 2, abline.x = TRUE, clabel.r = 1.5, clabel.c = 1.5)
  table.cont(chatsw, abmean.y = TRUE, csi = 2, abline.y = TRUE, clabel.r = 1.5, clabel.c = 1.5)
  table.cont(chatsw, x = chatscoa$c1[, 1], y = chatscoa$l1[, 1], abmean.x = TRUE, csi = 2, 
    abline.x = TRUE, clabel.r = 1.5, clabel.c = 1.5)
  table.cont(chatsw, x = chatscoa$c1[, 1], y = chatscoa$l1[, 1], abmean.y = TRUE, csi = 2, 
    abline.y = TRUE, clabel.r = 1.5, clabel.c = 1.5)
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='chazeb'>Charolais-Zebus</h2><span id='topic+chazeb'></span>

<h3>Description</h3>

<p>This data set gives six different weights of 23 charolais and zebu oxen. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chazeb)</code></pre>


<h3>Format</h3>

<p><code>chazeb</code> is a list of 2 components.
</p>

<dl>
<dt>tab</dt><dd><p>is a data frame with 23 rows and 6 columns.</p>
</dd>
<dt>cla</dt><dd><p>is a factor with two levels &quot;cha&quot; and &quot;zeb&quot;. </p>
</dd>
</dl>



<h3>Source</h3>

<p>Tomassone, R., Danzard, M., Daudin, J. J. and Masson J. P.  (1988) 
<em>Discrimination et classement</em>, Masson, Paris. p. 43
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chazeb)
if(!adegraphicsLoaded())
  plot(discrimin(dudi.pca(chazeb$tab, scan = FALSE), 
    chazeb$cla, scan = FALSE))
</code></pre>

<hr>
<h2 id='chevaine'>Enzymatic polymorphism in Leuciscus cephalus</h2><span id='topic+chevaine'></span>

<h3>Description</h3>

<p>This data set contains a list of three components: spatial map, allellic profiles and sample sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chevaine)</code></pre>


<h3>Format</h3>

<p>This data set is a list of three components:
</p>

<dl>
<dt>tab</dt><dd><p> a data frame with 27 populations and 9 allelic frequencies (4 locus)</p>
</dd>
<dt>coo</dt><dd><p> a list containing all the elements to build a spatial map</p>
</dd>
<dt>eff</dt><dd><p> a numeric containing the numbers of fish samples per station</p>
</dd>
</dl>



<h3>References</h3>

<p>Guinand B., Bouvet Y. and Brohon B. (1996) Spatial aspects of genetic differentiation of the European 
chub in the Rhone River basin. <em>Journal of Fish Biology</em>, <b>49</b>, 714&ndash;726.
</p>
<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps054.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps054.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chevaine)
names(chevaine)
str(chevaine)
</code></pre>

<hr>
<h2 id='chickenk'>Veterinary epidemiological study to assess the risk factors for losses in broiler chickens</h2><span id='topic+chickenk'></span>

<h3>Description</h3>

<p>This data set contains information about potential risk factors for losses in broiler chickens</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chickenk)</code></pre>


<h3>Format</h3>

<p>A list with 5 components:
</p>

<dl>
<dt>mortality</dt><dd><p>a data frame with 351 observations and 4 variables which describe the losses (dependent dataset Y)</p>
</dd>
<dt>FarmStructure</dt><dd><p>a data frame with 351 observations and 5 variables which describe the farm structure (explanatory dataset)</p>
</dd>
<dt>OnFarmHistory</dt><dd><p>a data frame with 351 observations and 4 variables which describe the flock characteristics at placement (explanatory dataset)</p>
</dd>
<dt>FlockCharacteristics</dt><dd><p>a data frame with 351 observations and 6 variables which describe the flock characteristics during the rearing period (explanatory dataset)</p>
</dd>
<dt>CatchingTranspSlaught</dt><dd><p>a data frame with 351 observations and 5 variables which describe the transport, lairage conditions, slaughterhouse and inspection features (explanatory dataset)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Lupo C., le Bouquin S., Balaine L., Michel V., Peraste J., Petetin I., Colin P. and Chauvin C. (2009) Feasibility of screening broiler chicken flocks for risk markers as an aid for meat inspection. <em>Epidemiology and Infection</em>, 137, 1086-1098
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chickenk)
kta1 &lt;- ktab.list.df(chickenk)
</code></pre>

<hr>
<h2 id='clementines'>Fruit Production</h2><span id='topic+clementines'></span>

<h3>Description</h3>

<p>The <code>clementines</code> is a data set containing the fruit production of 20 clementine trees during 15 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(clementines)</code></pre>


<h3>Format</h3>

<p>A data frame with 15 rows and 20 columns
</p>


<h3>Source</h3>

<p>Tisné-Agostini, D. (1988) <em>Description par analyse en composantes principales de l'évolution de 
la production du clémentinier en association avec 12 types de porte-greffe</em>.
Rapport technique, DEA Analyse et modélisation des systèmes biologiques, Université Lyon 1. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(clementines)

op &lt;- par(no.readonly = TRUE) 
par(mfrow = c(5, 4))
par(mar = c(2, 2, 1, 1))
for(i in 1:20) {
  w0 &lt;- 1:15
  plot(w0, clementines[, i], type = "b")
  abline(lm(clementines[, i] ~ w0))
}
par(op)

pca1 &lt;- dudi.pca(clementines, scan = FALSE)
if(adegraphicsLoaded()) {
  g1 &lt;- s.corcircle(pca1$co, plab.cex = 0.75)
  g2 &lt;- s1d.barchart(pca1$li[, 1], p1d.hori = FALSE)
} else {
  s.corcircle(pca1$co, clab = 0.75)
  barplot(pca1$li[, 1])
}

op &lt;- par(no.readonly = TRUE) 
par(mfrow = c(5, 4))
par(mar = c(2, 2, 1, 1))
clem0 &lt;- pca1$tab
croi &lt;- 1:15
alter &lt;- c(rep(c(1, -1), 7), 1)
for(i in 1:20) {
  y &lt;- clem0[,i]
  plot(w0, y, type = "b", ylim = c(-2, 2))
  z &lt;- predict(lm(clem0[, i] ~ croi * alter))
  points(w0, z, pch = 20, cex = 2)
  for(j in 1:15)
    segments(j, y[j], j, z[j])
}
par(op)
par(mfrow = c(1, 1))
</code></pre>

<hr>
<h2 id='cnc2003'>Frequenting movie theaters in France in 2003</h2><span id='topic+cnc2003'></span>

<h3>Description</h3>

<p><code>cnc2003</code> is a data frame with 94 rows (94 departments from continental Metropolitan France)and 12 variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cnc2003)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following variables:
</p>

<dl>
<dt>popu</dt><dd><p>is the population department in million inhabitants. </p>
</dd>
<dt>entr</dt><dd><p>is the number of movie theater visitors in million. </p>
</dd>
<dt>rece</dt><dd><p>is the takings from ticket offices. </p>
</dd>
<dt>sean</dt><dd><p>is the number of proposed shows in thousands. </p>
</dd>
<dt>comm</dt><dd><p>is the number of equipped communes in movie theaters (units). </p>
</dd>
<dt>etab</dt><dd><p>is the number of active movie theaters (units). </p>
</dd>
<dt>salle</dt><dd><p>is the number of active screens. </p>
</dd>
<dt>faut</dt><dd><p>is the number of proposed seats. </p>
</dd>
<dt>artes</dt><dd><p>is the number of movie theaters offering &quot;Art and Essay&quot; movies. </p>
</dd>
<dt>multi</dt><dd><p>is the number of active multiplexes. </p>
</dd>
<dt>depart</dt><dd><p>is the name of the department. </p>
</dd>
<dt>reg</dt><dd><p>is the administrative region of the department. </p>
</dd>
</dl>



<h3>Source</h3>

<p>National Center of Cinematography (CNC), september 2003<br />
</p>


<h3>See Also</h3>

<p>This dataset is compatible with <code>elec88</code> and <code>presid2002</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cnc2003)
sco.quant(cnc2003$popu, cnc2003[,2:10], abline = TRUE, csub = 3)
</code></pre>

<hr>
<h2 id='coinertia'>Coinertia Analysis</h2><span id='topic+coinertia'></span><span id='topic+print.coinertia'></span><span id='topic+plot.coinertia'></span><span id='topic+summary.coinertia'></span>

<h3>Description</h3>

<p>The coinertia analysis performs a double inertia analysis of two tables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coinertia(dudiX, dudiY, scannf = TRUE, nf = 2)
## S3 method for class 'coinertia'
 plot(x, xax = 1, yax = 2, ...) 
## S3 method for class 'coinertia'
 print(x, ...) 
## S3 method for class 'coinertia'
 summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coinertia_+3A_dudix">dudiX</code></td>
<td>
<p>a duality diagram providing from one of the functions dudi.coa, dudi.pca, ...</p>
</td></tr>
<tr><td><code id="coinertia_+3A_dudiy">dudiY</code></td>
<td>
<p>a duality diagram providing from one of the functions dudi.coa, dudi.pca, ...</p>
</td></tr>
<tr><td><code id="coinertia_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="coinertia_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>
<p><br />
</p>
<table>
<tr><td><code id="coinertia_+3A_x">x</code>, <code id="coinertia_+3A_object">object</code></td>
<td>
<p>an object of class 'coinertia'</p>
</td></tr>
<tr><td><code id="coinertia_+3A_xax">xax</code>, <code id="coinertia_+3A_yax">yax</code></td>
<td>
<p>the numbers of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="coinertia_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class 'coinertia', sub-class 'dudi' containing:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>call</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>rank</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>a numeric value indicating the number of kept axes</p>
</td></tr>
<tr><td><code>RV</code></td>
<td>
<p>a numeric value, the RV coefficient</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a numeric vector with all the eigenvalues</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>a numeric vector with the rows weigths (crossed table)</p>
</td></tr>
<tr><td><code>cw</code></td>
<td>
<p>a numeric vector with the columns weigths (crossed table)</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p>a crossed table (CT)</p>
</td></tr> 
<tr><td><code>li</code></td>
<td>
<p>CT row scores (cols of dudiY)</p>
</td></tr>
<tr><td><code>l1</code></td>
<td>
<p>Principal components (loadings for cols of dudiY)</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>CT col scores (cols of dudiX)</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>Principal axes (cols of dudiX)</p>
</td></tr>
<tr><td><code>lX</code></td>
<td>
<p>Row scores (rows of dudiX)</p>
</td></tr>
<tr><td><code>mX</code></td>
<td>
<p>Normed row scores (rows of dudiX)</p>
</td></tr>
<tr><td><code>lY</code></td>
<td>
<p>Row scores (rows of dudiY)</p>
</td></tr>
<tr><td><code>mY</code></td>
<td>
<p>Normed row scores (rows of dudiY)</p>
</td></tr>
<tr><td><code>aX</code></td>
<td>
<p>Correlations between dudiX axes and coinertia axes</p>
</td></tr>
<tr><td><code>aY</code></td>
<td>
<p>Correlations between dudiY axes and coinertia axes</p>
</td></tr>
</table>


<h3>WARNING</h3>

<p>IMPORTANT : <code>dudi1</code> and <code>dudi2</code> must have identical row weights.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Dolédec, S. and Chessel, D. (1994) Co-inertia analysis: an alternative method for studying species-environment relationships. 
<em>Freshwater Biology</em>, <b>31</b>, 277&ndash;294.<br />
</p>
<p>Dray, S., Chessel, D. and J. Thioulouse (2003) Co-inertia analysis and the linking of the ecological data tables.
<em>Ecology</em>, <b>84</b>, 11, 3078&ndash;3089.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(doubs)
dudi1 &lt;- dudi.pca(doubs$env, scale = TRUE, scan = FALSE, nf = 3)
dudi2 &lt;- dudi.pca(doubs$fish, scale = FALSE, scan = FALSE, nf = 2)
coin1 &lt;- coinertia(dudi1,dudi2, scan = FALSE, nf = 2)
coin1
summary(coin1)

if(adegraphicsLoaded()) {
  g1 &lt;- s.arrow(coin1$l1, plab.cex = 0.7)
  g2 &lt;- s.arrow(coin1$c1, plab.cex = 0.7)
  g3 &lt;- s.corcircle(coin1$aX, plot = FALSE)
  g4 &lt;- s.corcircle(coin1$aY, plot = FALSE)
  cbindADEg(g3, g4, plot = TRUE)
  g5 &lt;- plot(coin1)
    
} else {
s.arrow(coin1$l1, clab = 0.7)
s.arrow(coin1$c1, clab = 0.7)
par(mfrow = c(1,2))
s.corcircle(coin1$aX)
s.corcircle(coin1$aY)
par(mfrow = c(1,1))
plot(coin1)
}</code></pre>

<hr>
<h2 id='coleo'>Table of Fuzzy Biological Traits </h2><span id='topic+coleo'></span>

<h3>Description</h3>

<p>This data set coleo (coleoptera) is a a fuzzy biological traits table.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coleo)</code></pre>


<h3>Format</h3>

<p><code>coleo</code> is a list of 5 components.
</p>

<dl>
<dt>tab</dt><dd><p>is a data frame with 110 rows (species) and 32 columns (categories).</p>
</dd>
<dt>species.names</dt><dd><p>is a vector of species names.</p>
</dd>
<dt>moda.names</dt><dd><p>is a vector of fuzzy variables names.</p>
</dd>
<dt>families</dt><dd><p>is a factor species family.</p>
</dd>
<dt>col.blocks</dt><dd><p>is a vector containing the number of categories of each trait.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Bournaud, M., Richoux, P. and Usseglio-Polatera, P. (1992)
An approach to the synthesis of qualitative ecological information from aquatic coleoptera communities.
<em>Regulated rivers: Research and Management</em>, <b>7</b>, 165&ndash;180.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coleo)
op &lt;- par(no.readonly = TRUE) 
coleo.fuzzy &lt;- prep.fuzzy.var(coleo$tab, coleo$col.blocks)
fca1 &lt;- dudi.fca(coleo.fuzzy, sca = FALSE, nf = 3)
indica &lt;- factor(rep(names(coleo$col), coleo$col))

if(adegraphicsLoaded()) {
  glist &lt;- list()
  for(i in levels(indica)) {
    df &lt;- coleo$tab[, which(indica == i)]
    names(df) &lt;- coleo$moda.names[which(indica == i)]
    glist[i] &lt;- s.distri(fca1$l1, df, psub.text = as.character(i), ellipseSize = 0, 
      starSize = 0.5, plot = FALSE, storeData = TRUE)
  }
  G &lt;- ADEgS(glist, layout = c(3, 3))
  
} else {
  par(mfrow = c(3, 3))
  for(j in levels(indica)) 
    s.distri(fca1$l1, coleo$tab[, which(indica == j)], clab = 1.5, sub = as.character(j), 
      cell = 0, csta = 0.5, csub = 3, label = coleo$moda.names[which(indica == j)])
  par(op)
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='combine.4thcorner'>Functions to combine and adjust the outputs 3-table methods</h2><span id='topic+combine.randtest.rlq'></span><span id='topic+combine.4thcorner'></span><span id='topic+p.adjust.4thcorner'></span>

<h3>Description</h3>

<p>Functions to combine and adjust the outputs of the <code>fourthcorner</code> and
<code>randtest.rlq</code> functions created using permutational models 2 and
4 (sequential approach).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.randtest.rlq(obj1, obj2, ...)
combine.4thcorner(four1,four2)
p.adjust.4thcorner(x, p.adjust.method.G = p.adjust.methods,
p.adjust.method.D = p.adjust.methods, p.adjust.D = c("global",
"levels"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.4thcorner_+3A_four1">four1</code></td>
<td>
<p> an object of the class 4thcorner created with
modeltype = 2 (or 4)</p>
</td></tr>
<tr><td><code id="combine.4thcorner_+3A_four2">four2</code></td>
<td>
<p> an object of the class 4thcorner created with
modeltype = 4 (or 2)</p>
</td></tr>
<tr><td><code id="combine.4thcorner_+3A_obj1">obj1</code></td>
<td>
<p>an object created with <code>randtest.rlq</code> and
modeltype = 2 (or 4)</p>
</td></tr>
<tr><td><code id="combine.4thcorner_+3A_obj2">obj2</code></td>
<td>
<p>an object  created with <code>randtest.rlq</code> and
modeltype = 4 (or 2)</p>
</td></tr>
<tr><td><code id="combine.4thcorner_+3A_x">x</code></td>
<td>
<p> an object of the class 4thcorner</p>
</td></tr>
<tr><td><code id="combine.4thcorner_+3A_p.adjust.method.g">p.adjust.method.G</code></td>
<td>
<p>a string indicating a method for multiple
adjustment used for output tabG, see <code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code> for possible choices</p>
</td></tr>
<tr><td><code id="combine.4thcorner_+3A_p.adjust.method.d">p.adjust.method.D</code></td>
<td>
<p>a string indicating a method for multiple
adjustment used for output tabD/tabD2, see <code>p.adjust.methods</code> for possible choices</p>
</td></tr>
<tr><td><code id="combine.4thcorner_+3A_p.adjust.d">p.adjust.D</code></td>
<td>
<p>a string indicating if multiple adjustment for
tabD/tabD2 should be done globally or only between levels of a factor
(&quot;levels&quot;, as in the original paper of Legendre et al. 1997)</p>
</td></tr>
<tr><td><code id="combine.4thcorner_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions combines the outputs of two objects (created by
<code>fourthcorner</code> and <code>randtest.rlq</code> functions) as described in
Dray and Legendre (2008) and ter Braak et al (2012).
</p>


<h3>Value</h3>

<p>The functions return objects of the same class than their
argument. They simply create a  new object where pvalues are equal to the
maximum of pvalues of the two arguments.
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a></p>


<h3>References</h3>

<p>Dray, S. and Legendre, P. (2008) 
Testing the species traits-environment relationships: the fourth-corner
problem revisited. <em>Ecology</em>,
<b>89</b>, 3400&ndash;3412.
</p>
<p>ter Braak, C., Cormont, A., and Dray, S. (2012)
Improved testing of species traits-environment relationships in the
fourth corner problem. <em>Ecology</em>, <b>93</b>, 1525&ndash;1526.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rlq">rlq</a></code>, <code><a href="#topic+fourthcorner">fourthcorner</a></code>, <code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aravo)
four2 &lt;- fourthcorner(aravo$env, aravo$spe, aravo$traits, nrepet=99,modeltype=2)
four4 &lt;- fourthcorner(aravo$env, aravo$spe, aravo$traits, nrepet=99,modeltype=4)
four.comb &lt;- combine.4thcorner(four2,four4)
## or directly :
## four.comb &lt;- fourthcorner(aravo$env, aravo$spe, aravo$traits, nrepet=99,modeltype=6)
summary(four.comb)
plot(four.comb, stat = "G")

</code></pre>

<hr>
<h2 id='corkdist'>Tests of randomization between distances applied to 'kdist' objetcs</h2><span id='topic+corkdist'></span><span id='topic+mantelkdist'></span><span id='topic+RVkdist'></span><span id='topic+print.corkdist'></span><span id='topic+summary.corkdist'></span><span id='topic+plot.corkdist'></span>

<h3>Description</h3>

<p>The mantelkdist and RVkdist functions apply to blocks of distance matrices the mantel.rtest and RV.rtest functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mantelkdist (kd, nrepet = 999, ...)
RVkdist (kd, nrepet = 999, ...)
## S3 method for class 'corkdist'
plot(x, whichinrow = NULL, whichincol = NULL, 
   gap = 4, nclass = 10,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corkdist_+3A_kd">kd</code></td>
<td>
<p>a list of class <code>kdist</code></p>
</td></tr>
<tr><td><code id="corkdist_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="corkdist_+3A_x">x</code></td>
<td>
<p>an objet of class <code>corkdist</code>, coming from RVkdist or mantelkdist</p>
</td></tr>
<tr><td><code id="corkdist_+3A_whichinrow">whichinrow</code></td>
<td>
<p>a vector of integers to select the graphs in rows (if NULL all the graphs are computed)</p>
</td></tr>
<tr><td><code id="corkdist_+3A_whichincol">whichincol</code></td>
<td>
<p>a vector of integers to select the graphs in columns (if NULL all the graphs are computed)</p>
</td></tr>
<tr><td><code id="corkdist_+3A_gap">gap</code></td>
<td>
<p>an integer to determinate the space between two graphs</p>
</td></tr>
<tr><td><code id="corkdist_+3A_nclass">nclass</code></td>
<td>
<p>a number of intervals for the histogram</p>
</td></tr>
<tr><td><code id="corkdist_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>corkdist</code> class has some generic functions <code>print</code>, <code>plot</code> and <code>summary</code>. The plot shows bivariate scatterplots between semi-matrices of distances or histograms of simulated values with an error position.
</p>


<h3>Value</h3>

<p>a list of class <code>corkdist</code> containing for each pair of distances an object of class <code>randtest</code> (permutation tests).
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(friday87)
fri.w &lt;- ktab.data.frame(friday87$fau, friday87$fau.blo, tabnames = friday87$tab.names)
fri.kc &lt;- lapply(1:10, function(x) dist.binary(fri.w[[x]], 10))
names(fri.kc) &lt;- substr(friday87$tab.names, 1, 4)
fri.kd &lt;- kdist(fri.kc)
fri.mantel &lt;- mantelkdist(kd = fri.kd, nrepet = 999)

plot(fri.mantel, 1:5, 1:5)
plot(fri.mantel, 1:5, 6:10)
plot(fri.mantel, 6:10, 1:5)
plot(fri.mantel, 6:10, 6:10)
s.corcircle(dudi.pca(as.data.frame(fri.kd), scan = FALSE)$co)
plot(RVkdist(fri.kd), 1:5, 1:5)

data(yanomama)
m1 &lt;- mantelkdist(kdist(yanomama), 999)
m1
summary(m1)
plot(m1)
</code></pre>

<hr>
<h2 id='corvus'>Corvus morphology</h2><span id='topic+corvus'></span>

<h3>Description</h3>

<p>This data set gives a morphological description of 28 species of the genus Corvus split in two habitat types and phylogeographic stocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(corvus)</code></pre>


<h3>Format</h3>

<p><code>corvus</code> is data frame with 28 observations (the species) and 4 variables : 
</p>

<dl>
<dt>wing</dt><dd><p>: wing length (mm)</p>
</dd>
<dt>bill</dt><dd><p>: bill length (mm)</p>
</dd>
<dt>habitat</dt><dd><p>: habitat with two levels <code>clos</code> and <code>open</code></p>
</dd>
<dt>phylog</dt><dd><p>: phylogeographic stock with three levels <code>amer</code>(America), <code>orien</code>(Oriental-Australian),
<code>pale</code>(Paleoarctic-African)</p>
</dd>
</dl>



<h3>References</h3>

<p>Laiolo, P. and Rolando, A. (2003) The evolution of vocalisations in the genus Corvus: effects of phylogeny, morphology and habitat. 
<em>Evolutionary Ecology</em>, <b>17</b>, 111&ndash;123.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(corvus)

if(adegraphicsLoaded()) {
  g1 &lt;- s.label(corvus[, 1:2], plab.cex = 0, porigin.include = FALSE, pgrid.draw = FALSE, 
    paxes.draw = TRUE, paxes.asp = "full", xlab = names(corvus)[2], 
    ylab = names(corvus)[2], plot = FALSE)
  g2 &lt;- s.class(corvus[, 1:2], corvus[, 4]:corvus[, 3], plot = FALSE)
  G &lt;- superpose(g1, g2, plot = TRUE)

} else {
  plot(corvus[, 1:2])
  s.class(corvus[, 1:2], corvus[, 4]:corvus[, 3], add.p = TRUE)
}
</code></pre>

<hr>
<h2 id='costatis'>STATIS and Co-Inertia : Analysis of a series of paired ecological tables</h2><span id='topic+costatis'></span>

<h3>Description</h3>

<p>Analysis of a series of pairs of ecological tables. This function uses
Partial Triadic Analysis (<a href="#topic+pta">pta</a>) and <a href="#topic+coinertia">coinertia</a>
to do the computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>costatis(KTX, KTY, scannf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="costatis_+3A_ktx">KTX</code></td>
<td>
<p>an objet of class ktab</p>
</td></tr>
<tr><td><code id="costatis_+3A_kty">KTY</code></td>
<td>
<p>an objet of class ktab</p>
</td></tr>
<tr><td><code id="costatis_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes 2 ktabs. It does a PTA (partial triadic analysis: <a href="#topic+pta">pta</a>) on each ktab, and does a coinertia analysis (<a href="#topic+coinertia">coinertia</a>) on the compromises of the two PTAs.
</p>


<h3>Value</h3>

<p>a list of class coinertia, subclass dudi. See <a href="#topic+coinertia">coinertia</a>
</p>


<h3>WARNING </h3>

<p>IMPORTANT : KTX and KTY must have the same k-tables structure, the same number
of columns, and the same column weights.
</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse <a href="mailto:Jean.Thioulouse@univ-lyon1.fr">Jean.Thioulouse@univ-lyon1.fr</a></p>


<h3>References</h3>

<p>Thioulouse J. (2011). Simultaneous analysis of a sequence of paired ecological tables: a comparison of several methods. <em>Annals of Applied Statistics</em>, <b>5</b>, 2300-2325.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meau)
wit1 &lt;- withinpca(meau$env, meau$design$season, scan = FALSE, scal = "total")
pcaspe &lt;- dudi.pca(meau$spe, scale = FALSE, scan = FALSE, nf = 2)
wit2 &lt;- wca(pcaspe, meau$design$season, scan = FALSE, nf = 2)
kta1 &lt;- ktab.within(wit1, colnames = rep(c("S1","S2","S3","S4","S5","S6"), 4))
kta2 &lt;- ktab.within(wit2, colnames = rep(c("S1","S2","S3","S4","S5","S6"), 4))
costatis1 &lt;- costatis(kta1, kta2, scan = FALSE)
plot(costatis1)
</code></pre>

<hr>
<h2 id='costatis.randtest'>Monte-Carlo test on a Costatis analysis (in C).</h2><span id='topic+costatis.randtest'></span>

<h3>Description</h3>

<p>Performs a Monte-Carlo test on a Costatis analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>costatis.randtest(KTX, KTY, nrepet = 999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="costatis.randtest_+3A_ktx">KTX</code></td>
<td>
<p>an objet of class ktab</p>
</td></tr>
<tr><td><code id="costatis.randtest_+3A_kty">KTY</code></td>
<td>
<p>an objet of class ktab</p>
</td></tr>
<tr><td><code id="costatis.randtest_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="costatis.randtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the class <code>randtest</code>
</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse <a href="mailto:Jean.Thioulouse@univ-lyon1.fr">Jean.Thioulouse@univ-lyon1.fr</a></p>


<h3>References</h3>

<p>Thioulouse J. (2011). Simultaneous analysis of a sequence of paired ecological tables: a comparison of several methods. <em>Annals of Applied Statistics</em>, <b>5</b>, 2300-2325.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meau)
wit1 &lt;- withinpca(meau$env, meau$design$season, scan = FALSE, scal = "total")
pcaspe &lt;- dudi.pca(meau$spe, scale = FALSE, scan = FALSE, nf = 2)
wit2 &lt;- wca(pcaspe, meau$design$season, scan = FALSE, nf = 2)
kta1 &lt;- ktab.within(wit1, colnames = rep(c("S1","S2","S3","S4","S5","S6"), 4))
kta2 &lt;- ktab.within(wit2, colnames = rep(c("S1","S2","S3","S4","S5","S6"), 4))
costatis1 &lt;- costatis(kta1, kta2, scan = FALSE)
costatis.randtest(kta1, kta2)
</code></pre>

<hr>
<h2 id='dagnelie.test'>Dagnelie multinormality test</h2><span id='topic+dagnelie.test'></span>

<h3>Description</h3>

<p>Compute Dagnelie test of multivariate normality on a data table of n objects (rows) and p variables (columns), with n &gt; (p+1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dagnelie.test(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dagnelie.test_+3A_x">x</code></td>
<td>
<p>Multivariate data table (<code>matrix</code> or <code>data.frame</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dagnelie's goodness-of-fit test of multivariate normality is applicable to 
multivariate data. Mahalanobis generalized distances are computed between each object and the multivariate centroid of all objects. Dagnelie’s approach is that, for multinormal data, the generalized distances should be normally distributed. The function computes a Shapiro-Wilk test of normality of the Mahalanobis distances; this is our improvement of Dagnelie’s method. 
The null hypothesis (H0) is that the data are multinormal, a situation where the Mahalanobis distances should be normally distributed. In that case, the test should not reject H0, subject to type I error at the selected significance level. <br />
</p>
<p>Numerical simulations by D. Borcard have shown that the test had correct levels of type I error for values of n between 3p and 8p, where n is the number of objects and p is the number of variables in the data 
matrix (simulations with 1 &lt;= p &lt;= 100). Outside that range of n values, the results were too liberal, meaning that the test rejected too often the null hypothesis of normality. For p = 2, the simulations showed the test to be valid for 6 &lt;= n &lt;= 13 and too liberal outside that range. If H0 is not rejected in a situation where the test is too liberal, the result is trustworthy.<br />
</p>
<p>Calculation of the Mahalanobis distances requires that n &gt; p+1 (actually, n &gt; rank+1). With fewer objects (n), all points are at equal Mahalanobis distances from the centroid in the resulting space, which has <code>min(rank,(n-1))</code> dimensions. For data matrices that happen to be collinear, the function uses <code>ginv</code> for inversion.<br />
</p>
<p>This test is not meant to be used with univariate data; in simulations, the type I error rate was higher than the 5% significance level for all values of n. Function <code>shapiro.test</code> should be used in that situation.
</p>


<h3>Value</h3>

<p>A list containing the following results: 
</p>
<table>
<tr><td><code>Shapiro.Wilk</code></td>
<td>
<p>W statistic and p-value</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>dimensions of the data matrix, n and p</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the rank of the covariance matrix</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Vector containing the Mahalanobis distances of the objects to the multivariate centroid</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Borcard and Pierre Legendre
</p>


<h3>References</h3>

<p>Dagnelie, P. 1975. L'analyse statistique a plusieurs variables. 
Les Presses agronomiques de Gembloux, Gembloux, Belgium.<br />
</p>
<p>Legendre, P. and L. Legendre. 2012. Numerical ecology, 3rd English
edition. Elsevier Science BV, Amsterdam, The Netherlands.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Example 1: 2 variables, n = 100
 n &lt;- 100; p &lt;- 2
 mat &lt;- matrix(rnorm(n*p), n, p)
 (out &lt;- dagnelie.test(mat))

 # Example 2: 10 variables, n = 50
 n &lt;- 50; p &lt;- 10
 mat &lt;- matrix(rnorm(n*p), n, p)
 (out &lt;- dagnelie.test(mat))

 # Example 3: 10 variables, n = 100
 n &lt;- 100; p &lt;- 10
 mat &lt;- matrix(rnorm(n*p), n, p)
 (out &lt;- dagnelie.test(mat))
 # Plot a histogram of the Mahalanobis distances
hist(out$D)

 # Example 4: 10 lognormal random variables, n = 50
 n &lt;- 50; p &lt;- 10
 mat &lt;- matrix(round(exp(rnorm((n*p), mean = 0, sd = 2.5))), n, p)
 (out &lt;- dagnelie.test(mat))
 # Plot a histogram of the Mahalanobis distances
 hist(out$D)

</code></pre>

<hr>
<h2 id='Deprecated+20functions'>Deprecated functions in ade4</h2><span id='topic+ade4-deprecated'></span>

<h3>Description</h3>

<p>The functions/data listed below are deprecated.
The R code of the deprecated functions are stored for memory in the file <code>ade4-deprecated.R</code>.
</p>
<p>- <code>between</code>: replaced by <code>bca</code> <br />
- <code>betweencoinertia</code>: replaced by <code>bca.coinertia</code> <br />
- <code>char2genet</code>: replaced by <code>df2genind</code> and <code>genind2genpop</code> in the <code>adegenet</code> package <br />
- <code>count2genet</code>: replaced by <code>df2genind</code> and <code>genind2genpop</code> in the <code>adegenet</code> package <br />
- <code>dist.genet</code>: replaced by <code>dist.genpop</code> in the <code>adegenet</code> package <br />
- <code>EH</code>: replaced by <code>EH</code> in the <code>adiv</code> package <br />
- <code>freq2genet</code>: replaced by <code>df2genind</code> and <code>genind2genpop</code> in the <code>adegenet</code> package <br />
- <code>fuzzygenet</code>: replaced by <code>df2genind</code> in the <code>adegenet</code> package <br />
- <code>optimEH</code>: replaced by <code>optimEH</code> in the <code>adiv</code> package <br />
- <code>orisaved</code>: replaced by <code>orisaved</code> in the <code>adiv</code> package <br />
- <code>orthogram</code>: replaced by <code>orthogram</code> in the <code>adephylo</code> package <br />
- <code>randEH</code>: replaced by <code>randEH</code> in the <code>adiv</code> package <br />
- <code>within</code>: replaced by <code>wca</code> <br />
- <code>withincoinertia</code>: replaced by <code>wca.coinertia</code> <br />
</p>

<hr>
<h2 id='deug'>Exam marks for some students</h2><span id='topic+deug'></span>

<h3>Description</h3>

<p>This data set gives the exam results of 104 students in the second year of a French University onto 9 subjects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(deug)</code></pre>


<h3>Format</h3>

<p><code>deug</code> is a list of three components.
</p>

<dl>
<dt>tab</dt><dd><p>is a data frame with 104 students and 9 subjects : Algebra, Analysis, Proba, Informatic, Economy,
Option1, Option2, English, Sport.</p>
</dd>
<dt>result</dt><dd><p>is a factor of 104 components giving the final exam levels (A+, A, B, B-, C-, D).</p>
</dd>
<dt>cent</dt><dd><p>is a vector of required marks by subject to get exactly 10/20 with a coefficient.</p>
</dd>
</dl>



<h3>Source</h3>

<p>University of Lyon 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deug)
# decentred PCA
pca1 &lt;- dudi.pca(deug$tab, scal = FALSE, center = deug$cent, scan = FALSE)
  
if(adegraphicsLoaded()) {
  g1 &lt;- s.class(pca1$li, deug$result, plot = FALSE)
  g2 &lt;- s.arrow(40 * pca1$c1, plot = FALSE)
  G &lt;- superpose(g1, g2, plot = TRUE)
  
} else {
  s.class(pca1$li, deug$result)
  s.arrow(40 * pca1$c1, add.plot = TRUE)
}
</code></pre>

<hr>
<h2 id='disc'>Rao's dissimilarity coefficient</h2><span id='topic+disc'></span>

<h3>Description</h3>

<p>Calculates the root square of Rao's dissimilarity coefficient between samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disc(samples, dis = NULL, structures = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disc_+3A_samples">samples</code></td>
<td>
<p>a data frame with elements as rows, samples as columns,
and abundance, presence-absence or frequencies as entries</p>
</td></tr>
<tr><td><code id="disc_+3A_dis">dis</code></td>
<td>
<p>an object of class <code>dist</code> containing distances or dissimilarities among elements.
If <code>dis</code> is NULL, equidistances are used.</p>
</td></tr>
<tr><td><code id="disc_+3A_structures">structures</code></td>
<td>
<p>a data frame containing, in the jth row and the kth column,
the name of the group of level k to which the jth population belongs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of objects of class <code>dist</code>
</p>


<h3>Author(s)</h3>

<p>Sandrine Pavoine <a href="mailto:pavoine@mnhn.fr">pavoine@mnhn.fr</a>
</p>


<h3>References</h3>

<p>Rao, C.R. (1982) Diversity and dissimilarity coefficients: a unified approach.
<em>Theoretical Population Biology</em>, <b>21</b>, 24&ndash;43.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humDNAm)
humDNA.dist &lt;- disc(humDNAm$samples, sqrt(humDNAm$distances), humDNAm$structures)
humDNA.dist
is.euclid(humDNA.dist$samples)
is.euclid(humDNA.dist$regions)

## Not run: 
data(ecomor)
dtaxo &lt;- dist.taxo(ecomor$taxo)
ecomor.dist &lt;- disc(ecomor$habitat, dtaxo)
ecomor.dist
is.euclid(ecomor.dist)

## End(Not run)
</code></pre>

<hr>
<h2 id='discrimin'>Linear Discriminant Analysis (descriptive statistic)</h2><span id='topic+discrimin'></span><span id='topic+plot.discrimin'></span><span id='topic+print.discrimin'></span>

<h3>Description</h3>

<p>performs a linear discriminant analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrimin(dudi, fac, scannf = TRUE, nf = 2)
## S3 method for class 'discrimin'
plot(x, xax = 1, yax = 2, ...) 
## S3 method for class 'discrimin'
print(x, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrimin_+3A_dudi">dudi</code></td>
<td>
<p>a duality diagram, object of class <code>dudi</code></p>
</td></tr>
<tr><td><code id="discrimin_+3A_fac">fac</code></td>
<td>
<p>a factor defining the classes of discriminant analysis</p>
</td></tr>
<tr><td><code id="discrimin_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="discrimin_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>
<p><br />
</p>
<table>
<tr><td><code id="discrimin_+3A_x">x</code></td>
<td>
<p>an object of class 'discrimin'</p>
</td></tr>
<tr><td><code id="discrimin_+3A_xax">xax</code></td>
<td>
<p>the column number of the x-axis</p>
</td></tr>
<tr><td><code id="discrimin_+3A_yax">yax</code></td>
<td>
<p>the column number of the y-axis</p>
</td></tr>
<tr><td><code id="discrimin_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class 'discrimin' containing :
</p>
<table>
<tr><td><code>nf</code></td>
<td>
<p>a numeric value indicating the number of kept axes</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a numeric vector with all the eigenvalues</p>
</td></tr>
<tr><td><code>fa</code></td>
<td>
<p>a matrix with the loadings: the canonical weights</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>a data frame which gives the canonical scores</p>
</td></tr>
<tr><td><code>va</code></td>
<td>
<p>a matrix which gives the cosines between the variables and the canonical scores</p>
</td></tr>
<tr><td><code>cp</code></td>
<td>
<p>a matrix which gives the cosines between the components and the canonical scores</p>
</td></tr>
<tr><td><code>gc</code></td>
<td>
<p>a data frame which gives the class scores</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>See Also</h3>

<p><code>lda</code> in package <code>MASS</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chazeb)
dis1 &lt;- discrimin(dudi.pca(chazeb$tab, scan = FALSE), chazeb$cla, 
    scan = FALSE)
dis1
if(!adegraphicsLoaded())
  plot(dis1)

data(skulls)
plot(discrimin(dudi.pca(skulls, scan = FALSE), gl(5,30), 
    scan = FALSE))
</code></pre>

<hr>
<h2 id='discrimin.coa'>Discriminant Correspondence Analysis
</h2><span id='topic+discrimin.coa'></span>

<h3>Description</h3>

<p>performs a discriminant correspondence analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrimin.coa(df, fac, scannf = TRUE, nf = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrimin.coa_+3A_df">df</code></td>
<td>
<p>a data frame containing positive or null values</p>
</td></tr>
<tr><td><code id="discrimin.coa_+3A_fac">fac</code></td>
<td>
<p>a factor defining the classes of discriminant analysis</p>
</td></tr>
<tr><td><code id="discrimin.coa_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="discrimin.coa_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class <code>discrimin</code>. See <code><a href="#topic+discrimin">discrimin</a></code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Perriere, G.,Lobry,  J. R.  and Thioulouse J. (1996) Correspondence discriminant analysis: a multivariate method for comparing 
classes of protein and nucleic acid sequences. <em>CABIOS</em>, <b>12</b>, 519&ndash;524.<br />
</p>
<p>Perriere, G. and Thioulouse, J. (2003) Use of Correspondence Discriminant Analysis to predict the subcellular location of bacterial proteins. 
<em>Computer Methods and Programs in Biomedicine</em>, <b>70</b>, 2, 99&ndash;105.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(perthi02)
plot(discrimin.coa(perthi02$tab, perthi02$cla, scan = FALSE))
</code></pre>

<hr>
<h2 id='dist.binary'>Computation of Distance Matrices for Binary Data</h2><span id='topic+dist.binary'></span>

<h3>Description</h3>

<p>computes for binary data some distance matrice. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.binary(df, method = NULL, diag = FALSE, upper = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.binary_+3A_df">df</code></td>
<td>
<p>a matrix or a data frame with positive or null numeric values. Used with <code>as.matrix(1 * (df &gt; 0))</code></p>
</td></tr>
<tr><td><code id="dist.binary_+3A_method">method</code></td>
<td>
<p>an integer between 1 and 10 . If NULL the choice is made with a console message. See details</p>
</td></tr>
<tr><td><code id="dist.binary_+3A_diag">diag</code></td>
<td>
<p>a logical value indicating whether the diagonal of the distance matrix should be printed by &lsquo;print.dist&rsquo;</p>
</td></tr>
<tr><td><code id="dist.binary_+3A_upper">upper</code></td>
<td>
<p>a logical value indicating whether the upper triangle of the distance matrix should be printed by &lsquo;print.dist&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let be the contingency table of binary data such as <code class="reqn">n_{11} = a</code>, <code class="reqn">n_{10} = b</code>, <code class="reqn">n_{01} = c</code> 
and <code class="reqn">n_{00} = d</code>. All these distances are of type <code class="reqn">d=\sqrt{1-s}</code> with <em>s</em> a similarity coefficient.
</p>

<dl>
<dt>1 = Jaccard index (1901)</dt><dd><p>S3 coefficient of Gower &amp; Legendre <code class="reqn">s_1 = \frac{a}{a+b+c}</code></p>
</dd>
<dt>2 = Simple matching coefficient of Sokal &amp; Michener (1958)</dt><dd><p>S4 coefficient of Gower &amp; Legendre <code class="reqn">s_2 =\frac{a+d}{a+b+c+d}</code></p>
</dd>
<dt>3 = Sokal &amp; Sneath(1963)</dt><dd><p>S5 coefficient of Gower &amp; Legendre <code class="reqn">s_3 =\frac{a}{a+2(b+c)}</code></p>
</dd>
<dt>4 = Rogers &amp; Tanimoto (1960)</dt><dd><p>S6 coefficient of Gower &amp; Legendre <code class="reqn">s_4 =\frac{a+d}{(a+2(b+c)+d)}</code></p>
</dd>
<dt>5 = Dice (1945) or Sorensen (1948)</dt><dd><p>S7 coefficient of Gower &amp; Legendre <code class="reqn">s_5 =\frac{2a}{2a+b+c}</code></p>
</dd>
<dt>6 = Hamann coefficient</dt><dd><p>S9 index of Gower &amp; Legendre (1986) <code class="reqn">s_6 =\frac{a-(b+c)+d}{a+b+c+d}</code></p>
</dd>
<dt>7 = Ochiai (1957)</dt><dd><p>S12 coefficient of Gower &amp; Legendre <code class="reqn">s_7 =\frac{a}{\sqrt{(a+b)(a+c)}}</code></p>
</dd>
<dt>8 = Sokal &amp; Sneath (1963)</dt><dd><p>S13 coefficient of Gower &amp; Legendre <code class="reqn">s_8 =\frac{ad}{\sqrt{(a+b)(a+c)(d+b)(d+c)}}</code></p>
</dd>
<dt>9 = Phi of Pearson</dt><dd><p>S14 coefficient of Gower &amp; Legendre <code class="reqn">s_9 =\frac{ad-bc}{\sqrt{(a+b)(a+c)(b+d)(d+c)}}</code></p>
</dd>
<dt>10 = S2 coefficient of Gower &amp; Legendre</dt><dd><p><code class="reqn">s_1 = \frac{a}{a+b+c+d}</code></p>
</dd>
</dl>



<h3>Value</h3>

<p>returns a distance matrix of class <code>dist</code> between the rows of the data frame
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Gower, J.C. and Legendre, P. (1986) Metric and Euclidean properties of dissimilarity coefficients. 
<em>Journal of Classification</em>, <b>3</b>, 5&ndash;48.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aviurba)
for (i in 1:10) {
    d &lt;- dist.binary(aviurba$fau, method = i)
    cat(attr(d, "method"), is.euclid(d), "\n")}
</code></pre>

<hr>
<h2 id='dist.dudi'>Computation of the Distance Matrix from a Statistical Triplet
</h2><span id='topic+dist.dudi'></span>

<h3>Description</h3>

<p>computes for a statistical triplet a distance matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.dudi(dudi, amongrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.dudi_+3A_dudi">dudi</code></td>
<td>
<p>a duality diagram, object of class <code>dudi</code></p>
</td></tr>
<tr><td><code id="dist.dudi_+3A_amongrow">amongrow</code></td>
<td>
<p>a logical value computing the distance if TRUE, between rows, if FALSE between columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>dist</code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data (meaudret)
pca1 &lt;- dudi.pca(meaudret$env, scan = FALSE)
sum((dist(scalewt(meaudret$env)) - dist.dudi(pca1))^2)
#[1] 4.045e-29 the same thing
</code></pre>

<hr>
<h2 id='dist.ktab'>Mixed-variables coefficient of distance</h2><span id='topic+dist.ktab'></span><span id='topic+prep.binary'></span><span id='topic+prep.circular'></span><span id='topic+prep.fuzzy'></span><span id='topic+ldist.ktab'></span><span id='topic+kdist.cor'></span>

<h3>Description</h3>

<p>The mixed-variables coefficient of distance generalizes Gower's general coefficient of distance 
to allow the treatment of various statistical types of variables when calculating distances.
This is especially important when measuring functional diversity. Indeed, most of the indices that
measure functional diversity depend on variables (traits) that have various statistical types (e.g. circular, 
fuzzy, ordinal) and that go through a matrix of distances among species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.ktab(x, type, option = c("scaledBYrange", "scaledBYsd", "noscale"),
scann = FALSE, tol = 1e-8)
ldist.ktab(x, type, option = c("scaledBYrange", "scaledBYsd",
"noscale"), scann = FALSE, tol = 1e-8)
kdist.cor(x, type, option = c("scaledBYrange", "scaledBYsd", "noscale"),
scann = FALSE, tol = 1e-8, squared = TRUE)
prep.fuzzy(df, col.blocks, row.w = rep(1, nrow(df)), labels = paste("F",
1:length(col.blocks), sep = ""))
prep.binary(df, col.blocks, labels = paste("B", 1:length(col.blocks), sep = "")) 
prep.circular(df, rangemin = apply(df, 2, min, na.rm = TRUE), rangemax =
apply(df, 2, max, na.rm = TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.ktab_+3A_x">x</code></td>
<td>
<p>Object of class <code>ktab</code> (see details)</p>
</td></tr>
<tr><td><code id="dist.ktab_+3A_type">type</code></td>
<td>
<p>Vector that provide the type of each table in x. The possible types are &quot;Q&quot;
(quantitative), &quot;O&quot; (ordinal), &quot;N&quot; (nominal), &quot;D&quot; (dichotomous), &quot;F&quot; (fuzzy, or
expressed as a proportion), &quot;B&quot; (multichoice nominal variables, coded by
binary columns), &quot;C&quot; (circular). Values in type must be in the same order as in x.</p>
</td></tr>
<tr><td><code id="dist.ktab_+3A_option">option</code></td>
<td>
<p>A string that can have three values: either &quot;scaledBYrange&quot; if the
quantitative variables must be scaled by their range, or &quot;scaledBYsd&quot; if they
must be scaled by their standard deviation, or &quot;noscale&quot; if they should not be
scaled. This last option can be useful if the the values have already been
normalized by the known range of the whole population instead of the
observed range measured on the sample. If x contains data from various types,
then the option &quot;scaledBYsd&quot; is not suitable (a warning will appear if the option selected with that condition).</p>
</td></tr>
<tr><td><code id="dist.ktab_+3A_scann">scann</code></td>
<td>
<p>A logical. If TRUE, then the user will have to choose among several possible
functions of distances for the quantitative, ordinal, fuzzy and binary variables.</p>
</td></tr>
<tr><td><code id="dist.ktab_+3A_tol">tol</code></td>
<td>
<p>A tolerance threshold: a value less than tol is considered as
null.</p>
</td></tr>
<tr><td><code id="dist.ktab_+3A_squared">squared</code></td>
<td>
<p>A logical, if TRUE, the squared distances are considered.</p>
</td></tr>
<tr><td><code id="dist.ktab_+3A_df">df</code></td>
<td>
<p>Objet of class data.frame</p>
</td></tr>
<tr><td><code id="dist.ktab_+3A_col.blocks">col.blocks</code></td>
<td>
<p>A vector that contains the number of levels per variable (in the same order
as in <code>df</code>)</p>
</td></tr>
<tr><td><code id="dist.ktab_+3A_row.w">row.w</code></td>
<td>
<p>A vector of row weigths</p>
</td></tr>
<tr><td><code id="dist.ktab_+3A_labels">labels</code></td>
<td>
<p>the names of the traits</p>
</td></tr>
<tr><td><code id="dist.ktab_+3A_rangemin">rangemin</code></td>
<td>
<p>A numeric corresponding to the smallest level where the loop starts</p>
</td></tr>
<tr><td><code id="dist.ktab_+3A_rangemax">rangemax</code></td>
<td>
<p>A numeric corresponding to the highest level where the loop closes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When preparing the object of class <code>ktab</code> (object x), variables of type &quot;Q&quot;, &quot;O&quot;, &quot;D&quot;, &quot;F&quot;, &quot;B&quot; and &quot;C&quot; should be of class <code>numeric</code> (the class <code>ordered</code> is not yet considered by <code>dist.ktab</code>); variables of type &quot;N&quot; should be of class <code>character</code> or <code>factor</code>
</p>


<h3>Value</h3>

<p>The functions provide the following results: 
</p>
<table>
<tr><td><code>dist.ktab</code></td>
<td>
<p>returns an object of class <code>dist</code>;</p>
</td></tr>
<tr><td><code>ldist.ktab</code></td>
<td>
<p>returns a list of objects of class <code>dist</code> that correspond to the distances between species calculated per trait;</p>
</td></tr>
<tr><td><code>kdist.cor</code></td>
<td>
<p>returns a list of three objects: &quot;paircov&quot; provides the covariance 
between traits in terms of (squared) distances between species;
&quot;paircor&quot; provides the correlations between traits in terms of (squared) distances between species;
&quot;glocor&quot; provides the correlations between the (squared) distances obtained for each trait and the global (squared) distances
obtained by mixing all the traits (= contributions of traits to the global distances);</p>
</td></tr>
<tr><td><code>prep.binary and prep.fuzzy</code></td>
<td>
<p>returns a data frame with the following attributes: col.blocks
specifies the number of columns per fuzzy variable; col.num specifies which variable
each column belongs to;</p>
</td></tr>
<tr><td><code>prep.circular</code></td>
<td>
<p>returns a data frame with the following attributes: max specifies the number
of levels in each circular variable.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sandrine Pavoine <a href="mailto:pavoine@mnhn.fr">pavoine@mnhn.fr</a>
</p>


<h3>References</h3>

<p>Pavoine S., Vallet, J., Dufour, A.-B., Gachet, S. and Daniel, H. (2009) 
On the challenge of treating various types of variables: 
Application for improving the measurement of functional diversity. <em>Oikos</em>, <b>118</b>, 391&ndash;402. <a href="https://doi.org/10.1111/j.1600-0706.2008.16668.x">doi:10.1111/j.1600-0706.2008.16668.x</a>
</p>
<p>Appendix available at: 
<a href="http://www.oikosjournal.org/sites/oikosjournal.org/files/appendix/o16668.pdf">http://www.oikosjournal.org/sites/oikosjournal.org/files/appendix/o16668.pdf</a>
<a href="http://www.oikosjournal.org/sites/oikosjournal.org/files/appendix/o16668_files.zip">http://www.oikosjournal.org/sites/oikosjournal.org/files/appendix/o16668_files.zip</a>
</p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+daisy">daisy</a></code> in the case of ratio-scale (quantitative) and nominal variables;
and <code><a href="#topic+woangers">woangers</a></code> for an application.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># With fuzzy variables
data(bsetal97)

w &lt;- prep.fuzzy(bsetal97$biol, bsetal97$biol.blo)
w[1:6, 1:10]
ktab1 &lt;- ktab.list.df(list(w))
dis &lt;- dist.ktab(ktab1, type = "F")
as.matrix(dis)[1:5, 1:5]

## Not run: 
# With ratio-scale and multichoice variables
data(ecomor)

wM &lt;- log(ecomor$morpho + 1) # Quantitative variables
wD &lt;- ecomor$diet
# wD is a data frame containing a multichoice nominal variable
# (diet habit), with 8 modalities (Granivorous, etc)
# We must prepare it by prep.binary
head(wD)
wD &lt;- prep.binary(wD, col.blocks = 8, label = "diet")
wF &lt;- ecomor$forsub
# wF is also a data frame containing a multichoice nominal variable
# (foraging substrat), with 6 modalities (Foliage, etc)
# We must prepare it by prep.binary
head(wF)
wF &lt;- prep.binary(wF, col.blocks = 6, label = "foraging")
# Another possibility is to combine the two last data frames wD and wF as
# they contain the same type of variables
wB &lt;- cbind.data.frame(ecomor$diet, ecomor$forsub)
head(wB)
wB &lt;- prep.binary(wB, col.blocks = c(8, 6), label = c("diet", "foraging"))
# The results given by the two alternatives are identical
ktab2 &lt;- ktab.list.df(list(wM, wD, wF))
disecomor &lt;- dist.ktab(ktab2, type= c("Q", "B", "B"))
as.matrix(disecomor)[1:5, 1:5]
contrib2 &lt;- kdist.cor(ktab2, type= c("Q", "B", "B"))
contrib2

ktab3 &lt;- ktab.list.df(list(wM, wB))
disecomor2 &lt;- dist.ktab(ktab3, type= c("Q", "B"))
as.matrix(disecomor2)[1:5, 1:5]
contrib3 &lt;- kdist.cor(ktab3, type= c("Q", "B"))
contrib3

# With a range of variables
data(woangers)

traits &lt;- woangers$traits
# Nominal variables 'li', 'pr', 'lp' and 'le'
# (see table 1 in the main text for the codes of the variables)
tabN &lt;- traits[,c(1:2, 7, 8)]
# Circular variable 'fo'
tabC &lt;- traits[3]
tabCp &lt;- prep.circular(tabC, 1, 12)
# The levels of the variable lie between 1 (January) and 12 (December).
# Ordinal variables 'he', 'ae' and 'un'
tabO &lt;- traits[, 4:6]
# Fuzzy variables 'mp', 'pe' and 'di'
tabF &lt;- traits[, 9:19]
tabFp &lt;- prep.fuzzy(tabF, c(3, 3, 5), labels = c("mp", "pe", "di"))
# 'mp' has 3 levels, 'pe' has 3 levels and 'di' has 5 levels.
# Quantitative variables 'lo' and 'lf'
tabQ &lt;- traits[, 20:21]
ktab1 &lt;- ktab.list.df(list(tabN, tabCp, tabO, tabFp, tabQ))
distrait &lt;- dist.ktab(ktab1, c("N", "C", "O", "F", "Q"))
is.euclid(distrait)
contrib &lt;- kdist.cor(ktab1, type = c("N", "C", "O", "F", "Q"))
contrib
dotchart(sort(contrib$glocor), labels = rownames(contrib$glocor)[order(contrib$glocor[, 1])])

## End(Not run)
</code></pre>

<hr>
<h2 id='dist.neig'>Computation of the Distance Matrix associated to a Neighbouring Graph
</h2><span id='topic+dist.neig'></span>

<h3>Description</h3>

<p>This distance matrix  between two points is the length of the shortest path between
these points. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.neig(neig)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.neig_+3A_neig">neig</code></td>
<td>
<p>a neighbouring graph, object of class <code>neig</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a distance matrix, object of class <code>dist</code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(elec88)
    d0 &lt;- dist.neig(elec88$neig)
    plot(dist(elec88$xy),d0)
</code></pre>

<hr>
<h2 id='dist.prop'>Computation of Distance Matrices of Percentage Data
</h2><span id='topic+dist.prop'></span>

<h3>Description</h3>

<p>computes for percentage data some distance matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.prop(df, method = NULL, diag = FALSE, upper = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.prop_+3A_df">df</code></td>
<td>
<p>a data frame containing only positive or null values, used as row percentages</p>
</td></tr>
<tr><td><code id="dist.prop_+3A_method">method</code></td>
<td>
<p>an integer between 1 and 5. If NULL the choice is made with a console message. See details</p>
</td></tr>
<tr><td><code id="dist.prop_+3A_diag">diag</code></td>
<td>
<p>a logical value indicating whether the diagonal of the distance matrix should be printed by &lsquo;print.dist&rsquo;</p>
</td></tr>
<tr><td><code id="dist.prop_+3A_upper">upper</code></td>
<td>
<p>a logical value indicating whether the upper triangle of the distance matrix should be printed by &lsquo;print.dist&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>1 = Manly</dt><dd><p><code class="reqn">d_1=\frac{1}{2} \sum_{i=1}^{K}{|{p_i-q_i}|}</code></p>
</dd>
<dt>2 = Overlap index Manly</dt><dd><p><code class="reqn">d_2=1-\frac{\sum_{i=1}^{K}{p_i q_i}}{\sqrt{\sum_{i=1}^{K}{p_i^2}}{\sqrt{\sum_{i=1}^{K}{q_i^2}}}}</code></p>
</dd>
<dt>3 = Rogers 1972 (one locus)</dt><dd><p><code class="reqn">d_3=\sqrt{\frac{1}{2} \sum_{i=1}^{K}{(p_i-q_i)^2}}</code></p>
</dd>
<dt>4 = Nei 1972 (one locus)</dt><dd><p><code class="reqn">d_4=\ln{\frac{\sum_{i=1}^{K}{p_i q_i}}{\sqrt{\sum_{i=1}^{K}{p_i^2}}{\sqrt{\sum_{i=1}^{K}{q_i^2}}}}}</code></p>
</dd>
<dt>5 = Edwards 1971 (one locus)</dt><dd><p><code class="reqn">d_5=\sqrt{1-\sum_{i=1}^{K}{\sqrt{p_1 q_i}}}</code></p>
</dd>
</dl>



<h3>Value</h3>

<p>returns a distance matrix, object of class <code>dist</code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Edwards, A. W. F. (1971) Distance between populations on the basis of gene frequencies. <em>Biometrics</em>, <b>27</b>, 
873&ndash;881. 
</p>
<p>Manly, B. F. (1994) <em>Multivariate Statistical Methods. A primer.</em>, Second edition. Chapman &amp; Hall, London.
</p>
<p>Nei, M. (1972) Genetic distances between populations. <em>The American Naturalist</em>, <b>106</b>, 283&ndash;292. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(microsatt)
w &lt;- microsatt$tab[1:microsatt$loci.eff[1]]

if(adegraphicsLoaded()) {
  g1 &lt;- scatter(dudi.pco(lingoes(dist.prop(w, 1)), scann = FALSE), plot = FALSE)
  g2 &lt;- scatter(dudi.pco(lingoes(dist.prop(w, 2)), scann = FALSE), plot = FALSE)
  g3 &lt;- scatter(dudi.pco(dist.prop(w, 3), scann = FALSE), plot = FALSE)
  g4 &lt;- scatter(dudi.pco(lingoes(dist.prop(w, 4)), scann = FALSE), plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  
} else {
  par(mfrow = c(2, 2))
  scatter(dudi.pco(lingoes(dist.prop(w, 1)), scann = FALSE))
  scatter(dudi.pco(lingoes(dist.prop(w, 2)), scann = FALSE))
  scatter(dudi.pco(dist.prop(w, 3), scann = FALSE))
  scatter(dudi.pco(lingoes(dist.prop(w, 4)), scann = FALSE))
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='dist.quant'>Computation of Distance Matrices on Quantitative Variables</h2><span id='topic+dist.quant'></span>

<h3>Description</h3>

<p>computes on quantitative variables, some distance matrices as canonical, Joreskog and Mahalanobis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.quant(df, method = NULL, diag = FALSE, upper = FALSE, 
    tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.quant_+3A_df">df</code></td>
<td>
<p>a data frame containing only quantitative variables</p>
</td></tr>
<tr><td><code id="dist.quant_+3A_method">method</code></td>
<td>
<p>an integer between 1 and 3. If NULL the choice is made with a console message. See details</p>
</td></tr>
<tr><td><code id="dist.quant_+3A_diag">diag</code></td>
<td>
<p>a logical value indicating whether the diagonal of the distance matrix should be printed by &lsquo;print.dist&rsquo;</p>
</td></tr>
<tr><td><code id="dist.quant_+3A_upper">upper</code></td>
<td>
<p>a logical value indicating whether the upper triangle of the distance matrix should be printed by &lsquo;print.dist&rsquo;</p>
</td></tr>
<tr><td><code id="dist.quant_+3A_tol">tol</code></td>
<td>
<p>used in case 3 of <code>method</code> as a tolerance threshold for null eigenvalues</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the distances are of type <code class="reqn">d=\|x-y\|_A =
  \sqrt{(x-y)^{t}A(x-y)}</code>
</p>

<dl>
<dt>1 = Canonical</dt><dd><p>A = Identity</p>
</dd>
<dt>2 = Joreskog</dt><dd><p><code class="reqn">A=\frac{1}{diag(cov)}</code></p>
</dd>
<dt>3 = Mahalanobis</dt><dd><p>A = inv(cov)</p>
</dd> 
</dl>



<h3>Value</h3>

<p>an object of class <code>dist</code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecomor)

if(adegraphicsLoaded()) {
  g1 &lt;- scatter(dudi.pco(dist.quant(ecomor$morpho, 3), scan = FALSE), plot = FALSE)
  g2 &lt;- scatter(dudi.pco(dist.quant(ecomor$morpho, 2), scan = FALSE), plot = FALSE)
  g3 &lt;- scatter(dudi.pco(dist(scalewt(ecomor$morpho)), scan = FALSE), plot = FALSE)
  g4 &lt;- scatter(dudi.pco(dist.quant(ecomor$morpho, 1), scan = FALSE), plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  
} else {
  par(mfrow = c(2, 2))
  scatter(dudi.pco(dist.quant(ecomor$morpho, 3), scan = FALSE))
  scatter(dudi.pco(dist.quant(ecomor$morpho, 2), scan = FALSE))
  scatter(dudi.pco(dist(scalewt(ecomor$morpho)), scan = FALSE))
  scatter(dudi.pco(dist.quant(ecomor$morpho, 1), scan = FALSE))
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='divc'>Rao's diversity coefficient also called quadratic entropy</h2><span id='topic+divc'></span>

<h3>Description</h3>

<p>Calculates Rao's diversity coefficient within samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divc(df, dis, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divc_+3A_df">df</code></td>
<td>
<p>a data frame with elements as rows, samples as columns,
and abundance, presence-absence or frequencies as entries</p>
</td></tr>
<tr><td><code id="divc_+3A_dis">dis</code></td>
<td>
<p>an object of class <code>dist</code> containing distances or dissimilarities among elements.
If <code>dis</code> is NULL, Gini-Simpson index is performed.</p>
</td></tr>
<tr><td><code id="divc_+3A_scale">scale</code></td>
<td>
<p>a logical value indicating whether or not the diversity coefficient
should be scaled by its maximal value over all frequency distributions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with samples as rows and the diversity coefficient within samples as columns
</p>


<h3>Author(s)</h3>

<p>Sandrine Pavoine <a href="mailto:pavoine@mnhn.fr">pavoine@mnhn.fr</a>
</p>


<h3>References</h3>

<p>Rao, C.R. (1982) Diversity and dissimilarity coefficients: a unified approach.
<em>Theoretical Population Biology</em>, <b>21</b>, 24&ndash;43.
</p>
<p>Gini, C. (1912) Variabilità e mutabilità. <em>Universite di Cagliari III</em>, Parte II.
</p>
<p>Simpson, E.H. (1949) Measurement of diversity. <em>Nature</em>, <b>163</b>, 688.
</p>
<p>Champely, S. and Chessel, D. (2002) Measuring biological diversity using Euclidean metrics.
<em>Environmental and Ecological Statistics</em>, <b>9</b>, 167&ndash;177.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecomor)
dtaxo &lt;- dist.taxo(ecomor$taxo)
divc(ecomor$habitat, dtaxo)

data(humDNAm)
divc(humDNAm$samples, sqrt(humDNAm$distances))
</code></pre>

<hr>
<h2 id='divcmax'>Maximal value of Rao's diversity coefficient also called 
quadratic entropy</h2><span id='topic+divcmax'></span>

<h3>Description</h3>

<p>For a given dissimilarity matrix, this function calculates the 
maximal value of Rao's diversity coefficient over all frequency 
distribution. It uses an optimization technique based on Rosen's 
projection gradient algorithm and is verified using the 
Kuhn-Tucker conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divcmax(dis, epsilon, comment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divcmax_+3A_dis">dis</code></td>
<td>
<p>an object of class <code>dist</code> containing distances 
or dissimilarities among elements.</p>
</td></tr>
<tr><td><code id="divcmax_+3A_epsilon">epsilon</code></td>
<td>
<p>a tolerance threshold : a frequency is non null 
if it is higher than epsilon.</p>
</td></tr>
<tr><td><code id="divcmax_+3A_comment">comment</code></td>
<td>
<p>a logical value indicating whether or not 
comments on the optimization technique should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list 
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>the maximal value of Rao's diversity coefficient.</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>a data frame containing four frequency 
distributions : <code>sim</code> is a simple distribution which is equal 
to <code class="reqn">\frac{D1}{1^tD1}</code>, <code>pro</code> is equal to 
<code class="reqn">\frac{z}{1^tz1}</code>, where z is the nonnegative 
eigenvector of the matrix containing the squared dissimilarities 
among the elements, <code>met</code> is equal to <code class="reqn">z^2</code>, <code>num</code> is a
frequency vector maximizing Rao's diversity coefficient.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stéphane Champely <a href="mailto:Stephane.Champely@univ-lyon1.fr">Stephane.Champely@univ-lyon1.fr</a> <br />
Sandrine Pavoine <a href="mailto:pavoine@mnhn.fr">pavoine@mnhn.fr</a>
</p>


<h3>References</h3>

<p>Rao, C.R. (1982) Diversity and dissimilarity coefficients: 
a unified approach. <em>Theoretical Population Biology</em>, 
<b>21</b>, 24&ndash;43.
</p>
<p>Gini, C. (1912) Variabilità e mutabilità. 
<em>Universite di Cagliari III</em>, Parte II.
</p>
<p>Simpson, E.H. (1949) Measurement of diversity. 
<em>Nature</em>, <b>163</b>, 688.
</p>
<p>Champely, S. and Chessel, D. (2002) Measuring biological diversity 
using Euclidean metrics. <em>Environmental and Ecological Statistics</em>, 
<b>9</b>, 167&ndash;177.
</p>
<p>Pavoine, S., Ollier, S. and Pontier, D. (2005) 
Measuring diversity from dissimilarities with Rao's quadratic entropy: 
are any dissimilarities suitable? <em>Theoretical Population Biology</em>,
<b>67</b>, 231&ndash;239.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(elec88)

# Dissimilarity matrix.
d0 &lt;- dist(elec88$xy/100)

# Frequency distribution maximizing spatial diversity in France
# according to Rao's quadratic entropy.
France.m &lt;- divcmax(d0)
w0 &lt;- France.m$vectors$num
v0 &lt;- France.m$value
idx &lt;- (1:94) [w0 &gt; 0]

if(!adegraphicsLoaded()) {
  # Smallest circle including all the 94 departments.
  # The squared radius of that circle is the maximal value of the
  # spatial diversity.
  w1 &lt;- elec88$xy[idx, ]/100
  w.c &lt;- apply(w1 * w0[idx], 2, sum)
  plot(elec88$xy[, 1]/100, elec88$xy[, 2]/100, asp=1)
  symbols(w.c[1], w.c[2], circles = sqrt(v0), inches = FALSE, add = TRUE)
  s.value(elec88$xy/100, w0, add.plot = TRUE)
}
</code></pre>

<hr>
<h2 id='dotchart.phylog'>Representation of many quantitative variables in front of a phylogenetic tree</h2><span id='topic+dotchart.phylog'></span>

<h3>Description</h3>

<p><code>dotchart.phylog</code> represents the phylogenetic tree and draws Cleveland dot
plot of each variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotchart.phylog(phylog, values, y = NULL, scaling = TRUE, ranging =
TRUE, yranging = NULL, joining = TRUE, yjoining = NULL, ceti = 1, cdot =
1, csub = 1, f.phylog = 1/(1 + ncol(values)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dotchart.phylog_+3A_phylog">phylog</code></td>
<td>
<p> an object of class <code>phylog</code></p>
</td></tr>
<tr><td><code id="dotchart.phylog_+3A_values">values</code></td>
<td>
<p> a vector or a data frame giving the variables</p>
</td></tr>
<tr><td><code id="dotchart.phylog_+3A_y">y</code></td>
<td>
<p> a vector which values correspond to leaves positions</p>
</td></tr>
<tr><td><code id="dotchart.phylog_+3A_scaling">scaling</code></td>
<td>
<p> if TRUE, data are scaled</p>
</td></tr>
<tr><td><code id="dotchart.phylog_+3A_ranging">ranging</code></td>
<td>
<p> if TRUE, dotplots are drawn with the same horizontal limits</p>
</td></tr>
<tr><td><code id="dotchart.phylog_+3A_yranging">yranging</code></td>
<td>
<p> a vector with two values giving the horizontal limits.
If NULL, horizontal limits are defined by lower and upper values of data</p>
</td></tr>
<tr><td><code id="dotchart.phylog_+3A_joining">joining</code></td>
<td>
<p> if TRUE, segments join each point to a central value</p>
</td></tr>
<tr><td><code id="dotchart.phylog_+3A_yjoining">yjoining</code></td>
<td>
<p> a vector with the central value. If NULL, the central value equals 0</p>
</td></tr>
<tr><td><code id="dotchart.phylog_+3A_ceti">ceti</code></td>
<td>
<p> a character size for editing horizontal limits, <br /> 
used with <code>par("cex")*ceti</code></p>
</td></tr>
<tr><td><code id="dotchart.phylog_+3A_cdot">cdot</code></td>
<td>
<p> a character size for plotting the points of the dot plot,
used with <code>par("cex")*cdot</code></p>
</td></tr>
<tr><td><code id="dotchart.phylog_+3A_csub">csub</code></td>
<td>
<p> a character size for editing the names of variables, <br /> 
used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="dotchart.phylog_+3A_f.phylog">f.phylog</code></td>
<td>
<p> a size coefficient for tree size (a parameter to draw the tree
in proportion to leaves labels)</p>
</td></tr>
<tr><td><code id="dotchart.phylog_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+symbols.phylog">symbols.phylog</a></code> and <code><a href="#topic+table.phylog">table.phylog</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># one variable
tre &lt;- c("((A,B),(C,D));")
phy &lt;- newick2phylog(tre)
x &lt;- 1:4
par(mfrow = c(2,2))
dotchart.phylog(phy, x, scaling = FALSE)
dotchart.phylog(phy, x)
dotchart.phylog(phy, x, joining = FALSE)
dotchart.phylog(phy, x, scaling = FALSE,
 yjoining = 0, yranging = c(-1, 5))
par(mfrow = c(1,1))

# many variables
data(mjrochet)
phy &lt;- newick2phylog(mjrochet$tre)
tab &lt;- data.frame(log(mjrochet$tab))
dotchart.phylog(phy, tab, ceti = 0.5, csub = 0.6,
 cleaves = 0, cdot = 0.6)
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='dotcircle'>Representation of n values on a circle</h2><span id='topic+dotcircle'></span>

<h3>Description</h3>

<p>This function represents <em>n</em> values on a circle. The <em>n</em> points are shared out regularly over the circle and put on the radius according to the value attributed to that measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotcircle(z, alpha0 = pi/2, xlim = range(pretty(z)),
 labels = names(z), clabel = 1, cleg = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dotcircle_+3A_z">z</code></td>
<td>
<p>: a numeric vector</p>
</td></tr>
<tr><td><code id="dotcircle_+3A_alpha0">alpha0</code></td>
<td>
<p>: polar angle to put the first value</p>
</td></tr>
<tr><td><code id="dotcircle_+3A_xlim">xlim</code></td>
<td>
<p>: the ranges to be encompassed by the circle radius</p>
</td></tr>
<tr><td><code id="dotcircle_+3A_labels">labels</code></td>
<td>
<p>: a vector of strings of characters for the angle labels</p>
</td></tr>
<tr><td><code id="dotcircle_+3A_clabel">clabel</code></td>
<td>
<p>: a character size for the labels, used with  <code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="dotcircle_+3A_cleg">cleg</code></td>
<td>
<p>: a character size for the ranges, used with <code>par("cex")*cleg</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel 
</p>


<h3>See Also</h3>

<p><code><a href="CircStats.html#topic+circ.plot">circ.plot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- scores.neig(neig(n.cir = 24))
par(mfrow = c(4,4))
for (k in 1:16) dotcircle(w[,k],labels = 1:24)
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='doubs'>Pair of Ecological Tables</h2><span id='topic+doubs'></span>

<h3>Description</h3>

<p>This data set gives environmental variables, fish species and spatial coordinates for 30 sites. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(doubs)</code></pre>


<h3>Format</h3>

<p><code>doubs</code> is a list with 4 components.
</p>

<dl>
<dt>env</dt><dd><p>is a data frame with 30 rows (sites) and 11 environmental variables.</p>
</dd>
<dt>fish</dt><dd><p>is a data frame with 30 rows (sites) and 27 fish species.</p>
</dd>
<dt>xy</dt><dd><p>is a data frame with 30 rows (sites)  and 2 spatial coordinates.</p>
</dd>
<dt>species</dt><dd><p>is a data frame with 27 rows (species)  and 4 columns (names).</p>
</dd>
</dl>



<h3>Details</h3>

<p>The rows of <code>doubs$env</code>, <code>doubs$fish</code> and <code>doubs$xy</code> are 30 sites along the Doubs, a French and Switzerland river.
</p>
<p><code>doubs$env</code> contains the following variables:
dfs - distance from the source (km * 10), 
alt - altitude (m), 
slo (<code class="reqn">\ln(x + 1)</code> where <em>x</em> is the slope (per mil * 100), 
flo - minimum average stream flow (m3/s * 100), 
pH (* 10), 
har - total hardness of water (mg/l of Calcium), 
pho - phosphates (mg/l * 100), 
nit - nitrates (mg/l * 100), 
amm - ammonia nitrogen (mg/l * 100), 
oxy - dissolved oxygen (mg/l * 10), 
bdo - biological demand for oxygen (mg/l * 10).
</p>
<p><code>doubs$fish</code> contains the abundance of the following fish species: <em>Cottus gobio</em> (Cogo), <em>Salmo trutta fario</em> (Satr), 
<em>Phoxinus phoxinus</em> (Phph), <em>Nemacheilus barbatulus</em> (Neba), <em>Thymallus thymallus</em> (Thth), <em>Telestes soufia agassizi</em> (Teso), 
<em>Chondrostoma nasus</em> (Chna), <em>Chondostroma toxostoma</em> (Chto), <em>Leuciscus leuciscus</em> (Lele), <em>Leuciscus cephalus cephalus</em> (Lece), 
<em>Barbus barbus</em> (Baba), <em>Spirlinus bipunctatus</em> (Spbi), <em>Gobio gobio</em> (Gogo), <em>Esox lucius</em> (Eslu), 
<em>Perca fluviatilis</em> (Pefl), <em>Rhodeus amarus</em> (Rham), <em>Lepomis gibbosus</em> (Legi), <em>Scardinius erythrophtalmus</em> (Scer), 
<em>Cyprinus carpio</em> (Cyca), <em>Tinca tinca</em> (Titi), <em>Abramis brama</em> (Abbr), <em>Ictalurus melas</em> (Icme), 
<em>Acerina cernua</em> (Acce), <em>Rutilus rutilus</em> (Ruru), <em>Blicca bjoerkna</em> (Blbj), <em>Alburnus alburnus</em> (Alal), 
<em>Anguilla anguilla</em> (Anan).
</p>
<p><code>doubs$species</code> contains the names of the 27 fish species. The four columns correspond to: 1 = scientific name (Genus species), 2 = French common name, 3 = English common name, 4 = Four character code.
</p>


<h3>Source</h3>

<p>Verneaux, J. (1973) 
<em>Cours d'eau de Franche-Comté (Massif du Jura). 
Recherches écologiques sur le réseau hydrographique du Doubs. Essai de biotypologie</em>. 
Thèse d'état, Besançon. 1&ndash;257.
</p>


<h3>References</h3>

<p>See a French description of fish species at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps047.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps047.pdf</a>.<br />
Chessel, D., Lebreton, J.D. and Yoccoz, N.G. (1987) Propriétés de l'analyse canonique des correspondances. Une illustration
en hydrobiologie. <em>Revue de Statistique Appliquée</em>, <b>35</b>, 4, 55&ndash;72.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(doubs)
pca1 &lt;- dudi.pca(doubs$env, scan = FALSE)
pca2 &lt;- dudi.pca(doubs$fish, scale = FALSE, scan = FALSE)
coiner1 &lt;- coinertia(pca1, pca2, scan = FALSE)
  
if(adegraphicsLoaded()) {
  g1 &lt;- s.corcircle(coiner1$aX, plot = FALSE)
  g2 &lt;- s.value(doubs$xy, coiner1$lX[, 1], plot = FALSE)
  g3 &lt;- s.value(doubs$xy, coiner1$lX[, 2], plot = FALSE)
  g4 &lt;- s.arrow(coiner1$c1, plot = FALSE)
  g5 &lt;- s.match(coiner1$mX, coiner1$mY, plot = FALSE)
  g6 &lt;- s.corcircle(coiner1$aY, plot = FALSE)
  g7 &lt;- s.arrow(coiner1$l1, plot = FALSE)
  g8 &lt;- s.value(doubs$xy, coiner1$lY[, 1], plot = FALSE)
  g9 &lt;- s.value(doubs$xy, coiner1$lY[, 2], plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4, g5, g6, g7, g8, g9), layout = c(3, 3))
  
} else {  
  par(mfrow = c(3, 3))
  s.corcircle(coiner1$aX)
  s.value(doubs$xy, coiner1$lX[, 1])
  s.value(doubs$xy, coiner1$lX[, 2])
  s.arrow(coiner1$c1)
  s.match(coiner1$mX, coiner1$mY)
  s.corcircle(coiner1$aY)
  s.arrow(coiner1$l1)
  s.value(doubs$xy, coiner1$lY[, 1])
  s.value(doubs$xy, coiner1$lY[, 2])
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='dpcoa'>Double principal coordinate analysis</h2><span id='topic+dpcoa'></span><span id='topic+plot.dpcoa'></span><span id='topic+print.dpcoa'></span><span id='topic+summary.dpcoa'></span>

<h3>Description</h3>

<p>Performs a double principal coordinate analysis  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpcoa(df, dis = NULL, scannf = TRUE, nf = 2, full = FALSE, tol = 1e-07,
RaoDecomp = TRUE)
## S3 method for class 'dpcoa'
plot(x, xax = 1, yax = 2, ...)
## S3 method for class 'dpcoa'
 print(x, ...)
## S3 method for class 'dpcoa'
 summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpcoa_+3A_df">df</code></td>
<td>
<p>a data frame with samples as rows and categories
(i.e. species) as columns and abundance or presence-absence as
entries. Previous releases of <span class="pkg">ade4</span> (&lt;=1.6-2) considered the
transposed matrix as argument.</p>
</td></tr>
<tr><td><code id="dpcoa_+3A_dis">dis</code></td>
<td>
<p>an object of class <code>dist</code> containing the distances between the categories.</p>
</td></tr>
<tr><td><code id="dpcoa_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar
plot should be displayed</p>
</td></tr>
<tr><td><code id="dpcoa_+3A_raodecomp">RaoDecomp</code></td>
<td>
<p>a logical value indicating whether Rao diversity
decomposition should be performed</p>
</td></tr>
<tr><td><code id="dpcoa_+3A_nf">nf</code></td>
<td>
<p>if scannf is FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="dpcoa_+3A_full">full</code></td>
<td>
<p>a logical value indicating whether all non null eigenvalues should be kept</p>
</td></tr>
<tr><td><code id="dpcoa_+3A_tol">tol</code></td>
<td>
<p>a tolerance threshold for null eigenvalues (a value less than tol times the first one is considered as null)</p>
</td></tr>
<tr><td><code id="dpcoa_+3A_x">x</code>, <code id="dpcoa_+3A_object">object</code></td>
<td>
<p>an object of class <code>dpcoa</code></p>
</td></tr>
<tr><td><code id="dpcoa_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="dpcoa_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="dpcoa_+3A_...">...</code></td>
<td>
<p><code>...</code> further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>dpcoa</code> containing:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>call</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>a numeric value indicating the number of kept axes</p>
</td></tr>
<tr><td><code>dw</code></td>
<td>
<p>a numeric vector containing the weights of the elements (was
<code>w1</code> in previous releases of <span class="pkg">ade4</span>)</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>a numeric vector containing the weights of the samples (was
<code>w2</code> in previous releases of <span class="pkg">ade4</span>)</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a numeric vector with all the eigenvalues</p>
</td></tr>
<tr><td><code>RaoDiv</code></td>
<td>
<p>a numeric vector containing diversities within samples</p>
</td></tr>
<tr><td><code>RaoDis</code></td>
<td>
<p>an object of class <code>dist</code> containing the dissimilarities between samples</p>
</td></tr>
<tr><td><code>RaoDecodiv</code></td>
<td>
<p>a data frame with the decomposition of the diversity</p>
</td></tr>
<tr><td><code>dls</code></td>
<td>
<p>a data frame with the coordinates of the elements (was
<code>l1</code> in previous releases of <span class="pkg">ade4</span>)</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>a data frame with the coordinates of the samples (was
<code>l2</code> in previous releases of <span class="pkg">ade4</span>)</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>a data frame with the scores of the principal axes of the elements</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Sandrine Pavoine <a href="mailto:pavoine@mnhn.fr">pavoine@mnhn.fr</a> <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Pavoine, S., Dufour, A.B. and Chessel, D. (2004) From dissimilarities among species to dissimilarities among communities:
a double principal coordinate analysis. <em>Journal of Theoretical Biology</em>, <b>228</b>, 523&ndash;537.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humDNAm)
dpcoahum &lt;- dpcoa(data.frame(t(humDNAm$samples)), sqrt(humDNAm$distances), scan = FALSE, nf = 2)
dpcoahum
if(adegraphicsLoaded()) {
  g1 &lt;- plot(dpcoahum)
} else {
  plot(dpcoahum)
}
  
## Not run: 
data(ecomor)
dtaxo &lt;- dist.taxo(ecomor$taxo)
dpcoaeco &lt;- dpcoa(data.frame(t(ecomor$habitat)), dtaxo, scan = FALSE, nf = 2)
dpcoaeco

if(adegraphicsLoaded()) {
  g1 &lt;- plot(dpcoaeco)
} else {
  plot(dpcoaeco)
}

## End(Not run)</code></pre>

<hr>
<h2 id='dudi'>Duality Diagram</h2><span id='topic+dudi'></span><span id='topic+as.dudi'></span><span id='topic+print.dudi'></span><span id='topic+t.dudi'></span><span id='topic+is.dudi'></span><span id='topic+redo.dudi'></span><span id='topic+summary.dudi'></span><span id='topic++5B.dudi'></span>

<h3>Description</h3>

<p><code>as.dudi</code> is called by many functions (<code>dudi.pca</code>, <code>dudi.coa</code>, <code>dudi.acm</code>, ...) 
and not directly by the user. It creates duality diagrams.
</p>
<p><code>t.dudi</code> returns an object of class '<code>dudi</code>' where the rows are the columns and the columns are the rows
of the initial <code>dudi</code>. 
</p>
<p><code>is.dudi</code> returns TRUE if the object is of class <code>dudi</code> 
</p>
<p><code>redo.dudi</code> computes again an analysis, eventually changing the number of kept axes. Used by other functions.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.dudi(df, col.w, row.w, scannf, nf, call, type, tol = 1e-07, 
    full = FALSE) 
## S3 method for class 'dudi'
print(x, ...) 
is.dudi(x) 
redo.dudi(dudi, newnf = 2) 
## S3 method for class 'dudi'
t(x)
## S3 method for class 'dudi'
summary(object, ...) 
## S3 method for class 'dudi'
x[i,j]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dudi_+3A_df">df</code></td>
<td>
<p>a data frame with <em>n</em> rows and <em>p</em> columns</p>
</td></tr>
<tr><td><code id="dudi_+3A_col.w">col.w</code></td>
<td>
<p>a numeric vector containing the row weights</p>
</td></tr>
<tr><td><code id="dudi_+3A_row.w">row.w</code></td>
<td>
<p>a numeric vector containing the column weights</p>
</td></tr>
<tr><td><code id="dudi_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="dudi_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="dudi_+3A_call">call</code></td>
<td>
<p>generally <code>match.call()</code></p>
</td></tr>
<tr><td><code id="dudi_+3A_type">type</code></td>
<td>
<p>a string of characters : the returned list will be of class <code>c(type, "dudi")</code></p>
</td></tr>
<tr><td><code id="dudi_+3A_tol">tol</code></td>
<td>
<p>a tolerance threshold for null eigenvalues (a value less than tol times the first one is considered as null)</p>
</td></tr>
<tr><td><code id="dudi_+3A_full">full</code></td>
<td>
<p>a logical value indicating whether all non null eigenvalues should be kept</p>
</td></tr>
<tr><td><code id="dudi_+3A_x">x</code>, <code id="dudi_+3A_dudi">dudi</code>, <code id="dudi_+3A_object">object</code></td>
<td>
<p>objects of class <code>dudi</code></p>
</td></tr>
<tr><td><code id="dudi_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="dudi_+3A_newnf">newnf</code></td>
<td>
<p>an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="dudi_+3A_i">i</code>, <code id="dudi_+3A_j">j</code></td>
<td>
<p>elements to extract (integer or empty): index of rows (i) and columns (j)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>as.dudi and all the functions that use it return a list with the following components :
</p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>a data frame with n rows and p columns</p>
</td></tr>
<tr><td><code>cw</code></td>
<td>
<p>column weights, a vector with n components</p>
</td></tr> 
<tr><td><code>lw</code></td>
<td>
<p>row (lines) weights, a vector with p components</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>eigenvalues, a vector with min(n,p) components</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>integer, number of kept axes</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>principal axes, data frame with p rows and nf columns</p>
</td></tr>
<tr><td><code>l1</code></td>
<td>
<p>principal components, data frame with n rows and nf columns</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>column coordinates, data frame with p rows and nf columns</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>row coordinates, data frame with n rows and nf columns</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>original call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a><br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Escoufier, Y. (1987) 
The duality diagram  : a means of better practical applications 
In <em>Development in numerical ecology</em>, Legendre, P. &amp; Legendre, L. (Eds.) 
NATO advanced Institute,  Serie G. Springer Verlag, Berlin,  139&ndash;156.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deug)
dd1 &lt;- dudi.pca(deug$tab, scannf = FALSE)
dd1
t(dd1)
is.dudi(dd1)
redo.dudi(dd1,3)
summary(dd1)
</code></pre>

<hr>
<h2 id='dudi.acm'>Multiple Correspondence Analysis</h2><span id='topic+dudi.acm'></span><span id='topic+acm.burt'></span><span id='topic+acm.disjonctif'></span><span id='topic+boxplot.acm'></span>

<h3>Description</h3>

<p><code>dudi.acm</code> performs the multiple correspondence analysis of a factor table.<br />
<code>acm.burt</code> an utility giving the crossed Burt table of two factors table.<br />
<code>acm.disjonctif</code> an utility giving the complete disjunctive table of a factor table.<br />
<code>boxplot.acm</code> a graphic utility to interpret axes.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dudi.acm (df, row.w = rep(1, nrow(df)), scannf = TRUE, nf = 2)
acm.burt (df1, df2, counts = rep(1, nrow(df1))) 
acm.disjonctif (df) 
## S3 method for class 'acm'
boxplot(x, xax = 1, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dudi.acm_+3A_df">df</code>, <code id="dudi.acm_+3A_df1">df1</code>, <code id="dudi.acm_+3A_df2">df2</code></td>
<td>
<p>data frames containing only factors</p>
</td></tr>
<tr><td><code id="dudi.acm_+3A_row.w">row.w</code>, <code id="dudi.acm_+3A_counts">counts</code></td>
<td>
<p>vector of row weights, by default, uniform weighting</p>
</td></tr>
<tr><td><code id="dudi.acm_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="dudi.acm_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="dudi.acm_+3A_x">x</code></td>
<td>
<p>an object of class <code>acm</code></p>
</td></tr>
<tr><td><code id="dudi.acm_+3A_xax">xax</code></td>
<td>
<p>the number of factor to display</p>
</td></tr>
<tr><td><code id="dudi.acm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dudi.acm</code> returns a list of class <code>acm</code> and <code>dudi</code> (see <a href="#topic+dudi">dudi</a>) containing  
</p>
<table>
<tr><td><code>cr</code></td>
<td>
<p> a data frame which rows are the variables, columns are the kept scores and the values
are the correlation ratios</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Tenenhaus, M. &amp; Young, F.W. (1985) An analysis and synthesis of multiple correspondence analysis, 
optimal scaling, dual scaling, homogeneity analysis ans other methods for quantifying categorical multivariate data. 
<em>Psychometrika</em>, <b>50</b>, 1, 91-119.
</p>
<p>Lebart, L., A. Morineau, and M. Piron. 1995. Statistique exploratoire multidimensionnelle. Dunod, Paris.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s.chull">s.chull</a></code>, <code><a href="#topic+s.class">s.class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ours)
summary(ours)

if(adegraphicsLoaded()) {
  g1 &lt;- s1d.boxplot(dudi.acm(ours, scan = FALSE)$li[, 1], ours)
} else {
  boxplot(dudi.acm(ours, scan = FALSE))
}
## Not run: 
data(banque)
banque.acm &lt;- dudi.acm(banque, scann = FALSE, nf = 3)

if(adegraphicsLoaded()) {
  g2 &lt;- adegraphics:::scatter.dudi(banque.acm)
} else {
  scatter(banque.acm)
}  

apply(banque.acm$cr, 2, mean)
banque.acm$eig[1:banque.acm$nf] # the same thing

if(adegraphicsLoaded()) {
  g3 &lt;- s1d.boxplot(banque.acm$li[, 1], banque)
  g4 &lt;- scatter(banque.acm)
} else {
  boxplot(banque.acm)
  scatter(banque.acm)
}


s.value(banque.acm$li, banque.acm$li[,3])

bb &lt;- acm.burt(banque, banque)
bbcoa &lt;- dudi.coa(bb, scann = FALSE)
plot(banque.acm$c1[,1], bbcoa$c1[,1])
# mca and coa of Burt table. Lebart &amp; coll. section 1.4

bd &lt;- acm.disjonctif(banque)
bdcoa &lt;- dudi.coa(bd, scann = FALSE)
plot(banque.acm$li[,1], bdcoa$li[,1]) 
# mca and coa of disjonctive table. Lebart &amp; coll. section 1.4
plot(banque.acm$co[,1], dudi.coa(bd, scann = FALSE)$co[,1]) 

## End(Not run)</code></pre>

<hr>
<h2 id='dudi.coa'>Correspondence Analysis</h2><span id='topic+dudi.coa'></span>

<h3>Description</h3>

<p>performs a correspondence analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dudi.coa(df, scannf = TRUE, nf = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dudi.coa_+3A_df">df</code></td>
<td>
<p>a data frame containing positive or null values</p>
</td></tr>
<tr><td><code id="dudi.coa_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="dudi.coa_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class <code>coa</code> and <code>dudi</code> (see <a href="#topic+dudi">dudi</a>) containing 
</p>
<table>
<tr><td><code>N</code></td>
<td>
<p>the sum of all the values of the initial table</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Benzécri, J.P. and Coll. (1973) <em>L'analyse des données. II L'analyse des correspondances</em>, Bordas, Paris. 1&ndash;620.<br />
</p>
<p>Greenacre, M. J. (1984) <em>Theory and applications of correspondence analysis</em>, Academic Press, London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rpjdl)
chisq.test(rpjdl$fau)$statistic
rpjdl.coa &lt;- dudi.coa(rpjdl$fau, scannf = FALSE, nf = 4)
sum(rpjdl.coa$eig)*rpjdl.coa$N # the same

if(adegraphicsLoaded()) {
  g1 &lt;- s.label(rpjdl.coa$co, plab.cex = 0.6, lab = rpjdl$frlab, plot = FALSE)
  g2 &lt;- s.label(rpjdl.coa$li, plab.cex = 0.6, plot = FALSE)
  cbindADEg(g1, g2, plot = TRUE)
} else {
  par(mfrow = c(1,2))
  s.label(rpjdl.coa$co, clab = 0.6, lab = rpjdl$frlab)
  s.label(rpjdl.coa$li, clab = 0.6)
  par(mfrow = c(1,1))
}

data(bordeaux)
db &lt;- dudi.coa(bordeaux, scan = FALSE)
db
score(db)
</code></pre>

<hr>
<h2 id='dudi.dec'>Decentred Correspondence Analysis</h2><span id='topic+dudi.dec'></span>

<h3>Description</h3>

<p>performs a decentred correspondence analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dudi.dec(df, eff, scannf = TRUE, nf = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dudi.dec_+3A_df">df</code></td>
<td>
<p>a data frame containing positive or null values</p>
</td></tr>
<tr><td><code id="dudi.dec_+3A_eff">eff</code></td>
<td>
<p>a vector containing the reference distribution. Its length is equal to the number of rows of df</p>
</td></tr>
<tr><td><code id="dudi.dec_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="dudi.dec_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>dec</code> and <code>dudi</code> (see <code><a href="#topic+dudi">dudi</a></code>) containing also 
</p>
<table>
<tr><td><code>R</code></td>
<td>
<p>sum of all the values of the initial table</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Dolédec, S., Chessel, D. and Olivier J. M. (1995) L'analyse des correspondances décentrée: 
application aux peuplements ichtyologiques du haut-Rhône. 
<em>Bulletin Français de la Pêche et de la Pisciculture</em>, <b>336</b>, 29&ndash;40.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ichtyo)
dudi1 &lt;- dudi.dec(ichtyo$tab, ichtyo$eff, scan = FALSE)
sum(apply(ichtyo$tab, 2, function(x)
    chisq.test(x, p = ichtyo$eff/sum(ichtyo$eff))$statistic))
sum(dudi1$eig) * sum(ichtyo$eff) # the same

s.class(dudi1$li, ichtyo$dat, wt = ichtyo$eff/sum(ichtyo$eff))
</code></pre>

<hr>
<h2 id='dudi.fca'>Fuzzy Correspondence Analysis and Fuzzy Principal Components Analysis</h2><span id='topic+dudi.fca'></span><span id='topic+dudi.fpca'></span><span id='topic+prep.fuzzy.var'></span>

<h3>Description</h3>

<p>Theses functions analyse a table of fuzzy variables.<br /><br />
A fuzzy variable takes values of type <code class="reqn">a=(a_1,\dots,a_k)</code> 
giving the importance of k categories.<br /><br />
A missing data is denoted (0,...,0).<br />
Only the profile a/sum(a) is used, and missing data are replaced by
the mean profile of the others in the function <code>prep.fuzzy.var</code>. See ref. for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep.fuzzy.var (df, col.blocks, row.w = rep(1, nrow(df)))
dudi.fca(df, scannf = TRUE, nf = 2)
dudi.fpca(df, scannf = TRUE, nf = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dudi.fca_+3A_df">df</code></td>
<td>
<p>a data frame containing positive or null values</p>
</td></tr>
<tr><td><code id="dudi.fca_+3A_col.blocks">col.blocks</code></td>
<td>
<p>a vector containing the number of categories for each fuzzy variable</p>
</td></tr>
<tr><td><code id="dudi.fca_+3A_row.w">row.w</code></td>
<td>
<p>a vector of row weights</p>
</td></tr>
<tr><td><code id="dudi.fca_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="dudi.fca_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>prep.fuzzy.var</code> returns a data frame with the attribute <code>col.blocks</code>. 
The function <code>dudi.fca</code> returns a list of class <code>fca</code> and <code>dudi</code> (see <a href="#topic+dudi">dudi</a>) containing also
</p>
<table>
<tr><td><code>cr</code></td>
<td>
<p>a data frame which rows are the blocs, columns are the kept axes, and values are the correlation ratios.</p>
</td></tr>
</table>
<p>The function <code>dudi.fpca</code> returns a list of class <code>pca</code> and <code>dudi</code> (see <a href="#topic+dudi">dudi</a>) containing also
</p>

<ol>
<li><p> cent
</p>
</li>
<li><p> norm
</p>
</li>
<li><p> blo
</p>
</li>
<li><p> indica
</p>
</li>
<li><p> FST
</p>
</li>
<li><p> inertia
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Chevenet, F., Dolédec, S. and Chessel, D. (1994) A fuzzy coding 
approach for the analysis of long-term ecological data. <em>Freshwater Biology</em>, <b>31</b>, 295&ndash;309.</p>


<h3>Examples</h3>

<pre><code class='language-R'>w1 &lt;- matrix(c(1,0,0,2,1,1,0,2,2,0,1,0,1,1,1,0,1,3,1,0), 4, 5)
w1 &lt;- data.frame(w1) 
w2 &lt;- prep.fuzzy.var(w1, c(2, 3))
w1
w2 
attributes(w2)

data(bsetal97)
w &lt;- prep.fuzzy.var(bsetal97$biol, bsetal97$biol.blo)

if(adegraphicsLoaded()) {
  g1 &lt;- plot(dudi.fca(w, scann = FALSE, nf = 3), plabels.cex = 1.5)
} else {
  scatter(dudi.fca(w, scann = FALSE, nf = 3), csub = 3, clab.moda = 1.5)
  scatter(dudi.fpca(w, scann = FALSE, nf = 3), csub = 3, clab.moda = 1.5)
}

## Not run: 
w1 &lt;- prep.fuzzy.var(bsetal97$biol, bsetal97$biol.blo)
w2 &lt;- prep.fuzzy.var(bsetal97$ecol, bsetal97$ecol.blo)
d1 &lt;- dudi.fca(w1, scannf = FALSE, nf = 3)
d2 &lt;- dudi.fca(w2, scannf = FALSE, nf = 3)
plot(coinertia(d1, d2, scannf = FALSE))

## End(Not run)

</code></pre>

<hr>
<h2 id='dudi.hillsmith'> Ordination of Tables mixing quantitative variables and factors </h2><span id='topic+dudi.hillsmith'></span>

<h3>Description</h3>

<p> performs a multivariate analysis with mixed quantitative variables and factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dudi.hillsmith(df, row.w = rep(1, nrow(df))/nrow(df), 
   scannf = TRUE, nf = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dudi.hillsmith_+3A_df">df</code></td>
<td>
<p> a data frame with mixed type variables (quantitative and factor) </p>
</td></tr>
<tr><td><code id="dudi.hillsmith_+3A_row.w">row.w</code></td>
<td>
<p> a vector of row weights, by default uniform row weights are used </p>
</td></tr>
<tr><td><code id="dudi.hillsmith_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="dudi.hillsmith_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>df</code> contains only quantitative variables, this is equivalent to a normed PCA.<br />
If <code>df</code> contains only factors, this is equivalent to a MCA.<br />
</p>
<p>This analysis is the Hill and Smith method and is very similar to <code>dudi.mix</code> function. 
The differences are that <code>dudi.hillsmith</code> allow to use various row weights, while
<code>dudi.mix</code> deals with ordered variables.<br />
The principal components of this analysis are centered and normed vectors maximizing the sum of :<br />
squared correlation coefficients with quantitative variables<br />
correlation ratios with factors<br />
</p>


<h3>Value</h3>

<p>Returns a list of class <code>mix</code> and <code>dudi</code> (see <a href="#topic+dudi">dudi</a>) containing also 
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>a factor giving the type of each variable : f = factor, q = quantitative</p>
</td></tr>
<tr><td><code>assign</code></td>
<td>
<p>a factor indicating the initial variable for each column of the transformed table</p>
</td></tr>
<tr><td><code>cr</code></td>
<td>
<p>a data frame giving for each variable and each score:<br />
the squared correlation coefficients if it is a quantitative variable<br />
the correlation ratios if it is a factor
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a><br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p> Hill, M. O., and A. J. E. Smith. 1976. Principal component analysis of taxonomic data with multi-state discrete characters. 
<em>Taxon</em>, <b>25</b>, 249-255. </p>


<h3>See Also</h3>

 <p><code>dudi.mix</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dunedata)
attributes(dunedata$envir$use)$class &lt;- "factor"   # use dudi.mix for ordered data
dd1 &lt;- dudi.hillsmith(dunedata$envir, scann = FALSE)
if(adegraphicsLoaded()) {
  g &lt;- scatter(dd1, row.plab.cex = 1, col.plab.cex = 1.5)
} else {
  scatter(dd1, clab.r = 1, clab.c = 1.5)
}</code></pre>

<hr>
<h2 id='dudi.mix'>Ordination of Tables mixing quantitative variables and factors</h2><span id='topic+dudi.mix'></span>

<h3>Description</h3>

<p>performs a multivariate analysis with mixed quantitative variables and factors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dudi.mix(df, add.square = FALSE, scannf = TRUE, nf = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dudi.mix_+3A_df">df</code></td>
<td>
<p>a data frame with mixed type variables (quantitative, factor and ordered)</p>
</td></tr>
<tr><td><code id="dudi.mix_+3A_add.square">add.square</code></td>
<td>
<p>a logical value indicating whether the squares of quantitative variables should be added</p>
</td></tr>
<tr><td><code id="dudi.mix_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="dudi.mix_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If df contains only quantitative variables, this is equivalent to a normed PCA.<br />
If df contains only factors, this is equivalent to a MCA.<br />
Ordered factors are replaced by <code>poly(x,deg=2)</code>. <br />
</p>
<p>This analysis generalizes the Hill and Smith method.<br />
The principal components of this analysis are centered and normed vectors maximizing the sum of the:<br />
squared correlation coefficients with quantitative variables<br />
squared multiple correlation coefficients with polynoms<br />
correlation ratios with factors. <br />
</p>


<h3>Value</h3>

<p>Returns a list of class <code>mix</code> and <code>dudi</code> (see <a href="#topic+dudi">dudi</a>) containing also 
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>a factor giving the type of each variable : f = factor, o = ordered, q = quantitative</p>
</td></tr>
<tr><td><code>assign</code></td>
<td>
<p>a factor indicating the initial variable for each column of the transformed table</p>
</td></tr>
<tr><td><code>cr</code></td>
<td>
<p>a data frame giving for each variable and each score:<br />
the squared correlation coefficients if it is a quantitative variable<br />
the correlation ratios if it is a factor<br />
the squared multiple correlation coefficients if it is ordered</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Hill, M. O., and A. J. E. Smith. 1976. Principal component analysis of taxonomic data with multi-state discrete characters. <em>Taxon</em>, <b>25</b>, 249-255.<br /><br />
De Leeuw, J., J. van Rijckevorsel, and . 1980. HOMALS and PRINCALS - Some generalizations of principal components analysis. Pages 231-242 in E. Diday and Coll., editors. Data Analysis and Informatics II. Elsevier Science Publisher, North Holland, Amsterdam.<br /><br />
Kiers, H. A. L. 1994. Simple structure in component analysis techniques for mixtures of qualitative ans quantitative variables. <em>Psychometrika</em>, <b>56</b>, 197-212.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dunedata)
dd1 &lt;- dudi.mix(dunedata$envir, scann = FALSE)
if(adegraphicsLoaded()) {
  g1 &lt;- scatter(dd1, row.plab.cex = 1, col.plab.cex = 1.5)
} else {
  scatter(dd1, clab.r = 1, clab.c = 1.5)
}

dd2 &lt;- dudi.mix(dunedata$envir, scann = FALSE, add.square = TRUE)
if(adegraphicsLoaded()) {
  g2 &lt;- scatter(dd2, row.plab.cex = 1, col.plab.cex = 1.5)
} else {
  scatter(dd2, clab.r = 1, clab.c = 1.5)
}  
</code></pre>

<hr>
<h2 id='dudi.nsc'>Non symmetric correspondence analysis</h2><span id='topic+dudi.nsc'></span>

<h3>Description</h3>

<p>performs a non symmetric correspondence analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dudi.nsc(df, scannf = TRUE, nf = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dudi.nsc_+3A_df">df</code></td>
<td>
<p>a data frame containing positive or null values</p>
</td></tr>
<tr><td><code id="dudi.nsc_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="dudi.nsc_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>nsc</code> and <code>dudi</code> (see <code><a href="#topic+dudi">dudi</a></code>) containing also
</p>
<table>
<tr><td><code>N</code></td>
<td>
<p>sum of the values of the initial table</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Kroonenberg, P. M., and Lombardo  R. (1999) Nonsymmetric correspondence analysis: 
a tool for analysing contingency tables with a dependence structure. <em>Multivariate Behavioral Research</em>, <b>34</b>, 367&ndash;396.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(housetasks)
nsc1 &lt;- dudi.nsc(housetasks, scan = FALSE)
if(adegraphicsLoaded()) {
  g1 &lt;- s.label(nsc1$c1, plab.cex = 1.25)
  g2 &lt;- s.arrow(nsc1$li, add = TRUE, plab.cex = 0.75)
} else {
  s.label(nsc1$c1, clab = 1.25)
  s.arrow(nsc1$li, add.pl = TRUE, clab = 0.75) # see ref p.383
}</code></pre>

<hr>
<h2 id='dudi.pca'>Principal Component Analysis</h2><span id='topic+dudi.pca'></span>

<h3>Description</h3>

<p><code>dudi.pca</code> performs a principal component analysis of a data frame and
returns the results as objects of class <code>pca</code> and <code>dudi</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dudi.pca(df, row.w = rep(1, nrow(df))/nrow(df), 
    col.w = rep(1, ncol(df)), center = TRUE, scale = TRUE, 
    scannf = TRUE, nf = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dudi.pca_+3A_df">df</code></td>
<td>
<p>a data frame with n rows (individuals) and p columns (numeric variables)</p>
</td></tr>
<tr><td><code id="dudi.pca_+3A_row.w">row.w</code></td>
<td>
<p>an optional row weights (by default, uniform row weights)</p>
</td></tr>
<tr><td><code id="dudi.pca_+3A_col.w">col.w</code></td>
<td>
<p>an optional column weights (by default, unit column weights)</p>
</td></tr>
<tr><td><code id="dudi.pca_+3A_center">center</code></td>
<td>
<p>a logical or numeric value, centring option<br />
if TRUE, centring by the mean<br />
if FALSE no centring<br />
if a numeric vector, its length must be equal to the number of columns of the data frame df
and gives the decentring</p>
</td></tr>
<tr><td><code id="dudi.pca_+3A_scale">scale</code></td>
<td>
<p>a logical value indicating whether the column vectors should be normed for the row.w weighting</p>
</td></tr>
<tr><td><code id="dudi.pca_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the screeplot should be displayed</p>
</td></tr>
<tr><td><code id="dudi.pca_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of classes <code>pca</code> and <code>dudi</code> (see <a href="#topic+dudi">dudi</a>) containing the used information
for computing the principal component analysis :
</p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>the data frame to be analyzed depending of the transformation arguments (center and scale)</p>
</td></tr>
<tr><td><code>cw</code></td>
<td>
<p>the column weights</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>the row weights</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>the eigenvalues</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the rank of the analyzed matrice</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>the number of kept factors</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>the column normed scores  i.e. the principal axes</p>
</td></tr>
<tr><td><code>l1</code></td>
<td>
<p>the row normed scores</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>the column coordinates</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>the row coordinates i.e. the principal components</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call function</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>the <em>p</em> vector containing the means for variables (Note that if <code>center = F</code>, the vector contains <em>p</em> 0)</p>
</td></tr>
<tr><td><code>norm</code></td>
<td>
<p>the <em>p</em> vector containing the standard deviations for variables i.e. the root
of the sum of squares deviations of the values from their means divided by <em>n</em> (Note that if <code>norm = F</code>, the vector contains <em>p</em> 1)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>See Also</h3>

<p><code>prcomp</code>, <code>princomp</code> in the <code>mva</code> library
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deug)
deug.dudi &lt;- dudi.pca(deug$tab, center = deug$cent, scale = FALSE, scan = FALSE)
deug.dudi1 &lt;- dudi.pca(deug$tab, center = TRUE, scale = TRUE, scan = FALSE)

if(adegraphicsLoaded()) {
  g1 &lt;- s.class(deug.dudi$li, deug$result, plot = FALSE)
  g2 &lt;- s.arrow(deug.dudi$c1, lab = names(deug$tab), plot = FALSE)
  g3 &lt;- s.class(deug.dudi1$li, deug$result, plot = FALSE)
  g4 &lt;- s.corcircle(deug.dudi1$co, lab = names(deug$tab), full = FALSE, plot = FALSE)
  G1 &lt;- rbindADEg(cbindADEg(g1, g2, plot = FALSE), cbindADEg(g3, g4, plot = FALSE), plot = TRUE)
  
  G2 &lt;- s1d.hist(deug.dudi$tab, breaks = seq(-45, 35, by = 5), type = "density", xlim = c(-40, 40), 
    right = FALSE, ylim = c(0, 0.1), porigin.lwd = 2)
    
} else {
  par(mfrow = c(2, 2))
  s.class(deug.dudi$li, deug$result, cpoint = 1)
  s.arrow(deug.dudi$c1, lab = names(deug$tab))
  s.class(deug.dudi1$li, deug$result, cpoint = 1)
  s.corcircle(deug.dudi1$co, lab = names(deug$tab), full = FALSE, box = TRUE)
  par(mfrow = c(1, 1))

  # for interpretations
  par(mfrow = c(3, 3))
  par(mar = c(2.1, 2.1, 2.1, 1.1))
  for(i in 1:9) {
    hist(deug.dudi$tab[,i], xlim = c(-40, 40), breaks = seq(-45, 35, by = 5), 
      prob = TRUE, right = FALSE, main = names(deug$tab)[i], xlab = "", ylim = c(0, 0.10))
  abline(v = 0, lwd = 3)
  }
  par(mfrow = c(1, 1))
}
</code></pre>

<hr>
<h2 id='dudi.pco'>Principal Coordinates Analysis</h2><span id='topic+dudi.pco'></span><span id='topic+scatter.pco'></span>

<h3>Description</h3>

<p><code>dudi.pco</code> performs a principal coordinates analysis of a Euclidean distance matrix
and returns the results as objects of class <code>pco</code> and <code>dudi</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dudi.pco(d, row.w = "uniform", scannf = TRUE, nf = 2, 
    full = FALSE, tol = 1e-07)
## S3 method for class 'pco'
scatter(x, xax = 1, yax = 2, clab.row = 1, posieig = "top", 
    sub = NULL, csub = 2, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dudi.pco_+3A_d">d</code></td>
<td>
<p>an object of class <code>dist</code> containing a Euclidean distance matrix.</p>
</td></tr>
<tr><td><code id="dudi.pco_+3A_row.w">row.w</code></td>
<td>
<p>an optional distance matrix row weights. 
If not NULL, must be a vector of positive numbers with length equal to the size of the distance matrix</p>
</td></tr>
<tr><td><code id="dudi.pco_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="dudi.pco_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="dudi.pco_+3A_full">full</code></td>
<td>
<p>a logical value indicating whether all the axes should be kept</p>
</td></tr>
<tr><td><code id="dudi.pco_+3A_tol">tol</code></td>
<td>
<p>a tolerance threshold to test whether the distance matrix is Euclidean :
an eigenvalue is considered positive if it is larger than 
<code>-tol*lambda1</code> where <code>lambda1</code> is the largest eigenvalue.</p>
</td></tr></table>
<p><br /><br />
</p>
<table>
<tr><td><code id="dudi.pco_+3A_x">x</code></td>
<td>
<p>an object of class <code>pco</code></p>
</td></tr>
<tr><td><code id="dudi.pco_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="dudi.pco_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="dudi.pco_+3A_clab.row">clab.row</code></td>
<td>
<p>a character size for the row labels</p>
</td></tr>
<tr><td><code id="dudi.pco_+3A_posieig">posieig</code></td>
<td>
<p>if &quot;top&quot; the eigenvalues bar plot is upside,
if &quot;bottom&quot; it is downside, if &quot;none&quot; no plot</p>
</td></tr>
<tr><td><code id="dudi.pco_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="dudi.pco_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="dudi.pco_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dudi.pco</code> returns a list of class <code>pco</code> and <code>dudi</code>. See <code><a href="#topic+dudi">dudi</a></code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Gower, J. C. (1966) Some distance properties of latent root and vector methods used in multivariate analysis. <em>Biometrika</em>, <b>53</b>, 325&ndash;338.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(yanomama)
gen &lt;- quasieuclid(as.dist(yanomama$gen))
geo &lt;- quasieuclid(as.dist(yanomama$geo))
ant &lt;- quasieuclid(as.dist(yanomama$ant))
geo1 &lt;- dudi.pco(geo, scann = FALSE, nf = 3)
gen1 &lt;- dudi.pco(gen, scann = FALSE, nf = 3)
ant1 &lt;- dudi.pco(ant, scann = FALSE, nf = 3)
plot(coinertia(ant1, gen1, scann = FALSE))
</code></pre>

<hr>
<h2 id='dunedata'>Dune Meadow Data</h2><span id='topic+dunedata'></span>

<h3>Description</h3>

<p><code>dunedata</code> is a data set containing for 20 sites, environmental variables and plant species. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dunedata)</code></pre>


<h3>Format</h3>

<p><code>dunedata</code> is a list with 2 components.
</p>

<dl>
<dt>envir</dt><dd><p>is a data frame with 20 rows (sites) 5 columns (environnemental variables).</p>
</dd>
<dt>veg</dt><dd><p>is a data frame with 20 rows (sites) 30 columns (plant species).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Jongman, R. H., ter Braak, C. J. F.  and van Tongeren, O. F. R.  (1987)
<em>Data analysis in community and landscape ecology</em>, Pudoc, Wageningen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dunedata)
summary(dunedata$envir)
is.ordered(dunedata$envir$use)
score(dudi.mix(dunedata$envir, scan = FALSE))
</code></pre>

<hr>
<h2 id='ecg'>Electrocardiogram data</h2><span id='topic+ecg'></span>

<h3>Description</h3>

<p>These data were measured during the normal sinus rhythm of a patient who occasionally experiences arrhythmia. 
There are 2048 observations measured in units of millivolts and collected at a rate of 180 samples per second.
This time series is a good candidate for a multiresolution analysis because its components are on different scales.
For example, the large scale (low frequency) fluctuations, known as baseline drift, are due to the patient respiration,
while the prominent short scale (high frequency) intermittent fluctuations between 3 and 4 seconds are evidently due to patient movement.
Heart rhythm determines most of the remaining features in the series. 
The large spikes occurring about 0.7 seconds apart the R waves of normal heart rhythm;
the smaller, but sharp peak coming just prior to an R wave is known as a P wave;
and the broader peak that comes after a R wave is a T wave.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ecg)</code></pre>


<h3>Format</h3>

<p>A vector of class <code>ts</code> containing 2048 observations.
</p>


<h3>Source</h3>

<p>Gust Bardy and Per Reinhall, University of Washington
</p>


<h3>References</h3>

<p>Percival, D. B., and Walden, A.T. (2000) <em>Wavelet Methods for Time Series Analysis</em>, Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# figure 130 in Percival and Walden (2000)
if (requireNamespace("waveslim") == TRUE) { 
data(ecg)
ecg.level &lt;- haar2level(ecg)
ecg.haar &lt;- orthobasis.haar(length(ecg))
ecg.mld &lt;- mld(ecg, ecg.haar, ecg.level, plot = FALSE)
res &lt;- cbind.data.frame(apply(ecg.mld[,1:5],1,sum), ecg.mld[,6:11])
par(mfrow = c(8,1))
par(mar = c(2, 5, 1.5, 0.6))
plot(as.ts(ecg), ylab = "ECG")
apply(res, 2, function(x) plot(as.ts(x), ylim = range(res),
 ylab = ""))
par(mfrow = c(1,1))
}
## End(Not run)
</code></pre>

<hr>
<h2 id='ecomor'>Ecomorphological Convergence</h2><span id='topic+ecomor'></span>

<h3>Description</h3>

<p>This data set gives ecomorphological informations about 129 bird species. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ecomor)</code></pre>


<h3>Format</h3>

<p><code>ecomor</code> is a list of 7 components.
</p>

<dl>
<dt>forsub</dt><dd><p>is a data frame with 129 species, 6 variables (the feeding place classes): 
foliage, ground , twig , bush, trunk and aerial feeders. These dummy variables indicate the use (1) 
or  no use (0) of a given feeding place by a species. </p>
</dd>
<dt>diet</dt><dd><p>is a data frame with 129 species and 8 variables (diet types): Gr (granivorous: seeds), 
Fr (frugivorous: berries, acorns, drupes), Ne (frugivorous: nectar), Fo (folivorous: leaves), 
In (invertebrate feeder: insects, spiders, myriapods, isopods, snails, worms), 
Ca (carnivorous: flesh of small vertebrates), Li (limnivorous: invertebrates in fresh water),
and Ch (carrion feeder). These dummy variables indicate the use (1) 
or  no use (0) of a given diet type by a species.</p>
</dd>
<dt>habitat</dt><dd><p>is a data frame with 129 species, 16 dummy variables (the habitats). 
These variables indicate the species presence (1) or the species absence (0) in a given habitat.</p>
</dd>
<dt>morpho</dt><dd><p>is a data frame with 129 species abd 8 morphological variables: wingl (Wing length, mm), 
taill (Tail length, mm), culml (Culmen length, mm), bilh (Bill height, mm), bilw (Bill width, mm), 
tarsl (Tarsus length, mm), midtl (Middle toe length, mm) and weig (Weight, g).</p>
</dd>
<dt>taxo</dt><dd><p>is a data frame with 129 species and 3 factors: Genus, Family and Order.
It is a data frame of class <code>'taxo'</code>: the variables are factors giving nested classifications.</p>
</dd>
<dt>labels</dt><dd><p>is a data frame with vectors of the names of species (complete and in abbreviated form.</p>
</dd>
<dt>categ</dt><dd><p>is a data frame with 129 species, 2 factors : 'forsub' summarizing the feeding place and 
'diet' the diet type.</p>
</dd>
</dl>


<h3>Source</h3>

<p>Blondel, J., Vuilleumier, F., Marcus, L.F., and Terouanne, E. (1984). Is there ecomorphological convergence 
among mediterranean bird communities of Chile, California, and France. In <em>Evolutionary Biology</em> 
(eds M.K. Hecht, B. Wallace and R.J. MacIntyre), 141&ndash;213, <b>18</b>. Plenum Press, New York.
</p>


<h3>References</h3>

<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps023.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps023.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecomor)
ric &lt;- apply(ecomor$habitat, 2, sum)
s.corcircle(dudi.pca(log(ecomor$morpho), scan = FALSE)$co)

forsub &lt;- data.frame(t(apply(ecomor$forsub, 1, function (x) x / sum(x))))
pca1 &lt;- dudi.pca(forsub, scan = FALSE, scale = FALSE)
w1 &lt;- as.matrix(forsub)
if(adegraphicsLoaded()) {
  g1 &lt;- s.arrow(pca1$c1, plot = FALSE)
  g2 &lt;- s.label(w1, plab.cex = 0, ppoi.cex = 2, plot = FALSE)
  G1 &lt;- superpose(g1, g2, plot = TRUE)
} else {
  s.arrow(pca1$c1)
  s.label(w1, clab = 0, add.p = TRUE, cpoi = 2)
}

diet &lt;- data.frame(t(apply(ecomor$diet, 1, function (x) x / sum(x))))
pca2 &lt;- dudi.pca(diet, scan = FALSE, scale = FALSE)
w2 &lt;- as.matrix(diet)
if(adegraphicsLoaded()) {
  g3 &lt;- s.arrow(pca2$c1, plot = FALSE)
  g4 &lt;- s.label(w2, plab.cex = 0, ppoi.cex = 2, plot = FALSE)
  G2 &lt;- superpose(g3, g4, plot = TRUE)
} else {
  s.arrow(pca2$c1)
  s.label(w2, clab = 0, add.p = TRUE, cpoi = 2)
}


## Not run: 
dmorpho &lt;- dist.quant(log(ecomor$morpho), 3)
dhabitat &lt;- dist.binary(ecomor$habitat, 1)
dtaxo &lt;- dist.taxo(ecomor$taxo)

mantel.randtest(dmorpho, dhabitat)
RV.rtest(pcoscaled(dmorpho), pcoscaled(dhabitat), 999)
procuste.randtest(pcoscaled(dmorpho), pcoscaled(dhabitat))

ecophy &lt;- taxo2phylog(ecomor$taxo, add.tools=TRUE)
table.phylog(ecomor$habitat, ecophy, clabel.n = 0.5, f = 0.6,
     clabel.c = 0.75, clabel.r = 0.5, csi = 0.75, cleg = 0)
plot(ecophy, clabel.n = 0.75, clabel.l = 0.75,
     labels.l = ecomor$labels[,"latin"])
mantel.randtest(dmorpho, dtaxo)
mantel.randtest(dhabitat, dtaxo)

## End(Not run)</code></pre>

<hr>
<h2 id='elec88'>Electoral Data</h2><span id='topic+elec88'></span>

<h3>Description</h3>

<p>This data set gives the results of the presidential election in France in 1988 
for each department and all the candidates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(elec88)</code></pre>


<h3>Format</h3>

<p><code>elec88</code> is a list with the following components:
</p>

<dl>
<dt>tab</dt><dd><p>a data frame with 94 rows (departments) and 9 variables (candidates)</p>
</dd>
<dt>res</dt><dd><p>the global result of the election all-over the country</p>
</dd>
<dt>lab</dt><dd><p>a data frame with two variables: <code>elec88$lab$dep</code> is a 
vector containing the names of the 94 french departments, 
<code>elec88$lab$reg</code> is a vector containing the names of the 
21 French administrative regions.</p>
</dd>
<dt>area</dt><dd><p>the data frame of 3 variables returning the boundary lines of each department. 
The first variable is a factor. The levels of this one are the row.names of <code>tab</code>. 
The second and third variables return the coordinates (x, y) of the points of the boundary line.</p>
</dd>
<dt>contour</dt><dd><p>a data frame with 4 variables (x1, y1, x2, y2) for the contour display of France</p>
</dd>
<dt>xy</dt><dd><p>a data frame with two variables (x, y) giving the position of the center for each department</p>
</dd>
<dt>neig</dt><dd><p>the neighbouring graph between departments, object of the class <code>neig</code></p>
</dd>
<dt>nb</dt><dd><p>the neighbouring graph between departments, object of the class <code>nb</code></p>
</dd>
<dt>Spatial</dt><dd><p>the map of the french departments in Lambert II coordinates 
(an object of the class <code>SpatialPolygons</code> of <code>sp</code>)</p>
</dd>
<dt>Spatial.contour</dt><dd><p>the contour of the map of France in Lambert II 
coordinates (an object of the class <code>SpatialPolygons</code> of <code>sp</code>)</p>
</dd>
</dl>


<h3>Source</h3>

<p>Public data</p>


<h3>See Also</h3>

<p>This dataset is compatible with <code>presid2002</code> and <code>cnc2003</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(elec88)
apply(elec88$tab, 2, mean)
summary(elec88$res)
pca1 &lt;- dudi.pca(elec88$tab, scale = FALSE, scannf = FALSE)

if(adegraphicsLoaded()) {
  if(requireNamespace("sp", quietly = TRUE)) {
    data1 &lt;- as.data.frame(as.numeric(rownames(elec88$tab) == "D25"))
    rownames(data1) &lt;- row.names(elec88$Spatial)
    obj1 &lt;- sp::SpatialPolygonsDataFrame(Sr = elec88$Spatial, data = data1)
    g1 &lt;- s.Spatial(obj1, psub.text = "", plot = FALSE)
    g2 &lt;- s.Spatial(obj1, psub.text = "", nb = elec88$nb, pnb.node.cex = 0, plot = FALSE)

    data3 &lt;- as.data.frame(elec88$xy[, 1] + elec88$xy[, 2])
    rownames(data3) &lt;- row.names(elec88$Spatial)
    obj3 &lt;- sp::SpatialPolygonsDataFrame(Sr = elec88$Spatial, data = data3)
    g3 &lt;- s.Spatial(obj3, psub.text = "", plot = FALSE)
    
    data4 &lt;- as.data.frame(pca1$li[, 1])
    rownames(data4) &lt;- row.names(elec88$Spatial)
    obj4 &lt;- sp::SpatialPolygonsDataFrame(Sr = elec88$Spatial, data = data4)
    g4 &lt;- s.Spatial(obj4, psub.text = "F1 PCA", plot = FALSE)
    
    G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  }
  
} else {
  par(mfrow = c(2, 2))
  plot(elec88$area[, 2:3], type = "n", asp = 1)
  lpoly &lt;- split(elec88$area[, 2:3], elec88$area[, 1])
  lapply(lpoly, function(x) {points(x, type = "l"); invisible()})
  polygon(elec88$area[elec88$area$V1 == "D25", 2:3], col = 1)
  area.plot(elec88$area, graph = elec88$neig, lwdg = 1)
  polygon(elec88$area[elec88$area$V1 == "D25", 2:3], col = 1)
  area.plot(elec88$area, val = elec88$xy[, 1] + elec88$xy[, 2])
  area.plot(elec88$area, val = pca1$li[, 1], sub = "F1 PCA", 
    csub = 2, cleg = 1.5)
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='escopage'>K-tables of wine-tasting</h2><span id='topic+escopage'></span>

<h3>Description</h3>

<p>This data set describes 27 characteristics of 21 wines distributed in four fields : 
rest, visual, olfactory and global. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(escopage)</code></pre>


<h3>Format</h3>

<p><code>escopage</code> is a list of 3 components.
</p>

<dl>
<dt>tab</dt><dd><p>is a data frame with 21 observations (wines) and 27 variables. </p>
</dd>
<dt>tab.names</dt><dd><p>is the vector of the names of sub-tables : &quot;rest&quot; &quot;visual&quot; &quot;olfactory&quot; &quot;global&quot;.</p>
</dd>
<dt>blo</dt><dd><p>is a vector of the numbers of variables for each sub-table.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Escofier, B. and Pagès, J. (1990) 
<em>Analyses factorielles simples et multiples : objectifs, méthodes et interprétation</em> 
Dunod, Paris. 1&ndash;267.
</p>
<p>Escofier, B. and Pagès, J. (1994) 
Multiple factor analysis (AFMULT package). 
<em>Computational Statistics and Data Analysis</em>, <b>18</b>, 121&ndash;140.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(escopage)
w &lt;- data.frame(scale(escopage$tab))
w &lt;- ktab.data.frame(w, escopage$blo)
names(w)[1:4] &lt;- escopage$tab.names
plot(mfa(w, scan = FALSE))
</code></pre>

<hr>
<h2 id='euro123'>Triangular Data</h2><span id='topic+euro123'></span>

<h3>Description</h3>

<p>This data set gives the proportions of employement in the primary, secondary and tertiary 
sectors for 12 European countries in 1978, 1986 and 1997. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(euro123)</code></pre>


<h3>Format</h3>

<p><code>euro123</code> is a list of 4 components.
</p>

<dl>
<dt>in78</dt><dd><p>is a data frame with 12 rows and 3 variables.</p>
</dd>
<dt>in86</dt><dd><p>: idem in 1986</p>
</dd>
<dt>in97</dt><dd><p>: idem in 1997</p>
</dd>
<dt>plan</dt><dd><p>is a data frame with two factors to both organize the 3 tables.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Encyclopaedia Universalis, Symposium, Les chiffres du Monde. Encyclopaedia Universalis, Paris. 519.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(euro123)

if(adegraphicsLoaded()) {
  g1 &lt;- triangle.label(euro123$in78, addaxes = TRUE, plabels.cex = 0, 
    plot = FALSE)
  g2 &lt;- triangle.label(euro123$in86, addaxes = TRUE, plabels.cex = 0, 
    plot = FALSE)
  g3 &lt;- triangle.label(euro123$in97, addaxes = TRUE, plabels.cex = 0, 
    plot = FALSE)
  g4 &lt;- triangle.match(euro123$in78, euro123$in97, plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  
} else {
  par(mfrow = c(2,2))
  triangle.plot(euro123$in78, addaxes = TRUE)
  triangle.plot(euro123$in86, addaxes = TRUE)
  triangle.plot(euro123$in97, addaxes = TRUE)
  triangle.biplot(euro123$in78, euro123$in97)
  par(mfrow = c(1,1))
}</code></pre>

<hr>
<h2 id='fission'>Fission pattern and heritable morphological traits</h2><span id='topic+fission'></span>

<h3>Description</h3>

<p>This data set contains the mean values of five highly heritable linear combinations of cranial metric (GM1-GM3) and non metric (GN1-GN2) for 8 social groups of Rhesus Macaques on Cayo Santiago. It also describes the fission tree depicting the historical phyletic relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fission)</code></pre>


<h3>Format</h3>

<p><code>fission</code> is a list containing the 2 following objects : 
</p>
   
<dl>
<dt>tre</dt><dd><p>is a character string giving the fission tree in Newick format.</p>
</dd> 
<dt>tab</dt><dd><p>is a data frame with 8 social groups and five traits : cranial metrics (GM1, GM2, GM3) and
cranial non metrics (GN1, GN2)</p>
</dd></dl>
  


<h3>References</h3>

<p>Cheverud, J. and Dow, M.M. (1985) An autocorrelation analysis of genetic variation due to lineal fission in social groups of rhesus macaques. 
<em>American Journal of Physical Anthropology</em>, <b>67</b>, 113&ndash;122.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fission)
fis.phy &lt;- newick2phylog(fission$tre)
table.phylog(fission$tab[names(fis.phy$leaves),], fis.phy, csi = 2)
gearymoran(fis.phy$Amat, fission$tab)
</code></pre>

<hr>
<h2 id='foucart'>K-tables Correspondence Analysis with the same rows and the same columns</h2><span id='topic+foucart'></span><span id='topic+plot.foucart'></span><span id='topic+print.foucart'></span>

<h3>Description</h3>

<p>K tables have the same rows and the same columns.<br />
Each table is transformed by P = X/sum(X). The average of P is computing.<br />
A correspondence analysis is realized on this average.<br />
The initial rows and the initial columns are projected in supplementary elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foucart(X, scannf = TRUE, nf = 2)
## S3 method for class 'foucart'
plot(x, xax = 1, yax = 2, clab = 1, csub = 2, 
    possub = "bottomright", ...) 
## S3 method for class 'foucart'
print(x, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foucart_+3A_x">X</code></td>
<td>
<p>a list of data frame where the row names and the column names are the same for each table</p>
</td></tr>
<tr><td><code id="foucart_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="foucart_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>
<p><br />
</p>
<table>
<tr><td><code id="foucart_+3A_x">x</code></td>
<td>
<p>an object of class 'foucart'</p>
</td></tr>
<tr><td><code id="foucart_+3A_xax">xax</code></td>
<td>
<p>the column number of the x-axis</p>
</td></tr>
<tr><td><code id="foucart_+3A_yax">yax</code></td>
<td>
<p>the column number of the y-axis</p>
</td></tr>
<tr><td><code id="foucart_+3A_clab">clab</code></td>
<td>
<p>if not NULL, a character size for the labels, used with <code>par("cex")*clab</code></p>
</td></tr>
<tr><td><code id="foucart_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="foucart_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="foucart_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>foucart</code> returns a list of the classes 'dudi', 'coa' and 'foucart'
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>origine</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>axes-components saved</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>rank</p>
</td></tr>
<tr><td><code>blo</code></td>
<td>
<p>useful vector</p>
</td></tr>
<tr><td><code>cw</code></td>
<td>
<p>vector: column weights</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>vector: row weights</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>vector: eigen values</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p>data.frame: modified array</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>data.frame: row coordinates</p>
</td></tr>
<tr><td><code>l1</code></td>
<td>
<p>data.frame: row normed scores</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>data.frame: column coordinates</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>data.frame: column normed scores</p>
</td></tr>
<tr><td><code>Tli</code></td>
<td>
<p>data.frame: row coordinates (each table)</p>
</td></tr>
<tr><td><code>Tco</code></td>
<td>
<p>data.frame: col coordinates (each table)</p>
</td></tr>
<tr><td><code>TL</code></td>
<td>
<p>data.frame: factors for Tli</p>
</td></tr>
<tr><td><code>TC</code></td>
<td>
<p>data.frame: factors for Tco</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pierre Bady <a href="mailto:pierre.bady@univ-lyon1.fr">pierre.bady@univ-lyon1.fr</a><br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Foucart, T. (1984) <em>Analyse factorielle de tableaux multiples</em>, Masson, Paris.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bf88)
fou1 &lt;- foucart(bf88, scann = FALSE, nf = 3)
fou1
plot(fou1)

data(meaudret)
l1 &lt;- split(meaudret$spe, meaudret$design$season)
l1 &lt;- lapply(l1, function(x) 
    {row.names(x) &lt;- paste("Sit",1:5,sep="");x})
fou2 &lt;- foucart(l1, scan = FALSE)

if(adegraphicsLoaded()) {
  kplot(fou2, row.plabels.cex = 2)
} else {
  kplot(fou2, clab.r = 2)
}
</code></pre>

<hr>
<h2 id='fourthcorner'> Functions to compute the fourth-corner statistic  </h2><span id='topic+fourthcorner'></span><span id='topic+fourthcorner2'></span><span id='topic+print.4thcorner'></span><span id='topic+summary.4thcorner'></span><span id='topic+plot.4thcorner'></span><span id='topic+fourthcorner.rlq'></span>

<h3>Description</h3>

<p>These functions allow to compute the fourth-corner statistic for abundance or presence-absence data. The fourth-corner statistic has been developed by Legendre et al (1997) and extended in Dray and Legendre (2008). The statistic measures the link between three tables: a table L (n x p) containing the abundances of p species at n sites, a second table R (n x m) containing the measurements of m environmental variables for the n sites, and a third table Q (p x s) describing s species traits for the p species. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourthcorner(tabR, tabL, tabQ, modeltype = 6, nrepet = 999, tr01 =
FALSE, p.adjust.method.G = p.adjust.methods, p.adjust.method.D =
p.adjust.methods, p.adjust.D = c("global", "levels"), ...)
fourthcorner2(tabR, tabL, tabQ, modeltype = 6, nrepet = 999, tr01 =
FALSE, p.adjust.method.G = p.adjust.methods, ...)
## S3 method for class '4thcorner'
print(x, varQ = 1:length(x$varnames.Q), varR =
1:length(x$varnames.R), stat = c("D", "D2"), ...)
## S3 method for class '4thcorner'
summary(object,...)
## S3 method for class '4thcorner'
plot(x, stat = c("D", "D2", "G"), type = c("table",
"biplot"), xax = 1, yax = 2, x.rlq = NULL, alpha = 0.05, col =
c("lightgrey", "red", "deepskyblue", "purple"), ...)
fourthcorner.rlq(xtest, nrepet = 999, modeltype = 6, typetest =
c("axes", "Q.axes", "R.axes"), p.adjust.method.G = p.adjust.methods,
p.adjust.method.D = p.adjust.methods, p.adjust.D = c("global",
"levels"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fourthcorner_+3A_tabr">tabR</code></td>
<td>
<p> a dataframe containing the measurements (numeric values or factors) of m environmental variables (columns) for the n sites (rows).</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_tabl">tabL</code></td>
<td>
<p> a dataframe containing the abundances of p species (columns) at n sites (rows).</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_tabq">tabQ</code></td>
<td>
<p> a dataframe containing numeric values or factors describing s species traits (columns) for the p species (rows).</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_modeltype">modeltype</code></td>
<td>
<p> an integer (1-6) indicating the permutation model used in the testing procedure (see details). </p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_nrepet">nrepet</code></td>
<td>
<p> the number of permutations </p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_tr01">tr01</code></td>
<td>
<p> a logical indicating if data in <code>tabL</code> must be transformed to presence-absence data (FALSE by default)</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_object">object</code></td>
<td>
<p> an object of the class 4thcorner</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_x">x</code></td>
<td>
<p> an object of the class 4thcorner</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_varr">varR</code></td>
<td>
<p> a vector containing indices for variables in <code>tabR</code></p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_varq">varQ</code></td>
<td>
<p> a vector containing indices for variables in <code>tabQ</code></p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_type">type</code></td>
<td>
<p> results are represented by a table or on a biplot (see x.rlq)</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_alpha">alpha</code></td>
<td>
<p> a value of significance level</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_p.adjust.method.g">p.adjust.method.G</code></td>
<td>
<p>a string indicating a method for multiple
adjustment used for output tabG, see <code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code> for possible choices</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_p.adjust.method.d">p.adjust.method.D</code></td>
<td>
<p>a string indicating a method for multiple
adjustment used for output tabD/tabD2, see <code>p.adjust.methods</code> for possible choices</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_p.adjust.d">p.adjust.D</code></td>
<td>
<p>a string indicating if multiple adjustment for
tabD/tabD2 should be done globally or only between levels of a factor
(&quot;levels&quot;, as in the original paper of Legendre et al. 1997)</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_stat">stat</code></td>
<td>
<p>a character to specify if results should be plotted for
cells (D and D2) or variables (G)</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_xax">xax</code></td>
<td>
<p>an integer indicating which rlq axis should be plotted on the x-axis</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_yax">yax</code></td>
<td>
<p>an integer indicating which rlq axis should be plotted on the y-axis</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_x.rlq">x.rlq</code></td>
<td>
<p>an object created by the <code>rlq</code> function. Used to
represent results on a biplot (type should be &quot;biplot&quot; and object
created by the <code>fourthcorner</code> functions)</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_col">col</code></td>
<td>
<p>a vector of length 4 containing four colors used for the
graphical representations. The first is used to represent non-significant
associations, the second positive significant, the third negative
significant. For the 'biplot' method and objects created by the
<code>fourthcorner.rlq</code> function, the second corresponds to variables
significantly linked
to the x-axis, the third for the y-axis and the fourth for both axes</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_xtest">xtest</code></td>
<td>
<p>an object created by the <code>rlq</code> function</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_typetest">typetest</code></td>
<td>
<p>a string indicating which tests should be performed</p>
</td></tr>
<tr><td><code id="fourthcorner_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>fourthcorner</code> function, the link is measured by a Pearson correlation coefficient for two quantitative variables (trait and environmental variable), by a Pearson Chi2 and G statistic for two qualitative variables and by a Pseudo-F and Pearson r for one quantitative variable and one qualitative variable. The fourthcorner2 function offers a multivariate statistic (equal to the sum of eigenvalues of RLQ analysis) and measures the link between two variables by a square correlation coefficient (quant/quant), a Chi2/sum(L) (qual/qual) and a correlation ratio (quant/qual). The significance is tested by a permutation procedure. Different models are available:
</p>

<ul>
<li><p> model 1 (<code>modeltype</code>=1): Permute values for each species independently (i.e., permute within each column of table L)
</p>
</li>
<li><p> model 2 (<code>modeltype</code>=2): Permute values of sites (i.e., permute entire rows of table L)
</p>
</li>
<li><p> model 3 (<code>modeltype</code>=3): Permute values for each site independently (i.e., permute within each row of table L)
</p>
</li>
<li><p> model 4 (<code>modeltype</code>=4): Permute values of species (i.e., permute entire columns of table L)
</p>
</li>
<li><p> model 5 (<code>modeltype</code>=5): Permute values of species and after
(or before) permute values of sites (i.e., permute entire columns and
after (or before) entire rows of table L)
</p>
</li>
<li><p> model 6 (<code>modeltype</code>=6): combination of the outputs of models
2 and 4. Dray and Legendre (2008) and ter Braak et al. (20012) showed
that all models (except model 6) have inflated type I error.
</p>
</li></ul>

<p>Note that the model 5 is strictly equivalent to permuting
simultaneously the rows of tables R and Q, as proposed by Doledec et
al. (1996).
</p>
<p>The function <code>summary</code> returns results for variables (G). The
function <code>print</code> returns results for cells (D and D2). In the case
of qualitative variables, Holm's corrected pvalues are also provided.
</p>
<p>The function <code>plot</code> produces a graphical representation of the
results (white for non significant, light grey for negative significant
and dark grey for positive significant relationships). Results can be
plotted for variables (G) or for cells (D and D2). In the case of
qualitative / quantitative association, homogeneity (D) or correlation
(D2) are plotted.
</p>


<h3>Value</h3>

<p>The <code>fourthcorner</code> function returns a a list where:
</p>
<p><code>tabD</code> is a <code>krandtest</code> object giving the results of tests
for cells of the fourth-corner (homogeneity for quant./qual.).
<code>tabD2</code> is a <code>krandtest</code> object giving the results of tests
for cells of the fourth-corner (Pearson r for quant./qual.).
<code>tabG</code> is a <code>krandtest</code> object giving the results of tests
for variables (Pearson's Chi2 for qual./qual.).
</p>
<p>The <code>fourthcorner2</code> function returns a list where:
</p>
<p><code>tabG</code> is a <code>krandtest</code> object giving the results of tests for
variables.
<code>trRLQ</code> is a <code>krandtest</code> object giving the results of tests for
the multivariate statistic (i.e. equivalent to <code>randtest.rlq</code> function).
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a></p>


<h3>References</h3>

 
<p>Doledec, S., Chessel, D., ter Braak, C.J.F. and Champely, S. (1996) 
Matching species traits to environmental variables: a new three-table ordination method. <em>Environmental and Ecological Statistics</em>, 
<b>3</b>, 143&ndash;166.
</p>
<p>Legendre, P., R. Galzin, and M. L. Harmelin-Vivien. (1997)
Relating behavior to habitat: solutions to the fourth-corner problem. <em>Ecology</em>,
<b>78</b>, 547&ndash;562.
</p>
<p>Dray, S. and Legendre, P. (2008) 
Testing the species traits-environment relationships: the fourth-corner
problem revisited. <em>Ecology</em>,
<b>89</b>, 3400&ndash;3412.
</p>
<p>ter Braak, C., Cormont, A., and Dray, S. (2012)
Improved testing of species traits-environment relationships in the
fourth corner problem. <em>Ecology</em>, <b>93</b>, 1525&ndash;1526.
</p>
<p>Dray, S., Choler, P., Doledec, S., Peres-Neto, P.R., Thuiller, W.,
Pavoine, S. and ter Braak, C.J.F (2014)
Combining the fourth-corner and the RLQ methods for assessing trait
responses to environmental variation. <em>Ecology</em>, <b>95</b>, 14&ndash;21. doi:10.1890/13-0196.1
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+rlq">rlq</a></code>, <code><a href="#topic+combine.4thcorner">combine.4thcorner</a></code>, <code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aviurba)

## Version using the sequential test (ter Braak et al 2012)
## as recommended in Dray et al (2013), 
## using Holm correction of P-values (only 99 permutations here)
four.comb.default &lt;- fourthcorner(aviurba$mil,aviurba$fau,aviurba$traits,nrepet=99)
summary(four.comb.default)
plot(four.comb.default, stat = "G")

## using fdr correction of P-values
four.comb.fdr &lt;- fourthcorner(aviurba$mil, aviurba$fau, aviurba$traits,
nrepet = 99, p.adjust.method.G = 'fdr', p.adjust.method.D = 'fdr')  
summary(four.comb.fdr)
plot(four.comb.fdr, stat = "G")

## Explicit procedure to combine the results of two models
## proposed in Dray and Legendre (2008);the above does this implicitly
four2 &lt;- fourthcorner(aviurba$mil,aviurba$fau,aviurba$traits,nrepet=99,modeltype=2)
four4 &lt;- fourthcorner(aviurba$mil,aviurba$fau,aviurba$traits,nrepet=99,modeltype=4)
four.comb &lt;- combine.4thcorner(four2, four4)
summary(four.comb)
plot(four.comb, stat = "G")


</code></pre>

<hr>
<h2 id='friday87'>Faunistic K-tables</h2><span id='topic+friday87'></span>

<h3>Description</h3>

<p>This data set gives informations about sites, species and environmental variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(friday87)</code></pre>


<h3>Format</h3>

<p><code>friday87</code> is a list of 4 components.
</p>

<dl>
<dt>fau</dt><dd><p>is a data frame containing a faunistic table with 16 sites and 91 species.</p>
</dd>
<dt>mil</dt><dd><p>is a data frame with 16 sites and 11 environmental variables.</p>
</dd>
<dt>fau.blo</dt><dd><p>is a vector of the number of species per group.</p>
</dd>
<dt>tab.names</dt><dd><p>is the name of each group of species.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Friday, L.E. (1987) The diversity of macroinvertebrate and macrophyte communities in ponds, <em>Freshwater Biology</em>, <b>18</b>, 87&ndash;104.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(friday87)
wfri &lt;- data.frame(scale(friday87$fau, scal = FALSE))
wfri &lt;- ktab.data.frame(wfri, friday87$fau.blo, 
    tabnames = friday87$tab.names)

if(adegraphicsLoaded()) {    
  g1 &lt;- kplot(sepan(wfri), row.plabels.cex = 2)
} else {
  kplot(sepan(wfri), clab.r = 2, clab.c = 1)
}
</code></pre>

<hr>
<h2 id='fruits'>Pair of Tables</h2><span id='topic+fruits'></span>

<h3>Description</h3>

<p>28 batches of fruits -two types- are judged by two different ways.<br />
They are classified in order of preference, without ex aequo, by 16 individuals.<br />
15 quantitative variables described the batches of fruits.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fruits)</code></pre>


<h3>Format</h3>

<p><code>fruits</code> is a list of 3 components:
</p>

<dl>
<dt>typ</dt><dd><p>is a vector returning the type of the 28 batches of fruits (peaches or nectarines).</p>
</dd>
<dt>jug</dt><dd><p>is a data frame of 28 rows and 16 columns (judges).</p>
</dd>
<dt>var</dt><dd><p>is a data frame of 28 rows and 16 measures (average of 2 judgements).</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>fruits$var</code> is a data frame of 15 variables:
</p>

<ol>
<li><p> taches: quantity of cork blemishes (0=absent - maximum 5)
</p>
</li>
<li><p> stries: quantity of stria (1/none - maximum 4)
</p>
</li>
<li><p> abmucr: abundance of mucron (1/absent - 4)
</p>
</li>
<li><p> irform: shape irregularity (0/none - 3)
</p>
</li>
<li><p> allong: length of the fruit (1/round fruit - 4)
</p>
</li>
<li><p> suroug: percentage of the red surface (minimum 40% - maximum 90%)
</p>
</li>
<li><p> homlot: homogeneity of the intra-batch coloring (1/strong - 4)
</p>
</li>
<li><p> homfru: homogeneity of the intra-fruit coloring (1/strong - 4)
</p>
</li>
<li><p> pubesc: pubescence (0/none - 4)
</p>
</li>
<li><p> verrou: intensity of green in red area (1/none - 4)
</p>
</li>
<li><p> foncee: intensity of dark area (0/pink - 4)
</p>
</li>
<li><p> comucr: intensity of the mucron color (1=no contrast - 4/dark)
</p>
</li>
<li><p> impres: kind of impression (1/watched - 4/pointillé)
</p>
</li>
<li><p> coldom: intensity of the predominating color (0/clear - 4)
</p>
</li>
<li><p> calibr: grade (1/&lt;90g - 5/&gt;200g)
</p>
</li></ol>



<h3>Source</h3>

<p> Kervella, J. (1991) Analyse de l'attrait d'un produit : 
exemple d'une comparaison de lots de pêches. Agro-Industrie et 
méthodes statistiques. Compte-rendu des secondes journées 
européennes. Nantes 13-14 juin 1991.  Association pour la 
Statistique et ses Utilisations, Paris, 313&ndash;325.</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(fruits)
pcajug &lt;- dudi.pca(fruits$jug, scann = FALSE)
pcavar &lt;- dudi.pca(fruits$var, scann = FALSE)

if(adegraphicsLoaded()) {
  g1 &lt;- s.corcircle(pcajug$co, plot = FALSE)
  g2 &lt;- s.class(pcajug$li, fac = fruits$type, plot = FALSE)
  g3 &lt;- s.corcircle(pcavar$co, plot = FALSE)
  g4 &lt;- s.class(pcavar$li, fac = fruits$type, plot = FALSE)
  
  G1 &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  G2 &lt;- plot(coinertia(pcajug, pcavar, scan = FALSE))

} else {
  par(mfrow = c(2,2)) 
  s.corcircle(pcajug$co)
  s.class(pcajug$li, fac = fruits$type)
  s.corcircle(pcavar$co)
  s.class(pcavar$li, fac = fruits$type)
  
  par(mfrow = c(1,1))
  plot(coinertia(pcajug, pcavar, scan = FALSE))
}
</code></pre>

<hr>
<h2 id='gearymoran'>Moran's I and Geary'c randomization tests for spatial and phylogenetic autocorrelation</h2><span id='topic+gearymoran'></span>

<h3>Description</h3>

<p>This function performs Moran's I test using phylogenetic and spatial link matrix (binary or general). It uses neighbouring weights so Moran's I and Geary's c randomization tests are equivalent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gearymoran(bilis, X, nrepet = 999, alter=c("greater", "less", "two-sided"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gearymoran_+3A_bilis">bilis</code></td>
<td>
<p>: a <em>n</em> by <em>n</em> link matrix where <em>n</em> is the row number of X</p>
</td></tr>
<tr><td><code id="gearymoran_+3A_x">X</code></td>
<td>
<p>: a data frame with continuous variables</p>
</td></tr>
<tr><td><code id="gearymoran_+3A_nrepet">nrepet</code></td>
<td>
<p>: number of random vectors for the randomization test</p>
</td></tr>
<tr><td><code id="gearymoran_+3A_alter">alter</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of &quot;greater&quot; (default), &quot;less&quot; or &quot;two-sided&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bilis</code> is a squared symmetric matrix which terms are all positive or null. 
</p>
<p><code>bilis</code> is firstly transformed in frequency matrix A by dividing it by the total sum of data matrix :  
</p>
<p style="text-align: center;"><code class="reqn">a_{ij} = \frac{bilis_{ij}}{\sum_{i=1}^{n}\sum_{j=1}^{n}bilis_{ij}}</code>
</p>
 
<p>The neighbouring weights is defined by the matrix <code class="reqn">D = diag(d_1,d_2, \ldots)</code> where <code class="reqn">d_i = \sum_{j=1}^{n}bilis_{ij}</code>.
For each vector x of the data frame X, the test is based on the Moran statistic <code class="reqn">x^{t}Ax</code> where x is D-centred. 
</p>


<h3>Value</h3>

<p>Returns an object of class <code>krandtest</code> (randomization tests).
</p>


<h3>Author(s)</h3>

<p>Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a> <br />
Daniel Chessel 
</p>


<h3>References</h3>

<p>Cliff, A. D. and Ord, J. K. (1973) <em>Spatial autocorrelation</em>, Pion, London.
</p>
<p>Thioulouse, J., Chessel, D. and Champely, S. (1995) Multivariate analysis of spatial patterns: a unified approach to local and global structures. 
<em>Environmental and Ecological Statistics</em>, <b>2</b>, 1&ndash;14.
</p>


<h3>See Also</h3>

<p><code><a href="spdep.html#topic+moran.test">moran.test</a></code> and <code><a href="spdep.html#topic+geary.test">geary.test</a></code> for classical versions of Moran's test and Geary's one</p>


<h3>Examples</h3>

<pre><code class='language-R'># a spatial example
data(mafragh)
tab0 &lt;- (as.data.frame(scalewt(mafragh$env)))
bilis0 &lt;- neig2mat(mafragh$neig)
gm0 &lt;- gearymoran(bilis0, tab0, 999)
gm0
plot(gm0, nclass = 20)

## Not run: 
# a phylogenetic example
data(mjrochet)
mjr.phy &lt;- newick2phylog(mjrochet$tre)
mjr.tab &lt;- log(mjrochet$tab)
gearymoran(mjr.phy$Amat, mjr.tab)
gearymoran(mjr.phy$Wmat, mjr.tab)

if(adegraphicsLoaded()) {
  g1 &lt;- table.value(mjr.phy$Wmat, ppoints.cex = 0.35, nclass = 5,
    axis.text = list(cex = 0), plot = FALSE)
  g2 &lt;- table.value(mjr.phy$Amat, ppoints.cex = 0.35, nclass = 5,
    axis.text = list(cex = 0), plot = FALSE)
  G &lt;- cbindADEg(g1, g2, plot = TRUE)
  
} else {
  par(mfrow = c(1, 2))
  table.value(mjr.phy$Wmat, csi = 0.25, clabel.r = 0)
  table.value(mjr.phy$Amat, csi = 0.35, clabel.r = 0)
  par(mfrow = c(1, 1))
}

## End(Not run)</code></pre>

<hr>
<h2 id='ggtortoises'>Microsatellites of Galapagos tortoises populations</h2><span id='topic+ggtortoises'></span>

<h3>Description</h3>

<p>This data set gives genetic relationships between Galapagos tortoises 
populations with 10 microsatellites. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ggtortoises)</code></pre>


<h3>Format</h3>

<p><code>ggtortoises</code> is a list with the following components:
</p>

<dl>
<dt>area</dt><dd><p>a data frame designed to be used in the <code>area.plot</code> function</p>
</dd>
<dt>ico</dt><dd><p>a list of three pixmap icons representing the tortoises morphotypes</p>
</dd>
<dt>pop</dt><dd><p>a data frame containing meta informations about populations</p>
</dd>
<dt>misc</dt><dd><p>a data frame containing the coordinates of the island labels</p>
</dd>
<dt>loc</dt><dd><p>a numeric vector giving the number of alleles by marker</p>
</dd>
<dt>tab</dt><dd><p>a data frame containing the number of alleles by populations for 10 microsatellites</p>
</dd>
<dt>Spatial</dt><dd><p>an object of the class <code>SpatialPolygons</code> of <code>sp</code>,
containing the map</p>
</dd>
</dl>


<h3>Source</h3>

<p>M.C. Ciofi, C. Milinkovitch, J.P. Gibbs, A. Caccone, and J.R. Powell (2002) 
Microsatellite analysis of genetic divergence among populations of giant 
galapagos tortoises. <em>Molecular Ecology</em> <b>11</b>: 2265-2283.
</p>


<h3>References</h3>

<p>M.C. Ciofi, C. Milinkovitch, J.P. Gibbs, A. Caccone, and J.R. Powell (2002).
Microsatellite analysis of genetic divergence among populations of giant 
galapagos tortoises. <em>Molecular Ecology</em> <b>11</b>: 2265-2283.
</p>
<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps069.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps069.pdf</a> 
(in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("pixmap", quietly=TRUE)) {
  data(ggtortoises)
  
  if(adegraphicsLoaded()) {
    if(requireNamespace("sp", quietly = TRUE)) {
      g1 &lt;- s.logo(ggtortoises$pop, ggtortoises$ico[as.character(ggtortoises$pop$carap)], 
        Sp = ggtortoises$Spatial, pbackground.col = "lightblue", pSp.col = "white", 
        pgrid.draw = FALSE, ppoints.cex = 0.5)
      g1 &lt;- s.label(ggtortoises$misc, pgrid.draw = FALSE, porigin.include = FALSE, 
        paxes.draw = FALSE, add = TRUE)
    }

  } else {    
  	a1 &lt;- ggtortoises$area
  	area.plot(a1)
  	rect(min(a1$x), min(a1$y), max(a1$x), max(a1$y), col = "lightblue")
  	invisible(lapply(split(a1, a1$id), function(x) polygon(x[, -1], col = "white")))
  	s.label(ggtortoises$misc, grid = FALSE, include.ori = FALSE, addaxes = FALSE, add.p = TRUE)
  	listico &lt;- ggtortoises$ico[as.character(ggtortoises$pop$carap)]
  	s.logo(ggtortoises$pop, listico, add.p = TRUE)
  }
}</code></pre>

<hr>
<h2 id='granulo'>Granulometric Curves</h2><span id='topic+granulo'></span>

<h3>Description</h3>

<p>This data set gives the repartition in diameter classes of deposit samples. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(granulo)</code></pre>


<h3>Format</h3>

<p><code>granulo</code> is a list of 2 components.
</p>

<dl>
<dt>tab</dt><dd><p>contains the 49 deposit samples, 9 diameter classes, weight of grains by size class</p>
</dd>
<dt>born</dt><dd><p>contains the boundaries of the diameter classes</p>
</dd>
</dl>



<h3>Source</h3>

<p>Gaschignard-Fossati, O. (1986) <em>Répartition spatiale des macroinvertébrés benthiques d'un bras vif du Rhône.
Rôle des crues et dynamique saisonnière.</em>
Thèse de doctorat, Université Lyon 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(granulo)
w &lt;- t(apply(granulo$tab, 1, function (x) x / sum(x)))
w &lt;- data.frame(w)
wtr &lt;- data.frame(t(w))
wmoy &lt;- data.frame(matrix(apply(wtr, 1, mean), 1))
d1 &lt;- dudi.pca(w, scal = FALSE, scan = FALSE)
wmoy &lt;- suprow(d1, wmoy)$lisup

if(adegraphicsLoaded()) {
  s.arrow(d1$c1, plab.cex = 1.5)
  s.distri(d1$c1, wtr, starSize = 0.33, ellipseSize = 0, 
    add = TRUE, plab.cex = 0.75)
  s.label(wmoy, ppoints.cex = 5, plab.cex = 0, add = TRUE)
} else {
  
  s.arrow(d1$c1, clab = 1.5)
  s.distri(d1$c1, wtr, cstar = 0.33, cell = 0, 
    axesell = FALSE, add.p = TRUE, clab = 0.75)
  s.label(wmoy, cpoi = 5, clab = 0, add.p = TRUE)
}</code></pre>

<hr>
<h2 id='gridrowcol'>Complete regular grid analysis</h2><span id='topic+gridrowcol'></span>

<h3>Description</h3>

<p>This function defines objects to analyse data sets associated with complete regular grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridrowcol(nrow, ncol, cell.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridrowcol_+3A_nrow">nrow</code></td>
<td>
<p>size of the grid (number of rows)</p>
</td></tr>
<tr><td><code id="gridrowcol_+3A_ncol">ncol</code></td>
<td>
<p>size of the grid (number of columns)</p>
</td></tr>
<tr><td><code id="gridrowcol_+3A_cell.names">cell.names</code></td>
<td>
<p>grid cell labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the following items :
</p>
<table>
<tr><td><code>xy</code></td>
<td>
<p>: a data frame with grid cell coordinates</p>
</td></tr>
<tr><td><code>area</code></td>
<td>
<p>: a data frame with three variables to display grid cells as areas</p>
</td></tr>
<tr><td><code>neig</code></td>
<td>
<p>: an object of class <code>'neig'</code> corresponding to a neighbouring graph of the grid (rook case)</p>
</td></tr>
<tr><td><code>orthobasis</code></td>
<td>
<p>: an object of class <code>'orthobasis'</code> corresponding to the analytical solution for the neighbouring graph</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a> <br />
Daniel Chessel 
</p>


<h3>References</h3>

<p>Méot, A., Chessel, D. and Sabatier, D. (1993) Opérateurs de voisinage et analyse des données spatio-temporelles.
<em>in</em> J.D. Lebreton and B. Asselain, editors. Biométrie et environnement. Masson, 45-72.
</p>
<p>Cornillon, P.A. (1998) <em>Prise en compte de proximités en analyse factorielle et comparative</em>. Thèse, Ecole Nationale Supérieure Agronomique, Montpellier.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orthobasis">orthobasis</a></code>, <code><a href="adephylo.html#topic+orthogram">orthogram</a></code>, <code><a href="#topic+mld">mld</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- gridrowcol(8, 5)
par(mfrow = c(1, 2))
area.plot(w$area, center = w$xy, graph = w$neig, clab = 0.75)
area.plot(w$area, center = w$xy, graph = w$neig, clab = 0.75, label = as.character(1:40))
par(mfrow = c(1, 1))

if(adegraphicsLoaded()) {
  fac1 &lt;- w$orthobasis
  names(fac1) &lt;- as.character(signif(attr(w$orthobasis, "values"), 3))
  s.value(w$xy, fac1, porigin.include = FALSE, plegend.drawKey = FALSE, pgrid.text.cex = 0,
    ylim = c(0, 10))

} else {
  par(mfrow = c(5,8))
  for(k in 1:39)
    s.value(w$xy, w$orthobasis[, k], csi = 3, cleg = 0, csub = 2,
     sub = as.character(signif(attr(w$orthobasis, "values")[k], 3)),
      incl = FALSE, addax = FALSE, cgr = 0, ylim = c(0,10))
  par(mfrow = c(1,1))
}
</code></pre>

<hr>
<h2 id='hdpg'>Genetic Variation In Human Populations</h2><span id='topic+hdpg'></span>

<h3>Description</h3>

<p>This data set gives genotypes variation of 1066 individuals belonging to 52 predefined populations, 
for 404 microsatellite markers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hdpg)</code></pre>


<h3>Format</h3>

<p><code>hdpg</code> is a list of 3 components. <br />
</p>

<dl>
<dt>tab</dt><dd><p> is a data frame with the genotypes of 1066 individuals 
encoded with 6 characters (individuals in row, locus in column), for 
example &lsquo;123098&rsquo; for a heterozygote carrying alleles &lsquo;123&rsquo; and &lsquo;098&rsquo;, 
&lsquo;123123&rsquo; for a homozygote carrying two alleles &lsquo;123&rsquo; and,
&lsquo;000000&rsquo; for a not classified locus (missing data). </p>
</dd>
<dt>ind</dt><dd><p> is a a data frame with 4 columns containing information about the 1066 individuals: 
<code>hdpg$ind$id</code> containing the Diversity Panel identification number of each individual,
and three factors <code>hdpg$ind$sex</code>, <code>hdpg$ind$population</code> and <code>hdpg$ind$region</code> 
containing the names of the 52 populations belonging to 7 major geographic regions (see details). </p>
</dd>
<dt>locus</dt><dd><p> is a dataframe containing four columns: <code>hdpg$locus$marknames</code> 
a vector of names of the microsatellite markers, <code>hdpg$locus$allbyloc</code> 
a vector containing the number of alleles by loci, <code>hdpg$locus$chromosome</code> 
a factor defining a number for one chromosome and,
<code>hdpg$locus$maposition</code> indicating the position of the locus in the chromosome. </p>
</dd>
</dl>



<h3>Details</h3>

<p>The rows of <code>hdpg$pop</code> are the names of the 52 populations belonging to the geographic regions
contained in the rows of <code>hdpg$region</code>. The chosen regions are: America, Asia, Europe, 
Middle East North Africa, Oceania, Subsaharan AFRICA. <br />
</p>
<p>The 52 populations are: Adygei, Balochi, Bantu, Basque, Bedouin, Bergamo, Biaka Pygmies, 
Brahui, Burusho, Cambodian, Columbian, Dai, Daur, Druze, French, 
Han, Hazara, Hezhen, Japanese, Kalash, Karitiana, Lahu, Makrani, Mandenka, Maya,
Mbuti Pygmies, Melanesian, Miaozu, Mongola, Mozabite, Naxi, NewGuinea, Nilote, Orcadian,
Oroqen, Palestinian, Pathan, Pima, Russian, San, Sardinian, She, Sindhi, Surui, Tu, Tujia, Tuscan,
Uygur, Xibo, Yakut, Yizu, Yoruba. <br />
</p>
<p><code>hdpg$freq</code> is a data frame with 52 rows, 
corresponding to the 52 populations described above, and 4992 microsatellite markers.
</p>


<h3>Source</h3>

<p>Extract of data prepared by the Human Diversity Panel Genotypes 
(invalid http://research.marshfieldclinic.org/genetics/Freq/FreqInfo.htm)
</p>
<p>prepared by Hinda Haned, from data used in:
Noah A. Rosenberg, Jonatahan K. Pritchard, James L. Weber, Howard M. Cabb, Kenneth K. Kidds, 
Lev A. Zhivotovsky, Marcus W. Feldman (2002)
Genetic Structure of human Populations
<em>Science</em>, <b>298</b>, 2381&ndash;2385.
</p>
<p>Lev A. Zhivotovsky, Noah Rosenberg, and Marcus W. Feldman (2003).
Features of Evolution and Expansion of Modern Humans, Inferred from Genomewide Microsatellite Markers
<em>Am. J. Hum. Genet</em>, <b>72</b>, 1171&ndash;1186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hdpg)
names(hdpg)
str(hdpg)
</code></pre>

<hr>
<h2 id='houmousr'>Morphometric data set</h2><span id='topic+houmousr'></span>

<h3>Description</h3>

<p>Morphometric data set describing the shape of the first upper molar in populations of the Western European house mouse (<em>Mus musculus domesticus</em>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(houmousr)</code></pre>


<h3>Format</h3>

<p><code>houmousr</code> is a list with 2 components.
</p>

<dl>
<dt>dfcc</dt><dd><p>is a data frame with 214 rows (mice) and 128 morphometric variables.</p>
</dd>
<dt>faccc</dt><dd><p>is a factor giving the sampling location of the 214 mice.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The rows of <code>houmousr$dfcc</code> correspond to 214 mice sampled in five locations in France and Italy. The 128 columns are 128 aligned coordinates describing the shape of the occlusal surface of the first upper molar (UM1).
</p>
<p><code>houmousr$faccc</code> is a factor giving the location where mice were sampled: Montpellier, Frontignan, Gardouch (South of France), Lombardy (Northern Italy), and Corsica.
</p>


<h3>Source</h3>

<p>Thioulouse, J., Renaud, S., Dufour, AB. et al. Overcoming the Spurious Groups Problem in Between-Group PCA. Evol Biol (2021). https://doi.org/10.1007/s11692-021-09550-0
</p>


<h3>References</h3>

<p>Renaud S, Pantalacci S, Auffray J (2011) Differential evolvability along lines of least resistance of upper and lower molars in island house mice. PLoS ONE 6, https://doi.org/10.1371/journal.pone.0018951
</p>
<p>Renaud S, Dufour A, Hardouin E, Ledevin R, Auffray J (2015) Once upon multivariate analyses: when they tell several stories about biological evolution. PLoS ONE 10, https://doi.org/10.1371/journal.pone.0132801
</p>
<p>Renaud S, Ledevin R, Souquet L, Gomes Rodrigues H, Ginot S, Agret S, Claude J, Herrel A, Hautier L (2018) Evolving teeth within a stable masticatory apparatus in Orkney mice. Evolutionary Biology 45:405–424
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(houmousr)
fac1 &lt;- houmousr$faccc
df1 &lt;- houmousr$dfcc
nf1 &lt;- nlevels(fac1) - 1
# Compute PCA 
pca1 &lt;- dudi.pca(df1, scale = FALSE, scannf = FALSE, nf = nf1)
# Compute BGA
bca1 &lt;- bca(pca1, fac1, scannf = FALSE, nf = nf1)
if(adegraphicsLoaded()) {
	s.class(bca1$ls, fac1, starSize = 0, chullSize = 1, ellipseSize = 0, ppoint.cex = 0,
	plabel.cex = 0, plegend.drawKey = FALSE, col = TRUE)
	s.class(bca1$ls, fac1, starSize = 1, ellipseSize = 0, col = TRUE, add = T)                                                           
} else {
	col1 &lt;- c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00")
	s.class(bca1$ls, fac1, cstar = 1, cellipse = 0, col = col1)
	s.chull(bca1$ls, fac1, optchull = 1, add.plot = TRUE, col = col1)
}
## Not run: 
# Compute cross-validated coordinates
xbca1 &lt;- loocv(bca1)
plot(xbca1)
## End(Not run)
</code></pre>

<hr>
<h2 id='housetasks'>Contingency Table</h2><span id='topic+housetasks'></span>

<h3>Description</h3>

<p>The <code>housetasks</code> data frame gives 13 housetasks and their repartition in the couple. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(housetasks)</code></pre>


<h3>Format</h3>

<p>This data frame contains four columns : wife, alternating, husband and jointly.
Each column is a numeric vector. 
</p>


<h3>Source</h3>

<p>Kroonenberg, P. M. and Lombardo, R. (1999)
Nonsymmetric correspondence analysis: a tool for analysing contingency tables with a dependence structure.
<em>Multivariate Behavioral Research</em>, <b>34</b>, 367&ndash;396
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(housetasks)
nsc1 &lt;- dudi.nsc(housetasks, scan = FALSE)

if(adegraphicsLoaded()) {
  s.label(nsc1$c1, plab.cex = 1.25)
  s.arrow(nsc1$li, add = TRUE, plab.cex = 0.75)
} else {
  s.label(nsc1$c1, clab = 1.25)
  s.arrow(nsc1$li, add.pl = TRUE, clab = 0.75) 
}</code></pre>

<hr>
<h2 id='humDNAm'>human mitochondrial DNA restriction data</h2><span id='topic+humDNAm'></span>

<h3>Description</h3>

<p>This data set gives the frequencies of haplotypes of mitochondrial DNA restriction data in ten populations all over the world.<br />
It gives also distances among the haplotypes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(humDNAm)</code></pre>


<h3>Format</h3>

<p><code>humDNAm</code> is a list of 3 components.
</p>

<dl>
<dt>distances</dt><dd><p>is an object of class <code>dist</code> with 56 haplotypes.
These distances are computed by counting the number of differences in restriction sites between two haplotypes.</p>
</dd>
<dt>samples</dt><dd><p>is a data frame with 56 haplotypes, 10 abundance variables (populations). 
These variables give the haplotype abundance in a given population.</p>
</dd>
<dt>structures</dt><dd><p>is a data frame with 10 populations, 1 variable (classification).
This variable gives the name of the continent in which a given population is located. </p>
</dd>
</dl>


<h3>Source</h3>

<p>Excoffier, L., Smouse, P.E. and Quattro, J.M. (1992) Analysis of molecular variance inferred from metric distances
among DNA haplotypes: application to human mitochondrial DNA restriction data. <em>Genetics</em>, <b>131</b>, 479&ndash;491.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humDNAm)
dpcoahum &lt;- dpcoa(data.frame(t(humDNAm$samples)), 
    sqrt(humDNAm$distances), scan = FALSE, nf = 2)
plot(dpcoahum)
</code></pre>

<hr>
<h2 id='ichtyo'>Point sampling of fish community</h2><span id='topic+ichtyo'></span>

<h3>Description</h3>

<p>This data set gives informations between a faunistic array, 
the total number of sampling points made at each sampling occasion and 
the year of the sampling occasion. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ichtyo)</code></pre>


<h3>Format</h3>

<p><code>ichtyo</code> is a list of 3 components.
</p>

<dl>
<dt>tab</dt><dd><p>is a faunistic array with 9 columns and 32 rows.</p>
</dd>
<dt>eff</dt><dd><p>is a vector of the 32 sampling effort.</p>
</dd>
<dt>dat</dt><dd><p>is a factor where the levels are the 10 years of the sampling occasion.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The value <em>n(i,j)</em> at the <em>ith</em> row and the <em>jth</em> column in <code>tab</code> corresponds
to the number of sampling points of the <em>ith</em> sampling occasion (in <code>eff</code>) that contains the <em>jth</em> species.
</p>


<h3>Source</h3>

<p>Dolédec, S., Chessel, D. and Olivier, J. M. (1995)
L'analyse des correspondances décentrée: application aux peuplements ichtyologiques du haut-Rhône.
<em>Bulletin Français de la Pêche et de la Pisciculture</em>, <b>336</b>, 29&ndash;40.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ichtyo)
dudi1 &lt;- dudi.dec(ichtyo$tab, ichtyo$eff, scannf = FALSE)
s.class(dudi1$li, ichtyo$dat, wt = ichtyo$eff / sum(ichtyo$eff))
</code></pre>

<hr>
<h2 id='inertia.dudi'>Decomposition of inertia (i.e. contributions) in multivariate methods</h2><span id='topic+inertia'></span><span id='topic+inertia.dudi'></span><span id='topic+print.inertia'></span><span id='topic+summary.inertia'></span>

<h3>Description</h3>

<p>Computes the decomposition of inertia to measure the contributions of row and/or columns in multivariate methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dudi'
inertia(x, row.inertia = FALSE, col.inertia = FALSE, ...)
## S3 method for class 'inertia'
print(x, ...)
## S3 method for class 'inertia'
summary(object, sort.axis = 1, subset = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inertia.dudi_+3A_x">x</code>, <code id="inertia.dudi_+3A_object">object</code></td>
<td>
<p>a duality diagram, object of class <code>dudi</code> for <code>inertia.dudi</code>. An object of class <code>inertia</code> for the methods <code>print</code> and <code>summary</code></p>
</td></tr>
<tr><td><code id="inertia.dudi_+3A_row.inertia">row.inertia</code></td>
<td>
<p>if TRUE, returns the decomposition of inertia for the rows</p>
</td></tr>
<tr><td><code id="inertia.dudi_+3A_col.inertia">col.inertia</code></td>
<td>
<p>if TRUE, returns the decomposition of inertia for the columns</p>
</td></tr>
<tr><td><code id="inertia.dudi_+3A_sort.axis">sort.axis</code></td>
<td>
<p>the kept axis used to sort the contributions in decreasing order</p>
</td></tr>
<tr><td><code id="inertia.dudi_+3A_subset">subset</code></td>
<td>
<p>the number of rows and/or columns to display in the summary</p>
</td></tr>
<tr><td><code id="inertia.dudi_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contributions are printed in percentage and the sign is the sign of the coordinates</p>


<h3>Value</h3>

<p>An object of class <code>inertia</code>, i.e. a list containing :
</p>
<table>
<tr><td><code>tot.inertia</code></td>
<td>
<p>repartition of the total inertia between axes</p>
</td></tr>
<tr><td><code>row.contrib</code></td>
<td>
<p>contributions of the rows to the total inertia</p>
</td></tr>
<tr><td><code>row.abs</code></td>
<td>
<p>absolute contributions of the rows (i.e. decomposition per axis)</p>
</td></tr>
<tr><td><code>row.rel</code></td>
<td>
<p>relative contributions of the rows</p>
</td></tr>
<tr><td><code>row.cum</code></td>
<td>
<p>cumulative relative contributions of the rows (i.e. decomposition per row)</p>
</td></tr>
<tr><td><code>col.contrib</code></td>
<td>
<p>contributions of the columns to the total inertia</p>
</td></tr>
<tr><td><code>col.abs</code></td>
<td>
<p>absolute contributions of the columns (i.e. decomposition per axis)</p>
</td></tr>
<tr><td><code>col.rel</code></td>
<td>
<p>relative contributions of the columns</p>
</td></tr>
<tr><td><code>col.cum</code></td>
<td>
<p>cumulative relative contributions of the columns (i.e. decomposition per column)</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>the number of kept axes</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a><br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Lebart, L., Morineau, A. and Tabart, N. (1977) <em>Techniques de la description statistique, méthodes et logiciels pour la description des grands tableaux</em>, Dunod, Paris, 61&ndash;62.<br /><br />
Volle, M. (1981) <em>Analyse des données</em>, Economica, Paris, 89&ndash;90 and 118<br /><br />
Lebart, L., Morineau, L. and Warwick, K.M. (1984) <em>Multivariate descriptive analysis: correspondence and related techniques for large matrices</em>, John Wiley and Sons, New York.<br /><br />
Greenacre, M. (1984) <em>Theory and applications of correspondence analysis</em>, Academic Press, London, 66.<br /><br />
Rouanet, H. and Le Roux, B. (1993) <em>Analyse des données multidimensionnelles</em>,  Dunod, Paris, 143&ndash;144.<br /><br />
Tenenhaus, M. (1994) <em>Méthodes statistiques en gestion</em>,  Dunod, Paris, p. 160, 161, 166, 204.<br /><br />
Lebart, L., Morineau, A. and Piron, M. (1995) <em>Statistique exploratoire multidimensionnelle</em>, Dunod, Paris,  p. 56,95-96.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(housetasks)
coa1 &lt;- dudi.coa(housetasks, scann = FALSE)
res &lt;- inertia(coa1, col = TRUE, row = FALSE)
res
summary(res)
</code></pre>

<hr>
<h2 id='irishdata'>Geary's Irish Data</h2><span id='topic+irishdata'></span>

<h3>Description</h3>

<p>This data set contains geographical informations about 25 counties of Ireland.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(irishdata)</code></pre>


<h3>Format</h3>

<p><code>irishdata</code> is a list of 13 components:
</p>

<dl>
<dt>area</dt><dd><p>a data frame with polygons for each of the 25 contiguous counties</p>
</dd>
<dt>county.names</dt><dd><p>a vector with the names of the 25 counties</p>
</dd>
<dt>xy</dt><dd><p>a data frame with the coordinates centers of the 25 counties</p>
</dd>
<dt>tab</dt><dd><p>a data frame with 25 rows (counties) and 12 variables</p>
</dd>
<dt>contour</dt><dd><p>a data frame with the global polygon of all the 25 counties</p>
</dd>
<dt>link</dt><dd><p>a matrix containing the common length between two counties 
from <code>area</code></p>
</dd>
<dt>area.utm</dt><dd><p>a data frame with polygons for each of the 25 contiguous 
counties expressed in Universal Transverse Mercator (UTM) coordinates</p>
</dd>
<dt>xy.utm</dt><dd><p>a data frame with the UTM coordinates centers of the 25 counties</p>
</dd>
<dt>link.utm</dt><dd><p>a matrix containing the common length between two counties
from <code>area.utm</code></p>
</dd>
<dt>tab.utm</dt><dd><p>a data frame with the 25 counties (explicitly named) and 
12 variables</p>
</dd>
<dt>contour.utm</dt><dd><p>a data frame with the global polygon of all the 25 
counties expressed in UTM coordinates</p>
</dd>
<dt>Spatial</dt><dd><p>the map of the 25 counties of Ireland (an object of the 
class <code>SpatialPolygons</code> of <code>sp</code>)</p>
</dd>
<dt>Spatial.contour</dt><dd><p>the contour of the map of the 25 counties of 
Ireland (an object of the class <code>SpatialPolygons</code> of <code>sp</code>)</p>
</dd>
</dl>


<h3>Source</h3>

<p>Geary, R.C. (1954) The contiguity ratio and statistical mapping. 
<em>The incorporated Statistician</em>, <b>5</b>, 3, 115&ndash;145.
</p>
<p>Cliff, A.D. and Ord, J.K. (1973) <em>Spatial autocorrelation</em>, Pion, London. 1&ndash;178.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(irishdata)

if(adegraphicsLoaded()) {

  if(requireNamespace("sp", quietly = TRUE)){
  g1 &lt;- s.label(irishdata$xy.utm, Sp = irishdata$Spatial, pSp.col = "white", plot = FALSE)
  
  g21 &lt;- s.label(irishdata$xy.utm, Sp = irishdata$Spatial, pSp.col = "white", plab.cex = 0, 
    ppoints.cex = 0, plot = FALSE)
  g22 &lt;- s.label(irishdata$xy.utm, Sp = irishdata$Spatial.contour, pSp.col = "transparent", 
    plab.cex = 0, ppoints.cex = 0, pSp.lwd = 3, plot = FALSE)
  g2 &lt;- superpose(g21, g22)   

  g3 &lt;- s.corcircle(dudi.pca(irishdata$tab, scan = FALSE)$co, plot = FALSE)
  
  score &lt;- dudi.pca(irishdata$tab, scannf = FALSE, nf = 1)$li$Axis1
  names(score) &lt;- row.names(irishdata$Spatial)
  
  obj &lt;- sp::SpatialPolygonsDataFrame(Sr = irishdata$Spatial, data = as.data.frame(score))
  g4 &lt;- s.Spatial(obj, plot = FALSE)
  
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  }
  
} else {
  par(mfrow = c(2, 2))
  area.plot(irishdata$area, lab = irishdata$county.names, clab = 0.75)
  area.plot(irishdata$area)
  apply(irishdata$contour, 1, function(x) segments(x[1], x[2], x[3], x[4], lwd = 3))
  s.corcircle(dudi.pca(irishdata$tab, scannf = FALSE)$co)
  score &lt;- dudi.pca(irishdata$tab, scannf = FALSE, nf = 1)$li$Axis1
  names(score) &lt;- row.names(irishdata$tab)
  area.plot(irishdata$area, score)
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='is.euclid'>Is a Distance Matrix Euclidean?</h2><span id='topic+is.euclid'></span><span id='topic+summary.dist'></span>

<h3>Description</h3>

<p>Confirmation of the Euclidean nature of a distance matrix by the Gower's theorem.<br />
<code>is.euclid</code> is used in <code>summary.dist</code>.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.euclid(distmat, plot = FALSE, print = FALSE, tol = 1e-07)
## S3 method for class 'dist'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.euclid_+3A_distmat">distmat</code></td>
<td>
<p>an object of class 'dist'</p>
</td></tr>
<tr><td><code id="is.euclid_+3A_plot">plot</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot of the matrix of the term <code class="reqn">-\frac{1}{2} {d_{ij}^2}</code> centred by rows and columns should be diplayed</p>
</td></tr>
<tr><td><code id="is.euclid_+3A_print">print</code></td>
<td>
<p>a logical value indicating whether the eigenvalues of the matrix of the term <code class="reqn">-\frac{1}{2} {d_{ij}^2}</code> centred by rows and columns should be printed</p>
</td></tr>
<tr><td><code id="is.euclid_+3A_tol">tol</code></td>
<td>
<p>a tolerance threshold : an eigenvalue is considered positive if it is larger than <code>-tol*lambda1</code> where <code>lambda1</code> is the largest eigenvalue.</p>
</td></tr>
<tr><td><code id="is.euclid_+3A_object">object</code></td>
<td>
<p>an object of class 'dist'</p>
</td></tr>
<tr><td><code id="is.euclid_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a logical value indicating if all the eigenvalues are positive or equal to zero
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Gower, J.C. and Legendre, P. (1986) Metric and Euclidean properties of dissimilarity coefficients. <em>Journal of Classification</em>, <b>3</b>, 5&ndash;48.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- matrix(runif(10000), 100, 100)
w &lt;- dist(w)
summary(w)
is.euclid (w) # TRUE
w &lt;- quasieuclid(w) # no correction need in: quasieuclid(w)
w &lt;- lingoes(w) # no correction need in: lingoes(w)
w &lt;- cailliez(w) # no correction need in: cailliez(w)
rm(w)
</code></pre>

<hr>
<h2 id='julliot'>Seed dispersal</h2><span id='topic+julliot'></span>

<h3>Description</h3>

<p>This data set gives the spatial distribution of seeds (quadrats counts) of 
seven species in the understorey of tropical rainforest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(julliot)</code></pre>


<h3>Format</h3>

<p><code>julliot</code> is a list with the following components:
</p>

<dl>
<dt>tab</dt><dd><p>a data frame with 160 rows (quadrats) and 7 variables (species)</p>
</dd>
<dt>xy</dt><dd><p>a data frame with the coordinates of the 160 quadrats
(positioned by their centers)</p>
</dd>
<dt>area</dt><dd><p>a data frame with 3 variables returning the boundary lines of 
each quadrat. The first variable is a factor. The levels of this one are 
the row.names of <code>tab</code>. The second and third variables return the 
coordinates (x,y) of the points of the boundary line.</p>
</dd>
<dt>Spatial</dt><dd><p>an object of the class <code>SpatialPolygons</code> of <code>sp</code>,
containing the map</p>
</dd>
</dl>


<h3>Details</h3>

<p>Species names of <code>julliot$tab</code> are:
<em>Pouteria torta</em>, 
<em>Minquartia guianensis</em>, 
<em>Quiina obovata</em>, 
<em>Chrysophyllum lucentifolium</em>, 
<em>Parahancornia fasciculata</em>, 
<em>Virola michelii</em>, 
and <em>Pourouma spp</em>.
</p>


<h3>References</h3>

<p>Julliot, C. (1992). Utilisation des ressources alimentaires par le singe hurleur 
roux, <em>Alouatta seniculus</em> (Atelidae, Primates), en Guyane : impact de 
la dissémination des graines sur la régénération forestière. Thèse de troisième
cycle, Université de Tours.
</p>
<p>Julliot, C. (1997). Impact of seed dispersal by red howler monkeys 
<em>Alouatta seniculus</em> on the seedling population in the understorey of 
tropical rain forest. <em>Journal of Ecology</em>, <b>85</b>, 431&ndash;440.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(julliot)

## Not run: 
if(adegraphicsLoaded()) {
  if(requireNamespace("sp", quietly = TRUE)) {
    obj1 &lt;- sp::SpatialPolygonsDataFrame(Sr = julliot$Spatial, data = log(julliot$tab + 1))
    g1 &lt;- s.Spatial(obj1)
    g2 &lt;- s.value(julliot$xy, scalewt(log(julliot$tab + 1)), Sp = julliot$Spatial, 
      pSp.col = "white", pgrid.draw = FALSE)
  }
} else {
  if(requireNamespace("splancs", quietly = TRUE)) {
    par(mfrow = c(3, 3))
    for(k in 1:7)
      area.plot(julliot$area, val = log(julliot$tab[, k] + 1),
        sub = names(julliot$tab)[k], csub = 2.5)
    par(mfrow = c(1, 1))
    
    par(mfrow = c(3, 3))
    for(k in 1:7) {
      area.plot(julliot$area)
      s.value(julliot$xy, scalewt(log(julliot$tab[, k] + 1)),
        sub = names(julliot$tab)[k], csub = 2.5, add.p = TRUE)
    }
    par(mfrow = c(1, 1))
  }
}
## End(Not run)


if(adegraphicsLoaded()) {
  if(requireNamespace("sp", quietly = TRUE)) {
    g3 &lt;- s.image(julliot$xy, log(julliot$tab + 1), span = 0.25)
  }
  g4 &lt;- s.value(julliot$xy, log(julliot$tab + 1))
  
} else {
  if(requireNamespace("splancs", quietly = TRUE)) {
    par(mfrow = c(3, 3))
    for(k in 1:7)
      s.image(julliot$xy, log(julliot$tab[, k] + 1), kgrid = 3, span = 0.25,
        sub = names(julliot$tab)[k], csub = 2.5)
    par(mfrow = c(1, 1))
    
    par(mfrow = c(3, 3))
    for(k in 1:7)
      s.value(julliot$xy, log(julliot$tab[, k] + 1),
        sub = names(julliot$tab)[k], csub = 2.5)
    par(mfrow = c(1, 1))    
  }
}
        
## Not run: 
if (requireNamespace("spdep", quietly = TRUE)) {
  neig0 &lt;- nb2neig(spdep::dnearneigh(as.matrix(julliot$xy), 1, 1.8))
  if(adegraphicsLoaded()) {
    g5 &lt;- s.label(julliot$xy, nb = spdep::dnearneigh(as.matrix(julliot$xy), 1, 1.8))
  
  } else {
    par(mfrow = c(1, 1))
    s.label(julliot$xy, neig = neig0, clab = 0.75, incl = FALSE,
     addax = FALSE, grid = FALSE)
  }
  gearymoran(ade4:::neig.util.LtoG(neig0), log(julliot$tab + 1))
  
  if (requireNamespace("adephylo", quietly = TRUE)) {
    adephylo::orthogram(log(julliot$tab[, 3] + 1), ortho = scores.neig(neig0))
  }
}
## End(Not run)
</code></pre>

<hr>
<h2 id='jv73'>K-tables Multi-Regions</h2><span id='topic+jv73'></span>

<h3>Description</h3>

<p>This data set gives physical and physico-chemical variables, fish species, 
spatial coordinates about 92 sites. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(jv73)</code></pre>


<h3>Format</h3>

<p><code>jv73</code> is a list with the following components:
</p>

<dl>
<dt>morpho</dt><dd><p>a data frame with 92 sites and 6 physical variables</p>
</dd>
<dt>phychi</dt><dd><p>a data frame with 92 sites and 12 physico-chemical variables</p>
</dd>
<dt>poi</dt><dd><p>a data frame with 92 sites and 19 fish species</p>
</dd>
<dt>xy</dt><dd><p>a data frame with 92 sites and 2 spatial coordinates</p>
</dd>
<dt>contour</dt><dd><p>a data frame for mapping</p>
</dd>
<dt>fac.riv</dt><dd><p>a factor distributing the 92 sites on 12 rivers</p>
</dd>
<dt>Spatial</dt><dd><p>an object of the class <code>SpatialLines</code> of <code>sp</code>,
containing the map</p>
</dd>
</dl>


<h3>Source</h3>

<p>Verneaux, J. (1973) Cours d'eau de Franche-Comté (Massif du Jura).
Recherches écologiques sur le réseau hydrographique du Doubs.
Essai de biotypologie. Thèse d'Etat, Besançon.
</p>


<h3>References</h3>

<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps047.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps047.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jv73)

w &lt;- split(jv73$morpho, jv73$fac.riv)
w &lt;- lapply(w, function(x) t(dudi.pca(x, scann = FALSE)))
w &lt;- ktab.list.dudi(w)

if(adegraphicsLoaded()) {
  if(requireNamespace("sp", quietly = TRUE)) {
    g11 &lt;- s.label(jv73$xy, Sp = jv73$Spatial, pori.incl = FALSE, plab.cex = 0.75, plot = FALSE)
    g12 &lt;- s.class(jv73$xy, jv73$fac.riv, ellipseSize = 0, pellipses.axes.draw = FALSE, 
      starSize = 0, ppoints.cex = 0, plab.cex = 1.25, plot = FALSE)
    g1 &lt;- superpose(g11, g12, plot = TRUE)
  
    g2 &lt;- kplot(sepan(w), perm = TRUE, row.plab.cex = 0, posieig = "none")
  }
  
} else {
  s.label(jv73$xy, contour = jv73$contour, incl = FALSE, clab = 0.75)
  s.class(jv73$xy, jv73$fac.riv, add.p = TRUE, cell = 0, axese = FALSE, csta = 0, 
    cpoi = 0, clab = 1.25)
  
  kplot(sepan(w), perm = TRUE, clab.r = 0, clab.c = 2, show = FALSE)
}</code></pre>

<hr>
<h2 id='kcponds'>Ponds in a nature reserve</h2><span id='topic+kcponds'></span>

<h3>Description</h3>

<p>This data set contains informations about 33 ponds in De Maten reserve 
(Genk, Belgium).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kcponds)</code></pre>


<h3>Format</h3>

<p><code>kponds</code> is a list with the following components:
</p>

<dl>
<dt>tab</dt><dd><p>a data frame with 15 environmental variables (columns) on 33 ponds (rows)</p>
</dd>
<dt>area</dt><dd><p>an object of class <code>area</code></p>
</dd>
<dt>xy</dt><dd><p>a data frame with the coordinates of ponds</p>
</dd>
<dt>neig</dt><dd><p>an object of class <code>neig</code></p>
</dd>
<dt>nb</dt><dd><p>the neighbourhood graph of the 33 sites (an object of class <code>nb</code>)</p>
</dd>
<dt>Spatial</dt><dd><p>an object of the class <code>SpatialPolygons</code> of <code>sp</code>, containing the map</p>
</dd>
</dl>


<h3>Details</h3>

 
<p>Variables of <code>kcponds$tab</code> are the following ones : depth, area, O2 (oxygen concentration), 
cond (conductivity), pH, Fe (Fe concentration), secchi (Secchi disk depth), N (NNO concentration),
TP (total phosphorus concentration), chla (chlorophyll-a concentration), EM (emergent macrophyte cover),
FM (floating macrophyte cover), SM (submerged macrophyte cover), denMI (total density of macroinvertebrates),
divMI (diversity macroinvertebrates)
</p>


<h3>Source</h3>

<p>Cottenie, K. (2002) Local and regional processes in a zooplankton metacommunity. 
PhD, Katholieke Universiteit Leuven, Leuven, Belgium. <br />
<a href="https://bio.kuleuven.be/eco/phdkarlcottenie.pdf">https://bio.kuleuven.be/eco/phdkarlcottenie.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kcponds)
w &lt;- as.numeric(scalewt(kcponds$tab$N))

if(adegraphicsLoaded()) {
  if(requireNamespace("sp", quietly = TRUE)) {
    g1 &lt;- s.label(kcponds$xy, Sp = kcponds$Spatial, pSp.col = "white", nb = kcponds$nb, 
      plab.cex = 0, paxes.asp = "fill", plot = FALSE)
    g2 &lt;- s.label(kcponds$xy, Sp = kcponds$Spatial, pSp.col = "white", plabels.cex = 0.8, 
      paxes.asp = "fill", plot = FALSE)
    g3 &lt;- s.value(kcponds$xy, w, psub.text = "Nitrogen concentration", paxe.asp = "fill", 
      plot = FALSE)
    G &lt;- rbindADEg(g1, g2, g3, plot = TRUE)
  }

} else {
  par(mfrow=c(3, 1))
  area.plot(kcponds$area)
  s.label(kcponds$xy, add.p = TRUE, cpoi = 2, clab = 0)
  s.label(kcponds$xy, add.p = TRUE, cpoi = 3, clab = 0)
  s.label(kcponds$xy, add.p = TRUE, cpoi = 0, clab = 0, neig = kcponds$neig, cneig = 1)
  area.plot(kcponds$area)
  s.label(kcponds$xy, add.p = TRUE, clab = 1.5)
  s.value(kcponds$xy, w, cleg = 2, sub = "Nitrogen concentration", csub = 4, 
    possub = "topright", include = FALSE)
  par(mfrow = c(1, 1))
}

## Not run: 
  par(mfrow = c(3, 1))
  pca1 &lt;- dudi.pca(kcponds$tab, scan = FALSE, nf = 4)
  if(requireNamespace("spdep", quietly = TRUE)) {
    multi1 &lt;- multispati(pca1, spdep::nb2listw(neig2nb(kcponds$neig)), scannf = FALSE, nfposi = 2, 
      nfnega = 1)
    summary(multi1)
  }
  par(mfrow = c(1, 1))

## End(Not run)</code></pre>

<hr>
<h2 id='kdist'>the class of objects 'kdist' (K distance matrices)</h2><span id='topic+kdist'></span><span id='topic+c.kdist'></span><span id='topic+print.kdist'></span><span id='topic++5B.kdist'></span><span id='topic+as.data.frame.kdist'></span>

<h3>Description</h3>

<p>An object of class <code>kdist</code> is a list of distance matrices observed on the same individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kdist(..., epsi = 1e-07, upper = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kdist_+3A_...">...</code></td>
<td>
<p> a sequence of objects of the class <code>kdist</code>. </p>
</td></tr>
<tr><td><code id="kdist_+3A_epsi">epsi</code></td>
<td>
<p> a tolerance threshold to test if distances are Euclidean (Gower's theorem) using <code class="reqn">\frac{\lambda_n}{\lambda_1}</code> is larger than -epsi. </p>
</td></tr>
<tr><td><code id="kdist_+3A_upper">upper</code></td>
<td>
<p> a logical value indicating whether the upper of a distance matrix is used (TRUE) or not (FALSE).  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The attributs of a 'kdist' object are:<br />
<code>names</code>: the names of the distances<br />
<code>size</code>: the number of points between distances are known<br />
<code>labels</code>: the labels of points<br />
<code>euclid</code>: a logical vector indicating whether each distance of the list is Euclidean or not.<br />
<code>call</code>: a call order<br />
<code>class</code>: object 'kdist'<br />
</p>


<h3>Value</h3>

<p>returns an object of class 'kdist' containing a list of semidefinite matrices.
</p>


<h3>Author(s)</h3>

<p> Daniel Chessel  <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a></p>


<h3>References</h3>

<p> Gower, J. C. (1966) Some distance properties of latent root and vector methods used in multivariate analysis. <em>Biometrika</em>, <b>53</b>, 325&ndash;338. </p>


<h3>Examples</h3>

<pre><code class='language-R'># starting from a list of matrices 
data(yanomama)
lapply(yanomama,class)  
kd1 = kdist(yanomama)
print(kd1)

# giving the correlations of Mantel's test
cor(as.data.frame(kd1))
pairs(as.data.frame(kd1))

# starting from a list of objects 'dist'
data(friday87)
fri.w &lt;- ktab.data.frame(friday87$fau, friday87$fau.blo, 
    tabnames = friday87$tab.names)
fri.kd = lapply(1:10, function(x) dist.binary(fri.w[[x]],2))
names(fri.kd) = friday87$tab.names
unlist(lapply(fri.kd,class)) # a list of distances
fri.kd = kdist(fri.kd)
fri.kd
s.corcircle(dudi.pca(as.data.frame(fri.kd), scan = FALSE)$co)

# starting from several distances
data(ecomor)
d1 &lt;- dist.binary(ecomor$habitat, 1)
d2 &lt;- dist.prop(ecomor$forsub, 5)
d3 &lt;- dist.prop(ecomor$diet, 5)
d4 &lt;- dist.quant(ecomor$morpho, 3)
d5 &lt;- dist.taxo(ecomor$taxo)
ecomor.kd &lt;- kdist(d1, d2, d3, d4, d5)
names(ecomor.kd) = c("habitat", "forsub", "diet", "morpho", "taxo")
class(ecomor.kd)
s.corcircle(dudi.pca(as.data.frame(ecomor.kd), scan = FALSE)$co)

data(bsetal97)
X &lt;- prep.fuzzy.var(bsetal97$biol, bsetal97$biol.blo)
w1 &lt;- attr(X, "col.num")
w2 &lt;- levels(w1)
w3 &lt;- lapply(w2, function(x) dist.quant(X[,w1==x], method = 1))
names(w3) &lt;- names(attr(X, "col.blocks"))
w3 &lt;- kdist(list = w3)
s.corcircle(dudi.pca(as.data.frame(w3), scan = FALSE)$co)

data(rpjdl)
w1 = lapply(1:10, function(x) dist.binary(rpjdl$fau, method = x))
w2 = c("JACCARD", "SOKAL_MICHENER", "SOKAL_SNEATH_S4", "ROGERS_TANIMOTO")
w2 = c(w2, "CZEKANOWSKI", "S9_GOWER_LEGENDRE", "OCHIAI", "SOKAL_SNEATH_S13")
w2 &lt;- c(w2, "Phi_PEARSON", "S2_GOWER_LEGENDRE")
names(w1) &lt;- w2
w3 = kdist(list = w1)
w4 &lt;- dudi.pca(as.data.frame(w3), scan = FALSE)$co
w4
</code></pre>

<hr>
<h2 id='kdist2ktab'> Transformation of K distance matrices (object 'kdist') into K Euclidean representations (object 'ktab') </h2><span id='topic+kdist2ktab'></span>

<h3>Description</h3>

<p>The function creates a <code>ktab</code> object with the Euclidean representations from a <code>kdist</code> object. Notice that the euclid attribute must be TRUE for all elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kdist2ktab(kd, scale = TRUE, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kdist2ktab_+3A_kd">kd</code></td>
<td>
<p> an object of class <code>kdist</code> </p>
</td></tr>
<tr><td><code id="kdist2ktab_+3A_scale">scale</code></td>
<td>
<p> a logical value indicating whether the inertia of Euclidean representations are equal to 1 (TRUE) or not (FALSE).  </p>
</td></tr>
<tr><td><code id="kdist2ktab_+3A_tol">tol</code></td>
<td>
<p> a tolerance threshold, an eigenvalue is considered equal to zero if <code>eig$values</code> &gt; (<code>eig$values[1</code> * tol) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class <code>ktab</code> containing for each distance of <code>kd</code> the data frame of its Euclidean representation
</p>


<h3>Author(s)</h3>

<p> Daniel Chessel  <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(friday87)
fri.w &lt;- ktab.data.frame(friday87$fau, friday87$fau.blo, tabnames = friday87$tab.names)
fri.kd &lt;- lapply(1:10, function(x) dist.binary(fri.w[[x]], 10))
names(fri.kd) &lt;- substr(friday87$tab.names, 1, 4)
fri.kd &lt;- kdist(fri.kd)
fri.ktab &lt;- kdist2ktab(kd = fri.kd)
fri.sepan &lt;- sepan(fri.ktab)
plot(fri.sepan)

tapply(fri.sepan$Eig, fri.sepan$TC[,1], sum)
# the sum of the eigenvalues is constant and equal to 1, for each K tables

fri.statis &lt;- statis(fri.ktab, scan = FALSE, nf = 2)
round(fri.statis$RV, dig = 2)

fri.mfa &lt;- mfa(fri.ktab, scan = FALSE, nf = 2)
fri.mcoa &lt;- mcoa(fri.ktab, scan = FALSE, nf = 2)

apply(fri.statis$RV, 1, mean) 
fri.statis$RV.tabw 
plot(apply(fri.statis$RV, 1, mean), fri.statis$RV.tabw)
plot(fri.statis$RV.tabw, fri.statis$RV.tabw)
</code></pre>

<hr>
<h2 id='kdisteuclid'>a way to obtain Euclidean distance matrices</h2><span id='topic+kdisteuclid'></span>

<h3>Description</h3>

<p>a way to obtain Euclidean distance matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kdisteuclid(obj, method = c("lingoes", "cailliez", "quasi"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kdisteuclid_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>kdist</code></p>
</td></tr>
<tr><td><code id="kdisteuclid_+3A_method">method</code></td>
<td>
<p>a method to convert a distance matrix in a Euclidean one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class <code>kdist</code> with all distances Euclidean.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Gower, J.C. and Legendre, P. (1986) Metric and Euclidean properties of dissimilarity coefficients. <em>Journal of Classification</em>,  <b>3</b>, 5&ndash;48.
</p>
<p>Cailliez, F. (1983) The analytical solution of the additive constant problem. <em>Psychometrika</em>,  <b>48</b>, 305&ndash;310.
</p>
<p>Lingoes, J.C. (1971) Somme boundary conditions for a monotone analysis of symmetric matrices. <em>Psychometrika</em>, <b>36</b>, 195&ndash;203.
</p>
<p>Legendre, P. and Anderson, M.J. (1999) Distance-based redundancy analysis: testing multispecies responses in multifactorial ecological experiments. <em>Ecological Monographs</em>, <b>69</b>, 1&ndash;24.
</p>
<p>Legendre, P., and L. Legendre. (1998) Numerical ecology, 2nd English edition edition. Elsevier Science BV, Amsterdam. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- c(0.8, 0.8, 0.377350269, 0.8, 0.377350269, 0.377350269) # see ref.
w &lt;- kdist(w)
w1 &lt;- c(kdisteuclid(kdist(w), "lingoes"), kdisteuclid(kdist(w), "cailliez"), 
  kdisteuclid(kdist(w), "quasi"))
print(w, print = TRUE)
print(w1, print = TRUE)

data(eurodist)
par(mfrow = c(1, 3))
eu1 &lt;- kdist(eurodist) # an object of class 'dist'
plot(data.frame(unclass(c(eu1, kdisteuclid(eu1, "quasi")))), asp = 1)
title(main = "Quasi")
abline(0,1)
plot(data.frame(unclass(c(eu1, kdisteuclid(eu1, "lingoes")))), asp = 1)
title(main = "Lingoes")
abline(0,1)
plot(data.frame(unclass(c(eu1, kdisteuclid(eu1, "cailliez")))), asp = 1)
title(main = "Cailliez")
abline(0,1)
</code></pre>

<hr>
<h2 id='kplot'>Generic Function for Multiple Graphs in a K-tables Analysis</h2><span id='topic+kplot'></span>

<h3>Description</h3>

<p>Methods for <code>foucart</code>, <code>mcoa</code>, <code>mfa</code>, <code>pta</code>, <code>sepan</code>, <code>sepan.coa</code> and <code>statis</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kplot_+3A_object">object</code></td>
<td>
<p>an object used to select a method</p>
</td></tr>
<tr><td><code id="kplot_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>methods(plot)
methods(scatter)
methods(kplot)
</code></pre>

<hr>
<h2 id='kplot.foucart'>Multiple Graphs for the Foucart's Correspondence Analysis</h2><span id='topic+kplot.foucart'></span>

<h3>Description</h3>

<p>performs high level plots of a Foucart's Correspondence Analysis, 
using an object of class <code>foucart</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foucart'
kplot(object, xax = 1, yax = 2, mfrow = NULL, 
    which.tab = 1:length(object$blo), clab.r = 1, clab.c = 1.25, 
    csub = 2, possub = "bottomright", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kplot.foucart_+3A_object">object</code></td>
<td>
<p>an object of class <code>foucart</code> </p>
</td></tr>
<tr><td><code id="kplot.foucart_+3A_xax">xax</code>, <code id="kplot.foucart_+3A_yax">yax</code></td>
<td>
<p>the numbers of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="kplot.foucart_+3A_mfrow">mfrow</code></td>
<td>
<p>a vector of the form 'c(nr,nc)', otherwise computed by as special own function <code>n2mfrow</code></p>
</td></tr>
<tr><td><code id="kplot.foucart_+3A_which.tab">which.tab</code></td>
<td>
<p>vector of table numbers for analyzing</p>
</td></tr>
<tr><td><code id="kplot.foucart_+3A_clab.r">clab.r</code></td>
<td>
<p>a character size for the row labels</p>
</td></tr>
<tr><td><code id="kplot.foucart_+3A_clab.c">clab.c</code></td>
<td>
<p>a character size for the column labels</p>
</td></tr>
<tr><td><code id="kplot.foucart_+3A_csub">csub</code></td>
<td>
<p>a character size for the sub-titles used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="kplot.foucart_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="kplot.foucart_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(bf88)
fou1 &lt;- foucart(bf88, scann = FALSE, nf = 3)

if(adegraphicsLoaded()) {
  g &lt;- kplot(fou1, row.plab.cex = 0, psub.cex = 2)
} else {
  kplot(fou1, clab.c = 2, clab.r = 0, csub = 3)
}
</code></pre>

<hr>
<h2 id='kplot.mcoa'>Multiple Graphs for a Multiple Co-inertia Analysis</h2><span id='topic+kplot.mcoa'></span>

<h3>Description</h3>

<p>performs high level plots of a Multiple Co-inertia Analysis, 
using an object of class <code>mcoa</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcoa'
kplot(object, xax = 1, yax = 2, which.tab = 1:nrow(object$cov2), 
    mfrow = NULL, option = c("points", "axis", "columns"), 
    clab = 1, cpoint = 2, csub = 2, possub = "bottomright",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kplot.mcoa_+3A_object">object</code></td>
<td>
<p>an object of class <code>mcoa</code></p>
</td></tr>
<tr><td><code id="kplot.mcoa_+3A_xax">xax</code>, <code id="kplot.mcoa_+3A_yax">yax</code></td>
<td>
<p>the numbers of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="kplot.mcoa_+3A_which.tab">which.tab</code></td>
<td>
<p>a numeric vector containing the numbers of the tables to analyse</p>
</td></tr>
<tr><td><code id="kplot.mcoa_+3A_mfrow">mfrow</code></td>
<td>
<p>a vector of the form 'c(nr,nc)', otherwise computed by as special own function <code>n2mfrow</code></p>
</td></tr>
<tr><td><code id="kplot.mcoa_+3A_option">option</code></td>
<td>
<p>a string of characters for the drawing option
</p>

<dl>
<dt>&quot;points&quot;</dt><dd><p>plot of the projected scattergram onto the co-inertia axes</p>
</dd>
<dt>&quot;axis&quot;</dt><dd><p>projections of inertia axes onto the co-inertia axes.</p>
</dd>
<dt>&quot;columns&quot;</dt><dd><p>projections of variables onto the synthetic variables planes.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="kplot.mcoa_+3A_clab">clab</code></td>
<td>
<p>a character size for the labels</p>
</td></tr>
<tr><td><code id="kplot.mcoa_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")</code>*cpoint. If zero, no points are drawn.</p>
</td></tr>
<tr><td><code id="kplot.mcoa_+3A_csub">csub</code></td>
<td>
<p>a character size for the sub-titles, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="kplot.mcoa_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="kplot.mcoa_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(friday87)
w1 &lt;- data.frame(scale(friday87$fau, scal = FALSE))
w2 &lt;- ktab.data.frame(w1, friday87$fau.blo, tabnames = friday87$tab.names)
mcoa1 &lt;- mcoa(w2, "lambda1", scan = FALSE)
kplot(mcoa1, option = "axis")
kplot(mcoa1)
kplot(mcoa1, option = "columns")
</code></pre>

<hr>
<h2 id='kplot.mfa'>Multiple Graphs for a Multiple Factorial Analysis</h2><span id='topic+kplot.mfa'></span>

<h3>Description</h3>

<p>performs high level plots of a Multiple Factorial Analysis, 
using an object of class <code>mfa</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mfa'
kplot(object, xax = 1, yax = 2, mfrow = NULL, 
    which.tab = 1:length(object$blo), row.names = FALSE, col.names = TRUE, 
    traject = FALSE, permute.row.col = FALSE, 
    clab = 1, csub = 2, possub = "bottomright", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kplot.mfa_+3A_object">object</code></td>
<td>
<p>an object of class <code>mfa</code></p>
</td></tr>
<tr><td><code id="kplot.mfa_+3A_xax">xax</code>, <code id="kplot.mfa_+3A_yax">yax</code></td>
<td>
<p>the numbers of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="kplot.mfa_+3A_mfrow">mfrow</code></td>
<td>
<p>a vector of the form 'c(nr,nc'), otherwise computed by a special own function <code>n2mfrow</code></p>
</td></tr>
<tr><td><code id="kplot.mfa_+3A_which.tab">which.tab</code></td>
<td>
<p>vector of the numbers of tables used for the analysis</p>
</td></tr>
<tr><td><code id="kplot.mfa_+3A_row.names">row.names</code></td>
<td>
<p>a logical value indicating whether the row labels should be inserted</p>
</td></tr>
<tr><td><code id="kplot.mfa_+3A_col.names">col.names</code></td>
<td>
<p>a logical value indicating whether the column labels should be inserted</p>
</td></tr>
<tr><td><code id="kplot.mfa_+3A_traject">traject</code></td>
<td>
<p>a logical value indicating whether the trajectories of the rows should be drawn in a natural order</p>
</td></tr>
<tr><td><code id="kplot.mfa_+3A_permute.row.col">permute.row.col</code></td>
<td>
<p>if TRUE, the rows are represented by vectors and columns by points, otherwise it is the opposite</p>
</td></tr>
<tr><td><code id="kplot.mfa_+3A_clab">clab</code></td>
<td>
<p>a character size for the labels</p>
</td></tr>
<tr><td><code id="kplot.mfa_+3A_csub">csub</code></td>
<td>
<p>a character size for the sub-titles, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="kplot.mfa_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="kplot.mfa_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(friday87)
w1 &lt;- data.frame(scale(friday87$fau, scal = FALSE))
w2 &lt;- ktab.data.frame(w1, friday87$fau.blo, tabnames = friday87$tab.names)
mfa1 &lt;- mfa(w2, scann = FALSE)
kplot(mfa1)
</code></pre>

<hr>
<h2 id='kplot.pta'>Multiple Graphs for a Partial Triadic Analysis</h2><span id='topic+kplot.pta'></span>

<h3>Description</h3>

<p>performs high level plots of a Partial Triadic Analysis, 
using an object of class <code>pta</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pta'
kplot(object, xax = 1, yax = 2, which.tab = 1:nrow(object$RV), 
    mfrow = NULL, which.graph = 1:4, clab = 1, cpoint = 2, csub = 2, 
    possub = "bottomright", ask = par("ask"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kplot.pta_+3A_object">object</code></td>
<td>
<p>an object of class <code>pta</code></p>
</td></tr>
<tr><td><code id="kplot.pta_+3A_xax">xax</code>, <code id="kplot.pta_+3A_yax">yax</code></td>
<td>
<p>the numbers of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="kplot.pta_+3A_which.tab">which.tab</code></td>
<td>
<p>a numeric vector containing the numbers of the tables to analyse</p>
</td></tr>
<tr><td><code id="kplot.pta_+3A_mfrow">mfrow</code></td>
<td>
<p>parameter of the array of figures to be drawn, otherwise the graphs associated to a table are drawn on the same row</p>
</td></tr>
<tr><td><code id="kplot.pta_+3A_which.graph">which.graph</code></td>
<td>
<p>an option for drawing, an integer between 1 and
4. For each table of which.tab, are drawn :
</p>

<dl>
<dt>1</dt><dd><p>the projections of the principal axes</p>
</dd>
<dt>2</dt><dd><p>the projections of the rows</p>
</dd>
<dt>3</dt><dd><p>the projections of the columns</p>
</dd>
<dt>4</dt><dd><p>the projections of the principal components onto the
planes of the compromise</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="kplot.pta_+3A_clab">clab</code></td>
<td>
<p>a character size for the labels</p>
</td></tr>
<tr><td><code id="kplot.pta_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")</code>*cpoint. If zero, no points are drawn.</p>
</td></tr>
<tr><td><code id="kplot.pta_+3A_csub">csub</code></td>
<td>
<p>a character size for the sub-titles, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="kplot.pta_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="kplot.pta_+3A_ask">ask</code></td>
<td>
<p>a logical value indicating if the graphs requires several arrays of figures</p>
</td></tr>
<tr><td><code id="kplot.pta_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
wit1 &lt;- wca(dudi.pca(meaudret$spe, scan = FALSE, scal = FALSE), 
  meaudret$design$season, scan = FALSE)
kta1 &lt;- ktab.within(wit1, colnames = rep(c("S1", "S2", "S3", "S4", "S5"), 4))
kta2 &lt;- t(kta1)
pta1 &lt;- pta(kta2, scann = FALSE)
kplot(pta1)
kplot(pta1, which.graph = 3)
</code></pre>

<hr>
<h2 id='kplot.sepan'>Multiple Graphs for Separated Analyses in a K-tables</h2><span id='topic+kplot.sepan'></span><span id='topic+kplotsepan.coa'></span>

<h3>Description</h3>

<p>performs high level plots for Separed Analyses in a K-tables, 
using an object of class <code>sepan</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sepan'
kplot(object, xax = 1, yax = 2, which.tab = 1:length(object$blo), 
    mfrow = NULL, permute.row.col = FALSE, clab.row = 1, 
    clab.col = 1.25, traject.row = FALSE, csub = 2, 
    possub = "bottomright", show.eigen.value = TRUE,...)

kplotsepan.coa(object, xax = 1, yax = 2, which.tab = 1:length(object$blo), 
    mfrow = NULL, permute.row.col = FALSE, clab.row = 1, 
    clab.col = 1.25, csub = 2, possub = "bottomright", 
    show.eigen.value = TRUE, poseig = c("bottom", "top"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kplot.sepan_+3A_object">object</code></td>
<td>
<p>an object of class <code>sepan</code></p>
</td></tr>
<tr><td><code id="kplot.sepan_+3A_xax">xax</code>, <code id="kplot.sepan_+3A_yax">yax</code></td>
<td>
<p>the numbers of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="kplot.sepan_+3A_which.tab">which.tab</code></td>
<td>
<p>a numeric vector containing the numbers of the tables to analyse</p>
</td></tr>
<tr><td><code id="kplot.sepan_+3A_mfrow">mfrow</code></td>
<td>
<p>parameter for the array of figures to be drawn, otherwise use n2mfrow</p>
</td></tr>
<tr><td><code id="kplot.sepan_+3A_permute.row.col">permute.row.col</code></td>
<td>
<p>if TRUE the rows are represented by arrows and the columns by points, if FALSE it is the opposite</p>
</td></tr>
<tr><td><code id="kplot.sepan_+3A_clab.row">clab.row</code></td>
<td>
<p>a character size for the row labels</p>
</td></tr>
<tr><td><code id="kplot.sepan_+3A_clab.col">clab.col</code></td>
<td>
<p>a character size for the column labels</p>
</td></tr>
<tr><td><code id="kplot.sepan_+3A_traject.row">traject.row</code></td>
<td>
<p>a logical value indicating whether the trajectories between rows should be drawn in a natural order</p>
</td></tr>
<tr><td><code id="kplot.sepan_+3A_csub">csub</code></td>
<td>
<p>a character size for the sub-titles, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="kplot.sepan_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="kplot.sepan_+3A_show.eigen.value">show.eigen.value</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be drawn</p>
</td></tr>
<tr><td><code id="kplot.sepan_+3A_poseig">poseig</code></td>
<td>
<p>if &quot;top&quot; the eigenvalues bar plot is upside, if &quot;bottom&quot;, it is downside</p>
</td></tr>
<tr><td><code id="kplot.sepan_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>kplot.sepan</code> superimposes the points for the rows and the arrows for the columns using an 
adapted rescaling such as the <code>scatter.dudi</code>.<br />
<code>kplotsepan.coa</code> superimposes the row coordinates and the column coordinates with the same scale.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(escopage)
w1 &lt;- data.frame(scale(escopage$tab))
w1 &lt;- ktab.data.frame(w1, escopage$blo, tabnames = escopage$tab.names)
sep1 &lt;- sepan(w1)
if(adegraphicsLoaded()) {
  kplot(sep1, posieig = "none")
} else {
  kplot(sep1, show = FALSE)
}

data(friday87)
w2 &lt;- data.frame(scale(friday87$fau, scal = FALSE))
w2 &lt;- ktab.data.frame(w2, friday87$fau.blo, tabnames = friday87$tab.names)
if(adegraphicsLoaded()) {
  kplot(sepan(w2), row.plabel.cex = 1.25, col.plab.cex = 0)
} else {
  kplot(sepan(w2), clab.r = 1.25, clab.c = 0)
}

data(microsatt)
w3 &lt;- dudi.coa(data.frame(t(microsatt$tab)), scann = FALSE)
loci.fac &lt;- factor(rep(microsatt$loci.names, microsatt$loci.eff))
wit &lt;- wca(w3, loci.fac, scann = FALSE)
microsatt.ktab &lt;- ktab.within(wit)
if(adegraphicsLoaded()) {
  kplotsepan.coa(sepan(microsatt.ktab), posieig = "none", col.plab.cex = 0, row.plab.cex = 1.5)
} else {
  kplotsepan.coa(sepan(microsatt.ktab), show = FALSE, clab.c = 0, 
    mfrow = c(3,3), clab.r = 1.5)
}    
</code></pre>

<hr>
<h2 id='kplot.statis'>Multiple Graphs of a STATIS Analysis</h2><span id='topic+kplot.statis'></span>

<h3>Description</h3>

<p>performs high level plots for a STATIS analysis, 
using an object of class <code>statis</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'statis'
kplot(object, xax = 1, yax = 2, mfrow = NULL, 
    which.tab = 1:length(object$tab.names), clab = 1.5, cpoi = 2, 
    traject = FALSE, arrow = TRUE, class = NULL, 
    unique.scale = FALSE, csub = 2, possub = "bottomright",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kplot.statis_+3A_object">object</code></td>
<td>
<p>an object of class <code>statis</code></p>
</td></tr>
<tr><td><code id="kplot.statis_+3A_xax">xax</code>, <code id="kplot.statis_+3A_yax">yax</code></td>
<td>
<p>the numbers of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="kplot.statis_+3A_mfrow">mfrow</code></td>
<td>
<p>parameter for the array of figures to be drawn</p>
</td></tr>
<tr><td><code id="kplot.statis_+3A_which.tab">which.tab</code></td>
<td>
<p>a numeric vector containing the numbers of the tables to analyse</p>
</td></tr>
<tr><td><code id="kplot.statis_+3A_clab">clab</code></td>
<td>
<p>a character size for the labels</p>
</td></tr>
<tr><td><code id="kplot.statis_+3A_cpoi">cpoi</code></td>
<td>
<p>the size of points</p>
</td></tr>
<tr><td><code id="kplot.statis_+3A_traject">traject</code></td>
<td>
<p>a logical value indicating whether the trajectories should be drawn in a natural order</p>
</td></tr>
<tr><td><code id="kplot.statis_+3A_arrow">arrow</code></td>
<td>
<p>a logical value indicating whether the column factorial diagrams should be plotted</p>
</td></tr>
<tr><td><code id="kplot.statis_+3A_class">class</code></td>
<td>
<p>if not NULL, a factor of length equal to the number of the total columns of the K-tables</p>
</td></tr>
<tr><td><code id="kplot.statis_+3A_unique.scale">unique.scale</code></td>
<td>
<p>if TRUE, all the arrays of figures have the same scale</p>
</td></tr>
<tr><td><code id="kplot.statis_+3A_csub">csub</code></td>
<td>
<p>a character size for the labels of the arrays of figures used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="kplot.statis_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="kplot.statis_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jv73)
dudi1 &lt;- dudi.pca(jv73$poi, scann = FALSE, scal = FALSE)
wit1 &lt;- wca(dudi1, jv73$fac.riv, scann = FALSE)
kta1 &lt;- ktab.within(wit1)
statis1 &lt;- statis(kta1, scann = FALSE)

if(adegraphicsLoaded()) {
  g1 &lt;- kplot(statis1, traj = TRUE, arrow = FALSE, plab.cex = 0, psub.cex = 2, ppoi.cex = 2)
} else {
  kplot(statis1, traj = TRUE, arrow = FALSE, unique = TRUE, clab = 0, csub = 2, cpoi = 2)
}</code></pre>

<hr>
<h2 id='krandtest'>Class of the Permutation Tests (in C).</h2><span id='topic+krandtest'></span><span id='topic+plot.krandtest'></span><span id='topic+print.krandtest'></span><span id='topic+as.krandtest'></span><span id='topic++5B.krandtest'></span><span id='topic++5B+5B.krandtest'></span>

<h3>Description</h3>

<p>Plot, print and extract permutation tests. Objects of class <code>'krandtest'</code> are lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.krandtest(sim, obs, alter = "greater", call = match.call(),
  names = colnames(sim), p.adjust.method = "none", output = c("light", "full"))

## S3 method for class 'krandtest'
plot(x, mfrow = NULL, nclass = 10, main.title = x$names, ...)
## S3 method for class 'krandtest'
print(x, ...)
## S3 method for class 'krandtest'
x[i]
## S3 method for class 'krandtest'
x[[i]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krandtest_+3A_sim">sim</code></td>
<td>
<p>a matrix or data.frame of simulated values (repetitions as rows, number of tests as columns</p>
</td></tr>
<tr><td><code id="krandtest_+3A_obs">obs</code></td>
<td>
<p>a numeric vector of observed values for each test</p>
</td></tr>
<tr><td><code id="krandtest_+3A_alter">alter</code></td>
<td>
<p>a vector of character specifying the alternative hypothesis for each test. Each element must be one of
&quot;greater&quot; (default), &quot;less&quot; or &quot;two-sided&quot;. The length must be equal to the length of the vector obs, values are recycled if shorter.</p>
</td></tr>
<tr><td><code id="krandtest_+3A_call">call</code></td>
<td>
<p>a call order</p>
</td></tr>
<tr><td><code id="krandtest_+3A_names">names</code></td>
<td>
<p>a vector of names for tests</p>
</td></tr>
<tr><td><code id="krandtest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>a string indicating a method for multiple adjustment, see <code>p.adjust.methods</code> for possible choices.</p>
</td></tr>
<tr><td><code id="krandtest_+3A_output">output</code></td>
<td>
<p>a character string specifying if all simulations should be stored (<code>"full"</code>). This was the default until <code>ade4</code> 1.7-5. 
Now, by default (<code>"light"</code>), only the distribution of simulated values is stored in element <code>plot</code> as produced by the <code>hist</code> function.</p>
</td></tr> 
<tr><td><code id="krandtest_+3A_x">x</code></td>
<td>
<p>an object of class <code>'krandtest'</code></p>
</td></tr>
<tr><td><code id="krandtest_+3A_mfrow">mfrow</code></td>
<td>
<p>a vector of the form 'c(nr,nc)', otherwise computed by as special own function <code>n2mfrow</code></p>
</td></tr>
<tr><td><code id="krandtest_+3A_nclass">nclass</code></td>
<td>
<p>a number of intervals for the histogram. Ignored if object output is <code>"light"</code></p>
</td></tr>
<tr><td><code id="krandtest_+3A_main.title">main.title</code></td>
<td>
<p>a string of character for the main title</p>
</td></tr>
<tr><td><code id="krandtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="krandtest_+3A_i">i</code></td>
<td>
<p>numeric indices specifying elements to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot.krandtest</code> draws the <em>p</em> simulated values histograms and the position of the observed value.
<code>[.krandtest</code> returns a <code>krandtest</code> object and 
<code>[[.krandtest</code> returns a <code>randtest</code> object.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel and Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+randtest">randtest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>wkrandtest &lt;- as.krandtest(obs = c(0, 1.2, 2.4, 3.4, 5.4, 20.4), 
  sim = matrix(rnorm(6*200), 200, 6))
wkrandtest
plot(wkrandtest)
wkrandtest[c(1, 4, 6)]
wkrandtest[[1]]
</code></pre>

<hr>
<h2 id='ktab'>the class of objects 'ktab' (K-tables)</h2><span id='topic+ktab'></span><span id='topic+is.ktab'></span><span id='topic+c.ktab'></span><span id='topic++5B.ktab'></span><span id='topic+print.ktab'></span><span id='topic+t.ktab'></span><span id='topic+row.names.ktab'></span><span id='topic+row.names+3C-.ktab'></span><span id='topic+col.names'></span><span id='topic+col.names.ktab'></span><span id='topic+col.names+3C-'></span><span id='topic+col.names+3C-.ktab'></span><span id='topic+tab.names'></span><span id='topic+tab.names.ktab'></span><span id='topic+tab.names+3C-'></span><span id='topic+tab.names+3C-.ktab'></span><span id='topic+ktab.util.names'></span><span id='topic+ktab.util.addfactor'></span>

<h3>Description</h3>

<p>an object of class <code>ktab</code> is a list of data frames with the same row.names in common.<br />
a list of class 'ktab' contains moreover :
</p>

<dl>
<dt>blo</dt><dd><p>: the vector of the numbers of columns for each table</p>
</dd>
<dt>lw</dt><dd><p>: the vector of the row weightings in common for all tables</p>
</dd>
<dt>cw</dt><dd><p>: the vector of the column weightings</p>
</dd>
<dt>TL</dt><dd><p>: a data frame of two components to manage the parameter positions associated with the rows of tables</p>
</dd>
<dt>TC</dt><dd><p>: a data frame of two components to manage the parameter positions associated with the columns of tables</p>
</dd>
<dt>T4</dt><dd><p>: a data frame of two components to manage the parameter positions of 4 components associated to an array</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ktab'
c(...)
## S3 method for class 'ktab'
x[i,j,k]
is.ktab(x)
## S3 method for class 'ktab'
t(x)
## S3 method for class 'ktab'
row.names(x)
## S3 method for class 'ktab'
col.names(x)
tab.names(x)
col.names(x)
ktab.util.names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ktab_+3A_x">x</code></td>
<td>
<p>an object of the class <code>ktab</code></p>
</td></tr>
<tr><td><code id="ktab_+3A_...">...</code></td>
<td>
<p>a sequence of objects of the class <code>ktab</code></p>
</td></tr>
<tr><td><code id="ktab_+3A_i">i</code>, <code id="ktab_+3A_j">j</code>, <code id="ktab_+3A_k">k</code></td>
<td>
<p>elements to extract (integer or empty): index of tables (i), rows (j) and columns (k)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 'ktab' object can be created with :<br />
a list of data frame : <code><a href="#topic+ktab.list.df">ktab.list.df</a></code><br />
a list of <code>dudi</code> objects : <code><a href="#topic+ktab.list.dudi">ktab.list.dudi</a></code><br />
a data.frame : <code><a href="#topic+ktab.data.frame">ktab.data.frame</a></code><br />
an object <code>within</code> : <code><a href="#topic+ktab.within">ktab.within</a></code><br />
a couple of <code>ktab</code>s : <code><a href="#topic+ktab.match2ktabs">ktab.match2ktabs</a></code><br />
</p>


<h3>Value</h3>

<p><code>c.ktab</code> returns an object <code>ktab</code>. It concatenates K-tables with the same rows in common. <br />
<code>t.ktab</code> returns an object <code>ktab</code>. It permutes each data frame into a K-tables. All tables have the same column names and the same column weightings (a data cube). <br />
<code>"["</code> returns an object <code>ktab</code>. It allows to select some arrays in a K-tables. <br />
<code>is.ktab</code> returns TRUE if x is a K-tables. <br />
<code>row.names</code> returns the vector of the row names common with all the tables of a K-tables and allowes to modifie them.<br />
<code>col.names</code> returns the vector of the column names of a K-tables and allowes to modifie them.<br />
<code>tab.names</code> returns the vector of the array names of a K-tables and allowes to modifie them.<br />
<code>ktab.util.names</code> is a useful function.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(friday87)
wfri &lt;- data.frame(scale(friday87$fau, scal = FALSE))
wfri &lt;- ktab.data.frame(wfri, friday87$fau.blo)
wfri[2:4, 1:5, 1:3]
c(wfri[2:4], wfri[5])

data(meaudret)
wit1 &lt;- withinpca(meaudret$env, meaudret$design$season, scan = FALSE, 
    scal = "partial")
kta1 &lt;- ktab.within(wit1, colnames = rep(c("S1","S2","S3","S4","S5"), 4))
kta2 &lt;- t(kta1)

if(adegraphicsLoaded()) {
  kplot(sepan(kta2), row.plab.cex = 1.5, col.plab.cex = 0.75)
} else {
  kplot(sepan(kta2), clab.r = 1.5, clab.c = 0.75)
}
</code></pre>

<hr>
<h2 id='ktab.data.frame'>Creation of K-tables from a data frame</h2><span id='topic+ktab.data.frame'></span>

<h3>Description</h3>

<p>creates K tables from a data frame. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ktab.data.frame(df, blocks, rownames = NULL, colnames = NULL, 
    tabnames = NULL, w.row = rep(1, nrow(df)) / nrow(df), 
    w.col = rep(1, ncol(df)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ktab.data.frame_+3A_df">df</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="ktab.data.frame_+3A_blocks">blocks</code></td>
<td>
<p>an integer vector for which the sum must be the number of variables of df. Its length is the number of arrays of the K-tables</p>
</td></tr>
<tr><td><code id="ktab.data.frame_+3A_rownames">rownames</code></td>
<td>
<p>the row names of the K-tables (otherwise the row names of df)</p>
</td></tr>
<tr><td><code id="ktab.data.frame_+3A_colnames">colnames</code></td>
<td>
<p>the column names of the K-tables (otherwise the column names of df)</p>
</td></tr>
<tr><td><code id="ktab.data.frame_+3A_tabnames">tabnames</code></td>
<td>
<p>the names of the arrays of the K-tables (otherwise &quot;Ana1&quot;, &quot;Ana2&quot;, ...)</p>
</td></tr>
<tr><td><code id="ktab.data.frame_+3A_w.row">w.row</code></td>
<td>
<p>a vector of the row weightings</p>
</td></tr>
<tr><td><code id="ktab.data.frame_+3A_w.col">w.col</code></td>
<td>
<p>a vector of the column weightings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class <code>ktab</code>. See <code><a href="#topic+ktab">ktab</a></code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(escopage)
wescopage &lt;- data.frame(scalewt(escopage$tab))
wescopage &lt;- ktab.data.frame(wescopage, escopage$blo,
        tabnames = escopage$tab.names)
plot(sepan(wescopage))
data(friday87)
w &lt;- data.frame(scale(friday87$fau, scal = FALSE))
w &lt;- ktab.data.frame(w, friday87$fau.blo, tabnames = friday87$tab.names)
kplot(sepan(w))
</code></pre>

<hr>
<h2 id='ktab.list.df'>Creating a K-tables from a list of data frames.
</h2><span id='topic+ktab.list.df'></span>

<h3>Description</h3>

<p>creates a list of class <code>ktab</code> from a list of data frames 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ktab.list.df(obj, rownames = NULL, colnames = NULL, tabnames = NULL, 
    w.row = rep(1, nrow(obj[[1]])), w.col = lapply(obj, function(x) 
    rep(1 / ncol(x), ncol(x))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ktab.list.df_+3A_obj">obj</code></td>
<td>
<p>a list of data frame</p>
</td></tr>
<tr><td><code id="ktab.list.df_+3A_rownames">rownames</code></td>
<td>
<p>the names of the K-tables rows (otherwise, the row names of the arrays)</p>
</td></tr>
<tr><td><code id="ktab.list.df_+3A_colnames">colnames</code></td>
<td>
<p>the names of the K-tables columns (otherwise, the column names of the arrays)</p>
</td></tr>
<tr><td><code id="ktab.list.df_+3A_tabnames">tabnames</code></td>
<td>
<p>the names of the arrays of the K-tables (otherwise, the names of the obj if they exist, or else &quot;Ana1&quot;, &quot;Ana2&quot;, ...)</p>
</td></tr>
<tr><td><code id="ktab.list.df_+3A_w.row">w.row</code></td>
<td>
<p>a vector of the row weightings in common with all the arrays</p>
</td></tr>
<tr><td><code id="ktab.list.df_+3A_w.col">w.col</code></td>
<td>
<p>a list of the vector of the column weightings for each array</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each element of the initial list have to possess the same names and row numbers
</p>


<h3>Value</h3>

<p>returns a list of class <code>ktab</code>. See <code><a href="#topic+ktab">ktab</a></code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jv73)
l0 &lt;- split(jv73$morpho, jv73$fac.riv)
l0 &lt;- lapply(l0, function(x) data.frame(t(scalewt(x))))
kta &lt;- ktab.list.df(l0)
kplot(sepan(kta[c(2, 5, 7, 10)]), perm = TRUE)
</code></pre>

<hr>
<h2 id='ktab.list.dudi'>Creation of a K-tables from a list of duality diagrams</h2><span id='topic+ktab.list.dudi'></span>

<h3>Description</h3>

<p>creates a list of class <code>ktab</code> from a list of duality diagrams. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ktab.list.dudi(obj, rownames = NULL, colnames = NULL, tabnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ktab.list.dudi_+3A_obj">obj</code></td>
<td>
<p>a list of objects of class 'dudi'. Each element of the list must have the same row names for <code>$tab</code> and even for <code>$lw</code></p>
</td></tr>
<tr><td><code id="ktab.list.dudi_+3A_rownames">rownames</code></td>
<td>
<p>the row names of the K-tables (otherwise the row names of the <code>$tab</code>)</p>
</td></tr>
<tr><td><code id="ktab.list.dudi_+3A_colnames">colnames</code></td>
<td>
<p>the column names of the K-tables (otherwise the column names of the <code>$tab</code>)</p>
</td></tr>
<tr><td><code id="ktab.list.dudi_+3A_tabnames">tabnames</code></td>
<td>
<p>the names of the arrays of the K-tables (otherwise the names of the <code>obj</code>  if they exist, or else &quot;Ana1&quot;, &quot;Ana2&quot;, ...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class <code>ktab</code>. See <code><a href="#topic+ktab">ktab</a></code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(euro123)
pca1 &lt;- dudi.pca(euro123$in78, scale = FALSE, scann = FALSE)
pca2 &lt;- dudi.pca(euro123$in86, scale = FALSE, scann = FALSE)
pca3 &lt;- dudi.pca(euro123$in97, scale = FALSE, scann = FALSE)
ktabeuro &lt;- ktab.list.dudi(list(pca1, pca2, pca3), 
    tabnames = c("1978", "1986", "1997"))
if(adegraphicsLoaded()) {
  kplot(sepan(ktabeuro))
} else {
  kplot(sepan(ktabeuro), mfr = c(2, 2), clab.c = 1.5)
}

data(meaudret)
w1 &lt;- split(meaudret$env,meaudret$design$season)
ll &lt;- lapply(w1, dudi.pca, scann = FALSE)
kta &lt;- ktab.list.dudi(ll, rownames &lt;- paste("Site", 1:5, sep = ""))
if(adegraphicsLoaded()) {
  kplot(sepan(kta), row.plab.cex = 1.5, col.plab.cex = 0.75)
} else {
  kplot(sepan(kta), clab.r = 1.5, clab.c = 0.75)
}

data(jv73)
w &lt;- split(jv73$poi, jv73$fac.riv)
wjv73poi &lt;- lapply(w, dudi.pca, scal = FALSE, scan = FALSE)
wjv73poi &lt;- lapply(wjv73poi, t)
wjv73poi &lt;- ktab.list.dudi(wjv73poi)
kplot(sepan(wjv73poi), permut = TRUE, traj = TRUE)
</code></pre>

<hr>
<h2 id='ktab.match2ktabs'>STATIS and Co-Inertia : Analysis of a series of paired ecological tables</h2><span id='topic+ktab.match2ktabs'></span>

<h3>Description</h3>

<p>Prepares the analysis of a series of paired ecological tables. Partial Triadic
Analysis (see <code><a href="#topic+pta">pta</a></code>) can be used thereafter to perform the analysis of this k-table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ktab.match2ktabs(KTX, KTY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ktab.match2ktabs_+3A_ktx">KTX</code></td>
<td>
<p>an objet of class <code>ktab</code></p>
</td></tr>
<tr><td><code id="ktab.match2ktabs_+3A_kty">KTY</code></td>
<td>
<p>an objet of class <code>ktab</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class <code>ktab</code>, subclass <code>kcoinertia</code>. See <code><a href="#topic+ktab">ktab</a></code>
</p>


<h3>WARNING </h3>

<p>IMPORTANT : <code>KTX</code> and <code>KTY</code> must have the same k-tables structure, the same number
of columns, and the same column weights.
</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse <a href="mailto:Jean.Thioulouse@univ-lyon1.fr">Jean.Thioulouse@univ-lyon1.fr</a></p>


<h3>References</h3>

<p>Thioulouse J., Simier M. and Chessel D. (2004). Simultaneous analysis of a sequence of paired ecological tables.  <em>Ecology</em> <b>85</b>, 272-283.. 
</p>
<p>Simier, M., Blanc L., Pellegrin F., and Nandris D. (1999). Approche simultanée de K couples de tableaux : 
Application a l'étude des relations pathologie végétale - environnement. <em>Revue de Statistique Appliquée</em>, <b>47</b>, 31-46.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meau)
wit1 &lt;- withinpca(meau$env, meau$design$season, scan = FALSE, scal = "total")
pcaspe &lt;- dudi.pca(meau$spe, scale = FALSE, scan = FALSE, nf = 2)
wit2 &lt;- wca(pcaspe, meau$design$season, scan = FALSE, nf = 2)
kta1 &lt;- ktab.within(wit1, colnames = rep(c("S1","S2","S3","S4","S5","S6"), 4))
kta2 &lt;- ktab.within(wit2, colnames = rep(c("S1","S2","S3","S4","S5","S6"), 4))
kcoi &lt;- ktab.match2ktabs(kta1, kta2)
ptacoi &lt;- pta(kcoi, scan = FALSE, nf = 2)
plot(ptacoi)
kplot(ptacoi)
</code></pre>

<hr>
<h2 id='ktab.within'>Process to go from a Within Analysis to a K-tables</h2><span id='topic+ktab.within'></span>

<h3>Description</h3>

<p>performs the process to go from a Within Analysis to a K-tables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ktab.within(dudiwit, rownames = NULL, colnames = NULL, tabnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ktab.within_+3A_dudiwit">dudiwit</code></td>
<td>
<p>an objet of class <code>within</code></p>
</td></tr>
<tr><td><code id="ktab.within_+3A_rownames">rownames</code></td>
<td>
<p>the row names of the K-tables (otherwise the row names of <code>dudiwit$tab</code>)</p>
</td></tr>
<tr><td><code id="ktab.within_+3A_colnames">colnames</code></td>
<td>
<p>the column names of the K-tables (otherwise the column names <br />
of <code>dudiwit$tab</code>)</p>
</td></tr>
<tr><td><code id="ktab.within_+3A_tabnames">tabnames</code></td>
<td>
<p>the names of the arrays of the K-tables (otherwise the levels of the factor which defines the within-classes)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class <code>ktab</code>. See <code><a href="#topic+ktab">ktab</a></code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bacteria)
w1 &lt;- data.frame(t(bacteria$espcodon))
dudi1 &lt;- dudi.coa(w1, scann = FALSE, nf = 4)
wit1 &lt;- wca(dudi1, bacteria$code, scannf = FALSE)
kta1 &lt;- ktab.within(wit1)
plot(statis(kta1, scann = FALSE))

kta2 &lt;- kta1[kta1$blo&gt;3]
kplot(mfa(kta2, scann = FALSE))
</code></pre>

<hr>
<h2 id='lascaux'>Genetic/Environment and types of variables</h2><span id='topic+lascaux'></span>

<h3>Description</h3>

<p>This data set gives meristic, genetic and morphological data frame 
for 306 trouts.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lascaux)</code></pre>


<h3>Format</h3>

<p><code>lascaux</code> is a list of 9 components.
</p>

<dl>
<dt>riv</dt><dd><p>is a factor returning the river where 306 trouts are captured</p>
</dd>
<dt>code</dt><dd><p>vector of characters : code of the 306 trouts</p>
</dd>
<dt>sex</dt><dd><p>factor sex of the 306 trouts</p>
</dd>
<dt>meris</dt><dd><p>data frame 306 trouts - 5 meristic variables</p>
</dd>
<dt>tap</dt><dd><p>data frame of the total number of red and black points</p>
</dd>
<dt>gen</dt><dd><p>factor of the genetic code of the 306 trouts</p>
</dd>
<dt>morpho</dt><dd><p>data frame 306 trouts 37 morphological variables</p>
</dd>
<dt>colo</dt><dd><p>data frame 306 trouts 15 variables of coloring</p>
</dd>
<dt>ornem</dt><dd><p>data frame 306 trouts 15 factors (ornementation)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Lascaux, J.M. (1996)
<em>Analyse de la variabilité morphologique de la truite commune (Salmo trutta L.) dans les cours d'eau du bassin pyrénéen méditerranéen</em>.
Thèse de doctorat en sciences agronomiques, INP Toulouse.
</p>


<h3>References</h3>

<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps022.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps022.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lascaux)

if(adegraphicsLoaded()) {
  g1 &lt;- s1d.barchart(dudi.pca(lascaux$meris, scan = FALSE)$eig, psub.text = "Meristic", 
    p1d.horizontal = FALSE, plot = FALSE)
  g2 &lt;- s1d.barchart(dudi.pca(lascaux$colo, scan = FALSE)$eig, psub.text = "Coloration", 
    p1d.horizontal = FALSE, plot = FALSE)
  g3 &lt;- s1d.barchart(dudi.pca(na.omit(lascaux$morpho), scan = FALSE)$eig, 
    psub.text = "Morphometric", p1d.horizontal = FALSE, plot = FALSE)
  g4 &lt;- s1d.barchart(dudi.acm(na.omit(lascaux$orne), scan = FALSE)$eig, 
    psub.text = "Ornemental", p1d.horizontal = FALSE, plot = FALSE)
  
  G &lt;- ADEgS(c(g1, g2, g3, g4), layout = c(2, 2))
  
} else {
  par(mfrow = c(2,2))
  barplot(dudi.pca(lascaux$meris, scan = FALSE)$eig)
  title(main = "Meristic")
  barplot(dudi.pca(lascaux$colo, scan = FALSE)$eig)
  title(main = "Coloration")
  barplot(dudi.pca(na.omit(lascaux$morpho), scan = FALSE)$eig)
  title(main = "Morphometric")
  barplot(dudi.acm(na.omit(lascaux$orne), scan = FALSE)$eig)
  title(main = "Ornemental")
  par(mfrow = c(1,1))
}
</code></pre>

<hr>
<h2 id='lingoes'>Transformation of a Distance Matrix for becoming Euclidean</h2><span id='topic+lingoes'></span>

<h3>Description</h3>

<p>transforms a distance matrix in a Euclidean one. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lingoes(distmat, print = FALSE, tol = 1e-07, cor.zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lingoes_+3A_distmat">distmat</code></td>
<td>
<p>an object of class <code>dist</code></p>
</td></tr>
<tr><td><code id="lingoes_+3A_print">print</code></td>
<td>
<p>if TRUE, prints the eigenvalues of the matrix</p>
</td></tr>
<tr><td><code id="lingoes_+3A_tol">tol</code></td>
<td>
<p>a tolerance threshold for zero</p>
</td></tr>
<tr><td><code id="lingoes_+3A_cor.zero">cor.zero</code></td>
<td>
<p>if TRUE, zero distances are not modified</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the smaller positive constant k which transforms the matrix of <code class="reqn">\sqrt{d_{ij}^2 + 2 \ast k}</code> in an Euclidean one
</p>


<h3>Value</h3>

<p>returns an object of class <code>dist</code> with a Euclidean distance
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Lingoes, J.C. (1971) Some boundary conditions for a monotone analysis of symmetric matrices. 
<em>Psychometrika</em>, <b>36</b>, 195&ndash;203. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(capitales)
d0 &lt;- capitales$dist
is.euclid(d0) # FALSE
d1 &lt;- lingoes(d0, TRUE)
# Lingoes constant = 2120982
is.euclid(d1) # TRUE
plot(d0, d1)
x0 &lt;- sort(unclass(d0))
lines(x0, sqrt(x0^2 + 2 * 2120982), lwd = 3)
 
is.euclid(sqrt(d0^2 + 2 * 2120981), tol = 1e-10) # FALSE
is.euclid(sqrt(d0^2 + 2 * 2120982), tol = 1e-10) # FALSE
is.euclid(sqrt(d0^2 + 2 * 2120983), tol = 1e-10) 
    # TRUE the smaller constant
</code></pre>

<hr>
<h2 id='lizards'>Phylogeny and quantitative traits of lizards</h2><span id='topic+lizards'></span>

<h3>Description</h3>

<p>This data set describes the phylogeny of 18 lizards as reported by Bauwens and Díaz-Uriarte (1997). 
It also gives life-history traits corresponding to these 18 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lizards)</code></pre>


<h3>Format</h3>

<p><code>lizards</code> is a list containing the 3 following objects : 
</p>
    
<dl>
<dt>traits</dt><dd><p>is a data frame with 18 species and 8 traits.</p>
</dd>  
<dt>hprA</dt><dd><p>is a character string giving the phylogenetic tree (hypothesized phylogenetic relationships based on immunological distances) in Newick format.</p>
</dd> 
<dt>hprB</dt><dd><p>is a character string giving the phylogenetic tree (hypothesized phylogenetic relationships based on morphological characteristics) in Newick format.</p>
</dd>
</dl>


<h3>Details</h3>

<p>Variables of <code>lizards$traits</code> are the following ones : 
mean.L (mean length (mm)), matur.L (length at maturity (mm)), 
max.L (maximum length (mm)), hatch.L (hatchling length (mm)),
hatch.m (hatchling mass (g)), clutch.S (Clutch size),
age.mat (age at maturity (number of months of activity)),
clutch.F (clutch frequency).
</p>


<h3>References</h3>

<p>Bauwens, D., and Díaz-Uriarte, R. (1997) Covariation of life-history traits in lacertid lizards: a comparative study. 
<em>American Naturalist</em>, <b>149</b>, 91&ndash;111. 
</p>
<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps063.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps063.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lizards)
w &lt;- data.frame(scalewt(log(lizards$traits)))
par(mfrow = c(1,2))
wphy &lt;- newick2phylog(lizards$hprA)
table.phylog(w, wphy, csi = 3)
wphy &lt;- newick2phylog(lizards$hprB)
table.phylog(w, wphy, csi = 3)
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='loocv.between'>
Leave-one-out cross-validation for a <code>bca</code>
</h2><span id='topic+loocv.between'></span><span id='topic+plot.bcaloocv'></span><span id='topic+print.bcaloocv'></span>

<h3>Description</h3>

<p>Leave-one-out cross-validation for <code>bca</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'between'
loocv(x, nax = 0, progress = FALSE, parallel = FALSE, ...)
## S3 method for class 'bcaloocv'
print(x, ...)
## S3 method for class 'bcaloocv'
plot(x, xax = 1, yax = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loocv.between_+3A_x">x</code></td>
<td>

<p>dudi of the <code>bca</code> on which cross-validation should be done
</p>
</td></tr>
<tr><td><code id="loocv.between_+3A_nax">nax</code></td>
<td>

<p>list of axes for mean overlap index computation (0 = all axes)
</p>
</td></tr>
<tr><td><code id="loocv.between_+3A_progress">progress</code></td>
<td>

<p>logical, TRUE = display a progress bar during computations
</p>
</td></tr>
<tr><td><code id="loocv.between_+3A_parallel">parallel</code></td>
<td>

<p>logical, TRUE = process cross-validation in parallel computing 
</p>
</td></tr>
<tr><td><code id="loocv.between_+3A_xax">xax</code>, <code id="loocv.between_+3A_yax">yax</code></td>
<td>

<p>the numbers of the x-axis and the y-axis
</p>
</td></tr>
<tr><td><code id="loocv.between_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list containing the cross-validated coordinates of the rows (the rows of the original analysis, not the rows of the <code>bca</code>). The <code>dudi</code> on which the <code>bca</code> was computed is redone after removing each row of the data table, one at a time. A <code>bca</code> is done on this new <code>dudi</code> and the coordinates of the missing row are computed by projection as supplementary element in the corresponding <code>bca</code>. This is most useful in the case p &gt;&gt; n (many variables and few samples), where <code>bca</code> graphs can show spurious groups (see Refs.)
</p>
<p>For parallel computing (parallel argument = TRUE), the new <code>dudi</code>, <code>bca</code> and cross-validation computations are processed in parallel on all the available nodes of the computer processor(s).
</p>


<h3>Value</h3>

<p>A list with:
</p>
<p>- <code>XValCoord</code>: 
the cross-validated row coordinates 
</p>
<p>- <code>PRESS</code>: 
the Predicted Residual Error Sum for each row
</p>
<p>- <code>PRESSTot</code>: 
the sum of <code>PRESS</code> for each <code>bca</code> axis 
</p>
<p>- <code>Oij_bga</code>: 
the mean overlap index for BGA
</p>
<p>- <code>Oij_XVal</code>: 
the mean overlap index for cross-validation
</p>
<p>- <code>DeltaOij</code>: 
the spuriousness index

</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse
</p>


<h3>References</h3>

<p>Thioulouse J, Renaud S, Dufour AB, Dray S. Overcoming the Spurious Groups Problem in Between-Group PCA. Evolutionary Biology (2021). (Accepted).
</p>
<p>Cardini A, Polly D. Cross-validated Between Group PCA Scatterplots: A Solution to Spurious Group Separation ? Evolutionary Biology (2020) 47:85–95. <a href="https://doi.org/10.1007/s11692-020-09494-x">doi:10.1007/s11692-020-09494-x</a>
</p>
<p>Cardini A, O'Higgins P, Rohlf J. Seeing Distinct Groups Where There are None: Spurious Patterns from Between-Group PCA. Evolutionary Biology (2019) 46:303-316. <a href="https://doi.org/10.1007/s11692-019-09487-5">doi:10.1007/s11692-019-09487-5</a>
</p>
<p>Bookstein F. Pathologies of Between-Groups Principal Components Analysis in Geometric Morphometrics. Evolutionary Biology (2019) 46:271-302. <a href="https://doi.org/10.1007/s11692-019-09484-8">doi:10.1007/s11692-019-09484-8</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+loocv.dudi">loocv.dudi</a>
<a href="#topic+loocv.discrimin">loocv.discrimin</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data = meaudret
data(meaudret)
pca1 &lt;- dudi.pca(meaudret$env, scannf = FALSE, nf = 3)
bca1 &lt;- bca(pca1, meaudret$design$site, scannf = FALSE, nf = 3)
pst1 &lt;- paste0("Meaudret BGA randtest: p=",
randtest(bca1)$pvalue, " ratio=", round(bca1$ratio, 2))
xbca1 &lt;- loocv(bca1, progress = TRUE)

if(adegraphicsLoaded()){
    sc1 &lt;- s.class(bca1$ls, meaudret$design$site, col = TRUE,
    psub.text = pst1, ellipseSize=0, chullSize=1, plot = FALSE)
    sc2 &lt;- s.class(xbca1$XValCoord, meaudret$design$site,
    col = TRUE, psub.text = "Meaudret cross-validation",
    ellipseSize=0, chullSize=1, plot = FALSE)
    ADEgS(list(sc1, sc2))
} else {
	par(mfrow=c(2,2))
	s.chull(dfxy = bca1$ls, fac = meaudret$design$site, cpoint = 1, 
    	col = hcl.colors(5, "Dark 2"), sub = pst1)
    s.class(bca1$ls, meaudret$design$site, col = hcl.colors(5, "Dark 2"),
    	cellipse = 0, add.plot = TRUE)
	s.chull(dfxy = xbca1$XValCoord, fac = meaudret$design$site, cpoint = 1, 
    	col = hcl.colors(5, "Dark 2"), sub = "Meaudret cross-validation")
    s.class(xbca1$XValCoord, meaudret$design$site, col = hcl.colors(5, "Dark 2"),
    	cellipse = 0, add.plot = TRUE)
}
## Not run: 
# Data = rnorm()
set.seed(9)
fac1 &lt;- as.factor(rep(1:3, each = 10))
tab &lt;- as.data.frame(matrix(rnorm(10800), nrow = 30))
pca2 &lt;- dudi.pca(tab, scannf = FALSE)
bca2 &lt;- bca(pca2, fac1, scannf = FALSE)
pst2 &lt;- paste0("rnorm spurious groups: p=",
randtest(bca2)$pvalue, " ratio=", round(bca2$ratio, 2))
xbca2 &lt;- loocv(bca2, progress = TRUE)
if(adegraphicsLoaded()){
	sc3 &lt;- s.class(bca2$ls, fac1, col = TRUE,
		psub.text = pst2, ellipseSize=0, chullSize=1,
		xlim = c(-8, 8), ylim = c(-8, 8), plot = FALSE)
	sc4 &lt;- s.class(xbca2$XValCoord, fac1, col = TRUE,
		psub.text = "rnorm cross-validation", ellipseSize=0,
		chullSize=1, xlim = c(-8, 8), ylim = c(-8, 8), plot = FALSE)
	ADEgS(list(sc3, sc4))
} else {
	par(mfrow=c(2,2))
	s.chull(bca2$ls, fac1, optchull = 1, cpoint = 1, xlim = c(-8, 8), ylim = c(-8, 8),
    	col = hcl.colors(3, "Dark 2"), sub = pst2)
    s.class(bca2$ls, fac1, xlim = c(-8, 8), ylim = c(-8, 8),
    	col = hcl.colors(3, "Dark 2"), cellipse = 0, add.plot = TRUE)
	s.chull(xbca2$XValCoord, fac1, optchull = 1, cpoint = 1, xlim = c(-8, 8),
		ylim = c(-8, 8), col = hcl.colors(3, "Dark 2"), sub = "rnorm cross-validation")
    s.class(xbca2$XValCoord, fac1, xlim = c(-8, 8), ylim = c(-8, 8),
    	col = hcl.colors(3, "Dark 2"), cellipse = 0, add.plot = TRUE)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='loocv.discrimin'>
Leave-one-out cross-validation for a <code>discrimin</code> analysis
</h2><span id='topic+loocv.discrimin'></span><span id='topic+plot.discloocv'></span><span id='topic+print.discloocv'></span>

<h3>Description</h3>

<p>Leave-one-out cross-validation to test the existence of groups in a <code>discrimin</code> analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'discrimin'
loocv(x, nax = 0, progress = FALSE, ...)
## S3 method for class 'discloocv'
print(x, ...)
## S3 method for class 'discloocv'
plot(x, xax = 1, yax = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loocv.discrimin_+3A_x">x</code></td>
<td>

<p>the <code>discrimin</code> analysis on which cross-validation should be done
</p>
</td></tr>
<tr><td><code id="loocv.discrimin_+3A_nax">nax</code></td>
<td>

<p>list of axes for mean overlap index computation (0 = all axes)
</p>
</td></tr>
<tr><td><code id="loocv.discrimin_+3A_progress">progress</code></td>
<td>

<p>logical to display a progress bar during computations (see the <code>progress</code> package)
</p>
</td></tr>
<tr><td><code id="loocv.discrimin_+3A_xax">xax</code>, <code id="loocv.discrimin_+3A_yax">yax</code></td>
<td>

<p>the numbers of the x-axis and the y-axis
</p>
</td></tr>
<tr><td><code id="loocv.discrimin_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list containing the cross-validated coordinates of the rows. The analysis on which the <code>discrimin</code> was computed is redone after removing each row of the data table, one at a time. A <code>discrimin</code> analysis is done on this new analysis and the coordinates of the missing row are computed by projection as supplementary element in the new <code>discrimin</code> analysis. This can be useful to check that the groups evidenced by the <code>discrimin</code> analysis are supported.
</p>


<h3>Value</h3>

<p>A list with:
</p>
<p>- <code>XValCoord</code>: 
the cross-validated row coordinates 
</p>
<p>- <code>PRESS</code>: 
the Predicted Residual Error Sum for each row
</p>
<p>- <code>PRESSTot</code>: 
the sum of <code>PRESS</code> for each <code>bca</code> axis 
</p>
<p>- <code>Oij_disc</code>: 
the mean overlap index for the discriminant analysis
</p>
<p>- <code>Oij_XVal</code>: 
the mean overlap index for cross-validation
</p>
<p>- <code>DeltaOij</code>: 
the spuriousness index

</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse
</p>


<h3>See Also</h3>

<p><a href="#topic+loocv.dudi">loocv.dudi</a>
<a href="#topic+loocv.between">loocv.between</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Data = skulls
data(skulls)
pcaskul &lt;- dudi.pca(skulls, scan = FALSE)
facskul &lt;- gl(5,30)
diskul &lt;- discrimin(pcaskul, facskul, scan = FALSE)
xdiskul &lt;- loocv(diskul, progress = TRUE)
oijdisc &lt;- xdiskul$Oij_disc
oijxval &lt;- xdiskul$Oij_XVal
Doij &lt;- (oijxval - oijdisc)/0.5*100
pst1 &lt;- paste0("Skulls discrimin randtest: p=", round(randtest(diskul)$pvalue, 4), 
", Oij = ", round(oijdisc,2))
pst2 &lt;- paste0("Skulls cross-validation: Oij = ", round(oijxval,2), ", dOij = ",
round(Doij), "%")
if (adegraphicsLoaded()) {
	sc1 &lt;- s.class(diskul$li, facskul, col = TRUE, psub.text = pst1, ellipseSize=0,
	chullSize=1, plot = FALSE)
	sc2 &lt;- s.class(xdiskul$XValCoord, facskul, col = TRUE, psub.text = pst2,
	ellipseSize=0, chullSize=1, plot = FALSE)
	ADEgS(list(sc1, sc2), layout=c(2,2))
} else {
	par(mfrow=c(2,2))
	s.class(diskul$li, facskul, sub = pst1)
	s.class(xdiskul$XValCoord, facskul, sub = pst2)
}
data(chazeb)
pcacz &lt;- dudi.pca(chazeb$tab, scan = FALSE)
discz &lt;- discrimin(pcacz, chazeb$cla, scan = FALSE)
xdiscz &lt;- loocv(discz, progress = TRUE)
oijdiscz &lt;- xdiscz$Oij_disc
oijxvalz &lt;- xdiscz$Oij_XVal
Doijz &lt;- (oijxvalz - oijdiscz)/0.5*100
pst1 &lt;- paste0("Chazeb discrimin randtest: p=", round(randtest(discz)$pvalue, 4), 
", Oij = ", round(oijdiscz,2))
pst2 &lt;- paste0("Chazeb cross-validation: Oij = ", round(oijxvalz,2), ", dOij = ", 
round(Doijz), "%")
if (adegraphicsLoaded()) {
	tabi &lt;- cbind(discz$li, pcacz$tab)
	gr1 &lt;- s.class(tabi, xax=1, yax=2:7, chazeb$cla, col = TRUE, plot = FALSE)
	for (i in 1:6) gr1[[i]] &lt;- update(gr1[[i]], psub.text = names(tabi)[i+1],
	plot = FALSE)
	pos1 &lt;- gr1@positions
	pos1[,1] &lt;- c(0, .3333, .6667, 0, .3333, .6667)
	pos1[,2] &lt;- c(.6667, .6667, .6667, .3333, .3333, .3333)
	pos1[,3] &lt;- c(.3333, .6667, 1, .3333, .6667, 1)
	pos1[,4] &lt;- c(1, 1, 1, .6667, .6667, .6667)
	gr1@positions &lt;- pos1
	sc1 &lt;- s1d.gauss(discz$li, chazeb$cla, col = TRUE, psub.text = pst1,
	plot = FALSE)
	sc2 &lt;- s1d.gauss(xdiscz$XValCoord, chazeb$cla, col = TRUE, psub.text = pst2,
	plot = FALSE)
	ADEgS(list(gr1[[1]], gr1[[2]], gr1[[3]], gr1[[4]], gr1[[5]], gr1[[6]], sc1, sc2))
} else {
	dev.new()
	sco.gauss(discz$li[,1], as.data.frame(chazeb$cla), sub = pst1)
	dev.new()
	sco.gauss(xdiscz$XValCoord[,1], as.data.frame(chazeb$cla), sub = pst2)
}

## End(Not run)</code></pre>

<hr>
<h2 id='loocv.dudi'>
Leave-one-out cross-validation for a <code>dudi</code>
</h2><span id='topic+loocv.dudi'></span><span id='topic+loocv'></span>

<h3>Description</h3>

<p>Leave-one-out cross-validation to check the dispersion of row coordinates in a <code>dudi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dudi'
loocv(x, progress = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loocv.dudi_+3A_x">x</code></td>
<td>

<p>the dudi of the <code>bca</code> on which cross-validation should be done
</p>
</td></tr>
<tr><td><code id="loocv.dudi_+3A_progress">progress</code></td>
<td>

<p>logical to display a progress bar during computations (see the <code>progress</code> package)
</p>
</td></tr>
<tr><td><code id="loocv.dudi_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does a cross-validation of the row coordinates of a dudi. Each row is removed from the table one at a time, and its coordinates are computed by projection of this row in the analysis of the table with the removed row. This can be used to check the sensitivity of an analysis to outliers. The cross-validated and original coordinates can be compared with the <code>s.match</code> function (see example).
</p>


<h3>Value</h3>

<p>A list with:
</p>
<p>- <code>XValCoord</code>: 
the cross-validated row coordinates 
</p>
<p>- <code>PRESS</code>: 
the Predicted Residual Error Sum for each row
</p>
<p>- <code>PRESSTot</code>: 
the sum of <code>PRESS</code> for each <code>bca</code> axis 

</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse
</p>


<h3>See Also</h3>

<p><a href="#topic+loocv.between">loocv.between</a>, <a href="#topic+loocv.discrimin">loocv.discrimin</a>, <a href="#topic+suprow">suprow</a>, <a href="#topic+s.match">s.match</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
envpca &lt;- dudi.pca(meaudret$env, scannf = FALSE, nf = 3)
xvpca &lt;- loocv(envpca)
s.match(envpca$li, xvpca$XValCoord)
</code></pre>

<hr>
<h2 id='macaca'>Landmarks</h2><span id='topic+macaca'></span>

<h3>Description</h3>

<p>This data set gives the landmarks of a macaca at the ages of 0.9 and 5.77 years. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(macaca)</code></pre>


<h3>Format</h3>

<p><code>macaca</code> is a list of 2 components.
</p>

<dl>
<dt>xy1</dt><dd><p>is a data frame with 72 points and 2 coordinates.</p>
</dd>
<dt>xy2</dt><dd><p>is a data frame with 72 points and 2 coordinates.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Olshan, A.F., Siegel, A.F. and Swindler, D.R. (1982)
Robust and least-squares orthogonal mapping: Methods for the study of cephalofacial form and growth.
<em>American Journal of Physical Anthropology</em>, <b>59</b>, 131&ndash;137.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(macaca)
pro1 &lt;- procuste(macaca$xy1, macaca$xy2, scal = FALSE)
pro2 &lt;- procuste(macaca$xy1, macaca$xy2)
  
if(adegraphicsLoaded()) {
  g1 &lt;- s.match(macaca$xy1, macaca$xy2, plab.cex = 0, plot = FALSE)
  g2 &lt;- s.match(pro1$tabX, pro1$rotY, plab.cex = 0.7, plot = FALSE)
  g3 &lt;- s.match(pro1$tabY, pro1$rotX, plab.cex = 0.7, plot = FALSE)
  g4 &lt;- s.match(pro2$tabY, pro2$rotX, plab.cex = 0.7, plot = FALSE)
  G &lt;- ADEgS(c(g1, g2, g3, g4), layout = c(2, 2))

} else {
  par(mfrow = c(2,2))
  s.match(macaca$xy1, macaca$xy2, clab = 0)
  s.match(pro1$tabX, pro1$rotY, clab = 0.7)
  s.match(pro1$tabY, pro1$rotX, clab = 0.7)
  s.match(pro2$tabY, pro2$rotX, clab = 0.7)
  par(mfrow = c(1,1))
}</code></pre>

<hr>
<h2 id='macon'>Wine Tasting</h2><span id='topic+macon'></span>

<h3>Description</h3>

<p>The <code>macon</code> data frame has 8 rows-wines and 25 columns-tasters.
Each column is a classification of 8 wines (Beaujolais, France).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(macon)</code></pre>


<h3>Source</h3>

<p>Foire Nationale des Vins de France, Mâcon, 1985
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(macon)
s.corcircle(dudi.pca(macon, scan = FALSE)$co)
</code></pre>

<hr>
<h2 id='macroloire'>Assemblages of Macroinvertebrates in the Loire River (France)</h2><span id='topic+macroloire'></span>

<h3>Description</h3>

<p>A total of 38 sites were surveyed along 800 km of the Loire River yielding 40 species 
of Trichoptera and Coleoptera sampled from riffle habitats. The river was divided 
into three regions according to geology: granitic highlands (Region#1), 
limestone lowlands (Region#2) and granitic lowlands (Region#3). This data set has been 
collected for analyzing changes in macroinvertebrate assemblages 
along the course of a large river. Four criterias are given here: variation in 1/ species composition 
and relative abundance, 2/ taxonomic composition, 3/ Body Sizes, 4/ Feeding habits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(macroloire)</code></pre>


<h3>Format</h3>

<p><code>macroloire</code> is a list of 5 components.
</p>

<dl>
<dt>fau</dt><dd><p>is a data frame containing the abundance of each species in each station.</p>
</dd>
<dt>traits</dt><dd><p>is a data frame describes two traits : the maximal sizes and feeding habits for each species. 
Each trait is divided into categories. The maximal size achieved by the species 
is divided into four length categories: &lt;= 5mm ; &gt;5-10mm ; &gt;10-20mm ; &gt;20-40mm. 
Feeding habits comprise seven categories: engulfers, shredders, scrapers,
deposit-feeders, active filter-feeders, passive filter-feeders and piercers, in this order.
The affinity of each species to each trait category is quantified using a fuzzy coding approach.
A score is assigned to each species for describing its affinity for a given trait category from &quot;0&quot;
which indicates no affinity to &quot;3&quot; which indicates high affinity. These affinities are
further transformed into percentage per trait per species.</p>
</dd>
<dt>taxo</dt><dd><p>is a data frame with species and 3 factors: Genus, Family
and Order. It is a data frame of class &quot;taxo&quot;: the
variables are factors giving nested classifications.</p>
</dd>
<dt>envir</dt><dd><p>is a data frame giving for each station, its name (variable &quot;SamplingSite&quot;), 
its distance from the source (km, variable &quot;Distance&quot;), its altitude (m, variable &quot;Altitude&quot;),
its position regarding the dams [1: before the first dam; 2: 
after the first dam; 3: after the second dam] (variable &quot;Dam&quot;),
its position in one of the three regions defined according to
geology: granitic highlands, limestone lowlands and granitic
lowlands (variable &quot;Morphoregion&quot;), presence of confluence (variable &quot;Confluence&quot;)</p>
</dd>
<dt>labels</dt><dd><p>is a data frame containing the latin names of the species.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Ivol, J.M., Guinand, B., Richoux, P. and Tachet, H. (1997) Longitudinal changes in
Trichoptera and Coleoptera assemblages and environmental conditions in the Loire
River (France). <em>Archiv for Hydrobiologie</em>, <b>138</b>, 525&ndash;557.<br />
</p>
<p>Pavoine S. and Doledec S. (2005) The apportionment of quadratic entropy: 
a useful alternative for partitioning diversity in ecological data. 
<em>Environmental and Ecological Statistics</em>, <b>12</b>, 125&ndash;138.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(macroloire)
    apqe.Equi &lt;- apqe(macroloire$fau, , macroloire$morphoregions)
    apqe.Equi
    #test.Equi &lt;- randtest.apqe(apqe.Equi, method = "aggregated", 99)
    #plot(test.Equi)

    ## Not run:  

    m.phy &lt;- taxo2phylog(macroloire$taxo)
    apqe.Tax &lt;- apqe(macroloire$fau, m.phy$Wdist, macroloire$morphoregions)
    apqe.Tax
    #test.Tax &lt;- randtest.apqe(apqe.Tax, method = "aggregated", 99)
    #plot(test.Tax)

    dSize &lt;- sqrt(dist.prop(macroloire$traits[ ,1:4], method = 2))
    apqe.Size &lt;- apqe(macroloire$fau, dSize, macroloire$morphoregions)
    apqe.Size
    #test.Size &lt;- randtest.apqe(apqe.Size, method = "aggregated", 99)
    #plot(test.Size)

    dFeed &lt;- sqrt(dist.prop(macroloire$traits[ ,-(1:4)], method = 2))
    apqe.Feed &lt;- apqe(macroloire$fau, dFeed, macroloire$morphoregions)
    apqe.Feed
    #test.Feed &lt;- randtest.apqe(apqe.Feed, method = "aggregated", 99)
    #plot(test.Size)

    
## End(Not run)

</code></pre>

<hr>
<h2 id='mafragh'>Phyto-Ecological Survey</h2><span id='topic+mafragh'></span>

<h3>Description</h3>

<p>This data set gives environmental and spatial informations about species and 
sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mafragh)</code></pre>


<h3>Format</h3>

<p><code>mafragh</code> is a list with the following components:
</p>

<dl>
<dt>xy</dt><dd><p>the coordinates of 97 sites</p>
</dd>
<dt>flo</dt><dd><p>a data frame with 97 sites and 56 species</p>
</dd>
<dt>neig</dt><dd><p>the neighbourhood graph of the 97 sites (an object of class <code>neig</code>)</p>
</dd>
<dt>env</dt><dd><p>a data frame with 97 sites and 11 environmental variables</p>
</dd>
<dt>partition</dt><dd><p>a factor classifying the 97 sites in 7 classes</p>
</dd>
<dt>area</dt><dd><p>a data frame of class <code>area</code></p>
</dd>
<dt>tre</dt><dd><p>a character providing the phylogeny as a newick object</p>
</dd>
<dt>traits</dt><dd><p>a list of data frame. Each data frame provides the value of biological traits for plant species</p>
</dd>
<dt>nb</dt><dd><p>the neighbourhood graph of the 97 Mafragh sites (an object of class <code>nb</code>)</p>
</dd>
<dt>Spatial</dt><dd><p>the map of the 97 Mafragh sites (an object of the class <code>SpatialPolygons</code> of <code>sp</code>)</p>
</dd>
<dt>spenames</dt><dd><p>a data frame with 56 rows (species) and 2 columns (names)</p>
</dd>
<dt>Spatial.contour</dt><dd><p>the contour of the Magragh map (an object of the class <code>SpatialPolygons</code> of <code>sp</code>)</p>
</dd>
</dl>


<h3>Source</h3>

<p>de Bélair, Gérard and Bencheikh-Lehocine, Mahmoud (1987) Composition et déterminisme de la végétation d'une 
plaine côtière marécageuse : La Mafragh (Annaba, Algérie). <em>Bulletin d'Ecologie</em>, <b>18</b>(4), 393&ndash;407.
</p>
<p>Pavoine, S., Vela, E., Gachet, S., de Bélair, G. and Bonsall, M. B. (2011)
Linking patterns in phylogeny, traits, abiotic variables and space: a novel approach to linking environmental filtering and plant community assembly. 
<em>Journal of Ecology</em>, <b>99</b>, 165&ndash;175. doi:10.1111/j.1365-2745.2010.01743.x
</p>


<h3>References</h3>

<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps053.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps053.pdf</a> (in French).</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mafragh)
coa1 &lt;- dudi.coa(mafragh$flo, scan = FALSE)
pca1 &lt;- dudi.pca(mafragh$xy, scan = FALSE)
if(adegraphicsLoaded()) {
  g1 &lt;- s.label(mafragh$xy, nb = mafragh$nb, psub.text = "Samples &amp; Neighbourhood graph", 
    plot = FALSE)
  g2 &lt;- s.value(mafragh$xy, coa1$li[, 1], psub.text = "Axis 1 - COA", plot = FALSE)
  g3 &lt;- s.value(mafragh$xy, pca1$li[, 1], psub.text = "Axis 1 - PCA", plot = FALSE)
  g4 &lt;- s.class(pca1$li, mafragh$partition, psub.text = "Plane 1-2 - PCA", plot = FALSE)
  g5 &lt;- s.class(coa1$li, mafragh$partition, psub.text = "Plane 1-2 - COA", plot = FALSE)
  g6 &lt;- s.class(mafragh$xy, mafragh$partition, chullSize = 1, ellipseSize = 0, starSize = 0, 
    ppoints.cex = 0, plot = FALSE)
  G &lt;- ADEgS(c(g1, g2, g3, g4, g5, g6), layout = c(3, 2))

} else {
  par(mfrow = c(3, 2))
  s.label(mafragh$xy, inc = FALSE, neig = mafragh$neig, sub = "Samples &amp; Neighbourhood graph")
  s.value(mafragh$xy, coa1$li[, 1], sub = "Axis 1 - COA")
  s.value(mafragh$xy, pca1$li[, 1], sub = "Axis 1 - PCA")
  s.class(pca1$li, mafragh$partition, sub = "Plane 1-2 - PCA")
  s.class(coa1$li, mafragh$partition, sub = "Plane 1-2 - COA")
  s.chull(mafragh$xy, mafragh$partition, optchull = 1)
  par(mfrow = c(1, 1))
}

## Not run: 
link1 &lt;- area2link(mafragh$area)
neig1 &lt;- neig(mat01 = 1*(link1 &gt; 0))
nb1 &lt;- neig2nb(neig1)

if(adegraphicsLoaded()) {
  if(requireNamespace("sp", quietly = TRUE)) {
    g7 &lt;- s.label(mafragh$xy, Sp = mafragh$Spatial, pSp.col = "white", plot = FALSE)
    g8 &lt;- s.label(mafragh$xy, Sp = mafragh$Spatial, pSp.col = "white", nb = nb1, plab.cex = 0, 
      pnb.node.cex = 0, ppoints.cex = 0, plot = FALSE)
    G &lt;- ADEgS(c(g7, g8), layout = c(2, 1))
  }

} else {
  par(mfrow = c(2, 1))
  area.plot(mafragh$area, center = mafragh$xy, clab = 0.75)
  area.plot(mafragh$area, center = mafragh$xy, graph = neig1)
  par(mfrow = c(1, 1))
}

if(requireNamespace("spdep", quietly = TRUE)) {
  lw1 &lt;- apply(link1, 1, function(x) x[x &gt; 0])
  listw1 &lt;- spdep::nb2listw(nb1, lw1)
  coa1 &lt;- dudi.coa(mafragh$flo, scan = FALSE, nf = 4)
  ms1 &lt;- multispati(coa1, listw1, scan = FALSE, nfp = 2, nfn = 0)
  summary(ms1)
  
  if(adegraphicsLoaded()) {
    if(requireNamespace("lattice", quietly = TRUE)) {
      g9 &lt;- s1d.barchart(coa1$eig, p1d.hori = FALSE, plot = FALSE)
      g10 &lt;- s1d.barchart(ms1$eig, p1d.hori = FALSE, plot = FALSE)
      g11 &lt;- s.corcircle(ms1$as, plot = FALSE)
      g12 &lt;- lattice::xyplot(ms1$li[, 1] ~ coa1$li[, 1])
      G &lt;- ADEgS(list(g9, g10, g11, g12), layout = c(2, 2))
    }
    
  } else {    
    par(mfrow = c(2, 2))
    barplot(coa1$eig)
    barplot(ms1$eig)
    s.corcircle(ms1$as)
    plot(coa1$li[, 1], ms1$li[, 1])
    par(mfrow = c(1, 1))
  }
}

## End(Not run)</code></pre>

<hr>
<h2 id='mantel.randtest'>Mantel test (correlation between two distance matrices (in C).)
</h2><span id='topic+mantel.randtest'></span>

<h3>Description</h3>

<p>Performs a Mantel test between two distance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mantel.randtest(m1, m2, nrepet = 999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mantel.randtest_+3A_m1">m1</code></td>
<td>
<p>an object of class <code>dist</code></p>
</td></tr>
<tr><td><code id="mantel.randtest_+3A_m2">m2</code></td>
<td>
<p>an object of class <code>dist</code></p>
</td></tr>
<tr><td><code id="mantel.randtest_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="mantel.randtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>randtest</code> (randomization tests)
</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse <a href="mailto:Jean.Thioulouse@univ-lyon1.fr">Jean.Thioulouse@univ-lyon1.fr</a></p>


<h3>References</h3>

<p>Mantel, N. (1967) The detection of disease clustering and a generalized regression approach. <em>Cancer Research</em>, <b>27</b>, 209&ndash;220.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(yanomama)
gen &lt;- quasieuclid(as.dist(yanomama$gen))
geo &lt;- quasieuclid(as.dist(yanomama$geo))
plot(r1 &lt;- mantel.randtest(geo,gen), main = "Mantel's test")
r1
</code></pre>

<hr>
<h2 id='mantel.rtest'>Mantel test (correlation between two distance matrices (in R).)
</h2><span id='topic+mantel.rtest'></span>

<h3>Description</h3>

<p>Performs a Mantel test between two distance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mantel.rtest(m1, m2, nrepet = 99, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mantel.rtest_+3A_m1">m1</code></td>
<td>
<p>an object of class <code>dist</code></p>
</td></tr>
<tr><td><code id="mantel.rtest_+3A_m2">m2</code></td>
<td>
<p>an object of class <code>dist</code></p>
</td></tr>
<tr><td><code id="mantel.rtest_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="mantel.rtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>rtest</code> (randomization tests)
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Mantel, N. (1967) The detection of disease clustering and a generalized regression approach. <em>Cancer Research</em>, <b>27</b>, 209&ndash;220.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(yanomama)
    gen &lt;- quasieuclid(as.dist(yanomama$gen))
    geo &lt;- quasieuclid(as.dist(yanomama$geo))
    plot(r1 &lt;- mantel.rtest(geo,gen), main = "Mantel's test")
    r1
</code></pre>

<hr>
<h2 id='maples'>Phylogeny and quantitative traits of flowers</h2><span id='topic+maples'></span>

<h3>Description</h3>

<p>This data set describes the phylogeny of 17 flowers as reported by Ackerly and Donoghue (1998). It also gives 31 traits corresponding to these 17 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(maples)</code></pre>


<h3>Format</h3>

<p><code>tithonia</code> is a list containing the 2 following objects :
</p>

<dl>
<dt>tre</dt><dd><p>is a character string giving the phylogenetic tree in Newick format.</p>
</dd> 
<dt>tab</dt><dd><p>is a data frame with 17 species and 31 traits</p>
</dd>
</dl>



<h3>References</h3>

<p>Ackerly, D. D. and Donoghue, M.J. (1998) Leaf size, sapling allometry, and Corner's rules: phylogeny and correlated evolution in Maples (Acer). 
<em>American Naturalist</em>, <b>152</b>, 767&ndash;791.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(maples)
phy &lt;- newick2phylog(maples$tre)
dom &lt;- maples$tab$Dom
bif &lt;- maples$tab$Bif
if (requireNamespace("adephylo", quietly = TRUE) &amp; requireNamespace("ape", quietly = TRUE)) {
  phylo &lt;- ape::read.tree(text = maples$tre)
  adephylo::orthogram(dom, tre = phylo)
  adephylo::orthogram(bif, tre = phylo)
  par(mfrow = c(1, 2))
  dotchart.phylog(phy, dom)
  dotchart.phylog(phy, bif, clabel.nodes = 0.7)
  par(mfrow = c(1, 1))
  plot(bif, dom, pch = 20)
  abline(lm(dom~bif))
  summary(lm(dom~bif))
  cor.test(bif, dom)
  pic.bif &lt;- ape::pic(bif, phylo)
  pic.dom &lt;- ape::pic(dom, phylo)
  cor.test(pic.bif, pic.dom)
}
</code></pre>

<hr>
<h2 id='mariages'>Correspondence Analysis Table</h2><span id='topic+mariages'></span>

<h3>Description</h3>

<p>This array contains the socio-professionnal repartitions of 5850 couples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mariages)</code></pre>


<h3>Format</h3>

<p>The <code>mariages</code> data frame has 9 rows and 9 columns.
The rows represent the wife's socio-professionnal category and the columns the husband's socio-professionnal category (1982).<br />
</p>
<p>Codes for rows and columns are identical : agri (Farmers), ouva (Farm workers),
pat (Company directors (commerce and industry)), sup (Liberal profession, executives and higher intellectual professions),
moy (Intermediate professions), emp (Other white-collar workers), ouv (Manual workers), serv (Domestic staff),
aut (other workers).
</p>


<h3>Source</h3>

<p>Vallet, L.A. (1986)
Activité professionnelle de la femme mariée et détermination de la position sociale de la famille.
Un test empirique : la France entre 1962 et 1982.
<em>Revue Française de Sociologie</em>, <b>27</b>, 656&ndash;696.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mariages)
w &lt;- dudi.coa(mariages, scan = FALSE, nf = 3)

if(adegraphicsLoaded()) {
  g1 &lt;- scatter(w, met = 1, posi = "bottomleft", plot = FALSE)
  g2 &lt;- scatter(w, met = 2, posi = "bottomleft", plot = FALSE)
  g3 &lt;- scatter(w, met = 3, posi = "bottomleft", plot = FALSE)
  ## g4 &lt;- score(w, 3)
  G &lt;- ADEgS(list(g1, g2, g3), layout = c(2, 2))

} else {
  par(mfrow = c(2, 2))
  scatter(w, met = 1, posi = "bottom")
  scatter(w, met = 2, posi = "bottom")
  scatter(w, met = 3, posi = "bottom")
  score(w, 3)
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='mbpcaiv'>Multiblock principal component analysis with instrumental variables</h2><span id='topic+mbpcaiv'></span>

<h3>Description</h3>

<p>Function to perform a multiblock redundancy analysis of several explanatory blocks <code class="reqn">(X_1, \dots, X_k)</code>, defined as an object of class <code>ktab</code>, to explain a dependent dataset $Y$, defined as an object of class <code>dudi</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>mbpcaiv(dudiY, ktabX, scale = TRUE, option = c("uniform", "none"), scannf = TRUE, nf = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbpcaiv_+3A_dudiy">dudiY</code></td>
<td>
<p>an object of class <code>dudi</code> containing the dependent variables</p>
</td></tr>
<tr><td><code id="mbpcaiv_+3A_ktabx">ktabX</code></td>
<td>
<p>an object of class <code>ktab</code>  containing the blocks of
explanatory variables</p>
</td></tr>
<tr><td><code id="mbpcaiv_+3A_scale">scale</code></td>
<td>
<p>logical value indicating whether the explanatory variables
should be standardized</p>
</td></tr>
<tr><td><code id="mbpcaiv_+3A_option">option</code></td>
<td>
<p>an option for the block weighting. If <code>uniform</code>,
the block weight is equal to $1/K$ for <code class="reqn">(X_1, \dots, X_K)</code> and to
$1$ for $X$ and $Y$. If <code>none</code>, the block weight is equal to the
block inertia</p>
</td></tr>
<tr><td><code id="mbpcaiv_+3A_scannf">scannf</code></td>
<td>
<p>logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="mbpcaiv_+3A_nf">nf</code></td>
<td>
<p>integer indicating the number of kept dimensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matching call</p>
</td></tr>
<tr><td><code>tabY</code></td>
<td>
<p>data frame of dependent variables centered, eventually scaled (if <span class="option">scale=TRUE</span>) and weighted (if <span class="option">option="uniform"</span>)</p>
</td></tr>
<tr><td><code>tabX</code></td>
<td>
<p>data frame of explanatory variables centered, eventually scaled (if <span class="option">scale=TRUE</span>) and weighted (if <span class="option">option="uniform"</span>)</p>
</td></tr>
<tr><td><code>TL</code>, <code>TC</code></td>
<td>
<p>data frame useful to manage graphical outputs</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>numeric value indicating the number of kept dimensions</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>numeric vector of row weights</p>
</td></tr>
<tr><td><code>X.cw</code></td>
<td>
<p>numeric vector of column weighs for the explanalatory dataset</p>
</td></tr>
<tr><td><code>blo</code></td>
<td>
<p>vector of the numbers of variables in each explanatory dataset</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>maximum rank of the analysis</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>numeric vector containing the eigenvalues</p>
</td></tr>
<tr><td><code>lX</code></td>
<td>
<p>matrix of the global components associated with the whole explanatory dataset (scores of the individuals)</p>
</td></tr>
<tr><td><code>lY</code></td>
<td>
<p>matrix of the components associated with the dependent dataset</p>
</td></tr>
<tr><td><code>Yc1</code></td>
<td>
<p>matrix of the variable loadings associated with the dependent dataset</p>
</td></tr>
<tr><td><code>Tli</code></td>
<td>
<p>matrix containing the partial components associated with each explanatory dataset</p>
</td></tr>
<tr><td><code>Tl1</code></td>
<td>
<p>matrix containing the normalized partial components associated with each explanatory dataset</p>
</td></tr>
<tr><td><code>Tfa</code></td>
<td>
<p>matrix containing the partial loadings associated with each explanatory dataset</p>
</td></tr>
<tr><td><code>cov2</code></td>
<td>
<p>squared covariance between lY and Tl1</p>
</td></tr>
<tr><td><code>Yco</code></td>
<td>
<p>matrix of the regression coefficients of the dependent dataset onto the global components</p>
</td></tr>
<tr><td><code>faX</code></td>
<td>
<p>matrix of the regression coefficients of the whole explanatory dataset onto the global components</p>
</td></tr>
<tr><td><code>XYcoef</code></td>
<td>
<p>list of matrices of the regression coefficients of the whole explanatory dataset onto the dependent dataset</p>
</td></tr>
<tr><td><code>bip</code></td>
<td>
<p>block importances for a given dimension</p>
</td></tr>
<tr><td><code>bipc</code></td>
<td>
<p>cumulated block importances for a given number of dimensions</p>
</td></tr>
<tr><td><code>vip</code></td>
<td>
<p>variable importances for a given dimension</p>
</td></tr>
<tr><td><code>vipc</code></td>
<td>
<p>cumulated variable importances for a given number of dimensions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stéphanie Bougeard (<a href="mailto:stephanie.bougeard@anses.fr">stephanie.bougeard@anses.fr</a>) and Stéphane Dray (<a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>)</p>


<h3>References</h3>

<p>Bougeard, S., Qannari, E.M. and Rose, N. (2011) Multiblock Redundancy Analysis: interpretation tools and application in epidemiology. <em>Journal of Chemometrics</em>, <b>23</b>, 1-9
</p>
<p>Bougeard, S. and Dray S. (2018) Supervised Multiblock Analysis in R with the ade4 Package. <em>Journal of Statistical Software</em>, <b>86</b> (1), 1-17. <a href="https://doi.org/10.18637/jss.v086.i01">doi:10.18637/jss.v086.i01</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mbpls">mbpls</a></code>, <code><a href="#topic+testdim.multiblock">testdim.multiblock</a></code>, <code><a href="#topic+randboot.multiblock">randboot.multiblock</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chickenk)
Mortality &lt;- chickenk[[1]]
dudiY.chick &lt;- dudi.pca(Mortality, center = TRUE, scale = TRUE, scannf =
FALSE)
ktabX.chick &lt;- ktab.list.df(chickenk[2:5])
resmbpcaiv.chick &lt;- mbpcaiv(dudiY.chick, ktabX.chick, scale = TRUE,
option = "uniform", scannf = FALSE)
summary(resmbpcaiv.chick)
if(adegraphicsLoaded())
plot(resmbpcaiv.chick)
</code></pre>

<hr>
<h2 id='mbpls'>Multiblock partial least squares</h2><span id='topic+mbpls'></span>

<h3>Description</h3>

<p>Function to perform a multiblock partial least squares (PLS) of several explanatory blocks <code class="reqn">(X_1, \dots, X_k)</code> defined as an object of class <code>ktab</code>, to explain a dependent dataset $Y$ defined as an object of class <code>dudi</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>mbpls(dudiY, ktabX, scale = TRUE, option = c("uniform", "none"), scannf = TRUE, nf = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbpls_+3A_dudiy">dudiY</code></td>
<td>
<p>an object of class <code>dudi</code> containing the dependent variables</p>
</td></tr>
<tr><td><code id="mbpls_+3A_ktabx">ktabX</code></td>
<td>
<p>an object of class <code>ktab</code>  containing the blocks of
explanatory variables</p>
</td></tr>
<tr><td><code id="mbpls_+3A_scale">scale</code></td>
<td>
<p>logical value indicating whether the explanatory variables
should be standardized</p>
</td></tr>
<tr><td><code id="mbpls_+3A_option">option</code></td>
<td>
<p>an option for the block weighting. If <code>uniform</code>,
the block weight is equal to $1/K$ for <code class="reqn">(X_1, \dots, X_K)</code> and to
$1$ for $X$ and $Y$. If <code>none</code>, the block weight is equal to the block inertia</p>
</td></tr>
<tr><td><code id="mbpls_+3A_scannf">scannf</code></td>
<td>
<p>logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="mbpls_+3A_nf">nf</code></td>
<td>
<p>integer indicating the number of kept dimensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matching call</p>
</td></tr>
<tr><td><code>tabY</code></td>
<td>
<p>data frame of dependent variables centered, eventually scaled (if <span class="option">scale=TRUE</span>) and weighted (if <span class="option">option="uniform"</span>)</p>
</td></tr>
<tr><td><code>tabX</code></td>
<td>
<p>data frame of explanatory variables centered, eventually scaled (if <span class="option">scale=TRUE</span>) and weighted (if <span class="option">option="uniform"</span>)</p>
</td></tr>
<tr><td><code>TL</code>, <code>TC</code></td>
<td>
<p>data frame useful to manage graphical outputs</p>
</td></tr>  
<tr><td><code>nf</code></td>
<td>
<p>numeric value indicating the number of kept dimensions</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>numeric vector of row weights</p>
</td></tr>
<tr><td><code>X.cw</code></td>
<td>
<p>numeric vector of column weighs for the explanalatory dataset</p>
</td></tr>
<tr><td><code>blo</code></td>
<td>
<p>vector of the numbers of variables in each explanatory dataset</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>maximum rank of the analysis</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>numeric vector containing the eigenvalues</p>
</td></tr>
<tr><td><code>lX</code></td>
<td>
<p>matrix of the global components associated with the whole explanatory dataset (scores of the individuals)</p>
</td></tr>
<tr><td><code>lY</code></td>
<td>
<p>matrix of the components associated with the dependent dataset</p>
</td></tr>
<tr><td><code>Yc1</code></td>
<td>
<p>matrix of the variable loadings associated with the dependent
dataset</p>
</td></tr>
<tr><td><code>cov2</code></td>
<td>
<p>squared covariance between lY and TlX</p>
</td></tr>
<tr><td><code>Tc1</code></td>
<td>
<p>matrix containing the partial loadings associated with each
explanatory dataset (unit norm)</p>
</td></tr>
<tr><td><code>TlX</code></td>
<td>
<p>matrix containing the partial components associated with each explanatory dataset</p>
</td></tr>
<tr><td><code>faX</code></td>
<td>
<p>matrix of the regression coefficients of the whole explanatory dataset onto the global components</p>
</td></tr>
<tr><td><code>XYcoef</code></td>
<td>
<p>list of matrices of the regression coefficients of the whole explanatory dataset onto the dependent dataset</p>
</td></tr>
<tr><td><code>bip</code></td>
<td>
<p>block importances for a given dimension</p>
</td></tr>
<tr><td><code>bipc</code></td>
<td>
<p>cumulated block importances for a given number of dimensions</p>
</td></tr>
<tr><td><code>vip</code></td>
<td>
<p>variable importances for a given dimension</p>
</td></tr>
<tr><td><code>vipc</code></td>
<td>
<p>cumulated variable importances for a given number of dimensions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stéphanie Bougeard (<a href="mailto:stephanie.bougeard@anses.fr">stephanie.bougeard@anses.fr</a>) and Stéphane Dray (<a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>)</p>


<h3>References</h3>

<p>Bougeard, S., Qannari, E.M., Lupo, C. and Hanafi, M. (2011). From multiblock partial least squares to multiblock redundancy analysis. A continuum approach. <em>Informatica</em>, 22(1), 11-26
</p>
<p>Bougeard, S. and Dray S. (2018) Supervised Multiblock Analysis in R with the ade4 Package. <em>Journal of Statistical Software</em>, <b>86</b> (1), 1-17. <a href="https://doi.org/10.18637/jss.v086.i01">doi:10.18637/jss.v086.i01</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mbpls">mbpls</a></code>, <code><a href="#topic+testdim.multiblock">testdim.multiblock</a></code>,
<code><a href="#topic+randboot.multiblock">randboot.multiblock</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chickenk)
Mortality &lt;- chickenk[[1]]
dudiY.chick &lt;- dudi.pca(Mortality, center = TRUE, scale = TRUE, scannf =
FALSE)
ktabX.chick &lt;- ktab.list.df(chickenk[2:5])
resmbpls.chick &lt;- mbpls(dudiY.chick, ktabX.chick, scale = TRUE,
option = "uniform", scannf = FALSE)
summary(resmbpls.chick)
if(adegraphicsLoaded())
plot(resmbpls.chick)
</code></pre>

<hr>
<h2 id='mcoa'>Multiple CO-inertia Analysis</h2><span id='topic+mcoa'></span><span id='topic+print.mcoa'></span><span id='topic+summary.mcoa'></span><span id='topic+plot.mcoa'></span>

<h3>Description</h3>

<p>performs a multiple CO-inertia analysis, 
using an object of class <code>ktab</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcoa(X, option = c("inertia", "lambda1", "uniform", "internal"), 
    scannf = TRUE, nf = 3, tol = 1e-07)
## S3 method for class 'mcoa'
print(x, ...)
## S3 method for class 'mcoa'
summary(object, ...)
## S3 method for class 'mcoa'
plot(x, xax = 1, yax = 2, eig.bottom = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcoa_+3A_x">X</code></td>
<td>
<p>an object of class <code>ktab</code></p>
</td></tr>
<tr><td><code id="mcoa_+3A_option">option</code></td>
<td>
<p>a string of characters for the weightings of the arrays
options :
</p>

<dl>
<dt>&quot;inertia&quot;</dt><dd><p>weighting of group k by the inverse of the total inertia of the array k</p>
</dd>
<dt>&quot;lambda1&quot;</dt><dd><p>weighting of group k by the inverse of the first eigenvalue of the k analysis</p>
</dd>
<dt>&quot;uniform&quot;</dt><dd><p>uniform weighting of groups</p>
</dd>
<dt>&quot;internal&quot;</dt><dd><p>weighting included in <code>X$tabw</code></p>
</dd>
</dl>

</td></tr>
<tr><td><code id="mcoa_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="mcoa_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="mcoa_+3A_tol">tol</code></td>
<td>
<p>a tolerance threshold, an eigenvalue is considered positive if it is larger than <code>-tol*lambda1</code> where <code>lambda1</code> is the largest eigenvalue.</p>
</td></tr>
<tr><td><code id="mcoa_+3A_x">x</code>, <code id="mcoa_+3A_object">object</code></td>
<td>
<p>an object of class 'mcoa'</p>
</td></tr>
<tr><td><code id="mcoa_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="mcoa_+3A_xax">xax</code>, <code id="mcoa_+3A_yax">yax</code></td>
<td>
<p>the numbers of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="mcoa_+3A_eig.bottom">eig.bottom</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be added</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mcoa returns a list of  class 'mcoa' containing :
</p>
<table>
<tr><td><code>pseudoeig</code></td>
<td>
<p>a numeric vector with the all pseudo eigenvalues</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call-up order</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>a numeric value indicating the number of kept axes</p>
</td></tr>
<tr><td><code>SynVar</code></td>
<td>
<p>a data frame with the synthetic scores</p>
</td></tr>
<tr><td><code>axis</code></td>
<td>
<p>a data frame with the co-inertia axes</p>
</td></tr>
<tr><td><code>Tli</code></td>
<td>
<p>a data frame with the co-inertia coordinates</p>
</td></tr>
<tr><td><code>Tl1</code></td>
<td>
<p>a data frame with the co-inertia normed scores</p>
</td></tr>
<tr><td><code>Tax</code></td>
<td>
<p>a data frame with the inertia axes onto co-inertia axis</p>
</td></tr>
<tr><td><code>Tco</code></td>
<td>
<p>a data frame with the column coordinates onto synthetic scores</p>
</td></tr>
<tr><td><code>TL</code></td>
<td>
<p>a data frame with the factors for Tli Tl1</p>
</td></tr>
<tr><td><code>TC</code></td>
<td>
<p>a data frame with the factors for Tco</p>
</td></tr>
<tr><td><code>T4</code></td>
<td>
<p>a data frame with the factors for Tax</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>a data frame with the all eigenvalues (computed on the separate analyses)</p>
</td></tr>
<tr><td><code>cov2</code></td>
<td>
<p>a numeric vector with the all pseudo eigenvalues (synthetic analysis)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Chessel, D. and Hanafi, M. (1996) Analyses de la co-inertie de K nuages de points, <em>Revue de Statistique Appliquée</em>, <b>44</b>, 35&ndash;60.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(friday87)
w1 &lt;- data.frame(scale(friday87$fau, scal = FALSE))
w2 &lt;- ktab.data.frame(w1, friday87$fau.blo, tabnames = friday87$tab.names)
mcoa1 &lt;- mcoa(w2, "lambda1", scan = FALSE)
mcoa1
summary(mcoa1)
plot(mcoa1)
</code></pre>

<hr>
<h2 id='mdpcoa'>Multiple Double Principal Coordinate Analysis</h2><span id='topic+mdpcoa'></span><span id='topic+kplotX.mdpcoa'></span><span id='topic+prep.mdpcoa'></span>

<h3>Description</h3>

<p>The DPCoA analysis (see <code><a href="#topic+dpcoa">dpcoa</a></code>) has been developed by Pavoine et al. (2004).
It has been used in genetics for describing inter-population nucleotide
diversity. However, this procedure can only be used with one locus. In order to measure
and describe nucleotide diversity with more than one locus, we developed three versions of
multiple DPCoA by using three ordination methods: multiple co-inertia analysis, STATIS, and
multiple factorial analysis.
The multiple DPCoA allows the impact of various loci in the
measurement and description of diversity to be quantified and described. This method is general enough to handle a large variety
of data sets. It complements existing methods such as the analysis of molecular variance or other
analyses based on linkage disequilibrium measures, and is very useful to study the impact of various
loci on the measurement of diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdpcoa(msamples, mdistances = NULL, method = 
    c("mcoa", "statis", "mfa"), 
    option = c("inertia", "lambda1", "uniform", "internal"), 
    scannf = TRUE, nf = 3, full = TRUE, 
    nfsep = NULL, tol = 1e-07)
kplotX.mdpcoa(object, xax = 1, yax = 2, mfrow = NULL, 
    which.tab = 1:length(object$nX), includepop = FALSE, 
    clab = 0.7, cpoi = 0.7, unique.scale = FALSE, 
    csub = 2, possub = "bottomright")
prep.mdpcoa(dnaobj, pop, model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdpcoa_+3A_msamples">msamples</code></td>
<td>
<p>A list of data frames with the populations as columns, alleles as rows and abundances as
entries. All the tables should have equal numbers of columns (populations). Each table
corresponds to a locus;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_mdistances">mdistances</code></td>
<td>
<p>A list of objects of class 'dist', corresponding to the distances among alleles. The order of
the loci should be the same in msamples as in mdistances;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_method">method</code></td>
<td>
<p>One of the three possibilities: &quot;mcoa&quot;, &quot;statis&quot;, or &quot;mfa&quot;. If a vector is given, only its first
value is considered;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_option">option</code></td>
<td>
<p>One of the four possibilities for normalizing the population coordinates over the loci:
&quot;inertia&quot;, &quot;lambda1&quot;, &quot;uniform&quot;, or &quot;internal&quot;. These options are used with MCoA and
MFA only;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plots should be displayed;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_nf">nf</code></td>
<td>
<p>if scannf is FALSE, an integer indicating the number of kept axes for the multiple analysis;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_full">full</code></td>
<td>
<p>a logical value indicating whether all the axes should be kept in the separated analyses
(one analysis, DPCoA, per locus);</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_nfsep">nfsep</code></td>
<td>
<p>if full is FALSE, a vector indicating the number of kept axes for each of the separated
analyses;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_tol">tol</code></td>
<td>
<p>a tolerance threshold for null eigenvalues (a value less than tol times the first one is
considered as null);</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_object">object</code></td>
<td>
<p>an object of class 'mdpcoa';</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_xax">xax</code></td>
<td>
<p>the number of the x-axis;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_yax">yax</code></td>
<td>
<p>the number of the y-axis;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_mfrow">mfrow</code></td>
<td>
<p>a vector of the form 'c(nr,nc)', otherwise computed by as special own function 'n2mfrow';</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_which.tab">which.tab</code></td>
<td>
<p>a numeric vector containing the numbers of the loci to analyse;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_includepop">includepop</code></td>
<td>
<p>a logical indicating if the populations must be displayed. In that case, the alleles are
displayed by points and the populations by labels;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_clab">clab</code></td>
<td>
<p>a character size for the labels;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_cpoi">cpoi</code></td>
<td>
<p>a character size for plotting the points, used with 'par(&quot;cex&quot;)'*cpoint. If zero, no points are
drawn;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_unique.scale">unique.scale</code></td>
<td>
<p>if TRUE, all the arrays of figures have the same scale;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_csub">csub</code></td>
<td>
<p>a character size for the labels of the arrays of figures used with 'par(&quot;cex&quot;)*csub';</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position
(&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;);</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_dnaobj">dnaobj</code></td>
<td>
<p>a list of dna sequences that can be obtained with the function <code>read.dna</code> of the ape package;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_pop">pop</code></td>
<td>
<p>a factor that gives the name of the population to which each sequence belongs;</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_model">model</code></td>
<td>
<p>a vector giving the model to be applied for the calculations of
the distances for each locus. One model should be attributed to each
locus, given that the loci are in alphabetical order. The models can
take the following values: &quot;raw&quot;, &quot;JC69&quot;, &quot;K80&quot; (the default), &quot;F81&quot;,
&quot;K81&quot;, &quot;F84&quot;, &quot;BH87&quot;, &quot;T92&quot;, &quot;TN93&quot;, &quot;GG95&quot;, &quot;logdet&quot;, or &quot;paralin&quot;.
See the help documentation for the function &quot;dist.dna&quot; of ape for a
describtion of the models.</p>
</td></tr>
<tr><td><code id="mdpcoa_+3A_...">...</code></td>
<td>
<p><code>...</code> further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object obtained by the function mdpcoa has two classes. The first one is &quot;mdpcoa&quot; and the
second is either &quot;mcoa&quot;, or &quot;statis&quot;, or &quot;mfa&quot;, depending on the method chosen.
Consequently, other functions already available in ade4 for displaying graphical results can be
used:
With MCoA,
- plot.mcoa: this function displays (1) the differences among the populations according
to each locus and the compromise, (2) the projection of the principal axes of the
individual analyses onto the synthetic variables,
(3) the projection of the principal axes of the individual analyses onto the co-inertia
axes, (4) the squared vectorial covariance
among the coinertia scores and the synthetic variables;
- kplot.mcoa: this function divides previous displays (figures 1, 2, or 3 described in
plot.mcoa) by giving one plot per locus.
</p>
<p>With STATIS,
- plot.statis: this function displays (1) the scores of each locus according to the two
first eigenvectors of the matrix <em>Rv</em>, (2) the scatter diagram of the differences among
populations according to the compromise, (3) the weight attributed to each locus
in abscissa and the vectorial covariance among each individual analysis with the
notations in the main text of the paper) and the compromise analysis in
ordinates, (4) the covariance between the principal component inertia axes of each
locus and the axes of the compromise space;
- kplot.statis: this function displays for each locus the projection of the principal
axes onto the compromise space.
</p>
<p>With MFA,
- plot.mfa: this function displays (1) the differences among the populations according
to each locus and the compromise, (2) the projection of the principal axes of the
individual analyses onto the compromise, (3) the covariance between the principal
component inertia axes of each locus and the axes of the compromise space, (4) for
each axis of the compromise, the amount of inertia conserved by the projection of the
individual analyses onto the common space.
- kplot.mfa: this function displays for each locus the projection of the principal axes
and populations onto the compromise space.
</p>


<h3>Value</h3>

<p>The functions provide the following results: 
</p>
<table>
<tr><td><code>dist.ktab</code></td>
<td>
<p>returns an object of class <code>dist</code>;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sandrine Pavoine <a href="mailto:pavoine@mnhn.fr">pavoine@mnhn.fr</a>
</p>


<h3>References</h3>

<p>Pavoine, S. and Bailly, X. (2007) New analysis for consistency among markers in the study of genetic diversity: 
development and application to the description of bacterial diversity. <em>BMC Evolutionary Biology</em>, <b>7</b>, e156.<br />
</p>
<p>Pavoine, S., Dufour, A.B. and Chessel, D. (2004) From dissimilarities among species to dissimilarities among communities:
a double principal coordinate analysis. <em>Journal of Theoretical Biology</em>, <b>228</b>, 523&ndash;537.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpcoa">dpcoa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The functions used below require the package ape
data(rhizobium)
if (requireNamespace("ape", quietly = TRUE)) {
dat &lt;- prep.mdpcoa(rhizobium[[1]], rhizobium[[2]], 
    model = c("F84", "F84", "F84", "F81"), pairwise.deletion = TRUE)
sam &lt;- dat$sam
dis &lt;- dat$dis
# The distances should be Euclidean. 
# Several transformations exist to render a distance object Euclidean 
# (see functions cailliez, lingoes and quasieuclid in the ade4 package). 
# Here we use the quasieuclid function.
dis &lt;- lapply(dis, quasieuclid)
mdpcoa1 &lt;- mdpcoa(sam, dis, scannf = FALSE, nf = 2)

# Reference analysis
plot(mdpcoa1)

# Differences between the loci
kplot(mdpcoa1)

# Alleles projected on the population maps.
kplotX.mdpcoa(mdpcoa1)
}
</code></pre>

<hr>
<h2 id='meau'>Ecological Data : sites-variables, sites-species, where and when</h2><span id='topic+meau'></span>

<h3>Description</h3>

<p>This data set contains information about sites, environmental variables
and Ephemeroptera Species. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meau)</code></pre>


<h3>Format</h3>

<p><code>meau</code> is a list of 3 components.
</p>

<dl>
<dt>env</dt><dd><p>is a data frame with 24 sites and 10 physicochemical variables.</p>
</dd>
<dt>fau</dt><dd><p>is a data frame with 24 sites and 13 Ephemeroptera Species.</p>
</dd>
<dt>design</dt><dd><p>is a data frame with 24 sites and 2 factors.
</p>

<ul>
<li> <p><code>season</code>: is a factor with 4 levels = seasons.
</p>
</li>
<li> <p><code>site</code>: is a factor with 6 levels = sites.
</p>
</li></ul>

</dd>
</dl>



<h3>Details</h3>

<p>Data set equivalents to <code><a href="#topic+meaudret">meaudret</a></code>, except that one site (6) along the Bourne (a Meaudret affluent) and
one physico chemical variable - the oxygen concentration were added.
</p>


<h3>Source</h3>

<p>Pegaz-Maucet, D. (1980)
<em>Impact d'une perturbation d'origine organique sur la dérive des macro-invertébrés benthiques d'un cours d'eau.
Comparaison avec le benthos</em>.
Thèse de 3ème cycle, Université Lyon 1, 130 p.
</p>
<p>Thioulouse, J., Simier, M. and Chessel, D. (2004) Simultaneous analysis of a sequence of paired ecological
tables. <em>Ecology</em>, <b>85</b>, 1, 272&ndash;283.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meau)
pca1 &lt;- dudi.pca(meau$env, scan = FALSE, nf = 4)
pca2 &lt;- bca(pca1, meau$design$season, scan = FALSE, nf = 2)

if(adegraphicsLoaded()) {
  g1 &lt;- s.class(pca1$li, meau$design$season, psub.text = "Principal Component Analysis", 
    plot = FALSE)
  g2 &lt;- s.class(pca2$ls, meau$design$season, 
    psub.text = "Between seasons Principal Component Analysis", plot = FALSE)
  g3 &lt;- s.corcircle(pca1$co, plot = FALSE)
  g4 &lt;- s.corcircle(pca2$as, plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  
} else {
  par(mfrow = c(2, 2))
  s.class(pca1$li, meau$design$season, 
      sub = "Principal Component Analysis")
  s.class(pca2$ls, meau$design$season, sub = "Between seasons Principal Component Analysis")
  s.corcircle(pca1$co)
  s.corcircle(pca2$as)
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='meaudret'>Ecological Data : sites-variables, sites-species, where and when</h2><span id='topic+meaudret'></span>

<h3>Description</h3>

<p>This data set contains information about sites, environmental variables
and Ephemeroptera Species. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meaudret)</code></pre>


<h3>Format</h3>

<p><code>meaudret</code> is a list of 4 components.
</p>

<dl>
<dt>env</dt><dd><p>is a data frame with 20 sites and 9 variables.</p>
</dd>
<dt>fau</dt><dd><p>is a data frame with 20 sites and 13 Ephemeroptera Species.</p>
</dd>
<dt>design</dt><dd><p>is a data frame with 20 sites and 2 factors.
</p>

<ul>
<li> <p><code>season</code> is a factor with 4 levels = seasons.
</p>
</li>
<li> <p><code>site</code> is a factor with 5 levels = sites along the Meaudret river.
</p>
</li></ul>

</dd>
<dt>spe.names</dt><dd><p>is a character vector containing the names of the 13 species.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data set equivalents to <code><a href="#topic+meau">meau</a></code>: site (6) on the Bourne (a Meaudret affluent) and
oxygen concentration were removed.
</p>


<h3>Source</h3>

<p>Pegaz-Maucet, D. (1980) 
<em>Impact d'une perturbation d'origine organique sur la dérive des macro-invertébrés benthiques d'un cours d'eau.
Comparaison avec le benthos.</em>
Thèse de 3ème cycle, Université Lyon 1, 130 p.
</p>
<p>Thioulouse, J., Simier, M. and Chessel, D. (2004) Simultaneous analysis of a sequence of paired ecological
tables. <em>Ecology</em>, <b>85</b>, 1, 272&ndash;283.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
pca1 &lt;- dudi.pca(meaudret$env, scan = FALSE, nf = 4)
pca2 &lt;- bca(pca1, meaudret$design$season, scan = FALSE, nf = 2)
  
if(adegraphicsLoaded()) {
  g1 &lt;- s.class(pca1$li, meaudret$design$season, 
    psub.text = "Principal Component Analysis", plot = FALSE)
  g2 &lt;- s.class(pca2$ls, meaudret$design$season, 
    psub.text = "Between dates Principal Component Analysis", plot = FALSE)
  g3 &lt;- s.corcircle(pca1$co, plot = FALSE)
  g4 &lt;- s.corcircle(pca2$as, plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))

} else {
  par(mfrow = c(2, 2))
  s.class(pca1$li, meaudret$design$season, sub = "Principal Component Analysis")
  s.class(pca2$ls, meaudret$design$season, sub = "Between dates Principal Component Analysis")
  s.corcircle(pca1$co)
  s.corcircle(pca2$as)
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='mfa'>Multiple Factorial Analysis</h2><span id='topic+mfa'></span><span id='topic+print.mfa'></span><span id='topic+plot.mfa'></span><span id='topic+summary.mfa'></span>

<h3>Description</h3>

<p>performs a multiple factorial analysis, 
using an object of class <code>ktab</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfa(X, option = c("lambda1", "inertia", "uniform", "internal"), 
    scannf = TRUE, nf = 3)
## S3 method for class 'mfa'
plot(x, xax = 1, yax = 2, option.plot = 1:4, ...) 
## S3 method for class 'mfa'
print(x, ...) 
## S3 method for class 'mfa'
summary(object, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfa_+3A_x">X</code></td>
<td>
<p>K-tables, an object of class <code>ktab</code></p>
</td></tr>
<tr><td><code id="mfa_+3A_option">option</code></td>
<td>
<p>a string of characters for the weighting of arrays
options :
</p>

<dl>
<dt><code>lambda1</code></dt><dd><p>weighting of group k by the inverse of the first eigenvalue of the k analysis</p>
</dd>
<dt><code>inertia</code></dt><dd><p>weighting of group k by the inverse of the total inertia of the array k</p>
</dd>
<dt><code>uniform</code></dt><dd><p>uniform weighting of groups</p>
</dd>
<dt><code>internal</code></dt><dd><p>weighting included in <code>X$tabw</code></p>
</dd>
</dl>

</td></tr>
<tr><td><code id="mfa_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="mfa_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="mfa_+3A_x">x</code>, <code id="mfa_+3A_object">object</code></td>
<td>
<p>an object of class 'mfa'</p>
</td></tr>
<tr><td><code id="mfa_+3A_xax">xax</code>, <code id="mfa_+3A_yax">yax</code></td>
<td>
<p>the numbers of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="mfa_+3A_option.plot">option.plot</code></td>
<td>
<p>an integer between 1 and 4, otherwise the 4 components of the plot are displayed</p>
</td></tr>
<tr><td><code id="mfa_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list including :
</p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>a data frame with the modified array</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>a vector of ranks for the analyses</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a numeric vector with the all eigenvalues</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>a data frame with the coordinates of rows</p>
</td></tr>
<tr><td><code>TL</code></td>
<td>
<p>a data frame with the factors associated to the rows (indicators of table)</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>a data frame with the coordinates of columns</p>
</td></tr>
<tr><td><code>TC</code></td>
<td>
<p>a data frame with the factors associated to the columns (indicators of table)</p>
</td></tr>
<tr><td><code>blo</code></td>
<td>
<p>a vector indicating the number of variables for each table</p>
</td></tr>
<tr><td><code>lisup</code></td>
<td>
<p>a data frame with the projections of normalized scores of rows for each table</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>a data frame containing the projected inertia and the links between the arrays and the reference array</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Escofier, B. and Pagès, J. (1994) Multiple factor analysis (AFMULT package), <em>Computational Statistics and Data Analysis</em>, <b>18</b>, 121&ndash;140.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(friday87)
w1 &lt;- data.frame(scale(friday87$fau, scal = FALSE))
w2 &lt;- ktab.data.frame(w1, friday87$fau.blo, 
    tabnames = friday87$tab.names)
mfa1 &lt;- mfa(w2, scann = FALSE)
mfa1
plot(mfa1)

data(escopage)
w &lt;- data.frame(scale(escopage$tab))
w &lt;- ktab.data.frame(w, escopage$blo, tabnames = escopage$tab.names)
plot(mfa(w, scann = FALSE))
</code></pre>

<hr>
<h2 id='microsatt'>Genetic Relationships between cattle breeds with microsatellites</h2><span id='topic+microsatt'></span>

<h3>Description</h3>

<p>This data set gives genetic relationships between cattle breeds with microsatellites. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(microsatt)</code></pre>


<h3>Format</h3>

<p><code>microsatt</code> is a list of 4 components. 
</p>

<dl>
<dt>tab</dt><dd><p>contains the allelic frequencies for 18 cattle breeds (Taurine or Zebu,French or African) and 9 microsatellites.</p>
</dd>
<dt>loci.names</dt><dd><p>is a vector of the names of loci.</p>
</dd>
<dt>loci.eff</dt><dd><p>is a vector of the number of alleles per locus.</p>
</dd>
<dt>alleles.names</dt><dd><p>is a vector of the names of alleles.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Extract of data prepared by D. Laloë <a href="mailto:ugendla@dga2.jouy.inra.fr">ugendla@dga2.jouy.inra.fr</a> from data used in:
</p>
<p>Moazami-Goudarzi, K., D. Laloë, J. P. Furet, and F. Grosclaude (1997)
Analysis of genetic relationships between 10 cattle breeds with 17 microsatellites.
<em>Animal Genetics</em>, <b>28</b>, 338&ndash;345.
</p>
<p>Souvenir Zafindrajaona, P.,Zeuh V. ,Moazami-Goudarzi K., Laloë D., Bourzat D., Idriss A., and Grosclaude F. (1999)
Etude du statut phylogénétique du bovin Kouri du lac Tchad à l'aide de marqueurs moléculaires.
<em>Revue d'Elevage et de Médecine Vétérinaire des pays Tropicaux</em>, <b>55</b>, 155&ndash;162.
</p>
<p>Moazami-Goudarzi, K., Belemsaga D. M. A., Ceriotti G., Laloë D. , Fagbohoun F., Kouagou N. T., Sidibé I., Codjia V., Crimella M. C., Grosclaude F. and Touré S. M. (2001)<br />
Caractérisation de la race bovine Somba à l'aide de marqueurs moléculaires.
<em>Revue d'Elevage et de Médecine Vétérinaire des pays Tropicaux</em>, <b>54</b>, 1&ndash;10.
</p>


<h3>References</h3>

<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps055.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps055.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(microsatt)
fac &lt;- factor(rep(microsatt$loci.names, microsatt$loci.eff))
w &lt;- dudi.coa(data.frame(t(microsatt$tab)), scann = FALSE)
wit &lt;- wca(w, fac, scann = FALSE)
microsatt.ktab &lt;- ktab.within(wit)

plot(sepan(microsatt.ktab)) # 9 separated correspondence analyses
plot(mcoa(microsatt.ktab, scan = FALSE))
plot(mfa(microsatt.ktab, scan = FALSE))
plot(statis(microsatt.ktab, scan = FALSE))

## End(Not run)</code></pre>

<hr>
<h2 id='mjrochet'>Phylogeny and quantitative traits of teleos fishes</h2><span id='topic+mjrochet'></span>

<h3>Description</h3>

<p>This data set describes the phylogeny of 49 teleos fishes as reported by Rochet et al. (2000). It also gives life-history traits corresponding to these 49 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mjrochet)</code></pre>


<h3>Format</h3>

<p><code>mjrochet</code> is a list containing the 2 following objects : 
</p>
 
<dl>
<dt>tre</dt><dd><p>is a character string giving the phylogenetic tree in Newick format.</p>
</dd>
<dt>tab</dt><dd><p>is a data frame with 49 rows and 7 traits.</p>
</dd>  
</dl>


<h3>Details</h3>

        
<p>Variables of <code>mjrochet$tab</code> are the following ones : tm (age at maturity (years)), 
lm (length at maturity (cm)), l05 (length at 5 per cent survival (cm)),
t05 (time to 5 per cent survival (years)), fb (slope of the log-log fecundity-length relationship),
fm (fecundity the year of maturity), egg (volume of eggs (<code class="reqn">mm^{3}</code>)).
</p>


<h3>Source</h3>

<p>Data taken from: <br />
Summary of data - Clupeiformes : http://www.ifremer.fr/maerha/clupe.html <br />
Summary of data - Argentiniformes : http://www.ifremer.fr/maerha/argentin.html <br />
Summary of data - Salmoniformes : http://www.ifremer.fr/maerha/salmon.html <br />
Summary of data - Gadiformes : http://www.ifremer.fr/maerha/gadi.html <br />
Summary of data - Lophiiformes : http://www.ifremer.fr/maerha/loph.html <br />
Summary of data - Atheriniformes : http://www.ifremer.fr/maerha/ather.html <br />
Summary of data - Perciformes : http://www.ifremer.fr/maerha/perci.html <br />
Summary of data - Pleuronectiformes : http://www.ifremer.fr/maerha/pleuro.html <br />
Summary of data - Scorpaeniformes : http://www.ifremer.fr/maerha/scorpa.html <br />
Phylogenetic tree : http://www.ifremer.fr/maerha/life_history.html
</p>


<h3>References</h3>

<p>Rochet, M. J., Cornillon, P-A., Sabatier, R. and Pontier, D. (2000) 
Comparative analysis of phylogenic and fishing effects in life history patterns of teleos fishes.
<em>Oïkos</em>, <b>91</b>, 255&ndash;270.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mjrochet)
mjrochet.phy &lt;- newick2phylog(mjrochet$tre)
tab &lt;- log((mjrochet$tab))
tab0 &lt;- data.frame(scalewt(tab))
table.phylog(tab0, mjrochet.phy, csi = 2, clabel.r = 0.75)
if (requireNamespace("adephylo", quietly = TRUE)) {
  adephylo::orthogram(tab0[,1], ortho = mjrochet.phy$Bscores)
}
</code></pre>

<hr>
<h2 id='mld'>Multi Level Decomposition of unidimensional data</h2><span id='topic+mld'></span><span id='topic+haar2level'></span>

<h3>Description</h3>

<p>The function <code>mld</code> performs an additive decomposition of the input vector <code>x</code> onto sub-spaces associated 
to an orthonormal orthobasis. The sub-spaces are defined by levels of the input factor <code>level</code>.
The function <code>haar2level</code> builds the factor <code>level</code> such that the multi level decomposition corresponds exactly to a multiresolution analysis performed with the haar basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mld(x, orthobas, level, na.action = c("fail", "mean"),
 plot = TRUE, dfxy = NULL, phylog = NULL, ...)
haar2level(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mld_+3A_x">x</code></td>
<td>
<p>is a vector or a time serie containing the data to be decomposed. This must be a dyadic length vector (power of 2) for the function <code>haar2level</code>.</p>
</td></tr>
<tr><td><code id="mld_+3A_orthobas">orthobas</code></td>
<td>
<p>is a data frame containing the vectors of the orthonormal basis.</p>
</td></tr>
<tr><td><code id="mld_+3A_level">level</code></td>
<td>
<p>is a factor which levels define the sub-spaces on which the function <code>mld</code> performs the additive decomposition.</p>
</td></tr>
<tr><td><code id="mld_+3A_na.action">na.action</code></td>
<td>
<p> if 'fail' stops the execution of the current expression when <code>x</code> contains any missing value. If 'mean' replaces any missing values by mean(<code>x</code>).</p>
</td></tr>
<tr><td><code id="mld_+3A_plot">plot</code></td>
<td>
<p>if TRUE plot <code>x</code> and the components resulting from the decomposition.</p>
</td></tr>
<tr><td><code id="mld_+3A_dfxy">dfxy</code></td>
<td>
<p>is a data frame with two coordinates.</p>
</td></tr>
<tr><td><code id="mld_+3A_phylog">phylog</code></td>
<td>
<p>is an object of class <code>phylog</code>.</p>
</td></tr>
<tr><td><code id="mld_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the components resulting from the decomposition.
</p>


<h3>Author(s)</h3>

<p>Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a></p>


<h3>References</h3>

<p>Mallat, S. G. (1989) A theory for multiresolution signal decomposition: the wavelet representation. 
<em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, <b>11</b>, 7, 674&ndash;693.
</p>
<p>Percival, D. B. and Walden, A. T. (2000) <em>Wavelet Methods for Time Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gridrowcol">gridrowcol</a></code>, <code><a href="#topic+orthobasis">orthobasis</a></code>, 
<code><a href="adephylo.html#topic+orthogram">orthogram</a></code>, <code><a href="waveslim.html#topic+mra">mra</a></code> 
for multiresolution analysis with various families of wavelets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# decomposition of a time serie
data(co2)
x &lt;- log(co2)
orthobas &lt;- orthobasis.line(length(x))
level&lt;-rep("D", 467)
level[1:3]&lt;-rep("A", 3)
level[c(77,78,79,81)]&lt;-rep("B", 4)
level[156]&lt;-"C"
level&lt;-as.factor(level)
res &lt;- mld(x, orthobas, level)
sum(scale(x, scale = FALSE) - apply(res, 1, sum))

## End(Not run)
# decomposition of a biological trait on a phylogeny
data(palm)
vfruit&lt;-palm$traits$vfruit
vfruit&lt;-scalewt(vfruit)   
palm.phy&lt;-newick2phylog(palm$tre)
level &lt;- rep("F", 65)
level[c(4, 21, 3, 6, 13)] &lt;- LETTERS[1:5]
level &lt;- as.factor(level)
res &lt;- mld(as.vector(vfruit), palm.phy$Bscores, level,
 phylog = palm.phy, clabel.nod = 0.7, f.phylog=0.8,
  csize = 2, clabel.row = 0.7, clabel.col = 0.7)
</code></pre>

<hr>
<h2 id='mollusc'>Faunistic Communities and Sampling Experiment</h2><span id='topic+mollusc'></span>

<h3>Description</h3>

<p>This data set gives the abundance of 32 mollusk species in 163 samples. 
For each sample, 4 informations are known : the sampling sites, the seasons, 
the sampler types and the time of exposure. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mollusc)</code></pre>


<h3>Format</h3>

<p><code>mollusc</code> is a list of 2 objects.
</p>

<dl>
<dt>fau</dt><dd><p>is a data frame with 163 samples and 32 mollusk species (abundance).</p>
</dd>
<dt>plan</dt><dd><p>contains the 163 samples and 4 variables.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Richardot-Coulet, M., Chessel D. and Bournaud M. (1986)
Typological value of the benthos of old beds of a large river. Methodological approach.
<em>Archiv fùr Hydrobiologie</em>, <b>107</b>, 363&ndash;383.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mollusc)
coa1 &lt;- dudi.coa(log(mollusc$fau + 1), scannf = FALSE, nf = 3)

if(adegraphicsLoaded()) {
  g1 &lt;- s.class(coa1$li, mollusc$plan$site, ellipseSize = 0, starSize = 0, chullSize = 1, 
    xax = 2, yax = 3, plot = FALSE)
  g2 &lt;- s.class(coa1$li, mollusc$plan$season, ellipseSize = 0, starSize = 0, chullSize = 1, 
    xax = 2, yax = 3, plot = FALSE)
  g3 &lt;- s.class(coa1$li, mollusc$plan$method, ellipseSize = 0, starSize = 0, chullSize = 1, 
    xax = 2, yax = 3, plot = FALSE)
  g4 &lt;- s.class(coa1$li, mollusc$plan$duration, ellipseSize = 0, starSize = 0, chullSize = 1, 
    xax = 2, yax = 3, plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  
} else {
  par(mfrow = c(2, 2))
  s.chull(coa1$li, mollusc$plan$site, 2, 3, opt = 1, cpoi = 1)
  s.chull(coa1$li, mollusc$plan$season, 2, 3, opt = 1, cpoi = 1)
  s.chull(coa1$li, mollusc$plan$method, 2, 3, opt = 1, cpoi = 1)
  s.chull(coa1$li, mollusc$plan$duration, 2, 3, opt = 1, cpoi = 1)
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='monde84'>Global State of the World in 1984</h2><span id='topic+monde84'></span>

<h3>Description</h3>

<p>The <code>monde84</code> data frame gives five demographic variables 
for 48 countries in the world. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(monde84)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<ol>
<li><p> pib: Gross Domestic Product
</p>
</li>
<li><p> croipop: Growth of the population
</p>
</li>
<li><p> morta: Infant Mortality
</p>
</li>
<li><p> anal: Literacy Rate
</p>
</li>
<li><p> scol: Percentage of children in full-time education
</p>
</li></ol>



<h3>Source</h3>

<p>Geze, F. and Coll., eds. (1984)
<em>L'état du Monde 1984 : annuaire économique et géopolitique mondial</em>. La Découverte, Paris.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(monde84)
X &lt;- cbind.data.frame(lpib = log(monde84$pib), monde84$croipop)
Y &lt;- cbind.data.frame(lmorta = log(monde84$morta), 
    lanal = log(monde84$anal + 1), rscol = sqrt(100 - monde84$scol))
pcaY &lt;- dudi.pca(Y, scan = FALSE)
pcaiv1 &lt;- pcaiv(pcaY, X0 &lt;- scale(X), scan = FALSE)
sum(cor(pcaiv1$l1[,1], Y0 &lt;- scale(Y))^2)
pcaiv1$eig[1] #the same
</code></pre>

<hr>
<h2 id='morphosport'>Athletes' Morphology</h2><span id='topic+morphosport'></span>

<h3>Description</h3>

<p>This data set gives a morphological description of 153 athletes split in five different sports. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(morphosport)</code></pre>


<h3>Format</h3>

<p><code>morphosport</code> is a list of 2 objects.
</p>

<dl>
<dt>tab</dt><dd><p>is a data frame with 153 athletes and 5 variables.</p>
</dd>
<dt>sport</dt><dd><p>is a factor with 6 items</p>
</dd>
</dl>



<h3>Details</h3>

    
<p>Variables of <code>morphosport$tab</code> are the following ones: dbi (biacromial diameter (cm)),
tde (height (cm)), tas (distance from the buttocks to the top of the head (cm)),
lms (length of the upper limbs (cm)), poids (weigth (kg)).<br />
</p>
<p>The levels of <code>morphosport$sport</code> are: athl (athletics), foot (football),
hand (handball), judo, nata (swimming), voll (volleyball).
</p>


<h3>Source</h3>

<p>Mimouni , N. (1996) 
<em>Contribution de méthodes biométriques à l'analyse de la morphotypologie des sportifs</em>. 
Thèse de doctorat. Université Lyon 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(morphosport)
plot(discrimin(dudi.pca(morphosport$tab, scan = FALSE), 
    morphosport$sport, scan = FALSE))
</code></pre>

<hr>
<h2 id='mstree'>Minimal Spanning Tree</h2><span id='topic+mstree'></span>

<h3>Description</h3>

<p>Minimal Spanning Tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstree(xdist, ngmax = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstree_+3A_xdist">xdist</code></td>
<td>
<p> an object of class <code>dist</code> containing an observed dissimilarity </p>
</td></tr>
<tr><td><code id="mstree_+3A_ngmax">ngmax</code></td>
<td>
<p> a component number (default=1). Select 1 for getting classical MST. To add n supplementary edges k times: select k+1. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class <code>neig</code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mafragh)
maf.coa &lt;- dudi.coa(mafragh$flo, scan = FALSE)
maf.mst &lt;- ade4::mstree(dist.dudi(maf.coa), 1)

if(adegraphicsLoaded()) {
  g0 &lt;- s.label(maf.coa$li, plab.cex = 0, ppoints.cex = 2, nb = neig2nb(maf.mst))
} else {
  s.label(maf.coa$li, clab = 0, cpoi = 2, neig = maf.mst, cnei = 1)
}

xy &lt;- data.frame(x = runif(20), y = runif(20))

if(adegraphicsLoaded()) {
  g1 &lt;- s.label(xy, xlim = c(0, 1), ylim = c(0, 1), 
    nb = neig2nb(ade4::mstree(dist.quant(xy, 1), 1)), plot = FALSE)
  g2 &lt;- s.label(xy, xlim = c(0, 1), ylim = c(0, 1), 
    nb = neig2nb(ade4::mstree(dist.quant(xy, 1), 2)), plot = FALSE)
  g3 &lt;- s.label(xy, xlim = c(0, 1), ylim = c(0, 1), 
    nb = neig2nb(ade4::mstree(dist.quant(xy, 1), 3)), plot = FALSE)
  g4 &lt;- s.label(xy, xlim = c(0, 1), ylim = c(0, 1), 
    nb = neig2nb(ade4::mstree(dist.quant(xy, 1), 4)), plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))

} else {
  par(mfrow = c(2, 2))
  for(k in 1:4) {
    neig &lt;- mstree(dist.quant(xy, 1), k)
    s.label(xy, xlim = c(0, 1), ylim = c(0, 1), addax = FALSE, neig = neig)
  }
}</code></pre>

<hr>
<h2 id='multiblock'>Display and summarize multiblock objects</h2><span id='topic+summary.multiblock'></span><span id='topic+print.multiblock'></span>

<h3>Description</h3>

<p>Generic methods print and summary for mulitblock objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiblock'
summary(object, ...)
## S3 method for class 'multiblock'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiblock_+3A_object">object</code></td>
<td>
<p>an object of class multiblock created by <code><a href="#topic+mbpls">mbpls</a></code>
or <code><a href="#topic+mbpcaiv">mbpcaiv</a></code></p>
</td></tr>
<tr><td><code id="multiblock_+3A_x">x</code></td>
<td>
<p>an object of class multiblock created by <code><a href="#topic+mbpls">mbpls</a></code>
or <code><a href="#topic+mbpcaiv">mbpcaiv</a></code></p>
</td></tr>
<tr><td><code id="multiblock_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stéphanie Bougeard (<a href="mailto:stephanie.bougeard@anses.fr">stephanie.bougeard@anses.fr</a>) and Stéphane Dray (<a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>)</p>


<h3>References</h3>

<p>Bougeard, S. and Dray S. (2018) Supervised Multiblock Analysis in R with the ade4 Package. <em>Journal of Statistical Software</em>, <b>86</b> (1), 1-17. <a href="https://doi.org/10.18637/jss.v086.i01">doi:10.18637/jss.v086.i01</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mbpls">mbpls</a></code>, <code><a href="#topic+mbpcaiv">mbpcaiv</a></code>
</p>

<hr>
<h2 id='multispati'>Multivariate spatial analysis</h2><span id='topic+multispati'></span><span id='topic+plot.multispati'></span><span id='topic+summary.multispati'></span><span id='topic+print.multispati'></span>

<h3>Description</h3>

<p>These functions are deprecated. See the function <code>multispati</code> and the methods <code>plot.multispati</code>, <code>summary.multispati</code> and <code>print.multispati</code> in the package <code>adespatial</code>.
</p>
<p>This function ensures a multivariate extension of the univariate method of spatial autocorrelation analysis.
By accounting for the spatial dependence of data observations and their multivariate covariance simultaneously, 
complex interactions among many variables are analysed. Using a methodological scheme borrowed from duality diagram 
analysis, a strategy for the exploratory analysis of spatial pattern in the multivariate is developped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multispati(dudi, listw, scannf = TRUE, nfposi = 2, nfnega = 0)
## S3 method for class 'multispati'
plot(x, xax = 1, yax = 2, ...) 
## S3 method for class 'multispati'
summary(object, ...) 
## S3 method for class 'multispati'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multispati_+3A_dudi">dudi</code></td>
<td>
<p>an object of class <code>dudi</code> for the duality diagram analysis</p>
</td></tr>
<tr><td><code id="multispati_+3A_listw">listw</code></td>
<td>
<p>an object of class <code>listw</code> for the spatial dependence of data observations</p>
</td></tr>
<tr><td><code id="multispati_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="multispati_+3A_nfposi">nfposi</code></td>
<td>
<p>an integer indicating the number of kept positive axes</p>
</td></tr>
<tr><td><code id="multispati_+3A_nfnega">nfnega</code></td>
<td>
<p>an integer indicating the number of kept negative axes</p>
</td></tr>
<tr><td><code id="multispati_+3A_x">x</code>, <code id="multispati_+3A_object">object</code></td>
<td>
<p>an object of class <code>multispati</code></p>
</td></tr>
<tr><td><code id="multispati_+3A_xax">xax</code>, <code id="multispati_+3A_yax">yax</code></td>
<td>
<p>the numbers of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="multispati_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This analysis generalizes the Wartenberg's multivariate spatial
correlation analysis to various duality diagrams created by the
functions (<code>dudi.pca</code>, <code>dudi.coa</code>, <code>dudi.acm</code>, <code>dudi.mix</code>...)
If <em>dudi</em> is a duality diagram created by the function <code>dudi.pca</code> 
and <em>listw</em> gives spatial weights created by a row normalized coding scheme,
the analysis is equivalent to Wartenberg's analysis. 
</p>
<p>We note X the data frame with the variables, Q the column weights matrix 
and D the row weights matrix associated to the duality diagram <em>dudi</em>.
We note L the neighbouring weights matrix associated to  <em>listw</em>.
Then, the <code>'multispati'</code> analysis gives principal axes v that maximize
the product of spatial autocorrelation and inertia of row scores : 
</p>
<p style="text-align: center;"><code class="reqn">I(XQv)*\|XQv\|^2 = v^{t}Q^{t}X^{t}DLXQv</code>
</p>



<h3>Value</h3>

<p>Returns an object of class <code>multispati</code>, which contains the following elements :
</p>
<table>
<tr><td><code>eig</code></td>
<td>
<p>a numeric vector containing the eigenvalues</p>
</td></tr>
<tr><td><code>nfposi</code></td>
<td>
<p>integer, number of kept axes associated to positive eigenvalues</p>
</td></tr>
<tr><td><code>nfnega</code></td>
<td>
<p>integer, number of kept axes associated to negative eigenvalues</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>principle axes (v), data frame with p rows and (nfposi + nfnega) columns</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>principal components (XQv), data frame with n rows and (nfposi + nfnega) columns</p>
</td></tr>
<tr><td><code>ls</code></td>
<td>
<p>lag vector onto the principal axes (LXQv), data frame with n rows and (nfposi + nfnega) columns</p>
</td></tr>
<tr><td><code>as</code></td>
<td>
<p>principal axes of the dudi analysis (u) onto principal axes of multispati (t(u)Qv), data frame with <code>nf</code> rows and <code>(nfposi + nfnega)</code> columns</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Sebastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a> <br />
Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Dray, S., Said, S. and Debias, F. (2008) Spatial ordination of
vegetation data using a generalization of Wartenberg's  multivariate
spatial correlation. <em>Journal of vegetation science</em>, <b>19</b>,
45&ndash;56.
</p>
<p>Grunsky, E. C. and Agterberg, F. P. (1988) Spatial and multivariate analysis of geochemical data from metavolcanic rocks in the Ben Nevis area, Ontario. <em>Mathematical Geology</em>, <b>20</b>, 825&ndash;861.
</p>
<p>Switzer, P. and Green, A.A. (1984) Min/max autocorrelation factors for multivariate spatial imagery. Tech. rep. 6, Stanford University.
</p>
<p>Thioulouse, J., Chessel, D. and Champely, S. (1995) Multivariate analysis of spatial patterns: a unified approach to local and global structures. <em>Environmental and Ecological Statistics</em>, <b>2</b>, 1&ndash;14.
</p>
<p>Wartenberg, D. E. (1985) Multivariate spatial correlation: a method for
exploratory geographical analysis. <em>Geographical Analysis</em>,
<b>17</b>, 263&ndash;283.
</p>
<p>Jombart, T., Devillard, S., Dufour, A.-B. and Pontier, D. A
spatially explicit multivariate method to disentangle global and local
patterns of genetic variability. Submitted to <em>Genetics</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dudi">dudi</a></code>,<code><a href="spdep.html#topic+mat2listw">mat2listw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (requireNamespace("spdep", quietly = TRUE)) {
    data(mafragh)
    maf.xy &lt;- mafragh$xy
    maf.flo &lt;- mafragh$flo
    maf.listw &lt;- spdep::nb2listw(neig2nb(mafragh$neig))
    if(adegraphicsLoaded()) {
      g1 &lt;- s.label(maf.xy, nb = neig2nb(mafragh$neig), plab.cex = 0.75)
    } else {
      s.label(maf.xy, neig = mafragh$neig, clab = 0.75)
    }
    maf.coa &lt;- dudi.coa(maf.flo,scannf = FALSE)
    maf.coa.ms &lt;- multispati(maf.coa, maf.listw, scannf = FALSE, nfposi = 2, nfnega = 2)
    maf.coa.ms
    
    ### detail eigenvalues components
    fgraph &lt;- function(obj){
      # use multispati summary
      sum.obj &lt;- summary(obj)
      # compute Imin and Imax
      L &lt;- spdep::listw2mat(eval(as.list(obj$call)$listw))
      Imin &lt;- min(eigen(0.5*(L+t(L)))$values)
      Imax &lt;- max(eigen(0.5*(L+t(L)))$values)
      I0 &lt;- -1/(nrow(obj$li)-1)
      # create labels
      labels &lt;- lapply(1:length(obj$eig),function(i) bquote(lambda[.(i)]))
      # draw the plot
      xmax &lt;- eval(as.list(obj$call)$dudi)$eig[1]*1.1
      par(las=1)
      var &lt;- sum.obj[,2]
      moran &lt;- sum.obj[,3]
      plot(x=var,y=moran,type='n',xlab='Inertia',ylab="Spatial autocorrelation (I)",
           xlim=c(0,xmax),ylim=c(Imin*1.1,Imax*1.1),yaxt='n')
      text(x=var,y=moran,do.call(expression,labels))
      ytick &lt;- c(I0,round(seq(Imin,Imax,le=5),1))
      ytlab &lt;- as.character(round(seq(Imin,Imax,le=5),1))
      ytlab &lt;- c(as.character(round(I0,1)),as.character(round(Imin,1)),
           ytlab[2:4],as.character(round(Imax,1)))
      axis(side=2,at=ytick,labels=ytlab)
      rect(0,Imin,xmax,Imax,lty=2)
      segments(0,I0,xmax,I0,lty=2)
      abline(v=0)
      title("Spatial and inertia components of the eigenvalues")
    }
    fgraph(maf.coa.ms)
    ## end eigenvalues details


    if(adegraphicsLoaded()) {
      g2 &lt;- s1d.barchart(maf.coa$eig, p1d.hori = FALSE, plot = FALSE)
      g3 &lt;- s1d.barchart(maf.coa.ms$eig, p1d.hori = FALSE, plot = FALSE) 
      g4 &lt;- s.corcircle(maf.coa.ms$as, plot = FALSE)
      G1 &lt;- ADEgS(list(g2, g3, g4), layout = c(1, 3))
    } else {
      par(mfrow = c(1, 3))
      barplot(maf.coa$eig)
      barplot(maf.coa.ms$eig) 
      s.corcircle(maf.coa.ms$as)
      par(mfrow = c(1, 1))
    }
 
 
    if(adegraphicsLoaded()) {
      g5 &lt;- s.value(maf.xy, -maf.coa$li[, 1], plot = FALSE)
      g6 &lt;- s.value(maf.xy, -maf.coa$li[, 2], plot = FALSE)
      g7 &lt;- s.value(maf.xy, maf.coa.ms$li[, 1], plot = FALSE)
      g8 &lt;- s.value(maf.xy, maf.coa.ms$li[, 2], plot = FALSE)
      G2 &lt;- ADEgS(list(g5, g6, g7, g8), layout = c(2, 2))
    } else {
      par(mfrow = c(2, 2))
      s.value(maf.xy, -maf.coa$li[, 1])
      s.value(maf.xy, -maf.coa$li[, 2])
      s.value(maf.xy, maf.coa.ms$li[, 1])
      s.value(maf.xy, maf.coa.ms$li[, 2])
      par(mfrow = c(1, 1))
    }


    w1 &lt;- -maf.coa$li[, 1:2]
    w1m &lt;- apply(w1, 2, spdep::lag.listw, x = maf.listw)
    w1.ms &lt;- maf.coa.ms$li[, 1:2]
    w1.msm &lt;- apply(w1.ms, 2, spdep::lag.listw, x = maf.listw)
    if(adegraphicsLoaded()) {
      g9 &lt;- s.match(w1, w1m, plab.cex = 0.75, plot = FALSE)
      g10 &lt;- s.match(w1.ms, w1.msm, plab.cex = 0.75, plot = FALSE)
      G3 &lt;- cbindADEg(g9, g10, plot = TRUE)
    } else {
      par(mfrow = c(1,2))
      s.match(w1, w1m, clab = 0.75)
      s.match(w1.ms, w1.msm, clab = 0.75)
      par(mfrow = c(1, 1))
    }

    maf.pca &lt;- dudi.pca(mafragh$env, scannf = FALSE)
    multispati.randtest(maf.pca, maf.listw)
    maf.pca.ms &lt;- multispati(maf.pca, maf.listw, scannf=FALSE)
    plot(maf.pca.ms)
}

## End(Not run)</code></pre>

<hr>
<h2 id='multispati.randtest'>Multivariate spatial autocorrelation test (in C)</h2><span id='topic+multispati.randtest'></span>

<h3>Description</h3>

<p>This function performs a multivariate autocorrelation test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multispati.randtest(dudi, listw, nrepet = 999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multispati.randtest_+3A_dudi">dudi</code></td>
<td>
<p>an object of class <code>dudi</code> for the duality diagram analysis</p>
</td></tr>
<tr><td><code id="multispati.randtest_+3A_listw">listw</code></td>
<td>
<p>an object of class <code>listw</code> for the spatial dependence of data observations</p>
</td></tr>
<tr><td><code id="multispati.randtest_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="multispati.randtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We note X the data frame with the variables, Q the column weights matrix 
and D the row weights matrix associated to the duality diagram <em>dudi</em>.
We note L the neighbouring weights matrix associated to  <em>listw</em>.
This function performs a Monte-Carlo Test on the multivariate spatial 
autocorrelation index : </p>
<p style="text-align: center;"><code class="reqn">r = \frac{trace(X^{t}DLXQ)}{trace(X^{t}DXQ)}</code>
</p>



<h3>Value</h3>

<p>Returns an object of class <code>randtest</code> (randomization tests).
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a>
</p>


<h3>References</h3>

<p>Smouse, P. E. and Peakall, R. (1999) Spatial autocorrelation analysis of individual multiallele and multilocus genetic structure. 
<em>Heredity</em>, <b>82</b>, 561&ndash;573.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dudi">dudi</a></code>,<code><a href="spdep.html#topic+mat2listw">mat2listw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("spdep", quietly = TRUE)) {
    data(mafragh)
    maf.listw &lt;- spdep::nb2listw(neig2nb(mafragh$neig))
    maf.pca &lt;- dudi.pca(mafragh$env, scannf = FALSE)
    multispati.randtest(maf.pca, maf.listw)
    maf.pca.ms &lt;- multispati(maf.pca, maf.listw, scannf = FALSE)
    plot(maf.pca.ms)
}
</code></pre>

<hr>
<h2 id='multispati.rtest'>Multivariate spatial autocorrelation test</h2><span id='topic+multispati.rtest'></span>

<h3>Description</h3>

<p>This function performs a multivariate autocorrelation test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multispati.rtest(dudi, listw, nrepet = 99, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multispati.rtest_+3A_dudi">dudi</code></td>
<td>
<p>an object of class <code>dudi</code> for the duality diagram analysis</p>
</td></tr>
<tr><td><code id="multispati.rtest_+3A_listw">listw</code></td>
<td>
<p>an object of class <code>listw</code> for the spatial dependence of data observations</p>
</td></tr>
<tr><td><code id="multispati.rtest_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="multispati.rtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We note X the data frame with the variables, Q the column weight matrix 
and D the row weight matrix associated to the duality diagram <em>dudi</em>.
We note L the neighbouring weights matrix associated to  <em>listw</em>.
This function performs a Monte-Carlo Test on the multivariate spatial 
autocorrelation index : </p>
<p style="text-align: center;"><code class="reqn">r = \frac{X^{t}DLXQ}{X^{t}DXQ}</code>
</p>



<h3>Value</h3>

<p>Returns an object of class <code>randtest</code> (randomization tests).
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a>
</p>


<h3>References</h3>

<p>Smouse, P. E. and Peakall, R. (1999) Spatial autocorrelation analysis of individual multiallele and multilocus genetic structure. 
<em>Heredity</em>, <b>82</b>, 561&ndash;573.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dudi">dudi</a></code>,<code><a href="spdep.html#topic+mat2listw">mat2listw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("spdep", quietly = TRUE)) {
    data(mafragh)
    maf.listw &lt;- spdep::nb2listw(neig2nb(mafragh$neig))
    maf.pca &lt;- dudi.pca(mafragh$env, scannf = FALSE)
    multispati.rtest(maf.pca, maf.listw)
    maf.pca.ms &lt;- multispati(maf.pca, maf.listw, scannf = FALSE)
    plot(maf.pca.ms)
}
</code></pre>

<hr>
<h2 id='neig'>Neighbourhood Graphs</h2><span id='topic+neig'></span><span id='topic+neig.util.GtoL'></span><span id='topic+neig.util.LtoG'></span><span id='topic+print.neig'></span><span id='topic+summary.neig'></span><span id='topic+scores.neig'></span><span id='topic+nb2neig'></span><span id='topic+neig2nb'></span><span id='topic+neig2mat'></span>

<h3>Description</h3>

<p><code>neig</code> creates objects of class <code>neig</code> with : <br />
a list of edges<br />
a binary square matrix<br />
a list of vectors of neighbours<br />
an integer (linear and circular graphs)<br />
a data frame of polygons (area)<br />
</p>
<p>scores.neig returns the eigenvectors of neighbouring,<br />
orthonormalized scores (null average, unit variance 1/n and null covariances) of maximal autocorrelation.<br />
</p>
<p>nb2neig returns an object of class <code>neig</code> using an object of class <code>nb</code> in the library 'spdep'
</p>
<p>neig2nb returns an object of class <code>nb</code> using an object of class <code>neig</code>
</p>
<p>neig2mat returns the incidence matrix between edges (1 = neighbour ; 0 = no neighbour)
</p>
<p>neig.util.GtoL and neig.util.LtoG are utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neig(list = NULL, mat01 = NULL, edges = NULL,
    n.line = NULL, n.circle = NULL, area = NULL)

scores.neig  (obj) 
## S3 method for class 'neig'
print(x, ...) 
## S3 method for class 'neig'
summary(object, ...)
nb2neig (nb)
neig2nb (neig)
neig2mat (neig)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neig_+3A_list">list</code></td>
<td>
<p>a list which each component gives the number of neighbours</p>
</td></tr>
<tr><td><code id="neig_+3A_mat01">mat01</code></td>
<td>
<p>a symmetric square matrix of 0-1 values</p>
</td></tr>
<tr><td><code id="neig_+3A_edges">edges</code></td>
<td>
<p>a matrix of 2 columns with integer values giving a list of edges</p>
</td></tr>
<tr><td><code id="neig_+3A_n.line">n.line</code></td>
<td>
<p>the number of points for a linear plot</p>
</td></tr>
<tr><td><code id="neig_+3A_n.circle">n.circle</code></td>
<td>
<p>the number of points for a circular plot</p>
</td></tr>
<tr><td><code id="neig_+3A_area">area</code></td>
<td>
<p>a data frame containing a polygon set (see <a href="#topic+area.plot">area.plot</a>)</p>
</td></tr>
<tr><td><code id="neig_+3A_nb">nb</code></td>
<td>
<p>an object of class 'nb'</p>
</td></tr>
<tr><td><code id="neig_+3A_neig">neig</code>, <code id="neig_+3A_x">x</code>, <code id="neig_+3A_obj">obj</code>, <code id="neig_+3A_object">object</code></td>
<td>
<p>an object of class 'neig'</p>
</td></tr>
<tr><td><code id="neig_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>References</h3>

<p>Thioulouse, J., D. Chessel, and S. Champely. 1995. 
Multivariate analysis of spatial patterns: a unified approach to local and global structures.
<em>Environmental and Ecological Statistics</em>, <b>2</b>, 1&ndash;14.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!adegraphicsLoaded()) {
  
  if(requireNamespace("deldir", quietly = TRUE)) {
  
    data(mafragh)
    par(mfrow = c(2, 1))
    provi &lt;- deldir::deldir(mafragh$xy)
    provi.neig &lt;- neig(edges = as.matrix(provi$delsgs[, 5:6]))
    
    s.label(mafragh$xy, neig = provi.neig, inc = FALSE, 
      addax = FALSE, clab = 0, cnei = 2)
    dist &lt;- apply(provi.neig, 1, function(x) 
      sqrt(sum((mafragh$xy[x[1], ] - mafragh$xy[x[2], ]) ^ 2)))
    #hist(dist, nclass = 50)
    mafragh.neig &lt;- neig(edges = provi.neig[dist &lt; 50, ])
    s.label(mafragh$xy, neig = mafragh.neig, inc = FALSE, 
      addax = FALSE, clab = 0, cnei = 2)
    par(mfrow = c(1, 1))
    
    data(irishdata)
    irish.neig &lt;- neig(area = irishdata$area)
    summary(irish.neig)
    print(irish.neig)
    s.label(irishdata$xy, neig = irish.neig, cneig = 3,
      area = irishdata$area, clab = 0.8, inc = FALSE)
    
    irish.scores &lt;- scores.neig(irish.neig)
    par(mfrow = c(2, 3))
    for(i in 1:6)
      s.value(irishdata$xy, irish.scores[, i], inc = FALSE, grid = FALSE, addax = FALSE,
        neig = irish.neig, csi = 2, cleg = 0, sub = paste("Eigenvector ",i), csub = 2)
    par(mfrow = c(1, 1))
    
    a.neig &lt;- neig(n.circle = 16)
    a.scores &lt;- scores.neig(a.neig)
    xy &lt;- cbind.data.frame(cos((1:16) * pi / 8), sin((1:16) * pi / 8))
    par(mfrow = c(4, 4))
    for(i in 1:15)
      s.value(xy, a.scores[, i], neig = a.neig, csi = 3, cleg = 0)
    par(mfrow = c(1, 1))
    
    a.neig &lt;- neig(n.line = 28)
    a.scores &lt;- scores.neig(a.neig)
    par(mfrow = c(7, 4))
    par(mar = c(1.1, 2.1, 0.1, 0.1))
    for(i in 1:27)
      barplot(a.scores[, i], col = grey(0.8))
    par(mfrow = c(1, 1))
  }

  if(requireNamespace("spdep", quietly = TRUE)) {
    
    data(mafragh)
    maf.rel &lt;- spdep::relativeneigh(as.matrix(mafragh$xy))
    maf.rel &lt;- spdep::graph2nb(maf.rel)
    s.label(mafragh$xy, neig = neig(list = maf.rel), inc = FALSE,
      clab = 0, addax = FALSE, cne = 1, cpo = 2)
    
    par(mfrow = c(2, 2))
    w &lt;- matrix(runif(100), 50, 2)
    x.gab &lt;- spdep::gabrielneigh(w)
    x.gab &lt;- spdep::graph2nb(x.gab)
    s.label(data.frame(w), neig = neig(list = x.gab), inc = FALSE,
      clab = 0, addax = FALSE, cne = 1, cpo = 2, sub = "relative")
    x.rel &lt;- spdep::relativeneigh(w)
    x.rel &lt;- spdep::graph2nb(x.rel)
    s.label(data.frame(w), neig = neig(list = x.rel), inc = FALSE,
      clab = 0, addax = FALSE, cne = 1, cpo = 2, sub = "Gabriel")
    k1 &lt;- spdep::knn2nb(spdep::knearneigh(w))
    s.label(data.frame(w), neig = neig(list = k1), inc = FALSE,
      clab = 0, addax = FALSE, cne = 1, cpo = 2, sub = "k nearest neighbours")
    
    all.linked &lt;- max(unlist(spdep::nbdists(k1, w)))
    z &lt;- spdep::dnearneigh(w, 0, all.linked)
    s.label(data.frame(w), neig = neig(list = z), inc = FALSE, clab = 0, 
      addax = FALSE, cne = 1, cpo = 2, sub = "Neighbourhood contiguity by distance")
    par(mfrow = c(1, 1))
  }
  
}</code></pre>

<hr>
<h2 id='newick.eg'>Phylogenetic trees in Newick format</h2><span id='topic+newick.eg'></span>

<h3>Description</h3>

<p>This data set contains various exemples of phylogenetic trees in Newick format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(newick.eg)</code></pre>


<h3>Format</h3>

<p><code>newick.eg</code> is a list containing 14 character strings in Newick format. 
</p>


<h3>Source</h3>

<p>Trees 1 to 7 were obtained from the URL <br /> 
<a href="http://evolution.genetics.washington.edu/phylip/newicktree.html">http://evolution.genetics.washington.edu/phylip/newicktree.html</a>. 
</p>
<p>Trees 8 and 9 were obtained by Clémentine Carpentier-Gimaret. 
</p>
<p>Tree 10 was obtained from Treezilla Data Sets . 
</p>
<p>Trees 11 and 12 are taken from Bauwens and Díaz-Uriarte (1997).
</p>
<p>Tree 13 is taken from Cheverud and Dow (1985). 
</p>
<p>Tree 13 is taken from Martins and Hansen (1997).
</p>


<h3>References</h3>

<p>Bauwens, D. and Díaz-Uriarte, R. (1997) Covariation of life-history traits in lacertid lizards: a comparative study. 
<em>American Naturalist</em>, <b>149</b>, 91&ndash;111. 
</p>
<p>Cheverud, J. and Dow, M.M. (1985) An autocorrelation analysis of genetic variation due to lineal fission in social groups of rhesus macaques. 
<em>American Journal of Physical Anthropology</em>, <b>67</b>, 113&ndash;122. 
</p>
<p>Martins, E. P. and Hansen, T.F. (1997) Phylogenies and the comparative method: a general approach to incorporating phylogenetic information 
into the analysis of interspecific data. <em>American Naturalist</em>, <b>149</b>, 646&ndash;667.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(newick.eg)
newick2phylog(newick.eg[[11]])
radial.phylog(newick2phylog(newick.eg[[7]]), circ = 1,
 clabel.l = 0.75)
</code></pre>

<hr>
<h2 id='newick2phylog'>Create phylogeny</h2><span id='topic+newick2phylog'></span><span id='topic+hclust2phylog'></span><span id='topic+taxo2phylog'></span><span id='topic+newick2phylog.addtools'></span>

<h3>Description</h3>

<p>The first three functions ensure to create object of class <code>phylog</code> from either a character string in Newick format (<code>newick2phylog</code>) or an object of class <code>'hclust'</code> (<code>hclust2phylog</code>) or a taxonomy (<code>taxo2phylog</code>).
The function <code>newick2phylog.addtools</code> is an internal function called by <code>newick2phylog</code>, <code>hclust2phylog</code> and <code>taxo2phylog</code> when <code>newick2phylog.addtools</code> = TRUE. It adds some items in <code>'phylog'</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newick2phylog(x.tre, add.tools = TRUE, call = match.call())
hclust2phylog(hc, add.tools = TRUE)
taxo2phylog(taxo, add.tools = FALSE, root="Root", abbrev=TRUE)
newick2phylog.addtools(res, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newick2phylog_+3A_x.tre">x.tre</code></td>
<td>
<p>a character string corresponding to a phylogenetic tree in Newick format<br />
(<a href="http://evolution.genetics.washington.edu/phylip/newicktree.html">http://evolution.genetics.washington.edu/phylip/newicktree.html</a>)</p>
</td></tr>
<tr><td><code id="newick2phylog_+3A_add.tools">add.tools</code></td>
<td>
<p>if TRUE, executes the function <code>newick2phylog.addtools</code></p>
</td></tr>
<tr><td><code id="newick2phylog_+3A_call">call</code></td>
<td>
<p>call</p>
</td></tr>
<tr><td><code id="newick2phylog_+3A_hc">hc</code></td>
<td>
<p>an object of class <code>hclust</code></p>
</td></tr>
<tr><td><code id="newick2phylog_+3A_taxo">taxo</code></td>
<td>
<p>an object of class <code>taxo</code></p>
</td></tr>
<tr><td><code id="newick2phylog_+3A_res">res</code></td>
<td>
<p>an object of class <code>phylog</code> (an internal argument of the function <code>newick2phylog</code>)</p>
</td></tr>
<tr><td><code id="newick2phylog_+3A_tol">tol</code></td>
<td>
<p>used in case 3 of <code>method</code> as a tolerance threshold for null eigenvalues</p>
</td></tr>
<tr><td><code id="newick2phylog_+3A_root">root</code></td>
<td>
<p>a character string for the root of the tree</p>
</td></tr>
<tr><td><code id="newick2phylog_+3A_abbrev">abbrev</code></td>
<td>
<p>logical : if TRUE levels are abbreviated by column and two characters are added before</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return object of class <code>phylog</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phylog">phylog</a></code>, <code><a href="#topic+plot.phylog">plot.phylog</a></code>, <code><a href="#topic+as.taxo">as.taxo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
 w &lt;- "((((,,),,(,)),),(,));"
 w.phy &lt;- newick2phylog(w)
 print(w.phy)
 plot(w.phy)

## Not run: 
# newick2phylog
data(newick.eg)
radial.phylog(newick2phylog(newick.eg[[8]], FALSE), cnode = 1,
 clabel.l = 0.8)

w &lt;- NULL
w[1] &lt;- "(,((((((((((((((((,,(,(,))),),(((,(,)),(,)),),(,(,)),(,)),((((("
w[2] &lt;- ",(,)),),),(,)),((((,((,),((,(,)),))),(,)),(,(,),,((,),(,)),)),("
w[3] &lt;- "(((((,),),(,(,))),),(,)),(((,),),)))),((,,((,),)),(,)),((,),(,)"
w[4] &lt;- ")),(((((((((,,),),,),),((,),)),(,),((,),)),),(((((,),),),((,),)"
w[5] &lt;- "),(((,(,(,(,)))),(,)),(((,),(((((((,),),),,),(,)),(,)),)),((,)"
w[6] &lt;- ",))))),(,((,),(,)),((,(,)),)))),((((,(,(,))),((,(,)),,((,(,)),)"
w[7] &lt;- ",)),(((,),),(((,),),))),((,),))),((((((((((,,,,(,)),),((,),)),("
w[8] &lt;- ",(,))),(((((((((,(,)),(,)),((((,((,),(,(,(,))))),((,),(,(,)))),"
w[9] &lt;- "),((,),))),(((((((((,(,)),((,),(,))),),),),(((,((,),)),),((,((,"
w[10] &lt;- "),)),)),(,)),(,(,(,)))),((((,(,)),(,)),(((,),(,)),(,),,(,))),(,"
w[11] &lt;- "))),(,,,))),((((,),),),(((,(,(,))),((,),)),(,)))),(,)),),(,((,("
w[12] &lt;- ",)),),(((,),),))),),(((,),),(,),(,(,))),(((,),(,)),((,),(,)))),"
w[13] &lt;- "(((,),((,),)),(((((,,,,,),(,)),(,)),(,((,),))),))),(,(((((,(((("
w[14] &lt;- ",(,)),),),)),),((,((,),((,((,),(,))),))),)),((((,),(((,),(,(,))"
w[15] &lt;- "),)),),)),((,),)))),(((,((,,((,),)),)),),((,),))),((,),(,))),(("
w[16] &lt;- ",),)),(((((,),((,(,)),(((,(,)),(,(((,),),))),))),(,),,),),),,(,"
w[17] &lt;- ")),((((,),,),),((,,,),((,),((,),))))),((((((,(,)),,(,)),,(,),(,"
w[18] &lt;- "),),(((((,(,(,),)),(((,),,),(,))),),),),,,((,),)),),)),(((((,),"
w[19] &lt;- "(,(,)),),((,((,),),,),)),(((((((,),((((,,,),(,(,))),(((,(,)),),"
w[20] &lt;- "(,))),)),),),),(,)),),),((,),))),((,),)),(((((((((((,),),(((((("
w[21] &lt;- ",),),((,),)),(,)),),)),(,)),),((((((,),),(((,),),)),(,)),),(,))"
w[22] &lt;- ",),),),),(,)),),((,),(,),,,)),(,(,(,)))),),(,)),),);"
phy1 &lt;- newick2phylog(w,FALSE)
phy1
radial.phylog(phy1, clabel.l = 0, circle = 2.2, clea = 0.5,
 cnod = 0.5)
data(newick.eg)
radial.phylog(newick2phylog(newick.eg[[8]], FALSE), cnode = 1,
 clabel.l = 0.8)

# hclust2phylog
data(USArrests)
hc &lt;- hclust(dist(USArrests), "ave")
par(mfrow = c(1,2))
plot(hc, hang = -1)
phy &lt;- hclust2phylog(hc)
plot(phy, clabel.l = 0.75, clabel.n = 0.6, f = 0.75)

par(mfrow = c(1,1))
row.names(USArrests) 
names(phy$leaves) #WARNING not the same for two reasons
row.names(USArrests) &lt;- gsub(" ","_",row.names(USArrests))
row.names(USArrests) 
names(phy$leaves) #WARNING not the same for one reason
USArrests &lt;- USArrests[names(phy$leaves),]
row.names(USArrests) 
names(phy$leaves) #the same
table.phylog(data.frame(scalewt(USArrests)), phy, csi = 2.5,
 clabel.r = 0.75, f = 0.7)

#taxo2phylog
data(taxo.eg)
tax &lt;- as.taxo(taxo.eg[[1]])
tax.phy &lt;- taxo2phylog(as.taxo(taxo.eg[[1]]))
par(mfrow = c(1,2))
plot(tax.phy, clabel.l = 1.25, clabel.n = 1.25, f = 0.75)
plot(taxo2phylog(as.taxo(taxo.eg[[1]][sample(15),])),
 clabel.l = 1.25, clabel.n = 1.25, f = 0.75)

par(mfrow=c(1,1))
plot(taxo2phylog(as.taxo(taxo.eg[[2]])), clabel.l = 1,
 clabel.n = 0.75, f = 0.65)

## End(Not run)</code></pre>

<hr>
<h2 id='niche'>Method to Analyse a pair of tables : Environmental and Faunistic Data</h2><span id='topic+niche'></span><span id='topic+plot.niche'></span><span id='topic+print.niche'></span><span id='topic+niche.param'></span><span id='topic+rtest.niche'></span>

<h3>Description</h3>

<p>performs a special multivariate analysis for ecological data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niche(dudiX, Y, scannf = TRUE, nf = 2)
## S3 method for class 'niche'
print(x, ...) 
## S3 method for class 'niche'
plot(x, xax = 1, yax = 2, ...)
niche.param(x)
## S3 method for class 'niche'
rtest(xtest,nrepet=99, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niche_+3A_dudix">dudiX</code></td>
<td>
<p>a duality diagram providing from a function <code>dudi.coa</code>, <code>dudi.pca</code>, ... using an array sites-variables</p>
</td></tr>
<tr><td><code id="niche_+3A_y">Y</code></td>
<td>
<p>a data frame sites-species according to <code>dudiX$tab</code> with no columns of zero</p>
</td></tr>
<tr><td><code id="niche_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="niche_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="niche_+3A_x">x</code></td>
<td>
<p>an object of class <code>niche</code></p>
</td></tr>
<tr><td><code id="niche_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="niche_+3A_xax">xax</code>, <code id="niche_+3A_yax">yax</code></td>
<td>
<p>the numbers of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="niche_+3A_xtest">xtest</code></td>
<td>
<p>an object of class <code>niche</code></p>
</td></tr>
<tr><td><code id="niche_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations for the testing procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of the class <code>niche</code> (sub-class of <code>dudi</code>) containing :
</p>
<table>
<tr><td><code>rank</code></td>
<td>
<p>an integer indicating the rank of the studied matrix</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code>RV</code></td>
<td>
<p>a numeric value indicating the RV coefficient</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a numeric vector with the all eigenvalues</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>a data frame with the row weigths (crossed array)</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p>a data frame with the crossed array (averaging species/sites)</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>a data frame with the species coordinates</p>
</td></tr>
<tr><td><code>l1</code></td>
<td>
<p>a data frame with the species normed scores</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>a data frame with the variable coordinates</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>a data frame with the variable normed scores</p>
</td></tr>
<tr><td><code>ls</code></td>
<td>
<p>a data frame with the site coordinates</p>
</td></tr>
<tr><td><code>as</code></td>
<td>
<p>a data frame with the axis upon niche axis</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel<br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a><br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Dolédec, S., Chessel, D. and Gimaret, C. (2000) Niche separation in community analysis: a new method. <em>Ecology</em>, <b>81</b>, 2914&ndash;1927.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(doubs)
dudi1 &lt;- dudi.pca(doubs$env, scale = TRUE, scan = FALSE, nf = 3)
nic1 &lt;- niche(dudi1, doubs$fish, scann = FALSE)

if(adegraphicsLoaded()) {
  g1 &lt;- s.traject(dudi1$li, plab.cex = 0, plot = FALSE)
  g2 &lt;- s.traject(nic1$ls, plab.cex = 0, plot = FALSE)
  g3 &lt;- s.corcircle(nic1$as, plot = FALSE)
  g4 &lt;- s.arrow(nic1$c1, plot = FALSE)
  G1 &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  
  glist &lt;- list()
  for(i in 1:ncol(doubs$fish))
    glist[[i]] &lt;- s.distri(nic1$ls, dfdistri = doubs$fish[, i], psub.text = names(doubs$fish)[i], 
      plot = FALSE, storeData = TRUE)
  G2 &lt;- ADEgS(glist, layout = c(5, 6))
  
  G3 &lt;- s.arrow(nic1$li, plab.cex = 0.7)  
    
} else {
  par(mfrow = c(2, 2))
  s.traject(dudi1$li, clab = 0)
  s.traject(nic1$ls, clab = 0)
  s.corcircle(nic1$as)
  s.arrow(nic1$c1)

  par(mfrow = c(5, 6))
  for (i in 1:27) s.distri(nic1$ls, as.data.frame(doubs$fish[,i]),
    csub = 2, sub = names(doubs$fish)[i])
    
  par(mfrow = c(1, 1))
  s.arrow(nic1$li, clab = 0.7)

}

data(trichometeo)
pca1 &lt;- dudi.pca(trichometeo$meteo, scan = FALSE)
nic1 &lt;- niche(pca1, log(trichometeo$fau + 1), scan = FALSE)
plot(nic1)
niche.param(nic1)
rtest(nic1,19)

data(rpjdl)
plot(niche(dudi.pca(rpjdl$mil, scan = FALSE), rpjdl$fau, scan = FALSE))
</code></pre>

<hr>
<h2 id='nipals'>Non-linear Iterative Partial Least Squares (NIPALS) algorithm</h2><span id='topic+nipals'></span><span id='topic+print.nipals'></span><span id='topic+scatter.nipals'></span>

<h3>Description</h3>

<p>This function performs NIPALS algorithm, i.e. a principal component
analysis of a data table that can contain missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nipals(df, nf = 2, rec = FALSE, niter = 100, tol = 1e-09)
## S3 method for class 'nipals'
scatter(x, xax = 1, yax = 2, clab.row = 0.75, clab.col
= 1, posieig = "top", sub = NULL, ...)
## S3 method for class 'nipals'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nipals_+3A_df">df</code></td>
<td>
<p>a data frame that can contain missing values</p>
</td></tr>
<tr><td><code id="nipals_+3A_nf">nf</code></td>
<td>
<p>an integer, the number of axes to keep</p>
</td></tr>
<tr><td><code id="nipals_+3A_rec">rec</code></td>
<td>
<p>a logical that specify if the functions must perform the
reconstitution of the data using the <code>nf</code> axes</p>
</td></tr>
<tr><td><code id="nipals_+3A_niter">niter</code></td>
<td>
<p>an integer, the maximum number of iterations</p>
</td></tr>
<tr><td><code id="nipals_+3A_tol">tol</code></td>
<td>
<p>a real, the tolerance used in the iterative algorithm</p>
</td></tr>
<tr><td><code id="nipals_+3A_x">x</code></td>
<td>
<p>an object of class <code>nipals</code></p>
</td></tr>
<tr><td><code id="nipals_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="nipals_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="nipals_+3A_clab.row">clab.row</code></td>
<td>
<p>a character size for the rows</p>
</td></tr>
<tr><td><code id="nipals_+3A_clab.col">clab.col</code></td>
<td>
<p>a character size for the columns</p>
</td></tr>
<tr><td><code id="nipals_+3A_posieig">posieig</code></td>
<td>
<p>if &quot;top&quot; the eigenvalues bar plot is upside, if &quot;bottom&quot; it is downside, if &quot;none&quot; no plot</p>
</td></tr>
<tr><td><code id="nipals_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="nipals_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data are scaled (mean 0 and variance 1) prior to the analysis.
</p>


<h3>Value</h3>

<p>Returns a list of classes <code>nipals</code>:
</p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>the scaled data frame</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>the pseudoeigenvalues</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the rank of the analyzed matrice</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>the number of factors</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>the column normed scores</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>the column coordinates</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>the row coordinates</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call function</p>
</td></tr>
<tr><td><code>nb</code></td>
<td>
<p>the number of iterations for each axis</p>
</td></tr>
<tr><td><code>rec</code></td>
<td>
<p>a data frame obtained by the reconstitution of the scaled
data using the <code>nf</code> axes</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a></p>


<h3>References</h3>

<p>Wold, H. (1966)  Estimation of principal
components and related models by iterative least squares. In
P. Krishnaiah, editors.<em>Multivariate
Analysis</em>, Academic Press, 391&ndash;420.<br /><br />
</p>
<p>Wold, S., Esbensen, K. and Geladi, P. (1987) Principal component
analysis <em>Chemometrics and Intelligent Laboratory Systems</em>,
<b>2</b>, 37&ndash;52.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dudi.pca">dudi.pca</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(doubs)
## nipals is equivalent to dudi.pca when there are no NA
acp1 &lt;- dudi.pca(doubs$env, scannf = FALSE, nf = 2)
nip1 &lt;- nipals(doubs$env)


if(adegraphicsLoaded()) {
  if(requireNamespace("lattice", quietly = TRUE)) {
    g1 &lt;- s1d.barchart(acp1$eig, psub.text = "dudi.pca", p1d.horizontal = FALSE, plot = FALSE)
    g2 &lt;- s1d.barchart(nip1$eig, psub.text = "nipals", p1d.horizontal = FALSE, plot = FALSE)
    g3 &lt;- lattice::xyplot(nip1$c1[, 1] ~ acp1$c1[, 1], main = "col scores", xlab = "dudi.pca", 
      ylab = "nipals")
    g4 &lt;- lattice::xyplot(nip1$li[, 1] ~ acp1$li[, 1], main = "row scores", xlab = "dudi.pca", 
      ylab = "nipals")
    G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  }
  
} else {
  par(mfrow = c(2, 2))
  barplot(acp1$eig, main = "dudi.pca")
  barplot(nip1$eig, main = "nipals")
  plot(acp1$c1[, 1], nip1$c1[, 1], main = "col scores", xlab = "dudi.pca", ylab = "nipals")
  plot(acp1$li[, 1], nip1$li[, 1], main = "row scores", xlab = "dudi.pca", ylab = "nipals")
}

## Not run: 
## with NAs:
doubs$env[1, 1] &lt;- NA
nip2 &lt;- nipals(doubs$env)
cor(nip1$li, nip2$li)
nip1$eig
nip2$eig

## End(Not run)</code></pre>

<hr>
<h2 id='njplot'>Phylogeny and trait of bacteria</h2><span id='topic+njplot'></span>

<h3>Description</h3>

<p>This data set describes the phylogeny of 36 bacteria as reported by Perrière and Gouy (1996). It also gives the GC rate corresponding to these 36 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(njplot)</code></pre>


<h3>Format</h3>

<p><code>njplot</code> is a list containing the 2 following objects:
</p>

<dl>
<dt>tre</dt><dd><p>is a character string giving the fission tree in Newick format.</p>
</dd> 
<dt>tauxcg</dt><dd><p>is a numeric vector that gives the CG rate of the 36
species.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data were obtained by Manolo Gouy <a href="mailto:manolo.gouy@univ-lyon1.fr">manolo.gouy@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Perrière, G. and Gouy, M. (1996) WWW-Query : an on-line retrieval system for biological sequence banks. <em>Biochimie</em>, <b>78</b>, 364&ndash;369.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(njplot)
njplot.phy &lt;- newick2phylog(njplot$tre)
par(mfrow = c(2,1))
tauxcg0 &lt;- njplot$tauxcg - mean(njplot$tauxcg)
symbols.phylog(njplot.phy, squares = tauxcg0)
symbols.phylog(njplot.phy, circles = tauxcg0)
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='olympic'>Olympic Decathlon</h2><span id='topic+olympic'></span>

<h3>Description</h3>

<p>This data set gives the performances of 33 men's decathlon at the Olympic Games (1988).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(olympic)</code></pre>


<h3>Format</h3>

<p><code>olympic</code> is a list of 2 components.
</p>

<dl>
<dt>tab</dt><dd><p>is a data frame with 33 rows and 10 columns events of the decathlon: 100 meters (100), 
long jump (long), shotput (poid), high jump (haut), 400 meters (400), 110-meter hurdles (110),
discus throw (disq), pole vault (perc), javelin (jave) and 1500 meters (1500).</p>
</dd>
<dt>score</dt><dd><p>is a vector of the final points scores of the competition.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Example 357 in: <br />
Hand, D.J., Daly, F., Lunn, A.D., McConway, K.J. and Ostrowski, E. (1994) 
<em>A handbook of small data sets</em>, Chapman &amp; Hall, London. 458 p.
</p>
<p>Lunn, A. D. and McNeil, D.R. (1991) <em>Computer-Interactive Data Analysis</em>, Wiley, New York
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(olympic)
pca1 &lt;- dudi.pca(olympic$tab, scan = FALSE)

if(adegraphicsLoaded()) {
  if(requireNamespace("lattice", quietly = TRUE)) {
    g1 &lt;- s1d.barchart(pca1$eig, p1d.hori = FALSE, plot = FALSE)
    g2 &lt;- s.corcircle(pca1$co, plot = FALSE)
    g3 &lt;- lattice::xyplot(pca1$l1[, 1] ~ olympic$score, type = c("p", "r"))
    g41 &lt;- s.label(pca1$l1, plab.cex = 0.5, plot = FALSE)
    g42 &lt;- s.arrow(2 * pca1$co, plot = FALSE)
    g4 &lt;- superpose(g41, g42)
    G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  }
  
} else {
  par(mfrow = c(2, 2))
  barplot(pca1$eig)
  s.corcircle(pca1$co)
  plot(olympic$score, pca1$l1[, 1])
  abline(lm(pca1$l1[, 1] ~ olympic$score))
  s.label(pca1$l1, clab = 0.5)
  s.arrow(2 * pca1$co, add.p = TRUE)
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='oribatid'>Oribatid mite</h2><span id='topic+oribatid'></span>

<h3>Description</h3>

<p>This data set contains informations about environmental control and spatial structure in ecological communities of Oribatid mites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oribatid)</code></pre>


<h3>Format</h3>

<p><code>oribatid</code> is a list containing the following objects : 
</p>

<dl>
<dt>fau</dt><dd><p>: a data frame with 70 rows (sites) and 35 columns (Oribatid species)</p>
</dd>   
<dt>envir</dt><dd><p>: a data frame with 70 rows (sites) and 5 columns (environmental variables)</p>
</dd>
<dt>xy</dt><dd><p>: a data frame that contains spatial coordinates of the 70 sites</p>
</dd>
</dl>


<h3>Details</h3>

<p>Variables of <code>oribatid$envir</code> are the following ones : <br />
substrate: a factor with seven levels that describes the nature of the substratum<br />
shrubs: a factor with three levels that describes the absence/presence of shrubs<br />
topo: a factor with two levels that describes the microtopography<br />
density: substratum density (<code class="reqn">g.L^{-1}</code>)<br />
water: water content of the substratum (<code class="reqn">g.L^{-1}</code>)
</p>


<h3>Source</h3>

<p>Data prepared by P. Legendre <a href="mailto:Pierre.Legendre@umontreal.ca">Pierre.Legendre@umontreal.ca</a> and D. Borcard <a href="mailto:borcardd@magellan.umontreal.ca">borcardd@magellan.umontreal.ca</a>
</p>


<h3>References</h3>

<p>Borcard, D., and Legendre, P. (1994) Environmental control and spatial structure in ecological communities: 
an example using Oribatid mites (<em>Acari Oribatei</em>). <em>Environmental and Ecological Statistics</em>, <b>1</b>, 37&ndash;61.
</p>
<p>Borcard, D., Legendre, P., and Drapeau, P. (1992) Partialling out the spatial component of ecological variation. 
<em>Ecology</em>, <b>73</b>, 1045&ndash;1055.
</p>
<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps039.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps039.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oribatid)
ori.xy &lt;- oribatid$xy[, c(2, 1)]
names(ori.xy) &lt;- c("x","y")
plot(ori.xy,pch = 20, cex = 2, asp = 1)

if(requireNamespace("deldir", quietly = TRUE) &amp; requireNamespace("spdep", quietly = TRUE)) {
  plot(deldir::deldir(ori.xy), add = TRUE)
  if(adegraphicsLoaded()) {
    s.label(ori.xy, nb = spdep::knn2nb(spdep::knearneigh(as.matrix(ori.xy), 3)), plab.cex = 0)
  } else {
    s.label(ori.xy, add.p = TRUE, clab = 0, 
      neig = nb2neig(spdep::knn2nb(spdep::knearneigh(as.matrix(ori.xy), 3))))
  }
}
</code></pre>

<hr>
<h2 id='originality'>Originality of a species
</h2><span id='topic+originality'></span>

<h3>Description</h3>

<p>computes originality values for species from an ultrametric phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>originality(phyl, method = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="originality_+3A_phyl">phyl</code></td>
<td>
<p>an object of class phylog</p>
</td></tr>
<tr><td><code id="originality_+3A_method">method</code></td>
<td>
<p>a vector containing integers between 1 and 7. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>1 = Vane-Wright et al.'s (1991) node-counting index
2 = May's (1990) branch-counting index
3 = Nixon and Wheeler's (1991) unweighted index, based on the sum of units in binary values
4 = Nixon and Wheeler's (1991) weighted index 
5 = QE-based index
6 = Isaac et al. (2007) ED index
7 = Redding et al. (2006) Equal-split index
</p>


<h3>Value</h3>

<p>Returns a data frame with species in rows, and the selected indices of originality in columns. 
Indices are expressed as percentages.
</p>


<h3>Author(s)</h3>

<p>Sandrine Pavoine <a href="mailto:pavoine@mnhn.fr">pavoine@mnhn.fr</a>
</p>


<h3>References</h3>

<p>Isaac, N.J.B., Turvey, S.T., Collen, B., Waterman, C. and Baillie, J.E.M. (2007) Mammals on the EDGE: 
conservation priorities based on threat and phylogeny. <em>PloS ONE</em>, <b>2</b>, e&ndash;296.
</p>
<p>Redding, D. and Mooers, A. (2006) Incorporating evolutionary measures into conservation prioritization. 
<em>Conservation Biology</em>, <b>20</b>, 1670&ndash;1678.
</p>
<p>Pavoine, S., Ollier, S. and Dufour, A.-B. (2005)  Is the originality of a species measurable? 
<em>Ecology Letters</em>, <b>8</b>, 579&ndash;586.
</p>
<p>Vane-Wright, R.I., Humphries, C.J. and Williams, P.H. (1991). What to protect? Systematics 
and the agony of choice. <em>Biological Conservation</em>, <b>55</b>, 235&ndash;254. 
</p>
<p>May, R.M. (1990). Taxonomy as destiny. <em>Nature</em>, <b>347</b>, 129&ndash;130. 
</p>
<p>Nixon, K.C. and Wheeler, Q.D. (1992). Measures of phylogenetic diversity. In: <em>Extinction and 
Phylogeny</em> (eds. Novacek, M.J. and Wheeler, Q.D.), 216&ndash;234, Columbia University Press, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carni70)
carni70.phy &lt;- newick2phylog(carni70$tre)
ori.tab &lt;- originality(carni70.phy, 1:7)
names(ori.tab)
dotchart.phylog(carni70.phy, ori.tab, scaling = FALSE, yjoining = 0, 
    ranging = FALSE, cleaves = 0, ceti = 0.5, csub = 0.7, cdot = 0.5)
</code></pre>

<hr>
<h2 id='orthobasis'>Orthonormal basis for orthonormal transform</h2><span id='topic+orthobasis'></span><span id='topic+orthobasis.neig'></span><span id='topic+orthobasis.line'></span><span id='topic+orthobasis.circ'></span><span id='topic+orthobasis.mat'></span><span id='topic+orthobasis.haar'></span><span id='topic+print.orthobasis'></span><span id='topic+is.orthobasis'></span><span id='topic+summary.orthobasis'></span><span id='topic+plot.orthobasis'></span>

<h3>Description</h3>

<p>These functions returns object of class <code>'orthobasis'</code> that
contains data frame defining an orthonormal basis.
</p>
<p><code>orthobasic.neig</code> returns the eigen vectors of the matrix N-M where M is the symmetric <em>n</em> by <em>n</em> matrix of the between-sites neighbouring graph and N is the diagonal matrix of neighbour numbers. <br />
<code>orthobasis.line</code> returns the analytical solution for the linear neighbouring graph. <br />
<code>orthobasic.circ</code> returns the analytical solution for the circular neighbouring graph. <br />
<code>orthobsic.mat</code> returns the eigen vectors of the general link matrix M. <br />
<code>orthobasis.haar</code> returns wavelet haar basis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthobasis.neig(neig)
orthobasis.line(n)
orthobasis.circ(n)
orthobasis.mat(mat, cnw=TRUE)
orthobasis.haar(n)
## S3 method for class 'orthobasis'
print(x,..., nr = 6, nc = 4)
## S3 method for class 'orthobasis'
plot(x,...)
## S3 method for class 'orthobasis'
summary(object,...)
is.orthobasis(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthobasis_+3A_neig">neig</code></td>
<td>
<p>is an object of class <code>neig</code></p>
</td></tr>
<tr><td><code id="orthobasis_+3A_n">n</code></td>
<td>
<p>is an integer that defines length of vectors</p>
</td></tr>
<tr><td><code id="orthobasis_+3A_mat">mat</code></td>
<td>
<p>is a <em>n</em> by <em>n</em> phylogenetic or spatial link matrix</p>
</td></tr>
<tr><td><code id="orthobasis_+3A_cnw">cnw</code></td>
<td>
<p>if TRUE, the matrix of the neighbouring graph is modified to give Constant Neighbouring Weights</p>
</td></tr>
<tr><td><code id="orthobasis_+3A_x">x</code>, <code id="orthobasis_+3A_object">object</code></td>
<td>
<p>is an object of class <code>orthobasis</code></p>
</td></tr>
<tr><td><code id="orthobasis_+3A_nr">nr</code>, <code id="orthobasis_+3A_nc">nc</code></td>
<td>
<p>the number of rows and columns to be printed</p>
</td></tr>
<tr><td><code id="orthobasis_+3A_...">...</code></td>
<td>
<p>: further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All the functions return an object of class <code>orthobasis</code> containing a data frame.
This data frame defines an orthonormal basis with various attributes: <br />
</p>
<table>
<tr><td><code>names</code></td>
<td>
<p>names of the vectors</p>
</td></tr>
<tr><td><code>row.names</code></td>
<td>
<p>row names of the data frame</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>class</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>optional associated eigenvalues</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>weights for the rows</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>: call</p>
</td></tr>
</table>


<h3>Note</h3>

<p>the function <code>orthobasis.haar</code> uses function <code><a href="waveslim.html#topic+wavelet.filter">wavelet.filter</a></code> from package waveslim.</p>


<h3>Author(s)</h3>

<p>Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a> <br />
Daniel Chessel 
</p>


<h3>References</h3>

<p>Misiti, M., Misiti, Y., Oppenheim, G. and Poggi, J.M. (1993) Analyse de signaux classiques par décomposition en ondelettes. 
<em>Revue de Statistique Appliquée</em>, <b>41</b>, 5&ndash;32.
</p>
<p>Cornillon, P.A. (1998) <em>Prise en compte de proximités en analyse factorielle et comparative</em>.
Thèse, Ecole Nationale Supérieure Agronomique, Montpellier.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gridrowcol">gridrowcol</a></code> that defines an orthobasis for square grid, 
<code><a href="#topic+phylog">phylog</a></code> that defines an orthobasis for phylogenetic tree, 
<code><a href="adephylo.html#topic+orthogram">orthogram</a></code> and <code><a href="#topic+mld">mld</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a 2D spatial orthobasis
w &lt;- gridrowcol(8, 8)
if(adegraphicsLoaded()) {
  g1 &lt;- s.value(w$xy, w$orthobasis[, 1:16], pleg.drawKey = FALSE, pgri.text.cex = 0, 
    ylim = c(0, 10), porigin.include = FALSE, paxes.draw = FALSE)
  g2 &lt;- s1d.barchart(attr(w$orthobasis, "values"), p1d.horizontal = FALSE, 
    labels = names(attr(w$orthobasis, "values")), plabels.cex = 0.7)

} else {
  par(mfrow = c(4, 4))
  for(k in 1:16)
    s.value(w$xy, w$orthobasis[, k], cleg = 0, csi = 2, incl = FALSE,
      addax = FALSE, sub = k, csub = 4, ylim = c(0, 10), cgri = 0)
  par(mfrow = c(1, 1))
  barplot(attr(w$orthobasis, "values"))
}


# Haar 1D orthobasis
w &lt;- orthobasis.haar(32)
par(mfrow = c(8, 4))
par(mar = c(0.1, 0.1, 0.1, 0.1))
 for (k in 1:31) {
    plot(w[, k], type = "S", xlab = "", ylab = "", xaxt = "n",
     yaxt = "n", xaxs = "i", yaxs = "i", ylim = c(-4.5, 4.5))
    points(w[, k], type = "p", pch = 20, cex = 1.5)
}

# a 1D orthobasis
w &lt;- orthobasis.line(n = 33)
par(mfrow = c(8, 4))
par(mar = c(0.1, 0.1, 0.1, 0.1))
 for (k in 1:32) {
    plot(w[, k], type = "l", xlab = "", ylab = "", xaxt = "n",
     yaxt = "n", xaxs = "i", yaxs = "i", ylim = c(-1.5, 1.5))
    points(w[, k], type = "p", pch = 20, cex = 1.5)
}

if(adegraphicsLoaded()) {
  s1d.barchart(attr(w, "values"), p1d.horizontal = FALSE, labels = names(attr(w, "values")), 
    plab.cex = 0.7)
} else {
  par(mfrow = c(1, 1))
  barplot(attr(w, "values"))
}

w &lt;- orthobasis.circ(n = 26)
#par(mfrow = c(5, 5))
#par(mar = c(0.1, 0.1, 0.1, 0.1))
# for (k in 1:25) 
#    dotcircle(w[, k], xlim = c(-1.5, 1.5), cleg = 0)

par(mfrow = c(1, 1))
#barplot(attr(w, "values"))

## Not run: 
# a spatial orthobasis
data(mafragh)
w &lt;- orthobasis.neig(mafragh$neig)
if(adegraphicsLoaded()) {
  s.value(mafragh$xy, w[, 1:8], plegend.drawKey = FALSE)
  s1d.barchart(attr(w, "values"), p1d.horizontal = FALSE)
} else {
  par(mfrow = c(4, 2))
  for(k in 1:8)
    s.value(mafragh$xy, w[, k], cleg = 0, sub = as.character(k), csub = 3)
  par(mfrow = c(1, 1))
  barplot(attr(w, "values"))
}

# a phylogenetic orthobasis
data(njplot)
phy &lt;- newick2phylog(njplot$tre)
wA &lt;- phy$Ascores
wW &lt;- phy$Wscores
table.phylog(phylog = phy, wA, clabel.row = 0, clabel.col  = 0.5)
table.phylog(phylog = phy, wW, clabel.row = 0, clabel.col  = 0.5)


## End(Not run)</code></pre>

<hr>
<h2 id='ours'>A table of Qualitative Variables</h2><span id='topic+ours'></span>

<h3>Description</h3>

<p>The <code>ours</code> (bears) data frame has 38 rows, areas of the &quot;Inventaire National Forestier&quot;, and 10 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ours)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<ol>
<li><p> altit: importance of the altitudinal area inhabited by bears,
a factor with levels: 
</p>

<ul>
<li> <p><code>1</code> less than 50% of the area between 800 and 2000 meters 
</p>
</li>
<li> <p><code>2</code> between 50 and 70% 
</p>
</li>
<li> <p><code>3</code> more than 70%</p>
</li></ul>

</li>
<li><p> deniv: importance of the average variation in level by square of 50 km2, a factor with levels: 
</p>

<ul>
<li> <p><code>1</code> less than 700m
</p>
</li>
<li> <p><code>2</code> between 700 and 900 m 
</p>
</li>
<li> <p><code>3</code> more than 900 m </p>
</li></ul>

</li>
<li><p> cloiso: partitioning of the massif, a factor with levels: 
</p>

<ul>
<li> <p><code>1</code> a great valley or a ridge isolates at least a quarter of the massif 
</p>
</li>
<li> <p><code>2</code> less than a quarter of the massif is isolated 
</p>
</li>
<li> <p><code>3</code> the massif has no split</p>
</li></ul>

</li>
<li><p> domain: importance of the national forests on contact with the massif, a factor with levels: 
</p>

<ul>
<li> <p><code>1</code> less than 400  km2 
</p>
</li>
<li> <p><code>2</code> between 400 and 1000  km2 
</p>
</li>
<li> <p><code>3</code> more than 1000  km2 </p>
</li></ul>

</li>
<li><p> boise: rate of afforestation, a factor with levels: 
</p>

<ul>
<li> <p><code>1</code> less than 30% 
</p>
</li>
<li> <p><code>2</code> between 30 and 50% 
</p>
</li>
<li> <p><code>3</code> more than 50% </p>
</li></ul>

</li>
<li><p> hetra: importance of plantations and mixed forests, a factor with levels: 
</p>

<ul>
<li> <p><code>1</code> less than 5% 
</p>
</li>
<li> <p><code>2</code> between 5 and 10% 
</p>
</li>
<li> <p><code>3</code> more than 10% of the massif </p>
</li></ul>

</li>
<li><p> favor: importance of favorable forests, plantations, mixed forests, fir plantations, a factor with levels: 
</p>

<ul>
<li> <p><code>1</code> less than 5% 
</p>
</li>
<li> <p><code>2</code> between 5 and 10% 
</p>
</li>
<li> <p><code>3</code> more than 10% of the massif </p>
</li></ul>

</li>
<li><p> inexp: importance of unworked forests, a factor with levels: 
</p>

<ul>
<li> <p><code>1</code> less than 4% 
</p>
</li>
<li> <p><code>2</code> between 4 and 8% 
</p>
</li>
<li> <p><code>3</code> more than 8% of the total area </p>
</li></ul>

</li>
<li><p> citat: presence of the bear before its disappearance, a factor with levels: 
</p>

<ul>
<li> <p><code>1</code> no quotation since 1840 
</p>
</li>
<li> <p><code>2</code> 1 to 3 quotations before 1900 and none after 
</p>
</li>
<li> <p><code>3</code> 4 quotations before 1900 and none after 
</p>
</li>
<li> <p><code>4</code> at least 4 quotations before 1900 and at least 1 quotation between 1900 and 1940 </p>
</li></ul>

</li>
<li><p> depart: district, a factor with levels: 
</p>

<ul>
<li> <p><code>AHP</code> Alpes-de-Haute-Provence 
</p>
</li>
<li> <p><code>AM</code> Alpes-Maritimes 
</p>
</li>
<li> <p><code>D</code> Drôme 
</p>
</li>
<li> <p><code>HP</code> Hautes-Alpes 
</p>
</li>
<li> <p><code>HS</code> Haute-Savoie 
</p>
</li>
<li> <p><code>I</code> Isère 
</p>
</li>
<li> <p><code>S</code> Savoie</p>
</li></ul>

</li></ol>



<h3>Source</h3>

<p>Erome, G. (1989) <em>L'ours brun dans les Alpes françaises. Historique de sa disparition</em>.
Centre Ornithologique Rhône-Alpes, Villeurbanne. 120 p.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ours)
if(adegraphicsLoaded()) {
  s1d.boxplot(dudi.acm(ours, scan = FALSE)$l1[, 1], ours)
} else {
  boxplot(dudi.acm(ours, scan = FALSE))
}
</code></pre>

<hr>
<h2 id='palm'>Phylogenetic and quantitative traits of amazonian palm trees</h2><span id='topic+palm'></span>

<h3>Description</h3>

<p>This data set describes the phylogeny of 66 amazonian palm trees. It also gives 7 traits corresponding to these 66 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(palm)</code></pre>


<h3>Format</h3>

<p><code>palm</code> is a list containing the 2 following objects: 
</p>
 
<dl>
<dt>tre</dt><dd><p>is a character string giving the phylogenetic tree in Newick format.</p>
</dd> 
<dt>traits</dt><dd><p>is a data frame with 66 species (rows) and 7 traits (columns).</p>
</dd>
</dl>
 

<h3>Details</h3>

       
<p>Variables of <code>palm$traits</code> are the following ones: <br />
rord: specific richness with five ordered levels<br />
h: height in meter (squared transform)<br />
dqual: diameter at breast height in centimeter with five levels <code>sout : subterranean</code>, <code> d1(0, 5 cm)</code>, <code> d2(5, 15 cm)</code>, <code> d3(15, 30 cm)</code> and <code> d4(30, 100 cm)</code><br />
vfruit: fruit volume in <code class="reqn">mm^{3}</code> (logged transform)<br />
vgrain: seed volume in <code class="reqn">mm^{3}</code> (logged transform)<br />
aire: spatial distribution area (<code class="reqn">km^{2}</code>)<br />
alti: maximum altitude in meter (logged transform)<br />       
</p>


<h3>Source</h3>

<p>This data set was obtained by Clémentine Gimaret-Carpentier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(palm)
palm.phy &lt;- newick2phylog(palm$tre)
radial.phylog(palm.phy,clabel.l=1.25)

if (requireNamespace("adephylo", quietly = TRUE) &amp; requireNamespace("ape", quietly = TRUE)) {
  tre &lt;- ape::read.tree(text = palm$tre)
  adephylo::orthogram(palm$traits[, 4], tre)
}
dotchart.phylog(palm.phy,palm$traits[,4], clabel.l = 1,
 labels.n = palm.phy$Blabels, clabel.n = 0.75)
w &lt;- cbind.data.frame(palm.phy$Bscores[,c(3,4,6,13,21)],
 scalewt((palm$traits[,4])))
names(w)[6] &lt;- names(palm$traits[4])
table.phylog(w, palm.phy, clabel.r = 0.75, f = 0.5)

gearymoran(palm.phy$Amat, palm$traits[,-c(1,3)])

## End(Not run)</code></pre>

<hr>
<h2 id='pap'>Taxonomy and quantitative traits of carnivora</h2><span id='topic+pap'></span>

<h3>Description</h3>

<p>This data set describes the taxonomy of 39 carnivora. It also gives life-history traits corresponding to these 39 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pap)</code></pre>


<h3>Format</h3>

<p><code>pap</code> is a list containing the 2 following objects : 
</p>
 
<dl>
<dt>taxo</dt><dd><p>is a data frame with 39 species and 3 columns.</p>
</dd> 
<dt>tab</dt><dd><p>is a data frame with 39 species and 4 traits.</p>
</dd>    
</dl>


<h3>Details</h3>

       
<p>Variables of <code>pap$tab</code> are the following ones : genre (genus with 30 levels),
famille (family with 6 levels), superfamille (superfamily with 2 levels).<br />
</p>
<p>Variables of <code>pap$tab</code> are Group Size, Body Weight, Brain Weight, Litter Size.
</p>


<h3>Source</h3>

<p>Data taken from the phylogenetic autocorrelation package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pap)
taxo &lt;- taxo2phylog(as.taxo(pap$taxo))
table.phylog(as.data.frame(scalewt(pap$tab)), taxo, csi = 2, clabel.nod = 0.6,
 f.phylog = 0.6)
</code></pre>

<hr>
<h2 id='pcaiv'>Principal component analysis with respect to instrumental variables</h2><span id='topic+pcaiv'></span><span id='topic+plot.pcaiv'></span><span id='topic+print.pcaiv'></span><span id='topic+summary.pcaiv'></span>

<h3>Description</h3>

<p>performs a principal component analysis with respect to instrumental variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcaiv(dudi, df, scannf = TRUE, nf = 2)
## S3 method for class 'pcaiv'
plot(x, xax = 1, yax = 2, ...) 
## S3 method for class 'pcaiv'
print(x, ...)
## S3 method for class 'pcaiv'
summary(object, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcaiv_+3A_dudi">dudi</code></td>
<td>
<p>a duality diagram, object of class <code>dudi</code></p>
</td></tr>
<tr><td><code id="pcaiv_+3A_df">df</code></td>
<td>
<p>a data frame with the same rows</p>
</td></tr>
<tr><td><code id="pcaiv_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="pcaiv_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>
<p><br />
</p>
<table>
<tr><td><code id="pcaiv_+3A_x">x</code>, <code id="pcaiv_+3A_object">object</code></td>
<td>
<p>an object of class <code>pcaiv</code></p>
</td></tr>
<tr><td><code id="pcaiv_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="pcaiv_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="pcaiv_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class <code>pcaiv</code>, sub-class of class <code>dudi</code>
</p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>a data frame with the modified array (projected variables)</p>
</td></tr>
<tr><td><code>cw</code></td>
<td>
<p>a numeric vector with the column weigths (from <code>dudi</code>)</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>a numeric vector with the row weigths (from <code>dudi</code>)</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a vector with the all eigenvalues</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>an integer indicating the rank of the studied matrix</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>a data frame with the Pseudo Principal Axes (PPA)</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>a data frame <code>dudi$ls</code> with the predicted values by X</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>a data frame with the inner products between the CPC and Y</p>
</td></tr>
<tr><td><code>l1</code></td>
<td>
<p>data frame with the Constraint Principal Components (CPC)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a data frame with the explanatory variables</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>a data frame with the dependant variables</p>
</td></tr>
<tr><td><code>ls</code></td>
<td>
<p>a data frame with the projections of lines of <code>dudi$tab</code> on PPA</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a table containing information about contributions of the analyses : absolute (1) and cumulative (2) contributions of the decomposition of inertia of the dudi object, absolute (3) and cumulative (4) variances of the projections, the ration (5) between the cumulative variances of the projections (4) and the cumulative contributions (2), the square coefficient of correlation (6) and the eigenvalues of the pcaiv (7)</p>
</td></tr>
<tr><td><code>as</code></td>
<td>
<p>a data frame with the Principal axes of <code>dudi$tab</code> on PPA</p>
</td></tr>
<tr><td><code>fa</code></td>
<td>
<p>a data frame with the loadings (Constraint Principal Components as linear combinations of X</p>
</td></tr>
<tr><td><code>cor</code></td>
<td>
<p>a data frame with the correlations between the CPC and X </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a><br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Rao, C. R. (1964) The use and interpretation of principal component analysis in applied research. <em>Sankhya</em>, <b>A 26</b>, 329&ndash;359.<br /><br />
Obadia, J. (1978) L'analyse en composantes explicatives. <em>Revue de Statistique Appliquee</em>, <b>24</b>, 5&ndash;28.<br /><br />
Lebreton, J. D., Sabatier, R., Banco G. and  Bacou A. M. (1991) 
Principal component and correspondence analyses with respect to instrumental variables : 
an overview of their role in studies of structure-activity and species- environment relationships. 
In J. Devillers and W. Karcher, editors. <em>Applied Multivariate Analysis in SAR and Environmental Studies</em>, 
Kluwer Academic Publishers, 85&ndash;114.
</p>
<p>Ter Braak, C. J. F. (1986) Canonical correspondence analysis : a new eigenvector technique for multivariate direct gradient analysis. <em>Ecology</em>, <b>67</b>, 1167&ndash;1179.<br /><br />
Ter Braak, C. J. F. (1987) The analysis of vegetation-environment relationships by canonical correspondence analysis. <em>Vegetatio</em>, <b>69</b>, 69&ndash;77.<br /><br />
Chessel, D., Lebreton J. D. and Yoccoz N. (1987) Propriétés de l'analyse canonique des correspondances. Une utilisation en hydrobiologie. <em>Revue de Statistique Appliquée</em>, <b>35</b>, 55&ndash;72.<br /><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example for the pcaiv
data(rhone)
pca1 &lt;- dudi.pca(rhone$tab, scan = FALSE, nf = 3)
iv1 &lt;- pcaiv(pca1, rhone$disch, scan = FALSE)
summary(iv1)
plot(iv1)

# example for the caiv
data(rpjdl)
millog &lt;- log(rpjdl$mil + 1)
coa1 &lt;- dudi.coa(rpjdl$fau, scann = FALSE)
caiv1 &lt;- pcaiv(coa1, millog, scan = FALSE)

if(adegraphicsLoaded()) {
  G1 &lt;- plot(caiv1)
  
  # analysis with c1 - as - li -ls
  # projections of inertia axes on PCAIV axes
  G2 &lt;- s.corcircle(caiv1$as)
  
  # Species positions
  g31 &lt;- s.label(caiv1$c1, xax = 2, yax = 1, plab.cex = 0.5, xlim = c(-4, 4), plot = FALSE)
  # Sites positions at the weighted mean of present species
  g32 &lt;- s.label(caiv1$ls, xax = 2, yax = 1, plab.cex = 0, plot = FALSE)
  G3 &lt;- superpose(g31, g32, plot = TRUE)
  
  # Prediction of the positions by regression on environmental variables
  G4 &lt;- s.match(caiv1$ls, caiv1$li, xax = 2, yax = 1, plab.cex = 0.5)
  
  # analysis with fa - l1 - co -cor
  # canonical weights giving unit variance combinations
  G5 &lt;- s.arrow(caiv1$fa)
  
  # sites position by environmental variables combinations
  # position of species by averaging
  g61 &lt;- s.label(caiv1$l1, xax = 2, yax = 1, plab.cex = 0, ppoi.cex = 1.5, plot = FALSE)
  g62 &lt;- s.label(caiv1$co, xax = 2, yax = 1, plot = FALSE)
  G6 &lt;- superpose(g61, g62, plot = TRUE)
  
  G7 &lt;- s.distri(caiv1$l1, rpjdl$fau, xax = 2, yax = 1, ellipseSize = 0, starSize = 0.33)
  
  # coherence between weights and correlations
  g81 &lt;- s.corcircle(caiv1$cor, xax = 2, yax = 1, plot = FALSE)
  g82 &lt;- s.arrow(caiv1$fa, xax = 2, yax = 1, plot = FALSE)
  G8 &lt;- cbindADEg(g81, g82, plot = TRUE)

} else {
  plot(caiv1)
  
  # analysis with c1 - as - li -ls
  # projections of inertia axes on PCAIV axes
  s.corcircle(caiv1$as)
  
  # Species positions
  s.label(caiv1$c1, 2, 1, clab = 0.5, xlim = c(-4, 4))
  # Sites positions at the weighted mean of present species
  s.label(caiv1$ls, 2, 1, clab = 0, cpoi = 1, add.p = TRUE)
  
  # Prediction of the positions by regression on environmental variables
  s.match(caiv1$ls, caiv1$li, 2, 1, clab = 0.5)
  
  # analysis with fa - l1 - co -cor
  # canonical weights giving unit variance combinations
  s.arrow(caiv1$fa)
  
  # sites position by environmental variables combinations
  # position of species by averaging
  s.label(caiv1$l1, 2, 1, clab = 0, cpoi = 1.5)
  s.label(caiv1$co, 2, 1, add.plot = TRUE)
  
  s.distri(caiv1$l1, rpjdl$fau, 2, 1, cell = 0, csta = 0.33)
  s.label(caiv1$co, 2, 1, clab = 0.75, add.plot = TRUE)
  
  # coherence between weights and correlations
  par(mfrow = c(1, 2))
  s.corcircle(caiv1$cor, 2, 1)
  s.arrow(caiv1$fa, 2, 1)
  par(mfrow = c(1, 1))
}
</code></pre>

<hr>
<h2 id='pcaivortho'>Principal Component Analysis with respect to orthogonal instrumental variables</h2><span id='topic+pcaivortho'></span><span id='topic+summary.pcaivortho'></span>

<h3>Description</h3>

<p>performs a Principal Component Analysis with respect to orthogonal instrumental variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcaivortho(dudi, df, scannf = TRUE, nf = 2)
## S3 method for class 'pcaivortho'
summary(object, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcaivortho_+3A_dudi">dudi</code></td>
<td>
<p>a duality diagram, object of class <code>dudi</code></p>
</td></tr>
<tr><td><code id="pcaivortho_+3A_df">df</code></td>
<td>
<p>a data frame with the same rows</p>
</td></tr>
<tr><td><code id="pcaivortho_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="pcaivortho_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="pcaivortho_+3A_object">object</code></td>
<td>
<p>an object of class <code>pcaiv</code></p>
</td></tr>
<tr><td><code id="pcaivortho_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'pcaivortho' sub-class of class <code>dudi</code>
</p>
<table>
<tr><td><code>rank</code></td>
<td>
<p>an integer indicating the rank of the studied matrix</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a vector with the all eigenvalues</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>a numeric vector with the row weigths (from <code>dudi</code>)</p>
</td></tr>
<tr><td><code>cw</code></td>
<td>
<p>a numeric vector with the column weigths (from <code>dudi</code>)</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>a data frame with the dependant variables</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a data frame with the explanatory variables</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p>a data frame with the modified array (projected variables)</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>a data frame with the Pseudo Principal Axes (PPA)</p>
</td></tr>
<tr><td><code>as</code></td>
<td>
<p>a data frame with the Principal axis of <code>dudi$tab</code> on PAP</p>
</td></tr>
<tr><td><code>ls</code></td>
<td>
<p>a data frame with the projection of lines of <code>dudi$tab</code> on PPA</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>a data frame <code>dudi$ls</code> with the predicted values by X</p>
</td></tr>
<tr><td><code>l1</code></td>
<td>
<p>a data frame with the Constraint Principal Components (CPC)</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>a data frame with the inner product between the CPC and Y</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a data frame containing a summary</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a><br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Rao, C. R. (1964) The use and interpretation of principal component analysis in applied research. <em>Sankhya</em>, <b>A 26</b>, 329&ndash;359.<br /><br />
Sabatier, R., Lebreton J. D. and Chessel D. (1989) Principal component analysis with instrumental variables as a tool for modelling composition data. In R. Coppi and S. Bolasco, editors. <em>Multiway data analysis</em>, Elsevier Science Publishers B.V., North-Holland, 341&ndash;352
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(avimedi)
cla &lt;- avimedi$plan$reg:avimedi$plan$str
# simple ordination
coa1 &lt;- dudi.coa(avimedi$fau, scan = FALSE, nf = 3)
# within region
w1 &lt;- wca(coa1, avimedi$plan$reg, scan = FALSE)
# no region the same result
pcaivnonA &lt;- pcaivortho(coa1, avimedi$plan$reg, scan = FALSE)
summary(pcaivnonA)
# region + strate
interAplusB &lt;- pcaiv(coa1, avimedi$plan, scan = FALSE)

if(adegraphicsLoaded()) {
  g1 &lt;- s.class(coa1$li, cla, psub.text = "Sans contrainte", plot = FALSE)
  g21 &lt;- s.match(w1$li, w1$ls, plab.cex = 0, psub.text = "Intra Région", plot = FALSE)
  g22 &lt;- s.class(w1$li, cla, plot = FALSE)
  g2 &lt;- superpose(g21, g22)
  g31 &lt;- s.match(pcaivnonA$li, pcaivnonA$ls, plab.cex = 0, psub.tex = "Contrainte Non A", 
    plot = FALSE)
  g32 &lt;- s.class(pcaivnonA$li, cla, plot = FALSE)
  g3 &lt;- superpose(g31, g32)
  g41 &lt;- s.match(interAplusB$li, interAplusB$ls, plab.cex = 0, psub.text = "Contrainte A + B", 
    plot = FALSE)
  g42 &lt;- s.class(interAplusB$li, cla, plot = FALSE)
  g4 &lt;- superpose(g41, g42)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))

} else {
  par(mfrow = c(2, 2))
  s.class(coa1$li, cla, sub = "Sans contrainte")
  s.match(w1$li, w1$ls, clab = 0, sub = "Intra Région")
  s.class(w1$li, cla, add.plot = TRUE)
  s.match(pcaivnonA$li, pcaivnonA$ls, clab = 0, sub = "Contrainte Non A")
  s.class(pcaivnonA$li, cla, add.plot = TRUE)
  s.match(interAplusB$li, interAplusB$ls, clab = 0, sub = "Contrainte A + B")
  s.class(interAplusB$li, cla, add.plot = TRUE)
  par(mfrow = c(1,1))
}
## End(Not run)</code></pre>

<hr>
<h2 id='pcoscaled'>Simplified Analysis in Principal Coordinates</h2><span id='topic+pcoscaled'></span>

<h3>Description</h3>

<p>performs a simplified analysis in principal coordinates, 
using an object of class <code>dist</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcoscaled(distmat, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcoscaled_+3A_distmat">distmat</code></td>
<td>
<p>an object of class <code>dist</code></p>
</td></tr>
<tr><td><code id="pcoscaled_+3A_tol">tol</code></td>
<td>
<p>a tolerance threshold, an eigenvalue is considered as positive if it is larger than <code>-tol*lambda1</code> where <code>lambda1</code> is the largest eigenvalue</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame containing the Euclidean representation of the distance matrix with a total inertia equal to 1
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>References</h3>

<p>Gower, J. C. (1966) Some distance properties of latent root and vector methods used in multivariate analysis. <em>Biometrika</em>, <b>53</b>, 325&ndash;338.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    a &lt;- 1 / sqrt(3) - 0.2
    w &lt;- matrix(c(0,0.8,0.8,a,0.8,0,0.8,a,
        0.8,0.8,0,a,a,a,a,0),4,4)
    w &lt;- as.dist(w)
    w &lt;- cailliez(w)
    w
    pcoscaled(w)
    dist(pcoscaled(w)) # w
    dist(pcoscaled(2 * w)) # the same
    sum(pcoscaled(w)^2) # unity
</code></pre>

<hr>
<h2 id='pcw'>Distribution of of tropical trees along the Panama canal</h2><span id='topic+pcw'></span>

<h3>Description</h3>

<p>Abundance of tropical trees, environmental variables and spatial
coordinates for 50 sites. Data are available at
<a href="https://doi.org/10.1126/science.1066854">doi:10.1126/science.1066854</a> 
but plots from Barro Colorado Island were removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pcw)</code></pre>


<h3>Format</h3>

<p>A list with 5 components.
</p>

<dl>
<dt>spe</dt><dd><p>Distribution of the abundances of 778 species in 50 sites</p>
</dd>
<dt>env</dt><dd><p>Measurements of environmental variables for the 50 sites</p>
</dd>
<dt>xy</dt><dd><p>Spatial coordinates for the sites (decimal degrees)</p>
</dd>
<dt>xy.utm</dt><dd><p>Spatial coordinates for the sites (UTM)</p>
</dd>
<dt>map</dt><dd><p>Map of the study area stored as a SpatialPolygons object</p>
</dd>
</dl>



<h3>Source</h3>

<p>Condit, R., N. Pitman, E. G. Leigh, J. Chave, J. Terborgh,
R. B. Foster, P. Núnez, S. Aguilar, R. Valencia, G. Villa,
H. C. Muller-Landau, E. Losos, and S. P. Hubbell. (2002) Beta-diversity
in tropical forest trees. <em>Science</em>, <b>295</b>, 666-669.
</p>
<p>Pyke, C. R., R. Condit, S. Aguilar, and S. Lao. (2001) Floristic
composition across a climatic gradient in a neotropical lowland
forest. <em>Journal of Vegetation Science</em>, <b>12</b>, 553&ndash;566.
</p>


<h3>References</h3>

<p>Dray, S., R. Pélissier, P. Couteron, M. J. Fortin, P. Legendre,
P. R. Peres-Neto, E. Bellier, R. Bivand, F. G. Blanchet, M. De
Caceres, A. B. Dufour, E. Heegaard, T. Jombart, F. Munoz, J. Oksanen,
J. Thioulouse, and H. H. Wagner. (2012) Community ecology in the age of
multivariate multiscale spatial analysis. <em>Ecological
Monographs</em>,  <b>82</b>, 257&ndash;275.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(adegraphicsLoaded()) {
  data(pcw)
  if(requireNamespace("spdep", quietly = TRUE)) {
    nb1 &lt;- spdep::graph2nb(spdep::gabrielneigh(pcw$xy.utm), sym = TRUE) 
    s.label(pcw$xy, nb = nb1, Sp = pcw$map)
  }
}</code></pre>

<hr>
<h2 id='perthi02'>Contingency Table with a partition in Molecular Biology</h2><span id='topic+perthi02'></span>

<h3>Description</h3>

<p>This data set gives the amino acids of 904 proteins 
distributed in three classes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(perthi02)</code></pre>


<h3>Format</h3>

<p><code>perthi02</code> is a list of 2 components.
</p>

<dl>
<dt>tab</dt><dd><p>is a data frame 904 rows (proteins of 201 species) 20 columns (amino acids).</p>
</dd>
<dt>cla</dt><dd><p>is a factor of 3 classes of protein</p>
</dd>
</dl>

<p>The levels of <code>perthi02$cla</code> are <code>cyto</code> (cytoplasmic proteins) <code>memb</code> (integral membran proteins) <code>peri</code> (periplasmic proteins)
</p>


<h3>Source</h3>

<p>Perriere, G. and Thioulouse, J. (2002) 
Use of Correspondence Discriminant Analysis to predict the subcellular location of bacterial proteins. 
<em>Computer Methods and Programs in Biomedicine</em>, <b>70</b>, 2, 99&ndash;105.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(perthi02)
plot(discrimin.coa(perthi02$tab, perthi02$cla, scan = FALSE))
</code></pre>

<hr>
<h2 id='phylog'>Phylogeny</h2><span id='topic+phylog'></span><span id='topic+print.phylog'></span><span id='topic+phylog.extract'></span><span id='topic+phylog.permut'></span>

<h3>Description</h3>

<p>Create and use objects of class <code>phylog</code>. <br />
<code>phylog.extract</code> returns objects of class <code>phylog</code>. It extracts sub-trees from a tree. <br />
<code>phylog.permut</code> returns objects of class <code>phylog</code>. It creates the different representations compatible with tree topology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylog'
print(x, ...)
phylog.extract(phylog, node, distance = TRUE)
phylog.permut(phylog, list.nodes = NULL, distance = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylog_+3A_x">x</code>, <code id="phylog_+3A_phylog">phylog</code></td>
<td>
<p>: an object of class <code>phylog</code></p>
</td></tr>
<tr><td><code id="phylog_+3A_...">...</code></td>
<td>
<p>: further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="phylog_+3A_node">node</code></td>
<td>
<p>: a string of characters giving a node name. The functions extracts the tree rooted at this node.</p>
</td></tr>
<tr><td><code id="phylog_+3A_distance">distance</code></td>
<td>
<p>: if TRUE, both functions retain branch lengths. If FALSE, they returns tree with arbitrary branch lengths (each branch length equals one)</p>
</td></tr>
<tr><td><code id="phylog_+3A_list.nodes">list.nodes</code></td>
<td>
<p>: a list which elements are vectors of string of character corresponding to direct descendants of nodes. This list defines one representation compatible with tree topology among the set of possibilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>phylog</code> :
</p>
<table>
<tr><td><code>tre</code></td>
<td>
<p>: a character string of the phylogenetic tree in Newick format whithout branch length values</p>
</td></tr>
<tr><td><code>leaves</code></td>
<td>
<p>: a vector which names corresponds to leaves and values gives the distance between leaves and nodes closest to these leaves</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>: a vector which names corresponds to nodes and values gives the distance between nodes and nodes closest to these leaves</p>
</td></tr>
<tr><td><code>parts</code></td>
<td>
<p>: a list which elements gives the direct descendants of each nodes</p>
</td></tr>
<tr><td><code>paths</code></td>
<td>
<p>: a list which elements gives the path leading from the root to taxonomic units (leaves and nodes)</p>
</td></tr>
<tr><td><code>droot</code></td>
<td>
<p>: a vector which names corresponds to taxonomic units and values gives distance between taxonomic units and the root</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>: call</p>
</td></tr> 
<tr><td><code>Wmat</code></td>
<td>
<p>: a phylogenetic link matrix, generally called the covariance matrix. Matrix values <code class="reqn">Wmat_{ij}</code> correspond to path length that lead from root to the first common ancestor of the two leaves i and j</p>
</td></tr>
<tr><td><code>Wdist</code></td>
<td>
<p>: a phylogenetic distance matrix of class <code>'dist'</code>. Matrix values <code class="reqn">Wdist_{ij}</code> correspond to <code class="reqn">\sqrt{d_{ij}}</code> where <code class="reqn">d_{ij}</code> is the classical distance between two leaves i and j</p>
</td></tr>
<tr><td><code>Wvalues</code></td>
<td>
<p>: a vector with the eigen values of Wmat</p>
</td></tr>
<tr><td><code>Wscores</code></td>
<td>
<p>: a data frame with eigen vectors of Wmat. This data frame defines an orthobasis that could be used to calculate the orthonormal decomposition of a biological trait on a tree.</p>
</td></tr>
<tr><td><code>Amat</code></td>
<td>
<p>: a phylogenetic link matrix stemed from Abouheif's test and defined in Ollier et al. (submited)</p>
</td></tr>
<tr><td><code>Avalues</code></td>
<td>
<p>: a vector with the eigen values of Amat</p>
</td></tr>
<tr><td><code>Adim</code></td>
<td>
<p>: number of positive eigen values</p>
</td></tr>
<tr><td><code>Ascores</code></td>
<td>
<p>: a data frame with eigen vectors of Amat. This data frame defines an orthobasis that could be used to calculate the orthonormal decomposition of a biological trait on a tree.</p>
</td></tr>
<tr><td><code>Aparam</code></td>
<td>
<p>: a data frame with attributes associated to nodes.</p>
</td></tr>
<tr><td><code>Bindica</code></td>
<td>
<p>: a data frame giving for some taxonomic units the partition of leaves that is associated to its</p>
</td></tr>
<tr><td><code>Bscores</code></td>
<td>
<p>: a data frame giving an orthobasis defined by Ollier et al. (submited) that could be used to calculate the orthonormal decomposition of a biological trait on a tree.</p>
</td></tr>
<tr><td><code>Bvalues</code></td>
<td>
<p>: a vector giving the degree of phylogenetic autocorrelation for each vectors of Bscores (Moran's form calculated with the matrix Wmat)</p>
</td></tr>
<tr><td><code>Blabels</code></td>
<td>
<p>: a vector giving for each nodes the name of the vector of Bscores that is associated to its</p>
</td></tr>    
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a>
</p>


<h3>References</h3>

<p>Ollier, S., Couteron, P. and Chessel, D. (2006) 
Orthonormal transform to decompose the variance of a life-history trait across a phylogenetic tree. 
<em>Biometrics</em> Biometrics, <b>62</b>, 2, 471&ndash;477.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+newick2phylog">newick2phylog</a></code>, <code><a href="#topic+plot.phylog">plot.phylog</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>marthans.tre &lt;- NULL
marthans.tre[1] &lt;-"((((1:4,2:4)a:5,(3:7,4:7)b:2)c:2,5:11)d:2,"
marthans.tre[2] &lt;- "((6:5,7:5)e:4,(8:4,9:4)f:5)g:4);"
marthans.phylog &lt;- newick2phylog(marthans.tre)
marthans.phylog

if(requireNamespace("ape", quietly = TRUE)) {
  marthans.phylo &lt;- ape::read.tree(text = marthans.tre)
  marthans.phylo

  par(mfrow = c(1, 2))
  plot(marthans.phylog, cnode = 3, f = 0.8, cle = 3)
  plot(marthans.phylo)
  par(mfrow = c(1, 1))
}
</code></pre>

<hr>
<h2 id='PI2newick'>Import data files from Phylogenetic Independance Package</h2><span id='topic+PI2newick'></span>

<h3>Description</h3>

<p>This function ensures to transform a data set written for the Phylogenetic Independance package of Abouheif (1999) in a data set formatting for the functions of ade4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PI2newick(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PI2newick_+3A_x">x</code></td>
<td>
<p>is a data frame that contains information on phylogeny topology and trait values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing :
</p>
<table>
<tr><td><code>tre</code></td>
<td>
<p>: a character string giving the phylogenetic tree in Newick format</p>
</td></tr>
<tr><td><code>trait</code></td>
<td>
<p>: a vector containing values of the trait</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a> <br />
Daniel Chessel 
</p>


<h3>References</h3>

<p>Abouheif, E. (1999) A method for testing the assumption of phylogenetic independence in comparative data. <em>Evolutionary Ecology Research</em>, <b>1</b>, 895&ndash;909.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2.0266, 0.5832, 0.2460, 1.2963, 0.2460, 0.1565, -99.0000,
        -99.0000, 10.1000, -99.0000,  20.2000,  28.2000, -99.0000, 
        14.1000, 11.2000, -99.0000, 21.3000, 27.5000, 1.0000, 2.0000,
        -1.0000, 4.0000, -1.0000, -1.0000, 3.0000, -1.0000, -1.0000,
        5.0000, -1.0000, -1.0000, 0.0000, 0.0000, 0.0000, 0.0000,
        0.0000, 0.0000)
x &lt;- matrix(x, nrow = 6)
x &lt;- as.data.frame(x)
res &lt;- PI2newick(x)
dotchart.phylog(newick2phylog(res$tre), res$trait)
</code></pre>

<hr>
<h2 id='piosphere'>
Plant traits response to grazing
</h2><span id='topic+piosphere'></span>

<h3>Description</h3>

<p>Plant species cover, traits and environmental parameters recorded around
livestock watering points in different habitats of central Namibian
farmlands. See the Wesuls et al. (2012) paper for a full description of
the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(piosphere)</code></pre>


<h3>Format</h3>

<p><code>piosphere</code> is a list of 4 components.
</p>

<dl>
<dt>veg</dt><dd><p>is a data frame containing plant species cover</p>
</dd>
<dt>traits</dt><dd><p>is a data frame with plant traits</p>
</dd>
<dt>env</dt><dd><p>is a data frame with environmental variables</p>
</dd>
<dt>habitat</dt><dd><p>is a factor describing habitat/years for each site</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wesuls, D., Oldeland, J. and Dray, S. (2012) Disentangling plant trait
responses to livestock grazing from spatio-temporal variation: the
partial RLQ approach. <em>Journal of Vegetation Science</em>, <b>23</b>, 98&ndash;113. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(piosphere)
names(piosphere)
afcL &lt;- dudi.coa(log(piosphere$veg + 1), scannf = FALSE)
acpR &lt;- dudi.pca(piosphere$env, scannf = FALSE, row.w = afcL$lw)
acpQ &lt;- dudi.hillsmith(piosphere$traits, scannf = FALSE, row.w = afcL$cw)
rlq1 &lt;- rlq(acpR, afcL, acpQ, scannf = FALSE)
plot(rlq1)
</code></pre>

<hr>
<h2 id='plot.phylog'>Plot phylogenies</h2><span id='topic+plot.phylog'></span><span id='topic+radial.phylog'></span><span id='topic+enum.phylog'></span>

<h3>Description</h3>

<p><code>plot.phylog</code> draws phylogenetic trees as linear dendograms. <br />
<code>radial.phylog</code> draws phylogenetic trees as circular dendograms. <br />
<code>enum.phylog</code> enumerate all the possible representations for a phylogeny.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phylog'
plot(x, y = NULL, f.phylog = 0.5, cleaves = 1, cnodes = 0,
 labels.leaves = names(x$leaves), clabel.leaves = 1,
 labels.nodes = names(x$nodes), clabel.nodes = 0, sub = "",
 csub = 1.25, possub = "bottomleft", draw.box = FALSE, ...)
radial.phylog(phylog, circle = 1, cleaves = 1, cnodes = 0,
 labels.leaves = names(phylog$leaves), clabel.leaves = 1,
 labels.nodes = names(phylog$nodes), clabel.nodes = 0,
 draw.box = FALSE)
enum.phylog(phylog, no.over = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.phylog_+3A_x">x</code>, <code id="plot.phylog_+3A_phylog">phylog</code></td>
<td>
<p>an object of class <code>phylog</code></p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_y">y</code></td>
<td>
<p>a vector which values correspond to leaves positions</p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_f.phylog">f.phylog</code></td>
<td>
<p>a size coefficient for tree size (a parameter to draw the tree in proportion to leaves label)</p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_circle">circle</code></td>
<td>
<p>a size coefficient for the outer circle</p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_cleaves">cleaves</code></td>
<td>
<p>a character size for plotting the points that represent the leaves, used with <code>par("cex")*cleaves</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_cnodes">cnodes</code></td>
<td>
<p>a character size for plotting the points that represent the nodes, used with <code>par("cex")*cnodes</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_labels.leaves">labels.leaves</code></td>
<td>
<p>a vector of strings of characters for the leaves labels</p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_clabel.leaves">clabel.leaves</code></td>
<td>
<p>a character size for the leaves labels, used with <code>par("cex")*clabel.leaves</code>. If zero, no leaves labels are drawn</p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_labels.nodes">labels.nodes</code></td>
<td>
<p>a vector of strings of characters for the nodes labels</p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_clabel.nodes">clabel.nodes</code></td>
<td>
<p>a character size for the nodes labels, used with <code>par("cex")*clabel.nodes</code>. If zero, no nodes labels are drawn</p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_draw.box">draw.box</code></td>
<td>
<p>if TRUE draws a box around the current plot with the function <code>box()</code></p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="plot.phylog_+3A_no.over">no.over</code></td>
<td>
<p>a size coefficient for the number of representations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector y is an argument of the function <code>plot.phylog</code> that ensures to plot one of the possible representations of a phylogeny.
The vector y is a permutation of the set of leaves {1,2,...,f} compatible with the phylogeny's topology.
</p>


<h3>Value</h3>

<p>The function <code>enum.phylog</code> returns a matrix with as many columns as leaves. Each row gives a permutation of the set of leaves {1,2,...,f} compatible with the phylogeny's topology. 
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phylog">phylog</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(newick.eg)
par(mfrow = c(3,2))
for(i in 1:6) plot(newick2phylog(newick.eg[[i]], FALSE),
 clea = 2, clabel.l = 3, cnod = 2.5)
par(mfrow = c(1,1))

## Not run: 
par(mfrow = c(1,2))
plot(newick2phylog(newick.eg[[11]], FALSE), clea = 1.5,
 clabel.l = 1.5, clabel.nod = 0.75, f = 0.8)
plot(newick2phylog(newick.eg[[10]], FALSE), clabel.l = 0,
 clea = 0, cn = 0, f = 1)
par(mfrow = c(1,1))

## End(Not run)

par(mfrow = c(2,2))
w7 &lt;- newick2phylog("(((((1,2,3)b),(6)c),(4,5)d,7)f);")
plot(w7,clabel.l = 1.5, clabel.n = 1.5, f = 0.8, cle = 2,
 cnod = 3, sub = "(((((1,2,3)b),(6)c),(4,5)d,7)f);", csub = 2)
w &lt;- NULL
w[1] &lt;- "((((e1:4,e2:4)a:5,(e3:7,e4:7)b:2)c:2,e5:11)d:2,"
w[2] &lt;- "((e6:5,e7:5)e:4,(e8:4,e9:4)f:5)g:4);"
plot(newick2phylog(w), f = 0.8, cnod = 2, cleav = 2, clabel.l = 2)

data(taxo.eg)
w &lt;- taxo2phylog(as.taxo(taxo.eg[[1]]))
plot(w, clabel.lea = 1.25, clabel.n = 1.25, sub = "Taxonomy",
 csub = 3, f = 0.8, possub = "topleft")

provi.tre &lt;- "(((a,b,c,d,e)A,(f,g,h)B)C)D;"
provi.phy &lt;- newick2phylog(provi.tre)
plot(provi.phy, clabel.l = 2, clabel.n = 2, f = 0.8)
par(mfrow = c(1,1))

## Not run: 
par(mfrow = c(3,3))
for (j in 1:6) radial.phylog(newick2phylog(newick.eg[[j]],
 FALSE), clabel.l = 2, cnodes = 2)
radial.phylog(newick2phylog(newick.eg[[7]],FALSE), clabel.l = 2)
radial.phylog(newick2phylog(newick.eg[[8]],FALSE), clabel.l = 0,
 circle = 1.8)
radial.phylog(newick2phylog(newick.eg[[9]],FALSE), clabel.l = 1,
 clabel.n = 1, cle = 0, cnode = 1)
par(mfrow = c(1,1))

data(bsetal97)
bsetal.phy = taxo2phylog(as.taxo(bsetal97$taxo[,1:3]), FALSE)
radial.phylog(bsetal.phy, cnod = 1, clea = 1, clabel.l = 0.75,
 draw.box = TRUE, cir = 1.1)
par(mfrow = c(1,1))

## End(Not run)

## Not run: 
# plot all the possible representations of a phylogenetic tree
a &lt;- "((a,b)A,(c,d,(e,f)B)C)D;"
wa &lt;- newick2phylog(a)
wx &lt;- enum.phylog(wa)
dim(wx)

par(mfrow = c(6,8))
fun &lt;- function(x) {
    w  &lt;-NULL
    lapply(x, function(y) w&lt;&lt;-paste(w,as.character(y),sep=""))
    plot(wa, x, clabel.n = 1.25, f = 0.75, clabel.l = 2,
     box = FALSE, cle = 1.5, sub = w, csub = 2)
    invisible()}
apply(wx,1,fun)
par(mfrow = c(1,1))

## End(Not run)

</code></pre>

<hr>
<h2 id='presid2002'>Results of the French presidential elections of 2002</h2><span id='topic+presid2002'></span>

<h3>Description</h3>

<p><code>presid2002</code> is a list of two data frames <code>tour1</code> and <code>tour2</code> with 93 rows (93 departments from continental Metropolitan France) and,
4 and 12 variables respectively . 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(presid2002)</code></pre>


<h3>Format</h3>

<p><code>tour1</code> contains the following arguments:<br />
the number of registered voters (<code>inscrits</code>); the number of abstentions (<code>abstentions</code>);
the number of voters (<code>votants</code>); the number of expressed votes (<code>exprimes</code>) and,
the numbers of votes for each candidate: <code>Megret</code>, <code>Lepage</code>, <code>Gluksten</code>, <code>Bayrou</code>, 
<code>Chirac</code>, <code>Le_Pen</code>, <code>Taubira</code>, <code>Saint.josse</code>, <code>Mamere</code>, <code>Jospin</code>, <code>Boutin</code>, 
<code>Hue</code>, <code>Chevenement</code>, <code>Madelin</code>, <code>Besancenot</code>.<br /><br />
<code>tour2</code> contains the following arguments:<br />
the number of registered voters (<code>inscrits</code>); the number of abstentions (<code>abstentions</code>);
the number of voters (<code>votants</code>); the number of expressed votes (<code>exprimes</code>) and, 
the numbers of votes for each candidate: <code>Chirac</code> and <code>Le_Pen</code>.
</p>


<h3>Source</h3>

<p>Site of the ministry of the Interior, of the Internal Security and of the local liberties<br />
<a href="https://www.interieur.gouv.fr/Elections/Les-resultats/Presidentielles/elecresult__presidentielle_2002/(path)/presidentielle_2002/index.html">https://www.interieur.gouv.fr/Elections/Les-resultats/Presidentielles/elecresult__presidentielle_2002/(path)/presidentielle_2002/index.html</a>
</p>


<h3>See Also</h3>

<p>This dataset is compatible with <code>elec88</code> and <code>cnc2003</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(presid2002)
all((presid2002$tour2$Chirac + presid2002$tour2$Le_Pen) == presid2002$tour2$exprimes)

## Not run: 
data(elec88)
data(cnc2003)
w0 &lt;- ade4:::area.util.class(elec88$area, cnc2003$reg)
w1 &lt;- scale(elec88$tab$Chirac)
w2 &lt;- scale(presid2002$tour1$Chirac / presid2002$tour1$exprimes)
w3 &lt;- scale(elec88$tab$Mitterand)
w4 &lt;- scale(presid2002$tour2$Chirac / presid2002$tour2$exprimes)

if(adegraphicsLoaded()) {
  g1 &lt;- s.value(elec88$xy, w1, Sp = elec88$Spatial, pSp.col = "white", pgrid.draw = FALSE, 
    psub.text = "Chirac 1988 T1", plot = FALSE)
  g2 &lt;- s.value(elec88$xy, w2, Sp = elec88$Spatial, pSp.col = "white", pgrid.draw = FALSE, 
    psub.text = "Chirac 2002 T1", plot = FALSE)
  g3 &lt;- s.value(elec88$xy, w3, Sp = elec88$Spatial, pSp.col = "white", pgrid.draw = FALSE, 
    psub.text = "Mitterand 1988 T1", plot = FALSE)
  g4 &lt;- s.value(elec88$xy, w4, Sp = elec88$Spatial, pSp.col = "white", pgrid.draw = FALSE, 
    psub.text = "Chirac 2002 T2", plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
      
} else {
  par(mfrow = c(2, 2))
  par(mar = c(0.1, 0.1, 0.1, 0.1))

  area.plot(w0)
  s.value(elec88$xy, w1, add.plot = TRUE)
  scatterutil.sub("Chirac 1988 T1", csub = 2, "topleft")

  area.plot(w0)
  s.value(elec88$xy, w2, add.plot = TRUE)
  scatterutil.sub("Chirac 2002 T1", csub = 2, "topleft")
  
  area.plot(w0)
  s.value(elec88$xy, w3, add.plot = TRUE)
  scatterutil.sub("Mitterand 1988 T1", csub = 2, "topleft")
  
  area.plot(w0)
  s.value(elec88$xy, w4, add.plot = TRUE)
  scatterutil.sub("Chirac 2002 T2", csub = 2, "topleft")
}
## End(Not run)</code></pre>

<hr>
<h2 id='procella'>Phylogeny and quantitative traits of birds</h2><span id='topic+procella'></span>

<h3>Description</h3>

<p>This data set describes the phylogeny of 19 birds as reported by Bried et al. (2002). It also gives 6 traits corresponding to these 19 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(procella)</code></pre>


<h3>Format</h3>

<p><code>procella</code> is a list containing the 2 following objects:  
</p>
     
<dl>
<dt>tre</dt><dd><p>is a character string giving the phylogenetic tree in Newick format.</p>
</dd> 
<dt>traits</dt><dd><p>is a data frame with 19 species and 6 traits</p>
</dd>    
</dl>


<h3>Details</h3>

<p>Variables of <code>procella$traits</code> are the following ones: <br />
site.fid: a numeric vector that describes the percentage of site fidelity<br />
mate.fid: a numeric vector that describes the percentage of mate fidelity<br />
mass: an integer vector that describes the adult body weight (g)<br />
ALE: a numeric vector that describes the adult life expectancy (years)<br />
BF: a numeric vector that describes the breeding frequencies<br />
col.size: an integer vector that describes the colony size (no nests monitored)
</p>


<h3>References</h3>

<p>Bried, J., Pontier, D. and Jouventin, P. (2002) Mate fidelity in monogamus birds: a re-examination of the Procellariiformes. 
<em>Animal Behaviour</em>, <b>65</b>, 235&ndash;246. 
</p>
<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps037.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps037.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(procella)
pro.phy &lt;- newick2phylog(procella$tre)
plot(pro.phy,clabel.n = 1, clabel.l = 1)
wt &lt;- procella$traits
wt$site.fid[is.na(wt$site.fid)] &lt;- mean(wt$site.fid[!is.na(wt$site.fid)])
wt$site.fid &lt;- asin(sqrt(wt$site.fid/100))
wt$ALE[is.na(wt$ALE)] &lt;- mean(wt$ALE[!is.na(wt$ALE)])
wt$ALE &lt;- sqrt(wt$ALE)
wt$BF[is.na(wt$BF)] &lt;- mean(wt$BF[!is.na(wt$BF)])
wt$mass &lt;- log(wt$mass)
wt &lt;- wt[, -6]
table.phylog(scalewt(wt), pro.phy, csi = 2)
gearymoran(pro.phy$Amat,wt,9999)
</code></pre>

<hr>
<h2 id='procuste'>Simple Procruste Rotation between two sets of points</h2><span id='topic+procuste'></span><span id='topic+plot.procuste'></span><span id='topic+print.procuste'></span><span id='topic+randtest.procuste'></span>

<h3>Description</h3>

<p>performs a simple procruste rotation between two sets of points. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procuste(dfX, dfY, scale = TRUE, nf = 4, tol = 1e-07) 
## S3 method for class 'procuste'
plot(x, xax = 1, yax = 2, ...)
## S3 method for class 'procuste'
print(x, ...)
## S3 method for class 'procuste'
randtest(xtest, nrepet = 999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="procuste_+3A_dfx">dfX</code>, <code id="procuste_+3A_dfy">dfY</code></td>
<td>
<p>two data frames with the same rows</p>
</td></tr>
<tr><td><code id="procuste_+3A_scale">scale</code></td>
<td>
<p>a logical value indicating whether a transformation by the Gower's scaling (1971) should be applied</p>
</td></tr>
<tr><td><code id="procuste_+3A_nf">nf</code></td>
<td>
<p>an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="procuste_+3A_tol">tol</code></td>
<td>
<p>a tolerance threshold to test whether the distance matrix is Euclidean : an eigenvalue is considered positive if it is larger than <code>-tol*lambda1</code> where <code>lambda1</code> is the largest eigenvalue.</p>
</td></tr>
</table>
<p><br />
</p>
<table>
<tr><td><code id="procuste_+3A_x">x</code>, <code id="procuste_+3A_xtest">xtest</code></td>
<td>
<p>an objet of class <code>procuste</code></p>
</td></tr>
<tr><td><code id="procuste_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="procuste_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="procuste_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of repetitions to perform the randomization test</p>
</td></tr>
<tr><td><code id="procuste_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of the class <code>procuste</code> with 9 components 
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>a numeric vector of the singular values</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>an integer indicating the rank of the crossed matrix</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code>tabX</code></td>
<td>
<p>a data frame with the array X, possibly scaled</p>
</td></tr>
<tr><td><code>tabY</code></td>
<td>
<p>a data frame with the array Y, possibly scaled</p>
</td></tr>
<tr><td><code>rotX</code></td>
<td>
<p>a data frame with the result of the rotation from array X to array Y</p>
</td></tr>
<tr><td><code>rotY</code></td>
<td>
<p>a data frame with the result of the rotation from array Y to array X</p>
</td></tr>
<tr><td><code>loadX</code></td>
<td>
<p>a data frame with the loadings of array X</p>
</td></tr>
<tr><td><code>loadY</code></td>
<td>
<p>a data frame with the loadings of array Y</p>
</td></tr>
<tr><td><code>scorX</code></td>
<td>
<p>a data frame with the scores of array X</p>
</td></tr>
<tr><td><code>scorY</code></td>
<td>
<p>a data frame with the scores of array Y</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>a call order of the analysis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Digby, P. G. N. and Kempton, R. A. (1987) Multivariate Analysis of Ecological Communities. <em>Population and Community Biology Series</em>, Chapman and Hall, London.<br /><br />
Gower, J.C. (1971) Statistical methods of comparing different multivariate analyses of the same data. In <em>Mathematics in the archaeological and historical sciences</em>, Hodson, F.R, Kendall, D.G. &amp; Tautu, P. (Eds.) University Press, Edinburgh,  138&ndash;149.<br /><br />
Schönemann, P.H. (1968) On two-sided Procustes problems. <em>Psychometrika</em>, <b>33</b>, 19&ndash;34.<br /><br />
Torre, F. and Chessel, D. (1994) Co-structure de deux tableaux totalement appariés. <em>Revue de Statistique Appliquée</em>, <b>43</b>, 109&ndash;121.<br /><br />
Dray, S., Chessel, D. and Thioulouse, J.  (2003) Procustean co-inertia analysis for the linking of multivariate datasets. <em>Ecoscience</em>, <b>10</b>, 1, 110-119.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(macaca)
pro1 &lt;- procuste(macaca$xy1, macaca$xy2, scal = FALSE)
pro2 &lt;- procuste(macaca$xy1, macaca$xy2)
if(adegraphicsLoaded()) {
  g1 &lt;- s.match(pro1$tabX, pro1$rotY, plab.cex = 0.7, plot = FALSE)
  g2 &lt;- s.match(pro1$tabY, pro1$rotX, plab.cex = 0.7, plot = FALSE)
  g3 &lt;- s.match(pro2$tabX, pro2$rotY, plab.cex = 0.7, plot = FALSE)
  g4 &lt;- s.match(pro2$tabY, pro2$rotX, plab.cex = 0.7, plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
} else {
  par(mfrow = c(2, 2))
  s.match(pro1$tabX, pro1$rotY, clab = 0.7)
  s.match(pro1$tabY, pro1$rotX, clab = 0.7)
  s.match(pro2$tabX, pro2$rotY, clab = 0.7)
  s.match(pro2$tabY, pro2$rotX, clab = 0.7)
  par(mfrow = c(1,1))
}

data(doubs)
pca1 &lt;- dudi.pca(doubs$env, scal = TRUE, scann = FALSE)
pca2 &lt;- dudi.pca(doubs$fish, scal = FALSE, scann = FALSE)
pro3 &lt;- procuste(pca1$tab, pca2$tab, nf = 2)
if(adegraphicsLoaded()) {
  g11 &lt;- s.traject(pro3$scorX, plab.cex = 0, plot = FALSE)
  g12 &lt;- s.label(pro3$scorX, plab.cex = 0.8, plot = FALSE)
  g1 &lt;- superpose(g11, g12)
  g21 &lt;- s.traject(pro3$scorY, plab.cex = 0, plot = FALSE)
  g22 &lt;- s.label(pro3$scorY, plab.cex = 0.8, plot = FALSE)
  g2 &lt;- superpose(g21, g22)
  g3 &lt;- s.arrow(pro3$loadX, plab.cex = 0.75, plot = FALSE)
  g4 &lt;- s.arrow(pro3$loadY, plab.cex = 0.75, plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))

} else {
  par(mfrow = c(2, 2))
  s.traject(pro3$scorX, clab = 0)
  s.label(pro3$scorX, clab = 0.8, add.p = TRUE)
  s.traject(pro3$scorY, clab = 0)
  s.label(pro3$scorY, clab = 0.8, add.p = TRUE)
  s.arrow(pro3$loadX, clab = 0.75)
  s.arrow(pro3$loadY, clab = 0.75)
  par(mfrow = c(1, 1))
}

plot(pro3)
randtest(pro3)

data(fruits)
plot(procuste(scalewt(fruits$jug), scalewt(fruits$var)))
</code></pre>

<hr>
<h2 id='procuste.randtest'>
Monte-Carlo Test on the sum of the singular values of a procustean rotation (in C).
</h2><span id='topic+procuste.randtest'></span>

<h3>Description</h3>

<p>performs a Monte-Carlo Test on the sum of the singular values of a procustean rotation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procuste.randtest(df1, df2, nrepet = 999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="procuste.randtest_+3A_df1">df1</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="procuste.randtest_+3A_df2">df2</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="procuste.randtest_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="procuste.randtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class <code>randtest</code>
</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse <a href="mailto:Jean.Thioulouse@univ-lyon1.fr">Jean.Thioulouse@univ-lyon1.fr</a></p>


<h3>References</h3>

<p>Jackson, D.A. (1995) PROTEST: a PROcustean randomization TEST of community environment concordance. <em>Ecosciences</em>, <b>2</b>, 297&ndash;303.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(doubs)
pca1 &lt;- dudi.pca(doubs$env, scal = TRUE, scann = FALSE)
pca2 &lt;- dudi.pca(doubs$fish, scal = FALSE, scann = FALSE)
protest1 &lt;- procuste.randtest(pca1$tab, pca2$tab, 999)
protest1
plot(protest1,main="PROTEST")
</code></pre>

<hr>
<h2 id='procuste.rtest'>
Monte-Carlo Test on the sum of the singular values of a procustean rotation (in R).
</h2><span id='topic+procuste.rtest'></span>

<h3>Description</h3>

<p>performs a Monte-Carlo Test on the sum of the singular values of a procustean rotation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procuste.rtest(df1, df2, nrepet = 99, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="procuste.rtest_+3A_df1">df1</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="procuste.rtest_+3A_df2">df2</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="procuste.rtest_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="procuste.rtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class <code>rtest</code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Jackson, D.A. (1995) PROTEST: a PROcustean randomization TEST of community environment concordance. <em>Ecosciences</em>, <b>2</b>, 297&ndash;303.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(doubs)
pca1 &lt;- dudi.pca(doubs$env, scal = TRUE, scann = FALSE)
pca2 &lt;- dudi.pca(doubs$fish, scal = FALSE, scann = FALSE)
proc1 &lt;- procuste(pca1$tab, pca2$tab)
protest1 &lt;- procuste.rtest(pca1$tab, pca2$tab, 999)
protest1
plot(protest1)
</code></pre>

<hr>
<h2 id='pta'>Partial Triadic Analysis of a K-tables</h2><span id='topic+pta'></span><span id='topic+print.pta'></span><span id='topic+plot.pta'></span>

<h3>Description</h3>

<p>performs a partial triadic analysis of a K-tables, 
using an object of class <code>ktab</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pta(X, scannf = TRUE, nf = 2)
## S3 method for class 'pta'
plot(x, xax = 1, yax = 2, option = 1:4, ...)
## S3 method for class 'pta'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pta_+3A_x">X</code></td>
<td>
<p>an object of class <code>ktab</code> where the arrays have 1) the same dimensions 2) the same names for columns 3) the same column weightings</p>
</td></tr>
<tr><td><code id="pta_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="pta_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="pta_+3A_x">x</code></td>
<td>
<p>an object of class 'pta'</p>
</td></tr>
<tr><td><code id="pta_+3A_xax">xax</code>, <code id="pta_+3A_yax">yax</code></td>
<td>
<p>the numbers of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="pta_+3A_option">option</code></td>
<td>
<p>an integer between 1 and 4, otherwise the 4 components of the plot are displayed</p>
</td></tr>
<tr><td><code id="pta_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class 'pta', sub-class of  'dudi' containing :
</p>
<table>
<tr><td><code>RV</code></td>
<td>
<p>a matrix with the all RV coefficients</p>
</td></tr>
<tr><td><code>RV.eig</code></td>
<td>
<p>a numeric vector with the all eigenvalues (interstructure)</p>
</td></tr>
<tr><td><code>RV.coo</code></td>
<td>
<p>a data frame with the scores of the arrays</p>
</td></tr>
<tr><td><code>tab.names</code></td>
<td>
<p>a vector of characters with the array names</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>an integer indicating the rank of the studied matrix</p>
</td></tr>
<tr><td><code>tabw</code></td>
<td>
<p>a numeric vector with the array weights</p>
</td></tr>
<tr><td><code>cw</code></td>
<td>
<p>a numeric vector with the column weights</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>a numeric vector with the row weights</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a numeric vector with the all eigenvalues (compromis)</p>
</td></tr>
<tr><td><code>cos2</code></td>
<td>
<p>a numeric vector with the <code class="reqn">\cos^2</code> between compromise and arrays</p>
</td></tr> 
<tr><td><code>tab</code></td>
<td>
<p>a data frame with the modified array</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>a data frame with the row coordinates</p>
</td></tr>
<tr><td><code>l1</code></td>
<td>
<p>a data frame with the row normed scores</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>a data frame with the column coordinates</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>a data frame with the column normed scores</p>
</td></tr>
<tr><td><code>Tli</code></td>
<td>
<p>a data frame with the row coordinates (each table)</p>
</td></tr>
<tr><td><code>Tco</code></td>
<td>
<p>a data frame with the column coordinates (each table)</p>
</td></tr>
<tr><td><code>Tcomp</code></td>
<td>
<p>a data frame with the principal components (each table)</p>
</td></tr>
<tr><td><code>Tax</code></td>
<td>
<p>a data frame with the principal axes (each table)</p>
</td></tr>
<tr><td><code>TL</code></td>
<td>
<p>a data frame with the factors for Tli</p>
</td></tr>
<tr><td><code>TC</code></td>
<td>
<p>a data frame with the factors for Tco</p>
</td></tr>
<tr><td><code>T4</code></td>
<td>
<p>a data frame with the factors for Tax and Tcomp</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pierre Bady <a href="mailto:pierre.bady@univ-lyon1.fr">pierre.bady@univ-lyon1.fr</a><br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Blanc, L., Chessel, D. and Dolédec, S. (1998) Etude de la stabilité temporelle des structures spatiales par Analyse d'une série de tableaux faunistiques totalement appariés. <em>Bulletin Français de la Pêche et de la Pisciculture</em>, <b>348</b>, 1&ndash;21.<br /><br />
Thioulouse, J., and D. Chessel. 1987. Les analyses multi-tableaux en écologie factorielle. I De la typologie d'état à la typologie de fonctionnement par l'analyse triadique. <em>Acta Oecologica, Oecologia Generalis</em>, <b>8</b>, 463&ndash;480.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
wit1 &lt;- withinpca(meaudret$env, meaudret$design$season, scan = FALSE, scal = "partial")
kta1 &lt;- ktab.within(wit1, colnames = rep(c("S1", "S2", "S3", "S4", "S5"), 4))
kta2 &lt;- t(kta1)
pta1 &lt;- pta(kta2, scann = FALSE)
pta1
plot(pta1)
</code></pre>

<hr>
<h2 id='quasieuclid'>Transformation of a distance matrice to a Euclidean one</h2><span id='topic+quasieuclid'></span>

<h3>Description</h3>

<p>transforms a distance matrix in a Euclidean one. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quasieuclid(distmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quasieuclid_+3A_distmat">distmat</code></td>
<td>
<p>an object of class <code>dist</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates a distance matrice with the positive eigenvalues of the Euclidean representation. <br /> 
Only for Euclidean distances which are not Euclidean for numeric approximations (for examples, in papers as the following example).
</p>


<h3>Value</h3>

<p>object of class <code>dist</code> containing a Euclidean distance matrice
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(yanomama)
geo &lt;- as.dist(yanomama$geo)
is.euclid(geo) # FALSE
geo1 &lt;- quasieuclid(geo)
is.euclid(geo1) # TRUE
par(mfrow = c(2,2))
lapply(yanomama, function(x) plot(as.dist(x), quasieuclid(as.dist(x))))

par(mfrow = c(1,1))</code></pre>

<hr>
<h2 id='randboot'>Bootstrap simulations</h2><span id='topic+as.krandboot'></span><span id='topic+print.krandboot'></span><span id='topic+as.randboot'></span><span id='topic+print.randboot'></span><span id='topic+randboot'></span>

<h3>Description</h3>

<p>Functions and classes to manage outputs of bootstrap
simulations for one (class <code>randboot</code>) or several (class <code>krandboot</code>) statistics</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.krandboot(obs, boot, quantiles = c(0.025, 0.975), names =
colnames(boot), call = match.call())
## S3 method for class 'krandboot'
print(x, ...)
as.randboot(obs, boot, quantiles = c(0.025, 0.975), call = match.call())
## S3 method for class 'randboot'
print(x, ...)
randboot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randboot_+3A_obs">obs</code></td>
<td>
<p>a value (class <code>randboot</code>) or a vector (class
<code>krandboot</code>) with observed statistics</p>
</td></tr>
<tr><td><code id="randboot_+3A_boot">boot</code></td>
<td>
<p>a vector (class <code>randboot</code>) or a matrix (class
<code>krandboot</code>) with the bootstrap values of the statistics</p>
</td></tr>
<tr><td><code id="randboot_+3A_quantiles">quantiles</code></td>
<td>
<p>a vector indicating the lower and upper quantiles to compute</p>
</td></tr>
<tr><td><code id="randboot_+3A_names">names</code></td>
<td>
<p>a vector of names for the statistics</p>
</td></tr>
<tr><td><code id="randboot_+3A_call">call</code></td>
<td>
<p>the matching call</p>
</td></tr>
<tr><td><code id="randboot_+3A_x">x</code></td>
<td>
<p>an object of class <code>randboot</code> or <code>krandboot</code></p>
</td></tr>
<tr><td><code id="randboot_+3A_object">object</code></td>
<td>
<p>an object on which bootstrap should be perform</p>
</td></tr>
<tr><td><code id="randboot_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>randboot</code> or <code>krandboot</code></p>


<h3>Author(s)</h3>

<p>Stéphane Dray (<a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>)</p>


<h3>References</h3>

<p>Carpenter, J. and Bithell, J. (2000) Bootstrap confidence
intervals: when, which, what? A practical guide for medical
statisticians.<em>Statistics in medicine</em>, 19, 1141-1164</p>


<h3>See Also</h3>

<p><code><a href="#topic+randboot.multiblock">randboot.multiblock</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## an example corresponding to 10 statistics and 100 repetitions
bt &lt;- as.krandboot(obs = rnorm(10), boot = matrix(rnorm(1000), nrow = 100))
bt
if(adegraphicsLoaded())
plot(bt) 

</code></pre>

<hr>
<h2 id='randboot.multiblock'>Bootstraped simulations for multiblock methods</h2><span id='topic+randboot.multiblock'></span>

<h3>Description</h3>

<p>Function to perform bootstraped simulations for multiblock
principal component analysis with instrumental variables or multiblock
partial least squares, in order to get confidence intervals for some parameters, <em>i.e.</em>, regression coefficients, variable and block importances</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiblock'
randboot(object, nrepet = 199, optdim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randboot.multiblock_+3A_object">object</code></td>
<td>
<p>an object of class multiblock created by <code><a href="#topic+mbpls">mbpls</a></code>
or <code><a href="#topic+mbpcaiv">mbpcaiv</a></code></p>
</td></tr>
<tr><td><code id="randboot.multiblock_+3A_nrepet">nrepet</code></td>
<td>
<p>integer indicating the number of repetitions</p>
</td></tr>
<tr><td><code id="randboot.multiblock_+3A_optdim">optdim</code></td>
<td>
<p>integer indicating the optimal number of dimensions, <em>i.e.</em>, the optimal number of global components to be introduced in the model</p>
</td></tr>
<tr><td><code id="randboot.multiblock_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing objects of class <code>krandboot</code></p>


<h3>Author(s)</h3>

<p>Stéphanie Bougeard (<a href="mailto:stephanie.bougeard@anses.fr">stephanie.bougeard@anses.fr</a>) and Stéphane Dray (<a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>)</p>


<h3>References</h3>

<p>Carpenter, J. and Bithell, J. (2000) Bootstrap confidence intervals: when, which, what? A practical guide for medical statisticians.<em>Statistics in medicine</em>, 19, 1141-1164.
</p>
<p>Bougeard, S. and Dray S. (2018) Supervised Multiblock Analysis in R with the ade4 Package. <em>Journal of Statistical Software</em>, <b>86</b> (1), 1-17. <a href="https://doi.org/10.18637/jss.v086.i01">doi:10.18637/jss.v086.i01</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mbpcaiv">mbpcaiv</a></code>, <code><a href="#topic+mbpls">mbpls</a></code>,
<code><a href="#topic+testdim.multiblock">testdim.multiblock</a></code>, <code><a href="#topic+as.krandboot">as.krandboot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chickenk)
Mortality &lt;- chickenk[[1]]
dudiY.chick &lt;- dudi.pca(Mortality, center = TRUE, scale = TRUE, scannf =
FALSE)
ktabX.chick &lt;- ktab.list.df(chickenk[2:5])
resmbpcaiv.chick &lt;- mbpcaiv(dudiY.chick, ktabX.chick, scale = TRUE,
option = "uniform", scannf = FALSE, nf = 4)
## nrepet should be higher for a real analysis
test &lt;- randboot(resmbpcaiv.chick, optdim = 4, nrepet = 10)
test
if(adegraphicsLoaded())
plot(test$bipc) 
</code></pre>

<hr>
<h2 id='randtest'>Class of the Permutation Tests (in C).</h2><span id='topic+randtest'></span><span id='topic+as.randtest'></span><span id='topic+plot.randtest'></span><span id='topic+print.randtest'></span>

<h3>Description</h3>

<p><code>randtest</code> is a generic function. It proposes methods for the following objects <code>between</code>, <code>discrimin</code>, <code>coinertia</code> <code>...</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randtest(xtest, ...)
as.randtest(sim, obs, alter = c("greater", "less", "two-sided"), 
  output = c("light", "full"), call = match.call(), subclass = NULL)

## S3 method for class 'randtest'
plot(x, nclass = 10, coeff = 1, ...)
## S3 method for class 'randtest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randtest_+3A_xtest">xtest</code></td>
<td>
<p>an object used to select a method</p>
</td></tr>
<tr><td><code id="randtest_+3A_x">x</code></td>
<td>
<p>an object of class <code>randtest</code></p>
</td></tr>
<tr><td><code id="randtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods; in <code>plot.randtest</code> to <code>hist</code></p>
</td></tr>
<tr><td><code id="randtest_+3A_output">output</code></td>
<td>
<p>a character string specifying if all simulations should be stored (<code>"full"</code>). This was the default until <code>ade4</code> 1.7-5. Now, by default (<code>"light"</code>), only the distribution    of simulated values is stored in element <code>plot</code> as produced by the <code>hist</code> function.</p>
</td></tr>
<tr><td><code id="randtest_+3A_nclass">nclass</code></td>
<td>
<p>a number of intervals for the histogram. Ignored if object output is <code>"light"</code></p>
</td></tr>
<tr><td><code id="randtest_+3A_coeff">coeff</code></td>
<td>
<p>to fit the magnitude of the graph. Ignored if object output is <code>"light"</code></p>
</td></tr>
<tr><td><code id="randtest_+3A_sim">sim</code></td>
<td>
<p>a numeric vector of simulated values</p>
</td></tr>
<tr><td><code id="randtest_+3A_obs">obs</code></td>
<td>
<p>a numeric vector of an observed value</p>
</td></tr>
<tr><td><code id="randtest_+3A_alter">alter</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;greater&quot; (default), &quot;less&quot; or &quot;two-sided&quot;</p>
</td></tr>
<tr><td><code id="randtest_+3A_call">call</code></td>
<td>
<p>a call order</p>
</td></tr>
<tr><td><code id="randtest_+3A_subclass">subclass</code></td>
<td>
<p>a character vector indicating the subclasses associated to the returned object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the alternative hypothesis is &quot;greater&quot;, a p-value is estimated as: (number of random values equal to or greater than the observed one +
1)/(number of permutations + 1). The null hypothesis is rejected if the p-value is less than the significance level. If the alternative
hypothesis is &quot;less&quot;, a p-value is estimated as: (number of random values equal to or less than the observed one + 1)/(number of
permutations + 1). Again, the null hypothesis is rejected if the p-value is less than the significance level. Lastly, if the alternative
hypothesis is &quot;two-sided&quot;, the estimation of the p-value is equivalent to the one used for &quot;greater&quot; except that random and observed values are
firstly centered (using the average of random values) and secondly transformed to their absolute values. Note that this is only suitable
for symmetric random distribution.
</p>


<h3>Value</h3>

<p><code>as.randtest</code> returns a list of class <code>randtest</code>.<br />
<code>plot.randtest</code> draws the simulated values histograms and the position of the observed value.
</p>


<h3>See Also</h3>

<p><a href="#topic+randtest.amova">randtest.amova</a>, <a href="#topic+randtest.between">randtest.between</a>, <a href="#topic+randtest.coinertia">randtest.coinertia</a>, <a href="#topic+randtest.discrimin">randtest.discrimin</a>, 
<a href="#topic+randtest.dpcoa">randtest.dpcoa</a>, <a href="#topic+randtest.pcaiv">randtest.pcaiv</a>, <a href="#topic+rtest">rtest</a>, <a href="#topic+rtest.between">rtest.between</a>, <a href="#topic+rtest.discrimin">rtest.discrimin</a>, 
<a href="#topic+RV.rtest">RV.rtest</a>, <a href="#topic+RVdist.randtest">RVdist.randtest</a>, <a href="#topic+mantel.randtest">mantel.randtest</a>, <a href="#topic+mantel.rtest">mantel.rtest</a>, <a href="#topic+procuste.randtest">procuste.randtest</a>, <a href="#topic+procuste.rtest">procuste.rtest</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(2,2))
for (x0 in c(2.4,3.4,5.4,20.4)) {
  l0 &lt;- as.randtest(sim = rnorm(200), obs = x0)
  print(l0)
  plot(l0,main=paste("p.value = ", round(l0$pvalue, dig = 5)))
}
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='randtest.amova'>
Permutation tests on an analysis of molecular variance (in C).</h2><span id='topic+randtest.amova'></span>

<h3>Description</h3>

<p>Tests the components of covariance with permutation processes described by Excoffier et al. (1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'amova'
randtest(xtest, nrepet = 99, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randtest.amova_+3A_xtest">xtest</code></td>
<td>
<p>an object of class <code>amova</code></p>
</td></tr>
<tr><td><code id="randtest.amova_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="randtest.amova_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class <code>krandtest</code> or <code>randtest</code>
</p>


<h3>Author(s)</h3>

<p>Sandrine Pavoine <a href="mailto:pavoine@mnhn.fr">pavoine@mnhn.fr</a>
</p>


<h3>References</h3>

<p>Excoffier, L., Smouse, P.E. and Quattro, J.M. (1992) Analysis of molecular variance inferred from
metric distances among DNA haplotypes: application to human mitochondrial DNA restriction data.
<em>Genetics</em>, <b>131</b>, 479&ndash;491.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humDNAm)
amovahum &lt;- amova(humDNAm$samples, sqrt(humDNAm$distances), humDNAm$structures)
amovahum
randtesthum &lt;- randtest(amovahum, 49)
plot(randtesthum)
</code></pre>

<hr>
<h2 id='randtest.between'>Monte-Carlo Test on the between-groups inertia percentage (in C).
</h2><span id='topic+randtest.between'></span>

<h3>Description</h3>

<p>Performs a Monte-Carlo test on the between-groups inertia percentage. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'between'
randtest(xtest, nrepet = 999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randtest.between_+3A_xtest">xtest</code></td>
<td>
<p>an object of class <code>between</code></p>
</td></tr>
<tr><td><code id="randtest.between_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="randtest.between_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the class <code>randtest</code>
</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse <a href="mailto:Jean.Thioulouse@univ-lyon1.fr">Jean.Thioulouse@univ-lyon1.fr</a></p>


<h3>References</h3>

<p>Romesburg, H. C. (1985) Exploring, confirming and randomization tests. <em>Computers and Geosciences</em>, <b>11</b>, 19&ndash;37.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
pca1 &lt;- dudi.pca(meaudret$env, scan = FALSE, nf = 3)
rand1 &lt;- randtest(bca(pca1, meaudret$design$season, scan = FALSE), 99)
rand1
plot(rand1, main = "Monte-Carlo test")
</code></pre>

<hr>
<h2 id='randtest.coinertia'>Monte-Carlo test on a Co-inertia analysis (in C).</h2><span id='topic+randtest.coinertia'></span>

<h3>Description</h3>

<p>Performs a Monte-Carlo test on a Co-inertia analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coinertia'
randtest(xtest, nrepet = 999, fixed=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randtest.coinertia_+3A_xtest">xtest</code></td>
<td>
<p>an object of class <code>coinertia</code></p>
</td></tr>
<tr><td><code id="randtest.coinertia_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="randtest.coinertia_+3A_fixed">fixed</code></td>
<td>
<p>when non uniform row weights are used in the coinertia analysis,
this parameter must be the number of the table that should be kept fixed in the permutations</p>
</td></tr>
<tr><td><code id="randtest.coinertia_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the class <code>randtest</code>
</p>


<h3>Note</h3>

<p>A testing procedure based on the total coinertia of the analysis
is available by the function <code>randtest.coinertia</code>. The function
allows to deal with various analyses for the two tables. The test is
based on random permutations of the rows of the two tables. If the row
weights are not uniform, mean and variances are recomputed for each
permutation (PCA); for MCA, tables are recentred and column weights are recomputed. If weights are computed using the data contained in one
table (e.g. COA), you must fix this table and permute only the rows of
the other table. The case of decentred PCA (PCA where centers are
entered by the user) is not yet implemented. If you want to use the
testing procedure for this case, you must firstly center the table and then perform a
non-centered PCA on the modified table. The case where one table is
treated by hill-smith analysis (mix of quantitative and qualitative
variables) will be soon implemented.</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse <a href="mailto:Jean.Thioulouse@univ-lyon1.fr">Jean.Thioulouse@univ-lyon1.fr</a> modified by Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a></p>


<h3>References</h3>

<p>Dolédec, S. and Chessel, D. (1994) Co-inertia analysis: an alternative method for
studying species-environment relationships. <em>Freshwater Biology</em>, <b>31</b>, 277&ndash;294.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(doubs)
dudi1 &lt;- dudi.pca(doubs$env, scale = TRUE, scan = FALSE, nf = 3)
dudi2 &lt;- dudi.pca(doubs$fish, scale = FALSE, scan = FALSE, nf = 2)
coin1 &lt;- coinertia(dudi1,dudi2, scan = FALSE, nf = 2)
plot(randtest(coin1))
 </code></pre>

<hr>
<h2 id='randtest.discrimin'>
Monte-Carlo Test on a Discriminant Analysis (in C).</h2><span id='topic+randtest.discrimin'></span>

<h3>Description</h3>

<p>Test of the sum of a discriminant analysis eigenvalues (divided by the rank). Non parametric version of the Pillai's test. It authorizes any weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'discrimin'
randtest(xtest, nrepet = 999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randtest.discrimin_+3A_xtest">xtest</code></td>
<td>
<p>an object of class <code>discrimin</code></p>
</td></tr>
<tr><td><code id="randtest.discrimin_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="randtest.discrimin_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class <code>randtest</code>
</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse <a href="mailto:Jean.Thioulouse@univ-lyon1.fr">Jean.Thioulouse@univ-lyon1.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
pca1 &lt;- dudi.pca(meaudret$env, scan = FALSE, nf = 3)
rand1 &lt;- randtest(discrimin(pca1, meaudret$design$season, scan = FALSE), 99)
rand1
#Monte-Carlo test
#Observation: 0.3035 
#Call: as.randtest(sim = sim, obs = obs)
#Based on 999 replicates
#Simulated p-value: 0.001 
plot(rand1, main = "Monte-Carlo test")
summary.manova(manova(as.matrix(meaudret$env)~meaudret$design$season), "Pillai")
#                   Df Pillai approx F num Df den Df  Pr(&gt;F)    
# meaudret$design$season  3   2.73    11.30     27     30 1.6e-09 ***
# Residuals         16                                          
# ---
# Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 
# 2.731/9 = 0.3034
</code></pre>

<hr>
<h2 id='randtest.dpcoa'>
Permutation test for double principal coordinate analysis (DPCoA)
</h2><span id='topic+randtest.dpcoa'></span>

<h3>Description</h3>

<p><code>randtest.dpcoa</code> calculates the ratio of beta to gamma diversity associated with DPCoA and compares the observed value to values obtained by permuting data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dpcoa'
randtest(xtest, model = c("1p","1s"), nrepet = 99,
alter = c("greater", "less", "two-sided"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randtest.dpcoa_+3A_xtest">xtest</code></td>
<td>
<p>an object of class <code>dpcoa</code></p>
</td></tr>
<tr><td><code id="randtest.dpcoa_+3A_model">model</code></td>
<td>
<p>either &quot;1p&quot;, &quot;1s&quot;, or the name of a function, (see details)</p>
</td></tr>
<tr><td><code id="randtest.dpcoa_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations to perform, the default is 99</p>
</td></tr>
<tr><td><code id="randtest.dpcoa_+3A_alter">alter</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;greater&quot; (default), &quot;less&quot; or &quot;two-sided&quot;</p>
</td></tr>
<tr><td><code id="randtest.dpcoa_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model 1p permutes the names of the columns of the abundance matrix.
Model 1s permutes the abundances of the categories (columns of the abundance matrix, usually species) within collections (rows of the abundance matrix, usually communities). Only the categories with positive abundances are permuted. 
The null models were introduced in Hardy (2008).
</p>
<p>Other null model can be used by entering the name of a function. For example, loading the <code>picante</code> package of R, if <code>model=randomizeMatrix</code>, then the permutations will follow function <code>randomizeMatrix</code> available in picante. Any function can be used provided it returns an abundance matrix of similar size as the observed abundance matrix. Parameters of the chosen function can be added to <code>randtest.dpcoa</code>. For example, using parameter <code>null.model</code> of <code>randomizeMatrix</code>, the following command can be used:
<code>randtest.dpcoa(xtest, model = randomizeMatrix, null.model = "trialswap")</code>
</p>


<h3>Value</h3>

<p>an object of class <code>randtest</code>
</p>


<h3>Author(s)</h3>

<p>Sandrine Pavoine <a href="mailto:pavoine@mnhn.fr">pavoine@mnhn.fr</a>
</p>


<h3>References</h3>

<p>Hardy, O. (2008) Testing the spatial phylogenetic structure of local communities: statistical performances of different null models and test statistics on a locally neutral community. <em>Journal of Ecology</em>, <b>96</b>, 914&ndash;926
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpcoa">dpcoa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humDNAm)
dpcoahum &lt;- dpcoa(data.frame(t(humDNAm$samples)), sqrt(humDNAm$distances), scan = FALSE, nf = 2)
randtest(dpcoahum)
</code></pre>

<hr>
<h2 id='randtest.pcaiv'>Monte-Carlo Test on the percentage of explained (i.e.
constrained) inertia</h2><span id='topic+randtest.pcaiv'></span><span id='topic+randtest.pcaivortho'></span>

<h3>Description</h3>

<p>Performs a Monte-Carlo test on on the percentage of explained (i.e.
constrained) inertia. The statistic is the ratio of the inertia (sum
of eigenvalues) of the
constrained analysis divided by the inertia of the unconstrained analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcaiv'
randtest(xtest, nrepet = 99, ...)
## S3 method for class 'pcaivortho'
randtest(xtest, nrepet = 99, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randtest.pcaiv_+3A_xtest">xtest</code></td>
<td>
<p>an object of class <code>pcaiv</code>, <code>pcaivortho</code> or <code>caiv</code></p>
</td></tr>
<tr><td><code id="randtest.pcaiv_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="randtest.pcaiv_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the class <code>randtest</code>
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>, original code
by Raphaël Pélissier</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rpjdl)
millog &lt;- log(rpjdl$mil + 1)
coa1 &lt;- dudi.coa(rpjdl$fau, scann = FALSE)
caiv1 &lt;- pcaiv(coa1, millog, scan = FALSE)
randtest(caiv1)
</code></pre>

<hr>
<h2 id='randxval'>Two-fold cross-validation</h2><span id='topic+randxval'></span><span id='topic+krandxval'></span><span id='topic+as.krandxval'></span><span id='topic+print.krandxval'></span><span id='topic+as.randxval'></span><span id='topic+print.randxval'></span>

<h3>Description</h3>

<p>Functions and classes to manage outputs of two-fold
cross-validation for one (class <code>randxval</code>) or several (class
<code>krandxval</code>) statistics</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.krandxval(RMSEc, RMSEv, quantiles = c(0.25, 0.75), names =
colnames(RMSEc), call = match.call())
## S3 method for class 'krandxval'
print(x, ...)
as.randxval(RMSEc, RMSEv, quantiles = c(0.25, 0.75), call =
match.call())
## S3 method for class 'randxval'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randxval_+3A_rmsec">RMSEc</code></td>
<td>
<p>a vector (class <code>randxval</code>) or a matrix (class
<code>krandxval</code>) with the root-mean-square error of calibration
(statistics as columns and repetions as rows)</p>
</td></tr>
<tr><td><code id="randxval_+3A_rmsev">RMSEv</code></td>
<td>
<p>a vector (class <code>randxval</code>) or a matrix (class
<code>krandxval</code>) with the root-mean-square error of validation
(statistics as columns and repetions as rows)</p>
</td></tr>
<tr><td><code id="randxval_+3A_quantiles">quantiles</code></td>
<td>
<p>a vector indicating the lower and upper quantiles to compute</p>
</td></tr>
<tr><td><code id="randxval_+3A_names">names</code></td>
<td>
<p>a vector of names for the statistics</p>
</td></tr>
<tr><td><code id="randxval_+3A_call">call</code></td>
<td>
<p>the matching call</p>
</td></tr>
<tr><td><code id="randxval_+3A_x">x</code></td>
<td>
<p>an object of class <code>randxval</code> or <code>krandxval</code></p>
</td></tr>
<tr><td><code id="randxval_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>randxval</code> or <code>krandxval</code></p>


<h3>Author(s)</h3>

<p>Stéphane Dray (<a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>)</p>


<h3>References</h3>

<p>Stone M. (1974) Cross-validatory choice and assessment of
statistical predictions. <em>Journal of the Royal Statistical
Society</em>, 36, 111-147</p>


<h3>See Also</h3>

<p><code><a href="#topic+testdim.multiblock">testdim.multiblock</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## an example corresponding to 10 statistics and 100 repetitions
cv &lt;- as.krandxval(RMSEc = matrix(rnorm(1000), nrow = 100), RMSEv =
matrix(rnorm(1000, mean = 1), nrow = 100))
cv
if(adegraphicsLoaded())
plot(cv) 

</code></pre>

<hr>
<h2 id='rankrock'>Ordination Table</h2><span id='topic+rankrock'></span>

<h3>Description</h3>

<p>This data set gives the classification in order of preference of 10 music groups by 51 students. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rankrock)</code></pre>


<h3>Format</h3>

<p>A data frame with 10 rows and 51 columns.<br />
Each column contains the rank (1 for the favorite, ..., 10 for the less appreciated)<br />
attributed to the group by a student.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rankrock)
dudi1 &lt;- dudi.pca(rankrock, scannf = FALSE, nf = 3)
if(adegraphicsLoaded()) {
  g &lt;- scatter(dudi1, row.plab.cex = 1.5)
} else {
  scatter(dudi1, clab.r = 1.5)
}</code></pre>

<hr>
<h2 id='reconst'>Reconstitution of Data from a Duality Diagram</h2><span id='topic+reconst'></span><span id='topic+reconst.pca'></span><span id='topic+reconst.coa'></span>

<h3>Description</h3>

<p>Generic Function for the reconstitution of data from 
a principal component analysis or
a correspondence analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconst (dudi, ...)
## S3 method for class 'pca'
reconst(dudi, nf = 1, ...) 
## S3 method for class 'coa'
reconst(dudi, nf = 1, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconst_+3A_dudi">dudi</code></td>
<td>
<p>an object of class <code>dudi</code> used to select a method: pca or coa</p>
</td></tr>
<tr><td><code id="reconst_+3A_nf">nf</code></td>
<td>
<p>an integer indicating the number of kept axes for the reconstitution</p>
</td></tr>
<tr><td><code id="reconst_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame containing the reconstituted data
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Gabriel, K.R. (1978) Least-squares approximation of matrices by additive and multiplicative models. <em>Journal of the Royal Statistical Society</em>, B , <b>40</b>, 186&ndash;196.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rhone)
dd1 &lt;- dudi.pca(rhone$tab, nf = 2, scann = FALSE)
rh1 &lt;- reconst(dd1, 1)
rh2 &lt;- reconst(dd1, 2)
par(mfrow = c(4,4))
par(mar = c(2.6,2.6,1.1,1.1))
for (i in 1:15) {
    plot(rhone$date, rhone$tab[,i])
    lines(rhone$date, rh1[,i], lty = 2)
    lines(rhone$date, rh2[,i], lty = 1)
    ade4:::scatterutil.sub(names(rhone$tab)[i], 2, "topright")}

data(chats)
chatsw &lt;- data.frame(t(chats))
chatscoa &lt;- dudi.coa(chatsw, scann = FALSE)
model0 &lt;- reconst(chatscoa, 0)
round(model0,3)
round(chisq.test(chatsw)$expected,3)
chisq.test(chatsw)$statistic
sum(((chatsw-model0)^2)/model0)
effectif &lt;- sum(chatsw)
sum(chatscoa$eig)*effectif
model1 &lt;- reconst(chatscoa, 1)
round(model1, 3)
sum(((chatsw-model1)^2)/model0)
sum(chatscoa$eig[-1])*effectif
</code></pre>

<hr>
<h2 id='rhizobium'>Genetic structure of two nitrogen fixing bacteria influenced
by geographical isolation and host specialization</h2><span id='topic+rhizobium'></span>

<h3>Description</h3>

<p>The data set concerns fixing bacteria belonging to the genus Sinorhizobium
(Rhizobiaceae) associated with the plant genus Medicago
(Fabaceae). It is a combination of two data sets fully available online from GenBank and
published in two recent papers (see reference below). The complete sampling
procedure is described in the Additional file 3 of the reference below. We delineated six populations
according to geographical origin (France: F, Tunisia Hadjeb:
TH, Tunisia Enfidha: TE), the host plant (<em>M. truncatula</em>
or similar symbiotic specificity: T, M. laciniata: L), and the
taxonomical status of bacteria (S. meliloti: mlt, S. medicae:
mdc). Each population will be called hereafter according
to the three above criteria, e.g. THLmlt is the population
sampled in Tunisia at Hadjeb from M. laciniata nodules
which include S. meliloti isolates. S. medicae interacts with
M. truncatula while S. meliloti interacts with both M. laciniata
(S. meliloti bv. medicaginis) and M. truncatula (S.
meliloti bv. meliloti). The numbers of individuals
are respectively 46 for FTmdc, 43 for FTmlt, 20 for TETmdc,
24 for TETmlt, 20 for TELmlt, 42 for THTmlt and 20
for THLmlt.
</p>
<p>Four different intergenic spacers (IGS), IGSNOD,
IGSEXO, IGSGAB, and IGSRKP, distributed on the different
replication units of the model strain 1021 of S.
meliloti bv. meliloti had been sequenced to
characterize each bacterial isolate (DNA extraction and
sequencing procedures are described in an additional file). 
It is noteworthy that the IGSNOD
marker is located within the nod gene cluster and that specific
alleles at these loci determine the ability of S. meliloti
strains to interact with either M. laciniata or M. truncatula. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rhizobium)</code></pre>


<h3>Format</h3>

<p><code>rhizobium</code> is a list of 2 components.
</p>

<ul>
<li><p> dnaobj: list of dna lists. Each dna list corresponds to a locus. For a given locus, the dna list provides the
dna sequences The ith sequences of all loci corresponds to the ith individual of the data set.
</p>
</li>
<li><p> pop: The list of the populations which each individual sequence belongs to.
</p>
</li></ul>


<h3>Source</h3>

<p>Pavoine, S. and Bailly, X. (2007) New analysis for consistency among markers in the study of genetic diversity: 
development and application to the description of bacterial diversity. <em>BMC Evolutionary Biology</em>, <b>7</b>, e156.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The functions used below require the package ape
data(rhizobium)
if(requireNamespace("ape", quietly = TRUE)) {
dat &lt;- prep.mdpcoa(rhizobium[[1]], rhizobium[[2]], 
    model = c("F84", "F84", "F84", "F81"),
    pairwise.deletion = TRUE)
sam &lt;- dat$sam
dis &lt;- dat$dis
# The distances should be Euclidean. 
# Several transformations exist to render a distance object Euclidean 
# (see functions cailliez, lingoes and quasieuclid in the ade4 package). 
# Here we use the quasieuclid function.
dis &lt;- lapply(dis, quasieuclid)
mdpcoa1 &lt;- mdpcoa(sam, dis, scann = FALSE, nf = 2)

# Reference analysis
plot(mdpcoa1)

# Differences between the loci
kplot(mdpcoa1)

# Alleles projected on the population maps.
kplotX.mdpcoa(mdpcoa1)
}

</code></pre>

<hr>
<h2 id='rhone'>Physico-Chemistry Data</h2><span id='topic+rhone'></span>

<h3>Description</h3>

<p>This data set gives for 39 water samples a physico-chemical description 
with the number of sample date and the flows of three tributaries. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rhone)</code></pre>


<h3>Format</h3>

<p><code>rhone</code> is a list of 3 components.
</p>

<dl>
<dt>tab</dt><dd><p>is a data frame with 39 water samples and 15 physico-chemical variables.</p>
</dd>
<dt>date</dt><dd><p>is a vector of the sample date (in days).</p>
</dd>
<dt>disch</dt><dd><p>is a data frame with 39 water samples and the flows of the three tributaries.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Carrel, G., Barthelemy, D., Auda, Y. and Chessel, D. (1986)
Approche graphique de l'analyse en composantes principales normée : utilisation en hydrobiologie.
<em>Acta Oecologica, Oecologia Generalis</em>, <b>7</b>, 189&ndash;203.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rhone)
pca1 &lt;- dudi.pca(rhone$tab, nf = 2, scann = FALSE)
rh1 &lt;- reconst(pca1, 1)
rh2 &lt;- reconst(pca1, 2)
par(mfrow = c(4,4))
par(mar = c(2.6,2.6,1.1,1.1))
for (i in 1:15) {
    plot(rhone$date, rhone$tab[,i])
    lines(rhone$date, rh1[,i], lwd = 2)
    lines(rhone$date, rh2[,i])
    ade4:::scatterutil.sub(names(rhone$tab)[i], 2, "topright")
}
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='rlq'>RLQ analysis </h2><span id='topic+rlq'></span><span id='topic+print.rlq'></span><span id='topic+plot.rlq'></span><span id='topic+summary.rlq'></span><span id='topic+randtest.rlq'></span>

<h3>Description</h3>

<p>RLQ analysis performs a double inertia analysis of two arrays (R and Q) with a link expressed by a contingency table (L).
The rows of L correspond to the rows of R and the columns of L correspond to the rows of Q.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlq(dudiR, dudiL, dudiQ, scannf = TRUE, nf = 2)
## S3 method for class 'rlq'
print(x, ...)
## S3 method for class 'rlq'
plot(x, xax = 1, yax = 2, ...)
## S3 method for class 'rlq'
summary(object, ...)
## S3 method for class 'rlq'
randtest(xtest,nrepet = 999, modeltype = 6,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlq_+3A_dudir">dudiR</code></td>
<td>
<p> a duality diagram providing from one of the functions dudi.hillsmith, dudi.pca, ... </p>
</td></tr>
<tr><td><code id="rlq_+3A_dudil">dudiL</code></td>
<td>
<p> a duality diagram of the function dudi.coa </p>
</td></tr>
<tr><td><code id="rlq_+3A_dudiq">dudiQ</code></td>
<td>
<p> a duality diagram providing from one of the functions dudi.hillsmith, dudi.pca, ... </p>
</td></tr>
<tr><td><code id="rlq_+3A_scannf">scannf</code></td>
<td>
<p> a logical value indicating whether the eigenvalues bar plot should be displayed </p>
</td></tr>
<tr><td><code id="rlq_+3A_nf">nf</code></td>
<td>
<p> if scannf FALSE, an integer indicating the number of kept axes </p>
</td></tr>
<tr><td><code id="rlq_+3A_x">x</code></td>
<td>
<p> an rlq object </p>
</td></tr>
<tr><td><code id="rlq_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="rlq_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="rlq_+3A_object">object</code></td>
<td>
<p> an rlq object </p>
</td></tr>
<tr><td><code id="rlq_+3A_xtest">xtest</code></td>
<td>
<p> an rlq object </p>
</td></tr>
<tr><td><code id="rlq_+3A_nrepet">nrepet</code></td>
<td>
<p> the number of permutations </p>
</td></tr>
<tr><td><code id="rlq_+3A_modeltype">modeltype</code></td>
<td>
<p>the model used to permute data(2: permute rows of R,
4: permute rows of Q, 5: permute both, 6: sequential approach, see
ter Braak et al. 2012)</p>
</td></tr>
<tr><td><code id="rlq_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class 'dudi', sub-class 'rlq' containing:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>call</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>rank</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>a numeric value indicating the number of kept axes</p>
</td></tr>
<tr><td><code>RV</code></td>
<td>
<p>a numeric value, the RV coefficient</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a numeric vector with all the eigenvalues</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>a numeric vector with the rows weigths (crossed array)</p>
</td></tr>
<tr><td><code>cw</code></td>
<td>
<p>a numeric vector with the columns weigths (crossed array)</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p>a crossed array (CA)</p>
</td></tr> 
<tr><td><code>li</code></td>
<td>
<p>R col = CA row: coordinates</p>
</td></tr>
<tr><td><code>l1</code></td>
<td>
<p>R col = CA row: normed scores</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>Q col = CA column: coordinates</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>Q col = CA column: normed scores</p>
</td></tr>
<tr><td><code>lR</code></td>
<td>
<p>the row coordinates (R)</p>
</td></tr>
<tr><td><code>mR</code></td>
<td>
<p>the normed row scores (R)</p>
</td></tr>
<tr><td><code>lQ</code></td>
<td>
<p>the row coordinates (Q)</p>
</td></tr>
<tr><td><code>mQ</code></td>
<td>
<p>the normed row scores (Q)</p>
</td></tr>
<tr><td><code>aR</code></td>
<td>
<p>the axis onto co-inertia axis (R)</p>
</td></tr>
<tr><td><code>aQ</code></td>
<td>
<p>the axis onto co-inertia axis (Q)</p>
</td></tr>
</table>


<h3>WARNING </h3>

<p>IMPORTANT : row weights for <code>dudiR</code> and <code>dudiQ</code> must be taken from <code>dudiL</code>.
</p>


<h3>Note</h3>

<p>A testing procedure based on the total coinertia of the RLQ
analysis is available by the function <code>randtest.rlq</code>. The
function allows to deal with various analyses for tables R and Q. Means and variances are recomputed for each
permutation (PCA); for MCA, tables are recentred and column weights are recomputed.The
case of decentred PCA (PCA where centers are entered by the user) for
R or Q is not yet implemented. If you want to use the testing
procedure for this case, you must firstly center the table and then perform a non-centered PCA on the modified table.</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a></p>


<h3>References</h3>

 
<p>Doledec, S., Chessel, D., ter Braak, C.J.F. and Champely, S. (1996) 
Matching species traits to environmental variables: a new three-table ordination method. <em>Environmental and Ecological Statistics</em>, 
<b>3</b>, 143&ndash;166.
</p>
<p>Dray, S., Pettorelli, N., Chessel, D. (2002) Matching data sets from two different spatial samplings. 
<em>Journal of Vegetation Science</em>, <b>13</b>, 867&ndash;874.
</p>
<p>Dray, S. and Legendre, P. (2008) 
Testing the species traits-environment relationships: the fourth-corner
problem revisited. <em>Ecology</em>,
<b>89</b>, 3400&ndash;3412.
</p>
<p>ter Braak, C., Cormont, A., Dray, S. (2012) Improved testing of species
traits-environment relationships in the fourth corner problem.
<em>Ecology</em>, <b>93</b>, 1525&ndash;1526.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+coinertia">coinertia</a></code>,   <code><a href="#topic+fourthcorner">fourthcorner</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   data(aviurba)
   coa1 &lt;- dudi.coa(aviurba$fau, scannf = FALSE, nf = 2)
   dudimil &lt;- dudi.hillsmith(aviurba$mil, scannf = FALSE, nf = 2, row.w = coa1$lw)
   duditrait &lt;- dudi.hillsmith(aviurba$traits, scannf = FALSE, nf = 2, row.w = coa1$cw)
   rlq1 &lt;- rlq(dudimil, coa1, duditrait, scannf = FALSE, nf = 2)
   plot(rlq1)
   summary(rlq1)
   randtest(rlq1)
   fourthcorner.rlq(rlq1,type="Q.axes")
   fourthcorner.rlq(rlq1,type="R.axes")

</code></pre>

<hr>
<h2 id='rpjdl'>Avifauna and Vegetation</h2><span id='topic+rpjdl'></span>

<h3>Description</h3>

<p>This data set gives the abundance of 51 species and 8 environmental variables 
in 182 sites. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rpjdl)</code></pre>


<h3>Format</h3>

<p><code>rpjdl</code> is a list of 5 components.
</p>

<dl>
<dt>fau</dt><dd><p>is the faunistic array of 182 sites (rows) and 51 species (columns).</p>
</dd>
<dt>mil</dt><dd><p>is the array of environmental variables : 182 sites and 8 variables.</p>
</dd>
<dt>frlab</dt><dd><p>is a vector of the names of species in French.</p>
</dd>
<dt>lalab</dt><dd><p>is a vector of the names of species in Latin.</p>
</dd>
<dt>lab</dt><dd><p>is a vector of the simplified labels of species.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Prodon, R. and Lebreton, J.D. (1981)
Breeding avifauna of a Mediterranean succession : the holm oak and cork oak series in the eastern Pyrénées.
1 : Analysis and modelling of the structure gradient.
<em>Oïkos</em>, <b>37</b>, 21&ndash;38.
</p>
<p>Lebreton, J. D., Chessel D., Prodon R. and Yoccoz N. (1988)
L'analyse des relations espèces-milieu par l'analyse canonique des correspondances.
I. Variables de milieu quantitatives.
<em>Acta Oecologica, Oecologia Generalis</em>, <b>9</b>, 53&ndash;67.
</p>


<h3>References</h3>

<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps048.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps048.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rpjdl)
coa1 &lt;- dudi.coa(rpjdl$fau, scann = FALSE)
pca1 &lt;- dudi.pca(rpjdl$fau, scal = FALSE, scann = FALSE)

if(adegraphicsLoaded()) {
  g1 &lt;- s.distri(coa1$l1, rpjdl$fau, xax = 2, yax = 1, starSize = 0.3, 
                 ellipseSize = 0, plab.cex = 0)
  g2 &lt;- s.distri(pca1$l1, rpjdl$fau, xax = 2, yax = 1, starSize = 0.3, 
                 ellipseSize = 0, plab.cex = 0)
} else {
  s.distri(coa1$l1, rpjdl$fau, 2, 1, cstar = 0.3, cell = 0)
  s.distri(pca1$l1, rpjdl$fau, 2, 1, cstar = 0.3, cell = 0)
}

caiv1 &lt;- pcaiv(coa1, rpjdl$mil, scan = FALSE)
plot(caiv1)

## End(Not run)</code></pre>

<hr>
<h2 id='rtest'>Class of the Permutation Tests (in R).</h2><span id='topic+rtest'></span>

<h3>Description</h3>

<p>rtest is a generic function. It proposes methods for the following objects <code>between</code>, <code>discrimin</code>, <code>procuste</code> <code>...</code><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    rtest(xtest, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtest_+3A_xtest">xtest</code></td>
<td>
<p>an object used to select a method</p>
</td></tr>
<tr><td><code id="rtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods; in <code>plot.randtest</code> to <code>hist</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rtest</code> returns an object of class <code>randtest</code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>See Also</h3>

<p><code><a href="#topic+RV.rtest">RV.rtest</a></code>, <code><a href="#topic+mantel.rtest">mantel.rtest</a></code>, <code><a href="#topic+procuste.rtest">procuste.rtest</a></code>, <code><a href="#topic+randtest">randtest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(2, 2))
for (x0 in c(2.4, 3.4, 5.4, 20.4)) {
    l0 &lt;- as.randtest(sim = rnorm(200), obs = x0)
    print(l0)
    plot(l0, main = paste("p.value = ", round(l0$pvalue, dig = 5)))
}
par(mfrow = c(1, 1))
</code></pre>

<hr>
<h2 id='rtest.between'>Monte-Carlo Test on the between-groups inertia percentage (in R).
</h2><span id='topic+rtest.between'></span>

<h3>Description</h3>

<p>Performs a Monte-Carlo test on the between-groups inertia percentage. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'between'
rtest(xtest, nrepet = 99, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtest.between_+3A_xtest">xtest</code></td>
<td>
<p>an object of class <code>between</code></p>
</td></tr>
<tr><td><code id="rtest.between_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="rtest.between_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the class <code>rtest</code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>References</h3>

<p>Romesburg, H. C. (1985) Exploring, confirming and randomization tests. <em>Computers and Geosciences</em>, <b>11</b>, 19&ndash;37.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
pca1 &lt;- dudi.pca(meaudret$env, scan = FALSE, nf = 3)
rand1 &lt;- rtest(bca(pca1, meaudret$design$season, scan = FALSE), 99)
rand1
plot(rand1, main = "Monte-Carlo test")
</code></pre>

<hr>
<h2 id='rtest.discrimin'>
Monte-Carlo Test on a Discriminant Analysis (in R).
</h2><span id='topic+rtest.discrimin'></span>

<h3>Description</h3>

<p>Test of the sum of a discriminant analysis eigenvalues (divided by the rank). Non parametric version of the Pillai's test. It authorizes any weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'discrimin'
rtest(xtest, nrepet = 99, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtest.discrimin_+3A_xtest">xtest</code></td>
<td>
<p>an object of class <code>discrimin</code></p>
</td></tr>
<tr><td><code id="rtest.discrimin_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="rtest.discrimin_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class <code>rtest</code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
pca1 &lt;- dudi.pca(meaudret$env, scan = FALSE, nf = 3)
rand1 &lt;- rtest(discrimin(pca1, meaudret$design$season, scan = FALSE), 99)
rand1
#Monte-Carlo test
#Observation: 0.3035 
#Call: as.rtest(sim = sim, obs = obs)
#Based on 999 replicates
#Simulated p-value: 0.001 
plot(rand1, main = "Monte-Carlo test")
summary.manova(manova(as.matrix(meaudret$env)~meaudret$design$season), "Pillai")
#                         Df Pillai approx F num Df den Df  Pr(&gt;F)    
# meaudret$design$season  3   2.73    11.30     27     30 1.6e-09 ***
# Residuals         16                                          
# ---
# Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 
# 2.731/9 = 0.3034
</code></pre>

<hr>
<h2 id='RV.randtest'>Monte-Carlo Test on the sum of eigenvalues of a co-inertia analysis (in C++ with Rcpp).</h2><span id='topic+RV.randtest'></span>

<h3>Description</h3>

<p>performs a Monte-Carlo Test on the sum of eigenvalues of a co-inertia analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RV.randtest(df1, df2, nrepet = 999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RV.randtest_+3A_df1">df1</code>, <code id="RV.randtest_+3A_df2">df2</code></td>
<td>
<p>two data frames with the same rows</p>
</td></tr>
<tr><td><code id="RV.randtest_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="RV.randtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class 'randtest'
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel and Jean Thioulouse</p>


<h3>References</h3>

<p>Heo, M. &amp; Gabriel, K.R. (1997) A permutation test of association between configurations by means of the RV coefficient. 
Communications in Statistics - Simulation and Computation, <b>27</b>, 843-856.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(doubs)
pca1 &lt;- dudi.pca(doubs$env, scal = TRUE, scann = FALSE)
pca2 &lt;- dudi.pca(doubs$fish, scal = FALSE, scann = FALSE)
rv1 &lt;- RV.randtest(pca1$tab, pca2$tab, 99)
rv1
plot(rv1)
</code></pre>

<hr>
<h2 id='RV.rtest'>Monte-Carlo Test on the sum of eigenvalues of a co-inertia analysis (in R).</h2><span id='topic+RV.rtest'></span>

<h3>Description</h3>

<p>performs a Monte-Carlo Test on the sum of eigenvalues of a co-inertia analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RV.rtest(df1, df2, nrepet = 99, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RV.rtest_+3A_df1">df1</code>, <code id="RV.rtest_+3A_df2">df2</code></td>
<td>
<p>two data frames with the same rows</p>
</td></tr>
<tr><td><code id="RV.rtest_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="RV.rtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class 'rtest'
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>References</h3>

<p>Heo, M. &amp; Gabriel, K.R. (1997) A permutation test of association between configurations by means of the RV coefficient. 
Communications in Statistics - Simulation and Computation, <b>27</b>, 843-856.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(doubs)
pca1 &lt;- dudi.pca(doubs$env, scal = TRUE, scann = FALSE)
pca2 &lt;- dudi.pca(doubs$fish, scal = FALSE, scann = FALSE)
rv1 &lt;- RV.rtest(pca1$tab, pca2$tab, 99)
rv1
plot(rv1)
</code></pre>

<hr>
<h2 id='RVdist.randtest'>Tests of randomization on the correlation between two distance matrices (in R).</h2><span id='topic+RVdist.randtest'></span>

<h3>Description</h3>

<p>performs a RV Test between two distance matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVdist.randtest(m1, m2, nrepet = 999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVdist.randtest_+3A_m1">m1</code>, <code id="RVdist.randtest_+3A_m2">m2</code></td>
<td>
<p>two Euclidean matrices</p>
</td></tr>
<tr><td><code id="RVdist.randtest_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="RVdist.randtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class 'randtest'
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>References</h3>

<p>Heo, M. &amp; Gabriel, K.R. (1997) A permutation test of association between configurations by means of the RV coefficient. 
Communications in Statistics - Simulation and Computation, <b>27</b>, 843-856.
</p>

<hr>
<h2 id='RVintra.randtest'>Monte-Carlo Test on the sum of eigenvalues of a within-class co-inertia analysis (in C++ with Rcpp).</h2><span id='topic+RVintra.randtest'></span>

<h3>Description</h3>

<p>performs a Monte-Carlo Test on the sum of eigenvalues of a within-class co-inertia analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVintra.randtest(df1, df2, fac, nrepet = 999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVintra.randtest_+3A_df1">df1</code>, <code id="RVintra.randtest_+3A_df2">df2</code></td>
<td>
<p>two data frames with the same rows</p>
</td></tr>
<tr><td><code id="RVintra.randtest_+3A_fac">fac</code></td>
<td>
<p>the factor defining classes</p>
</td></tr>
<tr><td><code id="RVintra.randtest_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="RVintra.randtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class 'randtest'
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel and Jean Thioulouse</p>


<h3>References</h3>

<p>Heo, M. &amp; Gabriel, K.R. (1997) A permutation test of association between configurations by means of the RV coefficient. 
Communications in Statistics - Simulation and Computation, <b>27</b>, 843-856.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
pca1 &lt;- dudi.pca(meaudret$env, scan = FALSE, nf = 4)
pca2 &lt;- dudi.pca(meaudret$spe, scal = FALSE, scan = FALSE, nf = 4)
wit1 &lt;- wca(pca1, meaudret$design$season, scan = FALSE, nf = 2)
wit2 &lt;- wca(pca2, meaudret$design$season, scan = FALSE, nf = 2)
coiw &lt;- coinertia(wit1, wit2, scann = FALSE)
rv1 &lt;- RVintra.randtest(pca1$tab, pca2$tab, meaudret$design$season, nrep=999)
rv1
plot(rv1)
</code></pre>

<hr>
<h2 id='s.arrow'>Plot of the factorial maps for the projection of a vector basis</h2><span id='topic+s.arrow'></span>

<h3>Description</h3>

<p>performs the scatter diagrams of the projection of a vector basis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.arrow(dfxy, xax = 1, yax = 2, label = row.names(dfxy), 
    clabel = 1, pch = 20, cpoint = 0, boxes = TRUE, edge = TRUE, origin = c(0,0), 
    xlim = NULL, ylim = NULL, grid = TRUE, addaxes = TRUE, cgrid = 1, 
    sub = "", csub = 1.25, possub = "bottomleft", pixmap = NULL, 
    contour = NULL, area = NULL, add.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.arrow_+3A_dfxy">dfxy</code></td>
<td>
<p>a data frame containing the two columns for the axes</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_xax">xax</code></td>
<td>
<p>the column number of x in <code>dfxy</code></p>
</td></tr>
<tr><td><code id="s.arrow_+3A_yax">yax</code></td>
<td>
<p>the column number of y in <code>dfxy</code></p>
</td></tr>
<tr><td><code id="s.arrow_+3A_label">label</code></td>
<td>
<p>a vector of strings of characters for the point labels</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_clabel">clabel</code></td>
<td>
<p>if not NULL, a character size for the labels used with par(&quot;cex&quot;)*<code>clabel</code></p>
</td></tr>
<tr><td><code id="s.arrow_+3A_pch">pch</code></td>
<td>
<p>if <code>cpoint</code> &gt; 0, an integer specifying the symbol or the single character to be used in plotting points</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with par(&quot;cex&quot;)*<code>cpoint</code>. If zero, no points are drawn.</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_boxes">boxes</code></td>
<td>
<p>if TRUE, labels are framed</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_edge">edge</code></td>
<td>
<p>a logical value indicating whether the arrows should be plotted</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, by default c(0,0) the origin of axes. The arrows begin at <code>cent</code>.</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x-axis, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the y-axis, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_addaxes">addaxes</code></td>
<td>
<p>a logical value indicating whether the axes should be plotted</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with <code>par("cex")*cgrid</code>, to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="s.arrow_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the legend position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_pixmap">pixmap</code></td>
<td>
<p>an object 'pixmap' displayed in the map background</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_contour">contour</code></td>
<td>
<p>a data frame with 4 columns to plot the contour of the map : each row gives a segment (x1,y1,x2,y2)</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_area">area</code></td>
<td>
<p>a data frame of class 'area' to plot a set of surface units in contour</p>
</td></tr>
<tr><td><code id="s.arrow_+3A_add.plot">add.plot</code></td>
<td>
<p>if TRUE uses the current graphics window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>Examples</h3>

<pre><code class='language-R'>s.arrow(cbind.data.frame(runif(55,-2,3), runif(55,-3,2)))
</code></pre>

<hr>
<h2 id='s.chull'>Plot of the factorial maps with polygons of contour by level of a factor</h2><span id='topic+s.chull'></span>

<h3>Description</h3>

<p>performs the scatter diagrams with polygons of contour by level of a factor. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.chull(dfxy, fac, xax = 1, yax = 2, 
    optchull = c(0.25, 0.5, 0.75, 1), label = levels(fac), clabel = 1, 
    cpoint = 0, col = rep(1, length(levels(fac))), xlim = NULL, ylim = NULL,
    grid = TRUE, addaxes = TRUE, origin = c(0,0), include.origin = TRUE, 
    sub = "", csub = 1, possub = "bottomleft", cgrid = 1, pixmap = NULL, 
    contour = NULL, area = NULL, add.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.chull_+3A_dfxy">dfxy</code></td>
<td>
<p>a data frame containing the two columns for the axes</p>
</td></tr>
<tr><td><code id="s.chull_+3A_fac">fac</code></td>
<td>
<p>a factor partioning the rows of the data frame in classes</p>
</td></tr>
<tr><td><code id="s.chull_+3A_xax">xax</code></td>
<td>
<p>the column number of x in <code>dfxy</code></p>
</td></tr>
<tr><td><code id="s.chull_+3A_yax">yax</code></td>
<td>
<p>the column number of y in <code>dfxy</code></p>
</td></tr>
<tr><td><code id="s.chull_+3A_optchull">optchull</code></td>
<td>
<p>the number of convex hulls and their interval</p>
</td></tr>
<tr><td><code id="s.chull_+3A_label">label</code></td>
<td>
<p>a vector of strings of characters for the point labels</p>
</td></tr>
<tr><td><code id="s.chull_+3A_clabel">clabel</code></td>
<td>
<p>if not NULL, a character size for the labels, used with  <code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="s.chull_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")*cpoint</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="s.chull_+3A_col">col</code></td>
<td>
<p>a vector of colors used to draw each class in a different color</p>
</td></tr>
<tr><td><code id="s.chull_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x axis, if NULL, they are computed</p>
</td></tr>
<tr><td><code id="s.chull_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the y axis, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.chull_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="s.chull_+3A_addaxes">addaxes</code></td>
<td>
<p>a logical value indicating whether the axes should be plotted</p>
</td></tr>
<tr><td><code id="s.chull_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example c(0,0) the origin axes</p>
</td></tr>
<tr><td><code id="s.chull_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should be belonged to the graph space</p>
</td></tr>
<tr><td><code id="s.chull_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="s.chull_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="s.chull_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="s.chull_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with par(&quot;cex&quot;)* <code>cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="s.chull_+3A_pixmap">pixmap</code></td>
<td>
<p>an object 'pixmap' displayed in the map background</p>
</td></tr>
<tr><td><code id="s.chull_+3A_contour">contour</code></td>
<td>
<p>a data frame with 4 columns to plot the contour of the map : each row gives a segment (x1,y1,x2,y2)</p>
</td></tr>
<tr><td><code id="s.chull_+3A_area">area</code></td>
<td>
<p>a data frame of class 'area' to plot a set of surface units in contour</p>
</td></tr>
<tr><td><code id="s.chull_+3A_add.plot">add.plot</code></td>
<td>
<p>if TRUE uses the current graphics window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy &lt;- cbind.data.frame(x = runif(200,-1,1), y = runif(200,-1,1))
posi &lt;- factor(xy$x &gt; 0) : factor(xy$y &gt; 0)
coul &lt;- c("black", "red", "green", "blue")

if(adegraphicsLoaded()) {
  s.class(xy, posi, ppoi.cex = 1.5, chullSize = c(0.25, 0.5, 0.75, 1), ellipseSize = 0, 
    starSize = 0, ppoly = list(col = "white", border = coul))
} else {
  s.chull(xy, posi, cpoi = 1.5, col = coul)
}</code></pre>

<hr>
<h2 id='s.class'>Plot of factorial maps with representation of point classes</h2><span id='topic+s.class'></span>

<h3>Description</h3>

<p>performs the scatter diagrams with representation of point classes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.class(dfxy, fac, wt = rep(1, length(fac)), xax = 1, 
    yax = 2, cstar = 1, cellipse = 1.5, axesell = TRUE, 
    label = levels(fac), clabel = 1, cpoint = 1, pch = 20, 
    col = rep(1, length(levels(fac))), xlim = NULL, ylim = NULL, 
    grid = TRUE, addaxes = TRUE, origin = c(0,0), 
    include.origin = TRUE, sub = "", csub = 1, possub = "bottomleft", 
    cgrid = 1, pixmap = NULL, contour = NULL, area = NULL, add.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.class_+3A_dfxy">dfxy</code></td>
<td>
<p>a data frame containing the two columns for the axes</p>
</td></tr>
<tr><td><code id="s.class_+3A_fac">fac</code></td>
<td>
<p>a factor partitioning the rows of the data frame in classes</p>
</td></tr>
<tr><td><code id="s.class_+3A_wt">wt</code></td>
<td>
<p>a vector of the point weightings of the data frame used for computing the means (star centers) and the ellipses of dispersion</p>
</td></tr>
<tr><td><code id="s.class_+3A_xax">xax</code></td>
<td>
<p>the column number of x in <code>dfxy</code></p>
</td></tr>
<tr><td><code id="s.class_+3A_yax">yax</code></td>
<td>
<p>the column number of y in <code>dfxy</code></p>
</td></tr>
<tr><td><code id="s.class_+3A_cstar">cstar</code></td>
<td>
<p>a number between 0 and 1 which defines the length of the star size</p>
</td></tr>
<tr><td><code id="s.class_+3A_cellipse">cellipse</code></td>
<td>
<p>a positive coefficient for the inertia ellipse size</p>
</td></tr>
<tr><td><code id="s.class_+3A_axesell">axesell</code></td>
<td>
<p>a logical value indicating whether the ellipse axes should be drawn</p>
</td></tr>
<tr><td><code id="s.class_+3A_label">label</code></td>
<td>
<p>a vector of strings of characters for the point labels</p>
</td></tr>
<tr><td><code id="s.class_+3A_clabel">clabel</code></td>
<td>
<p>if not NULL, a character size for the labels, used with <code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="s.class_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")*cpoint</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="s.class_+3A_pch">pch</code></td>
<td>
<p>if <code>cpoint</code> &gt; 0, an integer specifying the symbol or the single character to be used in plotting points</p>
</td></tr>
<tr><td><code id="s.class_+3A_col">col</code></td>
<td>
<p>a vector of colors used to draw each class in a different color</p>
</td></tr>
<tr><td><code id="s.class_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.class_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the y, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.class_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="s.class_+3A_addaxes">addaxes</code></td>
<td>
<p>a logical value indicating whether the axes should be plotted</p>
</td></tr>
<tr><td><code id="s.class_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example c(0,0) the origin axes</p>
</td></tr>
<tr><td><code id="s.class_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should be belonged to the graph space</p>
</td></tr>
<tr><td><code id="s.class_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="s.class_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="s.class_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="s.class_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with par(&quot;cex&quot;)* <code>cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="s.class_+3A_pixmap">pixmap</code></td>
<td>
<p>an object 'pixmap' displayed in the map background</p>
</td></tr>
<tr><td><code id="s.class_+3A_contour">contour</code></td>
<td>
<p>a data frame with 4 columns to plot the contour of the map : each row gives a segment (x1,y1,x2,y2)</p>
</td></tr>
<tr><td><code id="s.class_+3A_area">area</code></td>
<td>
<p>a data frame of class 'area' to plot a set of surface units in contour</p>
</td></tr>
<tr><td><code id="s.class_+3A_add.plot">add.plot</code></td>
<td>
<p>if TRUE uses the current graphics window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!adegraphicsLoaded()) {
  xy &lt;- cbind.data.frame(x = runif(200, -1, 1), y = runif(200, -1, 1))
  posi &lt;- factor(xy$x &gt; 0) : factor(xy$y &gt; 0)
  coul &lt;- c("black", "red", "green", "blue")
  par(mfrow = c(2, 2))
  s.class(xy, posi, cpoi = 2)
  s.class(xy, posi, cell = 0, cstar = 0.5)
  s.class(xy, posi, cell = 2, axesell = FALSE, csta = 0, col = coul)
  s.chull(xy, posi, cpoi = 1)
  par(mfrow = c(1, 1))
  
  ## Not run: 
  data(banque)
  dudi1 &lt;- dudi.acm(banque, scannf = FALSE)
  coul = rainbow(length(levels(banque[, 20])))
  par(mfrow = c(2, 2))
  s.label(dudi1$li, sub = "Factorial map from ACM", csub = 1.5, 
    possub = "topleft")
  s.class(dudi1$li, banque[, 20], sub = names(banque)[20], 
    possub = "bottomright", cell = 0, cstar = 0.5, cgrid = 0, csub = 1.5)
  s.class(dudi1$li, banque[, 20], csta = 0, cell = 2, cgrid = 0, 
    clab = 1.5)
  s.class(dudi1$li, banque[, 20], sub = names(banque)[20], 
    possub = "topright", cgrid = 0, col = coul)
  par(mfrow = c(1, 1))
  
  par(mfrow = n2mfrow(ncol(banque)))
  for(i in 1:(ncol(banque)))
    s.class(dudi1$li, banque[, i], clab = 1.5, sub = names(banque)[i], 
      csub = 2, possub = "topleft", cgrid = 0, csta = 0, cpoi = 0)
  s.label(dudi1$li, clab = 0, sub = "Common background")
  par(mfrow = c(1, 1))

## End(Not run)
}</code></pre>

<hr>
<h2 id='s.corcircle'>Plot of the factorial maps of a correlation circle</h2><span id='topic+s.corcircle'></span>

<h3>Description</h3>

<p>performs the scatter diagram of a correlation circle. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.corcircle(dfxy, xax = 1, yax = 2, label = row.names(df), 
    clabel = 1, grid = TRUE, sub = "", csub = 1, possub = "bottomleft", 
    cgrid = 0, fullcircle = TRUE, box = FALSE, add.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.corcircle_+3A_dfxy">dfxy</code></td>
<td>
<p>a data frame with two coordinates </p>
</td></tr>
<tr><td><code id="s.corcircle_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="s.corcircle_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="s.corcircle_+3A_label">label</code></td>
<td>
<p>a vector of strings of characters for the point labels</p>
</td></tr>
<tr><td><code id="s.corcircle_+3A_clabel">clabel</code></td>
<td>
<p>if not NULL, a character size for the labels, used with  <code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="s.corcircle_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="s.corcircle_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="s.corcircle_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="s.corcircle_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="s.corcircle_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with par(&quot;cex&quot;)*<code>cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="s.corcircle_+3A_fullcircle">fullcircle</code></td>
<td>
<p>a logical value indicating whether the complete circle sould be drawn</p>
</td></tr>
<tr><td><code id="s.corcircle_+3A_box">box</code></td>
<td>
<p>a logical value indcating whether a box should be drawn</p>
</td></tr>
<tr><td><code id="s.corcircle_+3A_add.plot">add.plot</code></td>
<td>
<p>if TRUE uses the current graphics window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!adegraphicsLoaded()) {
  data (olympic)
  dudi1 &lt;- dudi.pca(olympic$tab, scan = FALSE) # a normed PCA
  par(mfrow = c(2, 2))
  s.corcircle(dudi1$co, lab = names(olympic$tab))
  s.corcircle(dudi1$co, cgrid = 0, full = FALSE, clab = 0.8)
  s.corcircle(dudi1$co, lab = as.character(1:11), cgrid = 2, 
    full = FALSE, sub = "Correlation circle", csub = 2.5, 
    possub = "bottomleft", box = TRUE)
  s.arrow(dudi1$co, clab = 1)
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='s.distri'>Plot of a frequency distribution</h2><span id='topic+s.distri'></span>

<h3>Description</h3>

<p>performs the scatter diagram of a frequency distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.distri(dfxy, dfdistri, xax = 1, yax = 2, cstar = 1, 
    cellipse = 1.5, axesell = TRUE, label = names(dfdistri), 
    clabel = 0, cpoint = 1, pch = 20, xlim = NULL, ylim = NULL, 
    grid = TRUE, addaxes = TRUE, origin = c(0,0), 
    include.origin = TRUE, sub = "", csub = 1, possub = "bottomleft", 
    cgrid = 1, pixmap = NULL, contour = NULL, area = NULL, add.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.distri_+3A_dfxy">dfxy</code></td>
<td>
<p>a data frame containing two columns for the axes</p>
</td></tr>
<tr><td><code id="s.distri_+3A_dfdistri">dfdistri</code></td>
<td>
<p>a data frame containing the mass distributions in columns</p>
</td></tr>
<tr><td><code id="s.distri_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="s.distri_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="s.distri_+3A_cstar">cstar</code></td>
<td>
<p>a number between 0 and 1 which defines the length of the star size</p>
</td></tr>
<tr><td><code id="s.distri_+3A_cellipse">cellipse</code></td>
<td>
<p>a positive coefficient for the inertia ellipse size</p>
</td></tr>
<tr><td><code id="s.distri_+3A_axesell">axesell</code></td>
<td>
<p>a logical value indicating whether the ellipse axes should be drawn</p>
</td></tr>
<tr><td><code id="s.distri_+3A_label">label</code></td>
<td>
<p>a vector of strings of characters for the distribution centers labels</p>
</td></tr>
<tr><td><code id="s.distri_+3A_clabel">clabel</code></td>
<td>
<p>if not NULL, a character size for the labels, used with <code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="s.distri_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")*cpoint</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="s.distri_+3A_pch">pch</code></td>
<td>
<p>if <code>cpoint</code> &gt; 0, an integer specifying the symbol or the single character to be used in plotting points</p>
</td></tr>
<tr><td><code id="s.distri_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.distri_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the y, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.distri_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="s.distri_+3A_addaxes">addaxes</code></td>
<td>
<p>a logical value indicating whether the axes should be plotted</p>
</td></tr>
<tr><td><code id="s.distri_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example c(0,0) the origin axes</p>
</td></tr>
<tr><td><code id="s.distri_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should be belonged to the graph space</p>
</td></tr>
<tr><td><code id="s.distri_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="s.distri_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="s.distri_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="s.distri_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with par(&quot;cex&quot;)* <code>cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="s.distri_+3A_pixmap">pixmap</code></td>
<td>
<p>an object 'pixmap' displayed in the map background</p>
</td></tr>
<tr><td><code id="s.distri_+3A_contour">contour</code></td>
<td>
<p>a data frame with 4 columns to plot the contour of the map : each row gives a segment (x1,y1,x2,y2)</p>
</td></tr>
<tr><td><code id="s.distri_+3A_area">area</code></td>
<td>
<p>a data frame of class 'area' to plot a set of surface units in contour</p>
</td></tr>
<tr><td><code id="s.distri_+3A_add.plot">add.plot</code></td>
<td>
<p>if TRUE uses the current graphics window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!adegraphicsLoaded()) {
  xy &lt;- cbind.data.frame(x = runif(200, -1, 1), y = runif(200, -1, 1))
  distri &lt;- data.frame(w1 = rpois(200, xy$x * (xy$x &gt; 0)))
  s.value(xy, distri$w1, cpoi = 1)
  s.distri(xy, distri, add.p = TRUE)
  
  w1 &lt;- as.numeric((xy$x&gt; 0) &amp; (xy$y &gt; 0))
  w2 &lt;- ((xy$x &gt; 0) &amp; (xy$y &lt; 0)) * (1 - xy$y) * xy$x
  w3 &lt;- ((xy$x &lt; 0) &amp; (xy$y &gt; 0)) * (1 - xy$x) * xy$y
  w4 &lt;- ((xy$x &lt; 0) &amp; (xy$y &lt; 0)) * xy$y * xy$x
  
  distri &lt;- data.frame(a = w1 / sum(w1), b = w2 / sum(w2), 
    c = w3 / sum(w3), d = w4 / sum(w4))
  s.value(xy, unlist(apply(distri, 1, sum)), cleg = 0, csi = 0.75)
  s.distri(xy, distri, clab = 2, add.p = TRUE)
  
  data(rpjdl)
  xy &lt;- dudi.coa(rpjdl$fau, scan = FALSE)$li
  par(mfrow = c(3, 4))
  for (i in c(1, 5, 8, 20, 21, 23, 26, 33, 36, 44, 47, 49)) {
    s.distri(xy, rpjdl$fau[, i], cell = 1.5, sub = rpjdl$frlab[i], 
      csub = 2, cgrid = 1.5)}
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='s.hist'>Display of a scatterplot and its two marginal histograms</h2><span id='topic+s.hist'></span>

<h3>Description</h3>

<p>performs a scatterplot and the two marginal histograms of each axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.hist(dfxy, xax = 1, yax = 2, cgrid = 1, cbreaks = 2, adjust = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.hist_+3A_dfxy">dfxy</code></td>
<td>
<p>a data frame with two coordinates </p>
</td></tr>
<tr><td><code id="s.hist_+3A_xax">xax</code></td>
<td>
<p>column for the x axis </p>
</td></tr>
<tr><td><code id="s.hist_+3A_yax">yax</code></td>
<td>
<p>column for the y axis </p>
</td></tr>
<tr><td><code id="s.hist_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with <code>par("cex")*cgrid</code> to indicate the mesh of the grid </p>
</td></tr>
<tr><td><code id="s.hist_+3A_cbreaks">cbreaks</code></td>
<td>
<p>a parameter used to define the numbers of cells for the histograms. By default,
two cells are defined for each interval of the grid displayed in <code>s.label</code>. With an increase of the integer <code>cbreaks</code>, 
the number of cells increases as well.</p>
</td></tr>
<tr><td><code id="s.hist_+3A_adjust">adjust</code></td>
<td>
<p>a parameter passed to <code>density</code> to display a kernel density estimation</p>
</td></tr>
<tr><td><code id="s.hist_+3A_...">...</code></td>
<td>
<p>further arguments passed from the <code>s.label</code> for the scatter plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rpjdl)
coa1 &lt;- dudi.coa(rpjdl$fau, scannf = FALSE, nf = 4)
s.hist(coa1$li)
s.hist(coa1$li, cgrid = 2, cbr = 3, adj = 0.5, clab = 0)
s.hist(coa1$co, cgrid = 2, cbr = 3, adj = 0.5, clab = 0)
</code></pre>

<hr>
<h2 id='s.image'> Graph of a variable using image and contour </h2><span id='topic+s.image'></span>

<h3>Description</h3>

<p>performs a scatterplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.image(dfxy, z, xax = 1, yax = 2, span = 0.5, xlim = NULL, ylim = NULL, 
  kgrid = 2, scale = TRUE, grid = FALSE, addaxes = FALSE, cgrid = 0, 
  include.origin = FALSE, origin = c(0, 0), sub = "", csub = 1, 
  possub = "topleft", neig = NULL, cneig = 1, image.plot = TRUE, 
  contour.plot = TRUE, pixmap = NULL, contour = NULL, area = NULL, 
  add.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.image_+3A_dfxy">dfxy</code></td>
<td>
<p> a data frame containing the two columns for the axes </p>
</td></tr>
<tr><td><code id="s.image_+3A_z">z</code></td>
<td>
<p> a vector of values on the <code>dfxy</code> rows </p>
</td></tr>
<tr><td><code id="s.image_+3A_xax">xax</code></td>
<td>
<p> the column number of x in <code>dfxy</code> </p>
</td></tr>
<tr><td><code id="s.image_+3A_yax">yax</code></td>
<td>
<p> the column number of y in <code>dfxy</code> </p>
</td></tr>
<tr><td><code id="s.image_+3A_span">span</code></td>
<td>
<p> the parameter alpha which controls the degree of smoothing </p>
</td></tr>
<tr><td><code id="s.image_+3A_xlim">xlim</code></td>
<td>
<p> the ranges to be encompassed by the x-axis, if NULL they are computed </p>
</td></tr>
<tr><td><code id="s.image_+3A_ylim">ylim</code></td>
<td>
<p> the ranges to be encompassed by the y-axis, if NULL they are computed </p>
</td></tr>
<tr><td><code id="s.image_+3A_kgrid">kgrid</code></td>
<td>
<p> a number of points used to locally estimate the level line through the nodes of the grid, 
used by <code>kgrid*sqrt(length(z))</code> </p>
</td></tr>
<tr><td><code id="s.image_+3A_scale">scale</code></td>
<td>
<p> if TRUE, data are centered and reduced </p>
</td></tr>
<tr><td><code id="s.image_+3A_grid">grid</code></td>
<td>
<p> if TRUE, the background grid is traced </p>
</td></tr>
<tr><td><code id="s.image_+3A_addaxes">addaxes</code></td>
<td>
<p> a logical value indicating whether the axes should be plotted </p>
</td></tr>
<tr><td><code id="s.image_+3A_cgrid">cgrid</code></td>
<td>
<p> a character size, parameter used with par(&quot;cex&quot;)* <code>cgrid</code> to indicate the mesh of the grid </p>
</td></tr>
<tr><td><code id="s.image_+3A_include.origin">include.origin</code></td>
<td>
<p> a logical value indicating whether the point &quot;origin&quot; should be belonged to the graph space </p>
</td></tr>
<tr><td><code id="s.image_+3A_origin">origin</code></td>
<td>
<p> the fixed point in the graph space, for example c(0,0) the origin axes </p>
</td></tr>
<tr><td><code id="s.image_+3A_sub">sub</code></td>
<td>
<p> a string of characters to be inserted as legend </p>
</td></tr>
<tr><td><code id="s.image_+3A_csub">csub</code></td>
<td>
<p> a character size for the legend, used with <code>par("cex")*csub</code> </p>
</td></tr>
<tr><td><code id="s.image_+3A_possub">possub</code></td>
<td>
<p> a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;) </p>
</td></tr>
<tr><td><code id="s.image_+3A_neig">neig</code></td>
<td>
<p> an object of class <code>neig</code> </p>
</td></tr>
<tr><td><code id="s.image_+3A_cneig">cneig</code></td>
<td>
<p> a size for the neighbouring graph lines used with <code>par("lwd")*cneig</code> </p>
</td></tr>
<tr><td><code id="s.image_+3A_image.plot">image.plot</code></td>
<td>
<p> if TRUE, the image is traced </p>
</td></tr>
<tr><td><code id="s.image_+3A_contour.plot">contour.plot</code></td>
<td>
<p> if TRUE, the contour lines are plotted </p>
</td></tr>
<tr><td><code id="s.image_+3A_pixmap">pixmap</code></td>
<td>
<p> an object 'pixmap' displayed in the map background </p>
</td></tr>
<tr><td><code id="s.image_+3A_contour">contour</code></td>
<td>
<p> a data frame with 4 columns to plot the contour of the map : each row gives a segment (x1,y1,x2,y2) </p>
</td></tr>
<tr><td><code id="s.image_+3A_area">area</code></td>
<td>
<p> a data frame of class 'area' to plot a set of surface units in contour </p>
</td></tr>
<tr><td><code id="s.image_+3A_add.plot">add.plot</code></td>
<td>
<p> if TRUE uses the current graphics window </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!adegraphicsLoaded()) {
  if(requireNamespace("splancs", quietly = TRUE)) {
    wxy &lt;- data.frame(expand.grid(-3:3, -3:3))
    names(wxy) &lt;- c("x", "y")
    z &lt;- (1 / sqrt(2)) * exp(-(wxy$x ^ 2 + wxy$y ^ 2) / 2)
    par(mfrow = c(2, 2))
    s.value(wxy, z)
    s.image(wxy, z)
    s.image(wxy, z, kgrid = 5)
    s.image(wxy, z, kgrid = 15)
    par(mfrow = c(1, 1))
  }
  
  ## Not run: 
  data(t3012)
  if(requireNamespace("splancs", quietly = TRUE)) {
    par(mfrow = c(3, 4))
    for(k in 1:12)
      s.image(t3012$xy, scalewt(t3012$temp[, k]), kgrid = 3)
    par(mfrow = c(1, 1))
  }
      
  data(elec88)
  if(requireNamespace("splancs", quietly = TRUE)) {
    par(mfrow = c(3,4))
    for(k in 1:12)
      s.image(t3012$xy, scalewt(t3012$temp[, k]), kgrid = 3, sub = names(t3012$temp)[k],
        csub = 3, area = elec88$area)
    par(mfrow = c(1, 1))
  }
  
## End(Not run)
}</code></pre>

<hr>
<h2 id='s.kde2d'> Scatter Plot with Kernel Density Estimate </h2><span id='topic+s.kde2d'></span>

<h3>Description</h3>

<p>performs a scatter of points without labels by a kernel Density Estimation in One or Two Dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.kde2d(dfxy, xax = 1, yax = 2, pch = 20, cpoint = 1, neig = NULL, cneig = 2, 
    xlim = NULL, ylim = NULL, grid = TRUE, addaxes = TRUE, cgrid = 1, 
    include.origin = TRUE, origin = c(0, 0), sub = "", csub = 1.25, 
    possub = "bottomleft", pixmap = NULL, contour = NULL, 
    area = NULL, add.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.kde2d_+3A_dfxy">dfxy</code></td>
<td>
<p> a data frame with at least two coordinates </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_xax">xax</code></td>
<td>
<p> the column number for the x-axis </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_yax">yax</code></td>
<td>
<p> the column number for the y-axis</p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_pch">pch</code></td>
<td>
<p> if <code>cpoint</code> &gt; 0, an integer specifying the symbol or the
single character to be used in plotting points </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_cpoint">cpoint</code></td>
<td>
<p> a character size for plotting the points, used with
<code>par("cex")*cpoint</code>. If zero, no points are drawn </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_neig">neig</code></td>
<td>
<p> a neighbouring graph </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_cneig">cneig</code></td>
<td>
<p> a size for the neighbouring graph lines used with
par(&quot;lwd&quot;)*<code>cneig</code> </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_xlim">xlim</code></td>
<td>
<p> the ranges to be encompassed by the x axis, if NULL, they are
computed </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_ylim">ylim</code></td>
<td>
<p> the ranges to be encompassed by the y axis, if NULL, they are
computed </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_grid">grid</code></td>
<td>
<p> a logical value indicating whether a grid in the background
of the plot should be drawn </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_addaxes">addaxes</code></td>
<td>
<p> a logical value indicating whether the axes should be plotted </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_cgrid">cgrid</code></td>
<td>
<p> a character size, parameter used with par(&quot;cex&quot;)* 'cgrid' to
indicate the mesh of the grid </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_include.origin">include.origin</code></td>
<td>
<p> a logical value indicating whether the point &quot;origin&quot;
should be belonged to the graph space </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_origin">origin</code></td>
<td>
<p> the fixed point in the graph space, for example c(0,0) the
origin axes </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_sub">sub</code></td>
<td>
<p> a string of characters to be inserted as legend </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_csub">csub</code></td>
<td>
<p> a character size for the legend, used with <code>par("cex")*csub</code> </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_possub">possub</code></td>
<td>
<p> a string of characters indicating the sub-title position
(&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;) </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_pixmap">pixmap</code></td>
<td>
<p> an object <code>pixmap</code> displayed in the map background </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_contour">contour</code></td>
<td>
<p> a data frame with 4 columns to plot the contour of the map :
each row gives a segment (x1,y1,x2,y2) </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_area">area</code></td>
<td>
<p> a data frame of class 'area' to plot a set of surface units
in contour </p>
</td></tr>
<tr><td><code id="s.kde2d_+3A_add.plot">add.plot</code></td>
<td>
<p> if TRUE uses the current graphics window </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p> Daniel Chessel  
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To recognize groups of points
if(!adegraphicsLoaded()) {
  data(rpjdl)
  coa1 &lt;- dudi.coa(rpjdl$fau, scannf = FALSE, nf = 3)
  s.kde2d(coa1$li)
}
</code></pre>

<hr>
<h2 id='s.label'>Scatter Plot</h2><span id='topic+s.label'></span>

<h3>Description</h3>

<p>performs the scatter diagrams with labels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.label(dfxy, xax = 1, yax = 2, label = row.names(dfxy), 
    clabel = 1, pch = 20, cpoint = if (clabel == 0) 1 else 0, boxes = TRUE,
    neig = NULL, cneig = 2, xlim = NULL, ylim = NULL, grid = TRUE, 
    addaxes = TRUE, cgrid = 1, include.origin = TRUE, origin = c(0,0), 
    sub = "", csub = 1.25, possub = "bottomleft", pixmap = NULL, 
    contour = NULL, area = NULL, add.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.label_+3A_dfxy">dfxy</code></td>
<td>
<p>a data frame with at least two coordinates</p>
</td></tr>
<tr><td><code id="s.label_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="s.label_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="s.label_+3A_label">label</code></td>
<td>
<p>a vector of strings of characters for the point labels</p>
</td></tr>
<tr><td><code id="s.label_+3A_clabel">clabel</code></td>
<td>
<p>if not NULL, a character size for the labels, used with <code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="s.label_+3A_pch">pch</code></td>
<td>
<p>if <code>cpoint</code> &gt; 0, an integer specifying the symbol or the single character to be used in plotting points</p>
</td></tr>
<tr><td><code id="s.label_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")*cpoint</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="s.label_+3A_boxes">boxes</code></td>
<td>
<p>if TRUE, labels are framed</p>
</td></tr>
<tr><td><code id="s.label_+3A_neig">neig</code></td>
<td>
<p>a neighbouring graph</p>
</td></tr>
<tr><td><code id="s.label_+3A_cneig">cneig</code></td>
<td>
<p>a size for the neighbouring graph lines used with par(&quot;lwd&quot;)*<code>cneig</code></p>
</td></tr>
<tr><td><code id="s.label_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x axis, if NULL, they are computed</p>
</td></tr>
<tr><td><code id="s.label_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the y axis, if NULL, they are computed</p>
</td></tr>
<tr><td><code id="s.label_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="s.label_+3A_addaxes">addaxes</code></td>
<td>
<p>a logical value indicating whether the axes should be plotted</p>
</td></tr>
<tr><td><code id="s.label_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with par(&quot;cex&quot;)* <code>cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="s.label_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should be belonged to the graph space</p>
</td></tr>
<tr><td><code id="s.label_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example c(0,0) the origin axes</p>
</td></tr>
<tr><td><code id="s.label_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="s.label_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="s.label_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="s.label_+3A_pixmap">pixmap</code></td>
<td>
<p>an object 'pixmap' displayed in the map background</p>
</td></tr>
<tr><td><code id="s.label_+3A_contour">contour</code></td>
<td>
<p>a data frame with 4 columns to plot the contour of the map : each row gives a segment (x1,y1,x2,y2)</p>
</td></tr>
<tr><td><code id="s.label_+3A_area">area</code></td>
<td>
<p>a data frame of class 'area' to plot a set of surface units in contour</p>
</td></tr>
<tr><td><code id="s.label_+3A_add.plot">add.plot</code></td>
<td>
<p>if TRUE uses the current graphics window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!adegraphicsLoaded()) {
  layout(matrix(c(1, 2, 3, 2), 2, 2))
  data(atlas)
  s.label(atlas$xy, lab = atlas$names.district, 
    area = atlas$area, inc = FALSE, addax = FALSE)
  data(mafragh)
  s.label(mafragh$xy, inc = FALSE, neig = mafragh$neig, addax = FALSE)
  data(irishdata)
  s.label(irishdata$xy, inc = FALSE, contour = irishdata$contour, 
    addax = FALSE)
  
  par(mfrow = c(2, 2))
  cha &lt;- ls()
  s.label(cbind.data.frame(runif(length(cha)), 
    runif(length(cha))), lab = cha)
  x &lt;- runif(50, -2, 2)
  y &lt;- runif(50, -2, 2)
  z &lt;- x^2 + y^2
  s.label(data.frame(x, y), lab = as.character(z &lt; 1))
  s.label(data.frame(x, y), clab = 0, cpoi = 1, add.plot = TRUE)
  symbols(0, 0, circles = 1, add = TRUE, inch = FALSE)
  s.label(cbind.data.frame(runif(100, 0, 10), runif(100, 5, 12)), 
    incl = FALSE, clab = 0)
  s.label(cbind.data.frame(runif(100, -3, 12),
    runif(100, 2, 10)), cl = 0, cp = 2, include = FALSE)
}</code></pre>

<hr>
<h2 id='s.logo'>Representation of an object in a graph by a picture</h2><span id='topic+s.logo'></span><span id='topic+scatterutil.logo'></span>

<h3>Description</h3>

<p>performs the scatter diagrams using pictures to represent the points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.logo(dfxy, listlogo, klogo=NULL, clogo=1, rectlogo=TRUE,
    xax = 1, yax = 2, neig = NULL, cneig = 1, xlim = NULL, ylim = NULL, 
    grid = TRUE, addaxes = TRUE, cgrid = 1, include.origin = TRUE, 
    origin = c(0, 0), sub = "", csub = 1.25, possub = "bottomleft", 
    pixmap = NULL, contour = NULL, area = NULL, add.plot = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.logo_+3A_dfxy">dfxy</code></td>
<td>
<p>a data frame with at least two coordinates</p>
</td></tr>
<tr><td><code id="s.logo_+3A_listlogo">listlogo</code></td>
<td>
<p>a list of pixmap pictures</p>
</td></tr>
<tr><td><code id="s.logo_+3A_klogo">klogo</code></td>
<td>
<p>a numeric vector giving the order in which pictures of listlogo are used; if NULL, the order is the same than the rows of dfxy</p>
</td></tr>
<tr><td><code id="s.logo_+3A_clogo">clogo</code></td>
<td>
<p>a numeric vector giving the size factor applied to each picture</p>
</td></tr>
<tr><td><code id="s.logo_+3A_rectlogo">rectlogo</code></td>
<td>
<p>a logical to decide whether a rectangle should be drawn around the picture (TRUE) or not (FALSE)</p>
</td></tr>
<tr><td><code id="s.logo_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="s.logo_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="s.logo_+3A_neig">neig</code></td>
<td>
<p>a neighbouring graph</p>
</td></tr>
<tr><td><code id="s.logo_+3A_cneig">cneig</code></td>
<td>
<p>a size for the neighbouring graph lines used with par(&quot;lwd&quot;)*<code>cneig</code></p>
</td></tr>
<tr><td><code id="s.logo_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x axis, if NULL, they are computed</p>
</td></tr>
<tr><td><code id="s.logo_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the y axis, if NULL, they are computed</p>
</td></tr>
<tr><td><code id="s.logo_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="s.logo_+3A_addaxes">addaxes</code></td>
<td>
<p>a logical value indicating whether the axes should be plotted</p>
</td></tr>
<tr><td><code id="s.logo_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with par(&quot;cex&quot;)* <code>cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="s.logo_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should be belonged to the graph space</p>
</td></tr>
<tr><td><code id="s.logo_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example c(0,0) the origin axes</p>
</td></tr>
<tr><td><code id="s.logo_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="s.logo_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="s.logo_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="s.logo_+3A_pixmap">pixmap</code></td>
<td>
<p>an object 'pixmap' displayed in the map background</p>
</td></tr>
<tr><td><code id="s.logo_+3A_contour">contour</code></td>
<td>
<p>a data frame with 4 columns to plot the contour of the map : each row gives a segment (x1,y1,x2,y2)</p>
</td></tr>
<tr><td><code id="s.logo_+3A_area">area</code></td>
<td>
<p>a data frame of class 'area' to plot a set of surface units in contour</p>
</td></tr>
<tr><td><code id="s.logo_+3A_add.plot">add.plot</code></td>
<td>
<p>if TRUE uses the current graphics window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel and Thibaut Jombart <a href="mailto:t.jombart@imperial.ac.uk">t.jombart@imperial.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("pixmap", quietly = TRUE) &amp; requireNamespace("sp", quietly = TRUE)) {
  if(!adegraphicsLoaded()) {
  	data(ggtortoises)
  	a1 &lt;- ggtortoises$area
  	area.plot(a1)
  	rect(min(a1$x), min(a1$y), max(a1$x), max(a1$y), col = "lightblue")
  	invisible(lapply(split(a1, a1$id), function(x) polygon(x[, -1],col = "white")))
  	s.label(ggtortoises$misc, grid = FALSE, include.ori = FALSE, addaxes = FALSE, add.p = TRUE)
  	listico &lt;- ggtortoises$ico[as.character(ggtortoises$pop$carap)]
  	s.logo(ggtortoises$pop, listico, add.p = TRUE)
  	
  } else {
  	data(capitales, package = "ade4")
  	# 'capitales' data doesn't work with ade4 anymore
    g3 &lt;- s.logo(capitales$xy[sort(rownames(capitales$xy)), ], capitales$logo, 
      Sp = capitales$Spatial, pbackground.col = "lightblue", pSp.col = "white", 
      pgrid.draw = FALSE)
  }
}</code></pre>

<hr>
<h2 id='s.match'>Plot of Paired Coordinates</h2><span id='topic+s.match'></span>

<h3>Description</h3>

<p>performs the scatter diagram for a paired coordinates. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.match(df1xy, df2xy, xax = 1, yax = 2, pch = 20, cpoint = 1, 
    label = row.names(df1xy), clabel=1, edge = TRUE, xlim = NULL, 
    ylim = NULL, grid = TRUE, addaxes = TRUE, cgrid = 1, 
    include.origin = TRUE, origin = c(0,0), sub = "", csub = 1.25, 
    possub = "bottomleft", pixmap = NULL, contour = NULL, area = NULL, 
    add.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.match_+3A_df1xy">df1xy</code></td>
<td>
<p>a data frame containing two columns from the first system</p>
</td></tr>
<tr><td><code id="s.match_+3A_df2xy">df2xy</code></td>
<td>
<p>a data frame containing two columns from teh second system</p>
</td></tr>
<tr><td><code id="s.match_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis of both the two systems</p>
</td></tr>
<tr><td><code id="s.match_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis of both the two systems</p>
</td></tr>
<tr><td><code id="s.match_+3A_pch">pch</code></td>
<td>
<p>if <code>cpoint</code> &gt; 0, an integer specifying the symbol or the single character to be used in plotting points</p>
</td></tr>
<tr><td><code id="s.match_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")*cpoint</code>. If zero, no points are drawn </p>
</td></tr>
<tr><td><code id="s.match_+3A_label">label</code></td>
<td>
<p>a vector of strings of characters for the couple labels</p>
</td></tr>
<tr><td><code id="s.match_+3A_clabel">clabel</code></td>
<td>
<p>if not NULL, a character size for the labels, used with <code>par("cex")*clabel</code> </p>
</td></tr>
<tr><td><code id="s.match_+3A_edge">edge</code></td>
<td>
<p>If TRUE the arrows are plotted, otherwise only the segments are drawn</p>
</td></tr>
<tr><td><code id="s.match_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x axis, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.match_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the y axis, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.match_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="s.match_+3A_addaxes">addaxes</code></td>
<td>
<p>a logical value indicating whether the axes should be plotted</p>
</td></tr>
<tr><td><code id="s.match_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with par(&quot;cex&quot;)* <code>cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="s.match_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should be belonged to the graph space</p>
</td></tr>
<tr><td><code id="s.match_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example c(0,0) the origin axes</p>
</td></tr>
<tr><td><code id="s.match_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="s.match_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="s.match_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="s.match_+3A_pixmap">pixmap</code></td>
<td>
<p>aan object <code>pixmap</code> displayed in the map background</p>
</td></tr>
<tr><td><code id="s.match_+3A_contour">contour</code></td>
<td>
<p>a data frame with 4 columns to plot the contour of the map : each row gives a segment (x1,y1,x2,y2)</p>
</td></tr>
<tr><td><code id="s.match_+3A_area">area</code></td>
<td>
<p>a data frame of class 'area' to plot a set of surface units in contour</p>
</td></tr>
<tr><td><code id="s.match_+3A_add.plot">add.plot</code></td>
<td>
<p>if TRUE uses the current graphics window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!adegraphicsLoaded()) {
  X &lt;- data.frame(x = runif(50, -1, 2), y = runif(50, -1, 2))
  Y &lt;- X + rnorm(100, sd = 0.3)
  par(mfrow = c(2, 2))
  s.match(X, Y)
  s.match(X, Y, edge = FALSE, clab = 0)
  s.match(X, Y, edge = FALSE, clab = 0)
  s.label(X, clab = 1, add.plot = TRUE)
  s.label(Y, clab = 0.75, add.plot = TRUE)
  s.match(Y, X, clab = 0)
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='s.match.class'>Scatterplot of two sets of coordinates and a partionning into classes</h2><span id='topic+s.match.class'></span>

<h3>Description</h3>

<p>Performs a graphical representation of two sets of coordinates
(different colors and symbols) and a partitionning  into classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.match.class(df1xy, df2xy, fac, wt = rep(1/nrow(df1xy), nrow(df1xy)),
xax = 1, yax = 2, pch1 = 16, pch2 = 15, col1 = rep("lightgrey",
nlevels(fac)), col2 = rep("darkgrey", nlevels(fac)), cpoint = 1, label =
levels(fac), clabel = 1, cstar = 1, cellipse = 0, axesell = TRUE, xlim =
NULL, ylim = NULL, grid = TRUE, addaxes = TRUE, cgrid = 1,
include.origin = TRUE, origin = c(0, 0), sub = "", csub = 1.25, possub =
"bottomleft", pixmap = NULL, contour = NULL, area = NULL, add.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.match.class_+3A_df1xy">df1xy</code></td>
<td>
<p>a dataframe with the first system of coordinates</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_df2xy">df2xy</code></td>
<td>
<p>a dataframe with the secocnd system of coordinates</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_fac">fac</code></td>
<td>
<p>a factor partitioning the rows of the data frame in classes</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_wt">wt</code></td>
<td>
<p>a vector of weights</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_xax">xax</code></td>
<td>
<p>a number indicating which column should be plotted on the x-axis</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_yax">yax</code></td>
<td>
<p>a number indicating which column should be plotted on the x-axis</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_pch1">pch1</code></td>
<td>
<p>if <code>cpoint</code> &gt; 0, an integer specifying the symbol or the single character to be used for plotting points</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_pch2">pch2</code></td>
<td>
<p>if <code>cpoint</code> &gt; 0, an integer specifying the symbol or the single character to be used for plotting points</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_col1">col1</code></td>
<td>
<p>a color for symbols</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_col2">col2</code></td>
<td>
<p>a color for symbols</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")*cpoint</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_label">label</code></td>
<td>
<p>a vector of strings of characters for the couple labels</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_clabel">clabel</code></td>
<td>
<p>if not NULL, a character size for the labels, used with <code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="s.match.class_+3A_cstar">cstar</code></td>
<td>
<p>a number between 0 and 1 which defines the length of the star size</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_cellipse">cellipse</code></td>
<td>
<p>a positive coefficient for the inertia ellipse size</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_axesell">axesell</code></td>
<td>
<p>a logical value indicating whether the ellipse axes should be drawn</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x axis, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the y axis, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_addaxes">addaxes</code></td>
<td>
<p>a logical value indicating whether the axes should be plotted</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with par(&quot;cex&quot;)* <code>cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should belong to the graph space</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_origin">origin</code></td>
<td>
<p>a fixed point in the graph space, for example c(0,0) for
the origin of axes</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="s.match.class_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_pixmap">pixmap</code></td>
<td>
<p>a <code>pixmap</code> object</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_contour">contour</code></td>
<td>
<p>a dataframe with 4 columns to plot the contour of the map : each row gives a segment (x1,y1,x2,y2)</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_area">area</code></td>
<td>
<p>a dataframe of class 'area' to plot an areal map</p>
</td></tr>
<tr><td><code id="s.match.class_+3A_add.plot">add.plot</code></td>
<td>
<p>if TRUE, add the plot to the current graphic device</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s.class">s.class</a></code>, <code><a href="#topic+s.match">s.match</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy &lt;- data.frame(matrix(rnorm(100), 50, 2))
xy[, 1] &lt;- xy[, 1] + rep(seq(0, 12, by = 3), rep(10, 5))
xy[, 2] &lt;- xy[, 2] + rep(seq(0, 12, by = 3), rep(10, 5))
fac &lt;- gl(5, 10)
xy2 &lt;- xy + matrix(rnorm(100), 50, 2) + 1

if(adegraphicsLoaded()) {
  mat &lt;- rbind(xy, xy2)
  minmat &lt;- apply(mat, 2, min)
  maxmat &lt;- apply(mat, 2, max)
  lag &lt;- 0.1 * abs(minmat - maxmat)
  xli &lt;- c(minmat[1] - lag[1], maxmat[1] + lag[1])
  yli &lt;- c(minmat[2] - lag[2], maxmat[2] + lag[2])
  
  g1 &lt;- s.class(xy, fac, ellipseSize = 0, col = rep("grey45", nlevels(fac)), xlim = xli, 
    ylim = yli, plabels.cex = 0, plot = FALSE)
  g2 &lt;- s.class(xy2, fac, ellipseSize = 0, col = rep("grey75", nlevels(fac)), xlim = xli, 
    ylim = yli, plabels.cex = 0, plot = FALSE)
  g3 &lt;- s.match(g1@stats$means, g2@stats$means, xlim = xli, ylim = yli, plines.lwd = 2, 
    psub.text = "xy -&gt; xy2", plot = FALSE)
  
  g4 &lt;- do.call("superpose", list(g1, g2))
  g4@Call &lt;- call("superpose", g1@Call, g2@Call)
  g4 &lt;- do.call("superpose", list(g4, g3))
  g4@Call &lt;- call("superpose", g4@Call, g3@Call)
  g4
  
} else {
  s.match.class(xy, xy2, fac)
}
</code></pre>

<hr>
<h2 id='s.multinom'>Graph of frequency profiles (useful for instance in genetic)</h2><span id='topic+s.multinom'></span>

<h3>Description</h3>

<p>The main purpose of this function is to draw categories using scores and profiles by their gravity center.
Confidence intervals of the average position (issued from a multinomial distribution) can be superimposed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.multinom(dfxy, dfrowprof, translate = FALSE, xax = 1, yax = 2, 
   labelcat = row.names(dfxy), clabelcat = 1, cpointcat = if (clabelcat == 0) 2 else 0,
   labelrowprof = row.names(dfrowprof), clabelrowprof = 0.75, 
   cpointrowprof = if (clabelrowprof == 0) 2 else 0, pchrowprof = 20, 
   coulrowprof = grey(0.8), proba = 0.95, n.sample = apply(dfrowprof, 1, sum),
   axesell = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.multinom_+3A_dfxy">dfxy</code></td>
<td>
<p><code>dfxy</code> is a data frame containing at least two numerical variables.
The rows of <code>dfxy</code> are categories such as 1,2 and 3 in the triangular plot.</p>
</td></tr>
<tr><td><code id="s.multinom_+3A_dfrowprof">dfrowprof</code></td>
<td>
<p><code>dfrowprof</code> is a data frame whose the columns are the rows of <code>dfxy</code>.
The rows of <code>dfxy</code> are profiles or frequency distributions on the categories.
The column number of <code>dfrowprof</code> must be equal to the row number of <code>dfxy</code>.
<code>row.names(dfxy)</code> and <code>names(dfrowprof)</code> must be identical. </p>
</td></tr>
<tr><td><code id="s.multinom_+3A_translate">translate</code></td>
<td>
<p>a logical value indicating whether the plot should be translated(TRUE) or not. 
The origin becomes the gravity center weighted by profiles. </p>
</td></tr>
<tr><td><code id="s.multinom_+3A_xax">xax</code></td>
<td>
<p>the column number of <code>dfxy</code> for the x-axis </p>
</td></tr>
<tr><td><code id="s.multinom_+3A_yax">yax</code></td>
<td>
<p>the column number of <code>dfxy</code> for the y-axis </p>
</td></tr>
<tr><td><code id="s.multinom_+3A_labelcat">labelcat</code></td>
<td>
<p>a vector of strings of characters for the labels of categories </p>
</td></tr>
<tr><td><code id="s.multinom_+3A_clabelcat">clabelcat</code></td>
<td>
<p>an integer specifying the character size for the labels of categories, 
used with <code>par("cex")*clabelcat</code> </p>
</td></tr>
<tr><td><code id="s.multinom_+3A_cpointcat">cpointcat</code></td>
<td>
<p>an integer specifying the character size for the points showing the categories, 
used with <code>par("cex")*cpointcat</code> </p>
</td></tr>
<tr><td><code id="s.multinom_+3A_labelrowprof">labelrowprof</code></td>
<td>
<p>a vector of strings of characters for the labels of profiles (rows of <code>dfrowprof</code>) </p>
</td></tr>
<tr><td><code id="s.multinom_+3A_clabelrowprof">clabelrowprof</code></td>
<td>
<p>an integer specifying the character size for the labels of profiles 
used with par(&quot;cex&quot;)*clabelrowprof</p>
</td></tr>
<tr><td><code id="s.multinom_+3A_cpointrowprof">cpointrowprof</code></td>
<td>
<p>an integer specifying the character size for the points representative 
of the profiles used with par(&quot;cex&quot;)*cpointrowprof </p>
</td></tr>
<tr><td><code id="s.multinom_+3A_pchrowprof">pchrowprof</code></td>
<td>
<p>either an integer specifying a symbol or a single character to be used for the profile labels </p>
</td></tr>
<tr><td><code id="s.multinom_+3A_coulrowprof">coulrowprof</code></td>
<td>
<p>a vector of colors used for ellipses, possibly recycled</p>
</td></tr>
<tr><td><code id="s.multinom_+3A_proba">proba</code></td>
<td>
<p>a value lying between 0.500 and 0.999 to draw a confidence interval </p>
</td></tr>
<tr><td><code id="s.multinom_+3A_n.sample">n.sample</code></td>
<td>
<p>a vector containing the sample size, possibly recycled. Used <code>n.sample = 0</code> if the profiles
are not issued from a multinomial distribution and that confidence intervals have no sense. </p>
</td></tr>
<tr><td><code id="s.multinom_+3A_axesell">axesell</code></td>
<td>
<p>a logical value indicating whether the ellipse axes should be drawn</p>
</td></tr>
<tr><td><code id="s.multinom_+3A_...">...</code></td>
<td>
<p>further arguments passed from the <code>s.label</code> for the initial scatter plot. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns in a hidden way a list of three components :
</p>
<table>
<tr><td><code>tra</code></td>
<td>
<p>a vector with two values giving the done original translation. </p>
</td></tr>
<tr><td><code>ell</code></td>
<td>
<p>a matrix, with 5 columns and for rows the number of profiles, giving the means, 
the variances and the covariance of the profile for the used
numerical codes (column of <code>dfxy</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(2,2))
par(mar = c(0.1,0.1,0.1,0.1))
proba &lt;- matrix(c(0.49,0.47,0.04,0.4,0.3,0.3,0.05,0.05,0.9,0.05,0.7,0.25), ncol = 3, byrow = TRUE)
proba.df &lt;- as.data.frame (proba)
names(proba.df) &lt;- c("A","B","C") ; row.names(proba.df) &lt;- c("P1","P2","P3","P4")
w.proba &lt;- triangle.plot(proba.df, clab = 2, show = FALSE)
box()

w.tri = data.frame(x = c(-sqrt(1/2),sqrt(1/2),0), y = c(-1/sqrt(6),-1/sqrt(6),2/sqrt(6)))
L3 &lt;- c("A","B","C")
row.names(w.tri) &lt;- L3
s.multinom(w.tri, proba.df, n.sample = 0, coulrowprof = "black", clabelrowprof = 1.5)
s.multinom(w.tri, proba.df, n.sample = 30, coul = palette()[5])
s.multinom(w.tri, proba.df, n.sample = 60, coul = palette()[6], add.p = TRUE)
s.multinom(w.tri, proba.df, n.sample = 120, coul = grey(0.8), add.p = TRUE)

print(s.multinom(w.tri, proba.df[-3,], n.sample = 0, translate = TRUE)$tra)
</code></pre>

<hr>
<h2 id='s.traject'>Trajectory Plot</h2><span id='topic+s.traject'></span>

<h3>Description</h3>

<p>performs the scatter diagram with trajectories. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.traject(dfxy, fac = factor(rep(1, nrow(dfxy))), 
    ord = (1:length(fac)),  xax = 1, yax = 2, label = levels(fac), 
    clabel = 1, cpoint = 1, pch = 20, xlim = NULL, ylim = NULL, 
    grid = TRUE, addaxes = TRUE, edge = TRUE, origin = c(0,0), 
    include.origin = TRUE, sub = "", csub = 1, possub = "bottomleft", 
    cgrid = 1, pixmap = NULL, contour = NULL, area = NULL, add.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.traject_+3A_dfxy">dfxy</code></td>
<td>
<p>a data frame containing two columns for the axes</p>
</td></tr>
<tr><td><code id="s.traject_+3A_fac">fac</code></td>
<td>
<p>a factor partioning the rows of the data frame in classes</p>
</td></tr>
<tr><td><code id="s.traject_+3A_ord">ord</code></td>
<td>
<p>a vector of length equal to fac. The trajectory is drawn in an ascending order of the ord values</p>
</td></tr>
<tr><td><code id="s.traject_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="s.traject_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="s.traject_+3A_label">label</code></td>
<td>
<p>a vector of strings of characters for the point labels</p>
</td></tr>
<tr><td><code id="s.traject_+3A_clabel">clabel</code></td>
<td>
<p>if not NULL, a character size for the labels, used with <code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="s.traject_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")*cpoint</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="s.traject_+3A_pch">pch</code></td>
<td>
<p>if <code>cpoint</code> &gt; 0, an integer specifying the symbol or the single character to be used in plotting points</p>
</td></tr>
<tr><td><code id="s.traject_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.traject_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the y, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.traject_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="s.traject_+3A_addaxes">addaxes</code></td>
<td>
<p>a logical value indicating whether the axes should be plotted</p>
</td></tr>
<tr><td><code id="s.traject_+3A_edge">edge</code></td>
<td>
<p>if TRUE the arrows are plotted, otherwhise only the segments</p>
</td></tr>
<tr><td><code id="s.traject_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example c(0,0) the origin axes</p>
</td></tr>
<tr><td><code id="s.traject_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should be belonged to the graph space</p>
</td></tr>
<tr><td><code id="s.traject_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="s.traject_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="s.traject_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="s.traject_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with <code>par("cex")*cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="s.traject_+3A_pixmap">pixmap</code></td>
<td>
<p>aan object 'pixmap' displayed in the map background</p>
</td></tr>
<tr><td><code id="s.traject_+3A_contour">contour</code></td>
<td>
<p>a data frame with 4 columns to plot the contour of the map : each row gives a segment (x1,y1,x2,y2)</p>
</td></tr>
<tr><td><code id="s.traject_+3A_area">area</code></td>
<td>
<p>a data frame of class 'area' to plot a set of surface units in contour</p>
</td></tr>
<tr><td><code id="s.traject_+3A_add.plot">add.plot</code></td>
<td>
<p>if TRUE uses the current graphics window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!adegraphicsLoaded()) {
  rw &lt;- function(a) {
    x &lt;- 0
    for(i in 1:49) x &lt;- c(x, x[length(x)] + runif(1, -1, 1))
    x
  }
  y &lt;- unlist(lapply(1:5, rw))
  x &lt;- unlist(lapply(1:5, rw))
  z &lt;- gl(5, 50)
  s.traject(data.frame(x, y), z, edge = FALSE)
}</code></pre>

<hr>
<h2 id='s.value'>Representation of a value in a graph</h2><span id='topic+s.value'></span>

<h3>Description</h3>

<p>performs the scatter diagram with the representation of a value for a variable 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s.value(dfxy, z, xax = 1, yax = 2, method = c("squaresize", "greylevel"), 
    zmax=NULL, csize = 1, cpoint = 0, pch = 20, clegend = 0.75, neig = NULL, 
    cneig = 1, xlim = NULL, ylim = NULL, grid = TRUE, addaxes = TRUE, 
    cgrid = 0.75, include.origin = TRUE, origin = c(0,0), sub = "", 
    csub = 1, possub = "topleft", pixmap = NULL, contour = NULL, 
    area = NULL, add.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s.value_+3A_dfxy">dfxy</code></td>
<td>
<p>a data frame with two coordinates</p>
</td></tr>
<tr><td><code id="s.value_+3A_z">z</code></td>
<td>
<p>a vector of the values corresponding to the rows of <code>dfxy</code></p>
</td></tr>
<tr><td><code id="s.value_+3A_xax">xax</code></td>
<td>
<p>column for the x axis</p>
</td></tr>
<tr><td><code id="s.value_+3A_yax">yax</code></td>
<td>
<p>column for the y axis</p>
</td></tr>
<tr><td><code id="s.value_+3A_method">method</code></td>
<td>
<p>a string of characters <br />
&quot;squaresize&quot; gives black squares for positive values and white for negative values with a proportional area equal to the absolute value.  <br />
&quot;greylevel&quot; gives squares of equal size with a grey level proportional to the value. By default the first choice</p>
</td></tr>
<tr><td><code id="s.value_+3A_zmax">zmax</code></td>
<td>
<p>a numeric value, equal by default to max(abs(z)), can be used to impose a common scale of the size of the squares to several drawings in the same device</p>
</td></tr>
<tr><td><code id="s.value_+3A_csize">csize</code></td>
<td>
<p>a size coefficient for symbols</p>
</td></tr>
<tr><td><code id="s.value_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")*cpoint</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="s.value_+3A_pch">pch</code></td>
<td>
<p>if <code>cpoint</code> &gt; 0, an integer specifying the symbol or the single character to be used in plotting points</p>
</td></tr>
<tr><td><code id="s.value_+3A_clegend">clegend</code></td>
<td>
<p>a character size for the legend used by <code>par("cex")*clegend</code></p>
</td></tr>
<tr><td><code id="s.value_+3A_neig">neig</code></td>
<td>
<p>a neighbouring graph</p>
</td></tr>
<tr><td><code id="s.value_+3A_cneig">cneig</code></td>
<td>
<p>a size for the neighbouring graph lines used with <code>par("lwd")*cneig</code></p>
</td></tr>
<tr><td><code id="s.value_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.value_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the y, if NULL they are computed</p>
</td></tr>
<tr><td><code id="s.value_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="s.value_+3A_addaxes">addaxes</code></td>
<td>
<p>a logical value indicating whether the axes should be plotted</p>
</td></tr>
<tr><td><code id="s.value_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with <code>par("cex")*cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="s.value_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should be belonged to the graph space</p>
</td></tr>
<tr><td><code id="s.value_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example c(0,0) the origin axes</p>
</td></tr>
<tr><td><code id="s.value_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="s.value_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="s.value_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="s.value_+3A_pixmap">pixmap</code></td>
<td>
<p>an object 'pixmap' displayed in the map background</p>
</td></tr>
<tr><td><code id="s.value_+3A_contour">contour</code></td>
<td>
<p>a data frame with 4 columns to plot the contour of the map : each row gives a segment (x1,y1,x2,y2)</p>
</td></tr>
<tr><td><code id="s.value_+3A_area">area</code></td>
<td>
<p>a data frame of class 'area' to plot a set of surface units in contour</p>
</td></tr>
<tr><td><code id="s.value_+3A_add.plot">add.plot</code></td>
<td>
<p>if TRUE uses the current graphics window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!adegraphicsLoaded()) {
  xy &lt;- cbind.data.frame(x = runif(500), y = runif(500))
  z &lt;- rnorm(500)
  s.value(xy, z)
  
  s.value(xy, z, method = "greylevel")
  
  data(rpjdl)
  fau.coa &lt;- dudi.coa(rpjdl$fau, scan = FALSE, nf = 3)
  s.value(fau.coa$li, fau.coa$li[,3], csi = 0.75, cleg = 0.75)
  
  data(irishdata)
  par(mfrow = c(3, 4))
  irq0 &lt;- data.frame(scale(irishdata$tab, scale = TRUE))
  for (i in 1:12) {
    z &lt;- irq0[, i]
    nam &lt;- names(irq0)[i]
    s.value(irishdata$xy, z, area = irishdata$area, csi = 3,
      csub = 2, sub = nam, cleg = 1.5, cgrid = 0, inc = FALSE,
      xlim = c(16, 205), ylim = c(-50, 268), adda = FALSE, grid = FALSE)
  }
}</code></pre>

<hr>
<h2 id='santacatalina'>Indirect Ordination</h2><span id='topic+santacatalina'></span>

<h3>Description</h3>

<p>This data set gives the densities per hectare of 11 species of trees 
for 10 transects of topographic moisture values (mean of several stations per class).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(santacatalina)</code></pre>


<h3>Format</h3>

<p>a data frame with 11 rows and 10 columns
</p>


<h3>Source</h3>

<p>Gauch, H. G. J., Chase, G. B. and Whittaker R. H. (1974)
Ordination of vegetation samples by Gaussian species distributions.
<em>Ecology</em>, <b>55</b>, 1382&ndash;1390.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(santacatalina)
coa1 &lt;- dudi.coa(log(santacatalina + 1), scan = FALSE) # 2 factors

if(adegraphicsLoaded()) {
  g1 &lt;- table.value(log(santacatalina + 1), plot = FALSE)
  g2 &lt;- table.value(log(santacatalina + 1)[, sample(10)], plot = FALSE)
  g3 &lt;- table.value(log(santacatalina + 1)[order(coa1$li[, 1]), order(coa1$co[, 1])], plot = FALSE)
  g4 &lt;- scatter(coa1, posi = "bottomright", plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
} else {
  par(mfrow = c(2, 2))
  table.value(log(santacatalina + 1))
  table.value(log(santacatalina + 1)[, sample(10)])
  table.value(log(santacatalina + 1)[order(coa1$li[, 1]), order(coa1$co[, 1])]) 
  scatter(coa1, posi = "bottomright")
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='sarcelles'>Array of Recapture of Rings</h2><span id='topic+sarcelles'></span>

<h3>Description</h3>

<p>The data frame <code>sarcelles$tab</code> contains the number of the winter teals 
(<em>Anas C. Crecca</em>) for which the ring was retrieved in the area <em>i</em> 
during the month <em>j</em> (<em>n</em>=3049).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sarcelles)</code></pre>


<h3>Format</h3>

<p><code>sarcelles</code> is a list with the following components:
</p>

<dl>
<dt>tab</dt><dd><p>a data frame with 14 rows-areas and 12 columns-months</p>
</dd>
<dt>xy</dt><dd><p>a data frame with the 2 spatial coordinates of the 14 region centers</p>
</dd>
<dt>neig</dt><dd><p>the neighbouring graph between areas, object of the class <code>neig</code></p>
</dd>
<dt>col.names</dt><dd><p>a vector containing the month items</p>
</dd>
<dt>nb</dt><dd><p>a neighborhood object (class <code>nb</code> defined in package <code>spdep</code>)</p>
</dd>
</dl>


<h3>Source</h3>

<p>Lebreton, J.D. (1973). Etude des déplacements saisonniers des Sarcelles d'hiver, 
Anas c. crecca L., hivernant en Camargue à l'aide de l'analyse factorielle des 
correspondances. <em>Compte rendu hebdomadaire des séances de l'Académie des 
sciences</em>, Paris, D, III, <b>277</b>, 2417&ndash;2420.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(!adegraphicsLoaded()) {
  # depends of pixmap
  if(requireNamespace("pixmap", quietly = TRUE)) {
    bkgnd.pnm &lt;- pixmap::read.pnm(system.file("pictures/sarcelles.pnm", package = "ade4"))
    data(sarcelles)
    par(mfrow = c(4, 3))
    for(i in 1:12) {
      s.distri(sarcelles$xy, sarcelles$tab[, i], pixmap = bkgnd.pnm, 
       sub = sarcelles$col.names[i], clab = 0, csub = 2)
      s.value(sarcelles$xy, sarcelles$tab[, i], add.plot = TRUE, cleg = 0)
    }
    par(mfrow = c(1, 1))
  }
}
## End(Not run)</code></pre>

<hr>
<h2 id='scalewt'>Compute or scale data using (weighted) means, variances and
covariances (possibly for the levels of a factor)</h2><span id='topic+covwt'></span><span id='topic+varwt'></span><span id='topic+scalewt'></span><span id='topic+meanfacwt'></span><span id='topic+varfacwt'></span><span id='topic+covfacwt'></span><span id='topic+scalefacwt'></span>

<h3>Description</h3>

<p>These utility functions compute (weighted) means, variances and covariances for
dataframe partitioned by a factor. The scale transforms a numeric matrix in a centred and scaled matrix for any weighting. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covwt(x, wt, na.rm = FALSE)
varwt(x, wt, na.rm = FALSE)
scalewt(df, wt = rep(1/nrow(df), nrow(df)), center = TRUE, scale = TRUE)
meanfacwt(df, fac = NULL, wt = rep(1/nrow(df), nrow(df)), drop = FALSE)
varfacwt(df, fac = NULL, wt = rep(1/nrow(df), nrow(df)), drop = FALSE)
covfacwt(df, fac = NULL, wt = rep(1/nrow(df), nrow(df)), drop = FALSE)
scalefacwt(df, fac = NULL, wt = rep(1/nrow(df), nrow(df)), scale = TRUE, drop = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalewt_+3A_x">x</code></td>
<td>
<p>a numeric vector (<code>varwt</code>) or a matrix (<code>covwt</code>)
containg the data.</p>
</td></tr>
<tr><td><code id="scalewt_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="scalewt_+3A_df">df</code></td>
<td>
<p>a matrix or a dataframe containing the data.</p>
</td></tr>
<tr><td><code id="scalewt_+3A_fac">fac</code></td>
<td>
<p>a factor partitioning the data.</p>
</td></tr>
<tr><td><code id="scalewt_+3A_wt">wt</code></td>
<td>
<p>a numeric vector of weights.</p>
</td></tr>
<tr><td><code id="scalewt_+3A_drop">drop</code></td>
<td>
<p>a logical value indicating whether unused levels should be kept.</p>
</td></tr>
<tr><td><code id="scalewt_+3A_scale">scale</code></td>
<td>
<p>a logical value indicating whether data should be scaled or not.</p>
</td></tr>
<tr><td><code id="scalewt_+3A_center">center</code></td>
<td>
<p>a logical value indicating whether data should be centered or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions returns biased estimates of variances and covariances
(i.e. divided by n and not n-1)
</p>


<h3>Value</h3>

<p>For <code>varwt</code>, the weighted variance. For <code>covwt</code>,
the matrix of weighted co-variances. For <code>scalewt</code>, the scaled
dataframe. For other function a list (if <code>fac</code> is not null) of dataframes with approriate values
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meau)
w &lt;- rowSums(meau$spe)
varwt(meau$env, w)
varfacwt(meau$env, wt = w)
varfacwt(meau$env, wt = w, fac = meau$design$season)
covfacwt(meau$env, wt = w, fac = meau$design$season)
scalewt(meau$env, wt = w)
</code></pre>

<hr>
<h2 id='scatter'>Graphical representation of the outputs of a multivariate analysis</h2><span id='topic+scatter'></span><span id='topic+biplot.dudi'></span><span id='topic+screeplot.dudi'></span>

<h3>Description</h3>

<p><code>scatter</code> is a generic function that has methods for the classes
<code>coa</code>, <code>dudi</code>, <code>fca</code>, <code>acm</code> and <code>pco</code>.
It plots the outputs of a multivariate analysis by representing
simultaneously the rows and the colums of the original table
(biplot). The function <code>biplot</code> returns exactly the same
representation. <br />
The function <code>screeplot</code> represents the amount of inertia (usually
variance) associated to each dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter(x, ...)
## S3 method for class 'dudi'
biplot(x, ...)
## S3 method for class 'dudi'
screeplot(x, npcs = length(x$eig), type = c("barplot", "lines"), 
    main = deparse(substitute(x)), col = c(rep("black", x$nf),
rep("grey", npcs - x$nf)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatter_+3A_x">x</code></td>
<td>
<p>an object of the class <code>dudi</code> containing the outputs of
a multivariate analysis</p>
</td></tr>
<tr><td><code id="scatter_+3A_npcs">npcs</code></td>
<td>
<p>the number of components to be plotted</p>
</td></tr>
<tr><td><code id="scatter_+3A_type">type</code></td>
<td>
<p>the type of plot</p>
</td></tr>
<tr><td><code id="scatter_+3A_main">main</code></td>
<td>
<p>the title of the plot</p>
</td></tr>
<tr><td><code id="scatter_+3A_col">col</code></td>
<td>
<p>a vector of colors</p>
</td></tr>
<tr><td><code id="scatter_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+s.arrow">s.arrow</a></code>, <code><a href="#topic+s.chull">s.chull</a></code>, <code><a href="#topic+s.class">s.class</a></code>, 
<code><a href="#topic+s.corcircle">s.corcircle</a></code>, <code><a href="#topic+s.distri">s.distri</a></code>, <code><a href="#topic+s.label">s.label</a></code>, 
<code><a href="#topic+s.match">s.match</a></code>, <code><a href="#topic+s.traject">s.traject</a></code>, <code><a href="#topic+s.value">s.value</a></code>, <code><a href="#topic+add.scatter">add.scatter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rpjdl)
rpjdl.coa &lt;- dudi.coa(rpjdl$fau, scannf = FALSE, nf = 4)
screeplot(rpjdl.coa)
biplot(rpjdl.coa)
</code></pre>

<hr>
<h2 id='scatter.acm'>Plot of the factorial maps in a Multiple Correspondence Analysis</h2><span id='topic+scatter.acm'></span>

<h3>Description</h3>

<p>performs the scatter diagrams of a Multiple Correspondence Analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'acm'
scatter(x, xax = 1, yax = 2, mfrow=NULL, csub = 2, possub = "topleft", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatter.acm_+3A_x">x</code></td>
<td>
<p>an object of class <code>acm</code></p>
</td></tr>
<tr><td><code id="scatter.acm_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="scatter.acm_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="scatter.acm_+3A_mfrow">mfrow</code></td>
<td>
<p>a vector of the form &quot;c(nr,nc)&quot;, if NULL (the default) is 
computed by <code>n2mfrow</code></p>
</td></tr>
<tr><td><code id="scatter.acm_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="scatter.acm_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the legend position (&quot;topleft&quot;, 
&quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;) in a array of figures</p>
</td></tr>
<tr><td><code id="scatter.acm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lascaux)
if(adegraphicsLoaded()) {
  plot(dudi.acm(lascaux$ornem, sca = FALSE))
} else {
  scatter(dudi.acm(lascaux$ornem, sca = FALSE), csub = 3)
}
</code></pre>

<hr>
<h2 id='scatter.coa'>Plot of the factorial maps for a correspondence analysis</h2><span id='topic+scatter.coa'></span>

<h3>Description</h3>

<p>performs the scatter diagrams of a correspondence analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coa'
scatter(x, xax = 1, yax = 2, method = 1:3, clab.row = 0.75, 
    clab.col = 1.25, posieig = "top", sub = NULL, csub = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatter.coa_+3A_x">x</code></td>
<td>
<p>an object of class <code>coa</code></p>
</td></tr>
<tr><td><code id="scatter.coa_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="scatter.coa_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="scatter.coa_+3A_method">method</code></td>
<td>
<p>an integer between 1 and 3 <br />
1 Rows and columns with the coordinates of lambda variance<br />
2 Columns variance 1 and rows by averaging<br />
3 Rows variance 1 and columns by averaging</p>
</td></tr>
<tr><td><code id="scatter.coa_+3A_clab.row">clab.row</code></td>
<td>
<p>a character size for the rows</p>
</td></tr>
<tr><td><code id="scatter.coa_+3A_clab.col">clab.col</code></td>
<td>
<p>a character size for the columns</p>
</td></tr>
<tr><td><code id="scatter.coa_+3A_posieig">posieig</code></td>
<td>
<p>if &quot;top&quot; the eigenvalues bar plot is upside,vif &quot;bottom&quot; it is downside, if &quot;none&quot; no plot</p>
</td></tr>
<tr><td><code id="scatter.coa_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="scatter.coa_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="scatter.coa_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>References</h3>

<p>Oksanen, J. (1987) Problems of joint display of species and site scores in correspondence analysis. <em>Vegetatio</em>, <b>72</b>, 51&ndash;57.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(housetasks)
w &lt;- dudi.coa(housetasks, scan = FALSE)
if(adegraphicsLoaded()) {
  g1 &lt;- scatter(w, method = 1, psub.text = "1 / Standard", posieig = "none", plot = FALSE)
  g2 &lt;- scatter(w, method = 2, psub.text = "2 / Columns -&gt; averaging -&gt; Rows", 
    posieig = "none", plot = FALSE)
  g3 &lt;- scatter(w, method = 3, psub.text = "3 / Rows -&gt; averaging -&gt; Columns ", 
    posieig = "none", plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3), layout = c(2, 2))
  
} else {
  par(mfrow = c(2, 2))
  scatter(w, method = 1, sub = "1 / Standard", posieig = "none")
  scatter(w, method = 2, sub = "2 / Columns -&gt; averaging -&gt; Rows", posieig = "none")
  scatter(w, method = 3, sub = "3 / Rows -&gt; averaging -&gt; Columns ", posieig = "none")
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='scatter.dudi'>Plot of the Factorial Maps</h2><span id='topic+scatter.dudi'></span>

<h3>Description</h3>

<p>performs the scatter diagrams of objects of class <code>dudi</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dudi'
scatter(x, xax = 1, yax = 2, clab.row = 0.75, clab.col = 1, 
    permute = FALSE, posieig = "top", sub = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatter.dudi_+3A_x">x</code></td>
<td>
<p>an object of class <code>dudi</code></p>
</td></tr>
<tr><td><code id="scatter.dudi_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="scatter.dudi_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="scatter.dudi_+3A_clab.row">clab.row</code></td>
<td>
<p>a character size for the rows</p>
</td></tr>
<tr><td><code id="scatter.dudi_+3A_clab.col">clab.col</code></td>
<td>
<p>a character size for the columns</p>
</td></tr>
<tr><td><code id="scatter.dudi_+3A_permute">permute</code></td>
<td>
<p>if FALSE, the rows are plotted by points and the columns by arrows. If TRUE it is the opposite.</p>
</td></tr>
<tr><td><code id="scatter.dudi_+3A_posieig">posieig</code></td>
<td>
<p>if &quot;top&quot; the eigenvalues bar plot is upside, if &quot;bottom&quot; it is downside, if &quot;none&quot; no plot</p>
</td></tr>
<tr><td><code id="scatter.dudi_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="scatter.dudi_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>scatter.dudi</code> is a factorial map of individuals and the projection of the vectors of the canonical basis multiplied by a constante of rescaling. In the eigenvalues bar plot,the used axes for the plot are in black, the other kept axes in grey and the other in white.
</p>
<p>The <code>permute</code> argument can be used to choose between the distance biplot (default) and the correlation biplot (permute = TRUE).
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deug)
scatter(dd1 &lt;- dudi.pca(deug$tab, scannf = FALSE, nf = 4), 
    posieig = "bottomright")

data(rhone)
dd1 &lt;- dudi.pca(rhone$tab, nf = 4, scann = FALSE)
if(adegraphicsLoaded()) {
  scatter(dd1, row.psub.text = "Principal component analysis")
} else {
  scatter(dd1, sub = "Principal component analysis")
}
</code></pre>

<hr>
<h2 id='scatter.fca'>Plot of the factorial maps for a fuzzy correspondence analysis</h2><span id='topic+scatter.fca'></span>

<h3>Description</h3>

<p>performs the scatter diagrams of a fuzzy correspondence analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fca'
scatter(x, xax = 1, yax = 2, clab.moda = 1, labels = names(x$tab), 
    sub = NULL, csub = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatter.fca_+3A_x">x</code></td>
<td>
<p>an object of class <code>fca</code></p>
</td></tr>
<tr><td><code id="scatter.fca_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="scatter.fca_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="scatter.fca_+3A_clab.moda">clab.moda</code></td>
<td>
<p>the character size to write the modalities</p>
</td></tr>
<tr><td><code id="scatter.fca_+3A_labels">labels</code></td>
<td>
<p>a vector of strings of characters for the labels of the modalities</p>
</td></tr>
<tr><td><code id="scatter.fca_+3A_sub">sub</code></td>
<td>
<p>a vector of strings of characters to be inserted as legend in each figure</p>
</td></tr>
<tr><td><code id="scatter.fca_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="scatter.fca_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel 
</p>


<h3>References</h3>

<p>Chevenet, F., Dolédec, S. and Chessel, D. (1994) 
A fuzzy coding approach for the analysis of long-term ecological data. <em>Freshwater Biology</em>, <b>31</b>, 295&ndash;309.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coleo)
coleo.fuzzy &lt;- prep.fuzzy.var(coleo$tab, coleo$col.blocks)
fca1 &lt;- dudi.fca(coleo.fuzzy, sca = FALSE, nf = 3)

if(adegraphicsLoaded()) {
  plot(fca1)
} else {
  scatter(fca1, labels = coleo$moda.names, clab.moda = 1.5,
    sub = names(coleo$col.blocks), csub = 3)
}
</code></pre>

<hr>
<h2 id='scatterutil'>Graphical utility functions</h2><span id='topic+scatterutil'></span><span id='topic+scatterutil.base'></span><span id='topic+scatterutil.sco'></span><span id='topic+scatterutil.chull'></span><span id='topic+scatterutil.eigen'></span><span id='topic+scatterutil.ellipse'></span><span id='topic+scatterutil.eti.circ'></span><span id='topic+scatterutil.eti'></span><span id='topic+scatterutil.grid'></span><span id='topic+scatterutil.legend.bw.square'></span><span id='topic+scatterutil.legend.square.grey'></span><span id='topic+scatterutil.legendgris'></span><span id='topic+scatterutil.scaling'></span><span id='topic+scatterutil.star'></span><span id='topic+scatterutil.sub'></span><span id='topic+scatterutil.convrot90'></span>

<h3>Description</h3>

<p>These are utilities used in graphical functions.
</p>


<h3>Details</h3>

<p>The functions scatter use some utilities functions :
</p>

<dl>
<dt>scatterutil.base</dt><dd><p>defines the layer of the plot for all
scatters</p>
</dd>
<dt>scatterutil.sco</dt><dd><p>defines the layer of the plot for sco functions</p>
</dd>
<dt>scatterutil.chull</dt><dd><p>plots the polygons of the external contour</p>
</dd>
<dt>scatterutil.eigen</dt><dd><p>plots the eigenvalues bar plot</p>
</dd>
<dt>scatterutil.ellipse</dt><dd><p>plots an inertia ellipse for a weighting distribution</p>
</dd>
<dt>scatterutil.eti.circ</dt><dd><p>puts labels on a correlation circle</p>
</dd>
<dt>scatterutil.eti</dt><dd><p>puts labels centred on the points</p>
</dd>
<dt>scatterutil.grid</dt><dd><p>plots a grid and adds a legend</p>
</dd>
<dt>scatterutil.legend.bw.square</dt><dd><p>puts a legend of values by square size</p>
</dd>
<dt>scatterutil.legend.square.grey</dt><dd><p>puts a legend by squares and grey levels</p>
</dd>
<dt>scatterutil.legendgris</dt><dd><p>adds a legend of grey levels for the areas</p>
</dd>
<dt>scatterutil.scaling</dt><dd><p>to fit a plot on a background bipmap</p>
</dd>
<dt>scatterutil.star</dt><dd><p>plots a star for a weighting distribution</p>
</dd>
<dt>scatterutil.sub</dt><dd><p>adds a string of characters in sub-title of a
graph</p>
</dd>
<dt>scatterutil.convrot90</dt><dd><p>is used to rotate labels</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Daniel Chessel, Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+s.arrow">s.arrow</a></code>, <code><a href="#topic+s.chull">s.chull</a></code>, <code><a href="#topic+s.class">s.class</a></code>, 
<code><a href="#topic+s.corcircle">s.corcircle</a></code>, <code><a href="#topic+s.distri">s.distri</a></code>, <code><a href="#topic+s.label">s.label</a></code>, 
<code><a href="#topic+s.match">s.match</a></code>, <code><a href="#topic+s.traject">s.traject</a></code>, <code><a href="#topic+s.value">s.value</a></code>, <code><a href="#topic+add.scatter">add.scatter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(3,3))
plot.new()
ade4:::scatterutil.legendgris(1:20, 4, 1.6) 

plot.new()
ade4:::scatterutil.sub("lkn5555555555lkn", csub = 2, possub = "bottomleft")
ade4:::scatterutil.sub("lkn5555555555lkn", csub = 1, possub = "topleft")
ade4:::scatterutil.sub("jdjjl", csub = 3, possub = "topright")
ade4:::scatterutil.sub("**", csub = 2, possub = "bottomright")

x &lt;- c(0.5,0.2,-0.5,-0.2) ; y &lt;- c(0.2,0.5,-0.2,-0.5)
eti &lt;- c("toto", "kjbk", "gdgiglgl", "sdfg")
plot(x, y, xlim = c(-1,1), ylim = c(-1,1))
ade4:::scatterutil.eti.circ(x, y, eti, 2.5)
abline(0, 1, lty = 2) ; abline(0, -1, lty = 2)

x &lt;- c(0.5,0.2,-0.5,-0.2) ; y &lt;- c(0.2,0.5,-0.2,-0.5)
eti &lt;- c("toto", "kjbk", "gdgiglgl", "sdfg")
plot(x, y, xlim = c(-1,1), ylim = c(-1,1))
ade4:::scatterutil.eti(x, y, eti, 1.5)

plot(runif(10,-3,5), runif(10,-1,1), asp = 1)
ade4:::scatterutil.grid(2)
abline(h = 0, v = 0, lwd = 3)

x &lt;- runif(10,0,1) ; y &lt;- rnorm(10) ; z &lt;- rep(1,10)
plot(x,y) ; ade4:::scatterutil.star(x, y, z, 0.5)
plot(x,y) ; ade4:::scatterutil.star(x, y, z, 1)

x &lt;- c(runif(10,0,0.5), runif(10,0.5,1))
y &lt;- runif(20)
plot(x, y, asp = 1) # asp=1 is essential to have perpendicular axes
ade4:::scatterutil.ellipse(x, y, rep(c(1,0), c(10,10)), cell = 1.5, ax = TRUE)
ade4:::scatterutil.ellipse(x, y, rep(c(0,1), c(10,10)), cell = 1.5, ax = TRUE)

x &lt;- c(runif(100,0,0.75), runif(100,0.25,1))
y &lt;- c(runif(100,0,0.75), runif(100,0.25,1))
z &lt;- factor(rep(c(1,2), c(100,100)))
plot(x, y, pch = rep(c(1,20), c(100,100)))
ade4:::scatterutil.chull(x, y, z, opt = c(0.25,0.50,0.75,1))
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='sco.boxplot'>Representation of the link between a variable and a set of qualitative variables</h2><span id='topic+sco.boxplot'></span>

<h3>Description</h3>

<p>represents the link between a variable and a set of qualitative variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sco.boxplot(score, df, labels = names(df), clabel = 1, xlim = NULL, 
    grid = TRUE, cgrid = 0.75, include.origin = TRUE, origin = 0, 
    sub = NULL, csub = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sco.boxplot_+3A_score">score</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="sco.boxplot_+3A_df">df</code></td>
<td>
<p>a data frame with only factors</p>
</td></tr>
<tr><td><code id="sco.boxplot_+3A_labels">labels</code></td>
<td>
<p>a vector of strings of characters for the labels of variables</p>
</td></tr>
<tr><td><code id="sco.boxplot_+3A_clabel">clabel</code></td>
<td>
<p>if not NULL, a character size for the labels, used with  <code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="sco.boxplot_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x axis, if NULL they are computed</p>
</td></tr>
<tr><td><code id="sco.boxplot_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether the scale vertical lines should be drawn</p>
</td></tr>
<tr><td><code id="sco.boxplot_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with <code>par("cex")*cgrid</code> to indicate the mesh of the scale</p>
</td></tr>
<tr><td><code id="sco.boxplot_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should be belonged to the graph space</p>
</td></tr>
<tr><td><code id="sco.boxplot_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example 0 the origin axis</p>
</td></tr>
<tr><td><code id="sco.boxplot_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="sco.boxplot_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w1 &lt;- rnorm(100,-1)
w2 &lt;- rnorm(100)
w3 &lt;- rnorm(100,1)
f1 &lt;- gl(3,100)
f2 &lt;- gl(30,10)
sco.boxplot(c(w1,w2,w3), data.frame(f1,f2))

data(banque)
banque.acm &lt;- dudi.acm(banque, scan = FALSE, nf = 4)
par(mfrow = c(1,3))
sco.boxplot(banque.acm$l1[,1], banque[,1:7], clab = 1.8)
sco.boxplot(banque.acm$l1[,1], banque[,8:14], clab = 1.8)
sco.boxplot(banque.acm$l1[,1], banque[,15:21], clab = 1.8)
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='sco.class'>1D plot of a numeric score and a factor with labels</h2><span id='topic+sco.class'></span>

<h3>Description</h3>

<p>Draws evenly spaced labels, each label linked to the corresponding
values of the levels of a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sco.class(score, fac, label = levels(fac), clabel = 1, horizontal = TRUE, 
    reverse = FALSE, pos.lab = 0.5, pch = 20, cpoint = 1, boxes = TRUE, 
    col = rep(1, length(levels(fac))), lim = NULL, grid = TRUE, 
    cgrid = 1, include.origin = TRUE, origin = c(0, 0), sub = "", 
    csub = 1.25, possub = "bottomleft")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sco.class_+3A_score">score</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="sco.class_+3A_fac">fac</code></td>
<td>
<p>a factor</p>
</td></tr>
<tr><td><code id="sco.class_+3A_label">label</code></td>
<td>
<p>labels for the levels of the factor</p>
</td></tr>
<tr><td><code id="sco.class_+3A_clabel">clabel</code></td>
<td>
<p>a character size for the labels, used with
<code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="sco.class_+3A_horizontal">horizontal</code></td>
<td>
<p>logical. If TRUE, the plot is horizontal</p>
</td></tr>
<tr><td><code id="sco.class_+3A_reverse">reverse</code></td>
<td>
<p>logical. If horizontal = TRUE and reverse=TRUE, the
plot is at the bottom, if reverse = FALSE, the plot is at the top. If
horizontal = FALSE, the plot is at the right (TRUE) or at the left
(FALSE).</p>
</td></tr>
<tr><td><code id="sco.class_+3A_pos.lab">pos.lab</code></td>
<td>
<p>a values between 0 and 1 to manage the position of the
labels.</p>
</td></tr>
<tr><td><code id="sco.class_+3A_pch">pch</code></td>
<td>
<p>an integer specifying the symbol or the single character to be used in plotting points</p>
</td></tr>
<tr><td><code id="sco.class_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")*cpoint</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="sco.class_+3A_boxes">boxes</code></td>
<td>
<p>if TRUE, labels are framed</p>
</td></tr>
<tr><td><code id="sco.class_+3A_col">col</code></td>
<td>
<p>a vector of colors used to draw each class in a different color</p>
</td></tr>
<tr><td><code id="sco.class_+3A_lim">lim</code></td>
<td>
<p>the range for the x axis or y axis (if horizontal = FALSE), if NULL, they are computed</p>
</td></tr>
<tr><td><code id="sco.class_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="sco.class_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with par(&quot;cex&quot;)* <code>cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="sco.class_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should belong to the plot</p>
</td></tr>
<tr><td><code id="sco.class_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example c(0,0) the origin axes</p>
</td></tr>
<tr><td><code id="sco.class_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="sco.class_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="sco.class_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meau)
envpca &lt;- dudi.pca(meau$env, scannf=FALSE)
par(mfrow=c(2,1))
sco.class(envpca$li[,1],meau$design$season, col = 1:6)
sco.class(envpca$li[,1],meau$design$season, col = 1:4, reverse = TRUE)
</code></pre>

<hr>
<h2 id='sco.distri'>Representation by mean- standard deviation of a set of weight distributions on a numeric score</h2><span id='topic+sco.distri'></span>

<h3>Description</h3>

<p>represents the mean- standard deviation of a set of weight distributions on a numeric score. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sco.distri(score, df, y.rank = TRUE, csize = 1, labels = names(df), 
    clabel = 1, xlim = NULL, grid = TRUE, cgrid = 0.75,
    include.origin = TRUE, origin = 0, sub = NULL, csub = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sco.distri_+3A_score">score</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="sco.distri_+3A_df">df</code></td>
<td>
<p>a data frame with only positive or null values</p>
</td></tr>
<tr><td><code id="sco.distri_+3A_y.rank">y.rank</code></td>
<td>
<p>a logical value indicating whether the means should be classified in ascending order</p>
</td></tr>
<tr><td><code id="sco.distri_+3A_csize">csize</code></td>
<td>
<p>an integer indicating the size segment</p>
</td></tr>
<tr><td><code id="sco.distri_+3A_labels">labels</code></td>
<td>
<p>a vector of strings of characters for the labels of the variables</p>
</td></tr>
<tr><td><code id="sco.distri_+3A_clabel">clabel</code></td>
<td>
<p>if not NULL, a character size for the labels, used with  <code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="sco.distri_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x axis, if NULL they are computed</p>
</td></tr>
<tr><td><code id="sco.distri_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether the scale vertical lines should be drawn</p>
</td></tr>
<tr><td><code id="sco.distri_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with <code>par("cex")*cgrid</code> to indicate the mesh of the scale</p>
</td></tr>
<tr><td><code id="sco.distri_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should be belonged to the graph space</p>
</td></tr>
<tr><td><code id="sco.distri_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example c(0,0) the origin axes</p>
</td></tr>
<tr><td><code id="sco.distri_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="sco.distri_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an invisible data.frame with means and variances
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!adegraphicsLoaded()) {
  w &lt;- seq(-1, 1, le = 200)
  distri &lt;- data.frame(lapply(1:50, 
    function(x) sample((200:1)) * ((w &gt;= (- x / 50)) &amp; (w &lt;= x / 50))))
  names(distri) &lt;- paste("w", 1:50, sep = "")
  par(mfrow = c(1, 2))
  sco.distri(w, distri, csi = 1.5)
  sco.distri(w, distri, y.rank = FALSE, csi = 1.5)
  par(mfrow = c(1, 1))
  
  data(rpjdl)
  coa2 &lt;- dudi.coa(rpjdl$fau, FALSE)
  sco.distri(coa2$li[, 1], rpjdl$fau, lab = rpjdl$frlab, clab = 0.8)
  
  data(doubs)
  par(mfrow = c(2, 2))
  poi.coa &lt;- dudi.coa(doubs$fish, scann = FALSE)
  sco.distri(poi.coa$l1[, 1], doubs$fish)
  poi.nsc &lt;- dudi.nsc(doubs$fish, scann = FALSE)
  sco.distri(poi.nsc$l1[, 1], doubs$fish)
  s.label(poi.coa$l1)
  s.label(poi.nsc$l1)
  
  data(rpjdl)
  fau.coa &lt;- dudi.coa(rpjdl$fau, scann = FALSE)
  sco.distri(fau.coa$l1[,1], rpjdl$fau)
  fau.nsc &lt;- dudi.nsc(rpjdl$fau, scann = FALSE)
  sco.distri(fau.nsc$l1[,1], rpjdl$fau)
  s.label(fau.coa$l1)
  s.label(fau.nsc$l1)
  
  par(mfrow = c(1, 1))
}
</code></pre>

<hr>
<h2 id='sco.gauss'>Relationships between one score and qualitative variables</h2><span id='topic+sco.gauss'></span>

<h3>Description</h3>

<p>Draws Gauss curves with the same mean and variance as the scores of indivivuals belonging to categories of several qualitative variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sco.gauss(score, df, xlim = NULL, steps = 200, ymax = NULL, sub =
names(df), csub = 1.25, possub = "topleft", legen =TRUE, label = row.names(df),
clabel = 1, grid = TRUE, cgrid = 1, include.origin = TRUE, origin = c(0, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sco.gauss_+3A_score">score</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_df">df</code></td>
<td>
<p>a dataframe containing only factors, number of rows equal to the length of the score vector</p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_xlim">xlim</code></td>
<td>
<p>starting point and end point for drawing the Gauss curves</p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_steps">steps</code></td>
<td>
<p>number of segments for drawing the Gauss curves</p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_ymax">ymax</code></td>
<td>
<p>max ordinate for all Gauss curves. If NULL, ymax is
computed and different for each factor</p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_sub">sub</code></td>
<td>
<p>vector of strings of characters for the lables of qualitative variables</p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_csub">csub</code></td>
<td>
<p>character size for the legend</p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_legen">legen</code></td>
<td>
<p>if TRUE, the first graphic of the series displays the score with evenly spaced labels (see <code>sco.label</code>)</p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_label">label</code></td>
<td>
<p>labels for the score</p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_clabel">clabel</code></td>
<td>
<p>a character size for the labels, used with
<code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with par(&quot;cex&quot;)*<code>cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should belong to the plot</p>
</td></tr>
<tr><td><code id="sco.gauss_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example c(0,0) the origin axes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes one vector containing quantitative values (score) and one dataframe containing only factors
that give categories to wich the quantitative values belong. Computes the mean and variance
of the values in each category of each factor, and draws a Gauss curve with
the same mean and variance for each category of each factor.
Can optionaly set the start and end point of the curves and the number of
segments. The max ordinate (ymax) can also be set arbitrarily to set a common
max for all factors (else the max is different for each factor).
</p>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse, Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meau)
envpca &lt;- dudi.pca(meau$env, scannf=FALSE)
dffac &lt;- cbind.data.frame(meau$design$season, meau$design$site)
sco.gauss(envpca$li[,1], dffac, clabel = 2, csub = 2)
</code></pre>

<hr>
<h2 id='sco.label'>1D plot of a numeric score with labels</h2><span id='topic+sco.label'></span>

<h3>Description</h3>

<p>Draws evenly spaced labels, each label linked to the corresponding value of a numeric score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sco.label(score, label = names(score), clabel = 1, horizontal = TRUE,
reverse = FALSE, pos.lab = 0.5, pch = 20, cpoint = 1, boxes = TRUE, lim
= NULL, grid = TRUE, cgrid = 1, include.origin = TRUE, origin = c(0, 0),
sub = "", csub = 1.25, possub = "bottomleft")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sco.label_+3A_score">score</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="sco.label_+3A_label">label</code></td>
<td>
<p>labels for the score</p>
</td></tr>
<tr><td><code id="sco.label_+3A_clabel">clabel</code></td>
<td>
<p>a character size for the labels, used with
<code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="sco.label_+3A_horizontal">horizontal</code></td>
<td>
<p>logical. If TRUE, the plot is horizontal</p>
</td></tr>
<tr><td><code id="sco.label_+3A_reverse">reverse</code></td>
<td>
<p>logical. If horizontal = TRUE and reverse=TRUE, the
plot is at the bottom, if reverse = FALSE, the plot is at the top. If
horizontal = FALSE, the plot is at the right (TRUE) or at the left
(FALSE).</p>
</td></tr>
<tr><td><code id="sco.label_+3A_pos.lab">pos.lab</code></td>
<td>
<p>a values between 0 and 1 to manage the position of the labels.</p>
</td></tr>
<tr><td><code id="sco.label_+3A_pch">pch</code></td>
<td>
<p>an integer specifying the symbol or the single character to be used in plotting points</p>
</td></tr>
<tr><td><code id="sco.label_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")*cpoint</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="sco.label_+3A_boxes">boxes</code></td>
<td>
<p>if TRUE, labels are framed</p>
</td></tr>
<tr><td><code id="sco.label_+3A_lim">lim</code></td>
<td>
<p>the range for the x axis or y axis (if horizontal = FALSE), if NULL, they are computed</p>
</td></tr>
<tr><td><code id="sco.label_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="sco.label_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with par(&quot;cex&quot;)* <code>cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="sco.label_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should belong to the plot</p>
</td></tr>
<tr><td><code id="sco.label_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example c(0,0) the origin axes</p>
</td></tr>
<tr><td><code id="sco.label_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="sco.label_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="sco.label_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>, Jean Thioulouse</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meau)
envpca &lt;- dudi.pca(meau$env, scannf=FALSE)
par(mfrow=c(2,1))
sco.label(envpca$l1[,1], row.names(envpca$l1), lim=c(-1,3.5))
sco.label(envpca$co[,1], row.names(envpca$co), reverse = TRUE, lim=c(-1,3.5))
</code></pre>

<hr>
<h2 id='sco.match'>1D plot of a pair of numeric scores with labels</h2><span id='topic+sco.match'></span>

<h3>Description</h3>

<p>Draws evenly spaced labels, each label linked to the corresponding values of two numeric score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sco.match(score1, score2, label = names(score1), clabel = 1, 
    horizontal = TRUE, reverse = FALSE, pos.lab = 0.5, wmatch = 3, 
    pch = 20, cpoint = 1, boxes = TRUE, lim = NULL, grid = TRUE, 
    cgrid = 1, include.origin = TRUE, origin = c(0, 0), sub = "", 
    csub = 1.25, possub = "bottomleft")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sco.match_+3A_score1">score1</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="sco.match_+3A_score2">score2</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="sco.match_+3A_label">label</code></td>
<td>
<p>labels for the score</p>
</td></tr>
<tr><td><code id="sco.match_+3A_clabel">clabel</code></td>
<td>
<p>a character size for the labels, used with
<code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="sco.match_+3A_horizontal">horizontal</code></td>
<td>
<p>logical. If TRUE, the plot is horizontal</p>
</td></tr>
<tr><td><code id="sco.match_+3A_reverse">reverse</code></td>
<td>
<p>logical. If horizontal = TRUE and reverse=TRUE, the
plot is at the bottom, if reverse = FALSE, the plot is at the top. If
horizontal = FALSE, the plot is at the right (TRUE) or at the left
(FALSE).</p>
</td></tr>
<tr><td><code id="sco.match_+3A_pos.lab">pos.lab</code></td>
<td>
<p>a values between 0 and 1 to manage the position of the
labels.</p>
</td></tr>
<tr><td><code id="sco.match_+3A_wmatch">wmatch</code></td>
<td>
<p>a numeric values to specify the width of the matching
region in the plot. The width is equal to wmatch * the height of character</p>
</td></tr>
<tr><td><code id="sco.match_+3A_pch">pch</code></td>
<td>
<p>an integer specifying the symbol or the single character to be used in plotting points</p>
</td></tr>
<tr><td><code id="sco.match_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")*cpoint</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="sco.match_+3A_boxes">boxes</code></td>
<td>
<p>if TRUE, labels are framed</p>
</td></tr>
<tr><td><code id="sco.match_+3A_lim">lim</code></td>
<td>
<p>the range for the x axis or y axis (if horizontal = FALSE), if NULL, they are computed</p>
</td></tr>
<tr><td><code id="sco.match_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
<tr><td><code id="sco.match_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with par(&quot;cex&quot;)* <code>cgrid</code> to indicate the mesh of the grid</p>
</td></tr>
<tr><td><code id="sco.match_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should belong to the plot</p>
</td></tr>
<tr><td><code id="sco.match_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example c(0,0) the origin axes</p>
</td></tr>
<tr><td><code id="sco.match_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="sco.match_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="sco.match_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matched call.
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>sco.match(-5:5,2*(-5:5))
</code></pre>

<hr>
<h2 id='sco.quant'>Graph to Analyse the Relation between a Score and Quantitative Variables</h2><span id='topic+sco.quant'></span>

<h3>Description</h3>

<p>represents the graphs to analyse the relation between a score and quantitative variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sco.quant (score, df, fac = NULL, clabel = 1, abline = FALSE, 
    sub = names(df), csub = 2, possub = "topleft") 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sco.quant_+3A_score">score</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="sco.quant_+3A_df">df</code></td>
<td>
<p>a data frame which rows equal to the score length</p>
</td></tr>
<tr><td><code id="sco.quant_+3A_fac">fac</code></td>
<td>
<p>a factor with the same length than the score</p>
</td></tr>
<tr><td><code id="sco.quant_+3A_clabel">clabel</code></td>
<td>
<p>character size for the class labels (if any) used with <code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="sco.quant_+3A_abline">abline</code></td>
<td>
<p>a logical value indicating whether a regression line should be added</p>
</td></tr>
<tr><td><code id="sco.quant_+3A_sub">sub</code></td>
<td>
<p>a vector of strings of characters for the labels of variables</p>
</td></tr>
<tr><td><code id="sco.quant_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="sco.quant_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- runif(100, -5, 10)
fw &lt;- cut (w, 5)
levels(fw) &lt;- LETTERS[1:5]
wX &lt;- data.frame(matrix(w + rnorm(900, sd = (1:900) / 100), 100, 9))
sco.quant(w, wX, fac = fw, abline = TRUE, clab = 2, csub = 3)
</code></pre>

<hr>
<h2 id='score'>Graphs for One Dimension</h2><span id='topic+score'></span><span id='topic+scoreutil.base'></span>

<h3>Description</h3>

<p>score is a generic function. It proposes methods for the objects 'coa', 'acm', 'mix', 'pca'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>score(x, ...)
scoreutil.base(y, xlim, grid, cgrid, include.origin, origin, sub, csub) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_+3A_x">x</code></td>
<td>
<p>an object used to select a method</p>
</td></tr>
<tr><td><code id="score_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="score_+3A_y">y</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="score_+3A_xlim">xlim</code></td>
<td>
<p>the ranges to be encompassed by the x axis, if NULL they are computed</p>
</td></tr>
<tr><td><code id="score_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether the scale vertical lines should be drawn</p>
</td></tr>
<tr><td><code id="score_+3A_cgrid">cgrid</code></td>
<td>
<p>a character size, parameter used with <code>par("cex")*cgrid</code> to indicate the mesh of the scale</p>
</td></tr>
<tr><td><code id="score_+3A_include.origin">include.origin</code></td>
<td>
<p>a logical value indicating whether the point &quot;origin&quot; should be belonged to the graph space</p>
</td></tr>
<tr><td><code id="score_+3A_origin">origin</code></td>
<td>
<p>the fixed point in the graph space, for example 0 the origin axis</p>
</td></tr>
<tr><td><code id="score_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="score_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>scoreutil.base</code> is a utility function - not for the user - to define the bottom of the layout of all <code>score</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>See Also</h3>

<p><code><a href="#topic+sco.boxplot">sco.boxplot</a></code>, <code><a href="#topic+sco.distri">sco.distri</a></code>, <code><a href="#topic+sco.quant">sco.quant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
par(mar = c(1, 1, 1, 1))
ade4:::scoreutil.base (runif(20, 3, 7), xlim = NULL, grid = TRUE, cgrid = 0.8, 
  include.origin = TRUE, origin = 0, sub = "Uniform", csub = 1)
## End(Not run)
# returns the value of the user coordinate of the low line.  
# The user window id defined with c(0,1) in ordinate.
# box()
</code></pre>

<hr>
<h2 id='score.acm'>Graphs to study one factor in a Multiple Correspondence Analysis</h2><span id='topic+score.acm'></span>

<h3>Description</h3>

<p>performs the canonical graph of a Multiple Correspondence Analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'acm'
score(x, xax = 1, which.var = NULL, mfrow = NULL, 
    sub = names(oritab), csub = 2, possub = "topleft", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.acm_+3A_x">x</code></td>
<td>
<p>an object of class <code>acm</code></p>
</td></tr>
<tr><td><code id="score.acm_+3A_xax">xax</code></td>
<td>
<p>the column number for the used axis</p>
</td></tr>
<tr><td><code id="score.acm_+3A_which.var">which.var</code></td>
<td>
<p>the numbers of the kept columns for the analysis, otherwise all columns</p>
</td></tr>
<tr><td><code id="score.acm_+3A_mfrow">mfrow</code></td>
<td>
<p>a vector of the form &quot;c(nr,nc)&quot;, otherwise computed by a special own function <code>n2mfrow</code></p>
</td></tr>
<tr><td><code id="score.acm_+3A_sub">sub</code></td>
<td>
<p>a vector of strings of characters to be inserted as sub-titles, otherwise the variable names of the initial array</p>
</td></tr>
<tr><td><code id="score.acm_+3A_csub">csub</code></td>
<td>
<p>a character size for the sub-titles</p>
</td></tr>
<tr><td><code id="score.acm_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="score.acm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(banque)
banque.acm &lt;- dudi.acm(banque, scann = FALSE, nf = 3)
score(banque.acm, which = which(banque.acm$cr[, 1] &gt; 0.2))
</code></pre>

<hr>
<h2 id='score.coa'>Reciprocal scaling after a correspondence analysis</h2><span id='topic+score.coa'></span><span id='topic+reciprocal.coa'></span>

<h3>Description</h3>

<p>performs the canonical graph of a correspondence analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coa'
score(x, xax = 1, dotchart = FALSE, clab.r = 1, clab.c = 1, 
    csub = 1, cpoi = 1.5, cet = 1.5, ...)
reciprocal.coa(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.coa_+3A_x">x</code></td>
<td>
<p>an object of class <code>coa</code></p>
</td></tr>
<tr><td><code id="score.coa_+3A_xax">xax</code></td>
<td>
<p>the column number for the used axis</p>
</td></tr>
<tr><td><code id="score.coa_+3A_dotchart">dotchart</code></td>
<td>
<p>if TRUE the graph gives a &quot;dual scaling&quot;, if FALSE a &quot;reciprocal scaling&quot;</p>
</td></tr>
<tr><td><code id="score.coa_+3A_clab.r">clab.r</code></td>
<td>
<p>a character size for row labels</p>
</td></tr>
<tr><td><code id="score.coa_+3A_clab.c">clab.c</code></td>
<td>
<p>a character size for column labels</p>
</td></tr>
<tr><td><code id="score.coa_+3A_csub">csub</code></td>
<td>
<p>a character size for the sub-titles, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="score.coa_+3A_cpoi">cpoi</code></td>
<td>
<p>a character size for the points</p>
</td></tr>
<tr><td><code id="score.coa_+3A_cet">cet</code></td>
<td>
<p>a coefficient for the size of segments in standard deviation</p>
</td></tr>
<tr><td><code id="score.coa_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a &quot;reciprocal scaling&quot;, the reference score is a numeric code centred and normalized of the non zero cells of the array which both maximizes the variance of means by row and by column. The bars are drawn with half the length of this standard deviation.
</p>


<h3>Value</h3>

<p>return a data.frame with the scores, weights and factors of
correspondences (non zero cells)</p>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>References</h3>

<p>Thioulouse, J. and Chessel D. (1992) A method for reciprocal scaling of species tolerance and sample diversity. <em>Ecology</em>, <b>73</b>, 670&ndash;680.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout(matrix(c(1,1,2,3), 2, 2), resp = FALSE)
data(aviurba)
dd1 &lt;- dudi.coa(aviurba$fau, scan = FALSE)
score(dd1, clab.r = 0, clab.c = 0.75)
recscal &lt;- reciprocal.coa(dd1)
head(recscal)
abline(v = 1, lty = 2, lwd = 3)
sco.distri(dd1$l1[,1], aviurba$fau)
sco.distri(dd1$c1[,1], data.frame(t(aviurba$fau)))

# 1 reciprocal scaling correspondence score -&gt; species amplitude + sample diversity
# 2 sample score -&gt; averaging -&gt; species amplitude
# 3 species score -&gt; averaging -&gt; sample diversity

layout(matrix(c(1,1,2,3), 2, 2), resp = FALSE)
data(rpjdl)
rpjdl1 &lt;- dudi.coa(rpjdl$fau, scan = FALSE)
score(rpjdl1, clab.r = 0, clab.c = 0.75)
if (requireNamespace("MASS", quietly = TRUE)) {
   data(caith, package = "MASS")
   score(dudi.coa(caith, scan = FALSE), clab.r = 1.5, clab.c = 1.5, cpoi = 3)
   data(housetasks)
   score(dudi.coa(housetasks, scan = FALSE), clab.r = 1.25, clab.c = 1.25, 
        csub = 0, cpoi = 3)
}
par(mfrow = c(1,1))
score(rpjdl1, dotchart = TRUE, clab.r = 0)
</code></pre>

<hr>
<h2 id='score.mix'>Graphs to Analyse a factor in a Mixed Analysis</h2><span id='topic+score.mix'></span>

<h3>Description</h3>

<p>performs the canonical graph of a mixed analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mix'
score(x, xax = 1, csub = 2, mfrow = NULL, which.var = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.mix_+3A_x">x</code></td>
<td>
<p>an object of class <code>mix</code></p>
</td></tr>
<tr><td><code id="score.mix_+3A_xax">xax</code></td>
<td>
<p>the column number for the used axis</p>
</td></tr>
<tr><td><code id="score.mix_+3A_csub">csub</code></td>
<td>
<p>a character size for the sub-titles, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="score.mix_+3A_mfrow">mfrow</code></td>
<td>
<p>a vector of the form &quot;c(nr,nc)&quot;, otherwise computed by a special own function <code>n2mfrow</code></p>
</td></tr>
<tr><td><code id="score.mix_+3A_which.var">which.var</code></td>
<td>
<p>the numbers of the kept columns for the analysis, otherwise all columns </p>
</td></tr>
<tr><td><code id="score.mix_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lascaux)
w &lt;- cbind.data.frame(lascaux$colo, lascaux$ornem)
dd &lt;- dudi.mix(w, scan = FALSE, nf = 4, add = TRUE)
score(dd, which = which(dd$cr[,1] &gt; 0.3))
</code></pre>

<hr>
<h2 id='score.pca'>Graphs to Analyse a factor in PCA</h2><span id='topic+score.pca'></span>

<h3>Description</h3>

<p>performs the canonical graph of a Principal Component Analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pca'
score(x, xax = 1, which.var = NULL, mfrow = NULL, csub = 2, 
    sub = names(x$tab), abline = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.pca_+3A_x">x</code></td>
<td>
<p>an object of class <code>pca</code></p>
</td></tr>
<tr><td><code id="score.pca_+3A_xax">xax</code></td>
<td>
<p>the column number for the used axis</p>
</td></tr>
<tr><td><code id="score.pca_+3A_which.var">which.var</code></td>
<td>
<p>the numbers of the kept columns for the analysis, otherwise all columns</p>
</td></tr>
<tr><td><code id="score.pca_+3A_mfrow">mfrow</code></td>
<td>
<p>a vector of the form &quot;c(nr,nc)&quot;, otherwise computed by a special own function <code>n2mfrow</code></p>
</td></tr>
<tr><td><code id="score.pca_+3A_csub">csub</code></td>
<td>
<p>a character size for sub-titles, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="score.pca_+3A_sub">sub</code></td>
<td>
<p>a vector of string of characters to be inserted as sub-titles, otherwise the names of the variables</p>
</td></tr>
<tr><td><code id="score.pca_+3A_abline">abline</code></td>
<td>
<p>a logical value indicating whether a regression line should be added</p>
</td></tr>
<tr><td><code id="score.pca_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deug)
dd1 &lt;- dudi.pca(deug$tab, scan = FALSE)
score(dd1)
 
# The correlations are :
dd1$co[,1]
# [1] 0.7925 0.6532 0.7410 0.5287 0.5539 0.7416 0.3336 0.2755 0.4172
</code></pre>

<hr>
<h2 id='seconde'>Students and  Subjects</h2><span id='topic+seconde'></span>

<h3>Description</h3>

<p>The <code>seconde</code> data frame gives the marks of 22 students for 8 subjects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(seconde)</code></pre>


<h3>Format</h3>

<p>This data frame (22,8) contains the following columns:
- HGEO: History and Geography
- FRAN: French literature
- PHYS: Physics
- MATH: Mathematics
- BIOL: Biology
- ECON: Economy
- ANGL: English language
- ESPA: Spanish language
</p>


<h3>Source</h3>

<p>Personal communication
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(seconde)
if(adegraphicsLoaded()) {
  scatter(dudi.pca(seconde, scan = FALSE), row.plab.cex = 1, col.plab.cex = 1.5)
} else {
  scatter(dudi.pca(seconde, scan = FALSE), clab.r = 1, clab.c = 1.5)
}
</code></pre>

<hr>
<h2 id='sepan'>Separated Analyses in a K-tables</h2><span id='topic+sepan'></span><span id='topic+plot.sepan'></span><span id='topic+print.sepan'></span><span id='topic+summary.sepan'></span>

<h3>Description</h3>

<p>performs K separated multivariate analyses of an object of class <code>ktab</code> 
containing K tables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sepan(X, nf = 2)
## S3 method for class 'sepan'
plot(x, mfrow = NULL, csub = 2, ...)
## S3 method for class 'sepan'
summary(object, ...)
## S3 method for class 'sepan'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sepan_+3A_x">X</code></td>
<td>
<p>an object of class <code>ktab</code></p>
</td></tr>
<tr><td><code id="sepan_+3A_nf">nf</code></td>
<td>
<p>an integer indicating the number of kept axes for each separated analysis</p>
</td></tr>  
<tr><td><code id="sepan_+3A_x">x</code>, <code id="sepan_+3A_object">object</code></td>
<td>
<p>an object of class 'sepan'</p>
</td></tr>
<tr><td><code id="sepan_+3A_mfrow">mfrow</code></td>
<td>
<p>a vector of the form &quot;c(nr,nc)&quot;, otherwise computed by a special own function <code>n2mfrow</code></p>
</td></tr>
<tr><td><code id="sepan_+3A_csub">csub</code></td>
<td>
<p>a character size for the sub-titles, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="sepan_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plot on a <code>sepan</code> object allows to compare inertias and structures between arrays.
In black, the eigenvalues of kept axes in the object 'sepan'.
</p>


<h3>Value</h3>

<p>returns a list of class 'sepan' containing :
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>a call order</p>
</td></tr>
<tr><td><code>tab.names</code></td>
<td>
<p>a vector of characters with the names of tables</p>
</td></tr>
<tr><td><code>blo</code></td>
<td>
<p>a numeric vector with the numbers of columns for each table</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>a numeric vector with the rank of the studied matrix for each table</p>
</td></tr>
<tr><td><code>Eig</code></td>
<td>
<p>a numeric vector with all the eigenvalues</p>
</td></tr>
<tr><td><code>Li</code></td>
<td>
<p>a data frame with the row coordinates</p>
</td></tr>
<tr><td><code>L1</code></td>
<td>
<p>a data frame with the row normed scores</p>
</td></tr>
<tr><td><code>Co</code></td>
<td>
<p>a data frame with the column coordinates</p>
</td></tr>
<tr><td><code>C1</code></td>
<td>
<p>a data frame with the column normed coordinates</p>
</td></tr>
<tr><td><code>TL</code></td>
<td>
<p>a data frame with the factors for Li L1</p>
</td></tr>
<tr><td><code>TC</code></td>
<td>
<p>a data frame with the factors for Co C1</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(escopage)
w &lt;- data.frame(scale(escopage$tab))
w &lt;- ktab.data.frame(w, escopage$blo, tabnames = escopage$tab.names)
sep1 &lt;- sepan(w)
sep1
summary(sep1)
plot(sep1)
</code></pre>

<hr>
<h2 id='skulls'>Morphometric Evolution</h2><span id='topic+skulls'></span>

<h3>Description</h3>

<p>This data set gives four anthropometric measures of 150 Egyptean 
skulls belonging to five different historical periods. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(skulls)</code></pre>


<h3>Format</h3>

<p>The <code>skulls</code> data frame has 150 rows (egyptean skulls) and 4 columns (anthropometric measures). 
The four variables are the maximum breadth (V1), the basibregmatic height (V2), the basialveolar length (V3)
and the nasal height (V4). All measurements were taken in millimeters.
</p>


<h3>Details</h3>

<p>The measurements are made on 5 groups and 30 Egyptian skulls. The groups are defined as follows :<br />
1 - the early predynastic period (circa 4000 BC)<br />
2 - the late predynastic period (circa 3300 BC)<br />
3 - the 12th and 13th dynasties (circa 1850 BC)<br />
4 - the Ptolemiac period (circa 200 BC)<br />
5 - the Roman period (circa 150 BC)<br />
</p>


<h3>Source</h3>

<p>Thompson, A. and Randall-Maciver, R. (1905) <em>Ancient races of the Thebaid</em>, Oxford University Press.
</p>


<h3>References</h3>

<p>Manly, B.F. (1994) <em>Multivariate Statistical Methods. A primer</em>, 
Second edition. Chapman &amp; Hall, London. 1&ndash;215.<br />
The example is treated pp. 6, 13, 51, 64, 72, 107, 112 and 117.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(skulls)
pca1 &lt;- dudi.pca(skulls, scan = FALSE)
fac &lt;- gl(5, 30)
levels(fac) &lt;- c("-4000", "-3300", "-1850", "-200", "+150")
dis.skulls &lt;- discrimin(pca1, fac, scan = FALSE)
if(!adegraphicsLoaded())
  plot(dis.skulls, 1, 1)
</code></pre>

<hr>
<h2 id='statico'>STATIS and Co-Inertia : Analysis of a series of paired ecological tables</h2><span id='topic+statico'></span>

<h3>Description</h3>

<p>Does the analysis of a series of pairs of ecological tables. This function uses
Partial Triadic Analysis (<a href="#topic+pta">pta</a>) and <a href="#topic+ktab.match2ktabs">ktab.match2ktabs</a>
to do the computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statico(KTX, KTY, scannf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statico_+3A_ktx">KTX</code></td>
<td>
<p>an objet of class ktab</p>
</td></tr>
<tr><td><code id="statico_+3A_kty">KTY</code></td>
<td>
<p>an objet of class ktab</p>
</td></tr>
<tr><td><code id="statico_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes 2 ktabs and crosses each pair of tables of these ktabs with the function <a href="#topic+ktab.match2ktabs">ktab.match2ktabs</a>. It then does a partial triadic analysis on this new ktab with <a href="#topic+pta">pta</a>.
</p>


<h3>Value</h3>

<p>a list of class ktab, subclass kcoinertia. See <a href="#topic+ktab">ktab</a>
</p>


<h3>WARNING </h3>

<p>IMPORTANT : KTX and KTY must have the same k-tables structure, the same number
of columns, and the same column weights.
</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse <a href="mailto:jean.thioulouse@univ-lyon1.fr">jean.thioulouse@univ-lyon1.fr</a></p>


<h3>References</h3>

<p>Thioulouse J. (2011). Simultaneous analysis of a sequence of paired ecological tables: a comparison of several methods. <em>Annals of Applied Statistics</em>, <b>5</b>, 2300-2325.
Thioulouse J., Simier M. and Chessel D. (2004). Simultaneous analysis of a sequence of paired ecological tables.  <em>Ecology</em> <b>85</b>, 272-283.
Simier, M., Blanc L., Pellegrin F., and Nandris D. (1999). Approche simultanée de K couples de tableaux : 
Application a l'étude des relations pathologie végétale - environnement. <em>Revue de Statistique Appliquée</em>, <b>47</b>, 31-46.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meau)
wit1 &lt;- withinpca(meau$env, meau$design$season, scan = FALSE, scal = "total")
spepca &lt;- dudi.pca(meau$spe, scale = FALSE, scan = FALSE, nf = 2)
wit2 &lt;- wca(spepca, meau$design$season, scan = FALSE, nf = 2)
kta1 &lt;- ktab.within(wit1, colnames = rep(c("S1","S2","S3","S4","S5","S6"), 4))
kta2 &lt;- ktab.within(wit2, colnames = rep(c("S1","S2","S3","S4","S5","S6"), 4))
statico1 &lt;- statico(kta1, kta2, scan = FALSE)
plot(statico1)
kplot(statico1)
</code></pre>

<hr>
<h2 id='statico.krandtest'>Monte-Carlo test on a Statico analysis (in C).</h2><span id='topic+statico.krandtest'></span>

<h3>Description</h3>

<p>Performs the series of Monte-Carlo coinertia tests of a Statico analysis (one for each couple of tables). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statico.krandtest(KTX, KTY, nrepet = 999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statico.krandtest_+3A_ktx">KTX</code></td>
<td>
<p>an objet of class ktab containing the environmental data</p>
</td></tr>
<tr><td><code id="statico.krandtest_+3A_kty">KTY</code></td>
<td>
<p>an objet of class ktab containing the species data</p>
</td></tr>
<tr><td><code id="statico.krandtest_+3A_nrepet">nrepet</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
<tr><td><code id="statico.krandtest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes 2 ktabs and does a coinertia analysis with <a href="#topic+coinertia">coinertia</a> on each pair of tables. It then uses the <a href="#topic+randtest">randtest</a> function to do a permutation test on each of these coinertia analyses.
</p>


<h3>Value</h3>

<p>krandtest, a list of randtest objects. See <a href="#topic+krandtest">krandtest</a>
</p>


<h3>WARNING </h3>

<p>IMPORTANT : KTX and KTY must have the same k-tables structure, the same number
of columns, and the same column weights.
</p>


<h3>Author(s)</h3>

<p>Jean Thioulouse <a href="mailto:jean.thioulouse@univ-lyon1.fr">jean.thioulouse@univ-lyon1.fr</a></p>


<h3>References</h3>

<p>Thioulouse J. (2011). Simultaneous analysis of a sequence of paired ecological tables: a comparison of several methods. <em>Annals of Applied Statistics</em>, <b>5</b>, 2300-2325.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meau)
wit1 &lt;- withinpca(meau$env, meau$design$season, scan = FALSE, scal = "total")
spepca &lt;- dudi.pca(meau$spe, scale = FALSE, scan = FALSE, nf = 2)
wit2 &lt;- wca(spepca, meau$design$season, scan = FALSE, nf = 2)
kta1 &lt;- ktab.within(wit1, colnames = rep(c("S1","S2","S3","S4","S5","S6"), 4))
kta2 &lt;- ktab.within(wit2, colnames = rep(c("S1","S2","S3","S4","S5","S6"), 4))
statico1 &lt;- statico(kta1, kta2, scan = FALSE)
kr1 &lt;- statico.krandtest(kta1, kta2)
plot(kr1)
</code></pre>

<hr>
<h2 id='statis'>STATIS, a method for analysing K-tables</h2><span id='topic+statis'></span><span id='topic+print.statis'></span><span id='topic+plot.statis'></span>

<h3>Description</h3>

<p>performs a STATIS analysis of a <code>ktab</code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statis(X, scannf = TRUE, nf = 3, tol = 1e-07)
## S3 method for class 'statis'
plot(x, xax = 1, yax = 2, option = 1:4, ...) 
## S3 method for class 'statis'
print(x, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statis_+3A_x">X</code></td>
<td>
<p>an object of class 'ktab'</p>
</td></tr>
<tr><td><code id="statis_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the number of kept axes for the compromise should be asked</p>
</td></tr>
<tr><td><code id="statis_+3A_nf">nf</code></td>
<td>
<p>if <code>scannf</code> FALSE, an integer indicating the number of kept axes for the compromise</p>
</td></tr>
<tr><td><code id="statis_+3A_tol">tol</code></td>
<td>
<p>a tolerance threshold to test whether the distance matrix is Euclidean : an eigenvalue is considered positive if it is larger than <code>-tol*lambda1</code> where <code>lambda1</code> is the largest eigenvalue</p>
</td></tr>
<tr><td><code id="statis_+3A_x">x</code></td>
<td>
<p>an object of class 'statis'</p>
</td></tr>
<tr><td><code id="statis_+3A_xax">xax</code>, <code id="statis_+3A_yax">yax</code></td>
<td>
<p>the numbers of the x-axis and the y-axis</p>
</td></tr>
<tr><td><code id="statis_+3A_option">option</code></td>
<td>
<p>an integer between 1 and 4, otherwise the 4 components of the plot are dispayed</p>
</td></tr>
<tr><td><code id="statis_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>statis</code> returns a list of class 'statis' containing :
</p>
<table>
<tr><td><code>RV</code></td>
<td>
<p>a matrix with the all RV coefficients</p>
</td></tr>
<tr><td><code>RV.eig</code></td>
<td>
<p>a numeric vector with all the eigenvalues</p>
</td></tr>
<tr><td><code>RV.coo</code></td>
<td>
<p>a data frame with the array scores</p>
</td></tr>
<tr><td><code>tab.names</code></td>
<td>
<p>a vector of characters with the names of the arrays</p>
</td></tr>
<tr><td><code>RV.tabw</code></td>
<td>
<p>a numeric vector with the array weigths</p>
</td></tr>
<tr><td><code>C.nf</code></td>
<td>
<p>an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code>C.rank</code></td>
<td>
<p>an integer indicating the rank of the analysis</p>
</td></tr>
<tr><td><code>C.li</code></td>
<td>
<p>a data frame with the row coordinates</p>
</td></tr>
<tr><td><code>C.Co</code></td>
<td>
<p>a data frame with the column coordinates</p>
</td></tr>
<tr><td><code>C.T4</code></td>
<td>
<p>a data frame with the principal vectors (for each table)</p>
</td></tr>
<tr><td><code>TL</code></td>
<td>
<p>a data frame with the factors (not used)</p>
</td></tr>
<tr><td><code>TC</code></td>
<td>
<p>a data frame with the factors for Co</p>
</td></tr>
<tr><td><code>T4</code></td>
<td>
<p>a data frame with the factors for T4</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel 
</p>


<h3>References</h3>

<p>Lavit, C. (1988) <em>Analyse conjointe de tableaux quantitatifs</em>, Masson, Paris.<br /><br />
Lavit, C., Escoufier, Y., Sabatier, R. and Traissac, P. (1994) The ACT (Statis method). <em>Computational Statistics and Data Analysis</em>, <b>18</b>, 97&ndash;119.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jv73)
kta1 &lt;- ktab.within(withinpca(jv73$morpho, jv73$fac.riv, scann = FALSE))
statis1 &lt;- statis(kta1, scann = FALSE)
plot(statis1)

dudi1 &lt;- dudi.pca(jv73$poi, scann = FALSE, scal = FALSE)
wit1 &lt;- wca(dudi1, jv73$fac.riv, scann = FALSE)
kta3 &lt;- ktab.within(wit1)
data(jv73)
statis3 &lt;- statis(kta3, scann = FALSE)
plot(statis3)

if(adegraphicsLoaded()) {
  s.arrow(statis3$C.li, pgrid.text.cex = 0)
  kplot(statis3, traj = TRUE, arrow = FALSE, plab.cex = 0, psub.cex = 3, ppoi.cex = 3)
} else {
  s.arrow(statis3$C.li, cgrid = 0)
  kplot(statis3, traj = TRUE, arrow = FALSE, unique = TRUE, 
    clab = 0, csub = 3, cpoi = 3)
}

statis3
</code></pre>

<hr>
<h2 id='steppe'>Transect in the Vegetation</h2><span id='topic+steppe'></span>

<h3>Description</h3>

<p>This data set gives the presence-absence of 37 species on 515 sites. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(steppe)</code></pre>


<h3>Format</h3>

<p><code>steppe</code> is a list of 2 components.
</p>

<dl>
<dt>tab</dt><dd><p>is a data frame with 512 rows (sites) and 37 variables (species) in presence-absence.</p>
</dd>
<dt>esp.names</dt><dd><p>is a vector of the species names.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Estève, J. (1978) Les méthodes d'ordination : éléments pour une discussion.
in J. M. Legay and R. Tomassone, editors. 
<em>Biométrie et Ecologie</em>, Société Française de Biométrie, Paris, 223&ndash;250. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(3,1))
data(steppe)
w1 &lt;- col(as.matrix(steppe$tab[,1:15]))
w1 &lt;- as.numeric(w1[steppe$tab[,1:15] &gt; 0])
w2 &lt;- row(as.matrix(steppe$tab[,1:15]))
w2 &lt;- as.numeric(w2[steppe$tab[,1:15] &gt; 0])
plot(w2, w1, pch = 20)
plot(dudi.pca(steppe$tab, scan = FALSE, scale = FALSE)$li[,1],
    pch = 20, ylab = "PCA", xlab = "", type = "b")
plot(dudi.coa(steppe$tab, scan = FALSE)$li[,1], pch = 20, 
    ylab = "COA", xlab = "", type = "b")
par(mfrow = c(1,1))
</code></pre>

<hr>
<h2 id='supcol'>Projections of Supplementary Columns</h2><span id='topic+supcol'></span><span id='topic+supcol.coa'></span><span id='topic+supcol.dudi'></span>

<h3>Description</h3>

<p>performs projections of supplementary columns. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supcol(x, ...)
## S3 method for class 'dudi'
supcol(x, Xsup, ...) 
## S3 method for class 'coa'
supcol(x, Xsup, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supcol_+3A_x">x</code></td>
<td>
<p>an object used to select a method</p>
</td></tr>
<tr><td><code id="supcol_+3A_xsup">Xsup</code></td>
<td>
<p>an array with the supplementary columns (<code>Xsup</code> and <code>x$tab</code> have the same row number)</p>
</td></tr>
<tr><td><code id="supcol_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>supcol.dudi</code> is used, the column vectors of <code>Xsup</code> are projected without prior modification onto the principal components of dudi with the scalar product associated to the row weightings of dudi.
</p>


<h3>Value</h3>

<p>A list of two components:
</p>
<table>
<tr><td><code>tabsup</code></td>
<td>
<p>data frame containing the array with the supplementary columns transformed or not</p>
</td></tr>
<tr><td><code>cosup</code></td>
<td>
<p>data frame containing the coordinates of the supplementary projections</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rpjdl)
rpjdl.coa &lt;- dudi.coa(rpjdl$fau, scan = FALSE, nf = 4)
rpjdl.coa$co[1:3, ]
supcol(rpjdl.coa, rpjdl$fau[, 1:3])$cosup  #the same

data(doubs)
dudi1 &lt;- dudi.pca(doubs$fish, scal = FALSE, scan = FALSE)
if(adegraphicsLoaded()) {
  g1 &lt;- s.arrow(dudi1$co, plot = FALSE)
  g2 &lt;- s.arrow(supcol(dudi1, data.frame(scalewt(doubs$env)))$cosup, plab.cex = 2, plot = FALSE)
  G &lt;- superpose(g1, g2, plot = TRUE)
  
} else {
  s.arrow(dudi1$co)
  s.arrow(supcol(dudi1, data.frame(scalewt(doubs$env)))$cosup, add.p = TRUE, clab = 2)
  symbols(0, 0, circles = 1, inches = FALSE, add = TRUE)
}
</code></pre>

<hr>
<h2 id='supdist'>
Projection of additional items in a PCO analysis
</h2><span id='topic+supdist'></span>

<h3>Description</h3>

<p>This function takes the grand distance matrix between all items (Active + 
Supplementary). It computes the PCO of the distance matrix between Active items, 
and projects the distance matrix of Supplementary items in this PCO.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supdist(d, fsup, tol = 1e-07)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supdist_+3A_d">d</code></td>
<td>
<p>Grand distance matrix between all (Active + Supplementary) items</p>
</td></tr>
<tr><td><code id="supdist_+3A_fsup">fsup</code></td>
<td>
<p>A factor with two levels giving the Active (level &lsquo;A&rsquo;) or 
Supplementary (level &lsquo;S&rsquo;) status for each item in the distance matrix.</p>
</td></tr>
<tr><td><code id="supdist_+3A_tol">tol</code></td>
<td>
<p>Numeric tolerance used to evaluate zero eigenvalues</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>coordSup</code></td>
<td>
<p>Coordinates of Supplementary items projected in the PCO of Active items</p>
</td></tr>
<tr><td><code>coordAct</code></td>
<td>
<p>Coordinates of Active item</p>
</td></tr>
<tr><td><code>coordTot</code></td>
<td>
<p>Coordinates of Active plus Supplementary items</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jean Thioulouse</p>


<h3>References</h3>

<p>Computations based on the Methods section of the following paper:
Pele J, Abdi H, Moreau M, Thybert D, Chabbert M (2011) Multidimensional Scaling 
Reveals the Main Evolutionary Pathways of Class A G-Protein-Coupled Receptors. 
PLoS ONE 6(4): e19094. <a href="https://doi.org/10.1371/journal.pone.0019094">doi:10.1371/journal.pone.0019094</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dudi.pco">dudi.pco</a></code>, <code><a href="#topic+suprow">suprow</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meau)
## Case 1: Supplementary items = subset of Active items
## Supplementary coordinates should be equal to Active coordinates
## PCO of active items (meau dataset has 6 sites and 10 variables)
envpca1 &lt;- dudi.pca(meau$env, scannf = FALSE)
dAct &lt;- dist(envpca1$tab)
pco1 &lt;- dudi.pco(dAct, scannf = FALSE)
## Projection of rows 19:24 (winter season for the 6 sites)
## Supplementary items must be normalized
f1 &lt;- function(w) (w - envpca1$cent) / envpca1$norm
envSup &lt;- t(apply(meau$env[19:24, ], 1, f1))
envTot &lt;- rbind.data.frame(envpca1$tab, envSup)
dTot &lt;- dist(envTot)
fSA1 &lt;- as.factor(rep(c("A", "S"), c(24, 6)))
cSup1 &lt;- supdist(dTot, fSA1)
## Comparison (coordinates should be equal)
cSup1$coordSup[, 1:2]
pco1$li[19:24, ]

data(meaudret)
## Case 2: Supplementary items = new items
## PCO of active items (meaudret dataset has only 5 sites and 9 variables)
envpca2 &lt;- dudi.pca(meaudret$env, scannf = FALSE)
dAct &lt;- dist(envpca2$tab)
pco2 &lt;- dudi.pco(dAct, scannf = FALSE)
## Projection of site 6 (four seasons, without Oxyg variable)
## Supplementary items must be normalized
f1 &lt;- function(w) (w - envpca2$cent) / envpca2$norm
envSup &lt;- t(apply(meau$env[seq(6, 24, 6), -5], 1, f1))
envTot &lt;- rbind.data.frame(envpca2$tab, envSup)
dTot &lt;- dist(envTot)
fSA2 &lt;- as.factor(rep(c("A", "S"), c(20, 4)))
cSup2 &lt;- supdist(dTot, fSA2)
## Supplementary items vs. real items (both in red)
if(!adegraphicsLoaded()) {
 par(mfrow = c(2, 2))
 s.label(pco1$li, boxes = FALSE)
 s.label(rbind.data.frame(pco2$li, cSup2$coordSup[, 1:2]), boxes = FALSE)
} else {
 gl1 &lt;- s.label(pco1$li, plabels.optim = TRUE, plabels.col=rep(c(rep("black", 5),"red"), 4))
 gl2 &lt;- s.label(rbind.data.frame(pco2$li, cSup2$coordSup[, 1:2]),
  plabels.optim = TRUE, plabels.col=rep(c("black","red"),c(20, 4)))
 ADEgS(list(gl1, gl2))
}
</code></pre>

<hr>
<h2 id='suprow'>Projections of Supplementary Rows</h2><span id='topic+suprow'></span><span id='topic+suprow.coa'></span><span id='topic+suprow.pca'></span><span id='topic+suprow.dudi'></span><span id='topic+suprow.fca'></span><span id='topic+predict.dudi'></span><span id='topic+suprow.acm'></span><span id='topic+suprow.mix'></span>

<h3>Description</h3>

<p>This function performs a projection of supplementary rows (i.e. supplementary individuals). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'coa'
suprow(x, Xsup, ...) 
## S3 method for class 'dudi'
suprow(x, Xsup, ...) 
## S3 method for class 'dudi'
predict(object, newdata, ...) 
## S3 method for class 'pca'
suprow(x, Xsup, ...)
## S3 method for class 'acm'
suprow(x, Xsup, ...) 
## S3 method for class 'mix'
suprow(x, Xsup, ...)
## S3 method for class 'fca'
suprow(x, Xsup, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suprow_+3A_x">x</code>, <code id="suprow_+3A_object">object</code></td>
<td>
<p>an object of class <code>dudi</code></p>
</td></tr>
<tr><td><code id="suprow_+3A_xsup">Xsup</code>, <code id="suprow_+3A_newdata">newdata</code></td>
<td>
<p>an array with the supplementary rows</p>
</td></tr>
<tr><td><code id="suprow_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>suprow.dudi</code> is used, the column vectors of Xsup are projected without prior modifications onto the principal components of dudi with the scalar product associated to the row weightings of dudi.
</p>


<h3>Value</h3>

<p><code>predict</code> returns a data frame containing the coordinates of the supplementary rows. <code>suprow</code> returns a list with the transformed table <code>Xsup</code> in <code>tabsup</code> and the coordinates of the supplementary rows in <code>lisup</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Gower, J. C. (1967) Multivariate analysis and multivariate geometry. <em>The statistician</em>, <b>17</b>, 13&ndash;28.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(euro123)
par(mfrow = c(2, 2))
w &lt;- euro123[[2]]
dudi1 &lt;- dudi.pca(w, scal = FALSE, scan = FALSE)

if(adegraphicsLoaded()) {
  g11 &lt;- s.arrow(dudi1$c1, psub.text = "Classical", psub.posi = "bottomright", plot = FALSE)
  g12 &lt;- s.label(suprow(dudi1, w)$tabsup, plab.cex = 0.75, plot = FALSE)
  g1 &lt;- superpose(g11, g12)
  
  g21 &lt;- s.arrow(dudi1$c1, psub.text = "Without centring", psub.posi = "bottomright", plot = FALSE)
  g22 &lt;- s.label(suprow(dudi1, w)$tabsup, plab.cex = 0.75, plot = FALSE)
  g2 &lt;- superpose(g21, g22) 
  
  g3 &lt;- triangle.label(w, plab.cex = 0.75, label = row.names(w), adjust = FALSE, plot = FALSE)
  g4 &lt;- triangle.label(w, plab.cex = 0.75, label = row.names(w), adjust = TRUE, plot = FALSE)
  
  G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  
} else {
  s.arrow(dudi1$c1, sub = "Classical", possub = "bottomright", csub = 2.5)
  s.label(suprow(dudi1, w), add.plot = TRUE, clab = 0.75)
  
  s.arrow(dudi1$c1, sub = "Without centring", possub = "bottomright", csub = 2.5)
  s.label(suprow(dudi1, w), clab = 0.75, add.plot = TRUE)
  
  triangle.plot(w, clab = 0.75, label = row.names(w), scal = FALSE)
  triangle.plot(w, clab = 0.75, label = row.names(w), scal = TRUE)
}

data(rpjdl)
rpjdl.coa &lt;- dudi.coa(rpjdl$fau, scann = FALSE, nf = 4)
rpjdl.coa$li[1:3, ]
suprow(rpjdl.coa,rpjdl$fau[1:3, ])$lisup  #the same

data(deug)
deug.dudi &lt;- dudi.pca(df = deug$tab, center = deug$cent, scale = FALSE, scannf = FALSE)
suprow(deug.dudi, deug$tab[1:3, ])$lisup  #the supplementary individuals are centered
deug.dudi$li[1:3, ]  # the same
</code></pre>

<hr>
<h2 id='suprow.pta'>
Projections of Supplementary Rows for a Partial Triadic Analysis of K-tables
</h2><span id='topic+suprow.pta'></span>

<h3>Description</h3>

<p>This function performs a projection of supplementary rows (i.e. supplementary individuals) for a Partial Triadic Analysis (<code>pta</code>) of K-tables.
Computations are valid ONLY if the <code>pta</code> has been done on a K-Tables obtained by the <code>withinpca</code> function, followed by calls to the <code>ktab.within</code> and <code>t</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pta'
suprow(x, Xsup, facSup, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suprow.pta_+3A_x">x</code></td>
<td>
<p>an object of class <code>pta</code></p>
</td></tr>
<tr><td><code id="suprow.pta_+3A_xsup">Xsup</code></td>
<td>
<p>a table with the supplementary rows</p>
</td></tr>
<tr><td><code id="suprow.pta_+3A_facsup">facSup</code></td>
<td>
<p>a factor partitioning the rows of <code>Xsup</code></p>
</td></tr>
<tr><td><code id="suprow.pta_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the coordinates of the supplementary rows for a K-tables.
The table of supplementary rows is standardized according to the 'Bouroche' standardization used in the Within Analysis of the original <code>pta</code>.
In a first step, the table of supplementary rows is standardized (centred and normed) with the mean and variance of the original table of active individuals (i.e. the K-tables used in <code>pta</code>). Then, according to the <code>withinpca</code> procedure, a second transformation is applied.
</p>
<p>For &quot;partial&quot;, supplementary rows are standardized in each sub-table (corresponding to each level of the factor) by the mean and variance of each corresponding sub-sample in the table of active individuals. Hence, supplementary rows have null mean and unit variance in each sub-table.
</p>
<p>For &quot;total&quot;, supplementary rows are centred in each sub-table with the mean of each coresponding sub-sample in the table of active individuals and then normed with the global variance ot the table of active individuals. Hence, supplementary rows have a null mean in each sub-table and a global variance equal to one. 
</p>


<h3>Value</h3>

<p>Returns a list with the transformed table <code>Xsup</code> in <code>tabsup</code> and the coordinates of the supplementary rows in <code>lisup</code>.
</p>


<h3>Author(s)</h3>

<p>Benjamin Alric  <a href="mailto:benjamin.alric@irstea.fr">benjamin.alric@irstea.fr</a> <br />
Jean Thioulouse <a href="mailto:jean.thioulouse@univ-lyon1.fr">jean.thioulouse@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Bouroche, J. M. (1975) <em>Analyse des données ternaires: la double analyse en composantes principales</em>. 
Thèse de 3ème cycle, Université de Paris VI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meau)
# Active rows
actenv &lt;- meau$env[meau$design$site != "S6", -c(5)]
actfac &lt;- meau$design$season[meau$design$site != "S6"]
# Suplementary rows
supenv &lt;- meau$env[meau$design$site == "S6", -c(5)]
supfac &lt;- meau$design$season[meau$design$site == "S6"]
# Total = active + suplementary rows
totenv &lt;- meau$env[, -c(5)]
totfac &lt;- meau$design$season
# PTA with 6 sampling sites
wittot &lt;- withinpca(df = totenv, fac = totfac, scannf = FALSE, scaling = "partial")
kta1tot &lt;- ktab.within(wittot, colnames = rep(c("S1", "S2", "S3", "S4", "S5", "S6"), 4))
kta2tot &lt;- t(kta1tot)
pta1tot &lt;- pta(kta2tot, scann = FALSE)
# PTA with 5 sampling sites and site 6 added as supplementary element
wit1 &lt;- withinpca(df = actenv, fac = actfac, scannf = FALSE, scaling = "partial")
kta1 &lt;- ktab.within(wit1, colnames = rep(c("S1", "S2", "S3", "S4", "S5"), 4))
kta2 &lt;- t(kta1)
pta1 &lt;- pta(kta2, scann = FALSE)
supenv.pta &lt;- suprow(x = pta1, Xsup = supenv, facSup = supfac)
if (adegraphicsLoaded()) {
# g1t = active + suplementary rows
	g1t &lt;- s.label(pta1tot$Tli, labels = rownames(totenv), 
	  plabels = list(box = list(draw = FALSE), optim = TRUE), xlim = c(-6, 5), ylim = c(-5, 5), 
	  psub = list(text="Total", position="topleft"), plot = FALSE)
# g1 = Active rows
	g1 &lt;- s.label(pta1$Tli, labels = rownames(actenv), 
	  plabels = list(box = list(draw = FALSE), optim =TRUE), xlim = c(-6, 5), ylim = c(-5, 5), 
	  psub = list(text="Active", position="topleft"), pgrid = list(text=list(cex = 0)), 
	  plot = FALSE)
# g2 = Supplementary rows
	g2 &lt;- s.label(supenv.pta$lisup, plabels = list(box = list(draw = FALSE), optim = TRUE), 
	  ppoints = list(col = "red"), psub = list(text="Supplementary", position="topright"), 
	  pgrid = list(text=list(cex = 0)), plot = FALSE)
# g3 = superposition of active and suplementary rows
	g3 &lt;- g1 + g2
# Comparison of the total analysis and the analysis with supplementary rows
	ADEgS(list(g1t,g3))
} else {
	par(mfrow=c(2,2))
# g1t = active + suplementary rows
	g1t &lt;- s.label(pta1tot$Tli, label = rownames(totenv), xlim = c(-6, 5), ylim = c(-5, 5), 
	  sub="Total")
# g1 = Active rows
	g1 &lt;- s.label(pta1$Tli, label = rownames(actenv), clabel = 1, xlim = c(-6, 5),
	  ylim = c(-5, 5), sub="Active+Supplementary")
# g2 = Supplementary rows
	g2 &lt;- s.label(supenv.pta$lisup, clabel = 1.5, xlim = c(-6, 5), ylim = c(-5, 5), 
	  add.plot = TRUE)  
}
</code></pre>

<hr>
<h2 id='symbols.phylog'>Representation of a quantitative variable in front of a phylogenetic tree</h2><span id='topic+symbols.phylog'></span>

<h3>Description</h3>

<p><code>symbols.phylog</code> draws the phylogenetic tree and represents the values of
the variable by symbols (squares or circles) which size is proportional to value.
White symbols correspond to values which are below the mean, and black symbols
correspond to values which are over.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbols.phylog(phylog, circles, squares, csize = 1, clegend = 1,
 sub = "", csub = 1, possub = "topleft")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbols.phylog_+3A_phylog">phylog</code></td>
<td>
<p> an object of class <code>phylog</code></p>
</td></tr>
<tr><td><code id="symbols.phylog_+3A_circles">circles</code></td>
<td>
<p> a vector giving the radii of the circles</p>
</td></tr>
<tr><td><code id="symbols.phylog_+3A_squares">squares</code></td>
<td>
<p> a vector giving the length of the sides of the squares</p>
</td></tr>
<tr><td><code id="symbols.phylog_+3A_csize">csize</code></td>
<td>
<p> a size coefficient for symbols</p>
</td></tr>
<tr><td><code id="symbols.phylog_+3A_clegend">clegend</code></td>
<td>
<p> a character size for the legend used by <code>par("cex")*clegend</code></p>
</td></tr>
<tr><td><code id="symbols.phylog_+3A_sub">sub</code></td>
<td>
<p> a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="symbols.phylog_+3A_csub">csub</code></td>
<td>
<p> a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="symbols.phylog_+3A_possub">possub</code></td>
<td>
<p> a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+table.phylog">table.phylog</a></code> and <code><a href="#topic+dotchart.phylog">dotchart.phylog</a></code> for many variables</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mjrochet)
mjrochet.phy &lt;- newick2phylog(mjrochet$tre)
tab0 &lt;- data.frame(scalewt(log(mjrochet$tab)))
par(mfrow=c(3,2))
for (j in 1:6) {
    w &lt;- tab0[,j]
    symbols.phylog(phylog = mjrochet.phy, w, csi = 1.5, cleg = 1.5,
     sub = names(tab0)[j], csub = 3)
}
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='syndicats'>Two Questions asked on a Sample of 1000 Respondents</h2><span id='topic+syndicats'></span>

<h3>Description</h3>

<p>This data set is extracted from an opinion poll (period 1970-1980) on 1000 respondents. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(syndicats)</code></pre>


<h3>Format</h3>

<p>The <code>syndicats</code> data frame has 5 rows and 4 columns.<br />
&quot;Which politic family are you agreeing about?&quot; has 5 response items : 
<code>extgauche</code> (extreme left) <code>left</code> <code>center</code> <code>right</code> and <code>extdroite</code> (extreme right)<br />
&quot;What do you think of the trade importance?&quot; has 4 response items :
<code>trop</code> (too important) <code>adequate</code> <code>insufficient</code> <code>nesaispas</code> (no opinion)
</p>


<h3>Source</h3>

<p>unknown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(syndicats)
par(mfrow = c(1,2))
dudi1 &lt;- dudi.coa(syndicats, scan = FALSE)
score (dudi1, 1, TRUE)
score (dudi1, 1, FALSE)
</code></pre>

<hr>
<h2 id='t3012'>Average temperatures of 30 French cities</h2><span id='topic+t3012'></span>

<h3>Description</h3>

<p>This data set gives the average temperatures of 30 French cities during 12 months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(t3012)</code></pre>


<h3>Format</h3>

<p><code>t3012</code> is a list with the following components:
</p>

<dl>
<dt>xy</dt><dd><p>a data frame with 30 rows (cities) and 2 coordinates (x, y)</p>
</dd>
<dt>temp</dt><dd><p>a data frame with 30 rows (cities) and 12 columns (months). 
Each column contains the average temperature in tenth of degree Celsius.</p>
</dd>
<dt>contour</dt><dd><p>a data frame with 4 columns (x1, y1, x2, y2) for the contour 
display of France</p>
</dd>
<dt>Spatial</dt><dd><p>an object of the class <code>SpatialPolygons</code> of <code>sp</code>,
containing the map</p>
</dd>
</dl>


<h3>Source</h3>

<p>Besse, P. (1979) <em>Etude descriptive d'un processus; approximation, 
interpolation</em>. Thèse de troisième cycle, Université Paul Sabatier, Toulouse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(t3012)
data(elec88)

if(adegraphicsLoaded()) {
  if(requireNamespace("sp", quietly = TRUE)) {
    s.arrow(t3012$xy, pori.ori = as.numeric(t3012$xy["Paris", ]), Sp = t3012$Spatial, 
      pSp.col = "white", pgrid.draw = FALSE)
  }
} else {
  area.plot(elec88$area)
  s.arrow(t3012$xy, ori = as.numeric(t3012$xy["Paris", ]), add.p = TRUE)
}</code></pre>

<hr>
<h2 id='table.cont'>Plot of Contingency Tables</h2><span id='topic+table.cont'></span>

<h3>Description</h3>

<p>presents a graph for viewing contingency tables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.cont(df, x = 1:ncol(df), y = 1:nrow(df),
    row.labels = row.names(df), col.labels = names(df),
    clabel.row = 1, clabel.col = 1, abmean.x = FALSE, abline.x = FALSE,
    abmean.y = FALSE, abline.y = FALSE, csize = 1, clegend = 0, grid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table.cont_+3A_df">df</code></td>
<td>
<p>a data frame with only positive or null values</p>
</td></tr>
<tr><td><code id="table.cont_+3A_x">x</code></td>
<td>
<p>a vector of values to position the columns</p>
</td></tr>
<tr><td><code id="table.cont_+3A_y">y</code></td>
<td>
<p>a vector of values to position the rows</p>
</td></tr>
<tr><td><code id="table.cont_+3A_row.labels">row.labels</code></td>
<td>
<p>a character vector for the row labels</p>
</td></tr>
<tr><td><code id="table.cont_+3A_col.labels">col.labels</code></td>
<td>
<p>a character vetor for the column labels</p>
</td></tr>
<tr><td><code id="table.cont_+3A_clabel.row">clabel.row</code></td>
<td>
<p>a character size for the row labels</p>
</td></tr>
<tr><td><code id="table.cont_+3A_clabel.col">clabel.col</code></td>
<td>
<p>a character size for the column labels</p>
</td></tr>
<tr><td><code id="table.cont_+3A_abmean.x">abmean.x</code></td>
<td>
<p>a logical value indicating whether the column conditional means should be drawn</p>
</td></tr>
<tr><td><code id="table.cont_+3A_abline.x">abline.x</code></td>
<td>
<p>a logical value indicating whether the regression line of y onto x should be plotted</p>
</td></tr>
<tr><td><code id="table.cont_+3A_abmean.y">abmean.y</code></td>
<td>
<p>a logical value indicating whether the row conditional means should be drawn</p>
</td></tr>
<tr><td><code id="table.cont_+3A_abline.y">abline.y</code></td>
<td>
<p>a logical value indicating whether the regression line of x onto y should be plotted</p>
</td></tr>
<tr><td><code id="table.cont_+3A_csize">csize</code></td>
<td>
<p>a coefficient for the square size of the values</p>
</td></tr>
<tr><td><code id="table.cont_+3A_clegend">clegend</code></td>
<td>
<p>if not NULL, a character size for the legend used with  <code>par("cex")*clegend</code></p>
</td></tr>
<tr><td><code id="table.cont_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chats)
chatsw &lt;- data.frame(t(chats))
chatscoa &lt;- dudi.coa(chatsw, scann = FALSE)
par(mfrow = c(2,2))
table.cont(chatsw, abmean.x = TRUE, csi = 2, abline.x = TRUE, 
    clabel.r = 1.5, clabel.c = 1.5)
table.cont(chatsw, abmean.y = TRUE, csi = 2, abline.y = TRUE, 
    clabel.r = 1.5, clabel.c = 1.5)
table.cont(chatsw, x = chatscoa$c1[,1], y = chatscoa$l1[,1],
    abmean.x = TRUE, csi = 2, abline.x = TRUE, clabel.r = 1.5, clabel.c = 1.5)
table.cont(chatsw, x = chatscoa$c1[,1], y = chatscoa$l1[,1],
    abmean.y = TRUE, csi = 2, abline.y = TRUE, clabel.r = 1.5, clabel.c = 1.5)
par(mfrow = c(1,1))

## Not run: 
data(rpjdl)
w &lt;- data.frame(t(rpjdl$fau))
wcoa &lt;- dudi.coa(w, scann = FALSE)
table.cont(w, abmean.y = TRUE, x = wcoa$c1[,1], y = rank(wcoa$l1[,1]),
    csi = 0.2, clabel.c = 0, row.labels = rpjdl$lalab, clabel.r = 0.75)

## End(Not run)</code></pre>

<hr>
<h2 id='table.dist'>Graph Display for Distance Matrices</h2><span id='topic+table.dist'></span>

<h3>Description</h3>

<p>presents a graph for viewing distance matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.dist(d, x = 1:(attr(d, "Size")), labels = as.character(x), 
    clabel = 1, csize = 1, grid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table.dist_+3A_d">d</code></td>
<td>
<p>an object of class <code>dist</code></p>
</td></tr>
<tr><td><code id="table.dist_+3A_x">x</code></td>
<td>
<p>a vector of the row and column positions</p>
</td></tr>
<tr><td><code id="table.dist_+3A_labels">labels</code></td>
<td>
<p>a vector of strings of characters for the labels</p>
</td></tr>
<tr><td><code id="table.dist_+3A_clabel">clabel</code></td>
<td>
<p>a character size for the labels</p>
</td></tr>
<tr><td><code id="table.dist_+3A_csize">csize</code></td>
<td>
<p>a coefficient for the circle size</p>
</td></tr>
<tr><td><code id="table.dist_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether a grid in the background of the plot should be drawn</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eurodist)
table.dist(eurodist, labels = attr(eurodist, "Labels"))
</code></pre>

<hr>
<h2 id='table.paint'>Plot of the arrays by grey levels</h2><span id='topic+table.paint'></span>

<h3>Description</h3>

<p>presents a graph for viewing the numbers of a table by grey levels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.paint(df, x = 1:ncol(df), y = nrow(df):1, 
    row.labels = row.names(df), col.labels = names(df), 
    clabel.row = 1, clabel.col = 1, csize = 1, clegend = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table.paint_+3A_df">df</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="table.paint_+3A_x">x</code></td>
<td>
<p>a vector of values to position the columns, used only for the ordered values</p>
</td></tr>
<tr><td><code id="table.paint_+3A_y">y</code></td>
<td>
<p>a vector of values to position the rows, used only for the ordered values</p>
</td></tr>
<tr><td><code id="table.paint_+3A_row.labels">row.labels</code></td>
<td>
<p>a character vector for the row labels</p>
</td></tr>
<tr><td><code id="table.paint_+3A_col.labels">col.labels</code></td>
<td>
<p>a character vector for the column labels</p>
</td></tr>
<tr><td><code id="table.paint_+3A_clabel.row">clabel.row</code></td>
<td>
<p>a character size for the row labels</p>
</td></tr>
<tr><td><code id="table.paint_+3A_clabel.col">clabel.col</code></td>
<td>
<p>a character size for the column labels</p>
</td></tr>
<tr><td><code id="table.paint_+3A_csize">csize</code></td>
<td>
<p>if 'clegend' not NULL, a coefficient for the legend size</p>
</td></tr>
<tr><td><code id="table.paint_+3A_clegend">clegend</code></td>
<td>
<p>a character size for the legend, otherwise no legend</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rpjdl)
X &lt;- data.frame(t(rpjdl$fau))
Y &lt;- data.frame(t(rpjdl$mil))
layout(matrix(c(1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2), 4, 4))
coa1 &lt;- dudi.coa(X, scan = FALSE)
x &lt;- rank(coa1$co[,1])
y &lt;- rank(coa1$li[,1])
table.paint(Y, x = x, y = 1:8, clabel.c = 0, cleg = 0)
abline(v = 114.9, lwd = 3, col = "red")
abline(v = 66.4, lwd = 3, col = "red")
table.paint(X, x = x, y = y, clabel.c = 0, cleg = 0,
    row.lab = paste("  ", row.names(X), sep = ""))
abline(v = 114.9, lwd = 3, col = "red")
abline(v = 66.4, lwd = 3, col = "red")
par(mfrow = c(1, 1))
</code></pre>

<hr>
<h2 id='table.phylog'>Plot arrays in front of a phylogenetic tree</h2><span id='topic+table.phylog'></span>

<h3>Description</h3>

<p>This function gives a graphical display for viewing the numbers of a table by square sizes in front of the corresponding phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.phylog(df, phylog, x = 1:ncol(df), f.phylog = 0.5,
 labels.row = gsub("[_]", " ", row.names(df)), clabel.row = 1,
 labels.col = names(df), clabel.col = 1,
 labels.nod = names(phylog$nodes), clabel.nod = 0, cleaves = 1,
 cnodes = 1, csize = 1, grid = TRUE, clegend = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table.phylog_+3A_df">df</code></td>
<td>
<p>: a data frame or a matrix</p>
</td></tr>
<tr><td><code id="table.phylog_+3A_phylog">phylog</code></td>
<td>
<p>: an object of class <code>'phylog'</code></p>
</td></tr>
<tr><td><code id="table.phylog_+3A_x">x</code></td>
<td>
<p>: a vector of values to position the columns</p>
</td></tr>
<tr><td><code id="table.phylog_+3A_f.phylog">f.phylog</code></td>
<td>
<p>: a size coefficient for tree size (a parameter to draw the tree in proportion to leaves labels)</p>
</td></tr>
<tr><td><code id="table.phylog_+3A_labels.row">labels.row</code></td>
<td>
<p>: a vector of strings of characters for row labels</p>
</td></tr>
<tr><td><code id="table.phylog_+3A_clabel.row">clabel.row</code></td>
<td>
<p>: a character size for the leaves labels, used with <code>par("cex")*clabel.row</code>. If zero, no row labels are drawn</p>
</td></tr>
<tr><td><code id="table.phylog_+3A_labels.col">labels.col</code></td>
<td>
<p>: a vector of strings of characters for columns labels</p>
</td></tr>
<tr><td><code id="table.phylog_+3A_clabel.col">clabel.col</code></td>
<td>
<p>: a character size for the leaves labels, used with <code>par("cex")*clabel.col</code>. If zero, no column labels are drawn</p>
</td></tr>
<tr><td><code id="table.phylog_+3A_labels.nod">labels.nod</code></td>
<td>
<p>: a vector of strings of characters for the nodes labels</p>
</td></tr>
<tr><td><code id="table.phylog_+3A_clabel.nod">clabel.nod</code></td>
<td>
<p>: a character size for the nodes labels, used with <code>par("cex")*clabel.nodes</code>. If zero, no nodes labels are drawn</p>
</td></tr>
<tr><td><code id="table.phylog_+3A_cleaves">cleaves</code></td>
<td>
<p>: a character size for plotting the points that represent the leaves, used with <code>par("cex")*cleaves</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="table.phylog_+3A_cnodes">cnodes</code></td>
<td>
<p>: a character size for plotting the points that represent the nodes, used with <code>par("cex")*cnodes</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="table.phylog_+3A_csize">csize</code></td>
<td>
<p>: a size coefficient for symbols</p>
</td></tr>
<tr><td><code id="table.phylog_+3A_grid">grid</code></td>
<td>
<p>: a logical value indicating whether the grid should be plotted</p>
</td></tr>
<tr><td><code id="table.phylog_+3A_clegend">clegend</code></td>
<td>
<p>: a character size for the legend (if 0, no legend)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function verifies that <code>sort(row.names(df))==sort(names(phylog$leaves))</code>. 
If <code>df</code> is a matrix the function uses <code>as.data.frame(df)</code>. </p>


<h3>Author(s)</h3>

<p>Daniel Chessel  <br />
Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+symbols.phylog">symbols.phylog</a></code> for one variable</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(newick.eg)
w.phy &lt;- newick2phylog(newick.eg[[9]])
w.tab &lt;- data.frame(matrix(rnorm(620), 31, 20))
row.names(w.tab) &lt;- sort(names(w.phy$leaves))
table.phylog(w.tab, w.phy, csi = 1.5, f = 0.5,
 clabel.n = 0.75, clabel.c = 0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='table.value'>Plot of the Arrays</h2><span id='topic+table.value'></span><span id='topic+table.prepare'></span>

<h3>Description</h3>

<p>presents a graph for viewing the numbers of a table by square sizes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.value(df, x = 1:ncol(df), y = nrow(df):1, 
    row.labels = row.names(df), col.labels = names(df), clabel.row = 1, 
    clabel.col = 1, csize = 1, clegend = 1, grid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table.value_+3A_df">df</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="table.value_+3A_x">x</code></td>
<td>
<p>a vector of values to position the columns</p>
</td></tr>
<tr><td><code id="table.value_+3A_y">y</code></td>
<td>
<p>a vector of values to position the rows</p>
</td></tr>
<tr><td><code id="table.value_+3A_row.labels">row.labels</code></td>
<td>
<p>a character vector for the row labels</p>
</td></tr>
<tr><td><code id="table.value_+3A_col.labels">col.labels</code></td>
<td>
<p>a character vector for the column labels</p>
</td></tr>
<tr><td><code id="table.value_+3A_clabel.row">clabel.row</code></td>
<td>
<p>a character size for the row labels</p>
</td></tr>
<tr><td><code id="table.value_+3A_clabel.col">clabel.col</code></td>
<td>
<p>a character size for the column labels</p>
</td></tr>
<tr><td><code id="table.value_+3A_csize">csize</code></td>
<td>
<p>a coefficient for the square size of the values</p>
</td></tr>
<tr><td><code id="table.value_+3A_clegend">clegend</code></td>
<td>
<p>a character size for the legend (if 0, no legend)</p>
</td></tr>
<tr><td><code id="table.value_+3A_grid">grid</code></td>
<td>
<p>a logical value indicating whether the grid should be plotted</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!adegraphicsLoaded()) {
  data(olympic)
  w &lt;- olympic$tab
  w &lt;- data.frame(scale(w))
  wpca &lt;- dudi.pca(w, scann = FALSE)
  par(mfrow = c(1, 3))
  table.value(w, csi = 2, clabel.r = 2, clabel.c = 2)
  table.value(w, y = rank(wpca$li[, 1]), x = rank(wpca$co[, 1]), csi = 2,
    clabel.r = 2, clabel.c = 2)
  table.value(w, y = wpca$li[, 1], x = wpca$co[, 1], csi = 2, 
    clabel.r = 2, clabel.c = 2)
  par(mfrow = c(1, 1))
}</code></pre>

<hr>
<h2 id='tarentaise'>Mountain Avifauna</h2><span id='topic+tarentaise'></span>

<h3>Description</h3>

<p>This data set gives informations between sites, species, environmental and biolgoical variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tarentaise)</code></pre>


<h3>Format</h3>

<p><code>tarentaise</code> is a list of 5 components.
</p>

<dl>
<dt>ecol</dt><dd><p>is a data frame with 376 sites and 98 bird species.</p>
</dd>
<dt>frnames</dt><dd><p>is a vector of the 98 French names of the species.</p>
</dd>
<dt>alti</dt><dd><p>is a vector giving the altitude of the 376 sites in m.</p>
</dd>
<dt>envir</dt><dd><p>is a data frame with 14 environmental variables.</p>
</dd>
<dt>traits</dt><dd><p>is a data frame with 29 biological variables of the 98 species.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The attribute <code>col.blocks</code> of the data frame <code>tarentaise$traits</code> indicates it is composed of 6 units of variables.
</p>


<h3>Source</h3>

<p>Original data from Hubert Tournier, University of Savoie and Philippe Lebreton, University of Lyon 1.
</p>


<h3>References</h3>

<p>Lebreton, P., Tournier H. and Lebreton J. D. (1976) 
Etude de l'avifaune du Parc National de la Vanoise 
VI Recherches d'ordre quantitatif sur les Oiseaux forestiers de Vanoise. 
<em>Travaux Scientifiques du parc National de la vanoise</em>, <b>7</b>, 163&ndash;243. 
</p>
<p>Lebreton, Ph. and Martinot, J.P. (1998) 
Oiseaux de Vanoise. Guide de l'ornithologue en montagne. 
<em>Libris</em>, Grenoble. 1&ndash;240. 
</p>
<p>Lebreton, Ph., Lebrun, Ph., Martinot, J.P., Miquet, A. and Tournier, H. (1999) 
Approche écologique de l'avifaune de la Vanoise. 
<em>Travaux scientifiques du Parc national de la Vanoise</em>, <b>21</b>, 7&ndash;304.
</p>
<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps038.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps038.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tarentaise)
coa1 &lt;- dudi.coa(tarentaise$ecol, sca = FALSE, nf = 2)
s.class(coa1$li, tarentaise$envir$alti, wt = coa1$lw)
## Not run: 
acm1 &lt;- dudi.acm(tarentaise$envir, sca = FALSE, nf = 2)
s.class(acm1$li, tarentaise$envir$alti)

## End(Not run)
</code></pre>

<hr>
<h2 id='taxo.eg'>Examples of taxonomy</h2><span id='topic+taxo.eg'></span>

<h3>Description</h3>

<p>This data sets contains two taxonomies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(taxo.eg)</code></pre>


<h3>Format</h3>

<p><code>taxo.eg</code> is a list containing the 2 following objects: 
</p>
     
<dl>
<dt>taxo.eg[[1]]</dt><dd><p>is a data frame with 15 species and 3 columns.</p>
</dd> 
<dt>taxo.eg[[2]]</dt><dd><p>is a data frame with 40 species and 2 columns.</p>
</dd>
</dl>


<h3>Details</h3>

       
<p>Variables of the first data frame are : genre (a factor genre with 8 levels), 
famille (a factor familiy with 5 levels) and ordre (a factor order with 2 levels).<br />
</p>
<p>Variables of the second data frame are : gen(a factor genre with 29 levels), 
fam (a factor family with 19 levels).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(taxo.eg)
taxo.eg[[1]]
as.taxo(taxo.eg[[1]])
class(taxo.eg[[1]])
class(as.taxo(taxo.eg[[1]]))

tax.phy &lt;- taxo2phylog(as.taxo(taxo.eg[[1]]),  add.tools = TRUE)
plot(tax.phy,clabel.l=1)

par(mfrow = c(1,2))
table.phylog(tax.phy$Bindica,tax.phy)
table.phylog(tax.phy$Bscores,tax.phy)
par(mfrow = c(1,1))

radial.phylog(taxo2phylog(as.taxo(taxo.eg[[2]])))
</code></pre>

<hr>
<h2 id='testdim'> Function to perform a test of dimensionality</h2><span id='topic+testdim'></span><span id='topic+testdim.pca'></span>

<h3>Description</h3>

<p>This functions allow to test for the number of axes in multivariate analysis. The
procedure <code>testdim.pca</code> implements a method for principal component analysis on
correlation matrix. The procedure is based on the computation of the RV coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testdim(object, ...)
## S3 method for class 'pca'
testdim(object, nrepet = 99, nbax = object$rank, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testdim_+3A_object">object</code></td>
<td>
<p> an object corresponding to an analysis (e.g. duality diagram, an object of class <code>dudi</code>)</p>
</td></tr>
<tr><td><code id="testdim_+3A_nrepet">nrepet</code></td>
<td>
<p> the number of repetitions for the permutation procedure</p>
</td></tr>
<tr><td><code id="testdim_+3A_nbax">nbax</code></td>
<td>
<p> the number of axes to be tested, by default all axes</p>
</td></tr>
<tr><td><code id="testdim_+3A_alpha">alpha</code></td>
<td>
<p> the significance level</p>
</td></tr>
<tr><td><code id="testdim_+3A_...">...</code></td>
<td>
<p> other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>krandtest</code>. It contains also:
</p>
<table>
<tr><td><code>nb</code></td>
<td>
<p>The estimated number of axes to keep</p>
</td></tr>
<tr><td><code>nb.cor</code></td>
<td>
<p>The number of axes to keep estimated using a sequential Bonferroni
procedure</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a></p>


<h3>References</h3>

<p>Dray, S. (2008) On the number of principal components: A test of
dimensionality based on measurements of similarity between
matrices. <em>Computational Statistics and Data Analysis</em>, <b>Volume 52</b>, 2228&ndash;2237. doi:10.1016/j.csda.2007.07.015
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dudi.pca">dudi.pca</a></code>, <code><a href="#topic+RV.rtest">RV.rtest</a></code>,<code><a href="#topic+testdim.multiblock">testdim.multiblock</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- data.frame(matrix(rnorm(200),20,10))
pca1 &lt;- dudi.pca(tab,scannf=FALSE)
test1 &lt;- testdim(pca1)
test1
test1$nb
test1$nb.cor
data(doubs)
pca2 &lt;- dudi.pca(doubs$env,scannf=FALSE)
test2 &lt;- testdim(pca2)
test2
test2$nb
test2$nb.cor
</code></pre>

<hr>
<h2 id='testdim.multiblock'>Selection of the number of dimension by two-fold cross-validation for multiblock methods</h2><span id='topic+testdim.multiblock'></span>

<h3>Description</h3>

<p>Function to perform a two-fold cross-validation to select the optimal number of dimensions of multiblock methods, <em>i.e.</em>, multiblock principal component analysis with instrumental Variables or multiblock partial least squares</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiblock'
testdim(object, nrepet = 100, quantiles = c(0.25, 0.75), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testdim.multiblock_+3A_object">object</code></td>
<td>
<p>an object of class multiblock created by <code><a href="#topic+mbpls">mbpls</a></code>
or <code><a href="#topic+mbpcaiv">mbpcaiv</a></code></p>
</td></tr>
<tr><td><code id="testdim.multiblock_+3A_nrepet">nrepet</code></td>
<td>
<p>integer indicating the number of repetitions</p>
</td></tr>
<tr><td><code id="testdim.multiblock_+3A_quantiles">quantiles</code></td>
<td>
<p>a vector indicating the lower and upper quantiles to compute</p>
</td></tr>
<tr><td><code id="testdim.multiblock_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>krandxval</code></p>


<h3>Author(s)</h3>

<p>Stéphanie Bougeard (<a href="mailto:stephanie.bougeard@anses.fr">stephanie.bougeard@anses.fr</a>) and Stéphane Dray (<a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>)</p>


<h3>References</h3>

<p>Stone M. (1974) Cross-validatory choice and assessment of statistical predictions. <em>Journal of the Royal Statistical Society</em>, <b>36</b>, 111-147.
</p>
<p>Bougeard, S. and Dray S. (2018) Supervised Multiblock Analysis in R with the ade4 Package. <em>Journal of Statistical Software</em>, <b>86</b> (1), 1-17. <a href="https://doi.org/10.18637/jss.v086.i01">doi:10.18637/jss.v086.i01</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mbpcaiv">mbpcaiv</a></code>, <code><a href="#topic+mbpls">mbpls</a></code>,
<code><a href="#topic+randboot.multiblock">randboot.multiblock</a></code>, <code><a href="#topic+as.krandxval">as.krandxval</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chickenk)
Mortality &lt;- chickenk[[1]]
dudiY.chick &lt;- dudi.pca(Mortality, center = TRUE, scale = TRUE, scannf =
FALSE)
ktabX.chick &lt;- ktab.list.df(chickenk[2:5])
resmbpcaiv.chick &lt;- mbpcaiv(dudiY.chick, ktabX.chick, scale = TRUE,
option = "uniform", scannf = FALSE)
## nrepet should be higher for a real analysis
test &lt;- testdim(resmbpcaiv.chick, nrepet = 10)
test
if(adegraphicsLoaded())
plot(test)

</code></pre>

<hr>
<h2 id='tintoodiel'>Tinto and Odiel estuary geochemistry</h2><span id='topic+tintoodiel'></span>

<h3>Description</h3>

<p>This data set contains informations about geochemical characteristics of heavy 
metal pollution in surface sediments of the Tinto and Odiel river estuary 
(south-western Spain).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tintoodiel)</code></pre>


<h3>Format</h3>

<p><code>tintoodiel</code> is a list with the following components:
</p>

<dl>
<dt>xy</dt><dd><p>a data frame that contains spatial coordinates of the 52 sites</p>
</dd>   
<dt>tab</dt><dd><p>a data frame with 12 columns (concentration of heavy metals) and 52 rows (sites)</p>
</dd>
<dt>neig</dt><dd><p>an object of class <code>neig</code></p>
</dd>
<dt>nb</dt><dd><p>the neighbourhood graph of the 52 sites (an object of class <code>nb</code>)</p>
</dd>
</dl>


<h3>Source</h3>

<p>Borrego, J., Morales, J.A., de la Torre, M.L. and Grande, J.A. (2002) 
Geochemical characteristics of heavy metal pollution in surface sediments of 
the Tinto and Odiel river estuary (south-western Spain). <em>Environmental 
Geology</em>, <b>41</b>, 785&ndash;796.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tintoodiel)
if(!adegraphicsLoaded()) {
  ## Not run: 
  if(requireNamespace("pixmap", quietly = TRUE)) {
    estuary.pnm &lt;- pixmap::read.pnm(system.file("pictures/tintoodiel.pnm", package = "ade4"))
    s.label(tintoodiel$xy, pixmap = estuary.pnm, neig = tintoodiel$neig,
      clab = 0, cpoi = 2, cneig = 3, addax = FALSE, cgrid = 0, grid = FALSE)
  }
## End(Not run)
  
  estuary.pca &lt;- dudi.pca(tintoodiel$tab, scan = FALSE, nf = 4)
  
  if(requireNamespace("spdep", quietly = TRUE)) {
    estuary.listw &lt;- spdep::nb2listw(neig2nb(tintoodiel$neig))
    estuary.pca.ms &lt;- multispati(estuary.pca, estuary.listw, scan = FALSE, nfposi = 3, nfnega = 2)
    summary(estuary.pca.ms)
    par(mfrow = c(1, 2))
    barplot(estuary.pca$eig)
    barplot(estuary.pca.ms$eig)
    par(mfrow = c(1, 1))
}}</code></pre>

<hr>
<h2 id='tithonia'>Phylogeny and quantitative traits of flowers</h2><span id='topic+tithonia'></span>

<h3>Description</h3>

<p>This data set describes the phylogeny of 11 flowers as reported by Morales (2000). It also gives morphologic and demographic traits corresponding to these 11 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tithonia)</code></pre>


<h3>Format</h3>

<p><code>tithonia</code> is a list containing the 2 following objects :
</p>
  
<dl>
<dt>tre</dt><dd><p>is a character string giving the phylogenetic tree in Newick format.</p>
</dd> 
<dt>tab</dt><dd><p>is a data frame with 11 species and 14 traits (6 morphologic traits and 8 demographic).</p>
</dd>    
</dl>


<h3>Details</h3>

      
<p>Variables of <code>tithonia$tab</code> are the following ones : <br />
morho1: is a numeric vector that describes the seed size (mm)<br />
morho2: is a numeric vector that describes the flower size (mm)<br />
morho3: is a numeric vector that describes the female leaf size (cm)<br />
morho4: is a numeric vector that describes the head size (mm)<br />
morho5: is a integer vector that describes the number of flowers per head <br />
morho6: is a integer vector that describes the number of seeds per head <br />
demo7: is a numeric vector that describes the seedling height (cm)<br />
demo8: is a numeric vector that describes the growth rate (cm/day)<br />
demo9: is a numeric vector that describes the germination time<br />
demo10: is a numeric vector that describes the establishment (per cent)<br />
demo11: is a numeric vector that describes the viability (per cent)<br />
demo12: is a numeric vector that describes the germination (per cent)<br />
demo13: is a integer vector that describes the resource allocation<br />
demo14: is a numeric vector that describes the adult height (m)<br />
</p>


<h3>Source</h3>

<p>Data were obtained from Morales, E. (2000) Estimating phylogenetic inertia in Tithonia (Asteraceae) : 
a comparative approach. <em>Evolution</em>, <b>54</b>, 2, 475&ndash;484.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tithonia)
phy &lt;- newick2phylog(tithonia$tre)
tab &lt;- log(tithonia$tab + 1)
table.phylog(scalewt(tab), phy)
gearymoran(phy$Wmat, tab)
gearymoran(phy$Amat, tab)
</code></pre>

<hr>
<h2 id='tortues'>Morphological Study of the Painted Turtle</h2><span id='topic+tortues'></span>

<h3>Description</h3>

<p>This data set gives a morphological description (4 characters) of 48 turtles. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tortues)</code></pre>


<h3>Format</h3>

<p>a data frame with 48 rows and 4 columns (length (mm), maximum width(mm), height (mm), gender). 
</p>


<h3>Source</h3>

<p>Jolicoeur, P. and Mosimann, J. E. (1960)
Size and shape variation in the painted turtle. A principal component analysis.
<em>Growth</em>, <b>24</b>, 339&ndash;354.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tortues)
xyz &lt;- as.matrix(tortues[, 1:3])
ref &lt;- -svd(xyz)$u[, 1]
pch0 &lt;- c(1, 20)[as.numeric(tortues$sexe)]
plot(ref, xyz[, 1], ylim = c(40, 180), pch = pch0)
abline(lm(xyz[, 1] ~ -1 + ref))
points(ref,xyz[, 2], pch = pch0)
abline(lm(xyz[, 2] ~ -1 + ref))
points(ref,xyz[, 3], pch = pch0)
abline(lm(xyz[, 3] ~ -1 + ref))
</code></pre>

<hr>
<h2 id='toxicity'>Homogeneous Table</h2><span id='topic+toxicity'></span>

<h3>Description</h3>

<p>This data set gives the toxicity of 7 molecules on 17 targets
expressed in -log(mol/liter)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(toxicity)</code></pre>


<h3>Format</h3>

<p><code>toxicity</code> is a list of 3 components.
</p>

<dl>
<dt>tab</dt><dd><p>is a data frame with 7 columns and 17 rows</p>
</dd>
<dt>species</dt><dd><p>is a vector of the names of the species in the 17 targets</p>
</dd>
<dt>chemicals</dt><dd><p>is a vector of the names of the 7 molecules</p>
</dd>
</dl>



<h3>Source</h3>

<p>Devillers, J., Thioulouse, J. and Karcher W. (1993)
Chemometrical Evaluation of Multispecies-Multichemical Data by Means 
of Graphical Techniques Combined with Multivariate Analyses.
<em>Ecotoxicology and Environnemental Safety</em>, <b>26</b>, 333&ndash;345.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toxicity)
if(adegraphicsLoaded()) {
  table.image(toxicity$tab, labelsy = toxicity$species, labelsx = toxicity$chemicals, nclass = 7, 
    ptable.margin = list(b = 5, l = 25, t = 25, r = 5), ptable.y.pos = "left", pgrid.draw = TRUE)
  table.value(toxicity$tab, labelsy = toxicity$species, labelsx = toxicity$chemicals, 
    ptable.margin = list(b = 5, l = 5, t = 25, r = 26))
} else {
  table.paint(toxicity$tab, row.lab = toxicity$species, col.lab = toxicity$chemicals)
  table.value(toxicity$tab, row.lab = toxicity$species, col.lab = toxicity$chemicals)
}</code></pre>

<hr>
<h2 id='triangle.class'> Triangular Representation and Groups of points </h2><span id='topic+triangle.class'></span>

<h3>Description</h3>

<p>Function to plot triangular data (i.e. dataframe with 3 columns of
positive or null values) and a partition <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangle.class(ta, fac, col = rep(1, length(levels(fac))), 
    wt = rep(1, length(fac)), cstar = 1, cellipse = 0, axesell = TRUE, 
    label = levels(fac), clabel = 1, cpoint = 1, pch = 20, draw.line = TRUE, 
    addaxes = FALSE, addmean = FALSE, labeltriangle = TRUE, sub = "", csub = 1, 
    possub = "bottomright", show.position = TRUE, scale = TRUE, min3 = NULL, 
    max3 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangle.class_+3A_ta">ta</code></td>
<td>
<p> a data frame with 3 columns of null or positive numbers  </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_fac">fac</code></td>
<td>
<p> a factor of length the row number of <code>ta</code> </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_col">col</code></td>
<td>
<p> a vector of color for showing the groups </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_wt">wt</code></td>
<td>
<p> a vector of row weighting for the computation of the gravity centers by class </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_cstar">cstar</code></td>
<td>
<p> a character size for plotting the stars between 0 (no stars) and 1 (complete star) for a line linking a point to the gravity center of its belonging class. </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_cellipse">cellipse</code></td>
<td>
<p> a positive coefficient for the inertia ellipse size </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_axesell">axesell</code></td>
<td>
<p> a logical value indicating whether the ellipse axes should be drawn </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_label">label</code></td>
<td>
<p> a vector of strings of characters for the labels of gravity centers </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_clabel">clabel</code></td>
<td>
<p> if not NULL, a character size for the labels, used with <code>par("cex")*clabel</code> </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_cpoint">cpoint</code></td>
<td>
<p> a character size for plotting the points, used with <code>par("cex")*cpoint</code>. If zero, no points are drawn </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_pch">pch</code></td>
<td>
<p> if <code>cpoint</code> &gt; 0, an integer specifying the symbol or the single character to be used in plotting points </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_draw.line">draw.line</code></td>
<td>
<p> a logical value indicating whether the triangular lines should be drawn </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_addaxes">addaxes</code></td>
<td>
<p> a logical value indicating whether the axes should be plotted </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_addmean">addmean</code></td>
<td>
<p> a logical value indicating whether the mean point should be plotted </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_labeltriangle">labeltriangle</code></td>
<td>
<p> a logical value indicating whether the varliable labels of <code>ta</code> should be drawn on the triangular sides </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_sub">sub</code></td>
<td>
<p> a string of characters for the graph title </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_csub">csub</code></td>
<td>
<p> a character size for plotting the graph title </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_possub">possub</code></td>
<td>
<p> a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;) </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_show.position">show.position</code></td>
<td>
<p> a logical value indicating whether the sub-triangle containing the data should be put back in the total triangle </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_scale">scale</code></td>
<td>
<p>a logical value for the graph representation : the total triangle (FALSE) or the sub-triangle (TRUE) </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_min3">min3</code></td>
<td>
<p> if not NULL, a vector with 3 numbers between 0 and 1 </p>
</td></tr>
<tr><td><code id="triangle.class_+3A_max3">max3</code></td>
<td>
<p> if not NULL, a vector with 3 numbers between 0 and 1. Let notice that <code>min3</code>+<code>max3</code> must equal c(1,1,1) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Daniel Chessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!adegraphicsLoaded()) {
  data(euro123)
  par(mfrow = c(2, 2))
  x &lt;- rbind.data.frame(euro123$in78, euro123$in86, euro123$in97)
  triangle.plot(x)
  triangle.class(x, as.factor(rep("G", 36)), csta = 0.5, cell = 1)
  triangle.class(x, euro123$plan$an)
  triangle.class(x, euro123$plan$pays)
  triangle.class(x, euro123$plan$an, cell = 1, axesell = TRUE)
  triangle.class(x, euro123$plan$an, cell = 0, csta = 0, 
    col = c("red", "green", "blue"), axesell = TRUE, clab = 2, cpoi = 2)
  triangle.class(x, euro123$plan$an, cell = 2, csta = 0.5, 
    axesell = TRUE, clab = 1.5)
  triangle.class(x, euro123$plan$an, cell = 0, csta = 1, scale = FALSE, 
    draw.line = FALSE, show.posi = FALSE)
  par(mfrow = c(2, 2))
}</code></pre>

<hr>
<h2 id='triangle.plot'>Triangular Plotting</h2><span id='topic+triangle.plot'></span><span id='topic+triangle.biplot'></span><span id='topic+triangle.param'></span><span id='topic+triangle.posipoint'></span><span id='topic+add.position.triangle'></span>

<h3>Description</h3>

<p>Graphs for a dataframe with 3 columns of positive or null values<br />
<code>triangle.plot</code> is a scatterplot<br />
<code>triangle.biplot</code> is a paired scatterplots<br />
<code>triangle.posipoint</code>, <code>triangle.param</code>, <code>add.position.triangle</code> are utilitaries functions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangle.plot(ta, label = as.character(1:nrow(ta)), clabel = 0, 
    cpoint = 1, draw.line = TRUE, addaxes = FALSE, addmean = FALSE, 
    labeltriangle = TRUE, sub = "", csub = 0, possub = "topright", 
    show.position = TRUE, scale = TRUE, min3 = NULL, max3 = NULL, 
    box = FALSE)
triangle.biplot (ta1, ta2, label = as.character(1:nrow(ta1)), 
    draw.line = TRUE, show.position = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangle.plot_+3A_ta">ta</code>, <code id="triangle.plot_+3A_ta1">ta1</code>, <code id="triangle.plot_+3A_ta2">ta2</code></td>
<td>
<p>data frame with three columns, will be transformed in <b>percentages</b> by rows</p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_label">label</code></td>
<td>
<p>a vector of strings of characters for the point labels</p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_clabel">clabel</code></td>
<td>
<p>if not NULL, a character size for the labels, used with  <code>par("cex")*clabel</code></p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_cpoint">cpoint</code></td>
<td>
<p>a character size for plotting the points, used with <code>par("cex")*cpoint</code>. If zero, no points are drawn</p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_draw.line">draw.line</code></td>
<td>
<p>a logical value indicating whether the lines into the triangle should be drawn</p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_addaxes">addaxes</code></td>
<td>
<p>a logical value indicating whether the principal axes should be drawn</p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_addmean">addmean</code></td>
<td>
<p>a logical value indicating whether the mean should be plotted</p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_labeltriangle">labeltriangle</code></td>
<td>
<p>a logical value indicating whether the variable names should be wrote</p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_sub">sub</code></td>
<td>
<p>a string of characters to be inserted as legend</p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_csub">csub</code></td>
<td>
<p>a character size for the legend, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_possub">possub</code></td>
<td>
<p>a string of characters indicating the sub-title position (&quot;topleft&quot;, &quot;topright&quot;, &quot;bottomleft&quot;, &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_show.position">show.position</code></td>
<td>
<p>a logical value indicating whether the used triangle should be shown in the complete one</p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_scale">scale</code></td>
<td>
<p>a logical value indicating whether the smaller equilateral triangle containing the plot should be used</p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_min3">min3</code></td>
<td>
<p>If scale is FALSE, a vector of three values for the minima e.g. c(0.1,0.1,0.1) can be used</p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_max3">max3</code></td>
<td>
<p>If scale is FALSE a vector of three values for the maxima e.g. c(0.9,0.9,0.9) can be used</p>
</td></tr>
<tr><td><code id="triangle.plot_+3A_box">box</code></td>
<td>
<p>a logical value indicating whether a box around the current plot should be drawn</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>triangle.plot</code> returns an invisible matrix  containing the coordinates used for the plot. The graph can be supplemented in various ways.
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(euro123)
tot &lt;- rbind.data.frame(euro123$in78, euro123$in86, euro123$in97)
row.names(tot) &lt;- paste(row.names(euro123$in78), rep(c(1, 2, 3), rep(12, 3)), sep = "")
triangle.plot(tot, label = row.names(tot), clab = 1)

par(mfrow = c(2, 2))
triangle.plot(euro123$in78, clab = 0, cpoi = 2, addmean = TRUE, show = FALSE)
triangle.plot(euro123$in86, label = row.names(euro123$in78), clab = 0.8)
triangle.biplot(euro123$in78, euro123$in86)
triangle.plot(rbind.data.frame(euro123$in78, euro123$in86), clab = 1, 
  addaxes = TRUE, sub = "Principal axis", csub = 2, possub = "topright")

triangle.plot(euro123[[1]], min3 = c(0, 0.2, 0.3), max3 = c(0.5, 0.7, 0.8),
  clab = 1, label = row.names(euro123[[1]]), addax = TRUE)
triangle.plot(euro123[[2]], min3 = c(0, 0.2, 0.3), max3 = c(0.5, 0.7, 0.8), 
  clab = 1, label = row.names(euro123[[1]]), addax = TRUE)
triangle.plot(euro123[[3]], min3 = c(0, 0.2, 0.3), max3 = c(0.5, 0.7, 0.8), 
  clab = 1, label = row.names(euro123[[1]]), addax = TRUE)
triangle.plot(rbind.data.frame(euro123[[1]], euro123[[2]], euro123[[3]]))

par(mfrow = c(1, 1))
wtriangleplot &lt;- cbind.data.frame(a = runif(100), b = runif(100), c = runif(100, 4, 5))
wtriangleplot &lt;- triangle.plot(wtriangleplot)
points(wtriangleplot, col = "blue", cex = 2)
wtriangleplot &lt;- colMeans(wtriangleplot)
points(wtriangleplot[1], wtriangleplot[2], pch = 20, cex = 3, col = "red")
rm(wtriangleplot)
</code></pre>

<hr>
<h2 id='trichometeo'>Pair of Ecological Data</h2><span id='topic+trichometeo'></span>

<h3>Description</h3>

<p>This data set gives for trappong nights informations about 
species and meteorological variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(trichometeo)</code></pre>


<h3>Format</h3>

<p><code>trichometeo</code> is a list of 3 components.
</p>

<dl>
<dt>fau</dt><dd><p>is a data frame with 49 rows (trapping nights) and 17 species.</p>
</dd>
<dt>meteo</dt><dd><p>is a data frame with 49 rows and 11 meteorological variables.</p>
</dd>
<dt>cla</dt><dd><p>is a factor of 12 levels for the definition of the consecutive night groups</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data from P. Usseglio-Polatera
</p>


<h3>References</h3>

<p>Usseglio-Polatera, P. and Auda, Y. (1987) 
Influence des facteurs météorologiques sur les résultats de piégeage lumineux. 
<em>Annales de Limnologie</em>, <b>23</b>, 65&ndash;79. (code des espèces p. 76)
</p>
<p>See a data description at <a href="http://pbil.univ-lyon1.fr/R/pdf/pps034.pdf">http://pbil.univ-lyon1.fr/R/pdf/pps034.pdf</a> (in French).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trichometeo)
faulog &lt;- log(trichometeo$fau + 1)
pca1 &lt;- dudi.pca(trichometeo$meteo, scan = FALSE)
niche1 &lt;- niche(pca1, faulog, scan = FALSE)

if(adegraphicsLoaded()) {
  g1 &lt;- s.distri(niche1$ls, faulog, plab.cex = 0.6, ellipseSize = 0, starSize = 0.3, plot = FALSE)
  g2 &lt;- s.arrow(7 * niche1$c1, plab.cex = 1, plot = FALSE)
  G &lt;- superpose(g1, g2, plot = TRUE)
  
} else {
  s.label(niche1$ls, clab = 0)
  s.distri(niche1$ls, faulog, clab = 0.6, add.p = TRUE, cell = 0, csta = 0.3)
  s.arrow(7 * niche1$c1, clab = 1, add.p = TRUE)
}</code></pre>

<hr>
<h2 id='ungulates'>Phylogeny and quantitative traits of ungulates.</h2><span id='topic+ungulates'></span>

<h3>Description</h3>

<p>This data set describes the phylogeny of 18 ungulates as reported by Pélabon et al. (1995). It also gives 4 traits corresponding to these 18 species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ungulates)</code></pre>


<h3>Format</h3>

<p><code>fission</code> is a list containing the 2 following objects : 
</p>
 
<dl>
<dt>tre</dt><dd><p>is a character string giving the phylogenetic tree in Newick format.</p>
</dd> 
<dt>tab</dt><dd><p>is a data frame with 18 species and 4 traits</p>
</dd>    
</dl>


<h3>Details</h3>

        
<p>Variables of <code>ungulates$tab</code> are the following ones : <br />
afbw: is a numeric vector that describes the adult female body weight (g) <br />
mnw: is a numeric vector that describes the male neonatal weight (g) <br />
fnw: is a numeric vector that describes the female neonatal weight (g) <br />
ls: is a numeric vector that describes the litter size <br />
</p>


<h3>Source</h3>

<p>Data were obtained from Pélabon, C., Gaillard, J.M., Loison, A. and Portier, A. (1995) 
Is sex-biased maternal care limited by total maternal expenditure in polygynous ungulates? 
<em>Behavioral Ecology and Sociobiology</em>, <b>37</b>, 311&ndash;319.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ungulates)
ung.phy &lt;- newick2phylog(ungulates$tre)
plot(ung.phy,clabel.l=1.25,clabel.n=0.75)
ung.x &lt;- log(ungulates$tab[,1])
ung.y &lt;- log((ungulates$tab[,2]+ungulates$tab[,3])/2)
names(ung.x) &lt;- names(ung.phy$leaves)
names(ung.y) &lt;- names(ung.x)
plot(ung.x,ung.y)
abline(lm(ung.y~ung.x))
symbols.phylog(ung.phy,ung.x-mean(ung.x))
dotchart.phylog(ung.phy,ung.x,cle=1.5,cno=1.5,cdot=1)
if (requireNamespace("adephylo", quietly = TRUE) &amp; requireNamespace("ape", quietly = TRUE)) {
  tre &lt;- ape::read.tree(text = ungulates$tre)
  adephylo::orthogram(ung.x, tre)
  ung.z &lt;- residuals(lm(ung.y~ung.x))
  names(ung.z) &lt;- names(ung.phy$leaves)
  dotchart.phylog(ung.phy,ung.z,cle=1.5,cno=1.5,cdot=1,ceti=0.75)
  adephylo::orthogram(ung.z, tre)
}
</code></pre>

<hr>
<h2 id='uniquewt.df'>Elimination of Duplicated Rows in a Array</h2><span id='topic+uniquewt.df'></span>

<h3>Description</h3>

<p>An utility function to eliminate the duplicated rows in a array. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniquewt.df(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniquewt.df_+3A_x">x</code></td>
<td>
<p>a data frame which contains duplicated rows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>y</code> which contains once each duplicated row of <code>x</code>.<br />
<code>y</code> is an attribut 'factor' which gives the number of the row of <code>y</code> in which each row of <code>x</code> is found<br />
<code>y</code> is an attribut 'length.class' which gives the number of duplicates in <code>x</code> with an attribut of each row of <code>y</code> with an attribut
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecomor)
forsub.r &lt;- uniquewt.df(ecomor$forsub)
attr(forsub.r, "factor")
forsub.r[1,]
ecomor$forsub[126,] #idem

dudi.pca(ecomor$forsub, scale = FALSE, scann = FALSE)$eig
# [1] 0.36845 0.24340 0.15855 0.09052 0.07970 0.04490
w1 &lt;- attr(forsub.r, "len.class") / sum(attr(forsub.r,"len.class"))
dudi.pca(forsub.r, row.w = w1, scale = FALSE, scann = FALSE)$eig
# [1] 0.36845 0.24340 0.15855 0.09052 0.07970 0.04490
</code></pre>

<hr>
<h2 id='variance.phylog'>The phylogenetic ANOVA</h2><span id='topic+variance.phylog'></span>

<h3>Description</h3>

<p>This function performs the variance analysis of a trait on eigenvectors associated to a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance.phylog(phylog, z, bynames = TRUE,
 na.action = c("fail", "mean"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variance.phylog_+3A_phylog">phylog</code></td>
<td>
<p>: an object of class <code>phylog</code></p>
</td></tr>
<tr><td><code id="variance.phylog_+3A_z">z</code></td>
<td>
<p>: a numeric vector of the values corresponding to the variable</p>
</td></tr>
<tr><td><code id="variance.phylog_+3A_bynames">bynames</code></td>
<td>
<p>: if TRUE checks if <code>z</code> labels are the same as <code>phylog</code> leaves label, possibly in a different order. If FALSE the check is not made and <code>z</code> labels must be in the same order than <code>phylog</code> leaves label</p>
</td></tr>
<tr><td><code id="variance.phylog_+3A_na.action">na.action</code></td>
<td>
<p>: if 'fail' stops the execution of the current expression when <code>z</code> contains any missing value. If 'mean' replaces any missing values by mean(<code>z</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>phylog$Amat</code> defines a set of orthonormal vectors associated the each nodes of the phylogenetic tree. <br />
<code>phylog$Adim</code> defines the dimension of the subspace <b>A</b> defined by 
the first <code>phylog$Adim</code> vectors of <code>phylog$Amat</code> that corresponds to phylogenetic inertia. <br />
<code>variance.phylog</code> performs the linear regression of <code>z</code> on <b>A</b>.
</p>


<h3>Value</h3>

<p>Returns a list containing
</p>
<table>
<tr><td><code>lm</code></td>
<td>
<p>: an object of class <code>lm</code> that corresponds to the linear regression of <code>z</code> on <b>A</b>.</p>
</td></tr>
<tr><td><code>anova</code></td>
<td>
<p>: an object of class <code>anova</code> that corresponds to the anova of the precedent model.</p>
</td></tr>
<tr><td><code>smry</code></td>
<td>
<p>: an object of class <code>anova</code> that is a summary of the precedent object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Ollier <a href="mailto:sebastien.ollier@u-psud.fr">sebastien.ollier@u-psud.fr</a> <br />
Daniel Chessel 
</p>


<h3>References</h3>

<p>Grafen, A. (1989) The phylogenetic regression. <em>Philosophical Transactions of the Royal Society London B</em>, <b>326</b>, 119&ndash;156.
</p>
<p>Diniz-Filho, J. A. F., Sant'Ana, C.E.R. and Bini, L.M. (1998) An eigenvector method for estimating phylogenetic inertia. <em>Evolution</em>, <b>52</b>, 1247&ndash;1262.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phylog">phylog</a></code>, <code><a href="stats.html#topic+lm">lm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(njplot)
njplot.phy &lt;- newick2phylog(njplot$tre)
variance.phylog(njplot.phy,njplot$tauxcg)
par(mfrow = c(1,2))
table.phylog(njplot.phy$Ascores, njplot.phy, clabel.row = 0,
  clabel.col = 0.1, clabel.nod = 0.6, csize = 1)
dotchart.phylog(njplot.phy, njplot$tauxcg, clabel.nodes = 0.6)
if (requireNamespace("adephylo", quietly = TRUE) &amp; requireNamespace("ape", quietly = TRUE)) {
  tre &lt;- ape::read.tree(text = njplot$tre)
  adephylo::orthogram(njplot$tauxcg, tre = tre)
}
</code></pre>

<hr>
<h2 id='varipart'>Partition of the variation of a response multivariate table by 2 explanatory tables</h2><span id='topic+varipart'></span><span id='topic+print.varipart'></span>

<h3>Description</h3>

<p>The function partitions the variation of a response table (usually community data) with respect to two
explanatory tables. The function performs the variation partitioning based on
redundancy analysis (RDA, if <code>dudiY</code> is obtained by <code>dudi.pca</code>) or canonical correspondance analysis (CCA, if <code>dudiY</code> is obtained by <code>dudi.coa</code>) 
and computes 
unadjusted and adjusted R-squared. 
The significance of R-squared are evaluated by a randomization procedure
where the rows of the explanatory tables are permuted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varipart(Y, X, W = NULL, nrepet = 999, type = c("simulated", "parametric"),
scale = FALSE, ...)
## S3 method for class 'varipart'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varipart_+3A_y">Y</code></td>
<td>
<p>a vector, matrix or data frame or an object of class <code>dudi</code>. If not a <code>dudi</code> object, the data are trated by a principal component analysis (<code>dudi.pca</code>).</p>
</td></tr>
<tr><td><code id="varipart_+3A_x">X</code>, <code id="varipart_+3A_w">W</code></td>
<td>
<p>dataframes or matrices of explanatory (co)variables (numeric and/or factor
variables). By default, no covariables are considered (<code>W</code> is <code>NULL</code>) and this case corresponds to simple caonical ordination.</p>
</td></tr>
<tr><td><code id="varipart_+3A_nrepet">nrepet</code></td>
<td>
<p>an integer indicating the number of permutations
.</p>
</td></tr>
<tr><td><code id="varipart_+3A_type">type</code></td>
<td>
<p>a character specifying the algorithm which should be used to adjust R-squared (either <code>"simulated"</code> or \ code&quot;parametric&quot;).</p>
</td></tr>
<tr><td><code id="varipart_+3A_scale">scale</code></td>
<td>
<p>If <code>Y</code> is not a dudi, a <code>logical</code> indicating if variables should be scaled</p>
</td></tr>
<tr><td><code id="varipart_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>as.krandtest</code> or <code>as.randtest</code> (if no covariables are considered) for function <code>varipart</code>.</p>
</td></tr>
<tr><td><code id="varipart_+3A_x">x</code></td>
<td>
<p>an object of class <code>varipart</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two types of algorithm are provided to adjust R-squared. The &quot;simulated&quot; procedure 
estimates the unadjusted R-squared expected under the null hypothesis H0 and uses it to adjust the
observed R-squared as follows: R2.adj = 1 - (1 - R2) / (1 - E(R2|H0)) with R2.adj the
adjusted R-squared and R2 the unadjusted R-squared.
The &quot;parametric&quot; procedure performs the Ezequiel's adjustement on the unadjusted R-squared as: 
R2.adj = 1 - (1 - R2) / (1 - p / (n - 1)) where n is the number of sites, and p the number of
predictors.
</p>


<h3>Value</h3>

<p>It returns an object of class <code>varipart</code>. It is a <code>list</code> with:
</p>

<dl>
<dt><code>test</code></dt><dd><p>the significance test of fractions [ab], [bc], and [abc] based on randomization procedure. An object of class <code>krandtest</code></p>
</dd>
<dt><code>R2</code></dt><dd><p>unadjusted estimations of fractions [a], [b], [c], and [d]</p>
</dd>
<dt><code>R2.adj</code></dt><dd><p>adjusted estimations of fractions [a], [b], [c], and [d]</p>
</dd>
<dt><code>call</code></dt><dd><p>the matched call</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Stephane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a> and Sylvie Clappe <a href="mailto:sylvie.clappe@univ-lyon1.fr">sylvie.clappe@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Borcard, D., P. Legendre, and P. Drapeau. 1992. Partialling out the spatial component
of ecological variation. Ecology 73:1045. 
</p>
<p>Peres-Neto, P. R., P. Legendre, S. Dray, and D. Borcard. 2006. Variation partitioning of
species data matrices: estimation and comparison of fractions. Ecology 87:2614-2625.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcaiv">pcaiv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mafragh)

# PCA on response table Y
Y &lt;- mafragh$flo
dudiY &lt;- dudi.pca(Y, scannf = FALSE, scale = FALSE)

# Variation partitioning based on RDA
# without covariables
vprda &lt;- varipart(dudiY,  mafragh$env)
vprda
# Variation partitioning based on RDA
# with covariables and parametric estimation
vprda &lt;- varipart(dudiY,  mafragh$env, mafragh$xy, type = "parametric")
vprda
names(vprda)
</code></pre>

<hr>
<h2 id='vegtf'>Vegetation in Trois-Fontaines</h2><span id='topic+vegtf'></span>

<h3>Description</h3>

<p>This data set contains abundance values (Braun-Blanquet scale) of 80 plant
species for 337 sites. Data have been collected by Sonia Said and Francois Debias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vegtf)</code></pre>


<h3>Format</h3>

<p><code>vegtf</code> is a list with the following components:
</p>

<dl>
<dt>veg</dt><dd><p>a data.frame with the abundance values of 80 species (columns)
in 337 sites (rows)</p>
</dd>
<dt>xy</dt><dd><p>a data.frame with the spatial coordinates of the sites</p>
</dd>
<dt>area</dt><dd><p>a data.frame (area) which define the boundaries of the study site</p>
</dd>
<dt>sp.names</dt><dd><p>a vector containing the species latin names</p>
</dd>
<dt>nb</dt><dd><p>a neighborhood object (class <code>nb</code> defined in package <code>spdep</code>)</p>
</dd>
<dt>Spatial</dt><dd><p>an object of the class <code>SpatialPolygons</code> of <code>sp</code>,
containing the map</p>
</dd>
</dl>


<h3>Source</h3>

<p>Dray, S., Said, S. and Debias, F. (2008) Spatial ordination of vegetation 
data using a generalization of Wartenberg's multivariate spatial correlation. 
<em>Journal of vegetation science</em>, <b>19</b>, 45&ndash;56.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("spdep", quietly = TRUE)) {
  data(vegtf)
  coa1 &lt;- dudi.coa(vegtf$veg, scannf = FALSE)
  ms.coa1 &lt;- multispati(coa1, listw = spdep::nb2listw(vegtf$nb), nfposi = 2, 
    nfnega = 0, scannf = FALSE)
  summary(ms.coa1)
  plot(ms.coa1)
  
  if(adegraphicsLoaded()) {
    g1 &lt;- s.value(vegtf$xy, coa1$li[, 1], Sp = vegtf$Spatial, pSp.col = "white", plot = FALSE)
    g2 &lt;- s.value(vegtf$xy, ms.coa1$li[, 1], Sp = vegtf$Spatial, pSp.col = "white", plot = FALSE)
    g3 &lt;- s.label(coa1$c1, plot = FALSE)
    g4 &lt;- s.label(ms.coa1$c1, plot = FALSE)
    G &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))
  } else {
    par(mfrow = c(2, 2))
    s.value(vegtf$xy, coa1$li[, 1], area = vegtf$area, include.origin = FALSE)
    s.value(vegtf$xy, ms.coa1$li[, 1], area = vegtf$area, include.origin = FALSE)
    s.label(coa1$c1)
    s.label(ms.coa1$c1)
  }
}</code></pre>

<hr>
<h2 id='veuvage'>Example for Centring in PCA</h2><span id='topic+veuvage'></span>

<h3>Description</h3>

<p>The data come from the INSEE (National Institute of Statistics and Economical Studies). 
It is an array of widower percentages in relation with the age and the socioprofessional category. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(veuvage)</code></pre>


<h3>Format</h3>

<p><code>veuvage</code> is a list of 2 components.
</p>

<dl>
<dt>tab</dt><dd><p>is a data frame with 37 rows (widowers) 6 columns (socio-professional categories)</p>
</dd>
<dt>age</dt><dd><p>is a vector of the ages of the 37 widowers. </p>
</dd>
</dl>



<h3>Details</h3>

<p>The columns contain the socioprofessional categories:<br />
1- Farmers, 2- Craftsmen, 3- Executives and higher intellectual professions,<br />
4- Intermediate Professions, 5- Others white-collar workers and 6- Manual workers.<br />
</p>


<h3>Source</h3>

<p>unknown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(veuvage)
par(mfrow = c(3,2))
for (j in 1:6) plot(veuvage$age, veuvage$tab[,j],
    xlab = "age", ylab = "pourcentage de veufs",
    type = "b", main = names(veuvage$tab)[j])
</code></pre>

<hr>
<h2 id='wca'>Within-Class Analysis</h2><span id='topic+wca'></span><span id='topic+wca.dudi'></span>

<h3>Description</h3>

<p>Performs a particular case of an Orthogonal Principal Component Analysis with
respect to Instrumental Variables (orthopcaiv), in which there is only a
single factor as covariable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dudi'
wca(x, fac, scannf = TRUE, nf = 2, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wca_+3A_x">x</code></td>
<td>
<p>a duality diagram, object of class <code><a href="#topic+dudi">dudi</a></code> from
one of the functions <code>dudi.coa</code>, <code>dudi.pca</code>,...</p>
</td></tr>
<tr><td><code id="wca_+3A_fac">fac</code></td>
<td>
<p>a factor partitioning the rows of <code>dudi$tab</code> in classes</p>
</td></tr>
<tr><td><code id="wca_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="wca_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="wca_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of the sub-class <code>within</code> in the class <code>dudi</code>
</p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>a data frame containing the transformed data (substraction of the class mean)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matching call</p>
</td></tr>
<tr><td><code>nf</code></td>
<td>
<p>number of kept axes</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the rank of the analysis</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>percentage of within-class inertia</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a numeric vector containing the eigenvalues</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>a numeric vector of row weigths</p>
</td></tr>
<tr><td><code>cw</code></td>
<td>
<p>a numeric vector of column weigths</p>
</td></tr>
<tr><td><code>tabw</code></td>
<td>
<p>a numeric vector of class weigths</p>
</td></tr>
<tr><td><code>fac</code></td>
<td>
<p>the factor defining the classes</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>data frame row coordinates</p>
</td></tr>
<tr><td><code>l1</code></td>
<td>
<p>data frame row normed scores</p>
</td></tr> 
<tr><td><code>co</code></td>
<td>
<p>data frame column coordinates</p>
</td></tr>
<tr><td><code>c1</code></td>
<td>
<p>data frame column normed scores</p>
</td></tr>
<tr><td><code>ls</code></td>
<td>
<p>data frame supplementary row coordinates</p>
</td></tr>
<tr><td><code>as</code></td>
<td>
<p>data frame inertia axis onto within axis</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To avoid conflict names with the <code>base:::within</code> function, the
function <code>within</code> is now deprecated and removed. It 
is replaced by the method <code>wca.dudi</code> of the new generic <code>wca</code> function. 
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Benzécri, J. P. (1983) Analyse de l'inertie intra-classe par l'analyse d'un 
tableau de correspondances. <em>Les Cahiers de l'Analyse des données</em>, <b>8</b>, 351&ndash;358.<br /><br />
Dolédec, S. and Chessel, D. (1987) Rythmes saisonniers et composantes stationnelles 
en milieu aquatique I- Description d'un plan d'observations complet par projection de 
variables. <em>Acta Oecologica, Oecologia Generalis</em>, <b>8</b>, 3, 403&ndash;426.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
pca1 &lt;- dudi.pca(meaudret$env, scan = FALSE, nf = 4)
wit1 &lt;- wca(pca1, meaudret$design$site, scan = FALSE, nf = 2)

if(adegraphicsLoaded()) {
  g1 &lt;- s.traject(pca1$li, meaudret$design$site, psub.text = "Principal Component Analysis", 
    plines.lty = 1:nlevels(meaudret$design$site), psub.cex = 1.5, plot = FALSE)
  g2 &lt;- s.traject(wit1$li, meaudret$design$site, 
    psub.text = "Within site Principal Component Analysis", 
    plines.lty = 1:nlevels(meaudret$design$site), psub.cex = 1.5, plot = FALSE)
  g3 &lt;- s.corcircle (wit1$as, plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3), layout = c(2, 2))
  
} else {
  par(mfrow = c(2, 2))
  s.traject(pca1$li, meaudret$design$site, sub = "Principal Component Analysis", csub = 1.5)
  s.traject(wit1$li, meaudret$design$site, sub = "Within site Principal Component Analysis", 
    csub = 1.5)
  s.corcircle (wit1$as)
  par(mfrow = c(1,1))
}
plot(wit1)
</code></pre>

<hr>
<h2 id='wca.coinertia'>Within-class coinertia analysis</h2><span id='topic+wca.coinertia'></span>

<h3>Description</h3>

<p>Performs a within-class analysis after a coinertia analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coinertia'
wca(x, fac, scannf = TRUE, nf = 2, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wca.coinertia_+3A_x">x</code></td>
<td>
<p>a coinertia analysis (object of class <a href="#topic+coinertia">coinertia</a>)
obtained by the function <a href="#topic+coinertia">coinertia</a></p>
</td></tr>
<tr><td><code id="wca.coinertia_+3A_fac">fac</code></td>
<td>
<p>a factor partitioning the rows in classes</p>
</td></tr>
<tr><td><code id="wca.coinertia_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues barplot should be displayed</p>
</td></tr>
<tr><td><code id="wca.coinertia_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="wca.coinertia_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This analysis is equivalent to do a within-class analysis on each
initial dudi, and a coinertia analysis on the two within
analyses. This function returns additional outputs for the interpretation. 
</p>


<h3>Value</h3>

<p>An object of the class <code>witcoi</code>. Outputs are described by the
<code>print</code> function
</p>


<h3>Note</h3>

<p>To avoid conflict names with the <code>base:::within</code> function, the
function <code>within</code> is now deprecated and removed. To be
consistent, the <code>withincoinertia</code> function is also deprecated and
is replaced by the method <code>wca.coinertia</code> of the generic <code>wca</code> function. 
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a> and Jean Thioulouse <a href="mailto:jean.thioulouse@univ-lyon1.fr">jean.thioulouse@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Franquet E., Doledec S., and Chessel D. (1995) Using multivariate analyses for 
separating spatial and temporal effects within species-environment relationships. 
<em>Hydrobiologia</em>, <b>300</b>, 425&ndash;431.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coinertia">coinertia</a></code>, <code><a href="#topic+wca">wca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
pca1 &lt;- dudi.pca(meaudret$env, scan = FALSE, nf = 4)
pca2 &lt;- dudi.pca(meaudret$spe, scal = FALSE, scan = FALSE, nf = 4)
   
wit1 &lt;- wca(pca1, meaudret$design$site, scan = FALSE, nf = 2)
wit2 &lt;- wca(pca2, meaudret$design$site, scan = FALSE, nf = 2)
coiw &lt;- coinertia(wit1, wit2, scannf = FALSE)

coi &lt;- coinertia(pca1, pca2, scannf = FALSE, nf = 3)
coi.w &lt;- wca(coi, meaudret$design$site, scannf = FALSE)
## coiw and coi.w are equivalent

plot(coi.w)
</code></pre>

<hr>
<h2 id='wca.rlq'>
Within-Class RLQ analysis
</h2><span id='topic+wca.rlq'></span><span id='topic+plot.witrlq'></span><span id='topic+print.witrlq'></span>

<h3>Description</h3>

<p>Performs a particular RLQ analysis where a partition of sites (rows of
R) is taken into account. The within-class RLQ analysis search for
linear combinations of traits and environmental variables of maximal covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rlq'
wca(x, fac, scannf = TRUE, nf = 2, ...)
## S3 method for class 'witrlq'
plot(x, xax = 1, yax = 2, ...)
## S3 method for class 'witrlq'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wca.rlq_+3A_x">x</code></td>
<td>
<p>an object of class rlq (created by the <code>rlq</code> function)
for the <code>wca.rlq</code> function. An object of class <code>witrlq</code> for
the <code>print</code> and <code>plot</code> functions</p>
</td></tr>
<tr><td><code id="wca.rlq_+3A_fac">fac</code></td>
<td>
<p>a factor partitioning the rows of R</p>
</td></tr>
<tr><td><code id="wca.rlq_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="wca.rlq_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
<tr><td><code id="wca.rlq_+3A_xax">xax</code></td>
<td>
<p>the column number for the x-axis</p>
</td></tr>
<tr><td><code id="wca.rlq_+3A_yax">yax</code></td>
<td>
<p>the column number for the y-axis</p>
</td></tr>
<tr><td><code id="wca.rlq_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>wca.rlq</code> function returns an object of class 'betrlq'
(sub-class of 'dudi'). See the outputs of the <code>print</code> function
for more details.
</p>


<h3>Author(s)</h3>

<p>Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Wesuls, D., Oldeland, J. and Dray, S. (2012) Disentangling plant trait
responses to livestock grazing from spatio-temporal variation: the
partial RLQ approach. <em>Journal of Vegetation Science</em>, <b>23</b>, 98&ndash;113.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rlq">rlq</a></code>, <code><a href="#topic+wca">wca</a></code>, <code><a href="#topic+wca.rlq">wca.rlq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(piosphere)
afcL &lt;- dudi.coa(log(piosphere$veg + 1), scannf = FALSE)
acpR &lt;- dudi.pca(piosphere$env, scannf = FALSE, row.w = afcL$lw)
acpQ &lt;- dudi.hillsmith(piosphere$traits, scannf = FALSE, row.w = afcL$cw)
rlq1 &lt;- rlq(acpR, afcL, acpQ, scannf = FALSE)

wrlq1 &lt;- wca(rlq1, fac = piosphere$habitat, scannf = FALSE)
wrlq1
plot(wrlq1)
</code></pre>

<hr>
<h2 id='westafrica'>Freshwater fish zoogeography in west Africa</h2><span id='topic+westafrica'></span>

<h3>Description</h3>

<p>This data set contains informations about faunal similarities between river basins in West africa.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(westafrica)</code></pre>


<h3>Format</h3>

<p><code>westafrica</code> is a list containing the following objects : 
</p>

<dl>
<dt>tab</dt><dd><p>: a data frame with absence/presence of 268 species (rows) at 33 embouchures (columns)</p>
</dd>
<dt>spe.names</dt><dd><p>: a vector of string of characters with the name of species</p>
</dd>
<dt>spe.binames</dt><dd><p>: a data frame with the genus and species (columns) of the 256 species (rows)</p>
</dd>
<dt>riv.names</dt><dd><p>: a vector of string of characters with the name of rivers</p>
</dd>
<dt>atlantic</dt><dd><p>: a data frame with the coordinates of a polygon that represents the limits of atlantic (see example)</p>
</dd>
<dt>riv.xy</dt><dd><p>: a data frame with the coordinates of embouchures</p>
</dd>
<dt>lines</dt><dd><p>: a data frame with the coordinates of lines to complete the representation (see example)</p>
</dd>
<dt>cadre</dt><dd><p>: a data frame with the coordinates of points used to make the representation (see example)</p>
</dd>   
</dl>


<h3>Source</h3>

<p>Data provided by B. Hugueny <a href="mailto:hugueny@mnhn.fr">hugueny@mnhn.fr</a>.
</p>
<p>Paugy, D., Traoré, K. and Diouf, P.F. (1994) Faune ichtyologique des eaux douces d'Afrique de l'Ouest. 
In <em>Diversité biologique des poissons des eaux douces et saumâtres d'Afrique. Synthèses géographiques</em>, 
Teugels, G.G., Guégan, J.F. and Albaret, J.J. (Editors). Annales du Musée Royal de l'Afrique Centrale,  
Zoologie, <b>275</b>, Tervuren, Belgique, 35&ndash;66.
</p>
<p>Hugueny, B. (1989) <em>Biogéographie et structure des peuplements de Poissons d'eau douce de l'Afrique de l'ouest : 
approches quantitatives</em>. Thèse de doctorat, Université Paris 7.
</p>


<h3>References</h3>

<p>Hugueny, B., and Lévêque, C. (1994) Freshwater fish zoogeography in west Africa: 
faunal similarities between river basins. <em>Environmental Biology of Fishes</em>, <b>39</b>, 365&ndash;380.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(westafrica)

if(!adegraphicsLoaded()) {
  s.label(westafrica$cadre, xlim = c(30, 500), ylim = c(50, 290),
    cpoi = 0, clab = 0, grid = FALSE, addax = 0)
  old.par &lt;- par(no.readonly = TRUE)
  par(mar = c(0.1, 0.1, 0.1, 0.1))
  rect(30, 0, 500, 290)
  polygon(westafrica$atlantic, col = "lightblue")
  points(westafrica$riv.xy, pch = 20, cex = 1.5)
  apply(westafrica$lines, 1, function(x) segments(x[1], x[2], x[3], x[4], lwd = 1))
  apply(westafrica$riv.xy,1, function(x) segments(x[1], x[2], x[3], x[4], lwd = 1))
  text(c(175, 260, 460, 420), c(275, 200, 250, 100), c("Senegal", "Niger", "Niger", "Volta"))
  par(srt = 270)
  text(westafrica$riv.xy$x2, westafrica$riv.xy$y2-10, westafrica$riv.names, adj = 0, cex = 0.75)
  par(old.par)
  rm(old.par)
}

# multivariate analysis
afri.w &lt;- data.frame(t(westafrica$tab))
afri.dist &lt;- dist.binary(afri.w,1)
afri.pco &lt;- dudi.pco(afri.dist, scannf = FALSE, nf = 3)
if(adegraphicsLoaded()) {
  G1 &lt;- s1d.barchart(afri.pco$li[, 1:3], p1d.horizontal = FALSE, plabels.cex = 0)
} else {
  par(mfrow = c(3, 1))
  barplot(afri.pco$li[, 1])
  barplot(afri.pco$li[, 2])
  barplot(afri.pco$li[, 3])
}

if(requireNamespace("spdep", quietly = TRUE)) {
  # multivariate spatial analysis
  afri.neig &lt;- neig(n.line = 33)
  afri.nb &lt;- neig2nb(afri.neig)
  afri.listw &lt;- spdep::nb2listw(afri.nb)
  afri.ms &lt;- multispati(afri.pco, afri.listw, scannf = FALSE, nfposi = 6, nfnega = 0)
  
  if(adegraphicsLoaded()) {
    G2 &lt;- s1d.barchart(afri.ms$li[, 1:3], p1d.horizontal = FALSE, plabels.cex = 0)
    
    g31 &lt;- s.label(afri.ms$li, plabels.cex = 0.75, ppoints.cex = 0, nb = afri.nb, plot = FALSE)
    g32 &lt;- s.value(afri.ms$li, afri.ms$li[, 3], plot = FALSE)
    g33 &lt;- s.value(afri.ms$li, afri.ms$li[, 4], plot = FALSE)
    g34 &lt;- s.value(afri.ms$li, afri.ms$li[, 5], plot = FALSE)
    G3 &lt;- ADEgS(list(g31, g32, g33, g34), layout = c(2, 2))
    
  } else {
    par(mfrow = c(3, 1))
    barplot(afri.ms$li[, 1])
    barplot(afri.ms$li[, 2])
    barplot(afri.ms$li[, 3])
    
    par(mfrow = c(2, 2))
    s.label(afri.ms$li, clab = 0.75, cpoi = 0, neig = afri.neig, cneig = 1.5)
    s.value(afri.ms$li, afri.ms$li[, 3])
    s.value(afri.ms$li, afri.ms$li[, 4])
    s.value(afri.ms$li, afri.ms$li[, 5])
  }
  summary(afri.ms)
}

par(mfrow = c(1, 1))
plot(hclust(afri.dist, "ward.D"), h = -0.2)
</code></pre>

<hr>
<h2 id='within'>Within-Class Analysis</h2><span id='topic+print.within'></span><span id='topic+summary.within'></span><span id='topic+plot.within'></span><span id='topic+plot.witcoi'></span><span id='topic+print.witcoi'></span>

<h3>Description</h3>

<p>Outputs and graphical representations of the results of a within-class analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'within'
plot(x, xax = 1, yax = 2, ...) 
## S3 method for class 'within'
print(x, ...)
## S3 method for class 'witcoi'
plot(x, xax = 1, yax = 2, ...)
## S3 method for class 'witcoi'
print(x, ...)
## S3 method for class 'within'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="within_+3A_x">x</code>, <code id="within_+3A_object">object</code></td>
<td>
<p>an object of class <code>within</code> or <code>witcoi</code></p>
</td></tr>
<tr><td><code id="within_+3A_xax">xax</code></td>
<td>
<p>the column index for the x-axis</p>
</td></tr>
<tr><td><code id="within_+3A_yax">yax</code></td>
<td>
<p>the column index for the y-axis</p>
</td></tr>
<tr><td><code id="within_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a><br />
Stéphane Dray <a href="mailto:stephane.dray@univ-lyon1.fr">stephane.dray@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Benzécri, J. P. (1983) Analyse de l'inertie intra-classe par l'analyse d'un tableau de correspondances. <em>Les Cahiers de l'Analyse des données</em>, <b>8</b>, 351&ndash;358.<br /><br />
Dolédec, S. and Chessel, D. (1987) Rythmes saisonniers et composantes stationnelles en milieu aquatique I- Description d'un plan d'observations complet par projection de variables. <em>Acta Oecologica, Oecologia Generalis</em>, <b>8</b>, 3, 403&ndash;426.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wca.dudi">wca.dudi</a></code>, <code><a href="#topic+wca.coinertia">wca.coinertia</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
pca1 &lt;- dudi.pca(meaudret$env, scan = FALSE, nf = 4)
wit1 &lt;- wca(pca1, meaudret$design$site, scan = FALSE, nf = 2)

if(adegraphicsLoaded()) {
  g1 &lt;- s.traject(pca1$li, meaudret$design$site, psub.text = "Principal Component Analysis", 
    plines.lty = 1:length(levels(meaudret$design$site)), plot = FALSE)
  g2 &lt;- s.traject(wit1$li, meaudret$design$site, psub.text = 
    "Within site Principal Component Analysis", 
    plines.lty = 1:length(levels(meaudret$design$site)), plot = FALSE)
  g3 &lt;- s.corcircle (wit1$as, plot = FALSE)
  G &lt;- ADEgS(list(g1, g2, g3), layout = c(2, 2))
  
} else {
  par(mfrow = c(2, 2))
  s.traject(pca1$li, meaudret$design$site, sub = "Principal Component Analysis", csub = 1.5)
  s.traject(wit1$li, meaudret$design$site, sub = "Within site Principal Component Analysis", 
    csub = 1.5)
  s.corcircle (wit1$as)
  par(mfrow = c(1, 1))
}

plot(wit1)
</code></pre>

<hr>
<h2 id='withinpca'>Normed within principal component analysis</h2><span id='topic+withinpca'></span>

<h3>Description</h3>

<p>Performs a normed within Principal Component Analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>withinpca(df, fac, scaling = c("partial", "total"), 
    scannf = TRUE, nf = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="withinpca_+3A_df">df</code></td>
<td>
<p>a data frame with quantitative variables</p>
</td></tr>
<tr><td><code id="withinpca_+3A_fac">fac</code></td>
<td>
<p>a factor partitioning the rows of df in classes</p>
</td></tr>
<tr><td><code id="withinpca_+3A_scaling">scaling</code></td>
<td>
<p>a string of characters as a scaling option : <br />
if &quot;partial&quot;, the sub-table corresponding to each class is centred and normed.<br />
If &quot;total&quot;, the sub-table corresponding to each class is centred and the total table is then normed.</p>
</td></tr>
<tr><td><code id="withinpca_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="withinpca_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions implements the 'Bouroche' standardization. In a first
step, the original variables are standardized (centred and normed). Then, a second
transformation is applied according to the value of the <code>scaling</code>
argument. For &quot;partial&quot;, variables are standardized in each sub-table
(corresponding to each level of the factor). Hence, variables have null
mean and unit variance in each sub-table. For &quot;total&quot;, variables are
centred in each sub-table and then normed globally. Hence, variables
have a null mean in each sub-table and a global variance equal to one.
</p>


<h3>Value</h3>

<p>returns a list of the sub-class <code>within</code> of class <code>dudi</code>. See <code><a href="#topic+wca">wca</a></code>
</p>


<h3>Author(s)</h3>

<p>Daniel Chessel <br />
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
</p>


<h3>References</h3>

<p>Bouroche, J. M. (1975) <em>Analyse des données ternaires: la double analyse en composantes principales</em>. 
Thèse de 3ème cycle, Université de Paris VI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
wit1 &lt;- withinpca(meaudret$env, meaudret$design$season, scannf = FALSE, scaling = "partial")
kta1 &lt;- ktab.within(wit1, colnames = rep(c("S1", "S2", "S3", "S4", "S5"), 4))
unclass(kta1)

# See pta
plot(wit1)
</code></pre>

<hr>
<h2 id='witwit.coa'>Internal Correspondence Analysis</h2><span id='topic+witwit.coa'></span><span id='topic+summary.witwit'></span><span id='topic+witwitsepan'></span>

<h3>Description</h3>

<p><code>witwit.coa</code> performs an Internal Correspondence Analysis. 
<code>witwitsepan</code> gives the computation and the barplot of the eigenvalues
for each separated analysis in an Internal Correspondence Analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>witwit.coa(dudi, row.blocks, col.blocks, scannf = TRUE, nf = 2)
## S3 method for class 'witwit'
summary(object, ...)
witwitsepan(ww, mfrow = NULL, csub = 2, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="witwit.coa_+3A_dudi">dudi</code></td>
<td>
<p>an object of class <code>coa</code> </p>
</td></tr>
<tr><td><code id="witwit.coa_+3A_row.blocks">row.blocks</code></td>
<td>
<p>a numeric vector indicating the row numbers for each block of rows</p>
</td></tr>
<tr><td><code id="witwit.coa_+3A_col.blocks">col.blocks</code></td>
<td>
<p>a numeric vector indicating the column numbers for each block of columns</p>
</td></tr>
<tr><td><code id="witwit.coa_+3A_scannf">scannf</code></td>
<td>
<p>a logical value indicating whether the eigenvalues bar plot should be displayed</p>
</td></tr>
<tr><td><code id="witwit.coa_+3A_nf">nf</code></td>
<td>
<p>if scannf FALSE, an integer indicating the number of kept axes</p>
</td></tr>
</table>
<p><br />
</p>
<table>
<tr><td><code id="witwit.coa_+3A_object">object</code></td>
<td>
<p>an object of class <code>witwit</code></p>
</td></tr>
<tr><td><code id="witwit.coa_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>
<p><br />
</p>
<table>
<tr><td><code id="witwit.coa_+3A_ww">ww</code></td>
<td>
<p>an object of class <code>witwit</code></p>
</td></tr>
<tr><td><code id="witwit.coa_+3A_mfrow">mfrow</code></td>
<td>
<p>a vector of the form &quot;c(nr,nc)&quot;, otherwise computed by a special own function 'n2mfrow'</p>
</td></tr>
<tr><td><code id="witwit.coa_+3A_csub">csub</code></td>
<td>
<p>a character size for the sub-titles, used with <code>par("cex")*csub</code></p>
</td></tr>
<tr><td><code id="witwit.coa_+3A_plot">plot</code></td>
<td>
<p>if FALSE, numeric results are returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of class <code>witwit</code>, <code>coa</code> and <code>dudi</code> (see <a href="#topic+as.dudi">as.dudi</a>) containing
</p>
<table>
<tr><td><code>rbvar</code></td>
<td>
<p>a data frame with the within variances of the rows of the factorial coordinates</p>
</td></tr>
<tr><td><code>lbw</code></td>
<td>
<p>a data frame with the marginal weighting of the row classes</p>
</td></tr>
<tr><td><code>cvar</code></td>
<td>
<p>a data frame with the within variances of the columns of the factorial coordinates</p>
</td></tr>
<tr><td><code>cbw</code></td>
<td>
<p>a data frame with the marginal weighting of the column classes</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Chessel
Anne-Béatrice Dufour <a href="mailto:anne-beatrice.dufour@univ-lyon1.fr">anne-beatrice.dufour@univ-lyon1.fr</a>
Correction by Campo Elías PARDO <a href="mailto:cepardot@cable.net.co">cepardot@cable.net.co</a>
</p>


<h3>References</h3>

<p>Cazes, P., Chessel, D. and Dolédec, S. (1988) L'analyse des correspondances internes d'un tableau partitionné :
son usage en hydrobiologie. <em>Revue de Statistique Appliquée</em>, <b>36</b>, 39&ndash;54. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ardeche)
coa1 &lt;- dudi.coa(ardeche$tab, scann = FALSE, nf = 4)
ww &lt;- witwit.coa(coa1, ardeche$row.blocks, ardeche$col.blocks, scann = FALSE)
ww
summary(ww)

if(adegraphicsLoaded()) {
  g1 &lt;- s.class(ww$co, ardeche$sta.fac, plab.cex = 1.5, ellipseSi = 0, paxes.draw = FALSE, 
    plot = FALSE)
  g2 &lt;- s.label(ww$co, plab.cex = 0.75, plot = FALSE)
  G &lt;- superpose(g1, g2, plot = TRUE)
  
} else {
  s.class(ww$co, ardeche$sta.fac, clab = 1.5, cell = 0, axesell = FALSE)
  s.label(ww$co, add.p = TRUE, clab = 0.75)
}

witwitsepan(ww, c(4, 6))
</code></pre>

<hr>
<h2 id='woangers'>Plant assemblages in woodlands of the conurbation of Angers (France)</h2><span id='topic+woangers'></span>

<h3>Description</h3>

<p>This data set gives the presence of plant species in relevés of woodlands in the conurbation of Angers; and their biological traits. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(woangers)</code></pre>


<h3>Format</h3>

<p><code>woangers</code> is a list of 2 components.
</p>

<ol>
<li><p> flo: is a data frame that contains the presence/absence of species in each sample site. In the
codes for the sample sites (first column of the data frame), the first three letters provide the
code of the woodland and the numbers represent the 5 quadrats sampled in each site.
Codes for the woodlands are based on either their local name when they have one or on
the name of the nearest locality.
</p>
</li>
<li><p> traits: is a data frame that contains the values of the 13 functional traits considered in the paper.
One trait can be encoded by several columns.
The codes are as follows:
</p>

<ul>
<li><p> Column 1: Species names;
</p>
</li>
<li><p> Column 2: <code>li</code>, nominal variable that indicates the presence (y) or absence (n) of
ligneous structures;
</p>
</li>
<li><p> Column 3: <code>pr</code>, nominal variable that indicates the presence (y) or absence (n) of
prickly structures;
</p>
</li>
<li><p> Column 4: <code>fo</code>, circular variable that indicates the month when the flowering period
starts (from 1 January to 9 September);
</p>
</li>
<li><p> Column 5: <code>he</code>, ordinal variable that indicates the maximum height of the leaf
canopy;
</p>
</li>
<li><p> Column 6: <code>ae</code>, ordinal variable that indicates the degree of aerial vegetative
multiplication;
</p>
</li>
<li><p> Column 7: <code>un</code>, ordinal variable that indicates the degree of underground vegetative
multiplication;
</p>
</li>
<li><p> Column 8: <code>lp</code>, nominal variable that represents the leaf position by 3 levels (<code>ros</code> =
rosette, <code>semiros</code> = semi-rosette and <code>leafy</code> = leafy stem);
</p>
</li>
<li><p> Column 9: <code>le</code>, nominal variable that represents the mode of leaf persistence by 5
levels (<code>seasaes</code> = seasonal aestival, <code>seashib</code> = seasonal hibernal, <code>seasver</code> =
seasonal vernal, <code>everalw</code> = always evergreen, <code>everparti</code> = partially evergreen);
</p>
</li>
<li><p> Columns 10, 11 and 12: fuzzy variable that describes the modes of pollination with 3
levels (<code>auto</code> = autopollination, <code>insects</code> = pollination by insects, <code>wind</code> =
pollination by wind); this fuzzy variable is expressed as proportions, i.e. for each
row, the sum of the three columns equals 1;
</p>
</li>
<li><p> Columns 13, 14 and 15: fuzzy variable that describes the life cycle with 3 levels
(annual, monocarpic and polycarpic); this fuzzy variable is expressed as
proportions, i.e. for each row, the sum of the three column equals 1;
</p>
</li>
<li><p> Columns 16 to 20: fuzzy variable that describes the modes of dispersion with 5 levels
(<code>elaio</code> = dispersion by ants, <code>endozoo</code> = injection by animals, <code>epizoo</code> =
external transport by animals, <code>wind</code> = transport by wind, <code>unsp</code> = unspecialized
transport); this fuzzy variable is expressed as proportions, i.e. for each row, the
sum of the three columns equals 1;
</p>
</li>
<li><p> Column 21: <code>lo</code>, quantitative variable that provides the seed bank longevity index;
</p>
</li>
<li><p> Column 22: <code>lf</code>, quantitative variable that provides the length of the flowering
period.
</p>
</li></ul>

</li></ol>



<h3>Source</h3>

<p>Pavoine, S., Vallet, J., Dufour, A.-B., Gachet, S. and Daniel, H. (2009) 
On the challenge of treating various types of variables: 
Application for improving the measurement of functional diversity. <em>Oikos</em>, <b>118</b>, 391&ndash;402.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading the data
data(woangers)

# Preparating of the traits
traits &lt;- woangers$traits
# Nominal variables 'li', 'pr', 'lp' and 'le'
# (see table 1 in the main text for the codes of the variables)
tabN &lt;- traits[, c(1:2, 7, 8)]
# Circular variable 'fo'
tabC &lt;- traits[3]
tabCp &lt;- prep.circular(tabC, 1, 12)
# The levels of the variable lie between 1 (January) and 12 (December).
# Ordinal variables 'he', 'ae' and 'un'
tabO &lt;- traits[, 4:6]
# Fuzzy variables 'mp', 'pe' and 'di'
tabF &lt;- traits[, 9:19]
tabFp &lt;- prep.fuzzy(tabF, c(3, 3, 5), labels = c("mp", "pe", "di"))
# 'mp' has 3 levels, 'pe' has 3 levels and 'di' has 5 levels.
# Quantitative variables 'lo' and 'lf'
tabQ &lt;- traits[, 20:21]

# Combining the traits
ktab1 &lt;- ktab.list.df(list(tabN, tabCp, tabO, tabFp, tabQ))
## Not run: 
# Calculating the distances for all traits combined
distrait &lt;- dist.ktab(ktab1, c("N", "C", "O", "F", "Q"))
is.euclid(distrait)

# Calculating the contribution of each trait in the combined distances
contrib &lt;- kdist.cor(ktab1, type = c("N", "C", "O", "F", "Q"))
contrib
dotchart(sort(contrib$glocor), labels = rownames(contrib$glocor)[order(contrib$glocor[, 1])])

## End(Not run)
</code></pre>

<hr>
<h2 id='worksurv'>French Worker Survey (1970)</h2><span id='topic+worksurv'></span>

<h3>Description</h3>

<p>The <code>worksurv</code> data frame gives 319 response items and 4 questions 
providing from a French Worker Survey. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(worksurv)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<ol>
<li><p> pro: Professional elections. In professional elections in your firm, would you rather vote for a list supported by?
</p>

<ul>
<li> <p><code>CGT</code>
</p>
</li>
<li> <p><code>CFDT</code>
</p>
</li>
<li> <p><code>FO</code>
</p>
</li>
<li> <p><code>CFTC</code>
</p>
</li>
<li> <p><code>Auton</code> Autonomous
</p>
</li>
<li> <p><code>Abst</code>
</p>
</li>
<li> <p><code>Nonaffi</code> Not affiliated
</p>
</li>
<li> <p><code>NR</code> No response</p>
</li></ul>

</li>
<li><p> una: Union affiliation. At the present time, are you affiliated to a Union, and in the affirmative, which one?
</p>

<ul>
<li> <p><code>CGT</code>
</p>
</li>
<li> <p><code>CFDT</code>
</p>
</li>
<li> <p><code>FO</code>
</p>
</li>
<li> <p><code>CFTC</code>
</p>
</li>
<li> <p><code>Auton</code> Autonomous
</p>
</li>
<li> <p><code>CGC</code>
</p>
</li>
<li> <p><code>Notaffi</code> Not affiliated
</p>
</li>
<li> <p><code>NR</code> No response</p>
</li></ul>

</li>
<li><p> pre: Presidential election. On the last presidential election
(1969), can you tell me the candidate for whom you havevoted?
</p>

<ul>
<li> <p><code>Duclos</code>
</p>
</li>
<li> <p><code>Deferre</code>
</p>
</li>
<li> <p><code>Krivine</code>
</p>
</li>
<li> <p><code>Rocard</code>
</p>
</li>
<li> <p><code>Poher</code>
</p>
</li>
<li> <p><code>Ducatel</code>
</p>
</li>
<li> <p><code>Pompidou</code>
</p>
</li>
<li> <p><code>NRAbs</code> No response, abstention</p>
</li></ul>

</li>
<li><p> pol: political sympathy. Which political party do you feel closest to, as a rule?
</p>

<ul>
<li> <p><code>Communist</code> (PCF)
</p>
</li>
<li> <p><code>Socialist</code> (SFIO+PSU+FGDS)
</p>
</li>
<li> <p><code>Left</code> (Party of workers,...)
</p>
</li>
<li> <p><code>Center</code> MRP+RAD.
</p>
</li>
<li> <p><code>RI</code>
</p>
</li>
<li> <p><code>Right</code> INDEP.+CNI
</p>
</li>
<li> <p><code>Gaullist</code> UNR
</p>
</li>
<li> <p><code>NR</code> No response</p>
</li></ul>

</li></ol>



<h3>Details</h3>

<p>The data frame <code>worksurv</code> has the attribute 'counts' giving the number of responses for each item.
</p>


<h3>Source</h3>

<p>Rouanet, H. and Le Roux, B. (1993) 
<em>Analyse des données multidimensionnelles</em>. Dunod, Paris.
</p>


<h3>References</h3>

<p>Le Roux, B. and Rouanet, H.  (1997) 
Interpreting axes in multiple correspondence analysis: method of the contributions of points and deviation. 
Pages 197-220 in B. J. and M. Greenacre, editors. 
<em>Visualization of categorical data</em>, Acamedic Press, London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(worksurv)
acm1 &lt;- dudi.acm(worksurv, row.w = attr(worksurv, "counts"), scan = FALSE)

if(adegraphicsLoaded()) {
  s.class(acm1$li, worksurv)
} else {
  par(mfrow = c(2, 2))
  apply(worksurv, 2, function(x) s.class(acm1$li, factor(x), attr(worksurv, 'counts')))
  par(mfrow = c(1, 1))
}
</code></pre>

<hr>
<h2 id='yanomama'>Distance Matrices</h2><span id='topic+yanomama'></span>

<h3>Description</h3>

<p>This data set gives 3 matrices about geographical, genetic and anthropometric distances. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(yanomama)</code></pre>


<h3>Format</h3>

<p><code>yanomama</code> is a list of 3 components:
</p>

<dl>
<dt>geo</dt><dd><p>is a matrix of 19-19 geographical distances</p>
</dd>
<dt>gen</dt><dd><p>is a matrix of 19-19 SFA (genetic) distances</p>
</dd>
<dt>ant</dt><dd><p>is a matrix of 19-19 anthropometric distances</p>
</dd>
</dl>



<h3>Source</h3>

<p>Spielman, R.S. (1973) 
Differences among Yanomama Indian villages: do the patterns of allele frequencies, anthropometrics and map locations correspond? 
<em>American Journal of Physical Anthropology</em>, <b>39</b>, 461&ndash;480.
</p>


<h3>References</h3>

<p>Table 7.2 Distance matrices for 19 villages of Yanomama Indians. 
All distances are as given by Spielman (1973), multiplied by 100 for convenience in: 
Manly, B.F.J. (1991) 
<em>Randomization and Monte Carlo methods in biology</em> 
Chapman and Hall, London, 1&ndash;281.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(yanomama)
    gen &lt;- quasieuclid(as.dist(yanomama$gen)) # depends of mva
    ant &lt;- quasieuclid(as.dist(yanomama$ant)) # depends of mva
    par(mfrow = c(2,2))
    plot(gen, ant)
    t1 &lt;- mantel.randtest(gen, ant, 99);
    plot(t1, main = "gen-ant-mantel") ; print(t1)
    t1 &lt;- procuste.rtest(pcoscaled(gen), pcoscaled(ant), 99)
    plot(t1, main = "gen-ant-procuste") ; print(t1)
    t1 &lt;- RV.rtest(pcoscaled(gen), pcoscaled(ant), 99)
    plot(t1, main = "gen-ant-RV") ; print(t1)
</code></pre>

<hr>
<h2 id='zealand'>Road distances in New-Zealand</h2><span id='topic+zealand'></span>

<h3>Description</h3>

<p>This data set gives the road distances between 13 towns in New-Zealand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(zealand)</code></pre>


<h3>Format</h3>

<p><code>zealand</code> is a list with the following components:
</p>

<dl>
<dt>road</dt><dd><p>a data frame with 13 rows (New Zealand towns) and 13 columns 
(New Zealand towns) containing the road distances between these towns</p>
</dd>
<dt>xy</dt><dd><p>a data frame containing the coordinates of the 13 towns</p>
</dd>
<dt>neig</dt><dd><p>an object of class <code>neig</code>, a neighbour graph to visualize
the map shape</p>
</dd>
<dt>nb</dt><dd><p>a neighborhood object (class <code>nb</code> defined in package 
<code>spdep</code>)</p>
</dd>
</dl>


<h3>Source</h3>

<p>Manly, B.F. (1994). <em>Multivariate Statistical Methods. A primer.</em>, Second 
edition, Chapman and Hall, London, 1&ndash;215, page 172.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(zealand)
d0 &lt;- as.dist(as.matrix(zealand$road))
d1 &lt;- cailliez (d0)
d2 &lt;- lingoes(d0)

if(adegraphicsLoaded()) {
  G1 &lt;- s.label(zealand$xy, lab = as.character(1:13), nb = zealand$nb)
  
  g1 &lt;- s.label(cmdscale(dist(zealand$xy)), lab = as.character(1:13), nb = zealand$nb, 
    psub.text = "Distance canonique", plot = FALSE)
  g2 &lt;- s.label(cmdscale(d0), lab = as.character(1:13), nb = zealand$nb, 
    psub.text = "Distance routiere", plot = FALSE)
  g3 &lt;- s.label(cmdscale(d1), lab = as.character(1:13), nb = zealand$nb, 
    psub.text = "Distance routiere / Cailliez", plot = FALSE)
  g4 &lt;- s.label(cmdscale(d2), lab = as.character(1:13), nb = zealand$nb, 
    psub.text = "Distance routiere / Lingoes", plot = FALSE)
  G2 &lt;- ADEgS(list(g1, g2, g3, g4), layout = c(2, 2))

} else {
  s.label(zealand$xy, lab = as.character(1:13), neig = zealand$neig)
  par(mfrow = c(2, 2))
  s.label(cmdscale(dist(zealand$xy)), lab = as.character(1:13), 
    neig = zealand$neig, sub = "Distance canonique", csub = 2)
  s.label(cmdscale(d0), lab = as.character(1:13), neig = zealand$neig, 
    sub = "Distance routiere", csub = 2)
  s.label(cmdscale(d1), lab = as.character(1:13), neig = zealand$neig, 
    sub = "Distance routiere / Cailliez", csub = 2)
  s.label(cmdscale(d2), lab = as.character(1:13), neig = zealand$neig, 
    sub = "Distance routiere / Lingoes", csub = 2)
}</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
