<!DOCTYPE html><html lang="en"><head><title>Help for package clusterGeneration</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clusterGeneration}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#genOrthogonal'>
<p>Generate An Orthogonal Matrix</p></a></li>
<li><a href='#genPositiveDefMat'><p>GENERATE A POSITIVE DEFINITE MATRIX/COVARIANCE MATRIX</p></a></li>
<li><a href='#genRandomClust'><p>RANDOM CLUSTER GENERATION WITH SPECIFIED DEGREE OF SEPARATION</p></a></li>
<li><a href='#getSepProj'><p>OPTIMAL PROJECTION DIRECTION AND CORRESPONDING SEPARATION INDEX FOR PAIRS OF CLUSTERS</p></a></li>
<li><a href='#nearestNeighborSepVal'><p>SEPARATON INFORMATION MATRIX</p></a></li>
<li><a href='#plot1DProjection'><p>PLOT A PAIR OF CLUSTERS AND THEIR DENSITY ESTIMATES, WHICH ARE PROJECTED  ALONG A SPECIFIED 1-D PROJECTION DIRECTION</p></a></li>
<li><a href='#plot2DProjection'><p>PLOT A PAIR OF CLUSTERS ALONG A 2-D PROJECTION SPACE</p></a></li>
<li><a href='#rcorrmatrix'><p>GENERATE A RANDOM CORRELATION MATRIX BASED ON RANDOM PARTIAL CORRELATIONS</p></a></li>
<li><a href='#sepIndex'><p>MEASURE THE MAGNITUDE OF THE GAP OR SPARSE AREA BETWEEN A PAIR OF CLUSTERS ALONG THE SPECIFIED PROJECTION DIRECTION</p></a></li>
<li><a href='#simClustDesign'><p>DESIGN FOR RANDOM CLUSTER GENERATION WITH SPECIFIED DEGREE OF SEPARATION</p></a></li>
<li><a href='#viewClusters'><p>PLOT ALL CLUSTERS IN A 2-D PROJECTION SPACE</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.3.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-15</td>
</tr>
<tr>
<td>Title:</td>
<td>Random Cluster Generation (with Specified Degree of Separation)</td>
</tr>
<tr>
<td>Author:</td>
<td>Weiliang Qiu &lt;weiliang.qiu@gmail.com&gt;, Harry Joe
        &lt;harry@stat.ubc.ca&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Weiliang Qiu &lt;weiliang.qiu@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), MASS</td>
</tr>
<tr>
<td>Description:</td>
<td>We developed the clusterGeneration package to provide functions 
        for generating random clusters, generating random 
        covariance/correlation matrices,
        calculating a separation index (data and population version)
        for pairs of clusters or cluster distributions, and 1-D and 2-D
        projection plots to visualize clusters.  The package also
        contains a function to generate random clusters based on
        factorial designs with factors such as degree of separation,
        number of clusters, number of variables, number of noisy
        variables.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-16 02:01:35 UTC; weiliangqiu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-16 04:20:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='genOrthogonal'>
Generate An Orthogonal Matrix
</h2><span id='topic+genOrthogonal'></span>

<h3>Description</h3>

<p>Generate an orthogonal matrix with given dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genOrthogonal(dim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genOrthogonal_+3A_dim">dim</code></td>
<td>

<p>integer. Dimension of the orthogonal matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An orthogonal matrix with dimension <code>dim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
Q = genOrthogonal(3)
print(Q)
A = Q 
print(A)

</code></pre>

<hr>
<h2 id='genPositiveDefMat'>GENERATE A POSITIVE DEFINITE MATRIX/COVARIANCE MATRIX</h2><span id='topic+genPositiveDefMat'></span>

<h3>Description</h3>

<p>Generate a positive definite matrix/covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genPositiveDefMat(
  dim, 
  covMethod = c("eigen", "onion", "c-vine", "unifcorrmat"), 
  eigenvalue = NULL,
  alphad = 1, 
  eta = 1, 
  rangeVar = c(1, 10), 
  lambdaLow = 1, 
  ratioLambda = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genPositiveDefMat_+3A_dim">dim</code></td>
<td>

<p>Dimension of the matrix to be generated.
</p>
</td></tr>
<tr><td><code id="genPositiveDefMat_+3A_covmethod">covMethod</code></td>
<td>

<p>Method to generate positive definite matrices/covariance matrices.
Choices are &ldquo;eigen&rdquo;, &ldquo;onion&rdquo;, &ldquo;c-vine&rdquo;, or &ldquo;unifcorrmat&rdquo;; see details below. 
</p>
</td></tr>
<tr><td><code id="genPositiveDefMat_+3A_eigenvalue">eigenvalue</code></td>
<td>

<p>numeric. user-specified eigenvalues when <code>covMethod = "eigen"</code>. If <code>eigenvalue = NULL</code> and <code>covMethod = "eigen"</code>, then eigenvalues will be automatically generated.  
</p>
</td></tr>
<tr><td><code id="genPositiveDefMat_+3A_alphad">alphad</code></td>
<td>
<p>parameter for unifcorrmat method to generate random correlation matrix
<code>alphad=1</code> for uniform. <code>alphad</code> should be positive.</p>
</td></tr>
<tr><td><code id="genPositiveDefMat_+3A_eta">eta</code></td>
<td>
<p>parameter for &ldquo;c-vine&rdquo; and &ldquo;onion&rdquo; methods to generate random correlation matrix
<code>eta=1</code> for uniform. <code>eta</code> should be positive.</p>
</td></tr>
<tr><td><code id="genPositiveDefMat_+3A_rangevar">rangeVar</code></td>
<td>

<p>Range for variances of a covariance matrix (see details).
The default range is <code class="reqn">[1, 10]</code> which can generate reasonable
variability of variances.
</p>
</td></tr>
<tr><td><code id="genPositiveDefMat_+3A_lambdalow">lambdaLow</code></td>
<td>

<p>Lower bound on the eigenvalues of cluster covariance matrices. 
If the argument <code>covMethod="eigen"</code>, eigenvalues are generated for cluster covariance matrices.
The eigenvalues are randomly generated from the
interval [<code>lambdaLow</code>, <code>lambdaLow</code><code class="reqn">*</code><code>ratioLambda</code>]. 
In our experience, <code>lambdaLow</code><code class="reqn">=1</code> and <code>ratioLambda</code><code class="reqn">=10</code> 
can give reasonable variability of the diameters of clusters.
<code>lambdaLow</code> should be positive.
</p>
</td></tr>
<tr><td><code id="genPositiveDefMat_+3A_ratiolambda">ratioLambda</code></td>
<td>

<p>The ratio of the upper bound of the eigenvalues to the lower bound of the 
eigenvalues of cluster covariance matrices.  See <code>lambdaLow</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current version of the function <code>genPositiveDefMat</code> implements four 
methods to generate random covariance matrices. The first method, denoted by 
&ldquo;eigen&rdquo;, first randomly generates eigenvalues 
(<code class="reqn">\lambda_1,\ldots,\lambda_p</code>) for the covariance matrix 
(<code class="reqn">\boldsymbol{\Sigma}</code>), then
uses columns of a randomly generated orthogonal matrix 
(<code class="reqn">\boldsymbol{Q}=(\boldsymbol{\alpha}_1,\ldots,\boldsymbol{\alpha}_p)</code>) 
as eigenvectors. The covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code> is then 
contructed as 
<code class="reqn">\boldsymbol{Q}*diag(\lambda_1,\ldots,\lambda_p)*\boldsymbol{Q}^T</code>.
</p>
<p>The remaining methods, denoted as &ldquo;onion&rdquo;, &ldquo;c-vine&rdquo;, and &ldquo;unifcorrmat&rdquo;
respectively, first generates a random 
correlation matrix (<code class="reqn">\boldsymbol{R}</code>) via the method mentioned and proposed in Joe (2006),
then randomly generates variances (<code class="reqn">\sigma_1^2,\ldots,\sigma_p^2</code>) from 
an interval specified by the argument <code>rangeVar</code>. The covariance matrix 
<code class="reqn">\boldsymbol{\Sigma}</code> is then constructed as 
<code class="reqn">diag(\sigma_1,\ldots,\sigma_p)*\boldsymbol{R}*diag(\sigma_1,\ldots,\sigma_p)</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>egvalues</code></td>
<td>

<p>eigenvalues of Sigma
</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>

<p>positive definite matrix/covariance matrix
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Weiliang Qiu <a href="mailto:weiliang.qiu@gmail.com">weiliang.qiu@gmail.com</a><br />
Harry Joe <a href="mailto:harry@stat.ubc.ca">harry@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>Joe, H. (2006)
Generating Random Correlation Matrices Based on Partial Correlations. 
<em>Journal of Multivariate Analysis</em>, <b>97</b>, 2177&ndash;2189.
</p>
<p>Ghosh, S., Henderson, S. G. (2003). 
Behavior of the NORTA method for correlated random vector generation 
as the dimension increases.
<em>ACM Transactions on Modeling and Computer Simulation (TOMACS)</em>,
<b>13(3)</b>, 276&ndash;294.
</p>
<p>Kurowicka and Cooke, 2006.
<em>Uncertainty Analysis with High Dimensional Dependence Modelling</em>,
Wiley, 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genPositiveDefMat(
		  dim = 4, 
		  covMethod = "unifcorrmat")

aa &lt;- genPositiveDefMat(
			dim = 3,
			covMethod = "eigen", 
			eigenvalue = c(3, 2, 1))
print(aa)
print(eigen(aa$Sigma))

</code></pre>

<hr>
<h2 id='genRandomClust'>RANDOM CLUSTER GENERATION WITH SPECIFIED DEGREE OF SEPARATION</h2><span id='topic+genRandomClust'></span>

<h3>Description</h3>

<p>Generate cluster data sets with specified degree of separation. 
The separation between any cluster and its nearest neighboring cluster can be 
set to a specified value. The covariance matrices of clusters can have 
arbitrary diameters, shapes and orientations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genRandomClust(numClust, 
               sepVal = 0.01, 
               numNonNoisy = 2, 
               numNoisy = 0, 
               numOutlier = 0, 
               numReplicate = 3, 
               fileName = "test",  
               clustszind = 2, 
               clustSizeEq = 50, 
               rangeN = c(50,200), 
               clustSizes = NULL, 
               covMethod = c("eigen", "onion", "c-vine", "unifcorrmat"), 
	       eigenvalue = NULL,
               rangeVar = c(1, 10), 
               lambdaLow = 1, 
               ratioLambda = 10,  
               alphad = 1,
               eta = 1,
               rotateind = TRUE, 
               iniProjDirMethod = c("SL", "naive"), 
               projDirMethod = c("newton", "fixedpoint"), 
               alpha = 0.05, 
               ITMAX = 20, 
               eps = 1.0e-10, 
               quiet = TRUE, 
               outputDatFlag = TRUE, 
               outputLogFlag = TRUE, 
               outputEmpirical = TRUE, 
               outputInfo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genRandomClust_+3A_numclust">numClust</code></td>
<td>

<p>Number of clusters in a data set.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_sepval">sepVal</code></td>
<td>

<p>Desired value of the separation index between a cluster
and its nearest neighboring cluster. Theoretically, <code>sepVal</code> can take 
values within the interval <code class="reqn">[-1, 1)</code> 
(In practice, we set <code>sepVal</code> in <code class="reqn">(-0.999, 0.999)</code>). 
The closer to <code class="reqn">1</code> <code>sepVal</code> is, the more separated clusters are.
The default value is <code class="reqn">0.01</code> which is the value of the separation index for
two univariate clusters generated from <code class="reqn">N(0, 1)</code> and <code class="reqn">N(0, A)</code>,
respectively,  where <code class="reqn">A=4</code>. 
<code>sepVal</code><code class="reqn">=0.01</code> indicates a close cluster structure. 
<code>sepVal</code><code class="reqn">=0.21 (A=6)</code> indicates a separated cluster structure. 
<code>sepVal</code><code class="reqn">=0.34 (A=8)</code> indicates a well-separated cluster.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_numnonnoisy">numNonNoisy</code></td>
<td>

<p>Number of non-noisy variables.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_numnoisy">numNoisy</code></td>
<td>

<p>Number of noisy variables.
The default values of <code>numNoisy</code> and <code>numOutlier</code> are <code class="reqn">0</code> so 
that we get <dfn>clean</dfn> data sets. 
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_numoutlier">numOutlier</code></td>
<td>

<p>Number or ratio of outliers. If <code>numOutlier</code> is a positive integer, 
then <code>numOutlier</code> means the number of outliers. 
If <code>numOutlier</code> is a real number between <code class="reqn">(0, 1)</code>, then 
<code>numOutlier</code> means the ratio of outliers, i.e. the number of outliers 
is equal to <code>round</code>(<code>numOutlier</code><code class="reqn">*n_1</code>), where <code class="reqn">n_1</code> is 
the total number of non-outliers.  If <code>numOutlier</code> is a real number 
greater than <code class="reqn">1</code>, then <code>numOutlier</code> to rounded to an integer.
The default values of <code>numNoisy</code> and <code>numOutlier</code> are 
<code class="reqn">0</code> so that we get &lsquo;clean&rsquo; data sets. 
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_numreplicate">numReplicate</code></td>
<td>

<p>Number of data sets to be generated for the same cluster structure specified 
by the other arguments of the function <code>genRandomClust</code>.
The default value <code class="reqn">3</code> follows the design in Milligan (1985).
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_filename">fileName</code></td>
<td>

<p>The first part of the names of data files that record the generated data sets 
and associated information, such as cluster membership of data points, labels 
of noisy variables, separation index matrix, projection directions, etc. 
(see details). The default value of <code>fileName</code> is &lsquo;<span class="file">test</span>&rsquo;.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_clustszind">clustszind</code></td>
<td>

<p>Cluster size indicator.
<code>clustszind</code><code class="reqn">=1</code> indicates that all cluster have equal size. 
The size is specified by the argument <code>clustSizeEq</code>.
<code>clustszind</code><code class="reqn">=2</code> indicates that the cluster sizes are randomly 
generated from the range specified by the argument <code>rangeN</code>.
<code>clustszind</code><code class="reqn">=3</code> indicates that the cluster sizes are specified
via the vector <code>clustSizes</code>.
The default value is <code class="reqn">2</code> so that the generated clusters are more
realistic.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_clustsizeeq">clustSizeEq</code></td>
<td>

<p>Cluster size.
If the argument <code>clustszind</code><code class="reqn">=1</code>, then all clusters will have the 
equal number <code>clustSizeEq</code> of data points. The value of <code>clustSizeEq</code> 
should be large enough to get non-singular cluster covariance matrices. 
We recommend the <code>clustSizeEq</code> is at least <code class="reqn">10*p</code>, where <code class="reqn">p</code> 
is the total number of variables (including both non-noisy and noisy variables).
The default value <code class="reqn">100</code> is a reasonable cluster size.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_rangen">rangeN</code></td>
<td>

<p>The range of cluster sizes.
If <code>clustszind</code><code class="reqn">=2</code>, then cluster sizes will be randomly generated 
from the range specified by <code>rangeN</code>. The lower bound of the number of 
clusters should be large enough to get non-singular cluster covariance 
matrices. We recommend the minimum cluster size is at least <code class="reqn">10*p</code>, where 
<code class="reqn">p</code> is the total number of variables (including both non-noisy and noisy 
variables).  The default range is <code class="reqn">[50, 200]</code> which
can produce reasonable variability of cluster sizes.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_clustsizes">clustSizes</code></td>
<td>

<p>The sizes of clusters.
If <code>clustszind</code><code class="reqn">=3</code>, then cluster sizes will be specified via the 
vector <code>clustSizes</code>.  We recommend the minimum cluster size is at least 
<code class="reqn">10*p</code>, where <code class="reqn">p</code> is the total number of variables (including both 
non-noisy and noisy variables).
The user needs to specify the value of <code>clustSizes</code>. Therefore, we
set the default value of <code>clustSizes</code> as <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_covmethod">covMethod</code></td>
<td>

<p>Method to generate covariance matrices for clusters (see details).
The default method is 'eigen' so that the user can directly 
specify the range of the <dfn>diameters</dfn> of clusters.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_eigenvalue">eigenvalue</code></td>
<td>

<p>numeric. user-specified eigenvalues when <code>covMethod = "eigen"</code>. If <code>eigenvalue = NULL</code> and <code>covMethod = "eigen"</code>, then eigenvalues will be automatically generated.  
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_rangevar">rangeVar</code></td>
<td>

<p>Range for variances of a covariance matrix (see details).
The default range is <code class="reqn">[1, 10]</code> which can generate reasonable
variability of variances.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_lambdalow">lambdaLow</code></td>
<td>

<p>Lower bound of the eigenvalues of cluster covariance matrices. 
If the argument &ldquo;covMethod=&quot;eigen&quot;&rdquo;, we need to generate eigenvalues for cluster covariance matrices.
The eigenvalues are randomly generated from the
interval [<code>lambdaLow</code>, <code>lambdaLow</code><code class="reqn">*</code><code>ratioLambda</code>]. 
In our experience, <code>lambdaLow</code><code class="reqn">=1</code> and <code>ratioLambda</code><code class="reqn">=10</code> 
can give reasonable variability of the diameters of clusters.
<code>lambdaLow</code> should be positive.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_ratiolambda">ratioLambda</code></td>
<td>

<p>The ratio of the upper bound of the eigenvalues to the lower bound of the 
eigenvalues of cluster covariance matrices. 
If the argument <code>covMethod="eigen"</code>, we need to generate eigenvalues for
cluster covariance matrices.
The eigenvalues are randomly generated from the
interval [<code>lambdaLow</code>, <code>lambdaLow</code><code class="reqn">*</code><code>ratioLambda</code>]. 
In our experience, <code>lambdaLow</code><code class="reqn">=1</code> and <code>ratioLambda</code><code class="reqn">=10</code> 
can give reasonable variability of the diameters of clusters.
<code>ratioLambda</code> should be larger than <code class="reqn">1</code>.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_alphad">alphad</code></td>
<td>
<p>parameter for unifcorrmat method to generate random correlation matrix
<code>alphad=1</code> for uniform. <code>alphad</code> should be positive.</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_eta">eta</code></td>
<td>
<p>parameter for &ldquo;c-vine&rdquo; and &ldquo;onion&rdquo; methods to generate random correlation matrix
<code>eta=1</code> for uniform. <code>eta</code> should be positive.</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_rotateind">rotateind</code></td>
<td>

<p>Rotation indicator.
<code>rotateind=TRUE</code> indicates randomly rotating data in non-noisy 
dimensions so that we may not detect the full cluster structure from 
pair-wise scatter plots of the variables.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_iniprojdirmethod">iniProjDirMethod</code></td>
<td>

<p>Indicating the method to get initial projection direction when calculating
the separation index between a pair of clusters (c.f. Qiu and Joe,
2006a, 2006b). <br />
<code>iniProjDirMethod</code>=&ldquo;SL&rdquo;, the default, indicates the initial 
projection direction is the sample version of the SL's projection direction 
(Su and Liu, 1993, JASA)
<code class="reqn">\left(\boldsymbol{\Sigma}_1+\boldsymbol{\Sigma}_2\right)^{-1}\left(\boldsymbol{\mu}_2-\boldsymbol{\mu}_1\right)</code><br />
<code>iniProjDirMethod</code>=&ldquo;naive&rdquo; indicates the initial projection 
direction is <code class="reqn">\boldsymbol{\mu}_2-\boldsymbol{\mu}_1</code>
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_projdirmethod">projDirMethod</code></td>
<td>

<p>Indicating the method to get the optimal projection direction when calculating 
the separation index between a pair of clusters (c.f. Qiu and Joe,
2006a, 2006b). <br />
<code>projDirMethod</code>=&ldquo;newton&rdquo; indicates we use the modified
Newton-Raphson method to search the optimal projection direction 
(c.f. Qiu and Joe, 2006a). This requires the assumptions that both covariance 
matrices of the pair of clusters are positive-definite. If this assumption 
is violated, the &ldquo;fixedpoint&rdquo; method could be used. The 
&ldquo;fixedpoint&rdquo; method iteratively searches the optimal projection 
direction based on the first derivative of the separation index to the 
projection direction (c.f. Qiu and Joe, 2006b).
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_alpha">alpha</code></td>
<td>

<p>Tuning parameter reflecting the percentage in the two
tails of a projected cluster that might be outlying.
We set <code>alpha</code><code class="reqn">=0.05</code> like we set
the significance level in hypothesis testing as <code class="reqn">0.05</code>.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_itmax">ITMAX</code></td>
<td>

<p>Maximum iteration allowed when iteratively calculating the
optimal projection direction.
The actual number of iterations is usually much less than the default value 20.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_eps">eps</code></td>
<td>

<p>Convergence threshold. A small positive number to check if a quantitiy <code class="reqn">q</code> 
is equal to zero.  If <code class="reqn">|q|&lt;</code><code>eps</code>, then we regard <code class="reqn">q</code> is equal 
to zero.  <code>eps</code> is used to check if an algorithm converges.
The default value is <code class="reqn">1.0e-10</code>.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_quiet">quiet</code></td>
<td>

<p>A flag to switch on/off the outputs of intermediate results and/or possible warning messages. The default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_outputdatflag">outputDatFlag</code></td>
<td>

<p>Indicates if data set should be output to file.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_outputlogflag">outputLogFlag</code></td>
<td>

<p>Indicates if log info should be output to file.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_outputempirical">outputEmpirical</code></td>
<td>

<p>Indicates if empirical separation indices and projection directions should be 
calculated. This option is useful when generating clusters with sizes which 
are not large enough so that the sample covariance matrices may be singular.
Hence, by default, <code>outputEmpirical=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="genRandomClust_+3A_outputinfo">outputInfo</code></td>
<td>

<p>Indicates if theoretical and empirical separation information data frames 
should be output to a file with format <code>[fileName]_info.log</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>genRandomClust</code> is an implementation of the random cluster 
generation method proposed in Qiu and Joe (2006a) which improve the cluster 
generation method proposed in Milligan (1985) so that the degree of separation 
between any cluster and its nearest neighboring cluster could be set to a 
specified value while the cluster covariance matrices can be arbitrary positive definite matrices, and so that clusters generated might not be visualized 
by pair-wise scatterplots of variables. The separation between a pair of 
clusters is measured by the separation index proposed in Qiu and Joe (2006b).
</p>
<p>The current version of the function <code>genRandomClust</code> implements two 
methods to generate covariance matrices for clusters. The first method, 
denoted by <code>eigen</code>, first randomly generates eigenvalues 
(<code class="reqn">\lambda_1,\ldots&gt;\lambda_p</code>) for the covariance matrix 
(<code class="reqn">\boldsymbol{\Sigma}</code>), then uses columns of a randomly generated 
orthogonal matrix 
(<code class="reqn">\boldsymbol{Q}=(\boldsymbol{\alpha}_1,\ldots,\boldsymbol{\alpha}_p)</code>) 
as eigenvectors. The covariance matrix 
<code class="reqn">\boldsymbol{\Sigma}</code> is then contructed as 
<code class="reqn">\boldsymbol{Q}*diag(\lambda_1,\dots, \lambda_p)*\boldsymbol{Q}^T</code>.
The second method, denoted as &ldquo;unifcorrmax&rdquo;, first generates a random 
correlation matrix (<code class="reqn">\boldsymbol{R}</code>) via the method proposed in Joe (2006),
then randomly generates variances (<code class="reqn">\sigma_1^2,\ldots, \sigma_p^2</code>) from 
an interval specified by the argument <code>rangeVar</code>. The covariance matrix 
<code class="reqn">\boldsymbol{\Sigma}</code> is then constructed as 
<code class="reqn">diag(\sigma_1,\ldots,\sigma_p)*\boldsymbol{R}*diag(\sigma_1,\ldots,\sigma_p)</code>.
</p>
<p>For each data set generated, the function <code>genRandomClust</code> outputs
four files: data file, log file, membership file, and noisy set file. 
All four files have the same format: <code>[fileName]_[i].[extension]</code>, 
where <code class="reqn">i</code> indicates the replicate number, and &lsquo;<span class="file">extension</span>&rsquo; can be 
&lsquo;<span class="file">dat</span>&rsquo;, &lsquo;<span class="file">log</span>&rsquo;, &lsquo;<span class="file">mem</span>&rsquo;, and &lsquo;<span class="file">noisy</span>&rsquo;. 
</p>
<p>The data file with file extension &lsquo;<span class="file">dat</span>&rsquo; contains <code class="reqn">n+1</code> rows and 
<code class="reqn">p</code> columns, where <code class="reqn">n</code> is the number of data points and <code class="reqn">p</code> 
is the number of variables. The first row is the variable names. 
The log file with file extension &lsquo;<span class="file">log</span>&rsquo; contains information such 
as cluster sizes, mean vectors, covariance matrices, projection directions, 
separation index matrices, etc. The membership file with file extension 
&lsquo;<span class="file">mem</span>&rsquo; contains <code class="reqn">n</code> rows and one column of cluster memberships for 
data points. The noisy set file with file extension &lsquo;<span class="file">noisy</span>&rsquo; contains 
a row of labels of noisy variables.
</p>
<p>When generating clusters, population covariance matrices are all 
positive-definite. However sample covariance matrices might be 
semi-positive-definite due to small cluster sizes. In this case, the 
function <code>genRandomClust</code> will automatically use the 
&ldquo;fixedpoint&rdquo; method to search the optimal projection direction.
</p>
<p>The current version of the function <code>genPositiveDefMat</code> implements four 
methods to generate random covariance matrices. The first method, denoted by 
&ldquo;eigen&rdquo;, first randomly generates eigenvalues 
(<code class="reqn">\lambda_1,\ldots,\lambda_p</code>) for the covariance matrix 
(<code class="reqn">\boldsymbol{\Sigma}</code>), then
uses columns of a randomly generated orthogonal matrix 
(<code class="reqn">\boldsymbol{Q}=(\boldsymbol{\alpha}_1,\ldots,\boldsymbol{\alpha}_p)</code>) 
as eigenvectors. The covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code> is then 
contructed as 
<code class="reqn">\boldsymbol{Q}*diag(\lambda_1,\ldots,\lambda_p)*\boldsymbol{Q}^T</code>.
</p>
<p>The remaining methods, denoted as &ldquo;onion&rdquo;, &ldquo;c-vine&rdquo;, and &ldquo;unifcorrmat&rdquo;
respectively, first generates a random 
correlation matrix (<code class="reqn">\boldsymbol{R}</code>) via the method mentioned and proposed in Joe (2006),
then randomly generates variances (<code class="reqn">\sigma_1^2,\ldots,\sigma_p^2</code>) from 
an interval specified by the argument <code>rangeVar</code>. The covariance matrix 
<code class="reqn">\boldsymbol{\Sigma}</code> is then constructed as 
<code class="reqn">diag(\sigma_1,\ldots,\sigma_p)*\boldsymbol{R}*diag(\sigma_1,\ldots,\sigma_p)</code>.
</p>


<h3>Value</h3>

<p>The function outputs four data files for each data set (see details).
</p>
<p>This function also returns separation information data frames 
<code>infoFrameTheory</code> and <code>infoFrameData</code> based on population 
and empirical mean vectors and covariance matrices of clusters for all 
the data sets generated. Both <code>infoFrameTheory</code> and <code>infoFrameData</code> 
contain the following seven columns:
</p>
<table role = "presentation">
<tr><td><code>Column 1:</code></td>
<td>

<p>Labels of clusters (<code class="reqn">1, 2, \ldots, numClust</code>), where <code class="reqn">numClust</code> 
is the number of clusters for the data set.
</p>
</td></tr>
<tr><td><code>Column 2:</code></td>
<td>

<p>Labels of the corresponding nearest neighbors.
</p>
</td></tr>
<tr><td><code>Column 3:</code></td>
<td>

<p>Separation indices of the clusters to their nearest neighboring clusters.
</p>
</td></tr>
<tr><td><code>Column 4:</code></td>
<td>

<p>Labels of the corresponding farthest neighboring clusters.
</p>
</td></tr>
<tr><td><code>Column 5:</code></td>
<td>

<p>Separation indices of the clusters to their farthest neighbors.
</p>
</td></tr>
<tr><td><code>Column 6:</code></td>
<td>

<p>Median separation indices of the clusters to their neighbors.
</p>
</td></tr>
<tr><td><code>Column 7:</code></td>
<td>

<p>Data file names with format <code>[fileName]_[i]</code>, where <code class="reqn">i</code> indicates 
the replicate number.
</p>
</td></tr>
</table>
<p>The function also returns three lists: <code>datList</code>, <code>memList</code>, and <code>noisyList</code>.
</p>
<table role = "presentation">
<tr><td><code>datList:</code></td>
<td>

<p>a list of data matrices for generated data sets.
</p>
</td></tr>
<tr><td><code>memList:</code></td>
<td>

<p>a list of luster memberships for data points for generated data sets.
</p>
</td></tr>
<tr><td><code>noisyList:</code></td>
<td>

<p>a list of sets of noisy variables for generated data sets.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function might be take a while to complete.</p>


<h3>Author(s)</h3>

<p>Weiliang Qiu <a href="mailto:weiliang.qiu@gmail.com">weiliang.qiu@gmail.com</a><br />
Harry Joe <a href="mailto:harry@stat.ubc.ca">harry@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>Joe, H. (2006)
Generating Random Correlation Matrices Based on Partial Correlations. 
<em>Journal of Multivariate Analysis</em>, <b>97</b>, 2177&ndash;2189.
</p>
<p>Milligan G. W. (1985) 
An Algorithm for Generating Artificial Test Clusters.
<em>Psychometrika</em> <b>50</b>, 123&ndash;127.
</p>
<p>Qiu, W.-L. and Joe, H. (2006a)
Generation of Random Clusters with Specified Degree of Separaion.
<em>Journal of Classification</em>, <b>23</b>(2), 315-334.
</p>
<p>Qiu, W.-L. and Joe, H. (2006b)
Separation Index and Partial Membership for Clustering.
<em>Computational Statistics and Data Analysis</em>, <b>50</b>, 585&ndash;603.
</p>
<p>Su, J. Q. and Liu, J. S. (1993)
Linear Combinations of Multiple Diagnostic Markers.
<em>Journal of the American Statistical Association</em>, <b>88</b>, 1350&ndash;1355.
</p>
<p>Ghosh, S., Henderson, S. G. (2003).
Behavior of the NORTA method for correlated random vector generation
as the dimension increases.
<em>ACM Transactions on Modeling and Computer Simulation (TOMACS)</em>,
<b>13(3)</b>, 276&ndash;294.
</p>
<p>Kurowicka and Cooke, 2006.
<em>Uncertainty Analysis with High Dimensional Dependence Modelling</em>,
Wiley, 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tmp1 &lt;- genRandomClust(
		       numClust = 7, 
		       sepVal = 0.3, 
		       numNonNoisy = 5,  
                       numNoisy = 3, 
		       numOutlier = 5, 
		       numReplicate = 2, 
		       fileName = "chk1")

## End(Not run)
## Not run: 
tmp2 &lt;- genRandomClust(
		       numClust = 7, 
		       sepVal = 0.3, 
		       numNonNoisy = 5,  
                       numNoisy = 3, 
		       numOutlier = 5, 
		       numReplicate = 2, 
                       covMethod = "unifcorrmat", 
		       fileName = "chk2")

## End(Not run)
## Not run: 
tmp3 &lt;- genRandomClust(
		       numClust = 2, 
		       sepVal = -0.1, 
		       numNonNoisy = 2,  
                       numNoisy = 6, 
		       numOutlier = 30, 
		       numReplicate = 1, 
                       clustszind = 1, 
		       clustSizeEq = 80, 
		       rangeVar = c(10, 20),
                       covMethod = "unifcorrmat", 
		       iniProjDirMethod = "naive",
                       projDirMethod = "fixedpoint", 
		       fileName = "chk3")

## End(Not run)

</code></pre>

<hr>
<h2 id='getSepProj'>OPTIMAL PROJECTION DIRECTION AND CORRESPONDING SEPARATION INDEX FOR PAIRS OF CLUSTERS</h2><span id='topic+getSepProj'></span><span id='topic+getSepProjTheory'></span><span id='topic+getSepProjData'></span>

<h3>Description</h3>

<p>Optimal projection direction and corresponding separation index for pairs of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSepProjTheory(
		 muMat, 
		 SigmaArray, 
                 iniProjDirMethod = c("SL", "naive"), 
                 projDirMethod = c("newton", "fixedpoint"), 
                 alpha = 0.05, 
		 ITMAX = 20, 
		 eps = 1.0e-10, 
		 quiet = TRUE)

getSepProjData(
	       y, 
	       cl, 
               iniProjDirMethod = c("SL", "naive"), 
               projDirMethod = c("newton", "fixedpoint"), 
               alpha = 0.05, 
	       ITMAX = 20, 
	       eps = 1.0e-10, 
	       quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSepProj_+3A_mumat">muMat</code></td>
<td>

<p>Matrix of mean vectors. Rows correspond to mean vectors for clusters.
</p>
</td></tr>
<tr><td><code id="getSepProj_+3A_sigmaarray">SigmaArray</code></td>
<td>

<p>Array of covariance matrices. <code>SigmaArray[,,i]</code> record the covariance 
matrix of the <code>i</code>-th cluster.
</p>
</td></tr>
<tr><td><code id="getSepProj_+3A_y">y</code></td>
<td>

<p>Data matrix. Rows correspond to observations. Columns correspond to variables.
</p>
</td></tr>
<tr><td><code id="getSepProj_+3A_cl">cl</code></td>
<td>

<p>Cluster membership vector.
</p>
</td></tr>
<tr><td><code id="getSepProj_+3A_iniprojdirmethod">iniProjDirMethod</code></td>
<td>

<p>Indicating the method to get initial projection direction when calculating
the separation index between a pair of clusters (c.f. Qiu and Joe,
2006a, 2006b). <br />
<code>iniProjDirMethod</code>=&ldquo;SL&rdquo; indicates the initial projection 
direction is the sample version of the SL's projection direction 
(Su and Liu, 1993)
<code class="reqn">\left(\boldsymbol{\Sigma}_1+\boldsymbol{\Sigma}_2\right)^{-1}\left(\boldsymbol{\mu}_2-\boldsymbol{\mu}_1\right)</code><br />
<code>iniProjDirMethod</code>=&ldquo;naive&rdquo; indicates the initial projection 
direction is <code class="reqn">\boldsymbol{\mu}_2-\boldsymbol{\mu}_1</code>
</p>
</td></tr>
<tr><td><code id="getSepProj_+3A_projdirmethod">projDirMethod</code></td>
<td>

<p>Indicating the method to get the optimal projection direction when calculating 
the separation index between a pair of clusters (c.f. Qiu and Joe,
2006a, 2006b). <br />
<code>projDirMethod</code>=&ldquo;newton&rdquo; indicates we use the Newton-Raphson 
method to search the optimal projection direction (c.f. Qiu and Joe, 2006a). 
This requires the assumptions that both covariance matrices of the pair of 
clusters are positive-definite. If this assumption is violated, the 
&ldquo;fixedpoint&rdquo; method could be used. The &ldquo;fixedpoint&rdquo; method 
iteratively searches the optimal projection direction based on the first 
derivative of the separation index to the project direction 
(c.f. Qiu and Joe, 2006b).
</p>
</td></tr>
<tr><td><code id="getSepProj_+3A_alpha">alpha</code></td>
<td>

<p>Tuning parameter reflecting the percentage in the two
tails of a projected cluster that might be outlying.
We set <code>alpha</code><code class="reqn">=0.05</code> like we set
the significance level in hypothesis testing as <code class="reqn">0.05</code>.
</p>
</td></tr>
<tr><td><code id="getSepProj_+3A_itmax">ITMAX</code></td>
<td>

<p>Maximum iteration allowed when to iteratively calculate the
optimal projection direction.
The actual number of iterations is usually much less than the default value 20.
</p>
</td></tr>
<tr><td><code id="getSepProj_+3A_eps">eps</code></td>
<td>

<p>Convergence threshold. A small positive number to check if a quantitiy 
<code class="reqn">q</code> is equal to zero.  If <code class="reqn">|q|&lt;</code><code>eps</code>, then we regard <code class="reqn">q</code> 
as equal to zero.  <code>eps</code> is used to check if an algorithm converges.
The default value is <code class="reqn">1.0e-10</code>.
</p>
</td></tr>
<tr><td><code id="getSepProj_+3A_quiet">quiet</code></td>
<td>

<p>A flag to switch on/off the outputs of intermediate results and/or possible warning messages. The default value is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When calculating the optimal projection direction and corresponding optimal 
separation index for a pair of cluster, if one or both cluster covariance 
matrices is/are singular, the &lsquo;newton&rsquo; method can not be used. 
In this case, the functions <code>getSepProjTheory</code> and <code>getSepProjData</code> 
will automatically use the &lsquo;fixedpoint&rsquo; method to search the optimal 
projection direction, even if the user specifies the value of the argument 
<code>projDirMethod</code> as &lsquo;newton&rsquo;. Also, multiple initial projection 
directions will be evaluated. 
</p>
<p>Specifically, <code class="reqn">2+2p</code> projection directions will be evaluated. The first 
projection direction is the &ldquo;naive&rdquo; direction 
<code class="reqn">\boldsymbol{\mu}_2-\boldsymbol{\mu}_1</code>. 
The second projection direction is the &ldquo;SL&rdquo; projection direction  
<code class="reqn">\left(\boldsymbol{\Sigma}_1+\boldsymbol{\Sigma}_2\right)^{-1}
\left(\boldsymbol{\mu}_2-\boldsymbol{\mu}_1\right)</code>.
The next <code class="reqn">p</code> projection directions are the <code class="reqn">p</code> eigenvectors of the covariance 
matrix of the first cluster. The remaining <code class="reqn">p</code> projection directions are 
the <code class="reqn">p</code> eigenvectors of the covariance matrix of the second cluster. 
</p>
<p>Each of these <code class="reqn">2+2*p</code> projection directions are in turn used as the initial 
projection direction for the &lsquo;fixedpoint&rsquo; algorithm to obtain the 
optimal projection direction and the corresponding optimal separation index. 
We also obtain <code class="reqn">2+2*p</code> separation indices by projecting two clusters along each of these <code class="reqn">2+2*p</code> projection directions.
</p>
<p>Finally, the projection direction with the largest separation index among the 
<code class="reqn">2*(2+2*p)</code> optimal separation indices is chosen as the optimal projection 
direction. The corresponding separation index is chosen as the optimal 
separation index.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sepValMat</code></td>
<td>

<p>Separation index matrix
</p>
</td></tr>
<tr><td><code>projDirArray</code></td>
<td>

<p>Array of projection directions for each pair of clusters
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Weiliang Qiu <a href="mailto:weiliang.qiu@gmail.com">weiliang.qiu@gmail.com</a><br />
Harry Joe <a href="mailto:harry@stat.ubc.ca">harry@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>Qiu, W.-L. and Joe, H. (2006a)
Generation of Random Clusters with Specified Degree of Separaion.
<em>Journal of Classification</em>, <b>23</b>(2), 315-334.
</p>
<p>Qiu, W.-L. and Joe, H. (2006b)
Separation Index and Partial Membership for Clustering.
<em>Computational Statistics and Data Analysis</em>, <b>50</b>, 585&ndash;603.
</p>
<p>Su, J. Q. and Liu, J. S. (1993)
Linear Combinations of Multiple Diagnostic Markers.
<em>Journal of the American Statistical Association</em>, <b>88</b>, 1350&ndash;1355.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 50
mu1 &lt;- c(0, 0)
Sigma1 &lt;- matrix(c(2, 1, 1, 5), 2, 2)
n2 &lt;- 100
mu2 &lt;- c(10, 0)
Sigma2 &lt;- matrix(c(5, -1, -1, 2), 2, 2)
projDir &lt;- c(1,  0)
muMat &lt;- rbind(mu1,  mu2)
SigmaArray &lt;- array(0,  c(2, 2, 2))
SigmaArray[, , 1] &lt;- Sigma1
SigmaArray[, , 2] &lt;- Sigma2

a &lt;- getSepProjTheory(
		    muMat = muMat, 
		    SigmaArray = SigmaArray, 
		    iniProjDirMethod = "SL")
# separation index for cluster distributions 1 and 2
a$sepValMat[1, 2]
# projection direction for cluster distributions 1 and 2
a$projDirArray[1, 2, ]

library(MASS)
y1 &lt;- mvrnorm(n1, mu1, Sigma1)
y2 &lt;- mvrnorm(n2, mu2, Sigma2)
y &lt;- rbind(y1, y2)
cl &lt;- rep(1:2, c(n1, n2))

b &lt;- getSepProjData(
		  y = y, 
		  cl = cl, 
		  iniProjDirMethod = "SL", 
		  projDirMethod = "newton")
# separation index for clusters 1 and 2
b$sepValMat[1, 2]
# projection direction for clusters 1 and 2
b$projDirArray[1, 2, ]

</code></pre>

<hr>
<h2 id='nearestNeighborSepVal'>SEPARATON INFORMATION MATRIX</h2><span id='topic+nearestNeighborSepVal'></span>

<h3>Description</h3>

<p>Separation information matrix containing the nearest neighbor and farthest neighbor of each cluster. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nearestNeighborSepVal(sepValMat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nearestNeighborSepVal_+3A_sepvalmat">sepValMat</code></td>
<td>

<p>a <code>K</code> by <code>K</code> matrix, where <code>K</code> is the number of clusters. 
<code>sepValMat[i,j]</code> is the separation index between cluster <code>i</code> and 
<code>j</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a separation information matrix containing <code>K</code> rows and 
the following six columns, where <code>K</code> is the number of clusters.
</p>
<table role = "presentation">
<tr><td><code>Column 1:</code></td>
<td>

<p>Labels of clusters (<code class="reqn">1, 2, \ldots, numClust</code>), where <code class="reqn">numClust</code> is 
the number of clusters for the data set.
</p>
</td></tr>
<tr><td><code>Column 2:</code></td>
<td>

<p>Labels of the corresponding nearest neighbors.
</p>
</td></tr>
<tr><td><code>Column 3:</code></td>
<td>

<p>Separation indices of the clusters to their nearest neighboring clusters.
</p>
</td></tr>
<tr><td><code>Column 4:</code></td>
<td>

<p>Labels of the corresponding farthest neighboring clusters.
</p>
</td></tr>
<tr><td><code>Column 5:</code></td>
<td>

<p>Separation indices of the clusters to their farthest neighbors.
</p>
</td></tr>
<tr><td><code>Column 6:</code></td>
<td>

<p>Median separation indices of the clusters to their neighbors.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Weiliang Qiu <a href="mailto:weiliang.qiu@gmail.com">weiliang.qiu@gmail.com</a><br />
Harry Joe <a href="mailto:harry@stat.ubc.ca">harry@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>Qiu, W.-L. and Joe, H. (2006a)
Generation of Random Clusters with Specified Degree of Separaion.
<em>Journal of Classification</em>, <b>23</b>(2), 315-334.
</p>
<p>Qiu, W.-L. and Joe, H. (2006b)
Separation Index and Partial Membership for Clustering.
<em>Computational Statistics and Data Analysis</em>, <b>50</b>, 585&ndash;603.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 50
mu1 &lt;- c(0, 0)
Sigma1 &lt;- matrix(c(2, 1, 1, 5), 2, 2)
n2 &lt;- 100
mu2 &lt;- c(10, 0)
Sigma2 &lt;- matrix(c(5, -1, -1, 2), 2, 2)
n3 &lt;- 30
mu3 &lt;- c(10, 10)
Sigma3 &lt;- matrix(c(3, 1.5, 1.5, 1), 2, 2)

projDir &lt;- c(1, 0)
muMat &lt;- rbind(mu1, mu2, mu3)
SigmaArray &lt;- array(0, c(2, 2, 3))
SigmaArray[, , 1] &lt;- Sigma1
SigmaArray[, , 2] &lt;- Sigma2
SigmaArray[, , 3] &lt;- Sigma3

tmp &lt;- getSepProjTheory(
			muMat = muMat, 
			SigmaArray = SigmaArray, 
			iniProjDirMethod="SL")
sepValMat &lt;- tmp$sepValMat
nearestNeighborSepVal(sepValMat = sepValMat)
</code></pre>

<hr>
<h2 id='plot1DProjection'>PLOT A PAIR OF CLUSTERS AND THEIR DENSITY ESTIMATES, WHICH ARE PROJECTED  ALONG A SPECIFIED 1-D PROJECTION DIRECTION</h2><span id='topic+plot1DProjection'></span>

<h3>Description</h3>

<p>Plot a pair of clusters and their density estimates, which are projected along a specified 1-D projection direction. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot1DProjection(
		 y1, 
		 y2, 
		 projDir, 
                 sepValMethod = c("normal", "quantile"), 
		 bw = "nrd0", 
                 xlim = NULL, 
		 ylim = NULL, 
                 xlab = "1-D projected clusters", 
		 ylab = "density estimates", 
                 title = "1-D Projected Clusters and their density estimates",
                 font = 2, 
		 font.lab = 2, 
		 cex = 1.2, 
		 cex.lab = 1.2, 
		 cex.main = 1.5,
                 lwd = 4, 
		 lty1 = 1, 
		 lty2 = 2, 
		 pch1 = 18, 
		 pch2 = 19, 
		 col1 = 2, 
		 col2 = 4, 
                 type = "l", 
		 alpha = 0.05, 
		 eps = 1.0e-10, 
		 quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot1DProjection_+3A_y1">y1</code></td>
<td>

<p>Data matrix of cluster 1. Rows correspond to observations. Columns correspond to variables.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_y2">y2</code></td>
<td>

<p>Data matrix of cluster 2. Rows correspond to observations. Columns correspond to variables.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_projdir">projDir</code></td>
<td>

<p>1-D projection direction along which two clusters will be projected.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_sepvalmethod">sepValMethod</code></td>
<td>

<p>Method to calculate separation index for a pair of clusters projected onto a 
1-D space. <code>sepValMethod="quantile"</code> indicates the quantile version of
separation index will be used: <code class="reqn">sepVal=(L_2-U_1)/(U_2-L_1)</code> where <code class="reqn">L_i</code> and 
<code class="reqn">U_i</code>, <code class="reqn">i=1, 2</code>, are the lower and upper <code>alpha/2</code> sample percentiles 
of projected cluster <code class="reqn">i</code>. <code>sepValMethod="normal"</code> indicates the 
normal version of separation index will be used: 
<code class="reqn">sepVal=[(xbar_2-xbar_1)-z_{\alpha/2}(s_1+s_2)]/
[(xbar_2-xbar_1)+z_{\alpha/2}(s_1+s_2)]</code>, 
where <code class="reqn">xbar_i</code> and <code class="reqn">s_i</code> are the sample mean and standard deviation 
of projected cluster <code class="reqn">i</code>.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_bw">bw</code></td>
<td>

<p>The smoothing bandwidth to be used by the function <code>density</code>.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_xlim">xlim</code></td>
<td>

<p>Range of X axis.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_ylim">ylim</code></td>
<td>

<p>Range of Y axis.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_xlab">xlab</code></td>
<td>

<p>X axis label.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_ylab">ylab</code></td>
<td>

<p>Y axis label.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_title">title</code></td>
<td>

<p>Title of the plot.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_font">font</code></td>
<td>

<p>An integer which specifies which font to use for text (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_font.lab">font.lab</code></td>
<td>

<p>The font to be used for x and y labels (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_cex">cex</code></td>
<td>

<p>A numerical value giving the amount by which plotting text
and symbols should be scaled relative to the default (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_cex.lab">cex.lab</code></td>
<td>

<p>The magnification to be used for x and y labels relative
to the current setting of 'cex' (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_cex.main">cex.main</code></td>
<td>

<p>The magnification to be used for main titles relative
to the current setting of 'cex' (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_lwd">lwd</code></td>
<td>

<p>The line width, a positive number, defaulting to '1' (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_lty1">lty1</code></td>
<td>

<p>Line type for cluster 1 (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_lty2">lty2</code></td>
<td>

<p>Line type for cluster 2 (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_pch1">pch1</code></td>
<td>

<p>Either an integer specifying a symbol or a single character
to be used as the default in plotting points for cluster 1 (see <code>points</code>).
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_pch2">pch2</code></td>
<td>

<p>Either an integer specifying a symbol or a single character
to be used as the default in plotting points for cluster 2 (see <code>points</code>).
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_col1">col1</code></td>
<td>

<p>Color to indicates cluster 1.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_col2">col2</code></td>
<td>

<p>Color to indicates cluster 2.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_type">type</code></td>
<td>

<p>What type of plot should be drawn (see <code>plot</code>).
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_alpha">alpha</code></td>
<td>

<p>Tuning parameter reflecting the percentage in the two
tails of a projected cluster that might be outlying.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_eps">eps</code></td>
<td>

<p>A small positive number to check if a quantitiy <code class="reqn">q</code> is equal to zero.  
If <code class="reqn">|q|&lt;</code><code>eps</code>, then we regard <code class="reqn">q</code> as equal to zero.  
<code>eps</code> is used to check the denominator in the formula of the separation 
index is equal to zero. Zero-value denominator indicates two clusters are 
totally overlapped. Hence the separation index is set to be <code class="reqn">-1</code>.
The default value of <code>eps</code> is <code class="reqn">1.0e-10</code>.
</p>
</td></tr>
<tr><td><code id="plot1DProjection_+3A_quiet">quiet</code></td>
<td>

<p>A flag to switch on/off the outputs of intermediate results and/or possible warning messages. The default value is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ticks along X axis indicates the positions of points of the projected 
two clusters. The positions of <code class="reqn">L_i</code> and <code class="reqn">U_i</code>, <code class="reqn">i=1, 2</code>, are also indicated 
on X axis, where <code class="reqn">L_i</code> and <code class="reqn">U_i</code> are the lower and upper <code class="reqn">\alpha/2</code> sample 
percentiles of cluster <code class="reqn">i</code> if <code>sepValMethod="quantile"</code>. 
If <code>sepValMethod="normal"</code>,
<code class="reqn">L_i=xbar_i-z_{\alpha/2}s_i</code>, where <code class="reqn">xbar_i</code> and <code class="reqn">s_i</code> are the 
sample mean and standard deviation of cluster <code class="reqn">i</code>, and <code class="reqn">z_{\alpha/2}</code> 
is the upper <code class="reqn">\alpha/2</code> percentile of standard normal distribution.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sepVal</code></td>
<td>

<p>value of the separation index for the projected two clusters along
the projection direction <code>projDir</code>.
</p>
</td></tr>
<tr><td><code>projDir</code></td>
<td>

<p>projection direction. To make sure the projected cluster 1 is on the 
left-hand side of the projected cluster 2, the input <code>projDir</code>
might be changed to <code>-projDir</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Weiliang Qiu <a href="mailto:weiliang.qiu@gmail.com">weiliang.qiu@gmail.com</a><br />
Harry Joe <a href="mailto:harry@stat.ubc.ca">harry@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>Qiu, W.-L. and Joe, H. (2006)
Separation Index and Partial Membership for Clustering.
<em>Computational Statistics and Data Analysis</em>, <b>50</b>, 585&ndash;603.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot2DProjection">plot2DProjection</a></code>
<code><a href="#topic+viewClusters">viewClusters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 50
mu1 &lt;- c(0,0)
Sigma1 &lt;- matrix(c(2, 1, 1, 5), 2, 2)
n2 &lt;- 100
mu2 &lt;- c(10, 0)
Sigma2 &lt;- matrix(c(5, -1, -1, 2), 2, 2)
projDir &lt;- c(1,  0)

library(MASS)
set.seed(1234)
y1 &lt;- mvrnorm(n1, mu1, Sigma1)
y2 &lt;- mvrnorm(n2, mu2, Sigma2)
y &lt;- rbind(y1, y2)
cl &lt;- rep(1:2, c(n1, n2))

b &lt;- getSepProjData(
		    y = y, 
		    cl = cl, 
		    iniProjDirMethod = "SL", 
		    projDirMethod = "newton")
# projection direction for clusters 1 and 2
projDir &lt;- b$projDirArray[1, 2, ]

plot1DProjection(
		 y1 = y1, 
		 y2 = y2, 
		 projDir = projDir)

</code></pre>

<hr>
<h2 id='plot2DProjection'>PLOT A PAIR OF CLUSTERS ALONG A 2-D PROJECTION SPACE</h2><span id='topic+plot2DProjection'></span>

<h3>Description</h3>

<p>Plot a pair of clusters along a 2-D projection space. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot2DProjection(
		 y1, 
		 y2, 
		 projDir, 
                 sepValMethod = c("normal", "quantile"), 
                 iniProjDirMethod = c("SL", "naive"), 
                 projDirMethod = c("newton", "fixedpoint"), 
                 xlim = NULL, 
		 ylim = NULL, 
                 xlab = "1st projection direction", 
                 ylab = "2nd projection direction", 
                 title = "Scatter plot of 2-D Projected Clusters",
                 font = 2, 
		 font.lab = 2, 
		 cex = 1.2, 
		 cex.lab = 1, 
		 cex.main = 1.5,
                 lwd = 4, 
		 lty1 = 1, 
		 lty2 = 2, 
		 pch1 = 18, 
		 pch2 = 19, 
		 col1 = 2, 
		 col2 = 4, 
                 alpha = 0.05, 
		 ITMAX = 20, 
		 eps = 1.0e-10, 
		 quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot2DProjection_+3A_y1">y1</code></td>
<td>

<p>Data matrix of cluster 1. Rows correspond to observations. Columns correspond to variables.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_y2">y2</code></td>
<td>

<p>Data matrix of cluster 2. Rows correspond to observations. Columns correspond to variables.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_projdir">projDir</code></td>
<td>

<p>1-D projection direction along which two clusters will be projected.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_sepvalmethod">sepValMethod</code></td>
<td>

<p>Method to calculate separation index for a pair of clusters projected onto a 
1-D space. <code>sepValMethod="quantile"</code> indicates the quantile version of
separation index will be used: <code class="reqn">sepVal=(L_2-U_1)/(U_2-L_1)</code> where <code class="reqn">L_i</code> and 
<code class="reqn">U_i</code>, <code class="reqn">i=1, 2</code>, are the lower and upper <code>alpha/2</code> sample percentiles 
of projected cluster <code class="reqn">i</code>. <code>sepValMethod="normal"</code> indicates the 
normal version of separation index will be used: 
<code class="reqn">sepVal=[(xbar_2-xbar_1)-z_{\alpha/2}(s_1+s_2)]/
[(xbar_2-xbar_1)+z_{\alpha/2}(s_1+s_2)]</code>, 
where <code class="reqn">xbar_i</code> and <code class="reqn">s_i</code> are the sample mean and standard deviation 
of projected cluster <code class="reqn">i</code>.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_iniprojdirmethod">iniProjDirMethod</code></td>
<td>

<p>Indicating the method to get initial projection direction when calculating
the separation index between a pair of clusters (c.f. Qiu and Joe,
2006a, 2006b). <br />
<code>iniProjDirMethod</code>=&ldquo;SL&rdquo; indicates the initial projection 
direction is the sample version of the SL's projection direction 
(Su and Liu, 1993)
<code class="reqn">\left(\boldsymbol{\Sigma}_1+\boldsymbol{\Sigma}_2\right)^{-1}\left(\boldsymbol{\mu}_2-\boldsymbol{\mu}_1\right)</code><br />
<code>iniProjDirMethod</code>=&ldquo;naive&rdquo; indicates the initial projection 
direction is <code class="reqn">\boldsymbol{\mu}_2-\boldsymbol{\mu}_1</code>
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_projdirmethod">projDirMethod</code></td>
<td>

<p>Indicating the method to get the optimal projection direction when calculating 
the separation index between a pair of clusters (c.f. Qiu and Joe,
2006a, 2006b). <br />
<code>projDirMethod</code>=&ldquo;newton&rdquo; indicates we use the Newton-Raphson 
method to search the optimal projection direction (c.f. Qiu and Joe, 2006a). 
This requires the assumptions that both covariance matrices of the pair of 
clusters are positive-definite. If this assumption is violated, the 
&ldquo;fixedpoint&rdquo; method could be used. The &ldquo;fixedpoint&rdquo; method 
iteratively searches the optimal projection direction based on the first 
derivative of the separation index to the project direction 
(c.f. Qiu and Joe, 2006b).
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_xlim">xlim</code></td>
<td>

<p>Range of X axis.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_ylim">ylim</code></td>
<td>

<p>Range of Y axis.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_xlab">xlab</code></td>
<td>

<p>X axis label.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_ylab">ylab</code></td>
<td>

<p>Y axis label.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_title">title</code></td>
<td>

<p>Title of the plot.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_font">font</code></td>
<td>

<p>An integer which specifies which font to use for text (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_font.lab">font.lab</code></td>
<td>

<p>The font to be used for x and y labels (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_cex">cex</code></td>
<td>

<p>A numerical value giving the amount by which plotting text
and symbols should be scaled relative to the default (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_cex.lab">cex.lab</code></td>
<td>

<p>The magnification to be used for x and y labels relative
to the current setting of 'cex' (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_cex.main">cex.main</code></td>
<td>

<p>The magnification to be used for main titles relative
to the current setting of 'cex' (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_lwd">lwd</code></td>
<td>

<p>The line width, a positive number, defaulting to '1' (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_lty1">lty1</code></td>
<td>

<p>Line type for cluster 1 (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_lty2">lty2</code></td>
<td>

<p>Line type for cluster 2 (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_pch1">pch1</code></td>
<td>

<p>Either an integer specifying a symbol or a single character
to be used as the default in plotting points for cluster 1 (see <code>points</code>).
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_pch2">pch2</code></td>
<td>

<p>Either an integer specifying a symbol or a single character
to be used as the default in plotting points for cluster 2 (see <code>points</code>).
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_col1">col1</code></td>
<td>

<p>Color to indicates cluster 1.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_col2">col2</code></td>
<td>

<p>Color to indicates cluster 2.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_alpha">alpha</code></td>
<td>

<p>Tuning parameter reflecting the percentage in the two
tails of a projected cluster that might be outlying.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_itmax">ITMAX</code></td>
<td>

<p>Maximum iteration allowed when iteratively calculating the
optimal projection direction.
The actual number of iterations is usually much less than the default value 20.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_eps">eps</code></td>
<td>

<p>A small positive number to check if a quantitiy <code class="reqn">q</code> is equal to zero.  
If <code class="reqn">|q|&lt;</code><code>eps</code>, then we regard <code class="reqn">q</code> as equal to zero.  
<code>eps</code> is used to check the denominator in the formula of the separation 
index is equal to zero. Zero-value denominator indicates two clusters are 
totally overlapped. Hence the separation index is set to be <code class="reqn">-1</code>.
The default value of <code>eps</code> is <code class="reqn">1.0e-10</code>.
</p>
</td></tr>
<tr><td><code id="plot2DProjection_+3A_quiet">quiet</code></td>
<td>

<p>A flag to switch on/off the outputs of intermediate results and/or possible warning messages. The default value is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To get the second projection direction, we first construct an orthogonal 
matrix with first column <code>projDir</code>. Then we rotate the data points 
according to this orthogonal matrix. Next, we remove the first dimension 
of the rotated data points, and obtain the optimal projection direction 
<code>projDir2</code> for the rotated data points in the remaining dimensions. 
Finally, we rotate the vector
<code>projDir3=(0, projDir2)</code> back to the original space. 
The vector <code>projDir3</code> is the second projection direction.
</p>
<p>The ticks along X axis indicates the positions of points of the projected 
two clusters. The positions of <code class="reqn">L_i</code> and <code class="reqn">U_i</code>, <code class="reqn">i=1, 2</code>, are also indicated 
on X axis, where <code class="reqn">L_i</code> and <code class="reqn">U_i</code> are the lower and upper <code class="reqn">\alpha/2</code> sample 
percentiles of cluster <code class="reqn">i</code> if <code>sepValMethod="quantile"</code>. 
If <code>sepValMethod="normal"</code>,
<code class="reqn">L_i=xbar_i-z_{\alpha/2}s_i</code>, where <code class="reqn">xbar_i</code> and <code class="reqn">s_i</code> are the 
sample mean and standard deviation of cluster <code class="reqn">i</code>, and <code class="reqn">z_{\alpha/2}</code> 
is the upper <code class="reqn">\alpha/2</code> percentile of standard normal distribution.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sepValx</code></td>
<td>

<p>value of the separation index for the projected two clusters along the
1st projection direction.
</p>
</td></tr>
<tr><td><code>sepValy</code></td>
<td>

<p>value of the separation index for the projected two clusters along the
2nd projection direction.
</p>
</td></tr>
<tr><td><code>Q2</code></td>
<td>

<p>1st column is the 1st projection direction. 2nd column is the 2nd
projection direction.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Weiliang Qiu <a href="mailto:weiliang.qiu@gmail.com">weiliang.qiu@gmail.com</a><br />
Harry Joe <a href="mailto:harry@stat.ubc.ca">harry@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>Qiu, W.-L. and Joe, H. (2006a)
Generation of Random Clusters with Specified Degree of Separaion.
<em>Journal of Classification</em>, <b>23</b>(2), 315-334.
</p>
<p>Qiu, W.-L. and Joe, H. (2006b)
Separation Index and Partial Membership for Clustering.
<em>Computational Statistics and Data Analysis</em>, <b>50</b>, 585&ndash;603.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot1DProjection">plot1DProjection</a></code>
<code><a href="#topic+viewClusters">viewClusters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 50
mu1 &lt;- c(0,0)
Sigma1 &lt;- matrix(c(2, 1, 1, 5), 2, 2)
n2 &lt;- 100
mu2 &lt;- c(10, 0)
Sigma2 &lt;- matrix(c(5, -1, -1, 2), 2, 2)
projDir &lt;- c(1,  0)

library(MASS)
set.seed(1234)
y1 &lt;- mvrnorm(n1, mu1, Sigma1)
y2 &lt;- mvrnorm(n2, mu2, Sigma2)
y &lt;- rbind(y1, y2)
cl &lt;- rep(1:2, c(n1, n2))

b &lt;- getSepProjData(
		    y = y, 
		    cl = cl, 
		    iniProjDirMethod = "SL", 
		    projDirMethod = "newton")
# projection direction for clusters 1 and 2
projDir &lt;- b$projDirArray[1,2,]

par(mfrow = c(2,1))
plot1DProjection(
		 y1 = y1, 
		 y2 = y2, 
		 projDir = projDir)
plot2DProjection(
		 y1 = y1, 
		 y2 = y2, 
		 projDir = projDir)

</code></pre>

<hr>
<h2 id='rcorrmatrix'>GENERATE A RANDOM CORRELATION MATRIX BASED ON RANDOM PARTIAL CORRELATIONS</h2><span id='topic+rcorrmatrix'></span>

<h3>Description</h3>

<p>Generate a random correlation matrix based on random partial correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rcorrmatrix(d, alphad = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcorrmatrix_+3A_d">d</code></td>
<td>

<p>Dimension of the matrix. <code>d</code> should be a non-negative integer.
</p>
</td></tr>
<tr><td><code id="rcorrmatrix_+3A_alphad">alphad</code></td>
<td>

<p><code class="reqn">\alpha</code> parameter for partial of <code class="reqn">1,d</code> given <code class="reqn">2,\ldots,d-1</code>, for 
generating random correlation matrix based on the method proposed by Joe (2006),
where <code class="reqn">d</code> is the dimension of the correlation matrix.
The default value <code>alphad</code><code class="reqn">=1</code> leads to a random matrix which is 
uniform over space of positive definite correlation matrices.
Each correlation has a <code class="reqn">Beta(a,a)</code> distribution on <code class="reqn">(-1,1)</code> where
<code class="reqn">a=alphad+(d-2)/2</code>. <code>alphad</code> should be a positive number.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix.
</p>


<h3>Author(s)</h3>

<p>Weiliang Qiu <a href="mailto:weiliang.qiu@gmail.com">weiliang.qiu@gmail.com</a><br />
Harry Joe <a href="mailto:harry@stat.ubc.ca">harry@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>Joe, H. (2006)
Generating Random Correlation Matrices Based on Partial Correlations. 
<em>Journal of Multivariate Analysis</em>, <b>97</b>, 2177&ndash;2189.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcorrmatrix(3)
rcorrmatrix(5)
rcorrmatrix(5, alphad = 2.5)
</code></pre>

<hr>
<h2 id='sepIndex'>MEASURE THE MAGNITUDE OF THE GAP OR SPARSE AREA BETWEEN A PAIR OF CLUSTERS ALONG THE SPECIFIED PROJECTION DIRECTION</h2><span id='topic+sepIndex'></span><span id='topic+sepIndexTheory'></span><span id='topic+sepIndexData'></span>

<h3>Description</h3>

<p>Measure the magnitude of the gap or sparse area between a pair of clusters
(or cluster distributions) along the specified projection direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sepIndexTheory(
	       projDir, 
	       mu1, 
	       Sigma1, 
	       mu2, 
	       Sigma2, 
               alpha = 0.05, 
	       eps = 1.0e-10, 
	       quiet = TRUE)

sepIndexData(
	     projDir, 
	     y1, 
	     y2, 
	     alpha = 0.05, 
	     eps = 1.0e-10, 
	     quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sepIndex_+3A_projdir">projDir</code></td>
<td>

<p>Projection direction.
</p>
</td></tr>
<tr><td><code id="sepIndex_+3A_mu1">mu1</code></td>
<td>

<p>Mean vector of cluster 1.
</p>
</td></tr>
<tr><td><code id="sepIndex_+3A_sigma1">Sigma1</code></td>
<td>

<p>Covariance matrix of cluster 1.
</p>
</td></tr>
<tr><td><code id="sepIndex_+3A_mu2">mu2</code></td>
<td>

<p>Mean vector of cluster 2.
</p>
</td></tr>
<tr><td><code id="sepIndex_+3A_sigma2">Sigma2</code></td>
<td>

<p>Covariance matrix of cluster 2.
</p>
</td></tr>
<tr><td><code id="sepIndex_+3A_y1">y1</code></td>
<td>

<p>Data matrix of cluster 1. Rows correspond to observations. Columns correspond 
to variables.
</p>
</td></tr>
<tr><td><code id="sepIndex_+3A_y2">y2</code></td>
<td>

<p>Data matrix of cluster 2. Rows correspond to observations. Columns correspond 
to variables.
</p>
</td></tr>
<tr><td><code id="sepIndex_+3A_alpha">alpha</code></td>
<td>

<p>Tuning parameter reflecting the percentage in the two
tails of a projected cluster that might be outlying.
We set <code>alpha</code><code class="reqn">=0.05</code> like we set
the significance level in hypothesis testing as <code class="reqn">0.05</code>.
</p>
</td></tr>
<tr><td><code id="sepIndex_+3A_eps">eps</code></td>
<td>

<p>Convergence threshold. A small positive number to check if a quantitiy <code class="reqn">q</code> 
is equal to zero.  If <code class="reqn">|q|&lt;</code><code>eps</code>, then we regard <code class="reqn">q</code> is equal 
to zero.  <code>eps</code> is used to check if an algorithm converges.
The default value is <code class="reqn">1.0e-10</code>.
</p>
</td></tr>
<tr><td><code id="sepIndex_+3A_quiet">quiet</code></td>
<td>

<p>A flag to switch on/off the outputs of intermediate results and/or possible warning messages. The default value is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the separation index defined in Qiu and Joe (2006). 
</p>


<h3>Author(s)</h3>

<p>Weiliang Qiu <a href="mailto:weiliang.qiu@gmail.com">weiliang.qiu@gmail.com</a><br />
Harry Joe <a href="mailto:harry@stat.ubc.ca">harry@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>Qiu, W.-L. and Joe, H. (2006)
Separation Index and Partial Membership for Clustering.
<em>Computational Statistics and Data Analysis</em>, <b>50</b>, 585&ndash;603.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1&lt;-50
mu1&lt;-c(0,0)
Sigma1&lt;-matrix(c(2,1,1,5),2,2)
n2&lt;-100
mu2&lt;-c(10,0)
Sigma2&lt;-matrix(c(5,-1,-1,2),2,2)
projDir&lt;-c(1, 0)
sepIndexTheory(projDir, mu1, Sigma1, mu2, Sigma2)

library(MASS)
y1 &lt;- mvrnorm(n1, mu1, Sigma1)
y2 &lt;- mvrnorm(n2, mu2, Sigma2)
sepIndexData(
	     projDir = projDir, 
	     y1 = y1, 
	     y2 = y2)

</code></pre>

<hr>
<h2 id='simClustDesign'>DESIGN FOR RANDOM CLUSTER GENERATION WITH SPECIFIED DEGREE OF SEPARATION</h2><span id='topic+simClustDesign'></span>

<h3>Description</h3>

<p>Generating data sets via a factorial design, which has factors: 
degree of separation, number of clusters, number of non-noisy variables, 
number of noisy variables. The separation between any cluster and its 
nearest neighboring clusters can be set to a specified value. 
The covariance matrices of clusters can have arbitrary diameters, shapes 
and orientations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simClustDesign(numClust = c(3,6,9), 
               sepVal = c(0.01, 0.21, 0.342), 
               sepLabels = c("L", "M", "H"), 
               numNonNoisy = c(4,8,20), 
               numNoisy = NULL, 
               numOutlier = 0, 
               numReplicate = 3, 
               fileName = "test", 
               clustszind = 2, 
               clustSizeEq = 50, 
               rangeN = c(50,200), 
               clustSizes = NULL,
               covMethod = c("eigen", "onion", "c-vine", "unifcorrmat"), 
	       eigenvalue = NULL,
               rangeVar = c(1, 10), 
               lambdaLow = 1, 
               ratioLambda = 10, 
               alphad = 1, 
               eta = 1, 
               rotateind = TRUE, 
               iniProjDirMethod = c("SL", "naive"), 
               projDirMethod = c("newton", "fixedpoint"), 
               alpha = 0.05, 
               ITMAX = 20, 
               eps = 1.0e-10, 
               quiet = TRUE, 
               outputDatFlag = TRUE, 
               outputLogFlag = TRUE, 
               outputEmpirical = TRUE, 
               outputInfo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simClustDesign_+3A_numclust">numClust</code></td>
<td>

<p>Vector of the number of clusters for data sets in the design.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_sepval">sepVal</code></td>
<td>

<p>Vector of desired values of the separation index between clusters
and their nearest neighboring clusters. Each element of <code>sepVal</code> can 
take values within the interval <code>[-1, 1)</code>. 
The closer to 1 an element of <code>sepVal</code> is, the more separated the 
pair of clusters are.
The values <code class="reqn">0.01, 0.21, 0.34</code> are the values of the separation index for
two univariate clusters generated from <code class="reqn">N(0, 1)</code> and <code class="reqn">N(0, A)</code>,
where <code class="reqn">A=4, 6, 8</code>, respectively. <code>sepVal</code><code class="reqn">=0.01 (A=4)</code> indicates 
a close cluster structure. <code>sepVal</code><code class="reqn">=0.21 (A=6)</code> indicates a 
separated cluster structure. <code>sepVal</code><code class="reqn">=0.34 (A=8)</code> indicates 
a well-separated cluster.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_seplabels">sepLabels</code></td>
<td>

<p>Labels for &quot;close&quot;, &quot;separated&quot;, and &quot;well-separated&quot; cluster structures.
By default, &quot;L&quot; (low) means &quot;close&quot;, &quot;M&quot; (medium) means &quot;separated&quot;,
&quot;H&quot; (high) means &quot;well-separated&quot;.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_numnonnoisy">numNonNoisy</code></td>
<td>

<p>Vector of the number of non-noisy variables.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_numnoisy">numNoisy</code></td>
<td>

<p>Vectors of the number of noisy variables. The default value of <code>numNoisy</code> 
is <code>NULL</code> so that the program can automatically assign the value of 
<code>numNoisy</code> as a vector with elements <code class="reqn">1, round(p1/2), p1</code>.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_numoutlier">numOutlier</code></td>
<td>

<p>The number or ratio of outliers. If <code>numOutlier</code> is a 
positive integer, then <code>numOutlier</code> means the number of outliers. 
If <code>numOutlier</code> is a real number between <code class="reqn">(0, 1)</code>, then 
<code>numOutlier</code> means the ratio of outliers, i.e. the number of outliers 
is equal to 
<code>round</code>(<code>numOutlier</code><code class="reqn">*n_1</code>), where <code class="reqn">n_1</code> is the total number 
of non-outliers.  If <code>numOutlier</code> is a real number greater than <code class="reqn">1</code>, 
then <code>numOutlier</code> is rounded to an integer.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_numreplicate">numReplicate</code></td>
<td>

<p>Number of data sets to be generated for the same cluster structure specified 
by the other arguments of the function <code>genRandomClust</code>.
The default value <code class="reqn">3</code> follows the design in Milligan (1985).
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_filename">fileName</code></td>
<td>

<p>The first part of the names of data files that record the generated data sets 
and associated information, such as cluster membership of data points, labels 
of noisy variables, separation index matrix, projection directions, etc. 
(see details). The default value of <code>fileName</code> is &lsquo;<span class="file">test</span>&rsquo;.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_clustszind">clustszind</code></td>
<td>

<p>Cluster size indicator.
<code>clustszind</code><code class="reqn">=1</code> indicates that all cluster have equal size. 
The size is specified by the argument <code>clustSizeEq</code>.
<code>clustszind</code><code class="reqn">=2</code> indicates that the cluster sizes are randomly 
generated from the range specified by the argument <code>rangeN</code>.
<code>clustszind</code><code class="reqn">=3</code> indicates that the cluster sizes are specified
via the vector <code>clustSizes</code>.
The default value is <code class="reqn">2</code> so that the generated clusters are more
realistic.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_clustsizeeq">clustSizeEq</code></td>
<td>

<p>Cluster size.
If the argument <code>clustszind</code><code class="reqn">=1</code>, then all clusters will have the 
equal number <code>clustSizeEq</code> of data points. The value of <code>clustSizeEq</code> should be large enough to get non-singular cluster covariance matrices. 
We recommend the <code>clustSizeEq</code> is at least <code class="reqn">10*p</code>, where <code class="reqn">p</code> 
is the total number of variables (including both non-noisy and noisy variables).
The default value <code class="reqn">100</code> is a reasonable cluster size.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_rangen">rangeN</code></td>
<td>

<p>The range of cluster sizes.
If <code>clustszind</code><code class="reqn">=2</code>, then cluster sizes will be randomly generated 
from the range specified by <code>rangeN</code>. The lower bound of the number of 
clusters should be large enough to get non-singular cluster covariance 
matrices. We recommend the minimum cluster size is at least <code class="reqn">10*p</code>, where 
<code class="reqn">p</code> is the total number of variables (including both non-noisy and noisy 
variables).  The default range is <code class="reqn">[50, 200]</code> which
can produce reasonable variability of cluster sizes.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_clustsizes">clustSizes</code></td>
<td>

<p>The sizes of clusters.
If <code>clustszind</code><code class="reqn">=3</code>, then cluster sizes will be specified by the 
vector <code>clustSizes</code>.  We recommend the minimum cluster size is at least 
<code class="reqn">10*p</code>, where <code class="reqn">p</code> is the total number of variables (including both 
non-noisy and noisy variables).
The user needs to specify the value of <code>clustSizes</code>. Therefore, we
set the default value of <code>clustSizes</code> as <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_covmethod">covMethod</code></td>
<td>

<p>Method to generate covariance matrices for clusters (see details).
The default method is 'eigen' so that the user can directly 
specify the range of the <dfn>diameters</dfn> of clusters.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_eigenvalue">eigenvalue</code></td>
<td>

<p>numeric. user-specified eigenvalues when <code>covMethod = "eigen"</code>. If <code>eigenvalue = NULL</code> and <code>covMethod = "eigen"</code>, then eigenvalues will be automatically generated.  
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_rangevar">rangeVar</code></td>
<td>

<p>Range for variances of a covariance matrix (see details).
The default range is <code class="reqn">[1, 10]</code> which can generate reasonable
variability of variances.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_lambdalow">lambdaLow</code></td>
<td>

<p>Lower bound of the eigenvalues of cluster covariance matrices. 
If the argument <code>covMethod="eigen"</code>, we need to generate eigenvalues for 
cluster covariance matrices.
The eigenvalues are randomly generated from the
interval [<code>lambdaLow</code>, <code>lambdaLow</code><code class="reqn">*</code><code>ratioLambda</code>]. 
In our experience, <code>lambdaLow</code><code class="reqn">=1</code> and <code>ratioLambda</code><code class="reqn">=10</code> 
can give reasonable variability of the diameters of clusters.
<code>lambdaLow</code> should be positive.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_ratiolambda">ratioLambda</code></td>
<td>

<p>The ratio of the upper bound of the eigenvalues to the lower bound of the 
eigenvalues of cluster covariance matrices. 
If the argument <code>covMethod="eigen"</code>, we need to generate eigenvalues for 
cluster covariance matrices.
The eigenvalues are randomly generated from the
interval [<code>lambdaLow</code>, <code>lambdaLow</code><code class="reqn">*</code><code>ratioLambda</code>]. 
In our experience, <code>lambdaLow</code><code class="reqn">=1</code> and <code>ratioLambda</code><code class="reqn">=10</code> 
can give reasonable variability of the diameters of clusters.
<code>ratioLambda</code> should be larger than <code class="reqn">1</code>.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_alphad">alphad</code></td>
<td>
<p>parameter for unifcorrmat method to generate random correlation matrix
<code>alphad=1</code> for uniform. <code>alphad</code> should be positive.</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_eta">eta</code></td>
<td>
<p>parameter for &ldquo;c-vine&rdquo; and &ldquo;onion&rdquo; methods to generate random correlation matrix
<code>eta=1</code> for uniform. <code>eta</code> should be positive.</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_rotateind">rotateind</code></td>
<td>

<p>Rotation indicator.
<code>rotateind=TRUE</code> indicates randomly rotating data in non-noisy 
dimensions so that we may not detect the full cluster structure from 
pair-wise scatter plots of the variables.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_iniprojdirmethod">iniProjDirMethod</code></td>
<td>

<p>Indicating the method to get initial projection direction when calculating
the separation index between a pair of clusters (c.f. Qiu and Joe,
2006a, 2006b). <br />
<code>iniProjDirMethod</code>=&ldquo;SL&rdquo;, the default, indicates the initial 
projection direction is the sample version of the SL's projection direction 
(Su and Liu, 1993, JASA)
<code class="reqn">\left(\boldsymbol{\Sigma}_1+\boldsymbol{\Sigma}_2\right)^{-1}\left(\boldsymbol{\mu}_2-\boldsymbol{\mu}_1\right)</code><br />
<code>iniProjDirMethod</code>=&ldquo;naive&rdquo; indicates the initial projection 
direction is <code class="reqn">\boldsymbol{\mu}_2-\boldsymbol{\mu}_1</code>
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_projdirmethod">projDirMethod</code></td>
<td>

<p>Indicating the method to get the optimal projection direction when calculating 
the separation index between a pair of clusters (c.f. Qiu and Joe,
2006a, 2006b). <br />
<code>projDirMethod</code>=&ldquo;newton&rdquo; indicates we use the modified
Newton-Raphson method to search the optimal projection direction 
(c.f. Qiu and Joe, 2006a). This requires the assumptions that both covariance 
matrices of the pair of clusters are positive-definite. If this assumption 
is violated, the &ldquo;fixedpoint&rdquo; method could be used. The 
&ldquo;fixedpoint&rdquo; method iteratively searches the optimal projection 
direction based on the first derivative of the separation index to the 
projection direction (c.f. Qiu and Joe, 2006b).
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_alpha">alpha</code></td>
<td>

<p>Tuning parameter reflecting the percentage in the two
tails of a projected cluster that might be outlying.
We set <code>alpha</code><code class="reqn">=0.05</code> like we set
the significance level in hypothesis testing as <code class="reqn">0.05</code>.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_itmax">ITMAX</code></td>
<td>

<p>Maximum iteration allowed when to iteratively calculating the
optimal projection direction.
The actual number of iterations is usually much less than the default value 20.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_eps">eps</code></td>
<td>

<p>Convergence threshold. A small positive number to check if a quantitiy <code class="reqn">q</code> 
is equal to zero.  If <code class="reqn">|q|&lt;</code><code>eps</code>, then we regard <code class="reqn">q</code> as equal 
to zero.  <code>eps</code> is used to check if an algorithm converges.
The default value is <code class="reqn">1.0e-10</code>.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_quiet">quiet</code></td>
<td>

<p>A flag to switch on/off the outputs of intermediate results and/or possible warning messages. The default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_outputdatflag">outputDatFlag</code></td>
<td>

<p>Indicates if data set should be output to file.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_outputlogflag">outputLogFlag</code></td>
<td>

<p>Indicates if log info should be output to file.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_outputempirical">outputEmpirical</code></td>
<td>

<p>Indicates if empirical separation indices and projection directions should be 
calculated. This option is useful when generating clusters with sizes which 
are not large enough so that the sample covariance matrices may be singular.
Hence, by default, <code>outputEmpirical=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="simClustDesign_+3A_outputinfo">outputInfo</code></td>
<td>

<p>Indicates if theoretical and empirical separation information data frames 
should be output to a file with format <code>[fileName]_info.log</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>simClustDesign</code> is an implementation of the design for 
generating random clusters proposed in Qiu and Joe (2006a). In the design, 
the degree of separation between any cluster and its nearest neighboring 
cluster could be set to a specified value while the cluster covariance 
matrices can be arbitrary positive definite matrices, and so that clusters 
generated might not be visualized by pair-wise scatterplots of variables. 
The separation between a pair of clusters is measured by the separation index 
proposed in Qiu and Joe (2006b).
</p>
<p>The current version of the function <code>simClustDesign</code> implements two 
methods to generate covariance matrices for clusters. The first method, 
denoted by <code>eigen</code>, first randomly generates eigenvalues 
(<code class="reqn">\lambda_1,\ldots&gt;\lambda_p</code>) for the covariance matrix 
(<code class="reqn">\boldsymbol{\Sigma}</code>), then uses columns of a randomly generated 
orthogonal matrix 
(<code class="reqn">\boldsymbol{Q}=(\boldsymbol{\alpha}_1,\ldots,\boldsymbol{\alpha}_p)</code>) 
as eigenvectors. The covariance matrix 
<code class="reqn">\boldsymbol{\Sigma}</code> is then contructed as 
<code class="reqn">\boldsymbol{Q}*diag(\lambda_1,\dots,\lambda_p)*\boldsymbol{Q}^T</code>.
The second method, denoted as <code>unifcorrmat</code>, first generates a random
correlation matrix (<code class="reqn">\boldsymbol{R}</code>) via the method proposed in Joe (2006),
then randomly generates variances (<code class="reqn">\sigma_1^2,\ldots, \sigma_p^2</code>) from 
an interval specified by the argument <code>rangeVar</code>. The covariance matrix 
<code class="reqn">\boldsymbol{\Sigma}</code> is then constructed as 
<code class="reqn">diag(\sigma_1,\ldots,\sigma_p)*\boldsymbol{R}*diag(\sigma_1,\ldots,\sigma_p)</code>.
</p>
<p>For each data set generated, the function <code>simClustDesign</code> outputs
four files: data file, log file, membership file, and noisy set file. 
All four files have the same format: <br />
<code>[fileName]J[j]G[g]v[p1]nv[p2]out[numOutlier]_[numReplicate].[extension]</code> 
<br />
where &lsquo;<span class="file">extension</span>&rsquo; can be &lsquo;<span class="file">dat</span>&rsquo;, &lsquo;<span class="file">log</span>&rsquo;, &lsquo;<span class="file">mem</span>&rsquo;, or 
&lsquo;<span class="file">noisy</span>&rsquo;. &lsquo;J&rsquo; indicates separation index, with &lsquo;j&rsquo; 
indicating the level of the factor &lsquo;separation index&rsquo;; 
&lsquo;G&rsquo; indicates number of clusters, with &lsquo;g&rsquo; indicating the 
level of the factor &lsquo;number of clusters&rsquo;; &lsquo;v&rsquo; indicates 
the number of non-noisy variables, with &lsquo;p1&rsquo; indicating the level 
of the factor &lsquo;number of non-noisy variables&rsquo;; &lsquo;nv&rsquo; indicates 
the number of noisy variables, with &lsquo;p2&rsquo; indicating the level of 
the factor &lsquo;number of noisy variables&rsquo;; &lsquo;out&rsquo; indicates  
number of outliers, with &lsquo;numOutlier&rsquo; indicating the value of the 
argument <code>numOutlier</code> of the function <code>simClustDesign</code>; 
&lsquo;numReplicate&rsquo; indicates the value of the argument <code>numReplicate</code> 
of the function <code>simClustDesign</code>.
</p>
<p>The data file with file extension &lsquo;<span class="file">dat</span>&rsquo; contains <code class="reqn">n+1</code> rows and 
<code class="reqn">p</code> columns, where <code class="reqn">n</code> is the number of data points and <code class="reqn">p</code> is 
the number of variables. The first row is the variable names. The log file 
with file extension &lsquo;<span class="file">log</span>&rsquo; contains information such as cluster sizes, 
mean vectors, covariance matrices, projection directions, separation index 
matrices, etc. The membership file with file extension &lsquo;<span class="file">mem</span>&rsquo; contains 
<code class="reqn">n</code> rows and one column of cluster memberships for data points. The noisy 
set file with file extension &lsquo;<span class="file">noisy</span>&rsquo; contains a row of labels of noisy 
variables.
</p>
<p>When generating clusters, population covariance matrices are all 
positive-definite. However sample covariance matrices might be 
semi-positive-definite due to small cluster sizes. In this case, the 
function <code>genRandomClust</code> will automatically use the 
&ldquo;fixedpoint&rdquo; method to search the optimal projection direction.
</p>


<h3>Value</h3>

<p>The function outputs four data files for each data set (see details).
</p>
<p>This function also returns separation information data frames 
<code>infoFrameTheory</code> and <code>infoFrameData</code> based on population 
and empirical mean vectors and covariance matrices of clusters for all 
the data sets generated. Both <code>infoFrameTheory</code> and <code>infoFrameData</code> 
contain the following seven columns:
</p>
<table role = "presentation">
<tr><td><code>Column 1:</code></td>
<td>

<p>Labels of clusters (<code class="reqn">1, 2, \ldots, numClust</code>), where <code class="reqn">numClust</code> 
is the number of clusters for the data set.
</p>
</td></tr>
<tr><td><code>Column 2:</code></td>
<td>

<p>Labels of the corresponding nearest neighbors.
</p>
</td></tr>
<tr><td><code>Column 3:</code></td>
<td>

<p>Separation indices of the clusters to their nearest neighboring clusters.
</p>
</td></tr>
<tr><td><code>Column 4:</code></td>
<td>

<p>Labels of the corresponding farthest neighboring clusters.
</p>
</td></tr>
<tr><td><code>Column 5:</code></td>
<td>

<p>Separation indices of the clusters to their farthest neighbors.
</p>
</td></tr>
<tr><td><code>Column 6:</code></td>
<td>

<p>Median separation indices of the clusters to their neighbors.
</p>
</td></tr>
<tr><td><code>Column 7:</code></td>
<td>

<p>Data file names with format 
<code>[fileName]J[j]G[g]v[p1]nv[p2]out[numOutlier]_[numReplicate]</code> (see details).
</p>
</td></tr>
</table>
<p>The function also returns three lists: <code>datList</code>, <code>memList</code>, and <code>noisyList</code>.
</p>
<table role = "presentation">
<tr><td><code>datList:</code></td>
<td>

<p>a list of lists of data matrices for generated data sets.
</p>
</td></tr>
<tr><td><code>memList:</code></td>
<td>

<p>a list of lists of cluster memberships for data points for generated data sets.
</p>
</td></tr>
<tr><td><code>noisyList:</code></td>
<td>

<p>a list of lists of sets of noisy variables for generated data sets.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The speed of this function might be slow.</p>


<h3>Author(s)</h3>

<p>Weiliang Qiu <a href="mailto:weiliang.qiu@gmail.com">weiliang.qiu@gmail.com</a><br />
Harry Joe <a href="mailto:harry@stat.ubc.ca">harry@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>Joe, H. (2006)
Generating Random Correlation Matrices Based on Partial Correlations. 
<em>Journal of Multivariate Analysis</em>, <b>97</b>, 2177&ndash;2189.
</p>
<p>Milligan G. W. (1985) 
An Algorithm for Generating Artificial Test Clusters.
<em>Psychometrika</em> <b>50</b>, 123&ndash;127.
</p>
<p>Qiu, W.-L. and Joe, H. (2006a)
Generation of Random Clusters with Specified Degree of Separaion.
<em>Journal of Classification</em>, <b>23</b>(2), 315-334.
</p>
<p>Qiu, W.-L. and Joe, H. (2006b)
Separation Index and Partial Membership for Clustering.
<em>Computational Statistics and Data Analysis</em>, <b>50</b>, 585&ndash;603.
</p>
<p>Su, J. Q. and Liu, J. S. (1993)
Linear Combinations of Multiple Diagnostic Markers.
<em>Journal of the American Statistical Association</em>, <b>88</b>, 1350&ndash;1355
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tmp &lt;- simClustDesign(
		      numClust = 3, 
                      sepVal = c(0.01, 0.21), 
                      sepLabels = c("L", "M"), 
                      numNonNoisy = 4, 
                      numOutlier = 0, 
                      numReplicate = 2, 
                      clustszind = 2)
## End(Not run)
</code></pre>

<hr>
<h2 id='viewClusters'>PLOT ALL CLUSTERS IN A 2-D PROJECTION SPACE</h2><span id='topic+viewClusters'></span>

<h3>Description</h3>

<p>Plot all clusters in a 2-D projection space. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewClusters(
	     y, 
	     cl, 
	     outlierLabel = 0,
             projMethod = "Eigen", 
	     xlim = NULL, 
	     ylim = NULL,
             xlab = "1st projection direction", 
             ylab = "2nd projection direction", 
             title = "Scatter plot of 2-D Projected Clusters",
             font = 2, 
	     font.lab = 2, 
	     cex = 1.2, 
	     cex.lab = 1.2) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viewClusters_+3A_y">y</code></td>
<td>

<p>Data matrix. Rows correspond to observations. Columns correspond to variables.
</p>
</td></tr>
<tr><td><code id="viewClusters_+3A_cl">cl</code></td>
<td>

<p>Cluster membership vector.
</p>
</td></tr>
<tr><td><code id="viewClusters_+3A_outlierlabel">outlierLabel</code></td>
<td>

<p>Label for outliers. Outliers are not involved in calculating the projection
directions. Outliers will be represented by red triangles in the plot.
By default, <code>outlierLabel=0</code>.
</p>
</td></tr>
<tr><td><code id="viewClusters_+3A_projmethod">projMethod</code></td>
<td>

<p>Method to construct 2-D projection directions. 
<code>projMethod="Eigen"</code> indicates that we project data to the 
2-dimensional space spanned by the first two eigenvectors of the 
between cluster distance matrix 
<code class="reqn">B={2\over k_0}\sum_{i=1}^{k_0}\Sigma_i+{2\over
k_0(k_0-1)}\sum_{i&lt;j}(\theta_i-\theta_j) (\theta_i-\theta_j)^T</code>.
<code>projMethod="DMS"</code> indicates that we project data to the 
2-dimensional space spanned by the first two eigenvectors of the 
between cluster distance matrix 
<code class="reqn">B=\sum_{i=2}^{k_0}\sum_{j=1}^{i-1}
n_i n_j(\theta_i-\theta_j)(\theta_i-\theta_j)^T</code>. 
&ldquo;DMS&rdquo; method is proposed by Dhillon et al. (2002).
</p>
</td></tr>
<tr><td><code id="viewClusters_+3A_xlim">xlim</code></td>
<td>

<p>Range of X axis.
</p>
</td></tr>
<tr><td><code id="viewClusters_+3A_ylim">ylim</code></td>
<td>

<p>Range of Y axis.
</p>
</td></tr>
<tr><td><code id="viewClusters_+3A_xlab">xlab</code></td>
<td>

<p>X axis label.
</p>
</td></tr>
<tr><td><code id="viewClusters_+3A_ylab">ylab</code></td>
<td>

<p>Y axis label.
</p>
</td></tr>
<tr><td><code id="viewClusters_+3A_title">title</code></td>
<td>

<p>Title of the plot.
</p>
</td></tr>
<tr><td><code id="viewClusters_+3A_font">font</code></td>
<td>

<p>An integer which specifies which font to use for text (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="viewClusters_+3A_font.lab">font.lab</code></td>
<td>

<p>The font to be used for x and y labels (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="viewClusters_+3A_cex">cex</code></td>
<td>

<p>A numerical value giving the amount by which plotting text
and symbols should be scaled relative to the default (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="viewClusters_+3A_cex.lab">cex.lab</code></td>
<td>

<p>The magnification to be used for x and y labels relative
to the current setting of 'cex' (see <code>par</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>B</code></td>
<td>

<p>Between cluster distance matrix measuring the between cluster variation.
</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>

<p>Columns of <code>Q</code> are eigenvectors of the matrix <code>B</code>.
</p>
</td></tr>
<tr><td><code>proj</code></td>
<td>

<p>Projected clusters in the 2-D space spanned by the first 2 columns of
the matrix <code>Q</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Weiliang Qiu <a href="mailto:weiliang.qiu@gmail.com">weiliang.qiu@gmail.com</a><br />
Harry Joe <a href="mailto:harry@stat.ubc.ca">harry@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>Dhillon I. S., Modha, D. S. and Spangler, W. S. (2002)
Class visualization of high-dimensional data with applications.
<em>computational Statistics and Data Analysis</em>, <b>41</b>, 59&ndash;90.
</p>
<p>Qiu, W.-L. and Joe, H. (2006)
Separation Index and Partial Membership for Clustering.
<em>Computational Statistics and Data Analysis</em>, <b>50</b>, 585&ndash;603.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot1DProjection">plot1DProjection</a></code>
<code><a href="#topic+plot2DProjection">plot2DProjection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 50
mu1 &lt;- c(0, 0)
Sigma1 &lt;- matrix(c(2, 1, 1, 5), 2, 2)
n2 &lt;- 100
mu2 &lt;- c(10, 0)
Sigma2 &lt;- matrix(c(5, -1, -1, 2), 2, 2)
n3 &lt;- 30
mu3 &lt;- c(10, 10)
Sigma3 &lt;- matrix(c(3, 1.5, 1.5, 1), 2, 2)
n4 &lt;- 10
mu4 &lt;- c(0, 0)
Sigma4 &lt;- 50*diag(2)

library(MASS)
set.seed(1234)
y1 &lt;- mvrnorm(n1, mu1, Sigma1)
y2 &lt;- mvrnorm(n2, mu2, Sigma2)
y3 &lt;- mvrnorm(n3, mu3, Sigma3)
y4 &lt;- mvrnorm(n4, mu4, Sigma4)
y &lt;- rbind(y1, y2, y3, y4)
cl &lt;- rep(c(1:3, 0), c(n1, n2, n3, n4))

par(mfrow=c(2,1))
viewClusters(y = y, cl = cl)
viewClusters(y = y, cl = cl, projMethod = "DMS")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
