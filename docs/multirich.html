<!DOCTYPE html><html><head><title>Help for package multirich</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multirich}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#multirich-package'><p>multirich (package)</p></a></li>
<li><a href='#calc.mvd'><p>Calculate multivariate richness and functional overlap</p></a></li>
<li><a href='#calc.mvo'><p>Calculate functional overlap</p></a></li>
<li><a href='#check.breaks'><p>Check breaks</p></a></li>
<li><a href='#check.traits'><p>Check trait</p></a></li>
<li><a href='#data.preprocess'><p>Preprocess data</p></a></li>
<li><a href='#df.categorize'><p>Categorize data</p></a></li>
<li><a href='#expand.breaks'><p>Expand trait breaks</p></a></li>
<li><a href='#get.breaks'><p>Function to calculate break points for a trait</p></a></li>
<li><a href='#get.traitspace'><p>Calculate trait space (simple)</p></a></li>
<li><a href='#listtotext'><p>List to text</p></a></li>
<li><a href='#make.trait'><p>Make trait</p></a></li>
<li><a href='#matrix.check'><p>Check that input to mvfd is in matrix format</p></a></li>
<li><a href='#mvfd'><p>mvfd Main function to calculate functional richness</p></a></li>
<li><a href='#part.mvr.beta'><p>Partition multivariate richness Beta Component</p></a></li>
<li><a href='#plot.sensitivity'><p>Plot sensitivity analysis results</p></a></li>
<li><a href='#sensitivity.analysis'><p>Sensitivity Analysis</p></a></li>
<li><a href='#sensitivity.boxplots'><p>Make boxplots based on multiple simulations</p></a></li>
<li><a href='#utc.sim'><p>Sensitivity Simulator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculate Multivariate Richness via UTC and sUTC</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Keyel</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Keyel &lt;skeyel@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to calculate Unique Trait Combinations (UTC) and scaled
    Unique Trait Combinations (sUTC) as measures of multivariate richness. The
    package can also calculate beta-diversity for trait richness and can
    partition this into nestedness-related and turnover components. The code
    will also calculate several measures of overlap. See Keyel and Wiegand
    (2016) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12558">doi:10.1111/2041-210X.12558</a>&gt; for more details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, qpdf</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-14 15:36:49 UTC; ak697777</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-14 23:30:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='multirich-package'>multirich (package)</h2><span id='topic+multirich-package'></span>

<h3>Description</h3>

<p>Package to calculate the number of unique trait combinations and scale the
number of unique trait combinations by the total number of trait combinations
possible as measures of multivariate richness.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> 
Package: </td><td style="text-align: left;"> multirich</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-09-14</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 (or later)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alexander &quot;Sasha&quot; Keyel<br />
Maintainer: Sasha Keyel &lt;skeyel@gmail.com&gt;
</p>


<h3>References</h3>

<p>Keyel, A.C. and K. Wiegand. (in review) Validating the use of
Unique Trait Combinations for measuring multivariate functional richness.
</p>

<hr>
<h2 id='calc.mvd'>Calculate multivariate richness and functional overlap</h2><span id='topic+calc.mvd'></span>

<h3>Description</h3>

<p>Function to reduce to functional units, and calculate multivariate richness
and functional overlap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.mvd(in.mat, in.com, traitspace, calc.ovr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.mvd_+3A_in.mat">in.mat</code></td>
<td>
<p>A record by trait matrix</p>
</td></tr>
<tr><td><code id="calc.mvd_+3A_in.com">in.com</code></td>
<td>
<p>A record by community matrix</p>
</td></tr>
<tr><td><code id="calc.mvd_+3A_traitspace">traitspace</code></td>
<td>
<p>The total trait space for scaling purposes</p>
</td></tr>
<tr><td><code id="calc.mvd_+3A_calc.ovr">calc.ovr</code></td>
<td>
<p>An indicator for whether overlap metrics should be calculated</p>
</td></tr>
</table>

<hr>
<h2 id='calc.mvo'>Calculate functional overlap</h2><span id='topic+calc.mvo'></span>

<h3>Description</h3>

<p>Calculate functional overlap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.mvo(in.mat, dups)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.mvo_+3A_in.mat">in.mat</code></td>
<td>
<p>a record x trait matrix</p>
</td></tr>
<tr><td><code id="calc.mvo_+3A_dups">dups</code></td>
<td>
<p>dups indicate which records in the record x trait matrix are duplicates</p>
</td></tr>
</table>

<hr>
<h2 id='check.breaks'>Check breaks</h2><span id='topic+check.breaks'></span>

<h3>Description</h3>

<p>Check that break point lists are all the same length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.breaks(breaks, in.mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.breaks_+3A_breaks">breaks</code></td>
<td>
<p>A list containing break points to use for each continuous trait.
Categorical traits are unmodified, and should be a list containing the text &quot;cat&quot;</p>
</td></tr>
<tr><td><code id="check.breaks_+3A_in.mat">in.mat</code></td>
<td>
<p>A record x trait matrix</p>
</td></tr>
</table>

<hr>
<h2 id='check.traits'>Check trait</h2><span id='topic+check.traits'></span>

<h3>Description</h3>

<p>Check trait for compatibility with assembly procedure &amp; adjust as necessary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.traits(in.mat, tr1.lim, tr2.lim, sim.type, filter.vals = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.traits_+3A_in.mat">in.mat</code></td>
<td>
<p>A record x trait matrix</p>
</td></tr>
<tr><td><code id="check.traits_+3A_tr1.lim">tr1.lim</code></td>
<td>
<p>The minimum and maximum allowable values for trait 1</p>
</td></tr>
<tr><td><code id="check.traits_+3A_tr2.lim">tr2.lim</code></td>
<td>
<p>The minimum and maximum allowable values for trait 2</p>
</td></tr>
<tr><td><code id="check.traits_+3A_sim.type">sim.type</code></td>
<td>
<p>&quot;random&quot; runs random assembly (or if any sim.type other than limiting or filter is specified), &quot;limiting&quot; runs limiting similarity, and &quot;filter&quot; applies an environmental filter.</p>
</td></tr>
<tr><td><code id="check.traits_+3A_filter.vals">filter.vals</code></td>
<td>
<p>Vector of filter values in text form with a semi-colon delimiter (sorry!) e.g., c(&quot;1,1&quot;, &quot;1;2&quot;) would only allow values of 1,1 and 2,2 in the data.</p>
</td></tr>
<tr><td><code id="check.traits_+3A_tr1">tr1</code></td>
<td>
<p>Trait values for trait 1</p>
</td></tr>
<tr><td><code id="check.traits_+3A_tr2">tr2</code></td>
<td>
<p>Trait values for trait 2</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is very inefficient &amp; could be optimized!
</p>

<hr>
<h2 id='data.preprocess'>Preprocess data</h2><span id='topic+data.preprocess'></span>

<h3>Description</h3>

<p>Preprocess data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.preprocess(in.mat, log.trans = 0, st.range = 0, col.mins, col.maxs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.preprocess_+3A_in.mat">in.mat</code></td>
<td>
<p>A record x trait matrix</p>
</td></tr>
<tr><td><code id="data.preprocess_+3A_log.trans">log.trans</code></td>
<td>
<p>Whether or not to do a log transformation. It is recommended to do all log-transformations outside of the multirich package.</p>
</td></tr>
<tr><td><code id="data.preprocess_+3A_st.range">st.range</code></td>
<td>
<p>Must equal zero. This option may be added in future versions of the package</p>
</td></tr>
<tr><td><code id="data.preprocess_+3A_col.mins">col.mins</code></td>
<td>
<p>Minimum column values to use. &quot;use data&quot; will extract these from the dataset</p>
</td></tr>
<tr><td><code id="data.preprocess_+3A_col.maxs">col.maxs</code></td>
<td>
<p>Maximum column values to use. &quot;use data&quot; will extract these from the dataset</p>
</td></tr>
</table>

<hr>
<h2 id='df.categorize'>Categorize data</h2><span id='topic+df.categorize'></span>

<h3>Description</h3>

<p>Currently by rounding, which is a sub-optimal approach for many questions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df.categorize(in.mat, cell.res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df.categorize_+3A_in.mat">in.mat</code></td>
<td>
<p>A record x trait matrix</p>
</td></tr>
<tr><td><code id="df.categorize_+3A_cell.res">cell.res</code></td>
<td>
<p>The number of decimal places to round the data to.</p>
</td></tr>
</table>

<hr>
<h2 id='expand.breaks'>Expand trait breaks</h2><span id='topic+expand.breaks'></span>

<h3>Description</h3>

<p>Function to match longer lists of trait breaks. This may be a sub-optimal solution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.breaks(in.lst, target.reps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.breaks_+3A_in.lst">in.lst</code></td>
<td>
<p>the list of trait breakpoints to be expanded</p>
</td></tr>
<tr><td><code id="expand.breaks_+3A_target.reps">target.reps</code></td>
<td>
<p>the target length of the trait breakpoint list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an expanded list of trait breakpoints
</p>

<hr>
<h2 id='get.breaks'>Function to calculate break points for a trait</h2><span id='topic+get.breaks'></span>

<h3>Description</h3>

<p>takes range of values, and then creates break points for all possible sub-categorizations of those values
WARNING: Currently only gives breakpoints for integer values!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.breaks(min.val, max.val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.breaks_+3A_min.val">min.val</code></td>
<td>
<p>The minimum value to be used. Can be taken from the data, or can be based on a priori knowledge</p>
</td></tr>
<tr><td><code id="get.breaks_+3A_max.val">max.val</code></td>
<td>
<p>The maximum value to be used in generating break points. Can be taken from the data or can be based on a priori knowledge.</p>
</td></tr>
</table>

<hr>
<h2 id='get.traitspace'>Calculate trait space (simple)</h2><span id='topic+get.traitspace'></span>

<h3>Description</h3>

<p>Function to calculate the traitspace using minimum and maximum column values.
Creates a hypercubic traitspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.traitspace(in.mat, col.res, col.mins, col.maxs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.traitspace_+3A_in.mat">in.mat</code></td>
<td>
<p>A record x trait matrix</p>
</td></tr>
<tr><td><code id="get.traitspace_+3A_col.res">col.res</code></td>
<td>
<p>The number of decimal places to use for rounding (resolution) purposes</p>
</td></tr>
<tr><td><code id="get.traitspace_+3A_col.mins">col.mins</code></td>
<td>
<p>The minimum values to use for the trait space. &quot;use data&quot; extracts minimums from in.mat</p>
</td></tr>
<tr><td><code id="get.traitspace_+3A_col.maxs">col.maxs</code></td>
<td>
<p>The maximum values to use for the trait space. &quot;use data&quot; extracts maximums from in.mat</p>
</td></tr>
</table>

<hr>
<h2 id='listtotext'>List to text</h2><span id='topic+listtotext'></span>

<h3>Description</h3>

<p>Take a list (or vector) and convert it to text separated by separator.
Does not work for nested lists
ORIGINALLY FROM MYR.R script
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listtotext(inlist, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listtotext_+3A_inlist">inlist</code></td>
<td>
<p>An unnested list</p>
</td></tr>
<tr><td><code id="listtotext_+3A_sep">sep</code></td>
<td>
<p>A separator to separate elements of the list.</p>
</td></tr>
</table>

<hr>
<h2 id='make.trait'>Make trait</h2><span id='topic+make.trait'></span>

<h3>Description</h3>

<p>Create integer trait values from a uniform random distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.trait(trlim, n.recs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.trait_+3A_trlim">trlim</code></td>
<td>
<p>A vector containing the minimum and maximum values for the trait</p>
</td></tr>
<tr><td><code id="make.trait_+3A_n.recs">n.recs</code></td>
<td>
<p>The number of trait values to create for trait</p>
</td></tr>
</table>

<hr>
<h2 id='matrix.check'>Check that input to mvfd is in matrix format</h2><span id='topic+matrix.check'></span>

<h3>Description</h3>

<p>Check that input to mvfd is in matrix format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.check(in.mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.check_+3A_in.mat">in.mat</code></td>
<td>
<p>An input to be tested for matrix formatting</p>
</td></tr>
</table>

<hr>
<h2 id='mvfd'>mvfd Main function to calculate functional richness</h2><span id='topic+mvfd'></span>

<h3>Description</h3>

<p>Main function to calculate multivariate richness.
Goal is to mirror format of dbfd from Laliberte &amp; Shipley 2011.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvfd(
  in.mat,
  in.com = "none",
  unequal.abund = F,
  resolution = 0,
  st.range = 0,
  log.trans = 0,
  col.mins = "use data",
  col.maxs = "use data",
  traitspace = "use data",
  calc.ovr = 1,
  force.matrix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvfd_+3A_in.mat">in.mat</code></td>
<td>
<p>A record x trait matrix.  Needs to be in matrix format, not as a dataframe</p>
</td></tr>
<tr><td><code id="mvfd_+3A_in.com">in.com</code></td>
<td>
<p>A community x species matrix.  If only one community with all the species is considered, you can enter &quot;none&quot;, and the code will auto-create the community needed for the script.</p>
</td></tr>
<tr><td><code id="mvfd_+3A_unequal.abund">unequal.abund</code></td>
<td>
<p>A feature not currently in script, intended as an option to indicate whether abundance data should be incorporated.</p>
</td></tr>
<tr><td><code id="mvfd_+3A_resolution">resolution</code></td>
<td>
<p>This input controls rounding of the data (categorization was acheived by rounding for simplicity).  0 indicates integers, 1 = 1 decimal place, 2 = 2 decimal places, -1 = 10's place., etc.)</p>
</td></tr>
<tr><td><code id="mvfd_+3A_st.range">st.range</code></td>
<td>
<p>Option to control range standardization.  This was never properly scripted and should remain 0.  Any desired range transformations should be done prior to this script.</p>
</td></tr>
<tr><td><code id="mvfd_+3A_log.trans">log.trans</code></td>
<td>
<p>Option to control whether or not data are log transformed.  This has not been properly tested as I found it easier to log-transform the data manually in Excel.</p>
</td></tr>
<tr><td><code id="mvfd_+3A_col.mins">col.mins</code></td>
<td>
<p>If option is &quot;use data&quot; the function will get the minimum from the data.  Otherwise a vector of minimum values to use can be specified</p>
</td></tr>
<tr><td><code id="mvfd_+3A_col.maxs">col.maxs</code></td>
<td>
<p>If option is &quot;use data&quot; the function will get the maximum values from the data.  Otherwise a vector of maximum values can be specified.</p>
</td></tr>
<tr><td><code id="mvfd_+3A_traitspace">traitspace</code></td>
<td>
<p>If set to &quot;use data&quot;, the function will estimate the traitspace as the product of trait ranges.  Otherwise, the specified traitspace will be used for scaling (e.g., if you want to input a traitspace based on a convex hull)</p>
</td></tr>
<tr><td><code id="mvfd_+3A_calc.ovr">calc.ovr</code></td>
<td>
<p>An option to determine whether overlap is calculated.  This may be slow or buggy, so in some cases it may be easier to turn it off.</p>
</td></tr>
<tr><td><code id="mvfd_+3A_force.matrix">force.matrix</code></td>
<td>
<p>an option to determine whether to try to force an input into matrix format</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently takes a record x trait matrix and an optional community matrix.
</p>


<h3>Author(s)</h3>

<p>A.C. Keyel
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare functional diveristy between species using the Iris dataset
ind.mat = iris
ind.mat$Species = NULL
ind.lbl = sprintf("Ind_%s",seq(1,nrow(iris)))
ind.mat = as.matrix(ind.mat) #Needs to be in matrix format
rownames(ind.mat) = ind.lbl
com.base = iris$Species
pool = rep(1,nrow(iris))
com1 = sapply(com.base, function(x){ifelse(x == "setosa",1,0)})
com2 = sapply(com.base, function(x){ifelse(x == "versicolor",1,0)})
com3 = sapply(com.base, function(x){ifelse(x == "virginica",1,0)})
com.vec = c(pool,com1,com2,com3)
com.lbl = c("pool","com1","com2","com3")
com.mat = matrix(com.vec,nrow = 4,byrow = TRUE,dimnames = list(com.lbl,ind.lbl))

mvr.out = mvfd(ind.mat,com.mat)
</code></pre>

<hr>
<h2 id='part.mvr.beta'>Partition multivariate richness Beta Component</h2><span id='topic+part.mvr.beta'></span>

<h3>Description</h3>

<p>Function to calculate dissimilarity between a pair of communities, and
partition it into nestedness-related &amp; turnover components  
Either the Sorensen index or the Jaccard index can be used to calculate dissimilarity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part.mvr.beta(in.mat, in.com, index.rows, index.type = "Sorensen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="part.mvr.beta_+3A_in.mat">in.mat</code></td>
<td>
<p>A record x trait matrix.  Needs to be in matrix format, not as a dataframe</p>
</td></tr>
<tr><td><code id="part.mvr.beta_+3A_in.com">in.com</code></td>
<td>
<p>A community x record matrix</p>
</td></tr>
<tr><td><code id="part.mvr.beta_+3A_index.rows">index.rows</code></td>
<td>
<p>A vector with 2 elements, that gives the row number for the
pair of communities of interest.</p>
</td></tr>
<tr><td><code id="part.mvr.beta_+3A_index.type">index.type</code></td>
<td>
<p>specifies which index to use. Options are Sorensen (default) &amp; Jaccard</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> aa Overlap between the two communities
</p>
</li>
<li><p> dissimilarity Dissimilarity between the two communities
</p>
</li>
<li><p> turnover This gives the turnover between the two communities.  To get the percent of dissimilarity due to turnover, divide by total dissimilarity.
</p>
</li>
<li><p> Bnes Nestedness-related dissimilarity between the two communities.  To get the percent of dissimilarity due to this, divide by total dissimilarity.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>A.C. Keyel
</p>


<h3>References</h3>

<p>Baselga, A. 2010. Partitioning the turnover and nestedness components of beta diversity.  Global Ecology and Biogeography 19: 134-143<br />
Baselga, A. 2012. The relationship between species replacement, dissimilarity derived from nestedness, and nestedness.  Global Ecology and Biogeography 21: 1223-1232<br />
Villeger, S. Grenouillet, G., and Brosse, S. 2013.  Decomposing functional Beta-diversity reveals that low functional Beta-diversity is driven by low functional turnover in European fish assemblages.  Global Ecology and Biogeography 22: 671-681.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Partition beta diversity for two species in the iris dataset

# Set up record x trait matrix
ind.mat = iris
ind.mat$Species = NULL
ind.lbl = sprintf("Ind_%s",seq(1,nrow(iris)))
ind.mat = as.matrix(ind.mat) #Needs to be in matrix format
rownames(ind.mat) = ind.lbl

# Set up community matrix
com.base = iris$Species
pool = rep(1,nrow(iris))
com1 = sapply(com.base, function(x){ifelse(x == "setosa",1,0)})
com2 = sapply(com.base, function(x){ifelse(x == "versicolor",1,0)})
com3 = sapply(com.base, function(x){ifelse(x == "virginica",1,0)})
com.vec = c(pool,com1,com2,com3)
com.lbl = c("pool","com1","com2","com3") 
com.mat = matrix(com.vec, nrow = 4,byrow = TRUE,dimnames = list(com.lbl,ind.lbl))

# Specify the communities to compare
index.rows = c(2,4) #compare species 1 &amp; 3 (+1 due to the pool being the first community)

# Do the diversity partitioning
part.out = part.mvr.beta(ind.mat,com.mat,index.rows,index.type = "Sorensen")
  com.overlap = part.out[[1]]
  #0: no overlap
  com.dis = part.out[[2]]
  #1: complete dissimilarity
  com.turn = part.out[[3]]
  #1: This gives the absolute amount of dissimilarity due to turnover.
  # For percent dissimilarity due to turnover, you need to divide by overall dissimilarity
  com.nest = part.out[[4]]
  #0: This gives the absolute amount of dissimilarity due to nestedness.
  # For percent, divide by total dissimilarity
</code></pre>

<hr>
<h2 id='plot.sensitivity'>Plot sensitivity analysis results</h2><span id='topic+plot.sensitivity'></span>

<h3>Description</h3>

<p>Goal is to create a plot similar to a ROC plot, where at one side, everything is in a single
category, and on the other end, everything is in its own category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sensitivity'
plot(sutc.vals, traitspaces, n, com.names = "none", in.pdf = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sensitivity_+3A_sutc.vals">sutc.vals</code></td>
<td>
<p>A list containing scaled unique trait combinations (see above)</p>
</td></tr>
<tr><td><code id="plot.sensitivity_+3A_traitspaces">traitspaces</code></td>
<td>
<p>A vector containing the traitspace for each combination value</p>
</td></tr>
<tr><td><code id="plot.sensitivity_+3A_n">n</code></td>
<td>
<p>The sample size of the trait x record matrix</p>
</td></tr>
<tr><td><code id="plot.sensitivity_+3A_com.names">com.names</code></td>
<td>
<p>The names of the communities being evaluated (for labeling purposes)</p>
</td></tr>
<tr><td><code id="plot.sensitivity_+3A_in.pdf">in.pdf</code></td>
<td>
<p>A pdf file to be generated, containing the two plots. &quot;none&quot; skips generating a pdf, and &quot;no.plot&quot; disables the function</p>
</td></tr>
</table>

<hr>
<h2 id='sensitivity.analysis'>Sensitivity Analysis</h2><span id='topic+sensitivity.analysis'></span>

<h3>Description</h3>

<p>Run a sensitivity analysis on the data to see to what extent richness is sensitive to choice
of break points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensitivity.analysis(
  in.mat,
  in.com,
  breaks,
  out.pdf,
  in.traitspaces = "use data"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivity.analysis_+3A_in.mat">in.mat</code></td>
<td>
<p>A record x trait matrix</p>
</td></tr>
<tr><td><code id="sensitivity.analysis_+3A_in.com">in.com</code></td>
<td>
<p>A community x record matrix</p>
</td></tr>
<tr><td><code id="sensitivity.analysis_+3A_breaks">breaks</code></td>
<td>
<p>A list containing break points to use for each trait. Categorical
traits are unmodified, and should be a list containing the text &quot;cat&quot; and the number of categories.
e.g., list(&quot;cat&quot;,2). For non-categorical traits, this list needs to contain the same number
of elements for each trait. See example below for format.</p>
</td></tr>
<tr><td><code id="sensitivity.analysis_+3A_out.pdf">out.pdf</code></td>
<td>
<p>A pdf to be created containing the results of the sensitivity analysis.
&quot;none&quot; plots to the active R window. &quot;no.plot&quot; will disable the plot entirely.</p>
</td></tr>
<tr><td><code id="sensitivity.analysis_+3A_in.traitspaces">in.traitspaces</code></td>
<td>
<p>a vector of trait spaces, if pre-existing trait spaces are desired. Otherwise, 
the default of 'use data' will calculate traitspaces based on the range of values present in the data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example of a sensitivity analysis using simulated traits

# Set up example
#Adding 0.5 is to give even probabilities when rounding
n.recs = 10
tr1 = round(runif(n.recs,1 - 0.5, 10 +0.5),0) 
tr2 = round(runif(n.recs,1 - 0.5, 4 + 0.5),0)

# Set up row &amp; col names
row.nams = sprintf("Record_%s", seq(1,n.recs))
col.nams = c("tr1","tr2")

#Create matrix
in.mat = matrix(c(tr1,tr2), ncol = 2, dimnames = list(row.nams, col.nams))

# Get break points
tr1.breaks = get.breaks(1,10)
tr2.breaks = get.breaks(1,4)
tr2.breaks = expand.breaks(tr2.breaks, 9)

breaks = list(tr1.breaks, tr2.breaks)

# Actually run sensitivity analysis
# Note that the plot &amp; results will vary as this depends on random numbers
results = sensitivity.analysis(in.mat,"none", breaks, "none")

</code></pre>

<hr>
<h2 id='sensitivity.boxplots'>Make boxplots based on multiple simulations</h2><span id='topic+sensitivity.boxplots'></span>

<h3>Description</h3>

<p>Takes the output results from multiple simulation iterations and plots boxplots displaying the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensitivity.boxplots(results.mat, traitspaces, n.recs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivity.boxplots_+3A_results.mat">results.mat</code></td>
<td>
<p>An input matrix with ncol equal to the number of elements in traitspaces,
and a given row containing the values for each trait space for that simulation run.</p>
</td></tr>
<tr><td><code id="sensitivity.boxplots_+3A_traitspaces">traitspaces</code></td>
<td>
<p>A vector identifying the traitspaces at which the simulation analysis was carried out</p>
</td></tr>
<tr><td><code id="sensitivity.boxplots_+3A_n.recs">n.recs</code></td>
<td>
<p>The number of records in the original matrix.
This is the point where if every record were unique, the entire traitspace would be full.</p>
</td></tr>
</table>

<hr>
<h2 id='utc.sim'>Sensitivity Simulator</h2><span id='topic+utc.sim'></span>

<h3>Description</h3>

<p>Function to help run simulations for sensitivity analysis.
Note that for simplicity, the number of traits is restricted to two, each with the same range of values, as can be done for real traits by standardizing by range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utc.sim(
  n.reps,
  n.recs,
  tr1.lim,
  tr2.lim,
  sim.type = "random",
  filter.vals = "none"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utc.sim_+3A_n.reps">n.reps</code></td>
<td>
<p>The number of replicates for the simulation</p>
</td></tr>
<tr><td><code id="utc.sim_+3A_n.recs">n.recs</code></td>
<td>
<p>The number of records in the record x trait matrix</p>
</td></tr>
<tr><td><code id="utc.sim_+3A_tr1.lim">tr1.lim</code></td>
<td>
<p>The minimum and maximum allowable values for trait 1</p>
</td></tr>
<tr><td><code id="utc.sim_+3A_tr2.lim">tr2.lim</code></td>
<td>
<p>The minimum and maximum allowable values for trait 2</p>
</td></tr>
<tr><td><code id="utc.sim_+3A_sim.type">sim.type</code></td>
<td>
<p>&quot;random&quot; runs random assembly (or if any sim.type other than limiting or filter is specified), &quot;limiting&quot; runs limiting similarity, and &quot;filter&quot; applies an environmental filter.</p>
</td></tr>
<tr><td><code id="utc.sim_+3A_filter.vals">filter.vals</code></td>
<td>
<p>Vector of filter values in text form with a semi-colon delimiter (sorry!) e.g., c(&quot;1,1&quot;, &quot;1;2&quot;) would only allow values of 1,1 and 2,2 in the data.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
