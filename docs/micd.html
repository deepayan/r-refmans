<!DOCTYPE html><html lang="en"><head><title>Help for package micd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {micd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boot.graph'><p>Bootstrap Resampling for the PC-MI- and the FCI-MI-algorithm</p></a></li>
<li><a href='#disCItwd'><p>G square Test for (Conditional) Independence between Discrete Variables with Missings</p></a></li>
<li><a href='#disMItest'><p>G square Test for (Conditional) Independence between Discrete Variables after</p>
Multiple Imputation</a></li>
<li><a href='#fciMI'><p>Estimate a PAG by the FCI-MI Algorithm for Multiple Imputed Data Sets of Continuous Data</p></a></li>
<li><a href='#flexCItest'><p>Wrapper for gaussCItest, disCItest and mixCItest</p></a></li>
<li><a href='#flexCItwd'><p>Wrapper for gaussCItwd, disCItwd and mixCItwd</p></a></li>
<li><a href='#flexMItest'><p>Wrapper for gaussMItest, disMItest and mixMItest</p></a></li>
<li><a href='#gaussCItwd'><p>Fisher's z-Test for (Conditional) Independence between Gaussian Variables with Missings</p></a></li>
<li><a href='#gaussMItest'><p>Test Conditional Independence of Gaussians via Fisher's Z Using</p>
Multiple Imputations</a></li>
<li><a href='#getSuff'><p>Obtain 'suffStat' for conditional independence testing</p></a></li>
<li><a href='#make.formulas.saturated'><p>Creates a <code>formulas</code> Argument</p></a></li>
<li><a href='#makeResiduals'><p>Generate residuals based on variables in imputed data sets</p></a></li>
<li><a href='#mixCItest'><p>Likelihood Ratio Test for (Conditional) Independence between Mixed Variables</p></a></li>
<li><a href='#mixCItwd'><p>Likelihood Ratio Test for (Conditional) Independence between Mixed Variables with Missings</p></a></li>
<li><a href='#mixMItest'><p>Likelihood Ratio Test for (Conditional) Independence between Mixed Variables</p>
after Multiple Imputation</a></li>
<li><a href='#pcMI'><p>Estimate the Equivalence Class of a DAG Using the PC-MI Algorithm for Multiple</p>
Imputed Data Sets</a></li>
<li><a href='#skeletonMI'><p>Estimate (Initial) Skeleton of a DAG using the PC Algorithm for Multiple</p>
Imputed Data Sets of Continuous Data</a></li>
<li><a href='#with_graph'><p>Evaluate Causal Graph Discovery Algorithm in Multiple Imputed Data sets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Imputation in Causal Graph Discovery</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-09</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ronja Foraita &lt;foraita@leibniz-bips.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Modified functions of the package 'pcalg' and some additional functions
            to run the PC and the FCI (Fast Causal Inference) algorithm for constraint-based 
            causal discovery in incomplete and multiply imputed datasets.
            Foraita R, Friemel J, GÃ¼nther K, Behrens T, Bullerdiek J, Nimzyk R, Ahrens W, Didelez V (2020) &lt;<a href="https://doi.org/10.1111%2Frssa.12565">doi:10.1111/rssa.12565</a>&gt;;
            Andrews RM, Foraita R, Didelez V, Witte J (2021) &lt;<a href="https://doi.org/10.48550/arXiv.2108.13395">doi:10.48550/arXiv.2108.13395</a>&gt;; Witte J, Foraita R, Didelez V (2022) &lt;<a href="https://doi.org/10.1002%2Fsim.9535">doi:10.1002/sim.9535</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), pcalg, mice</td>
</tr>
<tr>
<td>Imports:</td>
<td>RBGL, Rfast, methods, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>nnet, ranger, Rgraphviz, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bips-hb/micd">https://github.com/bips-hb/micd</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bips-hb/micd/issues">https://github.com/bips-hb/micd/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-17 16:36:02 UTC; foraita</td>
</tr>
<tr>
<td>Author:</td>
<td>Ronja Foraita <a href="https://orcid.org/0000-0003-2216-6653"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph, cre],
  Janine Witte [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-17 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='boot.graph'>Bootstrap Resampling for the PC-MI- and the FCI-MI-algorithm</h2><span id='topic+boot.graph'></span>

<h3>Description</h3>

<p>Generate R bootstrap replicates for the PC or FCI algorithm for data with
missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.graph(
  data,
  select = NULL,
  method = c("pcMI", "fciMI"),
  method.mice = NULL,
  args,
  R,
  m = 10,
  args.residuals = NULL,
  seed = NA,
  quickpred = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot.graph_+3A_data">data</code></td>
<td>
<p>Data.frame with missing values</p>
</td></tr>
<tr><td><code id="boot.graph_+3A_select">select</code></td>
<td>
<p>Variable of integers, indicating columns to select from a data frame;
only continuous variables can be included in the model selection</p>
</td></tr>
<tr><td><code id="boot.graph_+3A_method">method</code></td>
<td>
<p>Character string specifying the algorithm for causal discovery
from the package 'pcalg'.</p>
</td></tr>
<tr><td><code id="boot.graph_+3A_method.mice">method.mice</code></td>
<td>
<p>Character string specifying imputation method; see <code><a href="mice.html#topic+mice">mice::mice()</a></code> for
more information.</p>
</td></tr>
<tr><td><code id="boot.graph_+3A_args">args</code></td>
<td>
<p>Arguments passed to <code>method</code>. NOTE: argument <code>labels</code> is set
internally and should not be used!</p>
</td></tr>
<tr><td><code id="boot.graph_+3A_r">R</code></td>
<td>
<p>A positive integer number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="boot.graph_+3A_m">m</code></td>
<td>
<p>Number of chains included in mice()'.</p>
</td></tr>
<tr><td><code id="boot.graph_+3A_args.residuals">args.residuals</code></td>
<td>
<p>(Optional) list containing vertices and confounders.
May be specified when residuals for vertices should be calculated in each bootstrap
data set. See <code><a href="#topic+makeResiduals">makeResiduals()</a></code> for more information</p>
</td></tr>
<tr><td><code id="boot.graph_+3A_seed">seed</code></td>
<td>
<p>A positive integer that is used as argument for set.seed().</p>
</td></tr>
<tr><td><code id="boot.graph_+3A_quickpred">quickpred</code></td>
<td>
<p>If true, mice uses quickpred to select predictors.</p>
</td></tr>
<tr><td><code id="boot.graph_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the imputation function <code>mice()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of objects of class <code>pcalgo</code> (see <a href="pcalg.html#topic+pcAlgo-class">pcalg::pcAlgo</a>)
or of <code>fcmialgo</code> (see <a href="pcalg.html#topic+fciAlgo-class">pcalg::fciAlgo</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(windspeed)
daten &lt;- mice::ampute(windspeed)$amp


bgraph &lt;- boot.graph(data = daten,
                     method = "pcMI",
                     args = "solve.confl = TRUE, alpha = 0.05",
                     R = 5)

</code></pre>

<hr>
<h2 id='disCItwd'>G square Test for (Conditional) Independence between Discrete Variables with Missings</h2><span id='topic+disCItwd'></span>

<h3>Description</h3>

<p>A wrapper for <code>pcalg::<a href="pcalg.html#topic+disCItest">disCItest</a></code>, to be used within
<code>pcalg::<a href="pcalg.html#topic+skeleton">skeleton</a></code>, <code>pcalg::<a href="pcalg.html#topic+pc">pc</a></code> or
<code>pcalg::<a href="pcalg.html#topic+fci">fci</a></code> when the data contain missing values.
Observations where at least one of the variables involved in the test is
missing are deleted prior to performing the test (test-wise deletion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disCItwd(x, y, S = NULL, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disCItwd_+3A_x">x</code>, <code id="disCItwd_+3A_y">y</code>, <code id="disCItwd_+3A_s">S</code></td>
<td>
<p>(Integer) position of variable X, Y and set of variables S,
respectively, in <code>suffStat</code>. It is tested whether X and Y
are conditionally independent given the subset S of the remaining variables.</p>
</td></tr>
<tr><td><code id="disCItwd_+3A_suffstat">suffStat</code></td>
<td>
<p>A list with three elements, <code>"dm"</code>, <code>"nlev"</code>,
<code>"adaptDF"</code>; each corresponding to the above arguments.
Can be obtained from a data.frame  of factor variables using
the <code>suffStat</code> function (see example section)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="pcalg.html#topic+disCItest">disCItest</a></code> for details on the G square test. Test-wise deletion
is valid if missingness does not jointly depend on X and Y.
</p>


<h3>Value</h3>

<p>A p-value.
</p>


<h3>See Also</h3>

<p><code>pcalg::<a href="pcalg.html#topic+disCItest">disCItest</a></code> for complete data, <code><a href="#topic+disMItest">disMItest</a></code>
for multiply imputed data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load data (200 observations)
data(gmD)
dat &lt;- gmD$x[1:1000,]

## delete some observations of X2 and X3
set.seed(123)
dat[sample(1:1000, 50), 2] &lt;- NA
dat[sample(1:1000, 50), 3] &lt;- NA

## analyse incomplete data
# test-wise deletion ==========
sufftwd &lt;- getSuff(dat, test = "disCItwd")
disCItwd(1, 3, NULL, suffStat = sufftwd)

# list-wise deletion ==========
dat2 &lt;- dat[complete.cases(dat), ]
suffStat2 &lt;- getSuff(dat2, test = "disCItest", adaptDF = FALSE)
disCItest(1, 3, NULL, suffStat = suffStat2)

## use disCItwd within pcalg::pc ==========
pc.fit &lt;- pc(suffStat = sufftwd, indepTest = disCItwd, alpha = 0.1, p = 5)
pc.fit

if (requireNamespace("Rgraphviz", quietly = TRUE))
plot(pc.fit)

</code></pre>

<hr>
<h2 id='disMItest'>G square Test for (Conditional) Independence between Discrete Variables after
Multiple Imputation</h2><span id='topic+disMItest'></span>

<h3>Description</h3>

<p>A modified version of <code>pcalg::<a href="pcalg.html#topic+disCItest">disCItest</a></code>, to be used within
<code>pcalg::<a href="pcalg.html#topic+skeleton">skeleton</a></code>, <code>pcalg::<a href="pcalg.html#topic+pc">pc</a></code> or
<code>pcalg::<a href="pcalg.html#topic+fci">fci</a></code> when multiply imputed data sets are available.
Note that in contrast to <code>pcalg::<a href="pcalg.html#topic+disCItest">disCItest</a></code>, the variables must
here be coded as factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disMItest(x, y, S = NULL, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disMItest_+3A_x">x</code>, <code id="disMItest_+3A_y">y</code>, <code id="disMItest_+3A_s">S</code></td>
<td>
<p>(Integer) position of variable X, Y and set of variables S,
respectively, in <code>suffStat</code>. It is tested whether X and Y are conditionally
independent given the subset S of the remaining variables.</p>
</td></tr>
<tr><td><code id="disMItest_+3A_suffstat">suffStat</code></td>
<td>
<p>A list of <code>data.frame</code>s containing the multiply imputed
data sets. Usually obtained from a <code>mice::<a href="mice.html#topic+mids-class">mids</a></code>
object using <code>mice::<a href="mice.html#topic+complete.mids">complete</a></code> with argument
<code>action="all"</code>. All variables must be coded as <code><a href="base.html#topic+factor">factor</a>s</code>. NO warning is issued if the variables are not coded as factors!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>pcalg::<a href="pcalg.html#topic+disCItest">disCItest</a></code> for details on the G square test. disMItest applies this test to each
<code>data.frame</code> in <code>suffStat</code>, then combines the results using the rules
in Meng &amp; Rubin (1992). Degrees of freedom are never adapted, and there is no
minimum required sample size, while <code>pcalg::<a href="pcalg.html#topic+disCItest">disCItest</a></code> requires
<code>10*df</code> observations and otherwise returns a p-value of 1.
</p>


<h3>Value</h3>

<p>A p-value.
</p>


<h3>Author(s)</h3>

<p>Janine Witte
</p>


<h3>References</h3>

<p>Meng X.-L., Rubin D.B. (1992): Performing likelihood ratio tests with multiply
imputed data sets. <em>Biometrika</em> 79(1):103-111.
</p>


<h3>See Also</h3>

<p><code>pcalg::<a href="pcalg.html#topic+disCItest">disCItest</a></code> for complete data,
<code><a href="#topic+disCItwd">disCItwd</a></code> for test-wise deletion
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load data (200 observations) and factorise
data(gmD)
dat &lt;- gmD$x[1:1000, ]
dat[] &lt;- lapply(dat, as.factor)

## delete some observations of X2 and X3
set.seed(123)
dat[sample(1:1000, 40), 2] &lt;- NA
dat[sample(1:1000, 40), 3] &lt;- NA

## impute missing values under model with two-way interactions
form &lt;- make.formulas.saturated(dat, d = 2)
imp &lt;- mice::mice(dat, formulas = form, printFlag = FALSE)
imp &lt;- mice::complete(imp, action = "all")

## analyse imputed data
disMItest(1, 3, NULL, suffStat = imp)

## use disMItest within pcalg::pc
pc.fit &lt;- pc(suffStat = imp, indepTest = disMItest, alpha = 0.01, p = 5)
pc.fit

if(require("Rgraphviz", character.only = TRUE, quietly = TRUE)){
plot(pc.fit)
}

</code></pre>

<hr>
<h2 id='fciMI'>Estimate a PAG by the FCI-MI Algorithm for Multiple Imputed Data Sets of Continuous Data</h2><span id='topic+fciMI'></span>

<h3>Description</h3>

<p>This function is a modification of <code><a href="pcalg.html#topic+fci">pcalg::fci()</a></code>
to be used for multiple imputation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fciMI(
  data,
  alpha,
  labels,
  p,
  skel.method = c("stable", "original"),
  type = c("normal", "anytime", "adaptive"),
  fixedGaps = NULL,
  fixedEdges = NULL,
  NAdelete = TRUE,
  m.max = Inf,
  pdsep.max = Inf,
  rules = rep(TRUE, 10),
  doPdsep = TRUE,
  biCC = FALSE,
  conservative = FALSE,
  maj.rule = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fciMI_+3A_data">data</code></td>
<td>
<p>An object of type mids, which stands for 'multiply imputed
data set', typically created by a call to function mice()</p>
</td></tr>
<tr><td><code id="fciMI_+3A_alpha">alpha</code></td>
<td>
<p>Significance level (number in (0,1) for the conditional
independence tests</p>
</td></tr>
<tr><td><code id="fciMI_+3A_labels">labels</code></td>
<td>
<p>(Optional) character vector of variable (or &quot;node&quot;) names.
Typically preferred to specifying p.</p>
</td></tr>
<tr><td><code id="fciMI_+3A_p">p</code></td>
<td>
<p>(Optional) number of variables (or nodes). May be specified if
labels are not, in which case labels is set to 1:p.</p>
</td></tr>
<tr><td><code id="fciMI_+3A_skel.method">skel.method</code></td>
<td>
<p>Character string specifying method; the default, &quot;stable&quot;
provides an order-independent skeleton, see <code><a href="pcalg.html#topic+skeleton">pcalg::skeleton()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fciMI_+3A_type">type</code></td>
<td>
<p>Character string specifying the version of the FCI algorithm to be used.
See <code><a href="pcalg.html#topic+fci">pcalg::fci()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fciMI_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>See <code><a href="pcalg.html#topic+fci">pcalg::fci()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fciMI_+3A_fixededges">fixedEdges</code></td>
<td>
<p>See <code><a href="pcalg.html#topic+fci">pcalg::fci()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fciMI_+3A_nadelete">NAdelete</code></td>
<td>
<p>See <code><a href="pcalg.html#topic+fci">pcalg::fci()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fciMI_+3A_m.max">m.max</code></td>
<td>
<p>Maximum size of the conditioning sets that are considered in
the conditional independence tests.</p>
</td></tr>
<tr><td><code id="fciMI_+3A_pdsep.max">pdsep.max</code></td>
<td>
<p>See <code><a href="pcalg.html#topic+fci">pcalg::fci()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fciMI_+3A_rules">rules</code></td>
<td>
<p>Logical vector of length 10 indicating which rules should be
used when directing edges. The order of the rules is
taken from Zhang (2008).</p>
</td></tr>
<tr><td><code id="fciMI_+3A_dopdsep">doPdsep</code></td>
<td>
<p>See <code><a href="pcalg.html#topic+fci">pcalg::fci()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fciMI_+3A_bicc">biCC</code></td>
<td>
<p>See <code><a href="pcalg.html#topic+fci">pcalg::fci()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fciMI_+3A_conservative">conservative</code></td>
<td>
<p>See <code><a href="pcalg.html#topic+fci">pcalg::fci()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fciMI_+3A_maj.rule">maj.rule</code></td>
<td>
<p>See <code><a href="pcalg.html#topic+fci">pcalg::fci()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fciMI_+3A_verbose">verbose</code></td>
<td>
<p>If true, more detailed output is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="pcalg.html#topic+fci">pcalg::fci()</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Original code by Diego Colombo, Markus Kalisch, and  Joris Mooij.
Modifications by Ronja Foraita.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
daten &lt;- windspeed[,1]
for(i in 2:ncol(windspeed)) daten &lt;- c(daten, windspeed[,i])
daten[sample(1:length(daten), 260)] &lt;- NA
daten &lt;- matrix(daten, ncol = 6)

## Impute missing values
imp &lt;- mice(daten, printFlag = FALSE)
fc.res &lt;- fciMI(data = imp, label = colnames(imp$data), alpha = 0.01)

if (requireNamespace("Rgraphviz", quietly = TRUE))
plot(fc.res)


</code></pre>

<hr>
<h2 id='flexCItest'>Wrapper for gaussCItest, disCItest and mixCItest</h2><span id='topic+flexCItest'></span>

<h3>Description</h3>

<p>A plug-in conditional independence test for <code><a href="pcalg.html#topic+skeleton">pcalg::skeleton()</a></code>, <code><a href="pcalg.html#topic+pc">pcalg::pc()</a></code> or
<code><a href="pcalg.html#topic+fci">pcalg::fci()</a></code> when multiply imputed data sets are available. <code><a href="#topic+flexCItest">flexCItest()</a></code> detects whether
variables are continuous, discrete or mixed, and automatically switches between <code>gaussCItest()</code> (continuous only),
<code>disCItest()</code> (discrete only) and <code><a href="#topic+mixCItest">mixCItest()</a></code> (mixed variables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexCItest(x, y, S = NULL, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flexCItest_+3A_x">x</code>, <code id="flexCItest_+3A_y">y</code>, <code id="flexCItest_+3A_s">S</code></td>
<td>
<p>(integer) position of variable X, Y and set of variables S,
respectively, in the dataset. It is tested whether X and Y are conditionally
independent given the subset S of the remaining variables.</p>
</td></tr>
<tr><td><code id="flexCItest_+3A_suffstat">suffStat</code></td>
<td>
<p>a list generated using <code>getSuff()</code> with <code>test="flexMItest"</code>. See below for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>suffStat</code> needs to be a list with four elements named <code>datlist</code>, <code>corlist</code>,
<code>conpos</code> and <code>dispos</code>. <code>datlist</code> is the list of imputed datasets. <code>corlist</code>
is a list with M+1 elements, where M is the number of imputed datasets. For i=1,...,M, the
the i-th element of <code>corlist</code> is the correlation matrix of the continuous variables in the i-th imputed dataset;
the (M+1)-the element is the number of rows in each imputed dataset.
<code>conpos</code> is a vector containing the integer positions of the continuous variables in the original dataset.
<code>dispos</code> is a vector containing the integer positions of the discrete variables in the original dataset.
</p>


<h3>Value</h3>

<p>A p-value.
</p>


<h3>See Also</h3>

<p><code>gaussCItest()</code>, <code>disCItest()</code> and <code><a href="#topic+mixCItest">mixCItest()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data (numeric and factor variables)
dat &lt;- toenail2[1:400, ]

# obtain correct input 'suffStat' for 'flexCItest'
suff &lt;- getSuff(dat, test="flexCItest")

flexCItest(2,3,NULL, suffStat = suff)

</code></pre>

<hr>
<h2 id='flexCItwd'>Wrapper for gaussCItwd, disCItwd and mixCItwd</h2><span id='topic+flexCItwd'></span>

<h3>Description</h3>

<p>A plug-in conditional independence test for <code>pcalg::<a href="pcalg.html#topic+skeleton">skeleton</a></code>, <code>pcalg::<a href="pcalg.html#topic+pc">pc</a></code> or
<code>pcalg::<a href="pcalg.html#topic+fci">fci</a></code> when the data contain missing values. Observations
where at least one of the variables involved in the test is missing are
deleted prior to performing the test (test-wise deletion). The function <code>flexCItwd</code> detects whether
variables are continuous, discrete or mixed, and automatically switches between <code><a href="#topic+gaussCItwd">gaussCItwd</a></code> (continuous only),
<code>link{disCItwd}</code> (discrete only) and <code><a href="#topic+mixCItwd">mixCItwd</a></code> (mixed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexCItwd(x, y, S = NULL, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flexCItwd_+3A_x">x</code>, <code id="flexCItwd_+3A_y">y</code>, <code id="flexCItwd_+3A_s">S</code></td>
<td>
<p>(Integer) position of variable X, Y and set of variables S,
respectively, in each correlation matrix in <code>suffStat</code>. It is tested
whether X and Y are conditionally independent given the subset S of the
remaining variables.</p>
</td></tr>
<tr><td><code id="flexCItwd_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data (numeric and factor variables)
dat &lt;- toenail2[1:400, ]

## delete some observations
set.seed(123)
dat[sample(400, 20), 2] &lt;- NA
dat[sample(400, 30), 4] &lt;- NA

## obtain correct input 'suffStat' for 'flexMItest'
suff &lt;- getSuff(imp, test="flexCItwd")

## analyse data
# continuous variables only
flexCItwd(4, 5, NULL, dat)

# discrete variables only
flexCItwd(2, 3, NULL, dat)

# mixed variables
flexCItwd(2, 3, 4, dat)

</code></pre>

<hr>
<h2 id='flexMItest'>Wrapper for gaussMItest, disMItest and mixMItest</h2><span id='topic+flexMItest'></span>

<h3>Description</h3>

<p>A plug-in conditional independence test for <code>pcalg::<a href="pcalg.html#topic+skeleton">skeleton</a></code>, <code>pcalg::<a href="pcalg.html#topic+pc">pc</a></code> or
<code>pcalg::<a href="pcalg.html#topic+fci">fci</a></code> when multiply imputed data sets are available. <code>flexMItest</code> detects whether
variables are continuous, discrete or mixed, and automatically switches between <code><a href="#topic+gaussMItest">gaussMItest</a></code> (continuous only),
<code>link{disMItest}</code> (discrete only) and <code><a href="#topic+mixMItest">mixMItest</a></code> (mixed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexMItest(x, y, S = NULL, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flexMItest_+3A_x">x</code>, <code id="flexMItest_+3A_y">y</code>, <code id="flexMItest_+3A_s">S</code></td>
<td>
<p>(integer) position of variable X, Y and set of variables S,
respectively, in the dataset. It is tested whether X and Y are conditionally
independent given the subset S of the remaining variables.</p>
</td></tr>
<tr><td><code id="flexMItest_+3A_suffstat">suffStat</code></td>
<td>
<p>a list generated using <code><a href="#topic+getSuff">getSuff</a></code> with <code>test="flexMItest"</code>. See below for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>suffStat</code> needs to be a list with four elements named <code>datlist</code>, <code>corlist</code>,
<code>conpos</code> and <code>dispos</code>. <code>datlist</code> is the list of imputed datasets. <code>corlist</code>
is a list with M+1 elements, where M is the number of imputed datasets. For i=1,...,M, the
the i-th element of <code>corlist</code> is the correlation matrix of the continuous variables in the i-th imputed dataset;
the (M+1)-the element is the number of rows in each imputed dataset.
<code>conpos</code> is a vector containing the integer positions of the continuous variables in the original dataset.
<code>dispos</code> is a vector containing the integer positions of the discrete variables in the original dataset.
</p>


<h3>Value</h3>

<p>A p-value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gaussMItest">gaussMItest</a></code>, <code><a href="#topic+disMItest">disMItest</a></code> and <code><a href="#topic+mixMItest">mixMItest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data (numeric and factor variables)
library(ranger)
dat &lt;- toenail2[1:400, ]

## delete some observations
set.seed(123)
dat[sample(400, 20), 2] &lt;- NA
dat[sample(400, 30), 4] &lt;- NA

## impute missing values using random forests
imp &lt;- mice::mice(dat, method = "rf", m = 3, printFlag = FALSE)

## obtain correct input 'suffStat' for 'flexMItest'
suff &lt;- getSuff(imp, test="flexMItest")

## analyse data
# continuous variables only
flexMItest(4,5,NULL, suffStat = suff)
implist &lt;- complete(imp, action="all")
gaussSuff &lt;- c(lapply(implist, function(i){cor(i[ ,c(4,5)])}), n = 400)
gaussMItest(1,2,NULL, suffStat = gaussSuff)
flexCItwd(4, 5, NULL, dat)

# discrete variables only
flexMItest(2,3,NULL, suffStat = suff)
disMItest(2,3,NULL, suffStat = complete(imp, action="all"))
flexCItwd(2,3,NULL, dat)

# mixed variables
flexMItest(2,3,4, suffStat = suff)
mixMItest(2,3,4, suffStat = complete(imp, action="all"))
flexCItwd(2,3,4, dat)

</code></pre>

<hr>
<h2 id='gaussCItwd'>Fisher's z-Test for (Conditional) Independence between Gaussian Variables with Missings</h2><span id='topic+gaussCItwd'></span>

<h3>Description</h3>

<p>A wrapper for <code>pcalg::<a href="pcalg.html#topic+condIndFisherZ">gaussCItest</a></code>,
to be used within <code>pcalg::<a href="pcalg.html#topic+skeleton">skeleton</a></code>, <code>pcalg::<a href="pcalg.html#topic+pc">pc</a></code> or
<code>pcalg::<a href="pcalg.html#topic+fci">fci</a></code> when the data contain missing values. Observations
where at least one of the variables involved in the test is missing are
deleted prior to performing the test (test-wise deletion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussCItwd(x, y, S = NULL, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaussCItwd_+3A_x">x</code>, <code id="gaussCItwd_+3A_y">y</code>, <code id="gaussCItwd_+3A_s">S</code></td>
<td>
<p>(integer) position of variable X, Y and set of variables S,
respectively, in each correlation matrix in <code>suffStat</code>. It is tested
whether X and Y are conditionally independent given the subset S of the
remaining variables.</p>
</td></tr>
<tr><td><code id="gaussCItwd_+3A_suffstat">suffStat</code></td>
<td>
<p><code>data.frame</code> containing the raw data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code>pcalg::<a href="pcalg.html#topic+condIndFisherZ">gaussCItest</a></code> for details on
Fisher's z-test. Test-wise deletion is valid if missingness does not jointly
depend on X and Y.
</p>
<p>A p-value.
</p>


<h3>See Also</h3>

<p><code><a href="pcalg.html#topic+condIndFisherZ">pcalg::condIndFisherZ()</a></code> for complete data, <code><a href="#topic+gaussCItestMI">gaussCItestMI()</a></code> for multiply imputed data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load data (numeric variables)
dat &lt;- as.matrix(windspeed)

## delete some observations
set.seed(123)
dat[sample(1:length(dat), 260)] &lt;- NA

## analyse data
# complete data:
suffcomplete &lt;- getSuff(windspeed, test="gaussCItest")
gaussCItest(1, 2, c(4,5), suffStat = suffcomplete)

# test-wise deletion: ==========
gaussCItwd(1, 2, c(4,5), suffStat = dat)

# list-wise deletion: ==========
sufflwd &lt;- getSuff(dat[complete.cases(dat), ], test="gaussCItest")
gaussCItest(1, 2, c(4,5), suffStat = sufflwd)

## use gaussCItwd within pcalg::pc
pc.fit &lt;- pc(suffStat = dat, indepTest = gaussCItwd, alpha = 0.01, p = 6)
pc.fit

</code></pre>

<hr>
<h2 id='gaussMItest'>Test Conditional Independence of Gaussians via Fisher's Z Using
Multiple Imputations</h2><span id='topic+gaussMItest'></span><span id='topic+gaussCItestMI'></span>

<h3>Description</h3>

<p>A modified version of <code>pcalg::<a href="pcalg.html#topic+condIndFisherZ">gaussCItest</a></code>,
to be used within
<code>pcalg::<a href="pcalg.html#topic+skeleton">skeleton</a></code>, <code>pcalg::<a href="pcalg.html#topic+pc">pc</a></code> or
<code>pcalg::<a href="pcalg.html#topic+fci">fci</a></code> when multiply imputated data sets are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussMItest(x, y, S, suffStat)

gaussCItestMI(x, y, S = NULL, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaussMItest_+3A_x">x</code>, <code id="gaussMItest_+3A_y">y</code>, <code id="gaussMItest_+3A_s">S</code></td>
<td>
<p>(Integer) position of variable X, Y and set of variables S,
respectively, in the adjacency matrix.
It is tested, whether X and Y are conditionally independent
given the subset S of the remaining nodes.</p>
</td></tr>
<tr><td><code id="gaussMItest_+3A_suffstat">suffStat</code></td>
<td>
<p>A list of length m+1, where m is the number of imputations;
the first m elements are the covariance matrices of the m
imputed data sets, the m-th element is the sample size. Can
be obtained from a mids object by
getSuff(mids, test=&quot;gaussMItest&quot;)</p>
</td></tr>
<tr><td><code id="gaussMItest_+3A_data">data</code></td>
<td>
<p>An object of type mids, which stands for 'multiply imputed
data set', typically created by a call to function mice()</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gaussMItest</code> is faster, as it uses pre-calculated covariance matrices.
</p>


<h3>Value</h3>

<p>A p-value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data (numeric variables)
dat &lt;- as.matrix(windspeed)

## delete some observations
set.seed(123)
dat[sample(1:length(dat), 260)] &lt;- NA

## Impute missing values under normal model
imp &lt;- mice(dat, method = "norm", printFlag = FALSE)

## analyse data
# complete data:
suffcomplete &lt;- getSuff(windspeed, test = "gaussCItest")
gaussCItest(1, 2, c(4,5), suffStat = suffcomplete)
# multiple imputation:
suffMI &lt;- getSuff(imp, test = "gaussMItest")
gaussMItest(1, 2, c(4,5), suffStat = suffMI)
gaussCItestMI(1, 2, c(4,5), data = imp)
# test-wise deletion:
gaussCItwd(1, 2, c(4,5), suffStat = dat)
# list-wise deletion:
dat2 &lt;- dat[complete.cases(dat), ]
sufflwd &lt;- getSuff(dat2, test = "gaussCItest")
gaussCItest(1, 2, c(4,5), suffStat = sufflwd)

## use gaussMItest or gaussCItestMI within pcalg::pc
(pc.fit &lt;- pc(suffStat = suffMI, indepTest = gaussMItest, alpha = 0.01, p = 6))
(pc.fit &lt;- pc(suffStat = imp, indepTest = gaussCItestMI, alpha = 0.01, p = 6))

</code></pre>

<hr>
<h2 id='getSuff'>Obtain 'suffStat' for conditional independence testing</h2><span id='topic+getSuff'></span>

<h3>Description</h3>

<p>A convenience function for transforming a multiply imputed data set into the 'suffStat' required
by <code><a href="pcalg.html#topic+condIndFisherZ">pcalg::gaussCItest()</a></code>, <code><a href="pcalg.html#topic+disCItest">pcalg::disCItest()</a></code>, <code><a href="#topic+mixCItest">mixCItest()</a></code>, <code><a href="#topic+flexCItest">flexCItest()</a></code>, <code><a href="#topic+gaussMItest">gaussMItest()</a></code>,
<code><a href="#topic+disMItest">disMItest()</a></code>, <code><a href="#topic+mixMItest">mixMItest()</a></code> and <code><a href="#topic+flexMItest">flexMItest()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSuff(
  X,
  test = c("gaussCItest", "gaussMItest", "disCItest", "disMItest", "disCItwd",
    "mixCItest", "mixMItest", "flexMItest", "flexCItest"),
  adaptDF = NULL,
  nlev = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSuff_+3A_x">X</code></td>
<td>
<p>For 'test=xxxCItest': a data.frame or matrix;
for 'test=xxxMItest': an object of class <code>mice::<a href="mice.html#topic+mids-class">mids</a></code>,
or a list of data.frames containing the multiply imputed data sets.</p>
</td></tr>
<tr><td><code id="getSuff_+3A_test">test</code></td>
<td>
<p>one of <code>gaussCItest()</code>, <code><a href="#topic+gaussMItest">gaussMItest()</a></code>, <code>disCItest()</code>,
<code><a href="#topic+disMItest">disMItest()</a></code>, <code><a href="#topic+mixCItest">mixCItest()</a></code>, <code><a href="#topic+mixMItest">mixMItest()</a></code>, <code><a href="#topic+flexCItest">flexCItest()</a></code>,
<code><a href="#topic+flexMItest">flexMItest()</a></code>.</p>
</td></tr>
<tr><td><code id="getSuff_+3A_adaptdf">adaptDF</code></td>
<td>
<p>for discrete variables: logical specifying if the degrees of freedom
should be lowered by one for each zero count. The value for the degrees of freedom
cannot go below 1.</p>
</td></tr>
<tr><td><code id="getSuff_+3A_nlev">nlev</code></td>
<td>
<p>(Optional) for discrete variables: vector with numbers of levels for each
variable in the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R object that can be used as input to the specified conditional independence test:
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1: continuous variables, no missing values =====================
data(windspeed)
dat1 &lt;- as.matrix(windspeed)

## analyse data
gaussCItest(1, 2, NULL, suffStat = getSuff(windspeed, test = "gaussCItest"))
mixCItest(1, 2, NULL, suffStat = windspeed)

## Example 2: continuous variables, multiple imputation ===================
dat2 &lt;- mice::ampute(windspeed)$amp

## delete some observations
set.seed(123)

## Impute missing values under normal model
imp2 &lt;- mice(dat2, method = "norm", printFlag = FALSE)

## analyse imputed data
gaussMItest(1, 2, c(4,5), suffStat = getSuff(imp2, test="gaussMItest"))
mixMItest(1, 2, c(4,5), suffStat = getSuff(imp2, test="mixMItest"))
mixMItest(1, 2, c(4,5), suffStat = mice::complete(imp2, action="all"))
flexMItest(1, 2, c(4,5), suffStat = getSuff(imp2, test="flexMItest"))

## Example 3: discrete variables, multiple imputation =====================
## simulate factor variables
n &lt;- 200
set.seed(789)
x &lt;- factor(sample(0:2, n, TRUE)) # factor, 3 levels
y &lt;- factor(sample(0:3, n, TRUE)) # factor, 4 levels
z &lt;- factor(sample(0:1, n, TRUE)) # factor, 2 levels
dat3 &lt;- data.frame(x,y,z)

## delete some observations of z
dat3[sample(1:n, 40), 3] &lt;- NA

## impute missing values under saturated model
form &lt;- make.formulas.saturated(dat3)
imp3 &lt;- mice::mice(dat3, method = "logreg", formulas = form, printFlag = FALSE)

## analyse imputed data
disMItest(1, 3, 2, suffStat = getSuff(imp3, test="disMItest"))
disMItest(1, 3, 2, suffStat = mice::complete(imp3, action = "all"))
mixMItest(1, 3, 2, suffStat = getSuff(imp3, test="mixMItest"))
mixMItest(1, 3, 2, suffStat = mice::complete(imp3, action = "all"))
flexMItest(1, 3, 2, suffStat = getSuff(imp3, test="flexMItest"))

# Example 4: mixed variables, multiple imputation =========================
dat4 &lt;- toenail2[1:400, ]
set.seed(123)
dat4[sample(400, 20), 2] &lt;- NA
dat4[sample(400, 30), 4] &lt;- NA

## impute missing values using random forests
imp4 &lt;- mice(dat4, method="rf", m = 3, printFlag = FALSE)
mixMItest(2, 3, 5, suffStat = getSuff(imp4, test="mixMItest"))
mixMItest(2, 3, 5, suffStat = mice::complete(imp4, action="all"))
flexMItest(2, 3, 5, suffStat = getSuff(imp4, test="flexMItest"))

</code></pre>

<hr>
<h2 id='make.formulas.saturated'>Creates a <code>formulas</code> Argument</h2><span id='topic+make.formulas.saturated'></span>

<h3>Description</h3>

<p>This helper function creates a valid <code>formulas</code> object.
The <code>formulas</code> object is an argument to the <code>mice::<a href="mice.html#topic+mice">mice</a></code> function.
It is a list of formulas that specifies the target variables and the predictors
by means of the standard ~ operator. In contrast to <code>mice::<a href="mice.html#topic+make.formulas">make.formulas</a></code>,
which creates main effects formulas, <code>make.formulas.saturated</code>
creates formulas including interaction effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.formulas.saturated(
  data,
  blocks = mice::make.blocks(data),
  predictorMatrix = NULL,
  d = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.formulas.saturated_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with the source data.</p>
</td></tr>
<tr><td><code id="make.formulas.saturated_+3A_blocks">blocks</code></td>
<td>
<p>An optional specification for blocks of variables in the rows.
The default assigns each variable in its own block.</p>
</td></tr>
<tr><td><code id="make.formulas.saturated_+3A_predictormatrix">predictorMatrix</code></td>
<td>
<p>A <code>predictorMatrix</code> specified by the user.</p>
</td></tr>
<tr><td><code id="make.formulas.saturated_+3A_d">d</code></td>
<td>
<p>maximum depth of interactions to be considered (1=no interactions, 2=two-way interactions, etc.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of formulas.
</p>


<h3>Note</h3>

<p>A modification of <code>mice::<a href="mice.html#topic+make.formulas">make.formulas</a></code> by Stef van Buuren et al.
</p>


<h3>See Also</h3>

<p><code>mice::<a href="mice.html#topic+make.formulas">make.formulas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## main effects model:
data(nhanes)
f1 &lt;- make.formulas(nhanes)
f1

## saturated model:
f2 &lt;- make.formulas.saturated(nhanes)
f2

</code></pre>

<hr>
<h2 id='makeResiduals'>Generate residuals based on variables in imputed data sets</h2><span id='topic+makeResiduals'></span>

<h3>Description</h3>

<p>Generate residuals based on variables in imputed data sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeResiduals(data, v, confounder, method = c("res", "cc", "pd"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeResiduals_+3A_data">data</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="makeResiduals_+3A_v">v</code></td>
<td>
<p>Vector of integers referring to the location of the variable(s) in the data set</p>
</td></tr>
<tr><td><code id="makeResiduals_+3A_confounder">confounder</code></td>
<td>
<p>Vector of integers referring to the location of the variable(s)
in the data set (confounders are not included in the network!)</p>
</td></tr>
<tr><td><code id="makeResiduals_+3A_method">method</code></td>
<td>
<p>Default method 'res' uses residuals, 'cc' uses complete cases
and 'pd' uses pairwise deletion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data matrix of residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(windspeed)
daten &lt;- mice::ampute(windspeed)$amp

# Impute missing values
imp &lt;- mice(daten, m = 5)

# Build residuals
knoten &lt;- 1:4
confounder &lt;- 5:6

# Residuals based on dataset with missing values
res.pd &lt;- makeResiduals(daten, v = knoten, confounder = confounder, method = "pd")

# Residuals based in multiple imputed data
residuals &lt;- list(data = list(), m = 5)
imp_c &lt;- mice::complete(imp, "all")
for (i in 1:imp$m){
   residuals$data[[i]] &lt;- makeResiduals(imp_c[[i]],
                          v = knoten, confounder = confounder)
 }

pc.res &lt;- pcMI(data = residuals, p = length(knoten), alpha = 0.05)
fci.res &lt;- fciMI(data = imp, p = length(knoten), alpha = 0.05)

if (requireNamespace("Rgraphviz", quietly = TRUE)){
oldpar &lt;- par(mfrow = c(1,2)) 
  plot(pc.res)
  plot(fci.res)
par(oldpar)
}

</code></pre>

<hr>
<h2 id='mixCItest'>Likelihood Ratio Test for (Conditional) Independence between Mixed Variables</h2><span id='topic+mixCItest'></span>

<h3>Description</h3>

<p>A likelihood ratio test for (conditional) independence between mixed
(continuous and unordered categorical) variables, to be used within
<code>pcalg::<a href="pcalg.html#topic+skeleton">skeleton</a></code>, <code>pcalg::<a href="pcalg.html#topic+pc">pc</a></code> or
<code>pcalg::<a href="pcalg.html#topic+fci">fci</a></code>. It assumes that the variables in the test
follow a Conditional Gaussian distribution, i.e. conditional on each
combination of values of the discrete variables, the continuous variables
are multivariate Gaussian. Each multivariate Gaussian distribution is
allowed to have its own mean vector and covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixCItest(x, y, S = NULL, suffStat, moreOutput = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixCItest_+3A_x">x</code>, <code id="mixCItest_+3A_y">y</code>, <code id="mixCItest_+3A_s">S</code></td>
<td>
<p>(Integer) position of variable X, Y and set of variables S,
respectively, in <code>suffStat</code>. It is tested whether X and Y are
conditionally independent given the subset S of the remaining variables.</p>
</td></tr>
<tr><td><code id="mixCItest_+3A_suffstat">suffStat</code></td>
<td>
<p>A <code>data.frame</code>. Discrete variables must be coded as factors.</p>
</td></tr>
<tr><td><code id="mixCItest_+3A_moreoutput">moreOutput</code></td>
<td>
<p>If <code>TRUE</code>, the test statistic and the degrees of
freedom are returned in addition to the p-value (only for mixed variables).
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation follows Andrews et al. (2018). The same test is
also implemented in TETRAD and in the R-package rcausal, a wrapper for the
TETRAD Java library. Small differences in the p-values returned by
CGtest and the TETRAD/rcausal equivalent are due to differences in
handling sparse or empty cells.
</p>


<h3>Value</h3>

<p>A p-value. If <code>moreOutput=TRUE</code>, the test statistic and the
degrees of freedom are returned as well.
</p>


<h3>Author(s)</h3>

<p>Janine Witte
</p>


<h3>References</h3>

<p>Andrews B., Ramsey J., Cooper G.F. (2018): Scoring Bayesian
networks of mixed variables. <em>International Journal of Data Science and
Analytics</em> 6:3-18.
</p>
<p>Lauritzen S.L., Wermuth N. (1989): Graphical models for associations between
variables, some of which are qualitative and some quantitative.
<em>The Annals of Statistics</em> 17(1):31-57.
</p>
<p>Scheines R., Spirtes P., Glymour C., Meek C., Richardson T. (1998):
The TETRAD project: Constraint based aids to causal model specification.
<em>Multivariate Behavioral Research</em> 33(1):65-117.
http://www.phil.cmu.edu/tetrad/index.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data (numeric and factor variables)
dat &lt;- toenail2[,-1]

# analyse data
mixCItest(4, 1, NULL, suffStat = dat)
mixCItest(1, 2, 3, suffStat = dat)

## use mixCItest within pcalg::fci
fci.fit &lt;- fci(suffStat = dat, indepTest = mixCItest, alpha = 0.01, p = 4)
if (requireNamespace("Rgraphviz", quietly = TRUE))
 plot(fci.fit)

</code></pre>

<hr>
<h2 id='mixCItwd'>Likelihood Ratio Test for (Conditional) Independence between Mixed Variables with Missings</h2><span id='topic+mixCItwd'></span>

<h3>Description</h3>

<p>A version of <code><a href="#topic+mixCItest">mixCItest</a></code>, to be used within <code>pcalg::<a href="pcalg.html#topic+skeleton">skeleton</a></code>,
<code>pcalg::<a href="pcalg.html#topic+pc">pc</a></code> or <code>pcalg::<a href="pcalg.html#topic+fci">fci</a></code> when the data contain missing values.
Observations where at least one of the variables involved in the test is missing
are deleted prior to performing the test (test-wise deletion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixCItwd(x, y, S = NULL, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixCItwd_+3A_x">x</code>, <code id="mixCItwd_+3A_y">y</code>, <code id="mixCItwd_+3A_s">S</code></td>
<td>
<p>(Integer) position of variable X, Y and set of variables S,
respectively, in <code>suffStat</code>. It is tested whether X and Y are conditionally
independent given the subset S of the remaining variables.</p>
</td></tr>
<tr><td><code id="mixCItwd_+3A_suffstat">suffStat</code></td>
<td>
<p><code>data.frame</code>. Discrete variables must be coded as factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+mixCItest">mixCItest</a></code> for details on the assumptions of the
Conditional Gaussian likelihood ratio test. Test-wise deletion is valid if
missingness does not jointly depend on X and Y.
</p>


<h3>Value</h3>

<p>A p-value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixCItest">mixCItest()</a></code> for complete data, <code><a href="#topic+mixMItest">mixMItest()</a></code> for multiply imputed data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data (numeric and factor variables)
data(toenail2)
dat &lt;- toenail2[, -1]

## delete some observations
set.seed(123)
dat[sample(2000, 20), 1] &lt;- NA
dat[sample(2000, 30), 3] &lt;- NA

## analyse data 
# complete data: ==========
mixCItest(1, 2, 4, suffStat=toenail2)

# test-wise deletion: ==========
mixCItwd(1, 2, 4, suffStat = dat)

# list-wise deletion: ==========
dat2 &lt;- dat[complete.cases(dat), ]
mixCItest(1, 2, 4, suffStat = dat2)

## use mixCItwd within pcalg::pc
pc.fit &lt;- pc(suffStat = dat, indepTest = mixCItwd, alpha = 0.01, p = 4)

</code></pre>

<hr>
<h2 id='mixMItest'>Likelihood Ratio Test for (Conditional) Independence between Mixed Variables
after Multiple Imputation</h2><span id='topic+mixMItest'></span>

<h3>Description</h3>

<p>A modified version of <code><a href="#topic+mixCItest">mixCItest</a></code>, to be used within <code>pcalg::<a href="pcalg.html#topic+skeleton">skeleton</a></code>,
<code>pcalg::<a href="pcalg.html#topic+pc">pc</a></code> or <code>pcalg::<a href="pcalg.html#topic+fci">fci</a></code> when multiply imputed data sets are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixMItest(x, y, S = NULL, suffStat, moreOutput = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixMItest_+3A_x">x</code>, <code id="mixMItest_+3A_y">y</code>, <code id="mixMItest_+3A_s">S</code></td>
<td>
<p>(integer) position of variable X, Y and set of variables S,
respectively, in <code>suffStat</code>. It is tested whether X and Y are
conditionally independent given the subset S of the remaining variables.</p>
</td></tr>
<tr><td><code id="mixMItest_+3A_suffstat">suffStat</code></td>
<td>
<p>A list of <code>data.frame</code>s containing the multiply
imputed data sets. Usually obtained from a <code>mice::<a href="mice.html#topic+mids-class">mids</a></code>
object using <code>mice::<a href="mice.html#topic+complete.mids">complete</a></code> with argument <code>action="all"</code>.
Discrete variables must be coded as factors.</p>
</td></tr>
<tr><td><code id="mixMItest_+3A_moreoutput">moreOutput</code></td>
<td>
<p>(only for mixed of discrete variables) If <code>TRUE</code>, the test
statistic, its main components and
the degrees of freedom are returned in addition to the p-value. Defaults to
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+mixCItest">mixCItest</a></code> for details on the assumptions of the
Conditional Gaussian likelihood ratio test. <code>CGtestMI</code> applies this test
to each <code>data.frame</code> in <code>suffStat</code>, then combines the results using
the rules in Meng &amp; Rubin (1992).
</p>


<h3>Value</h3>

<p>A p-value. If <code>moreOutput=TRUE</code>, the test statistic, its main
components and the degrees of freedom are returned as well.
</p>


<h3>Author(s)</h3>

<p>Janine Witte
</p>


<h3>References</h3>

<p>Meng X.-L., Rubin D.B. (1992): Performing likelihood ratio tests
with multiply imputed data sets. <em>Biometrika</em> 79(1):103-111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load data (numeric and factor variables)
data(toenail2)
dat &lt;- toenail2[1:1000, ]

## delete some observations
set.seed(123)
dat[sample(1000, 20), 2] &lt;- NA
dat[sample(1000, 30), 4] &lt;- NA

## impute missing values using random forests (because of run time we just impute 2 chains)
imp &lt;- mice(dat, method = "rf", m = 2, printFlag = FALSE)

## analyse data
# complete data:
mixCItest(2, 3, 5, suffStat = toenail2[1:1000, ])
# multiple imputation:
suffMI &lt;- complete(imp, action = "all")
mixMItest(2, 3, 5, suffStat =  suffMI)
# test-wise deletion:
mixCItwd(2, 3, 5, suffStat = dat)
# list-wise deletion:
sufflwd &lt;- dat[complete.cases(dat), ]
mixCItest(2, 3, 5, suffStat = sufflwd)

## use mixMItest within pcalg::pc

pc.fit &lt;- pc(suffStat =  suffMI, indepTest = mixMItest, alpha = 0.01, p = 5)
pc.fit


</code></pre>

<hr>
<h2 id='pcMI'>Estimate the Equivalence Class of a DAG Using the PC-MI Algorithm for Multiple
Imputed Data Sets</h2><span id='topic+pcMI'></span>

<h3>Description</h3>

<p>This function is a modification of <code><a href="pcalg.html#topic+pc">pcalg::pc()</a></code>
to be used for multiple imputation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcMI(
  data,
  alpha,
  labels,
  p,
  fixedGaps = NULL,
  fixedEdges = NULL,
  NAdelete = TRUE,
  m.max = Inf,
  u2pd = c("relaxed", "rand", "retry"),
  skel.method = c("stable", "original"),
  conservative = FALSE,
  maj.rule = FALSE,
  solve.confl = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcMI_+3A_data">data</code></td>
<td>
<p>An object of type mids, which stands for 'multiply imputed
data set', typically created by a call to function mice()</p>
</td></tr>
<tr><td><code id="pcMI_+3A_alpha">alpha</code></td>
<td>
<p>Significance level (number in (0,1) for the conditional
independence tests</p>
</td></tr>
<tr><td><code id="pcMI_+3A_labels">labels</code></td>
<td>
<p>(Optional) character vector of variable (or &quot;node&quot;) names.
Typically preferred to specifying p.</p>
</td></tr>
<tr><td><code id="pcMI_+3A_p">p</code></td>
<td>
<p>(Optional) number of variables (or nodes). May be specified if
labels are not, in which case labels is set to 1:p.</p>
</td></tr>
<tr><td><code id="pcMI_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry <code>[i,j]</code> or <code>[j,i]</code>
(or both) are TRUE, the edge i-j is removed before starting
the algorithm. Therefore, this edge is guaranteed to be
absent in the resulting graph.</p>
</td></tr>
<tr><td><code id="pcMI_+3A_fixededges">fixedEdges</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry <code>[i,j]</code> or <code>[j,i]</code>
(or both) are TRUE, the edge i-j is never considered for
removal. Therefore, this edge is guaranteed to be present
in the resulting graph</p>
</td></tr>
<tr><td><code id="pcMI_+3A_nadelete">NAdelete</code></td>
<td>
<p>If indepTest returns NA and this option is TRUE,
the corresponding edge is deleted. If this option is FALSE,
the edge is not deleted.</p>
</td></tr>
<tr><td><code id="pcMI_+3A_m.max">m.max</code></td>
<td>
<p>Maximal size of the conditioning sets that are considered in the
conditional independence tests.</p>
</td></tr>
<tr><td><code id="pcMI_+3A_u2pd">u2pd</code></td>
<td>
<p>String specifying the method for dealing with conflicting
information when trying to orient edges (see details below).</p>
</td></tr>
<tr><td><code id="pcMI_+3A_skel.method">skel.method</code></td>
<td>
<p>Character string specifying method; the default, &quot;stable&quot;
provides an order-independent skeleton, see
<code><a href="pcalg.html#topic+skeleton">pcalg::skeleton()</a></code> for details.</p>
</td></tr>
<tr><td><code id="pcMI_+3A_conservative">conservative</code></td>
<td>
<p>Logical indicating if the conservative PC is used. See
<code><a href="pcalg.html#topic+pc">pcalg::pc()</a></code> for details.</p>
</td></tr>
<tr><td><code id="pcMI_+3A_maj.rule">maj.rule</code></td>
<td>
<p>Logical indicating that the triples shall be checked for
ambiguity using a majority rule idea, which is less strict
than the conservative PC algorithm. For more information, see
<code><a href="pcalg.html#topic+pc">pcalg::pc()</a></code>.</p>
</td></tr>
<tr><td><code id="pcMI_+3A_solve.confl">solve.confl</code></td>
<td>
<p>See <code><a href="pcalg.html#topic+pc">pcalg::pc()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="pcMI_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, detailed output is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class &quot;pcAlgo&quot; (see pcAlgo) containing an estimate of
the equivalence class of the underlying DAG.
</p>


<h3>Value</h3>

<p>See <code><a href="pcalg.html#topic+pc">pcalg::pc()</a></code> for more details.
</p>


<h3>Note</h3>

<p>This is a modified function of <code><a href="pcalg.html#topic+pc">pcalg::pc()</a></code>
from the package 'pcalg' (Kalisch et al., 2012;
http://www.jstatsoft.org/v47/i11/).
</p>


<h3>Author(s)</h3>

<p>Original code by Markus Kalisch, Martin Maechler, and Diego Colombo.
Modifications by Ronja Foraita.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
daten &lt;- mice::ampute(windspeed)$amp

## Impute missing values
imp &lt;- mice(daten)
pcMI(data = imp, label = colnames(imp$data), alpha = 0.01)


</code></pre>

<hr>
<h2 id='skeletonMI'>Estimate (Initial) Skeleton of a DAG using the PC Algorithm for Multiple
Imputed Data Sets of Continuous Data</h2><span id='topic+skeletonMI'></span>

<h3>Description</h3>

<p>This function is a modification of <code><a href="pcalg.html#topic+skeleton">pcalg::skeleton()</a></code>
to be used for multiple imputation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skeletonMI(
  data,
  alpha,
  labels,
  p,
  method = c("stable", "original"),
  m.max = Inf,
  fixedGaps = NULL,
  fixedEdges = NULL,
  NAdelete = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skeletonMI_+3A_data">data</code></td>
<td>
<p>An object of type mids, which stands for 'multiply imputed
data set', typically created by a call to function mice()</p>
</td></tr>
<tr><td><code id="skeletonMI_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="skeletonMI_+3A_labels">labels</code></td>
<td>
<p>(Optional) character vector of variable (or &quot;node&quot;) names.
Typically preferred to specifying p</p>
</td></tr>
<tr><td><code id="skeletonMI_+3A_p">p</code></td>
<td>
<p>(Optional) number of variables (or nodes). May be specified if
labels are not, in which case labels is set to 1:p.</p>
</td></tr>
<tr><td><code id="skeletonMI_+3A_method">method</code></td>
<td>
<p>Character string specifying method; the default, &quot;stable&quot;
provides an order-independent skeleton, see
<code><a href="pcalg.html#topic+pc">pcalg::pc()</a></code> for details.</p>
</td></tr>
<tr><td><code id="skeletonMI_+3A_m.max">m.max</code></td>
<td>
<p>Maximal size of the conditioning sets that are considered in
the conditional independence tests.</p>
</td></tr>
<tr><td><code id="skeletonMI_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>Logical symmetric matrix of dimension p*p. If entry [i,j]
is true, the edge i-j is removed before starting the
algorithm. Therefore, this edge is guaranteed to be absent
in the resulting graph.</p>
</td></tr>
<tr><td><code id="skeletonMI_+3A_fixededges">fixedEdges</code></td>
<td>
<p>A logical symmetric matrix of dimension p*p. If entry [i,j]
is true, the edge i-j is never considered for removal.
Therefore, this edge is guaranteed to be present in the
resulting graph.</p>
</td></tr>
<tr><td><code id="skeletonMI_+3A_nadelete">NAdelete</code></td>
<td>
<p>Logical needed for the case indepTest(*) returns NA.
If it is true, the corresponding edge is deleted, otherwise not.</p>
</td></tr>
<tr><td><code id="skeletonMI_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, detailed output is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="pcalg.html#topic+skeleton">pcalg::skeleton()</a></code> for more details.
</p>


<h3>Note</h3>

<p>This is a modified function of <code><a href="pcalg.html#topic+skeleton">pcalg::skeleton()</a></code>
from the package 'pcalg' (Kalisch et al., 2012;
http://www.jstatsoft.org/v47/i11/).
</p>


<h3>Author(s)</h3>

<p>Original code by Markus Kalisch, Martin Maechler, Alain Hauser, and Diego Colombo.
Modifications by Ronja Foraita.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gmG)
n &lt;- nrow(gmG8$x)
V &lt;- colnames(gmG8$x) # labels aka node names
## estimate Skeleton
data_mids &lt;- mice(gmG8$x, printFlag = FALSE)
(skel.fit &lt;- skeletonMI(data = data_mids, alpha = 0.01, labels = V, verbose = FALSE))
</code></pre>

<hr>
<h2 id='with_graph'>Evaluate Causal Graph Discovery Algorithm in Multiple Imputed Data sets</h2><span id='topic+with_graph'></span>

<h3>Description</h3>

<p>Evaluate Causal Graph Discovery Algorithm in Multiple Imputed Data sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_graph(data, algo = c("pc", "fci", "fciPlus", "ges"), args, score = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="with_graph_+3A_data">data</code></td>
<td>
<p>An object of type mids, which stands for 'multiply imputed
data set', typically created by a call to function mice()</p>
</td></tr>
<tr><td><code id="with_graph_+3A_algo">algo</code></td>
<td>
<p>An algorithm for causal discovery from the package 'pcalg'
(see details).</p>
</td></tr>
<tr><td><code id="with_graph_+3A_args">args</code></td>
<td>
<p>Additional arguments passed to the algo. Must be a string
vector starting with comma, i.e. &quot;, ...&quot;</p>
</td></tr>
<tr><td><code id="with_graph_+3A_score">score</code></td>
<td>
<p>Logical indicating whether a score-based or a constrained-based
algorithm is applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of S3 class <code>mice::<a href="mice.html#topic+mira-class">mira-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(windspeed)
dat &lt;- as.matrix(windspeed)

## delete some observations
set.seed(123)
dat[sample(1:length(dat), 260)] &lt;- NA

## Impute missing values under normal model
imp &lt;- mice(dat, method = "norm", printFlag = FALSE)
mylabels &lt;- names(imp$imp)
out.fci &lt;- with_graph(data = imp, 
                      algo = "fciPlus", 
                      args = ", indepTest = gaussCItest, verbose = FALSE,
                      labels = mylabels, alpha = 0.01")
                          
 out.ges &lt;- with_graph(data = imp, algo = "ges", arg = NULL, score = TRUE)
 
if (requireNamespace("Rgraphviz", quietly = TRUE)){
 oldpar &lt;- par(mfrow = c(1,2)) 
   plot(out.fci$res[[1]])
   plot(out.ges$res[[1]]$essgraph)
 par(oldpar)
 }
                                     
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
