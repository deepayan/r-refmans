<!DOCTYPE html><html><head><title>Help for package smooth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smooth}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#smooth'><p>Smooth package</p></a></li>
<li><a href='#accuracy.smooth'><p>Error measures for an estimated model</p></a></li>
<li><a href='#adam'><p>ADAM is Augmented Dynamic Adaptive Model</p></a></li>
<li><a href='#auto.ces'><p>Complex Exponential Smoothing Auto</p></a></li>
<li><a href='#auto.gum'><p>Automatic GUM</p></a></li>
<li><a href='#auto.ssarima'><p>State Space ARIMA</p></a></li>
<li><a href='#ces'><p>Complex Exponential Smoothing</p></a></li>
<li><a href='#cma'><p>Centered Moving Average</p></a></li>
<li><a href='#es'><p>Exponential Smoothing in SSOE state space model</p></a></li>
<li><a href='#forecast.adam'><p>Forecasting time series using smooth functions</p></a></li>
<li><a href='#gum'><p>Generalised Univariate Model</p></a></li>
<li><a href='#is.smooth'><p>Smooth classes checkers</p></a></li>
<li><a href='#msarima'><p>Multiple Seasonal ARIMA</p></a></li>
<li><a href='#msdecompose'><p>Multiple seasonal classical decomposition</p></a></li>
<li><a href='#multicov'><p>Function returns the multiple steps ahead covariance matrix of forecast errors</p></a></li>
<li><a href='#oes'><p>Occurrence ETS model</p></a></li>
<li><a href='#oesg'><p>Occurrence ETS, general model</p></a></li>
<li><a href='#orders'><p>Functions that extract values from the fitted model</p></a></li>
<li><a href='#plot.adam'><p>Plots for the fit and states</p></a></li>
<li><a href='#pls'><p>Prediction Likelihood Score</p></a></li>
<li><a href='#reapply'><p>Reapply the model with randomly generated initial parameters and produce forecasts</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rmultistep'><p>Multiple steps ahead forecast errors</p></a></li>
<li><a href='#sim.ces'><p>Simulate Complex Exponential Smoothing</p></a></li>
<li><a href='#sim.es'><p>Simulate Exponential Smoothing</p></a></li>
<li><a href='#sim.gum'><p>Simulate Generalised Exponential Smoothing</p></a></li>
<li><a href='#sim.oes'><p>Simulate Occurrence Part of ETS model</p></a></li>
<li><a href='#sim.sma'><p>Simulate Simple Moving Average</p></a></li>
<li><a href='#sim.ssarima'><p>Simulate SSARIMA</p></a></li>
<li><a href='#sma'><p>Simple Moving Average</p></a></li>
<li><a href='#smoothCombine'><p>Combination of forecasts of state space models</p></a></li>
<li><a href='#sowhat'><p>Function returns the ultimate answer to any question</p></a></li>
<li><a href='#ssarima'><p>State Space ARIMA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Forecasting Using State Space Models</td>
</tr>
<tr>
<td>Version:</td>
<td>4.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-18</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/config-i1/smooth">https://github.com/config-i1/smooth</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/config-i1/smooth/issues">https://github.com/config-i1/smooth/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions implementing Single Source of Error state space models for purposes of time series analysis and forecasting.
             The package includes ADAM (Svetunkov, 2023, <a href="https://openforecast.org/adam/">https://openforecast.org/adam/</a>),
             Exponential Smoothing (Hyndman et al., 2008, &lt;<a href="https://doi.org/10.1007%2F978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>&gt;),
             SARIMA (Svetunkov &amp; Boylan, 2019 &lt;<a href="https://doi.org/10.1080%2F00207543.2019.1600764">doi:10.1080/00207543.2019.1600764</a>&gt;),
             Complex Exponential Smoothing (Svetunkov &amp; Kourentzes, 2018, &lt;<a href="https://doi.org/10.13140%2FRG.2.2.24986.29123">doi:10.13140/RG.2.2.24986.29123</a>&gt;),
             Simple Moving Average (Svetunkov &amp; Petropoulos, 2018 &lt;<a href="https://doi.org/10.1080%2F00207543.2017.1380326">doi:10.1080/00207543.2017.1380326</a>&gt;)
             and several simulation functions. It also allows dealing with intermittent demand based on the
             iETS framework (Svetunkov &amp; Boylan, 2019, &lt;<a href="https://doi.org/10.13140%2FRG.2.2.35897.06242">doi:10.13140/RG.2.2.35897.06242</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), greybox (&ge; 1.0.8)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.3), stats, generics (&ge; 0.1.2), graphics,
grDevices, pracma, statmod, MASS, nloptr, utils, xtable, zoo</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.8.100.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>legion, numDeriv, testthat, knitr, rmarkdown, doMC,
doParallel, foreach</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-19 12:59:28 UTC; config</td>
</tr>
<tr>
<td>Author:</td>
<td>Ivan Svetunkov [aut, cre] (Lecturer at Centre for Marketing Analytics
    and Forecasting, Lancaster University, UK)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ivan Svetunkov &lt;ivan@svetunkov.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-19 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='smooth'>Smooth package</h2><span id='topic+smooth'></span><span id='topic+smooth-package'></span>

<h3>Description</h3>

<p>Package contains functions implementing Single Source of Error state space models for
purposes of time series analysis and forecasting.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> smooth</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;">
2016-01-27 - Inf</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL-2 </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
<p> The following functions are
included in the package:
</p>

<ul>
<li> <p><a href="#topic+es">es</a> - Exponential Smoothing in Single Source of Errors State Space form.
</p>
</li>
<li> <p><a href="#topic+ces">ces</a> - Complex Exponential Smoothing.
</p>
</li>
<li> <p><a href="#topic+gum">gum</a> - Generalised Exponential Smoothing.
</p>
</li>
<li> <p><a href="#topic+ssarima">ssarima</a> - SARIMA in state space framework.
</p>
</li>
<li> <p><a href="#topic+auto.ces">auto.ces</a> - Automatic selection between seasonal and non-seasonal CES.
</p>
</li>
<li> <p><a href="#topic+auto.ssarima">auto.ssarima</a> - Automatic selection of ARIMA orders.
</p>
</li>
<li> <p><a href="#topic+sma">sma</a> - Simple Moving Average in state space form.
</p>
</li>
<li> <p><a href="#topic+smoothCombine">smoothCombine</a> - the function that combines forecasts from es(),
ces(), gum(), ssarima() and sma() functions.
</p>
</li>
<li> <p><a href="#topic+cma">cma</a> - Centered Moving Average. This is for smoothing time series,
not for forecasting.
</p>
</li>
<li> <p><a href="#topic+sim.es">sim.es</a> - simulate time series using ETS as a model.
</p>
</li>
<li> <p><a href="#topic+sim.ces">sim.ces</a> - simulate time series using CES as a model.
</p>
</li>
<li> <p><a href="#topic+sim.ssarima">sim.ssarima</a> - simulate time series using SARIMA as a model.
</p>
</li>
<li> <p><a href="#topic+sim.gum">sim.gum</a> - simulate time series using GUM as a model.
</p>
</li>
<li> <p><a href="#topic+sim.sma">sim.sma</a> - simulate time series using SMA.
</p>
</li>
<li> <p><a href="#topic+sim.oes">sim.oes</a> - simulate time series based on occurrence part of ETS model.
</p>
</li>
<li> <p><a href="#topic+oes">oes</a> - occurrence part of the intermittent state space model.
</p>
</li></ul>

<p>There are also several methods implemented in the package for the classes
&quot;smooth&quot; and &quot;smooth.sim&quot;:
</p>

<ul>
<li> <p><a href="#topic+orders">orders</a> - extracts orders of the fitted model.
</p>
</li>
<li><p> lags - extracts lags of the fitted model.
</p>
</li>
<li><p> modelType - extracts type of the fitted model.
</p>
</li>
<li><p> forecast - produces forecast using provided model.
</p>
</li>
<li> <p><a href="#topic+multicov">multicov</a> - returns covariance matrix of multiple steps ahead forecast errors.
</p>
</li>
<li> <p><a href="#topic+pls">pls</a> - returns Prediction Likelihood Score.
</p>
</li>
<li> <p><a href="greybox.html#topic+nparam">nparam</a> - returns number of the estimated parameters.
</p>
</li>
<li><p> fitted - extracts fitted values from provided model.
</p>
</li>
<li><p> getResponse - returns actual values from the provided model.
</p>
</li>
<li><p> residuals - extracts residuals of provided model.
</p>
</li>
<li><p> plot - plots either states of the model or produced forecast (depending on what object
is passed).
</p>
</li>
<li><p> simulate - uses sim functions (<a href="#topic+sim.es">sim.es</a>, <a href="#topic+sim.ces">sim.ces</a>,
<a href="#topic+sim.ssarima">sim.ssarima</a>, <a href="#topic+sim.gum">sim.gum</a>, <a href="#topic+sim.sma">sim.sma</a> and
<a href="#topic+sim.oes">sim.oes</a>) in order to simulate data using the provided object.
</p>
</li>
<li><p> summary - provides summary of the object.
</p>
</li>
<li><p> AICc, BICc - return, guess what...
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov
</p>
<p>Maintainer: Ivan Svetunkov &lt;ivan@svetunkov.ru&gt;
</p>


<h3>References</h3>


<ul>
<li><p> Snyder, R. D., 1985. Recursive Estimation of Dynamic Linear Models.
Journal of the Royal Statistical Society, Series B (Methodological) 47 (2), 272-276.
</p>
</li>
<li><p> Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>.
</p>
</li></ul>


<ul>
<li><p> Svetunkov Ivan and Boylan John E. (2017). Multiplicative
State-Space Models for Intermittent Time Series. Working Paper of
Department of Management Science, Lancaster University, 2017:4 , 1-43.
</p>
</li>
<li><p> Teunter R., Syntetos A., Babai Z. (2011). Intermittent demand:
Linking forecasting to inventory obsolescence. European Journal of
Operational Research, 214, 606-615.
</p>
</li>
<li><p> Croston, J. (1972) Forecasting and stock control for intermittent
demands. Operational Research Quarterly, 23(3), 289-303.
</p>
</li>
<li><p> Syntetos, A., Boylan J. (2005) The accuracy of intermittent demand
estimates. International Journal of Forecasting, 21(2), 303-314.
</p>
</li></ul>


<ul>
<li><p> Svetunkov, I., Kourentzes, N. (February 2015). Complex exponential
smoothing. Working Paper of Department of Management Science, Lancaster
University 2015:1, 1-31.
</p>
</li>
<li><p> Svetunkov I., Kourentzes N. (2017) Complex Exponential Smoothing
for Time Series Forecasting. Not yet published.
</p>
</li></ul>


<ul>
<li><p> Svetunkov I. (2023) Smooth forecasting with the smooth package in R. arXiv:2301.01790.
<a href="https://doi.org/10.48550/arXiv.2301.01790">doi:10.48550/arXiv.2301.01790</a>.
</p>
</li>
<li><p> Svetunkov I. (2015 - Inf) &quot;smooth&quot; package for R - series of posts about the underlying
models and how to use them: <a href="https://openforecast.org/category/r-en/smooth/">https://openforecast.org/category/r-en/smooth/</a>.
</p>
</li></ul>


<ul>
<li><p> Kolassa, S. (2011) Combining exponential smoothing forecasts using Akaike
weights. International Journal of Forecasting, 27, pp 238 - 251.
</p>
</li></ul>


<ul>
<li><p> Taylor, J.W. and Bunn, D.W. (1999) A Quantile Regression Approach to
Generating Prediction Intervals. Management Science, Vol 45, No 2, pp
225-237.
</p>
</li>
<li><p> Lichtendahl Kenneth C., Jr., Grushka-Cockayne Yael, Winkler
Robert L., (2013) Is It Better to Average Probabilities or
Quantiles? Management Science 59(7):1594-1611. DOI:
<a href="https://doi.org/10.1287/mnsc.1120.1667">doi:10.1287/mnsc.1120.1667</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="greybox.html#topic+forecast">forecast</a>, <a href="#topic+es">es</a>,
<a href="#topic+ssarima">ssarima</a>, <a href="#topic+ces">ces</a>, <a href="#topic+gum">gum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- ts(rnorm(100,10,3),frequency=12)

adam(y,h=20,holdout=TRUE)
es(y,h=20,holdout=TRUE)
gum(y,h=20,holdout=TRUE)
auto.ces(y,h=20,holdout=TRUE)
auto.ssarima(y,h=20,holdout=TRUE)

</code></pre>

<hr>
<h2 id='accuracy.smooth'>Error measures for an estimated model</h2><span id='topic+accuracy.smooth'></span><span id='topic+accuracy.smooth.forecast'></span>

<h3>Description</h3>

<p>Function produces error measures for the provided object and the holdout values of the
response variable. Note that instead of parameters <code>x</code>, <code>test</code>, the function
accepts the vector of values in <code>holdout</code>. Also, the parameters <code>d</code> and <code>D</code>
are not supported - MASE is always calculated via division by first differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smooth'
accuracy(object, holdout = NULL, ...)

## S3 method for class 'smooth.forecast'
accuracy(object, holdout = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy.smooth_+3A_object">object</code></td>
<td>
<p>The estimated model or a forecast from the estimated model generated via
either <code>predict()</code> or <code>forecast()</code> functions.</p>
</td></tr>
<tr><td><code id="accuracy.smooth_+3A_holdout">holdout</code></td>
<td>
<p>The vector of values of the response variable in the holdout (test) set.
If not provided, then the function will return the in-sample error measures. If the
<code>holdout=TRUE</code> parameter was used in the estimation of a model, the holdout values
will be extracted automatically.</p>
</td></tr>
<tr><td><code id="accuracy.smooth_+3A_...">...</code></td>
<td>
<p>Other variables passed to the <code>forecast()</code> function (e.g. <code>newdata</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a wrapper for the <a href="greybox.html#topic+measures">measures</a> function and is implemented
for convenience.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rnorm(100, 100, 10)
ourModel &lt;- adam(y, holdout=TRUE, h=10)
accuracy(ourModel)

</code></pre>

<hr>
<h2 id='adam'>ADAM is Augmented Dynamic Adaptive Model</h2><span id='topic+adam'></span><span id='topic+simulate.adam'></span><span id='topic+auto.adam'></span><span id='topic+sm.adam'></span>

<h3>Description</h3>

<p>Function constructs an advanced Single Source of Error model, based on ETS
taxonomy and ARIMA elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adam(data, model = "ZXZ", lags = c(frequency(data)), orders = list(ar =
  c(0), i = c(0), ma = c(0), select = FALSE), constant = FALSE,
  formula = NULL, regressors = c("use", "select", "adapt"),
  occurrence = c("none", "auto", "fixed", "general", "odds-ratio",
  "inverse-odds-ratio", "direct"), distribution = c("default", "dnorm",
  "dlaplace", "ds", "dgnorm", "dlnorm", "dinvgauss", "dgamma"),
  loss = c("likelihood", "MSE", "MAE", "HAM", "LASSO", "RIDGE", "MSEh",
  "TMSE", "GTMSE", "MSCE"), outliers = c("ignore", "use", "select"),
  level = 0.99, h = 0, holdout = FALSE, persistence = NULL,
  phi = NULL, initial = c("optimal", "backcasting", "complete"),
  arma = NULL, ic = c("AICc", "AIC", "BIC", "BICc"), bounds = c("usual",
  "admissible", "none"), silent = TRUE, ...)

## S3 method for class 'adam'
simulate(object, nsim = 1, seed = NULL,
  obs = nobs(object), ...)

auto.adam(data, model = "ZXZ", lags = c(frequency(data)),
  orders = list(ar = c(3, 3), i = c(2, 1), ma = c(3, 3), select = TRUE),
  formula = NULL, regressors = c("use", "select", "adapt"),
  occurrence = c("none", "auto", "fixed", "general", "odds-ratio",
  "inverse-odds-ratio", "direct"), distribution = c("dnorm", "dlaplace",
  "ds", "dgnorm", "dlnorm", "dinvgauss", "dgamma"), outliers = c("ignore",
  "use", "select"), level = 0.99, h = 0, holdout = FALSE,
  persistence = NULL, phi = NULL, initial = c("optimal", "backcasting",
  "complete"), arma = NULL, ic = c("AICc", "AIC", "BIC", "BICc"),
  bounds = c("usual", "admissible", "none"), silent = TRUE,
  parallel = FALSE, ...)

## S3 method for class 'adam'
sm(object, model = "YYY", lags = NULL, orders = list(ar =
  c(0), i = c(0), ma = c(0), select = FALSE), constant = FALSE,
  formula = NULL, regressors = c("use", "select", "adapt"), data = NULL,
  persistence = NULL, phi = NULL, initial = c("optimal", "backcasting"),
  arma = NULL, ic = c("AICc", "AIC", "BIC", "BICc"), bounds = c("usual",
  "admissible", "none"), silent = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adam_+3A_data">data</code></td>
<td>
<p>Vector, containing data needed to be forecasted. If a matrix (or
data.frame / data.table) is provided, then the first column is used as a
response variable, while the rest of the matrix is used as a set of explanatory
variables. <code>formula</code> can be used in the latter case in order to define what
relation to have.</p>
</td></tr>
<tr><td><code id="adam_+3A_model">model</code></td>
<td>
<p>The type of ETS model. The first letter stands for the type of
the error term (&quot;A&quot; or &quot;M&quot;), the second (and sometimes the third as well) is for
the trend (&quot;N&quot;, &quot;A&quot;, &quot;Ad&quot;, &quot;M&quot; or &quot;Md&quot;), and the last one is for the type of
seasonality (&quot;N&quot;, &quot;A&quot; or &quot;M&quot;). In case of several lags, the seasonal components
are assumed to be the same. The model is then printed out as
ETS(M,Ad,M)[m1,m2,...], where m1, m2, ... are the lags specified by the
<code>lags</code> parameter.
There are several options for the <code>model</code> besides the conventional ones,
which rely on information criteria:
</p>

<ol>
<li> <p><code>model="ZZZ"</code> means that the model will be selected based on the
chosen information criteria type. The Branch and Bound is used in the process.
</p>
</li>
<li> <p><code>model="XXX"</code> means that only additive components are tested, using
Branch and Bound.
</p>
</li>
<li> <p><code>model="YYY"</code> implies selecting between multiplicative components.
</p>
</li>
<li> <p><code>model="CCC"</code> triggers the combination of forecasts of models using
information criteria weights (Kolassa, 2011).
</p>
</li>
<li><p> combinations between these four and the classical components are also
accepted. For example, <code>model="CAY"</code> will combine models with additive
trend and either none or multiplicative seasonality.
</p>
</li>
<li> <p><code>model="PPP"</code> will produce the selection between pure additive and
pure multiplicative models. &quot;P&quot; stands for &quot;Pure&quot;. This cannot be mixed with
other types of components.
</p>
</li>
<li> <p><code>model="FFF"</code> will select between all the 30 types of models. &quot;F&quot;
stands for &quot;Full&quot;. This cannot be mixed with other types of components.
</p>
</li>
<li><p> The parameter <code>model</code> can also be a vector of names of models for a
finer tuning (pool of models). For example, <code>model=c("ANN","AAA")</code> will
estimate only two models and select the best of them.
</p>
</li></ol>

<p>Also, <code>model</code> can accept a previously estimated adam and use all
its parameters.
</p>
<p>Keep in mind that model selection with &quot;Z&quot; components uses Branch and Bound
algorithm and may skip some models that could have slightly smaller
information criteria. If you want to do a exhaustive search, you would need
to list all the models to check as a vector.
</p>
<p>The default value is set to <code>"ZXZ"</code>, because the multiplicative trend is explosive
and dangerous. It should be used only for each separate time series, not for the
automated predictions for big  datasets.</p>
</td></tr>
<tr><td><code id="adam_+3A_lags">lags</code></td>
<td>
<p>Defines lags for the corresponding components. All components
count, starting from level, so ETS(M,M,M) model for monthly data will have
<code>lags=c(1,1,12)</code>. However, the function will also accept <code>lags=c(12)</code>,
assuming that the lags 1 were dropped. In case of ARIMA, lags specify what should be
the seasonal component lag. e.g. <code>lags=c(1,12)</code> will lead to the
seasonal ARIMA with m=12. This can accept several lags, supporting multiple seasonal ETS
and ARIMA models.</p>
</td></tr>
<tr><td><code id="adam_+3A_orders">orders</code></td>
<td>
<p>The order of ARIMA to be included in the model. This should be passed
either as a vector (in which case the non-seasonal ARIMA is assumed) or as a list of
a type <code>orders=list(ar=c(p,P),i=c(d,D),ma=c(q,Q))</code>, in which case the <code>lags</code>
variable is used in order to determine the seasonality m. See <a href="#topic+msarima">msarima</a>
for details.
In addition, <code>orders</code> accepts one more parameter: <code>orders=list(select=FALSE)</code>.
If <code>TRUE</code>, then the function will select the most appropriate order using a
mechanism similar to <code>auto.msarima()</code>, but implemented in <code>auto.adam()</code>.
The values <code>list(ar=...,i=...,ma=...)</code> specify the maximum orders to check in
this case.</p>
</td></tr>
<tr><td><code id="adam_+3A_constant">constant</code></td>
<td>
<p>Logical, determining, whether the constant is needed in the model or not.
This is mainly needed for ARIMA part of the model, but can be used for ETS as well. In
case of pure regression, this is completely ignored (use <code>formula</code> instead).</p>
</td></tr>
<tr><td><code id="adam_+3A_formula">formula</code></td>
<td>
<p>Formula to use in case of explanatory variables. If <code>NULL</code>,
then all the variables are used as is. Can also include <code>trend</code>, which would add
the global trend. Only needed if <code>data</code> is a matrix or if <code>trend</code> is provided.</p>
</td></tr>
<tr><td><code id="adam_+3A_regressors">regressors</code></td>
<td>
<p>The variable defines what to do with the provided explanatory
variables:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done,
<code>"adapt"</code> will trigger the mechanism of time varying parameters for the
explanatory variables.</p>
</td></tr>
<tr><td><code id="adam_+3A_occurrence">occurrence</code></td>
<td>
<p>The type of model used in probability estimation. Can be
<code>"none"</code> - none,
<code>"fixed"</code> - constant probability,
<code>"general"</code> - the general Beta model with two parameters,
<code>"odds-ratio"</code> - the Odds-ratio model with b=1 in Beta distribution,
<code>"inverse-odds-ratio"</code> - the model with a=1 in Beta distribution,
<code>"direct"</code> - the TSB-like (Teunter et al., 2011) probability update
mechanism a+b=1,
<code>"auto"</code> - the automatically selected type of occurrence model.
</p>
<p>The type of model used in the occurrence is equal to the one provided in the
<code>model</code> parameter.
</p>
<p>Also, a model produced using <a href="#topic+oes">oes</a> or <a href="greybox.html#topic+alm">alm</a> function
can be used here.</p>
</td></tr>
<tr><td><code id="adam_+3A_distribution">distribution</code></td>
<td>
<p>what density function to assume for the error term. The full
name of the distribution should be provided, starting with the letter &quot;d&quot; -
&quot;density&quot;. The names align with the names of distribution functions in R.
For example, see <a href="stats.html#topic+dnorm">dnorm</a>. For detailed explanation of available
distributions, see vignette in greybox package: <code>vignette("greybox","alm")</code>.</p>
</td></tr>
<tr><td><code id="adam_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization. <code>loss</code> can
be:
</p>

<ul>
<li> <p><code>likelihood</code> - the model is estimated via the maximisation of the
likelihood of the function specified in <code>distribution</code>;
</p>
</li>
<li> <p><code>MSE</code> (Mean Squared Error),
</p>
</li>
<li> <p><code>MAE</code> (Mean Absolute Error),
</p>
</li>
<li> <p><code>HAM</code> (Half Absolute Moment),
</p>
</li>
<li> <p><code>LASSO</code> - use LASSO to shrink the parameters of the model;
</p>
</li>
<li> <p><code>RIDGE</code> - use RIDGE to shrink the parameters of the model;
</p>
</li>
<li> <p><code>TMSE</code> - Trace Mean Squared Error,
</p>
</li>
<li> <p><code>GTMSE</code> - Geometric Trace Mean Squared Error,
</p>
</li>
<li> <p><code>MSEh</code> - optimisation using only h-steps ahead error,
</p>
</li>
<li> <p><code>MSCE</code> - Mean Squared Cumulative Error.
</p>
</li></ul>

<p>In case of LASSO / RIDGE, the variables are not normalised prior to the estimation,
but the parameters are divided by the mean values of explanatory variables.
</p>
<p>Note that model selection and combination works properly only for the default
<code>loss="likelihood"</code>.
</p>
<p>Furthermore, just for fun the absolute and half analogues of multistep estimators
are available: <code>MAEh</code>, <code>TMAE</code>, <code>GTMAE</code>, <code>MACE</code>,
<code>HAMh</code>, <code>THAM</code>, <code>GTHAM</code>, <code>CHAM</code>.
</p>
<p>Last but not least, user can provide their own function here as well, making sure
that it accepts parameters <code>actual</code>, <code>fitted</code> and <code>B</code>. Here is an
example:
</p>
<p><code>lossFunction &lt;- function(actual, fitted, B) return(mean(abs(actual-fitted)))</code>
</p>
<p><code>loss=lossFunction</code></p>
</td></tr>
<tr><td><code id="adam_+3A_outliers">outliers</code></td>
<td>
<p>Defines what to do with outliers: <code>"ignore"</code>, so just returning the model,
<code>"use"</code> - detect outliers based on specified <code>level</code> and include dummies for them in the model,
or detect and <code>"select"</code> those of them that reduce <code>ic</code> value.</p>
</td></tr>
<tr><td><code id="adam_+3A_level">level</code></td>
<td>
<p>What confidence level to use for detection of outliers. The default is 99%. The specific
bounds of confidence interval depend on the distribution used in the model.</p>
</td></tr>
<tr><td><code id="adam_+3A_h">h</code></td>
<td>
<p>The forecast horizon. Mainly needed for the multistep loss functions.</p>
</td></tr>
<tr><td><code id="adam_+3A_holdout">holdout</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the holdout of the size <code>h</code>
is taken from the data (can be used for the model testing purposes).</p>
</td></tr>
<tr><td><code id="adam_+3A_persistence">persistence</code></td>
<td>
<p>Persistence vector <code class="reqn">g</code>, containing smoothing
parameters. If <code>NULL</code>, then estimated. Can be also passed as a names list of
the type: <code>persistence=list(level=0.1, trend=0.05, seasonal=c(0.1,0.2),
xreg=c(0.1,0.2))</code>. Dropping some elements from the named list will make the function
estimate them. e.g. if you don't specify seasonal in the persistence for the ETS(M,N,M)
model, it will be estimated.</p>
</td></tr>
<tr><td><code id="adam_+3A_phi">phi</code></td>
<td>
<p>Value of damping parameter. If <code>NULL</code> then it is estimated.
Only applicable for damped-trend models.</p>
</td></tr>
<tr><td><code id="adam_+3A_initial">initial</code></td>
<td>
<p>Can be either character or a list, or a vector of initial states.
If it is character, then it can be <code>"optimal"</code>, meaning that all initial
states are optimised, or <code>"backcasting"</code>, meaning that the initials of
dynamic part of the model are produced using backcasting procedure (advised
for data with high frequency). In the latter case, the parameters of the
explanatory variables are optimised. This is recommended for ETSX and ARIMAX
models. Alternatively, you can set <code>initial="complete"</code> backcasting,
which means that all states (including explanatory variables) are initialised
via backcasting.
</p>
<p>If a use provides a list of values, it is recommended to use the named one and
to provide the initial components that are available. For example:
<code>initial=list(level=1000,trend=10,seasonal=list(c(1,2),c(1,2,3,4)),
arima=1,xreg=100)</code>. If some of the components are needed by the model, but are
not provided in the list, they will be estimated. If the vector is provided,
then it is expected that the components will be provided inthe same order as above,
one after another without any gaps.</p>
</td></tr>
<tr><td><code id="adam_+3A_arma">arma</code></td>
<td>
<p>Either the named list or a vector with AR / MA parameters ordered lag-wise.
The number of elements should correspond to the specified orders e.g.
<code>orders=list(ar=c(1,1),ma=c(1,1)), lags=c(1,4), arma=list(ar=c(0.9,0.8),ma=c(-0.3,0.3))</code></p>
</td></tr>
<tr><td><code id="adam_+3A_ic">ic</code></td>
<td>
<p>The information criterion to use in the model selection / combination
procedure.</p>
</td></tr>
<tr><td><code id="adam_+3A_bounds">bounds</code></td>
<td>
<p>The type of bounds for the persistence to use in the model
estimation. Can be either <code>admissible</code> - guaranteeing the stability of the
model, <code>usual</code> - restricting the values with (0, 1) or <code>none</code> - no
restrictions (potentially dangerous).</p>
</td></tr>
<tr><td><code id="adam_+3A_silent">silent</code></td>
<td>
<p>Specifies, whether to provide the progress of the function or not.
If <code>TRUE</code>, then the function will print what it does and how much it has
already done.</p>
</td></tr>
<tr><td><code id="adam_+3A_...">...</code></td>
<td>
<p>Other non-documented parameters. For example, <code>FI=TRUE</code> will
make the function also produce Fisher Information matrix, which then can be
used to calculated variances of smoothing parameters and initial states of
the model. This is calculated based on the hessian of log-likelihood function and
accepts <code>stepSize</code> parameter, determining how it is calculated. The default value
is <code>stepSize=.Machine$double.eps^(1/4)</code>. This is used in the <a href="stats.html#topic+vcov">vcov</a> method.
Starting values of parameters can be passed via <code>B</code>, while the upper and lower
bounds should be passed in <code>ub</code> and <code>lb</code> respectively. In this case they
will be used for optimisation. These values should have the length equal
to the number of parameters to estimate in the following order:
</p>

<ol>
<li><p> All smoothing parameters (for the states and then for the explanatory variables);
</p>
</li>
<li><p> Damping parameter (if needed);
</p>
</li>
<li><p> ARMA parameters;
</p>
</li>
<li><p> All the initial values (for the states and then for the explanatory variables).
</p>
</li></ol>

<p>You can also pass parameters to the optimiser in order to fine tune its work:
</p>

<ul>
<li> <p><code>maxeval</code> - maximum number of evaluations to carry out. The default is 40 per
estimated parameter for ETS and / or ARIMA and at least 1000 if explanatory variables
are introduced in the model (100 per parameter for explanatory variables, but not less
than 1000);
</p>
</li>
<li> <p><code>maxtime</code> - stop, when the optimisation time (in seconds) exceeds this;
</p>
</li>
<li> <p><code>xtol_rel</code> - the relative precision of the optimiser (the default is 1E-6);
</p>
</li>
<li> <p><code>xtol_abs</code> - the absolute precision of the optimiser (the default is 1E-8);
</p>
</li>
<li> <p><code>ftol_rel</code> - the stopping criterion in case of the relative change in the loss
function (the default is 1E-8);
</p>
</li>
<li> <p><code>ftol_abs</code> - the stopping criterion in case of the absolute change in the loss
function (the default is 0 - not used);
</p>
</li>
<li> <p><code>algorithm</code> - the algorithm to use in optimisation
(by default, <code>"NLOPT_LN_NELDERMEAD"</code> is used);
</p>
</li>
<li> <p><code>print_level</code> - the level of output for the optimiser (0 by default).
If equal to 41, then the detailed results of the optimisation are returned.
</p>
</li></ul>

<p>You can read more about these parameters by running the function
<a href="nloptr.html#topic+nloptr.print.options">nloptr.print.options</a>.
Finally, the parameter <code>lambda</code> for LASSO / RIDGE, <code>alpha</code> for the Asymmetric
Laplace, <code>shape</code> for the Generalised Normal and <code>nu</code> for Student's distributions
can be provided here as well.</p>
</td></tr>
<tr><td><code id="adam_+3A_object">object</code></td>
<td>
<p>The model previously estimated using <code>adam()</code> function.</p>
</td></tr>
<tr><td><code id="adam_+3A_nsim">nsim</code></td>
<td>
<p>Number of series to generate from the model.</p>
</td></tr>
<tr><td><code id="adam_+3A_seed">seed</code></td>
<td>
<p>Random seed used in simulation of data.</p>
</td></tr>
<tr><td><code id="adam_+3A_obs">obs</code></td>
<td>
<p>Number of observations to produce in the simulated data.</p>
</td></tr>
<tr><td><code id="adam_+3A_parallel">parallel</code></td>
<td>
<p>If TRUE, the estimation of ADAM models is done in parallel (used in <code>auto.adam</code> only).
If the number is provided (e.g. <code>parallel=41</code>), then the specified number of cores is set up.
WARNING! Packages <code>foreach</code> and either <code>doMC</code> (Linux and Mac only)
or <code>doParallel</code> are needed in order to run the function in parallel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function estimates ADAM in a form of the Single Source of Error state space
model of the following type:
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = o_t (w(v_{t-l}) + h(x_t, a_{t-1}) + r(v_{t-l}) \epsilon_{t})</code>
</p>

<p style="text-align: center;"><code class="reqn">v_{t} = f(v_{t-l}, a_{t-1}) + g(v_{t-l}, a_{t-1}, x_{t}) \epsilon_{t}</code>
</p>

<p>Where <code class="reqn">o_{t}</code> is the Bernoulli distributed random variable (in case of
normal data it equals to 1 for all observations), <code class="reqn">v_{t}</code> is the state
vector and <code class="reqn">l</code> is the vector of lags, <code class="reqn">x_t</code> is the vector of
exogenous variables. w(.) is the measurement function, r(.) is the error
function, f(.) is the transition function, g(.) is the persistence
function and <code class="reqn">a_t</code> is the vector of parameters for exogenous variables.
Finally, <code class="reqn">\epsilon_{t}</code> is the error term.
</p>
<p>The implemented model allows introducing several seasonal states and supports
intermittent data via the <code>occurrence</code> variable.
</p>
<p>The error term <code class="reqn">\epsilon_t</code> can follow different distributions, which
are regulated via the <code>distribution</code> parameter. This includes:
</p>

<ol>
<li> <p><code>default</code> - Normal distribution is used for the Additive error models,
Gamma is used for the Multiplicative error models.
</p>
</li>
<li><p> dnorm - <a href="stats.html#topic+Normal">Normal</a> distribution,
</p>
</li>
<li> <p><a href="greybox.html#topic+dlaplace">dlaplace</a> - Laplace distribution,
</p>
</li>
<li> <p><a href="greybox.html#topic+ds">ds</a> - S distribution,
</p>
</li>
<li> <p><a href="greybox.html#topic+dgnorm">dgnorm</a> - Generalised Normal distribution,
</p>
</li>
<li> <p><a href="stats.html#topic+dlnorm">dlnorm</a> - Log-Normal distribution,
</p>
</li>
<li> <p><a href="stats.html#topic+dgamma">dgamma</a> - Gamma distribution,
</p>
</li>
<li> <p><a href="statmod.html#topic+dinvgauss">dinvgauss</a> - Inverse Gaussian distribution,
</p>
</li></ol>

<p>For some more information about the model and its implementation, see the
vignette: <code>vignette("adam","smooth")</code>. The more detailed explanation
of ADAM is provided by Svetunkov (2021).
</p>
<p>The function <code>auto.adam()</code> tries out models with the specified
distributions and returns the one with the most suitable one based on selected
information criterion.
</p>
<p><a href="greybox.html#topic+sm">sm</a>.adam method estimates the scale model for the already
estimated adam. In order for ADAM to take the SM model into account, the
latter needs to be recorded in the former, amending the likelihood and the number
of degrees of freedom. This can be done using <a href="greybox.html#topic+implant">implant</a> method.
</p>


<h3>Value</h3>

<p>Object of class &quot;adam&quot; is returned. It contains the list of the
following values:
</p>

<ul>
<li> <p><code>model</code> - the name of the constructed model,
</p>
</li>
<li> <p><code>timeElapsed</code> - the time elapsed for the estimation of the model,
</p>
</li>
<li> <p><code>data</code> - the in-sample part of the data used for the training of the model. Includes
the actual values in the first column,
</p>
</li>
<li> <p><code>holdout</code> - the holdout part of the data, excluded for purposes of model evaluation,
</p>
</li>
<li> <p><code>fitted</code> - the vector of fitted values,
</p>
</li>
<li> <p><code>residuals</code> - the vector of residuals,
</p>
</li>
<li> <p><code>forecast</code> - the point forecast for h steps ahead (by default NA is returned). NOTE
that these do not always correspond to the conditional expectations for ETS models. See ADAM
textbook, Section 6.4. for details (<a href="https://openforecast.org/adam/ETSTaxonomyMaths.html">https://openforecast.org/adam/ETSTaxonomyMaths.html</a>),
</p>
</li>
<li> <p><code>states</code> - the matrix of states with observations in rows and states in columns,
</p>
</li>
<li> <p><code>persisten</code> - the vector of smoothing parameters,
</p>
</li>
<li> <p><code>phi</code> - the value of damping parameter,
</p>
</li>
<li> <p><code>transition</code> - the transition matrix,
</p>
</li>
<li> <p><code>measurement</code> - the measurement matrix with observations in rows and state elements
in columns,
</p>
</li>
<li> <p><code>initial</code> - the named list of initial values, including level, trend, seasonal, ARIMA
and xreg components,
</p>
</li>
<li> <p><code>initialEstimated</code> - the named vector, defining which of the initials were estimated in
the model,
</p>
</li>
<li> <p><code>initialType</code> - the type of initialisation used (&quot;optimal&quot; / &quot;complete&quot; / &quot;provided&quot;),
</p>
</li>
<li> <p><code>orders</code> - the orders of ARIMA used in the estimation,
</p>
</li>
<li> <p><code>constant</code> - the value of the constant (if it was included),
</p>
</li>
<li> <p><code>arma</code> - the list of AR / MA parameters used in the model,
</p>
</li>
<li> <p><code>nParam</code> - the matrix of the estimated / provided parameters,
</p>
</li>
<li> <p><code>occurrence</code> - the oes model used for the occurrence part of the model,
</p>
</li>
<li> <p><code>formula</code> - the formula used for the explanatory variables expansion,
</p>
</li>
<li> <p><code>loss</code> - the type of loss function used in the estimation,
</p>
</li>
<li> <p><code>lossValue</code> - the value of that loss function,
</p>
</li>
<li> <p><code>logLik</code> - the value of the log-likelihood,
</p>
</li>
<li> <p><code>distribution</code> - the distribution function used in the calculation of the likelihood,
</p>
</li>
<li> <p><code>scale</code> - the value of the scale parameter,
</p>
</li>
<li> <p><code>lambda</code> - the value of the parameter used in LASSO / dalaplace / dt,
</p>
</li>
<li> <p><code>B</code> - the vector of all estimated parameters,
</p>
</li>
<li> <p><code>lags</code> - the vector of lags used in the model construction,
</p>
</li>
<li> <p><code>lagsAll</code> - the vector of the internal lags used in the model,
</p>
</li>
<li> <p><code>profile</code> - the matrix with the profile used in the construction of the model,
</p>
</li>
<li> <p><code>profileInitial</code> - the matrix with the initial profile (for the before the sample values),
</p>
</li>
<li> <p><code>call</code> - the call used in the evaluation,
</p>
</li>
<li> <p><code>bounds</code> - the type of bounds used in the process,
</p>
</li>
<li> <p><code>other</code> - the list with other parameters, such as shape for distributions or ARIMA
polynomials.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov I. (2023) Smooth forecasting with the smooth package in R. arXiv:2301.01790.
<a href="https://doi.org/10.48550/arXiv.2301.01790">doi:10.48550/arXiv.2301.01790</a>.
</p>
</li>
<li><p> Svetunkov I. (2015 - Inf) &quot;smooth&quot; package for R - series of posts about the underlying
models and how to use them: <a href="https://openforecast.org/category/r-en/smooth/">https://openforecast.org/category/r-en/smooth/</a>.
</p>
</li></ul>


<ul>
<li><p> Svetunkov, I. (2023). Forecasting and Analytics with the Augmented
Dynamic Adaptive Model (ADAM) (1st ed.). Chapman and Hall/CRC.
<a href="https://doi.org/10.1201/9781003452652">doi:10.1201/9781003452652</a>, online version: <a href="https://openforecast.org/adam/">https://openforecast.org/adam/</a>.
</p>
</li></ul>


<ul>
<li><p> Snyder, R. D., 1985. Recursive Estimation of Dynamic Linear Models.
Journal of the Royal Statistical Society, Series B (Methodological) 47 (2), 272-276.
</p>
</li>
<li><p> Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>.
</p>
</li></ul>


<ul>
<li><p> Svetunkov Ivan and Boylan John E. (2017). Multiplicative
State-Space Models for Intermittent Time Series. Working Paper of
Department of Management Science, Lancaster University, 2017:4 , 1-43.
</p>
</li>
<li><p> Teunter R., Syntetos A., Babai Z. (2011). Intermittent demand:
Linking forecasting to inventory obsolescence. European Journal of
Operational Research, 214, 606-615.
</p>
</li>
<li><p> Croston, J. (1972) Forecasting and stock control for intermittent
demands. Operational Research Quarterly, 23(3), 289-303.
</p>
</li>
<li><p> Syntetos, A., Boylan J. (2005) The accuracy of intermittent demand
estimates. International Journal of Forecasting, 21(2), 303-314.
</p>
</li></ul>


<ul>
<li><p> Kolassa, S. (2011) Combining exponential smoothing forecasts using Akaike
weights. International Journal of Forecasting, 27, pp 238 - 251.
</p>
</li></ul>


<ul>
<li><p> Taylor, J.W. and Bunn, D.W. (1999) A Quantile Regression Approach to
Generating Prediction Intervals. Management Science, Vol 45, No 2, pp
225-237.
</p>
</li>
<li><p> Lichtendahl Kenneth C., Jr., Grushka-Cockayne Yael, Winkler
Robert L., (2013) Is It Better to Average Probabilities or
Quantiles? Management Science 59(7):1594-1611. DOI:
<a href="https://doi.org/10.1287/mnsc.1120.1667">doi:10.1287/mnsc.1120.1667</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+es">es</a>, <a href="#topic+msarima">msarima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### The main examples are provided in the adam vignette, check it out via:
## Not run: vignette("adam","smooth")

# Model selection using a specified pool of models
ourModel &lt;- adam(rnorm(100,100,10), model=c("ANN","ANA","AAA"), lags=c(5,10))
adamSummary &lt;- summary(ourModel)
xtable(adamSummary)

forecast(ourModel)
par(mfcol=c(3,4))
plot(ourModel, c(1:11))

# Model combination using a specified pool
ourModel &lt;- adam(rnorm(100,100,10), model=c("ANN","AAN","MNN","CCC"),
                          lags=c(5,10))

# ADAM ARIMA
ourModel &lt;- adam(rnorm(100,100,10), model="NNN",
                          lags=c(1,4), orders=list(ar=c(1,0),i=c(1,0),ma=c(1,1)))

# Fit ADAM to the data
ourModel &lt;- adam(rnorm(100,100,10), model="AAdN")
# Simulate the data
x &lt;- simulate(ourModel)

# Automatic selection of appropriate distribution and orders of ADAM ETS+ARIMA
ourModel &lt;- auto.adam(rnorm(100,100,10), model="ZZN", lags=c(1,4),
                      orders=list(ar=c(2,2),ma=c(2,2),select=TRUE))

</code></pre>

<hr>
<h2 id='auto.ces'>Complex Exponential Smoothing Auto</h2><span id='topic+auto.ces'></span>

<h3>Description</h3>

<p>Function estimates CES in state space form with information potential equal
to errors with different seasonality types and chooses the one with the
lowest IC value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto.ces(y, models = c("none", "simple", "full"),
  initial = c("backcasting", "optimal"), ic = c("AICc", "AIC", "BIC",
  "BICc"), loss = c("likelihood", "MSE", "MAE", "HAM", "MSEh", "TMSE",
  "GTMSE", "MSCE"), h = 10, holdout = FALSE, cumulative = FALSE,
  interval = c("none", "parametric", "likelihood", "semiparametric",
  "nonparametric"), level = 0.95, bounds = c("admissible", "none"),
  silent = c("all", "graph", "legend", "output", "none"), xreg = NULL,
  regressors = c("use", "select"), initialX = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto.ces_+3A_y">y</code></td>
<td>
<p>Vector or ts object, containing data needed to be forecasted.</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_models">models</code></td>
<td>
<p>The vector containing several types of seasonality that should
be used in CES selection. See <a href="#topic+ces">ces</a> for more details about the
possible types of seasonal models.</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_initial">initial</code></td>
<td>
<p>Can be either character or a vector of initial states. If it
is character, then it can be <code>"optimal"</code>, meaning that the initial
states are optimised, or <code>"backcasting"</code>, meaning that the initials are
produced using backcasting procedure.</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_ic">ic</code></td>
<td>
<p>The information criterion used in the model selection procedure.</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization. <code>loss</code> can
be: <code>likelihood</code> (assuming Normal distribution of error term),
<code>MSE</code> (Mean Squared Error), <code>MAE</code> (Mean Absolute Error),
<code>HAM</code> (Half Absolute Moment), <code>TMSE</code> - Trace Mean Squared Error,
<code>GTMSE</code> - Geometric Trace Mean Squared Error, <code>MSEh</code> - optimisation
using only h-steps ahead error, <code>MSCE</code> - Mean Squared Cumulative Error.
If <code>loss!="MSE"</code>, then likelihood and model selection is done based
on equivalent <code>MSE</code>. Model selection in this cases becomes not optimal.
</p>
<p>There are also available analytical approximations for multistep functions:
<code>aMSEh</code>, <code>aTMSE</code> and <code>aGTMSE</code>. These can be useful in cases
of small samples.
</p>
<p>Finally, just for fun the absolute and half analogues of multistep estimators
are available: <code>MAEh</code>, <code>TMAE</code>, <code>GTMAE</code>, <code>MACE</code>, <code>TMAE</code>,
<code>HAMh</code>, <code>THAM</code>, <code>GTHAM</code>, <code>CHAM</code>.</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_h">h</code></td>
<td>
<p>Length of forecasting horizon.</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_holdout">holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_cumulative">cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_interval">interval</code></td>
<td>
<p>Type of interval to construct. This can be:
</p>

<ul>
<li> <p><code>"none"</code>, aka <code>"n"</code> - do not produce prediction
interval.
</p>
</li>
<li> <p><code>"parametric"</code>, <code>"p"</code> - use state-space structure of ETS. In
case of mixed models this is done using simulations, which may take longer
time than for the pure additive and pure multiplicative models. This type
of interval relies on unbiased estimate of in-sample error variance, which
divides the sume of squared errors by T-k rather than just T.
</p>
</li>
<li> <p><code>"likelihood"</code>, <code>"l"</code> - these are the same as <code>"p"</code>, but
relies on the biased estimate of variance from the likelihood (division by
T, not by T-k).
</p>
</li>
<li> <p><code>"semiparametric"</code>, <code>"sp"</code> - interval based on covariance
matrix of 1 to h steps ahead errors and assumption of normal / log-normal
distribution (depending on error type).
</p>
</li>
<li> <p><code>"nonparametric"</code>, <code>"np"</code> - interval based on values from a
quantile regression on error matrix (see Taylor and Bunn, 1999). The model
used in this process is e[j] = a j^b, where j=1,..,h.
</p>
</li></ul>

<p>The parameter also accepts <code>TRUE</code> and <code>FALSE</code>. The former means that
parametric interval are constructed, while the latter is equivalent to
<code>none</code>.
If the forecasts of the models were combined, then the interval are combined
quantile-wise (Lichtendahl et al., 2013).</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_level">level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_bounds">bounds</code></td>
<td>
<p>What type of bounds to use in the model estimation. The first
letter can be used instead of the whole word.</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_silent">silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words (&quot;n&quot;,
&quot;a&quot;, &quot;g&quot;, &quot;l&quot;, &quot;o&quot;).</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_xreg">xreg</code></td>
<td>
<p>The vector (either numeric or time series) or the matrix (or
data.frame) of exogenous variables that should be included in the model. If
matrix included than columns should contain variables and rows - observations.
Note that <code>xreg</code> should have number of observations equal either to
in-sample or to the whole series. If the number of observations in
<code>xreg</code> is equal to in-sample, then values for the holdout sample are
produced using <a href="#topic+es">es</a> function.</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_regressors">regressors</code></td>
<td>
<p>The variable defines what to do with the provided xreg:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done.
<code>"combine"</code> will be available at some point in future...</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_initialx">initialX</code></td>
<td>
<p>The vector of initial parameters for exogenous variables.
Ignored if <code>xreg</code> is NULL.</p>
</td></tr>
<tr><td><code id="auto.ces_+3A_...">...</code></td>
<td>
<p>Other non-documented parameters.  For example <code>FI=TRUE</code>
will make the function produce Fisher Information matrix, which then can be
used to calculated variances of parameters of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates several Complex Exponential Smoothing in the
state space 2 described in Svetunkov, Kourentzes (2015) with the information
potential equal to the approximation error using different types of
seasonality and chooses the one with the lowest value of information
criterion.
</p>
<p>For some more information about the model and its implementation, see the
vignette: <code>vignette("ces","smooth")</code>
</p>


<h3>Value</h3>

<p>Object of class &quot;smooth&quot; is returned. See <a href="#topic+ces">ces</a> for
details.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov, I., Kourentzes, N. (February 2015). Complex exponential
smoothing. Working Paper of Department of Management Science, Lancaster
University 2015:1, 1-31.
</p>
</li>
<li><p> Svetunkov I., Kourentzes N. (2017) Complex Exponential Smoothing
for Time Series Forecasting. Not yet published.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ces">ces</a>, <a href="#topic+es">es</a>,
<a href="greybox.html#topic+forecast">forecast</a>, <a href="stats.html#topic+ts">ts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- ts(rnorm(100,10,3),frequency=12)
# CES with and without holdout
auto.ces(y,h=20,holdout=TRUE)
auto.ces(y,h=20,holdout=FALSE)


# Selection between "none" and "full" seasonalities
auto.ces(AirPassengers,h=8,holdout=TRUE,
                   models=c("n","f"),interval="p",level=0.8,ic="AIC")

ourModel &lt;- auto.ces(AirPassengers,interval="sp")

summary(ourModel)
forecast(ourModel)
plot(forecast(ourModel))

</code></pre>

<hr>
<h2 id='auto.gum'>Automatic GUM</h2><span id='topic+auto.gum'></span>

<h3>Description</h3>

<p>Function selects the order of GUM model based on information criteria,
using fancy branch and bound mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto.gum(y, orders = 3, lags = frequency(y), type = c("additive",
  "multiplicative", "select"), initial = c("backcasting", "optimal"),
  ic = c("AICc", "AIC", "BIC", "BICc"), loss = c("likelihood", "MSE",
  "MAE", "HAM", "MSEh", "TMSE", "GTMSE", "MSCE"), h = 10, holdout = FALSE,
  cumulative = FALSE, interval = c("none", "parametric", "likelihood",
  "semiparametric", "nonparametric"), level = 0.95,
  bounds = c("restricted", "admissible", "none"), silent = c("all",
  "graph", "legend", "output", "none"), xreg = NULL, regressors = c("use",
  "select"), initialX = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto.gum_+3A_y">y</code></td>
<td>
<p>Vector or ts object, containing data needed to be forecasted.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_orders">orders</code></td>
<td>
<p>The value of the max order to check. This is the upper bound
of orders, but the real orders could be lower than this because of the
increasing number of parameters in the models with higher orders.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_lags">lags</code></td>
<td>
<p>The value of the maximum lag to check. This should usually be
a maximum frequency of the data.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_type">type</code></td>
<td>
<p>Type of model. Can either be <code>"additive"</code> or
<code>"multiplicative"</code>. The latter means that the GUM is fitted on
log-transformed data. If <code>"select"</code>, then this is selected automatically,
which may slow down things twice.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_initial">initial</code></td>
<td>
<p>Can be either character or a vector of initial states. If it
is character, then it can be <code>"optimal"</code>, meaning that the initial
states are optimised, or <code>"backcasting"</code>, meaning that the initials are
produced using backcasting procedure.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_ic">ic</code></td>
<td>
<p>The information criterion used in the model selection procedure.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization. <code>loss</code> can
be: <code>likelihood</code> (assuming Normal distribution of error term),
<code>MSE</code> (Mean Squared Error), <code>MAE</code> (Mean Absolute Error),
<code>HAM</code> (Half Absolute Moment), <code>TMSE</code> - Trace Mean Squared Error,
<code>GTMSE</code> - Geometric Trace Mean Squared Error, <code>MSEh</code> - optimisation
using only h-steps ahead error, <code>MSCE</code> - Mean Squared Cumulative Error.
If <code>loss!="MSE"</code>, then likelihood and model selection is done based
on equivalent <code>MSE</code>. Model selection in this cases becomes not optimal.
</p>
<p>There are also available analytical approximations for multistep functions:
<code>aMSEh</code>, <code>aTMSE</code> and <code>aGTMSE</code>. These can be useful in cases
of small samples.
</p>
<p>Finally, just for fun the absolute and half analogues of multistep estimators
are available: <code>MAEh</code>, <code>TMAE</code>, <code>GTMAE</code>, <code>MACE</code>, <code>TMAE</code>,
<code>HAMh</code>, <code>THAM</code>, <code>GTHAM</code>, <code>CHAM</code>.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_h">h</code></td>
<td>
<p>Length of forecasting horizon.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_holdout">holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_cumulative">cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_interval">interval</code></td>
<td>
<p>Type of interval to construct. This can be:
</p>

<ul>
<li> <p><code>"none"</code>, aka <code>"n"</code> - do not produce prediction
interval.
</p>
</li>
<li> <p><code>"parametric"</code>, <code>"p"</code> - use state-space structure of ETS. In
case of mixed models this is done using simulations, which may take longer
time than for the pure additive and pure multiplicative models. This type
of interval relies on unbiased estimate of in-sample error variance, which
divides the sume of squared errors by T-k rather than just T.
</p>
</li>
<li> <p><code>"likelihood"</code>, <code>"l"</code> - these are the same as <code>"p"</code>, but
relies on the biased estimate of variance from the likelihood (division by
T, not by T-k).
</p>
</li>
<li> <p><code>"semiparametric"</code>, <code>"sp"</code> - interval based on covariance
matrix of 1 to h steps ahead errors and assumption of normal / log-normal
distribution (depending on error type).
</p>
</li>
<li> <p><code>"nonparametric"</code>, <code>"np"</code> - interval based on values from a
quantile regression on error matrix (see Taylor and Bunn, 1999). The model
used in this process is e[j] = a j^b, where j=1,..,h.
</p>
</li></ul>

<p>The parameter also accepts <code>TRUE</code> and <code>FALSE</code>. The former means that
parametric interval are constructed, while the latter is equivalent to
<code>none</code>.
If the forecasts of the models were combined, then the interval are combined
quantile-wise (Lichtendahl et al., 2013).</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_level">level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_bounds">bounds</code></td>
<td>
<p>What type of bounds to use in the model estimation. The first
letter can be used instead of the whole word.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_silent">silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words (&quot;n&quot;,
&quot;a&quot;, &quot;g&quot;, &quot;l&quot;, &quot;o&quot;).</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_xreg">xreg</code></td>
<td>
<p>The vector (either numeric or time series) or the matrix (or
data.frame) of exogenous variables that should be included in the model. If
matrix included than columns should contain variables and rows - observations.
Note that <code>xreg</code> should have number of observations equal either to
in-sample or to the whole series. If the number of observations in
<code>xreg</code> is equal to in-sample, then values for the holdout sample are
produced using <a href="#topic+es">es</a> function.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_regressors">regressors</code></td>
<td>
<p>The variable defines what to do with the provided xreg:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done.
<code>"combine"</code> will be available at some point in future...</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_initialx">initialX</code></td>
<td>
<p>The vector of initial parameters for exogenous variables.
Ignored if <code>xreg</code> is NULL.</p>
</td></tr>
<tr><td><code id="auto.gum_+3A_...">...</code></td>
<td>
<p>Other non-documented parameters. For example <code>FI=TRUE</code> will
make the function also produce Fisher Information matrix, which then can be
used to calculated variances of parameters of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks several GUM models (see <a href="#topic+gum">gum</a> documentation)
and selects the best one based on the specified information criterion.
</p>
<p>The resulting model can be complicated and not straightforward, because GUM
allows capturing hidden orders that no ARIMA model can. It is advised to use
<code>initial="b"</code>, because optimising GUM of arbitrary order is not a simple
task.
</p>
<p>For some more information about the model and its implementation, see the
vignette: <code>vignette("gum","smooth")</code>
</p>


<h3>Value</h3>

<p>Object of class &quot;smooth&quot; is returned. See <a href="#topic+gum">gum</a> for
details.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Snyder, R. D., 1985. Recursive Estimation of Dynamic Linear Models.
Journal of the Royal Statistical Society, Series B (Methodological) 47 (2), 272-276.
</p>
</li>
<li><p> Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>.
</p>
</li></ul>


<ul>
<li><p> Svetunkov Ivan and Boylan John E. (2017). Multiplicative
State-Space Models for Intermittent Time Series. Working Paper of
Department of Management Science, Lancaster University, 2017:4 , 1-43.
</p>
</li>
<li><p> Teunter R., Syntetos A., Babai Z. (2011). Intermittent demand:
Linking forecasting to inventory obsolescence. European Journal of
Operational Research, 214, 606-615.
</p>
</li>
<li><p> Croston, J. (1972) Forecasting and stock control for intermittent
demands. Operational Research Quarterly, 23(3), 289-303.
</p>
</li>
<li><p> Syntetos, A., Boylan J. (2005) The accuracy of intermittent demand
estimates. International Journal of Forecasting, 21(2), 303-314.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+gum">gum</a>, <a href="#topic+es">es</a>,
<a href="#topic+ces">ces</a>, <a href="#topic+sim.es">sim.es</a>, <a href="#topic+ssarima">ssarima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(50,100,3)

# The best GUM model for the data
ourModel &lt;- auto.gum(x,orders=2,lags=4,h=18,holdout=TRUE,interval="np")

summary(ourModel)
forecast(ourModel)
plot(forecast(ourModel))


</code></pre>

<hr>
<h2 id='auto.ssarima'>State Space ARIMA</h2><span id='topic+auto.ssarima'></span>

<h3>Description</h3>

<p>Function selects the best State Space ARIMA based on information criteria,
using fancy branch and bound mechanism. The resulting model can be not
optimal in IC meaning, but it is usually reasonable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto.ssarima(y, orders = list(ar = c(3, 3), i = c(2, 1), ma = c(3, 3)),
  lags = c(1, frequency(y)), combine = FALSE, fast = TRUE,
  constant = NULL, initial = c("backcasting", "optimal"), ic = c("AICc",
  "AIC", "BIC", "BICc"), loss = c("likelihood", "MSE", "MAE", "HAM", "MSEh",
  "TMSE", "GTMSE", "MSCE"), h = 10, holdout = FALSE, cumulative = FALSE,
  interval = c("none", "parametric", "likelihood", "semiparametric",
  "nonparametric"), level = 0.95, bounds = c("admissible", "none"),
  silent = c("all", "graph", "legend", "output", "none"), xreg = NULL,
  regressors = c("use", "select"), initialX = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto.ssarima_+3A_y">y</code></td>
<td>
<p>Vector or ts object, containing data needed to be forecasted.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_orders">orders</code></td>
<td>
<p>List of maximum orders to check, containing vector variables
<code>ar</code>, <code>i</code> and <code>ma</code>. If a variable is not provided in the
list, then it is assumed to be equal to zero. At least one variable should
have the same length as <code>lags</code>.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_lags">lags</code></td>
<td>
<p>Defines lags for the corresponding orders (see examples). The
length of <code>lags</code> must correspond to the length of <code>orders</code>. There
is no restrictions on the length of <code>lags</code> vector.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_combine">combine</code></td>
<td>
<p>If <code>TRUE</code>, then resulting ARIMA is combined using AIC
weights.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_fast">fast</code></td>
<td>
<p>If <code>TRUE</code>, then some of the orders of ARIMA are
skipped. This is not advised for models with <code>lags</code> greater than 12.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_constant">constant</code></td>
<td>
<p>If <code>NULL</code>, then the function will check if constant is
needed. if <code>TRUE</code>, then constant is forced in the model. Otherwise
constant is not used.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_initial">initial</code></td>
<td>
<p>Can be either character or a vector of initial states. If it
is character, then it can be <code>"optimal"</code>, meaning that the initial
states are optimised, or <code>"backcasting"</code>, meaning that the initials are
produced using backcasting procedure.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_ic">ic</code></td>
<td>
<p>The information criterion used in the model selection procedure.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization. <code>loss</code> can
be: <code>likelihood</code> (assuming Normal distribution of error term),
<code>MSE</code> (Mean Squared Error), <code>MAE</code> (Mean Absolute Error),
<code>HAM</code> (Half Absolute Moment), <code>TMSE</code> - Trace Mean Squared Error,
<code>GTMSE</code> - Geometric Trace Mean Squared Error, <code>MSEh</code> - optimisation
using only h-steps ahead error, <code>MSCE</code> - Mean Squared Cumulative Error.
If <code>loss!="MSE"</code>, then likelihood and model selection is done based
on equivalent <code>MSE</code>. Model selection in this cases becomes not optimal.
</p>
<p>There are also available analytical approximations for multistep functions:
<code>aMSEh</code>, <code>aTMSE</code> and <code>aGTMSE</code>. These can be useful in cases
of small samples.
</p>
<p>Finally, just for fun the absolute and half analogues of multistep estimators
are available: <code>MAEh</code>, <code>TMAE</code>, <code>GTMAE</code>, <code>MACE</code>, <code>TMAE</code>,
<code>HAMh</code>, <code>THAM</code>, <code>GTHAM</code>, <code>CHAM</code>.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_h">h</code></td>
<td>
<p>Length of forecasting horizon.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_holdout">holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_cumulative">cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_interval">interval</code></td>
<td>
<p>Type of interval to construct. This can be:
</p>

<ul>
<li> <p><code>"none"</code>, aka <code>"n"</code> - do not produce prediction
interval.
</p>
</li>
<li> <p><code>"parametric"</code>, <code>"p"</code> - use state-space structure of ETS. In
case of mixed models this is done using simulations, which may take longer
time than for the pure additive and pure multiplicative models. This type
of interval relies on unbiased estimate of in-sample error variance, which
divides the sume of squared errors by T-k rather than just T.
</p>
</li>
<li> <p><code>"likelihood"</code>, <code>"l"</code> - these are the same as <code>"p"</code>, but
relies on the biased estimate of variance from the likelihood (division by
T, not by T-k).
</p>
</li>
<li> <p><code>"semiparametric"</code>, <code>"sp"</code> - interval based on covariance
matrix of 1 to h steps ahead errors and assumption of normal / log-normal
distribution (depending on error type).
</p>
</li>
<li> <p><code>"nonparametric"</code>, <code>"np"</code> - interval based on values from a
quantile regression on error matrix (see Taylor and Bunn, 1999). The model
used in this process is e[j] = a j^b, where j=1,..,h.
</p>
</li></ul>

<p>The parameter also accepts <code>TRUE</code> and <code>FALSE</code>. The former means that
parametric interval are constructed, while the latter is equivalent to
<code>none</code>.
If the forecasts of the models were combined, then the interval are combined
quantile-wise (Lichtendahl et al., 2013).</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_level">level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_bounds">bounds</code></td>
<td>
<p>What type of bounds to use in the model estimation. The first
letter can be used instead of the whole word.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_silent">silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words (&quot;n&quot;,
&quot;a&quot;, &quot;g&quot;, &quot;l&quot;, &quot;o&quot;).</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_xreg">xreg</code></td>
<td>
<p>The vector (either numeric or time series) or the matrix (or
data.frame) of exogenous variables that should be included in the model. If
matrix included than columns should contain variables and rows - observations.
Note that <code>xreg</code> should have number of observations equal either to
in-sample or to the whole series. If the number of observations in
<code>xreg</code> is equal to in-sample, then values for the holdout sample are
produced using <a href="#topic+es">es</a> function.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_regressors">regressors</code></td>
<td>
<p>The variable defines what to do with the provided xreg:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done.
<code>"combine"</code> will be available at some point in future...</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_initialx">initialX</code></td>
<td>
<p>The vector of initial parameters for exogenous variables.
Ignored if <code>xreg</code> is NULL.</p>
</td></tr>
<tr><td><code id="auto.ssarima_+3A_...">...</code></td>
<td>
<p>Other non-documented parameters. For example <code>FI=TRUE</code> will
make the function also produce Fisher Information matrix, which then can be
used to calculated variances of parameters of the model.  Maximum orders to
check can also be specified separately, however <code>orders</code> variable must
be set to <code>NULL</code>: <code>ar.orders</code> - Maximum order of AR term. Can be
vector, defining max orders of AR, SAR etc.  <code>i.orders</code> - Maximum order
of I. Can be vector, defining max orders of I, SI etc.  <code>ma.orders</code> -
Maximum order of MA term. Can be vector, defining max orders of MA, SMA etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function constructs bunch of ARIMAs in Single Source of Error
state space form (see <a href="#topic+ssarima">ssarima</a> documentation) and selects the
best one based on information criterion. The mechanism is described in
Svetunkov &amp; Boylan (2019).
</p>
<p>Due to the flexibility of the model, multiple seasonalities can be used. For
example, something crazy like this can be constructed:
SARIMA(1,1,1)(0,1,1)[24](2,0,1)[24*7](0,0,1)[24*30], but the estimation may
take a lot of time... It is recommended to use <a href="#topic+auto.msarima">auto.msarima</a> in
cases with more than one seasonality and high frequencies.
</p>
<p>For some more information about the model and its implementation, see the
vignette: <code>vignette("ssarima","smooth")</code>
</p>


<h3>Value</h3>

<p>Object of class &quot;smooth&quot; is returned. See <a href="#topic+ssarima">ssarima</a> for
details.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Snyder, R. D., 1985. Recursive Estimation of Dynamic Linear Models.
Journal of the Royal Statistical Society, Series B (Methodological) 47 (2), 272-276.
</p>
</li>
<li><p> Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>.
</p>
</li></ul>


<ul>
<li><p> Svetunkov Ivan and Boylan John E. (2017). Multiplicative
State-Space Models for Intermittent Time Series. Working Paper of
Department of Management Science, Lancaster University, 2017:4 , 1-43.
</p>
</li>
<li><p> Teunter R., Syntetos A., Babai Z. (2011). Intermittent demand:
Linking forecasting to inventory obsolescence. European Journal of
Operational Research, 214, 606-615.
</p>
</li>
<li><p> Croston, J. (1972) Forecasting and stock control for intermittent
demands. Operational Research Quarterly, 23(3), 289-303.
</p>
</li>
<li><p> Syntetos, A., Boylan J. (2005) The accuracy of intermittent demand
estimates. International Journal of Forecasting, 21(2), 303-314.
</p>
</li></ul>


<ul>
<li><p> Svetunkov, I., &amp; Boylan, J. E. (2019). State-space ARIMA for supply-chain forecasting.
International Journal of Production Research, 0(0), 110.
<a href="https://doi.org/10.1080/00207543.2019.1600764">doi:10.1080/00207543.2019.1600764</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+es">es</a>, <a href="#topic+ces">ces</a>,
<a href="#topic+sim.es">sim.es</a>, <a href="#topic+gum">gum</a>, <a href="#topic+ssarima">ssarima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(118,100,3)

# The best ARIMA for the data
ourModel &lt;- auto.ssarima(x,orders=list(ar=c(2,1),i=c(1,1),ma=c(2,1)),lags=c(1,12),
                                   h=18,holdout=TRUE,interval="np")

# The other one using optimised states
auto.ssarima(x,orders=list(ar=c(3,2),i=c(2,1),ma=c(3,2)),lags=c(1,12),
                       initial="o",h=18,holdout=TRUE)

# And now combined ARIMA
auto.ssarima(x,orders=list(ar=c(3,2),i=c(2,1),ma=c(3,2)),lags=c(1,12),
                       combine=TRUE,h=18,holdout=TRUE)

summary(ourModel)
forecast(ourModel)
plot(forecast(ourModel))


</code></pre>

<hr>
<h2 id='ces'>Complex Exponential Smoothing</h2><span id='topic+ces'></span>

<h3>Description</h3>

<p>Function estimates CES in state space form with information potential equal
to errors and returns several variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ces(y, seasonality = c("none", "simple", "partial", "full"),
  initial = c("backcasting", "optimal"), a = NULL, b = NULL,
  ic = c("AICc", "AIC", "BIC", "BICc"), loss = c("likelihood", "MSE",
  "MAE", "HAM", "MSEh", "TMSE", "GTMSE", "MSCE"), h = 10, holdout = FALSE,
  cumulative = FALSE, interval = c("none", "parametric", "likelihood",
  "semiparametric", "nonparametric"), level = 0.95,
  bounds = c("admissible", "none"), silent = c("all", "graph", "legend",
  "output", "none"), xreg = NULL, regressors = c("use", "select"),
  initialX = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ces_+3A_y">y</code></td>
<td>
<p>Vector or ts object, containing data needed to be forecasted.</p>
</td></tr>
<tr><td><code id="ces_+3A_seasonality">seasonality</code></td>
<td>
<p>The type of seasonality used in CES. Can be: <code>none</code>
- No seasonality; <code>simple</code> - Simple seasonality, using lagged CES
(based on <code>t-m</code> observation, where <code>m</code> is the seasonality lag);
<code>partial</code> - Partial seasonality with real seasonal components
(equivalent to additive seasonality); <code>full</code> - Full seasonality with
complex seasonal components (can do both multiplicative and additive
seasonality, depending on the data). First letter can be used instead of
full words.  Any seasonal CES can only be constructed for time series
vectors.</p>
</td></tr>
<tr><td><code id="ces_+3A_initial">initial</code></td>
<td>
<p>Can be either character or a vector of initial states. If it
is character, then it can be <code>"optimal"</code>, meaning that the initial
states are optimised, or <code>"backcasting"</code>, meaning that the initials are
produced using backcasting procedure.</p>
</td></tr>
<tr><td><code id="ces_+3A_a">a</code></td>
<td>
<p>First complex smoothing parameter. Should be a complex number.
</p>
<p>NOTE! CES is very sensitive to a and b values so it is advised either to
leave them alone, or to use values from previously estimated model.</p>
</td></tr>
<tr><td><code id="ces_+3A_b">b</code></td>
<td>
<p>Second complex smoothing parameter. Can be real if
<code>seasonality="partial"</code>. In case of <code>seasonality="full"</code> must be
complex number.</p>
</td></tr>
<tr><td><code id="ces_+3A_ic">ic</code></td>
<td>
<p>The information criterion used in the model selection procedure.</p>
</td></tr>
<tr><td><code id="ces_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization. <code>loss</code> can
be: <code>likelihood</code> (assuming Normal distribution of error term),
<code>MSE</code> (Mean Squared Error), <code>MAE</code> (Mean Absolute Error),
<code>HAM</code> (Half Absolute Moment), <code>TMSE</code> - Trace Mean Squared Error,
<code>GTMSE</code> - Geometric Trace Mean Squared Error, <code>MSEh</code> - optimisation
using only h-steps ahead error, <code>MSCE</code> - Mean Squared Cumulative Error.
If <code>loss!="MSE"</code>, then likelihood and model selection is done based
on equivalent <code>MSE</code>. Model selection in this cases becomes not optimal.
</p>
<p>There are also available analytical approximations for multistep functions:
<code>aMSEh</code>, <code>aTMSE</code> and <code>aGTMSE</code>. These can be useful in cases
of small samples.
</p>
<p>Finally, just for fun the absolute and half analogues of multistep estimators
are available: <code>MAEh</code>, <code>TMAE</code>, <code>GTMAE</code>, <code>MACE</code>, <code>TMAE</code>,
<code>HAMh</code>, <code>THAM</code>, <code>GTHAM</code>, <code>CHAM</code>.</p>
</td></tr>
<tr><td><code id="ces_+3A_h">h</code></td>
<td>
<p>Length of forecasting horizon.</p>
</td></tr>
<tr><td><code id="ces_+3A_holdout">holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td></tr>
<tr><td><code id="ces_+3A_cumulative">cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td></tr>
<tr><td><code id="ces_+3A_interval">interval</code></td>
<td>
<p>Type of interval to construct. This can be:
</p>

<ul>
<li> <p><code>"none"</code>, aka <code>"n"</code> - do not produce prediction
interval.
</p>
</li>
<li> <p><code>"parametric"</code>, <code>"p"</code> - use state-space structure of ETS. In
case of mixed models this is done using simulations, which may take longer
time than for the pure additive and pure multiplicative models. This type
of interval relies on unbiased estimate of in-sample error variance, which
divides the sume of squared errors by T-k rather than just T.
</p>
</li>
<li> <p><code>"likelihood"</code>, <code>"l"</code> - these are the same as <code>"p"</code>, but
relies on the biased estimate of variance from the likelihood (division by
T, not by T-k).
</p>
</li>
<li> <p><code>"semiparametric"</code>, <code>"sp"</code> - interval based on covariance
matrix of 1 to h steps ahead errors and assumption of normal / log-normal
distribution (depending on error type).
</p>
</li>
<li> <p><code>"nonparametric"</code>, <code>"np"</code> - interval based on values from a
quantile regression on error matrix (see Taylor and Bunn, 1999). The model
used in this process is e[j] = a j^b, where j=1,..,h.
</p>
</li></ul>

<p>The parameter also accepts <code>TRUE</code> and <code>FALSE</code>. The former means that
parametric interval are constructed, while the latter is equivalent to
<code>none</code>.
If the forecasts of the models were combined, then the interval are combined
quantile-wise (Lichtendahl et al., 2013).</p>
</td></tr>
<tr><td><code id="ces_+3A_level">level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td></tr>
<tr><td><code id="ces_+3A_bounds">bounds</code></td>
<td>
<p>What type of bounds to use in the model estimation. The first
letter can be used instead of the whole word.</p>
</td></tr>
<tr><td><code id="ces_+3A_silent">silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words (&quot;n&quot;,
&quot;a&quot;, &quot;g&quot;, &quot;l&quot;, &quot;o&quot;).</p>
</td></tr>
<tr><td><code id="ces_+3A_xreg">xreg</code></td>
<td>
<p>The vector (either numeric or time series) or the matrix (or
data.frame) of exogenous variables that should be included in the model. If
matrix included than columns should contain variables and rows - observations.
Note that <code>xreg</code> should have number of observations equal either to
in-sample or to the whole series. If the number of observations in
<code>xreg</code> is equal to in-sample, then values for the holdout sample are
produced using <a href="#topic+es">es</a> function.</p>
</td></tr>
<tr><td><code id="ces_+3A_regressors">regressors</code></td>
<td>
<p>The variable defines what to do with the provided xreg:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done.
<code>"combine"</code> will be available at some point in future...</p>
</td></tr>
<tr><td><code id="ces_+3A_initialx">initialX</code></td>
<td>
<p>The vector of initial parameters for exogenous variables.
Ignored if <code>xreg</code> is NULL.</p>
</td></tr>
<tr><td><code id="ces_+3A_...">...</code></td>
<td>
<p>Other non-documented parameters.  For example parameter
<code>model</code> can accept a previously estimated CES model and use all its
parameters.  <code>FI=TRUE</code> will make the function produce Fisher
Information matrix, which then can be used to calculated variances of
parameters of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates Complex Exponential Smoothing in the state space 2
described in Svetunkov, Kourentzes (2017) with the information potential
equal to the approximation error.  The estimation of initial states of xt is
done using backcast.
</p>
<p>For some more information about the model and its implementation, see the
vignette: <code>vignette("ces","smooth")</code>
</p>


<h3>Value</h3>

<p>Object of class &quot;smooth&quot; is returned. It contains the list of the
following values: </p>

<ul>
<li> <p><code>model</code> - type of constructed model.
</p>
</li>
<li> <p><code>timeElapsed</code> - time elapsed for the construction of the model.
</p>
</li>
<li> <p><code>states</code> - the matrix of the components of CES. The included
minimum is &quot;level&quot; and &quot;potential&quot;. In the case of seasonal model the
seasonal component is also included. In the case of exogenous variables the
estimated coefficients for the exogenous variables are also included.
</p>
</li>
<li> <p><code>a</code> - complex smoothing parameter in the form a0 + ia1
</p>
</li>
<li> <p><code>b</code> - smoothing parameter for the seasonal component. Can either
be real (if <code>seasonality="P"</code>) or complex (if <code>seasonality="F"</code>)
in a form b0 + ib1.
</p>
</li>
<li> <p><code>persistence</code> - persistence vector. This is the place, where
smoothing parameters live.
</p>
</li>
<li> <p><code>transition</code> - transition matrix of the model.
</p>
</li>
<li> <p><code>measurement</code> - measurement vector of the model.
</p>
</li>
<li> <p><code>initialType</code> - Type of the initial values used.
</p>
</li>
<li> <p><code>initial</code> - the initial values of the state vector (non-seasonal).
</p>
</li>
<li> <p><code>nParam</code> - table with the number of estimated / provided parameters.
If a previous model was reused, then its initials are reused and the number of
provided parameters will take this into account.
</p>
</li>
<li> <p><code>fitted</code> - the fitted values of CES.
</p>
</li>
<li> <p><code>forecast</code> - the point forecast of CES.
</p>
</li>
<li> <p><code>lower</code> - the lower bound of prediction interval. When
<code>interval="none"</code> then NA is returned.
</p>
</li>
<li> <p><code>upper</code> - the upper bound of prediction interval. When
<code>interval="none"</code> then NA is returned.
</p>
</li>
<li> <p><code>residuals</code> - the residuals of the estimated model.
</p>
</li>
<li> <p><code>errors</code> - The matrix of 1 to h steps ahead errors. Only returned when the
multistep losses are used and semiparametric interval is needed.
</p>
</li>
<li> <p><code>s2</code> - variance of the residuals (taking degrees of
freedom into account).
</p>
</li>
<li> <p><code>interval</code> - type of interval asked by user.
</p>
</li>
<li> <p><code>level</code> - confidence level for interval.
</p>
</li>
<li> <p><code>cumulative</code> - whether the produced forecast was cumulative or not.
</p>
</li>
<li> <p><code>y</code> - The data provided in the call of the function.
</p>
</li>
<li> <p><code>holdout</code> - the holdout part of the original data.
</p>
</li>
<li> <p><code>xreg</code> - provided vector or matrix of exogenous variables. If
<code>regressors="s"</code>, then this value will contain only selected exogenous
variables.
exogenous variables were estimated as well.
</p>
</li>
<li> <p><code>initialX</code> - initial values for parameters of exogenous variables.
</p>
</li>
<li> <p><code>ICs</code> - values of information criteria of the model. Includes
AIC, AICc, BIC and BICc.
</p>
</li>
<li> <p><code>logLik</code> - log-likelihood of the function.
</p>
</li>
<li> <p><code>lossValue</code> - Cost function value.
</p>
</li>
<li> <p><code>loss</code> - Type of loss function used in the estimation.
</p>
</li>
<li> <p><code>FI</code> - Fisher Information. Equal to NULL if <code>FI=FALSE</code>
or when <code>FI</code> is not provided at all.
</p>
</li>
<li> <p><code>accuracy</code> - vector of accuracy measures for the holdout sample. In
case of non-intermittent data includes: MPE, MAPE, SMAPE, MASE, sMAE,
RelMAE, sMSE and Bias coefficient (based on complex numbers). In case of
intermittent data the set of errors will be: sMSE, sPIS, sCE (scaled
cumulative error) and Bias coefficient. This is available only when
<code>holdout=TRUE</code>.
</p>
</li>
<li> <p><code>B</code> - the vector of all the estimated parameters.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov, I., Kourentzes, N. (February 2015). Complex exponential
smoothing. Working Paper of Department of Management Science, Lancaster
University 2015:1, 1-31.
</p>
</li>
<li><p> Svetunkov I., Kourentzes N. (2017) Complex Exponential Smoothing
for Time Series Forecasting. Not yet published.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+es">es</a>, <a href="stats.html#topic+ts">ts</a>, <a href="#topic+auto.ces">auto.ces</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rnorm(100,10,3)
ces(y,h=20,holdout=TRUE)
ces(y,h=20,holdout=FALSE)

y &lt;- 500 - c(1:100)*0.5 + rnorm(100,10,3)
ces(y,h=20,holdout=TRUE,interval="p",bounds="a")

ces(BJsales,h=8,holdout=TRUE,seasonality="s",interval="sp",level=0.8)

ces(AirPassengers,h=18,holdout=TRUE,seasonality="s",interval="sp")
ces(AirPassengers,h=18,holdout=TRUE,seasonality="p",interval="np")
ces(AirPassengers,h=18,holdout=TRUE,seasonality="f",interval="p")

</code></pre>

<hr>
<h2 id='cma'>Centered Moving Average</h2><span id='topic+cma'></span>

<h3>Description</h3>

<p>Function constructs centered moving average based on state space SMA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cma(y, order = NULL, silent = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cma_+3A_y">y</code></td>
<td>
<p>Vector or ts object, containing data needed to be smoothed.</p>
</td></tr>
<tr><td><code id="cma_+3A_order">order</code></td>
<td>
<p>Order of centered moving average. If <code>NULL</code>, then the
function will try to select order of SMA based on information criteria.
See <a href="#topic+sma">sma</a> for details.</p>
</td></tr>
<tr><td><code id="cma_+3A_silent">silent</code></td>
<td>
<p>If <code>TRUE</code>, then plot is not produced. Otherwise, there
is a plot...</p>
</td></tr>
<tr><td><code id="cma_+3A_...">...</code></td>
<td>
<p>Nothing. Needed only for the transition to the new name of variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the order is odd, then the function constructs SMA(order) and
shifts it back in time. Otherwise an AR(order+1) model is constructed
with the preset parameters:
</p>
<p style="text-align: center;"><code class="reqn">phi_i = {0.5,1,1,...,0.5} / order</code>
</p>

<p>This then corresponds to the centered MA with 0.5 weight for the
first observation and 0.5 weight for an additional one. e.g. if this is
monthly data and we use order=12, then half of the first January and
half of the new one is taken.
</p>
<p>This is not a forecasting tool. This is supposed to smooth the time
series in order to find trend. So don't expect any forecasts from this
function!
</p>


<h3>Value</h3>

<p>Object of class &quot;smooth&quot; is returned. It contains the list of the
following values:
</p>

<ul>
<li> <p><code>model</code> - the name of the estimated model.
</p>
</li>
<li> <p><code>timeElapsed</code> - time elapsed for the construction of the model.
</p>
</li>
<li> <p><code>order</code> - order of the moving average.
</p>
</li>
<li> <p><code>nParam</code> - table with the number of estimated / provided parameters.
If a previous model was reused, then its initials are reused and the number of
provided parameters will take this into account.
</p>
</li>
<li> <p><code>fitted</code> - the fitted values, shifted in time.
</p>
</li>
<li> <p><code>forecast</code> - NAs, because this function does not produce forecasts.
</p>
</li>
<li> <p><code>residuals</code> - the residuals of the SMA / AR model.
</p>
</li>
<li> <p><code>s2</code> - variance of the residuals (taking degrees of freedom into
account) of the SMA / AR model.
</p>
</li>
<li> <p><code>y</code> - the original data.
</p>
</li>
<li> <p><code>ICs</code> - values of information criteria from the respective SMA or
AR model. Includes AIC, AICc, BIC and BICc.
</p>
</li>
<li> <p><code>logLik</code> - log-likelihood of the SMA / AR model.
</p>
</li>
<li> <p><code>lossValue</code> - Cost function value (for the SMA / AR model).
</p>
</li>
<li> <p><code>loss</code> - Type of loss function used in the estimation.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov I. (2023) Smooth forecasting with the smooth package in R. arXiv:2301.01790.
<a href="https://doi.org/10.48550/arXiv.2301.01790">doi:10.48550/arXiv.2301.01790</a>.
</p>
</li>
<li><p> Svetunkov I. (2015 - Inf) &quot;smooth&quot; package for R - series of posts about the underlying
models and how to use them: <a href="https://openforecast.org/category/r-en/smooth/">https://openforecast.org/category/r-en/smooth/</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+es">es</a>, <a href="#topic+ssarima">ssarima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# CMA of specific order
ourModel &lt;- cma(rnorm(118,100,3),order=12)

# CMA of arbitrary order
ourModel &lt;- cma(rnorm(118,100,3))

summary(ourModel)

</code></pre>

<hr>
<h2 id='es'>Exponential Smoothing in SSOE state space model</h2><span id='topic+es'></span><span id='topic+es_old'></span>

<h3>Description</h3>

<p>Function constructs ETS model and returns forecast, fitted values, errors
and matrix of states. It is a wrapper of <a href="#topic+adam">adam</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>es(y, model = "ZZZ", lags = c(frequency(y)), persistence = NULL,
  phi = NULL, initial = c("optimal", "backcasting", "complete"),
  initialSeason = NULL, ic = c("AICc", "AIC", "BIC", "BICc"),
  loss = c("likelihood", "MSE", "MAE", "HAM", "MSEh", "TMSE", "GTMSE",
  "MSCE"), h = 10, holdout = FALSE, bounds = c("usual", "admissible",
  "none"), silent = TRUE, xreg = NULL, regressors = c("use", "select"),
  initialX = NULL, ...)

es_old(y, model = "ZZZ", persistence = NULL, phi = NULL,
  initial = c("optimal", "backcasting"), initialSeason = NULL,
  ic = c("AICc", "AIC", "BIC", "BICc"), loss = c("likelihood", "MSE",
  "MAE", "HAM", "MSEh", "TMSE", "GTMSE", "MSCE"), h = 10, holdout = FALSE,
  cumulative = FALSE, interval = c("none", "parametric", "likelihood",
  "semiparametric", "nonparametric"), level = 0.95, bounds = c("usual",
  "admissible", "none"), silent = c("all", "graph", "legend", "output",
  "none"), xreg = NULL, regressors = c("use", "select"), initialX = NULL,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="es_+3A_y">y</code></td>
<td>
<p>Vector or ts object, containing data needed to be forecasted.</p>
</td></tr>
<tr><td><code id="es_+3A_model">model</code></td>
<td>
<p>The type of ETS model. The first letter stands for the type of
the error term (&quot;A&quot; or &quot;M&quot;), the second (and sometimes the third as well) is for
the trend (&quot;N&quot;, &quot;A&quot;, &quot;Ad&quot;, &quot;M&quot; or &quot;Md&quot;), and the last one is for the type of
seasonality (&quot;N&quot;, &quot;A&quot; or &quot;M&quot;). So, the function accepts words with 3 or 4
characters: <code>ANN</code>, <code>AAN</code>, <code>AAdN</code>, <code>AAA</code>, <code>AAdA</code>,
<code>MAdM</code> etc. <code>ZZZ</code> means that the model will be selected based on the
chosen information criteria type. Models pool can be restricted with additive
only components. This is done via <code>model="XXX"</code>. For example, making
selection between models with none / additive / damped additive trend
component only (i.e. excluding multiplicative trend) can be done with
<code>model="ZXZ"</code>. Furthermore, selection between multiplicative models
(excluding additive components) is regulated using <code>model="YYY"</code>. This
can be useful for positive data with low values (for example, slow moving
products). Finally, if <code>model="CCC"</code>, then all the models are estimated
and combination of their forecasts using AIC weights is produced (Kolassa,
2011). This can also be regulated. For example, <code>model="CCN"</code> will
combine forecasts of all non-seasonal models and <code>model="CXY"</code> will
combine forecasts of all the models with non-multiplicative trend and
non-additive seasonality with either additive or multiplicative error. Not
sure why anyone would need this thing, but it is available.
</p>
<p>The parameter <code>model</code> can also be a vector of names of models for a
finer tuning (pool of models). For example, <code>model=c("ANN","AAA")</code> will
estimate only two models and select the best of them.
</p>
<p>Also <code>model</code> can accept a previously estimated ES or ETS (from forecast
package) model and use all its parameters.
</p>
<p>Keep in mind that model selection with &quot;Z&quot; components uses Branch and Bound
algorithm and may skip some models that could have slightly smaller
information criteria.</p>
</td></tr>
<tr><td><code id="es_+3A_lags">lags</code></td>
<td>
<p>Defines lags for the corresponding components. All components
count, starting from level, so ETS(M,M,M) model for monthly data will have
<code>lags=c(1,1,12)</code>. However, the function will also accept <code>lags=c(12)</code>,
assuming that the lags 1 were dropped.</p>
</td></tr>
<tr><td><code id="es_+3A_persistence">persistence</code></td>
<td>
<p>Persistence vector <code class="reqn">g</code>, containing smoothing
parameters. If <code>NULL</code>, then estimated.</p>
</td></tr>
<tr><td><code id="es_+3A_phi">phi</code></td>
<td>
<p>Value of damping parameter. If <code>NULL</code> then it is estimated.</p>
</td></tr>
<tr><td><code id="es_+3A_initial">initial</code></td>
<td>
<p>Can be either character or a vector of initial states.
If it is character, then it can be <code>"optimal"</code>, meaning that all initial
states are optimised, or <code>"backcasting"</code>, meaning that the initials of
dynamic part of the model are produced using backcasting procedure (advised
for data with high frequency). In the latter case, the parameters of the
explanatory variables are optimised. This is recommended for ETSX
model. Alternatively, you can set <code>initial="complete"</code> backcasting,
which means that all states (including explanatory variables) are initialised
via backcasting. You can also provide a vector with values for level and trend
components.
If character, then <code>initialSeason</code> will be estimated in the way defined
by <code>initial</code>.</p>
</td></tr>
<tr><td><code id="es_+3A_initialseason">initialSeason</code></td>
<td>
<p>Vector of initial values for seasonal components. If
<code>NULL</code>, they are estimated during optimisation.</p>
</td></tr>
<tr><td><code id="es_+3A_ic">ic</code></td>
<td>
<p>The information criterion used in the model selection procedure.</p>
</td></tr>
<tr><td><code id="es_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization. <code>loss</code> can
be: <code>likelihood</code> (assuming Normal distribution of error term),
<code>MSE</code> (Mean Squared Error), <code>MAE</code> (Mean Absolute Error),
<code>HAM</code> (Half Absolute Moment), <code>TMSE</code> - Trace Mean Squared Error,
<code>GTMSE</code> - Geometric Trace Mean Squared Error, <code>MSEh</code> - optimisation
using only h-steps ahead error, <code>MSCE</code> - Mean Squared Cumulative Error.
If <code>loss!="MSE"</code>, then likelihood and model selection is done based
on equivalent <code>MSE</code>. Model selection in this cases becomes not optimal.
</p>
<p>There are also available analytical approximations for multistep functions:
<code>aMSEh</code>, <code>aTMSE</code> and <code>aGTMSE</code>. These can be useful in cases
of small samples.
</p>
<p>Finally, just for fun the absolute and half analogues of multistep estimators
are available: <code>MAEh</code>, <code>TMAE</code>, <code>GTMAE</code>, <code>MACE</code>, <code>TMAE</code>,
<code>HAMh</code>, <code>THAM</code>, <code>GTHAM</code>, <code>CHAM</code>.</p>
</td></tr>
<tr><td><code id="es_+3A_h">h</code></td>
<td>
<p>Length of forecasting horizon.</p>
</td></tr>
<tr><td><code id="es_+3A_holdout">holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td></tr>
<tr><td><code id="es_+3A_bounds">bounds</code></td>
<td>
<p>What type of bounds to use in the model estimation. The first
letter can be used instead of the whole word.</p>
</td></tr>
<tr><td><code id="es_+3A_silent">silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words (&quot;n&quot;,
&quot;a&quot;, &quot;g&quot;, &quot;l&quot;, &quot;o&quot;).</p>
</td></tr>
<tr><td><code id="es_+3A_xreg">xreg</code></td>
<td>
<p>The vector (either numeric or time series) or the matrix (or
data.frame) of exogenous variables that should be included in the model. If
matrix included than columns should contain variables and rows - observations.
Note that <code>xreg</code> should have number of observations equal either to
in-sample or to the whole series. If the number of observations in
<code>xreg</code> is equal to in-sample, then values for the holdout sample are
produced using <a href="#topic+es">es</a> function.</p>
</td></tr>
<tr><td><code id="es_+3A_regressors">regressors</code></td>
<td>
<p>The variable defines what to do with the provided xreg:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done.
<code>"combine"</code> will be available at some point in future...</p>
</td></tr>
<tr><td><code id="es_+3A_initialx">initialX</code></td>
<td>
<p>The vector of initial parameters for exogenous variables.
Ignored if <code>xreg</code> is NULL.</p>
</td></tr>
<tr><td><code id="es_+3A_...">...</code></td>
<td>
<p>Other non-documented parameters. For example <code>FI=TRUE</code> will
make the function also produce Fisher Information matrix, which then can be
used to calculated variances of smoothing parameters and initial states of
the model.
Parameters <code>B</code>, <code>lb</code> and <code>ub</code> can be passed via
ellipsis as well. In this case they will be used for optimisation. <code>B</code>
sets the initial values before the optimisation, <code>lb</code> and
<code>ub</code> define lower and upper bounds for the search inside of the
specified <code>bounds</code>. These values should have length equal to the number
of parameters to estimate.
You can also pass two parameters to the optimiser: 1. <code>maxeval</code> - maximum
number of evaluations to carry on; 2. <code>xtol_rel</code> - the precision of the
optimiser. The default values used in es() are <code>maxeval=500</code> and
<code>xtol_rel=1e-8</code>. You can read more about these parameters in the
documentation of <a href="nloptr.html#topic+nloptr">nloptr</a> function.</p>
</td></tr>
<tr><td><code id="es_+3A_cumulative">cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td></tr>
<tr><td><code id="es_+3A_interval">interval</code></td>
<td>
<p>Type of interval to construct. This can be:
</p>

<ul>
<li> <p><code>"none"</code>, aka <code>"n"</code> - do not produce prediction
interval.
</p>
</li>
<li> <p><code>"parametric"</code>, <code>"p"</code> - use state-space structure of ETS. In
case of mixed models this is done using simulations, which may take longer
time than for the pure additive and pure multiplicative models. This type
of interval relies on unbiased estimate of in-sample error variance, which
divides the sume of squared errors by T-k rather than just T.
</p>
</li>
<li> <p><code>"likelihood"</code>, <code>"l"</code> - these are the same as <code>"p"</code>, but
relies on the biased estimate of variance from the likelihood (division by
T, not by T-k).
</p>
</li>
<li> <p><code>"semiparametric"</code>, <code>"sp"</code> - interval based on covariance
matrix of 1 to h steps ahead errors and assumption of normal / log-normal
distribution (depending on error type).
</p>
</li>
<li> <p><code>"nonparametric"</code>, <code>"np"</code> - interval based on values from a
quantile regression on error matrix (see Taylor and Bunn, 1999). The model
used in this process is e[j] = a j^b, where j=1,..,h.
</p>
</li></ul>

<p>The parameter also accepts <code>TRUE</code> and <code>FALSE</code>. The former means that
parametric interval are constructed, while the latter is equivalent to
<code>none</code>.
If the forecasts of the models were combined, then the interval are combined
quantile-wise (Lichtendahl et al., 2013).</p>
</td></tr>
<tr><td><code id="es_+3A_level">level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function estimates ETS in a form of the Single Source of Error state space
model of the following type:
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = o_t (w(v_{t-l}) + h(x_t, a_{t-1}) + r(v_{t-l}) \epsilon_{t})</code>
</p>

<p style="text-align: center;"><code class="reqn">v_{t} = f(v_{t-l}) + g(v_{t-l}) \epsilon_{t}</code>
</p>

<p style="text-align: center;"><code class="reqn">a_{t} = F_{X} a_{t-1} + g_{X} \epsilon_{t} / x_{t}</code>
</p>

<p>Where <code class="reqn">o_{t}</code> is the Bernoulli distributed random variable (in case of
normal data it equals to 1 for all observations), <code class="reqn">v_{t}</code> is the state
vector and <code class="reqn">l</code> is the vector of lags, <code class="reqn">x_t</code> is the vector of
exogenous variables. w(.) is the measurement function, r(.) is the error
function, f(.) is the transition function, g(.) is the persistence
function and h(.) is the explanatory variables function. <code class="reqn">a_t</code> is the
vector of parameters for exogenous variables, <code class="reqn">F_{X}</code> is the
<code>transitionX</code> matrix and <code class="reqn">g_{X}</code> is the <code>persistenceX</code> matrix.
Finally, <code class="reqn">\epsilon_{t}</code> is the error term.
</p>
<p>For the details see Hyndman et al.(2008).
</p>
<p>For some more information about the model and its implementation, see the
vignette: <code>vignette("es","smooth")</code>.
</p>
<p>Also, there are posts about the functions of the package smooth on the
website of Ivan Svetunkov:
<a href="https://openforecast.org/category/r-en/smooth/">https://openforecast.org/category/r-en/smooth/</a> - they explain the
underlying models and how to use the functions.
</p>


<h3>Value</h3>

<p>Object of class &quot;adam&quot; is returned. It contains the list of the
following values for classical ETS models:
</p>

<ul>
<li> <p><code>model</code> - type of constructed model.
</p>
</li>
<li> <p><code>formula</code> - mathematical formula, describing interactions between
components of es() and exogenous variables.
</p>
</li>
<li> <p><code>timeElapsed</code> - time elapsed for the construction of the model.
</p>
</li>
<li> <p><code>states</code> - matrix of the components of ETS.
</p>
</li>
<li> <p><code>persistence</code> - persistence vector. This is the place, where
smoothing parameters live.
</p>
</li>
<li> <p><code>phi</code> - value of damping parameter.
</p>
</li>
<li> <p><code>transition</code> - transition matrix of the model.
</p>
</li>
<li> <p><code>measurement</code> - measurement vector of the model.
</p>
</li>
<li> <p><code>initialType</code> - type of the initial values used.
</p>
</li>
<li> <p><code>initial</code> - initial values of the state vector (non-seasonal).
</p>
</li>
<li> <p><code>initialSeason</code> - initial values of the seasonal part of state vector.
</p>
</li>
<li> <p><code>nParam</code> - table with the number of estimated / provided parameters.
If a previous model was reused, then its initials are reused and the number of
provided parameters will take this into account.
</p>
</li>
<li> <p><code>fitted</code> - fitted values of ETS. In case of the intermittent model, the
fitted are multiplied by the probability of occurrence.
</p>
</li>
<li> <p><code>forecast</code> - the point forecast for h steps ahead (by default NA is returned). NOTE
that these do not always correspond to the conditional expectations. See ADAM
textbook, Section 4.4. for details (<a href="https://openforecast.org/adam/ETSTaxonomyMaths.html">https://openforecast.org/adam/ETSTaxonomyMaths.html</a>),
</p>
</li>
<li> <p><code>lower</code> - lower bound of prediction interval. When <code>interval="none"</code>
then NA is returned.
</p>
</li>
<li> <p><code>upper</code> - higher bound of prediction interval. When <code>interval="none"</code>
then NA is returned.
</p>
</li>
<li> <p><code>residuals</code> - residuals of the estimated model.
</p>
</li>
<li> <p><code>errors</code> - trace forecast in-sample errors, returned as a matrix. Only returned when the
multistep losses are used and semiparametric interval is needed.
</p>
</li>
<li> <p><code>s2</code> - variance of the residuals (taking degrees of freedom into account).
This is an unbiased estimate of variance.
</p>
</li>
<li> <p><code>interval</code> - type of interval asked by user.
</p>
</li>
<li> <p><code>level</code> - confidence level for interval.
</p>
</li>
<li> <p><code>cumulative</code> - whether the produced forecast was cumulative or not.
</p>
</li>
<li> <p><code>y</code> - original data.
</p>
</li>
<li> <p><code>holdout</code> - holdout part of the original data.
</p>
</li>
<li> <p><code>xreg</code> - provided vector or matrix of exogenous variables. If <code>regressors="s"</code>,
then this value will contain only selected exogenous variables.
</p>
</li>
<li> <p><code>initialX</code> - initial values for parameters of exogenous variables.
</p>
</li>
<li> <p><code>ICs</code> - values of information criteria of the model. Includes AIC, AICc, BIC and BICc.
</p>
</li>
<li> <p><code>logLik</code> - concentrated log-likelihood of the function.
</p>
</li>
<li> <p><code>lossValue</code> - loss function value.
</p>
</li>
<li> <p><code>loss</code> - type of loss function used in the estimation.
</p>
</li>
<li> <p><code>FI</code> - Fisher Information. Equal to NULL if <code>FI=FALSE</code> or when <code>FI</code>
is not provided at all.
</p>
</li>
<li> <p><code>accuracy</code> - vector of accuracy measures for the holdout sample. In
case of non-intermittent data includes: MPE, MAPE, SMAPE, MASE, sMAE,
RelMAE, sMSE and Bias coefficient (based on complex numbers). In case of
intermittent data the set of errors will be: sMSE, sPIS, sCE (scaled
cumulative error) and Bias coefficient. This is available only when
<code>holdout=TRUE</code>.
</p>
</li>
<li> <p><code>B</code> - the vector of all the estimated parameters.
</p>
</li></ul>

<p>If combination of forecasts is produced (using <code>model="CCC"</code>), then a
shorter list of values is returned:
</p>

<ul>
<li> <p><code>model</code>,
</p>
</li>
<li> <p><code>timeElapsed</code>,
</p>
</li>
<li> <p><code>initialType</code>,
</p>
</li>
<li> <p><code>fitted</code>,
</p>
</li>
<li> <p><code>forecast</code>,
</p>
</li>
<li> <p><code>lower</code>,
</p>
</li>
<li> <p><code>upper</code>,
</p>
</li>
<li> <p><code>residuals</code>,
</p>
</li>
<li> <p><code>s2</code> - variance of additive error of combined one-step-ahead forecasts,
</p>
</li>
<li> <p><code>interval</code>,
</p>
</li>
<li> <p><code>level</code>,
</p>
</li>
<li> <p><code>cumulative</code>,
</p>
</li>
<li> <p><code>y</code>,
</p>
</li>
<li> <p><code>holdout</code>,
</p>
</li>
<li> <p><code>ICs</code> - combined ic,
</p>
</li>
<li> <p><code>ICw</code> - ic weights used in the combination,
</p>
</li>
<li> <p><code>loss</code>,
</p>
</li>
<li> <p><code>xreg</code>,
</p>
</li>
<li> <p><code>accuracy</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Snyder, R. D., 1985. Recursive Estimation of Dynamic Linear Models.
Journal of the Royal Statistical Society, Series B (Methodological) 47 (2), 272-276.
</p>
</li>
<li><p> Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>.
</p>
</li></ul>


<ul>
<li><p> Svetunkov Ivan and Boylan John E. (2017). Multiplicative
State-Space Models for Intermittent Time Series. Working Paper of
Department of Management Science, Lancaster University, 2017:4 , 1-43.
</p>
</li>
<li><p> Teunter R., Syntetos A., Babai Z. (2011). Intermittent demand:
Linking forecasting to inventory obsolescence. European Journal of
Operational Research, 214, 606-615.
</p>
</li>
<li><p> Croston, J. (1972) Forecasting and stock control for intermittent
demands. Operational Research Quarterly, 23(3), 289-303.
</p>
</li>
<li><p> Syntetos, A., Boylan J. (2005) The accuracy of intermittent demand
estimates. International Journal of Forecasting, 21(2), 303-314.
</p>
</li></ul>


<ul>
<li><p> Kolassa, S. (2011) Combining exponential smoothing forecasts using Akaike
weights. International Journal of Forecasting, 27, pp 238 - 251.
</p>
</li></ul>


<ul>
<li><p> Taylor, J.W. and Bunn, D.W. (1999) A Quantile Regression Approach to
Generating Prediction Intervals. Management Science, Vol 45, No 2, pp
225-237.
</p>
</li>
<li><p> Lichtendahl Kenneth C., Jr., Grushka-Cockayne Yael, Winkler
Robert L., (2013) Is It Better to Average Probabilities or
Quantiles? Management Science 59(7):1594-1611. DOI:
<a href="https://doi.org/10.1287/mnsc.1120.1667">doi:10.1287/mnsc.1120.1667</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+adam">adam</a>, <a href="greybox.html#topic+forecast">forecast</a>,
<a href="stats.html#topic+ts">ts</a>, <a href="#topic+sim.es">sim.es</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See how holdout and trace parameters influence the forecast
es(BJsales,model="AAdN",h=8,holdout=FALSE,loss="MSE")
es(AirPassengers,model="MAM",h=18,holdout=TRUE,loss="TMSE")

# Model selection example
es(BJsales,model="ZZN",ic="AIC",h=8,holdout=FALSE,bounds="a")

# Model selection. Compare AICc of these two models:
es(AirPassengers,"ZZZ",h=10,holdout=TRUE)
es(AirPassengers,"MAdM",h=10,holdout=TRUE)

# Model selection, excluding multiplicative trend
es(AirPassengers,model="ZXZ",h=8,holdout=TRUE)

# Combination example
es(BJsales,model="CCN",h=8,holdout=TRUE)

# Model selection using a specified pool of models
ourModel &lt;- es(AirPassengers,model=c("ANN","AAM","AMdA"),h=18)

# Produce forecast and prediction interval
forecast(ourModel, h=18, interval="parametric")

# Semiparametric interval example
forecast(ourModel, h=18, interval="semiparametric")

# This will be the same model as in previous line but estimated on new portion of data
es(BJsales,model=ourModel,h=18,holdout=FALSE)

</code></pre>

<hr>
<h2 id='forecast.adam'>Forecasting time series using smooth functions</h2><span id='topic+forecast.adam'></span><span id='topic+forecast.smooth'></span><span id='topic+forecast'></span><span id='topic+forecast.oes'></span><span id='topic+forecast.msdecompose'></span>

<h3>Description</h3>

<p>Function produces conditional expectation (point forecasts) and prediction
intervals for the estimated model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adam'
forecast(object, h = 10, newdata = NULL,
  occurrence = NULL, interval = c("none", "prediction", "confidence",
  "simulated", "approximate", "semiparametric", "nonparametric", "empirical",
  "complete"), level = 0.95, side = c("both", "upper", "lower"),
  cumulative = FALSE, nsim = NULL, scenarios = FALSE, ...)

## S3 method for class 'smooth'
forecast(object, h = 10, interval = c("parametric",
  "semiparametric", "nonparametric", "none"), level = 0.95,
  side = c("both", "upper", "lower"), ...)

## S3 method for class 'oes'
forecast(object, h = 10, ...)

## S3 method for class 'msdecompose'
forecast(object, h = 10, interval = c("parametric",
  "semiparametric", "nonparametric", "none"), level = 0.95, model = NULL,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.adam_+3A_object">object</code></td>
<td>
<p>Time series model for which forecasts are required.</p>
</td></tr>
<tr><td><code id="forecast.adam_+3A_h">h</code></td>
<td>
<p>Forecast horizon.</p>
</td></tr>
<tr><td><code id="forecast.adam_+3A_newdata">newdata</code></td>
<td>
<p>The new data needed in order to produce forecasts.</p>
</td></tr>
<tr><td><code id="forecast.adam_+3A_occurrence">occurrence</code></td>
<td>
<p>The vector containing the future occurrence variable
(values in [0,1]), if it is known.</p>
</td></tr>
<tr><td><code id="forecast.adam_+3A_interval">interval</code></td>
<td>
<p>What type of mechanism to use for interval construction.
the recommended option is <code>interval="prediction"</code>, which will use analytical
solutions for pure additive models and simulations for the others.
<code>interval="simulated"</code> is the slowest method, but is robust to the type of
model. <code>interval="approximate"</code> (aka <code>interval="parametric"</code>) uses
analytical formulae for conditional h-steps ahead variance, but is approximate
for the non-additive error models. <code>interval="semiparametric"</code> relies on the
multiple steps ahead forecast error (extracted via <code>rmultistep</code> method) and on
the assumed distribution of the error term. <code>interval="nonparametric"</code> uses
Taylor &amp; Bunn (1999) approach with quantile regressions. <code>interval="empirical"</code>
constructs intervals based on empirical quantiles of multistep forecast errors.
<code>interval="complete"</code> will call for <code>reforecast()</code> function and produce
interval based on the uncertainty around the parameters of the model.
Finally, <code>interval="confidence"</code> tries to generate the confidence intervals
for the point forecast based on the <code>reforecast</code> method.</p>
</td></tr>
<tr><td><code id="forecast.adam_+3A_level">level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td></tr>
<tr><td><code id="forecast.adam_+3A_side">side</code></td>
<td>
<p>Defines, whether to provide <code>"both"</code> sides of prediction
interval or only <code>"upper"</code>, or <code>"lower"</code>.</p>
</td></tr>
<tr><td><code id="forecast.adam_+3A_cumulative">cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td></tr>
<tr><td><code id="forecast.adam_+3A_nsim">nsim</code></td>
<td>
<p>Number of iterations to do in cases of <code>interval="simulated"</code>,
<code>interval="prediction"</code> (for mixed and multiplicative model),
<code>interval="confidence"</code> and <code>interval="complete"</code>.
The default value for the prediction / simulated interval is 1000. In case of
confidence or complete intervals, this is set to 100.</p>
</td></tr>
<tr><td><code id="forecast.adam_+3A_scenarios">scenarios</code></td>
<td>
<p>Binary, defining whether to return scenarios produced via
simulations or not. Only works if <code>interval="simulated"</code>. If <code>TRUE</code>
the object will contain <code>scenarios</code> variable.</p>
</td></tr>
<tr><td><code id="forecast.adam_+3A_...">...</code></td>
<td>
<p>Other arguments accepted by either <a href="#topic+es">es</a>,
<a href="#topic+ces">ces</a>, <a href="#topic+gum">gum</a> or <a href="#topic+ssarima">ssarima</a>.</p>
</td></tr>
<tr><td><code id="forecast.adam_+3A_model">model</code></td>
<td>
<p>The type of ETS model to fit on the decomposed trend. Only applicable to
&quot;msdecompose&quot; class. This is then returned in parameter &quot;esmodel&quot;. If <code>NULL</code>, then
it will be selected automatically based on the type of the used decomposition (either
among pure additive or among pure multiplicative ETS models).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the function will generate conditional expectations from the
estimated model and will also produce a variety of prediction intervals
based on user preferences.
</p>


<h3>Value</h3>

<p>Returns object of class &quot;smooth.forecast&quot;, which contains:
</p>

<ul>
<li> <p><code>model</code> - the estimated model (ES / CES / GUM / SSARIMA).
</p>
</li>
<li> <p><code>method</code> - the name of the estimated model (ES / CES / GUM / SSARIMA).
</p>
</li>
<li> <p><code>forecast</code> aka <code>mean</code> - point forecasts of the model
(conditional mean).
</p>
</li>
<li> <p><code>lower</code> - lower bound of prediction interval.
</p>
</li>
<li> <p><code>upper</code> - upper bound of prediction interval.
</p>
</li>
<li> <p><code>level</code> - confidence level.
</p>
</li>
<li> <p><code>interval</code> - binary variable (whether interval were produced or not).
</p>
</li>
<li> <p><code>scenarios</code> - in case of <code>forecast.adam()</code> and
<code>interval="simulated"</code> returns matrix with scenarios (future paths) that were
used in simulations.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>

<p>Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="generics.html#topic+forecast">forecast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ourModel &lt;- ces(rnorm(100,0,1),h=10)

forecast(ourModel,h=10)
forecast(ourModel,h=10,interval=TRUE)
plot(forecast(ourModel,h=10,interval=TRUE))

</code></pre>

<hr>
<h2 id='gum'>Generalised Univariate Model</h2><span id='topic+gum'></span><span id='topic+ges'></span>

<h3>Description</h3>

<p>Function constructs Generalised Univariate Model, estimating matrices F, w,
vector g and initial parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gum(y, orders = c(1, 1), lags = c(1, frequency(y)), type = c("additive",
  "multiplicative"), persistence = NULL, transition = NULL,
  measurement = rep(1, sum(orders)), initial = c("optimal", "backcasting"),
  ic = c("AICc", "AIC", "BIC", "BICc"), loss = c("likelihood", "MSE",
  "MAE", "HAM", "MSEh", "TMSE", "GTMSE", "MSCE"), h = 10, holdout = FALSE,
  cumulative = FALSE, interval = c("none", "parametric", "likelihood",
  "semiparametric", "nonparametric"), level = 0.95,
  bounds = c("restricted", "admissible", "none"), silent = c("all",
  "graph", "legend", "output", "none"), xreg = NULL, regressors = c("use",
  "select"), initialX = NULL, ...)

ges(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gum_+3A_y">y</code></td>
<td>
<p>Vector or ts object, containing data needed to be forecasted.</p>
</td></tr>
<tr><td><code id="gum_+3A_orders">orders</code></td>
<td>
<p>Order of the model. Specified as vector of number of states
with different lags. For example, <code>orders=c(1,1)</code> means that there are
two states: one of the first lag type, the second of the second type.</p>
</td></tr>
<tr><td><code id="gum_+3A_lags">lags</code></td>
<td>
<p>Defines lags for the corresponding orders. If, for example,
<code>orders=c(1,1)</code> and lags are defined as <code>lags=c(1,12)</code>, then the
model will have two states: the first will have lag 1 and the second will
have lag 12. The length of <code>lags</code> must correspond to the length of
<code>orders</code>.</p>
</td></tr>
<tr><td><code id="gum_+3A_type">type</code></td>
<td>
<p>Type of model. Can either be <code>"A"</code> - additive - or
<code>"M"</code> - multiplicative. The latter means that the GUM is fitted on
log-transformed data.</p>
</td></tr>
<tr><td><code id="gum_+3A_persistence">persistence</code></td>
<td>
<p>Persistence vector <code class="reqn">g</code>, containing smoothing
parameters. If <code>NULL</code>, then estimated.</p>
</td></tr>
<tr><td><code id="gum_+3A_transition">transition</code></td>
<td>
<p>Transition matrix <code class="reqn">F</code>. Can be provided as a vector.
Matrix will be formed using the default <code>matrix(transition,nc,nc)</code>,
where <code>nc</code> is the number of components in state vector. If <code>NULL</code>,
then estimated.</p>
</td></tr>
<tr><td><code id="gum_+3A_measurement">measurement</code></td>
<td>
<p>Measurement vector <code class="reqn">w</code>. If <code>NULL</code>, then
estimated.</p>
</td></tr>
<tr><td><code id="gum_+3A_initial">initial</code></td>
<td>
<p>Can be either character or a vector of initial states. If it
is character, then it can be <code>"optimal"</code>, meaning that the initial
states are optimised, or <code>"backcasting"</code>, meaning that the initials are
produced using backcasting procedure.</p>
</td></tr>
<tr><td><code id="gum_+3A_ic">ic</code></td>
<td>
<p>The information criterion used in the model selection procedure.</p>
</td></tr>
<tr><td><code id="gum_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization. <code>loss</code> can
be: <code>likelihood</code> (assuming Normal distribution of error term),
<code>MSE</code> (Mean Squared Error), <code>MAE</code> (Mean Absolute Error),
<code>HAM</code> (Half Absolute Moment), <code>TMSE</code> - Trace Mean Squared Error,
<code>GTMSE</code> - Geometric Trace Mean Squared Error, <code>MSEh</code> - optimisation
using only h-steps ahead error, <code>MSCE</code> - Mean Squared Cumulative Error.
If <code>loss!="MSE"</code>, then likelihood and model selection is done based
on equivalent <code>MSE</code>. Model selection in this cases becomes not optimal.
</p>
<p>There are also available analytical approximations for multistep functions:
<code>aMSEh</code>, <code>aTMSE</code> and <code>aGTMSE</code>. These can be useful in cases
of small samples.
</p>
<p>Finally, just for fun the absolute and half analogues of multistep estimators
are available: <code>MAEh</code>, <code>TMAE</code>, <code>GTMAE</code>, <code>MACE</code>, <code>TMAE</code>,
<code>HAMh</code>, <code>THAM</code>, <code>GTHAM</code>, <code>CHAM</code>.</p>
</td></tr>
<tr><td><code id="gum_+3A_h">h</code></td>
<td>
<p>Length of forecasting horizon.</p>
</td></tr>
<tr><td><code id="gum_+3A_holdout">holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td></tr>
<tr><td><code id="gum_+3A_cumulative">cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td></tr>
<tr><td><code id="gum_+3A_interval">interval</code></td>
<td>
<p>Type of interval to construct. This can be:
</p>

<ul>
<li> <p><code>"none"</code>, aka <code>"n"</code> - do not produce prediction
interval.
</p>
</li>
<li> <p><code>"parametric"</code>, <code>"p"</code> - use state-space structure of ETS. In
case of mixed models this is done using simulations, which may take longer
time than for the pure additive and pure multiplicative models. This type
of interval relies on unbiased estimate of in-sample error variance, which
divides the sume of squared errors by T-k rather than just T.
</p>
</li>
<li> <p><code>"likelihood"</code>, <code>"l"</code> - these are the same as <code>"p"</code>, but
relies on the biased estimate of variance from the likelihood (division by
T, not by T-k).
</p>
</li>
<li> <p><code>"semiparametric"</code>, <code>"sp"</code> - interval based on covariance
matrix of 1 to h steps ahead errors and assumption of normal / log-normal
distribution (depending on error type).
</p>
</li>
<li> <p><code>"nonparametric"</code>, <code>"np"</code> - interval based on values from a
quantile regression on error matrix (see Taylor and Bunn, 1999). The model
used in this process is e[j] = a j^b, where j=1,..,h.
</p>
</li></ul>

<p>The parameter also accepts <code>TRUE</code> and <code>FALSE</code>. The former means that
parametric interval are constructed, while the latter is equivalent to
<code>none</code>.
If the forecasts of the models were combined, then the interval are combined
quantile-wise (Lichtendahl et al., 2013).</p>
</td></tr>
<tr><td><code id="gum_+3A_level">level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td></tr>
<tr><td><code id="gum_+3A_bounds">bounds</code></td>
<td>
<p>What type of bounds to use in the model estimation. The first
letter can be used instead of the whole word.</p>
</td></tr>
<tr><td><code id="gum_+3A_silent">silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words (&quot;n&quot;,
&quot;a&quot;, &quot;g&quot;, &quot;l&quot;, &quot;o&quot;).</p>
</td></tr>
<tr><td><code id="gum_+3A_xreg">xreg</code></td>
<td>
<p>The vector (either numeric or time series) or the matrix (or
data.frame) of exogenous variables that should be included in the model. If
matrix included than columns should contain variables and rows - observations.
Note that <code>xreg</code> should have number of observations equal either to
in-sample or to the whole series. If the number of observations in
<code>xreg</code> is equal to in-sample, then values for the holdout sample are
produced using <a href="#topic+es">es</a> function.</p>
</td></tr>
<tr><td><code id="gum_+3A_regressors">regressors</code></td>
<td>
<p>The variable defines what to do with the provided xreg:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done.
<code>"combine"</code> will be available at some point in future...</p>
</td></tr>
<tr><td><code id="gum_+3A_initialx">initialX</code></td>
<td>
<p>The vector of initial parameters for exogenous variables.
Ignored if <code>xreg</code> is NULL.</p>
</td></tr>
<tr><td><code id="gum_+3A_...">...</code></td>
<td>
<p>Other non-documented parameters.  For example parameter
<code>model</code> can accept a previously estimated GUM model and use all its
parameters.  <code>FI=TRUE</code> will make the function produce Fisher
Information matrix, which then can be used to calculated variances of
parameters of the model.
You can also pass two parameters to the optimiser: 1. <code>maxeval</code> - maximum
number of evaluations to carry on; 2. <code>xtol_rel</code> - the precision of the
optimiser. The default values used in es() are <code>maxeval=5000</code> and
<code>xtol_rel=1e-8</code>. You can read more about these parameters in the
documentation of <a href="nloptr.html#topic+nloptr">nloptr</a> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates the Single Source of Error state space model of the
following type:
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = o_{t} (w' v_{t-l} + x_t a_{t-1} + \epsilon_{t})</code>
</p>

<p style="text-align: center;"><code class="reqn">v_{t} = F v_{t-l} + g \epsilon_{t}</code>
</p>

<p style="text-align: center;"><code class="reqn">a_{t} = F_{X} a_{t-1} + g_{X} \epsilon_{t} / x_{t}</code>
</p>

<p>Where <code class="reqn">o_{t}</code> is the Bernoulli distributed random variable (in case of
normal data equal to 1), <code class="reqn">v_{t}</code> is the state vector (defined using
<code>orders</code>) and <code class="reqn">l</code> is the vector of <code>lags</code>, <code class="reqn">x_t</code> is the
vector of exogenous parameters. <code class="reqn">w</code> is the <code>measurement</code> vector,
<code class="reqn">F</code> is the <code>transition</code> matrix, <code class="reqn">g</code> is the <code>persistence</code>
vector, <code class="reqn">a_t</code> is the vector of parameters for exogenous variables,
<code class="reqn">F_{X}</code> is the <code>transitionX</code> matrix and <code class="reqn">g_{X}</code> is the
<code>persistenceX</code> matrix. Finally, <code class="reqn">\epsilon_{t}</code> is the error term.
</p>
<p>For some more information about the model and its implementation, see the
vignette: <code>vignette("gum","smooth")</code>
</p>


<h3>Value</h3>

<p>Object of class &quot;smooth&quot; is returned. It contains:
</p>

<ul>
<li> <p><code>model</code> - name of the estimated model.
</p>
</li>
<li> <p><code>timeElapsed</code> - time elapsed for the construction of the model.
</p>
</li>
<li> <p><code>states</code> - matrix of fuzzy components of GUM, where <code>rows</code>
correspond to time and <code>cols</code> to states.
</p>
</li>
<li> <p><code>initialType</code> - Type of the initial values used.
</p>
</li>
<li> <p><code>initial</code> - initial values of state vector (extracted from
<code>states</code>).
</p>
</li>
<li> <p><code>nParam</code> - table with the number of estimated / provided parameters.
If a previous model was reused, then its initials are reused and the number of
provided parameters will take this into account.
</p>
</li>
<li> <p><code>measurement</code> - matrix w.
</p>
</li>
<li> <p><code>transition</code> - matrix F.
</p>
</li>
<li> <p><code>persistence</code> - persistence vector. This is the place, where
smoothing parameters live.
</p>
</li>
<li> <p><code>fitted</code> - fitted values.
</p>
</li>
<li> <p><code>forecast</code> - point forecast.
</p>
</li>
<li> <p><code>lower</code> - lower bound of prediction interval. When
<code>interval="none"</code> then NA is returned.
</p>
</li>
<li> <p><code>upper</code> - higher bound of prediction interval. When
<code>interval="none"</code> then NA is returned.
</p>
</li>
<li> <p><code>residuals</code> - the residuals of the estimated model.
</p>
</li>
<li> <p><code>errors</code> - matrix of 1 to h steps ahead errors. Only returned when the
multistep losses are used and semiparametric interval is needed.
</p>
</li>
<li> <p><code>s2</code> - variance of the residuals (taking degrees of freedom
into account).
</p>
</li>
<li> <p><code>interval</code> - type of interval asked by user.
</p>
</li>
<li> <p><code>level</code> - confidence level for interval.
</p>
</li>
<li> <p><code>cumulative</code> - whether the produced forecast was cumulative or not.
</p>
</li>
<li> <p><code>y</code> - original data.
</p>
</li>
<li> <p><code>holdout</code> - holdout part of the original data.
</p>
</li>
<li> <p><code>xreg</code> - provided vector or matrix of exogenous variables. If
<code>regressors="s"</code>, then this value will contain only selected exogenous variables.
</p>
</li>
<li> <p><code>initialX</code> - initial values for parameters of exogenous variables.
</p>
</li>
<li> <p><code>ICs</code> - values of information criteria of the model. Includes
AIC, AICc, BIC and BICc.
</p>
</li>
<li> <p><code>logLik</code> - log-likelihood of the function.
</p>
</li>
<li> <p><code>lossValue</code> - Cost function value.
</p>
</li>
<li> <p><code>loss</code> - Type of loss function used in the estimation.
</p>
</li>
<li> <p><code>FI</code> - Fisher Information. Equal to NULL if <code>FI=FALSE</code> or
when <code>FI</code> variable is not provided at all.
</p>
</li>
<li> <p><code>accuracy</code> - vector of accuracy measures for the holdout sample.
In case of non-intermittent data includes: MPE, MAPE, SMAPE, MASE, sMAE,
RelMAE, sMSE and Bias coefficient (based on complex numbers). In case of
intermittent data the set of errors will be: sMSE, sPIS, sCE (scaled
cumulative error) and Bias coefficient. This is available only when
<code>holdout=TRUE</code>.
</p>
</li>
<li> <p><code>B</code> - the vector of all the estimated parameters.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov I. (2023) Smooth forecasting with the smooth package in R. arXiv:2301.01790.
<a href="https://doi.org/10.48550/arXiv.2301.01790">doi:10.48550/arXiv.2301.01790</a>.
</p>
</li>
<li><p> Svetunkov I. (2015 - Inf) &quot;smooth&quot; package for R - series of posts about the underlying
models and how to use them: <a href="https://openforecast.org/category/r-en/smooth/">https://openforecast.org/category/r-en/smooth/</a>.
</p>
</li></ul>


<ul>
<li><p> Taylor, J.W. and Bunn, D.W. (1999) A Quantile Regression Approach to
Generating Prediction Intervals. Management Science, Vol 45, No 2, pp
225-237.
</p>
</li>
<li><p> Lichtendahl Kenneth C., Jr., Grushka-Cockayne Yael, Winkler
Robert L., (2013) Is It Better to Average Probabilities or
Quantiles? Management Science 59(7):1594-1611. DOI:
<a href="https://doi.org/10.1287/mnsc.1120.1667">doi:10.1287/mnsc.1120.1667</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+adam">adam</a>, <a href="#topic+es">es</a>, <a href="#topic+ces">ces</a>,
<a href="#topic+sim.es">sim.es</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Something simple:
gum(rnorm(118,100,3),orders=c(1),lags=c(1),h=18,holdout=TRUE,bounds="a",interval="p")

# A more complicated model with seasonality
ourModel &lt;- gum(rnorm(118,100,3),orders=c(2,1),lags=c(1,4),h=18,holdout=TRUE)

# Redo previous model on a new data and produce prediction interval
gum(rnorm(118,100,3),model=ourModel,h=18,interval="sp")

# Produce something crazy with optimal initials (not recommended)
gum(rnorm(118,100,3),orders=c(1,1,1),lags=c(1,3,5),h=18,holdout=TRUE,initial="o")

# Simpler model estiamted using trace forecast error loss function and its analytical analogue
gum(rnorm(118,100,3),orders=c(1),lags=c(1),h=18,holdout=TRUE,bounds="n",loss="TMSE")
gum(rnorm(118,100,3),orders=c(1),lags=c(1),h=18,holdout=TRUE,bounds="n",loss="aTMSE")

# Introduce exogenous variables
gum(rnorm(118,100,3),orders=c(1),lags=c(1),h=18,holdout=TRUE,xreg=c(1:118))

# Or select the most appropriate one
gum(rnorm(118,100,3),orders=c(1),lags=c(1),h=18,holdout=TRUE,xreg=c(1:118),regressors="s")

summary(ourModel)
forecast(ourModel)
plot(forecast(ourModel))

</code></pre>

<hr>
<h2 id='is.smooth'>Smooth classes checkers</h2><span id='topic+is.smooth'></span><span id='topic+is.smoothC'></span><span id='topic+is.msarima'></span><span id='topic+is.oes'></span><span id='topic+is.oesg'></span><span id='topic+is.smooth.sim'></span><span id='topic+is.smooth.forecast'></span><span id='topic+is.adam'></span><span id='topic+is.adam.sim'></span><span id='topic+is.msdecompose'></span><span id='topic+is.msdecompose.forecast'></span>

<h3>Description</h3>

<p>Functions to check if an object is of the specified class
</p>
<p>Functions to check if an object is of the specified class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.smooth(x)

is.smoothC(x)

is.msarima(x)

is.oes(x)

is.oesg(x)

is.smooth.sim(x)

is.smooth.forecast(x)

is.adam(x)

is.adam.sim(x)

is.msdecompose(x)

is.msdecompose.forecast(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.smooth_+3A_x">x</code></td>
<td>
<p>The object to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of functions includes:
</p>

<ul>
<li> <p><code>is.smooth()</code> tests if the object was produced by a smooth function
(e.g. <a href="#topic+es">es</a> / <a href="#topic+ces">ces</a> / <a href="#topic+ssarima">ssarima</a> /
<a href="#topic+gum">gum</a> / <a href="#topic+sma">sma</a> / <a href="#topic+msarima">msarima</a>);
</p>
</li>
<li> <p><code>is.msarima()</code> tests if the object was produced by the
<a href="#topic+msarima">msarima</a> function;
</p>
</li>
<li> <p><code>is.smoothC()</code> tests if the object was produced by a combination
function (currently applies only to <a href="#topic+smoothCombine">smoothCombine</a>);
</p>
</li>
<li> <p><code>is.oes()</code> tests if the object was produced by <a href="#topic+oes">oes</a>
function;
</p>
</li>
<li> <p><code>is.smooth.sim()</code> tests if the object was produced by simulate functions
(e.g. <a href="#topic+sim.es">sim.es</a> / <a href="#topic+sim.ces">sim.ces</a> / <a href="#topic+sim.ssarima">sim.ssarima</a>
/ <a href="#topic+sim.sma">sim.sma</a> / <a href="#topic+sim.gum">sim.gum</a>);
</p>
</li>
<li> <p><code>is.smooth.forecast()</code> checks if the forecast was produced from a smooth
function using forecast() function.
</p>
</li></ul>

<p>The list of functions includes:
</p>

<ul>
<li> <p><code>is.adam()</code> tests if the object was produced by a <a href="#topic+adam">adam</a> function
</p>
</li>
<li> <p><code>is.adam.sim()</code> tests if the object was produced by sim.adam() function (not implemented yet);
</p>
</li></ul>



<h3>Value</h3>

<p><code>TRUE</code> if this is the specified class and <code>FALSE</code> otherwise.
</p>
<p><code>TRUE</code> if this is the specified class and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ourModel &lt;- msarima(rnorm(100,100,10))

is.smooth(ourModel)
is.msarima(ourModel)


ourModel &lt;- adam(rnorm(100,100,10))
is.adam(ourModel)

</code></pre>

<hr>
<h2 id='msarima'>Multiple Seasonal ARIMA</h2><span id='topic+msarima'></span><span id='topic+auto.msarima'></span><span id='topic+msarima_old'></span>

<h3>Description</h3>

<p>Function constructs Multiple Seasonal State Space ARIMA, estimating AR, MA
terms and initial states. It is a wrapper of <a href="#topic+adam">adam</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msarima(y, orders = list(ar = c(0), i = c(1), ma = c(1)), lags = c(1),
  constant = FALSE, AR = NULL, MA = NULL, model = NULL,
  initial = c("optimal", "backcasting", "complete"), ic = c("AICc", "AIC",
  "BIC", "BICc"), loss = c("likelihood", "MSE", "MAE", "HAM", "MSEh", "TMSE",
  "GTMSE", "MSCE"), h = 10, holdout = FALSE, bounds = c("usual",
  "admissible", "none"), silent = TRUE, xreg = NULL,
  regressors = c("use", "select", "adapt"), initialX = NULL, ...)

auto.msarima(y, orders = list(ar = c(3, 3), i = c(2, 1), ma = c(3, 3)),
  lags = c(1, frequency(y)), initial = c("optimal", "backcasting",
  "complete"), ic = c("AICc", "AIC", "BIC", "BICc"), loss = c("likelihood",
  "MSE", "MAE", "HAM", "MSEh", "TMSE", "GTMSE", "MSCE"), h = 10,
  holdout = FALSE, bounds = c("usual", "admissible", "none"),
  silent = TRUE, xreg = NULL, regressors = c("use", "select", "adapt"),
  initialX = NULL, ...)

msarima_old(y, orders = list(ar = c(0), i = c(1), ma = c(1)), lags = c(1),
  constant = FALSE, AR = NULL, MA = NULL, initial = c("backcasting",
  "optimal"), ic = c("AICc", "AIC", "BIC", "BICc"), loss = c("likelihood",
  "MSE", "MAE", "HAM", "MSEh", "TMSE", "GTMSE", "MSCE"), h = 10,
  holdout = FALSE, cumulative = FALSE, interval = c("none", "parametric",
  "likelihood", "semiparametric", "nonparametric"), level = 0.95,
  bounds = c("admissible", "none"), silent = c("all", "graph", "legend",
  "output", "none"), xreg = NULL, regressors = c("use", "select"),
  initialX = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msarima_+3A_y">y</code></td>
<td>
<p>Vector or ts object, containing data needed to be forecasted.</p>
</td></tr>
<tr><td><code id="msarima_+3A_orders">orders</code></td>
<td>
<p>List of orders, containing vector variables <code>ar</code>,
<code>i</code> and <code>ma</code>. Example:
<code>orders=list(ar=c(1,2),i=c(1),ma=c(1,1,1))</code>. If a variable is not
provided in the list, then it is assumed to be equal to zero. At least one
variable should have the same length as <code>lags</code>. Another option is to
specify orders as a vector of a form <code>orders=c(p,d,q)</code>. The non-seasonal
ARIMA(p,d,q) is constructed in this case.
For <code>auto.msarima</code> this is the list of maximum orders to check,
containing vector variables <code>ar</code>, <code>i</code> and <code>ma</code>. If a variable
is not provided in the list, then it is assumed to be equal to zero. At least
one variable should have the same length as <code>lags</code>.</p>
</td></tr>
<tr><td><code id="msarima_+3A_lags">lags</code></td>
<td>
<p>Defines lags for the corresponding orders (see examples above).
The length of <code>lags</code> must correspond to the length of either <code>ar</code>,
<code>i</code> or <code>ma</code> in <code>orders</code> variable. There is no restrictions on
the length of <code>lags</code> vector. It is recommended to order <code>lags</code>
ascending.
The orders are set by a user. If you want the automatic order selection,
then use <a href="#topic+auto.msarima">auto.msarima</a> function instead.</p>
</td></tr>
<tr><td><code id="msarima_+3A_constant">constant</code></td>
<td>
<p>If <code>TRUE</code>, constant term is included in the model. Can
also be a number (constant value). For <code>auto.msarima</code>, if <code>NULL</code>,
then the function will check if constant is needed.</p>
</td></tr>
<tr><td><code id="msarima_+3A_ar">AR</code></td>
<td>
<p>Vector or matrix of AR parameters. The order of parameters should
be lag-wise. This means that first all the AR parameters of the firs lag
should be passed, then for the second etc. AR of another msarima can be
passed here.</p>
</td></tr>
<tr><td><code id="msarima_+3A_ma">MA</code></td>
<td>
<p>Vector or matrix of MA parameters. The order of parameters should
be lag-wise. This means that first all the MA parameters of the firs lag
should be passed, then for the second etc. MA of another msarima can be
passed here.</p>
</td></tr>
<tr><td><code id="msarima_+3A_model">model</code></td>
<td>
<p>Previously estimated MSARIMA model.</p>
</td></tr>
<tr><td><code id="msarima_+3A_initial">initial</code></td>
<td>
<p>Can be either character or a vector of initial states.
If it is character, then it can be <code>"optimal"</code>, meaning that all initial
states are optimised, or <code>"backcasting"</code>, meaning that the initials of
dynamic part of the model are produced using backcasting procedure (advised
for data with high frequency). In the latter case, the parameters of the
explanatory variables are optimised. This is recommended for ARIMAX
model. Alternatively, you can set <code>initial="complete"</code> backcasting,
which means that all states (including explanatory variables) are initialised
via backcasting.</p>
</td></tr>
<tr><td><code id="msarima_+3A_ic">ic</code></td>
<td>
<p>The information criterion used in the model selection procedure.</p>
</td></tr>
<tr><td><code id="msarima_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization. <code>loss</code> can
be: <code>likelihood</code> (assuming Normal distribution of error term),
<code>MSE</code> (Mean Squared Error), <code>MAE</code> (Mean Absolute Error),
<code>HAM</code> (Half Absolute Moment), <code>TMSE</code> - Trace Mean Squared Error,
<code>GTMSE</code> - Geometric Trace Mean Squared Error, <code>MSEh</code> - optimisation
using only h-steps ahead error, <code>MSCE</code> - Mean Squared Cumulative Error.
If <code>loss!="MSE"</code>, then likelihood and model selection is done based
on equivalent <code>MSE</code>. Model selection in this cases becomes not optimal.
</p>
<p>There are also available analytical approximations for multistep functions:
<code>aMSEh</code>, <code>aTMSE</code> and <code>aGTMSE</code>. These can be useful in cases
of small samples.
</p>
<p>Finally, just for fun the absolute and half analogues of multistep estimators
are available: <code>MAEh</code>, <code>TMAE</code>, <code>GTMAE</code>, <code>MACE</code>, <code>TMAE</code>,
<code>HAMh</code>, <code>THAM</code>, <code>GTHAM</code>, <code>CHAM</code>.</p>
</td></tr>
<tr><td><code id="msarima_+3A_h">h</code></td>
<td>
<p>Length of forecasting horizon.</p>
</td></tr>
<tr><td><code id="msarima_+3A_holdout">holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td></tr>
<tr><td><code id="msarima_+3A_bounds">bounds</code></td>
<td>
<p>What type of bounds to use in the model estimation. The first
letter can be used instead of the whole word.</p>
</td></tr>
<tr><td><code id="msarima_+3A_silent">silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words (&quot;n&quot;,
&quot;a&quot;, &quot;g&quot;, &quot;l&quot;, &quot;o&quot;).</p>
</td></tr>
<tr><td><code id="msarima_+3A_xreg">xreg</code></td>
<td>
<p>The vector (either numeric or time series) or the matrix (or
data.frame) of exogenous variables that should be included in the model. If
matrix included than columns should contain variables and rows - observations.
Note that <code>xreg</code> should have number of observations equal either to
in-sample or to the whole series. If the number of observations in
<code>xreg</code> is equal to in-sample, then values for the holdout sample are
produced using <a href="#topic+es">es</a> function.</p>
</td></tr>
<tr><td><code id="msarima_+3A_regressors">regressors</code></td>
<td>
<p>The variable defines what to do with the provided xreg:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done.
<code>"combine"</code> will be available at some point in future...</p>
</td></tr>
<tr><td><code id="msarima_+3A_initialx">initialX</code></td>
<td>
<p>The vector of initial parameters for exogenous variables.
Ignored if <code>xreg</code> is NULL.</p>
</td></tr>
<tr><td><code id="msarima_+3A_...">...</code></td>
<td>
<p>Other non-documented parameters. see <a href="#topic+adam">adam</a> for
details.
</p>
<p><code>FI=TRUE</code> will make the function produce Fisher Information matrix,
which then can be used to calculated variances of parameters of the model.</p>
</td></tr>
<tr><td><code id="msarima_+3A_cumulative">cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td></tr>
<tr><td><code id="msarima_+3A_interval">interval</code></td>
<td>
<p>Type of interval to construct. This can be:
</p>

<ul>
<li> <p><code>"none"</code>, aka <code>"n"</code> - do not produce prediction
interval.
</p>
</li>
<li> <p><code>"parametric"</code>, <code>"p"</code> - use state-space structure of ETS. In
case of mixed models this is done using simulations, which may take longer
time than for the pure additive and pure multiplicative models. This type
of interval relies on unbiased estimate of in-sample error variance, which
divides the sume of squared errors by T-k rather than just T.
</p>
</li>
<li> <p><code>"likelihood"</code>, <code>"l"</code> - these are the same as <code>"p"</code>, but
relies on the biased estimate of variance from the likelihood (division by
T, not by T-k).
</p>
</li>
<li> <p><code>"semiparametric"</code>, <code>"sp"</code> - interval based on covariance
matrix of 1 to h steps ahead errors and assumption of normal / log-normal
distribution (depending on error type).
</p>
</li>
<li> <p><code>"nonparametric"</code>, <code>"np"</code> - interval based on values from a
quantile regression on error matrix (see Taylor and Bunn, 1999). The model
used in this process is e[j] = a j^b, where j=1,..,h.
</p>
</li></ul>

<p>The parameter also accepts <code>TRUE</code> and <code>FALSE</code>. The former means that
parametric interval are constructed, while the latter is equivalent to
<code>none</code>.
If the forecasts of the models were combined, then the interval are combined
quantile-wise (Lichtendahl et al., 2013).</p>
</td></tr>
<tr><td><code id="msarima_+3A_level">level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model, implemented in this function differs from the one in
<a href="#topic+ssarima">ssarima</a> function (Svetunkov &amp; Boylan, 2019), but it is more
efficient and better fitting the data (which might be a limitation).
</p>
<p>The basic ARIMA(p,d,q) used in the function has the following form:
</p>
<p><code class="reqn">(1 - B)^d (1 - a_1 B - a_2 B^2 - ... - a_p B^p) y_[t] = (1 + b_1 B +
b_2 B^2 + ... + b_q B^q) \epsilon_[t] + c</code>
</p>
<p>where <code class="reqn">y_[t]</code> is the actual values, <code class="reqn">\epsilon_[t]</code> is the error term,
<code class="reqn">a_i, b_j</code> are the parameters for AR and MA respectively and <code class="reqn">c</code> is
the constant. In case of non-zero differences <code class="reqn">c</code> acts as drift.
</p>
<p>This model is then transformed into ARIMA in the Single Source of Error
State space form (based by Snyder, 1985, but in a slightly different
formulation):
</p>
<p><code class="reqn">y_{t} = o_{t} (w' v_{t-l} + x_t a_{t-1} + \epsilon_{t})</code>
</p>
<p><code class="reqn">v_{t} = F v_{t-l} + g \epsilon_{t}</code>
</p>
<p><code class="reqn">a_{t} = F_{X} a_{t-1} + g_{X} \epsilon_{t} / x_{t}</code>
</p>
<p>Where <code class="reqn">o_{t}</code> is the Bernoulli distributed random variable (in case of
normal data equal to 1), <code class="reqn">v_{t}</code> is the state vector (defined based on
<code>orders</code>) and <code class="reqn">l</code> is the vector of <code>lags</code>, <code class="reqn">x_t</code> is the
vector of exogenous parameters. <code class="reqn">w</code> is the <code>measurement</code> vector,
<code class="reqn">F</code> is the <code>transition</code> matrix, <code class="reqn">g</code> is the <code>persistence</code>
vector, <code class="reqn">a_t</code> is the vector of parameters for exogenous variables,
<code class="reqn">F_{X}</code> is the <code>transitionX</code> matrix and <code class="reqn">g_{X}</code> is the
<code>persistenceX</code> matrix. The main difference from <a href="#topic+ssarima">ssarima</a>
function is that this implementation skips zero polynomials, substantially
decreasing the dimension of the transition matrix. As a result, this
function works faster than <a href="#topic+ssarima">ssarima</a> on high frequency data,
and it is more accurate.
</p>
<p>Due to the flexibility of the model, multiple seasonalities can be used. For
example, something crazy like this can be constructed:
SARIMA(1,1,1)(0,1,1)[24](2,0,1)[24*7](0,0,1)[24*30], but the estimation may
take some time... Still this should be estimated in finite time (not like
with <code>ssarima</code>).
</p>
<p>The <code>auto.msarima</code> function constructs several ARIMA models in Single
Source of Error state space form based on <code>adam</code> function (see
<a href="#topic+adam">adam</a> documentation) and selects the best one based on the
selected information criterion.
</p>
<p>For some additional details see the vignettes: <code>vignette("adam","smooth")</code>
and <code>vignette("ssarima","smooth")</code>
</p>


<h3>Value</h3>

<p>Object of class &quot;adam&quot; is returned. It contains the list of the
following values:
</p>

<ul>
<li> <p><code>model</code> - the name of the estimated model.
</p>
</li>
<li> <p><code>timeElapsed</code> - time elapsed for the construction of the model.
</p>
</li>
<li> <p><code>states</code> - the matrix of the fuzzy components of msarima, where
<code>rows</code> correspond to time and <code>cols</code> to states.
</p>
</li>
<li> <p><code>transition</code> - matrix F.
</p>
</li>
<li> <p><code>persistence</code> - the persistence vector. This is the place, where
smoothing parameters live.
</p>
</li>
<li> <p><code>measurement</code> - measurement vector of the model.
</p>
</li>
<li> <p><code>AR</code> - the matrix of coefficients of AR terms.
</p>
</li>
<li> <p><code>I</code> - the matrix of coefficients of I terms.
</p>
</li>
<li> <p><code>MA</code> - the matrix of coefficients of MA terms.
</p>
</li>
<li> <p><code>constant</code> - the value of the constant term.
</p>
</li>
<li> <p><code>initialType</code> - Type of the initial values used.
</p>
</li>
<li> <p><code>initial</code> - the initial values of the state vector (extracted
from <code>states</code>).
</p>
</li>
<li> <p><code>nParam</code> - table with the number of estimated / provided parameters.
If a previous model was reused, then its initials are reused and the number of
provided parameters will take this into account.
</p>
</li>
<li> <p><code>fitted</code> - the fitted values.
</p>
</li>
<li> <p><code>forecast</code> - the point forecast.
</p>
</li>
<li> <p><code>lower</code> - the lower bound of prediction interval. When
<code>interval="none"</code> then NA is returned.
</p>
</li>
<li> <p><code>upper</code> - the higher bound of prediction interval. When
<code>interval="none"</code> then NA is returned.
</p>
</li>
<li> <p><code>residuals</code> - the residuals of the estimated model.
</p>
</li>
<li> <p><code>errors</code> - The matrix of 1 to h steps ahead errors. Only returned when the
multistep losses are used and semiparametric interval is needed.
</p>
</li>
<li> <p><code>s2</code> - variance of the residuals (taking degrees of freedom into
account).
</p>
</li>
<li> <p><code>interval</code> - type of interval asked by user.
</p>
</li>
<li> <p><code>level</code> - confidence level for interval.
</p>
</li>
<li> <p><code>cumulative</code> - whether the produced forecast was cumulative or not.
</p>
</li>
<li> <p><code>y</code> - the original data.
</p>
</li>
<li> <p><code>holdout</code> - the holdout part of the original data.
</p>
</li>
<li> <p><code>xreg</code> - provided vector or matrix of exogenous variables. If
<code>regressors="s"</code>, then this value will contain only selected exogenous
variables.
</p>
</li>
<li> <p><code>initialX</code> - initial values for parameters of exogenous
variables.
</p>
</li>
<li> <p><code>ICs</code> - values of information criteria of the model. Includes
AIC, AICc, BIC and BICc.
</p>
</li>
<li> <p><code>logLik</code> - log-likelihood of the function.
</p>
</li>
<li> <p><code>lossValue</code> - Cost function value.
</p>
</li>
<li> <p><code>loss</code> - Type of loss function used in the estimation.
</p>
</li>
<li> <p><code>FI</code> - Fisher Information. Equal to NULL if <code>FI=FALSE</code>
or when <code>FI</code> is not provided at all.
</p>
</li>
<li> <p><code>accuracy</code> - vector of accuracy measures for the holdout sample.
In case of non-intermittent data includes: MPE, MAPE, SMAPE, MASE, sMAE,
RelMAE, sMSE and Bias coefficient (based on complex numbers). In case of
intermittent data the set of errors will be: sMSE, sPIS, sCE (scaled
cumulative error) and Bias coefficient. This is available only when
<code>holdout=TRUE</code>.
</p>
</li>
<li> <p><code>B</code> - the vector of all the estimated parameters.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Snyder, R. D., 1985. Recursive Estimation of Dynamic Linear Models.
Journal of the Royal Statistical Society, Series B (Methodological) 47 (2), 272-276.
</p>
</li>
<li><p> Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>.
</p>
</li></ul>


<ul>
<li><p> Svetunkov, I., &amp; Boylan, J. E. (2019). State-space ARIMA for supply-chain forecasting.
International Journal of Production Research, 0(0), 110.
<a href="https://doi.org/10.1080/00207543.2019.1600764">doi:10.1080/00207543.2019.1600764</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+adam">adam</a>, <a href="#topic+orders">orders</a>,
<a href="#topic+es">es</a>, <a href="#topic+auto.ssarima">auto.ssarima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(118,100,3)

# The simple call of ARIMA(1,1,1):
ourModel &lt;- msarima(x,orders=c(1,1,1),lags=1,h=18,holdout=TRUE)

# Example of SARIMA(2,0,0)(1,0,0)[4]
msarima(x,orders=list(ar=c(2,1)),lags=c(1,4),h=18,holdout=TRUE)

# SARIMA of a peculiar order on AirPassengers data
ourModel &lt;- msarima(AirPassengers,orders=list(ar=c(1,0,3),i=c(1,0,1),ma=c(0,1,2)),
                    lags=c(1,6,12),h=10,holdout=TRUE)

# ARIMA(1,1,1) with Mean Squared Trace Forecast Error
msarima(x,orders=c(1,1,1),lags=1,h=18,holdout=TRUE,loss="TMSE")

plot(forecast(ourModel, h=18, interval="approximate"))


# The best ARIMA for the data
ourModel &lt;- auto.msarima(x,orders=list(ar=c(2,1),i=c(1,1),ma=c(2,1)),lags=c(1,12),
                     h=18,holdout=TRUE)

# The other one using optimised states
auto.msarima(x,orders=list(ar=c(3,2),i=c(2,1),ma=c(3,2)),lags=c(1,12),
                       h=18,holdout=TRUE)

# And now combined ARIMA
auto.msarima(x,orders=list(ar=c(3,2),i=c(2,1),ma=c(3,2)),lags=c(1,12),
                       combine=TRUE,h=18,holdout=TRUE)

plot(forecast(ourModel, h=18, interval="simulated"))

</code></pre>

<hr>
<h2 id='msdecompose'>Multiple seasonal classical decomposition</h2><span id='topic+msdecompose'></span>

<h3>Description</h3>

<p>Function decomposes multiple seasonal time series into components using
the principles of classical decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msdecompose(y, lags = c(12), type = c("additive", "multiplicative"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msdecompose_+3A_y">y</code></td>
<td>
<p>Vector or ts object, containing data needed to be smoothed.</p>
</td></tr>
<tr><td><code id="msdecompose_+3A_lags">lags</code></td>
<td>
<p>Vector of lags, corresponding to the frequencies in the data.</p>
</td></tr>
<tr><td><code id="msdecompose_+3A_type">type</code></td>
<td>
<p>The type of decomposition. If <code>"multiplicative"</code> is selected,
then the logarithm of data is taken prior to the decomposition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function applies centred moving averages based on <a href="stats.html#topic+filter">filter</a>
function and order specified in <code>lags</code> variable in order to smooth the
original series and obtain level, trend and seasonal components of the series.
</p>


<h3>Value</h3>

<p>The object of the class &quot;msdecompose&quot; is return, containing:
</p>

<ul>
<li> <p><code>y</code> - the original time series.
</p>
</li>
<li> <p><code>initial</code> - the estimates of the initial level and trend.
</p>
</li>
<li> <p><code>trend</code> - the long term trend in the data.
</p>
</li>
<li> <p><code>seasonal</code> - the list of seasonal parameters.
</p>
</li>
<li> <p><code>lags</code> - the provided lags.
</p>
</li>
<li> <p><code>type</code> - the selected type of the decomposition.
</p>
</li>
<li> <p><code>yName</code> - the name of the provided data.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov I. (2023) Smooth forecasting with the smooth package in R. arXiv:2301.01790.
<a href="https://doi.org/10.48550/arXiv.2301.01790">doi:10.48550/arXiv.2301.01790</a>.
</p>
</li>
<li><p> Svetunkov I. (2015 - Inf) &quot;smooth&quot; package for R - series of posts about the underlying
models and how to use them: <a href="https://openforecast.org/category/r-en/smooth/">https://openforecast.org/category/r-en/smooth/</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+filter">filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Decomposition of multiple frequency data
## Not run: ourModel &lt;- msdecompose(forecast::taylor, lags=c(48,336), type="m")
ourModel &lt;- msdecompose(AirPassengers, lags=c(12), type="m")

plot(ourModel)
plot(forecast(ourModel, model="AAN", h=12))

</code></pre>

<hr>
<h2 id='multicov'>Function returns the multiple steps ahead covariance matrix of forecast errors</h2><span id='topic+multicov'></span><span id='topic+multicov.smooth'></span>

<h3>Description</h3>

<p>This function extracts covariance matrix of 1 to h steps ahead forecast errors for
<code>ssarima()</code>, <code>gum()</code>, <code>sma()</code>, <code>es()</code> and <code>ces()</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multicov(object, type = c("analytical", "empirical", "simulated"), h = 10,
  nsim = 1000, ...)

## S3 method for class 'smooth'
multicov(object, type = c("analytical", "empirical",
  "simulated"), h = 10, nsim = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multicov_+3A_object">object</code></td>
<td>
<p>Model estimated using one of the functions of smooth package.</p>
</td></tr>
<tr><td><code id="multicov_+3A_type">type</code></td>
<td>
<p>What method to use in order to produce covariance matrix:
</p>

<ol>
<li> <p><code>analytical</code> - based on the state space structure of the model and the
one-step-ahead forecast error. This works for pure additive and pure multiplicative
models. The values for the mixed models might be off.
</p>
</li>
<li> <p><code>empirical</code> - based on the in-sample 1 to h steps ahead forecast errors
(works fine on larger samples);
</p>
</li>
<li> <p><code>simulated</code> - the data is simulated from the estimated model, then the
same model is applied to it and then the empirical 1 to h steps ahead forecast
errors are produced;
</p>
</li></ol>
</td></tr>
<tr><td><code id="multicov_+3A_h">h</code></td>
<td>
<p>Forecast horizon to use in the calculations.</p>
</td></tr>
<tr><td><code id="multicov_+3A_nsim">nsim</code></td>
<td>
<p>Number of iterations to produce in the simulation. Only needed if
<code>type="simulated"</code></p>
</td></tr>
<tr><td><code id="multicov_+3A_...">...</code></td>
<td>
<p>Other parameters passed to simulate function (if <code>type="simulated"</code>
is used). These are <code>obs</code> and <code>seed</code>. By default <code>obs=1000</code>.
This approach increases the accuracy of covariance matrix on small samples
and intermittent data;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns either scalar (if it is a non-smooth model)
or the matrix of (h x h) size with variances and covariances of 1 to h steps ahead
forecast errors. This is currently done based on empirical values. The analytical ones
are more complicated.
</p>


<h3>Value</h3>

<p>Scalar in cases of non-smooth functions. (h x h) matrix otherwise.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+orders">orders</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(100,0,1)

# A simple example with a 5x5 covariance matrix
ourModel &lt;- ces(x, h=5)
multicov(ourModel)

</code></pre>

<hr>
<h2 id='oes'>Occurrence ETS model</h2><span id='topic+oes'></span>

<h3>Description</h3>

<p>Function returns the occurrence part of iETS model with the specified
probability update and model types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oes(y, model = "MNN", persistence = NULL, initial = "o",
  initialSeason = NULL, phi = NULL, occurrence = c("fixed", "general",
  "odds-ratio", "inverse-odds-ratio", "direct", "auto", "none"),
  ic = c("AICc", "AIC", "BIC", "BICc"), h = 10, holdout = FALSE,
  bounds = c("usual", "admissible", "none"), silent = c("all", "graph",
  "legend", "output", "none"), xreg = NULL, regressors = c("use",
  "select"), initialX = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oes_+3A_y">y</code></td>
<td>
<p>Either numeric vector or time series vector.</p>
</td></tr>
<tr><td><code id="oes_+3A_model">model</code></td>
<td>
<p>The type of ETS model used for the estimation. Normally this should
be <code>"MNN"</code> or any other pure multiplicative or additive model. The model
selection is available here (although it's not fast), so you can use, for example,
<code>"YYN"</code> and <code>"XXN"</code> for selecting between the pure multiplicative and
pure additive models respectively. Using mixed models is possible, but not
recommended.</p>
</td></tr>
<tr><td><code id="oes_+3A_persistence">persistence</code></td>
<td>
<p>Persistence vector <code class="reqn">g</code>, containing smoothing
parameters. If <code>NULL</code>, then estimated.</p>
</td></tr>
<tr><td><code id="oes_+3A_initial">initial</code></td>
<td>
<p>Can be either character or a vector of initial states. If it
is character, then it can be <code>"optimal"</code>, meaning that the initial
states are optimised, or <code>"backcasting"</code>, meaning that the initials are
produced using backcasting procedure.</p>
</td></tr>
<tr><td><code id="oes_+3A_initialseason">initialSeason</code></td>
<td>
<p>The vector of the initial seasonal components. If <code>NULL</code>,
then it is estimated.</p>
</td></tr>
<tr><td><code id="oes_+3A_phi">phi</code></td>
<td>
<p>The value of the dampening parameter. Used only for damped-trend models.</p>
</td></tr>
<tr><td><code id="oes_+3A_occurrence">occurrence</code></td>
<td>
<p>The type of model used in probability estimation. Can be
<code>"none"</code> - none,
<code>"fixed"</code> - constant probability,
<code>"odds-ratio"</code> - the Odds-ratio model with b=1 in Beta distribution,
<code>"inverse-odds-ratio"</code> - the model with a=1 in Beta distribution,
<code>"direct"</code> - the TSB-like (Teunter et al., 2011) probability update
mechanism a+b=1,
<code>"auto"</code> - the automatically selected type of occurrence model,
<code>"general"</code> - the general Beta model with two parameters. This will call
<code>oesg()</code> function with two similar ETS models and the same provided
parameters (initials and smoothing).</p>
</td></tr>
<tr><td><code id="oes_+3A_ic">ic</code></td>
<td>
<p>The information criteria to use in case of model selection.</p>
</td></tr>
<tr><td><code id="oes_+3A_h">h</code></td>
<td>
<p>The forecast horizon.</p>
</td></tr>
<tr><td><code id="oes_+3A_holdout">holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td></tr>
<tr><td><code id="oes_+3A_bounds">bounds</code></td>
<td>
<p>What type of bounds to use in the model estimation. The first
letter can be used instead of the whole word.</p>
</td></tr>
<tr><td><code id="oes_+3A_silent">silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words (&quot;n&quot;,
&quot;a&quot;, &quot;g&quot;, &quot;l&quot;, &quot;o&quot;).</p>
</td></tr>
<tr><td><code id="oes_+3A_xreg">xreg</code></td>
<td>
<p>The vector (either numeric or time series) or the matrix (or
data.frame) of exogenous variables that should be included in the model. If
matrix included than columns should contain variables and rows - observations.
Note that <code>xreg</code> should have number of observations equal either to
in-sample or to the whole series. If the number of observations in
<code>xreg</code> is equal to in-sample, then values for the holdout sample are
produced using <a href="#topic+es">es</a> function.</p>
</td></tr>
<tr><td><code id="oes_+3A_regressors">regressors</code></td>
<td>
<p>The variable defines what to do with the provided xreg:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done.
<code>"combine"</code> will be available at some point in future...</p>
</td></tr>
<tr><td><code id="oes_+3A_initialx">initialX</code></td>
<td>
<p>The vector of initial parameters for exogenous variables.
Ignored if <code>xreg</code> is NULL.</p>
</td></tr>
<tr><td><code id="oes_+3A_...">...</code></td>
<td>
<p>The parameters passed to the optimiser, such as <code>maxeval</code>,
<code>xtol_rel</code>, <code>algorithm</code> and <code>print_level</code>. The description of
these is printed out by <code>nloptr.print.options()</code> function from the <code>nloptr</code>
package. The default values in the oes function are <code>maxeval=500</code>,
<code>xtol_rel=1E-8</code>, <code>algorithm="NLOPT_LN_NELDERMEAD"</code> and <code>print_level=0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates probability of demand occurrence, using the selected
ETS state space models.
</p>
<p>For the details about the model and its implementation, see the respective
vignette: <code>vignette("oes","smooth")</code>
</p>


<h3>Value</h3>

<p>The object of class &quot;occurrence&quot; is returned. It contains following list of
values:
</p>

<ul>
<li> <p><code>model</code> - the type of the estimated ETS model;
</p>
</li>
<li> <p><code>timeElapsed</code> - the time elapsed for the construction of the model;
</p>
</li>
<li> <p><code>fitted</code> - the fitted values for the probability;
</p>
</li>
<li> <p><code>fittedModel</code> - the fitted values of the underlying ETS model, where applicable
(only for occurrence=c(&quot;o&quot;,&quot;i&quot;,&quot;d&quot;));
</p>
</li>
<li> <p><code>forecast</code> - the forecast of the probability for <code>h</code> observations ahead;
</p>
</li>
<li> <p><code>forecastModel</code> - the forecast of the underlying ETS model, where applicable
(only for occurrence=c(&quot;o&quot;,&quot;i&quot;,&quot;d&quot;));
</p>
</li>
<li> <p><code>lower</code> - the lower bound of the interval if <code>interval!="none"</code>;
</p>
</li>
<li> <p><code>upper</code> - the upper bound of the interval if <code>interval!="none"</code>;
</p>
</li>
<li> <p><code>lowerModel</code> - the lower bound of the interval of the underlying ETS model
if <code>interval!="none"</code>;
</p>
</li>
<li> <p><code>upperModel</code> - the upper bound of the interval of the underlying ETS model
if <code>interval!="none"</code>;
</p>
</li>
<li> <p><code>states</code> - the values of the state vector;
</p>
</li>
<li> <p><code>logLik</code> - the log-likelihood value of the model;
</p>
</li>
<li> <p><code>nParam</code> - the number of parameters in the model (the matrix is returned);
</p>
</li>
<li> <p><code>residuals</code> - the residuals of the model;
</p>
</li>
<li> <p><code>y</code> - actual values of occurrence (zeros and ones).
</p>
</li>
<li> <p><code>persistence</code> - the vector of smoothing parameters;
</p>
</li>
<li> <p><code>phi</code> - the value of the damped trend parameter;
</p>
</li>
<li> <p><code>initial</code> - initial values of the state vector;
</p>
</li>
<li> <p><code>initialSeason</code> - the matrix of initials seasonal states;
</p>
</li>
<li> <p><code>occurrence</code> - the type of the occurrence model;
</p>
</li>
<li> <p><code>updateX</code> - boolean, defining, if the states of exogenous variables were
estimated as well.
</p>
</li>
<li> <p><code>initialX</code> - initial values for parameters of exogenous variables.
</p>
</li>
<li> <p><code>persistenceX</code> - persistence vector g for exogenous variables.
</p>
</li>
<li> <p><code>transitionX</code> - transition matrix F for exogenous variables.
</p>
</li>
<li> <p><code>accuracy</code> - The error measures for the forecast (in case of <code>holdout=TRUE</code>).
</p>
</li>
<li> <p><code>B</code> - the vector of all the estimated parameters (in case of &quot;odds-ratio&quot;,
&quot;inverse-odds-ratio&quot; and &quot;direct&quot; models).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov Ivan and Boylan John E. (2017). Multiplicative
State-Space Models for Intermittent Time Series. Working Paper of
Department of Management Science, Lancaster University, 2017:4 , 1-43.
</p>
</li>
<li><p> Teunter R., Syntetos A., Babai Z. (2011). Intermittent demand:
Linking forecasting to inventory obsolescence. European Journal of
Operational Research, 214, 606-615.
</p>
</li>
<li><p> Croston, J. (1972) Forecasting and stock control for intermittent
demands. Operational Research Quarterly, 23(3), 289-303.
</p>
</li>
<li><p> Syntetos, A., Boylan J. (2005) The accuracy of intermittent demand
estimates. International Journal of Forecasting, 21(2), 303-314.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+adam">adam</a>, <a href="#topic+oesg">oesg</a>, <a href="#topic+es">es</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rpois(100,0.1)
oes(y, occurrence="auto")

oes(y, occurrence="f")

</code></pre>

<hr>
<h2 id='oesg'>Occurrence ETS, general model</h2><span id='topic+oesg'></span>

<h3>Description</h3>

<p>Function returns the general occurrence model of the of iETS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oesg(y, modelA = "MNN", modelB = "MNN", persistenceA = NULL,
  persistenceB = NULL, phiA = NULL, phiB = NULL, initialA = "o",
  initialB = "o", initialSeasonA = NULL, initialSeasonB = NULL,
  ic = c("AICc", "AIC", "BIC", "BICc"), h = 10, holdout = FALSE,
  bounds = c("usual", "admissible", "none"), silent = c("all", "graph",
  "legend", "output", "none"), xregA = NULL, xregB = NULL,
  initialXA = NULL, initialXB = NULL, regressorsA = c("use", "select"),
  regressorsB = c("use", "select"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oesg_+3A_y">y</code></td>
<td>
<p>Either numeric vector or time series vector.</p>
</td></tr>
<tr><td><code id="oesg_+3A_modela">modelA</code></td>
<td>
<p>The type of the ETS for the model A.</p>
</td></tr>
<tr><td><code id="oesg_+3A_modelb">modelB</code></td>
<td>
<p>The type of the ETS for the model B.</p>
</td></tr>
<tr><td><code id="oesg_+3A_persistencea">persistenceA</code></td>
<td>
<p>The persistence vector <code class="reqn">g</code>, containing smoothing
parameters used in the model A. If <code>NULL</code>, then estimated.</p>
</td></tr>
<tr><td><code id="oesg_+3A_persistenceb">persistenceB</code></td>
<td>
<p>The persistence vector <code class="reqn">g</code>, containing smoothing
parameters used in the model B. If <code>NULL</code>, then estimated.</p>
</td></tr>
<tr><td><code id="oesg_+3A_phia">phiA</code></td>
<td>
<p>The value of the dampening parameter in the model A. Used only
for damped-trend models.</p>
</td></tr>
<tr><td><code id="oesg_+3A_phib">phiB</code></td>
<td>
<p>The value of the dampening parameter in the model B. Used only
for damped-trend models.</p>
</td></tr>
<tr><td><code id="oesg_+3A_initiala">initialA</code></td>
<td>
<p>Either <code>"o"</code> - optimal or the vector of initials for the
level and / or trend for the model A.</p>
</td></tr>
<tr><td><code id="oesg_+3A_initialb">initialB</code></td>
<td>
<p>Either <code>"o"</code> - optimal or the vector of initials for the
level and / or trend for the model B.</p>
</td></tr>
<tr><td><code id="oesg_+3A_initialseasona">initialSeasonA</code></td>
<td>
<p>The vector of the initial seasonal components for the
model A. If <code>NULL</code>, then it is estimated.</p>
</td></tr>
<tr><td><code id="oesg_+3A_initialseasonb">initialSeasonB</code></td>
<td>
<p>The vector of the initial seasonal components for the
model B. If <code>NULL</code>, then it is estimated.</p>
</td></tr>
<tr><td><code id="oesg_+3A_ic">ic</code></td>
<td>
<p>Information criteria to use in case of model selection.</p>
</td></tr>
<tr><td><code id="oesg_+3A_h">h</code></td>
<td>
<p>Forecast horizon.</p>
</td></tr>
<tr><td><code id="oesg_+3A_holdout">holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td></tr>
<tr><td><code id="oesg_+3A_bounds">bounds</code></td>
<td>
<p>What type of bounds to use in the model estimation. The first
letter can be used instead of the whole word.</p>
</td></tr>
<tr><td><code id="oesg_+3A_silent">silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words (&quot;n&quot;,
&quot;a&quot;, &quot;g&quot;, &quot;l&quot;, &quot;o&quot;).</p>
</td></tr>
<tr><td><code id="oesg_+3A_xrega">xregA</code></td>
<td>
<p>The vector or the matrix of exogenous variables, explaining some parts
of occurrence variable of the model A.</p>
</td></tr>
<tr><td><code id="oesg_+3A_xregb">xregB</code></td>
<td>
<p>The vector or the matrix of exogenous variables, explaining some parts
of occurrence variable of the model B.</p>
</td></tr>
<tr><td><code id="oesg_+3A_initialxa">initialXA</code></td>
<td>
<p>The vector of initial parameters for exogenous variables in the model
A. Ignored if <code>xregA</code> is NULL.</p>
</td></tr>
<tr><td><code id="oesg_+3A_initialxb">initialXB</code></td>
<td>
<p>The vector of initial parameters for exogenous variables in the model
B. Ignored if <code>xregB</code> is NULL.</p>
</td></tr>
<tr><td><code id="oesg_+3A_regressorsa">regressorsA</code></td>
<td>
<p>Variable defines what to do with the provided <code>xregA</code>:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done.</p>
</td></tr>
<tr><td><code id="oesg_+3A_regressorsb">regressorsB</code></td>
<td>
<p>Similar to the <code>regressorsA</code>, but for the part B of the model.</p>
</td></tr>
<tr><td><code id="oesg_+3A_...">...</code></td>
<td>
<p>The parameters passed to the optimiser, such as <code>maxeval</code>,
<code>xtol_rel</code>, <code>algorithm</code> and <code>print_level</code>. The description of
these is printed out by <code>nloptr.print.options()</code> function from the <code>nloptr</code>
package. The default values in the oes function are <code>maxeval=500</code>,
<code>xtol_rel=1E-8</code>, <code>algorithm="NLOPT_LN_NELDERMEAD"</code> and <code>print_level=0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates probability of demand occurrence, based on the iETS_G
state-space model. It involves the estimation and modelling of the two
simultaneous state space equations. Thus two parts for the model type,
persistence, initials etc.
</p>
<p>For the details about the model and its implementation, see the respective
vignette: <code>vignette("oes","smooth")</code>
</p>
<p>The model is based on:
</p>
<p style="text-align: center;"><code class="reqn">o_t \sim Bernoulli(p_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">p_t = \frac{a_t}{a_t+b_t}</code>
</p>
<p>,
</p>
<p>where a_t and b_t are the parameters of the Beta distribution and are modelled
using separate ETS models.
</p>


<h3>Value</h3>

<p>The object of class &quot;occurrence&quot; is returned. It contains following list of
values:
</p>

<ul>
<li> <p><code>modelA</code> - the model A of the class oes, that contains the output similar
to the one from the <code>oes()</code> function;
</p>
</li>
<li> <p><code>modelB</code> - the model B of the class oes, that contains the output similar
to the one from the <code>oes()</code> function.
</p>
</li>
<li> <p><code>B</code> - the vector of all the estimated parameters.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+es">es</a>, <a href="#topic+oes">oes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rpois(100,0.1)
oesg(y, modelA="MNN", modelB="ANN")

</code></pre>

<hr>
<h2 id='orders'>Functions that extract values from the fitted model</h2><span id='topic+orders'></span><span id='topic+lags'></span><span id='topic+modelName'></span><span id='topic+modelType'></span>

<h3>Description</h3>

<p>These functions allow extracting orders and lags for <code>ssarima()</code>, <code>gum()</code> and <code>sma()</code>,
type of model from <code>es()</code> and <code>ces()</code> and name of model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orders(object, ...)

lags(object, ...)

modelName(object, ...)

modelType(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orders_+3A_object">object</code></td>
<td>
<p>Model estimated using one of the functions of smooth package.</p>
</td></tr>
<tr><td><code id="orders_+3A_...">...</code></td>
<td>
<p>Currently nothing is accepted via ellipsis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>orders()</code> and <code>lags()</code> are useful only for SSARIMA, GUM and SMA. They return <code>NA</code> for other functions.
This can also be applied to <code>arima()</code>, <code>Arima()</code> and <code>auto.arima()</code> functions from stats and forecast packages.
<code>modelType()</code> is useful only for ETS and CES. They return <code>NA</code> for other functions.
This can also be applied to <code>ets()</code> function from forecast package. <code>errorType</code>
extracts the type of error from the model (either additive or multiplicative). Finally, <code>modelName</code>
returns the name of the fitted model. For example, &quot;ARIMA(0,1,1)&quot;. This is purely descriptive and
can also be applied to non-smooth classes, so that, for example, you can easily extract the name
of the fitted AR model from <code>ar()</code> function from <code>stats</code> package.
</p>


<h3>Value</h3>

<p>Either vector, scalar or list with values is returned.
<code>orders()</code> in case of ssarima returns list of values:
</p>

<ul>
<li> <p><code>ar</code> - AR orders.
</p>
</li>
<li> <p><code>i</code> - I orders.
</p>
</li>
<li> <p><code>ma</code> - MA orders.
</p>
</li></ul>

<p><code>lags()</code> returns the vector of lags of the model.
All the other functions return strings of character.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+ssarima">ssarima</a>, <a href="#topic+msarima">msarima</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(100,0,1)

# Just as example. orders and lags do not return anything for ces() and es(). But modelType() does.
ourModel &lt;- ces(x, h=10)
orders(ourModel)
lags(ourModel)
modelType(ourModel)
modelName(ourModel)

# And as another example it does the opposite for gum() and ssarima()
ourModel &lt;- gum(x, h=10, orders=c(1,1), lags=c(1,4))
orders(ourModel)
lags(ourModel)
modelType(ourModel)
modelName(ourModel)

# Finally these values can be used for simulate functions or original functions.
ourModel &lt;- auto.ssarima(x)
ssarima(x, orders=orders(ourModel), lags=lags(ourModel), constant=ourModel$constant)
sim.ssarima(orders=orders(ourModel), lags=lags(ourModel), constant=ourModel$constant)

ourModel &lt;- es(x)
es(x, model=modelType(ourModel))
sim.es(model=modelType(ourModel))

</code></pre>

<hr>
<h2 id='plot.adam'>Plots for the fit and states</h2><span id='topic+plot.adam'></span><span id='topic+plot.smooth'></span><span id='topic+plot.msdecompose'></span>

<h3>Description</h3>

<p>The function produces diagnostics plots for a <code>smooth</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adam'
plot(x, which = c(1, 2, 4, 6), level = 0.95,
  legend = FALSE, ask = prod(par("mfcol")) &lt; length(which) &amp;&amp;
  dev.interactive(), lowess = TRUE, ...)

## S3 method for class 'smooth'
plot(x, which = c(1, 2, 4, 6), level = 0.95,
  legend = FALSE, ask = prod(par("mfcol")) &lt; length(which) &amp;&amp;
  dev.interactive(), lowess = TRUE, ...)

## S3 method for class 'msdecompose'
plot(x, which = c(1, 2, 4, 6), level = 0.95,
  legend = FALSE, ask = prod(par("mfcol")) &lt; length(which) &amp;&amp;
  dev.interactive(), lowess = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.adam_+3A_x">x</code></td>
<td>
<p>Estimated smooth model.</p>
</td></tr>
<tr><td><code id="plot.adam_+3A_which">which</code></td>
<td>
<p>Which of the plots to produce. The possible options (see details for explanations):
</p>

<ol>
<li><p> Actuals vs Fitted values;
</p>
</li>
<li><p> Standardised residuals vs Fitted;
</p>
</li>
<li><p> Studentised residuals vs Fitted;
</p>
</li>
<li><p> Absolute residuals vs Fitted;
</p>
</li>
<li><p> Squared residuals vs Fitted;
</p>
</li>
<li><p> Q-Q plot with the specified distribution;
</p>
</li>
<li><p> Fitted over time;
</p>
</li>
<li><p> Standardised residuals vs Time;
</p>
</li>
<li><p> Studentised residuals vs Time;
</p>
</li>
<li><p> ACF of the residuals;
</p>
</li>
<li><p> PACF of the residuals;
</p>
</li>
<li><p> Plot of states of the model;
</p>
</li>
<li><p> Absolute standardised residuals vs Fitted;
</p>
</li>
<li><p> Squared standardised residuals vs Fitted;
</p>
</li>
<li><p> ACF of the squared residuals;
</p>
</li>
<li><p> PACF of the squared residuals.
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.adam_+3A_level">level</code></td>
<td>
<p>Confidence level. Defines width of confidence interval. Used in plots (2), (3), (7), (8),
(9), (10) and (11).</p>
</td></tr>
<tr><td><code id="plot.adam_+3A_legend">legend</code></td>
<td>
<p>If <code>TRUE</code>, then the legend is produced on plots (2), (3) and (7).</p>
</td></tr>
<tr><td><code id="plot.adam_+3A_ask">ask</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the user is asked to press Enter before each plot.</p>
</td></tr>
<tr><td><code id="plot.adam_+3A_lowess">lowess</code></td>
<td>
<p>Logical; if <code>TRUE</code>, LOWESS lines are drawn on scatterplots, see <a href="stats.html#topic+lowess">lowess</a>.</p>
</td></tr>
<tr><td><code id="plot.adam_+3A_...">...</code></td>
<td>
<p>The parameters passed to the plot functions. Recommended to use with separate plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of produced plots includes:
</p>

<ol>
<li><p> Actuals vs Fitted values. Allows analysing, whether there are any issues in the fit.
Does the variability of actuals increase with the increase of fitted values? Is the relation
well captured? They grey line on the plot corresponds to the perfect fit of the model.
</p>
</li>
<li><p> Standardised residuals vs Fitted. Plots the points and the confidence bounds
(red lines) for the specified confidence <code>level</code>. Useful for the analysis of outliers;
</p>
</li>
<li><p> Studentised residuals vs Fitted. This is similar to the previous plot, but with the
residuals divided by the scales with the leave-one-out approach. Should be more sensitive
to outliers;
</p>
</li>
<li><p> Absolute residuals vs Fitted. Useful for the analysis of heteroscedasticity;
</p>
</li>
<li><p> Squared residuals vs Fitted - similar to (3), but with squared values;
</p>
</li>
<li><p> Q-Q plot with the specified distribution. Can be used in order to see if the
residuals follow the assumed distribution. The type of distribution depends on the one used
in the estimation (see <code>distribution</code> parameter in <a href="greybox.html#topic+alm">alm</a>);
</p>
</li>
<li><p> ACF of the residuals. Are the residuals autocorrelated? See <a href="stats.html#topic+acf">acf</a> for
details;
</p>
</li>
<li><p> Fitted over time. Plots actuals (black line), fitted values (purple line), point forecast
(blue line) and prediction interval (grey lines). Can be used in order to make sure that the model
did not miss any important events over time;
</p>
</li>
<li><p> Standardised residuals vs Time. Useful if you want to see, if there is autocorrelation or
if there is heteroscedasticity in time. This also shows, when the outliers happen;
</p>
</li>
<li><p> Studentised residuals vs Time. Similar to previous, but with studentised residuals;
</p>
</li>
<li><p> PACF of the residuals. No, really, are they autocorrelated? See pacf function from stats
package for details;
</p>
</li>
<li><p> Plot of the states of the model. It is not recommended to produce this plot together with
the others, because there might be several states, which would cause the creation of a different
canvas. In case of &quot;msdecompose&quot;, this will produce the decomposition of the series into states
on a different canvas;
</p>
</li>
<li><p> Absolute standardised residuals vs Fitted. Similar to the previous, but with absolute
values. This is more relevant to the models where scale is calculated as an absolute value of
something (e.g. Laplace);
</p>
</li>
<li><p> Squared standardised residuals vs Fitted. This is an additional plot needed to diagnose
heteroscedasticity in a model with varying scale. The variance on this plot will be constant if
the adequate model for <code>scale</code> was constructed. This is more appropriate for normal and
the related distributions.
</p>
</li></ol>

<p>Which of the plots to produce, is specified via the <code>which</code> parameter.
</p>


<h3>Value</h3>

<p>The function produces the number of plots, specified in the parameter <code>which</code>.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>See Also</h3>

<p><a href="greybox.html#topic+plot.greybox">plot.greybox</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ourModel &lt;- es(c(rnorm(50,100,10),rnorm(50,120,10)), "ANN", h=10)
par(mfcol=c(3,4))
plot(ourModel, c(1:11))
plot(ourModel, 12)

</code></pre>

<hr>
<h2 id='pls'>Prediction Likelihood Score</h2><span id='topic+pls'></span><span id='topic+pls.smooth'></span>

<h3>Description</h3>

<p>Function estimates Prediction Likelihood Score for the provided model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pls(object, holdout = NULL, ...)

## S3 method for class 'smooth'
pls(object, holdout = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pls_+3A_object">object</code></td>
<td>
<p>The model estimated using smooth functions. This thing also accepts
other models (e.g. estimated using functions from forecast package), but may not always
work properly with them.</p>
</td></tr>
<tr><td><code id="pls_+3A_holdout">holdout</code></td>
<td>
<p>The values for the holdout part of the sample. If the model was fitted
on the data with the <code>holdout=TRUE</code>, then the parameter is not needed.</p>
</td></tr>
<tr><td><code id="pls_+3A_...">...</code></td>
<td>
<p>Parameters passed to multicov function. The function is called in order to get
the covariance matrix of 1 to h steps ahead forecast errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prediction likelihood score (PLS) is based on either normal or log-normal
distribution of errors. This is extracted from the provided model. The likelihood
based on the distribution of 1 to h steps ahead forecast errors is used in the process.
</p>


<h3>Value</h3>

<p>A value of the log-likelihood.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<p>distribution. IEEE Signal Processing Letters. 13 (5): 300-303.
<a href="https://doi.org/10.1109/LSP.2006.870353">doi:10.1109/LSP.2006.870353</a> - this is not yet used in the function.
</p>
<ul>
<li><p> Snyder, R. D., Ord, J. K., Beaumont, A., 2012. Forecasting the intermittent
demand for slow-moving inventories: A modelling approach. International
Journal of Forecasting 28 (2), 485-496.
</p>
</li>
<li><p> Kolassa, S., 2016. Evaluating predictive count data distributions in retail
sales forecasting. International Journal of Forecasting 32 (3), 788-803..
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Generate data, apply es() with the holdout parameter and calculate PLS
x &lt;- rnorm(100,0,1)
ourModel &lt;- es(x, h=10, holdout=TRUE)
pls(ourModel, type="a")
pls(ourModel, type="e")
pls(ourModel, type="s", obs=100, nsim=100)

</code></pre>

<hr>
<h2 id='reapply'>Reapply the model with randomly generated initial parameters and produce forecasts</h2><span id='topic+reapply'></span><span id='topic+reforecast'></span>

<h3>Description</h3>

<p><code>reapply</code> function generates the parameters based on the values in the provided
object and then reapplies the same model with those parameters to the data, getting
the fitted paths and updated states. <code>reforecast</code> function uses those values
in order to produce forecasts for the <code>h</code> steps ahead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reapply(object, nsim = 1000, bootstrap = FALSE, heuristics = NULL, ...)

reforecast(object, h = 10, newdata = NULL, occurrence = NULL,
  interval = c("prediction", "confidence", "none"), level = 0.95,
  side = c("both", "upper", "lower"), cumulative = FALSE, nsim = 100,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reapply_+3A_object">object</code></td>
<td>
<p>Model estimated using one of the functions of smooth package.</p>
</td></tr>
<tr><td><code id="reapply_+3A_nsim">nsim</code></td>
<td>
<p>Number of paths to generate (number of simulations to do).</p>
</td></tr>
<tr><td><code id="reapply_+3A_bootstrap">bootstrap</code></td>
<td>
<p>The logical, which determines, whether to use bootstrap for the
covariance matrix of parameters or not.</p>
</td></tr>
<tr><td><code id="reapply_+3A_heuristics">heuristics</code></td>
<td>
<p>The value for proportion to use for heuristic estimation of the
standard deviation of parameters. If <code>NULL</code>, it is not used.</p>
</td></tr>
<tr><td><code id="reapply_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>reapply()</code> and <code>mean()</code> functions in case of
<code>reforecast</code> (<code>trim</code> parameter in <code>mean()</code> is set to
0.01 by default) and to <code>vcov</code> in case of <code>reapply</code>.</p>
</td></tr>
<tr><td><code id="reapply_+3A_h">h</code></td>
<td>
<p>Forecast horizon.</p>
</td></tr>
<tr><td><code id="reapply_+3A_newdata">newdata</code></td>
<td>
<p>The new data needed in order to produce forecasts.</p>
</td></tr>
<tr><td><code id="reapply_+3A_occurrence">occurrence</code></td>
<td>
<p>The vector containing the future occurrence variable
(values in [0,1]), if it is known.</p>
</td></tr>
<tr><td><code id="reapply_+3A_interval">interval</code></td>
<td>
<p>What type of mechanism to use for interval construction. The options
include <code>interval="none"</code>, <code>interval="prediction"</code> (prediction intervals)
and <code>interval="confidence"</code> (intervals for the point forecast). The other options
are not supported and do not make much sense for the refitted model.</p>
</td></tr>
<tr><td><code id="reapply_+3A_level">level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td></tr>
<tr><td><code id="reapply_+3A_side">side</code></td>
<td>
<p>Defines, whether to provide <code>"both"</code> sides of prediction
interval or only <code>"upper"</code>, or <code>"lower"</code>.</p>
</td></tr>
<tr><td><code id="reapply_+3A_cumulative">cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main motivation of the function is to take the randomness due to the in-sample
estimation of parameters into account when fitting the model and to propagate
this randomness to the forecasts. The methods can be considered as a special case
of recursive bootstrap.
</p>


<h3>Value</h3>

<p><code>reapply()</code> returns object of the class &quot;reapply&quot;, which contains:
</p>

<ul>
<li> <p><code>timeElapsed</code> - Time elapsed for the code execution;
</p>
</li>
<li> <p><code>y</code> - The actual values;
</p>
</li>
<li> <p><code>states</code> - The array of states of the model;
</p>
</li>
<li> <p><code>refitted</code> - The matrix with fitted values, where columns correspond
to different paths;
</p>
</li>
<li> <p><code>fitted</code> - The vector of fitted values (conditional mean);
</p>
</li>
<li> <p><code>model</code> - The name of the constructed model;
</p>
</li>
<li> <p><code>transition</code> - The array of transition matrices;
</p>
</li>
<li> <p><code>measurement</code> - The array of measurement matrices;
</p>
</li>
<li> <p><code>persistence</code> - The matrix of persistence vectors (paths in columns);
</p>
</li>
<li> <p><code>profile</code> - The array of profiles obtained by the end of each fit.
</p>
</li></ul>

<p><code>reforecast()</code> returns the object of the class <a href="#topic+forecast.smooth">forecast.smooth</a>,
which contains in addition to the standard list the variable <code>paths</code> - all
simulated trajectories with h in rows, simulated future paths for each state in
columns and different states (obtained from <code>reapply()</code> function) in the
third dimension.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+forecast.smooth">forecast.smooth</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(100,0,1)

# Just as example. orders and lags do not return anything for ces() and es(). But modelType() does.
ourModel &lt;- adam(x, "ANN")
refittedModel &lt;- reapply(ourModel, nsim=50)
plot(refittedModel)

ourForecast &lt;- reforecast(ourModel, nsim=50)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+xtable'></span><span id='topic+accuracy'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+accuracy">accuracy</a></code></p>
</dd>
<dt>xtable</dt><dd><p><code><a href="xtable.html#topic+xtable">xtable</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rmultistep'>Multiple steps ahead forecast errors</h2><span id='topic+rmultistep'></span>

<h3>Description</h3>

<p>The function extracts 1 to h steps ahead forecast errors from the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmultistep(object, h = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmultistep_+3A_object">object</code></td>
<td>
<p>Model estimated using one of the forecasting functions.</p>
</td></tr>
<tr><td><code id="rmultistep_+3A_h">h</code></td>
<td>
<p>The forecasting horizon to use.</p>
</td></tr>
<tr><td><code id="rmultistep_+3A_...">...</code></td>
<td>
<p>Currently nothing is accepted via ellipsis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The errors correspond to the error term epsilon_t in the ETS models. Don't forget
that different models make different assumptions about epsilon_t and / or 1+epsilon_t.
</p>


<h3>Value</h3>

<p>The matrix with observations in rows and h steps ahead values in columns.
So, the first row corresponds to the forecast produced from the 0th observation
from 1 to h steps ahead.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+residuals">residuals</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(100,0,1)
ourModel &lt;- adam(x)
rmultistep(ourModel, h=13)

</code></pre>

<hr>
<h2 id='sim.ces'>Simulate Complex Exponential Smoothing</h2><span id='topic+sim.ces'></span>

<h3>Description</h3>

<p>Function generates data using CES with Single Source of Error as a data
generating process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.ces(seasonality = c("none", "simple", "partial", "full"), obs = 10,
  nsim = 1, frequency = 1, a = NULL, b = NULL, initial = NULL,
  randomizer = c("rnorm", "rt", "rlaplace", "rs"), probability = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.ces_+3A_seasonality">seasonality</code></td>
<td>
<p>The type of seasonality used in CES. Can be: <code>none</code>
- No seasonality; <code>simple</code> - Simple seasonality, using lagged CES
(based on <code>t-m</code> observation, where <code>m</code> is the seasonality lag);
<code>partial</code> - Partial seasonality with real seasonal components
(equivalent to additive seasonality); <code>full</code> - Full seasonality with
complex seasonal components (can do both multiplicative and additive
seasonality, depending on the data). First letter can be used instead of
full words.  Any seasonal CES can only be constructed for time series
vectors.</p>
</td></tr>
<tr><td><code id="sim.ces_+3A_obs">obs</code></td>
<td>
<p>Number of observations in each generated time series.</p>
</td></tr>
<tr><td><code id="sim.ces_+3A_nsim">nsim</code></td>
<td>
<p>Number of series to generate (number of simulations to do).</p>
</td></tr>
<tr><td><code id="sim.ces_+3A_frequency">frequency</code></td>
<td>
<p>Frequency of generated data. In cases of seasonal models
must be greater than 1.</p>
</td></tr>
<tr><td><code id="sim.ces_+3A_a">a</code></td>
<td>
<p>First complex smoothing parameter. Should be a complex number.
</p>
<p>NOTE! CES is very sensitive to a and b values so it is advised to use values
from previously estimated model.</p>
</td></tr>
<tr><td><code id="sim.ces_+3A_b">b</code></td>
<td>
<p>Second complex smoothing parameter. Can be real if
<code>seasonality="partial"</code>. In case of <code>seasonality="full"</code> must be
complex number.</p>
</td></tr>
<tr><td><code id="sim.ces_+3A_initial">initial</code></td>
<td>
<p>A matrix with initial values for CES. In case with
<code>seasonality="partial"</code> and <code>seasonality="full"</code> first two columns
should contain initial values for non-seasonal components, repeated
<code>frequency</code> times.</p>
</td></tr>
<tr><td><code id="sim.ces_+3A_randomizer">randomizer</code></td>
<td>
<p>Type of random number generator function used for error
term. Defaults are: <code>rnorm</code>, <code>rt</code>, <code>rlaplace</code> and <code>rs</code>.
<code>rlnorm</code> should be used for multiplicative models (e.g. ETS(M,N,N)).
But any function from <a href="stats.html#topic+Distributions">Distributions</a> will do the trick if the
appropriate parameters are passed. For example <code>rpois</code> with
<code>lambda=2</code> can be used as well, but might result in weird values.</p>
</td></tr>
<tr><td><code id="sim.ces_+3A_probability">probability</code></td>
<td>
<p>Probability of occurrence, used for intermittent data
generation. This can be a vector, implying that probability varies in time
(in TSB or Croston style).</p>
</td></tr>
<tr><td><code id="sim.ces_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the chosen randomizer. All the
parameters should be passed in the order they are used in chosen randomizer.
For example, passing just <code>sd=0.5</code> to <code>rnorm</code> function will lead
to the call <code>rnorm(obs, mean=0.5, sd=1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the information about the function, see the vignette:
<code>vignette("simulate","smooth")</code>
</p>


<h3>Value</h3>

<p>List of the following values is returned:
</p>

<ul>
<li> <p><code>model</code> - Name of CES model.
</p>
</li>
<li> <p><code>a</code> - Value of complex smoothing parameter a. If <code>nsim&gt;1</code>, then
this is a vector.
</p>
</li>
<li> <p><code>b</code> - Value of complex smoothing parameter b. If <code>seasonality="n"</code>
or <code>seasonality="s"</code>, then this is equal to NULL. If <code>nsim&gt;1</code>,
then this is a vector.
</p>
</li>
<li> <p><code>initial</code> - Initial values of CES in a form of matrix. If <code>nsim&gt;1</code>,
then this is an array.
</p>
</li>
<li> <p><code>data</code> - Time series vector (or matrix if <code>nsim&gt;1</code>) of the generated
series.
</p>
</li>
<li> <p><code>states</code> - Matrix (or array if <code>nsim&gt;1</code>) of states. States are in
columns, time is in rows.
</p>
</li>
<li> <p><code>residuals</code> - Error terms used in the simulation. Either vector or matrix,
depending on <code>nsim</code>.
</p>
</li>
<li> <p><code>occurrence</code> - Values of occurrence variable. Once again, can be either
a vector or a matrix...
</p>
</li>
<li> <p><code>logLik</code> - Log-likelihood of the constructed model.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov, I., Kourentzes, N. (February 2015). Complex exponential
smoothing. Working Paper of Department of Management Science, Lancaster
University 2015:1, 1-31.
</p>
</li>
<li><p> Svetunkov I., Kourentzes N. (2017) Complex Exponential Smoothing
for Time Series Forecasting. Not yet published.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+sim.es">sim.es</a>, <a href="#topic+sim.ssarima">sim.ssarima</a>,
<a href="#topic+ces">ces</a>, <a href="stats.html#topic+Distributions">Distributions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create 120 observations from CES(n). Generate 100 time series of this kind.
x &lt;- sim.ces("n",obs=120,nsim=100)

# Generate similar thing for seasonal series of CES(s)_4
x &lt;- sim.ces("s",frequency=4,obs=80,nsim=100)

# Estimate model and then generate 10 time series from it
ourModel &lt;- ces(rnorm(100,100,5))
simulate(ourModel,nsim=10)

</code></pre>

<hr>
<h2 id='sim.es'>Simulate Exponential Smoothing</h2><span id='topic+sim.es'></span>

<h3>Description</h3>

<p>Function generates data using ETS with Single Source of Error as a data
generating process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.es(model = "ANN", obs = 10, nsim = 1, frequency = 1,
  persistence = NULL, phi = 1, initial = NULL, initialSeason = NULL,
  bounds = c("usual", "admissible", "restricted"), randomizer = c("rnorm",
  "rlnorm", "rt", "rlaplace", "rs"), probability = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.es_+3A_model">model</code></td>
<td>
<p>Type of ETS model according to [Hyndman et. al., 2008]
taxonomy. Can consist of 3 or 4 chars: <code>ANN</code>, <code>AAN</code>, <code>AAdN</code>,
<code>AAA</code>, <code>AAdA</code>, <code>MAdM</code> etc.</p>
</td></tr>
<tr><td><code id="sim.es_+3A_obs">obs</code></td>
<td>
<p>Number of observations in each generated time series.</p>
</td></tr>
<tr><td><code id="sim.es_+3A_nsim">nsim</code></td>
<td>
<p>Number of series to generate (number of simulations to do).</p>
</td></tr>
<tr><td><code id="sim.es_+3A_frequency">frequency</code></td>
<td>
<p>Frequency of generated data. In cases of seasonal models
must be greater than 1.</p>
</td></tr>
<tr><td><code id="sim.es_+3A_persistence">persistence</code></td>
<td>
<p>Persistence vector, which includes all the smoothing
parameters. Must correspond to the chosen model. The maximum length is 3:
level, trend and seasonal smoothing parameters. If <code>NULL</code>, values are
generated.</p>
</td></tr>
<tr><td><code id="sim.es_+3A_phi">phi</code></td>
<td>
<p>Value of damping parameter. If trend is not chosen in the model,
the parameter is ignored.</p>
</td></tr>
<tr><td><code id="sim.es_+3A_initial">initial</code></td>
<td>
<p>Vector of initial states of level and trend. The maximum
length is 2. If <code>NULL</code>, values are generated.</p>
</td></tr>
<tr><td><code id="sim.es_+3A_initialseason">initialSeason</code></td>
<td>
<p>Vector of initial states for seasonal coefficients.
Should have length equal to <code>frequency</code> parameter. If <code>NULL</code>,
values are generated.</p>
</td></tr>
<tr><td><code id="sim.es_+3A_bounds">bounds</code></td>
<td>
<p>Type of bounds to use for persistence vector if values are
generated. <code>"usual"</code> - bounds from p.156 by Hyndman et. al., 2008.
<code>"restricted"</code> - similar to <code>"usual"</code> but with upper bound equal
to 0.3. <code>"admissible"</code> - bounds from tables 10.1 and 10.2 of Hyndman
et. al., 2008. Using first letter of the type of bounds also works. These
bounds are also used for multiplicative models, but the models are much
more restrictive, so weird results might be obtained. Be careful!</p>
</td></tr>
<tr><td><code id="sim.es_+3A_randomizer">randomizer</code></td>
<td>
<p>Type of random number generator function used for error
term. Defaults are: <code>rnorm</code>, <code>rt</code>, <code>rlaplace</code> and <code>rs</code>.
<code>rlnorm</code> should be used for multiplicative models (e.g. ETS(M,N,N)).
But any function from <a href="stats.html#topic+Distributions">Distributions</a> will do the trick if the
appropriate parameters are passed. For example <code>rpois</code> with
<code>lambda=2</code> can be used as well, but might result in weird values.</p>
</td></tr>
<tr><td><code id="sim.es_+3A_probability">probability</code></td>
<td>
<p>Probability of occurrence, used for intermittent data
generation. This can be a vector, implying that probability varies in time
(in TSB or Croston style).</p>
</td></tr>
<tr><td><code id="sim.es_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the chosen randomizer. All the
parameters should be passed in the order they are used in chosen randomizer.
For example, passing just <code>sd=0.5</code> to <code>rnorm</code> function will lead
to the call <code>rnorm(obs, mean=0.5, sd=1)</code>.  ATTENTION! When generating
the multiplicative errors some tuning might be needed to obtain meaningful
data. <code>sd=0.1</code> is usually already a high value for such models. ALSO
NOTE: In case of multiplicative error model, the randomizer will generate
<code>1+e_t</code> error, not <code>e_t</code>. This means that the mean should
typically be equal to 1, not zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the information about the function, see the vignette:
<code>vignette("simulate","smooth")</code>
</p>


<h3>Value</h3>

<p>List of the following values is returned:
</p>

<ul>
<li> <p><code>model</code> - Name of ETS model.
</p>
</li>
<li> <p><code>data</code> - Time series vector (or matrix if <code>nsim&gt;1</code>) of the generated
series.
</p>
</li>
<li> <p><code>states</code> - Matrix (or array if <code>nsim&gt;1</code>) of states. States are in
columns, time is in rows.
</p>
</li>
<li> <p><code>persistence</code> - Vector (or matrix if <code>nsim&gt;1</code>) of smoothing
parameters used in the simulation.
</p>
</li>
<li> <p><code>phi</code> - Value of damping parameter used in time series generation.
</p>
</li>
<li> <p><code>initial</code> - Vector (or matrix) of initial values.
</p>
</li>
<li> <p><code>initialSeason</code> - Vector (or matrix) of initial seasonal coefficients.
</p>
</li>
<li> <p><code>probability</code> - vector of probabilities used in the simulation.
</p>
</li>
<li> <p><code>intermittent</code> - type of the intermittent model used.
</p>
</li>
<li> <p><code>residuals</code> - Error terms used in the simulation. Either vector or matrix,
depending on <code>nsim</code>.
</p>
</li>
<li> <p><code>occurrence</code> - Values of occurrence variable. Once again, can be either
a vector or a matrix...
</p>
</li>
<li> <p><code>logLik</code> - Log-likelihood of the constructed model.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Snyder, R. D., 1985. Recursive Estimation of Dynamic Linear Models.
Journal of the Royal Statistical Society, Series B (Methodological) 47 (2), 272-276.
</p>
</li>
<li><p> Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+es">es</a>, <a href="stats.html#topic+ts">ts</a>, <a href="stats.html#topic+Distributions">Distributions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create 40 observations of quarterly data using AAA model with errors from normal distribution
ETSAAA &lt;- sim.es(model="AAA",frequency=4,obs=40,randomizer="rnorm",mean=0,sd=100)

# Create 50 series of quarterly data using AAA model
# with 40 observations each with errors from normal distribution
ETSAAA &lt;- sim.es(model="AAA",frequency=4,obs=40,randomizer="rnorm",mean=0,sd=100,nsim=50)

# Create 50 series of quarterly data using AAdA model
# with 40 observations each with errors from normal distribution
# and smoothing parameters lying in the "admissible" range.
ETSAAA &lt;- sim.es(model="AAA",phi=0.9,frequency=4,obs=40,bounds="admissible",
                  randomizer="rnorm",mean=0,sd=100,nsim=50)

# Create 60 observations of monthly data using ANN model
# with errors from beta distribution
ETSANN &lt;- sim.es(model="ANN",persistence=c(1.5),frequency=12,obs=60,
                  randomizer="rbeta",shape1=1.5,shape2=1.5)
plot(ETSANN$states)

# Create 60 observations of monthly data using MAM model
# with errors from uniform distribution
ETSMAM &lt;- sim.es(model="MAM",persistence=c(0.3,0.2,0.1),initial=c(2000,50),
           phi=0.8,frequency=12,obs=60,randomizer="runif",min=-0.5,max=0.5)

# Create 80 observations of quarterly data using MMM model
# with predefined initial values and errors from the normal distribution
ETSMMM &lt;- sim.es(model="MMM",persistence=c(0.1,0.1,0.1),initial=c(2000,1),
           initialSeason=c(1.1,1.05,0.9,.95),frequency=4,obs=80,mean=0,sd=0.01)

# Generate intermittent data using AAdN
iETSAAdN &lt;- sim.es("AAdN",obs=30,frequency=1,probability=0.1,initial=c(3,0),phi=0.8)

# Generate iETS(MNN) with TSB style probabilities
oETSMNN &lt;- sim.oes("MNN",obs=50,occurrence="d",persistence=0.2,initial=1,
                   randomizer="rlnorm",meanlog=0,sdlog=0.3)
iETSMNN &lt;- sim.es("MNN",obs=50,frequency=12,persistence=0.2,initial=4,
                  probability=oETSMNN$probability)

</code></pre>

<hr>
<h2 id='sim.gum'>Simulate Generalised Exponential Smoothing</h2><span id='topic+sim.gum'></span>

<h3>Description</h3>

<p>Function generates data using GUM with Single Source of Error as a data
generating process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.gum(orders = c(1), lags = c(1), obs = 10, nsim = 1,
  frequency = 1, measurement = NULL, transition = NULL,
  persistence = NULL, initial = NULL, randomizer = c("rnorm", "rt",
  "rlaplace", "rs"), probability = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.gum_+3A_orders">orders</code></td>
<td>
<p>Order of the model. Specified as vector of number of states
with different lags. For example, <code>orders=c(1,1)</code> means that there are
two states: one of the first lag type, the second of the second type.</p>
</td></tr>
<tr><td><code id="sim.gum_+3A_lags">lags</code></td>
<td>
<p>Defines lags for the corresponding orders. If, for example,
<code>orders=c(1,1)</code> and lags are defined as <code>lags=c(1,12)</code>, then the
model will have two states: the first will have lag 1 and the second will
have lag 12. The length of <code>lags</code> must correspond to the length of
<code>orders</code>.</p>
</td></tr>
<tr><td><code id="sim.gum_+3A_obs">obs</code></td>
<td>
<p>Number of observations in each generated time series.</p>
</td></tr>
<tr><td><code id="sim.gum_+3A_nsim">nsim</code></td>
<td>
<p>Number of series to generate (number of simulations to do).</p>
</td></tr>
<tr><td><code id="sim.gum_+3A_frequency">frequency</code></td>
<td>
<p>Frequency of generated data. In cases of seasonal models
must be greater than 1.</p>
</td></tr>
<tr><td><code id="sim.gum_+3A_measurement">measurement</code></td>
<td>
<p>Measurement vector <code class="reqn">w</code>. If <code>NULL</code>, then
estimated.</p>
</td></tr>
<tr><td><code id="sim.gum_+3A_transition">transition</code></td>
<td>
<p>Transition matrix <code class="reqn">F</code>. Can be provided as a vector.
Matrix will be formed using the default <code>matrix(transition,nc,nc)</code>,
where <code>nc</code> is the number of components in state vector. If <code>NULL</code>,
then estimated.</p>
</td></tr>
<tr><td><code id="sim.gum_+3A_persistence">persistence</code></td>
<td>
<p>Persistence vector <code class="reqn">g</code>, containing smoothing
parameters. If <code>NULL</code>, then estimated.</p>
</td></tr>
<tr><td><code id="sim.gum_+3A_initial">initial</code></td>
<td>
<p>Vector of initial values for state matrix. If <code>NULL</code>,
then generated using advanced, sophisticated technique - uniform
distribution.</p>
</td></tr>
<tr><td><code id="sim.gum_+3A_randomizer">randomizer</code></td>
<td>
<p>Type of random number generator function used for error
term. Defaults are: <code>rnorm</code>, <code>rt</code>, <code>rlaplace</code> and <code>rs</code>.
<code>rlnorm</code> should be used for multiplicative models (e.g. ETS(M,N,N)).
But any function from <a href="stats.html#topic+Distributions">Distributions</a> will do the trick if the
appropriate parameters are passed. For example <code>rpois</code> with
<code>lambda=2</code> can be used as well, but might result in weird values.</p>
</td></tr>
<tr><td><code id="sim.gum_+3A_probability">probability</code></td>
<td>
<p>Probability of occurrence, used for intermittent data
generation. This can be a vector, implying that probability varies in time
(in TSB or Croston style).</p>
</td></tr>
<tr><td><code id="sim.gum_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the chosen randomizer. All the
parameters should be passed in the order they are used in chosen randomizer.
For example, passing just <code>sd=0.5</code> to <code>rnorm</code> function will lead
to the call <code>rnorm(obs, mean=0.5, sd=1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the information about the function, see the vignette:
<code>vignette("simulate","smooth")</code>
</p>


<h3>Value</h3>

<p>List of the following values is returned:
</p>

<ul>
<li> <p><code>model</code> - Name of GUM model.
</p>
</li>
<li> <p><code>measurement</code> - Matrix w.
</p>
</li>
<li> <p><code>transition</code> - Matrix F.
</p>
</li>
<li> <p><code>persistence</code> - Persistence vector. This is the place, where
smoothing parameters live.
</p>
</li>
<li> <p><code>initial</code> - Initial values of GUM in a form of matrix. If <code>nsim&gt;1</code>,
then this is an array.
</p>
</li>
<li> <p><code>data</code> - Time series vector (or matrix if <code>nsim&gt;1</code>) of the generated
series.
</p>
</li>
<li> <p><code>states</code> - Matrix (or array if <code>nsim&gt;1</code>) of states. States are in
columns, time is in rows.
</p>
</li>
<li> <p><code>residuals</code> - Error terms used in the simulation. Either vector or matrix,
depending on <code>nsim</code>.
</p>
</li>
<li> <p><code>occurrence</code> - Values of occurrence variable. Once again, can be either
a vector or a matrix...
</p>
</li>
<li> <p><code>logLik</code> - Log-likelihood of the constructed model.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov I. (2023) Smooth forecasting with the smooth package in R. arXiv:2301.01790.
<a href="https://doi.org/10.48550/arXiv.2301.01790">doi:10.48550/arXiv.2301.01790</a>.
</p>
</li>
<li><p> Svetunkov I. (2015 - Inf) &quot;smooth&quot; package for R - series of posts about the underlying
models and how to use them: <a href="https://openforecast.org/category/r-en/smooth/">https://openforecast.org/category/r-en/smooth/</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+sim.es">sim.es</a>, <a href="#topic+sim.ssarima">sim.ssarima</a>,
<a href="#topic+sim.ces">sim.ces</a>, <a href="#topic+gum">gum</a>, <a href="stats.html#topic+Distributions">Distributions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create 120 observations from GUM(1[1]). Generate 100 time series of this kind.
x &lt;- sim.gum(orders=c(1),lags=c(1),obs=120,nsim=100)

# Generate similar thing for seasonal series of GUM(1[1],1[4]])
x &lt;- sim.gum(orders=c(1,1),lags=c(1,4),frequency=4,obs=80,nsim=100,transition=c(1,0,0.9,0.9))

# Estimate model and then generate 10 time series from it
ourModel &lt;- gum(rnorm(100,100,5))
simulate(ourModel,nsim=10)

</code></pre>

<hr>
<h2 id='sim.oes'>Simulate Occurrence Part of ETS model</h2><span id='topic+sim.oes'></span>

<h3>Description</h3>

<p>Function generates data using ETS with Single Source of Error as a data
generating process for the demand occurrence. As the main output it produces
probabilities of occurrence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.oes(model = "MNN", obs = 10, nsim = 1, frequency = 1,
  occurrence = c("odds-ratio", "inverse-odds-ratio", "direct", "general"),
  bounds = c("usual", "admissible", "restricted"), randomizer = c("rlnorm",
  "rinvgauss", "rgamma", "rnorm"), persistence = NULL, phi = 1,
  initial = NULL, initialSeason = NULL, modelB = model,
  persistenceB = persistence, phiB = phi, initialB = initial,
  initialSeasonB = initialSeason, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.oes_+3A_model">model</code></td>
<td>
<p>Type of ETS model according to [Hyndman et. al., 2008]
taxonomy. Can consist of 3 or 4 chars: <code>ANN</code>, <code>AAN</code>, <code>AAdN</code>,
<code>AAA</code>, <code>AAdA</code>, <code>MAdM</code> etc. The conventional oETS model assumes
that the error term is positive, so &quot;MZZ&quot; models are recommended for this.
If you use additive error models, then the function will exponentiate the
obtained values before transforming them and getting the probability. This
is the type of model A.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_obs">obs</code></td>
<td>
<p>Number of observations in each generated time series.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_nsim">nsim</code></td>
<td>
<p>Number of series to generate (number of simulations to do).</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_frequency">frequency</code></td>
<td>
<p>Frequency of generated data. In cases of seasonal models
must be greater than 1.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_occurrence">occurrence</code></td>
<td>
<p>Type of occurrence model. See <code>vignette("oes","smooth")</code>
for details.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_bounds">bounds</code></td>
<td>
<p>Type of bounds to use for persistence vector if values are
generated. <code>"usual"</code> - bounds from p.156 by Hyndman et. al., 2008.
<code>"restricted"</code> - similar to <code>"usual"</code> but with upper bound equal
to 0.3. <code>"admissible"</code> - bounds from tables 10.1 and 10.2 of Hyndman
et. al., 2008. Using first letter of the type of bounds also works. These
bounds are also used for multiplicative models, but the models are much
more restrictive, so weird results might be obtained. Be careful!</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_randomizer">randomizer</code></td>
<td>
<p>Type of random number generator function used for error
term. It is advised to use <code>rlnorm()</code> or <code>rinvgauss()</code> in case of
multiplicative error models. If a randomiser is used, it is advised to
specify the parameters in the ellipsis.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_persistence">persistence</code></td>
<td>
<p>Persistence vector, which includes all the smoothing
parameters. Must correspond to the chosen model. The maximum length is 3:
level, trend and seasonal smoothing parameters. If <code>NULL</code>, values are
generated.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_phi">phi</code></td>
<td>
<p>Value of damping parameter. If trend is not chosen in the model,
the parameter is ignored.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_initial">initial</code></td>
<td>
<p>Vector of initial states of level and trend. The maximum
length is 2. If <code>NULL</code>, values are generated.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_initialseason">initialSeason</code></td>
<td>
<p>Vector of initial states for seasonal coefficients.
Should have length equal to <code>frequency</code> parameter. If <code>NULL</code>,
values are generated.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_modelb">modelB</code></td>
<td>
<p>Type of model B. This is used in <code>occurrence="general"</code>
and <code>occurrence="inverse-odds-ratio"</code>.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_persistenceb">persistenceB</code></td>
<td>
<p>The persistence vector for the model B.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_phib">phiB</code></td>
<td>
<p>Value of damping parameter for the model B.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_initialb">initialB</code></td>
<td>
<p>Vector of initial states of level and trend for the model B.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_initialseasonb">initialSeasonB</code></td>
<td>
<p>Vector of initial states for seasonal coefficients for
the model B.</p>
</td></tr>
<tr><td><code id="sim.oes_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the chosen randomizer. All the
parameters should be passed in the order they are used in chosen randomizer.
Both model A and model B share the same parameters for the randomizer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the information about the function, see the vignette:
<code>vignette("simulate","smooth")</code>
</p>


<h3>Value</h3>

<p>List of the following values is returned:
</p>

<ul>
<li> <p><code>model</code> - Name of ETS model.
</p>
</li>
<li> <p><code>modelA</code> - Model A, generated using <code>sim.es()</code> function;
</p>
</li>
<li> <p><code>modelB</code> - Model B, generated using <code>sim.es()</code> function;
</p>
</li>
<li> <p><code>probability</code> - The value of probability generated by the model;
</p>
</li>
<li> <p><code>occurrence</code> - Type of occurrence used in the model;
</p>
</li>
<li> <p><code>logLik</code> - Log-likelihood of the constructed model.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Snyder, R. D., 1985. Recursive Estimation of Dynamic Linear Models.
Journal of the Royal Statistical Society, Series B (Methodological) 47 (2), 272-276.
</p>
</li>
<li><p> Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+oes">oes</a>, <a href="#topic+sim.es">sim.es</a>, <a href="stats.html#topic+Distributions">Distributions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example uses rinvgauss function from statmod package.
oETSMNNIG &lt;- sim.oes(model="MNN",frequency=12,obs=60,
                               randomizer="rinvgauss",mean=1,dispersion=0.5)

# A simpler example with log normal distribution
oETSMNNlogN &lt;- sim.oes(model="MNN",frequency=12,obs=60,initial=1,
                       randomizer="rlnorm",meanlog=0,sdlog=0.1)

</code></pre>

<hr>
<h2 id='sim.sma'>Simulate Simple Moving Average</h2><span id='topic+sim.sma'></span>

<h3>Description</h3>

<p>Function generates data using SMA in a Single Source of Error state space
model as a data generating process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.sma(order = NULL, obs = 10, nsim = 1, frequency = 1,
  initial = NULL, randomizer = c("rnorm", "rt", "rlaplace", "rs"),
  probability = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.sma_+3A_order">order</code></td>
<td>
<p>Order of the modelled series. If omitted, then a random order from 1 to 100 is selected.</p>
</td></tr>
<tr><td><code id="sim.sma_+3A_obs">obs</code></td>
<td>
<p>Number of observations in each generated time series.</p>
</td></tr>
<tr><td><code id="sim.sma_+3A_nsim">nsim</code></td>
<td>
<p>Number of series to generate (number of simulations to do).</p>
</td></tr>
<tr><td><code id="sim.sma_+3A_frequency">frequency</code></td>
<td>
<p>Frequency of generated data. In cases of seasonal models
must be greater than 1.</p>
</td></tr>
<tr><td><code id="sim.sma_+3A_initial">initial</code></td>
<td>
<p>Vector of initial states for the model. If <code>NULL</code>,
values are generated.</p>
</td></tr>
<tr><td><code id="sim.sma_+3A_randomizer">randomizer</code></td>
<td>
<p>Type of random number generator function used for error
term. Defaults are: <code>rnorm</code>, <code>rt</code>, <code>rlaplace</code> and <code>rs</code>.
<code>rlnorm</code> should be used for multiplicative models (e.g. ETS(M,N,N)).
But any function from <a href="stats.html#topic+Distributions">Distributions</a> will do the trick if the
appropriate parameters are passed. For example <code>rpois</code> with
<code>lambda=2</code> can be used as well, but might result in weird values.</p>
</td></tr>
<tr><td><code id="sim.sma_+3A_probability">probability</code></td>
<td>
<p>Probability of occurrence, used for intermittent data
generation. This can be a vector, implying that probability varies in time
(in TSB or Croston style).</p>
</td></tr>
<tr><td><code id="sim.sma_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the chosen randomizer. All the
parameters should be passed in the order they are used in chosen randomizer.
For example, passing just <code>sd=0.5</code> to <code>rnorm</code> function will lead
to the call <code>rnorm(obs, mean=0.5, sd=1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the information about the function, see the vignette:
<code>vignette("simulate","smooth")</code>
</p>


<h3>Value</h3>

<p>List of the following values is returned:
</p>

<ul>
<li> <p><code>model</code> - Name of SMA model.
</p>
</li>
<li> <p><code>data</code> - Time series vector (or matrix if <code>nsim&gt;1</code>) of the generated
series.
</p>
</li>
<li> <p><code>states</code> - Matrix (or array if <code>nsim&gt;1</code>) of states. States are in
columns, time is in rows.
</p>
</li>
<li> <p><code>initial</code> - Vector (or matrix) of initial values.
</p>
</li>
<li> <p><code>probability</code> - vector of probabilities used in the simulation.
</p>
</li>
<li> <p><code>intermittent</code> - type of the intermittent model used.
</p>
</li>
<li> <p><code>residuals</code> - Error terms used in the simulation. Either vector or matrix,
depending on <code>nsim</code>.
</p>
</li>
<li> <p><code>occurrence</code> - Values of occurrence variable. Once again, can be either
a vector or a matrix...
</p>
</li>
<li> <p><code>logLik</code> - Log-likelihood of the constructed model.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Snyder, R. D., 1985. Recursive Estimation of Dynamic Linear Models.
Journal of the Royal Statistical Society, Series B (Methodological) 47 (2), 272-276.
</p>
</li>
<li><p> Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+es">es</a>, <a href="stats.html#topic+ts">ts</a>, <a href="stats.html#topic+Distributions">Distributions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create 40 observations of quarterly data using AAA model with errors from normal distribution
sma10 &lt;- sim.sma(order=10,frequency=4,obs=40,randomizer="rnorm",mean=0,sd=100)

</code></pre>

<hr>
<h2 id='sim.ssarima'>Simulate SSARIMA</h2><span id='topic+sim.ssarima'></span>

<h3>Description</h3>

<p>Function generates data using SSARIMA with Single Source of Error as a data
generating process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.ssarima(orders = list(ar = 0, i = 1, ma = 1), lags = 1, obs = 10,
  nsim = 1, frequency = 1, AR = NULL, MA = NULL, constant = FALSE,
  initial = NULL, bounds = c("admissible", "none"),
  randomizer = c("rnorm", "rt", "rlaplace", "rs"), probability = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.ssarima_+3A_orders">orders</code></td>
<td>
<p>List of orders, containing vector variables <code>ar</code>,
<code>i</code> and <code>ma</code>. Example:
<code>orders=list(ar=c(1,2),i=c(1),ma=c(1,1,1))</code>. If a variable is not
provided in the list, then it is assumed to be equal to zero. At least one
variable should have the same length as <code>lags</code>.</p>
</td></tr>
<tr><td><code id="sim.ssarima_+3A_lags">lags</code></td>
<td>
<p>Defines lags for the corresponding orders (see examples above).
The length of <code>lags</code> must correspond to the length of <code>orders</code>.
There is no restrictions on the length of <code>lags</code> vector.
It is recommended to order <code>lags</code> ascending.</p>
</td></tr>
<tr><td><code id="sim.ssarima_+3A_obs">obs</code></td>
<td>
<p>Number of observations in each generated time series.</p>
</td></tr>
<tr><td><code id="sim.ssarima_+3A_nsim">nsim</code></td>
<td>
<p>Number of series to generate (number of simulations to do).</p>
</td></tr>
<tr><td><code id="sim.ssarima_+3A_frequency">frequency</code></td>
<td>
<p>Frequency of generated data. In cases of seasonal models
must be greater than 1.</p>
</td></tr>
<tr><td><code id="sim.ssarima_+3A_ar">AR</code></td>
<td>
<p>Vector or matrix of AR parameters. The order of parameters should
be lag-wise. This means that first all the AR parameters of the firs lag
should be passed, then for the second etc. AR of another ssarima can be
passed here.</p>
</td></tr>
<tr><td><code id="sim.ssarima_+3A_ma">MA</code></td>
<td>
<p>Vector or matrix of MA parameters. The order of parameters should
be lag-wise. This means that first all the MA parameters of the firs lag
should be passed, then for the second etc. MA of another ssarima can be
passed here.</p>
</td></tr>
<tr><td><code id="sim.ssarima_+3A_constant">constant</code></td>
<td>
<p>If <code>TRUE</code>, constant term is included in the model. Can
also be a number (constant value).</p>
</td></tr>
<tr><td><code id="sim.ssarima_+3A_initial">initial</code></td>
<td>
<p>Vector of initial values for state matrix. If <code>NULL</code>,
then generated using advanced, sophisticated technique - uniform
distribution.</p>
</td></tr>
<tr><td><code id="sim.ssarima_+3A_bounds">bounds</code></td>
<td>
<p>Type of bounds to use for AR and MA if values are generated.
<code>"admissible"</code> - bounds guaranteeing stability and stationarity of
SSARIMA. <code>"none"</code> - we generate something, but do not guarantee
stationarity and stability. Using first letter of the type of bounds also
works.</p>
</td></tr>
<tr><td><code id="sim.ssarima_+3A_randomizer">randomizer</code></td>
<td>
<p>Type of random number generator function used for error
term. Defaults are: <code>rnorm</code>, <code>rt</code>, <code>rlaplace</code> and <code>rs</code>.
<code>rlnorm</code> should be used for multiplicative models (e.g. ETS(M,N,N)).
But any function from <a href="stats.html#topic+Distributions">Distributions</a> will do the trick if the
appropriate parameters are passed. For example <code>rpois</code> with
<code>lambda=2</code> can be used as well, but might result in weird values.</p>
</td></tr>
<tr><td><code id="sim.ssarima_+3A_probability">probability</code></td>
<td>
<p>Probability of occurrence, used for intermittent data
generation. This can be a vector, implying that probability varies in time
(in TSB or Croston style).</p>
</td></tr>
<tr><td><code id="sim.ssarima_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the chosen randomizer. All the
parameters should be passed in the order they are used in chosen randomizer.
For example, passing just <code>sd=0.5</code> to <code>rnorm</code> function will lead
to the call <code>rnorm(obs, mean=0.5, sd=1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the information about the function, see the vignette:
<code>vignette("simulate","smooth")</code>
</p>


<h3>Value</h3>

<p>List of the following values is returned:
</p>

<ul>
<li> <p><code>model</code> - Name of SSARIMA model.
</p>
</li>
<li> <p><code>AR</code> - Value of AR parameters. If <code>nsim&gt;1</code>, then this is a
matrix.
</p>
</li>
<li> <p><code>MA</code> - Value of MA parameters. If <code>nsim&gt;1</code>, then this is a
matrix.
</p>
</li>
<li> <p><code>constant</code> - Value of constant term. If <code>nsim&gt;1</code>, then this
is a vector.
</p>
</li>
<li> <p><code>initial</code> - Initial values of SSARIMA. If <code>nsim&gt;1</code>, then this
is a matrix.
</p>
</li>
<li> <p><code>data</code> - Time series vector (or matrix if <code>nsim&gt;1</code>) of the
generated series.
</p>
</li>
<li> <p><code>states</code> - Matrix (or array if <code>nsim&gt;1</code>) of states. States
are in columns, time is in rows.
</p>
</li>
<li> <p><code>residuals</code> - Error terms used in the simulation. Either vector or
matrix, depending on <code>nsim</code>.
</p>
</li>
<li> <p><code>occurrence</code> - Values of occurrence variable. Once again, can be
either a vector or a matrix...
</p>
</li>
<li> <p><code>logLik</code> - Log-likelihood of the constructed model.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Snyder, R. D., 1985. Recursive Estimation of Dynamic Linear Models.
Journal of the Royal Statistical Society, Series B (Methodological) 47 (2), 272-276.
</p>
</li>
<li><p> Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>.
</p>
</li></ul>


<ul>
<li><p> Svetunkov, I., &amp; Boylan, J. E. (2019). State-space ARIMA for supply-chain forecasting.
International Journal of Production Research, 0(0), 110.
<a href="https://doi.org/10.1080/00207543.2019.1600764">doi:10.1080/00207543.2019.1600764</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+sim.es">sim.es</a>, <a href="#topic+ssarima">ssarima</a>,
<a href="stats.html#topic+Distributions">Distributions</a>, <a href="#topic+orders">orders</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create 120 observations from ARIMA(1,1,1) with drift. Generate 100 time series of this kind.
x &lt;- sim.ssarima(ar.orders=1,i.orders=1,ma.orders=1,obs=120,nsim=100,constant=TRUE)

# Generate similar thing for seasonal series of SARIMA(1,1,1)(0,0,2)_4
x &lt;- sim.ssarima(ar.orders=c(1,0),i.orders=c(1,0),ma.orders=c(1,2),lags=c(1,4),
                 frequency=4,obs=80,nsim=100,constant=FALSE)

# Generate 10 series of high frequency data from SARIMA(1,0,2)_1(0,1,1)_7(1,0,1)_30
x &lt;- sim.ssarima(ar.orders=c(1,0,1),i.orders=c(0,1,0),ma.orders=c(2,1,1),lags=c(1,7,30),
                 obs=360,nsim=10)


</code></pre>

<hr>
<h2 id='sma'>Simple Moving Average</h2><span id='topic+sma'></span><span id='topic+sma_old'></span>

<h3>Description</h3>

<p>Function constructs state space simple moving average of predefined order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sma(y, order = NULL, ic = c("AICc", "AIC", "BIC", "BICc"), h = 10,
  holdout = FALSE, silent = TRUE, fast = TRUE, ...)

sma_old(y, order = NULL, ic = c("AICc", "AIC", "BIC", "BICc"), h = 10,
  holdout = FALSE, cumulative = FALSE, interval = c("none", "parametric",
  "likelihood", "semiparametric", "nonparametric"), level = 0.95,
  silent = c("all", "graph", "legend", "output", "none"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sma_+3A_y">y</code></td>
<td>
<p>Vector or ts object, containing data needed to be forecasted.</p>
</td></tr>
<tr><td><code id="sma_+3A_order">order</code></td>
<td>
<p>Order of simple moving average. If <code>NULL</code>, then it is
selected automatically using information criteria.</p>
</td></tr>
<tr><td><code id="sma_+3A_ic">ic</code></td>
<td>
<p>The information criterion used in the model selection procedure.</p>
</td></tr>
<tr><td><code id="sma_+3A_h">h</code></td>
<td>
<p>Length of forecasting horizon.</p>
</td></tr>
<tr><td><code id="sma_+3A_holdout">holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td></tr>
<tr><td><code id="sma_+3A_silent">silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words (&quot;n&quot;,
&quot;a&quot;, &quot;g&quot;, &quot;l&quot;, &quot;o&quot;).</p>
</td></tr>
<tr><td><code id="sma_+3A_fast">fast</code></td>
<td>
<p>if <code>TRUE</code>, then the modified Ternary search is used to
find the optimal order of the model. This does not guarantee the optimal
solution, but gives a reasonable one (local minimum).</p>
</td></tr>
<tr><td><code id="sma_+3A_...">...</code></td>
<td>
<p>Other non-documented parameters.  For example parameter
<code>model</code> can accept a previously estimated SMA model and use its
parameters.</p>
</td></tr>
<tr><td><code id="sma_+3A_cumulative">cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td></tr>
<tr><td><code id="sma_+3A_interval">interval</code></td>
<td>
<p>Type of interval to construct. This can be:
</p>

<ul>
<li> <p><code>"none"</code>, aka <code>"n"</code> - do not produce prediction
interval.
</p>
</li>
<li> <p><code>"parametric"</code>, <code>"p"</code> - use state-space structure of ETS. In
case of mixed models this is done using simulations, which may take longer
time than for the pure additive and pure multiplicative models. This type
of interval relies on unbiased estimate of in-sample error variance, which
divides the sume of squared errors by T-k rather than just T.
</p>
</li>
<li> <p><code>"likelihood"</code>, <code>"l"</code> - these are the same as <code>"p"</code>, but
relies on the biased estimate of variance from the likelihood (division by
T, not by T-k).
</p>
</li>
<li> <p><code>"semiparametric"</code>, <code>"sp"</code> - interval based on covariance
matrix of 1 to h steps ahead errors and assumption of normal / log-normal
distribution (depending on error type).
</p>
</li>
<li> <p><code>"nonparametric"</code>, <code>"np"</code> - interval based on values from a
quantile regression on error matrix (see Taylor and Bunn, 1999). The model
used in this process is e[j] = a j^b, where j=1,..,h.
</p>
</li></ul>

<p>The parameter also accepts <code>TRUE</code> and <code>FALSE</code>. The former means that
parametric interval are constructed, while the latter is equivalent to
<code>none</code>.
If the forecasts of the models were combined, then the interval are combined
quantile-wise (Lichtendahl et al., 2013).</p>
</td></tr>
<tr><td><code id="sma_+3A_level">level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function constructs AR model in the Single Source of Error state space form
based on the idea that:
</p>
<p><code class="reqn">y_{t} = \frac{1}{n} \sum_{j=1}^n y_{t-j}</code>
</p>
<p>which is AR(n) process, that can be modelled using:
</p>
<p><code class="reqn">y_{t} = w' v_{t-1} + \epsilon_{t}</code>
</p>
<p><code class="reqn">v_{t} = F v_{t-1} + g \epsilon_{t}</code>
</p>
<p>Where <code class="reqn">v_{t}</code> is a state vector.
</p>
<p>For some more information about the model and its implementation, see the
vignette: <code>vignette("sma","smooth")</code>
</p>


<h3>Value</h3>

<p>Object of class &quot;smooth&quot; is returned. It contains the list of the
following values:
</p>

<ul>
<li> <p><code>model</code> - the name of the estimated model.
</p>
</li>
<li> <p><code>timeElapsed</code> - time elapsed for the construction of the model.
</p>
</li>
<li> <p><code>states</code> - the matrix of the fuzzy components of ssarima, where
<code>rows</code> correspond to time and <code>cols</code> to states.
</p>
</li>
<li> <p><code>transition</code> - matrix F.
</p>
</li>
<li> <p><code>persistence</code> - the persistence vector. This is the place, where
smoothing parameters live.
</p>
</li>
<li> <p><code>measurement</code> - measurement vector of the model.
</p>
</li>
<li> <p><code>order</code> - order of moving average.
</p>
</li>
<li> <p><code>initial</code> - Initial state vector values.
</p>
</li>
<li> <p><code>initialType</code> - Type of initial values used.
</p>
</li>
<li> <p><code>nParam</code> - table with the number of estimated / provided parameters.
If a previous model was reused, then its initials are reused and the number of
provided parameters will take this into account.
</p>
</li>
<li> <p><code>fitted</code> - the fitted values.
</p>
</li>
<li> <p><code>forecast</code> - the point forecast.
</p>
</li>
<li> <p><code>lower</code> - the lower bound of prediction interval. When
<code>interval=FALSE</code> then NA is returned.
</p>
</li>
<li> <p><code>upper</code> - the higher bound of prediction interval. When
<code>interval=FALSE</code> then NA is returned.
</p>
</li>
<li> <p><code>residuals</code> - the residuals of the estimated model.
</p>
</li>
<li> <p><code>errors</code> - The matrix of 1 to h steps ahead errors. Only returned when the
multistep losses are used and semiparametric interval is needed.
</p>
</li>
<li> <p><code>s2</code> - variance of the residuals (taking degrees of freedom into
account).
</p>
</li>
<li> <p><code>interval</code> - type of interval asked by user.
</p>
</li>
<li> <p><code>level</code> - confidence level for interval.
</p>
</li>
<li> <p><code>cumulative</code> - whether the produced forecast was cumulative or not.
</p>
</li>
<li> <p><code>y</code> - the original data.
</p>
</li>
<li> <p><code>holdout</code> - the holdout part of the original data.
</p>
</li>
<li> <p><code>ICs</code> - values of information criteria of the model. Includes AIC,
AICc, BIC and BICc.
</p>
</li>
<li> <p><code>logLik</code> - log-likelihood of the function.
</p>
</li>
<li> <p><code>lossValue</code> - Cost function value.
</p>
</li>
<li> <p><code>loss</code> - Type of loss function used in the estimation.
</p>
</li>
<li> <p><code>accuracy</code> - vector of accuracy measures for the
holdout sample. Includes: MPE, MAPE, SMAPE, MASE, sMAE, RelMAE, sMSE and
Bias coefficient (based on complex numbers). This is available only when
<code>holdout=TRUE</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov I. (2023) Smooth forecasting with the smooth package in R. arXiv:2301.01790.
<a href="https://doi.org/10.48550/arXiv.2301.01790">doi:10.48550/arXiv.2301.01790</a>.
</p>
</li>
<li><p> Svetunkov I. (2015 - Inf) &quot;smooth&quot; package for R - series of posts about the underlying
models and how to use them: <a href="https://openforecast.org/category/r-en/smooth/">https://openforecast.org/category/r-en/smooth/</a>.
</p>
</li></ul>


<ul>
<li><p> Svetunkov, I., &amp; Petropoulos, F. (2017). Old dog, new tricks: a
modelling view of simple moving averages. International Journal of
Production Research, 7543(January), 1-14.
<a href="https://doi.org/10.1080/00207543.2017.1380326">doi:10.1080/00207543.2017.1380326</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+filter">filter</a>, <a href="#topic+adam">adam</a>, <a href="#topic+msarima">msarima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# SMA of specific order
ourModel &lt;- sma(rnorm(118,100,3), order=12, h=18, holdout=TRUE)

# SMA of arbitrary order
ourModel &lt;- sma(rnorm(118,100,3), h=18, holdout=TRUE)

plot(forecast(ourModel, h=18, interval="empirical"))

</code></pre>

<hr>
<h2 id='smoothCombine'>Combination of forecasts of state space models</h2><span id='topic+smoothCombine'></span>

<h3>Description</h3>

<p>Function constructs ETS, SSARIMA, CES, GUM and SMA and combines their
forecasts using IC weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothCombine(y, models = NULL, initial = c("optimal", "backcasting"),
  ic = c("AICc", "AIC", "BIC", "BICc"), loss = c("MSE", "MAE", "HAM",
  "MSEh", "TMSE", "GTMSE", "MSCE"), h = 10, holdout = FALSE,
  cumulative = FALSE, interval = c("none", "parametric", "likelihood",
  "semiparametric", "nonparametric"), level = 0.95, bins = 200,
  intervalCombine = c("quantile", "probability"), bounds = c("admissible",
  "none"), silent = c("all", "graph", "legend", "output", "none"),
  xreg = NULL, regressors = c("use", "select"), initialX = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothCombine_+3A_y">y</code></td>
<td>
<p>Vector or ts object, containing data needed to be forecasted.</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_models">models</code></td>
<td>
<p>List of the estimated smooth models to use in the
combination. If <code>NULL</code>, then all the models are estimated
in the function.</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_initial">initial</code></td>
<td>
<p>Can be <code>"optimal"</code>, meaning that the initial
states are optimised, or <code>"backcasting"</code>, meaning that the
initials are produced using backcasting procedure.</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_ic">ic</code></td>
<td>
<p>The information criterion used in the model selection procedure.</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization. <code>loss</code> can
be: <code>likelihood</code> (assuming Normal distribution of error term),
<code>MSE</code> (Mean Squared Error), <code>MAE</code> (Mean Absolute Error),
<code>HAM</code> (Half Absolute Moment), <code>TMSE</code> - Trace Mean Squared Error,
<code>GTMSE</code> - Geometric Trace Mean Squared Error, <code>MSEh</code> - optimisation
using only h-steps ahead error, <code>MSCE</code> - Mean Squared Cumulative Error.
If <code>loss!="MSE"</code>, then likelihood and model selection is done based
on equivalent <code>MSE</code>. Model selection in this cases becomes not optimal.
</p>
<p>There are also available analytical approximations for multistep functions:
<code>aMSEh</code>, <code>aTMSE</code> and <code>aGTMSE</code>. These can be useful in cases
of small samples.
</p>
<p>Finally, just for fun the absolute and half analogues of multistep estimators
are available: <code>MAEh</code>, <code>TMAE</code>, <code>GTMAE</code>, <code>MACE</code>, <code>TMAE</code>,
<code>HAMh</code>, <code>THAM</code>, <code>GTHAM</code>, <code>CHAM</code>.</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_h">h</code></td>
<td>
<p>Length of forecasting horizon.</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_holdout">holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_cumulative">cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_interval">interval</code></td>
<td>
<p>Type of interval to construct. This can be:
</p>

<ul>
<li> <p><code>"none"</code>, aka <code>"n"</code> - do not produce prediction
interval.
</p>
</li>
<li> <p><code>"parametric"</code>, <code>"p"</code> - use state-space structure of ETS. In
case of mixed models this is done using simulations, which may take longer
time than for the pure additive and pure multiplicative models. This type
of interval relies on unbiased estimate of in-sample error variance, which
divides the sume of squared errors by T-k rather than just T.
</p>
</li>
<li> <p><code>"likelihood"</code>, <code>"l"</code> - these are the same as <code>"p"</code>, but
relies on the biased estimate of variance from the likelihood (division by
T, not by T-k).
</p>
</li>
<li> <p><code>"semiparametric"</code>, <code>"sp"</code> - interval based on covariance
matrix of 1 to h steps ahead errors and assumption of normal / log-normal
distribution (depending on error type).
</p>
</li>
<li> <p><code>"nonparametric"</code>, <code>"np"</code> - interval based on values from a
quantile regression on error matrix (see Taylor and Bunn, 1999). The model
used in this process is e[j] = a j^b, where j=1,..,h.
</p>
</li></ul>

<p>The parameter also accepts <code>TRUE</code> and <code>FALSE</code>. The former means that
parametric interval are constructed, while the latter is equivalent to
<code>none</code>.
If the forecasts of the models were combined, then the interval are combined
quantile-wise (Lichtendahl et al., 2013).</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_level">level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_bins">bins</code></td>
<td>
<p>The number of bins for the prediction interval.
The lower value means faster work of the function, but less
precise estimates of the quantiles. This needs to be an even
number.</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_intervalcombine">intervalCombine</code></td>
<td>
<p>How to average the prediction interval:
quantile-wise (<code>"quantile"</code>) or probability-wise
(<code>"probability"</code>).</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_bounds">bounds</code></td>
<td>
<p>What type of bounds to use in the model estimation. The first
letter can be used instead of the whole word.</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_silent">silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words (&quot;n&quot;,
&quot;a&quot;, &quot;g&quot;, &quot;l&quot;, &quot;o&quot;).</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_xreg">xreg</code></td>
<td>
<p>The vector (either numeric or time series) or the matrix (or
data.frame) of exogenous variables that should be included in the model. If
matrix included than columns should contain variables and rows - observations.
Note that <code>xreg</code> should have number of observations equal either to
in-sample or to the whole series. If the number of observations in
<code>xreg</code> is equal to in-sample, then values for the holdout sample are
produced using <a href="#topic+es">es</a> function.</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_regressors">regressors</code></td>
<td>
<p>The variable defines what to do with the provided xreg:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done.
<code>"combine"</code> will be available at some point in future...</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_initialx">initialX</code></td>
<td>
<p>The vector of initial parameters for exogenous variables.
Ignored if <code>xreg</code> is NULL.</p>
</td></tr>
<tr><td><code id="smoothCombine_+3A_...">...</code></td>
<td>
<p>This currently determines nothing.
</p>

<ul>
<li> <p><code>timeElapsed</code> - time elapsed for the construction of the model.
</p>
</li>
<li> <p><code>initialType</code> - type of the initial values used.
</p>
</li>
<li> <p><code>fitted</code> - fitted values of ETS.
</p>
</li>
<li> <p><code>quantiles</code> - the 3D array of produced quantiles if <code>interval!="none"</code>
with the dimensions: (number of models) x (bins) x (h).
</p>
</li>
<li> <p><code>forecast</code> - point forecast of ETS.
</p>
</li>
<li> <p><code>lower</code> - lower bound of prediction interval. When <code>interval="none"</code>
then NA is returned.
</p>
</li>
<li> <p><code>upper</code> - higher bound of prediction interval. When <code>interval="none"</code>
then NA is returned.
</p>
</li>
<li> <p><code>residuals</code> - residuals of the estimated model.
</p>
</li>
<li> <p><code>s2</code> - variance of the residuals (taking degrees of freedom into account).
</p>
</li>
<li> <p><code>interval</code> - type of interval asked by user.
</p>
</li>
<li> <p><code>level</code> - confidence level for interval.
</p>
</li>
<li> <p><code>cumulative</code> - whether the produced forecast was cumulative or not.
</p>
</li>
<li> <p><code>y</code> - original data.
</p>
</li>
<li> <p><code>holdout</code> - holdout part of the original data.
</p>
</li>
<li> <p><code>xreg</code> - provided vector or matrix of exogenous variables. If <code>regressors="s"</code>,
then this value will contain only selected exogenous variables.
</p>
</li>
<li> <p><code>ICs</code> - values of information criteria of the model. Includes AIC, AICc, BIC and BICc.
</p>
</li>
<li> <p><code>accuracy</code> - vector of accuracy measures for the holdout sample. In
case of non-intermittent data includes: MPE, MAPE, SMAPE, MASE, sMAE,
RelMAE, sMSE and Bias coefficient (based on complex numbers). In case of
intermittent data the set of errors will be: sMSE, sPIS, sCE (scaled
cumulative error) and Bias coefficient.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The combination of these models using information criteria weights is
possible because they are all formulated in Single Source of Error
framework. Due to the the complexity of some of the models, the
estimation process may take some time. So be patient.
</p>
<p>The prediction interval are combined either probability-wise or
quantile-wise (Lichtendahl et al., 2013), which may take extra time,
because we need to produce all the distributions for all the models.
This can be sped up with the smaller value for bins parameter, but
the resulting interval may be imprecise.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Snyder, R. D., 1985. Recursive Estimation of Dynamic Linear Models.
Journal of the Royal Statistical Society, Series B (Methodological) 47 (2), 272-276.
</p>
</li>
<li><p> Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>.
</p>
</li></ul>


<ul>
<li><p> Kolassa, S. (2011) Combining exponential smoothing forecasts using Akaike
weights. International Journal of Forecasting, 27, pp 238 - 251.
</p>
</li></ul>


<ul>
<li><p> Taylor, J.W. and Bunn, D.W. (1999) A Quantile Regression Approach to
Generating Prediction Intervals. Management Science, Vol 45, No 2, pp
225-237.
</p>
</li>
<li><p> Lichtendahl Kenneth C., Jr., Grushka-Cockayne Yael, Winkler
Robert L., (2013) Is It Better to Average Probabilities or
Quantiles? Management Science 59(7):1594-1611. DOI:
<a href="https://doi.org/10.1287/mnsc.1120.1667">doi:10.1287/mnsc.1120.1667</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+es">es</a>, <a href="#topic+auto.ssarima">auto.ssarima</a>,
<a href="#topic+auto.ces">auto.ces</a>, <a href="#topic+auto.gum">auto.gum</a>, <a href="#topic+sma">sma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: ourModel &lt;- smoothCombine(BJsales,interval="p")
plot(ourModel)
## End(Not run)

# models parameter accepts either previously estimated smoothCombine
# or a manually formed list of smooth models estimated in sample:
## Not run: smoothCombine(BJsales,models=ourModel)

## Not run: models &lt;- list(es(BJsales), sma(BJsales))
smoothCombine(BJsales,models=models)
## End(Not run)

</code></pre>

<hr>
<h2 id='sowhat'>Function returns the ultimate answer to any question</h2><span id='topic+sowhat'></span>

<h3>Description</h3>

<p>You need description? So what?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sowhat(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sowhat_+3A_...">...</code></td>
<td>
<p>Any number of variables or string with a question.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You need details? So what?
</p>


<h3>Value</h3>

<p>It doesn't return any value, only messages. So what?
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://en.wiktionary.org/wiki/so_what">Sowhat?</a>
</p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=FJfFZqTlWrQ">Sowhat?</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Douglas_Adams">42</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Nowwhat (to be implemented),
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(10000,0,1);
sowhat(x);

sowhat("What's the meaning of life?")

sowhat("I don't have a girlfriend.")

</code></pre>

<hr>
<h2 id='ssarima'>State Space ARIMA</h2><span id='topic+ssarima'></span>

<h3>Description</h3>

<p>Function constructs State Space ARIMA, estimating AR, MA terms and initial
states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssarima(y, orders = list(ar = c(0), i = c(1), ma = c(1)), lags = c(1),
  constant = FALSE, AR = NULL, MA = NULL, initial = c("backcasting",
  "optimal"), ic = c("AICc", "AIC", "BIC", "BICc"), loss = c("likelihood",
  "MSE", "MAE", "HAM", "MSEh", "TMSE", "GTMSE", "MSCE"), h = 10,
  holdout = FALSE, cumulative = FALSE, interval = c("none", "parametric",
  "likelihood", "semiparametric", "nonparametric"), level = 0.95,
  bounds = c("admissible", "none"), silent = c("all", "graph", "legend",
  "output", "none"), xreg = NULL, regressors = c("use", "select"),
  initialX = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssarima_+3A_y">y</code></td>
<td>
<p>Vector or ts object, containing data needed to be forecasted.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_orders">orders</code></td>
<td>
<p>List of orders, containing vector variables <code>ar</code>,
<code>i</code> and <code>ma</code>. Example:
<code>orders=list(ar=c(1,2),i=c(1),ma=c(1,1,1))</code>. If a variable is not
provided in the list, then it is assumed to be equal to zero. At least one
variable should have the same length as <code>lags</code>. Another option is to
specify orders as a vector of a form <code>orders=c(p,d,q)</code>. The non-seasonal
ARIMA(p,d,q) is constructed in this case.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_lags">lags</code></td>
<td>
<p>Defines lags for the corresponding orders (see examples above).
The length of <code>lags</code> must correspond to the length of either <code>ar</code>,
<code>i</code> or <code>ma</code> in <code>orders</code> variable. There is no restrictions on
the length of <code>lags</code> vector. It is recommended to order <code>lags</code>
ascending.
The orders are set by a user. If you want the automatic order selection,
then use <a href="#topic+auto.ssarima">auto.ssarima</a> function instead.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_constant">constant</code></td>
<td>
<p>If <code>TRUE</code>, constant term is included in the model. Can
also be a number (constant value).</p>
</td></tr>
<tr><td><code id="ssarima_+3A_ar">AR</code></td>
<td>
<p>Vector or matrix of AR parameters. The order of parameters should
be lag-wise. This means that first all the AR parameters of the firs lag
should be passed, then for the second etc. AR of another ssarima can be
passed here.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_ma">MA</code></td>
<td>
<p>Vector or matrix of MA parameters. The order of parameters should
be lag-wise. This means that first all the MA parameters of the firs lag
should be passed, then for the second etc. MA of another ssarima can be
passed here.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_initial">initial</code></td>
<td>
<p>Can be either character or a vector of initial states. If it
is character, then it can be <code>"optimal"</code>, meaning that the initial
states are optimised, or <code>"backcasting"</code>, meaning that the initials are
produced using backcasting procedure.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_ic">ic</code></td>
<td>
<p>The information criterion used in the model selection procedure.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization. <code>loss</code> can
be: <code>likelihood</code> (assuming Normal distribution of error term),
<code>MSE</code> (Mean Squared Error), <code>MAE</code> (Mean Absolute Error),
<code>HAM</code> (Half Absolute Moment), <code>TMSE</code> - Trace Mean Squared Error,
<code>GTMSE</code> - Geometric Trace Mean Squared Error, <code>MSEh</code> - optimisation
using only h-steps ahead error, <code>MSCE</code> - Mean Squared Cumulative Error.
If <code>loss!="MSE"</code>, then likelihood and model selection is done based
on equivalent <code>MSE</code>. Model selection in this cases becomes not optimal.
</p>
<p>There are also available analytical approximations for multistep functions:
<code>aMSEh</code>, <code>aTMSE</code> and <code>aGTMSE</code>. These can be useful in cases
of small samples.
</p>
<p>Finally, just for fun the absolute and half analogues of multistep estimators
are available: <code>MAEh</code>, <code>TMAE</code>, <code>GTMAE</code>, <code>MACE</code>, <code>TMAE</code>,
<code>HAMh</code>, <code>THAM</code>, <code>GTHAM</code>, <code>CHAM</code>.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_h">h</code></td>
<td>
<p>Length of forecasting horizon.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_holdout">holdout</code></td>
<td>
<p>If <code>TRUE</code>, holdout sample of size <code>h</code> is taken from
the end of the data.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_cumulative">cumulative</code></td>
<td>
<p>If <code>TRUE</code>, then the cumulative forecast and prediction
interval are produced instead of the normal ones. This is useful for
inventory control systems.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_interval">interval</code></td>
<td>
<p>Type of interval to construct. This can be:
</p>

<ul>
<li> <p><code>"none"</code>, aka <code>"n"</code> - do not produce prediction
interval.
</p>
</li>
<li> <p><code>"parametric"</code>, <code>"p"</code> - use state-space structure of ETS. In
case of mixed models this is done using simulations, which may take longer
time than for the pure additive and pure multiplicative models. This type
of interval relies on unbiased estimate of in-sample error variance, which
divides the sume of squared errors by T-k rather than just T.
</p>
</li>
<li> <p><code>"likelihood"</code>, <code>"l"</code> - these are the same as <code>"p"</code>, but
relies on the biased estimate of variance from the likelihood (division by
T, not by T-k).
</p>
</li>
<li> <p><code>"semiparametric"</code>, <code>"sp"</code> - interval based on covariance
matrix of 1 to h steps ahead errors and assumption of normal / log-normal
distribution (depending on error type).
</p>
</li>
<li> <p><code>"nonparametric"</code>, <code>"np"</code> - interval based on values from a
quantile regression on error matrix (see Taylor and Bunn, 1999). The model
used in this process is e[j] = a j^b, where j=1,..,h.
</p>
</li></ul>

<p>The parameter also accepts <code>TRUE</code> and <code>FALSE</code>. The former means that
parametric interval are constructed, while the latter is equivalent to
<code>none</code>.
If the forecasts of the models were combined, then the interval are combined
quantile-wise (Lichtendahl et al., 2013).</p>
</td></tr>
<tr><td><code id="ssarima_+3A_level">level</code></td>
<td>
<p>Confidence level. Defines width of prediction interval.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_bounds">bounds</code></td>
<td>
<p>What type of bounds to use in the model estimation. The first
letter can be used instead of the whole word.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_silent">silent</code></td>
<td>
<p>If <code>silent="none"</code>, then nothing is silent, everything is
printed out and drawn. <code>silent="all"</code> means that nothing is produced or
drawn (except for warnings). In case of <code>silent="graph"</code>, no graph is
produced. If <code>silent="legend"</code>, then legend of the graph is skipped.
And finally <code>silent="output"</code> means that nothing is printed out in the
console, but the graph is produced. <code>silent</code> also accepts <code>TRUE</code>
and <code>FALSE</code>. In this case <code>silent=TRUE</code> is equivalent to
<code>silent="all"</code>, while <code>silent=FALSE</code> is equivalent to
<code>silent="none"</code>. The parameter also accepts first letter of words (&quot;n&quot;,
&quot;a&quot;, &quot;g&quot;, &quot;l&quot;, &quot;o&quot;).</p>
</td></tr>
<tr><td><code id="ssarima_+3A_xreg">xreg</code></td>
<td>
<p>The vector (either numeric or time series) or the matrix (or
data.frame) of exogenous variables that should be included in the model. If
matrix included than columns should contain variables and rows - observations.
Note that <code>xreg</code> should have number of observations equal either to
in-sample or to the whole series. If the number of observations in
<code>xreg</code> is equal to in-sample, then values for the holdout sample are
produced using <a href="#topic+es">es</a> function.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_regressors">regressors</code></td>
<td>
<p>The variable defines what to do with the provided xreg:
<code>"use"</code> means that all of the data should be used, while
<code>"select"</code> means that a selection using <code>ic</code> should be done.
<code>"combine"</code> will be available at some point in future...</p>
</td></tr>
<tr><td><code id="ssarima_+3A_initialx">initialX</code></td>
<td>
<p>The vector of initial parameters for exogenous variables.
Ignored if <code>xreg</code> is NULL.</p>
</td></tr>
<tr><td><code id="ssarima_+3A_...">...</code></td>
<td>
<p>Other non-documented parameters.
</p>
<p>Parameter <code>model</code> can accept a previously estimated SSARIMA model and
use all its parameters.
</p>
<p><code>FI=TRUE</code> will make the function produce Fisher Information matrix,
which then can be used to calculated variances of parameters of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model, implemented in this function, is discussed in Svetunkov &amp; Boylan
(2019).
</p>
<p>The basic ARIMA(p,d,q) used in the function has the following form:
</p>
<p><code class="reqn">(1 - B)^d (1 - a_1 B - a_2 B^2 - ... - a_p B^p) y_[t] = (1 + b_1 B +
b_2 B^2 + ... + b_q B^q) \epsilon_[t] + c</code>
</p>
<p>where <code class="reqn">y_[t]</code> is the actual values, <code class="reqn">\epsilon_[t]</code> is the error term,
<code class="reqn">a_i, b_j</code> are the parameters for AR and MA respectively and <code class="reqn">c</code> is
the constant. In case of non-zero differences <code class="reqn">c</code> acts as drift.
</p>
<p>This model is then transformed into ARIMA in the Single Source of Error
State space form (proposed in Snyder, 1985):
</p>
<p><code class="reqn">y_{t} = o_{t} (w' v_{t-l} + x_t a_{t-1} + \epsilon_{t})</code>
</p>
<p><code class="reqn">v_{t} = F v_{t-l} + g \epsilon_{t}</code>
</p>
<p><code class="reqn">a_{t} = F_{X} a_{t-1} + g_{X} \epsilon_{t} / x_{t}</code>
</p>
<p>Where <code class="reqn">o_{t}</code> is the Bernoulli distributed random variable (in case of
normal data equal to 1), <code class="reqn">v_{t}</code> is the state vector (defined based on
<code>orders</code>) and <code class="reqn">l</code> is the vector of <code>lags</code>, <code class="reqn">x_t</code> is the
vector of exogenous parameters. <code class="reqn">w</code> is the <code>measurement</code> vector,
<code class="reqn">F</code> is the <code>transition</code> matrix, <code class="reqn">g</code> is the <code>persistence</code>
vector, <code class="reqn">a_t</code> is the vector of parameters for exogenous variables,
<code class="reqn">F_{X}</code> is the <code>transitionX</code> matrix and <code class="reqn">g_{X}</code> is the
<code>persistenceX</code> matrix.
</p>
<p>Due to the flexibility of the model, multiple seasonalities can be used. For
example, something crazy like this can be constructed:
SARIMA(1,1,1)(0,1,1)[24](2,0,1)[24*7](0,0,1)[24*30], but the estimation may
take some finite time... If you plan estimating a model with more than one
seasonality, it is recommended to consider doing it using <a href="#topic+msarima">msarima</a>.
</p>
<p>The model selection for SSARIMA is done by the <a href="#topic+auto.ssarima">auto.ssarima</a> function.
</p>
<p>For some more information about the model and its implementation, see the
vignette: <code>vignette("ssarima","smooth")</code>
</p>


<h3>Value</h3>

<p>Object of class &quot;smooth&quot; is returned. It contains the list of the
following values:
</p>

<ul>
<li> <p><code>model</code> - the name of the estimated model.
</p>
</li>
<li> <p><code>timeElapsed</code> - time elapsed for the construction of the model.
</p>
</li>
<li> <p><code>states</code> - the matrix of the fuzzy components of ssarima, where
<code>rows</code> correspond to time and <code>cols</code> to states.
</p>
</li>
<li> <p><code>transition</code> - matrix F.
</p>
</li>
<li> <p><code>persistence</code> - the persistence vector. This is the place, where
smoothing parameters live.
</p>
</li>
<li> <p><code>measurement</code> - measurement vector of the model.
</p>
</li>
<li> <p><code>AR</code> - the matrix of coefficients of AR terms.
</p>
</li>
<li> <p><code>I</code> - the matrix of coefficients of I terms.
</p>
</li>
<li> <p><code>MA</code> - the matrix of coefficients of MA terms.
</p>
</li>
<li> <p><code>constant</code> - the value of the constant term.
</p>
</li>
<li> <p><code>initialType</code> - Type of the initial values used.
</p>
</li>
<li> <p><code>initial</code> - the initial values of the state vector (extracted
from <code>states</code>).
</p>
</li>
<li> <p><code>nParam</code> - table with the number of estimated / provided parameters.
If a previous model was reused, then its initials are reused and the number of
provided parameters will take this into account.
</p>
</li>
<li> <p><code>fitted</code> - the fitted values.
</p>
</li>
<li> <p><code>forecast</code> - the point forecast.
</p>
</li>
<li> <p><code>lower</code> - the lower bound of prediction interval. When
<code>interval="none"</code> then NA is returned.
</p>
</li>
<li> <p><code>upper</code> - the higher bound of prediction interval. When
<code>interval="none"</code> then NA is returned.
</p>
</li>
<li> <p><code>residuals</code> - the residuals of the estimated model.
</p>
</li>
<li> <p><code>errors</code> - The matrix of 1 to h steps ahead errors. Only returned when the
multistep losses are used and semiparametric interval is needed.
</p>
</li>
<li> <p><code>s2</code> - variance of the residuals (taking degrees of freedom into
account).
</p>
</li>
<li> <p><code>interval</code> - type of interval asked by user.
</p>
</li>
<li> <p><code>level</code> - confidence level for interval.
</p>
</li>
<li> <p><code>cumulative</code> - whether the produced forecast was cumulative or not.
</p>
</li>
<li> <p><code>y</code> - the original data.
</p>
</li>
<li> <p><code>holdout</code> - the holdout part of the original data.
</p>
</li>
<li> <p><code>xreg</code> - provided vector or matrix of exogenous variables. If
<code>regressors="s"</code>, then this value will contain only selected exogenous
variables.
</p>
</li>
<li> <p><code>initialX</code> - initial values for parameters of exogenous
variables.
</p>
</li>
<li> <p><code>ICs</code> - values of information criteria of the model. Includes
AIC, AICc, BIC and BICc.
</p>
</li>
<li> <p><code>logLik</code> - log-likelihood of the function.
</p>
</li>
<li> <p><code>lossValue</code> - Cost function value.
</p>
</li>
<li> <p><code>loss</code> - Type of loss function used in the estimation.
</p>
</li>
<li> <p><code>FI</code> - Fisher Information. Equal to NULL if <code>FI=FALSE</code>
or when <code>FI</code> is not provided at all.
</p>
</li>
<li> <p><code>accuracy</code> - vector of accuracy measures for the holdout sample.
In case of non-intermittent data includes: MPE, MAPE, SMAPE, MASE, sMAE,
RelMAE, sMSE and Bias coefficient (based on complex numbers). In case of
intermittent data the set of errors will be: sMSE, sPIS, sCE (scaled
cumulative error) and Bias coefficient. This is available only when
<code>holdout=TRUE</code>.
</p>
</li>
<li> <p><code>B</code> - the vector of all the estimated parameters.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Taylor, J.W. and Bunn, D.W. (1999) A Quantile Regression Approach to
Generating Prediction Intervals. Management Science, Vol 45, No 2, pp
225-237.
</p>
</li>
<li><p> Lichtendahl Kenneth C., Jr., Grushka-Cockayne Yael, Winkler
Robert L., (2013) Is It Better to Average Probabilities or
Quantiles? Management Science 59(7):1594-1611. DOI:
<a href="https://doi.org/10.1287/mnsc.1120.1667">doi:10.1287/mnsc.1120.1667</a>
</p>
</li></ul>


<ul>
<li><p> Snyder, R. D., 1985. Recursive Estimation of Dynamic Linear Models.
Journal of the Royal Statistical Society, Series B (Methodological) 47 (2), 272-276.
</p>
</li>
<li><p> Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
Forecasting with exponential smoothing: the state space approach,
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-540-71918-2">doi:10.1007/978-3-540-71918-2</a>.
</p>
</li></ul>


<ul>
<li><p> Svetunkov, I., &amp; Boylan, J. E. (2019). State-space ARIMA for supply-chain forecasting.
International Journal of Production Research, 0(0), 110.
<a href="https://doi.org/10.1080/00207543.2019.1600764">doi:10.1080/00207543.2019.1600764</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+auto.ssarima">auto.ssarima</a>, <a href="#topic+orders">orders</a>,
<a href="#topic+msarima">msarima</a>, <a href="#topic+auto.msarima">auto.msarima</a>,
<a href="#topic+sim.ssarima">sim.ssarima</a>, <a href="#topic+adam">adam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ARIMA(1,1,1) fitted to some data
ourModel &lt;- ssarima(rnorm(118,100,3),orders=list(ar=c(1),i=c(1),ma=c(1)),lags=c(1),h=18,
                             holdout=TRUE,interval="p")

# The previous one is equivalent to:
ourModel &lt;- ssarima(rnorm(118,100,3),ar.orders=c(1),i.orders=c(1),ma.orders=c(1),
                              lags=c(1),h=18,holdout=TRUE,interval="p")

# Model with the same lags and orders, applied to a different data
ssarima(rnorm(118,100,3),orders=orders(ourModel),lags=lags(ourModel),h=18,holdout=TRUE)

# The same model applied to a different data
ssarima(rnorm(118,100,3),model=ourModel,h=18,holdout=TRUE)

# Example of SARIMA(2,0,0)(1,0,0)[4]
ssarima(rnorm(118,100,3),orders=list(ar=c(2,1)),lags=c(1,4),h=18,holdout=TRUE)

# SARIMA(1,1,1)(0,0,1)[4] with different initialisations
ssarima(rnorm(118,100,3),orders=list(ar=c(1),i=c(1),ma=c(1,1)),
        lags=c(1,4),h=18,holdout=TRUE)
ssarima(rnorm(118,100,3),orders=list(ar=c(1),i=c(1),ma=c(1,1)),
        lags=c(1,4),h=18,holdout=TRUE,initial="o")

# SARIMA of a peculiar order on AirPassengers data
ssarima(AirPassengers,orders=list(ar=c(1,0,3),i=c(1,0,1),ma=c(0,1,2)),
                  lags=c(1,6,12),h=10,holdout=TRUE)

# ARIMA(1,1,1) with Mean Squared Trace Forecast Error
ssarima(rnorm(118,100,3),orders=list(ar=1,i=1,ma=1),lags=1,h=18,holdout=TRUE,loss="TMSE")
ssarima(rnorm(118,100,3),orders=list(ar=1,i=1,ma=1),lags=1,h=18,holdout=TRUE,loss="aTMSE")

# SARIMA(0,1,1) with exogenous variables
ssarima(rnorm(118,100,3),orders=list(i=1,ma=1),h=18,holdout=TRUE,xreg=c(1:118))

summary(ourModel)
forecast(ourModel)
plot(forecast(ourModel))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
