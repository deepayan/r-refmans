<!DOCTYPE html><html><head><title>Help for package kamila</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kamila}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#kamila-package'>
<p>Clustering for mixed continuous and categorical data sets</p></a></li>
<li><a href='#classifyKamila'><p>Classify new data into existing KAMILA clusters</p></a></li>
<li><a href='#dptmCpp'><p>Calculate distances from a set of points to a set of centroids</p></a></li>
<li><a href='#dummyCodeFactorDf'><p>Dummy coding of a data frame of factor variables</p></a></li>
<li><a href='#genMixedData'><p>Generate simulated mixed-type data with cluster structure.</p></a></li>
<li><a href='#gmsClust'><p>A general implementation of Modha-Spangler clustering for mixed-type data.</p></a></li>
<li><a href='#kamila'><p>KAMILA clustering of mixed-type data.</p></a></li>
<li><a href='#wkmeans'><p>Weighted k-means for mixed-type data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Foss [aut, cre],
  Marianthi Markatou [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Foss &lt;alexanderhfoss@gmail.com&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for Clustering Mixed-Type Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements methods for clustering mixed-type data,
  specifically combinations of continuous and nominal data. Special attention
  is paid to the often-overlooked problem of equitably balancing the
  contribution of the continuous and categorical variables. This package
  implements KAMILA clustering, a novel method for clustering
  mixed-type data in the spirit of k-means clustering. It does not require
  dummy coding of variables, and is efficient enough to scale to rather large
  data sets. Also implemented is Modha-Spangler clustering, which uses a
  brute-force strategy to maximize the cluster separation simultaneously in the
  continuous and categorical variables. For more information, see Foss, Markatou,
  Ray, &amp; Heching (2016) &lt;<a href="https://doi.org/10.1007%2Fs10994-016-5575-7">doi:10.1007/s10994-016-5575-7</a>&gt; and Foss &amp; Markatou
  (2018) &lt;<a href="https://doi.org/10.18637%2Fjss.v083.i13">doi:10.18637/jss.v083.i13</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ahfoss/kamila">https://github.com/ahfoss/kamila</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ahfoss/kamila/issues">https://github.com/ahfoss/kamila/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, abind, KernSmooth, gtools, Rcpp, plyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, clustMD, ggplot2, Hmisc</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-13 04:36:37 UTC; ahfoss</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-13 07:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='kamila-package'>
Clustering for mixed continuous and categorical data sets
</h2><span id='topic+kamila-package'></span>

<h3>Description</h3>

<p>A collection of methods for clustering mixed type data, including KAMILA (KAy-means for MIxed LArge data) and a flexible implementation of Modha-Spangler clustering
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> kamila</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-10-06</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alex Foss and Marianthi Markatou
</p>
<p>Maintainer: Alex Foss &lt;alexanderhfoss@gmail.com&gt;
</p>


<h3>References</h3>

<p>AH Foss, M Markatou, B Ray, and A Heching (in press). A semiparametric method for clustering mixed data. Machine Learning, DOI: 10.1007/s10994-016-5575-7.
</p>
<p>DS Modha and S Spangler (2003). Feature weighting in k-means clustering. Machine Learning 52(3), 217-237.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# import and format a mixed-type data set
data(Byar, package='clustMD')
Byar$logSpap &lt;- log(Byar$Serum.prostatic.acid.phosphatase)
conInd &lt;- c(5,6,8:10,16)
conVars &lt;- Byar[,conInd]
conVars &lt;- data.frame(scale(conVars))

catVarsFac &lt;- Byar[,-c(1:2,conInd,11,14,15)]
catVarsFac[] &lt;- lapply(catVarsFac, factor)
catVarsDum &lt;- dummyCodeFactorDf(catVarsFac)

# Modha-Spangler clustering with kmeans default Hartigan-Wong algorithm
gmsResHw &lt;- gmsClust(conVars, catVarsDum, nclust = 3)

# Modha-Spangler clustering with kmeans Forgy-Lloyd algorithm
# NOTE searchDensity should be &gt;= 10 for optimal performance:
# this is just a syntax demo
gmsResLloyd &lt;- gmsClust(conVars, catVarsDum, nclust = 3,
  algorithm = "Lloyd", searchDensity = 3)

# KAMILA clustering
kamRes &lt;- kamila(conVars, catVarsFac, numClust=3, numInit=10)

# Plot results
ternarySurvival &lt;- factor(Byar$SurvStat)
levels(ternarySurvival) &lt;- c('Alive','DeadProst','DeadOther')[c(1,2,rep(3,8))]
plottingData &lt;- cbind(
  conVars,
  catVarsFac,
  KamilaCluster = factor(kamRes$finalMemb),
  MSCluster = factor(gmsResHw$results$cluster))
plottingData$Bone.metastases &lt;- ifelse(
  plottingData$Bone.metastases == '1', yes='Yes',no='No')

# Plot Modha-Spangler/Hartigan-Wong results
msPlot &lt;- ggplot(
  plottingData,
  aes(
    x=logSpap,
    y=Index.of.tumour.stage.and.histolic.grade,
    color=ternarySurvival,
    shape=MSCluster))
plotOpts &lt;- function(pl) (pl + geom_point() + 
  scale_shape_manual(values=c(2,3,7)) + geom_jitter())
plotOpts(msPlot)

# Plot KAMILA results
kamPlot &lt;- ggplot(
  plottingData,
  aes(
    x=logSpap,
    y=Index.of.tumour.stage.and.histolic.grade,
    color=ternarySurvival,
    shape=KamilaCluster))
plotOpts(kamPlot)

## End(Not run)
</code></pre>

<hr>
<h2 id='classifyKamila'>Classify new data into existing KAMILA clusters</h2><span id='topic+classifyKamila'></span>

<h3>Description</h3>

<p>A function that classifies a new data set into existing KAMILA clusters
using the output object from the kamila function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classifyKamila(obj, newData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classifyKamila_+3A_obj">obj</code></td>
<td>
<p>An output object from the kamila function.</p>
</td></tr>
<tr><td><code id="classifyKamila_+3A_newdata">newData</code></td>
<td>
<p>A list of length 2, with first element a data frame of continuous variables, and second element a data frame of categorical factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function that takes obj, the output from the kamila function, and newData,
a list of length 2, where the first element is a data frame of continuous
variables, and the second element is a data frame of categorical factors.
Both data frames must have the same format as the original data used
to construct the kamila clustering.
</p>


<h3>Value</h3>

<p>An integer vector denoting cluster assignments of the new data points.
</p>


<h3>References</h3>

<p>Foss A, Markatou M; kamila: Clustering Mixed-Type Data in R and Hadoop. Journal of Statistical Software, 83(13). 2018. doi: 10.18637/jss.v083.i13
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate toy data set
set.seed(1234)
dat1 &lt;- genMixedData(400, nConVar = 2, nCatVar = 2, nCatLevels = 4,
  nConWithErr = 2, nCatWithErr = 2, popProportions = c(.5,.5),
  conErrLev = 0.2, catErrLev = 0.2)
# Partition the data into training/test set
trainingIds &lt;- sample(nrow(dat1$conVars), size = 300, replace = FALSE)
catTrain &lt;- data.frame(apply(dat1$catVars[trainingIds,], 2, factor), stringsAsFactors = TRUE)
conTrain &lt;- data.frame(scale(dat1$conVars)[trainingIds,], stringsAsFactors = TRUE)
catTest &lt;- data.frame(apply(dat1$catVars[-trainingIds,], 2, factor), stringsAsFactors = TRUE)
conTest &lt;- data.frame(scale(dat1$conVars)[-trainingIds,], stringsAsFactors = TRUE)
# Run the kamila clustering procedure on the training set
kamilaObj &lt;- kamila(conTrain, catTrain, numClust = 2, numInit = 10)
table(dat1$trueID[trainingIds], kamilaObj$finalMemb)
# Predict membership in the test data set
kamilaPred &lt;- classifyKamila(kamilaObj, list(conTest, catTest))
table(dat1$trueID[-trainingIds], kamilaPred)
</code></pre>

<hr>
<h2 id='dptmCpp'>Calculate distances from a set of points to a set of centroids</h2><span id='topic+dptmCpp'></span>

<h3>Description</h3>

<p>A function that calculates a NxM matrix of distances between a NxP set of
points and a MxP set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dptmCpp(pts, myMeans, wgts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dptmCpp_+3A_pts">pts</code></td>
<td>
<p>A matrix of points</p>
</td></tr>
<tr><td><code id="dptmCpp_+3A_mymeans">myMeans</code></td>
<td>
<p>A matrix of centroids, must have same ncol as pts</p>
</td></tr>
<tr><td><code id="dptmCpp_+3A_wgts">wgts</code></td>
<td>
<p>A Px1 vector of variable weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A MxP matrix of distances
</p>

<hr>
<h2 id='dummyCodeFactorDf'>Dummy coding of a data frame of factor variables</h2><span id='topic+dummyCodeFactorDf'></span>

<h3>Description</h3>

<p>Given a data frame of factor variables, this function returns a numeric
matrix of 0&ndash;1 dummy-coded variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummyCodeFactorDf(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummyCodeFactorDf_+3A_dat">dat</code></td>
<td>
<p>A data frame of factor variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix of 0&ndash;1 dummy coded variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dd &lt;- data.frame(a=factor(1:8), b=factor(letters[1:8]), stringsAsFactors = TRUE)
dummyCodeFactorDf(dd)
</code></pre>

<hr>
<h2 id='genMixedData'>Generate simulated mixed-type data with cluster structure.</h2><span id='topic+genMixedData'></span>

<h3>Description</h3>

<p>This function simulates mixed-type data sets with a latent cluster
structure, with continuous and nominal variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genMixedData(
  sampSize,
  nConVar,
  nCatVar,
  nCatLevels,
  nConWithErr,
  nCatWithErr,
  popProportions,
  conErrLev,
  catErrLev
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genMixedData_+3A_sampsize">sampSize</code></td>
<td>
<p>Integer: Size of the simulated data set.</p>
</td></tr>
<tr><td><code id="genMixedData_+3A_nconvar">nConVar</code></td>
<td>
<p>The number of continuous variables.</p>
</td></tr>
<tr><td><code id="genMixedData_+3A_ncatvar">nCatVar</code></td>
<td>
<p>The number of categorical variables.</p>
</td></tr>
<tr><td><code id="genMixedData_+3A_ncatlevels">nCatLevels</code></td>
<td>
<p>Integer: The number of categories per categorical variables. Currently must be a multiple of the number of populations specified in popProportions.</p>
</td></tr>
<tr><td><code id="genMixedData_+3A_nconwitherr">nConWithErr</code></td>
<td>
<p>Integer: The number of continuous variables with error.</p>
</td></tr>
<tr><td><code id="genMixedData_+3A_ncatwitherr">nCatWithErr</code></td>
<td>
<p>Integer: The number of categorical variables with error.</p>
</td></tr>
<tr><td><code id="genMixedData_+3A_popproportions">popProportions</code></td>
<td>
<p>A vector of scalars that sums to one. The length gives the number of populations (clusters), with values denoting the prior probability of observing a member of the corresponding population. NOTE: currently only two populations are supported.</p>
</td></tr>
<tr><td><code id="genMixedData_+3A_conerrlev">conErrLev</code></td>
<td>
<p>A scalar between 0.01 and 1 denoting the univariate overlap between clusters on the continuous variables specified to have error.</p>
</td></tr>
<tr><td><code id="genMixedData_+3A_caterrlev">catErrLev</code></td>
<td>
<p>Univariate overlap level for the categorical variables with error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates mixed-type data sets with a latent cluster
structure. Continuous variables follow a normal mixture model, and
categorical variables follow a multinomial mixture model. Overlap of the
continuous and categorical variables (i.e. how clear the cluster structure
is) can be manipulated by the user. Overlap between two clusters is the area
of the overlapping region defined by their densities (or, for categorical
variables, the summed height of overlapping segments defined by their point
masses). The default overlap level is 0.01 (i.e. almost perfect separation).
A user-specified number of continuous and categorical variables can be
specified to be &quot;error variables&quot; with arbitrary overlap within 0.01 and 1.00
(where 1.00 corresponds to complete overlap).
NOTE: Currently, only two populations (clusters) are supported. While exact
control of overlap between two clusters is straightforward, controlling the
overlap between the K choose 2 pairwise combinations of clusters is a more
difficult task.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>trueID</code></td>
<td>
<p>Integer vector giving population (cluster) membership of each observation</p>
</td></tr>
<tr><td><code>trueMus</code></td>
<td>
<p>Mean parameters used for population (cluster) centers in the continuous variables</p>
</td></tr>
<tr><td><code>conVars</code></td>
<td>
<p>The continuous variables</p>
</td></tr>
<tr><td><code>errVariance</code></td>
<td>
<p>Variance parameter used for continuous error distribution</p>
</td></tr>
<tr><td><code>popProbsNoErr</code></td>
<td>
<p>Multinomial probability vectors for categorical variables without measurement error</p>
</td></tr>
<tr><td><code>popProbsWithErr</code></td>
<td>
<p>Multinomial probability vectors for categorical variables with measurement error</p>
</td></tr>
<tr><td><code>catVars</code></td>
<td>
<p>The categorical variables</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- genMixedData(100, 2, 2, nCatLevels=4, nConWithErr=1, nCatWithErr=1,
  popProportions=c(0.3,0.7), conErrLev=0.3, catErrLev=0.2)
with(dat,plot(conVars,col=trueID))
with(dat,table(data.frame(catVars[,1:2],trueID, stringsAsFactors = TRUE)))
</code></pre>

<hr>
<h2 id='gmsClust'>A general implementation of Modha-Spangler clustering for mixed-type data.</h2><span id='topic+gmsClust'></span>

<h3>Description</h3>

<p>Modha-Spangler clustering estimates the optimal weighting for continuous
vs categorical variables using a brute-force search strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmsClust(
  conData,
  catData,
  nclust,
  searchDensity = 10,
  clustFun = wkmeans,
  conDist = squaredEuc,
  catDist = squaredEuc,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmsClust_+3A_condata">conData</code></td>
<td>
<p>A data frame of continuous variables.</p>
</td></tr>
<tr><td><code id="gmsClust_+3A_catdata">catData</code></td>
<td>
<p>A data frame of categorical variables; the allowable variable types depend on the specific clustering function used.</p>
</td></tr>
<tr><td><code id="gmsClust_+3A_nclust">nclust</code></td>
<td>
<p>An integer specifying the number of clusters.</p>
</td></tr>
<tr><td><code id="gmsClust_+3A_searchdensity">searchDensity</code></td>
<td>
<p>An integer determining the number of distinct cluster weightings evaluated in the brute-force search.</p>
</td></tr>
<tr><td><code id="gmsClust_+3A_clustfun">clustFun</code></td>
<td>
<p>The clustering function to be applied.</p>
</td></tr>
<tr><td><code id="gmsClust_+3A_condist">conDist</code></td>
<td>
<p>The continuous distance function used to construct the objective function.</p>
</td></tr>
<tr><td><code id="gmsClust_+3A_catdist">catDist</code></td>
<td>
<p>The categorical distance function used to construct the objective function.</p>
</td></tr>
<tr><td><code id="gmsClust_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to the <code>clustFun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modha-Spangler clustering uses a brute-force search strategy to estimate
the optimal weighting for continuous vs categorical variables. This
implementation admits an arbitrary clustering function and arbitrary
objective functions for continuous and categorical variables.
</p>
<p>The input parameter clustFun must be a function accepting inputs 
(conData, catData, conWeight, nclust, ...) and returning a list containing
(at least) the elements cluster, conCenters, and catCenters. The list element
&quot;cluster&quot; contains cluster memberships denoted by the integers 1:nclust. The
list elements &quot;conCenters&quot; and &quot;catCenters&quot; must be data frames whose rows
denote cluster centroids. The function clustFun must allow nclust = 1, in
which case $centers returns a data frame with a single row.
Input parameters conDist and catDist are functions that must each take two
data frame rows as input and return a scalar distance measure.
</p>


<h3>Value</h3>

<p>A list containing the following results objects:
</p>
<table>
<tr><td><code>results</code></td>
<td>
<p>A results object corresponding to the base clustering algorithm</p>
</td></tr>
<tr><td><code>objFun</code></td>
<td>
<p>A numeric vector of length <code>searchDensity</code> containing the values of the objective function for each weight used</p>
</td></tr>
<tr><td><code>Qcon</code></td>
<td>
<p>A numeric vector of length <code>searchDensity</code> containing the values of the continuous component of the objective function</p>
</td></tr>
<tr><td><code>Qcon</code></td>
<td>
<p>A numeric vector of length <code>searchDensity</code> containing the values of the categorical component of the objective function</p>
</td></tr>
<tr><td><code>bestInd</code></td>
<td>
<p>The index of the most successful run</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>A numeric vector of length <code>searchDensity</code> containing the continuous weights used</p>
</td></tr>
</table>


<h3>References</h3>

<p>Foss A, Markatou M; kamila: Clustering Mixed-Type Data in R and Hadoop. Journal of Statistical Software, 83(13). 2018. doi: 10.18637/jss.v083.i13
</p>
<p>Modha DS, Spangler WS; Feature Weighting in k-Means Clustering. Machine Learning, 52(3). 2003. doi: 10.1023/a:1024016609528
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate toy data set with poor quality categorical variables and good
# quality continuous variables.
set.seed(1)
dat &lt;- genMixedData(200, nConVar=2, nCatVar=2, nCatLevels=4, nConWithErr=2,
  nCatWithErr=2, popProportions=c(.5,.5), conErrLev=0.3, catErrLev=0.8)
catDf &lt;- dummyCodeFactorDf(data.frame(apply(dat$catVars, 2, factor), stringsAsFactors = TRUE))
conDf &lt;- data.frame(scale(dat$conVars), stringsAsFactors = TRUE)

msRes &lt;- gmsClust(conDf, catDf, nclust=2)

table(msRes$results$cluster, dat$trueID)

## End(Not run)
</code></pre>

<hr>
<h2 id='kamila'>KAMILA clustering of mixed-type data.</h2><span id='topic+kamila'></span>

<h3>Description</h3>

<p>KAMILA is an iterative clustering method that equitably balances the
contribution of continuous and categorical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kamila(
  conVar,
  catFactor,
  numClust,
  numInit,
  conWeights = rep(1, ncol(conVar)),
  catWeights = rep(1, ncol(catFactor)),
  maxIter = 25,
  conInitMethod = "runif",
  catBw = 0.025,
  verbose = FALSE,
  calcNumClust = "none",
  numPredStrCvRun = 10,
  predStrThresh = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kamila_+3A_convar">conVar</code></td>
<td>
<p>A data frame of continuous variables.</p>
</td></tr>
<tr><td><code id="kamila_+3A_catfactor">catFactor</code></td>
<td>
<p>A data frame of factors.</p>
</td></tr>
<tr><td><code id="kamila_+3A_numclust">numClust</code></td>
<td>
<p>The number of clusters returned by the algorithm.</p>
</td></tr>
<tr><td><code id="kamila_+3A_numinit">numInit</code></td>
<td>
<p>The number of initializations used.</p>
</td></tr>
<tr><td><code id="kamila_+3A_conweights">conWeights</code></td>
<td>
<p>A vector of continuous weights for the continuous variables.</p>
</td></tr>
<tr><td><code id="kamila_+3A_catweights">catWeights</code></td>
<td>
<p>A vector of continuous weights for the categorical variables.</p>
</td></tr>
<tr><td><code id="kamila_+3A_maxiter">maxIter</code></td>
<td>
<p>The maximum number of iterations in each run.</p>
</td></tr>
<tr><td><code id="kamila_+3A_coninitmethod">conInitMethod</code></td>
<td>
<p>Character: The method used to initialize each run.</p>
</td></tr>
<tr><td><code id="kamila_+3A_catbw">catBw</code></td>
<td>
<p>The bandwidth used for the categorical kernel.</p>
</td></tr>
<tr><td><code id="kamila_+3A_verbose">verbose</code></td>
<td>
<p>Logical: Whether detailed results should be printed and returned.</p>
</td></tr>
<tr><td><code id="kamila_+3A_calcnumclust">calcNumClust</code></td>
<td>
<p>Character: Method for selecting the number of clusters.</p>
</td></tr>
<tr><td><code id="kamila_+3A_numpredstrcvrun">numPredStrCvRun</code></td>
<td>
<p>Numeric: Number of CV runs for prediction strength method. Ignored unless calcNumClust == 'ps'</p>
</td></tr>
<tr><td><code id="kamila_+3A_predstrthresh">predStrThresh</code></td>
<td>
<p>Numeric: Threshold for prediction strength method. Ignored unless calcNumClust == 'ps'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>KAMILA (KAy-means for MIxed LArge data sets) is an iterative clustering
method that equitably balances the contribution of the continuous and
categorical variables. It uses a kernel density estimation technique to
flexibly model spherical clusters in the continuous domain, and uses a
multinomial model in the categorical domain.
</p>
<p>Weighting scheme: If no weights are desired, set all weights to 1 (the
default setting). Let a_1, ..., a_p denote the weights for p continuous 
variables. Let b_1, ..., b_q denote the weights for q categorical variables.
Currently, continuous weights are applied during the calculation of 
Euclidean distance, as:
Categorical weights are applied to the log-likelihoods obtained by the 
level probabilities given cluster membership as:
Total log likelihood for the kth cluster is obtained by weighting the
single continuous log-likelihood by the mean of all continuous weights
plus logLikCat_k:
Note that weights between 0 and 1 are admissible; weights equal to zero
completely remove a variable's influence on the clustering; weights equal
to 1 leave a variable's contribution unchanged. Weights between 0 and 1
may not be comparable across continuous and categorical variables.
Estimating the number of clusters: Default is no estimation method. Setting
calcNumClust to 'ps' uses the prediction strength method of Tibshirani &amp; 
Walther (J. of Comp. and Graphical Stats. 14(3), 2005). There is no perfect
method for estimating the number of clusters; PS tends to give a smaller
number than, say, BIC based methods for large sample sizes. The user must
specify the number of cross-validation runs and the threshold for
determining the number of clusters. The smaller the threshold, the larger
the number of clusters selected.
</p>


<h3>Value</h3>

<p>A list with the following results objects:
</p>
<table>
<tr><td><code>finalMemb</code></td>
<td>
<p>A numeric vector with cluster assignment indicated by integer.</p>
</td></tr>
<tr><td><code>numIter</code></td>
<td>
</td></tr>
<tr><td><code>finalLogLik</code></td>
<td>
<p>The pseudo log-likelihood of the returned clustering.</p>
</td></tr>
<tr><td><code>finalObj</code></td>
<td>
</td></tr>
<tr><td><code>finalCenters</code></td>
<td>
</td></tr>
<tr><td><code>finalProbs</code></td>
<td>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>Object with the given input parameter values.</p>
</td></tr>
<tr><td><code>nClust</code></td>
<td>
<p>An object describing the results of selecting the number of clusters, empty if calcNumClust == 'none'.</p>
</td></tr>
<tr><td><code>verbose</code></td>
<td>
<p>An optionally returned object with more detailed information.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Foss A, Markatou M; kamila: Clustering Mixed-Type Data in R and Hadoop. Journal of Statistical Software, 83(13). 2018. doi: 10.18637/jss.v083.i13
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate toy data set with poor quality categorical variables and good
# quality continuous variables.
set.seed(1)
dat &lt;- genMixedData(200, nConVar = 2, nCatVar = 2, nCatLevels = 4,
  nConWithErr = 2, nCatWithErr = 2, popProportions = c(.5, .5),
  conErrLev = 0.3, catErrLev = 0.8)
catDf &lt;- data.frame(apply(dat$catVars, 2, factor), stringsAsFactors = TRUE)
conDf &lt;- data.frame(scale(dat$conVars), stringsAsFactors = TRUE)

kamRes &lt;- kamila(conDf, catDf, numClust = 2, numInit = 10)

table(kamRes$finalMemb, dat$trueID)
</code></pre>

<hr>
<h2 id='wkmeans'>Weighted k-means for mixed-type data</h2><span id='topic+wkmeans'></span>

<h3>Description</h3>

<p>Weighted k-means for mixed continuous and categorical variables. A 
user-specified weight <code>conWeight</code> controls the relative contribution of the
variable types to the cluster solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkmeans(conData, catData, conWeight, nclust, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkmeans_+3A_condata">conData</code></td>
<td>
<p>The continuous variables. Must be coercible to a data frame.</p>
</td></tr>
<tr><td><code id="wkmeans_+3A_catdata">catData</code></td>
<td>
<p>The categorical variables, either as factors or dummy-coded variables. Must be coercible to a data frame.</p>
</td></tr>
<tr><td><code id="wkmeans_+3A_conweight">conWeight</code></td>
<td>
<p>The continuous weight; must be between 0 and 1. The categorical weight is <code>1-conWeight</code>.</p>
</td></tr>
<tr><td><code id="wkmeans_+3A_nclust">nclust</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="wkmeans_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code>kmeans</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple adaptation of <code>stats::kmeans</code> to mixed-type data.  Continuous
variables are multiplied by the input parameter <code>conWeight</code>, and categorical
variables are multipled by <code>1-conWeight</code>. If factor variables are input to
<code>catData</code>, they are transformed to 0-1 dummy coded variables with the function
<code>dummyCodeFactorDf</code>.
</p>


<h3>Value</h3>

<p>A stats::kmeans results object, with additional slots <code>conCenters</code> and <code>catCenters</code> giving the actual centers adjusted for the weighting process.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dummyCodeFactorDf">dummyCodeFactorDf</a></code>
</p>
<p><code><a href="stats.html#topic+kmeans">kmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate toy data set with poor quality categorical variables and good
# quality continuous variables.
set.seed(1)
dat &lt;- genMixedData(200, nConVar=2, nCatVar=2, nCatLevels=4, nConWithErr=2,
  nCatWithErr=2, popProportions=c(.5,.5), conErrLev=0.3, catErrLev=0.8)
catDf &lt;- data.frame(apply(dat$catVars, 2, factor), stringsAsFactors = TRUE)
conDf &lt;- data.frame(scale(dat$conVars), stringsAsFactors = TRUE)

# A clustering that emphasizes the continuous variables
r1 &lt;- with(dat,wkmeans(conDf, catDf, 0.9, 2))
table(r1$cluster, dat$trueID)

# A clustering that emphasizes the categorical variables; note argument
# passed to the underlying stats::kmeans function
r2 &lt;- with(dat,wkmeans(conDf, catDf, 0.1, 2, nstart=4))
table(r2$cluster, dat$trueID)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
