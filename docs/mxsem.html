<!DOCTYPE html><html lang="en"><head><title>Help for package mxsem</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mxsem}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_all_fields'><p>check_all_fields</p></a></li>
<li><a href='#check_modifier_for_algebra'><p>check_modifier_for_algebra</p></a></li>
<li><a href='#clean_syntax'><p>clean_syntax</p></a></li>
<li><a href='#extract_algebra_elements'><p>extract_algebra_elements</p></a></li>
<li><a href='#find_model_name'><p>find_model_name</p></a></li>
<li><a href='#get_groups'><p>get_groups</p></a></li>
<li><a href='#get_individual_algebra_results'><p>get_individual_algebra_results</p></a></li>
<li><a href='#mxsem'><p>mxsem</p></a></li>
<li><a href='#mxsem_group_by'><p>mxsem_group_by</p></a></li>
<li><a href='#parameter_table_rcpp'><p>parameter_table_rcpp</p></a></li>
<li><a href='#parameters'><p>parameters</p></a></li>
<li><a href='#print.multi_group_parameters'><p>print the multi_group_parameters</p></a></li>
<li><a href='#set_starting_values'><p>set_starting_values</p></a></li>
<li><a href='#simulate_latent_growth_curve'><p>simulate_latent_growth_curve</p></a></li>
<li><a href='#simulate_moderated_nonlinear_factor_analysis'><p>simulate_moderated_nonlinear_factor_analysis</p></a></li>
<li><a href='#split_string_all'><p>split_string_all</p></a></li>
<li><a href='#summarize_multi_group_model'><p>summarize_multi_group_model</p></a></li>
<li><a href='#unicode_directed'><p>unicode_directed</p></a></li>
<li><a href='#unicode_undirected'><p>unicode_undirected</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Specify 'OpenMx' Models with a 'lavaan'-Style Syntax</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jannik H. Orzek &lt;jannik.orzek@mailbox.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a 'lavaan'-like syntax for 'OpenMx' models. The syntax supports 
  definition variables, bounds, and parameter transformations. This allows for
  latent growth curve models with person-specific measurement occasions, moderated
  nonlinear factor analysis and much more.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>OpenMx</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10), stats, methods, dplyr, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jhorzek.github.io/mxsem/">https://jhorzek.github.io/mxsem/</a>,
<a href="https://github.com/jhorzek/mxsem/">https://github.com/jhorzek/mxsem/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jhorzek/mxsem/issues">https://github.com/jhorzek/mxsem/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-28 11:57:02 UTC; jannik</td>
</tr>
<tr>
<td>Author:</td>
<td>Jannik H. Orzek <a href="https://orcid.org/0000-0002-3123-2248"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-28 16:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_all_fields'>check_all_fields</h2><span id='topic+check_all_fields'></span>

<h3>Description</h3>

<p>checks all elements of the parameter table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_all_fields(parameter_table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_all_fields_+3A_parameter_table">parameter_table</code></td>
<td>
<p>parameter table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>

<hr>
<h2 id='check_modifier_for_algebra'>check_modifier_for_algebra</h2><span id='topic+check_modifier_for_algebra'></span>

<h3>Description</h3>

<p>takes in the parameter table and checks if any of the modifiers therein
is an mxAlgebra. If so, it replaces the modifier with a temporary name and
adds an algebra to the algebra data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_modifier_for_algebra(parameter_table, directed, undirected)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_modifier_for_algebra_+3A_parameter_table">parameter_table</code></td>
<td>
<p>parameter table</p>
</td></tr>
<tr><td><code id="check_modifier_for_algebra_+3A_directed">directed</code></td>
<td>
<p>symbol used to indicate directed effects (regressions and loadings)</p>
</td></tr>
<tr><td><code id="check_modifier_for_algebra_+3A_undirected">undirected</code></td>
<td>
<p>symbol used to indicate undirected effects (variances and covariances)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with parameters (parameter table)
</p>

<hr>
<h2 id='clean_syntax'>clean_syntax</h2><span id='topic+clean_syntax'></span>

<h3>Description</h3>

<p>takes in a lavaan style syntax and removes comments, white space, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_syntax(syntax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_syntax_+3A_syntax">syntax</code></td>
<td>
<p>lavaan style syntax</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of strings with cleaned syntax
</p>

<hr>
<h2 id='extract_algebra_elements'>extract_algebra_elements</h2><span id='topic+extract_algebra_elements'></span>

<h3>Description</h3>

<p>extract all variables/parameters from an mxAlgebra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_algebra_elements(mxAlgebra_formula, extracted = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_algebra_elements_+3A_mxalgebra_formula">mxAlgebra_formula</code></td>
<td>
<p>formula embedded in mxAlgebra</p>
</td></tr>
<tr><td><code id="extract_algebra_elements_+3A_extracted">extracted</code></td>
<td>
<p>used in recursive function calls; don't set this manually</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with names of variables and parameters used in the function call
</p>

<hr>
<h2 id='find_model_name'>find_model_name</h2><span id='topic+find_model_name'></span>

<h3>Description</h3>

<p>checks for a model name in the syntax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_model_name(syntax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_model_name_+3A_syntax">syntax</code></td>
<td>
<p>lavaan like syntax</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with (1) model name and (2) model syntax
</p>

<hr>
<h2 id='get_groups'>get_groups</h2><span id='topic+get_groups'></span>

<h3>Description</h3>

<p>returns a list of groups for a multi group model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_groups(multi_group_model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_groups_+3A_multi_group_model">multi_group_model</code></td>
<td>
<p>multi group model created with mxsem_group_by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with data for each group
</p>


<h3>Examples</h3>

<pre><code class='language-R'># THE FOLLOWING EXAMPLE IS ADAPTED FROM
# https://openmx.ssri.psu.edu/docs/OpenMx/latest/_static/Rdoc/mxModel.html
library(mxsem)

model &lt;- 'spatial =~ visual + cubes + paper
          verbal  =~ general + paragrap + sentence
          math    =~ numeric + series + arithmet'

mg_model &lt;- mxsem(model = model,
                  data  = OpenMx::HS.ability.data) |&gt;
  # we want separate models for all combinations of grades and schools:
  mxsem_group_by(grouping_variables = "school") |&gt;
  mxTryHard()

# let's summarize the results:
summarize_multi_group_model(mg_model)

# let's get the groups:
get_groups(mg_model)
</code></pre>

<hr>
<h2 id='get_individual_algebra_results'>get_individual_algebra_results</h2><span id='topic+get_individual_algebra_results'></span>

<h3>Description</h3>

<p>evaluates algebras for each subject in the data set. This function is
useful if you have algebras with definition variables (e.g., in mnlfa).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_individual_algebra_results(
  mxModel,
  algebra_names = NULL,
  progress_bar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_individual_algebra_results_+3A_mxmodel">mxModel</code></td>
<td>
<p>mxModel with algebras</p>
</td></tr>
<tr><td><code id="get_individual_algebra_results_+3A_algebra_names">algebra_names</code></td>
<td>
<p>optional: Only compute individual algebras for a subset
of the parameters</p>
</td></tr>
<tr><td><code id="get_individual_algebra_results_+3A_progress_bar">progress_bar</code></td>
<td>
<p>should a progress bar be shown?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data frames. The list contains data frames for each of the algebras.
The data frames contain the individual specific algebra results as well as all
definition variables used to predict said algebra
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mxsem)

set.seed(123)
dataset &lt;- simulate_moderated_nonlinear_factor_analysis(N = 50)

model &lt;- "
  xi  =~ x1 + x2 + x3
  eta =~ y1 + y2 + y3
  eta ~  {a := a0 + data.k*a1}*xi
  "
fit &lt;- mxsem(model = model,
             data = dataset) |&gt;
  mxTryHard()

algebra_results &lt;- get_individual_algebra_results(mxModel = fit,
                                                  progress_bar = FALSE)

# the following plot will only show two data points because there is only
# two values for the definition variable k (0 or 1).

plot(x = algebra_results[["a"]]$k,
     y = algebra_results[["a"]]$algebra_result)
</code></pre>

<hr>
<h2 id='mxsem'>mxsem</h2><span id='topic+mxsem'></span>

<h3>Description</h3>

<p>Create an extended SEM with <strong>OpenMx</strong> (Boker et al., 2011) using a
<strong>lavaan</strong>-style (Rosseel, 2012) syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxsem(
  model,
  data,
  scale_loadings = TRUE,
  scale_latent_variances = FALSE,
  add_intercepts = TRUE,
  add_variances = TRUE,
  add_exogenous_latent_covariances = TRUE,
  add_exogenous_manifest_covariances = TRUE,
  lbound_variances = TRUE,
  directed = unicode_directed(),
  undirected = unicode_undirected(),
  return_parameter_table = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mxsem_+3A_model">model</code></td>
<td>
<p>model syntax similar to <strong>lavaan</strong>'s syntax</p>
</td></tr>
<tr><td><code id="mxsem_+3A_data">data</code></td>
<td>
<p>raw data used to fit the model. Alternatively, an object created
with <code>OpenMx::mxData</code> can be used (e.g., <code>OpenMx::mxData(observed = cov(OpenMx::Bollen), means = colMeans(OpenMx::Bollen), numObs = nrow(OpenMx::Bollen), type = "cov")</code>).</p>
</td></tr>
<tr><td><code id="mxsem_+3A_scale_loadings">scale_loadings</code></td>
<td>
<p>should the first loading of each latent variable be used for scaling?</p>
</td></tr>
<tr><td><code id="mxsem_+3A_scale_latent_variances">scale_latent_variances</code></td>
<td>
<p>should the latent variances be used for scaling?</p>
</td></tr>
<tr><td><code id="mxsem_+3A_add_intercepts">add_intercepts</code></td>
<td>
<p>should intercepts for manifest variables be added automatically? If set to false, intercepts must be added manually. If no intercepts
are added, <strong>mxsem</strong> will automatically use just the observed covariances and not the observed means.</p>
</td></tr>
<tr><td><code id="mxsem_+3A_add_variances">add_variances</code></td>
<td>
<p>should variances for manifest and latent variables be added automatically?</p>
</td></tr>
<tr><td><code id="mxsem_+3A_add_exogenous_latent_covariances">add_exogenous_latent_covariances</code></td>
<td>
<p>should covariances between exogenous latent variables be
added automatically?</p>
</td></tr>
<tr><td><code id="mxsem_+3A_add_exogenous_manifest_covariances">add_exogenous_manifest_covariances</code></td>
<td>
<p>should covariances between exogenous manifest variables be
added automatically?</p>
</td></tr>
<tr><td><code id="mxsem_+3A_lbound_variances">lbound_variances</code></td>
<td>
<p>should the lower bound for variances be set to 0.000001?</p>
</td></tr>
<tr><td><code id="mxsem_+3A_directed">directed</code></td>
<td>
<p>symbol used to indicate directed effects (regressions and loadings)</p>
</td></tr>
<tr><td><code id="mxsem_+3A_undirected">undirected</code></td>
<td>
<p>symbol used to indicate undirected effects (variances and covariances)</p>
</td></tr>
<tr><td><code id="mxsem_+3A_return_parameter_table">return_parameter_table</code></td>
<td>
<p>if set to TRUE, the internal parameter table is returend
together with the mxModel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting up SEM can be tedious. The <strong>lavaan</strong> (Rosseel, 2012) package provides a great syntax to
make the process easier. The objective of <strong>mxsem</strong> is to provide a similar syntax
for <strong>OpenMx</strong>. <strong>OpenMx</strong> is a flexible R package for extended SEM. However, note that
<strong>mxsem</strong> only covers a small part of the <strong>OpenMx</strong> framework by focusing on &quot;standard&quot;
SEM. Similar to <strong>lavaan</strong>'s <code>sem()</code>-function, <code>mxsem</code> tries to set up parts
of the model automatically (e.g., adding variances automatically or scaling the
latent variables automatically). If you want to unlock
the full potential of <strong>OpenMx</strong>, <strong>mxsem</strong> may not be the best option.
</p>
<p><strong>Warning</strong>: The syntax and settings of <strong>mxsem</strong> may differ from
<strong>lavaan</strong> in some cases. See <code>vignette("Syntax", package = "mxsem")</code> for more details
on the syntax and the default arguments.
</p>


<h4>Alternatives</h4>

<p>You will find similar functions in the following packages:
</p>

<ul>
<li> <p><a href="https://github.com/mikewlcheung/metasem"><strong>metaSEM</strong></a> (Cheung, 2015) provides a <code>lavaan2RAM</code>
function that can be combined with the <code>create.mxModel</code> function. This combination
offers more features than <strong>mxsem</strong>. For instance, constraints of the form <code>a &lt; b</code>
are supported. In <strong>mxsem</strong> such constraints require algebras (e.g., <code style="white-space: pre;">&#8288;!diff; a := b - exp(diff)&#8288;</code>).
</p>
</li>
<li> <p><a href="https://github.com/tbates/umx"><strong>umx</strong></a> (Bates et al., 2019)
provides the <code>umxRAM</code> and <code>umxLav2RAM</code> functions that can parse single <strong>lavaan</strong>-style
statements (e.g., <code>eta =~ y1 + y2 + y3</code>)
or an entire <strong>lavaan</strong> models to <strong>OpenMx</strong> models.
</p>
</li>
<li> <p><a href="https://github.com/cjvanlissa/tidySEM"><strong>tidySEM</strong></a> (van Lissa, 2023) provides the
<code>as_ram</code> function to translate <strong>lavaan</strong> syntax to <strong>OpenMx</strong> and also implements a unified syntax to
specify both, <strong>lavaan</strong> and <strong>OpenMx</strong> models. Additionally, it works well with the
<strong>tidyverse</strong>.
</p>
</li>
<li> <p><a href="https://github.com/OpenMx/ezMx"><strong>ezMx</strong></a> (Bates, et al. 2014) simplifies fitting SEM with <strong>OpenMx</strong>
and also provides a translation of <strong>lavaan</strong> models to <strong>OpenMx</strong> with the
<code>lavaan.to.OpenMx</code> function.
</p>
</li></ul>

<p>Because <strong>mxsem</strong> implements the syntax parser from scratch, it can extend the
<strong>lavaan</strong> syntax to account for specific <strong>OpenMx</strong> features. This enables
implicit transformations with curly braces.
</p>



<h4>Citation</h4>

<p>Cite <strong>OpenMx</strong> (Boker et al., 2011) for the modeling and <strong>lavaan</strong> for the
syntax (Rosseel, 2012). <strong>mxsem</strong> itself is just a very small package and lets
<strong>OpenMx</strong> do all the heavy lifting.
</p>



<h4>Defaults</h4>

<p>By default, <strong>mxsem</strong> scales latent variables by setting the loadings on the first
item to 1. This can be changed by setting <code>scale_loadings = FALSE</code> in the function
call. Setting <code>scale_latent_variances = TRUE</code> sets latent variances to 1 for
scaling.
</p>
<p><strong>mxsem</strong> will add intercepts for all manifest variables as well as variances for
all manifest and latent variables. A lower bound of 1e-6 will be added to all
variances. Finally, covariances for all exogenous variables will be added.
All of these options can be changed when calling <strong>mxsem</strong>.
</p>



<h4>Syntax</h4>

<p>The syntax is, for the most part, identical to that of <strong>lavaan</strong>. The following
specifies loadings of a latent variable <code>eta</code> on manifest variables <code>y1</code>-<code>y4</code>:
</p>
<div class="sourceCode"><pre>eta =~ y1 + y2 + y3
</pre></div>
<p>Regressions are specified with <code>~</code>:
</p>
<div class="sourceCode"><pre>xi  =~ x1 + x2 + x3
eta =~ y1 + y2 + y3
# predict eta with xi:
eta ~  xi
</pre></div>
<p>Add covariances with <code style="white-space: pre;">&#8288;~~&#8288;</code>
</p>
<div class="sourceCode"><pre>xi  =~ x1 + x2 + x3
eta =~ y1 + y2 + y3
# predict eta with xi:
eta ~  xi
x1 ~~ x2
</pre></div>
<p>Intercepts are specified with <code>~1</code>
</p>
<div class="sourceCode"><pre>xi  =~ x1 + x2 + x3
eta =~ y1 + y2 + y3
# predict eta with xi:
eta ~  xi
x1 ~~ x2

eta ~ 1
</pre></div>



<h4>Parameter labels and constraints</h4>

<p>Add labels to parameters as follows:
</p>
<div class="sourceCode"><pre>xi  =~ l1*x1 + l2*x2 + l3*x3
eta =~ l4*y1 + l5*y2 + l6*y3
# predict eta with xi:
eta ~  b*xi
</pre></div>
<p>Fix parameters by using numeric values instead of labels:
</p>
<div class="sourceCode"><pre>xi  =~ 1*x1 + l2*x2 + l3*x3
eta =~ 1*y1 + l5*y2 + l6*y3
# predict eta with xi:
eta ~  b*xi
</pre></div>



<h4>Bounds</h4>

<p>Lower and upper bounds allow for constraints on parameters. For instance,
a lower bound can prevent negative variances.
</p>
<div class="sourceCode"><pre>xi  =~ 1*x1 + l2*x2 + l3*x3
eta =~ 1*y1 + l5*y2 + l6*y3
# predict eta with xi:
eta ~  b*xi
# residual variance for x1
x1 ~~ v*x1
# bound:
v &gt; 0
</pre></div>
<p>Upper bounds are specified with v &lt; 10. Note that the parameter label must always
come first. The following is not allowed: <code>0 &lt; v</code> or <code>10 &gt; v</code>.
</p>



<h4>(Non-)linear constraints</h4>

<p>Assume that latent construct <code>eta</code> was observed twice, where <code>eta1</code> is the first
observation and <code>eta2</code> the second. We want to define the loadings of <code>eta2</code>
on its observations as <code>l_1 + delta_l1</code>. If <code>delta_l1</code> is zero, we have measurement
invariance.
</p>
<div class="sourceCode"><pre>eta1 =~ l1*y1 + l2*y2 + l3*y3
eta2 =~ l4*y4 + l5*y5 + l6*y6
# define new delta-parameter
!delta_1; !delta_2; !delta_3
# redefine l4-l6
l4 := l1 + delta_1
l5 := l2 + delta_2
l6 := l3 + delta_3
</pre></div>
<p>Alternatively, implicit transformations can be used as follows:
</p>
<div class="sourceCode"><pre>eta1 =~ l1*y1 + l2*y2 + l3*y3
eta2 =~ {l1 + delta_1} * y4 + {l2 + delta_2} * y5 + {l3 + delta_3} * y6
</pre></div>
<p>Specific labels for the transformation results can also be provided:
</p>
<div class="sourceCode"><pre>eta1 =~ l1*y1 + l2*y2 + l3*y3
eta2 =~ {l4 := l1 + delta_1} * y4 + {l5 := l2 + delta_2} * y5 + {l6 := l3 + delta_3} * y6
</pre></div>
<p>This is inspired by the approach in <strong>metaSEM</strong> (Cheung, 2015).
</p>



<h4>Definition variables</h4>

<p>Definition variables allow for person-specific parameter constraints. Use the
<code>data.</code>-prefix to specify definition variables.
</p>
<div class="sourceCode"><pre>I =~ 1*y1 + 1*y2 + 1*y3 + 1*y4 + 1*y5
S =~ data.t_1 * y1 + data.t_2 * y2 + data.t_3 * y3 + data.t_4 * y4 + data.t_5 * y5

I ~ int*1
S ~ slp*1
</pre></div>



<h4>Starting Values</h4>

<p><strong>mxsem</strong> differs from <strong>lavaan</strong> in the specification of starting values. Instead
of providing starting values in the model syntax, the <code>set_starting_values</code>
function is used.
</p>



<h4>References</h4>


<ul>
<li><p> Bates, T. C., Maes, H., &amp; Neale, M. C. (2019). umx: Twin and Path-Based Structural Equation Modeling in R. Twin Research and Human Genetics, 22(1), 27–41. https://doi.org/10.1017/thg.2019.2
</p>
</li>
<li><p> Bates, T. C., Prindle, J. J. (2014). ezMx. https://github.com/OpenMx/ezMx
</p>
</li>
<li><p> Boker, S. M., Neale, M., Maes, H., Wilde, M., Spiegel, M., Brick, T., Spies, J., Estabrook, R., Kenny, S., Bates, T., Mehta, P., &amp; Fox, J. (2011).
OpenMx: An Open Source Extended Structural Equation Modeling Framework. Psychometrika, 76(2), 306–317. https://doi.org/10.1007/s11336-010-9200-6
</p>
</li>
<li><p> Cheung, M. W.-L. (2015). metaSEM: An R package for meta-analysis using structural equation modeling. Frontiers in Psychology, 5. https://doi.org/10.3389/fpsyg.2014.01521
</p>
</li>
<li><p> Rosseel, Y. (2012). lavaan: An R package for structural equation modeling. Journal of Statistical Software, 48(2), 1–36. https://doi.org/10.18637/jss.v048.i02
</p>
</li>
<li><p> van Lissa, C. J. (2023). tidySEM: Tidy Structural Equation Modeling. R package version 0.2.4, https://cjvanlissa.github.io/tidySEM/.
</p>
</li></ul>




<h3>Value</h3>

<p>mxModel object that can be fitted with mxRun or mxTryHard. If return_parameter_table
is TRUE, a list with the mxModel and the parameter table is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># THE FOLLOWING EXAMPLE IS ADAPTED FROM LAVAAN
library(mxsem)

model &lt;- '
  # latent variable definitions
     ind60 =~ x1 + x2 + x3
     dem60 =~ y1 + a1*y2 + b*y3 + c1*y4
     dem65 =~ y5 + a2*y6 + b*y7 + c2*y8

  # regressions
    dem60 ~ ind60
    dem65 ~ ind60 + dem60

  # residual correlations
    y1 ~~ y5
    y2 ~~ y4 + y6
    y3 ~~ y7
    y4 ~~ y8
    y6 ~~ y8
'

fit &lt;- mxsem(model = model,
            data  = OpenMx::Bollen) |&gt;
  mxTryHard()
omxGetParameters(fit)


model_transformations &lt;- '
  # latent variable definitions
     ind60 =~ x1 + x2 + x3
     dem60 =~ y1 + a1*y2 + b1*y3 + c1*y4
     dem65 =~ y5 + {a2 := a1 + delta_a}*y6 + {b2 := b1 + delta_b}*y7 + c2*y8

  # regressions
    dem60 ~ ind60
    dem65 ~ ind60 + dem60

  # residual correlations
    y1 ~~ y5
    y2 ~~ y4 + y6
    y3 ~~ y7
    y4 ~~ y8
    y6 ~~ y8
'

fit &lt;- mxsem(model = model_transformations,
            data  = OpenMx::Bollen) |&gt;
  mxTryHard()
omxGetParameters(fit)
</code></pre>

<hr>
<h2 id='mxsem_group_by'>mxsem_group_by</h2><span id='topic+mxsem_group_by'></span>

<h3>Description</h3>

<p>creates a multi-group model from an OpenMx model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxsem_group_by(
  mxModel,
  grouping_variables,
  parameters = c(".*"),
  use_grepl = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mxsem_group_by_+3A_mxmodel">mxModel</code></td>
<td>
<p>mxModel with the entire data</p>
</td></tr>
<tr><td><code id="mxsem_group_by_+3A_grouping_variables">grouping_variables</code></td>
<td>
<p>Variables used to split the data in groups</p>
</td></tr>
<tr><td><code id="mxsem_group_by_+3A_parameters">parameters</code></td>
<td>
<p>the parameters that should be group specific. By default
all parameters are group specific.</p>
</td></tr>
<tr><td><code id="mxsem_group_by_+3A_use_grepl">use_grepl</code></td>
<td>
<p>if set to TRUE, grepl is used to check which parameters are
group specific. For instance, if parameters = &quot;a&quot; and use_grepl = TRUE, all parameters
whose label contains the letter &quot;a&quot; will be group specific. If use_grep = FALSE
only the parameter that has the label &quot;a&quot; is group specific.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mxsem_group_by creates a multi-group model by splitting the data found
in an mxModel object using dplyr's group_by function. The general idea is
as follows:
</p>
<p>1. The function extracts the data from mxModel
2. The data is split using the group_by function of dplyr with the variables
in grouping_variables
3. a separate model is set up for each group. All parameters that match
those specified in the parameters argument are group specific
</p>
<p>**Warning**: The multi-group model may differ from **lavaan**! For instance,
**lavaan** will automatically set the latent variances for all but the first
group free if the loadings are fixed to equality. Such automatic procedures
are not yet implemented in **mxsem**.
</p>


<h3>Value</h3>

<p>mxModel with multiple groups. Use get_groups to extract the groups
</p>


<h3>Examples</h3>

<pre><code class='language-R'># THE FOLLOWING EXAMPLE IS ADAPTED FROM
# https://openmx.ssri.psu.edu/docs/OpenMx/latest/_static/Rdoc/mxModel.html
library(mxsem)

model &lt;- 'spatial =~ visual + cubes + paper
          verbal  =~ general + paragrap + sentence
          math    =~ numeric + series + arithmet'

mg_model &lt;- mxsem(model = model,
                  data  = OpenMx::HS.ability.data) |&gt;
  # we want separate models for all combinations of grades and schools:
  mxsem_group_by(grouping_variables = "school") |&gt;
  mxTryHard()

# let's summarize the results:
summarize_multi_group_model(mg_model)
</code></pre>

<hr>
<h2 id='parameter_table_rcpp'>parameter_table_rcpp</h2><span id='topic+parameter_table_rcpp'></span>

<h3>Description</h3>

<p>creates a parameter table from a lavaan like syntax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameter_table_rcpp(
  syntax,
  add_intercept,
  add_variance,
  add_exogenous_latent_covariances,
  add_exogenous_manifest_covariances,
  scale_latent_variance,
  scale_loading
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameter_table_rcpp_+3A_syntax">syntax</code></td>
<td>
<p>lavaan like syntax</p>
</td></tr>
<tr><td><code id="parameter_table_rcpp_+3A_add_intercept">add_intercept</code></td>
<td>
<p>should intercepts for manifest variables be automatically added?</p>
</td></tr>
<tr><td><code id="parameter_table_rcpp_+3A_add_variance">add_variance</code></td>
<td>
<p>should variances for all variables be automatically added?</p>
</td></tr>
<tr><td><code id="parameter_table_rcpp_+3A_add_exogenous_latent_covariances">add_exogenous_latent_covariances</code></td>
<td>
<p>should covariances between exogenous latent variables be
added automatically?</p>
</td></tr>
<tr><td><code id="parameter_table_rcpp_+3A_add_exogenous_manifest_covariances">add_exogenous_manifest_covariances</code></td>
<td>
<p>should covariances between exogenous manifest variables be
added automatically?</p>
</td></tr>
<tr><td><code id="parameter_table_rcpp_+3A_scale_latent_variance">scale_latent_variance</code></td>
<td>
<p>should variances of latent variables be set to 1?</p>
</td></tr>
<tr><td><code id="parameter_table_rcpp_+3A_scale_loading">scale_loading</code></td>
<td>
<p>should the first loading of each latent variable be set to 1?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parameter table
</p>

<hr>
<h2 id='parameters'>parameters</h2><span id='topic+parameters'></span>

<h3>Description</h3>

<p>Returns the parameter estimates of an mxModel. Wrapper
for omxGetParameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameters(mxMod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameters_+3A_mxmod">mxMod</code></td>
<td>
<p>mxModel object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with parameter estimates
</p>

<hr>
<h2 id='print.multi_group_parameters'>print the multi_group_parameters</h2><span id='topic+print.multi_group_parameters'></span>

<h3>Description</h3>

<p>print the multi_group_parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multi_group_parameters'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.multi_group_parameters_+3A_x">x</code></td>
<td>
<p>object from summarize_multi_group_model</p>
</td></tr>
<tr><td><code id="print.multi_group_parameters_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>

<hr>
<h2 id='set_starting_values'>set_starting_values</h2><span id='topic+set_starting_values'></span>

<h3>Description</h3>

<p>set the starting values of an OpenMx model. This is just an interface to
omxSetParameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_starting_values(mx_model, values)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_starting_values_+3A_mx_model">mx_model</code></td>
<td>
<p>model of class mxModel</p>
</td></tr>
<tr><td><code id="set_starting_values_+3A_values">values</code></td>
<td>
<p>vector with labeled parameter values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mxModel with changed parameter values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mxsem)

model &lt;- '
  # latent variable definitions
     ind60 =~ x1 + x2 + x3
     dem60 =~ y1 + a1*y2 + b*y3 + c1*y4
     dem65 =~ y5 + a2*y6 + b*y7 + c2*y8

  # regressions
    dem60 ~ ind60
    dem65 ~ ind60 + dem60

  # residual correlations
    y1 ~~ y5
    y2 ~~ y4 + y6
    y3 ~~ y7
    y4 ~~ y8
    y6 ~~ y8
'

fit &lt;- mxsem(model = model,
            data  = OpenMx::Bollen) |&gt;
  set_starting_values(values = c("a1" = .4, "c1" = .6)) |&gt;
  mxTryHard()
</code></pre>

<hr>
<h2 id='simulate_latent_growth_curve'>simulate_latent_growth_curve</h2><span id='topic+simulate_latent_growth_curve'></span>

<h3>Description</h3>

<p>simulate data for a latent growth curve model with five measurement occasions.
The time-distance between these occasions differs between subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_latent_growth_curve(N = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_latent_growth_curve_+3A_n">N</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data set with columns y1-y5 (observations) and t_1-t_5 (time of
observation)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
dataset &lt;- simulate_latent_growth_curve(N = 100)

model &lt;- "
  I =~ 1*y1 + 1*y2 + 1*y3 + 1*y4 + 1*y5
  S =~ data.t_1 * y1 + data.t_2 * y2 + data.t_3 * y3 + data.t_4 * y4 + data.t_5 * y5

  I ~ int*1
  S ~ slp*1

  # set intercepts of manifest variables to zero
  y1 ~ 0*1; y2 ~ 0*1; y3 ~ 0*1; y4 ~ 0*1; y5 ~ 0*1;
  "

mod &lt;- mxsem(model = model,
             data = dataset) |&gt;
  mxTryHard()
</code></pre>

<hr>
<h2 id='simulate_moderated_nonlinear_factor_analysis'>simulate_moderated_nonlinear_factor_analysis</h2><span id='topic+simulate_moderated_nonlinear_factor_analysis'></span>

<h3>Description</h3>

<p>simulate data for a moderated nonlinear factor analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_moderated_nonlinear_factor_analysis(N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_moderated_nonlinear_factor_analysis_+3A_n">N</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data set with variables x1-x3 and y1-y3 representing repeated measurements
of an affect measure. It is assumed that the autoregressive effect is different
depending on covariate k
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mxsem)
set.seed(123)
dataset &lt;- simulate_moderated_nonlinear_factor_analysis(N = 2000)

model &lt;- "
xi =~ x1 + x2 + x3
eta =~ y1 + y2 + y3
eta ~ a*xi

# we need two new parameters: a0 and a1. These are created as follows:
!a0
!a1
# Now, we redefine a to be a0 + k*a1, where k is found in the data
a := a0 + data.k*a1
"

mod &lt;- mxsem(model = model,
             data = dataset) |&gt;
  mxTryHard()

omxGetParameters(mod)
</code></pre>

<hr>
<h2 id='split_string_all'>split_string_all</h2><span id='topic+split_string_all'></span>

<h3>Description</h3>

<p>splits a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_string_all(str, at)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_string_all_+3A_str">str</code></td>
<td>
<p>string to be splitted</p>
</td></tr>
<tr><td><code id="split_string_all_+3A_at">at</code></td>
<td>
<p>where to split the string at</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of strings
</p>

<hr>
<h2 id='summarize_multi_group_model'>summarize_multi_group_model</h2><span id='topic+summarize_multi_group_model'></span>

<h3>Description</h3>

<p>summarize the results of a multi group model created with mxsem_group_by
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_multi_group_model(multi_group_model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarize_multi_group_model_+3A_multi_group_model">multi_group_model</code></td>
<td>
<p>multi group model created with mxsem_group_by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with goup specific parameters and common parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'># THE FOLLOWING EXAMPLE IS ADAPTED FROM
# https://openmx.ssri.psu.edu/docs/OpenMx/latest/_static/Rdoc/mxModel.html
library(mxsem)

model &lt;- 'spatial =~ visual + cubes + paper
          verbal  =~ general + paragrap + sentence
          math    =~ numeric + series + arithmet'

mg_model &lt;- mxsem(model = model,
                  data  = OpenMx::HS.ability.data) |&gt;
  # we want separate models for all combinations of grades and schools:
  mxsem_group_by(grouping_variables = "school") |&gt;
  mxTryHard()

# let's summarize the results:
summarize_multi_group_model(mg_model)
</code></pre>

<hr>
<h2 id='unicode_directed'>unicode_directed</h2><span id='topic+unicode_directed'></span>

<h3>Description</h3>

<p>this function returns the unicode for directed arrows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unicode_directed()
</code></pre>


<h3>Value</h3>

<p>returns unicode for directed arrows
</p>

<hr>
<h2 id='unicode_undirected'>unicode_undirected</h2><span id='topic+unicode_undirected'></span>

<h3>Description</h3>

<p>this function returns the unicode for undirected arrows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unicode_undirected()
</code></pre>


<h3>Value</h3>

<p>returns unicode for undirected arrows
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
