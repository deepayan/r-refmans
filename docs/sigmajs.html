<!DOCTYPE html><html><head><title>Help for package sigmajs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sigmajs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#color-scale'><p>Color</p></a></li>
<li><a href='#force'><p>Add forceAtlas2</p></a></li>
<li><a href='#lesmis_edges'><p>Edges from co-appearances of characters in &quot;Les Miserables&quot;</p></a></li>
<li><a href='#lesmis_igraph'><p>Co-appearances of characters in &quot;Les Miserables&quot; as igraph object</p></a></li>
<li><a href='#lesmis_nodes'><p>Nodes from co-appearances of characters in &quot;Les Miserables&quot;</p></a></li>
<li><a href='#read'><p>Read</p></a></li>
<li><a href='#read-batch'><p>Batch read</p></a></li>
<li><a href='#read-static'><p>Read</p></a></li>
<li><a href='#sg_add_images'><p>Add images to nodes</p></a></li>
<li><a href='#sg_add_node_p'><p>Add node or edge</p></a></li>
<li><a href='#sg_add_nodes'><p>Add nodes and edges</p></a></li>
<li><a href='#sg_add_nodes_delay_p'><p>Add nodes or edges with a delay</p></a></li>
<li><a href='#sg_add_nodes_p'><p>Add nodes or edges</p></a></li>
<li><a href='#sg_animate'><p>Animate</p></a></li>
<li><a href='#sg_button'><p>Buttons</p></a></li>
<li><a href='#sg_change_nodes_p'><p>Change</p></a></li>
<li><a href='#sg_clear_p'><p>Clear or kill the graph</p></a></li>
<li><a href='#sg_cluster'><p>Cluster</p></a></li>
<li><a href='#sg_custom_shapes'><p>Custom shapes</p></a></li>
<li><a href='#sg_drag_nodes'><p>Drag nodes</p></a></li>
<li><a href='#sg_drop_node_p'><p>Remove node or edge</p></a></li>
<li><a href='#sg_drop_nodes'><p>Drop</p></a></li>
<li><a href='#sg_drop_nodes_delay_p'><p>Drop nodes or edges with a delay</p></a></li>
<li><a href='#sg_drop_nodes_p'><p>Drop nodes or edges</p></a></li>
<li><a href='#sg_events'><p>Events</p></a></li>
<li><a href='#sg_export_svg'><p>Export</p></a></li>
<li><a href='#sg_filter_gt_p'><p>Filter</p></a></li>
<li><a href='#sg_from_gexf'><p>Graph from GEXF file</p></a></li>
<li><a href='#sg_from_igraph'><p>Create from igraph</p></a></li>
<li><a href='#sg_get_nodes_p'><p>Get nodes</p></a></li>
<li><a href='#sg_layout'><p>Layouts</p></a></li>
<li><a href='#sg_make_nodes'><p>Generate data</p></a></li>
<li><a href='#sg_neighbours'><p>Highlight neighbours</p></a></li>
<li><a href='#sg_nodes'><p>Add nodes and edges</p></a></li>
<li><a href='#sg_noverlap'><p>No overlap</p></a></li>
<li><a href='#sg_progress'><p>Text</p></a></li>
<li><a href='#sg_refresh_p'><p>Refresh instance</p></a></li>
<li><a href='#sg_relative_size'><p>Relative node sizes</p></a></li>
<li><a href='#sg_settings'><p>Settings</p></a></li>
<li><a href='#sg_zoom_p'><p>Zoom</p></a></li>
<li><a href='#sigmajs'><p>Initialise</p></a></li>
<li><a href='#sigmajs-shiny'><p>Shiny bindings for sigmajs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interface to 'Sigma.js' Graph Visualization Library</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-06-17</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Interface to 'sigma.js' graph visualization library including animations, plugins and shiny proxies.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0.9000</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://sigmajs.john-coene.com/">http://sigmajs.john-coene.com/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JohnCoene/sigmajs/issues">https://github.com/JohnCoene/sigmajs/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>htmlwidgets, dplyr (&ge; 0.7.0), magrittr, shiny, jsonlite,
igraph, htmltools, purrr, scales, crosstalk</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-17 15:16:46 UTC; jp</td>
</tr>
<tr>
<td>Author:</td>
<td>John Coene <a href="https://orcid.org/0000-0002-6637-4107"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Coene &lt;jcoenep@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-18 18:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='color-scale'>Color</h2><span id='topic+color-scale'></span><span id='topic+sg_scale_color'></span>

<h3>Description</h3>

<p>Scale color by node size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_scale_color(sg, pal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color-scale_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="color-scale_+3A_pal">pal</code></td>
<td>
<p>Vector of color.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of the <code>sg</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes() 
edges &lt;- sg_make_edges(nodes, 20)

sigmajs() %&gt;% 
  sg_nodes(nodes, id, size) %&gt;% 
  sg_scale_color(pal = c("red", "blue"))

</code></pre>

<hr>
<h2 id='force'>Add forceAtlas2</h2><span id='topic+force'></span><span id='topic+sg_force'></span><span id='topic+sg_force_start'></span><span id='topic+sg_force_stop'></span><span id='topic+sg_force_restart_p'></span><span id='topic+sg_force_restart'></span><span id='topic+sg_force_start_p'></span><span id='topic+sg_force_stop_p'></span><span id='topic+sg_force_kill_p'></span><span id='topic+sg_force_config_p'></span>

<h3>Description</h3>

<p>Implementation of <a href="http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0098679">forceAtlas2</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_force(sg, ...)

sg_force_start(sg, ...)

sg_force_stop(sg, delay = 5000)

sg_force_restart_p(proxy, ..., refresh = TRUE)

sg_force_restart(sg, data, delay, cumsum = TRUE)

sg_force_start_p(proxy, ..., refresh = TRUE)

sg_force_stop_p(proxy)

sg_force_kill_p(proxy)

sg_force_config_p(proxy, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="force_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="force_+3A_...">...</code></td>
<td>
<p>Any parameter, see <a href="https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.layout.forceAtlas2">official documentation</a>.</p>
</td></tr>
<tr><td><code id="force_+3A_delay">delay</code></td>
<td>
<p>Milliseconds after which the layout algorithm should stop running.</p>
</td></tr>
<tr><td><code id="force_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="force_+3A_refresh">refresh</code></td>
<td>
<p>Whether to refresh the graph after node is dropped, required to take effect.</p>
</td></tr>
<tr><td><code id="force_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> holding <code>delay</code> column.</p>
</td></tr>
<tr><td><code id="force_+3A_cumsum">cumsum</code></td>
<td>
<p>Whether to compute the cumulative sum of the delay.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The delay helps for build dynamic visualisations where nodes and edges do not appear all at the same time.
How the delay works depends on the <code>cumsum</code> parameter. if <code>TRUE</code> the function computes the cumulative sum
of the delay to effectively add each row one after the other: delay is thus applied at each row (number of seconds to wait
before the row is added *since the previous row*). If <code>FALSE</code> this is the number of milliseconds to wait before the node or
edge is added to the visualisation; <code>delay</code> is used as passed to the function.
</p>


<h3>Value</h3>

<p>Their first arguments, either <code>sg</code> or <code>proxy</code>.
</p>


<h3>Functions</h3>


<ul>
<li><p><code>sg_force</code>, <code>sg_force_start</code> starts the forceAtlas2 layout
</p>
</li>
<li><p><code>sg_force_stop</code> stops the forceAtlas2 layout after a <code>delay</code> milliseconds
</p>
</li>
<li><p><code>sg_force_restart_p</code> proxy to re-starts (<code>kill</code> then <code>start</code>) the forceAtlas2 layout, the options you pass to this function are applied on restart. If forceAtlas2 has not started yet it is launched.
</p>
</li>
<li><p><code>sg_force_start_p</code> proxy to start forceAtlas2.
</p>
</li>
<li><p><code>sg_force_stop_p</code> proxy to stop forceAtlas2.
</p>
</li>
<li><p><code>sg_force_kill_p</code> proxy to ompletely stops the layout and terminates the assiociated worker. You can still restart it later, but a new worker will have to initialize.
</p>
</li>
<li><p><code>sg_force_config_p</code> proxy to set configurations of forceAtlas2.
</p>
</li>
<li><p><code>sg_force_restart</code> Restarts (kills then starts) forceAtlas2 at given delay.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.layout.noverlap">official documentation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes(50)
edges &lt;- sg_make_edges(nodes, 100)

sigmajs() %&gt;%
  sg_nodes(nodes, id, label, size) %&gt;%
  sg_edges(edges, id, source, target) %&gt;% 
  sg_force() %&gt;% 
  sg_force_stop() # stop force after 5 seconds

</code></pre>

<hr>
<h2 id='lesmis_edges'>Edges from co-appearances of characters in &quot;Les Miserables&quot;</h2><span id='topic+lesmis_edges'></span>

<h3>Description</h3>

<p>A graph where the nodes are characters in &quot;Les Miserables&quot; updated from its first encoding 
by Professor Donald Knuth, as part of the Stanford Graph Base (SGB)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lesmis_edges
</code></pre>


<h3>Format</h3>

<p>An igraph object with 181 nodes and 4 variables
</p>

<dl>
<dt><code>source</code></dt><dd><p> abbreviation of character name</p>
</dd>
<dt><code>target</code></dt><dd><p> abbreviation of character name</p>
</dd>
<dt><code>id</code></dt><dd><p> unique edge id</p>
</dd>
<dt><code>label</code></dt><dd><p> edge label</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/MADStudioNU/lesmiserables-character-network">https://github.com/MADStudioNU/lesmiserables-character-network</a>
</p>

<hr>
<h2 id='lesmis_igraph'>Co-appearances of characters in &quot;Les Miserables&quot; as igraph object</h2><span id='topic+lesmis_igraph'></span>

<h3>Description</h3>

<p>A graph where the nodes are characters in &quot;Les Miserables&quot; updated from its first encoding 
by Professor Donald Knuth, as part of the Stanford Graph Base (SGB)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lesmis_igraph
</code></pre>


<h3>Format</h3>

<p>An igraph object with 181 nodes and 1589 edges
</p>

<dl>
<dt><code>id</code></dt><dd><p> abbreviation of character name</p>
</dd>
<dt><code>label</code></dt><dd><p> character name</p>
</dd>
<dt><code>color</code></dt><dd><p> random color</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/MADStudioNU/lesmiserables-character-network">https://github.com/MADStudioNU/lesmiserables-character-network</a>
</p>

<hr>
<h2 id='lesmis_nodes'>Nodes from co-appearances of characters in &quot;Les Miserables&quot;</h2><span id='topic+lesmis_nodes'></span>

<h3>Description</h3>

<p>A graph where the nodes are characters in &quot;Les Miserables&quot; updated from its first encoding 
by Professor Donald Knuth, as part of the Stanford Graph Base (SGB)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lesmis_nodes
</code></pre>


<h3>Format</h3>

<p>An igraph object with 181 nodes and 2 variables
</p>

<dl>
<dt><code>id</code></dt><dd><p> abbreviation of character name</p>
</dd>
<dt><code>label</code></dt><dd><p> character name</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/MADStudioNU/lesmiserables-character-network">https://github.com/MADStudioNU/lesmiserables-character-network</a>
</p>

<hr>
<h2 id='read'>Read</h2><span id='topic+read'></span><span id='topic+sg_read_nodes_p'></span><span id='topic+sg_read_edges_p'></span><span id='topic+sg_read_exec_p'></span>

<h3>Description</h3>

<p>Read nodes and edges to add to the graph. Other proxy methods to add data to a graph have to add nodes and edges one by one, 
thereby draining the browser, this method will add multiple nodes and edges more efficiently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_read_nodes_p(proxy, data, ...)

sg_read_edges_p(proxy, data, ...)

sg_read_exec_p(proxy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="read_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> of _one_ node or edge.</p>
</td></tr>
<tr><td><code id="read_+3A_...">...</code></td>
<td>
<p>any column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>proxy</code> object.
</p>


<h3>Functions</h3>


<ul>
<li><p><code>sg_read_nodes_p</code> read nodes.
</p>
</li>
<li><p><code>sg_read_edges_p</code> read edges.
</p>
</li>
<li><p><code>sg_read_exec_p</code> send read nodes and edges to JavaScript front end.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)

ui &lt;- fluidPage(
	actionButton("add", "add nodes &amp; edges"),
	sigmajsOutput("sg")
)

server &lt;- function(input, output, session){

	nodes &lt;- sg_make_nodes()
	edges &lt;- sg_make_edges(nodes)

	output$sg &lt;- renderSigmajs({
		sigmajs() %&gt;% 
			sg_nodes(nodes, id, label, color, size) %&gt;% 
			sg_edges(edges, id, source, target) %&gt;% 
			sg_layout()
	})

	i &lt;- 10

	observeEvent(input$add, {
		new_nodes &lt;- sg_make_nodes()
		new_nodes$id &lt;- as.character(as.numeric(new_nodes$id) + i)
		i &lt;&lt;- i + 10
		ids &lt;- 1:(i)
		new_edges &lt;- data.frame(
			id = as.character((i * 2 + 15):(i * 2 + 29)),
			source = as.character(sample(ids, 15)),
			target = as.character(sample(ids, 15))
		)
		
		sigmajsProxy("sg") %&gt;% 
			sg_force_kill_p() %&gt;% 
			sg_read_nodes_p(new_nodes, id, label, color, size) %&gt;% 
			sg_read_edges_p(new_edges, id, source, target) %&gt;% 
			sg_read_exec_p() %&gt;% 
			sg_force_start_p() %&gt;% 
			sg_refresh_p()
	})

}

if(interactive()) shinyApp(ui, server)

</code></pre>

<hr>
<h2 id='read-batch'>Batch read</h2><span id='topic+read-batch'></span><span id='topic+sg_read_delay_nodes_p'></span><span id='topic+sg_read_delay_edges_p'></span><span id='topic+sg_read_delay_exec_p'></span>

<h3>Description</h3>

<p>Read nodes and edges by batch with a delay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_read_delay_nodes_p(proxy, data, ..., delay)

sg_read_delay_edges_p(proxy, data, ..., delay)

sg_read_delay_exec_p(proxy, refresh = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read-batch_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="read-batch_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> of nodes or edges to add to the graph.</p>
</td></tr>
<tr><td><code id="read-batch_+3A_...">...</code></td>
<td>
<p>any column.</p>
</td></tr>
<tr><td><code id="read-batch_+3A_delay">delay</code></td>
<td>
<p>Column name of containing batch identifier.</p>
</td></tr>
<tr><td><code id="read-batch_+3A_refresh">refresh</code></td>
<td>
<p>Whether to refresh the graph after each batch (<code>delay</code>) has been added to the graph.
Note that this will also automatically restart any running force layout.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Add nodes and edges with <code>sg_read_delay_nodes_p</code> and <code>sg_read_delay_edges_p</code> then execute (send to JavaScript end) with <code>sg_read_delay_exec_p</code>.
</p>


<h3>Value</h3>

<p>The <code>proxy</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)

ui &lt;- fluidPage(
	actionButton("add", "add nodes &amp; edges"),
	sigmajsOutput("sg")
)

server &lt;- function(input, output, session){

	output$sg &lt;- renderSigmajs({
		sigmajs()
	})

	observeEvent(input$add, {
		nodes &lt;- sg_make_nodes(50)
		nodes$batch &lt;- c(
			rep(1000, 25),
			rep(3000, 25)
		)

		edges &lt;- data.frame(
			id = 1:80,
			source = c(
				sample(1:25, 40, replace = TRUE),
				sample(1:50, 40, replace = TRUE)
			),
			target = c(
				sample(1:25, 40, replace = TRUE),
				sample(1:50, 40, replace = TRUE)
			),
			batch = c(
				rep(1000, 40),
				rep(3000, 40)
			)
		) %&gt;% 
		dplyr::mutate_all(as.character)

		sigmajsProxy("sg") %&gt;% 
     sg_force_start_p() %&gt;% 
			sg_read_delay_nodes_p(nodes, id, color, label, size, delay = batch) %&gt;% 
			sg_read_delay_edges_p(edges, id, source, target, delay = batch) %&gt;% 
			sg_read_delay_exec_p()  %&gt;% 
			sg_force_stop_p()
	})

}

if(interactive()) shinyApp(ui, server)

</code></pre>

<hr>
<h2 id='read-static'>Read</h2><span id='topic+read-static'></span><span id='topic+sg_read_nodes'></span><span id='topic+sg_read_edges'></span><span id='topic+sg_read_exec'></span>

<h3>Description</h3>

<p>Read nodes and edges into your graph, with or without a delay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_read_nodes(sg, data, ..., delay)

sg_read_edges(sg, data, ..., delay)

sg_read_exec(sg, refresh = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read-static_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="read-static_+3A_data">data</code></td>
<td>
<p>Data.frame (or list) of nodes or edges.</p>
</td></tr>
<tr><td><code id="read-static_+3A_...">...</code></td>
<td>
<p>Any column name, see details.</p>
</td></tr>
<tr><td><code id="read-static_+3A_delay">delay</code></td>
<td>
<p>Column name containing delay in milliseconds.</p>
</td></tr>
<tr><td><code id="read-static_+3A_refresh">refresh</code></td>
<td>
<p>Whether to refresh the <code><a href="#topic+force">force</a></code> layout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of the <code>sg</code> object.
</p>


<h3>Functions</h3>


<ul>
<li><p><code>sg_read_nodes</code> read nodes.
</p>
</li>
<li><p><code>sg_read_edges</code> read edges.
</p>
</li>
<li><p><code>sg_read_exec</code> send read nodes and edges to JavaScript front end.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes(50)
 nodes$batch &lt;- c(
	 rep(1000, 25),
	 rep(3000, 25)
	)

edges &lt;- data.frame(
 id = 1:80,
	 source = c(
	  sample(1:25, 40, replace = TRUE),
		sample(1:50, 40, replace = TRUE)
	 ),
	 target = c(
	  sample(1:25, 40, replace = TRUE),
		sample(1:50, 40, replace = TRUE)
	 ),
	 batch = c(
	  rep(1000, 40),
		rep(3000, 40)
	 )
) %&gt;% 
 dplyr::mutate_all(as.character)

sigmajs() %&gt;% 
  sg_force_start() %&gt;% 
  sg_read_nodes(nodes, id, label, color, size, delay = batch) %&gt;% 
  sg_read_edges(edges, id, source, target, delay = batch) %&gt;% 
	 sg_force_stop(4000) %&gt;% 
  sg_read_exec() %&gt;% 
	 sg_button("read_exec", "Add nodes &amp; edges")

</code></pre>

<hr>
<h2 id='sg_add_images'>Add images to nodes</h2><span id='topic+sg_add_images'></span>

<h3>Description</h3>

<p>Add images to nodes with the <a href="https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.renderers.customShapes">Custom Shapes plugin</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_add_images(sg, data, url, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_add_images_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_add_images_+3A_data">data</code></td>
<td>
<p>Data.frame containing columns.</p>
</td></tr>
<tr><td><code id="sg_add_images_+3A_url">url</code></td>
<td>
<p>URL of image.</p>
</td></tr>
<tr><td><code id="sg_add_images_+3A_...">...</code></td>
<td>
<p>Any other column.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.renderers.customShapes">Official documentation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo("custom-shapes", package = "sigmajs")

## End(Not run)

</code></pre>

<hr>
<h2 id='sg_add_node_p'>Add node or edge</h2><span id='topic+sg_add_node_p'></span><span id='topic+sg_add_edge_p'></span>

<h3>Description</h3>

<p>Proxies to dynamically add a node or an edge to an already existing graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_add_node_p(proxy, data, ..., refresh = TRUE)

sg_add_edge_p(proxy, data, ..., refresh = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_add_node_p_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="sg_add_node_p_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> of _one_ node or edge.</p>
</td></tr>
<tr><td><code id="sg_add_node_p_+3A_...">...</code></td>
<td>
<p>any column.</p>
</td></tr>
<tr><td><code id="sg_add_node_p_+3A_refresh">refresh</code></td>
<td>
<p>Whether to refresh the graph after node is dropped, required to take effect, if you are running force the algorithm is killed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>proxy</code> object.
</p>


<h3>Note</h3>

<p>Have the parameters from your initial graph match that of the node you add, i.e.: if you pass <code>size</code> in your initial chart,
make sure you also have it in your proxy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo("add-node", package = "sigmajs")
demo("add-edge", package = "sigmajs")
demo("add-node-edge", package = "sigmajs")

## End(Not run)

</code></pre>

<hr>
<h2 id='sg_add_nodes'>Add nodes and edges</h2><span id='topic+sg_add_nodes'></span><span id='topic+sg_add_edges'></span>

<h3>Description</h3>

<p>Add nodes or edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_add_nodes(sg, data, delay, ..., cumsum = TRUE)

sg_add_edges(sg, data, delay, ..., cumsum = TRUE, refresh = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_add_nodes_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_add_nodes_+3A_data">data</code></td>
<td>
<p>Data.frame (or list) of nodes or edges.</p>
</td></tr>
<tr><td><code id="sg_add_nodes_+3A_delay">delay</code></td>
<td>
<p>Column name containing delay in milliseconds.</p>
</td></tr>
<tr><td><code id="sg_add_nodes_+3A_...">...</code></td>
<td>
<p>Any column name, see details.</p>
</td></tr>
<tr><td><code id="sg_add_nodes_+3A_cumsum">cumsum</code></td>
<td>
<p>Whether to compute the cumulative sum of the delay.</p>
</td></tr>
<tr><td><code id="sg_add_nodes_+3A_refresh">refresh</code></td>
<td>
<p>Whether to refresh the graph after node is dropped, required to take effect, if you are running force the algorithm is killed and restarted at every iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The delay helps for build dynamic visualisations where nodes and edges do not appear all at the same time.
How the delay works depends on the <code>cumsum</code> parameter. if <code>TRUE</code> the function computes the cumulative sum
of the delay to effectively add each row one after the other: delay is thus applied at each row (number of seconds to wait
before the row is added *since the previous row*). If <code>FALSE</code> this is the number of milliseconds to wait before the node or
edge is added to the visualisation; <code>delay</code> is used as passed to the function.
</p>


<h3>Value</h3>

<p>A modified version of the <code>sg</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># initial nodes
nodes &lt;- sg_make_nodes()

# additional nodes
nodes2 &lt;- sg_make_nodes()
nodes2$id &lt;- as.character(seq(11, 20))

# add delay
nodes2$delay &lt;- runif(nrow(nodes2), 500, 1000)

sigmajs() %&gt;%
  sg_nodes(nodes, id, label, size, color) %&gt;%
  sg_add_nodes(nodes2, delay, id, label, size, color)
  
edges &lt;- sg_make_edges(nodes, 25)
edges$delay &lt;- runif(nrow(edges), 100, 2000)

sigmajs() %&gt;%
  sg_force_start() %&gt;%
  sg_nodes(nodes, id, label, size, color) %&gt;% 
  sg_add_edges(edges, delay, id, source, target, cumsum = FALSE) %&gt;%
  sg_force_stop(2300) # stop after all edges added

</code></pre>

<hr>
<h2 id='sg_add_nodes_delay_p'>Add nodes or edges with a delay</h2><span id='topic+sg_add_nodes_delay_p'></span><span id='topic+sg_add_edges_delay_p'></span>

<h3>Description</h3>

<p>Proxies to dynamically add multiple nodes or edges to an already existing graph with a *delay* between each addition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_add_nodes_delay_p(proxy, data, delay, ..., refresh = TRUE, cumsum = TRUE)

sg_add_edges_delay_p(proxy, data, delay, ..., refresh = TRUE, cumsum = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_add_nodes_delay_p_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="sg_add_nodes_delay_p_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> of _one_ node or edge.</p>
</td></tr>
<tr><td><code id="sg_add_nodes_delay_p_+3A_delay">delay</code></td>
<td>
<p>Column name containing delay in milliseconds.</p>
</td></tr>
<tr><td><code id="sg_add_nodes_delay_p_+3A_...">...</code></td>
<td>
<p>any column.</p>
</td></tr>
<tr><td><code id="sg_add_nodes_delay_p_+3A_refresh">refresh</code></td>
<td>
<p>Whether to refresh the graph after node is dropped, required to take effect, if you are running force the algorithm is killed and restarted at every iteration.</p>
</td></tr>
<tr><td><code id="sg_add_nodes_delay_p_+3A_cumsum">cumsum</code></td>
<td>
<p>Whether to compute the cumulative sum of the delay.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The delay helps for build dynamic visualisations where nodes and edges do not appear all at the same time.
How the delay works depends on the <code>cumsum</code> parameter. if <code>TRUE</code> the function computes the cumulative sum
of the delay to effectively add each row one after the other: delay is thus applied at each row (number of seconds to wait
before the row is added *since the previous row*). If <code>FALSE</code> this is the number of milliseconds to wait before the node or
edge is added to the visualisation; <code>delay</code> is used as passed to the function.
</p>


<h3>Value</h3>

<p>The <code>proxy</code> object.
</p>


<h3>Note</h3>

<p>Have the parameters from your initial graph match that of the node you add, i.e.: if you pass <code>size</code> in your initial chart,
make sure you also have it in your proxy.
</p>

<hr>
<h2 id='sg_add_nodes_p'>Add nodes or edges</h2><span id='topic+sg_add_nodes_p'></span><span id='topic+sg_add_edges_p'></span>

<h3>Description</h3>

<p>Proxies to dynamically add *multiple* nodes or edges to an already existing graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_add_nodes_p(proxy, data, ..., refresh = TRUE, rate = "once")

sg_add_edges_p(proxy, data, ..., refresh = TRUE, rate = "once")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_add_nodes_p_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="sg_add_nodes_p_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> of nodes or edges.</p>
</td></tr>
<tr><td><code id="sg_add_nodes_p_+3A_...">...</code></td>
<td>
<p>any column.</p>
</td></tr>
<tr><td><code id="sg_add_nodes_p_+3A_refresh">refresh</code></td>
<td>
<p>Whether to refresh the graph after node is dropped, required to take effect, if you are running force the algorithm is killed and restarted at every iteration..</p>
</td></tr>
<tr><td><code id="sg_add_nodes_p_+3A_rate">rate</code></td>
<td>
<p>Refresh rate, either <code>once</code>, the graph is refreshed after data.frame of nodes is added or at each <code>iteration</code> (row-wise). Only applies if <code>refresh</code> is set to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>proxy</code> object.
</p>


<h3>Note</h3>

<p>Have the parameters from your initial graph match that of the node you add, i.e.: if you pass <code>size</code> in your initial chart,
make sure you also have it in your proxy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo("add-nodes", package = "sigmajs")
demo("add-edges", package = "sigmajs")

## End(Not run)

</code></pre>

<hr>
<h2 id='sg_animate'>Animate</h2><span id='topic+sg_animate'></span>

<h3>Description</h3>

<p>Animate graph components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_animate(sg, mapping, options = list(easing = "cubicInOut"), delay = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_animate_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_animate_+3A_mapping">mapping</code></td>
<td>
<p>Variables to map animation to.</p>
</td></tr>
<tr><td><code id="sg_animate_+3A_options">options</code></td>
<td>
<p>Animations options.</p>
</td></tr>
<tr><td><code id="sg_animate_+3A_delay">delay</code></td>
<td>
<p>Delay in milliseconds before animation is triggered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can animate, <code>x</code>, <code>y</code>, <code>size</code> and <code>color</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>htmlwidget</code> which renders the visualisation on print.
</p>


<h3>See Also</h3>

<p><a href="https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.plugins.animate">official documentation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate graph
nodes &lt;- sg_make_nodes(20)
edges &lt;- sg_make_edges(nodes, 30)

# add transition
n &lt;- nrow(nodes)
nodes$to_x &lt;- runif(n, 5, 10)
nodes$to_y &lt;- runif(n, 5, 10)
nodes$to_size &lt;- runif(n, 5, 10)

sigmajs() %&gt;%
  sg_nodes(nodes, id, label, size, color, to_x, to_y, to_size) %&gt;%
  sg_edges(edges, id, source, target) %&gt;% 
  sg_animate(mapping = list(x = "to_x", y = "to_y", size = "to_size"))

</code></pre>

<hr>
<h2 id='sg_button'>Buttons</h2><span id='topic+sg_button'></span>

<h3>Description</h3>

<p>Add buttons to your graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_button(
  sg,
  event,
  ...,
  position = "top",
  class = "btn btn-default",
  tag = htmltools::tags$button,
  id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_button_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_button_+3A_event">event</code></td>
<td>
<p>Event the button triggers, see valid events.</p>
</td></tr>
<tr><td><code id="sg_button_+3A_...">...</code></td>
<td>
<p>Content of the button, complient with <code>htmltools</code>.</p>
</td></tr>
<tr><td><code id="sg_button_+3A_position">position</code></td>
<td>
<p>Position of button, <code>top</code> or <code>bottom</code>.</p>
</td></tr>
<tr><td><code id="sg_button_+3A_class">class</code></td>
<td>
<p>Button <code>CSS</code> class, see note.</p>
</td></tr>
<tr><td><code id="sg_button_+3A_tag">tag</code></td>
<td>
<p>A Valid <code>htmltools</code> tags function.</p>
</td></tr>
<tr><td><code id="sg_button_+3A_id">id</code></td>
<td>
<p>A valid CSS id.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can pass multiple events as a vector, see examples. You can also pass multiple buttons.
</p>


<h3>Value</h3>

<p>An object of class <code>htmlwidget</code> which renders the visualisation on print.
</p>


<h3>Events</h3>


<ul>
<li><p><code>force_start</code>
</p>
</li>
<li><p><code>force_stop</code>
</p>
</li>
<li><p><code>noverlap</code>
</p>
</li>
<li><p><code>drag_nodes</code>
</p>
</li>
<li><p><code>relative_size</code>
</p>
</li>
<li><p><code>add_nodes</code>
</p>
</li>
<li><p><code>add_edges</code>
</p>
</li>
<li><p><code>drop_nodes</code>
</p>
</li>
<li><p><code>drop_edges</code>
</p>
</li>
<li><p><code>animate</code>
</p>
</li>
<li><p><code>export_svg</code>
</p>
</li>
<li><p><code>export_img</code>
</p>
</li>
<li><p><code>progress</code>
</p>
</li>
<li><p><code>read_exec</code>
</p>
</li></ul>



<h3>Note</h3>

<p>The default class (<code>btn btn-default</code>) works with Bootstrap 3 (the default framework for Shiny and R markdown).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes() 
edges &lt;- sg_make_edges(nodes)

# Button starts the layout and stops it after 3 seconds
sigmajs() %&gt;% 
  sg_nodes(nodes, id, size) %&gt;% 
  sg_edges(edges, id, source, target) %&gt;% 
  sg_force_start() %&gt;% 
  sg_force_stop(3000) %&gt;% 
  sg_button(c("force_start", "force_stop"), "start layout")
  
# additional nodes
nodes2 &lt;- sg_make_nodes()
nodes2$id &lt;- as.character(seq(11, 20))

# add delay
nodes2$delay &lt;- runif(nrow(nodes2), 500, 1000)

sigmajs() %&gt;%
  sg_nodes(nodes, id, label, size, color) %&gt;%
  sg_add_nodes(nodes2, delay, id, label, size, color) %&gt;% 
  sg_force_start() %&gt;% 
  sg_force_stop(3000) %&gt;% 
  sg_button(c("force_start", "force_stop"), "start layout") %&gt;% 
  sg_button("add_nodes", "add nodes")

</code></pre>

<hr>
<h2 id='sg_change_nodes_p'>Change</h2><span id='topic+sg_change_nodes_p'></span><span id='topic+sg_change_edges_p'></span>

<h3>Description</h3>

<p>Change nodes and edges attributes on the fly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_change_nodes_p(
  proxy,
  data,
  value,
  attribute,
  rate = c("once", "iteration"),
  refresh = TRUE
)

sg_change_edges_p(
  proxy,
  data,
  value,
  attribute,
  rate = c("once", "iteration"),
  refresh = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_change_nodes_p_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="sg_change_nodes_p_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> holding <code>delay</code> column.</p>
</td></tr>
<tr><td><code id="sg_change_nodes_p_+3A_value">value</code></td>
<td>
<p>Column containing value.</p>
</td></tr>
<tr><td><code id="sg_change_nodes_p_+3A_attribute">attribute</code></td>
<td>
<p>Name of attribute to change.</p>
</td></tr>
<tr><td><code id="sg_change_nodes_p_+3A_rate">rate</code></td>
<td>
<p>Rate at chich to refresh takes <code>once</code> refreshes once after all <code>values</code> have been changed, 
and <code>iteration</code> which refreshes at every iteration.</p>
</td></tr>
<tr><td><code id="sg_change_nodes_p_+3A_refresh">refresh</code></td>
<td>
<p>Whether to refresh the graph after the change is made.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(shiny)

nodes &lt;- sg_make_nodes()
nodes$new_color &lt;- "red"
edges &lt;- sg_make_edges(nodes)

ui &lt;- fluidPage(
  actionButton("start", "Change color"), 
  sigmajsOutput("sg")
) 

server &lt;- function(input, output){

  output$sg &lt;- renderSigmajs({
    sigmajs() %&gt;%
      sg_nodes(nodes, id, size, color) %&gt;%
      sg_edges(edges, id, source, target)
  })

  observeEvent(input$start, {
    sigmajsProxy("sg") %&gt;% # use sigmajsProxy!
      sg_change_nodes_p(nodes, new_color, "color")
  })

}

 if(interactive()) shinyApp(ui, server) # run

</code></pre>

<hr>
<h2 id='sg_clear_p'>Clear or kill the graph</h2><span id='topic+sg_clear_p'></span><span id='topic+sg_kill_p'></span><span id='topic+sg_kill'></span><span id='topic+sg_clear'></span>

<h3>Description</h3>

<p>Clear all nodes and edges from the graph or kills the graph.
</p>
<p>Kill the graph to ensure new data is redrawn, useful in Shiny 
when graph is not updated by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_clear_p(proxy, refresh = TRUE)

sg_kill_p(proxy, refresh = TRUE)

sg_kill(sg)

sg_clear(sg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_clear_p_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="sg_clear_p_+3A_refresh">refresh</code></td>
<td>
<p>Whether to refresh the graph after node is dropped, required to take effect, if you are running force the algorithm is killed and restarted.</p>
</td></tr>
<tr><td><code id="sg_clear_p_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>proxy</code> object.
</p>
<p>A modified version of the <code>sg</code> object.
</p>

<hr>
<h2 id='sg_cluster'>Cluster</h2><span id='topic+sg_cluster'></span><span id='topic+sg_get_cluster'></span>

<h3>Description</h3>

<p>Color nodes by cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_cluster(
  sg,
  colors = c("#B1E2A3", "#98D3A5", "#328983", "#1C5C70", "#24C96B"),
  directed = TRUE,
  algo = igraph::cluster_walktrap,
  quiet = !interactive(),
  save_igraph = TRUE,
  ...
)

sg_get_cluster(
  nodes,
  edges,
  colors = c("#B1E2A3", "#98D3A5", "#328983", "#1C5C70", "#24C96B"),
  directed = TRUE,
  algo = igraph::cluster_walktrap,
  quiet = !interactive(),
  save_igraph = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_cluster_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_cluster_+3A_colors">colors</code></td>
<td>
<p>Palette to color the nodes.</p>
</td></tr>
<tr><td><code id="sg_cluster_+3A_directed">directed</code></td>
<td>
<p>Whether or not to create a directed graph, passed to <code><a href="igraph.html#topic+graph_from_data_frame">graph_from_data_frame</a></code>.</p>
</td></tr>
<tr><td><code id="sg_cluster_+3A_algo">algo</code></td>
<td>
<p>An <code>igraph</code> clustering function.</p>
</td></tr>
<tr><td><code id="sg_cluster_+3A_quiet">quiet</code></td>
<td>
<p>Set to <code>TRUE</code> to print the number of clusters to the console.</p>
</td></tr>
<tr><td><code id="sg_cluster_+3A_save_igraph">save_igraph</code></td>
<td>
<p>Whether to save the <code>igraph</code> object used internally.</p>
</td></tr>
<tr><td><code id="sg_cluster_+3A_...">...</code></td>
<td>
<p>Any parameter to pass to <code>algo</code>.</p>
</td></tr>
<tr><td><code id="sg_cluster_+3A_nodes">nodes</code>, <code id="sg_cluster_+3A_edges">edges</code></td>
<td>
<p>Nodes and edges as prepared for sigmajs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The package uses <code>igraph</code> internally for a lot of computations the <code>save_igraph</code> 
allows saving the object to speed up subsequent computations.
</p>


<h3>Value</h3>

<p><code>sg_get_cluster</code> returns nodes with <code>color</code> variable while 
<code>sg_cluster</code> returns an object of class <code>htmlwidget</code> which renders 
the visualisation on print.
</p>


<h3>Functions</h3>


<ul>
<li><p><code>sg_cluster</code> Color nodes by cluster.
</p>
</li>
<li><p><code>sg_get_cluster</code> helper to get graph's nodes color by cluster.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes() 
edges &lt;- sg_make_edges(nodes, 15)

sigmajs() %&gt;% 
  sg_nodes(nodes, id, size) %&gt;% 
  sg_edges(edges, id, source, target) %&gt;% 
  sg_layout() %&gt;% 
  sg_cluster() 
  
clustered &lt;- sg_get_cluster(nodes, edges)

</code></pre>

<hr>
<h2 id='sg_custom_shapes'>Custom shapes</h2><span id='topic+sg_custom_shapes'></span>

<h3>Description</h3>

<p>Indicate a graph uses custom shapes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_custom_shapes(sg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_custom_shapes_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='sg_drag_nodes'>Drag nodes</h2><span id='topic+sg_drag_nodes'></span><span id='topic+sg_drag_nodes_start_p'></span><span id='topic+sg_drag_nodes_kill_p'></span>

<h3>Description</h3>

<p>Allow user to drag and drop nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_drag_nodes(sg)

sg_drag_nodes_start_p(proxy)

sg_drag_nodes_kill_p(proxy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_drag_nodes_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_drag_nodes_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sg_drag_nodes</code> An object of class <code>htmlwidget</code> which renders the visualisation on print.
While <code>sg_drag_nodes_start_p</code> and <code>sg_drag_nodes_kill_p</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate graph
nodes &lt;- sg_make_nodes(20)
edges &lt;- sg_make_edges(nodes, 35)

sigmajs() %&gt;%
  sg_nodes(nodes, id, label, size) %&gt;%
  sg_edges(edges, id, source, target) %&gt;%
  sg_drag_nodes()

## Not run: 
# proxies
demo("drag-nodes", package = "sigmajs")

## End(Not run)

</code></pre>

<hr>
<h2 id='sg_drop_node_p'>Remove node or edge</h2><span id='topic+sg_drop_node_p'></span><span id='topic+sg_drop_edge_p'></span>

<h3>Description</h3>

<p>Proxies to dynamically remove a node or an edge to an already existing graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_drop_node_p(proxy, id, refresh = TRUE)

sg_drop_edge_p(proxy, id, refresh = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_drop_node_p_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="sg_drop_node_p_+3A_id">id</code></td>
<td>
<p>Id of edge or node to delete.</p>
</td></tr>
<tr><td><code id="sg_drop_node_p_+3A_refresh">refresh</code></td>
<td>
<p>Whether to refresh the graph after node is dropped, required to take effect, if you are running force the algorithm is killed and restarted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>proxy</code> object.
</p>

<hr>
<h2 id='sg_drop_nodes'>Drop</h2><span id='topic+sg_drop_nodes'></span><span id='topic+sg_drop_edges'></span>

<h3>Description</h3>

<p>Drop nodes or edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_drop_nodes(sg, data, ids, delay, cumsum = TRUE)

sg_drop_edges(sg, data, ids, delay, cumsum = TRUE, refresh = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_drop_nodes_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_+3A_data">data</code></td>
<td>
<p>Data.frame (or list) of nodes or edges.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_+3A_ids">ids</code></td>
<td>
<p>Ids of elements to drop.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_+3A_delay">delay</code></td>
<td>
<p>Column name containing delay in milliseconds.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_+3A_cumsum">cumsum</code></td>
<td>
<p>Whether to compute the cumulative sum of the delay.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_+3A_refresh">refresh</code></td>
<td>
<p>Whether to refresh the graph after node is dropped, required to take effect, if you are running force the algorithm is killed and restarted at every iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The delay helps for build dynamic visualisations where nodes and edges do not disappear all at the same time.
How the delay works depends on the <code>cumsum</code> parameter. if <code>TRUE</code> the function computes the cumulative sum
of the delay to effectively drop each row one after the other: delay is thus applied at each row (number of seconds to wait
before the row is dropped *since the previous row*). If <code>FALSE</code> this is the number of milliseconds to wait before the node or
edge is dropped to the visualisation; <code>delay</code> is used as passed to the function.
</p>


<h3>Value</h3>

<p>A modified version of the <code>sg</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes(75)

# nodes to drop
nodes2 &lt;- nodes[sample(nrow(nodes), 50), ]
nodes2$delay &lt;- runif(nrow(nodes2), 1000, 3000)

sigmajs() %&gt;% 
  sg_nodes(nodes, id, size, color) %&gt;% 
  sg_drop_nodes(nodes2, id, delay, cumsum = FALSE)

</code></pre>

<hr>
<h2 id='sg_drop_nodes_delay_p'>Drop nodes or edges with a delay</h2><span id='topic+sg_drop_nodes_delay_p'></span><span id='topic+sg_drop_edges_delay_p'></span>

<h3>Description</h3>

<p>Proxies to dynamically drop multiple nodes or edges to an already existing graph with a *delay* between each removal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_drop_nodes_delay_p(proxy, data, ids, delay, refresh = TRUE, cumsum = TRUE)

sg_drop_edges_delay_p(proxy, data, ids, delay, refresh = TRUE, cumsum = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_drop_nodes_delay_p_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_delay_p_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> of _one_ node or edge.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_delay_p_+3A_ids">ids</code></td>
<td>
<p>Ids of elements to drop.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_delay_p_+3A_delay">delay</code></td>
<td>
<p>Column name containing delay in milliseconds.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_delay_p_+3A_refresh">refresh</code></td>
<td>
<p>Whether to refresh the graph after node is dropped, required to take effect, if you are running force the algorithm is killed and restarted at every iteration.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_delay_p_+3A_cumsum">cumsum</code></td>
<td>
<p>Whether to compute the cumulative sum of the delay.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The delay helps for build dynamic visualisations where nodes and edges do not disappear all at the same time.
How the delay works depends on the <code>cumsum</code> parameter. if <code>TRUE</code> the function computes the cumulative sum
of the delay to effectively drop each row one after the other: delay is thus applied at each row (number of seconds to wait
before the row is dropped *since the previous row*). If <code>FALSE</code> this is the number of milliseconds to wait before the node or
edge is added to the visualisation; <code>delay</code> is used as passed to the function.
</p>


<h3>Value</h3>

<p>The <code>proxy</code> object.
</p>


<h3>Note</h3>

<p>Have the parameters from your initial graph match that of the node you add, i.e.: if you pass <code>size</code> in your initial chart,
make sure you also have it in your proxy.
</p>

<hr>
<h2 id='sg_drop_nodes_p'>Drop nodes or edges</h2><span id='topic+sg_drop_nodes_p'></span><span id='topic+sg_drop_edges_p'></span>

<h3>Description</h3>

<p>Proxies to dynamically drop *multiple* nodes or edges from an already existing graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_drop_nodes_p(proxy, data, ids, refresh = TRUE, rate = "once")

sg_drop_edges_p(proxy, data, ids, refresh = TRUE, rate = "once")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_drop_nodes_p_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_p_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> of nodes or edges.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_p_+3A_ids">ids</code></td>
<td>
<p>Column containing ids to drop from the graph.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_p_+3A_refresh">refresh</code></td>
<td>
<p>Whether to refresh the graph after node is dropped, required to take effect.</p>
</td></tr>
<tr><td><code id="sg_drop_nodes_p_+3A_rate">rate</code></td>
<td>
<p>Refresh rate, either <code>once</code>, the graph is refreshed after data.frame of nodes is added or at each <code>iteration</code> (row-wise). Only applies if <code>refresh</code> is set to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>proxy</code> object.
</p>


<h3>Note</h3>

<p>Have the parameters from your initial graph match that of the node you add, i.e.: if you pass <code>size</code> in your initial chart,
make sure you also have it in your proxy.
</p>

<hr>
<h2 id='sg_events'>Events</h2><span id='topic+sg_events'></span>

<h3>Description</h3>

<p>Get events server-side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_events(sg, events)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_events_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_events_+3A_events">events</code></td>
<td>
<p>A vector of valid events (see section below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Events:
Valid events to pass to <code>events</code>.
</p>

<ul>
<li><p><code>clickNode</code>
</p>
</li>
<li><p><code>clickNodes</code>
</p>
</li>
<li><p><code>clickEdge</code>
</p>
</li>
<li><p><code>clickEdges</code>
</p>
</li>
<li><p><code>clickStage</code>
</p>
</li>
<li><p><code>doubleClickStage</code>
</p>
</li>
<li><p><code>rightClickStage</code>
</p>
</li>
<li><p><code>doubleClickNode</code>
</p>
</li>
<li><p><code>doubleClickNodes</code>  
</p>
</li>
<li><p><code>doubleClickEdge</code>
</p>
</li>
<li><p><code>doubleClickEdges</code>
</p>
</li>
<li><p><code>rightClickNode</code>
</p>
</li>
<li><p><code>rightClickNodes</code>
</p>
</li>
<li><p><code>rightClickEdge</code>
</p>
</li>
<li><p><code>rightClickEdges</code>
</p>
</li>
<li><p><code>hoverNode</code>
</p>
</li>
<li><p><code>hoverNodes</code>
</p>
</li>
<li><p><code>hoverEdge</code>
</p>
</li>
<li><p><code>hoverEdges</code>
</p>
</li>
<li><p><code>outNode</code>
</p>
</li>
<li><p><code>outNodes</code>
</p>
</li>
<li><p><code>outEdge</code>
</p>
</li>
<li><p><code>outEdges</code>
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>htmlwidget</code> which renders the visualisation on print.
</p>


<h3>See Also</h3>

<p><a href="https://github.com/jacomyal/sigma.js/wiki/Events-API">official documentation</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)

nodes &lt;- sg_make_nodes()
edges &lt;- sg_make_edges(nodes)

ui &lt;- fluidPage(
  sigmajsOutput("sg"),
  p("Click on a node"),
  verbatimTextOutput("clicked")
) 

server &lt;- function(input, output){
  output$sg &lt;- renderSigmajs({
    sigmajs() %&gt;%
      sg_nodes(nodes, id, size, color) %&gt;%
      sg_edges(edges, id, source, target) %&gt;% 
      sg_events("clickNode")
  })

# capture node clicked
output$clicked &lt;- renderPrint({
    input$sg_click_node
  })
}

## Not run: shinyApp(ui, server)

</code></pre>

<hr>
<h2 id='sg_export_svg'>Export</h2><span id='topic+sg_export_svg'></span><span id='topic+sg_export_img'></span><span id='topic+sg_export_img_p'></span><span id='topic+sg_export_svg_p'></span>

<h3>Description</h3>

<p>Export graph to SVG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_export_svg(
  sg,
  download = TRUE,
  file = "graph.svg",
  size = 1000,
  width = 1000,
  height = 1000,
  labels = FALSE,
  data = FALSE
)

sg_export_img(
  sg,
  download = TRUE,
  file = "graph.png",
  background = "white",
  format = "png",
  labels = FALSE
)

sg_export_img_p(
  proxy,
  download = TRUE,
  file = "graph.png",
  background = "white",
  format = "png",
  labels = FALSE
)

sg_export_svg_p(
  proxy,
  download = TRUE,
  file = "graph.svg",
  size = 1000,
  width = 1000,
  height = 1000,
  labels = FALSE,
  data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_export_svg_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_export_svg_+3A_download">download</code></td>
<td>
<p>set to <code>TRUE</code> to download.</p>
</td></tr>
<tr><td><code id="sg_export_svg_+3A_file">file</code></td>
<td>
<p>Name of file.</p>
</td></tr>
<tr><td><code id="sg_export_svg_+3A_size">size</code></td>
<td>
<p>Size of the SVG in pixels.</p>
</td></tr>
<tr><td><code id="sg_export_svg_+3A_width">width</code>, <code id="sg_export_svg_+3A_height">height</code></td>
<td>
<p>Width and height of the SVG in pixels.</p>
</td></tr>
<tr><td><code id="sg_export_svg_+3A_labels">labels</code></td>
<td>
<p>Whether the labels should be included in the svg file.</p>
</td></tr>
<tr><td><code id="sg_export_svg_+3A_data">data</code></td>
<td>
<p>Whether additional data (node ids for instance) should be included in the svg file.</p>
</td></tr>
<tr><td><code id="sg_export_svg_+3A_background">background</code></td>
<td>
<p>Background color of image.</p>
</td></tr>
<tr><td><code id="sg_export_svg_+3A_format">format</code></td>
<td>
<p>Format of image, takes <code>png</code>, <code>jpg</code>, <code>gif</code> or <code>tiff</code>.</p>
</td></tr>
<tr><td><code id="sg_export_svg_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>htmlwidget</code> which renders the visualisation on print.
Functions ending in <code>_p</code> return the <code>proxy</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes() 
edges &lt;- sg_make_edges(nodes, 17)

sigmajs() %&gt;% 
  sg_nodes(nodes, id, size) %&gt;% 
  sg_edges(edges, id, source, target) %&gt;% 
  sg_export_svg() %&gt;% 
  sg_button("export_svg", "download")

</code></pre>

<hr>
<h2 id='sg_filter_gt_p'>Filter</h2><span id='topic+sg_filter_gt_p'></span><span id='topic+sg_filter_lt_p'></span><span id='topic+sg_filter_eq_p'></span><span id='topic+sg_filter_not_eq_p'></span><span id='topic+sg_filter_undo_p'></span><span id='topic+sg_filter_neighbours_p'></span>

<h3>Description</h3>

<p>Filter nodes and/or edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_filter_gt_p(
  proxy,
  input,
  var,
  target = c("nodes", "edges", "both"),
  name = NULL
)

sg_filter_lt_p(
  proxy,
  input,
  var,
  target = c("nodes", "edges", "both"),
  name = NULL
)

sg_filter_eq_p(
  proxy,
  input,
  var,
  target = c("nodes", "edges", "both"),
  name = NULL
)

sg_filter_not_eq_p(
  proxy,
  input,
  var,
  target = c("nodes", "edges", "both"),
  name = NULL
)

sg_filter_undo_p(proxy, name)

sg_filter_neighbours_p(proxy, node, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_filter_gt_p_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="sg_filter_gt_p_+3A_input">input</code></td>
<td>
<p>A Shiny input.</p>
</td></tr>
<tr><td><code id="sg_filter_gt_p_+3A_var">var</code></td>
<td>
<p>Variable to filter.</p>
</td></tr>
<tr><td><code id="sg_filter_gt_p_+3A_target">target</code></td>
<td>
<p>Target of filter, <code>nodes</code>, <code>edges</code>, or <code>both</code>.</p>
</td></tr>
<tr><td><code id="sg_filter_gt_p_+3A_name">name</code></td>
<td>
<p>Name of the filter, useful to undo the filter later on with <code>sg_filter_undo</code>.</p>
</td></tr>
<tr><td><code id="sg_filter_gt_p_+3A_node">node</code></td>
<td>
<p>Node id to filter neighbours.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>proxy</code> object.
</p>


<h3>Functions</h3>


<ul>
<li><p><code>sg_filter_gt_p</code> Filter greater than <code>var</code>.
</p>
</li>
<li><p><code>sg_filter_lt_p</code> Filter less than <code>var</code>.
</p>
</li>
<li><p><code>sg_filter_eq_p</code> Filter equal to <code>var</code>.
</p>
</li>
<li><p><code>sg_filter_not_eq_p</code> Filter not equal to <code>var</code>.
</p>
</li>
<li><p><code>sg_filter_undo_p</code> Undo filters, accepts vector of <code>name</code>s.
</p>
</li></ul>


<hr>
<h2 id='sg_from_gexf'>Graph from GEXF file</h2><span id='topic+sg_from_gexf'></span>

<h3>Description</h3>

<p>Create a sigmajs graph from a GEXF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_from_gexf(sg, file, sd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_from_gexf_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_from_gexf_+3A_file">file</code></td>
<td>
<p>Path to GEXF file.</p>
</td></tr>
<tr><td><code id="sg_from_gexf_+3A_sd">sd</code></td>
<td>
<p>A <a href="crosstalk.html#topic+SharedData">SharedData</a> of nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of the <code>sg</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gexf &lt;- "https://gephi.org/gexf/data/yeast.gexf"

sigmajs() %&gt;% 
  sg_from_gexf(gexf) 

## End(Not run)

</code></pre>

<hr>
<h2 id='sg_from_igraph'>Create from igraph</h2><span id='topic+sg_from_igraph'></span>

<h3>Description</h3>

<p>Create a <code>sigmajs</code> from an <code>igraph</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_from_igraph(sg, igraph, layout = NULL, sd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_from_igraph_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_from_igraph_+3A_igraph">igraph</code></td>
<td>
<p>An object of class <code>igraph</code>.</p>
</td></tr>
<tr><td><code id="sg_from_igraph_+3A_layout">layout</code></td>
<td>
<p>A matrix of coordinates.</p>
</td></tr>
<tr><td><code id="sg_from_igraph_+3A_sd">sd</code></td>
<td>
<p>A <a href="crosstalk.html#topic+SharedData">SharedData</a> of nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of the <code>sg</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("lesmis_igraph")

layout &lt;- igraph::layout_with_fr(lesmis_igraph)

sigmajs() %&gt;%
	sg_from_igraph(lesmis_igraph, layout) %&gt;%
	sg_settings(defaultNodeColor = "#000")

## End(Not run)

</code></pre>

<hr>
<h2 id='sg_get_nodes_p'>Get nodes</h2><span id='topic+sg_get_nodes_p'></span><span id='topic+sg_get_edges_p'></span>

<h3>Description</h3>

<p>Retrieve nodes and edges from the widget.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_get_nodes_p(proxy)

sg_get_edges_p(proxy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_get_nodes_p_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>proxy</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)

nodes &lt;- sg_make_nodes()
edges &lt;- sg_make_edges(nodes)

ui &lt;- fluidPage(
  actionButton("start", "Trigger layout"), # add the button
  sigmajsOutput("sg"),
  verbatimTextOutput("txt")
) 

server &lt;- function(input, output){

  output$sg &lt;- renderSigmajs({
    sigmajs() %&gt;%
      sg_nodes(nodes, id, size, color) %&gt;%
      sg_edges(edges, id, source, target)
  })

  observeEvent(input$start, {
    sigmajsProxy("sg") %&gt;% # use sigmajsProxy!
      sg_get_nodes_p()
  })

  output$txt &lt;- renderPrint({
    input$sg_nodes
  })

}
if(interactive()) shinyApp(ui, server) # run

</code></pre>

<hr>
<h2 id='sg_layout'>Layouts</h2><span id='topic+sg_layout'></span><span id='topic+sg_get_layout'></span>

<h3>Description</h3>

<p>Layout your graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_layout(
  sg,
  directed = TRUE,
  layout = igraph::layout_nicely,
  save_igraph = TRUE,
  ...
)

sg_get_layout(
  nodes,
  edges,
  directed = TRUE,
  layout = igraph::layout_nicely,
  save_igraph = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_layout_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_layout_+3A_directed">directed</code></td>
<td>
<p>Whether or not to create a directed graph, passed to <code><a href="igraph.html#topic+graph_from_data_frame">graph_from_data_frame</a></code>.</p>
</td></tr>
<tr><td><code id="sg_layout_+3A_layout">layout</code></td>
<td>
<p>An <code>igraph</code> layout function.</p>
</td></tr>
<tr><td><code id="sg_layout_+3A_save_igraph">save_igraph</code></td>
<td>
<p>Whether to save the <code>igraph</code> object used internally.</p>
</td></tr>
<tr><td><code id="sg_layout_+3A_...">...</code></td>
<td>
<p>Any other parameter to pass to <code>layout</code> function.</p>
</td></tr>
<tr><td><code id="sg_layout_+3A_nodes">nodes</code>, <code id="sg_layout_+3A_edges">edges</code></td>
<td>
<p>Nodes and edges as prepared for sigmajs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The package uses <code>igraph</code> internally for a lot of computations the <code>save_igraph</code> 
allows saving the object to speed up subsequent computations.
</p>


<h3>Value</h3>

<p><code>sg_get_layout</code> returns nodes with <code>x</code> and <code>y</code> coordinates.
</p>


<h3>Functions</h3>


<ul>
<li><p><code>sg_layout</code> layout your graph.
</p>
</li>
<li><p><code>sg_get_layout</code> helper to get graph's <code>x</code> and <code>y</code> positions.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes(250) # 250 nodes
edges &lt;- sg_make_edges(nodes, n = 500)

sigmajs() %&gt;% 
  sg_nodes(nodes, id, size, color) %&gt;% 
  sg_edges(edges, id, source, target) %&gt;% 
  sg_layout()

nodes_coords &lt;- sg_get_layout(nodes, edges)

</code></pre>

<hr>
<h2 id='sg_make_nodes'>Generate data</h2><span id='topic+sg_make_nodes'></span><span id='topic+sg_make_edges'></span><span id='topic+sg_make_nodes_edges'></span>

<h3>Description</h3>

<p>Generate nodes and edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_make_nodes(
  n = 10,
  colors = c("#B1E2A3", "#98D3A5", "#328983", "#1C5C70", "#24C96B")
)

sg_make_edges(nodes, n = NULL)

sg_make_nodes_edges(n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_make_nodes_+3A_n">n</code></td>
<td>
<p>Number of nodes.</p>
</td></tr>
<tr><td><code id="sg_make_nodes_+3A_colors">colors</code></td>
<td>
<p>Color palette to use.</p>
</td></tr>
<tr><td><code id="sg_make_nodes_+3A_nodes">nodes</code></td>
<td>
<p>Nodes, as generated by <code>sg_make_nodes</code>.</p>
</td></tr>
<tr><td><code id="sg_make_nodes_+3A_...">...</code></td>
<td>
<p>Any other argument to pass to <a href="igraph.html#topic+sample_pa">sample_pa</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tibble</code> of nodes or edges or a <code>list</code> of the latter.
</p>


<h3>Functions</h3>


<ul>
<li><p><code>sg_make_nodes</code> generate data.frame nodes.
</p>
</li>
<li><p><code>sg_make_edges</code> generate data.frame edges.
</p>
</li>
<li><p><code>sg_make_nodes_edges</code> generate list of nodes and edges.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes()
edges &lt;- sg_make_edges(nodes)

sigmajs() %&gt;%
sg_nodes(nodes, id, label, size, color) %&gt;%
sg_edges(edges, id, source, target) %&gt;%
sg_settings(defaultNodeColor = "#0011ff")

</code></pre>

<hr>
<h2 id='sg_neighbours'>Highlight neighbours</h2><span id='topic+sg_neighbours'></span><span id='topic+sg_neighbors'></span><span id='topic+sg_neighbours_p'></span><span id='topic+sg_neighbors_p'></span>

<h3>Description</h3>

<p>Highlight node neighbours on click.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_neighbours(sg, nodes = "#eee", edges = "#eee")

sg_neighbors(sg, nodes = "#eee", edges = "#eee")

sg_neighbours_p(proxy, nodes = "#eee", edges = "#eee")

sg_neighbors_p(proxy, nodes = "#eee", edges = "#eee")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_neighbours_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_neighbours_+3A_nodes">nodes</code>, <code id="sg_neighbours_+3A_edges">edges</code></td>
<td>
<p>Color of nodes and edges</p>
</td></tr>
<tr><td><code id="sg_neighbours_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of the <code>sg</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes() 
edges &lt;- sg_make_edges(nodes, 20)

sigmajs() %&gt;% 
  sg_nodes(nodes, id, size, color) %&gt;% 
  sg_edges(edges, id, source, target) %&gt;% 
  sg_layout() %&gt;% 
  sg_neighbours()

</code></pre>

<hr>
<h2 id='sg_nodes'>Add nodes and edges</h2><span id='topic+sg_nodes'></span><span id='topic+sg_edges'></span><span id='topic+sg_edges2'></span><span id='topic+sg_nodes2'></span>

<h3>Description</h3>

<p>Add nodes and edges to a <code>sigmajs</code> graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_nodes(sg, data, ...)

sg_edges(sg, data, ...)

sg_edges2(sg, data)

sg_nodes2(sg, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_nodes_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_nodes_+3A_data">data</code></td>
<td>
<p>Data.frame (or list) of nodes or edges.</p>
</td></tr>
<tr><td><code id="sg_nodes_+3A_...">...</code></td>
<td>
<p>Any column name, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>nodes</strong>:
Must pass <code>id</code> (<em>unique</em>), <code>size</code> and <code>color</code>. If <code>color</code> is omitted than specify 
<code>defaultNodeColor</code> in <code><a href="#topic+sg_settings">sg_settings</a></code> otherwise nodes will be transparent. Ideally nodes 
also include <code>x</code> and <code>y</code>, 
if they are not passed then they are randomly generated, you can either get these coordinates with <code><a href="#topic+sg_get_layout">sg_get_layout</a></code>
or <code><a href="#topic+sg_layout">sg_layout</a></code>.
</p>
<p><strong>edges</strong>:
Each edge also must include a unique <code>id</code> as well as two columns named <code>source</code> and <code>target</code> which correspond to
node <code>id</code>s. If an edges goes from or to an <code>id</code> that is not in node <code>id</code>.
</p>


<h3>Value</h3>

<p>A modified version of the <code>sg</code> object.
</p>


<h3>Functions</h3>


<ul>
<li><p>Functions ending in <code>2</code> take a list like the original sigma.js JSON.
</p>
</li>
<li><p>Other functions take the arguments described above.
</p>
</li></ul>



<h3>Note</h3>

<p><code>node</code> also takes a <a href="crosstalk.html#topic+SharedData">SharedData</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes()
edges &lt;- sg_make_edges(nodes)

sg &lt;- sigmajs() %&gt;%
  sg_nodes(nodes, id, label, size, color) %&gt;%
  sg_edges(edges, id, source, target) 
  
sg # no layout

# layout
sg %&gt;% 
  sg_layout()

# directed graph
edges$type &lt;- "arrow" # directed

# omit color
sigmajs() %&gt;%
  sg_nodes(nodes, id, label, size) %&gt;%
  sg_edges(edges, id, source, target, type) %&gt;% 
  sg_settings(defaultNodeColor = "#141414")
  
# all source and target are present in node ids
all(c(edges$source, edges$target) %in% nodes$id)

</code></pre>

<hr>
<h2 id='sg_noverlap'>No overlap</h2><span id='topic+sg_noverlap'></span><span id='topic+sg_noverlap_p'></span>

<h3>Description</h3>

<p>This plugin runs an algorithm which distributes nodes in the network, ensuring that they do not overlap and providing a margin where specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_noverlap(sg, ...)

sg_noverlap_p(proxy, nodeMargin = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_noverlap_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_noverlap_+3A_...">...</code></td>
<td>
<p>any option to pass to the plugin, see <a href="https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.layout.noverlap">official documentation</a>.</p>
</td></tr>
<tr><td><code id="sg_noverlap_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="sg_noverlap_+3A_nodemargin">nodeMargin</code></td>
<td>
<p>The additional minimum space to apply around each and every node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first argument either <code>sg</code> or <code>proxy</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes(500)
edges &lt;- sg_make_edges(nodes)

sigmajs() %&gt;%
  sg_nodes(nodes, id, size, color) %&gt;%
  sg_edges(edges, id, source, target) %&gt;%
  sg_layout() %&gt;% 
  sg_noverlap()

</code></pre>

<hr>
<h2 id='sg_progress'>Text</h2><span id='topic+sg_progress'></span>

<h3>Description</h3>

<p>Add text to your graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_progress(
  sg,
  data,
  delay,
  text,
  ...,
  position = "top",
  id = NULL,
  tag = htmltools::span,
  cumsum = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_progress_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_progress_+3A_data">data</code></td>
<td>
<p>Data.frame holding <code>delay</code> and <code>text</code>.</p>
</td></tr>
<tr><td><code id="sg_progress_+3A_delay">delay</code></td>
<td>
<p>Delay, in milliseconds at which text should appear.</p>
</td></tr>
<tr><td><code id="sg_progress_+3A_text">text</code></td>
<td>
<p>Text to appear on graph.</p>
</td></tr>
<tr><td><code id="sg_progress_+3A_...">...</code></td>
<td>
<p>Content of the button, complient with <code>htmltools</code>.</p>
</td></tr>
<tr><td><code id="sg_progress_+3A_position">position</code></td>
<td>
<p>Position of button, <code>top</code> or <code>bottom</code>.</p>
</td></tr>
<tr><td><code id="sg_progress_+3A_id">id</code></td>
<td>
<p>A valid CSS id.</p>
</td></tr>
<tr><td><code id="sg_progress_+3A_tag">tag</code></td>
<td>
<p>A Valid <code>htmltools</code> tags function.</p>
</td></tr>
<tr><td><code id="sg_progress_+3A_cumsum">cumsum</code></td>
<td>
<p>Whether to compute the cumulative sum on the <code>delay</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>element</code> is passed to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement">Document.createElement()</a>
and therefore takes any valid <code>tagName</code>, including, but not limited to; <code>p</code>, <code>h1</code>, <code>div</code>.
</p>


<h3>Value</h3>

<p>A modified version of the <code>sg</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># initial nodes
nodes &lt;- sg_make_nodes()

# additional nodes
nodes2 &lt;- sg_make_nodes()
nodes2$id &lt;- as.character(seq(11, 20))

# add delay
nodes2$delay &lt;- runif(nrow(nodes2), 500, 1000)
nodes2$text &lt;- seq.Date(Sys.Date(), Sys.Date() + 9, "days")

sigmajs() %&gt;%
  sg_nodes(nodes, id, label, size, color) %&gt;%
  sg_add_nodes(nodes2, delay, id, label, size, color) %&gt;% 
  sg_progress(nodes2, delay, text, element = "h3") %&gt;%
  sg_button(c("add_nodes", "progress"), "add") 

</code></pre>

<hr>
<h2 id='sg_refresh_p'>Refresh instance</h2><span id='topic+sg_refresh_p'></span>

<h3>Description</h3>

<p>Refresh your instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_refresh_p(proxy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_refresh_p_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is often required to refresh the instance when using proxies.
</p>

<hr>
<h2 id='sg_relative_size'>Relative node sizes</h2><span id='topic+sg_relative_size'></span>

<h3>Description</h3>

<p>Change nodes size depending to their degree (number of relationships)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_relative_size(sg, initial = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_relative_size_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_relative_size_+3A_initial">initial</code></td>
<td>
<p>Initial node size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of the <code>sg</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes(50)
edges &lt;- sg_make_edges(nodes, 100)

sigmajs() %&gt;%
  sg_nodes(nodes, id, label) %&gt;% # no need to pass size
  sg_edges(edges, id, source, target) %&gt;% 
  sg_relative_size()

</code></pre>

<hr>
<h2 id='sg_settings'>Settings</h2><span id='topic+sg_settings'></span><span id='topic+sg_settings_p'></span>

<h3>Description</h3>

<p>Graph settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_settings(sg, ...)

sg_settings_p(proxy, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_settings_+3A_sg">sg</code></td>
<td>
<p>An object of class <code>sigmajs</code>as intatiated by <code><a href="#topic+sigmajs">sigmajs</a></code>.</p>
</td></tr>
<tr><td><code id="sg_settings_+3A_...">...</code></td>
<td>
<p>Any parameter, see <a href="https://github.com/jacomyal/sigma.js/wiki/Settings">official documentation</a>.</p>
</td></tr>
<tr><td><code id="sg_settings_+3A_proxy">proxy</code></td>
<td>
<p>A proxy as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes()

edges &lt;- sg_make_edges(nodes, 50)

sigmajs() %&gt;%
  sg_nodes(nodes, id, label, size) %&gt;%
  sg_edges(edges, id, source, target) %&gt;% 
  sg_force() %&gt;% 
  sg_settings(
    defaultNodeColor = "#0011ff"
  )

</code></pre>

<hr>
<h2 id='sg_zoom_p'>Zoom</h2><span id='topic+sg_zoom_p'></span>

<h3>Description</h3>

<p>Dynamically Zoom a node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_zoom_p(proxy, id, ratio = 0.5, duration = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_zoom_p_+3A_proxy">proxy</code></td>
<td>
<p>An object of class <code>sigmajsProxy</code> as returned by <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>.</p>
</td></tr>
<tr><td><code id="sg_zoom_p_+3A_id">id</code></td>
<td>
<p>Node id to zoom to.</p>
</td></tr>
<tr><td><code id="sg_zoom_p_+3A_ratio">ratio</code></td>
<td>
<p>The zoom ratio of the graph and its items.</p>
</td></tr>
<tr><td><code id="sg_zoom_p_+3A_duration">duration</code></td>
<td>
<p>Duration of animation.</p>
</td></tr>
</table>

<hr>
<h2 id='sigmajs'>Initialise</h2><span id='topic+sigmajs'></span>

<h3>Description</h3>

<p>Initialise a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmajs(
  type = NULL,
  width = "100%",
  kill = FALSE,
  height = NULL,
  elementId = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmajs_+3A_type">type</code></td>
<td>
<p>Renderer type, one of <code>canvas</code>, <code>webgl</code> or <code>svg</code>.</p>
</td></tr>
<tr><td><code id="sigmajs_+3A_width">width</code>, <code id="sigmajs_+3A_height">height</code></td>
<td>
<p>Dimensions of graph.</p>
</td></tr>
<tr><td><code id="sigmajs_+3A_kill">kill</code></td>
<td>
<p>Whether to kill the graph, set to <code>FALSE</code> 
if using <code><a href="#topic+sigmajsProxy">sigmajsProxy</a></code>, else set to <code>TRUE</code>. Only useful in Shiny.</p>
</td></tr>
<tr><td><code id="sigmajs_+3A_elementid">elementId</code></td>
<td>
<p>Id of elment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>htmlwidget</code> which renders the visualisation on print.
</p>


<h3>Note</h3>

<p>Keep <code>width</code> at <code>100%</code> for a responsive visualisation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sg_kill">sg_kill</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nodes &lt;- sg_make_nodes()
edges &lt;- sg_make_edges(nodes)

sigmajs("svg") %&gt;%
  sg_nodes(nodes, id, label, size, color) %&gt;%
  sg_edges(edges, id, source, target) 

</code></pre>

<hr>
<h2 id='sigmajs-shiny'>Shiny bindings for sigmajs</h2><span id='topic+sigmajs-shiny'></span><span id='topic+sigmajsOutput'></span><span id='topic+renderSigmajs'></span><span id='topic+sigmajsProxy'></span>

<h3>Description</h3>

<p>Output and render functions for using sigmajs within Shiny
applications and interactive Rmd documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmajsOutput(outputId, width = "100%", height = "400px")

renderSigmajs(expr, env = parent.frame(), quoted = FALSE)

sigmajsProxy(id, session = shiny::getDefaultReactiveDomain())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmajs-shiny_+3A_outputid">outputId</code>, <code id="sigmajs-shiny_+3A_id">id</code></td>
<td>
<p>output variable to read from</p>
</td></tr>
<tr><td><code id="sigmajs-shiny_+3A_width">width</code>, <code id="sigmajs-shiny_+3A_height">height</code></td>
<td>
<p>Must be a valid CSS unit (like <code>'100%'</code>,
<code>'400px'</code>, <code>'auto'</code>) or a number, which will be coerced to a
string and have <code>'px'</code> appended.</p>
</td></tr>
<tr><td><code id="sigmajs-shiny_+3A_expr">expr</code></td>
<td>
<p>An expression that generates a sigmajs</p>
</td></tr>
<tr><td><code id="sigmajs-shiny_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate <code>expr</code>.</p>
</td></tr>
<tr><td><code id="sigmajs-shiny_+3A_quoted">quoted</code></td>
<td>
<p>Is <code>expr</code> a quoted expression (with <code>quote()</code>)? This
is useful if you want to save an expression in a variable.</p>
</td></tr>
<tr><td><code id="sigmajs-shiny_+3A_session">session</code></td>
<td>
<p>A valid shiny session.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
