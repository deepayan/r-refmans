<!DOCTYPE html><html><head><title>Help for package eks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eks}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#contour'><p>Contour functions for tidy and geospatial kernel estimates</p></a></li>
<li><a href='#eks-internal'><p>Internal functions in the eks library</p></a></li>
<li><a href='#eks-package'><p>eks</p></a></li>
<li><a href='#geom_contour_ks'><p>Contour and filled contour plots for tidy kernel estimates</p></a></li>
<li><a href='#geom_point_ks'><p>Rug and scatter plots for tidy kernel estimates</p></a></li>
<li><a href='#grevilleasf'><p>Geographical locations of Grevillea plants in Western Australia</p></a></li>
<li><a href='#scale_transparent'><p>Change individual colours in discrete colour scale to transparent</p></a></li>
<li><a href='#st_add_coordinates'><p>Add coordinates as attributes to geospatial data</p></a></li>
<li><a href='#tidyst_kcde'><p>Tidy and geospatial kernel cumulative distribution and copula estimates</p></a></li>
<li><a href='#tidyst_kcurv'><p>Tidy and geospatial kernel summary density curvature estimates</p></a></li>
<li><a href='#tidyst_kda'><p>Tidy and geospatial kernel discrimination analysis (classification)</p></a></li>
<li><a href='#tidyst_kdcde'><p>Tidy and geospatial kernel deconvolved density estimates</p></a></li>
<li><a href='#tidyst_kdde'><p>Tidy and geospatial kernel density derivative estimates</p></a></li>
<li><a href='#tidyst_kde'><p>Tidy and geospatial kernel density estimates</p></a></li>
<li><a href='#tidyst_kde_balloon'><p>Tidy and geospatial kernel density estimates with variable kernels</p></a></li>
<li><a href='#tidyst_kde_boundary'><p>Tidy and geospatial kernel density estimates with boundary and truncated kernels</p></a></li>
<li><a href='#tidyst_kde_local_test'><p>Tidy and geospatial kernel density based local two-sample comparison tests</p></a></li>
<li><a href='#tidyst_kdr'><p>Tidy and geospatial kernel density ridge estimates</p></a></li>
<li><a href='#tidyst_kfs'><p>Tidy and geospatial kernel feature significance</p></a></li>
<li><a href='#tidyst_kms'><p>Tidy and geospatial kernel mean shift clustering</p></a></li>
<li><a href='#tidyst_kquiver'><p>Tidy and geospatial kernel density quiver estimate</p></a></li>
<li><a href='#tidyst_kroc'><p>Tidy and geospatial kernel receiver operating characteristic (ROC) curve</p></a></li>
<li><a href='#tidyst_ksupp'><p>Tidy and geospatial kernel support estimate</p></a></li>
<li><a href='#tidyst_plot'><p>Plots for tidy and geospatial kernel estimates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-25</td>
</tr>
<tr>
<td>Title:</td>
<td>Tidy and Geospatial Kernel Smoothing</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tarn Duong &lt;tarn.duong@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2 (&ge; 3.0.0), isoband, ks, mapsf, sf</td>
</tr>
<tr>
<td>Suggests:</td>
<td>colorspace, ggquiver, ggspatial, ggthemes, knitr, MASS,
rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Extensions of the kernel smoothing functions from the 'ks' package for compatibility with the tidyverse and geospatial ecosystems &lt;<a href="https://doi.org/10.48550%2FarXiv.2203.01686">doi:10.48550/arXiv.2203.01686</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.mvstat.net/mvksa/">https://www.mvstat.net/mvksa/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-25 11:43:21 UTC; tduong</td>
</tr>
<tr>
<td>Author:</td>
<td>Tarn Duong <a href="https://orcid.org/0000-0002-1198-3482"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-25 13:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='contour'>Contour functions for tidy and geospatial kernel estimates</h2><span id='topic+contour_breaks'></span><span id='topic+contourLevels.tidy_ks'></span><span id='topic+contourLevels.sf_ks'></span><span id='topic+st_get_contour'></span><span id='topic+label_percent'></span>

<h3>Description</h3>

<p>Contour functions for tidy and geospatial kernel estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidy_ks'
contourLevels(x, cont=c(25,50,75), group=FALSE, ...)
## S3 method for class 'sf_ks'
contourLevels(x, cont=c(25,50,75), group=FALSE, ...)
contour_breaks(data, cont=c(25,50,75), group=FALSE)
label_percent(y)

st_get_contour(x, cont=c(25,50,75), breaks, which_deriv_ind, disjoint=TRUE,
    as_point=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour_+3A_x">x</code>, <code id="contour_+3A_data">data</code></td>
<td>
<p>tidy kernel estimate (output from <code>tidy_k*</code>) or geospatial kernel estimate (output from <code>st_k*</code>)</p>
</td></tr>
<tr><td><code id="contour_+3A_cont">cont</code></td>
<td>
<p>vector of contour levels. Default is c(25,50,75).</p>
</td></tr>
<tr><td><code id="contour_+3A_group">group</code></td>
<td>
<p>flag to compute contour levels per group. Default is FALSE.</p>
</td></tr>
<tr><td><code id="contour_+3A_breaks">breaks</code></td>
<td>
<p>tibble or vector of contour levels (e.g. output from <code>contour_breaks</code>)</p>
</td></tr>
<tr><td><code id="contour_+3A_which_deriv_ind">which_deriv_ind</code></td>
<td>
<p>derivative index (only required for <code>st_kdde</code> objects)</p>
</td></tr>
<tr><td><code id="contour_+3A_disjoint">disjoint</code></td>
<td>
<p>flag to compute disjoint contours. Default is TRUE.</p>
</td></tr>
<tr><td><code id="contour_+3A_as_point">as_point</code></td>
<td>
<p>flag to return polygons as point coordinates in tidy format. Default is TRUE.</p>
</td></tr>  
<tr><td><code id="contour_+3A_y">y</code></td>
<td>
<p>factor variable</p>
</td></tr>
<tr><td><code id="contour_+3A_...">...</code></td>
<td>
<p>other parameters (not implemented)</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>By default, the 1% to 99% contours are computed for an <code>st_k*</code> output, though a plot of all 99 of them would be too crowded. <code>st_get_contour</code> selects a subset of these, as specified by <code>cont</code>. If a contour level in <code>cont</code> does not already exist or if absolute contour levels are specified in <code>breaks</code>, then the corresponding contours are computed. If <code>disjoint=TRUE</code> (default) then the contours are computed as a set of disjoint multipolygons: this allows for plotting without overlapping transparent colours. If <code>disjoint=FALSE</code> then the contours are overlapping and so their colours alpha-mixed, but they strictly satisfy the probabilistic definition, e.g. a 25% contour region is the smallest region that contains 25% of the probability mass defined by the kernel estimate, see <code><a href="#topic+geom_contour_ks">geom_contour_ks</a></code>.
</p>
<p>Since these default probability contours are relative contour levels, they aren't suitable for producing a contour plot with fixed contour levels across all groups. It may require trial and error to obtain a single set of contour levels which is appropriate for all groups: one possible choice is provided by <code>contour_breaks</code>. 
</p>


<h3>Value</h3>

<p>The output from <code>contour_breaks</code> is a tibble of the values of the contour breaks. The output from <code>st_get_contour</code> is an sf object of the contours as multipolygons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_contour_ks">geom_contour_ks</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(crabs, package="MASS")
crabs2 &lt;- dplyr::select(crabs, FL, CW, sex)
crabs2 &lt;- dplyr::group_by(crabs2, sex)
t1 &lt;- tidy_kde(crabs2)
b &lt;- contour_breaks(t1)
ggplot2::ggplot(t1, ggplot2::aes(x=FL, y=CW)) + 
    geom_contour_filled_ks(colour=1, breaks=b) + 
    ggplot2::facet_wrap(~sex)

## extract contour polygons
crabs2s &lt;- sf::st_as_sf(crabs2, coords=c("FL","CW"))
t2 &lt;- st_kde(crabs2s)
t2 &lt;- st_get_contour(t2, breaks=b, as_point=TRUE)
t2 &lt;- dplyr::rename(t2, FL=X, CW=Y)
ggplot2::ggplot(t2, ggplot2::aes(x=FL, y=CW)) + 
    ggplot2::geom_polygon(ggplot2::aes(fill=contlabel, 
    subgroup=contlabel_group), col=1) + 
    ggplot2::scale_fill_viridis_d() + 
    ggplot2::guides(fill=ggplot2::guide_legend(reverse=TRUE)) + 
    ggplot2::facet_wrap(~sex) 
</code></pre>

<hr>
<h2 id='eks-internal'>Internal functions in the eks library</h2><span id='topic+as_tidy_ks'></span><span id='topic+dim_ks'></span><span id='topic+tidy_ks'></span><span id='topic+st_ks'></span><span id='topic+st_cast_ks'></span><span id='topic+st_remove_long_segment'></span>

<h3>Description</h3>

<p>These functions are user-level but which the user is not required to use directly.</p>


<h3>Value</h3>

<p>The user is not required to use directly these outputs.</p>

<hr>
<h2 id='eks-package'>eks</h2><span id='topic+eks'></span>

<h3>Description</h3>

<p>This package extends the functionality of the kernel smoothing functions from the <span class="pkg">ks</span> package in base <span class="rlang"><b>R</b></span> to the tidyverse and to GIS (Geographical Information Systems) ecosystems.     
</p>


<h3>Details</h3>

<p>As the kernel smoothers from the <span class="pkg">ks</span> package are prefixed as <code>k*</code>, their equivalents in <span class="pkg">eks</span> are systematically named as follows:   
</p>

<ul>
<li> <p><code>tidy_k*</code> for 1- and 2-d tidy data 
</p>
</li>
<li> <p><code>st_k*</code> for 2-d geospatial data.
</p>
</li></ul>

<p>The output data tibbles (tidy data frames provided by the <span class="pkg">tibble</span> package) from <code>tidy_k*</code> can be visualised within the <span class="pkg">ggplot2</span> graphical interface, using the usual layer functions and the custom ones supplied in this package. These <code>tidy_k*</code> functions are analogous to those in the <span class="pkg">broom</span> and related packages, though the latter tend to focus on tidying the summary diagnostic output from model fitting (and not on tidying the underlying estimates themselves), whereas <code>tidy_k*</code> are more substantive since they do compute tidy estimates.   
</p>
<p>The output simple feature geometries (provided by the <span class="pkg">sf</span> package) from <code>st_k*</code> can be visualised in the (i) <span class="pkg">ggplot2</span> graphical interface using primarily the <code>geom_sf</code> layer function, or (ii) in the base <span class="rlang"><b>R</b></span> graphical interface using the <code>plot</code> method supplied in this package. These simple feature geometries can also be exported as standard geospatial formats (e.g. shapefile, GEOS geometry) for use in external GIS software such as ArcGIS and QGIS. 
</p>


<h3>Author(s)</h3>

<p> Tarn Duong </p>


<h3>References</h3>

<p>Chacon, J.E. &amp; Duong, T. (2018) <em>Multivariate Kernel Smoothing
and Its Applications</em>. Chapman &amp; Hall/CRC, Boca Raton. 
</p>
<p>Duong, T. (2022) <em>Statistical visualisation for tidy and geospatial data in R via kernel smoothing methods in the eks package</em>. Submitted. DOI:10.48550/arXiv.2203.01686
</p>

<hr>
<h2 id='geom_contour_ks'>Contour and filled contour plots for tidy kernel estimates</h2><span id='topic+geom_contour_ks'></span><span id='topic+stat_contour_ks'></span><span id='topic+geom_contour_filled_ks'></span><span id='topic+stat_contour_filled_ks'></span><span id='topic+GeomContourKs'></span><span id='topic+StatContourKs'></span><span id='topic+GeomContourFilledKs'></span><span id='topic+StatContourFilledKs'></span>

<h3>Description</h3>

<p>Contour and filled contour plots for tidy kernel estimates for 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_contour_ks(mapping=NULL, data=NULL, stat="contour_ks",
    position="identity", ..., cont=c(25,50,75), label_percent=NULL,
    breaks=NULL, show.legend=NA, inherit.aes=TRUE)
stat_contour_ks(mapping=NULL, data=NULL, geom="contour_ks",
    position="identity", ..., cont=c(25,50,75), label_percent=NULL,
    breaks=NULL, show.legend=NA, inherit.aes=TRUE)
geom_contour_filled_ks(mapping=NULL, data=NULL, stat="contour_filled_ks",
    position="identity", ..., cont=c(25,50,75), label_percent=NULL,
    breaks=NULL, show.legend=NA, inherit.aes=TRUE)
stat_contour_filled_ks(mapping=NULL, data=NULL, geom="contour_filled_ks",
    position="identity", ..., cont=c(25,50,75), label_percent=NULL,
    breaks=NULL, show.legend=NA, inherit.aes=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_contour_ks_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code>aes()</code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_contour_ks_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code>ggplot()</code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code>fortify()</code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_contour_ks_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_contour_ks_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_contour_ks_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code>layer()</code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour="red"</code> or <code>size=3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_contour_ks_+3A_cont">cont</code></td>
<td>
<p>Vector of contour probabilities. Default value is <code>cont=c(25,50,75</code>).</p>
</td></tr>
<tr><td><code id="geom_contour_ks_+3A_label_percent">label_percent</code></td>
<td>
<p>Flag for legend label as percentage. Default is TRUE.</p>
</td></tr>
<tr><td><code id="geom_contour_ks_+3A_breaks">breaks</code></td>
<td>
<p>Numeric vector to set the contour breaks e.g. output from <code>contour_breaks</code>. Overrides <code>cont</code>.</p>
</td></tr>
<tr><td><code id="geom_contour_ks_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_contour_ks_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code>borders()</code>.</p>
</td></tr>
<tr><td><code id="geom_contour_ks_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These layer functions are modifications of the standard layer functions <code>ggplot2::geom_contour</code>, <code>geom_contour_filled</code> and  <code>ggplot2::stat_contour</code>, <code>stat_contour_filled</code>. Their usage and output are similar, except that they require a tidy kernel estimate as the input, rather than the observations themselves, and that the underlying choice of the contour levels is different. For most cases, <code>geom_contour_ks</code> is equivalent to <code>geom_contour(stat="contour_ks")</code>, and likewise for <code>geom_contour_filled_ks</code>.
</p>
<p>The choice of the contour levels are based on probability contours. A 25% contour region is the smallest region that contains 25% of the probability mass defined by the kernel estimate. Probability contours offer a more intuitive approach to selecting the contour levels that reveal the pertinent characteristics of the kernel estimates. See Chacon &amp; Duong (2018, Chapter 2.2). They are specified by the <code>cont</code> parameter: the default value is <code>cont=c(25,50,75)</code>, which computes the upper quartile, median and lower quartile probability contours. If <code>percent_label=TRUE</code>, then the legend labels are given as these percentage in <code>cont</code>. Otherwise, the labels are the contour levels themselves.
</p>
<p>Since these probability contours are computed for each group of the grouping variable in <code>data</code>, then these relative contour levels are different for each group. To produce a contour plot with fixed contour levels across all groups, then these can be supplied in <code>breaks</code>: a possible choice is provided by <code><a href="#topic+contour_breaks">contour_breaks</a></code>. 
</p>


<h3>Value</h3>

<p>Similar output as the standard layer functions <code>ggplot2::geom_contour</code>, <code>geom_contour_filled</code> and  <code>ggplot2::stat_contour</code>, <code>stat_contour_filled</code>. 
</p>


<h3>References</h3>

<p>Chacon, J.E. &amp; Duong, T. (2018) <em>Multivariate Kernel Smoothing
and Its Applications</em>. Chapman &amp; Hall/CRC, Boca Raton.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contour_breaks">contour_breaks</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(crabs, package="MASS")
crabs2 &lt;- dplyr::select(crabs, FL, CW, sp)
crabs2 &lt;- dplyr::group_by(crabs2, sp)
tt &lt;- tidy_kde(crabs2)
gt &lt;- ggplot2::ggplot(tt, ggplot2::aes(x=FL, y=CW))
gt + geom_contour_ks() + ggplot2::facet_wrap(~sp)
gt + ggplot2::geom_contour(stat="contour_ks") +
    ggplot2::facet_wrap(~sp) ## same output
gt + geom_contour_filled_ks(colour=1) + ggplot2::facet_wrap(~sp)
gt + ggplot2::geom_contour_filled(stat="contour_filled_ks", colour=1) +
    ggplot2::facet_wrap(~sp) ## same output
</code></pre>

<hr>
<h2 id='geom_point_ks'>Rug and scatter plots for tidy kernel estimates</h2><span id='topic+geom_point_ks'></span><span id='topic+stat_point_ks'></span><span id='topic+geom_rug_ks'></span><span id='topic+stat_rug_ks'></span><span id='topic+GeomPointKs'></span><span id='topic+GeomRugKs'></span><span id='topic+StatPointKs'></span><span id='topic+StatRugKs'></span>

<h3>Description</h3>

<p>Rug and scatter plots for tidy kernel estimates for 1- and 2-dimensional data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_point_ks(mapping=NULL, data=NULL, stat="point_ks", position="identity", 
    ..., na.rm=FALSE, jitter=FALSE, show.legend=NA, inherit.aes=TRUE) 
stat_point_ks(mapping=NULL, data=NULL, geom="point_ks", position="identity", 
    ..., na.rm=FALSE, show.legend=NA, inherit.aes=TRUE)
geom_rug_ks(mapping=NULL, data=NULL, stat="rug_ks", position="identity", 
    ..., outside=FALSE, sides="bl", length=unit(0.03, "npc"), na.rm=FALSE, 
    jitter=FALSE, show.legend=NA, inherit.aes=TRUE) 
stat_rug_ks(mapping=NULL, data=NULL, geom="rug_ks", position="identity", 
    ..., na.rm=FALSE, show.legend=NA, inherit.aes=TRUE)   
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_point_ks_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code>aes()</code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_point_ks_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code>ggplot()</code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code>fortify()</code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_point_ks_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_point_ks_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_point_ks_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code>layer()</code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour="red"</code> or <code>size=3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_point_ks_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_point_ks_+3A_jitter">jitter</code></td>
<td>
<p>Flag to jitter data before plot. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="geom_point_ks_+3A_outside">outside</code></td>
<td>
<p>logical that controls whether to move the rug tassels outside of the plot area. Default is off (FALSE). You will also need to use <code>coord_cartesian(clip = "off")</code>. When set to TRUE, also consider changing the sides argument to &quot;tr&quot;. See examples.</p>
</td></tr>
<tr><td><code id="geom_point_ks_+3A_sides">sides</code></td>
<td>
<p>A string that controls which sides of the plot the rugs appear on.
It can be set to a string containing any of <code>"trbl"</code>, for top, right,
bottom, and left.</p>
</td></tr>
<tr><td><code id="geom_point_ks_+3A_length">length</code></td>
<td>
<p>A <code>grid::unit()</code> object that sets the length of the rug lines. Use scale expansion to avoid overplotting of data.</p>
</td></tr>
<tr><td><code id="geom_point_ks_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_point_ks_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code>borders()</code>.</p>
</td></tr>
<tr><td><code id="geom_point_ks_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These layer functions are modifications of the standard layer functions <code>ggplot2::geom_point</code>, <code>ggplot2::geom_rug</code> and <code>ggplot2::stat_point</code>. Their usage and output are similar, except that they require a tidy kernel estimate as the input, rather than the observations themselves. For most cases, <code>geom_rug_ks</code> is equivalent to <code>geom_rug(stat="rug_ks")</code>, and likewise for <code>geom_point_ks</code>. 
</p>


<h3>Value</h3>

<p>Similar output as the standard layer functions <code>ggplot2::geom_point</code>, <code>ggplot2::geom_rug</code> and <code>ggplot2::stat_point</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(crabs, package="MASS")

## rug plot for tidy 1-d kernel density estimate
crabs1 &lt;- dplyr::select(crabs, FL)
t1 &lt;- tidy_kde(crabs1)
g1 &lt;- ggplot2::ggplot(t1, ggplot2::aes(x=FL)) + ggplot2::geom_line()
g1 + geom_rug_ks(colour=4) 
g1 + ggplot2::geom_rug(stat="rug_ks", colour=4) ## same output

## scatter plot for tidy 2-d kernel density estimate
crabs2 &lt;- dplyr::select(crabs, FL, CW)
t2 &lt;- tidy_kde(crabs2)
g2 &lt;- ggplot2::ggplot(t2, ggplot2::aes(x=FL, y=CW)) 
g2 + geom_contour_ks(colour=1) + geom_point_ks(colour=4) 
g2 + ggplot2::geom_contour(stat="contour_ks", colour=1) +
    ggplot2::geom_point(stat="point_ks", colour=4) ## same output
</code></pre>

<hr>
<h2 id='grevilleasf'>Geographical locations of Grevillea plants in Western Australia</h2><span id='topic+grevilleasf'></span><span id='topic+wa'></span>

<h3>Description</h3>

<p>The <code>wa</code> data set contains the polygon of the administrative boundary of Western Australia (excluding islands). The <code>grevillea</code> data set contains the locations of 22303 grevillea plants in Western Australia. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wa)
data(grevilleasf)
</code></pre>


<h3>Format</h3>

<p><code>wa</code> is an sf object, whose geometry is the polygon in the 
EPSG:7850 (GDA2020/MGA zone 50) projection.
</p>
<p><code>grevilleasf</code> is an sf object with 22303 rows and 2 attributes.
Each row corresponds to an observed plant. 
The first column is the full scientific name,
the second is the species name.
The geometry is the point location of the plant in the EPSG:7850 (GDA2020/MGA zone 50) projection. This is a superset of the <code>grevillea</code> dataset in the <span class="pkg">ks</span> package. 
</p>


<h3>Source</h3>

<p>Atlas of Living Australia (2021). Grevillea occurrence. <a href="https://biocache.ala.org.au">https://biocache.ala.org.au</a>. Accessed on 2021-08-18. 
</p>
<p>Geoscape Australia (2021). WA State Boundary &ndash; Geoscape Administrative Boundaries. <a href="https://data.gov.au/data/dataset/wa-state-boundary-geoscape-administrative-boundaries">https://data.gov.au/data/dataset/wa-state-boundary-geoscape-administrative-boundaries</a>.  Accessed on 2021-08-18. 
</p>

<hr>
<h2 id='scale_transparent'>Change individual colours in discrete colour scale to transparent</h2><span id='topic+scale_transparent'></span>

<h3>Description</h3>

<p>Change individual colours in discrete colour scale to transparent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_transparent(x, ind=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_transparent_+3A_x">x</code></td>
<td>
<p>discrete colour scale</p>
</td></tr>
<tr><td><code id="scale_transparent_+3A_ind">ind</code></td>
<td>
<p>index of colour scale to change to transparent. Default is median.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is the same colour scale, except that the colours at the indices enumerated by <code>ind</code> are changed to transparent.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see ? tidy_kdde
</code></pre>

<hr>
<h2 id='st_add_coordinates'>Add coordinates as attributes to geospatial data</h2><span id='topic+st_add_coordinates'></span>

<h3>Description</h3>

<p>Add coordinates as attributes to geospatial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_add_coordinates(x, as_sf=FALSE, as_tibble=FALSE, rename=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_add_coordinates_+3A_x">x</code></td>
<td>
<p><code>sf</code> object with point geometry</p>
</td></tr>
<tr><td><code id="st_add_coordinates_+3A_as_sf">as_sf</code></td>
<td>
<p>flag for output as <code>sf</code> object. Default is TRUE.</p>
</td></tr>
<tr><td><code id="st_add_coordinates_+3A_as_tibble">as_tibble</code></td>
<td>
<p>flag for output as tibble. Default is TRUE.</p>
</td></tr>
<tr><td><code id="st_add_coordinates_+3A_rename">rename</code></td>
<td>
<p>flag to rename output from  <code>X,Y</code> to <code>lon,lat</code>. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sf::st_coordinates</code> is applied to obtain the longitude and latitude coordinates. 
</p>


<h3>Value</h3>

<p>The longitude and latitude of the point geometry are added as attributes.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")
hakeoides_coord &lt;- st_add_coordinates(hakeoides)
</code></pre>

<hr>
<h2 id='tidyst_kcde'>Tidy and geospatial kernel cumulative distribution and copula estimates</h2><span id='topic+tidy_kcde'></span><span id='topic+tidy_kcopula'></span><span id='topic+st_kcde'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of kernel cumulative distribution estimates for 1- and 2-dimensional data, and kernel copula estimates for 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kcde(data, ...)
tidy_kcopula(data, ...)
st_kcde(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kcde_+3A_data">data</code></td>
<td>
<p>data frame/tibble of data values</p>
</td></tr>
<tr><td><code id="tidyst_kcde_+3A_x">x</code></td>
<td>
<p>sf object with point geometry</p>
</td></tr>
<tr><td><code id="tidyst_kcde_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::kcde</code>, <code>ks::kcopula</code> functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of the computation of the kernel distribution and copula estimates, and of the bandwidth selector procedures, see <code>?ks::kcde</code>, <code>?ks::kcopula</code>.
</p>


<h3>Value</h3>

<p>The outputs from <code>*_kcde</code> have the same structure as the kernel density estimate from <code><a href="#topic+st_kde">*_kde</a></code>, except that <code>estimate</code> indicates the cumulative distribution rather than the density values. Likewise for <code>tidy_kcopula</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(crabs, package="MASS")
## tidy 1-d distribution estimate per species
crabs1 &lt;- dplyr::select(crabs, FL, sp)
crabs1 &lt;- dplyr::group_by(crabs1, sp)
t1 &lt;- tidy_kcde(crabs1)
gt1 &lt;- ggplot2::ggplot(t1, ggplot2::aes(x=FL)) 
gt1 + ggplot2::geom_line(colour=1) + geom_rug_ks(colour=4) +
    ggplot2::facet_wrap(~sp)

## tidy 2-d copula estimate
crabs2 &lt;- dplyr::select(crabs, FL, CW)
t2 &lt;- tidy_kcopula(crabs2)
gt2 &lt;- ggplot2::ggplot(t2, ggplot2::aes(x=FL, y=CW)) 
gt2 + geom_contour_filled_ks(colour=1, cont=seq(10,90,by=10))

## geospatial distribution estimate
data(wa)
data(grevilleasf)
paradoxa &lt;- dplyr::filter(grevilleasf, species=="paradoxa")
paradoxa_crop &lt;- sf::st_crop(paradoxa, xmin=4e5, xmax=8e5, ymin=6.4e6, ymax=6.65e6)
paradoxa_bbox &lt;- sf::st_as_sfc(sf::st_bbox(paradoxa_crop))
xminb &lt;- sf::st_bbox(paradoxa_crop)[1:2]
xmaxb &lt;- sf::st_bbox(paradoxa_crop)[3:4]
s1 &lt;- st_kcde(paradoxa_crop, xmin=xminb, xmax=xmaxb)

## base R filled contour plot
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(paradoxa_bbox, add=TRUE, lty=3, lwd=2)
plot(s1, add=TRUE)

## geom_sf filled contour plot
gs1 &lt;- ggplot2::ggplot(s1) + ggplot2::geom_sf(data=wa, fill=NA) + 
    ggthemes::theme_map() 
gs1 + ggplot2::geom_sf(data=paradoxa_bbox, linewidth=1.2, 
    linetype="dotted", fill=NA) +
    ggplot2::geom_sf(data=st_get_contour(s1), 
    ggplot2::aes(fill=label_percent(contlabel))) +
    ggplot2::scale_fill_viridis_d() +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim)
</code></pre>

<hr>
<h2 id='tidyst_kcurv'>Tidy and geospatial kernel summary density curvature estimates</h2><span id='topic+tidy_kcurv'></span><span id='topic+st_kcurv'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of kernel summary density curvature estimates for 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kcurv(data, ...)
st_kcurv(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kcurv_+3A_data">data</code></td>
<td>
<p>tidy kernel density curvature estimate (output from <code><a href="#topic+tidy_kdde">tidy_kdde</a>(deriv_order=2)</code>)</p>
</td></tr>
<tr><td><code id="tidyst_kcurv_+3A_x">x</code></td>
<td>
<p>geospatial density curvature estimate (output from <code><a href="#topic+st_kdde">st_kdde</a>(deriv_order=2)</code>)</p>
</td></tr>
<tr><td><code id="tidyst_kcurv_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::kcurv</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A kernel density summary curvature estimate is a modification of a kernel density curvature estimate where the matrix of second order partial derivative values is summarised as a scalar value. For details of the computation of the kernel density summary curvature estimate, see <code>?ks::kcurv</code>. The bandwidth matrix of smoothing parameters is computed as in <code>ks::kdde(deriv_order=2)</code>. 
</p>


<h3>Value</h3>

<p>The output from <code>*_kcurv</code> have the same structure as the input kernel density curvature estimate from <code><a href="#topic+st_kdde">*_kdde</a></code>, except that <code>estimate</code> indicates the summary curvature values rather than the density curvature values, and that <code>deriv_group</code> for each of the partial derivatives is collapsed into a single grouping.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## tidy kernel summary density curvature estimate
data(crabs, package="MASS")
crabs2 &lt;- dplyr::select(crabs, FL, CW)
t1 &lt;- tidy_kdde(crabs2, deriv_order=2)
t2 &lt;- tidy_kcurv(t1)
gt1 &lt;- ggplot2::ggplot(t2, ggplot2::aes(x=FL, y=CW)) 
gt1 + geom_contour_filled_ks(colour=1) + 
    ggplot2::scale_fill_brewer(palette="Oranges")

## geospatial kernel summary density curvature estimate
data(wa)
data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")
s1 &lt;- st_kdde(hakeoides, deriv_order=2)
s2 &lt;- st_kcurv(s1)

## base R plot
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(s2, add=TRUE)

## geom_sf plot
gs1 &lt;- ggplot2::ggplot(s2) + ggplot2::geom_sf(data=wa, fill=NA) + 
    ggthemes::theme_map()
gs1 + ggplot2::geom_sf(data=st_get_contour(s2), 
    ggplot2::aes(fill=label_percent(contlabel))) +
    colorspace::scale_fill_discrete_sequential(h1=30,c1=360,c2=30) +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim)
</code></pre>

<hr>
<h2 id='tidyst_kda'>Tidy and geospatial kernel discrimination analysis (classification)</h2><span id='topic+tidy_kda'></span><span id='topic+st_kda'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of kernel discrimination analysis (classification) for 1- and 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kda(data, ...)
st_kda(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kda_+3A_data">data</code></td>
<td>
<p>grouped tibble of data values</p>
</td></tr>
<tr><td><code id="tidyst_kda_+3A_x">x</code></td>
<td>
<p>sf object with grouping attribute and with point geometry</p>
</td></tr>
<tr><td><code id="tidyst_kda_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::kda</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A kernel discriminant analysis (aka classification or supervised learning) assigns each grid point to the group with the highest density value, weighted by the prior probabilities. 
</p>
<p>The output from <code>*_kda</code> have the same structure as the kernel density estimate from <code><a href="#topic+st_kde">*_kde</a></code>, except that <code>estimate</code> is the weighted kernel density values at the grid points (weighted by <code>prior_prob</code>), and <code>label</code> becomes the KDA grouping variable that indicates to which of the groups the grid points belong. The output is a grouped tibble, grouped by the input grouping variable.
</p>
<p>For details of the computation of the kernel discriminant analysis and the bandwidth selector procedure, see <code>?ks::kda</code>. The bandwidth matrix of smoothing parameters is computed as in <code>ks::kde</code> per group. 
</p>


<h3>Value</h3>

<p>&ndash;For <code>tidy_kda</code>, the output is an object of class <code>tidy_ks</code>, which is a tibble with columns: 
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>evaluation points in x-axis (name is taken from 1st input variable in <code>data</code>)</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>evaluation points in y-axis (2-d) (name is taken from 2nd input variable in <code>data</code>)</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>weighted kernel density estimate values</p>
</td></tr>
<tr><td><code>prior_prob</code></td>
<td>
<p>prior probabilities for each group</p>
</td></tr>
<tr><td><code>ks</code></td>
<td>
<p>first row (within each <code>group</code>) contains the untidy kernel estimate from <code>ks::kda</code></p>
</td></tr>
<tr><td><code>tks</code></td>
<td>
<p>short object class label derived from the <code>ks</code> object class</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>estimated KDA group label at <code>(x,y)</code></p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>grouping variable (same as input).</p>
</td></tr>
</table>
<p>&ndash;For <code>st_kda</code>, the output is an object of class <code>st_ks</code>, which is a list with fields:
</p>
<table>
<tr><td><code>tidy_ks</code></td>
<td>
<p>tibble of simplified output (<code>ks</code>, <code>tks</code>, <code>label</code>, <code>group</code>) from <code>tidy_kda</code></p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>sf object of grid of weighted kernel density estimate values, as polygons, with attributes <code>estimate</code>, <code>label</code>, <code>group</code> copied from the <code>tidy_ks</code> object</p>
</td></tr>
<tr><td><code>sf</code></td>
<td>
<p>sf object of 1% to 99% contour regions of weighted kernel density estimate, as multipolygons, with attributes <code>contlabel</code> derived from the contour level; and <code>estimate</code>, <code>group</code> copied from the <code>tidy_ks</code> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## tidy discriminant analysis (classification)
data(cardio, package="ks")
cardio &lt;- dplyr::as_tibble(cardio[,c("ASTV","Mean","NSP")])
cardio &lt;- dplyr::mutate(cardio, NSP=ordered(NSP))
cardio &lt;- dplyr::group_by(cardio, NSP)
set.seed(8192)
cardio.train.ind &lt;- sample(1:nrow(cardio), round(nrow(cardio)/4,0))
cardio.train &lt;- cardio[cardio.train.ind,]
cardio.train1 &lt;- dplyr::select(cardio.train, ASTV, NSP)
cardio.train2 &lt;- dplyr::select(cardio.train, ASTV, Mean, NSP)

## tidy 1-d classification
t1 &lt;- tidy_kda(cardio.train1) 
gt1 &lt;- ggplot2::ggplot(t1, ggplot2::aes(x=ASTV)) 
gt1 + ggplot2::geom_line(ggplot2::aes(colour=NSP)) + 
    ggplot2::geom_rug(ggplot2::aes(colour=label), sides="b", linewidth=1.5) +
    ggplot2::scale_colour_brewer(palette="Dark2", na.translate=FALSE) 

## tidy 2-d classification
t2 &lt;- tidy_kda(cardio.train2)
gt2 &lt;- ggplot2::ggplot(t2, ggplot2::aes(x=ASTV, y=Mean)) 
gt2 + geom_contour_ks(ggplot2::aes(colour=NSP)) + 
    ggplot2::geom_tile(ggplot2::aes(fill=label), alpha=0.2) +
    ggplot2::scale_fill_brewer(palette="Dark2", na.translate=FALSE) +
    ggplot2::scale_colour_brewer(palette="Dark2") + ggplot2::theme_bw()

## geospatial classification
data(wa)
data(grevilleasf)
grevillea_gr &lt;- dplyr::filter(grevilleasf, species=="hakeoides" |
    species=="paradoxa")
grevillea_gr &lt;- dplyr::mutate(grevillea_gr, species=factor(species))  
grevillea_gr &lt;- dplyr::group_by(grevillea_gr, species)
s1 &lt;- st_kda(grevillea_gr)
s2 &lt;- st_ksupp(st_kde(grevillea_gr))
s1$grid &lt;- s1$grid[sf::st_intersects(s1$grid, 
    sf::st_convex_hull(sf::st_union(s2$sf)), sparse=FALSE),]

## base R plot
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(s1, which_geometry="grid", add=TRUE, border=NA, legend=FALSE)
plot(s1, add=TRUE, lwd=2, border=rep(colorspace::qualitative_hcl(
    palette="Dark2", n=2, alpha=0.5), each=3))

## geom_sf plot
gs1 &lt;- ggplot2::ggplot(s1) + ggplot2::geom_sf(data=wa, fill=NA) + 
    ggplot2::geom_sf(data=dplyr::mutate(s1$grid, species=label), 
    ggplot2::aes(fill=species), alpha=0.1, colour=NA) + 
    ggthemes::theme_map()
gs1 + ggplot2::geom_sf(data=st_get_contour(s1), 
    ggplot2::aes(colour=species), fill=NA) +
    colorspace::scale_colour_discrete_qualitative(palette="Dark2") +
    colorspace::scale_fill_discrete_qualitative(palette="Dark2") +
    ggplot2::facet_wrap(~species) +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim)
</code></pre>

<hr>
<h2 id='tidyst_kdcde'>Tidy and geospatial kernel deconvolved density estimates</h2><span id='topic+tidy_kdcde'></span><span id='topic+st_kdcde'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of kernel deconvolved density estimates for 1- and 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kdcde(data, ...)
st_kdcde(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kdcde_+3A_data">data</code></td>
<td>
<p>data frame/tibble of data values</p>
</td></tr>
<tr><td><code id="tidyst_kdcde_+3A_x">x</code></td>
<td>
<p>sf object with point geometry</p>
</td></tr>
<tr><td><code id="tidyst_kdcde_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::kdcde</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A deconvolved kernel density estimate is a modification of the standard density estimate for data observed with error. This version is based on a weighted kernel density estimate. For details of the computation of the kernel deconvolved density estimate and the bandwidth selector procedure, see <code>?ks::kdcde</code>. 
</p>


<h3>Value</h3>

<p>The output from <code>*_kdcde</code> have the same structure as the standard kernel density estimate from <code><a href="#topic+st_kde">*_kde</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## tidy 2-d deconvolved density estimate
data(air, package="ks")
air &lt;- na.omit(air[, c("time","co2","pm10")])
air &lt;- dplyr::filter(air, time=="20:00")
air &lt;- dplyr::select(air, co2, pm10)
## for details on computation of Sigma.air, see ?ks::kdcde
Sigma.air &lt;- diag(c(6705.765, 957.664)) 

t1 &lt;- tidy_kde(air)
t2 &lt;- tidy_kdcde(air, Sigma=Sigma.air, reg=0.00021)
t3 &lt;- dplyr::bind_rows(dplyr::mutate(t1, group=1L), dplyr::mutate(t2, group=2L))
t3$group &lt;- factor(t3$group, label=c("Standard KDE","Deconvolved KDE"))
t3 &lt;- as_tidy_ks(t3)

## deconvolved estimate is more clearly bimodal than standard KDE 
gt &lt;- ggplot2::ggplot(t3, ggplot2::aes(x=co2,y=pm10)) 
gt + geom_contour_filled_ks(colour=1) + 
    colorspace::scale_fill_discrete_sequential() +
    ggplot2::facet_wrap(~group) 
</code></pre>

<hr>
<h2 id='tidyst_kdde'>Tidy and geospatial kernel density derivative estimates</h2><span id='topic+tidy_kdde'></span><span id='topic+st_kdde'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of kernel density derivative estimates for 1- and 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kdde(data, deriv_order=1, ...)
st_kdde(x, deriv_order=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kdde_+3A_data">data</code></td>
<td>
<p>data frame/tibble of data values</p>
</td></tr>
<tr><td><code id="tidyst_kdde_+3A_deriv_order">deriv_order</code></td>
<td>
<p>derivative order. Default is 1.</p>
</td></tr>
<tr><td><code id="tidyst_kdde_+3A_x">x</code></td>
<td>
<p>sf object with point geometry</p>
</td></tr>
<tr><td><code id="tidyst_kdde_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::kdde</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output from <code>*_kdde</code> have the same structure as the kernel density estimate from <code><a href="#topic+st_kde">*_kde</a></code>, except that <code>estimate</code> is the kernel density derivative values at the grid points, and the additional derived grouping variable <code>deriv_group</code> is the index of the partial derivative, e.g. &quot;deriv (1,0)&quot; and &quot;deriv (0,1)&quot; for a first order derivative for 2-d data. The output is a grouped tibble, grouped by the input grouping variable (if it exists) and by <code>deriv_group</code>.
</p>
<p>For details of the computation of the kernel density derivative estimate and the bandwidth selector procedure, see <code>?ks::kdde</code>.
</p>


<h3>Value</h3>

<p>&ndash;For <code>tidy_kdde</code>, the output is an object of class <code>tidy_ks</code>, which is a tibble with columns: 
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>evaluation points in x-axis (name is taken from 1st input variable in <code>data</code>)</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>evaluation points in y-axis (2-d) (name is taken from 2nd input variable in <code>data</code>)</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>kernel density derivative estimate values</p>
</td></tr>
<tr><td><code>deriv_order</code></td>
<td>
<p>derivative order (same as input)</p>
</td></tr>
<tr><td><code>deriv_ind</code></td>
<td>
<p>index of partial derivative</p>
</td></tr>
<tr><td><code>ks</code></td>
<td>
<p>first row (within each <code>group</code>) contains the untidy kernel estimate from <code>ks::kde</code></p>
</td></tr>
<tr><td><code>tks</code></td>
<td>
<p>short object class label derived from the <code>ks</code> object class</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>long object class label</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>grouping variable (if grouped input) (name is taken from grouping variable in <code>data</code>)</p>
</td></tr>
<tr><td><code>deriv_group</code></td>
<td>
<p>additional derived grouping variable on partial derivative indices.</p>
</td></tr>
</table>
<p>&ndash;For <code>st_kdde</code>, the output is an object of class <code>st_ks</code>, which is a list with fields:
</p>
<table>
<tr><td><code>tidy_ks</code></td>
<td>
<p>tibble of simplified output (<code>deriv_ind</code>, <code>ks</code>, <code>tks</code>, <code>label</code>, <code>group</code>, <code>deriv_group</code>) from <code>tidy_kdde</code></p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>sf object of grid of kernel density derivative estimate values, as polygons, with attributes <code>estimate</code>, <code>deriv_ind</code>, <code>group</code>, <code>deriv_group</code> copied from the <code>tidy_ks</code> object</p>
</td></tr>
<tr><td><code>sf</code></td>
<td>
<p>sf object of 1% to 99% contour regions of the kernel density derivative estimate, as multipolygons, with attributes <code>contlabel</code> derived from the contour level; and <code>estimate</code>, <code>deriv_ind</code>, <code>group</code>, <code>deriv_group</code> copied from the <code>tidy_ks</code> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(crabs, package="MASS")
## 1-d density curvature estimate
crabs1 &lt;- dplyr::select(crabs, FL)
t1 &lt;- tidy_kdde(crabs1, deriv_order=2)
gt1 &lt;- ggplot2::ggplot(t1, ggplot2::aes(x=FL))
gt1 + ggplot2::geom_line(colour=1) + geom_rug_ks(colour=4)

## 2-d density gradient estimate
crabs2 &lt;- dplyr::select(crabs, FL, CW)
t2 &lt;- tidy_kdde(crabs2, deriv_order=1)
cs &lt;- scale_transparent(colorspace::scale_fill_discrete_diverging())
gt2 &lt;- ggplot2::ggplot(t2, ggplot2::aes(x=FL, y=CW))
gt2 + geom_contour_ks(ggplot2::aes(group=deriv_group, 
    colour=ggplot2::after_stat(level))) +
    colorspace::scale_colour_discrete_diverging() +
    cs + ggplot2::facet_wrap(~deriv_group)
gt2 + geom_contour_filled_ks(colour=1) +
    cs + ggplot2::facet_wrap(~deriv_group)
## second partial derivative f^(0,1) only
gt2 + geom_contour_filled_ks(data=dplyr::filter(t2, deriv_ind==2), colour=1) +
   cs

## geospatial density derivative estimate
data(wa)
data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")
s1 &lt;- st_kdde(hakeoides, deriv_order=1)
s1_cont &lt;- st_get_contour(s1, which_deriv_ind=1)
s1_cont2 &lt;- st_get_contour(s1, breaks=contour_breaks(s1))

## base R filled contour plot
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(s1, add=TRUE, which_deriv_ind=1)

## geom_sf filled contour plot
gs &lt;- ggplot2::ggplot(s1) + ggplot2::geom_sf(data=wa, fill=NA) + 
    ggthemes::theme_map()
gs + ggplot2::geom_sf(data=s1_cont, 
    ggplot2::aes(fill=label_percent(contlabel))) +
    colorspace::scale_fill_discrete_diverging() +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim)

## facet wrapped geom_sf filled contour plot
## each facet = each partial derivative 
gs + ggplot2::geom_sf(data=s1_cont2, ggplot2::aes(fill=contlabel)) +
    colorspace::scale_fill_discrete_diverging() +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim) + 
    ggplot2::facet_wrap(~deriv_group)
</code></pre>

<hr>
<h2 id='tidyst_kde'>Tidy and geospatial kernel density estimates</h2><span id='topic+tidy_kde'></span><span id='topic+st_kde'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of kernel density estimates for 1- and 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kde(data, ...)
st_kde(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kde_+3A_data">data</code></td>
<td>
<p>data frame/tibble of data values</p>
</td></tr>
<tr><td><code id="tidyst_kde_+3A_x">x</code></td>
<td>
<p>sf object with point geometry</p>
</td></tr>
<tr><td><code id="tidyst_kde_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::kde</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>tidy_kde</code>, the first columns of the output tibble are copied from <code>aes(x)</code> (1-d) or <code>aes(x,y)</code> (2-d). These columns are the evaluation grid points. The <code>estimate</code> column is the kernel density values at these grid points. The <code>group</code> column is a copy of the grouping variable of the input data. The <code>ks</code> column is a copy of the untidy kernel estimate from <code>ks::kde</code>, since the calculations for the layer functions <code><a href="#topic+geom_contour_ks">geom_contour_ks</a></code>, <code><a href="#topic+geom_contour_filled_ks">geom_contour_filled_ks</a></code> require both the observations <code>data</code> and the kernel estimate as a <code>kde</code> object. For this reason, it is advised to compute a tidy kernel estimate first and then to create a <code>ggplot</code> with this tidy kernel estimate as the default <code>data</code> in the layer. 
</p>
<p>For <code>st_kde</code>, the output list contains the field <code>tidy_ks</code> which is the output from <code>tidy_ks</code>. The field <code>grid</code> is the kernel estimate values, with rectangular polygons. The field <code>sf</code> is the 1% to 99% probability contour regions as multipolygons, with the derived attribute <code>contlabel = 100%-cont</code>.
</p>
<p>The structure of the <code>tidy_kde</code> output is inherited from the input, i.e. if the input is a data frame/ (grouped) tibble then the output is a data frame/(grouped) tibble. Likewise for the <code>sf</code> object outputs for <code>st_kde</code>.
</p>
<p>The default bandwidth matrix is the unconstrained plug-in selector <code>ks::Hpi</code>, which is suitable for a wide range of data sets, since it is not restrained to smoothing along the coordinate axes. This produces a kernel estimate which is more representative of the data than with the default bandwidth in <code>geom_density_2d</code> and <code>geom_density_2d_filled</code>. For further details of the computation of the kernel density estimate and the bandwidth selector procedure, see <code>?ks::kde</code>.
</p>


<h3>Value</h3>

<p>&ndash;For <code>tidy_kde</code>, the output is an object of class <code>tidy_ks</code>, which is a tibble with columns:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>evaluation points in x-axis (name is taken from 1st input variable in <code>data</code>)</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>evaluation points in y-axis (2-d) (name is taken from 2nd input variable in <code>data</code>)</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>kernel estimate values</p>
</td></tr>
<tr><td><code>ks</code></td>
<td>
<p>first row (within each <code>group</code>) contains the untidy kernel estimate from <code>ks::kde</code></p>
</td></tr>
<tr><td><code>tks</code></td>
<td>
<p>short object class label derived from the <code>ks</code> object class</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>long object class label</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>grouping variable (if grouped input) (name is taken from grouping variable in <code>data</code>).</p>
</td></tr>
</table>
<p>&ndash;For <code>st_kde</code>, the output is an object of class <code>st_ks</code>, which is a list with fields:
</p>
<table>
<tr><td><code>tidy_ks</code></td>
<td>
<p>tibble of simplified output (<code>ks</code>, <code>tks</code>, <code>label</code>, <code>group</code>) from <code>tidy_kde</code></p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>sf object of grid of kernel density estimate values, as polygons, with attributes <code>estimate</code>, <code>group</code> copied from the <code>tidy_ks</code> object</p>
</td></tr>
<tr><td><code>sf</code></td>
<td>
<p>sf object of 1% to 99% contour regions of kernel density estimate, as multipolygons, with attributes <code>contlabel</code> derived from the contour level; and <code>estimate</code>, <code>group</code> copied from the <code>tidy_ks</code> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## tidy density estimates
data(crabs, package="MASS")
## tidy 1-d density estimate per species
crabs1 &lt;- dplyr::select(crabs, FL, sp)
crabs1 &lt;- dplyr::group_by(crabs1, sp)
t1 &lt;- tidy_kde(crabs1)
gt1 &lt;- ggplot2::ggplot(t1, ggplot2::aes(x=FL)) 
gt1 + ggplot2::geom_line(colour=1) + geom_rug_ks(colour=4) +
    ggplot2::facet_wrap(~sp)

## tidy 2-d density estimate
## suitable smoothing matrix gives bimodal estimate
crabs2 &lt;- dplyr::select(crabs, FL, CW)
t2 &lt;- tidy_kde(crabs2)
gt2 &lt;- ggplot2::ggplot(t2, ggplot2::aes(x=FL, y=CW)) 
gt2 + geom_contour_filled_ks(colour=1) + 
    colorspace::scale_fill_discrete_sequential()

## default smoothing matrix in geom_density_2d_filled() gives unimodal estimate
gt3 &lt;- ggplot2::ggplot(crabs2, ggplot2::aes(x=FL, y=CW)) 
gt3 + ggplot2::geom_density_2d_filled(bins=4, colour=1) +
    colorspace::scale_fill_discrete_sequential() +
    ggplot2::guides(fill=ggplot2::guide_legend(title="Density", reverse=TRUE))

## facet wrapped geom_sf plot with fixed contour levels for all facets
crabs3 &lt;- dplyr::select(crabs, FL, CW, sex)
t3 &lt;- tidy_kde(dplyr::group_by(crabs3, sex))
b &lt;- contour_breaks(t3)
gt3 &lt;- ggplot2::ggplot(t3, ggplot2::aes(x=FL, y=CW)) 
gt3 + geom_contour_filled_ks(colour=1, breaks=b) + 
    colorspace::scale_fill_discrete_sequential() +
    ggplot2::facet_wrap(~sex)

## geospatial density estimate
data(wa)
data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")
hakeoides_coord &lt;- data.frame(sf::st_coordinates(hakeoides))
s1 &lt;- st_kde(hakeoides)

## base R plot
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(s1, add=TRUE)

## geom_sf plot
## suitable smoothing matrix gives optimally smoothed contours
gs1 &lt;- ggplot2::ggplot(s1) + ggplot2::geom_sf(data=wa, fill=NA) + 
    ggthemes::theme_map()
gs1 + ggplot2::geom_sf(data=st_get_contour(s1), 
    ggplot2::aes(fill=label_percent(contlabel))) +
    colorspace::scale_fill_discrete_sequential(palette="Heat2") +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim) 

## default smoothing matrix in geom_density_2d_filled() is oversmoothed
gs2 &lt;- ggplot2::ggplot(hakeoides_coord) + ggplot2::geom_sf(data=wa, fill=NA) + 
    ggthemes::theme_map()
gs2 + ggplot2::geom_density_2d_filled(ggplot2::aes(x=X, y=Y), bins=4, colour=1) +
    colorspace::scale_fill_discrete_sequential(palette="Heat2") +
    ggplot2::guides(fill=ggplot2::guide_legend(title="Density", reverse=TRUE)) +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim) 

## Not run: ## export as geopackage for external GIS software
sf::write_sf(wa, dsn="grevillea.gpkg", layer="wa")
sf::write_sf(hakeoides, dsn="grevillea.gpkg", layer="hakeoides")
sf::write_sf(gs1_cont, dsn="grevillea.gpkg", layer="hakeoides_cont")
sf::write_sf(s1$grid, dsn="grevillea.gpkg", layer="hakeoides_grid")
## End(Not run)
</code></pre>

<hr>
<h2 id='tidyst_kde_balloon'>Tidy and geospatial kernel density estimates with variable kernels</h2><span id='topic+tidy_kde_balloon'></span><span id='topic+tidy_kde_sp'></span><span id='topic+st_kde_balloon'></span><span id='topic+st_kde_sp'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of kernel density estimates with variable kernels for 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kde_balloon(data, ...)
tidy_kde_sp(data, ...)
st_kde_balloon(x, ...)
st_kde_sp(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kde_balloon_+3A_data">data</code></td>
<td>
<p>data frame/tibble of data values</p>
</td></tr>
<tr><td><code id="tidyst_kde_balloon_+3A_x">x</code></td>
<td>
<p>sf object with point geometry</p>
</td></tr>
<tr><td><code id="tidyst_kde_balloon_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::kde.balloon</code>, <code>ks::kde.sp</code> functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A variable kernel density estimate is a modification of the standard density estimate where the bandwidth matrix is variable. There are two main types: balloon kernel estimates (<code>*_kde_balloon</code>) where the bandwidth varies with the grid point, and sample point kernel estimates (<code>*_kde_sp</code>) where the bandwidth varies with the data points. For details of the computation of the variable kernel estimates and of the bandwidth selector procedure, see <code>ks::kde.balloon</code>, <code>ks::kde.sp</code>.
</p>


<h3>Value</h3>

<p>The outputs from <code>*_kde_balloon</code>, <code>*_kde_sp</code> have the same structure as the standard kernel density estimate from <code><a href="#topic+st_kde">*_kde</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## tidy variable density estimates
data(worldbank, package="ks")
worldbank &lt;- dplyr::as_tibble(worldbank)
wb2 &lt;- na.omit(worldbank[,c("GDP.growth", "inflation")])
xmin &lt;- c(-70,-25); xmax &lt;- c(25,70)

## standard density estimate
t1 &lt;- tidy_kde(wb2, xmin=xmin, xmax=xmax)
## sample point variable density estimate
t2 &lt;- tidy_kde_sp(wb2, xmin=xmin, xmax=xmax)
tt &lt;- c(t1, t2, labels=c("Standard KDE","Sample point KDE"))

## fixed contour levels for all three plots
b &lt;- contour_breaks(tt)
gt &lt;- ggplot2::ggplot(tt, ggplot2::aes(x=GDP.growth, y=inflation)) 
gt + geom_contour_filled_ks(breaks=b, colour=1) + 
    colorspace::scale_fill_discrete_sequential() +
    ggplot2::facet_wrap(~group)

## balloon variable density estimate
## gridsize=c(21,21) only for illustrative purposes
t3 &lt;- tidy_kde_balloon(wb2, xmin=xmin, xmax=xmax, gridsize=c(21,21))
tt &lt;- c(t1, t2, t3, labels=c("Standard KDE","Sample point KDE","Balloon KDE"))
b &lt;- contour_breaks(tt, cont=seq(10,90,by=10))
gt + geom_contour_filled_ks(data=tt, breaks=b, colour=1) + 
    colorspace::scale_fill_discrete_sequential() +
    ggplot2::facet_wrap(~group)

## geospatial variable density estimates
data(wa)
data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")

## standard density estimate
s1 &lt;- st_kde(hakeoides)
## sample point variable density estimate
s2 &lt;- st_kde_sp(hakeoides)   
s3 &lt;- c(s1, s2, labels=c("Standard KDE","Sample point KDE"))
b &lt;- contour_breaks(s3)
bcols &lt;- colorspace::sequential_hcl(nrow(b), palette="Heat2", rev=TRUE)

## base R plot
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(s1, add=TRUE, col=bcols[1:2], breaks=b)
plot(wa, xlim=xlim, ylim=ylim)
plot(s2, add=TRUE, col=bcols, breaks=b)

## geom_sf plot
gs &lt;- ggplot2::ggplot(s3) + ggplot2::geom_sf(data=wa, fill=NA) + 
    ggthemes::theme_map()
gs + ggplot2::geom_sf(data=st_get_contour(s3, breaks=b),  
    ggplot2::aes(fill=contlabel)) + 
    colorspace::scale_fill_discrete_sequential(palette="Heat2") +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim) +
    ggplot2::facet_wrap(~group)
</code></pre>

<hr>
<h2 id='tidyst_kde_boundary'>Tidy and geospatial kernel density estimates with boundary and truncated kernels</h2><span id='topic+tidy_kde_boundary'></span><span id='topic+tidy_kde_truncate'></span><span id='topic+st_kde_boundary'></span><span id='topic+st_kde_truncate'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of kernel density estimates with boundary and truncated kernels for 1- and 2-dimensional data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kde_boundary(data, ...)
tidy_kde_truncate(data, boundary, ...)
st_kde_boundary(x, ...)
st_kde_truncate(x, boundary, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kde_boundary_+3A_data">data</code></td>
<td>
<p>data frame/tibble of data values</p>
</td></tr>
<tr><td><code id="tidyst_kde_boundary_+3A_x">x</code></td>
<td>
<p>sf object with point geometry</p>
</td></tr>
<tr><td><code id="tidyst_kde_boundary_+3A_boundary">boundary</code></td>
<td>
<p>data frame/sf point geometry of boundary</p>
</td></tr> 
<tr><td><code id="tidyst_kde_boundary_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::kde.boundary</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A boundary kernel density estimate is a modification of the standard density estimate for bounded data. There are two main types: beta kernels (<code>boundary.kernel="beta"</code>) and linear kernels (<code>boundary.kernel="linear"</code>). For details of the computation of the boundary kernel estimates and of the bandwidth selector procedure, see <code>ks::kde.boundary</code>. Currently only rectangular boundaries are supported, as defined by <code>xmin</code> x <code>xmax</code>. 
</p>
<p>A truncated kernel density estimate is a modification of the standard density estimate for bounded data. All the probability mass outside of <code>boundary</code> is set to zero and re-assigned over the regions inside in the boundary. The boundary can be any polygon. For further details of the computation of the truncated kernel estimate, see <code>ks::kde.truncate</code>. 
</p>
<p>For details of the computation of the boundary kernel estimates and the truncated kernel density estimates, and of the bandwidth selector procedure, see <code>ks::kde.boundary</code>, <code>ks::kde.truncate</code>.
</p>


<h3>Value</h3>

<p>The outputs from <code>*_kde_boundary</code>, <code>*_kde_truncate</code> have the same structure as the standard kernel density estimate from <code><a href="#topic+st_kde">*_kde</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## tidy boundary density estimates
data(worldbank, package="ks")
worldbank &lt;- dplyr::as_tibble(worldbank)
## percentage data is bounded on [0,100] x [0,100]
wb2 &lt;- na.omit(worldbank[,c("internet", "ag.value")])
xmin &lt;- c(0,0); xmax &lt;- c(100,100)
rectb &lt;- data.frame(x=c(0,100,100,0,0), y=c(0,0,100,100,0))

## standard density estimate
t1 &lt;- tidy_kde(wb2)
## beta boundary density estimate
t2 &lt;- tidy_kde_boundary(wb2, boundary.kernel="beta", xmin=xmin, xmax=xmax)
## linear boundary density estimate
t3 &lt;- tidy_kde_boundary(wb2, boundary.kernel="linear", xmin=xmin, xmax=xmax)
## tidy truncated density estimate
t4 &lt;- tidy_kde_truncate(wb2, boundary=rectb)

t5 &lt;- c(t1, t2, t3, t4, labels=c("Standard KDE","Beta bd KDE", "Linear bd KDE",
    "Truncated KDE"))

## standard estimate exceeds boundary but not boundary or truncated estimates
gr &lt;- ggplot2::geom_polygon(data=rectb, inherit.aes=FALSE, ggplot2::aes(x=x,y=y), 
    fill=NA, colour=1, linetype="dashed")
gt &lt;- ggplot2::ggplot(t5, ggplot2::aes(x=internet,y=ag.value)) 
gt + geom_contour_ks(ggplot2::aes(colour=group)) + gr + 
    ggplot2::facet_wrap(~group)

## geospatial boundary density estimates
data(wa)
data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")
hakeoides_crop &lt;- sf::st_crop(hakeoides, xmin=4e5, xmax=5.7e5, ymin=6.47e6, ymax=7e6)
hakeoides_bbox &lt;- sf::st_as_sfc(sf::st_bbox(hakeoides_crop))
xminb &lt;- sf::st_bbox(hakeoides_crop)[1:2]
xmaxb &lt;- sf::st_bbox(hakeoides_crop)[3:4]
s1 &lt;- st_kde(hakeoides_crop)
s2 &lt;- st_kde_boundary(hakeoides_crop, boundary.kernel="beta", 
    xmin=xminb, xmax=xmaxb)
s3 &lt;- st_kde_boundary(hakeoides_crop, boundary.kernel="linear", 
    xmin=xminb, xmax=xmaxb)
## geospatial truncated density estimate    
s4 &lt;- st_kde_truncate(x=hakeoides_crop, boundary=hakeoides_bbox)
s5 &lt;- c(s1, s2, s3, s4, labels=c("Standard KDE","Beta bd KDE", "Linear bd KDE",
    "Truncated KDE"))

## base R plots
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(hakeoides_bbox, add=TRUE, lty=3, lwd=2)
plot(s1, add=TRUE, border=1, col="transparent", legend=FALSE)
plot(s2, add=TRUE, border=2, col="transparent", legend=FALSE)
mapsf::mf_legend(type="symb", val=c("Standard KDE","Beta bd KDE"), pal=c(1,2), 
    pt_cex=rep(3,2), pt_pch=rep("-",2), title="Density", pos="bottomleft")

plot(wa, xlim=xlim, ylim=ylim)
plot(hakeoides_bbox, add=TRUE, lty=3, lwd=2)
plot(s1, add=TRUE, border=1, col="transparent", legend=FALSE)
plot(s3, add=TRUE, border=3, col="transparent", legend=FALSE)
mapsf::mf_legend(type="symb", val=c("Standard KDE","Linear bd KDE"), pal=c(1,3), 
    pt_cex=rep(3,2), pt_pch=rep("-",2), title="Density", pos="bottomleft")

plot(wa, xlim=xlim, ylim=ylim)
plot(hakeoides_bbox, add=TRUE, lty=3, lwd=2)
plot(s1, add=TRUE, border=1, col="transparent", legend=FALSE)
plot(s4, add=TRUE, border=4, col="transparent", legend=FALSE)
mapsf::mf_legend(type="symb", val=c("Standard KDE","Truncated KDE"), pal=c(1,4), 
    pt_cex=rep(3,2), pt_pch=rep("-",2), title="Density", pos="bottomleft")

## geom_sf plots
gs &lt;- ggplot2::ggplot(s1) + ggplot2::geom_sf(data=wa, fill=NA) + 
    ggplot2::geom_sf(data=hakeoides_bbox, 
    linewidth=1.2, linetype="dotted", fill=NA) + 
    ggplot2::geom_sf(data=dplyr::mutate(st_get_contour(s1), gr="Standard KDE"), 
        ggplot2::aes(colour=gr), fill=NA) + 
    ggthemes::theme_map()
gs + ggplot2::geom_sf(data=st_get_contour(s5), ggplot2::aes(colour=group), fill=NA) +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim) + 
    ggplot2::facet_wrap(~group)
</code></pre>

<hr>
<h2 id='tidyst_kde_local_test'>Tidy and geospatial kernel density based local two-sample comparison tests</h2><span id='topic+tidy_kde_local_test'></span><span id='topic+st_kde_local_test'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of kernel density based local two-sample comparison tests for 1- and 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kde_local_test(data1, data2, labels, ...)
st_kde_local_test(x1, x2, labels, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kde_local_test_+3A_data1">data1</code>, <code id="tidyst_kde_local_test_+3A_data2">data2</code></td>
<td>
<p>data frames/tibbles of data values</p>
</td></tr>
<tr><td><code id="tidyst_kde_local_test_+3A_x1">x1</code>, <code id="tidyst_kde_local_test_+3A_x2">x2</code></td>
<td>
<p>sf objects with point geometry</p>
</td></tr>
<tr><td><code id="tidyst_kde_local_test_+3A_labels">labels</code></td>
<td>
<p>flag or vector of strings for legend labels</p>
</td></tr>
<tr><td><code id="tidyst_kde_local_test_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::kde.local.test</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A kernel local density based two-sample comparison is a modification of the standard kernel density estimate where the two data samples are compared. A Hochberg procedure is employed to control the significance level for multiple comparison tests. 
</p>
<p>For details of the computation of the kernel local density based two-sample comparison test and the bandwidth selector procedure, see <code>?ks::kde.local.test</code>. The bandwidth matrix of smoothing parameters is computed as in <code>ks::kde</code> per data sample. 
</p>
<p>If <code>labels</code> is missing, then the first sample label is taken from <code>x1</code>, and the second sample label from <code>x2</code>. If <code>labels="default"</code> then these are &quot;f1&quot; and &quot;f2&quot;. Otherwise, they are assigned to the values of the input vector of strings.
</p>


<h3>Value</h3>

<p>The output has the same structure as the kernel density estimate from <code><a href="#topic+st_kde">*_kde</a></code>, except that <code>estimate</code> is the difference between the density values <code>data1-data2</code> rather than the density values, and <code>label</code> becomes an indicator factor of the local comparison test result: &quot;f1&lt;f2&quot; = <code>data1 &lt; data2</code>, 0 = <code>data1 = data2</code>, &quot;f2&gt;f1&quot; = <code>data1 &gt; data2</code>.
</p>
<p>The output from <code>st_kde_local_test</code> has two contours, with <code>contlabel=-50</code> (for f1&lt;f2) and <code>contlabel=50</code> (for f1&gt;f2), as multipolygons which delimit the significant difference regions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## tidy local test between unsuccessful and successful grafts
data(hsct, package="ks")
hsct &lt;- dplyr::as_tibble(hsct)
hsct &lt;- dplyr::filter(hsct, PE.Ly65Mac1 &gt;0 &amp; APC.CD45.2&gt;0)
hsct6 &lt;- dplyr::filter(hsct, subject==6)   ## unsuccessful graft 
hsct6 &lt;- dplyr::select(hsct6, PE.Ly65Mac1, APC.CD45.2)
hsct12 &lt;- dplyr::filter(hsct, subject==12) ## successful graft 
hsct12 &lt;- dplyr::select(hsct12, PE.Ly65Mac1, APC.CD45.2)
t1 &lt;- tidy_kde_local_test(data1=hsct6, data2=hsct12)
gt &lt;- ggplot2::ggplot(t1, ggplot2::aes(x=PE.Ly65Mac1, y=APC.CD45.2)) 
gt + geom_contour_filled_ks() + 
    scale_transparent(colorspace::scale_fill_discrete_qualitative(
        palette="Dark2", rev=TRUE, breaks=c("hsct6&lt;hsct12","hsct6&gt;hsct12"), order=c(2,1,3)))

## geospatial local test between Grevillea species
data(wa)
data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")
paradoxa &lt;- dplyr::filter(grevilleasf, species=="paradoxa")
s1 &lt;- st_kde_local_test(x1=hakeoides, x2=paradoxa)

## base R plot
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(s1, add=TRUE)

## geom_sf plot
gs &lt;- ggplot2::ggplot(s1) + ggplot2::geom_sf(data=wa, fill=NA)  + 
    ggthemes::theme_map() 
gs + ggplot2::geom_sf(data=st_get_contour(s1), ggplot2::aes(fill=label)) +
    colorspace::scale_fill_discrete_qualitative(palette="Dark2", rev=TRUE) +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim) 
</code></pre>

<hr>
<h2 id='tidyst_kdr'>Tidy and geospatial kernel density ridge estimates</h2><span id='topic+tidy_kdr'></span><span id='topic+st_kdr'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of kernel density ridge estimates for 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kdr(data, dTolerance, ...)
st_kdr(x, dTolerance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kdr_+3A_data">data</code></td>
<td>
<p>data frame/tibble of data values</p>
</td></tr>
<tr><td><code id="tidyst_kdr_+3A_x">x</code></td>
<td>
<p>sf object with point geometry</p>
</td></tr>
<tr><td><code id="tidyst_kdr_+3A_dtolerance">dTolerance</code></td>
<td>
<p>tolerance parameter in <code>sf::st_simplify</code> for reducing complexity of density ridge</p>
</td></tr>
<tr><td><code id="tidyst_kdr_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::kdr</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A density ridge can be interpreted as the line connecting the peaks in the kernel density estimate, like for a mountain range. It can also be interpreted as the filament generalisation of 2-d principal components.  For details of the computation and the bandwidth selection procedure of the kernel density ridge estimate, see <code>?ks::kdr</code>. The bandwidth matrix of smoothing parameters is computed as in <code>ks::kdde(deriv_order=2)</code>.
</p>
<p>To reduce the complexity of the density ridge, a call to <code>sf::st_simplify(,dTolerance)</code> is made. If <code>dTolerance</code> is missing, then it defaults to approximately the mean distance between each pair of consecutive points in each segment of the density ridge. If <code>dTolerance=0</code> then this step of Ramer-Douglas-Peucker simplification is not carried out.
</p>


<h3>Value</h3>

<p>The output from <code>*_kdr</code> have the same structure as the kernel density estimate from <code><a href="#topic+st_kde">*_kde</a></code>, except that <code>x,y</code> indicate the points on the density ridge, rather than the grid points themselves, and <code>estimate</code> becomes NA. For <code>st_kdr</code>, the density ridge is stored as a multipoints <code>sf</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## tidy density ridge estimate
data(cardio, package="ks")
cardio &lt;- dplyr::as_tibble(cardio[,c("ASTV","Mean")])
set.seed(8192)
cardio &lt;- cardio[sample(1:nrow(cardio), round(nrow(cardio)/4,0)),]
## gridsize=c(21,21) is for illustrative purposes only
## remove for more complete KDR
t1 &lt;- tidy_kdr(cardio, gridsize=c(21,21))
gt &lt;- ggplot2::ggplot(t1, ggplot2::aes(x=ASTV, y=Mean)) 
gt + geom_point_ks(colour=3, alpha=0.8) + 
    ggplot2::geom_path(ggplot2::aes(colour=label, group=segment), size=1.2, alpha=0.8) +
    ggplot2::scale_colour_manual(values=6)

## geospatial density ridge estimate
data(wa)
data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")
## gridsize=c(21,21) is for illustrative purposes only 
## remove for more complete KDR
s1 &lt;- st_kdr(hakeoides, gridsize=c(21,21))

## base R plot
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(sf::st_geometry(hakeoides), add=TRUE, col=3, pch=16)
plot(s1, add=TRUE, col=6, lwd=3, alpha=0.8)

## geom_sf plot
gs &lt;- ggplot2::ggplot(s1) + ggplot2::geom_sf(data=wa, fill=NA) +
    ggthemes::theme_map()
gs + ggplot2::geom_sf(data=hakeoides, colour=3, alpha=0.5) +
    ggplot2::geom_sf(data=s1$sf, ggplot2::aes(colour=label), linewidth=1.2, alpha=0.8) +
    ggplot2::scale_colour_manual(values=6) +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim) 
</code></pre>

<hr>
<h2 id='tidyst_kfs'>Tidy and geospatial kernel feature significance</h2><span id='topic+tidy_kfs'></span><span id='topic+st_kfs'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of kernel feature significance for 1- and 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kfs(data, ...)
st_kfs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kfs_+3A_data">data</code></td>
<td>
<p>data frame/tibble of data values</p>
</td></tr>
<tr><td><code id="tidyst_kfs_+3A_x">x</code></td>
<td>
<p>sf object with point geometry</p>
</td></tr>
<tr><td><code id="tidyst_kfs_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::kfs</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A significant kernel curvature region consist of all points whose density curvature value is significantly different less than zero (i.e. forms a bump surrounding a local maximum). A Hochberg procedure is employed to control the significance level for multiple significance tests. 
</p>
<p>For details of the computation of the significant kernel curvature regions, see <code>?ks::kfs</code>. The bandwidth matrix of smoothing parameters is computed as in <code>ks::kdde(deriv_order=2)</code>.  
</p>


<h3>Value</h3>

<p>The output from <code>tidy_kfs</code> has the same structure as the kernel density estimate from <code><a href="#topic+tidy_kde">tidy_kde</a></code>, except that all values of <code>estimate</code> outside of the significant curvature regions are set to zero, and the <code>label</code> indicates whether the corresponding <code>x,y</code> point is inside a significant curvature region. 
</p>
<p>The output from <code>st_kfs</code> has a single contour, with <code>contlabel=50</code>, as a multipolygon which delimits significant curvature regions. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## tidy significant curvature regions
data(hsct, package="ks")
hsct &lt;- dplyr::as_tibble(hsct)
hsct &lt;- dplyr::filter(hsct, PE.Ly65Mac1&gt;0 &amp; APC.CD45.2&gt;0)
hsct12 &lt;- dplyr::filter(hsct, subject==12)   
hsct12 &lt;- dplyr::select(hsct12, PE.Ly65Mac1, APC.CD45.2)
t1 &lt;- tidy_kfs(hsct12)
gt &lt;- ggplot2::ggplot(t1, ggplot2::aes(x=PE.Ly65Mac1, y=APC.CD45.2)) 
gt + geom_contour_filled_ks(ggplot2::aes(colour=label), colour=1) +
    ggplot2::scale_fill_manual(values=7) 

## geospatial significant curvature regions
data(wa)
data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")
s1 &lt;- st_kfs(hakeoides)

## base R plot
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(s1, add=TRUE)

## geom_sf plot
gs &lt;- ggplot2::ggplot(s1) + ggplot2::geom_sf(data=wa, fill=NA) + 
    ggthemes::theme_map() 
gs + ggplot2::geom_sf(data=st_get_contour(s1, cont=50), ggplot2::aes(fill=label)) +
    ggplot2::scale_fill_manual(values=7) +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim)
</code></pre>

<hr>
<h2 id='tidyst_kms'>Tidy and geospatial kernel mean shift clustering</h2><span id='topic+tidy_kms'></span><span id='topic+st_kms'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of a kernel mean shift clustering for 1- and 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kms(data, ...)
st_kms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kms_+3A_data">data</code></td>
<td>
<p>data frame/tibble of data values</p>
</td></tr>
<tr><td><code id="tidyst_kms_+3A_x">x</code></td>
<td>
<p>sf object with point geometry</p>
</td></tr>
<tr><td><code id="tidyst_kms_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::kms</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mean shift clustering is a generalisation of <code class="reqn">k</code>-means clustering (aka unsupervised learning) which allows for non-ellipsoidal clusters and does not require the number of clusters to be pre-specified. The mean shift clusters are determined by following the initial observations along the density gradient ascent paths to the cluster centre.
</p>
<p>For details of the computation and the bandwidth selection procedure of the kernel mean shift clustering, see <code>?ks::kms</code>. The bandwidth matrix of smoothing parameters is computed as in <code>ks::kdde(deriv_order=1)</code>. 
</p>


<h3>Value</h3>

<p>The output from <code>*_kms</code> have the same structure as the kernel density estimate from <code><a href="#topic+st_kde">*_kde</a></code>, except that <code>x,y</code> indicate the data points rather than the grid points, and <code>estimate</code> indicates the mean shift cluster label of the data points, rather than the density values. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## tidy 2-d mean shift clustering  
data(crabs, package="MASS")
crabs2 &lt;- dplyr::select(crabs, FL, CW)
t1 &lt;- tidy_kms(crabs2)
## convex hulls of clusters
t2 &lt;- dplyr::group_by(t1, estimate)
t2 &lt;- dplyr::slice(t2, chull(FL,CW))

gt &lt;- ggplot2::ggplot(t1, ggplot2::aes(x=FL, y=CW)) 
gt + ggplot2::geom_point(ggplot2::aes(colour=estimate)) +
    ggplot2::geom_polygon(data=t2, ggplot2::aes(fill=estimate), alpha=0.1)

## geospatial mean shift clustering 
data(wa)
data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")
s1 &lt;- st_kms(hakeoides)
## convex hulls of clusters
s2 &lt;- dplyr::group_by(s1$sf, estimate)
s2 &lt;- dplyr::summarise(s2, geometry=sf::st_combine(geometry))
s2 &lt;- sf::st_convex_hull(s2)

## base R plot
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(s1, add=TRUE, pch=16, pal=function(.){
    colorspace::qualitative_hcl(n=., palette="Set2")})
plot(s2, add=TRUE, lty=3, pal=function(.){
    colorspace::qualitative_hcl(n=., palette="Set2", alpha=0.15)})

## geom_sf plot
gs &lt;- ggplot2::ggplot(s1) + ggplot2::geom_sf(data=wa, fill=NA)  + 
    ggthemes::theme_map()
gs + ggplot2::geom_sf(data=s1$sf, ggplot2::aes(colour=estimate), alpha=0.5) + 
    ggplot2::geom_sf(data=s2, ggplot2::aes(fill=estimate), linetype="dotted", 
    alpha=0.15) + 
    colorspace::scale_colour_discrete_qualitative(palette="Set2") +
    colorspace::scale_fill_discrete_qualitative(palette="Set2") +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim) 
</code></pre>

<hr>
<h2 id='tidyst_kquiver'>Tidy and geospatial kernel density quiver estimate</h2><span id='topic+tidy_kquiver'></span><span id='topic+st_kquiver'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of a kernel density quiver estimate for 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kquiver(data, thin=5, transf=1/4, neg.grad=FALSE)
st_kquiver(x, thin=5, transf=1/4, neg.grad=FALSE, scale=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kquiver_+3A_data">data</code></td>
<td>
<p>tidy kernel density gradient estimate (output from <code><a href="#topic+tidy_kdde">tidy_kdde</a>(deriv_order=1)</code>)</p>
</td></tr>
<tr><td><code id="tidyst_kquiver_+3A_x">x</code></td>
<td>
<p>geospatial kernel density gradient estimate (output from <code><a href="#topic+st_kdde">st_kdde</a>(deriv_order=1)</code>)</p>
</td></tr>
<tr><td><code id="tidyst_kquiver_+3A_thin">thin</code></td>
<td>
<p>number to thin out estimation grid. Default is 5.</p>
</td></tr>
<tr><td><code id="tidyst_kquiver_+3A_transf">transf</code></td>
<td>
<p>power index in transformation. Default is 1/4.</p>
</td></tr> 
<tr><td><code id="tidyst_kquiver_+3A_neg.grad">neg.grad</code></td>
<td>
<p>flag to compute arrows in negative gradient direction. Default is FALSE.</p>
</td></tr>
<tr><td><code id="tidyst_kquiver_+3A_scale">scale</code></td>
<td>
<p>scale factor to normalise length of arrows. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A kernel quiver estimate is a modification of the standard kernel density gradient estimate in <code><a href="#topic+st_kdde">*_kdde</a></code> where the density derivatives are not given in the separate groups as indexed in <code>deriv_group</code>, but as extra columns <code>u</code> (for <code>deriv_group=(1,0)</code>) and <code>v</code> (for <code>deriv_group=(0,1)</code>). 
</p>
<p>The bandwidth matrix of smoothing parameters is computed as in <code>ks::kdde(deriv_order=1)</code>.
</p>


<h3>Value</h3>

<p>The output from <code>tidy_kquiver</code> has the same structure as the input kernel density gradient estimate, with the added columns <code>u,v</code> for the density gradient value in the <code class="reqn">x</code>-, <code class="reqn">y</code>-axis. This structure is compatible with the <code>ggquiver::geom_quiver</code> layer function for quiver plots. 
</p>
<p>Since <code>ggquiver::geom_quiver</code> is not compatible with <code>geom_sf</code> layers, the output from <code>st_kquiver</code> has added columns <code>lon</code>, <code>lat</code>, <code>lon_end</code>, <code>lat_end</code>, <code>len</code> which are required in <code>geom_segment</code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## tidy kernel quiver estimate
data(crabs, package="MASS")
crabs2 &lt;- dplyr::select(crabs, FL, CW)
t1 &lt;- tidy_kde(crabs2)
t2 &lt;- tidy_kdde(crabs2, deriv_order=1)
t3 &lt;- tidy_kquiver(t2, thin=5) 
gt &lt;- ggplot2::ggplot(t1, ggplot2::aes(x=FL, y=CW)) 
gt + geom_contour_filled_ks(colour=1, cont=seq(10,90,by=10)) +
    colorspace::scale_fill_discrete_sequential(alpha=0.5) + 
    ggquiver::geom_quiver(data=t3, ggplot2::aes(u=u, v=v), colour=6)

## geospatial kernel `quiver' estimate
data(wa)
data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")
hakeoides_coord &lt;- st_add_coordinates(hakeoides)
s1 &lt;- st_kde(hakeoides)
s2 &lt;- st_kdde(hakeoides, deriv_order=1)
s3 &lt;- st_kquiver(s2, thin=9) 

## base R plot
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(s1, add=TRUE, alpha=0.5)
plot(s3$tidy_ks$ks[[1]], add=TRUE, display="quiver")

## geom_sf plot - ggquiver::geom_quiver not compatible with ggplot2::geom_sf layers
## use instead geom_segment 
gs &lt;- ggplot2::ggplot(s1) + ggplot2::geom_sf(data=wa, fill=NA)  +
    ggthemes::theme_map()
gs + ggplot2::geom_sf(data=st_get_contour(s1),
    ggplot2::aes(fill=label_percent(contlabel)), alpha=0.5) + 
    ggplot2::coord_sf(xlim=xlim, ylim=ylim) + 
    ggplot2::geom_segment(data=s3$sf, 
    ggplot2::aes(x=lon, xend=lon_end, y=lat, yend=lat_end), 
    arrow=grid::arrow(length=0.05*s3$sf$len)) + 
    colorspace::scale_fill_discrete_sequential("Heat2")
</code></pre>

<hr>
<h2 id='tidyst_kroc'>Tidy and geospatial kernel receiver operating characteristic (ROC) curve</h2><span id='topic+tidy_kroc'></span><span id='topic+st_kroc'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of kernel receiver operating characteristic (ROC) curve for 1- and 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_kroc(data1, data2, ...)
st_kroc(x1, x2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_kroc_+3A_data1">data1</code>, <code id="tidyst_kroc_+3A_data2">data2</code></td>
<td>
<p>data frames/tibbles of data values</p>
</td></tr>
<tr><td><code id="tidyst_kroc_+3A_x1">x1</code>, <code id="tidyst_kroc_+3A_x2">x2</code></td>
<td>
<p>sf objects with point geometry</p>
</td></tr>
<tr><td><code id="tidyst_kroc_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::kroc</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A kernel ROC curve is a modification of the standard kernel distribution estimate where the two data samples are compared. For details of the computation and the bandwidth selection procedure of the kernel density ROC curve, see <code>?ks::kroc</code>. The bandwidth matrix of smoothing parameters is computed as in <code>ks::kcde</code> per data sample.
</p>


<h3>Value</h3>

<p>The output has the same structure as the 1-d kernel distribution estimate from <code><a href="#topic+st_kcde">*_kcde</a></code>, except that <code>fpr</code> (<code class="reqn">x</code>-variable) is the false positive rate (complement of specificity) and <code>estimate</code> is the true positive rate (sensitivity), rather than the usual estimation grid points and cdf values. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 2-d kernel ROC curve between unsuccessful and successful grafts
data(hsct, package="ks")
hsct &lt;- dplyr::as_tibble(hsct)
hsct &lt;- dplyr::filter(hsct, PE.Ly65Mac1 &gt;0 &amp; APC.CD45.2&gt;0)
hsct6 &lt;- dplyr::filter(hsct, subject==6)   ## unsuccessful graft 
hsct6 &lt;- dplyr::select(hsct6, PE.Ly65Mac1, APC.CD45.2)
hsct12 &lt;- dplyr::filter(hsct, subject==12) ## successful graft 
hsct12 &lt;- dplyr::select(hsct12, PE.Ly65Mac1, APC.CD45.2)
t1 &lt;- tidy_kroc(data1=hsct6, data2=hsct12)
gt &lt;- ggplot2::ggplot(t1, ggplot2::aes(x=fpr)) 
gt + ggplot2::geom_line(colour=1) 

## geospatial ROC curve between Grevillea species
data(wa)
data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")
paradoxa &lt;- dplyr::filter(grevilleasf, species=="paradoxa")
s1 &lt;- st_kroc(x1=hakeoides, x2=paradoxa)
gs &lt;- ggplot2::ggplot(s1, ggplot2::aes(x=fpr)) 
gs + ggplot2::geom_line(colour=1) 
</code></pre>

<hr>
<h2 id='tidyst_ksupp'>Tidy and geospatial kernel support estimate</h2><span id='topic+tidy_ksupp'></span><span id='topic+st_ksupp'></span>

<h3>Description</h3>

<p>Tidy and geospatial versions of a kernel support estimate for 2-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_ksupp(data, cont=95, convex_hull=TRUE, ...)
st_ksupp(x, cont=95, convex_hull=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_ksupp_+3A_data">data</code></td>
<td>
<p>tidy kernel density estimate (output from <code><a href="#topic+tidy_kde">tidy_kde</a></code>)</p>
</td></tr>
<tr><td><code id="tidyst_ksupp_+3A_x">x</code></td>
<td>
<p>spatial kernel density estimate (output from <code><a href="#topic+st_kde">st_kde</a></code>)</p>
</td></tr>
<tr><td><code id="tidyst_ksupp_+3A_cont">cont</code></td>
<td>
<p>scalar contour level. Default is 95.</p>
</td></tr>
<tr><td><code id="tidyst_ksupp_+3A_convex_hull">convex_hull</code></td>
<td>
<p>flag to compute convex hull of contour region. Default is TRUE.</p>
</td></tr>
<tr><td><code id="tidyst_ksupp_+3A_...">...</code></td>
<td>
<p>other parameters in <code>ks::ksupp</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The kernel support estimate is considered to be the <code>cont</code>% probability contour of the kernel density estimate, with an additional convex hull calculation if <code>convex_hull=TRUE</code>. For details of the computation of the kernel support estimate, see <code>?ks::ksupp</code>.
</p>


<h3>Value</h3>

<p>The output from <code>*_ksupp</code> have the same structure as the kernel density estimate from <code><a href="#topic+st_kde">*_kde</a></code>, except that <code>x,y</code> indicate the boundary of the density support estimate (if <code>convex.hull=TRUE</code>) or the grid points inside the density support (if <code>convex.hull=FALSE</code>), rather than the complete grid points themselves.
</p>
<p>For <code>st_kdr</code>, the density support estimate is stored as a (multi)polygon <code>sf</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## tidy density support estimate
data(crabs, package="MASS")
crabs2 &lt;- dplyr::select(crabs, FL, CW)
t1 &lt;- tidy_kde(crabs2)
t2 &lt;- tidy_ksupp(t1)
gt &lt;- ggplot2::ggplot(t1, ggplot2::aes(x=FL, y=CW)) 
gt + geom_contour_filled_ks(cont=c(25,50,75,95), colour=1) +
    ggplot2::geom_polygon(data=t2, ggplot2::aes(linetype=label), fill=NA, colour=1,
    linewidth=1.2) + colorspace::scale_fill_discrete_sequential() +
    ggplot2::scale_linetype_manual(values="dashed", name="Support\nconvex hull")

gt + ggplot2::geom_polygon(data=t2, ggplot2::aes(colour=label), fill=NA,
    linetype="dashed") + geom_point_ks(data=t1, colour=3) +
    ggplot2::scale_colour_manual(values=1)

## geospatial density support estimate
data(wa)
data(grevilleasf)
hakeoides &lt;- dplyr::filter(grevilleasf, species=="hakeoides")
s1 &lt;- st_kde(hakeoides)
s2 &lt;- st_ksupp(s1)

## base R plot
xlim &lt;- c(1.2e5, 1.1e6); ylim &lt;- c(6.1e6, 7.2e6)
plot(wa, xlim=xlim, ylim=ylim)
plot(s1, cont=c(25,50,75,95), add=TRUE)
plot(sf::st_geometry(hakeoides), add=TRUE, pch=16, col=1)
plot(s2, add=TRUE, lty=2, lwd=2)

## geom_sf plot
gs1 &lt;- ggplot2::ggplot(s1) + ggplot2::geom_sf(data=wa, fill=NA)  + 
    ggthemes::theme_map()
gs1 + ggplot2::geom_sf(data=st_get_contour(s1, cont=c(25,50,75,95)),
    ggplot2::aes(fill=label_percent(contlabel))) +
    ggplot2::geom_sf(data=st_get_contour(s2,cont=95), 
    ggplot2::aes(linetype=contlabel), fill=NA, colour=1) + 
    ggplot2::geom_sf(data=hakeoides, ggplot2::aes(colour=species)) +
    colorspace::scale_fill_discrete_sequential(palette="Heat2") +
    ggplot2::scale_colour_manual(values=1) + 
    ggplot2::guides(colour=ggplot2::guide_legend(title="Locations")) +
    ggplot2::scale_linetype_manual(values="dashed", name="Support\nconvex hull") +
    ggplot2::coord_sf(xlim=xlim, ylim=ylim)
</code></pre>

<hr>
<h2 id='tidyst_plot'>Plots for tidy and geospatial kernel estimates</h2><span id='topic+ggplot.tidy_ks'></span><span id='topic+ggplot.sf_ks'></span><span id='topic+plot.sf_ks'></span><span id='topic+aes_ks'></span><span id='topic+guides_ks'></span><span id='topic+labs_ks'></span>

<h3>Description</h3>

<p>Plots for tidy and geospatial kernel estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidy_ks'
ggplot(data=NULL, mapping=aes(), ...)
## S3 method for class 'sf_ks'
ggplot(data=NULL, mapping=aes(), ..., which_geometry="sf")
## S3 method for class 'sf_ks'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyst_plot_+3A_data">data</code>, <code id="tidyst_plot_+3A_x">x</code></td>
<td>
<p>object of class <code>tidy_ks</code> (output from <code>tidy_k*</code>) or object of class <code>sf_ks</code> (output from <code>st_k*</code>)</p>
</td></tr>
<tr><td><code id="tidyst_plot_+3A_mapping">mapping</code></td>
<td>
<p>default list of aesthetic mappings to use for plot.</p>
</td></tr>
<tr><td><code id="tidyst_plot_+3A_which_geometry">which_geometry</code></td>
<td>
<p>type of geometry to display: one of <code>c("sf", "grid")</code>. Default is <code>"sf"</code>.</p>
</td></tr>
<tr><td><code id="tidyst_plot_+3A_...">...</code></td>
<td>
<p>other graphics parameters. See below.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>tidy_ks</code> objects, the <code>ggplot</code> method adds some default aesthetics based on derived variables in the computed kernel estimate. These are <code>aes(y=estimate, weight=ks)</code> (1-d) and are <code>aes(z=estimate, weight=ks)</code> (2-d). These derived variables computed in the tibble output from <code>tidy_k*</code> are: <code>estimate</code> is the kernel estimate value and <code>ks</code> is the untidy version of the kernel estimate, which is required to compute contour levels. The <code>ggplot</code> method also adds some default labels for the axes and grouping variable, and some default formatting for the legends. These defaults replicate the appearance of the corresponding plots from the <span class="pkg">ks</span> package.  
</p>
<p>For <code>sf_ks</code> objects, the <code>ggplot</code> method is similar to the above method, except no default aesthetics are added. The function header for the <code>plot</code> method is 
</p>
<pre>
    plot(x, which_geometry="sf", percent_label=TRUE, cont=c(25,50,75), 
      abs_cont, which_deriv_ind=1, main="", legend=TRUE, ...)</pre>
<p>where
</p>
  
<dl>
<dt><code>which_geometry</code></dt><dd><p>type of geometry to display: one of <code>c("sf", "grid")</code>. Default is <code>"sf"</code>.</p>
</dd>
<dt><code>cont</code></dt><dd><p>vector of percentages for contour heights</p>
</dd>
<dt><code>abs_cont</code></dt><dd><p>vector of values for contour heights</p>
</dd>
<dt><code>which_deriv_ind</code></dt><dd><p>index for partial derivative for density derivative estimate. Default is 1.</p>
</dd>
<dt><code>main</code></dt><dd><p>main plot label. Default is &quot;&quot;.</p>
</dd>
<dt><code>legend</code></dt><dd><p>flag to add legend. Default is TRUE. The output from <code>mapsf::mf_legend</code> in base <span class="rlang"><b>R</b></span> is not as robust as the legend output in <code>ggplot2</code>.</p>
</dd>
<dt>...</dt><dd><p>other graphics parameters in the <code>plot</code> method for <code>sf</code> objects or for <code>mapsf::mf_legend</code>.</p>
</dd>
</dl>
    


<h3>Value</h3>

<p><code>ggplot</code> plot object is created. Base <span class="rlang"><b>R</b></span> plot is sent to graphics window. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+st_kde">tidy_kde,st_kde</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
