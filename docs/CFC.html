<!DOCTYPE html><html><head><title>Help for package CFC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CFC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bmt'><p>The Bone Marrow Transplant Data</p></a></li>
<li><a href='#cfc'>
<p>Cause-specific competing-risk survival analysis</p></a></li>
<li><a href='#cfc.pbasis'>
<p>Cause-specific competing-risk survival analysis in probability denomination</p></a></li>
<li><a href='#cfc.prepdata'>
<p>Utility function for CFC data preparation</p></a></li>
<li><a href='#cfc.survreg'>
<p>Cause-specific competing-risk survival analysis, using parametric survival regression models</p></a></li>
<li><a href='#cfc.survreg.survprob'>
<p>Survival probability function for <code>survreg</code> models</p></a></li>
<li><a href='#cfc.tbasis'>
<p>Cause-specific competing-risk survival analysis in time denomination</p></a></li>
<li><a href='#summary.cfc'>
<p>Summarizing and plotting output of <code>cfc</code></p></a></li>
<li><a href='#summary.cfc.pbasis'>
<p>Summarizing probability-denominated CFC objects</p></a></li>
<li><a href='#summary.cfc.survreg'>
<p>Summarizing and plotting output of <code>cfc.survreg</code></p></a></li>
<li><a href='#summary.cfc.tbasis'>
<p>Summarizing time-denominated CFC objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cause-Specific Framework for Competing-Risk Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Mansour T.A. Sharabiani, Alireza S. Mahani</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alireza S. Mahani &lt;alireza.s.mahani@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Numerical integration of cause-specific survival curves to arrive at cause-specific cumulative incidence functions,
  with three usage modes: 1) Convenient API for parametric survival regression followed by competing-risk analysis, 2) API for
  CFC, accepting user-specified survival functions in R, and 3) Same as 2, but accepting survival functions in C++. For 
  mathematical details and software tutorial, see Mahani and Sharabiani (2019) &lt;<a href="https://doi.org/10.18637%2Fjss.v089.i09">doi:10.18637/jss.v089.i09</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.1), abind, survival, doParallel, foreach</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-25 22:55:57 UTC; ec2-user</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-09 08:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='bmt'>The Bone Marrow Transplant Data</h2><span id='topic+bmt'></span>

<h3>Description</h3>

<p>Bone marrow transplant data with 408 rows and 5 columns.
</p>


<h3>Format</h3>

<p>The data has 408 rows and 5 columns.
</p>

<dl>
<dt>cause</dt><dd><p>a numeric vector code. 
Survival status. 1: dead from treatment related causes, 
2: relapse , 0: censored.</p>
</dd>
<dt>time</dt><dd><p> a numeric vector. Survival time.  </p>
</dd>
<dt>platelet</dt><dd><p>a numeric vector code. Plalelet 
1: more than 100 x <code class="reqn">10^9</code> per L, 0: less.</p>
</dd>
<dt>tcell</dt><dd><p>a numeric vector. T-cell depleted BMT 1:yes,
0:no.</p>
</dd>
<dt>age</dt><dd><p>a numeric vector code. Age of patient, scaled and
centered ((age-35)/15).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated data (taken from R package 'timereg')  
</p>

<hr>
<h2 id='cfc'>
Cause-specific competing-risk survival analysis
</h2><span id='topic+cfc'></span>

<h3>Description</h3>

<p>Using adaptive generalized Newton-Cotes for calculating cumulative incidence functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfc(f.list, args.list, n, tout, Nmax = 100L, rel.tol = 1e-05, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfc_+3A_f.list">f.list</code></td>
<td>
<p>In <code>R</code> mode, this is a list of survival functions, one per cause. Each survival function must have the prototype <code>f(t, args, n)</code>, where <code>t</code> is a vector of time-from-index values, <code>args</code> is a list of all arguments needed by the function, and <code>n</code> is the iterator that allows the function to produce a different output for each observation and/or Bayesian sample. The output is a vector of survival probabilities at times <code>t</code> for that particular observation/sample combination with iterator value <code>n</code>. In <code>C++</code> mode, this is a list of lists, one per cause. Each list must contain pointers to three <code>C++</code> functions, in order: 1) survival function of type <code>func</code> with prototype defined as <code>typedef arma::vec (*func)(arma::vec x, void* arg, int n)</code> (using <code>RcppArmadillo</code>'s <code>vec</code> class) and a similar interpetation as its <code>R</code> counterpart, 2) initializer function of type <code>initfunc</code>, with prototype defined as <code>typedef void* (*initfunc)(List arg)</code>, where <code>List</code> is the <code>Rcpp</code> wrapper class for <code>R</code> lists, and 3) resource de-allocator function of type <code>freefunc</code> with this prototype: <code>typedef void (*freefunc)(void *arg)</code>. See vignette for <code>C++</code> example.</p>
</td></tr>
<tr><td><code id="cfc_+3A_args.list">args.list</code></td>
<td>
<p>List of arguments (each one a list), one per cause, to be supplied to the survival functions in <code>f.list</code>.</p>
</td></tr>
<tr><td><code id="cfc_+3A_n">n</code></td>
<td>
<p>Range of iterator (starting at <code>1</code>) for survival functions. This can be the product of number of observations, and number of MCMC samplers in a Bayesian survival function.</p>
</td></tr>
<tr><td><code id="cfc_+3A_tout">tout</code></td>
<td>
<p>Vector of time points for which cumulative incidence functions are requested.</p>
</td></tr>
<tr><td><code id="cfc_+3A_nmax">Nmax</code></td>
<td>
<p>Maximum number of subdivisions in the interval [<code>0</code>, <code>max(tout)</code>] to be created in the adaptive quadrature algorithm.</p>
</td></tr>
<tr><td><code id="cfc_+3A_rel.tol">rel.tol</code></td>
<td>
<p>Threshold for relative integration error, used as stoppage criterion. It is calculated as the maximum relative error at time point <code>max(tout)</code> across all causes. Each relative error number is the difference between the Simpson-based and trapezoidal-based numbers, divided by the Simpson-based number.</p>
</td></tr>
<tr><td><code id="cfc_+3A_ncores">ncores</code></td>
<td>
<p>Number of parallel threads to use. This is currrently only implemented in <code>C++</code> mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cfc</code>, which is a list with the following elements:
</p>
<table>
<tr><td><code>ci</code></td>
<td>
<p>Array of dimensions <code>(length(tout), length(f.list), n)</code>, cumulative incidence functions for all causes and all values of the iterator, evaluated at all time points indicated by <code>tout</code>.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>Array of same dimensions as <code>ci</code>, containing the (unadjusted) survival functions for all causes and all values of the iterator, evaluated at all time points indicated by <code>tout</code>.</p>
</td></tr>
<tr><td><code>is.maxiter</code></td>
<td>
<p>Binary Array of length <code>n</code>, where <code>1</code> indicates that subdivision process for quadrature problem applied to survival functions at iteration <code>n</code> reached maximum set by <code>Nmax</code> before converging, and <code>0</code> otherwise.</p>
</td></tr>
<tr><td><code>n.maxiter</code></td>
<td>
<p>Number of iterations that did not converge, i.e., <code>sum(is.maxiter)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mansour T.A. Sharabiani, Alireza S. Mahani
</p>


<h3>References</h3>

<p>Haller, B., Schmidt, G., &amp; Ulm, K. (2013). Applying competing risks regression models: an overview. Lifetime data analysis, 1-26.
</p>
<p>Mahani A.S. and Sharabiani M.T.A. (2019). Bayesian, and Non-Bayesian, Cause-Specific Competing-Risk Analysis for Parametric and Nonparametric Survival Functions: The R Package CFC. Journal of Statistical Software, 89(9), 1-29. doi:10.18637/jss.v089.i09
</p>
<p>Prentice et al (1978). The analysis of failure times in the presence of competing risks. Biometrics, 541-554.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cfc.survreg">cfc.survreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library("survival") # used for constructing survival formulas
library("BSGW") # used for Bayesian survival regression

data("bmt")
# splitting data into training and prediction sets
idx.train &lt;- sample(1:nrow(bmt), size = 0.7 * nrow(bmt))
idx.pred &lt;- setdiff(1:nrow(bmt), idx.train)
nobs.train &lt;- length(idx.train)
nobs.pred &lt;- length(idx.pred)

# prepare data and formula for Bayesian cause-specific survival regression
# using R package BSGW
out.prep &lt;- cfc.prepdata(Surv(time, cause) ~ platelet + age + tcell, bmt)
f1 &lt;- out.prep$formula.list[[1]]
f2 &lt;- out.prep$formula.list[[2]]
dat &lt;- out.prep$dat
tmax &lt;- out.prep$tmax

# estimating cause-specific models
# set nsmp to larger number in real-world applications
nsmp &lt;- 10
reg1 &lt;- bsgw(f1, dat[idx.train, ], control = bsgw.control(iter = nsmp)
  , ordweib = T, print.level = 0)
reg2 &lt;- bsgw(f2, dat[idx.train, ], control = bsgw.control(iter = nsmp)
  , ordweib = T, print.level = 0)

# defining survival function for this model
survfunc &lt;- function(t, args, n) {
  nobs &lt;- args$nobs; natt &lt;- args$natt; nsmp &lt;- args$nsmp
  alpha &lt;- args$alpha; beta &lt;- args$beta; X &lt;- args$X
  idx.smp &lt;- floor((n - 1) / nobs) + 1
  idx.obs &lt;- n - (idx.smp - 1) * nobs
  return (exp(- t ^ alpha[idx.smp] * 
                exp(sum(X[idx.obs, ] * beta[idx.smp, ]))));
}

# preparing function and argument lists
X.pred &lt;- as.matrix(cbind(1, bmt[idx.pred, c("platelet", "age", "tcell")]))
arg.1 &lt;- list(nobs = nobs.pred, natt = 4, nsmp = nsmp
  , alpha = exp(reg1$smp$betas), beta = reg1$smp$beta, X = X.pred)
arg.2 &lt;- list(nobs = nobs.pred, natt = 4, nsmp = nsmp
  , alpha = exp(reg2$smp$betas), beta = reg2$smp$beta, X = X.pred)
arg.list &lt;- list(arg.1, arg.2)
f.list &lt;- list(survfunc, survfunc)

# cause-specific competing-risk
# set rel.tol to smaller number in real-world applications
tout &lt;- seq(from = 0.0, to = tmax, length.out = 10)
out.cfc &lt;- cfc(f.list, arg.list, nobs.pred * nsmp, tout, rel.tol = 1e-2)


## End(Not run)
</code></pre>

<hr>
<h2 id='cfc.pbasis'>
Cause-specific competing-risk survival analysis in probability denomination
</h2><span id='topic+cfc.pbasis'></span>

<h3>Description</h3>

<p>Constructing cumulative incidence and event-free probability functions from cause-specific survival times give for a fixed set of probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfc.pbasis(t1, t2, probs, unity.tol = 1e-06, diff.tol = 0.01,
  diff.tol.policy = c("all", "mean"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfc.pbasis_+3A_t1">t1</code></td>
<td>
<p>Multi-dimensional array containing survival times for cause 1 (i.e. exponential of the negative integral of hazard function). First dimension must correspond to probabilities at which times are calculated. Elements with same time, but distributed in the space of remaining dimensions, are treated independently. These diemensions can correspond, e.g., to observations or samples (in Bayesian frameworks). Survival times must be increasing along the first dimension.</p>
</td></tr>
<tr><td><code id="cfc.pbasis_+3A_t2">t2</code></td>
<td>
<p>Multi-dimensional array containing survival times for cause 2. See note for <code>t1</code>.</p>
</td></tr>
<tr><td><code id="cfc.pbasis_+3A_probs">probs</code></td>
<td>
<p>Probabilities for which survival times are provided in <code>t1</code> and <code>t2</code>. Must begin at 1.0 and be decreasing.</p>
</td></tr>
<tr><td><code id="cfc.pbasis_+3A_unity.tol">unity.tol</code></td>
<td>
<p>Tolerance for difference of survival probability from 1.0 at time=0.0. In other words, we require that <code>abs(probs[1] - 1.0) &lt; unity.tol</code>.</p>
</td></tr>
<tr><td><code id="cfc.pbasis_+3A_diff.tol">diff.tol</code></td>
<td>
<p>Tolerance for change in survival probabilities from one time point to the next. Large changes lead to higher errors during numerical integration.</p>
</td></tr>
<tr><td><code id="cfc.pbasis_+3A_diff.tol.policy">diff.tol.policy</code></td>
<td>
<p>If <code>"mean"</code>, then average change in survival probabilities are compared to <code>diff.tol</code>. If <code>"all"</code>, each values is compared. The latter is more strict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each 'row' of <code>t1</code>, and <code>t2</code>, all elements are processed independently. To combine the survival curves from corresponding elements of <code>t1</code> and <code>t2</code>, we first form a 'comon denominator' time vector by combining the two time vectors and sorting the results (after removing duplicates). We limit the maximum value in the combined time vector to minimum of the the two maxima from each cause. Next, we use interpolation to find survival probabilities of each cause at all the time points in the combined time vector. Finally, we call the function <code><a href="#topic+cfc.tbasis">cfc.tbasis</a></code>.
</p>


<h3>Value</h3>

<p>If <code>t1</code> and <code>t2</code> are one-dimensional, a matrix with columns named <code>"time"</code>, <code>"ci1"</code>, <code>"ci2"</code> and <code>"efp"</code> is returned. For multi-dimensional arrays, a list is returned with one such matrix for each element of the consolidated dimension representing all but the first dimension of <code>t1</code> and <code>t2</code>.
</p>


<h3>Author(s)</h3>

<p>Mansour T.A. Sharabiani, Alireza S. Mahani
</p>


<h3>References</h3>

<p>Mahani A.S. and Sharabiani M.T.A. (2019). Bayesian, and Non-Bayesian, Cause-Specific Competing-Risk Analysis for Parametric and Nonparametric Survival Functions: The R Package CFC. Journal of Statistical Software, 89(9), 1-29. doi:10.18637/jss.v089.i09
</p>
<p>Prentice et al (1978). The analysis of failure times in the presence of competing risks. Biometrics, 541-554.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cfc.tbasis">cfc.tbasis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# prepare data for cause-specific competing-risk analysis
data(bmt)
bmt$status1 &lt;- 1*(bmt$cause==1)
bmt$status2 &lt;- 1*(bmt$cause==2)
f1 &lt;- Surv(time, status1) ~ platelet + age + tcell
f2 &lt;- Surv(time, status2) ~ platelet + age + tcell

# perform weibull regression on each cause independently
library(survival)
reg1 &lt;- survreg(f1, bmt)
reg2 &lt;- survreg(f2, bmt)

# predict times for given probabilities
# transpose predictions so that first dimension
# is time/probability (use first 50 observations for speed)
pvec &lt;- seq(from=1.0, to = 0.1, length.out = 100)
pred1 &lt;- t(predict(reg1, newdata = bmt[1:50,], p = 1-pvec, type = "quantile"))
pred2 &lt;- t(predict(reg2, newdata = bmt[1:50,], p = 1-pvec, type = "quantile"))

# cause-specific competing risk analysis - probability mode
my.cfc &lt;- cfc.pbasis(pred1, pred2, probs = pvec)

# calculating averages across observations (e.g. patients in the study)
my.summ &lt;- summary(my.cfc)

# plotting average CI and event-free probability curves
plot(my.summ)


## End(Not run)
</code></pre>

<hr>
<h2 id='cfc.prepdata'>
Utility function for CFC data preparation
</h2><span id='topic+cfc.prepdata'></span>

<h3>Description</h3>

<p>Preparing a data frame and formulas for cause-specific competing-risk survival analysis. It expands the multi-state status column into a series of binary columns by treating an event for a cause as censoring for all other causes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfc.prepdata(formul, dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfc.prepdata_+3A_formul">formul</code></td>
<td>
<p>Original survival formula.</p>
</td></tr>
<tr><td><code id="cfc.prepdata_+3A_dat">dat</code></td>
<td>
<p>Original data frame, with <code>status</code> column being an integer with values from <code>0</code> to <code>K</code>. The value <code>0</code> represents right-censoring, while <code>1</code> to <code>K</code> represent the <code>K</code> mutually-exclusive events.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output data frame will have <code>K</code> new binary status columns. The <code>K</code> new status columns will be named <code>"status_1"</code>, <code>"status_2"</code> through <code>"status_&lt;K&gt;"</code>. Each of the output formulas in <code>formula.list</code> field will have the corresponding <code>status</code>. Column &quot;status_1&quot; will be <code>1</code> wherever <code>status</code> equals <code>1</code> in original data frame, and <code>0</code> elsewhere, and similarly for the remaining <code>K-1</code> newly-added status columns.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>K</code></td>
<td>
<p>Number of causes.</p>
</td></tr>
<tr><td><code>dat</code></td>
<td>
<p>Expanded data frame.</p>
</td></tr>
<tr><td><code>formula.list</code></td>
<td>
<p>A list of <code>K</code> formulas, each corresponding to one of the cause-specific survival models to be estimated. See details.</p>
</td></tr>
<tr><td><code>formula.noresp</code></td>
<td>
<p>A formula with no left-hand side (time and status variables). This can be used for preparing the model matrix for prediction data sets, which can possibly have no response.</p>
</td></tr>
<tr><td><code>tmax</code></td>
<td>
<p>Maximum time to event/censoring extracted from original data frame. This can be used, e.g., during competing-risk analysis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mansour T.A. Sharabiani, Alireza S. Mahani
</p>


<h3>References</h3>

<p>Mahani A.S. and Sharabiani M.T.A. (2019). Bayesian, and Non-Bayesian, Cause-Specific Competing-Risk Analysis for Parametric and Nonparametric Survival Functions: The R Package CFC. Journal of Statistical Software, 89(9), 1-29. doi:10.18637/jss.v089.i09
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bmt)
prep.out &lt;- cfc.prepdata(Surv(time, cause) ~ platelet + age + tcell, bmt)
</code></pre>

<hr>
<h2 id='cfc.survreg'>
Cause-specific competing-risk survival analysis, using parametric survival regression models
</h2><span id='topic+cfc.survreg'></span>

<h3>Description</h3>

<p>Convenient function to build cause-specific, parametric survival models using the <span class="pkg">survival</span> package. This is followed by application of <code>cfc</code> function to produce cumulative incidence functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfc.survreg(formula, data, newdata = NULL, dist = "weibull"
  , control = survreg.control(), tout, Nmax = 100L
  , rel.tol = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfc.survreg_+3A_formula">formula</code></td>
<td>
<p>Survival formula with a multi-state status variable. See <code>cfc.prepdata</code>.</p>
</td></tr>
<tr><td><code id="cfc.survreg_+3A_data">data</code></td>
<td>
<p>Data frame containing variables listed in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="cfc.survreg_+3A_newdata">newdata</code></td>
<td>
<p>Data frame of structure similar to <code>data</code>, perhaps without the time and status columns, to be used for generating cumulative incidence curves.</p>
</td></tr>
<tr><td><code id="cfc.survreg_+3A_dist">dist</code></td>
<td>
<p>One of <code>survreg.distributions</code>. It can also be a vector, in which case elements <code>1</code> through <code>K</code> (number of causes) will be extracted and assigned to each cause-specific survival model. This allows for using different distributions for different causes.</p>
</td></tr>
<tr><td><code id="cfc.survreg_+3A_control">control</code></td>
<td>
<p>List of <code>survreg</code> control parameters, according to <code>survreg.control</code>.</p>
</td></tr>
<tr><td><code id="cfc.survreg_+3A_tout">tout</code></td>
<td>
<p>Time points, along which to produce the cumulative incidence curves.</p>
</td></tr>
<tr><td><code id="cfc.survreg_+3A_nmax">Nmax</code></td>
<td>
<p>Maximum number of subdivisions to be used in the <code>cfc</code> quadrature algorithm.</p>
</td></tr>
<tr><td><code id="cfc.survreg_+3A_rel.tol">rel.tol</code></td>
<td>
<p>Threshold for relative error in <code>cfc</code> quadrature, used as a stoppage criterion. See <code>cfc</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>K</code></td>
<td>
<p>Number of causes.</p>
</td></tr>
<tr><td><code>formulas</code></td>
<td>
<p>List of formulas used in each of the <code>K</code> cause-specific survival regression models.</p>
</td></tr>
<tr><td><code>regs</code></td>
<td>
<p>List of all cause-specific regression objects returned by <code>survreg</code>, one per cause. The <code>x</code> field of each regression object has been substituted by the model matrix from <code>newdata</code>.</p>
</td></tr>
<tr><td><code>tout</code></td>
<td>
<p>Same as input.</p>
</td></tr>
<tr><td><code>cfc</code></td>
<td>
<p>An object of class <code>cfc</code>, the output of applying <code>cfc</code> to the parametric survival regression models constructed using <code>survreg</code> from <span class="pkg">survival</span> package.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mansour T.A. Sharabiani, Alireza S. Mahani
</p>


<h3>References</h3>

<p>Mahani A.S. and Sharabiani M.T.A. (2019). Bayesian, and Non-Bayesian, Cause-Specific Competing-Risk Analysis for Parametric and Nonparametric Survival Functions: The R Package CFC. Journal of Statistical Software, 89(9), 1-29. doi:10.18637/jss.v089.i09
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cfc.prepdata">cfc.prepdata</a></code>, <code><a href="#topic+cfc">cfc</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bmt)
formul &lt;- Surv(time, cause) ~ platelet + age + tcell
ret &lt;- cfc.survreg(formul, bmt[1:300, ], bmt[-(1:300), ]
  , Nmax = 300, rel.tol = 1e-3)
</code></pre>

<hr>
<h2 id='cfc.survreg.survprob'>
Survival probability function for <code>survreg</code> models
</h2><span id='topic+cfc.survreg.survprob'></span>

<h3>Description</h3>

<p>Function for predicting survival probability as a function of time for <code>survreg</code> regression objects in <span class="pkg">survival</span> package. It can be used to mix <code>survreg</code> models with other survival models in competing-risk analysis, using <span class="pkg">CFC</span> package. This function is used inside <code>cfc.survreg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfc.survreg.survprob(t, args, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfc.survreg.survprob_+3A_t">t</code></td>
<td>
<p>Time from index. Must be non-negative, but can be a vector.</p>
</td></tr>
<tr><td><code id="cfc.survreg.survprob_+3A_args">args</code></td>
<td>
<p>Regression object that is returned by <code>survreg</code>. If using <code>newdata</code> for prediction, the <code>x</code> field of this object must be updated accordingly.</p>
</td></tr>
<tr><td><code id="cfc.survreg.survprob_+3A_n">n</code></td>
<td>
<p>Observation index, must be between <code>1</code> and <code>nrow(args$x)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of survival probabilities at time(s) <code>t</code>.
</p>


<h3>Author(s)</h3>

<p>Mansour T.A. Sharabiani, Alireza S. Mahani
</p>


<h3>References</h3>

<p>Mahani A.S. and Sharabiani M.T.A. (2019). Bayesian, and Non-Bayesian, Cause-Specific Competing-Risk Analysis for Parametric and Nonparametric Survival Functions: The R Package CFC. Journal of Statistical Software, 89(9), 1-29. doi:10.18637/jss.v089.i09
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cfc.survreg">cfc.survreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("CFC") # for cfc
data(bmt)
library("randomForestSRC") # for rfsrc
library("survival") # for survreg

prep &lt;- cfc.prepdata(Surv(time, cause) ~ platelet + age + tcell, bmt)
f1 &lt;- prep$formula.list[[1]]
f2 &lt;- prep$formula.list[[2]]
dat &lt;- prep$dat
tmax &lt;- prep$tmax

# building a parametric Weibull regression model
# for cause 1
reg1 &lt;- survreg(f1, dat, x = TRUE) # must keep x for prediction

# building a random forest survival model for cause 2
reg2 &lt;- rfsrc(f2, dat)
# implementing a continuous interface for the random forest
# survival function
rfsrc.survfunc &lt;- function(t, args, n) {
  which.zero &lt;- which(t &lt; .Machine$double.eps)
  ret &lt;- approx(args$time.interest, args$survival[n, ], t, rule = 2)$y
  ret[which.zero] &lt;- 1.0
  return (ret)
}

# constructing function and argument list
f.list &lt;- list(cfc.survreg.survprob, rfsrc.survfunc)
arg.list &lt;- list(reg1, reg2)

# competing-risk analysis
tout &lt;- seq(0.0, tmax, length.out = 10)
# increase rel.tol for higher accuracy
cfc.out &lt;- cfc(f.list, arg.list, nrow(bmt), tout, rel.tol = 1e-3)


## End(Not run)
</code></pre>

<hr>
<h2 id='cfc.tbasis'>
Cause-specific competing-risk survival analysis in time denomination
</h2><span id='topic+cfc.tbasis'></span>

<h3>Description</h3>

<p>Constructing cumulative incidence and event-free probability functions from cause-specific survival probabilities evaluated at fixed time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfc.tbasis(p1, p2, unity.tol = 1e-06, diff.tol = 0.01,
  diff.tol.policy = c("mean", "all"), check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfc.tbasis_+3A_p1">p1</code></td>
<td>
<p>Multi-dimensional array containing survival probabilities for cause 1 (i.e. exponential of the negative integral of hazard function). First dimension must correspond to time points at which probabilities are calculated. Elements with same time, but distributed in the space of remaining dimensions, are treated independently. These diemensions can correspond, e.g., to observations or samples (in Bayesian frameworks).</p>
</td></tr>
<tr><td><code id="cfc.tbasis_+3A_p2">p2</code></td>
<td>
<p>Multi-dimensional array containing survival probabilities for cause 2. See note for <code>p1</code>.</p>
</td></tr>
<tr><td><code id="cfc.tbasis_+3A_unity.tol">unity.tol</code></td>
<td>
<p>Tolerance for difference of survival probabilities from 1.0 at time=0.0, which is the first 'row' of arrays <code>p1</code> and <code>p2</code>. For example, for two-dimensional arrays, we need <code>all(abs(p1[1,]-1.0) &lt; unity.tol)</code>, and a similar condition for <code>p2</code>.</p>
</td></tr>
<tr><td><code id="cfc.tbasis_+3A_diff.tol">diff.tol</code></td>
<td>
<p>Tolerance for change in survival probabilities from one time point to the next. Large changes lead to higher errors during numerical integration.</p>
</td></tr>
<tr><td><code id="cfc.tbasis_+3A_diff.tol.policy">diff.tol.policy</code></td>
<td>
<p>If <code>"mean"</code>, then average change in survival probabilities are compared to <code>diff.tol</code>. If <code>"all"</code>, each values is compared. The latter is more strict.</p>
</td></tr>
<tr><td><code id="cfc.tbasis_+3A_check">check</code></td>
<td>
<p>Boolean flag indicating whether or not to check probability arrays for validity. Current validity checks are: 1) ensuring all probabilities are between 0.0 and 1.0, 2) all probabilities at time=0.0 are equal to 1.0 (see <code>unity.tol</code>), 3) No changes in probabilities from one time point to next are too large (see <code>diff.tol</code>). Dimensional consistency between <code>p1</code> and <code>p2</code> is always checked regardless of the value of this flag.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assuming one-dimensional <code>p1</code> and <code>p2</code> for clarity, the algorithm calculates cumulative incidence function for cuase 1 using a recursive formula: <code>ci1[n+1] = ci1[n] + dci1[n]</code>, where <code>dci1[n] = 0.5*(p2[n] + p2[n+1])*(p1[n] - p1[n+1])</code>. The increment in cumulative incidence function for cause 2 is similarly calculated, <code>dci2[n] = 0.5*(p1[n] + p1[n+1])*(p2[n] - p2[n+1])</code>. These equations guarantee that <code>dci1[n] + dci2[n] = p1[n]*p2[n] - p1[n+1]*p2[n+1]</code>. Event-free probability is simply calculated as codeefp[n] = p1[n]*p2[n]. Taken together, this numerical integration ensures that <code>efp[n+1] - efp[n] + dci1[n] + dci2[n] = 0</code>.
</p>


<h3>Value</h3>

<p>If <code>p1</code> and <code>p2</code> are one-dimensional arrays (i.e. vectors), a matrix with columns named <code>"ci1"</code>, <code>"ci2"</code> and <code>"efp"</code> is returned, representing the cummulative incidence functions for cause 1 and cause 2 and the event-free probability, evaluated at same time points as <code>p1</code> and <code>p2</code> are provided. If <code>p1</code> and <code>p2</code> are multi-dimensional arrays, a list is returned with elements <code>"ci1"</code>, <code>"ci2"</code> and <code>"efp"</code>, each one with the same interpretation, and all of the same dimensions as <code>p1</code> and <code>p2</code>.
</p>


<h3>Note</h3>

<p>The integration algorithm described above does not require knowledge of time step. (Alternatively, using hazard functions for integration would have required specification of time step.) Since <code>p1</code> and <code>p2</code> are integrals (followed by exponentiation) of cause-specific hazard functions, using them directly adds to robustness of numerical integration and avoids error accumulation. The returned cumulative incidence and event-free probabilities correspond to the same time points assumed for input cause-specific probabilities.
</p>


<h3>Author(s)</h3>

<p>Mansour T.A. Sharabiani, Alireza S. Mahani
</p>


<h3>References</h3>

<p>Mahani A.S. and Sharabiani M.T.A. (2019). Bayesian, and Non-Bayesian, Cause-Specific Competing-Risk Analysis for Parametric and Nonparametric Survival Functions: The R Package CFC. Journal of Statistical Software, 89(9), 1-29. doi:10.18637/jss.v089.i09
</p>
<p>Prentice et al (1978). The analysis of failure times in the presence of competing risks. Biometrics, 541-554.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cfc.pbasis">cfc.pbasis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# prepare data for cause-specific competing-risk analysis
data(bmt)
bmt$status1 &lt;- 1*(bmt$cause==1)
bmt$status2 &lt;- 1*(bmt$cause==2)
f1 &lt;- Surv(time, status1) ~ platelet + age + tcell
f2 &lt;- Surv(time, status2) ~ platelet + age + tcell

# sample-based bayesian weibull regression
library(BSGW)
reg1 &lt;- bsgw(f1, bmt, ordweib = TRUE, control = bsgw.control(iter = 500, burnin = 100, nskip = 50))
reg2 &lt;- bsgw(f2, bmt, ordweib = TRUE, control = bsgw.control(iter = 500, burnin = 100, nskip = 50))

# prediction on a uniform grid of 100 time points
# (use first 50 observations for speed)
pred1 &lt;- predict(reg1, newdata = bmt[1:50,], tvec = 100)
pred2 &lt;- predict(reg2, newdata = bmt[1:50,], tvec = 100)

# permuting dimensions of survival objects to conform with cfc
S1 &lt;- aperm(pred1$smp$S, c(2,1,3))
S2 &lt;- aperm(pred2$smp$S, c(2,1,3))

# cause-specific competing risk analysis - time mode
my.cfc &lt;- cfc.tbasis(S1, S2)

# calculating averages across observations (e.g. patients in the study)
my.summ &lt;- summary(my.cfc, MARGIN = c(1,2))

# plotting mean CI and event-free functions
# as well as their sampled-based confidence intervals
plot(my.summ, t = pred1$tvec)



## End(Not run)
</code></pre>

<hr>
<h2 id='summary.cfc'>
Summarizing and plotting output of <code>cfc</code>
</h2><span id='topic+summary.cfc'></span><span id='topic+plot.summary.cfc'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code><a href="#topic+cfc">cfc</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cfc'
summary(object
  , f.reduce = function(x) x
  , pval = 0.05, ...)
## S3 method for class 'summary.cfc'
plot(x, which = c(1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cfc_+3A_object">object</code></td>
<td>
<p>An object of class &quot;cfc&quot;, usually the result of a call to <code><a href="#topic+cfc">cfc</a></code>.</p>
</td></tr>
<tr><td><code id="summary.cfc_+3A_f.reduce">f.reduce</code></td>
<td>
<p>Function to be applied to each sub-array of <code>object$ci</code> (cumulative incidence) and <code>object$s</code> (survival probability).</p>
</td></tr>
<tr><td><code id="summary.cfc_+3A_pval">pval</code></td>
<td>
<p>Desired significance level for confidence intervals produced by <code>summary.cfc</code>. We essentially set the argument <code>probs</code> to <code>c(pval/2, 0.5, 1-pval/2)</code> when calling <code>quantile</code>.</p>
</td></tr>
<tr><td><code id="summary.cfc_+3A_x">x</code></td>
<td>
<p>An object of class &quot;summary.cfc&quot;, usually the result of a call to <code><a href="#topic+summary.cfc">summary.cfc</a></code>.</p>
</td></tr>
<tr><td><code id="summary.cfc_+3A_which">which</code></td>
<td>
<p>Vector of integers, indicating which plot(s) must be produced: 1) cumulative incidence functions, one per cause. For each cause, median and credible bands are plotted vs. time-from-index. 2) (unadjusted) survival functions, one per cause. Similar to (1), median and credible bands are plotted.</p>
</td></tr>
<tr><td><code id="summary.cfc_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>f.reduce</code> (for <code>summary.cfc</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Recall that the survival probability and cumulative incidence arrays returned by <code>cfc</code> are three-dimensional, and their first two dimensions indicate 1) time points and 2) causes. <code>f.reduce</code> is expected to produce an array of a fixed length, when applied to each sub-array, <code>ci[i, j, ]</code> and <code>s[i, j, ]</code>. The end-result is two three-dimensional array, where the first two dimensions are identical to its input arrays. This 3D array is then passed to the <code>quantile</code> function to compute median and credible bands. There is a special case where <code>f.reduce</code> returns a scalar, rather than an array, when applied to each sub-array. In this case, quantile calculation is meaningless and we return simply these point estimates. In summary, the return object from <code>summary</code> is a list with elements: 1) <code>ci</code> (cumulative incidence), 2) <code>s</code> (survival), and 3) <code>quantiles</code>, a boolean flag indicating whether the cumulative incidence and survival arrays returned are quantiles or point estimates.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani</p>


<h3>References</h3>

<p>Mahani A.S. and Sharabiani M.T.A. (2019). Bayesian, and Non-Bayesian, Cause-Specific Competing-Risk Analysis for Parametric and Nonparametric Survival Functions: The R Package CFC. Journal of Statistical Software, 89(9), 1-29. doi:10.18637/jss.v089.i09
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cfc">cfc</a></code>, <code><a href="base.html#topic+summary">summary</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library("BSGW") # used for Bayesian survival regression

data(bmt)
# splitting data into training and prediction sets
idx.train &lt;- sample(1:nrow(bmt), size = 0.7 * nrow(bmt))
idx.pred &lt;- setdiff(1:nrow(bmt), idx.train)
nobs.train &lt;- length(idx.train)
nobs.pred &lt;- length(idx.pred)

# prepare data and formula for Bayesian cause-specific survival regression
# using R package BSGW
out.prep &lt;- cfc.prepdata(Surv(time, cause) ~ platelet + age + tcell, bmt)
f1 &lt;- out.prep$formula.list[[1]]
f2 &lt;- out.prep$formula.list[[2]]
dat &lt;- out.prep$dat
tmax &lt;- out.prep$tmax

# estimating cause-specific models
# set nsmp to larger number in real-world applications
nsmp &lt;- 10
reg1 &lt;- bsgw(f1, dat[idx.train, ], control = bsgw.control(iter = nsmp)
  , ordweib = T, print.level = 0)
reg2 &lt;- bsgw(f2, dat[idx.train, ], control = bsgw.control(iter = nsmp)
  , ordweib = T, print.level = 0)

# defining survival function for this model
survfunc &lt;- function(t, args, n) {
  nobs &lt;- args$nobs; natt &lt;- args$natt; nsmp &lt;- args$nsmp
  alpha &lt;- args$alpha; beta &lt;- args$beta; X &lt;- args$X
  idx.smp &lt;- floor((n - 1) / nobs) + 1
  idx.obs &lt;- n - (idx.smp - 1) * nobs
  return (exp(- t ^ alpha[idx.smp] * 
                exp(sum(X[idx.obs, ] * beta[idx.smp, ]))));
}

# preparing function and argument lists
X.pred &lt;- as.matrix(cbind(1, bmt[idx.pred, c("platelet", "age", "tcell")]))
arg.1 &lt;- list(nobs = nobs.pred, natt = 4, nsmp = nsmp
  , alpha = exp(reg1$smp$betas), beta = reg1$smp$beta, X = X.pred)
arg.2 &lt;- list(nobs = nobs.pred, natt = 4, nsmp = nsmp
  , alpha = exp(reg2$smp$betas), beta = reg2$smp$beta, X = X.pred)
arg.list &lt;- list(arg.1, arg.2)
f.list &lt;- list(survfunc, survfunc)

# cause-specific competing-risk
# set rel.tol to smaller number in real-world applications
out.cfc &lt;- cfc(f.list, arg.list, nobs.pred * nsmp, tout, rel.tol = 1e-2)

# summarizing (and plotting) the results
# this function calculates the population-average CI and survival, one
# per each MCMC sample; therefore, the quantiles produced by the summary
# method, correspondingly, reflect our confidence in population-average values
my.f.reduce &lt;- function(x, nobs, nsmp) {
  return (colMeans(array(x, dim = c(nobs, nsmp))))
}
my.summ &lt;- summary(out.cfc, f.reduce = my.f.reduce, nobs = nobs.pred, nsmp = nsmp)


## End(Not run)
</code></pre>

<hr>
<h2 id='summary.cfc.pbasis'>
Summarizing probability-denominated CFC objects
</h2><span id='topic+summary.cfc.pbasis'></span><span id='topic+plot.summary.cfc.pbasis'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code><a href="#topic+cfc.pbasis">cfc.pbasis</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cfc.pbasis'
summary(object, ...)
## S3 method for class 'summary.cfc.pbasis'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cfc.pbasis_+3A_object">object</code></td>
<td>
<p>An object of class &quot;cfc.pbasis&quot;, usually the result of a call to <code><a href="#topic+cfc.pbasis">cfc.pbasis</a></code>.</p>
</td></tr>
<tr><td><code id="summary.cfc.pbasis_+3A_x">x</code></td>
<td>
<p>An object of class &quot;summary.cfc.pbasis&quot;, usually the result of a call to <code>summary.cfc.pbasis</code>.</p>
</td></tr>
<tr><td><code id="summary.cfc.pbasis_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to/from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.cfc.pbasis</code> calculates the average of cumulative incidence and event-free probability functions at each time point across all elements of the object list. If the object is a matrix, it is returned without change.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani</p>


<h3>References</h3>

<p>Mahani A.S. and Sharabiani M.T.A. (2019). Bayesian, and Non-Bayesian, Cause-Specific Competing-Risk Analysis for Parametric and Nonparametric Survival Functions: The R Package CFC. Journal of Statistical Software, 89(9), 1-29. doi:10.18637/jss.v089.i09
</p>


<h3>See Also</h3>

<p>The model fitting function is <code><a href="#topic+cfc.pbasis">cfc.pbasis</a></code>. See <code><a href="base.html#topic+summary">summary</a></code> and <code><a href="graphics.html#topic+plot">plot</a></code> for descriptions of the generic methods. See <code><a href="#topic+cfc.tbasis">cfc.tbasis</a></code> for time-denominated CFC, as well as usage examples.
</p>

<hr>
<h2 id='summary.cfc.survreg'>
Summarizing and plotting output of <code>cfc.survreg</code>
</h2><span id='topic+summary.cfc.survreg'></span><span id='topic+plot.summary.cfc.survreg'></span>

<h3>Description</h3>

<p><code>summary</code> and method for class <code><a href="#topic+cfc.survreg">cfc.survreg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cfc.survreg'
summary(object, obs.idx = "all", ...)
## S3 method for class 'summary.cfc.survreg'
plot(x, which = c(1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cfc.survreg_+3A_object">object</code></td>
<td>
<p>An object of class &quot;cfc.survreg&quot;, usually the result of a call to <code><a href="#topic+cfc.survreg">cfc.survreg</a></code>.</p>
</td></tr>
<tr><td><code id="summary.cfc.survreg_+3A_obs.idx">obs.idx</code></td>
<td>
<p>Index of observations to calculate mean cumulative incidence for; defaults to all observation.</p>
</td></tr>
<tr><td><code id="summary.cfc.survreg_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to/from other methods.</p>
</td></tr>
<tr><td><code id="summary.cfc.survreg_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary.cfc.survreg</code>, usually the output of <code>summary.cfc.survreg</code>.</p>
</td></tr>
<tr><td><code id="summary.cfc.survreg_+3A_which">which</code></td>
<td>
<p>Vector of integers, indicating which plot(s) must be produced: 1) cumulative incidence functions, one per cause, as a function of time-to-index, all in the same plot, 2) comparison of cumulative incidence function with/without competing-risk adjustment. The unadjusted figure is equivalent to 1 minus the Kaplan-Meyer (i.e., survival) function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.cfc.surveeg</code> produces a matrix of dimensions <code>length(object$tout)</code> (number of time points) by <code>object$K</code> (number of causes). See description of <code>which</code> aregument for <code>plot.summary.cfc.survreg</code>.
</p>


<h3>Author(s)</h3>

<p>Mansour T.A. Sharabiani, Alireza S. Mahani</p>


<h3>References</h3>

<p>Mahani A.S. and Sharabiani M.T.A. (2019). Bayesian, and Non-Bayesian, Cause-Specific Competing-Risk Analysis for Parametric and Nonparametric Survival Functions: The R Package CFC. Journal of Statistical Software, 89(9), 1-29. doi:10.18637/jss.v089.i09
</p>


<h3>See Also</h3>

<p>The model fitting function is <code><a href="#topic+cfc.survreg">cfc.survreg</a></code>. See <code><a href="base.html#topic+summary">summary</a></code> and <code><a href="graphics.html#topic+plot">plot</a></code> for descriptions of the generic methods. For more flexible ways of cause-specific competing-risk analysis, see <code><a href="#topic+cfc">cfc</a></code>.
</p>

<hr>
<h2 id='summary.cfc.tbasis'>
Summarizing time-denominated CFC objects
</h2><span id='topic+summary.cfc.tbasis'></span><span id='topic+plot.summary.cfc.tbasis'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code><a href="#topic+cfc.tbasis">cfc.tbasis</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cfc.tbasis'
summary(object,
  MARGIN = if (class(object)[2] == "matrix") NULL else 1,
  ...)
## S3 method for class 'summary.cfc.tbasis'
plot(x, t = 1, ci = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cfc.tbasis_+3A_object">object</code></td>
<td>
<p>An object of class &quot;cfc.tbasis&quot;, usually the result of a call to <code><a href="#topic+cfc.tbasis">cfc.tbasis</a></code>.</p>
</td></tr>
<tr><td><code id="summary.cfc.tbasis_+3A_margin">MARGIN</code></td>
<td>
<p>Dimensions of cumulative incidence and event-free probability arrays to keep while averaging the remaining dimensions. If the <code>cfc.tbasis</code> object is a matrix, no averaging is performed, and the function returns the object unchanged. Note that for list objects, <code>MARGIN</code> must include <code>1</code> since it is meaningless to average out the time/probability dimension (which is always the first one).</p>
</td></tr>
<tr><td><code id="summary.cfc.tbasis_+3A_x">x</code></td>
<td>
<p>An object of class &quot;summary.cfc.tbasis&quot;, usually the result of a call to <code>summary.cfc.tbasis</code>.</p>
</td></tr>
<tr><td><code id="summary.cfc.tbasis_+3A_t">t</code></td>
<td>
<p>Regular time step, or vector of time values, used for producing cumulative incidence and event-free probability plots.</p>
</td></tr>
<tr><td><code id="summary.cfc.tbasis_+3A_ci">ci</code></td>
<td>
<p>Confidence interval used in cumulative incidence and event-free probability plots.</p>
</td></tr>
<tr><td><code id="summary.cfc.tbasis_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to/from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.cfc.tbasis</code> calculates the average of cumulative incidence and event-free probability functions as directed by <code>MARGIN</code>. For example, if the element <code>ci1</code> of the object list is three-dimensional, then using <code>MARGIN=c(1,2)</code> causes the last dimension to be averaged out.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani</p>


<h3>References</h3>

<p>Mahani A.S. and Sharabiani M.T.A. (2019). Bayesian, and Non-Bayesian, Cause-Specific Competing-Risk Analysis for Parametric and Nonparametric Survival Functions: The R Package CFC. Journal of Statistical Software, 89(9), 1-29. doi:10.18637/jss.v089.i09
</p>


<h3>See Also</h3>

<p>The model fitting function is <code><a href="#topic+cfc.tbasis">cfc.tbasis</a></code>. See <code><a href="base.html#topic+summary">summary</a></code> and <code><a href="graphics.html#topic+plot">plot</a></code> for descriptions of the generic methods. See <code><a href="#topic+cfc.pbasis">cfc.pbasis</a></code> for probability-denominated CFC, as well as usage examples.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
