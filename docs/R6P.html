<!DOCTYPE html><html><head><title>Help for package R6P</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {R6P}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Forward pipe operator</p></a></li>
<li><a href='#NullObject'><p>Null Object Pattern</p></a></li>
<li><a href='#Repository'><p>Repository Pattern</p></a></li>
<li><a href='#Singleton'><p>Singleton Pattern</p></a></li>
<li><a href='#ValueObject'><p>Value Object Pattern</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Design Patterns in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-01</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Harel Lustiger &lt;tidylab@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Build robust and maintainable software with object-oriented
    design patterns in R. Design patterns abstract and present in neat,
    well-defined components and interfaces the experience of many software
    designers and architects over many years of solving similar problems.
    These are solutions that have withstood the test of time with respect
    to re-usability, flexibility, and maintainability. 'R6P' provides
    abstract base classes with examples for a few known design patterns.
    The patterns were selected by their applicability to analytic projects
    in R. Using these patterns in R projects have proven effective in
    dealing with the complexity that data-driven applications possess.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tidylab.github.io/R6P/">https://tidylab.github.io/R6P/</a>, <a href="https://github.com/tidylab/R6P">https://github.com/tidylab/R6P</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidylab/R6P/issues">https://github.com/tidylab/R6P/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>collections, dplyr, purrr, R6, stringr, tibble, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DBI, ggplot2, RSQLite, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-02 18:15:57 UTC; BETA</td>
</tr>
<tr>
<td>Author:</td>
<td>Harel Lustiger <a href="https://orcid.org/0000-0003-2953-9598"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Tidylab [cph, fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-02 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Forward pipe operator</h2><span id='topic++25+3E+25'></span><span id='topic++25+7C+7C+25'></span>

<h3>Description</h3>

<p>Forward pipe operator
</p>
<p>NULL operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs

x %||% y
</code></pre>

<hr>
<h2 id='NullObject'>Null Object Pattern</h2><span id='topic+NullObject'></span>

<h3>Description</h3>

<p>Model a domain concept using natural lingo of the domain
experts, such as &quot;Passenger&quot;, &quot;Address&quot;, and &quot;Money&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NullObject()
</code></pre>


<h3>Details</h3>

<p>&lt;div class=&quot;alert alert-danger&quot;&gt;
**Caution:** NullObject is designed for demonstration purposes. Instead of directly using the design pattern as it appears in the package, you'd have to adjust the source code to the problem you are trying to solve.
&lt;/div&gt;
&lt;!&ndash; One line about what the function does &ndash;&gt;
</p>
<p><em><strong>Null Object</strong></em> provides special behaviour for particular cases.&lt;div class=&quot;alert alert-warning&quot;&gt;
**Note:** The Null Object is not the same as the reserved word in R 'NULL' (all
caps).
&lt;/div&gt;
</p>


<h4>How It Works</h4>

<p>When a function fails in R, some functions produce a run-time error while others
return <code>NULL</code> (and potentially prompt a warning). What the function evokes in
case of a failure is subjected to its programmer discretion. Usually, the
programmer follows either a punitive or forgiving policy regarding how
run-time errors should be handled.
</p>
<p>In other occasions, <code>NULL</code> is often the result of unavailable data. This could
happened when querying a data source matches no entries, or when the system is
waiting for user input (mainly in Shiny).
</p>
<p>If it is possible for a function to return <code>NULL</code> rather than an error,
then it is important to surround it with null test code, e.g.
<code>if(is.null(...)) do_the_right_thing()</code>. This way the software would do the
right thing if a null is present.
</p>
<p>Often the right thing is the same in many contexts, so you end up writing
similar code in lots of placesâ€”committing the sin of code duplication.
</p>
<p>Instead of returning <code>NULL</code>, or some odd value such as <code>NaN</code> or <code>logical(0)</code>, return a <strong>Null Object</strong> that has the same interface as what the caller expects. In R, this often means returning a <code>data.frame</code> structure, i.e. column names and variables types, with no rows.
</p>



<h4>When to Use It</h4>


<ul>
<li><p> In situations when a subroutine is likely to fail, such as loss of Internet
or database connectivity. Instead of prompting a run-time error, you could
return the <strong>Null Object</strong> as part of a <a href="https://en.wikipedia.org/wiki/Graceful_exit">gracefully failing</a> strategy. A common
strategy employs <code>tryCatch</code> that returns the <strong>Null Object</strong> in the case of
an error:
</p>
</li></ul>

<div class="sourceCode r"><pre># Simulate a database that is 5% likely to fail 
read_mtcars &lt;- function() if(runif(1) &lt; 0.05) stop() else return(mtcars)

# mtcars null object constructor
NullCar &lt;- function() mtcars[0,]

# How does the null car object look like? 
NullCar()
#&gt;  [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb
#&gt; &lt;0 rows&gt; (or 0-length row.names)

# Subroutine with gracefully failing strategy
set.seed(1814)
cars &lt;- tryCatch(
  # Try reading the mtcars dataset
  read_mtcars(), 
  # If there is an error, return the Null Car object
  error = function(e) return(NullCar()) 
)

# Notice: Whether the subroutine fails or succeeds, it returns a tibble with 
# the same structure.
colnames(cars)
#&gt;  [1] "mpg"  "cyl"  "disp" "hp"   "drat" "wt"   "qsec" "vs"   "am"   "gear"
#&gt; [11] "carb"
</pre></div>

<ul>
<li><p> In Shiny dashboards
</p>
</li></ul>

<div class="sourceCode r"><pre>geom_null &lt;- function(...){
  ggplot2::ggplot() + ggplot2::geom_blank() + ggplot2::theme_void()
}

if(exists("user_input")){
  ggplot2::ggplot(user_input, ggplot::aes(x = mpg, y = hp)) + ggplot2::geom_point()
} else {
  geom_null() + geom_text(aes(0,0), label = "choose an entry from the list")
}
</pre></div>

<ul>
<li><p> In unit-tests
</p>
</li></ul>

<div class="sourceCode r"><pre>classes &lt;- function(x) sapply(x, class)
    
test_that("mtcars follows a certain table structure", {
    # Compare column names
    expect_identical(colnames(mtcars), colnames(NullCar()))
    # Compare variable types
    expect_identical(classes(mtcars), classes(NullCar()))
})
</pre></div>



<h3>See Also</h3>

<p>Other base design patterns: 
<code><a href="#topic+Singleton">Singleton</a></code>,
<code><a href="#topic+ValueObject">ValueObject</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See more examples at &lt;https://tidylab.github.io/R6P/articles&gt;

colnames(NullObject())
nrow(NullObject())
</code></pre>

<hr>
<h2 id='Repository'>Repository Pattern</h2><span id='topic+Repository'></span><span id='topic+AbstractRepository'></span>

<h3>Description</h3>

<p>Mediates between the domain and data mapping layers using a
collection-like interface for accessing domain objects.
</p>


<h3>Details</h3>

<p>&lt;!&ndash; One line about what the function does &ndash;&gt;
</p>
<p>With <em><strong>Repository</strong></em>, in-memory objects do not need to know whether there is a
database present or absent, they need no SQL interface code, and certainly no
knowledge of the database schema.
</p>


<h4>How It Works</h4>


<ul>
<li> <p><strong>Repository</strong> isolates domain objects from details of the database access
code;
</p>
</li>
<li> <p><strong>Repository</strong> concentrates code of query construction; and
</p>
</li>
<li> <p><strong>Repository</strong> helps to minimize duplicate query logic.
</p>
</li></ul>

<p>In R, the simplest form of <strong>Repository</strong> encapsulates <code>data.frame</code> entries
persisted in a data store and the operations performed over them, providing a
more object-oriented view of the persistence layer. From the caller point of
view, the location (locally or remotely), the technology and the interface of
the data store are obscured.
</p>



<h4>When to Use It</h4>


<ul>
<li><p> In situations with multiple data sources.
</p>
</li>
<li><p> In situations where the real data store, the one that is used in production,
is remote. This allows you to implement a <strong>Repository</strong> mock with identical
queries that runs locally. Then, the mock could be used during development
and testing. The mock itself may comprise a sample of the real data store or
just fake data.
</p>
</li>
<li><p> In situations where the real data store doesn't exist. Implementing a mock
<strong>Repository</strong> allows you to defer immature decisions about the database
technology and/or defer its deployment. In this way, the temporary solution
allows you to focus the development effort on the core functionality of the
application.
</p>
</li>
<li><p> In situations where using SQL queries can be represented by meaningful
names. For example
<code style="white-space: pre;">&#8288;Repository$get_efficient_cars() = SELECT * FROM mtcars WHERE mpg &gt; 20&#8288;</code>
</p>
</li>
<li><p> When building <a href="https://www.oreilly.com/library/view/software-architects-handbook/9781788624060/c47a09b6-91f9-4322-a6d4-9bc1604b1bdf.xhtml">stateless microservices</a>.
</p>
</li></ul>




<h3>Super class</h3>

<p><code><a href="#topic+Singleton">R6P::Singleton</a></code> -&gt; <code>Repository</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Repository-new"><code>AbstractRepository$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Repository-add"><code>AbstractRepository$add()</code></a>
</p>
</li>
<li> <p><a href="#method-Repository-del"><code>AbstractRepository$del()</code></a>
</p>
</li>
<li> <p><a href="#method-Repository-get"><code>AbstractRepository$get()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
</ul>
</details>

<hr>
<a id="method-Repository-new"></a>



<h4>Method <code>new()</code></h4>

<p>Instantiate an object
</p>


<h5>Usage</h5>

<div class="r"><pre>AbstractRepository$new()</pre></div>


<hr>
<a id="method-Repository-add"></a>



<h4>Method <code>add()</code></h4>

<p>Add an element to the Repository.
</p>


<h5>Usage</h5>

<div class="r"><pre>AbstractRepository$add(key, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>(<code>character</code>) Name of the element.</p>
</dd>
<dt><code>value</code></dt><dd><p>(<code style="white-space: pre;">&#8288;?&#8288;</code>) Value of the element. Note: The values in the
<code>Repository</code> are not necessarily of the same type. That depends on the
implementation of <code>AbstractRepository</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Repository-del"></a>



<h4>Method <code>del()</code></h4>

<p>Delete an element from the Repository.
</p>


<h5>Usage</h5>

<div class="r"><pre>AbstractRepository$del(key)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>(<code>character</code>) Name of the element.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Repository-get"></a>



<h4>Method <code>get()</code></h4>

<p>Retrieve an element from the Repository.
</p>


<h5>Usage</h5>

<div class="r"><pre>AbstractRepository$get(key)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>(<code>character</code>) Name of the element.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># See more examples at &lt;https://tidylab.github.io/R6P/articles&gt;

# The following implementation is a Repository of car models with their
# specifications.

# First, we define the class constructor, initialize, to establish a
# transient data storage.

# In this case we use a dictionary from the collections package
# &lt;https://randy3k.github.io/collections/reference/dict.html&gt;

# Second, we define the add, del and get functions that operate on the dictionary.

# As an optional step, we define the NULL object. In this case, rather then
# the reserved word NULL, the NULL object is a data.frame with 0 rows and
# predefined column.

TransientRepository &lt;- R6::R6Class(
    classname = "Repository", inherit = R6P::AbstractRepository, public = list(
        initialize = function() {private$cars &lt;- collections::dict()},
        add = function(key, value){private$cars$set(key, value); invisible(self)},
        del = function(key){private$cars$remove(key); invisible(self)},
        get = function(key){return(private$cars$get(key, default = private$NULL_car))}
    ), private = list(
        NULL_car = cbind(uid  = NA_character_, datasets::mtcars)[0,],
        cars = NULL
))

# Adding customised operations is also possible via the R6 set function.
# The following example, adds a query that returns all the objects in the database

TransientRepository$set("public", "get_all_cars", overwrite = TRUE, function(){
    result &lt;- private$cars$values() %&gt;% dplyr::bind_rows()
    if(nrow(result) == 0) return(private$NULL_car) else return(result)
})

# In this example, we use the mtcars dataset with a uid column that uniquely
# identifies the different cars in the Repository:
mtcars &lt;- datasets::mtcars %&gt;% tibble::rownames_to_column("uid")
head(mtcars, 2)

# Here is how the caller uses the Repository:

## Instantiate a repository object
repository &lt;- TransientRepository$new()

## Add two different cars specification to the repository
repository$add(key = "Mazda RX4", value = dplyr::filter(mtcars, uid == "Mazda RX4"))
repository$add(key = "Mazda RX4 Wag", value = dplyr::filter(mtcars, uid == "Mazda RX4 Wag"))

## Get "Mazda RX4" specification
repository$get(key = "Mazda RX4")

## Get all the specifications in the repository
repository$get_all_cars()

## Delete "Mazda RX4" specification
repository$del(key = "Mazda RX4")

## Get "Mazda RX4" specification
repository$get(key = "Mazda RX4")
</code></pre>

<hr>
<h2 id='Singleton'>Singleton Pattern</h2><span id='topic+Singleton'></span>

<h3>Description</h3>

<p>Ensure a class only has one instance, and provide a global point
of access to it.
</p>


<h3>Details</h3>

<p>&lt;!&ndash; One line about what the function does &ndash;&gt;
</p>
<p><em><strong>Singleton</strong></em> ensures a class only has one instance, and provide a global
point of access to it.
</p>


<h4>How It Works</h4>


<ol>
<li><p> Create only one instance of the <strong>Singleton</strong> class; and
</p>
</li>
<li><p> If an instance exists, then serve the same object again.
</p>
</li></ol>

<p>The main features of <strong>Singleton</strong> are:
</p>

<ul>
<li><p> Ensuring that one and only one object of the class gets created;
</p>
</li>
<li><p> Providing an access point for an object that is global to the program; and
</p>
</li>
<li><p> Controlling concurrent access to resources that are shared.
</p>
</li></ul>




<h4>When to Use It</h4>


<ul>
<li><p> In situations that require exactly one instance of a class, that must be
accessible to clients from a well-known access point. See the <a href="#example-1"><code>Counter</code> example</a>.
</p>
</li></ul>
<p>&lt;div class=&quot;alert alert-danger&quot;&gt;
**Caution:** Singletons can be a problem in multi-threaded applications, especially when they manipulate mutable data.
&lt;/div&gt;
&lt;div class=&quot;alert alert-info&quot;&gt;
**Tip:** 
Singletons work well for immutable data, such as reading from some data source, since anything that canâ€™t change isnâ€™t going to run into thread clash problems.
&lt;/div&gt;
</p>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Singleton-new"><code>Singleton$new()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Singleton-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create or retrieve an object
</p>


<h5>Usage</h5>

<div class="r"><pre>Singleton$new()</pre></div>




<h3>See Also</h3>

<p>Other base design patterns: 
<code><a href="#topic+NullObject">NullObject</a>()</code>,
<code><a href="#topic+ValueObject">ValueObject</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See more examples at &lt;https://tidylab.github.io/R6P/articles&gt;
address &lt;- function(x) sub('&lt;environment: (.*)&gt;', '\\1', capture.output(x))

# In this example we implement a `Counter` that inherits the qualities of
# Singleton
Counter &lt;- R6::R6Class("Counter", inherit = R6P::Singleton, public = list(
    count = 0,
    add_1 = function(){self$count = self$count + 1; invisible(self)}
))

# Whenever we call the constructor on `Counter`, we always get the exact same
# instance:
counter_A &lt;- Counter$new()
counter_B &lt;- Counter$new()

identical(counter_A, counter_B, ignore.environment = FALSE)

# The two objects are equal and located at the same address; thus, they are
# the same object.

# When we make a change in any of the class instances, the rest of the
# instances are changed as well.

# How many times has the counter been increased?
counter_A$count

# Increase the counter by 1
counter_A$add_1()

# How many times have the counters been increased?
counter_A$count
counter_B$count
</code></pre>

<hr>
<h2 id='ValueObject'>Value Object Pattern</h2><span id='topic+ValueObject'></span>

<h3>Description</h3>

<p>Model a domain concept using natural lingo of the domain
experts, such as &quot;Passenger&quot;, &quot;Address&quot;, and &quot;Money&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ValueObject(given = NA_character_, family = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ValueObject_+3A_given">given</code></td>
<td>
<p>(<code>character</code>) A character vector with the given name.</p>
</td></tr>
<tr><td><code id="ValueObject_+3A_family">family</code></td>
<td>
<p>(<code>character</code>) A character vector with the family name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lt;div class=&quot;alert alert-danger&quot;&gt;
**Caution:** ValueObject is designed for demonstration purposes. Instead of directly using the design pattern as it appears in the package, you'd have to adjust the source code to the problem you are trying to solve.
&lt;/div&gt;
&lt;!&ndash; One line about what the function does &ndash;&gt;
</p>
<p>A <strong>Value Object</strong> models a domain concept using natural lingo of the domain
experts, such as &quot;Passenger&quot;, &quot;Address&quot;, and &quot;Money&quot;.
</p>
<p>Any <strong>Value Object</strong> is created by a function that receives input, applies some
transformations, and outputs the results in some data structure such as a
vector, a list or a data.frame.
</p>


<h4>How It Works</h4>

<p>In R, a good option for creating a <strong>Value Object</strong> is to follow two
instructions:
</p>

<ul>
<li><p> A <strong>Value Object</strong> is created by a <code>function</code>, rather than a class method;
and
</p>
</li>
<li><p> A <strong>Value Object</strong> returns a <code>tibble</code>, rather than a list or a vector.
</p>
</li></ul>

<p>In essence, a <strong>Value Object</strong> is a data type, like <code>integer</code>, <code>logical</code>, <code>Date</code>
or <code>data.frame</code> data types to name a few. While the built-in data types in R fit
any application, <strong>Value Objects</strong> are domain specific and as such, they fit
only to a specific application. This is because, <code>integer</code> is an abstract that
represent whole numbers. This abstract is useful in any application. However, a
<strong>Value Object</strong> represent a high-level abstraction that appears in a particular
domain.
</p>
<p>An example of a <strong>Value Object</strong> is the notion of a &quot;Person&quot;. Any person in the
world has a name. Needless to say, a person name is spelt by letters, rather
than numbers. A <strong>Value Object</strong> captures these attribute as <code>tibble</code> columns
and type checks:
</p>
<div class="sourceCode r"><pre>Person &lt;- function(given = NA_character_, family = NA_character_){
  stopifnot(is.character(given), is.character(family))
  stopifnot(length(given) == length(family))
  
  return(
    tibble::tibble(given = given, family = family)
    %&gt;% tidyr::drop_na(given)
  )
}
</pre></div>
<p>Instantiating a person <strong>Value Object</strong> is done by calling the <code>Person</code>
constructor function:
</p>
<div class="sourceCode r"><pre>person &lt;- Person(given = "Bilbo", family = "Baggins")
</pre></div>
<p>Getting to know the advantages of a <strong>Value Object</strong>, we should consider the
typical alternative &ndash; constructing a Person by using the <code>tibble</code> function
directly:
</p>
<div class="sourceCode r"><pre>person &lt;- tibble::tibble(given = "Bilbo", family = "Baggins")
</pre></div>
<p>Both implementations return objects with identical content and structure, that
is, their column names, column types and cell values are identical. Then, why
would one prefer using a <strong>Value Object</strong> and its constructor over the direct
alternative?
</p>
<p>There are four predominant qualities offered by the <strong>Value Object</strong> pattern
which are not offered by the alternative:
</p>

<ol>
<li><p> Readability. Each <strong>Value Object</strong> captures a concept belonging to the
problem domain. Rather than trying to infer what a <code>tibble</code> is by looking at
its low-level details, the <strong>Value Object</strong> constructor descries a context
on a high-level.
</p>
</li>
<li><p> Explicitness. Since the constructor of the <strong>Value Object</strong> is a function,
its expected input arguments and their type can be detailed in a helper
file. Moreover, assigning input arguments with default values of specific
type, such as <code>NA</code> (logical NA), <code>NA_integer_</code>, <code>NA_character_</code>, or
<code>NA_Date</code> (see <code>lubridate::NA_Date</code>), expresses clearly the variable types
of the <strong>Value Object</strong>.
</p>
</li>
<li><p> Coherence. The representation of a <strong>Value Object</strong> is concentrated in one
place &ndash; its constructor. Any change, mainly modifications and extensions,
applied to the constructor promise the change would propagate to all
instances of the Value Objects. That means, no structure discrepancies
between instances that are supposed to represent the same concept.
</p>
</li>
<li><p> Safety. The constructor may start with <a href="https://en.wikipedia.org/wiki/Defensive_programming">defensive programming</a> to ensure
the qualities of its input. One important assertion is type checking. Type
checking eliminated the risk of implicit type coercing. Another important
assertion is checking if the lengths of the input arguments meet some
criteria, say all inputs are of the same length, or more restrictively, all
inputs are scalars. Having a set of checks makes the code base more robust.
This is because <strong>Value Objects</strong> are regularly created with the output of
other functions calls, having a set of checks serves as pseudo-tests of
these functions output throughout the code.
</p>
</li></ol>

<p>In addition to these qualities, there are two desirable behaviours which are not
offered by directly calling <code>tibble</code>:
</p>

<ol>
<li><p> Null Value Object. Calling the <strong>Value Object</strong> constructor with no input
arguments returns the structure of the <code>tibble</code> (column names and column
types).
</p>
</li>
<li><p> Default values for missing input arguments. In this manner, the <strong>Value
Object</strong> has a well-defined behaviour for a person without a family name,
such as Madonna and Bono.
</p>
</li></ol>

<p>In addition to native R data types, a <strong>Value Object</strong> constructor can receive
other <strong>Value Objects</strong> as input arguments. Here are two examples that transmute
Person to other Person-based concepts:
</p>
<div class="sourceCode r"><pre># A Passenger is a Person with a flight booking reference
Passenger &lt;- function(person = Person(), booking_reference = NA_character_){
  stopifnot(all(colnames(person) %in% colnames(Person())))
  stopifnot(is.character(booking_reference))
  
  return(
    person 
    %&gt;% tibble::add_column(booking_reference = booking_reference)
    %&gt;% tidyr::drop_na(booking_reference)
  )
}

person &lt;- Person(given = "Bilbo", family = "Baggins")
passenger &lt;- Passenger(person = person, booking_reference = "B662HR")
print(passenger)
#&gt; # A tibble: 1 Ã— 3
#&gt;   given family  booking_reference
#&gt;   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;            
#&gt; 1 Bilbo Baggins B662HR
</pre></div>
<div class="sourceCode r"><pre># A Diner is a Person that may have dinner reservation
Diner &lt;- function(person = Person(), reservation_time = NA_POSIXct_){
  stopifnot(all(colnames(person) %in% colnames(Person())))
  stopifnot(is.POSIXct(reservation_time))
  
  return(
    person 
    %&gt;% tibble::add_column(reservation_time = reservation_time)
  )
}

person &lt;- Person(given = "Bilbo", family = "Baggins")
timestamp &lt;- as.POSIXct("2021-01-23 18:00:00 NZDT")
diner &lt;- Diner(person = person, reservation_time = timestamp)
print(diner)
#&gt; # A tibble: 1 Ã— 3
#&gt;   given family  reservation_time   
#&gt;   &lt;chr&gt; &lt;chr&gt;   &lt;dttm&gt;             
#&gt; 1 Bilbo Baggins 2021-01-23 18:00:00
</pre></div>



<h4>When to Use It</h4>


<ul>
<li><p> In situations where domain concepts are more important then the database
schema. For example, when you are modelling Passengers, your first instinct
might be to think about the different data sources you'd need for the
analysis. You may envision &quot;FlightDetails&quot; and &quot;CustomerDetails&quot;. Next you
will define the relationship between them. Instead, let the domain drive the
design. Create a Passenger <strong>Value Object</strong> with the attributes you must
have, regardless of any particular database schema.
</p>
</li>
<li><p> In a function that runs within a specific context. Rather than having an
input argument called <code>data</code> of type <code>data.frame</code>, use the appropriate
<strong>Value Object</strong> name and pass it its constructor.
</p>
</li></ul>

<div class="sourceCode r"><pre>Audience &lt;- Person

## Without a Value Object
clean_audience_data &lt;- function(data) 
  dplyr::mutate(.data = data, given = stringr::str_to_title(given))

## With a Value Object
clean_audience_data &lt;- function(attendees = Audience()) 
  dplyr::mutate(.data = attendees, given = stringr::str_to_title(given))
</pre></div>

<ul>
<li><p> In <a href="https://en.wikipedia.org/wiki/Pipeline_(software)">pipes and filters</a>
architecture.
</p>
</li></ul>
<p>&lt;div class=&quot;alert alert-warning&quot;&gt;
**Note:** **Value Objects** do not need to have unit-tests. This is because of two reasons: 
(1) **Value Objects** are often called by other functions that are being tested. That means, **Value Objects** are implicitly tested. 
(2) **Value Objects** are data types similarly to 'data.frame' or 'list'. As such, they need no testing
&lt;/div&gt;
</p>



<h3>See Also</h3>

<p>Other base design patterns: 
<code><a href="#topic+NullObject">NullObject</a>()</code>,
<code><a href="#topic+Singleton">Singleton</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See more examples at &lt;https://tidylab.github.io/R6P/articles&gt;

# In this example we are appointing elected officials to random ministries, just
# like in real-life.
Person &lt;- ValueObject
Person()

# Create a test for objects of type Person
# * Extract the column names of Person by using its Null Object (returned by Person())
# * Check that the input argument has all the columns that a Person has
is.Person &lt;- function(x) all(colnames(x) %in% colnames(Person()))

# A 'Minister' is a 'Person' with a ministry title. We capture that information
# in a new Value Object named 'Minister'.
# The Minister constructor requires two inputs:
# 1. (`Person`) Members of parliament
# 2. (`character`) Ministry titles
Minister &lt;- function(member = Person(), title = NA_character_){
    stopifnot(is.Person(member), is.character(title))
    stopifnot(nrow(member) == length(title) | all(is.na(title)))

    member %&gt;% dplyr::mutate(title = title)
}

# Given one or more parliament members
# When appoint_random_ministries is called
# Then the parliament members are appointed to an office.
appoint_random_ministries &lt;- function(member = Person()){
    positions &lt;- c(
        "Arts, Culture and Heritage", "Finance", "Corrections",
        "Racing", "Sport and Recreation", "Housing", "Energy and Resources",
        "Education", "Public Service", "Disability Issues", "Environment",
        "Justice", "Immigration", "Defence", "Internal Affairs", "Transport"
    )

   Minister(member = member, title = sample(positions, size = nrow(member)))
}

# Listing New Zealand elected officials in 2020, we instantiate a Person Object,
# appoint them to random offices and return a Member value object.
set.seed(2020)

parliament_members &lt;- Person(
    given = c("Jacinda", "Grant",     "Kelvin", "Megan", "Chris",   "Carmel"),
    family = c("Ardern", "Robertson", "Davis",  "Woods", "Hipkins", "Sepuloni")
)

parliament_members

appoint_random_ministries(member = parliament_members)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
