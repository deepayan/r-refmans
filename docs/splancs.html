<!DOCTYPE html><html lang="en"><head><title>Help for package splancs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {splancs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addpoints'>
<p>Add points interactively to a point data set</p></a></li>
<li><a href='#amacrines'><p>Amacrines on/off data set</p></a></li>
<li><a href='#areapl'>
<p>Calculate area of polygon</p></a></li>
<li><a href='#as.points'>
<p>Creates data in spatial point format</p></a></li>
<li><a href='#bboxx'>
<p>Generate a non-closed bounding polygon</p></a></li>
<li><a href='#bodmin'><p>Bodmin Moors granite tors</p></a></li>
<li><a href='#burkitt'><p>Burkitt's lymphoma in Uganda</p></a></li>
<li><a href='#cardiff'><p>Locations of homes of juvenile offenders</p></a></li>
<li><a href='#csr'>
<p>Generate completely spatially random points on a polygon</p></a></li>
<li><a href='#delpoints'>
<p>Select points to delete from a points data set</p></a></li>
<li><a href='#dsquare'>
<p>Distance-squared from a number of points to a number of sources</p></a></li>
<li><a href='#Fhat'>
<p>F nearest neighbour distribution function</p></a></li>
<li><a href='#Fzero'>
<p>Theoretical nearest neighbour distribution function</p></a></li>
<li><a href='#gen'><p>generate points in polygon</p></a></li>
<li><a href='#getpoly'>
<p>Draw a polygon on the current graphics device</p></a></li>
<li><a href='#Ghat'>
<p>G nearest neighbour distribution function</p></a></li>
<li><a href='#gridpts'>
<p>Generate a grid of points</p></a></li>
<li><a href='#inout'>
<p>Test points for inclusion in a polygon</p></a></li>
<li><a href='#inpip'>
<p>Select points inside a polygon</p></a></li>
<li><a href='#is.points'>
<p>Point Objects</p></a></li>
<li><a href='#k12hat'>
<p>Bivariate K-function</p></a></li>
<li><a href='#Kenv.csr'>
<p>Envelope of Khat from simulations of complete spatial randomness</p></a></li>
<li><a href='#Kenv.label'>
<p>Envelope of K1hat-K2hat from random labelling of two point patterns</p></a></li>
<li><a href='#Kenv.pcp'><p>Calculate simulation envelope for a Poisson Cluster Process</p></a></li>
<li><a href='#Kenv.tor'>
<p>Envelope of K12hat from random toroidal shifts of two point patterns</p></a></li>
<li><a href='#Kenv.tor1'><p>Modified envelope of K12hat from random toroidal shifts of two point patterns</p></a></li>
<li><a href='#kernel2d'>
<p>Kernel smoothing of a point pattern</p></a></li>
<li><a href='#kernel3d'>
<p>Space-time kernel</p></a></li>
<li><a href='#kernrat'>
<p>Ratio of two kernel smoothings</p></a></li>
<li><a href='#kerview'>
<p>A linked-window system for browsing space-time data</p></a></li>
<li><a href='#khat'>
<p>K-function</p></a></li>
<li><a href='#khvc'>
<p>Covariance matrix for the difference between two K-functions</p></a></li>
<li><a href='#khvmat'>
<p>Covariance matrix for the difference between two K-functions</p></a></li>
<li><a href='#mpoint'>
<p>Overlay a number of point patterns</p></a></li>
<li><a href='#mse2d'>
<p>Mean Square Error for a Kernel Smoothing</p></a></li>
<li><a href='#n2dist'>
<p>Nearest neighbours for two point patterns</p></a></li>
<li><a href='#nndistF'>
<p>Nearest neighbour distances as used by Fhat()</p></a></li>
<li><a href='#nndistG'>
<p>Nearest neighbour distances as used by Ghat()</p></a></li>
<li><a href='#npts'>
<p>Number of points in data set</p></a></li>
<li><a href='#okblack'><p>Oklahoma black offenders</p></a></li>
<li><a href='#okwhite'><p>Oklahoma white offenders</p></a></li>
<li><a href='#pcp'><p>Fit a Poisson cluster process</p></a></li>
<li><a href='#pcp.sim'><p>Generate a Poisson Cluster Process</p></a></li>
<li><a href='#pdense'>
<p>Overall density for a point pattern</p></a></li>
<li><a href='#pip'>
<p>Points inside or outside a polygon</p></a></li>
<li><a href='#plt'><p>bins nearest neighbour distances</p></a></li>
<li><a href='#pointmap'>
<p>Graphics</p></a></li>
<li><a href='#polymap'>
<p>Graphics</p></a></li>
<li><a href='#print.ribfit'>
<p>Display the fit from tribble()</p></a></li>
<li><a href='#ranpts'><p>adjust number of random points in polygon</p></a></li>
<li><a href='#rLabel'>
<p>Randomly label two or more point sets</p></a></li>
<li><a href='#rtor.shift'>
<p>Random toroidal shift on a point data set</p></a></li>
<li><a href='#sbox'>
<p>Generate a box surrounding a point object</p></a></li>
<li><a href='#secal'>
<p>Standard errors for the difference between two K-functions</p></a></li>
<li><a href='#Shift'>
<p>Shift a point data set</p></a></li>
<li><a href='#southlancs'><p>Cancer cases in Chorley-Ribble</p></a></li>
<li><a href='#splancs'>
<p>Return version number and author information</p></a></li>
<li><a href='#spoints'>
<p>Point Objects</p></a></li>
<li><a href='#stdiagn'>
<p>Summary plots for clustering analysis</p></a></li>
<li><a href='#stkhat'>
<p>Space-time K-functions</p></a></li>
<li><a href='#stmctest'>
<p>Monte-Carlo test of space-time clustering</p></a></li>
<li><a href='#stsecal'>
<p>Standard error for space-time clustering</p></a></li>
<li><a href='#stvmat'>
<p>Variance matrix for space-time clustering</p></a></li>
<li><a href='#thin'>
<p>Randomly thin a point data set</p></a></li>
<li><a href='#tor.shift'>
<p>Toroidal shift on a point data set</p></a></li>
<li><a href='#tribble'>
<p>Diggle-Rowlingson Raised Incidence Model</p></a></li>
<li><a href='#triblik'>
<p>Log-likelihood for the Diggle-Rowlingson raised incidence model</p></a></li>
<li><a href='#uganda'><p>Craters in Uganda</p></a></li>
<li><a href='#zoom'>
<p>Interactively specify a region of a plot for expansion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.01-45</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial and Space-Time Point Pattern Analysis</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), sp (&ge; 0.9)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, methods</td>
</tr>
<tr>
<td>Description:</td>
<td>The Splancs package was written as an enhancement to S-Plus for display and analysis of spatial point pattern data; it has been ported to R and is in "maintenance mode". </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>,
<a href="https://rsbivand.github.io/splancs/">https://rsbivand.github.io/splancs/</a>,
<a href="https://github.com/rsbivand/splancs">https://github.com/rsbivand/splancs</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rsbivand/splancs/issues">https://github.com/rsbivand/splancs/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-13 15:54:54 UTC; rsb</td>
</tr>
<tr>
<td>Author:</td>
<td>Roger Bivand [cre],
  Barry Rowlingson [aut],
  Peter Diggle [aut],
  Giovanni Petris [ctb],
  Stephen Eglen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roger Bivand &lt;Roger.Bivand@nhh.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-27 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addpoints'>
Add points interactively to a point data set
</h2><span id='topic+addpoints'></span>

<h3>Description</h3>

<p>Add points interactively to a point data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addpoints(pts,plot=FALSE,quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addpoints_+3A_pts">pts</code></td>
<td>

<p>A points data set.
</p>
</td></tr>
<tr><td><code id="addpoints_+3A_plot">plot</code></td>
<td>

<p>if true, plot the <code>pts</code> data, using <code>pointmap</code>. If false,
or if <code>pts</code> is missing,
don't plot the data. 
</p>
</td></tr>
<tr><td><code id="addpoints_+3A_quiet">quiet</code></td>
<td>

<p>if true, don't print a prompt to enter points.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The points entered are displayed on the current graphics device.
</p>


<h3>Value</h3>

<p>A points data set consisting of <code>pts</code> and the points entered on the current 
graphics device.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delpoints">delpoints</a></code>
</p>

<hr>
<h2 id='amacrines'>Amacrines on/off data set</h2><span id='topic+amacrines.on'></span><span id='topic+amacrines.off'></span>

<h3>Description</h3>

<p>Two two-column matrices of points marked on and off</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(amacrines)</code></pre>


<h3>Format</h3>

<p>Two two-column matrices of points marked on and off</p>


<h3>Source</h3>

<p><a href="https://www.maths.lancs.ac.uk/~diggle/pointpatterns/Datasets/">https://www.maths.lancs.ac.uk/~diggle/pointpatterns/Datasets/</a>, Peter J. Diggle, Department of Mathematics and Statistics, Lancaster University, Lancaster LA1 4YF, UK: public-domain spatial point pattern data-sets. 
</p>

<hr>
<h2 id='areapl'>
Calculate area of polygon
</h2><span id='topic+areapl'></span>

<h3>Description</h3>

<p>Calculate area of polygon. If the polygon is self-intersecting, the area will not be correct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areapl(poly)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="areapl_+3A_poly">poly</code></td>
<td>

<p>a polygon data set
</p>
</td></tr></table>


<h3>Value</h3>

<p>The area of the polygon is returned
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1,0,0,1,1,1,1,3,3,1)
y &lt;- c(0,0,1,1,0,0,-1,-1,0,0)
m &lt;- cbind(x, y)
plot(m, type="b")
areapl(m)
areapl(m[1:5,])
areapl(m[6:10,])
</code></pre>

<hr>
<h2 id='as.points'>
Creates data in spatial point format
</h2><span id='topic+as.points'></span>

<h3>Description</h3>

<p>Creates data in spatial point format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.points(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.points_+3A_...">...</code></td>
<td>

<p>any object(s), such as x and y vectors of the same length, or a list or data
frame containing x and y vectors. Valid options for <code>...</code> are:
a points object ; returns it unaltered;
a list with x and y elements of the same length &mdash; returns a
points object with the x and y elements as the coordinates of the points;
two vectors of equal length ; returns a points object with the 
first vector as the x coordinates, the second vector as the y-coordinates.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.points</code> tries to return the argument(s) as a points object. </p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>

<hr>
<h2 id='bboxx'>
Generate a non-closed bounding polygon
</h2><span id='topic+bboxx'></span>

<h3>Description</h3>

<p>Generate a non-closed bounding polygon from the bounding box of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bboxx(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bboxx_+3A_obj">obj</code></td>
<td>

<p>A matrix with two rows and two columns reporting the bounding box of an object
</p>
</td></tr></table>


<h3>Details</h3>

<p>The object used by <code>bboxx</code> may easily be created by using the <span class="pkg">sp</span> <code>bbox</code> method on an object of interest, such as a points data set.
</p>


<h3>Value</h3>

<p>A points data set of four points giving the non-closed coordinates of the bounding box
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbox">sbox</a></code>, <code><a href="sp.html#topic+bbox">bbox</a></code>
</p>

<hr>
<h2 id='bodmin'>Bodmin Moors granite tors</h2><span id='topic+bodmin'></span>

<h3>Description</h3>

<p>Locations of 35 granite tors on Bodmin Moor, taken from Infomap data set (northings multiplied by -1 to correspond to Figure 3.2, p. 82, Bailey and Gatrell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bodmin)</code></pre>


<h3>Format</h3>

<p>A list corresponding to a Venables and Ripley point object with 35 observations
</p>

<table>
<tr>
 <td style="text-align: left;">
    x  </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid eastings</td>
</tr>
<tr>
 <td style="text-align: left;">
    y   </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid northings</td>
</tr>
<tr>
 <td style="text-align: left;">
    area </td><td style="text-align: left;">	list	</td><td style="text-align: left;"> bounding box with xl, xu, yl, yu</td>
</tr>
<tr>
 <td style="text-align: left;">
    poly </td><td style="text-align: left;"> array </td><td style="text-align: left;"> polygon boundary with columns x and y</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Pinder and Witherick, 1977 - Bailey and Gatrell 1995, ch. 3.
</p>


<h3>References</h3>

<p>Bailey, T. C. and Gatrell, A. C. 1995, Interactive spatial data analysis. Longman, Harlow.
</p>

<hr>
<h2 id='burkitt'>Burkitt's lymphoma in Uganda</h2><span id='topic+burkitt'></span><span id='topic+burbdy'></span><span id='topic+burpts'></span>

<h3>Description</h3>

<p>Locations of cases of Burkitt's lymphoma in the Western Nile
district of Uganda 1960-1975. The time variable is recorded as the number of
days starting from an origin of 1 Jan 1960. The examples given below show
how the <code>chron()</code> function and derived time structures may be used to
analyse the data in the time dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(burkitt)</code></pre>


<h3>Format</h3>

<p>The data is provided as a data table:
</p>

<table>
<tr>
 <td style="text-align: left;">
    x  </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid eastings</td>
</tr>
<tr>
 <td style="text-align: left;">
    y   </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid northings</td>
</tr>
<tr>
 <td style="text-align: left;">
    t </td><td style="text-align: left;">	numeric	</td><td style="text-align: left;"> day number starting at 1/1/1960 of onset</td>
</tr>
<tr>
 <td style="text-align: left;">
    age </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> age of child patient</td>
</tr>
<tr>
 <td style="text-align: left;">
    dates </td><td style="text-align: left;"> factor </td><td style="text-align: left;"> day as string yy-mm-dd</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>as a points object <code>burpts</code> of <code>burkitt$x</code> and <code>burkitt$y</code>; and a point object of the area boundary <code>burbdy</code>.
</p>


<h3>Source</h3>

<p>Williams, E. H. et al. 1978, - Bailey and Gatrell 1995, ch. 3.
</p>


<h3>References</h3>

<p>Bailey, T. C. and Gatrell, A. C. 1995, Interactive spatial data analysis. Longman, Harlow.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(burkitt)
burDates &lt;- as.Date(as.character(burkitt$dates), "%y-%m-%d")
res &lt;- aggregate(rep(1, length(burDates)), list(quarters(burDates), format(burDates, "%y")), sum)
plot(as.numeric(as.character(res$Group.2)) +
 0.25*(as.numeric(substr(as.character(res$Group.1), 2, 2))-1),
 res$x, type="h", lwd=3, col=ifelse(as.character(res$Group.1)=="Q3",
 "grey","red"), xlab="year", ylab="count", xaxt="n")
axis(1, at=seq(61,75,4), labels=format(seq.Date(as.Date("1961/1/1"),
 as.Date("1975/1/1"), "4 years")))
title("Plot of Burkitt's lymphoma in West Nile district,\nQ3 grey shaded")
op &lt;- par(mfrow=c(3,5))
for (i in unique(format(burDates, "%y"))) {
	polymap(burbdy)
	pointmap(burpts[which(format(burDates, "%y") == i),], add=TRUE, pch=19)
	title(main=paste("19", i, sep=""))
}
par(op)
op &lt;- par(mfrow=c(2,2))
for (i in c("Q1", "Q2", "Q3", "Q4")) {
	polymap(burbdy)
	pointmap(burpts[which(unclass(quarters(burDates)) == i),], add=TRUE,
pch=19)
	title(main=i)
}
par(op)
op &lt;- par(mfrow=c(3,4))
for (i in months(seq(as.Date("70-01-01", "%y-%m-%d"), len=12, by="1 month"))) {
	polymap(burbdy)
	pointmap(burpts[which(unclass(months(burDates)) == i),], add=TRUE, pch=19)
	title(main=i)
}
par(op)
</code></pre>

<hr>
<h2 id='cardiff'>Locations of homes of juvenile offenders</h2><span id='topic+cardiff'></span>

<h3>Description</h3>

<p>Locations of homes of 168 juvenile offenders on a Cardiff housing estate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cardiff)</code></pre>


<h3>Format</h3>

<p>A list corresponding to a Venables and Ripley point object with 168 observations
</p>

<table>
<tr>
 <td style="text-align: left;">
    x  </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid eastings</td>
</tr>
<tr>
 <td style="text-align: left;">
    y   </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid northings</td>
</tr>
<tr>
 <td style="text-align: left;">
    area </td><td style="text-align: left;">	list	</td><td style="text-align: left;"> bounding box with xl, xu, yl, yu</td>
</tr>
<tr>
 <td style="text-align: left;">
    poly </td><td style="text-align: left;"> array </td><td style="text-align: left;"> polygon boundary with columns x and y</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Herbert, 1980, - Bailey and Gatrell 1995, ch. 3.
</p>


<h3>References</h3>

<p>Bailey, T. C. and Gatrell, A. C. 1995, Interactive spatial data analysis. Longman, Harlow.
</p>

<hr>
<h2 id='csr'>
Generate completely spatially random points on a polygon
</h2><span id='topic+csr'></span>

<h3>Description</h3>

<p>Generate completely spatially random points on a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csr(poly,npoints)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csr_+3A_poly">poly</code></td>
<td>

<p>A polygon data set.
</p>
</td></tr>
<tr><td><code id="csr_+3A_npoints">npoints</code></td>
<td>

<p>The number of points to generate.
</p>
</td></tr></table>


<h3>Details</h3>

<p><code>csr</code> generates points randomly in the bounding box of <code>poly,</code> then uses 
<code>pip</code> to extract those in the polygon. If the number of points remaining is
less than that required, <code>csr</code> generates some more points in the
bounding box until at least <code>npoints</code> remain inside the polygon. If too many
points are generated then the list of points is truncated.
</p>
<p>Uses <code>runif()</code> to generate random numbers and so updates <code>.Random.seed</code>,
the standard S random number generator seed.
</p>


<h3>Value</h3>

<p>A point data set consisting of <code>npoints</code> points distributed randomly,
i.e. as an independent random sample from the uniform distribution
in the polygon defined by <code>poly</code>.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cardiff)
nsim &lt;- 29
emp.Ghat &lt;- Ghat(as.points(cardiff), seq(0,30,1))
av.Ghat &lt;- numeric(length(emp.Ghat))
U.Ghat &lt;- numeric(length(emp.Ghat))
L.Ghat &lt;- numeric(length(emp.Ghat))
U.Ghat &lt;- -99999
L.Ghat &lt;- 99999
for(i in 1:nsim) {
S.Ghat &lt;- Ghat(csr(cardiff$poly, length(cardiff$x)), seq(0,30,1))
av.Ghat &lt;- av.Ghat + S.Ghat
L.Ghat &lt;- pmin(S.Ghat, L.Ghat)
U.Ghat &lt;- pmax(S.Ghat, U.Ghat)
}
av.Ghat &lt;- av.Ghat/nsim
plot(av.Ghat, emp.Ghat, type="l", xlim=c(0,1), ylim=c(0,1), 
xlab="Simulated average G", ylab="Empirical G")
lines(c(0,1),c(0,1),lty=2)
lines(U.Ghat,emp.Ghat,lty=3)
lines(L.Ghat,emp.Ghat,lty=3)
</code></pre>

<hr>
<h2 id='delpoints'>
Select points to delete from a points data set
</h2><span id='topic+delpoints'></span>

<h3>Description</h3>

<p>Select points to delete from a points data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delpoints(pts,add=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delpoints_+3A_pts">pts</code></td>
<td>

<p>a points data set
</p>
</td></tr>
<tr><td><code id="delpoints_+3A_add">add</code></td>
<td>

<p>if false, plot the points using <code>pointmap</code>.
</p>
</td></tr></table>


<h3>Details</h3>

<p>Using the mouse, the user selects points on the current graphics device.
These points are marked on the plot as they are selected. The function
returns the remaining points as a points object.
If <code>add</code> is false the points are plotted on the current plot device.
</p>


<h3>Value</h3>

<p>A points object containing the undeleted points.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>

<hr>
<h2 id='dsquare'>
Distance-squared from a number of points to a number of sources
</h2><span id='topic+dsquare'></span>

<h3>Description</h3>

<p>Computes the distance-squared from a number of points to a number of sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsquare(pts, srcs, namepref="d")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dsquare_+3A_pts">pts</code></td>
<td>

<p>A number of points representing the locations of cases and controls.
</p>
</td></tr>
<tr><td><code id="dsquare_+3A_srcs">srcs</code></td>
<td>

<p>A number of points representing source locations
</p>
</td></tr>
<tr><td><code id="dsquare_+3A_namepref">namepref</code></td>
<td>

<p>A prefix given to the name of the results.
</p>
</td></tr></table>


<h3>Value</h3>

<p>A data frame with the same number of  columns as <code>srcs</code>. The column names will 
be the value of <code>namepref</code> prefixing the numbers from 1 to the number
of sources.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tribble">tribble</a></code>, <code><a href="#topic+triblik">triblik</a></code>
</p>

<hr>
<h2 id='Fhat'>
F nearest neighbour distribution function
</h2><span id='topic+Fhat'></span>

<h3>Description</h3>

<p>Calculates an estimate of the F nearest neighbour distribution function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fhat(pts1,pts2,s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fhat_+3A_pts1">pts1</code></td>
<td>

<p>A points data set
</p>
</td></tr>
<tr><td><code id="Fhat_+3A_pts2">pts2</code></td>
<td>

<p>A points data set
</p>
</td></tr>
<tr><td><code id="Fhat_+3A_s">s</code></td>
<td>

<p>A vector of distances at which to evaluate Fhat
</p>
</td></tr></table>


<h3>Details</h3>

<p>The function <code>Fhat(pts1,pts2,s)</code> is defined as the proportion of members of a
point set <code>pts2</code> for which the distance to the nearest member of
another points set <code>pts1</code> is less than or equal to <code>s</code>.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>s</code>, containing the value of Fhat at the 
distances in <code>s</code>.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndistF">nndistF</a></code>,<code><a href="#topic+Fzero">Fzero</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(uganda)
plot(seq(20, 500, 20), Fhat(as.points(uganda), 
as.points(csr(uganda$poly, length(uganda$x))), seq(20, 500, 20)), 
type="l", xlab="distance", ylab="Estimated F")
plot(Ghat(as.points(uganda), seq(20, 500, 20)), Fhat(as.points(uganda), 
as.points(csr(uganda$poly, length(uganda$x))), seq(20, 500, 20)), 
type="l", xlab="Estimated G", ylab="Estimated F")
lines(c(0,1),c(0,1),lty=2)
</code></pre>

<hr>
<h2 id='Fzero'>
Theoretical nearest neighbour distribution function
</h2><span id='topic+Fzero'></span>

<h3>Description</h3>

<p>Calculate the theoretical nearest neighbour distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fzero(density,s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fzero_+3A_density">density</code></td>
<td>

<p>The density of the point pattern, i.e. the number of points per unit area.
</p>
</td></tr>
<tr><td><code id="Fzero_+3A_s">s</code></td>
<td>

<p>A vector of distances at which to evaluate Fzero
</p>
</td></tr></table>


<h3>Details</h3>

<p>Fzero returns the nearest neighbour distribution for a homogeneous planar
Poisson process. In fortran notation, Fzero(s) is
<code>FZERO = 1-EXP(-PI*DENSITY*(S**2))</code>.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>s</code>, containing the value of Fzero at the 
distances in <code>s</code>.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fhat">Fhat</a></code>,<code><a href="#topic+Ghat">Ghat</a></code>,<code><a href="#topic+pdense">pdense</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(uganda)
plot(Ghat(as.points(uganda), seq(20, 500, 20)), Fzero(pdense(as.points(uganda), 
uganda$poly), seq(20, 500, 20)), type="l", ylab="Theoretical G", 
xlab="Estimated G")
lines(c(0,1),c(0,1),lty=2)
</code></pre>

<hr>
<h2 id='gen'>generate points in polygon</h2><span id='topic+gen'></span>

<h3>Description</h3>

<p>generates random points within a defined polygon, trying to reach <code>npoints</code>
points - used in <code>csr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen(poly, npoints)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_+3A_poly">poly</code></td>
<td>
<p>A polygon data set</p>
</td></tr>
<tr><td><code id="gen_+3A_npoints">npoints</code></td>
<td>
<p>The number of points to generate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a point object.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csr">csr</a></code> </p>

<hr>
<h2 id='getpoly'>
Draw a polygon on the current graphics device
</h2><span id='topic+getpoly'></span>

<h3>Description</h3>

<p>Draw a polygon on the current graphics device
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getpoly(quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getpoly_+3A_quiet">quiet</code></td>
<td>

<p>if TRUE, don't prompt for input of a polygon.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The system prompts the user to enter points on the current graphics
device using the mouse or other pointing device. The points are joined
on the screen with the current line symbol.
A polygon of the points entered is drawn on the current graphics device.
</p>


<h3>Value</h3>

<p>A polygon data set consisting of the points entered. The current coordinate 
system is used.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>

<hr>
<h2 id='Ghat'>
G nearest neighbour distribution function
</h2><span id='topic+Ghat'></span>

<h3>Description</h3>

<p>Calculates an estimate of the G nearest neighbour distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ghat(pts,s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ghat_+3A_pts">pts</code></td>
<td>

<p>A points data set
</p>
</td></tr>
<tr><td><code id="Ghat_+3A_s">s</code></td>
<td>

<p>A vector of distances at which to evaluate the G function
</p>
</td></tr></table>


<h3>Details</h3>

<p>The function <code>Ghat(pts,s)</code> is defined as the proportion of members of a
point set for which the distance to the nearest other member of the set
is less than or equal to <code>s</code>.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>s</code>, containing the estimate of G at the 
distances in <code>s</code>.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fhat">Fhat</a></code>, <code><a href="#topic+nndistG">nndistG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(uganda)
plot(seq(20, 500, 20), Ghat(as.points(uganda), seq(20, 500, 20)), 
type="l", xlab="distance", ylab="Estimated G")
</code></pre>

<hr>
<h2 id='gridpts'>
Generate a grid of points
</h2><span id='topic+gridpts'></span>

<h3>Description</h3>

<p>Generate a grid of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridpts(poly,npts,xs,ys)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gridpts_+3A_poly">poly</code></td>
<td>

<p>polygon in which to generate the points
</p>
</td></tr>
<tr><td><code id="gridpts_+3A_npts">npts</code></td>
<td>

<p>approximate number of points to generate
</p>
</td></tr>
<tr><td><code id="gridpts_+3A_xs">xs</code>, <code id="gridpts_+3A_ys">ys</code></td>
<td>

<p>grid spacing in x and y 
</p>
<p>Either <code>npts</code> or <code>xs</code> and <code>ys</code> must be specified. If all three
are given then <code>xs</code> and <code>ys</code> are ignored. 
</p>
</td></tr></table>


<h3>Value</h3>

<p>A points object containing a grid of points inside the polygon. If <code>npts</code>
is specified, then a grid spacing <code>xs</code> and <code>ys</code> will be calculated to give
approximately <code>npts</code> in the polygon. If <code>xs</code> and <code>ys</code> are given then these
will be used to generate a number of points in the polygon.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>

<hr>
<h2 id='inout'>
Test points for inclusion in a polygon
</h2><span id='topic+inout'></span>

<h3>Description</h3>

<p>Test points for inclusion in a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inout(pts,poly,bound=NULL,quiet=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inout_+3A_pts">pts</code></td>
<td>

<p>A points data set
</p>
</td></tr>
<tr><td><code id="inout_+3A_poly">poly</code></td>
<td>

<p>A polygon data set
</p>
</td></tr>
<tr><td><code id="inout_+3A_bound">bound</code></td>
<td>
<p>If points fall exactly on polygon boundaries, the default NULL gives arbitrary assignments. If TRUE, then all points &quot;on&quot; boundaries are set as within the polygon, if FALSE, outside.</p>
</td></tr>
<tr><td><code id="inout_+3A_quiet">quiet</code></td>
<td>
<p>Do not report which points are on boundary for non-NULL bound</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of logical values. <code>TRUE</code> means the point was inside the
polygon, <code>FALSE</code> means the point was outside. Note that &quot;inside&quot; is an arbitrary concept for points &quot;on&quot; the polygon boundary.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inpip">inpip</a></code>,<code><a href="#topic+pip">pip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(uganda)
suganda &lt;- sbox(uganda$poly)
ruganda &lt;- csr(suganda, 1000)
polymap(suganda)
polymap(uganda$poly, add=TRUE)
def &lt;- inout(ruganda, uganda$poly, bound=NULL)
pointmap(as.points(ruganda[def,1], ruganda[def,2]), add=TRUE, col="black")
pointmap(as.points(ruganda[!def,1], ruganda[!def,2]), add=TRUE, col="red")
tru &lt;- inout(ruganda, uganda$poly, bound=TRUE, quiet=FALSE)
which(tru &amp; !def)
ds1 &lt;- as.points(expand.grid(x=seq(-1.5,1.5,0.5), y=seq(-1.5,1.5,0.5)))
ds1.poly &lt;- ds1[chull(ds1),]
ds2 &lt;- as.points(rnorm(300),rnorm(300))
plot(ds2, type="n", asp=1)
polymap(ds1.poly, add=TRUE, border="lightblue", col="lightblue", lwd=1)
points(ds2[inout(ds2,ds1.poly),],  col="green",  pch=20)
points(ds2[!inout(ds2,ds1.poly),], col="orange", pch=20)
points(ds1[inout(ds1,ds1.poly),],  col="black",  pch=20)
points(ds1[!inout(ds1,ds1.poly),], col="red",    pch=20)
plot(ds2, type="n", asp=1)
polymap(ds1.poly, add=TRUE, border="lightblue", col="lightblue", lwd=1)
points(ds2[inout(ds2,ds1.poly,bound=TRUE),],  col="green",  pch=20)
points(ds2[!inout(ds2,ds1.poly,bound=TRUE),], col="orange", pch=20)
points(ds1[inout(ds1,ds1.poly,bound=TRUE),],  col="black",  pch=20)
points(ds1[!inout(ds1,ds1.poly,bound=TRUE),], col="red",    pch=20)
plot(ds2, type="n", asp=1)
polymap(ds1.poly, add=TRUE, border="lightblue", col="lightblue", lwd=1)
points(ds2[inout(ds2,ds1.poly,bound=FALSE),],  col="green",  pch=20)
points(ds2[!inout(ds2,ds1.poly,bound=FALSE),], col="orange", pch=20)
points(ds1[inout(ds1,ds1.poly,bound=FALSE),],  col="black",  pch=20)
points(ds1[!inout(ds1,ds1.poly,bound=FALSE),], col="red",    pch=20)
</code></pre>

<hr>
<h2 id='inpip'>
Select points inside a polygon
</h2><span id='topic+inpip'></span>

<h3>Description</h3>

<p>Select points inside a polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inpip(pts,poly,bound=NULL,quiet=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inpip_+3A_pts">pts</code></td>
<td>

<p>A points data set
</p>
</td></tr>
<tr><td><code id="inpip_+3A_poly">poly</code></td>
<td>

<p>A polygon data set
</p>
</td></tr>
<tr><td><code id="inpip_+3A_bound">bound</code></td>
<td>
<p>If points fall exactly on polygon boundaries, the default NULL gives arbitrary assignments. If TRUE, then all points &quot;on&quot; boundaries are set as within the polygon, if FALSE, outside.</p>
</td></tr>
<tr><td><code id="inpip_+3A_quiet">quiet</code></td>
<td>
<p>Do not report which points are on boundary for non-NULL bound</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>inpip</code> returns a vector of indices of the points in <code>pts</code> that are located
in the polygon. Note that &quot;in&quot; is an arbitrary concept for points &quot;on&quot; the polygon boundary.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pip">pip</a></code>
</p>

<hr>
<h2 id='is.points'>
Point Objects
</h2><span id='topic+is.points'></span>

<h3>Description</h3>

<p>Tests for data in spatial point format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.points(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.points_+3A_p">p</code></td>
<td>

<p>any object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.points</code> returns TRUE if <code>p</code> is a points object, FALSE otherwise.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>

<hr>
<h2 id='k12hat'>
Bivariate K-function
</h2><span id='topic+k12hat'></span>

<h3>Description</h3>

<p>Calculates an estimate of the bivariate K-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k12hat(pts1,pts2,poly,s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="k12hat_+3A_pts1">pts1</code>, <code id="k12hat_+3A_pts2">pts2</code></td>
<td>

<p>Two points data sets
</p>
</td></tr>
<tr><td><code id="k12hat_+3A_poly">poly</code></td>
<td>

<p>A polygon containing the points
</p>
</td></tr>
<tr><td><code id="k12hat_+3A_s">s</code></td>
<td>

<p>A vector of distances at which to estimate the K12 function
</p>
</td></tr></table>


<h3>Details</h3>

<p>The bivariate K function is defined as the expected number of points of
pattern 1
within a distance s of an arbitrary point of pattern 2, divided by the
overall density of the points in pattern 1.  To estimate this function,
the approximately unbiased estimator given by Lotwick and Silverman
(1982) is used.
</p>


<h3>Value</h3>

<p>A vector like <code>s</code> containing the value of K12hat at the points in <code>s</code>.
</p>


<h3>References</h3>

<p>Lotwick, H.W. and Silverman B.W. (1982) Methods for Analysing Spatial
Processes of Several types of Points.
<em>J. R. Statist Soc</em> B44 406-13;
Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(okwhite)
data(okblack)
okpoly &lt;- list(x=c(okwhite$x, okblack$x), y=c(okwhite$y, okblack$y))
plot(seq(5,80,5), sqrt(k12hat(as.points(okwhite), as.points(okblack), 
bboxx(bbox(as.points(okpoly))), seq(5,80,5))/pi) - seq(5,80,5), xlab="distance", 
ylab=expression(hat(L)[12]), ylim=c(-20,20), type="l")
</code></pre>

<hr>
<h2 id='Kenv.csr'>
Envelope of Khat from simulations of complete spatial randomness
</h2><span id='topic+Kenv.csr'></span>

<h3>Description</h3>

<p>Compute envelope of Khat from simulations of complete spatial randomness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kenv.csr(nptg,poly,nsim,s,quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kenv.csr_+3A_nptg">nptg</code></td>
<td>

<p>Number of points to generate in each simulation.
</p>
</td></tr>
<tr><td><code id="Kenv.csr_+3A_poly">poly</code></td>
<td>

<p>Polygon in which to generate the points.
</p>
</td></tr>
<tr><td><code id="Kenv.csr_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulations to do.
</p>
</td></tr>
<tr><td><code id="Kenv.csr_+3A_s">s</code></td>
<td>

<p>Vector of distances at which to calculate the envelope.
</p>
</td></tr>
<tr><td><code id="Kenv.csr_+3A_quiet">quiet</code></td>
<td>

<p>If FALSE, print a message after every simulation for progress monitoring. If
TRUE, print no messages.
</p>
</td></tr></table>


<h3>Value</h3>

<p>A list with two components, called <code>$upper</code> and <code>$lower</code>. Each
component is a vector like <code>s</code>. The two components contain the upper 
and lower bound of the Khat envelope. 
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csr">csr</a></code>, <code><a href="#topic+khat">khat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cardiff)
UL.khat &lt;- Kenv.csr(length(cardiff$x), cardiff$poly, nsim=29, seq(2,30,2))
plot(seq(2,30,2), sqrt(khat(as.points(cardiff), cardiff$poly, 
seq(2,30,2))/pi)-seq(2,30,2), type="l", xlab="Splancs - polygon boundary", 
ylab="Estimated L", ylim=c(-1,1.5))
lines(seq(2,30,2), sqrt(UL.khat$upper/pi)-seq(2,30,2), lty=2)
lines(seq(2,30,2), sqrt(UL.khat$lower/pi)-seq(2,30,2), lty=2)
</code></pre>

<hr>
<h2 id='Kenv.label'>
Envelope of K1hat-K2hat from random labelling of two point patterns
</h2><span id='topic+Kenv.label'></span>

<h3>Description</h3>

<p>Compute envelope of K1hat-K2hat from random labelling of two point patterns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kenv.label(pts1,pts2,poly,nsim,s,quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kenv.label_+3A_pts1">pts1</code></td>
<td>

<p>First point data set.
</p>
</td></tr>
<tr><td><code id="Kenv.label_+3A_pts2">pts2</code></td>
<td>

<p>Second point data set.
</p>
</td></tr>
<tr><td><code id="Kenv.label_+3A_poly">poly</code></td>
<td>

<p>Polygon containing the points.
</p>
</td></tr>
<tr><td><code id="Kenv.label_+3A_nsim">nsim</code></td>
<td>

<p>Number of random labellings to do.
</p>
</td></tr>
<tr><td><code id="Kenv.label_+3A_s">s</code></td>
<td>

<p>Vector of distances at which to calculate the envelope.
</p>
</td></tr>
<tr><td><code id="Kenv.label_+3A_quiet">quiet</code></td>
<td>

<p>If FALSE, print a message after every simulation for progress monitoring. If
TRUE, print no messages.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The two point data sets are randomly labelled using <code>rLabel</code>, then
<code>Khat</code> is called to estimate the K-function for each resulting set
at the distances in <code>s</code>. The difference between these two estimates
is then calculated. 
The maximum and minimum values of this difference at each distance,over
the <code>nlab</code>
labellings is returned.
</p>


<h3>Value</h3>

<p>A list with two components, called <code>$upper</code> and <code>$lower</code>. Each
component is a vector like <code>s</code>.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rLabel">rLabel</a></code>,<code>i<a href="#topic+khat">khat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(okwhite)
data(okblack)
okpoly &lt;- list(x=c(okwhite$x, okblack$x), y=c(okwhite$y, okblack$y))
K1.hat &lt;- khat(as.points(okwhite), bboxx(bbox(as.points(okpoly))), seq(5,80,5))
K2.hat &lt;- khat(as.points(okblack), bboxx(bbox(as.points(okpoly))), seq(5,80,5))
K.diff &lt;- K1.hat-K2.hat
plot(seq(5,80,5), K.diff, xlab="distance", ylab=expression(hat(K)[1]-hat(K)[2]), 
ylim=c(-11000,7000), type="l", main="Simulation envelopes, random labelling")
env.lab &lt;- Kenv.label(as.points(okwhite), as.points(okblack), 
bboxx(bbox(as.points(okpoly))), nsim=29, s=seq(5,80,5))
lines(seq(5,80,5), env.lab$upper, lty=2)
lines(seq(5,80,5), env.lab$lower, lty=2)
</code></pre>

<hr>
<h2 id='Kenv.pcp'>Calculate simulation envelope for a Poisson Cluster Process</h2><span id='topic+Kenv.pcp'></span>

<h3>Description</h3>

<p>This function computes the envelope of Khat from simulations of a Poisson Cluster Process for a given polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kenv.pcp(rho, m, s2, region.poly, larger.region=NULL, nsim, r, vectorise.loop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kenv.pcp_+3A_rho">rho</code></td>
<td>
<p>intensity of the parent process</p>
</td></tr>
<tr><td><code id="Kenv.pcp_+3A_m">m</code></td>
<td>
<p>average number of offsprings per parent</p>
</td></tr>
<tr><td><code id="Kenv.pcp_+3A_s2">s2</code></td>
<td>
<p>variance of location of offsprings relative to their parent</p>
</td></tr>
<tr><td><code id="Kenv.pcp_+3A_region.poly">region.poly</code></td>
<td>
<p>a polygon defining the region in which the process is to be generated</p>
</td></tr>
<tr><td><code id="Kenv.pcp_+3A_larger.region">larger.region</code></td>
<td>
<p>a rectangle containing the region of interest given in the form (xl,xu,yl,yu), defaults to <code>sbox()</code> around region.poly</p>
</td></tr>
<tr><td><code id="Kenv.pcp_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations required</p>
</td></tr>
<tr><td><code id="Kenv.pcp_+3A_r">r</code></td>
<td>
<p>vector of distances at which the K function has to be estimated</p>
</td></tr>
<tr><td><code id="Kenv.pcp_+3A_vectorise.loop">vectorise.loop</code></td>
<td>
<p>if TRUE, use new vectorised code, if FALSE, use loop as before</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ave</code></td>
<td>
<p>mean of simulations</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper bound of envelope</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower bound of envelope</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni Petris &lt;GPetris@uark.edu&gt;,  Roger.Bivand@nhh.no</p>


<h3>References</h3>

<p>Diggle, P. J. (1983) <em>Statistical analysis of spatial point
patterns</em>, London: Academic Press, pp. 55-57 and 78-81; Bailey, T. C. and
Gatrell, A. C. (1995) <em>Interactive spatial data analysis</em>, Harlow:
Longman, pp. 106-109.</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcp">pcp</a></code>, <code><a href="#topic+pcp.sim">pcp.sim</a></code>, <code><a href="#topic+khat">khat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cardiff)
polymap(cardiff$poly)
pointmap(as.points(cardiff), add=TRUE)
title("Locations of homes of 168 juvenile offenders")
pcp.fit &lt;- pcp(as.points(cardiff), cardiff$poly, h0=30, n.int=30)
pcp.fit
m &lt;- npts(as.points(cardiff))/(areapl(cardiff$poly)*pcp.fit$par[2])
r &lt;- seq(2,30,by=2)
K.env &lt;- Kenv.pcp(pcp.fit$par[2], m, pcp.fit$par[1], cardiff$poly,
           nsim=20, r=r)
L.env &lt;- lapply(K.env, FUN=function(x) sqrt(x/pi)-r)
limits &lt;- range(unlist(L.env))
plot(r, sqrt(khat(as.points(cardiff),cardiff$poly,r)/pi)-r, ylim=limits,
     main="L function with simulation envelopes and average", type="l",
     xlab="distance", ylab="")
lines(r, L.env$lower, lty=5)
lines(r, L.env$upper, lty=5)
lines(r, L.env$ave, lty=6)
abline(h=0)
</code></pre>

<hr>
<h2 id='Kenv.tor'>
Envelope of K12hat from random toroidal shifts of two point patterns
</h2><span id='topic+Kenv.tor'></span>

<h3>Description</h3>

<p>Compute envelope of K12hat from random toroidal shifts of two point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kenv.tor(pts1,pts2,poly,nsim,s,quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kenv.tor_+3A_pts1">pts1</code></td>
<td>

<p>First point data set.
</p>
</td></tr>
<tr><td><code id="Kenv.tor_+3A_pts2">pts2</code></td>
<td>

<p>Second point data set.
</p>
</td></tr>
<tr><td><code id="Kenv.tor_+3A_poly">poly</code></td>
<td>

<p>Polygon containing the points.
</p>
</td></tr>
<tr><td><code id="Kenv.tor_+3A_nsim">nsim</code></td>
<td>

<p>Number of random toroidal shifts to do.
</p>
</td></tr>
<tr><td><code id="Kenv.tor_+3A_s">s</code></td>
<td>

<p>Vector of distances at which to calculate the envelope.
</p>
</td></tr>
<tr><td><code id="Kenv.tor_+3A_quiet">quiet</code></td>
<td>

<p>If FALSE, print a message after every simulation for progress monitoring. If
true, print no messages.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The second point data set is randomly shifted using <code>rtor.shift</code>
in the rectangle defined by <code>poly</code>. Then <code>k12hat</code> is called 
to compute K12hat for the two patterns. 
The upper and lower values of K12hat over the <code>ntor</code>
toroidal shifts are returned.
</p>


<h3>Value</h3>

<p>A list with two components, called <code>$upper</code> and <code>$lower</code>. Each
component is a vector like <code>s</code>.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rtor.shift">rtor.shift</a></code>,<code><a href="#topic+k12hat">k12hat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(okwhite)
data(okblack)
okpoly &lt;- list(x=c(okwhite$x, okblack$x), y=c(okwhite$y, okblack$y))
plot(seq(5,80,5), sqrt(k12hat(as.points(okwhite), as.points(okblack), 
bboxx(bbox(as.points(okpoly))), seq(5,80,5))/pi) - seq(5,80,5), xlab="distance", 
ylab=expression(hat(L)[12]), ylim=c(-35,35), type="l",
main="Simulation envelopes, random toroidal shifts")
env.ok &lt;- Kenv.tor(as.points(okwhite), as.points(okblack), 
bboxx(bbox(as.points(okpoly))), nsim=29, s=seq(5,80,5))
lines(seq(5,80,5), sqrt(env.ok$upper/pi)-seq(5,80,5), lty=2)
lines(seq(5,80,5), sqrt(env.ok$lower/pi)-seq(5,80,5), lty=2)
</code></pre>

<hr>
<h2 id='Kenv.tor1'>Modified envelope of K12hat from random toroidal shifts of two point patterns</h2><span id='topic+Kenv.tor1'></span>

<h3>Description</h3>

<p>Modification of <code>Kenv.tor()</code> to allow the assignment of a p value to the
goodness of fit, following the method outlined in Peter Diggle's 1986
paper (J Neurosci methods 18:115-125) and in his 2002 book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kenv.tor1(pts1, pts2, poly, nsim, s, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kenv.tor1_+3A_pts1">pts1</code></td>
<td>
<p>First point data set</p>
</td></tr>
<tr><td><code id="Kenv.tor1_+3A_pts2">pts2</code></td>
<td>
<p>Second point data set</p>
</td></tr>
<tr><td><code id="Kenv.tor1_+3A_poly">poly</code></td>
<td>
<p>Polygon containing the points</p>
</td></tr>
<tr><td><code id="Kenv.tor1_+3A_nsim">nsim</code></td>
<td>
<p>Number of random toroidal shifts to do</p>
</td></tr>
<tr><td><code id="Kenv.tor1_+3A_s">s</code></td>
<td>
<p>Vector of distances at which to calculate the envelope</p>
</td></tr>
<tr><td><code id="Kenv.tor1_+3A_quiet">quiet</code></td>
<td>
<p>If FALSE, print a message after every simulation for progress monitoring. If TRUE, print no messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components: <code>$upper</code>, <code>$lower</code>, <code>real</code>, <code>u</code>, <code>ksim</code>, and <code>rank</code>. The first three
components are vectors like <code>s</code>, the next two contain results passed back from the simulations, and the final is a one-element vector with the rank of the observed data set.
</p>


<h3>Author(s)</h3>

<p>Stephen Eglen &lt;stephen@inf.ed.ac.uk&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kenv.tor">Kenv.tor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(amacrines)
ama.a &lt;- rbind(amacrines.on, amacrines.off)
ama.bb &lt;- bboxx(bbox(as.points(ama.a)))
ama.t &lt;- seq(from = 0.002, to=.250, by=0.002)
nsim=999
plot(amacrines.on, asp=1, pch=19,
 main="Data set, match figure 1.4 of Diggle(2002)?")
points(amacrines.off, pch=1)
#
k12 &lt;- k12hat(amacrines.on, amacrines.off, ama.bb, ama.t)
#
k11 &lt;- khat(amacrines.on, ama.bb, ama.t)
k22 &lt;- khat(amacrines.off, ama.bb, ama.t)
k00 &lt;- khat(ama.a, ama.bb, ama.t)
theor &lt;- pi * (ama.t^2)
#
plot(ama.t, k12-theor, ylim=c(min( c(k12, k11, k22, k00) - theor),
 max( c(k12, k11, k22, k00) - theor)),
 main="2nd order properties, match figure 4.8 of Diggle (2002)", type="l")
lines(ama.t, -theor)
lines(ama.t, k11-theor, lty=2)
lines(ama.t, k22-theor, lty=3)
lines(ama.t, k00-theor, lty=5)
#
k12.tor &lt;- Kenv.tor(amacrines.on, amacrines.off, ama.bb,
 nsim, ama.t, quiet=TRUE)
plot(ama.t, k12-theor, type="l", main="Output from Kenv.tor")
lines(ama.t, k12.tor$upper-theor, type="l", col="red")
lines(ama.t, k12.tor$lower-theor, type="l", col="red")
#
k12.sims &lt;- Kenv.tor1(amacrines.on, amacrines.off, ama.bb,
 nsim, ama.t, quiet=TRUE)
plot(ama.t, sqrt(k12.sims$real/pi), type="l", asp=1, bty="n",
 main=paste("K12 versus toroidal sims; rank ", k12.sims$rank, "of",
 length(k12.sims$u)))
lines(ama.t, sqrt(k12.sims$upper/pi), col="red")
lines(ama.t, sqrt(k12.sims$lower/pi), col="red")
</code></pre>

<hr>
<h2 id='kernel2d'>
Kernel smoothing of a point pattern
</h2><span id='topic+kernel2d'></span><span id='topic+spkernel2d'></span>

<h3>Description</h3>

<p>Perform kernel smoothing of a point pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel2d(pts,poly,h0,nx=20,ny=20,kernel='quartic',quiet=FALSE)
spkernel2d(pts, poly, h0, grd, kernel = "quartic")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernel2d_+3A_pts">pts</code></td>
<td>

<p>A points data set, or in function spkernel2d an object with a coordinates method from the sp package
</p>
</td></tr>
<tr><td><code id="kernel2d_+3A_poly">poly</code></td>
<td>

<p>A splancs polygon data set
</p>
</td></tr>
<tr><td><code id="kernel2d_+3A_h0">h0</code></td>
<td>

<p>The kernel width parameter
</p>
</td></tr>
<tr><td><code id="kernel2d_+3A_nx">nx</code></td>
<td>

<p>Number of points along the x-axis of the returned grid.
</p>
</td></tr>
<tr><td><code id="kernel2d_+3A_ny">ny</code></td>
<td>

<p>Number of points along the y-axis of the returned grid.
</p>
</td></tr>
<tr><td><code id="kernel2d_+3A_kernel">kernel</code></td>
<td>

<p>Type of kernel function to use. Currently only the quartic kernel is implemented.
</p>
</td></tr>
<tr><td><code id="kernel2d_+3A_quiet">quiet</code></td>
<td>

<p>If TRUE, no debugging output is printed.
</p>
</td></tr>
<tr><td><code id="kernel2d_+3A_grd">grd</code></td>
<td>
<p>a GridTopology object from the sp package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The kernel estimate, with a correction for edge effects, is computed for
a grid of points that span the
input polygon. The kernel function for points in the grid that are outside the polygon are returned
as NA's.
The output list is in a format that can be read into <code>image()</code> directly,
for display and superposition onto other plots.
</p>


<h3>Value</h3>

<p>kernel2d returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>List of x-coordinates at which the kernel function has been evaluated.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>List of y-coordinates at which the kernel function has been evaluated.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>A matrix of dimension <code>nx</code> by <code>ny</code> containing the value of
the kernel function.</p>
</td></tr>
<tr><td><code>h0</code>, <code>kernel</code></td>
<td>
<p>containing the values input to <code>kernel2d</code></p>
</td></tr>
</table>
<p>spkernel2d returns a numeric vector with the value of the kernel function stored in the order required by sp package SpatialGridDataFrame objects
</p>


<h3>References</h3>

<p>Berman M. and Diggle P.J. (1989) Estimating Weighted Integrals of the
Second-Order Intensity of Spatial Point Patterns.  <em>J. R. Statist
Soc</em> B51 81-92; Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point
pattern analysis code in S-Plus.  Computers and Geosciences, 19, 627-655,
(Barry Rowlingson ); the original sources
can be accessed at: <a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See
also Bivand, R. and Gebhardt, A. 2000 Implementing functions for spatial
statistical analysis using the R language. Journal of Geographical
Systems, 2, 307-317.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bodmin)
plot(bodmin$poly, asp=1, type="n")
image(kernel2d(as.points(bodmin), bodmin$poly, h0=2, nx=100, ny=100), 
add=TRUE, col=terrain.colors(20))
pointmap(as.points(bodmin), add=TRUE)
polymap(bodmin$poly, add=TRUE)
bodmin.xy &lt;- coordinates(bodmin[1:2])
apply(bodmin$poly, 2, range)
grd1 &lt;- GridTopology(cellcentre.offset=c(-5.2, -11.5), cellsize=c(0.2, 0.2), cells.dim=c(75,100))
k100 &lt;- spkernel2d(bodmin.xy, bodmin$poly, h0=1, grd1)
k150 &lt;- spkernel2d(bodmin.xy, bodmin$poly, h0=1.5, grd1)
k200 &lt;- spkernel2d(bodmin.xy, bodmin$poly, h0=2, grd1)
k250 &lt;- spkernel2d(bodmin.xy, bodmin$poly, h0=2.5, grd1)
df &lt;- data.frame(k100=k100, k150=k150, k200=k200, k250=k250)
kernels &lt;- SpatialGridDataFrame(grd1, data=df)
spplot(kernels, checkEmptyRC=FALSE, col.regions=terrain.colors(16), cuts=15)
</code></pre>

<hr>
<h2 id='kernel3d'>
Space-time kernel
</h2><span id='topic+kernel3d'></span>

<h3>Description</h3>

<p>Compute the space-time kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel3d(pts, times, xgr, ygr, zgr, hxy, hz)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernel3d_+3A_pts">pts</code></td>
<td>

<p>A matrix of event coodinates x,y.
</p>
</td></tr>
<tr><td><code id="kernel3d_+3A_times">times</code></td>
<td>

<p>A vector of event times, t.
</p>
</td></tr>
<tr><td><code id="kernel3d_+3A_xgr">xgr</code></td>
<td>

<p>The values of x at which to compute the kernel function.
</p>
</td></tr>
<tr><td><code id="kernel3d_+3A_ygr">ygr</code></td>
<td>

<p>The values of y at which to compute the kernel function.
</p>
</td></tr>
<tr><td><code id="kernel3d_+3A_zgr">zgr</code></td>
<td>

<p>The values of time at which to compute the kernel function.
</p>
</td></tr>
<tr><td><code id="kernel3d_+3A_hxy">hxy</code></td>
<td>

<p>The quartic kernel width in the x and y direction.
</p>
</td></tr>
<tr><td><code id="kernel3d_+3A_hz">hz</code></td>
<td>

<p>The quartic kernel width in the temporal direction.
</p>
</td></tr></table>


<h3>Value</h3>

<p>A list is returned. Most of the components are just copies of the 
input parameters, except for the <code>$v</code> parameter.
This is a three dimensional array containing the kernel-smoothed
values. Its dimension is
<code>[length(xgr),length(ygr),length(tgr)]</code>. 
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kerview">kerview</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(burkitt)
b3d &lt;- kernel3d(burpts, burkitt$t, seq(250,350,10), seq(250, 400, 10),
  seq(365,5800,365), 30, 200)
brks &lt;- quantile(b3d$v, seq(0,1,0.05))
cols &lt;- heat.colors(length(brks)-1)
oldpar &lt;- par(mfrow=c(3,5))
for (i in 1:15) image(seq(250,350,10), seq(250, 400, 10), b3d$v[,,i],
  asp=1, xlab="", ylab="", main=1960+i, breaks=brks, col=cols)
par(oldpar)
</code></pre>

<hr>
<h2 id='kernrat'>
Ratio of two kernel smoothings
</h2><span id='topic+kernrat'></span>

<h3>Description</h3>

<p>Return the ratio of two kernel smoothings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernrat(pts1,pts2,poly,h1,h2,nx=20,ny=20,kernel='quartic')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernrat_+3A_pts1">pts1</code>, <code id="kernrat_+3A_pts2">pts2</code></td>
<td>

<p>Point data sets
</p>
</td></tr>
<tr><td><code id="kernrat_+3A_poly">poly</code></td>
<td>

<p>A polygon data set
</p>
</td></tr>
<tr><td><code id="kernrat_+3A_h1">h1</code>, <code id="kernrat_+3A_h2">h2</code></td>
<td>

<p>The kernel width parameters, <code>h1</code> for <code>pts1</code>, and <code>h2</code> for <code>pts2</code>
</p>
</td></tr>
<tr><td><code id="kernrat_+3A_nx">nx</code></td>
<td>

<p>Number of points along the x-axis of the returned grid.
</p>
</td></tr>
<tr><td><code id="kernrat_+3A_ny">ny</code></td>
<td>

<p>Number of points along the y-axis of the returned grid.
</p>
</td></tr>
<tr><td><code id="kernrat_+3A_kernel">kernel</code></td>
<td>

<p>Type of kernel function to use. Currently only the quartic kernel is implemented.
</p>
</td></tr></table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>List of x-coordinates at which the kernel function has been evaluated.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>List of y-coordinates at which the kernel function has been evaluated.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>A matrix of dimension <code>nx</code> by <code>ny</code> containing the ratio of the kernel functions.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>A vector of length 2 containing <code>h1</code> and <code>h2</code></p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>a character string containing the kernel name.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Berman M. and Diggle P.J. (1989) Estimating Weighted Integrals of the
Second-Order Intensity of Spatial Point Patterns.
<em>J. R. Statist Soc</em> B51 81-92;
Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel2d">kernel2d</a></code>, <code><a href="#topic+mse2d">mse2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(okwhite)
data(okblack)
okpoly &lt;- list(x=c(okwhite$x, okblack$x), y=c(okwhite$y, okblack$y))
kr &lt;- kernrat(as.points(okwhite), as.points(okblack), bboxx(bbox(as.points(okpoly))),
 h1=50, h2=50)
image(kr, asp=1)
brks &lt;- quantile(c(kr$z), seq(0,1,1/10), na.rm=TRUE)
lbrks &lt;- formatC(brks, 3, 6, "g", " ") 
cols &lt;- heat.colors(length(brks)-1)
def.par &lt;- par(no.readonly = TRUE)
layout(matrix(c(1,0,1,2), 2, 2, byrow = TRUE), c(2.5,1.5), c(1,3), TRUE)
image(kr, breaks=brks, col=cols, asp=1)
plot.new()
legend(c(0,1), c(0,1), legend=paste(lbrks[-length(lbrks)], lbrks[-1], sep=":"), fill=cols, bty="n")
par(def.par)
</code></pre>

<hr>
<h2 id='kerview'>
A linked-window system for browsing space-time data
</h2><span id='topic+kerview'></span>

<h3>Description</h3>

<p>A linked-window system for browsing space-time data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kerview(pts, times, k3, map=TRUE, addimg=TRUE, ncol=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kerview_+3A_pts">pts</code></td>
<td>

<p>A matrix of event x,y coordinates.
</p>
</td></tr>
<tr><td><code id="kerview_+3A_times">times</code></td>
<td>

<p>A vector of event times.
</p>
</td></tr>
<tr><td><code id="kerview_+3A_k3">k3</code></td>
<td>

<p>An object returned from <code>kernel3d</code>, the space-time kernel smoothing
function
</p>
</td></tr>
<tr><td><code id="kerview_+3A_map">map</code></td>
<td>

<p>If false, don't plot the map display.
</p>
</td></tr>
<tr><td><code id="kerview_+3A_addimg">addimg</code></td>
<td>

<p>If true, overwrite successive images in the image display, else
make a fresh image plot each time.
</p>
</td></tr>
<tr><td><code id="kerview_+3A_ncol">ncol</code></td>
<td>

<p>Number of columns and rows for multiple images and maps.
</p>
</td></tr></table>


<h3>Details</h3>

<p>This function displays three linked views of the data. In the current
graphics window a temporal slice from the kernel smoothing is displayed. 
Another graphics device is started to display a map of the data that
contributed to that time-slice. A third graphics device shows a 
histogram of the times of the events. Clicking with the mouse
in this window with button 1 sets the time for the other
displays to the time on the x-axis of the histogram at the clicked point.
</p>
<p>In this way the 3-dimensional kernel smoothed function can be browsed, 
and the corresponding map of the data compared.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel3d">kernel3d</a></code>
</p>

<hr>
<h2 id='khat'>
K-function
</h2><span id='topic+khat'></span><span id='topic+print.khat'></span><span id='topic+plot.khat'></span>

<h3>Description</h3>

<p>Calculates an estimate of the K-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>khat(pts,poly,s,newstyle=FALSE,checkpoly=TRUE)
## S3 method for class 'khat'
print(x, ...)
## S3 method for class 'khat'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="khat_+3A_pts">pts</code></td>
<td>

<p>A points data set
</p>
</td></tr>
<tr><td><code id="khat_+3A_poly">poly</code></td>
<td>

<p>A polygon containing the points - must be a perimeter ring of points
</p>
</td></tr>
<tr><td><code id="khat_+3A_s">s</code></td>
<td>

<p>A vector of distances at which to calculate the K function
</p>
</td></tr>
<tr><td><code id="khat_+3A_newstyle">newstyle</code></td>
<td>
<p>if TRUE, the function returns a khat object</p>
</td></tr>
<tr><td><code id="khat_+3A_checkpoly">checkpoly</code></td>
<td>
<p>if TRUE compare polygon area and polygon bounding box and convex hull areas to see whether the polygon object is malformed; may be set to FALSE if the polygon is known to be a ring of points</p>
</td></tr>
<tr><td><code id="khat_+3A_x">x</code></td>
<td>
<p>a <code>khat</code> object</p>
</td></tr>
<tr><td><code id="khat_+3A_...">...</code></td>
<td>
<p>other arguments passed to plot and print functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The K function is defined as the expected number of further points
within a distance s of an arbitrary point, divided by the
overall density of the points. 
In practice an edge-correction is required to avoid biasing the
estimation due to non-recording of points outside the polygon.
</p>
<p>The newstyle argument and khat object were introduced in collaboration 
with Thomas de Cornulier to permit the mapping of 
counts or khats for chosen distance values, as in 
<a href="http://pbil.univ-lyon1.fr/R/pdf/Thema81.pdf">http://pbil.univ-lyon1.fr/R/pdf/Thema81.pdf</a>, p.18.
</p>


<h3>Value</h3>

<p>If <code>newstyle</code> is FALSE, 
a vector like <code>s</code> containing the value of K at the points in <code>s</code>.
else a <code>khat</code> object list with:
</p>
<table role = "presentation">
<tr><td><code>khat</code></td>
<td>
<p>the value of K at the points in <code>s</code></p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>integer matrix of counts of points within the vector of
distances <code>s</code> for each point</p>
</td></tr>
<tr><td><code>khats</code></td>
<td>
<p>matrix of values of K within the vector of distances <code>s</code>
for each point</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p><code>s</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Ripley, B.D. 1976 The second-order analysis of stationary point processes,
<em> J. Appl. Prob, 13</em> 255-266;
Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kenv.csr">Kenv.csr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cardiff)
s &lt;- seq(2,30,2)
plot(s, sqrt(khat(as.points(cardiff), cardiff$poly, s)/pi) - s,
 type="l", xlab="Splancs - polygon boundary", ylab="Estimated L",
 ylim=c(-1,1.5))
newstyle &lt;- khat(as.points(cardiff), cardiff$poly, s, newstyle=TRUE)
str(newstyle)
newstyle
apply(newstyle$khats, 2, sum)
plot(newstyle)
</code></pre>

<hr>
<h2 id='khvc'>
Covariance matrix for the difference between two K-functions
</h2><span id='topic+khvc'></span>

<h3>Description</h3>

<p>Calculate the covariance matrix for the difference between two K-functions.
Also return the contribution to the variance for each of the two point
patterns,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>khvc(pts1, pts2, poly, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="khvc_+3A_pts1">pts1</code></td>
<td>

<p>An object containing the case locations.
</p>
</td></tr>
<tr><td><code id="khvc_+3A_pts2">pts2</code></td>
<td>

<p>An object containing the control locations.
</p>
</td></tr>
<tr><td><code id="khvc_+3A_poly">poly</code></td>
<td>

<p>A polygon enclosing the locations in <code>pts1</code> and <code>pts2</code>
</p>
</td></tr>
<tr><td><code id="khvc_+3A_s">s</code></td>
<td>

<p>A vector of distances at which the calculation is to be made.
</p>
</td></tr></table>


<h3>Value</h3>

<p>A list with four components:
</p>
<table role = "presentation">
<tr><td><code>varmat</code></td>
<td>
<p>The upper triangle of the covariance matrix.</p>
</td></tr>
<tr><td><code>k11</code></td>
<td>
<p>The variance of Khat for the cases</p>
</td></tr>
<tr><td><code>k22</code></td>
<td>
<p>The variance of Khat for the controls</p>
</td></tr>
<tr><td><code>k12</code></td>
<td>
<p>The covariance of Khat for the cases and Khat for controls.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the diagonal of the covariance matrix is
<code>$k11 - 2 * $k12 + $k22
</code></p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+khat">khat</a></code>, <code><a href="#topic+khvmat">khvmat</a></code>, <code><a href="#topic+secal">secal</a></code>
</p>

<hr>
<h2 id='khvmat'>
Covariance matrix for the difference between two K-functions
</h2><span id='topic+khvmat'></span>

<h3>Description</h3>

<p>Calculate the covariance matrix for the difference between two K-functions 
under random labelling of the corresponding two sets of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>khvmat(pts1, pts2, poly, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="khvmat_+3A_pts1">pts1</code></td>
<td>

<p>An object containing the case locations.
</p>
</td></tr>
<tr><td><code id="khvmat_+3A_pts2">pts2</code></td>
<td>

<p>An object containing the control locations.
</p>
</td></tr>
<tr><td><code id="khvmat_+3A_poly">poly</code></td>
<td>

<p>Polygon enclosing the points in pts1 and pts2.
</p>
</td></tr>
<tr><td><code id="khvmat_+3A_s">s</code></td>
<td>

<p>A vector of distances at which the calculation is to be made.
</p>
</td></tr></table>


<h3>Value</h3>

<p>A matrix containing the covariances, with the variances on the diagonal.
</p>


<h3>References</h3>

<p>Diggle P.J and Chetwynd A.C (1991) Second order analysis of
spatial clustering Biometrics 47 1155-63;
Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+secal">secal</a></code>
</p>

<hr>
<h2 id='mpoint'>
Overlay a number of point patterns
</h2><span id='topic+mpoint'></span>

<h3>Description</h3>

<p>Overlay a number of point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpoint(...,cpch,add=FALSE,type="p")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpoint_+3A_...">...</code></td>
<td>

<p>At least one argument consisting of a points data set must be specified.
</p>
</td></tr>
<tr><td><code id="mpoint_+3A_cpch">cpch</code></td>
<td>

<p>A vector of characters for plotting symbols
</p>
</td></tr>
<tr><td><code id="mpoint_+3A_add">add</code></td>
<td>

<p>if <code>add</code> is <code>TRUE</code> then overlay on an existing plot
</p>
</td></tr>
<tr><td><code id="mpoint_+3A_type">type</code></td>
<td>

<p>plot data as points if <code>type="p"</code>, lines if <code>type="l"</code>
</p>
</td></tr></table>


<h3>Details</h3>

<p><code>mpoint</code> enables several point or polygon datasets to be overlayed. The plot
region is calculated so that all the specified datasets fit in the region.
The parameter <code>cpch</code> specifies the characters to use for each set of points. The
default <code>cpch</code> consists of the numbers 1 to 9 followed by the uppercase 
letters A to Z. If <code>cpch</code> is shorter than the number of point sets to
plot, then it is repeated.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pointmap">pointmap</a></code>
</p>

<hr>
<h2 id='mse2d'>
Mean Square Error for a Kernel Smoothing
</h2><span id='topic+mse2d'></span>

<h3>Description</h3>

<p>Estimate the Mean Square Error for a Kernel Smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse2d(pts,poly,nsmse, range)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mse2d_+3A_pts">pts</code></td>
<td>

<p>A set of points.
</p>
</td></tr>
<tr><td><code id="mse2d_+3A_poly">poly</code></td>
<td>

<p>A polygon containng the points.
</p>
</td></tr>
<tr><td><code id="mse2d_+3A_nsmse">nsmse</code></td>
<td>

<p>Number of steps of <code>h</code> at which to calculate the mean square error.
</p>
</td></tr>
<tr><td><code id="mse2d_+3A_range">range</code></td>
<td>

<p>Maximum value of <code>h</code> for calculating the mean square error.
</p>
</td></tr></table>


<h3>Value</h3>

<p>A list with two components, <code>$h</code> and <code>$mse</code>. These vectors store
corresponding values of the mean square error at values of the kernel
smoothing parameter, <code>h</code>. 
The value of <code>h</code> corresponding to the minimum value of <code>$mse</code>
can be passed to <code>kernel2d</code> as the optimum smoothing parameter.
</p>


<h3>References</h3>

<p>Berman M. &amp; Diggle P.J. (1989) Estimating Weighted Integrals of the
Second-Order Intensity of a Spatial Point Pattern. 
<em> J. R. Statist Soc</em> B 51 81&ndash;92;
Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel2d">kernel2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bodmin)
Mse2d &lt;- mse2d(as.points(bodmin), bodmin$poly, nsmse=50, range=8)
plot(Mse2d$h[5:50],Mse2d$mse[5:50], type="l")
</code></pre>

<hr>
<h2 id='n2dist'>
Nearest neighbours for two point patterns
</h2><span id='topic+n2dist'></span>

<h3>Description</h3>

<p>Calculate nearest neighbours for two point patterns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n2dist(pts1,pts2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n2dist_+3A_pts1">pts1</code>, <code id="n2dist_+3A_pts2">pts2</code></td>
<td>

<p>Point data sets
</p>
</td></tr></table>


<h3>Value</h3>

<p>Returns a list with components <code>$dists</code> and <code>$neighs</code>.
<code>$dists[i]</code> is the distance
of the nearest neighbour of point <code>pts2[i,]</code>  
in <code>pts1</code> and <code>$neighs[i]</code>
is the index in <code>pts1</code> of the point nearest to <code>pts2[i,]</code>. Documentation and example by Alun Pope, 2007-08-23.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndistF">nndistF</a></code>, <code><a href="#topic+Fhat">Fhat</a></code>, <code><a href="#topic+Ghat">Ghat</a></code>, <code><a href="#topic+Fzero">Fzero</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(test1 &lt;- matrix(c(151.1791, -33.86056, 151.1599, -33.88729, 151.1528,
-33.90685, 151.1811, -33.85937),nrow=4,byrow=TRUE))
(test2 &lt;- as.points(151.15, -33.9))
n2dist(test1,test2)
n2dist(test2,test1)
</code></pre>

<hr>
<h2 id='nndistF'>
Nearest neighbour distances as used by Fhat()
</h2><span id='topic+nndistF'></span>

<h3>Description</h3>

<p>Calculate nearest neighbour distances as used by  <code>Fhat()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nndistF(pts1,pts2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nndistF_+3A_pts1">pts1</code></td>
<td>

<p>A points data set
</p>
</td></tr>
<tr><td><code id="nndistF_+3A_pts2">pts2</code></td>
<td>

<p>A points data set
</p>
</td></tr></table>


<h3>Value</h3>

<p>The set of distances from each of the points in <code>pts2</code> to the nearest
point in <code>pts1</code> is returned as a vector.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndistG">nndistG</a></code>, <code><a href="#topic+Fhat">Fhat</a></code>, <code><a href="#topic+Ghat">Ghat</a></code>, <code><a href="#topic+Fzero">Fzero</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(uganda)
boxplot(nndistF(as.points(uganda), as.points(csr(uganda$poly, length(uganda$x)))))
plot(ecdf(nndistF(as.points(uganda), 
as.points(csr(uganda$poly, length(uganda$x))))),
main="Fhat ecdf Uganda volcano data")
</code></pre>

<hr>
<h2 id='nndistG'>
Nearest neighbour distances as used by Ghat()
</h2><span id='topic+nndistG'></span>

<h3>Description</h3>

<p>Calculate nearest neighbour distances as used by <code>Ghat()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nndistG(pts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nndistG_+3A_pts">pts</code></td>
<td>

<p>A points data set
</p>
</td></tr></table>


<h3>Value</h3>

<p>Returns a list with components <code>$dists</code> and <code>$neighs</code>.
<code>$dists[i]</code> is the distance
to the nearest neighbour of point <code>i</code> in <code>pts,</code> and <code>$neighs[i]</code>
is the index
of the neighbour of point <code>i</code>.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndistF">nndistF</a></code>, <code><a href="#topic+Fhat">Fhat</a></code>, <code><a href="#topic+Ghat">Ghat</a></code>, <code><a href="#topic+Fzero">Fzero</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(uganda)
boxplot(nndistG(as.points(uganda))$dists)
plot(ecdf(nndistG(as.points(uganda))$dists))
</code></pre>

<hr>
<h2 id='npts'>
Number of points in data set
</h2><span id='topic+npts'></span>

<h3>Description</h3>

<p>return number of points in data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npts(pts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="npts_+3A_pts">pts</code></td>
<td>

<p>A points data set
</p>
</td></tr></table>


<h3>Value</h3>

<p>The number of points in the data set.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>

<hr>
<h2 id='okblack'>Oklahoma black offenders</h2><span id='topic+okblack'></span>

<h3>Description</h3>

<p>Locations of theft from property offences committed by black offenders in Oklahoma City
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(okblack)</code></pre>


<h3>Format</h3>

<p>A list corresponding to a Venables and Ripley point object with 147 observations
</p>

<table>
<tr>
 <td style="text-align: left;">
    x  </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid eastings</td>
</tr>
<tr>
 <td style="text-align: left;">
    y   </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid northings</td>
</tr>
<tr>
 <td style="text-align: left;">
    area </td><td style="text-align: left;">	list	</td><td style="text-align: left;"> bounding box with xl, xu, yl, yu</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>



<h3>Source</h3>

<p>Carter and Hill, 1979, - Bailey and Gatrell 1995, ch. 3.
</p>


<h3>References</h3>

<p>Bailey, T. C. and Gatrell, A. C. 1995, Interactive spatial data analysis. Longman, Harlow.
</p>

<hr>
<h2 id='okwhite'>Oklahoma white offenders</h2><span id='topic+okwhite'></span>

<h3>Description</h3>

<p>Locations of theft from property offences committed by white offenders in Oklahoma City
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(okwhite)</code></pre>


<h3>Format</h3>

<p>A list corresponding to a Venables and Ripley point object with 104 observations
</p>

<table>
<tr>
 <td style="text-align: left;">
    x  </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid eastings</td>
</tr>
<tr>
 <td style="text-align: left;">
    y   </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid northings</td>
</tr>
<tr>
 <td style="text-align: left;">
    area </td><td style="text-align: left;">	list	</td><td style="text-align: left;"> bounding box with xl, xu, yl, yu</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Carter and Hill, 1979, - Bailey and Gatrell 1995, ch. 3.
</p>


<h3>References</h3>

<p>Bailey, T. C. and Gatrell, A. C. 1995, Interactive spatial data analysis. Longman, Harlow.
</p>

<hr>
<h2 id='pcp'>Fit a Poisson cluster process</h2><span id='topic+pcp'></span>

<h3>Description</h3>

<p>The function fits a Poisson cluster process to point data for a given
enclosing polygon and fit parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcp(point.data, poly.data, h0=NULL, expo=0.25, n.int=20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcp_+3A_point.data">point.data</code></td>
<td>
<p>a points object</p>
</td></tr>
<tr><td><code id="pcp_+3A_poly.data">poly.data</code></td>
<td>
<p>a polygon enclosing the study region</p>
</td></tr>
<tr><td><code id="pcp_+3A_h0">h0</code></td>
<td>
<p>upper bound of integration in the criterion function</p>
</td></tr>
<tr><td><code id="pcp_+3A_expo">expo</code></td>
<td>
<p>exponent in the criterion function</p>
</td></tr>
<tr><td><code id="pcp_+3A_n.int">n.int</code></td>
<td>
<p>number of intervals used to approximate the integral in the criterion function with a sum</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object as returned by <code>optim</code>, including:
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p>The best set of parameters s2 and rho found</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value of the fit corresponding to &lsquo;par&rsquo;</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>&lsquo;0&rsquo; indicates successful convergence</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni Petris &lt;GPetris@uark.edu&gt;,  Roger.Bivand@nhh.no</p>


<h3>References</h3>

<p>Diggle, P. J. (1983) <em>Statistical analysis of spatial point
patterns</em>, London: Academic Press, pp. 55-57 and 78-81; Bailey, T. C. and
Gatrell, A. C. (1995) <em>Interactive spatial data analysis</em>, Harlow:
Longman, pp. 106-109.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+pcp.sim">pcp.sim</a></code>, <code><a href="#topic+Kenv.pcp">Kenv.pcp</a></code>, <code><a href="#topic+khat">khat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cardiff)
polymap(cardiff$poly)
pointmap(as.points(cardiff), add=TRUE)
title("Locations of homes of 168 juvenile offenders")
pcp.fit &lt;- pcp(as.points(cardiff), cardiff$poly, h0=30, n.int=30)
pcp.fit
</code></pre>

<hr>
<h2 id='pcp.sim'>Generate a Poisson Cluster Process</h2><span id='topic+pcp.sim'></span>

<h3>Description</h3>

<p>The function generates a Poisson cluster process for a given polygon within
a larger bounding region and given process parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcp.sim(rho, m, s2, region.poly, larger.region=NULL, vectorise.loop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcp.sim_+3A_rho">rho</code></td>
<td>
<p>intensity of the parent process</p>
</td></tr>
<tr><td><code id="pcp.sim_+3A_m">m</code></td>
<td>
<p>average number of offsprings per parent</p>
</td></tr>
<tr><td><code id="pcp.sim_+3A_s2">s2</code></td>
<td>
<p>variance of location of offsprings relative to their parent</p>
</td></tr>
<tr><td><code id="pcp.sim_+3A_region.poly">region.poly</code></td>
<td>
<p>a polygon defining the region in which the process is to be generated</p>
</td></tr>
<tr><td><code id="pcp.sim_+3A_larger.region">larger.region</code></td>
<td>
<p>a rectangle containing the region of interest given in the form (xl,xu,yl,yu), defaults to <code>sbox()</code> around region.poly</p>
</td></tr>
<tr><td><code id="pcp.sim_+3A_vectorise.loop">vectorise.loop</code></td>
<td>
<p>if TRUE, use new vectorised code, if FALSE, use loop as before</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates the parents in the larger bounding region, generates
their children also in the larger bounding region, and then returns those
inside the given polygon.</p>


<h3>Value</h3>

<p>A point object with the simulated pattern
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris &lt;GPetris@uark.edu&gt;,  Roger.Bivand@nhh.no</p>


<h3>References</h3>

<p>Diggle, P. J. (1983) <em>Statistical analysis of spatial point
patterns</em>, London: Academic Press, pp. 55-57 and 78-81; Bailey, T. C. and
Gatrell, A. C. (1995) <em>Interactive spatial data analysis</em>, Harlow:
Longman, pp. 106-109.</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcp">pcp</a></code>, <code><a href="#topic+Kenv.pcp">Kenv.pcp</a></code>, <code><a href="#topic+khat">khat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cardiff)
polymap(cardiff$poly)
pointmap(as.points(cardiff), add=TRUE)
title("Locations of homes of 168 juvenile offenders")
pcp.fit &lt;- pcp(as.points(cardiff), cardiff$poly, h0=30, n.int=30)
pcp.fit
m &lt;- npts(as.points(cardiff))/(areapl(cardiff$poly)*pcp.fit$par[2])
sims &lt;- pcp.sim(pcp.fit$par[2], m, pcp.fit$par[1], cardiff$poly)
pointmap(as.points(sims), add=TRUE, col="red")
</code></pre>

<hr>
<h2 id='pdense'>
Overall density for a point pattern
</h2><span id='topic+pdense'></span>

<h3>Description</h3>

<p>Calculate overall density for a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdense(pts,poly)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdense_+3A_pts">pts</code></td>
<td>

<p>A points data set
</p>
</td></tr>
<tr><td><code id="pdense_+3A_poly">poly</code></td>
<td>

<p>A polygon data set
</p>
</td></tr></table>


<h3>Value</h3>

<p>The density of the points in the polygon. i.e. the number of points
per unit area.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fzero">Fzero</a></code>
</p>

<hr>
<h2 id='pip'>
Points inside or outside a polygon
</h2><span id='topic+pip'></span>

<h3>Description</h3>

<p>Return points inside or outside a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pip(pts,poly,out=FALSE,bound=NULL,quiet=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pip_+3A_pts">pts</code></td>
<td>

<p>A points data set
</p>
</td></tr>
<tr><td><code id="pip_+3A_poly">poly</code></td>
<td>

<p>A polygon data set
</p>
</td></tr>
<tr><td><code id="pip_+3A_out">out</code></td>
<td>

<p>If <code>out=TRUE</code>, return the points outside the polygon, else the points inside.
</p>
</td></tr>
<tr><td><code id="pip_+3A_bound">bound</code></td>
<td>
<p>If points fall exactly on polygon boundaries, the default NULL gives arbitrary assignments. If TRUE, then all points &quot;on&quot; boundaries are set as within the polygon, if FALSE, outside.</p>
</td></tr>
<tr><td><code id="pip_+3A_quiet">quiet</code></td>
<td>
<p>Do not report which points are on boundary for non-NULL bound</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pip</code> calls <code>inout</code>, then selects the appropriate sub-set of points.
</p>


<h3>Value</h3>

<p><code>pip</code> returns the points of <code>pts</code> that lie inside (or outside with
<code>out=TRUE</code>)
the polygon <code>poly</code>. Compare this with <code>inpip</code>, which returns
the indices of
the points in the polygon, and <code>inout</code> which returns a logical vector
indicating whether points are inside or outside.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inpip">inpip</a></code>, <code><a href="#topic+inout">inout</a></code>
</p>

<hr>
<h2 id='plt'>bins nearest neighbour distances</h2><span id='topic+plt'></span>

<h3>Description</h3>

<p>bins nearest neighbour distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt(data, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plt_+3A_data">data</code></td>
<td>
<p>nearest neighbour distances</p>
</td></tr>
<tr><td><code id="plt_+3A_value">value</code></td>
<td>
<p>breaks for binning distances</p>
</td></tr>
</table>


<h3>Value</h3>

<p>binned values
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fhat">Fhat</a></code>, <code><a href="#topic+Ghat">Ghat</a></code></p>

<hr>
<h2 id='pointmap'>
Graphics
</h2><span id='topic+pointmap'></span>

<h3>Description</h3>

<p>Plots point and polygon data sets on the current graphics device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointmap(pts,add=FALSE,axes=TRUE,xlab="",ylab="", asp,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pointmap_+3A_pts">pts</code></td>
<td>

<p>a points data set.
</p>
</td></tr>
<tr><td><code id="pointmap_+3A_add">add</code></td>
<td>

<p>if FALSE, start a new plot. If TRUE, superimpose on current plot.
</p>
</td></tr>
<tr><td><code id="pointmap_+3A_axes">axes</code></td>
<td>

<p>if true, display axes with labelling. If false, do not display any 
axes on the plot.
</p>
</td></tr>
<tr><td><code id="pointmap_+3A_xlab">xlab</code>, <code id="pointmap_+3A_ylab">ylab</code></td>
<td>

<p>Label strings for x and y axes.
</p>
</td></tr>
<tr><td><code id="pointmap_+3A_asp">asp</code></td>
<td>
<p>aspect parameter for plot</p>
</td></tr>
<tr><td><code id="pointmap_+3A_...">...</code></td>
<td>

<p>Graphical arguments may be entered, and these are passed to the
standard S <code>points</code> and <code>polygon</code> routines.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The specified data set is plotted on the current graphics device, either
as points or polygons. For <code>polymap</code>, the last point in the data set
is drawn connected to the first point.
<code>pointmap</code> and <code>polymap</code> preserve
the aspect ratio in the data by using the <code>asp=1</code> plot argument.
Graphical parameters can also be supplied to these routines, and are passed 
through to <code>plot</code>. Some useful parameters include <code>pch</code> to change the plotting
character for points, <code>lty</code> to change the line type for polygons, and 
<code>type="n"</code> to set up axes for the plot without plotting anything.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpoint">mpoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bodmin)
plot(bodmin$poly, asp=1, type="n")
pointmap(as.points(bodmin), add=TRUE)
polymap(bodmin$poly, add=TRUE)
</code></pre>

<hr>
<h2 id='polymap'>
Graphics
</h2><span id='topic+polymap'></span>

<h3>Description</h3>

<p>Plots point and polygon data sets on the current graphics device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polymap(poly,add=FALSE,xlab="",ylab="",axes=TRUE, asp,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polymap_+3A_poly">poly</code></td>
<td>

<p>a polygon.
</p>
</td></tr>
<tr><td><code id="polymap_+3A_add">add</code></td>
<td>

<p>if FALSE, start a new plot. If TRUE, superimpose on current plot.
</p>
</td></tr>
<tr><td><code id="polymap_+3A_xlab">xlab</code>, <code id="polymap_+3A_ylab">ylab</code></td>
<td>

<p>Label strings for x and y axes.
</p>
</td></tr>
<tr><td><code id="polymap_+3A_axes">axes</code></td>
<td>

<p>if true, display axes with labelling. If false, do not display any 
axes on the plot.
</p>
</td></tr>
<tr><td><code id="polymap_+3A_asp">asp</code></td>
<td>
<p>aspect parameter for plot</p>
</td></tr>
<tr><td><code id="polymap_+3A_...">...</code></td>
<td>

<p>Graphical arguments may be entered, and these are passed to the
standard S <code>points</code> and <code>polygon</code> routines.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The specified data set is plotted on the current graphics device, either
as points or polygons. For <code>polymap</code>, the last point in the data set
is drawn connected to the first point.
<code>pointmap</code> and <code>polymap</code> preserve
the aspect ratio in the data by using the <code>asp=1</code> plot argument.
Graphical parameters can also be supplied to these routines, and are passed 
through to <code>plot</code>. Some useful parameters include <code>pch</code> to change the plotting
character for points, <code>lty</code> to change the line type for polygons, and 
<code>type="n"</code> to just set up axes for the plot without plotting anything.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+par">par</a></code>, <code><a href="#topic+mpoint">mpoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bodmin)
plot(bodmin$poly, asp=1, type="n")
pointmap(as.points(bodmin), add=TRUE)
polymap(bodmin$poly, add=TRUE)
</code></pre>

<hr>
<h2 id='print.ribfit'>
Display the fit from tribble()
</h2><span id='topic+print.ribfit'></span>

<h3>Description</h3>

<p>Display the fit from <code>tribble</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ribfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ribfit_+3A_x">x</code></td>
<td>

<p>An object returned from <code>tribble</code>
</p>
</td></tr>
<tr><td><code id="print.ribfit_+3A_...">...</code></td>
<td>
<p>optional arguments to pass through to <code>print()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter estimates and log-likelihood for the raised incidence 
model are displayed. The likelihood ratio, D = 2*(L-Lo), is also given.
This function is called whenever <code>print</code> operates on an object
with class <code>ribfit</code>.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tribble">tribble</a></code>
</p>

<hr>
<h2 id='ranpts'>adjust number of random points in polygon</h2><span id='topic+ranpts'></span>

<h3>Description</h3>

<p>adjust number of random points in polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranpts(pts, poly, nprq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranpts_+3A_pts">pts</code></td>
<td>
<p>points object</p>
</td></tr>
<tr><td><code id="ranpts_+3A_poly">poly</code></td>
<td>
<p>polygon object</p>
</td></tr>
<tr><td><code id="ranpts_+3A_nprq">nprq</code></td>
<td>
<p>required number of points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>points object with required number of random points
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csr">csr</a></code></p>

<hr>
<h2 id='rLabel'>
Randomly label two or more point sets
</h2><span id='topic+rLabel'></span>

<h3>Description</h3>

<p>Randomly label two or more point sets. (function name changed from rlabel to rLabel to avoid collision with spatstat)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rLabel(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rLabel_+3A_...">...</code></td>
<td>

<p>Any number of points data sets
</p>
</td></tr></table>


<h3>Details</h3>

<p>The output data sets are a random labelling of the input data sets, i.e. 
all the points in the input data sets are randomly assigned to the output 
sets. The number of points in each output set is the same as its corresponding
input set.
</p>


<h3>Value</h3>

<p>A list of points data sets. There are as many elements in the list as 
arguments.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>

<hr>
<h2 id='rtor.shift'>
Random toroidal shift on a point data set
</h2><span id='topic+rtor.shift'></span>

<h3>Description</h3>

<p>Perform a random toroidal shift on a point data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtor.shift(pts,rect)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rtor.shift_+3A_pts">pts</code></td>
<td>

<p>The point data set to shift
</p>
</td></tr>
<tr><td><code id="rtor.shift_+3A_rect">rect</code></td>
<td>

<p>A rectangle defining the region for the toroidal map. If not given, 
the bounding box of <code>pts</code> is used.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The planar region defined by <code>rect</code>
is assumed connected at its top and bottom edges, and at its left and
right sides. A random shift is applied to the 
points and the resulting set of points returned. 
</p>


<h3>Value</h3>

<p>A point data set like <code>pts</code>, but after application of a random toroidal 
shift along the x and y axes. 
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Shift">Shift</a></code>
</p>

<hr>
<h2 id='sbox'>
Generate a box surrounding a point object
</h2><span id='topic+sbox'></span>

<h3>Description</h3>

<p>Generate a box surrounding a point object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbox(pts, xfrac = .1, yfrac = .1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sbox_+3A_pts">pts</code></td>
<td>

<p>A points data set
</p>
</td></tr>
<tr><td><code id="sbox_+3A_xfrac">xfrac</code></td>
<td>

<p>The fraction of the width of the point pattern by which the box will
surround the point pattern to the left and right.
</p>
</td></tr>
<tr><td><code id="sbox_+3A_yfrac">yfrac</code></td>
<td>

<p>The fraction of the height of the point pattern by which the box will 
surround the point pattern to the top and bottom. 
</p>
</td></tr></table>


<h3>Value</h3>

<p>A points data set of four points giving the coordinates of the surrounding box
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bboxx">bboxx</a></code>
</p>

<hr>
<h2 id='secal'>
Standard errors for the difference between two K-functions
</h2><span id='topic+secal'></span>

<h3>Description</h3>

<p>Calculate standard errors for the difference between two K-functions under
random labelling of the corresponding two sets of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secal(pts1,pts2,poly,s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="secal_+3A_pts1">pts1</code>, <code id="secal_+3A_pts2">pts2</code></td>
<td>

<p>Two point data sets
</p>
</td></tr>
<tr><td><code id="secal_+3A_poly">poly</code></td>
<td>

<p>Polygon enclosing the points in <code>pts1</code> and <code>pts2</code>
</p>
</td></tr>
<tr><td><code id="secal_+3A_s">s</code></td>
<td>

<p>A vector of distances at which to calculate the standard error.
</p>
</td></tr></table>


<h3>Details</h3>

<p>To compare two point patterns, one can calculate the difference between
their K-functions. The function <code>secal</code> gives the pointwise standard 
errors for the estimated differences, under the random labelling hypothesis.
</p>


<h3>Value</h3>

<p>A vector like <code>s</code> containing the value of the standard error at each of the
distances in <code>s</code>
</p>


<h3>References</h3>

<p>Diggle P.J. and Chetwynd A.G. (1991) Second-order analysis of spatial 
clustering
<em>Biometrics 47</em> 1155&ndash;63; 
Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+khat">khat</a></code>
</p>

<hr>
<h2 id='Shift'>
Shift a point data set
</h2><span id='topic+Shift'></span>

<h3>Description</h3>

<p>Shift a point data set (function name changed from shift to Shift to avoid collision with spatstat)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Shift(pts,xsh=0.0,ysh=0.0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Shift_+3A_pts">pts</code></td>
<td>

<p>The point data set to shift
</p>
</td></tr>
<tr><td><code id="Shift_+3A_xsh">xsh</code></td>
<td>

<p>Amount to shift along the x-axis
</p>
</td></tr>
<tr><td><code id="Shift_+3A_ysh">ysh</code></td>
<td>

<p>Amount to shift along the y-axis
</p>
</td></tr></table>


<h3>Value</h3>

<p>A point data set like <code>pts</code>, but with <code>xsh</code> added to its
x-coordinates, and <code>ysh</code> added to its y-coordinates.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tor.shift">tor.shift</a></code>
</p>

<hr>
<h2 id='southlancs'>Cancer cases in Chorley-Ribble</h2><span id='topic+southlancs'></span><span id='topic+southlancs.pts'></span><span id='topic+southlancs.cc'></span><span id='topic+old.incinerator'></span><span id='topic+southlancs.bdy'></span>

<h3>Description</h3>

<p>Locations of cases of cancer of lung and larynx in
Chorley-Ribble, Lancashire. The data set is split into a points object <code>southlancs.pts</code> and a
case/control 0/1 vector <code>southlancs.cc</code>. There are 917 controls and 57
cases in this data set - these numbers differ from 978 and 58 in Diggle (1990)
and Diggle and Rowlingson (1994). The data set also includes the approximate
location of an old incinerator <code>old.incinerator</code>, as well as
<code>southlancs.bdy</code>, the study area boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(southlancs)</code></pre>


<h3>Format</h3>

<p>A data frame with 974 observations
</p>

<table>
<tr>
 <td style="text-align: right;">
    [,1]  </td><td style="text-align: left;"> x  </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid eastings (metres)</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,2]  </td><td style="text-align: left;"> y   </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid northings (metres)</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,3]  </td><td style="text-align: left;"> cc  </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> case/control, lung=0, larynx=1</td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Diggle, Gatrell and Lovett, 1990, - Bailey and Gatrell 1995, ch. 3.
</p>


<h3>References</h3>

<p>Bailey and Gatrell 1995, ch. 3; Diggle, P. (1990) A point process
modelling approach to raised incidence of a rare phenomenon in the viscinity
of a prespecified point. Journal of the Royal Statistical Society, A, 153,
349-362; Diggle, P. and Rowlingson, B. (1994) A conditional approach to point
process modelling of elevated risk. Journal of the Royal Statistical Society,
A, 157, 433-440.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(southlancs)
op &lt;- par(mfrow=c(2,1))
pointmap(southlancs.pts[southlancs.cc == 0,])
pointmap(old.incinerator, add=TRUE, col="red", pch=19)
title("Lung cancer controls")
pointmap(southlancs.pts[southlancs.cc == 1,])
pointmap(old.incinerator, add=TRUE, col="red", pch=19)
title("Larynx cancer cases")
par(op)
polymap(southlancs.bdy,border="grey")
contour(kernel2d(southlancs.pts[southlancs.cc == 0,], 
	southlancs.bdy, h=500, nx=100, ny=100), nlevels=20, 
	add=TRUE,drawlabels=FALSE)
pointmap(southlancs.pts[southlancs.cc == 1,], add=TRUE, pch=19,
	 col="green")
pointmap(old.incinerator, add=TRUE, pch=19, col="red")
title(xlab="h=500, quartic kernel")
title("Density map of control, green case points, red old incinerator")

</code></pre>

<hr>
<h2 id='splancs'>
Return version number and author information
</h2><span id='topic+splancs'></span>

<h3>Description</h3>

<p>Return version number and author information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splancs()
</code></pre>


<h3>Value</h3>

<p>The version string is returned. This is a number of the format x.yy,
where x is the major version number and yy is the minor version number.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>

<hr>
<h2 id='spoints'>
Point Objects
</h2><span id='topic+spoints'></span>

<h3>Description</h3>

<p>Creates and tests for data in spatial point format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spoints(data,npoints)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spoints_+3A_data">data</code></td>
<td>

<p>vector containing the data values for the points
in order (x1,y1),(x2,y2),...
</p>
</td></tr>
<tr><td><code id="spoints_+3A_npoints">npoints</code></td>
<td>

<p>number of points to generate, if missing, set to length(data)/2.
</p>
</td></tr></table>


<h3>Value</h3>

<p><code>spoints</code> returns an object suitable for use as a point data
object. If <code>npoints</code> is given, the vector data is either truncated
or repeated until sufficient data values are generated.
The returned object is a two-column matrix, where the first column stores the 
x-coordinate, and the second column stores the y-coordinate.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npts">npts</a></code>
</p>

<hr>
<h2 id='stdiagn'>
Summary plots for clustering analysis
</h2><span id='topic+stdiagn'></span>

<h3>Description</h3>

<p>Produces some summary plots for clustering analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdiagn(pts, stkh, stse, stmc=0,Dzero=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stdiagn_+3A_pts">pts</code></td>
<td>

<p>A set of points, as used in Splancs
</p>
</td></tr>
<tr><td><code id="stdiagn_+3A_stkh">stkh</code></td>
<td>

<p>An object returned from <code>stkhat</code>
</p>
</td></tr>
<tr><td><code id="stdiagn_+3A_stse">stse</code></td>
<td>

<p>An object returned from <code>stsecal</code>
</p>
</td></tr>
<tr><td><code id="stdiagn_+3A_stmc">stmc</code></td>
<td>

<p>An object returned from <code>stmctest</code>
</p>
</td></tr>
<tr><td><code id="stdiagn_+3A_dzero">Dzero</code></td>
<td>
<p>FALSE - default D plot, TRUE Dzero plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four plots are produced on the current graphics device.
The first plot is simply a map of the data. The second is a perspective plot
of the difference between space-time K-function and the product of spatial
and temporal K-functions. The third plot is of the 
standardised residuals against the product of spatial and temporal
K-functions. If the Monte-Carlo data is given the fourth plot is a
a histogram of the test statistics, with the value for the data indicated
with a vertical line.
See Diggle, Chetwynd, Haggkvist, and Morris (1995) for details.
</p>


<h3>References</h3>

<p>Diggle, P., Chetwynd, A., Haggkvist, R. and Morris, S. 1995 Second-order analysis of space-time clustering. Statistical Methods in Medical Research, 4, 124-136;Bailey, T. C. and Gatrell, A. C. 1995, Interactive spatial data analysis. Longman, Harlow, pp. 122-125;
Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stkhat">stkhat</a></code>, <code><a href="#topic+stsecal">stsecal</a></code>, <code><a href="#topic+stvmat">stvmat</a></code>, <code><a href="#topic+stmctest">stmctest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(stkhat)
example(stsecal)
example(stmctest)
stdiagn(burpts, bur1, bur1se, bur1mc)
</code></pre>

<hr>
<h2 id='stkhat'>
Space-time K-functions
</h2><span id='topic+stkhat'></span>

<h3>Description</h3>

<p>Compute the space-time K-functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stkhat(pts, times, poly, tlimits, s, tm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stkhat_+3A_pts">pts</code></td>
<td>

<p>A set of points as defined in Splancs
</p>
</td></tr>
<tr><td><code id="stkhat_+3A_times">times</code></td>
<td>

<p>A vector of times, the same length as the number of points in <code>pts</code>
</p>
</td></tr>
<tr><td><code id="stkhat_+3A_poly">poly</code></td>
<td>

<p>A polygon enclosing the points
</p>
</td></tr>
<tr><td><code id="stkhat_+3A_tlimits">tlimits</code></td>
<td>

<p>A vector of length 2 specifying the upper and lower temporal domain.
</p>
</td></tr>
<tr><td><code id="stkhat_+3A_s">s</code></td>
<td>

<p>A vector of spatial distances for the analysis.
</p>
</td></tr>
<tr><td><code id="stkhat_+3A_tm">tm</code></td>
<td>

<p>A vector of times for the analysis
</p>
</td></tr></table>


<h3>Value</h3>

<p>A list with the following components is returned:
</p>
<table role = "presentation">
<tr><td><code>s</code>, <code>t</code></td>
<td>
<p>The spatial and temporal scales</p>
</td></tr>
<tr><td><code>ks</code></td>
<td>
<p>The spatial K-function</p>
</td></tr>
<tr><td><code>kt</code></td>
<td>
<p>The temporal K-function</p>
</td></tr>
<tr><td><code>kst</code></td>
<td>
<p>The space-time K-function</p>
</td></tr>
</table>
<p>For details see Diggle, Chetwynd, Haggkvist, and Morris (1995)
</p>


<h3>References</h3>

<p>Diggle, P., Chetwynd, A., Haggkvist, R. and Morris, S. 1995 Second-order analysis of space-time clustering. Statistical Methods in Medical Research, 4, 124-136;Bailey, T. C. and Gatrell, A. C. 1995, Interactive spatial data analysis. Longman, Harlow, pp. 122-125;
Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stsecal">stsecal</a></code>, <code><a href="#topic+stvmat">stvmat</a></code>, <code><a href="#topic+stmctest">stmctest</a></code>, <code><a href="#topic+stdiagn">stdiagn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(burkitt)
bur1 &lt;- stkhat(burpts, burkitt$t, burbdy, c(400, 5800),
  seq(1,40,2), seq(100, 1500, 100))
oldpar &lt;- par(mfrow=c(2,1))
plot(bur1$s, bur1$ks, type="l", xlab="distance", ylab="Estimated K",
  main="spatial K function")
plot(bur1$t, bur1$kt, type="l", xlab="time", ylab="Estimated K",
  main="temporal K function")
par(oldpar)
</code></pre>

<hr>
<h2 id='stmctest'>
Monte-Carlo test of space-time clustering
</h2><span id='topic+stmctest'></span>

<h3>Description</h3>

<p>Perform a Monte-Carlo test of space-time clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stmctest(pts, times, poly, tlimits, s, tt, nsim, quiet=FALSE, returnSims=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stmctest_+3A_pts">pts</code></td>
<td>

<p>A set of points as used by Splancs.
</p>
</td></tr>
<tr><td><code id="stmctest_+3A_times">times</code></td>
<td>

<p>A vector of times, the same length as the number of points in <code>pts</code>.
</p>
</td></tr>
<tr><td><code id="stmctest_+3A_poly">poly</code></td>
<td>

<p>A polygon enclosing the points.
</p>
</td></tr>
<tr><td><code id="stmctest_+3A_tlimits">tlimits</code></td>
<td>

<p>A vector of length 2, specifying the upper and lower temporal domain.
</p>
</td></tr>
<tr><td><code id="stmctest_+3A_s">s</code></td>
<td>

<p>A vector of spatial distances for the analysis.
</p>
</td></tr>
<tr><td><code id="stmctest_+3A_tt">tt</code></td>
<td>

<p>A vector of times for the analysis.
</p>
</td></tr>
<tr><td><code id="stmctest_+3A_nsim">nsim</code></td>
<td>

<p>The number of simulations to do.
</p>
</td></tr>
<tr><td><code id="stmctest_+3A_quiet">quiet</code></td>
<td>

<p>If <code>quiet=TRUE</code> then no output is produced, otherwise the function
prints the number of simulations completed so far, and also how the
test statistic for the data ranks with the simulations.
</p>
</td></tr>
<tr><td><code id="stmctest_+3A_returnsims">returnSims</code></td>
<td>
<p>default FALSE, if TRUE, return the <code>stkhat</code> output for the observed data and each simulation as attributes <code>obs</code> and <code>sims</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function  uses a sum of residuals as a test statistic, 
randomly permutes the times of the set of points and recomputes the
test statistic for a number of simulations.
See Diggle, Chetwynd, Haggkvist and Morris (1995) for details.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>t0</code></td>
<td>
<p>The observed value of the statistic</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>A single column matrix with <code>nsim</code> values each of which is a simulated value of the statistic</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The example of using returned simulated values is included only to show how the values might be used, not to indicate that this constitutes a way of examining which observed values of the space-time measure are exceptional.</p>


<h3>References</h3>

<p>Diggle, P., Chetwynd, A., Haggkvist, R. and Morris, S. 1995 Second-order analysis of space-time clustering. Statistical Methods in Medical Research, 4, 124-136;Bailey, T. C. and Gatrell, A. C. 1995, Interactive spatial data analysis. Longman, Harlow, pp. 122-125;
Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stkhat">stkhat</a></code>, <code><a href="#topic+stsecal">stsecal</a></code>, <code><a href="#topic+stvmat">stvmat</a></code>, <code><a href="#topic+stdiagn">stdiagn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(stkhat)
bur1mc &lt;- stmctest(burpts, burkitt$t, burbdy, c(400, 5800),
  seq(1,40,2), seq(100, 1500, 100), nsim=49, quiet=TRUE, returnSims=TRUE)
plot(density(bur1mc$t), xlim=range(c(bur1mc$t0, bur1mc$t)))
abline(v=bur1mc$t0)
r0 &lt;- attr(bur1mc, "obs")$kst-outer(attr(bur1mc, "obs")$ks, attr(bur1mc, "obs")$kt)
rsimlist &lt;- lapply(attr(bur1mc, "sims"), function(x) x$kst - outer(x$ks, x$kt))
rarray &lt;- array(do.call("cbind", rsimlist), dim=c(20, 15, 49))
rmin &lt;- apply(rarray, c(1,2), min)
rmax &lt;- apply(rarray, c(1,2), max)
r0 &lt; rmin
r0 &gt; rmax
</code></pre>

<hr>
<h2 id='stsecal'>
Standard error for space-time clustering
</h2><span id='topic+stsecal'></span>

<h3>Description</h3>

<p>Computes the standard error for space-time clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsecal(pts, times, poly, tlim, s, tm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsecal_+3A_pts">pts</code></td>
<td>

<p>A set of points, as defined in Splancs.
</p>
</td></tr>
<tr><td><code id="stsecal_+3A_times">times</code></td>
<td>

<p>A vector of times, the same length as the number of points in <code>pts</code>
</p>
</td></tr>
<tr><td><code id="stsecal_+3A_poly">poly</code></td>
<td>

<p>A polygon enclosing the points
</p>
</td></tr>
<tr><td><code id="stsecal_+3A_tlim">tlim</code></td>
<td>

<p>A vector of length 2 specifying the upper and lower temporal domain.
</p>
</td></tr>
<tr><td><code id="stsecal_+3A_s">s</code></td>
<td>

<p>A vector of spatial distances for the analysis
</p>
</td></tr>
<tr><td><code id="stsecal_+3A_tm">tm</code></td>
<td>

<p>A vector of times for the analysis
</p>
</td></tr></table>


<h3>Value</h3>

<p>A matrix of dimension <code>[length(s),length(t)]</code> is returned. Element 
<code>[i,j]</code> is the standard error at <code>s[i],t[j]</code>.
See Diggle Chetwynd Haggkvist and Morris (1995) for details.
</p>


<h3>References</h3>

<p>Diggle, P., Chetwynd, A., Haggkvist, R. and Morris, S. 1995 Second-order analysis of space-time clustering. Statistical Methods in Medical Research, 4, 124-136;Bailey, T. C. and Gatrell, A. C. 1995, Interactive spatial data analysis. Longman, Harlow, pp. 122-125;
Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stkhat">stkhat</a></code>, <code><a href="#topic+stsecal">stsecal</a></code>, <code><a href="#topic+stvmat">stvmat</a></code>, <code><a href="#topic+stdiagn">stdiagn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(stkhat)
bur1se &lt;- stsecal(burpts, burkitt$t, burbdy, c(400, 5800),
 seq(1,40,2), seq(100, 1500, 100))
</code></pre>

<hr>
<h2 id='stvmat'>
Variance matrix for space-time clustering
</h2><span id='topic+stvmat'></span>

<h3>Description</h3>

<p>Compute the variance matrix for space-time clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stvmat(pts, times, poly, tlim, s, tm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stvmat_+3A_pts">pts</code></td>
<td>

<p>A set of points.
</p>
</td></tr>
<tr><td><code id="stvmat_+3A_times">times</code></td>
<td>

<p>A vector of times, the same length as the number of points in <code>pts</code>
</p>
</td></tr>
<tr><td><code id="stvmat_+3A_poly">poly</code></td>
<td>

<p>A polygon that encloses the points
</p>
</td></tr>
<tr><td><code id="stvmat_+3A_tlim">tlim</code></td>
<td>

<p>A vector of length 2 specifying the upper and lower temporal domain.
</p>
</td></tr>
<tr><td><code id="stvmat_+3A_s">s</code></td>
<td>

<p>A vector of spatial distances for the analysis
</p>
</td></tr>
<tr><td><code id="stvmat_+3A_tm">tm</code></td>
<td>

<p>A vector of times for the analysis
</p>
</td></tr></table>


<h3>Value</h3>

<p>A four-dimensional matrix is returned. The covariance between space-time
<code>t1,s1</code> and <code>t2,s2</code> is given by the corresponding element <code>[t1,s1,t2,s2]</code>
For full details, see Diggle, Chetwynd, Haggkvist and Morris (1995)
</p>


<h3>References</h3>

<p>Diggle, P., Chetwynd, A., Haggkvist, R. and Morris, S. 1995 Second-order analysis of space-time clustering. Statistical Methods in Medical Research, 4, 124-136;
Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stkhat">stkhat</a></code>, <code><a href="#topic+stsecal">stsecal</a></code>, <code><a href="#topic+stmctest">stmctest</a></code>, <code><a href="#topic+stdiagn">stdiagn</a></code>
</p>

<hr>
<h2 id='thin'>
Randomly thin a point data set
</h2><span id='topic+thin'></span>

<h3>Description</h3>

<p>Randomly thin a point data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin(pts,n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thin_+3A_pts">pts</code></td>
<td>

<p>a points data set.
</p>
</td></tr>
<tr><td><code id="thin_+3A_n">n</code></td>
<td>

<p>the number of points to return
</p>
</td></tr></table>


<h3>Value</h3>

<p>Returns a point data set consisting of <code>n</code> points selected randomly
from the set <code>pts</code>.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>

<hr>
<h2 id='tor.shift'>
Toroidal shift on a point data set
</h2><span id='topic+tor.shift'></span>

<h3>Description</h3>

<p>Perform a toroidal shift on a point data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tor.shift(pts,xsh=0.0,ysh=0.0,rect)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tor.shift_+3A_pts">pts</code></td>
<td>

<p>The point data set to shift
</p>
</td></tr>
<tr><td><code id="tor.shift_+3A_xsh">xsh</code></td>
<td>

<p>Amount to shift along the x-axis
</p>
</td></tr>
<tr><td><code id="tor.shift_+3A_ysh">ysh</code></td>
<td>

<p>Amount to shift along the y-axis
</p>
</td></tr>
<tr><td><code id="tor.shift_+3A_rect">rect</code></td>
<td>

<p>A rectangle defining the region for the toroidal map. If not given, 
the bounding box of <code>pts</code> is used.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The planar region defined by <code>rect</code>
is assumed connected at its top and bottom edges, and at its left and
right sides. A shift of <code>xsh</code> and <code>ysh</code> is applied to the 
points and the resulting set of points returned. 
</p>


<h3>Value</h3>

<p>A point data set like <code>pts</code>, but after application of a toroidal 
shift along the x and y axes. 
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Shift">Shift</a></code>
</p>

<hr>
<h2 id='tribble'>
Diggle-Rowlingson Raised Incidence Model
</h2><span id='topic+tribble'></span>

<h3>Description</h3>

<p>Fits the Diggle-Rowlingson Raised Incidence Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tribble(ccflag, vars=NULL, alphas=NULL, betas=NULL, rho, 
 which=1:length(alphas), covars=NULL, thetas=NULL, 
 steps=NULL, reqmin=0.001, icount=50, hessian=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tribble_+3A_ccflag">ccflag</code></td>
<td>

<p>Case-control flag : a vector of ones and zeroes.
</p>
</td></tr>
<tr><td><code id="tribble_+3A_vars">vars</code></td>
<td>

<p>A matrix where <code>vars[i,j]</code> is the distance squared from point <code>i</code> 
to source <code>j</code>.
</p>
</td></tr>
<tr><td><code id="tribble_+3A_alphas">alphas</code></td>
<td>

<p>Initial value of the <code>alpha</code> parameters.
</p>
</td></tr>
<tr><td><code id="tribble_+3A_betas">betas</code></td>
<td>

<p>Initial value of the <code>beta</code> parameters.
</p>
</td></tr>
<tr><td><code id="tribble_+3A_rho">rho</code></td>
<td>

<p>Initial value of the <code>rho</code> parameter.
</p>
</td></tr>
<tr><td><code id="tribble_+3A_which">which</code></td>
<td>

<p>Defines the mapping from sources to parameters.
</p>
</td></tr>
<tr><td><code id="tribble_+3A_covars">covars</code></td>
<td>

<p>A matrix of covariates to be modelled as log-linear terms. The element 
<code>covars[i,j]</code> is the value of covariate <code>j</code> for case/control <code>i</code>.
</p>
</td></tr>
<tr><td><code id="tribble_+3A_thetas">thetas</code></td>
<td>

<p>Initial values of covariate parameters.
</p>
</td></tr>
<tr><td><code id="tribble_+3A_steps">steps</code></td>
<td>

<p>Step sizes for the Nelder-Mead simplex algorithm.
</p>
</td></tr>
<tr><td><code id="tribble_+3A_reqmin">reqmin</code></td>
<td>

<p>Tolerance for simplex algorithm
</p>
</td></tr>
<tr><td><code id="tribble_+3A_icount">icount</code></td>
<td>

<p>Iteration count for simplex algorithm
</p>
</td></tr>
<tr><td><code id="tribble_+3A_hessian">hessian</code></td>
<td>
<p>by default NULL, any other value causes hessian to be computed and returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value is a list with many components, and class <code>ribfit</code>. 
</p>
<table role = "presentation">
<tr><td><code>alphas</code></td>
<td>
<p>A vector of the alpha parameters at the maximum</p>
</td></tr>
<tr><td><code>betas</code></td>
<td>
<p>A vector of the beta values at the maximum</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>The value of rho at the maximum</p>
</td></tr>
<tr><td><code>logl</code></td>
<td>
<p>The maximised log-likelihood</p>
</td></tr>
<tr><td><code>null.logl</code></td>
<td>
<p>The null log-likelihood</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call to <code>tribble</code></p>
</td></tr>
</table>
<p>For further information see Diggle and Rowlingson (1993).
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triblik">triblik</a></code>, <code><a href="#topic+dsquare">dsquare</a></code>
</p>

<hr>
<h2 id='triblik'>
Log-likelihood for the Diggle-Rowlingson raised incidence model
</h2><span id='topic+triblik'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood for the Diggle-Rowlingson raised incidence model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triblik(ccflag, vars=NULL, alphas=NULL, betas=NULL, rho, 
 which=1:length(alphas), covars=NULL, thetas=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triblik_+3A_ccflag">ccflag</code></td>
<td>

<p>Case-control flag : a vector of ones and zeroes.
</p>
</td></tr>
<tr><td><code id="triblik_+3A_vars">vars</code></td>
<td>

<p>A matrix where <code>vars[i,j]</code> is the distance squared from point <code>i</code> 
to source <code>j</code>.
</p>
</td></tr>
<tr><td><code id="triblik_+3A_alphas">alphas</code></td>
<td>

<p>The <code>alpha</code> parameters.
</p>
</td></tr>
<tr><td><code id="triblik_+3A_betas">betas</code></td>
<td>

<p>The <code>beta</code> parameters.
</p>
</td></tr>
<tr><td><code id="triblik_+3A_rho">rho</code></td>
<td>

<p>The <code>rho</code> parameter.
</p>
</td></tr>
<tr><td><code id="triblik_+3A_which">which</code></td>
<td>

<p>Defines the mapping from sources to parameters.
</p>
</td></tr>
<tr><td><code id="triblik_+3A_covars">covars</code></td>
<td>

<p>A matrix of covariates to be modelled as log-linear terms. The element 
<code>covars[i,j]</code> is the value of covariate <code>j</code> for case/control <code>i</code>.
</p>
</td></tr>
<tr><td><code id="triblik_+3A_thetas">thetas</code></td>
<td>

<p>The covariate parameters.
</p>
</td></tr></table>


<h3>Value</h3>

<p>The log-likelihood for the given parameters and the given distances and
optional covariates is returned.
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tribble">tribble</a></code>, <code><a href="#topic+dsquare">dsquare</a></code>
</p>

<hr>
<h2 id='uganda'>Craters in Uganda</h2><span id='topic+uganda'></span>

<h3>Description</h3>

<p>Locations of craters in a volcanic field in Uganda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(uganda)</code></pre>


<h3>Format</h3>

<p>A list corresponding to a Venables and Ripley point object with 120 observations
</p>

<table>
<tr>
 <td style="text-align: left;">
    x  </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid eastings</td>
</tr>
<tr>
 <td style="text-align: left;">
    y   </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> grid northings</td>
</tr>
<tr>
 <td style="text-align: left;">
    area </td><td style="text-align: left;">	list	</td><td style="text-align: left;"> bounding box with xl, xu, yl, yu</td>
</tr>
<tr>
 <td style="text-align: left;">
    poly </td><td style="text-align: left;"> array </td><td style="text-align: left;"> polygon boundary with columns x and y</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Tinkler, 1971, - Bailey and Gatrell 1995, ch. 3.
</p>


<h3>References</h3>

<p>Bailey, T. C. and Gatrell, A. C. 1995, Interactive spatial data analysis. Longman, Harlow.
</p>

<hr>
<h2 id='zoom'>
Interactively specify a region of a plot for expansion
</h2><span id='topic+zoom'></span>

<h3>Description</h3>

<p>Interactively specify a region of a plot for expansion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoom(quiet=FALSE,out=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoom_+3A_quiet">quiet</code></td>
<td>

<p>If false, prompt the user to enter two coordinates. If true, say nothing.
</p>
</td></tr>
<tr><td><code id="zoom_+3A_out">out</code></td>
<td>

<p>If true, expand the limits of the current plot by a factor of three, centred
on the current plot.
</p>
</td></tr>
<tr><td><code id="zoom_+3A_...">...</code></td>
<td>

<p>Other arguments are passed through to pointmap.
</p>
</td></tr></table>


<h3>Details</h3>

<p>A prompt is optionally displayed, and the user selects two points
forming the diagonal of a rectangle. A new, empty plot is created that has its
axis limits set to the bounding square of the selected rectangle. 
If <code>out=TRUE</code>, no prompt is displayed, and a new blank plot is created with
its limits in x and y set to span an area three times the height and width
centred on the current centre.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>References</h3>

<p>Rowlingson, B. and Diggle, P. 1993 Splancs: spatial point pattern analysis
code in S-Plus.  Computers and Geosciences, 19, 627-655;
the original sources can be accessed at:
<a href="https://www.maths.lancs.ac.uk/~rowlings/Splancs/">https://www.maths.lancs.ac.uk/~rowlings/Splancs/</a>. See also Bivand, R. and
Gebhardt, A. 2000 Implementing functions for spatial statistical analysis
using the R language. Journal of Geographical Systems, 2, 307-317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pointmap">pointmap</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
