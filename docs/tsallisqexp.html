<!DOCTYPE html><html><head><title>Help for package tsallisqexp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tsallisqexp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tsal'><p>The Tsallis Distribution</p></a></li>
<li><a href='#tsal.boot'><p>Bootstraps methods for Tsallis Distributions</p></a></li>
<li><a href='#tsal.fit'><p>Fitting Tsallis Distributions</p></a></li>
<li><a href='#tsal.tail'><p>The Tsallis Distribution with a censoring parameter (tail-conditional)</p></a></li>
<li><a href='#tsal.test'><p>Test Tsallis Distributions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tsallis q-Exp Distribution</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9-4</td>
</tr>
<tr>
<td>Author:</td>
<td>Cosma Shalizi [aut] (original R code), Christophe Dutang [cre] (R code packaging)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christophe Dutang &lt;christophe.dutang@ensimag.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tsallis distribution also known as the q-exponential family distribution. Provide distribution d, p, q, r functions, fitting and testing functions. Project initiated by Paul Higbie and based on Cosma Shalizi's code.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-09 21:12:27 UTC; dutang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-10 05:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tsal'>The Tsallis Distribution</h2><span id='topic+tsal'></span><span id='topic+dtsal'></span><span id='topic+ptsal'></span><span id='topic+qtsal'></span><span id='topic+rtsal'></span><span id='topic+tsal.mean'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtsal(x, shape=1, scale=1, q=tsal.q.from.shape(shape),
kappa=tsal.kappa.from.ss(shape,scale),
log=FALSE)

ptsal(x, shape=1, scale=1, q=tsal.q.from.shape(shape),
kappa=tsal.kappa.from.ss(shape,scale),
lower.tail=TRUE, log.p=FALSE)

qtsal(p,  shape=1, scale=1, q=tsal.q.from.shape(shape),
kappa=tsal.kappa.from.ss(shape,scale),
lower.tail=TRUE, log.p=FALSE)

rtsal(n, shape=1, scale=1, q=tsal.q.from.shape(shape),
kappa=tsal.kappa.from.ss(shape,scale))

tsal.mean(shape, scale, q=tsal.q.from.shape(shape),
kappa=tsal.kappa.from.ss(shape,scale))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsal_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="tsal_+3A_q">q</code></td>
<td>
<p>vector of quantiles or a shape parameter.</p>
</td></tr>
<tr><td><code id="tsal_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="tsal_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="tsal_+3A_shape">shape</code></td>
<td>
<p>shape parameter.</p>
</td></tr>
<tr><td><code id="tsal_+3A_scale">scale</code>, <code id="tsal_+3A_kappa">kappa</code></td>
<td>
<p>scale parameters.</p>
</td></tr>
<tr><td><code id="tsal_+3A_log">log</code>, <code id="tsal_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="tsal_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Tsallis distribution is defined by the following density
</p>
<p style="text-align: center;"><code class="reqn">
        f(x) = \frac{1}{ \kappa}(1-(1-q)x/\kappa)^{1/(1-q)}
    </code>
</p>

<p>for all <code class="reqn">x</code>.
It is convenient to introduce a re-parameterization
<code class="reqn">shape = -1/(1-q)</code>, <code class="reqn">scale = shape*\kappa</code>
which makes the relationship to the Pareto clearer, and eases estimation.
If we have both shape/scale and q/kappa parameters, the latter over-ride.
</p>


<h3>Value</h3>

<p><code>dtsal</code> gives the density,
<code>ptsal</code> gives the distribution function,
<code>qtsal</code> gives the quantile function, and
<code>rtsal</code> generates random deviates.
<code>tsal.mean</code> computes the expected value.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rtsal</code>, and is the maximum of the lengths of the
numerical parameters for the other functions.  
</p>


<h3>Author(s)</h3>

<p>Cosma Shalizi (original R code),
Christophe Dutang (R packaging)
</p>


<h3>References</h3>

<p><em>Maximum Likelihood Estimation for q-Exponential (Tsallis) Distributions</em>,
<a href="http://bactra.org/research/tsallis-MLE/">http://bactra.org/research/tsallis-MLE/</a> and <a href="https://arxiv.org/abs/math/0701854">https://arxiv.org/abs/math/0701854</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) density function
x &lt;- seq(0, 5, length=24)

cbind(x, dtsal(x, 1/2, 1/4))

#####
# (2) distribution function

cbind(x, ptsal(x, 1/2, 1/4))




		
</code></pre>

<hr>
<h2 id='tsal.boot'>Bootstraps methods for Tsallis Distributions</h2><span id='topic+tsal.boot'></span><span id='topic+tsal.bootstrap.errors'></span><span id='topic+tsal.total.magnitude'></span>

<h3>Description</h3>

<p>Bootstrap functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsal.bootstrap.errors(dist=NULL, reps=500, confidence=0.95,
    n=if(is.null(dist)) 1 else dist$n,
    shape=if(is.null(dist)) 1 else dist$shape,
    scale=if(is.null(dist)) 1 else dist$scale,
    q = if(is.null(dist)) tsal.q.from.shape(shape) else dist$q,
    kappa = if(is.null(dist)) tsal.kappa.from.ss(shape,scale) else dist$kappa,
    method = if(is.null(dist)) "mle.equation" else dist$method,
    xmin = if(is.null(dist)) 0 else dist$xmin)


tsal.total.magnitude(dist=NULL, n=if(is.null(dist)) 1 else dist$n,
    shape=if(is.null(dist)) 1 else dist$shape,
    scale=if(is.null(dist)) 1 else dist$scale,
    q = if(is.null(dist)) tsal.q.from.shape(shape) else dist$q,
    kappa = if(is.null(dist)) tsal.kappa.from.ss(shape,scale) else dist$kappa,
    xmin = if(is.null(dist)) 0 else dist$xmin,
    mult = 1)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsal.boot_+3A_dist">dist</code></td>
<td>
<p>distribution (as a list of the sort produced by tsal.fit)</p>
</td></tr>
<tr><td><code id="tsal.boot_+3A_reps">reps</code></td>
<td>
<p>number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="tsal.boot_+3A_confidence">confidence</code></td>
<td>
<p>confidence level for confidence intervals.</p>
</td></tr>
<tr><td><code id="tsal.boot_+3A_n">n</code></td>
<td>
<p>original sample size.</p>
</td></tr>
<tr><td><code id="tsal.boot_+3A_shape">shape</code>, <code id="tsal.boot_+3A_q">q</code></td>
<td>
<p>shape parameters (over-riding those of the distribution, if
one was given).</p>
</td></tr>
<tr><td><code id="tsal.boot_+3A_scale">scale</code>, <code id="tsal.boot_+3A_kappa">kappa</code></td>
<td>
<p>scale parameters (over-riding those of the distribution, if
one was given).</p>
</td></tr>
<tr><td><code id="tsal.boot_+3A_method">method</code></td>
<td>
<p>fitting method (over-riding that used in the original
fit, if one was given), see <code><a href="#topic+tsal.fit">tsal.fit</a></code>.</p>
</td></tr>
<tr><td><code id="tsal.boot_+3A_xmin">xmin</code></td>
<td>
<p>minimum x-value (left-censoring threshold).</p>
</td></tr>
<tr><td><code id="tsal.boot_+3A_mult">mult</code></td>
<td>
<p>multiplier of size (if the base units of the data are not real units).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tsal.bootstrap.errors</code> finds biases and standard errors for parameter estimates by parametric
bootstrapping, and simple confidence intervals
Simulate, many times, drawing samples from the estimated distribution, of
the same size as the original data; re-estimate the parameters on the
simulated data.  The distribution of the re-estimates around the estimated
parameters is approximately the same as the distribution of the estimate
around the true parameters.
This function invokes the estimating-equation MLE, but it would be easy to modify to
use other methods.
Confidence intervals (CI) are calculated for each parameter separately, using
a simple pivotal interval (see, e.g., Wasserman, _All of Statistics_, Section
8.3).  Confidence regions for combinations of parameters would be a tedious,
but straightforward, extension.
</p>
<p><code>tsal.total.magnitude</code>
estimates the total magnitude of a tail-sampled population
given that we have n samples from the tail of a distribution, i.e., only
values &gt;= xmin were retained, provide an estimate of the total magnitude
(summed values) of the population.
Then it estimates the number of objects, observed and un-observed, as n/pr(X &gt;= xmin)
and then multiply by the mean.
</p>


<h3>Value</h3>

<p><code>tsal.bootstrap.errors</code> returns a structured list, containing the actual parameter settings used,
the estimated biases, the estimated standard errors, the lower
confidence limits, the upper confidence limits, the sample size, the
number of replicates, the confidence level, and the fitting method.
</p>
<p><code>tsal.total.magnitude</code> returns a list, giving estimated total magnitude
and estimated total population size.
</p>


<h3>Author(s)</h3>

<p>Cosma Shalizi (original R code),
Christophe Dutang (R packaging)
</p>


<h3>References</h3>

<p><em>Maximum Likelihood Estimation for q-Exponential (Tsallis) Distributions</em>,
<a href="http://bactra.org/research/tsallis-MLE/">http://bactra.org/research/tsallis-MLE/</a> and <a href="https://arxiv.org/abs/math/0701854">https://arxiv.org/abs/math/0701854</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) fit
x &lt;- rtsal(20, 1/2, 1/4)
tsal.loglik(x, 1/2, 1/4)

tsal.fit(x, method="mle.equation")
tsal.fit(x, method="mle.direct")
tsal.fit(x, method="leastsquares")



		
</code></pre>

<hr>
<h2 id='tsal.fit'>Fitting Tsallis Distributions</h2><span id='topic+tsal.loglik'></span><span id='topic+tsal.fisher'></span><span id='topic+tsal.fit'></span>

<h3>Description</h3>

<p>Loglikelihood and fit functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsal.loglik(x, shape, scale, q=tsal.q.from.shape(shape),
kappa=tsal.kappa.from.ss(shape,scale), xmin=0)

tsal.fit(x, xmin=0, method=c("mle.equation", "mle.direct", "leastsquares"), ...)

#
# Note that this function ONLY works with the shape-scale parameterization
# Inputs: shape, scale, left-censoring threshold

tsal.fisher(shape, scale, xmin=0)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsal.fit_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="tsal.fit_+3A_shape">shape</code>, <code id="tsal.fit_+3A_q">q</code></td>
<td>
<p>shape parameters.</p>
</td></tr>
<tr><td><code id="tsal.fit_+3A_scale">scale</code>, <code id="tsal.fit_+3A_kappa">kappa</code></td>
<td>
<p>scale parameters.</p>
</td></tr>
<tr><td><code id="tsal.fit_+3A_xmin">xmin</code></td>
<td>
<p>minimum x-value.</p>
</td></tr>
<tr><td><code id="tsal.fit_+3A_method">method</code></td>
<td>
<p>A character string for the estimation method:
<code>"mle.equation"</code> (default), <code>"mle.direct"</code>, <code>"leastsquares"</code>.</p>
</td></tr>
<tr><td><code id="tsal.fit_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the estimation method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tsal.loglik</code> computes the loglikelihood of a sample <code>x</code>.
</p>
<p><code>tsal.fisher</code> calculates the Fisher information matrix, for asymptotic variances and
covariances of the maximum likelihood estimates of shape and scale
First row/column corresponds to shape, second to scale
Convergence to the asymptotic normal distribution can be slow, so for limited
data you should bootstrap.
</p>
<p><code>tsal.fit</code> estimates parameters by solving maximum likelihood equations when
<code>method="mle.equation"</code>, by minimizing the log-likelihood (directly) when
<code>method="mle.direct"</code>, by minimizing the square difference between the
empirical and theoretical distribution functions.
This function is a wrapper for the actual methods:
<code>tsal.fit.mle.equation</code> (solve maximum likelihood estimating equations);
<code>tsal.fit.mle.direct</code> (numerical likelihood maximization); and
<code>tsal.fit.leastsquares</code> (least-squares curve-fitting to the empirical
distribution);
prettying up the results in all cases.
</p>


<h3>Value</h3>

<p><code>tsal.loglik</code> returns the loglikelihood as a numeric.
</p>
<p><code>tsal.fit</code> returns <code>NA</code> when estimation aborts
or a list with components (<code>type</code>, <code>q</code>, <code>kappa</code>, <code>shape</code>,
<code>scale</code>, <code>loglik</code>, <code>n</code>, <code>xmin</code>,
<code>method</code>) when estimation succeeds.
</p>


<h3>Author(s)</h3>

<p>Cosma Shalizi (original R code),
Christophe Dutang (R packaging)
</p>


<h3>References</h3>

<p><em>Maximum Likelihood Estimation for q-Exponential (Tsallis) Distributions</em>,
<a href="http://bactra.org/research/tsallis-MLE/">http://bactra.org/research/tsallis-MLE/</a> and <a href="https://arxiv.org/abs/math/0701854">https://arxiv.org/abs/math/0701854</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) fit
x &lt;- rtsal(20, 1/2, 1/4)
tsal.loglik(x, 1/2, 1/4)

tsal.fit(x, method="mle.equation")
tsal.fit(x, method="mle.direct")
tsal.fit(x, method="leastsquares")



		
</code></pre>

<hr>
<h2 id='tsal.tail'>The Tsallis Distribution with a censoring parameter (tail-conditional)</h2><span id='topic+tsal.tail'></span><span id='topic+dtsal.tail'></span><span id='topic+ptsal.tail'></span><span id='topic+qtsal.tail'></span><span id='topic+rtsal.tail'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtsal.tail(x, shape=1,scale=1, q=tsal.q.from.shape(shape),
kappa=tsal.kappa.from.ss(shape,scale), xmin=0,
log=FALSE)

ptsal.tail(x, shape=1, scale=1, q=tsal.q.from.shape(shape),
kappa=tsal.kappa.from.ss(shape,scale), xmin=0,
lower.tail=TRUE, log.p=FALSE)

qtsal.tail(p,  shape=1, scale=1, q=tsal.q.from.shape(shape),
kappa=tsal.kappa.from.ss(shape,scale), xmin=0,
lower.tail=TRUE, log.p=FALSE)

rtsal.tail(n, shape=1, scale=1, q=tsal.q.from.shape(shape),
kappa=tsal.kappa.from.ss(shape,scale), xmin=0)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsal.tail_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="tsal.tail_+3A_q">q</code></td>
<td>
<p>vector of quantiles or a shape parameter.</p>
</td></tr>
<tr><td><code id="tsal.tail_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="tsal.tail_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="tsal.tail_+3A_shape">shape</code></td>
<td>
<p>shape parameter.</p>
</td></tr>
<tr><td><code id="tsal.tail_+3A_scale">scale</code>, <code id="tsal.tail_+3A_kappa">kappa</code></td>
<td>
<p>scale parameters.</p>
</td></tr>
<tr><td><code id="tsal.tail_+3A_xmin">xmin</code></td>
<td>
<p>minimum x-value.</p>
</td></tr>
<tr><td><code id="tsal.tail_+3A_log">log</code>, <code id="tsal.tail_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="tsal.tail_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Tsallis distribution with a censoring parameter is the distribution of
a Tsallis distributed random variable conditionnaly on <code class="reqn">x&gt;xmin</code>.
The density is defined as
</p>
<p style="text-align: center;"><code class="reqn">
        f(x) = \frac{C}{ \kappa}(1-(1-q)x/\kappa)^{1/(1-q)}
    </code>
</p>

<p>for all <code class="reqn">x&gt;xmin</code> where <code class="reqn">C</code> is the appropriate constant so that the integral
of the density equals 1. That is <code class="reqn">C</code> is the survival probability of the classic Tsallis
distribution at <code class="reqn">x=xmin</code>.
It is convenient to introduce a re-parameterization
<code class="reqn">shape = -1/(1-q)</code>, <code class="reqn">scale = shape*\kappa</code>
which makes the relationship to the Pareto clearer, and eases estimation.
If we have both shape/scale and q/kappa parameters, the latter over-ride.
</p>


<h3>Value</h3>

<p><code>dtsal.tail</code> gives the density,
<code>ptsal.tail</code> gives the distribution function,
<code>qtsal.tail</code> gives the quantile function, and
<code>rtsal.tail</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rtsal.tail</code>, and is the maximum of the lengths of the
numerical parameters for the other functions.  
</p>


<h3>Author(s)</h3>

<p>Cosma Shalizi (original R code),
Christophe Dutang (R packaging)
</p>


<h3>References</h3>

<p><em>Maximum Likelihood Estimation for q-Exponential (Tsallis) Distributions</em>,
<a href="http://bactra.org/research/tsallis-MLE/">http://bactra.org/research/tsallis-MLE/</a> and <a href="https://arxiv.org/abs/math/0701854">https://arxiv.org/abs/math/0701854</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) density function
x &lt;- seq(0, 5, length=24)

cbind(x, dtsal(x, 1/2, 1/4))

#####
# (2) distribution function

cbind(x, ptsal(x, 1/2, 1/4))




		
</code></pre>

<hr>
<h2 id='tsal.test'>Test Tsallis Distributions</h2><span id='topic+tsal.test'></span><span id='topic+test.tsal.quantile.transform'></span><span id='topic+test.tsal.LR.distribution'></span>

<h3>Description</h3>

<p>Test functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.tsal.quantile.transform(from=0, to=1e6, shape=1, scale=1,
    q=tsal.q.from.shape(shape), kappa=tsal.kappa.from.ss(shape,scale),
    n=1e5, lwd=0.01, xmin=0, ...)

test.tsal.LR.distribution(n=100, reps=100, shape=1, scale=1,
    q=tsal.q.from.shape(shape), kappa=tsal.kappa.from.ss(shape,scale),
    xmin=0,method="mle.equation",...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsal.test_+3A_from">from</code></td>
<td>
<p>lower limit for <code>x</code>.</p>
</td></tr>
<tr><td><code id="tsal.test_+3A_to">to</code></td>
<td>
<p>upper limit for <code>x</code>.</p>
</td></tr>
<tr><td><code id="tsal.test_+3A_shape">shape</code>, <code id="tsal.test_+3A_q">q</code></td>
<td>
<p>shape parameters.</p>
</td></tr>
<tr><td><code id="tsal.test_+3A_scale">scale</code>, <code id="tsal.test_+3A_kappa">kappa</code></td>
<td>
<p>scale parameters.  If we have both shape/scale and q/kappa parameters, the latter over-ride.</p>
</td></tr>
<tr><td><code id="tsal.test_+3A_n">n</code></td>
<td>
<p>number of points at which to evaluate the function over the domain
or number of sample points.</p>
</td></tr>
<tr><td><code id="tsal.test_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="tsal.test_+3A_xmin">xmin</code></td>
<td>
<p>minimum x-value (left-censoring threshold).</p>
</td></tr>
<tr><td><code id="tsal.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+curve">curve</a></code> or <code><a href="graphics.html#topic+plot">plot</a></code>,
except <code>xlim</code> for <code>test.tsal.LR.distribution</code>.</p>
</td></tr>
<tr><td><code id="tsal.test_+3A_reps">reps</code></td>
<td>
<p>number of replicates.</p>
</td></tr>
<tr><td><code id="tsal.test_+3A_method">method</code></td>
<td>
<p>estimation method, see <code><a href="#topic+tsal.fit">tsal.fit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.tsal.quantile.transform</code> check the accuracy of quantile/inverse quantile transformations
For all parameter values and all <code>x</code>, <code>qtsal(ptsal(x))</code> should <code>= x</code>.
This function displays the relative error in the transformation, which is due
to numerical imprecision.  This indicates roughly how far off random variates
generated by the transformation method will be.
If everything is going according to plan, the curve plotted should oscillate
extremely rapidly between positive and negative limits which, while growing,
stay quite small in absolute terms, e.g., on the order of 1e-5 when
<code>x</code> is on the order of 1e9.
</p>
<p><code>plot.tsal.LR.distribution</code>
checks likelihood ratio estimation accuracy :
<code class="reqn"> 2*[(Likelihood at estimated parameters) - (likelihood at true parameters)]</code>
should have a chi square distribution with 2 degrees of freedom, at least
asymptotically for large samples.
</p>


<h3>Value</h3>

<p><code>plot.tsal.quantile.transform</code> plots the relative error in the transformation.
</p>
<p><code>plot.tsal.LR.distribution</code> plots the likelihood ratio against a
chi-square distribution and returns the result of Kolmgorov-Smirnov
test against theoretical distribution.
</p>


<h3>Author(s)</h3>

<p>Cosma Shalizi (original R code),
Christophe Dutang (R packaging)
</p>


<h3>References</h3>

<p><em>Maximum Likelihood Estimation for q-Exponential (Tsallis) Distributions</em>,
<a href="http://bactra.org/research/tsallis-MLE/">http://bactra.org/research/tsallis-MLE/</a> and <a href="https://arxiv.org/abs/math/0701854">https://arxiv.org/abs/math/0701854</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) fit
x &lt;- rtsal(20, 1/2, 1/4)
tsal.loglik(x, 1/2, 1/4)

tsal.fit(x, method="mle.equation")
tsal.fit(x, method="mle.direct")
tsal.fit(x, method="leastsquares")



		
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
