<!DOCTYPE html><html><head><title>Help for package rrcov</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rrcov}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Appalachia'><p> Annual maximum streamflow in central Appalachia</p></a></li>
<li><a href='#biplot-methods'>
<p>Biplot for Principal Components (objects of class 'Pca')</p></a></li>
<li><a href='#bus'><p> Automatic vehicle recognition data</p></a></li>
<li><a href='#bushmiss'><p> Campbell Bushfire Data with added missing data items</p></a></li>
<li><a href='#Cars'>
<p>Consumer reports car data: dimensions</p></a></li>
<li><a href='#Cascades'><p> Annual precipitation totals for the North Cascades region</p></a></li>
<li><a href='#Cov-class'><p>Class &quot;Cov&quot; &ndash; a base class for estimates of multivariate</p>
location and scatter</a></li>
<li><a href='#CovClassic'><p>Classical Estimates of Multivariate Location and Scatter</p></a></li>
<li><a href='#CovClassic-class'><p>Class &quot;CovClassic&quot; - classical estimates of multivariate</p>
location and scatter</a></li>
<li><a href='#CovControl-class'><p>Class &quot;CovControl&quot; is a VIRTUAL base control class</p></a></li>
<li><a href='#CovControlMcd'><p> Constructor function for objects of class &quot;CovControlMcd&quot;</p></a></li>
<li><a href='#CovControlMcd-class'><p>Class 'CovControlMcd' - contains control parameters for CovMcd</p></a></li>
<li><a href='#CovControlMest'><p> Constructor function for objects of class &quot;CovControlMest&quot;</p></a></li>
<li><a href='#CovControlMest-class'><p>Class 'CovControlMest' - contains control parameters for &quot;CovMest&quot;</p></a></li>
<li><a href='#CovControlMMest'><p> Constructor function for objects of class &quot;CovControlMMest&quot;</p></a></li>
<li><a href='#CovControlMMest-class'><p>Class 'CovControlMMest' - contains control parameters for &quot;CovMMest&quot;</p></a></li>
<li><a href='#CovControlMrcd'><p> Constructor function for objects of class &quot;CovControlMrcd&quot;</p></a></li>
<li><a href='#CovControlMrcd-class'><p>Class 'CovControlMrcd' - contains control parameters for CovMrcd()</p></a></li>
<li><a href='#CovControlMve'><p> Constructor function for objects of class &quot;CovControlMve&quot;</p></a></li>
<li><a href='#CovControlMve-class'><p>Class 'CovControlMve' - contains control parameters for CovMve</p></a></li>
<li><a href='#CovControlOgk'><p> Constructor function for objects of class &quot;CovControlOgk&quot;</p></a></li>
<li><a href='#CovControlOgk-class'><p> Class 'CovControlOgk' - contains control parameters for CovOgk</p></a></li>
<li><a href='#CovControlSde'><p> Constructor function for objects of class &quot;CovControlSde&quot;</p></a></li>
<li><a href='#CovControlSde-class'><p>Class 'CovControlSde' - contains control parameters for &quot;CovSde&quot;</p></a></li>
<li><a href='#CovControlSest'><p> Constructor function for objects of class &quot;CovControlSest&quot;</p></a></li>
<li><a href='#CovControlSest-class'><p>Class 'CovControlSest' - contains control parameters for &quot;CovSest&quot;</p></a></li>
<li><a href='#CovMcd'><p> Robust Location and Scatter Estimation via MCD</p></a></li>
<li><a href='#CovMcd-class'><p> MCD Estimates of Multivariate Location and Scatter</p></a></li>
<li><a href='#covMest'><p>Constrained M-Estimates of Location and Scatter</p></a></li>
<li><a href='#CovMest'><p>Constrained M-Estimates of Location and Scatter</p></a></li>
<li><a href='#CovMest-class'><p>Constrained M-estimates of Multivariate Location and Scatter</p></a></li>
<li><a href='#CovMMest'><p> MM Estimates of Multivariate Location and Scatter</p></a></li>
<li><a href='#CovMMest-class'><p> MM Estimates of Multivariate Location and Scatter</p></a></li>
<li><a href='#CovMrcd'><p> Robust Location and Scatter Estimation via Minimum Regularized Covariance Determonant (MRCD)</p></a></li>
<li><a href='#CovMrcd-class'><p> MRCD Estimates of Multivariate Location and Scatter</p></a></li>
<li><a href='#CovMve'><p> Robust Location and Scatter Estimation via MVE</p></a></li>
<li><a href='#CovMve-class'><p> MVE Estimates of Multivariate Location and Scatter</p></a></li>
<li><a href='#CovOgk'><p> Robust Location and Scatter Estimation - Ortogonalized Gnanadesikan-Kettenring (OGK)</p></a></li>
<li><a href='#CovOgk-class'><p> OGK Estimates of Multivariate Location and Scatter</p></a></li>
<li><a href='#CovRobust'><p> Robust Location and Scatter Estimation</p></a></li>
<li><a href='#CovRobust-class'><p>Class &quot;CovRobust&quot; - virtual base class for robust</p>
estimates of multivariate location and scatter</a></li>
<li><a href='#CovSde'><p>Stahel-Donoho Estimates of Multivariate Location and Scatter</p></a></li>
<li><a href='#CovSde-class'>
<p>Stahel-Donoho Estimates of Multivariate Location and Scatter</p></a></li>
<li><a href='#CovSest'><p> S Estimates of Multivariate Location and Scatter</p></a></li>
<li><a href='#CovSest-class'><p> S Estimates of Multivariate Location and Scatter</p></a></li>
<li><a href='#diabetes'><p>Reaven and Miller diabetes data</p></a></li>
<li><a href='#fish'><p> Fish Catch Data Set</p></a></li>
<li><a href='#fruit'><p>Fruit data set</p></a></li>
<li><a href='#getCenter-methods'><p>Accessor methods to the essential slots of Cov and its subclasses</p></a></li>
<li><a href='#getEllipse'><p>Calculates the points for drawing a confidence ellipsoid</p></a></li>
<li><a href='#getLoadings-methods'><p> Accessor methods to the essential slots of Pca and its subclasses</p></a></li>
<li><a href='#hemophilia'><p> Hemophilia Data</p></a></li>
<li><a href='#ionosphere'><p>Johns Hopkins University Ionosphere database.</p></a></li>
<li><a href='#isSingular-methods'>
<p>Check if a covariance matrix (object of class 'Cov') is singular</p></a></li>
<li><a href='#Lda-class'><p>Class &quot;Lda&quot; - virtual base class for all classic and robust LDA classes</p></a></li>
<li><a href='#LdaClassic'><p> Linear Discriminant Analysis</p></a></li>
<li><a href='#LdaClassic-class'><p>Class &quot;LdaClassic&quot; - Linear Discriminant Analysis</p></a></li>
<li><a href='#LdaPP'><p> Robust Linear Discriminant Analysis by Projection Pursuit</p></a></li>
<li><a href='#LdaPP-class'><p>Class &quot;LdaPP&quot; - Robust method for Linear Discriminant Analysis by Projection-pursuit</p></a></li>
<li><a href='#LdaRobust-class'><p>Class &quot;LdaRobust&quot; is a virtual base class for all robust LDA classes</p></a></li>
<li><a href='#Linda'><p> Robust Linear Discriminant Analysis</p></a></li>
<li><a href='#Linda-class'><p>Class &quot;Linda&quot; - Robust method for LINear Discriminant Analysis</p></a></li>
<li><a href='#lmom32'><p> Hosking and Wallis Data Set, Table 3.2</p></a></li>
<li><a href='#lmom33'><p> Hosking and Wallis Data Set, Table 3.3</p></a></li>
<li><a href='#machines'><p>Computer Hardware</p></a></li>
<li><a href='#maryo'><p> Marona and Yohai Artificial Data</p></a></li>
<li><a href='#octane'><p>  Octane data</p></a></li>
<li><a href='#olitos'>
<p>Olive Oil Data</p></a></li>
<li><a href='#OsloTransect'><p> Oslo Transect Data</p></a></li>
<li><a href='#Pca-class'><p>Class &quot;Pca&quot; - virtual base class for all classic and robust PCA classes</p></a></li>
<li><a href='#pca.distances'>
<p>Compute score and orthogonal distances for Principal Components (objects of class 'Pca')</p></a></li>
<li><a href='#pca.scoreplot'>
<p>Score plot for Principal Components (objects of class 'Pca')</p></a></li>
<li><a href='#PcaClassic'><p> Principal Components Analysis</p></a></li>
<li><a href='#PcaClassic-class'><p>Class &quot;PcaClassic&quot; - Principal Components Analysis</p></a></li>
<li><a href='#PcaCov'><p> Robust PCA based on a robust covariance matrix</p></a></li>
<li><a href='#PcaCov-class'><p>Class &quot;PcaCov&quot; - Robust PCA based on a robust covariance matrix</p></a></li>
<li><a href='#PcaGrid'><p> Robust Principal Components based on Projection Pursuit (PP): GRID search Algorithm</p></a></li>
<li><a href='#PcaGrid-class'><p>Class &quot;PcaGrid&quot; - Robust PCA using PP - GRID search Algorithm</p></a></li>
<li><a href='#PcaHubert'><p> ROBPCA - ROBust method for Principal Components Analysis</p></a></li>
<li><a href='#PcaHubert-class'><p>Class &quot;PcaHubert&quot; - ROBust method for Principal Components Analysis</p></a></li>
<li><a href='#PcaLocantore'><p> Spherical Principal Components</p></a></li>
<li><a href='#PcaLocantore-class'><p>Class &quot;PcaLocantore&quot; Spherical Principal Components</p></a></li>
<li><a href='#PcaProj'><p> Robust Principal Components based on Projection Pursuit (PP): Croux and Ruiz-Gazen (2005) algorithm</p></a></li>
<li><a href='#PcaProj-class'><p>Class &quot;PcaProj&quot; - Robust PCA using PP - Croux and Ruiz-Gazen (2005) algorithm</p></a></li>
<li><a href='#PcaRobust-class'><p>Class &quot;PcaRobust&quot; is a virtual base class for all robust PCA classes</p></a></li>
<li><a href='#plot-methods'><p>Methods for Function 'plot' in Package 'rrcov'</p></a></li>
<li><a href='#pottery'><p>Archaic Greek Pottery data</p></a></li>
<li><a href='#PredictLda-class'><p>Class &quot;PredictLda&quot; - prediction of &quot;Lda&quot; objects</p></a></li>
<li><a href='#PredictQda-class'><p>Class &quot;PredictQda&quot; - prediction of &quot;Qda&quot; objects</p></a></li>
<li><a href='#Qda-class'><p>Class &quot;Qda&quot; - virtual base class for all classic and robust QDA classes</p></a></li>
<li><a href='#QdaClassic'><p> Quadratic Discriminant Analysis</p></a></li>
<li><a href='#QdaClassic-class'><p>Class &quot;QdaClassic&quot; - Quadratic Discriminant Analysis</p></a></li>
<li><a href='#QdaCov'><p> Robust Quadratic Discriminant Analysis</p></a></li>
<li><a href='#QdaCov-class'><p>Class &quot;QdaCov&quot; - Robust methods for Quadratic Discriminant Analysis</p></a></li>
<li><a href='#QdaRobust-class'><p>Class &quot;QdaRobust&quot; is a virtual base class for all robust QDA classes</p></a></li>
<li><a href='#restimate-methods'><p> Methods for Function estimate in Package 'rrcov'</p></a></li>
<li><a href='#rice'><p> Rice taste data</p></a></li>
<li><a href='#rrcov-utils'><p>Different utility functions to be used in rrcov and packages depending on rrcov</p></a></li>
<li><a href='#salmon'><p>  Salmon data</p></a></li>
<li><a href='#scorePlot-methods'>
<p>Score plot for Principal Components (objects of class 'Pca')</p></a></li>
<li><a href='#soil'>
<p>Exchangable cations in forest soil data set</p></a></li>
<li><a href='#SummaryCov-class'><p>Class &quot;SummaryCov&quot; - summary of &quot;Cov&quot; objects</p></a></li>
<li><a href='#SummaryCovRobust-class'><p>Class &quot;SummaryCovRobust&quot; - summary of &quot;CovRobust&quot; objects</p></a></li>
<li><a href='#SummaryLda-class'><p> Class &quot;SummaryLda&quot; - summary of &quot;Lda&quot; objects</p></a></li>
<li><a href='#SummaryPca-class'><p>Class &quot;SummaryPca&quot; - summary of &quot;Pca&quot; objects</p></a></li>
<li><a href='#SummaryQda-class'><p> Class &quot;SummaryQda&quot; - summary of &quot;Qda&quot; objects</p></a></li>
<li><a href='#T2.test'><p>Robust Hotelling T2 test</p></a></li>
<li><a href='#un86'><p> United Nations Data - 1986</p></a></li>
<li><a href='#wages'><p>Wages and Hours</p></a></li>
<li><a href='#Wilks.test'>
<p>Classical and Robust One-way MANOVA: Wilks Lambda</p></a></li>
<li><a href='#wolves'><p>Skull dimensions of the wolf <em>Canis lupus</em> L.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.7-5</td>
</tr>
<tr>
<td>VersionNote:</td>
<td>Released 1.7-4 on 2023-06-24 on CRAN</td>
</tr>
<tr>
<td>Title:</td>
<td>Scalable Robust Estimators with High Breakdown Point</td>
</tr>
<tr>
<td>Description:</td>
<td>Robust Location and Scatter Estimation and Robust
        Multivariate Analysis with High Breakdown Point:
        principal component analysis (Filzmoser and Todorov (2013), &lt;<a href="https://doi.org/10.1016%2Fj.ins.2012.10.017">doi:10.1016/j.ins.2012.10.017</a>&gt;),
        linear and quadratic discriminant analysis (Todorov and Pires (2007)),
        multivariate tests (Todorov and Filzmoser (2010) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2009.08.015">doi:10.1016/j.csda.2009.08.015</a>&gt;),
        outlier detection (Todorov et al. (2010) &lt;<a href="https://doi.org/10.1007%2Fs11634-010-0075-2">doi:10.1007/s11634-010-0075-2</a>&gt;).
        See also Todorov and Filzmoser (2009) &lt;urn:isbn:978-3838108148&gt;,
        Todorov and Filzmoser (2010) &lt;<a href="https://doi.org/10.18637%2Fjss.v032.i03">doi:10.18637/jss.v032.i03</a>&gt; and
        Boudt et al. (2019) &lt;<a href="https://doi.org/10.1007%2Fs11222-019-09869-x">doi:10.1007/s11222-019-09869-x</a>&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Valentin Todorov &lt;valentin.todorov@chello.at&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), robustbase (&ge; 0.92.1), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, stats4, mvtnorm, lattice, pcaPP</td>
</tr>
<tr>
<td>Suggests:</td>
<td>grid, MASS</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/valentint/rrcov">https://github.com/valentint/rrcov</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/valentint/rrcov/issues">https://github.com/valentint/rrcov/issues</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-30 21:34:46 UTC; valen</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Valentin Todorov <a href="https://orcid.org/0000-0003-4215-0245"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 22:10:02 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
</table>
<hr>
<h2 id='Appalachia'> Annual maximum streamflow in central Appalachia</h2><span id='topic+Appalachia'></span>

<h3>Description</h3>

<p>The data on annual maximum streamflow at 104 gaging stations
in the central Appalachia region of the United States contains
the sample L-moments ratios (L-CV, L-skewness and L-kurtosis) as
used by Hosking and Wallis (1997) to illustrate regional
freqency analysis (RFA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Appalachia)</code></pre>


<h3>Format</h3>

<p>A data frame with 104 observations on the following 3 variables:
</p>

<dl>
<dt><code>L-CV</code></dt><dd><p>L-coefficient of variation</p>
</dd>
<dt><code>L-skewness</code></dt><dd><p>L-coefficient of skewness</p>
</dd>
<dt><code>L-kurtosis</code></dt><dd><p>L-coefficient of kurtosis</p>
</dd>
</dl>



<h3>Details</h3>

<p>The sample L-moment ratios (L-CV, L-skewness and L-kurtosis) of a
site are regarded as a point in three dimensional space.
</p>


<h3>Source</h3>

<p>Hosking, J. R. M. and J. R. Wallis (1997), <em>Regional Frequency Analysis: An
Approach Based on L-moments.</em> Cambridge University Press, p.175&ndash;185
</p>


<h3>References</h3>

<p>Neykov, N.M., Neytchev, P.N., Van Gelder, P.H.A.J.M. and Todorov V. (2007),
Robust detection of discordant sites in regional frequency analysis,
<em>Water Resources Research</em>, 43, W06417, doi:10.1029/2006WR005322
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(Appalachia)

    # plot a matrix of scatterplots
    pairs(Appalachia,
          main="Appalachia data set",
          pch=21,
          bg=c("red", "green3", "blue"))

    mcd&lt;-CovMcd(Appalachia)
    mcd
    plot(mcd, which="dist", class=TRUE)
    plot(mcd, which="dd", class=TRUE)

    ##  identify the discordant sites using robust distances and compare 
    ##  to the classical ones
    mcd &lt;- CovMcd(Appalachia)
    rd &lt;- sqrt(getDistance(mcd))
    ccov &lt;- CovClassic(Appalachia)
    cd &lt;- sqrt(getDistance(ccov))
    r.out &lt;- which(rd &gt; sqrt(qchisq(0.975,3)))
    c.out &lt;- which(cd &gt; sqrt(qchisq(0.975,3)))
    cat("Robust: ", length(r.out), " outliers: ", r.out,"\n")
    cat("Classical: ", length(c.out), " outliers: ", c.out,"\n")
</code></pre>

<hr>
<h2 id='biplot-methods'>
Biplot for Principal Components (objects of class 'Pca')
</h2><span id='topic+biplot'></span><span id='topic+biplot-methods'></span><span id='topic+biplot+2CANY-method'></span><span id='topic+biplot+2CPca-method'></span>

<h3>Description</h3>

<p>Produces a biplot from an object (derived from)  <code><a href="#topic+Pca-class">Pca-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S4 method for signature 'Pca'
biplot(x, choices=1L:2L, scale=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biplot-methods_+3A_x">x</code></td>
<td>
<p>an object of class (derived from) <code>"Pca"</code>.</p>
</td></tr>
<tr><td><code id="biplot-methods_+3A_choices">choices</code></td>
<td>
<p>length 2 vector specifying the components to plot. Only the default is a biplot in the strict sense.</p>
</td></tr>
<tr><td><code id="biplot-methods_+3A_scale">scale</code></td>
<td>

<p>The variables are scaled by <code>lambda ^ scale</code> and the
observations are scaled by <code>lambda ^ (1-scale)</code> where
<code>lambda</code> are the singular values as computed by
the Principal Components function. Normally <code>0 &lt;= scale &lt;= 1</code>, and a warning
will be issued if the specified <code>scale</code> is outside this range.
</p>
</td></tr>
<tr><td><code id="biplot-methods_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to the internal graphical functions.</p>
</td></tr>
</table>


<h3>Side Effects</h3>

<p>a plot is produced on the current graphics device.
</p>


<h3>Methods</h3>


<dl>
<dt>biplot</dt><dd><p><code>signature(x = Pca)</code>: Plot a biplot, i.e. represent both
the observations and variables of a matrix of multivariate data on the same
plot. See also <code><a href="stats.html#topic+biplot.princomp">biplot.princomp</a></code>.</p>
</dd>
</dl>


<h3>References</h3>

<p>Gabriel, K. R. (1971).
The biplot graphical display of matrices with applications to
principal component analysis.
<em>Biometrika</em>, <b>58</b>, 453&ndash;467.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pca-class">Pca-class</a></code>,
<code><a href="#topic+PcaClassic">PcaClassic</a></code>,
<code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)
biplot(PcaClassic(USArrests, k=2))
</code></pre>

<hr>
<h2 id='bus'> Automatic vehicle recognition data</h2><span id='topic+bus'></span>

<h3>Description</h3>

<p>The data set bus (Hettich and Bay, 1999) corresponds to a study in 
automatic vehicle recognition (see Maronna et al. 2006, page 213, Example 6.3)). 
This data set from the 
Turing Institute, Glasgow, Scotland, contains measures of shape 
features extracted from vehicle silhouettes. The images were acquired 
by a camera looking downward at the model vehicle from a fixed angle 
of elevation. Each of the 218 rows corresponds to a view of a bus 
silhouette, and contains 18 attributes of the image. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bus)</code></pre>


<h3>Format</h3>

<p>A data frame with 218 observations on the following 18 variables: 
</p>

<dl>
<dt><code>V1</code></dt><dd><p>compactness</p>
</dd>
<dt><code>V2</code></dt><dd><p>circularity</p>
</dd>
<dt><code>V3</code></dt><dd><p>distance circularity</p>
</dd>
<dt><code>V4</code></dt><dd><p>radius ratio</p>
</dd>
<dt><code>V5</code></dt><dd><p>principal axis aspect ratio</p>
</dd>
<dt><code>V6</code></dt><dd><p>maximum length aspect ratio</p>
</dd>
<dt><code>V7</code></dt><dd><p>scatter ratio</p>
</dd>
<dt><code>V8</code></dt><dd><p>elongatedness</p>
</dd>
<dt><code>V9</code></dt><dd><p>principal axis rectangularity</p>
</dd>
<dt><code>V10</code></dt><dd><p>maximum length rectangularity</p>
</dd>
<dt><code>V11</code></dt><dd><p>scaled variance along major axis</p>
</dd>
<dt><code>V12</code></dt><dd><p>scaled variance along minor axis</p>
</dd>
<dt><code>V13</code></dt><dd><p>scaled radius of gyration</p>
</dd>
<dt><code>V14</code></dt><dd><p>skewness about major axis</p>
</dd>
<dt><code>V15</code></dt><dd><p>skewness about minor axis</p>
</dd>
<dt><code>V16</code></dt><dd><p>kurtosis about minor axis</p>
</dd>
<dt><code>V17</code></dt><dd><p>kurtosis about major axis</p>
</dd>
<dt><code>V18</code></dt><dd><p>hollows ratio</p>
</dd>
</dl>



<h3>Source</h3>

<p>Hettich, S. and Bay, S.D. (1999), The UCI KDD Archive,
Irvine, CA:University of California, Department of Information and Computer Science,
'http://kdd.ics.uci.edu'
</p>


<h3>References</h3>

<p>Maronna, R., Martin, D. and Yohai, V., (2006). Robust Statistics: Theory and Methods. Wiley, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Reproduce Table 6.3 from Maronna et al. (2006), page 213
    data(bus)
    bus &lt;- as.matrix(bus)
    
    ## calculate MADN for each variable
    xmad &lt;- apply(bus, 2, mad)      
    cat("\nMin, Max of MADN: ", min(xmad), max(xmad), "\n")


    ## MADN vary between 0 (for variable 9) and 34. Therefore exclude 
    ##  variable 9 and divide the remaining variables by their MADNs.
    bus1 &lt;- bus[, -9]
    madbus &lt;- apply(bus1, 2, mad)
    bus2 &lt;- sweep(bus1, 2, madbus, "/", check.margin = FALSE)

    ## Compute classical and robust PCA (Spherical/Locantore, Hubert, MCD and OGK)    
    pca  &lt;- PcaClassic(bus2)
    rpca &lt;- PcaLocantore(bus2)
    pcaHubert &lt;- PcaHubert(bus2, k=17, kmax=17, mcd=FALSE)
    pcamcd &lt;- PcaCov(bus2, cov.control=CovControlMcd())
    pcaogk &lt;- PcaCov(bus2, cov.control=CovControlOgk())

    ev    &lt;- getEigenvalues(pca)
    evrob &lt;- getEigenvalues(rpca)
    evhub &lt;- getEigenvalues(pcaHubert)
    evmcd &lt;- getEigenvalues(pcamcd)
    evogk &lt;- getEigenvalues(pcaogk)

    uvar    &lt;- matrix(nrow=6, ncol=6)
    svar    &lt;- sum(ev)
    svarrob &lt;- sum(evrob)
    svarhub &lt;- sum(evhub)
    svarmcd &lt;- sum(evmcd)
    svarogk &lt;- sum(evogk)
    for(i in 1:6){
        uvar[i,1] &lt;- i
        uvar[i,2] &lt;- round((svar - sum(ev[1:i]))/svar, 3)
        uvar[i,3] &lt;- round((svarrob - sum(evrob[1:i]))/svarrob, 3)
        uvar[i,4] &lt;- round((svarhub - sum(evhub[1:i]))/svarhub, 3)
        uvar[i,5] &lt;- round((svarmcd - sum(evmcd[1:i]))/svarmcd, 3)
        uvar[i,6] &lt;- round((svarogk - sum(evogk[1:i]))/svarogk, 3)
    }
    uvar &lt;- as.data.frame(uvar)
    names(uvar) &lt;- c("q", "Classical","Spherical", "Hubert", "MCD", "OGK")
    cat("\nBus data: proportion of unexplained variability for q components\n")
    print(uvar)
 
    ## Reproduce Table 6.4 from Maronna et al. (2006), page 214
    ##
    ## Compute classical and robust PCA extracting only the first 3 components
    ## and take the squared orthogonal distances to the 3-dimensional hyperplane
    ##
    pca3 &lt;- PcaClassic(bus2, k=3)               # classical
    rpca3 &lt;- PcaLocantore(bus2, k=3)            # spherical (Locantore, 1999)
    hpca3 &lt;- PcaHubert(bus2, k=3)               # Hubert
    dist &lt;- pca3@od^2
    rdist &lt;- rpca3@od^2
    hdist &lt;- hpca3@od^2

    ## calculate the quantiles of the distances to the 3-dimensional hyperplane
    qclass  &lt;- round(quantile(dist, probs = seq(0, 1, 0.1)[-c(1,11)]), 1)
    qspc &lt;- round(quantile(rdist, probs = seq(0, 1, 0.1)[-c(1,11)]), 1)
    qhubert &lt;- round(quantile(hdist, probs = seq(0, 1, 0.1)[-c(1,11)]), 1)
    qq &lt;- cbind(rbind(qclass, qspc, qhubert), round(c(max(dist), max(rdist), max(hdist)), 0))
    colnames(qq)[10] &lt;- "Max"
    rownames(qq) &lt;- c("Classical", "Spherical", "Hubert")
    cat("\nBus data: quantiles of distances to hiperplane\n")
    print(qq)

    ## 
    ## Reproduce Fig 6.1 from Maronna et al. (2006), page 214
    ## 
    cat("\nBus data: Q-Q plot of logs of distances to hyperplane (k=3) 
    \nfrom classical and robust estimates. The line is the identity diagonal\n")
    plot(sort(log(dist)), sort(log(rdist)), xlab="classical", ylab="robust")
    lines(sort(log(dist)), sort(log(dist)))
   
    
</code></pre>

<hr>
<h2 id='bushmiss'> Campbell Bushfire Data with added missing data items</h2><span id='topic+bushmiss'></span>

<h3>Description</h3>

<p>This data set is based on the bushfire data set which was used by 
Campbell (1984) to locate bushfire scars - see  <code><a href="robustbase.html#topic+bushfire">bushfire</a></code>
in package <code>robustbase</code>. The original dataset contains satelite 
measurements on five frequency bands, corresponding to each of 38 pixels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bushmiss)</code></pre>


<h3>Format</h3>

<p>A data frame with 190 observations on 6 variables.
</p>
<p>The original data set consists of 38 observations in 5 variables. 
Based on it four new data sets are created in which some of the data 
items are replaced by missing values with a simple &quot;missing completely 
at random &quot; mechanism. For this purpose independent Bernoulli trials 
are realized for each data item with a probability of success 0.1, 0.2, 0.3, 0.4,
where success means that the corresponding item is set to missing.  The obtained five 
data sets, including the original one (each with probability of a data 
item to be missing equal to 0, 0.1, 0.2, 0.3 and 0.4 which is reflected 
in the new variable <code>MPROB</code>) are merged. (See also Beguin and Hulliger (2004).)

</p>


<h3>Source</h3>

<p>Maronna, R.A. and Yohai, V.J. (1995)
The Behavoiur of the Stahel-Donoho Robust Multivariate Estimator.
<em>Journal of the American Statistical Association</em> <b>90</b>, 330&ndash;341.
</p>
<p>Beguin, C. and Hulliger, B. (2004) Multivariate outlier detection in incomplete
survey data: the epidemic algorithm and transformed rank correlations.
<em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> <b>127</b>, 2, 275&ndash;294.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The following code will result in exactly the same output
##  as the one obtained from the original data set
data(bushmiss)
bf &lt;- bushmiss[bushmiss$MPROB==0,1:5]
plot(bf)
covMcd(bf)


## Not run: 
##  This is the code with which the missing data were created:
##
##  Creates a data set with missing values (for testing purposes)
##  from a complete data set 'x'. The probability of
##  each item being missing is 'pr' (Bernoulli trials).
##
getmiss &lt;- function(x, pr=0.1)
{
    n &lt;- nrow(x)
    p &lt;- ncol(x)
    done &lt;- FALSE
    iter &lt;- 0
    while(iter &lt;= 50){
        bt &lt;- rbinom(n*p, 1, pr)
        btmat &lt;- matrix(bt, nrow=n)
        btmiss &lt;- ifelse(btmat==1, NA, 0)
        y &lt;- x+btmiss
        if(length(which(rowSums(nanmap(y)) == p)) == 0)
            return (y)
        iter &lt;- iter + 1
    }
    y
}

## End(Not run)

</code></pre>

<hr>
<h2 id='Cars'>
Consumer reports car data: dimensions
</h2><span id='topic+Cars'></span>

<h3>Description</h3>

<p>A data frame containing 11 variables with different dimensions of 111 cars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Cars)</code></pre>


<h3>Format</h3>

<p>A data frame with 111 observations on the following 11 variables.
</p>

<dl>
<dt><code>length</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>wheelbase</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>width</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>height</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>front.hd</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>rear.hd</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>front.leg</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>rear.seating</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>front.shoulder</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>rear.shoulder</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>luggage</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Consumer reports. (April 1990). http://backissues.com/issue/Consumer-Reports-April-1990, pp. 235&ndash;288.
</p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1992). Statistical models in S. Cole, Pacific Grove, CA:
Wadsworth and Brooks, pp. 46&ndash;47.
</p>
<p>M. Hubert, P. J. Rousseeuw, K. Vanden Branden (2005), ROBPCA: A new approach to robust 
principal components analysis, <em>Technometrics</em>, 
<b>47</b>, 64&ndash;79.    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(Cars)

## Plot a pairwise scaterplot matrix
    pairs(Cars[,1:6])

    mcd &lt;- CovMcd(Cars[,1:6])    
    plot(mcd, which="pairs")
    
## Start with robust PCA
    pca &lt;- PcaHubert(Cars, k=ncol(Cars), kmax=ncol(Cars))
    pca

## Compare with the classical PCA
    prcomp(Cars)

## or  
    PcaClassic(Cars, k=ncol(Cars), kmax=ncol(Cars))
    
## If you want to print the scores too, use
    print(pca, print.x=TRUE)

## Using the formula interface
    PcaHubert(~., data=Cars, k=ncol(Cars), kmax=ncol(Cars))

## To plot the results:

    plot(pca)                    # distance plot
    pca2 &lt;- PcaHubert(Cars, k=4)  
    plot(pca2)                   # PCA diagnostic plot (or outlier map)
    
## Use the standard plots available for prcomp and princomp
    screeplot(pca)    # it is interesting with all variables    
    biplot(pca)       # for biplot we need more than one PCs
    
## Restore the covraiance matrix     
    py &lt;- PcaHubert(Cars, k=ncol(Cars), kmax=ncol(Cars))
    cov.1 &lt;- py@loadings %*% diag(py@eigenvalues) %*% t(py@loadings)
    cov.1      

</code></pre>

<hr>
<h2 id='Cascades'> Annual precipitation totals for the North Cascades region</h2><span id='topic+Cascades'></span>

<h3>Description</h3>

<p>The data on annual precipitation totals for the North Cascades region
contains the sample L-moments ratios (L-CV, L-skewness and L-kurtosis)
for 19 sites as used by Hosking and Wallis (1997), page 53, Table 3.4,
to illustrate screening tools for regional freqency analysis (RFA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Cascades)</code></pre>


<h3>Format</h3>

<p>A data frame with 19 observations on the following 3 variables.
</p>

<dl>
<dt><code>L-CV</code></dt><dd><p>L-coefficient of variation</p>
</dd>
<dt><code>L-skewness</code></dt><dd><p>L-coefficient of skewness</p>
</dd>
<dt><code>L-kurtosis</code></dt><dd><p>L-coefficient of kurtosis</p>
</dd>
</dl>



<h3>Details</h3>

<p>The sample L-moment ratios (L-CV, L-skewness and L-kurtosis) of a
site are regarded as a point in three dimensional space.
</p>


<h3>Source</h3>

<p>Hosking, J. R. M. and J. R. Wallis (1997), <em>Regional Frequency Analysis: An
Approach Based on L-moments.</em> Cambridge University Press, p. 52&ndash;53
</p>


<h3>References</h3>

<p>Neykov, N.M., Neytchev, P.N., Van Gelder, P.H.A.J.M. and Todorov V. (2007),
Robust detection of discordant sites in regional frequency analysis,
<em>Water Resources Research</em>, 43, W06417, doi:10.1029/2006WR005322
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(Cascades)

    # plot a matrix of scatterplots
    pairs(Cascades,
          main="Cascades data set",
          pch=21,
          bg=c("red", "green3", "blue"))

    mcd&lt;-CovMcd(Cascades)
    mcd
    plot(mcd, which="dist", class=TRUE)
    plot(mcd, which="dd", class=TRUE)

    ##  identify the discordant sites using robust distances and compare 
    ##  to the classical ones
    rd &lt;- sqrt(getDistance(mcd))
    ccov &lt;- CovClassic(Cascades)
    cd &lt;- sqrt(getDistance(ccov))
    r.out &lt;- which(rd &gt; sqrt(qchisq(0.975,3)))
    c.out &lt;- which(cd &gt; sqrt(qchisq(0.975,3)))
    cat("Robust: ", length(r.out), " outliers: ", r.out,"\n")
    cat("Classical: ", length(c.out), " outliers: ", c.out,"\n")
</code></pre>

<hr>
<h2 id='Cov-class'>Class &quot;Cov&quot; &ndash; a base class for estimates of multivariate
location and scatter</h2><span id='topic+Cov-class'></span><span id='topic+getCenter-method'></span><span id='topic+getCenter+2CCov-method'></span><span id='topic+getCov+2CCov-method'></span><span id='topic+getCorr+2CCov-method'></span><span id='topic+getData+2CCov-method'></span><span id='topic+getDistance+2CCov-method'></span><span id='topic+getEvals+2CCov-method'></span><span id='topic+getDet+2CCov-method'></span><span id='topic+getShape+2CCov-method'></span><span id='topic+getFlag+2CCov-method'></span><span id='topic+isClassic+2Cmethod'></span><span id='topic+isClassic+2CCov-method'></span><span id='topic+plot'></span><span id='topic+plot+2CCov+2Cmissing-method'></span><span id='topic+show+2CCov-method'></span><span id='topic+summary+2CCov-method'></span><span id='topic+Uvector-class'></span><span id='topic+Ulist-class'></span><span id='topic+Utable-class'></span><span id='topic+Umatrix-class'></span><span id='topic+Ufunction-class'></span>

<h3>Description</h3>

<p>The class <code>Cov</code> represents an estimate of the
multivariate location and scatter of a data set. The objects of class <code>Cov</code>
contain the classical estimates and serve as base for deriving other
estimates, i.e. different types of robust estimates.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Cov", ...)</code>,
but the usual way of creating <code>Cov</code> objects is a call to the function
<code>Cov</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"language"</code> </p>
</dd>
<dt><code>cov</code>:</dt><dd><p>covariance matrix</p>
</dd>
<dt><code>center</code>:</dt><dd><p>location</p>
</dd>
<dt><code>n.obs</code>:</dt><dd><p>number of observations used for the computation of the estimates</p>
</dd>
<dt><code>mah</code>:</dt><dd><p>mahalanobis distances</p>
</dd>
<dt><code>det</code>:</dt><dd><p>determinant</p>
</dd>
<dt><code>flag</code>:</dt><dd><p>flags (FALSE if suspected an outlier)</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a character string describing the method used to
compute the estimate: &quot;Classic&quot;</p>
</dd>
<dt><code>singularity</code>:</dt><dd><p>a list with singularity information for the
covariance matrix (or <code>NULL</code> of not singular)</p>
</dd>
<dt><code>X</code>:</dt><dd><p>data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getCenter</dt><dd><p><code>signature(obj = "Cov")</code>: location vector </p>
</dd>
<dt>getCov</dt><dd><p><code>signature(obj = "Cov")</code>: covariance matrix </p>
</dd>
<dt>getCorr</dt><dd><p><code>signature(obj = "Cov")</code>: correlation matrix </p>
</dd>
<dt>getData</dt><dd><p><code>signature(obj = "Cov")</code>: data frame </p>
</dd>
<dt>getDistance</dt><dd><p><code>signature(obj = "Cov")</code>: distances </p>
</dd>
<dt>getEvals</dt><dd><p><code>signature(obj = "Cov")</code>: Computes and returns
the eigenvalues of the covariance matrix </p>
</dd>
<dt>getDet</dt><dd><p><code>signature(obj = "Cov")</code>: Computes and returns 
the determinant of the covariance matrix (or 0 if the covariance matrix is singular) </p>
</dd>
<dt>getShape</dt><dd><p><code>signature(obj = "Cov")</code>: Computes and returns 
the shape matrix corresponding to the covariance matrix (i.e. the covariance matrix scaled to have determinant =1) </p>
</dd>
<dt>getFlag</dt><dd><p><code>signature(obj = "Cov")</code>: Flags observations as outliers if the corresponding mahalanobis distance is larger then <code>qchisq(prob, p)</code> where <code>prob</code> defaults to 0.975. </p>
</dd>
<dt>isClassic</dt><dd><p><code>signature(obj = "Cov")</code>: returns TRUE by default. If necessary, the robust
classes will override </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "Cov")</code>: plot the object </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Cov")</code>: display the object </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "Cov")</code>: calculate summary information </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Cov")
</code></pre>

<hr>
<h2 id='CovClassic'>Classical Estimates of Multivariate Location and Scatter</h2><span id='topic+CovClassic'></span><span id='topic+Cov'></span>

<h3>Description</h3>

<p>Computes the classical estimates of multivariate location and scatter.
Returns an S4 class <code>CovClassic</code> with the estimated <code>center</code>,
<code>cov</code>, Mahalanobis distances and weights based on these distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    CovClassic(x, unbiased=TRUE)
    Cov(x, unbiased=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovClassic_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. As usual, rows are observations and
columns are variables. </p>
</td></tr>
<tr><td><code id="CovClassic_+3A_unbiased">unbiased</code></td>
<td>
<p> whether to return the unbiased estimate of
the covariance matrix. Default is  <code>unbiased = TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"CovClassic"</code>.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Cov-class">Cov-class</a></code>, <code><a href="#topic+CovClassic-class">CovClassic-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])
cv &lt;- CovClassic(hbk.x)
cv
summary(cv)
plot(cv)
</code></pre>

<hr>
<h2 id='CovClassic-class'>Class &quot;CovClassic&quot; - classical estimates of multivariate
location and scatter </h2><span id='topic+CovClassic-class'></span>

<h3>Description</h3>

<p> The class <code>CovClassic</code> represents an estimate of the
multivariate location and scatter of a data set. The objects of class <code>CovClassic</code>
contain the classical estimates.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovClassic", ...)</code>,
but the usual way of creating <code>CovClassic</code> objects is a call to the function
<code>CovClassic</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"language"</code> </p>
</dd>
<dt><code>cov</code>:</dt><dd><p>covariance matrix</p>
</dd>
<dt><code>center</code>:</dt><dd><p>location</p>
</dd>
<dt><code>n.obs</code>:</dt><dd><p>number of observations used for the computation of the estimates</p>
</dd>
<dt><code>mah</code>:</dt><dd><p>mahalanobis distances</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a character string describing the method used to
compute the estimate: &quot;Classic&quot;</p>
</dd>
<dt><code>singularity</code>:</dt><dd><p>a list with singularity information for the
ocvariance matrix (or <code>NULL</code> of not singular)</p>
</dd>
<dt><code>X</code>:</dt><dd><p>data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getCenter</dt><dd><p><code>signature(obj = "CovClassic")</code>: location vector </p>
</dd>
<dt>getCov</dt><dd><p><code>signature(obj = "CovClassic")</code>: covariance matrix </p>
</dd>
<dt>getCorr</dt><dd><p><code>signature(obj = "CovClassic")</code>: correlation matrix </p>
</dd>
<dt>getData</dt><dd><p><code>signature(obj = "CovClassic")</code>: data frame </p>
</dd>
<dt>getDistance</dt><dd><p><code>signature(obj = "CovClassic")</code>: distances </p>
</dd>
<dt>getEvals</dt><dd><p><code>signature(obj = "CovClassic")</code>: Computes and returns
the eigenvalues of the covariance matrix </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "CovClassic")</code>: plot the object </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "CovClassic")</code>: display the object </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "CovClassic")</code>: calculate summary information </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])
cv &lt;- CovClassic(hbk.x)
cv
summary(cv)
plot(cv)
</code></pre>

<hr>
<h2 id='CovControl-class'>Class &quot;CovControl&quot; is a VIRTUAL base control class </h2><span id='topic+CovControl-class'></span>

<h3>Description</h3>

<p>  The class &quot;CovControl&quot; is a VIRTUAL base control class
for the derived classes representing the control parameters
for the different robust methods </p>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovControl-class_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>
<tr><td><code id="CovControl-class_+3A_tolsolve">tolSolve</code></td>
<td>
<p>numeric tolerance to be used for inversion
(<code><a href="base.html#topic+solve">solve</a></code>) of the covariance matrix in
<code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code>.</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;CovControl&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>

<hr>
<h2 id='CovControlMcd'> Constructor function for objects of class &quot;CovControlMcd&quot;</h2><span id='topic+CovControlMcd'></span>

<h3>Description</h3>

<p>This function will create a control object <code>CovControlMcd</code>
containing the control parameters for <code>CovMcd</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovControlMcd(alpha = 0.5, nsamp = 500, scalefn=NULL, maxcsteps=200, 
seed = NULL, trace= FALSE, use.correction = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovControlMcd_+3A_alpha">alpha</code></td>
<td>
<p>numeric parameter controlling the size of the subsets
over which the determinant is minimized, i.e., <code>alpha*n</code>
observations are used for computing the determinant.  Allowed values
are between 0.5 and 1 and the default is 0.5.</p>
</td></tr>
<tr><td><code id="CovControlMcd_+3A_nsamp">nsamp</code></td>
<td>
<p> number of subsets used for initial estimates or <code>"best"</code>,
<code>"exact"</code> or <code>"deterministic"</code>.  Default is <code>nsamp = 500</code>.  
For <code>nsamp="best"</code> exhaustive enumeration is done, as long as the
number of trials does not exceed 5000. For <code>"exact"</code>,
exhaustive enumeration will be attempted however many samples are
needed.  In this case a warning message will be displayed saying
that the computation can take a very long time.
</p>
<p>For <code>"deterministic"</code>, the <em>deterministic</em> MCD is computed; as
proposed by Hubert et al. (2012) it starts from the <code class="reqn">h</code> most
central observations of <em>six</em> (deterministic) estimators.   
</p>
</td></tr>
<tr><td><code id="CovControlMcd_+3A_scalefn">scalefn</code></td>
<td>
<p><code><a href="base.html#topic+function">function</a></code> to compute a robust scale
estimate or character string specifying a rule determining such a
function, see <code><a href="robustbase.html#topic+rrcov.control">rrcov.control</a></code>.</p>
</td></tr>
<tr><td><code id="CovControlMcd_+3A_maxcsteps">maxcsteps</code></td>
<td>
<p>maximal number of concentration steps in the
deterministic MCD; should not be reached.</p>
</td></tr>
<tr><td><code id="CovControlMcd_+3A_seed">seed</code></td>
<td>
<p>starting value for random generator. Default is <code>seed = NULL</code></p>
</td></tr>
<tr><td><code id="CovControlMcd_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>
<tr><td><code id="CovControlMcd_+3A_use.correction">use.correction</code></td>
<td>
<p> whether to use finite sample correction factors.
Default is <code>use.correction=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>CovControlMcd</code> object
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlMcd", alpha=0.75)
    ctrl2 &lt;- CovControlMcd(alpha=0.75)

    data(hbk)
    CovMcd(hbk, control=ctrl1)
</code></pre>

<hr>
<h2 id='CovControlMcd-class'>Class 'CovControlMcd' - contains control parameters for CovMcd </h2><span id='topic+CovControlMcd-class'></span><span id='topic+restimate+2CCovControlMcd-method'></span>

<h3>Description</h3>

<p>This class extends the <code>CovControl</code> class
and contains the control parameters for <code>"CovMcd"</code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovControlMcd", ...)</code>
or by calling the constructor-function <code>CovControlMcd</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alpha</code>:</dt><dd><p>numeric parameter controlling the size of the subsets
over which the determinant is minimized, i.e., <code>alpha*n</code>
observations are used for computing the determinant.  Allowed values
are between 0.5 and 1 and the default is 0.5.</p>
</dd>
<dt>nsamp</dt><dd><p> number of subsets used for initial estimates or <code>"best"</code>,
<code>"exact"</code> or <code>"deterministic"</code>.  Default is <code>nsamp = 500</code>.  
For <code>nsamp="best"</code> exhaustive enumeration is done, as long as the
number of trials does not exceed 5000. For <code>"exact"</code>,
exhaustive enumeration will be attempted however many samples are
needed.  In this case a warning message will be displayed saying
that the computation can take a very long time.
</p>
<p>For <code>"deterministic"</code>, the <em>deterministic</em> MCD is computed; as
proposed by Hubert et al. (2012) it starts from the <code class="reqn">h</code> most
central observations of <em>six</em> (deterministic) estimators.   
</p>
</dd>
<dt>scalefn</dt><dd><p><code><a href="base.html#topic+function">function</a></code> to compute a robust scale
estimate or character string specifying a rule determining such a
function.</p>
</dd>
<dt>maxcsteps</dt><dd><p>maximal number of concentration steps in the
deterministic MCD; should not be reached.</p>
</dd>
<dt><code>seed</code>:</dt><dd><p>starting value for random generator. Default is <code>seed = NULL</code></p>
</dd>
<dt><code>use.correction</code>:</dt><dd><p> whether to use finite sample correction factors.
Default is <code>use.correction=TRUE</code>.
</p>
</dd>
<dt><code>trace</code>, <code>tolSolve</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovControl-class">CovControl</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovControl-class">CovControl</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>restimate</dt><dd><p><code>signature(obj = "CovControlMcd")</code>: the generic
function <code>restimate</code> allows the different methods for robust estimation to be
used polymorphically -  this function will call <code>CovMcd</code> passing it the control
object and will return the obtained <code>CovRobust</code> object</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlMcd", alpha=0.75)
    ctrl2 &lt;- CovControlMcd(alpha=0.75)

    data(hbk)
    CovMcd(hbk, control=ctrl1)
</code></pre>

<hr>
<h2 id='CovControlMest'> Constructor function for objects of class &quot;CovControlMest&quot; </h2><span id='topic+CovControlMest'></span>

<h3>Description</h3>

<p>This function will create a control object <code>CovControlMest</code>
containing the control parameters for <code>CovMest</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovControlMest(r = 0.45, arp = 0.05, eps = 0.001, maxiter = 120)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovControlMest_+3A_r">r</code></td>
<td>
<p>a numeric value specifying the required
breakdown point.  Allowed values are between
<code>(n - p)/(2 * n)</code> and 1 and the default is 0.45</p>
</td></tr>
<tr><td><code id="CovControlMest_+3A_arp">arp</code></td>
<td>
<p>a numeric value specifying the asympthotic
rejection point, i.e. the fraction of points receiving zero
weight (see Rocke (1996)).  Default is <code>0.05</code> </p>
</td></tr>
<tr><td><code id="CovControlMest_+3A_eps">eps</code></td>
<td>
<p>a numeric value specifying the
relative precision of the solution of the M-estimate.
Defaults to <code>1e-3</code></p>
</td></tr>
<tr><td><code id="CovControlMest_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed
in the computation of the M-estimate. Defaults to 120 </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>CovControlMest</code> object
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlMest", r=0.4)
    ctrl2 &lt;- CovControlMest(r=0.4)

    data(hbk)
    CovMest(hbk, control=ctrl1)
</code></pre>

<hr>
<h2 id='CovControlMest-class'>Class 'CovControlMest' - contains control parameters for &quot;CovMest&quot;</h2><span id='topic+CovControlMest-class'></span>

<h3>Description</h3>

<p>This class extends the <code>CovControl</code> class
and contains the control parameters for CovMest</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovControlMest", ...)</code>
or by calling the constructor-function <code>CovControlMest</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>r</code>:</dt><dd><p>a numeric value specifying the required
breakdown point.  Allowed values are between
<code>(n - p)/(2 * n)</code> and 1 and the default is 0.45</p>
</dd>
<dt><code>arp</code>:</dt><dd><p>a numeric value specifying the asympthotic
rejection point, i.e. the fraction of points receiving zero
weight (see Rocke (1996)).  Default is <code>0.05</code> </p>
</dd>
<dt><code>eps</code>:</dt><dd><p>a numeric value specifying the
relative precision of the solution of the M-estimate.
Defaults to <code>1e-3</code></p>
</dd>
<dt><code>maxiter</code>:</dt><dd><p>maximum number of iterations allowed
in the computation of the M-estimate. Defaults to 120 </p>
</dd>
<dt><code>trace</code>, <code>tolSolve</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovControl-class">CovControl</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovControl-class">CovControl</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>restimate</dt><dd><p><code>signature(obj = "CovControlMest")</code>: the generic
function <code>restimate</code> allowes the different methods for robust estimation to be
used polymorphically -  this function will call <code>CovMest</code> passing it the control
object and will return the obtained <code>CovRobust</code> object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlMest", r=0.4)
    ctrl2 &lt;- CovControlMest(r=0.4)

    data(hbk)
    CovMest(hbk, control=ctrl1)

</code></pre>

<hr>
<h2 id='CovControlMMest'> Constructor function for objects of class &quot;CovControlMMest&quot; </h2><span id='topic+CovControlMMest'></span>

<h3>Description</h3>

<p>This function will create a control object <code>CovControlMMest</code>
containing the control parameters for <code>CovMMest</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    CovControlMMest(bdp = 0.5, eff=0.95, maxiter = 50, sest=CovControlSest(),
        trace = FALSE, tolSolve = 1e-7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovControlMMest_+3A_bdp">bdp</code></td>
<td>
<p> a numeric value specifying the required
breakdown point.  Allowed values are between
0.5 and 1 and the default is 0.5
</p>
</td></tr>
<tr><td><code id="CovControlMMest_+3A_eff">eff</code></td>
<td>
<p>a numeric value specifying the required efficiency
for the MM estimates.  Default is <code>eff=0.95</code>.
</p>
</td></tr>
<tr><td><code id="CovControlMMest_+3A_sest">sest</code></td>
<td>
<p>an <code>CovControlSest</code> object containing control parameters for the initial S-estimate.
</p>
</td></tr>
<tr><td><code id="CovControlMMest_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed
in the computation of the MM-estimate.
Defaults to 150.
</p>
</td></tr>
<tr><td><code id="CovControlMMest_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code>.</p>
</td></tr>
<tr><td><code id="CovControlMMest_+3A_tolsolve">tolSolve</code></td>
<td>
<p>numeric tolerance to be used as 
a convergence tolerance for the MM-iteration.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>CovControlSest</code> object.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlMMest", bdp=0.25)
    ctrl2 &lt;- CovControlMMest(bdp=0.25)

    data(hbk)
    CovMMest(hbk, control=ctrl1)
    
    
    
</code></pre>

<hr>
<h2 id='CovControlMMest-class'>Class 'CovControlMMest' - contains control parameters for &quot;CovMMest&quot;</h2><span id='topic+CovControlMMest-class'></span><span id='topic+restimate+2CCovControlMMest-method'></span>

<h3>Description</h3>

<p>This class extends the <code>CovControl</code> class
and contains the control parameters for CovMMest
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovControlMMest", ...)</code>
or by calling the constructor-function <code>CovControlMMest</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>bdp</dt><dd><p>a numeric value specifying the required
breakdown point.  Allowed values are between
0.5 and 1 and the default is <code>bdp=0.5</code>.
</p>
</dd>
<dt>eff</dt><dd><p>a numeric value specifying the required efficiency
for the MM estimates.  Default is <code>eff=0.95</code>.
</p>
</dd>
<dt>sest</dt><dd><p>an <code>CovControlSest</code> object containing control parameters for the initial S-estimate.
</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations allowed
in the computation of the MM-estimate.
Default is <code>maxiter=50</code>.
</p>
</dd>
<dt><code>trace</code>, <code>tolSolve</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovControl-class">CovControl</a>"</code> class. <code>tolSolve</code> is used as 
a convergence tolerance for the MM-iteration.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovControl-class">CovControl</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>restimate</dt><dd><p><code>signature(obj = "CovControlMMest")</code>: the generic
function <code>restimate</code> allowes the different methods for robust estimation to be
used polymorphically -  this function will call <code>CovMMest</code> passing it the control
object and will return the obtained <code>CovRobust</code> object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlMMest", bdp=0.25)
    ctrl2 &lt;- CovControlMMest(bdp=0.25)

    data(hbk)
    CovMMest(hbk, control=ctrl1)

</code></pre>

<hr>
<h2 id='CovControlMrcd'> Constructor function for objects of class &quot;CovControlMrcd&quot;</h2><span id='topic+CovControlMrcd'></span>

<h3>Description</h3>

<p>This function will create a control object <code>CovControlMrcd</code>
containing the control parameters for <code>CovMrcd</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovControlMrcd(alpha = 0.5, h=NULL, maxcsteps=200, rho=NULL, 
    target=c("identity", "equicorrelation"), maxcond=50,
    trace= FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovControlMrcd_+3A_alpha">alpha</code></td>
<td>
<p>numeric parameter controlling the size of the subsets
over which the determinant is minimized, i.e., <code>alpha*n</code>
observations are used for computing the determinant.  Allowed values
are between 0.5 and 1 and the default is 0.5.</p>
</td></tr>
<tr><td><code id="CovControlMrcd_+3A_h">h</code></td>
<td>
<p>the size of the subset (can be between ceiling(n/2) and n). 
Normally NULL and then it <code>h</code> will be calculated as 
<code>h=ceiling(alpha*n)</code>. If <code>h</code> is provided, <code>alpha</code> 
will be calculated as <code>alpha=h/n</code>.</p>
</td></tr>
<tr><td><code id="CovControlMrcd_+3A_maxcsteps">maxcsteps</code></td>
<td>
<p>maximal number of concentration steps in the
deterministic MCD; should not be reached.</p>
</td></tr>
<tr><td><code id="CovControlMrcd_+3A_rho">rho</code></td>
<td>
<p>regularization parameter. Normally NULL and will be estimated from the data.</p>
</td></tr>
<tr><td><code id="CovControlMrcd_+3A_target">target</code></td>
<td>
<p>structure of the robust positive definite target matrix: 
a) &quot;identity&quot;: target matrix is diagonal matrix with robustly estimated 
univariate scales on the diagonal or b) &quot;equicorrelation&quot;: non-diagonal 
target matrix that incorporates an equicorrelation structure 
(see (17) in paper). Default is <code>target="identity"</code></p>
</td></tr>
<tr><td><code id="CovControlMrcd_+3A_maxcond">maxcond</code></td>
<td>
<p>maximum condition number allowed 
(see step 3.4 in algorithm 1). Default is <code>maxcond=50</code></p>
</td></tr>
<tr><td><code id="CovControlMrcd_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>CovControlMrcd</code> object
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlMrcd", alpha=0.75)
    ctrl2 &lt;- CovControlMrcd(alpha=0.75)

    data(hbk)
    CovMrcd(hbk, control=ctrl1)
</code></pre>

<hr>
<h2 id='CovControlMrcd-class'>Class 'CovControlMrcd' - contains control parameters for CovMrcd()</h2><span id='topic+CovControlMrcd-class'></span><span id='topic+restimate+2CCovControlMrcd-method'></span>

<h3>Description</h3>

<p>This class extends the <code>CovControl</code> class
and contains the control parameters for <code>"CovMrcd"</code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovControlMrcd", ...)</code>
or by calling the constructor-function <code>CovControlMrcd</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alpha</code>:</dt><dd><p>numeric parameter controlling the size of the subsets
over which the determinant is minimized, i.e., <code>alpha*n</code>
observations are used for computing the determinant.  Allowed values
are between 0.5 and 1 and the default is 0.5.</p>
</dd>
<dt>h</dt><dd><p>the size of the subset (can be between ceiling(n/2) and n). 
Normally NULL and then it <code>h</code> will be calculated as 
<code>h=ceiling(alpha*n)</code>. If <code>h</code> is provided, <code>alpha</code> 
will be calculated as <code>alpha=h/n</code>.</p>
</dd>
<dt>maxcsteps</dt><dd><p>maximal number of concentration steps in the 
deterministic MCD; should not be reached.</p>
</dd>
<dt>rho</dt><dd><p>regularization parameter. Normally NULL and will be estimated from the data.</p>
</dd>
<dt>target</dt><dd><p>structure of the robust positive definite target matrix: 
a) &quot;identity&quot;: target matrix is diagonal matrix with robustly estimated 
univariate scales on the diagonal or b) &quot;equicorrelation&quot;: non-diagonal 
target matrix that incorporates an equicorrelation structure 
(see (17) in paper).</p>
</dd>
<dt>maxcond</dt><dd><p>maximum condition number allowed (see step 3.4 in algorithm 1).</p>
</dd>
<dt><code>trace</code>, <code>tolSolve</code>:</dt><dd><p>from the <code>"<a href="#topic+CovControl-class">CovControl</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovControl-class">CovControl</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>restimate</dt><dd><p><code>signature(obj = "CovControlMrcd")</code>: the generic
function <code>restimate</code> allows the different methods for robust estimation to be
used polymorphically -  this function will call <code>CovMrcd</code> passing it the control
object and will return the obtained <code>CovRobust</code> object</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code>"<a href="#topic+CovControlMcd-class">CovControlMcd</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlMrcd", alpha=0.75)
    ctrl2 &lt;- CovControlMrcd(alpha=0.75)

    data(hbk)
    CovMrcd(hbk, control=ctrl1)
</code></pre>

<hr>
<h2 id='CovControlMve'> Constructor function for objects of class &quot;CovControlMve&quot;</h2><span id='topic+CovControlMve'></span>

<h3>Description</h3>

<p>This function will create a control object <code>CovControlMve</code>
containing the control parameters for <code>CovMve</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovControlMve(alpha = 0.5, nsamp = 500, seed = NULL, trace= FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovControlMve_+3A_alpha">alpha</code></td>
<td>
<p>numeric parameter controlling the size of the subsets
over which the determinant is minimized, i.e., <code>alpha*n</code>
observations are used for computing the determinant.  Allowed values
are between 0.5 and 1 and the default is 0.5.</p>
</td></tr>
<tr><td><code id="CovControlMve_+3A_nsamp">nsamp</code></td>
<td>
<p> number of subsets used for initial estimates or <code>"best"</code>
or <code>"exact"</code>.  Default is <code>nsamp = 500</code>.  For
<code>nsamp="best"</code> exhaustive enumeration is done, as long as the
number of trials does not exceed 5000. For <code>"exact"</code>,
exhaustive enumeration will be attempted however many samples are
needed.  In this case a warning message will be displayed saying
that the computation can take a very long time.</p>
</td></tr>
<tr><td><code id="CovControlMve_+3A_seed">seed</code></td>
<td>
<p>starting value for random generator. Default is <code>seed = NULL</code></p>
</td></tr>
<tr><td><code id="CovControlMve_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>CovControlMve</code> object
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlMve", alpha=0.75)
    ctrl2 &lt;- CovControlMve(alpha=0.75)

    data(hbk)
    CovMve(hbk, control=ctrl1)
</code></pre>

<hr>
<h2 id='CovControlMve-class'>Class 'CovControlMve' - contains control parameters for CovMve </h2><span id='topic+CovControlMve-class'></span><span id='topic+restimate+2CCovControlMve-method'></span>

<h3>Description</h3>

<p>This class extends the <code>CovControl</code> class
and contains the control parameters for <code>"CovMve"</code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovControlMve", ...)</code>
or by calling the constructor-function <code>CovControlMve</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alpha</code>:</dt><dd><p>numeric parameter controlling the size of the subsets
over which the determinant is minimized, i.e., <code>alpha*n</code>
observations are used for computing the determinant.  Allowed values
are between 0.5 and 1 and the default is 0.5.</p>
</dd>
<dt><code>nsamp</code>:</dt><dd><p> number of subsets used for initial estimates or <code>"best"</code>
or <code>"exact"</code>.  Default is <code>nsamp = 500</code>.  For
<code>nsamp="best"</code> exhaustive enumeration is done, as long as the
number of trials does not exceed 5000. For <code>"exact"</code>,
exhaustive enumeration will be attempted however many samples are
needed.  In this case a warning message will be displayed saying
that the computation can take a very long time.</p>
</dd>
<dt><code>seed</code>:</dt><dd><p>starting value for random generator. Default is <code>seed = NULL</code></p>
</dd>
<dt><code>trace</code>, <code>tolSolve</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovControl-class">CovControl</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovControl-class">CovControl</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>restimate</dt><dd><p><code>signature(obj = "CovControlMve")</code>: the generic
function <code>restimate</code> allowes the different methods for robust estimation to be
used polymorphically -  this function will call <code>CovMve</code> passing it the control
object and will return the obtained <code>CovRobust</code> object</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlMve", alpha=0.75)
    ctrl2 &lt;- CovControlMve(alpha=0.75)

    data(hbk)
    CovMve(hbk, control=ctrl1)
</code></pre>

<hr>
<h2 id='CovControlOgk'> Constructor function for objects of class &quot;CovControlOgk&quot; </h2><span id='topic+CovControlOgk'></span>

<h3>Description</h3>

<p>This function will create a control object <code>CovControlOgk</code>
containing the control parameters for <code>CovOgk</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovControlOgk(niter = 2, beta = 0.9, mrob = NULL, 
vrob = .vrobGK, smrob = "scaleTau2", svrob = "gk")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovControlOgk_+3A_niter">niter</code></td>
<td>
<p> number of iterations, usually 1 or 2 since iterations
beyond the second do not lead to improvement. </p>
</td></tr>
<tr><td><code id="CovControlOgk_+3A_beta">beta</code></td>
<td>
<p> coverage parameter for the final reweighted estimate </p>
</td></tr>
<tr><td><code id="CovControlOgk_+3A_mrob">mrob</code></td>
<td>
<p> function for computing the robust univariate location
and dispersion - one could use the <code>tau scale</code> defined in
Yohai and Zamar (1998), see <code><a href="robustbase.html#topic+scaleTau2">scaleTau2</a></code>.
The C version of this function defined by <code>smrob</code> is the default.
</p>
</td></tr>
<tr><td><code id="CovControlOgk_+3A_vrob">vrob</code></td>
<td>
<p> function for computing robust estimate
of covariance between two random vectors - one could use the function
proposed by Gnanadesikan and Kettenring (1972), see
<code><a href="robustbase.html#topic+covOGK">covOGK</a>()</code>. The C version of this function defined
by <code>svrob</code> is the default.
</p>
</td></tr>
<tr><td><code id="CovControlOgk_+3A_smrob">smrob</code></td>
<td>
<p> a string indicating the name of the function for computing
the robust univariate location and dispersion - defaults to
<code>scaleTau2</code>  - the scale tau function defined in Yohai and Zamar (1998)
</p>
</td></tr>
<tr><td><code id="CovControlOgk_+3A_svrob">svrob</code></td>
<td>
<p> a string indicating the name of the function for computing
robust estimate of covariance between two random vectors - defaults <code>gk</code>,
the one proposed by Gnanadesikan and Kettenring (1972)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the user does not specify a scale and covariance function to be used in
the computations or specifies one by using the arguments <code>smrob</code> and <code>svrob</code>
(i.e. the names of the functions as strings), a native code written in C will be called which
is by far faster than the R version.
</p>
<p>If the arguments <code>mrob</code> and <code>vrob</code> are not NULL, the specified functions
will be used via the pure R implementation of the algorithm. This could be quite slow.
</p>


<h3>Value</h3>

<p>A <code>CovControlOgk</code> object
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Maronna, R.A. and Zamar, R.H. (2002)
Robust estimates of location and dispersion of high-dimensional datasets;
<em>Technometrics</em> <b>44</b>(4), 307&ndash;317.
</p>
<p>Yohai, R.A. and Zamar, R.H. (1998)
High breakdown point estimates of regression by means of the minimization of efficient scale
<em>JASA</em> <b>86</b>, 403&ndash;413.
</p>
<p>Gnanadesikan, R. and John R. Kettenring (1972)
Robust estimates, residuals, and outlier detection with multiresponse data.
<em>Biometrics</em> <b>28</b>, 81&ndash;124.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlOgk", beta=0.95)
    ctrl2 &lt;- CovControlOgk(beta=0.95)

    data(hbk)
    CovOgk(hbk, control=ctrl1)
</code></pre>

<hr>
<h2 id='CovControlOgk-class'> Class 'CovControlOgk' - contains control parameters for CovOgk </h2><span id='topic+CovControlOgk-class'></span><span id='topic+restimate+2CCovControlOgk-method'></span>

<h3>Description</h3>

<p>This class extends the <code>CovControl</code> class
and contains the control parameters for <code>"CovOgk"</code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovControlOgk", ...)</code>
or by calling the constructor-function <code>CovControlOgk</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>niter</dt><dd><p> number of iterations, usually 1 or 2 since iterations
beyond the second do not lead to improvement. </p>
</dd>
<dt>beta</dt><dd><p> coverage parameter for the final reweighted estimate </p>
</dd>
<dt>mrob</dt><dd><p> function for computing the robust univariate location
and dispersion - defaults to the <code>tau scale</code> defined in
Yohai and Zamar (1998) </p>
</dd>
<dt>vrob</dt><dd><p> function for computing robust estimate
of covariance between two random vectors - defaults the one proposed by
Gnanadesikan and Kettenring (1972) </p>
</dd>
<dt>smrob</dt><dd><p>A string indicating the name of the function for computing
the robust univariate location and dispersion - defaults to <code>scaleTau2</code> -
the scale 'tau' function defined in Yohai and Zamar (1998)</p>
</dd>
<dt>svrob</dt><dd><p>A string indicating the name of the function for computing
robust estimate of covariance between two random vectors -
defaults to <code>gk</code>, the one proposed by Gnanadesikan and Kettenring (1972).
</p>
</dd>
<dt><code>trace</code>, <code>tolSolve</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovControl-class">CovControl</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovControl-class">CovControl</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>restimate</dt><dd><p><code>signature(obj = "CovControlOgk")</code>: the generic
function <code>restimate</code> allowes the different methods for robust estimation to be
used polymorphically -  this function will call <code>CovOgk</code> passing it the control
object and will return the obtained <code>CovRobust</code> object</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlOgk", beta=0.95)
    ctrl2 &lt;- CovControlOgk(beta=0.95)

    data(hbk)
    CovOgk(hbk, control=ctrl1)
</code></pre>

<hr>
<h2 id='CovControlSde'> Constructor function for objects of class &quot;CovControlSde&quot; </h2><span id='topic+CovControlSde'></span>

<h3>Description</h3>

<p>This function will create a control object <code>CovControlSde</code>
containing the control parameters for <code>CovSde</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovControlSde(nsamp = 0, maxres = 0, tune = 0.95, eps = 0.5, prob = 0.99,
    seed = NULL, trace = FALSE, tolSolve = 1e-14)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovControlSde_+3A_nsamp">nsamp</code></td>
<td>
<p>a positive integer giving the number of resamples required;
<code>nsamp</code> may not be reached if too many of the <code>p</code>-subsamples,
chosen out of the observed vectors, are in a hyperplane.
If <code>nsamp = 0</code> all possible subsamples are taken.
If <code>nsamp</code> is omitted, it is calculated to provide a breakdown point
of <code>eps</code> with probability <code>prob</code>.</p>
</td></tr>
<tr><td><code id="CovControlSde_+3A_maxres">maxres</code></td>
<td>
<p>a positive integer specifying the maximum number of
resamples to be performed including those that are discarded due to linearly
dependent subsamples.  If <code>maxres</code> is omitted it will be set to 2 times <code>nsamp</code>.</p>
</td></tr>
<tr><td><code id="CovControlSde_+3A_tune">tune</code></td>
<td>
<p>a numeric value between 0 and 1 giving the fraction of the data to receive non-zero weight.
Defaults to <code>0.95</code>. </p>
</td></tr>
<tr><td><code id="CovControlSde_+3A_prob">prob</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the probability of high breakdown point;
used to compute <code>nsamp</code> when <code>nsamp</code> is omitted. Defaults to <code>0.99</code>. </p>
</td></tr>
<tr><td><code id="CovControlSde_+3A_eps">eps</code></td>
<td>
<p>a numeric value between 0 and 0.5 specifying the breakdown point;
used to compute <code>nsamp</code> when <code>nresamp</code> is omitted. Defaults to <code>0.5</code>. </p>
</td></tr>
<tr><td><code id="CovControlSde_+3A_seed">seed</code></td>
<td>
<p>starting value for random generator. Default is <code>seed = NULL</code>.</p>
</td></tr>
<tr><td><code id="CovControlSde_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code>.  </p>
</td></tr>
<tr><td><code id="CovControlSde_+3A_tolsolve">tolSolve</code></td>
<td>
<p>numeric tolerance to be used for inversion
(<code><a href="base.html#topic+solve">solve</a></code>) of the covariance matrix in
<code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>CovControlSde</code> object.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlSde", nsamp=2000)
    ctrl2 &lt;- CovControlSde(nsamp=2000)

    data(hbk)
    CovSde(hbk, control=ctrl1)
</code></pre>

<hr>
<h2 id='CovControlSde-class'>Class 'CovControlSde' - contains control parameters for &quot;CovSde&quot;</h2><span id='topic+CovControlSde-class'></span><span id='topic+restimate+2CCovControlSde-method'></span>

<h3>Description</h3>

<p>This class extends the <code>CovControl</code> class
and contains the control parameters for CovSde
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovControlSde", ...)</code>
or by calling the constructor-function <code>CovControlSde</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nsamp</code></dt><dd><p>a positive integer giving the number of resamples required</p>
</dd>
<dt><code>maxres</code></dt><dd><p>a positive integer specifying the maximum number of
resamples to be performed including those that are discarded due to linearly
dependent subsamples.</p>
</dd>
<dt><code>tune</code></dt><dd><p>a numeric value between 0 and 1 giving the fraction of
the data to receive non-zero weight. Default is <code>tune = 0.95</code>.</p>
</dd>
<dt><code>prob</code></dt><dd><p>a numeric value between 0 and 1 specifying
the probability of high breakdown point; used to compute
<code>nsamp</code> when <code>nsamp</code> is omitted. Default is <code>prob = 0.99</code>.</p>
</dd>
<dt><code>eps</code></dt><dd><p>a numeric value between 0 and 0.5 specifying the breakdown point;
used to compute <code>nsamp</code> when <code>nresamp</code> is omitted.
Default is <code>eps = 0.5</code>.</p>
</dd>
<dt>seed</dt><dd><p>starting value for random generator. Default is <code>seed = NULL</code>.</p>
</dd>
<dt><code>trace</code>, <code>tolSolve</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovControl-class">CovControl</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovControl-class">CovControl</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>restimate</dt><dd><p><code>signature(obj = "CovControlSde")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlSde", nsamp=2000)
    ctrl2 &lt;- CovControlSde(nsamp=2000)

    data(hbk)
    CovSde(hbk, control=ctrl1)
</code></pre>

<hr>
<h2 id='CovControlSest'> Constructor function for objects of class &quot;CovControlSest&quot; </h2><span id='topic+CovControlSest'></span>

<h3>Description</h3>

<p>This function will create a control object <code>CovControlSest</code>
containing the control parameters for <code>CovSest</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    CovControlSest(bdp = 0.5, arp = 0.1, eps = 1e-5, maxiter = 120,
        nsamp = 500, seed = NULL, trace = FALSE, tolSolve = 1e-14, method= "sfast")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovControlSest_+3A_bdp">bdp</code></td>
<td>
<p> a numeric value specifying the required
breakdown point.  Allowed values are between
<code>(n - p)/(2 * n)</code> and 1 and the default is 0.45
</p>
</td></tr>
<tr><td><code id="CovControlSest_+3A_arp">arp</code></td>
<td>
<p>a numeric value specifying the asympthotic
rejection point (for the Rocke type S estimates),
i.e. the fraction of points receiving zero
weight (see Rocke (1996)).  Default is <code>0.1</code>
</p>
</td></tr>
<tr><td><code id="CovControlSest_+3A_eps">eps</code></td>
<td>
<p>a numeric value specifying the
relative precision of the solution of the S-estimate (bisquare and Rocke type).
Defaults to <code>1e-5</code>.
</p>
</td></tr>
<tr><td><code id="CovControlSest_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed
in the computation of the S-estimate (bisquare and Rocke type).
Defaults to 120.
</p>
</td></tr>
<tr><td><code id="CovControlSest_+3A_nsamp">nsamp</code></td>
<td>
<p>the number of random subsets considered. Default is <code>nsamp = 500</code>.</p>
</td></tr>
<tr><td><code id="CovControlSest_+3A_seed">seed</code></td>
<td>
<p>starting value for random generator. Default is <code>seed = NULL</code>.</p>
</td></tr>
<tr><td><code id="CovControlSest_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code>.</p>
</td></tr>
<tr><td><code id="CovControlSest_+3A_tolsolve">tolSolve</code></td>
<td>
<p>numeric tolerance to be used for inversion
(<code><a href="base.html#topic+solve">solve</a></code>) of the covariance matrix in
<code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code>.
</p>
</td></tr>
<tr><td><code id="CovControlSest_+3A_method">method</code></td>
<td>
<p> Which algorithm to use: 'sfast'=FAST-S or 'surreal'=SURREAL </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>CovControlSest</code> object.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlSest", bdp=0.4)
    ctrl2 &lt;- CovControlSest(bdp=0.4)

    data(hbk)
    CovSest(hbk, control=ctrl1)
</code></pre>

<hr>
<h2 id='CovControlSest-class'>Class 'CovControlSest' - contains control parameters for &quot;CovSest&quot;</h2><span id='topic+CovControlSest-class'></span><span id='topic+restimate+2CCovControlSest-method'></span>

<h3>Description</h3>

<p>This class extends the <code>CovControl</code> class
and contains the control parameters for CovSest
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovControlSest", ...)</code>
or by calling the constructor-function <code>CovControlSest</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>bdp</dt><dd><p>a numeric value specifying the required
breakdown point.  Allowed values are between
<code>(n - p)/(2 * n)</code> and 1 and the default is <code>bdp=0.45</code>.
</p>
</dd>
<dt>arp</dt><dd><p>a numeric value specifying the asympthotic
rejection point (for the Rocke type S estimates),
i.e. the fraction of points receiving zero
weight (see Rocke (1996)).  Default is <code>arp=0.1</code>.
</p>
</dd>
<dt>eps</dt><dd><p>a numeric value specifying the
relative precision of the solution of the S-estimate
(bisquare and Rocke type). Default is to <code>eps=1e-5</code>.
</p>
</dd>
<dt>maxiter</dt><dd><p>maximum number of iterations allowed
in the computation of the S-estimate (bisquare and Rocke type).
Default is <code>maxiter=120</code>.
</p>
</dd>
<dt>nsamp</dt><dd><p>the number of random subsets considered.
Default is <code>nsamp = 500</code>.</p>
</dd>
<dt>seed</dt><dd><p>starting value for random generator. Default is <code>seed = NULL</code>.</p>
</dd>
<dt>method</dt><dd><p>Which algorithm to use: 'sfast'=FAST-S, 'surreal'=Ruppert's SURREAL algorithm,
'bisquare'=Bisquare S-estimation with HBDP start or 'rocke' for Rocke type S-estimates</p>
</dd>
<dt><code>trace</code>, <code>tolSolve</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovControl-class">CovControl</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovControl-class">CovControl</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>restimate</dt><dd><p><code>signature(obj = "CovControlSest")</code>: the generic
function <code>restimate</code> allowes the different methods for robust estimation to be
used polymorphically -  this function will call <code>CovSest</code> passing it the control
object and will return the obtained <code>CovRobust</code> object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## the following two statements are equivalent
    ctrl1 &lt;- new("CovControlSest", bdp=0.4)
    ctrl2 &lt;- CovControlSest(bdp=0.4)

    data(hbk)
    CovSest(hbk, control=ctrl1)

</code></pre>

<hr>
<h2 id='CovMcd'> Robust Location and Scatter Estimation via MCD </h2><span id='topic+CovMcd'></span>

<h3>Description</h3>

<p>Computes a robust multivariate location and scatter estimate with a high
breakdown point, using the &lsquo;Fast MCD&rsquo; (Minimum Covariance
Determinant) estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovMcd(x,
       raw.only=FALSE, alpha=control@alpha, nsamp=control@nsamp,
       scalefn=control@scalefn, maxcsteps=control@maxcsteps,
       initHsets=NULL, save.hsets=FALSE,
       seed=control@seed, trace=control@trace,
       use.correction=control@use.correction,
       control=CovControlMcd(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovMcd_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. </p>
</td></tr>
<tr><td><code id="CovMcd_+3A_raw.only">raw.only</code></td>
<td>
<p>should only the &ldquo;raw&rdquo; estimate be returned.</p>
</td></tr>
<tr><td><code id="CovMcd_+3A_alpha">alpha</code></td>
<td>
<p>numeric parameter controlling the size of the subsets
over which the determinant is minimized, i.e., <code>alpha*n</code>
observations are used for computing the determinant.  Allowed values
are between 0.5 and 1 and the default is 0.5.</p>
</td></tr>
<tr><td><code id="CovMcd_+3A_nsamp">nsamp</code></td>
<td>
<p> number of subsets used for initial estimates or <code>"best"</code>,
<code>"exact"</code> or <code>"deterministic"</code>.  Default is <code>nsamp = 500</code>.
For <code>nsamp="best"</code> exhaustive enumeration is done, as long as the
number of trials does not exceed 5000. For <code>"exact"</code>,
exhaustive enumeration will be attempted however many samples are
needed.  In this case a warning message will be displayed saying
that the computation can take a very long time.
</p>
<p>For <code>"deterministic"</code>, the <em>deterministic</em> MCD is computed; as
proposed by Hubert et al. (2012) it starts from the <code class="reqn">h</code> most
central observations of <em>six</em> (deterministic) estimators.
</p>
</td></tr>
<tr><td><code id="CovMcd_+3A_scalefn">scalefn</code></td>
<td>
<p><code><a href="base.html#topic+function">function</a></code> to compute a robust scale
estimate or character string specifying a rule determining such a
function, see <code><a href="robustbase.html#topic+rrcov.control">rrcov.control</a></code>.</p>
</td></tr>
<tr><td><code id="CovMcd_+3A_maxcsteps">maxcsteps</code></td>
<td>
<p>maximal number of concentration steps in the
deterministic MCD; should not be reached.</p>
</td></tr>
<tr><td><code id="CovMcd_+3A_inithsets">initHsets</code></td>
<td>
<p>NULL or a <code class="reqn">K x h</code> integer matrix of initial
subsets of observations of size <code class="reqn">h</code> (specified by the indices in
<code>1:n</code>).</p>
</td></tr>
<tr><td><code id="CovMcd_+3A_save.hsets">save.hsets</code></td>
<td>
<p>(for deterministic MCD) logical indicating if the
initial subsets should be returned as <code>initHsets</code>.</p>
</td></tr>
<tr><td><code id="CovMcd_+3A_seed">seed</code></td>
<td>
<p>starting value for random generator. Default is <code>seed = NULL</code></p>
</td></tr>
<tr><td><code id="CovMcd_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>
<tr><td><code id="CovMcd_+3A_use.correction">use.correction</code></td>
<td>
<p> whether to use finite sample correction factors.
Default is <code>use.correction=TRUE</code></p>
</td></tr>
<tr><td><code id="CovMcd_+3A_control">control</code></td>
<td>
<p> a control object (S4) of class <code><a href="#topic+CovControlMcd-class">CovControlMcd-class</a></code>
containing estimation options - same as these provided in the function
specification. If the control object is supplied, the parameters from it
will be used. If parameters are passed also in the invocation statement, they will
override the corresponding elements of the control object.</p>
</td></tr>
<tr><td><code id="CovMcd_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to <span class="pkg">robustbase</span>'s
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the minimum covariance determinant estimator
of location and scatter and returns an S4 object of class
<code><a href="#topic+CovMcd-class">CovMcd-class</a></code> containing the estimates.
The implementation of the function is similar to the existing <span class="rlang"><b>R</b></span> function
<code><a href="robustbase.html#topic+covMcd">covMcd</a>()</code> which returns an S3 object.
The MCD method looks for the <code class="reqn">h (&gt; n/2)</code>
observations (out of <code class="reqn">n</code>) whose classical
covariance matrix has the lowest possible determinant.  The raw MCD
estimate of location is then the average of these <code class="reqn">h</code> points,
whereas the raw MCD estimate of scatter is their covariance matrix,
multiplied by a consistency factor and a finite sample correction factor
(to make it consistent at the normal model and unbiased at small samples).
Both rescaling factors are returned also in the vector <code>raw.cnp2</code>
of length 2. Based on these raw MCD estimates, a reweighting step is performed
which increases the finite-sample efficiency considerably - see Pison et al. (2002).
The rescaling factors for the reweighted estimates are returned in the
vector <code>cnp2</code> of length 2. Details for the computation of the finite
sample correction factors can be found in Pison et al. (2002).
The finite sample corrections can be suppressed by setting <code>use.correction=FALSE</code>.
The implementation in rrcov uses the Fast MCD algorithm of Rousseeuw and Van Driessen (1999)
to approximate the minimum covariance determinant estimator.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+CovMcd-class">CovMcd-class</a></code> which is a subclass of the
virtual class <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>P. J. Rousseeuw and A. M. Leroy (1987)
<em>Robust Regression and Outlier Detection.</em> Wiley.
</p>
<p>P. J. Rousseeuw and K. van Driessen (1999)
A fast algorithm for the minimum covariance determinant estimator.
<em>Technometrics</em> <b>41</b>, 212&ndash;223.
</p>
<p>M. Hubert, P. Rousseeuw and T. Verdonck (2012) A deterministic algorithm
for robust location and scatter.
<em>Journal of Computational and Graphical Statistics</em> <b>21</b>(3), 618&ndash;637.
</p>
<p>Pison, G., Van Aelst, S., and Willems, G. (2002),
Small Sample Corrections for LTS and MCD,
<em>Metrika</em>, <b>55</b>, 111-123.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+cov.rob">cov.rob</a></code> from package <span class="pkg">MASS</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])
CovMcd(hbk.x)
cD &lt;- CovMcd(hbk.x, nsamp = "deterministic")
summary(cD)

## the following three statements are equivalent
c1 &lt;- CovMcd(hbk.x, alpha = 0.75)
c2 &lt;- CovMcd(hbk.x, control = CovControlMcd(alpha = 0.75))
## direct specification overrides control one:
c3 &lt;- CovMcd(hbk.x, alpha = 0.75,
             control = CovControlMcd(alpha=0.95))
c1
</code></pre>

<hr>
<h2 id='CovMcd-class'> MCD Estimates of Multivariate Location and Scatter </h2><span id='topic+CovMcd-class'></span>

<h3>Description</h3>

<p>This class, derived from the virtual class <code>"CovRobust"</code> accomodates
MCD Estimates of multivariate location and scatter computed by the
&lsquo;Fast MCD&rsquo; algorithm.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovMcd", ...)</code>,
but the usual way of creating <code>CovMcd</code> objects is a call to the function
<code>CovMcd</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alpha</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the size of the
subsets over which the determinant is minimized (the default is (n+p+1)/2) </p>
</dd>
<dt><code>quan</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the number of
observations on which the MCD is based. If <code>quan</code> equals
<code>n.obs</code>, the MCD is the classical covariance matrix. </p>
</dd>
<dt><code>best</code>:</dt><dd><p>Object of class <code>"Uvector"</code> - the best subset
found and used for computing the raw estimates. The size of <code>best</code>
is equal to <code>quan</code> </p>
</dd>
<dt><code>raw.cov</code>:</dt><dd><p>Object of class <code>"matrix"</code> the raw
(not reweighted) estimate of location </p>
</dd>
<dt><code>raw.center</code>:</dt><dd><p>Object of class <code>"vector"</code> - the raw
(not reweighted) estimate of scatter</p>
</dd>
<dt><code>raw.mah</code>:</dt><dd><p>Object of class <code>"Uvector"</code> - mahalanobis
distances of the observations based on the raw estimate of the
location and scatter </p>
</dd>
<dt><code>raw.wt</code>:</dt><dd><p>Object of class <code>"Uvector"</code> - weights of
the observations based on the raw estimate of the location and scatter </p>
</dd>
<dt><code>raw.cnp2</code>:</dt><dd><p>Object of class <code>"numeric"</code> - a vector of length
two containing the consistency correction factor and the finite sample
correction factor of the raw estimate of the covariance matrix </p>
</dd>
<dt><code>cnp2</code>:</dt><dd><p>Object of class <code>"numeric"</code> - a vector of length two
containing the consistency correction factor and the finite sample
correction factor of the final estimate of the covariance matrix.
</p>
</dd>
<dt><code>iter</code>, <code>crit</code>, <code>wt</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code> class.
</p>
</dd>
<dt><code>call</code>, <code>cov</code>, <code>center</code>,
<code>n.obs</code>, <code>mah</code>, <code>method</code>,
<code>singularity</code>, <code>X</code>:</dt><dd><p>from the <code>"<a href="#topic+Cov-class">Cov</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Cov-class">Cov</a>"</code>, by class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class <code>"CovMcd"</code> in the signature.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CovMcd">CovMcd</a></code>, <code><a href="#topic+Cov-class">Cov-class</a></code>, <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CovMcd")
</code></pre>

<hr>
<h2 id='covMest'>Constrained M-Estimates of Location and Scatter</h2><span id='topic+covMest'></span>

<h3>Description</h3>

<p>Computes constrained M-Estimates of multivariate location and scatter
based on the translated biweight function (&lsquo;t-biweight&rsquo;) using
a High breakdown point initial estimate. The default initial estimate
is the Minimum Volume Ellipsoid computed
with <code><a href="#topic+CovMve">CovMve</a></code>. The raw (not reweighted) estimates are taken
and the covariance matrix is standardized to determinant 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covMest(x, cor=FALSE, r = 0.45, arp = 0.05, eps=1e-3,
    maxiter=120, control, t0, S0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covMest_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. </p>
</td></tr>
<tr><td><code id="covMest_+3A_cor">cor</code></td>
<td>
<p>should the returned result include a correlation matrix?
Default is <code>cor = FALSE</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="covMest_+3A_r">r</code></td>
<td>
<p> required breakdown point.  Allowed values are between
<code>(n - p)/(2 * n)</code> and 1 and the default is 0.45</p>
</td></tr>
<tr><td><code id="covMest_+3A_arp">arp</code></td>
<td>
<p> asympthotic rejection point, i.e. the fraction of points
receiving zero weight (see Rocke (1996)).  Default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="covMest_+3A_eps">eps</code></td>
<td>
<p> a numeric value specifying the relative precision of the solution of
the M-estimate. Defaults to <code>1e-3</code></p>
</td></tr>
<tr><td><code id="covMest_+3A_maxiter">maxiter</code></td>
<td>
<p> maximum number of iterations allowed in the computation of
the M-estimate. Defaults to 120</p>
</td></tr>
<tr><td><code id="covMest_+3A_control">control</code></td>
<td>
<p> a list with estimation options - same as these provided in the
fucntion specification. If the control object is supplied, the parameters from it
will be used. If parameters are passed also in the invocation statement, they will
override the corresponding elements of the control object.</p>
</td></tr>
<tr><td><code id="covMest_+3A_t0">t0</code></td>
<td>
<p> optional initial high breakdown point estimates of the location.
If not supplied MVE will be used. </p>
</td></tr>
<tr><td><code id="covMest_+3A_s0">S0</code></td>
<td>
<p> optional initial high breakdown point estimates of the
scatter. If not supplied MVE will be used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rocke (1996) has shown that the S-estimates of multivariate location and scatter
in high dimensions can be sensitive to outliers even if the breakdown point
is set to be near 0.5. To mitigate this problem he proposed to utilize
the translated  biweight (or t-biweight) method with a
standardization step consisting of equating the median of <code>rho(d)</code>
with the median under normality. This is then not an S-estimate, but is
instead a constrained M-estimate. In order to make the smooth estimators
to work, a reasonable starting point is necessary, which will lead reliably to a
good solution of the estimator. In <code>covMest</code> the MVE computed by
<code><a href="#topic+CovMve">CovMve</a></code> is used, but the user has the possibility to give her own
initial estimates.
</p>


<h3>Value</h3>

<p>An object of class <code>"mest"</code> which is basically a <code><a href="base.html#topic+list">list</a></code> with
the following components. This class is &quot;derived&quot; from <code>"mcd"</code> so that
the same generic functions -  <code>print</code>,  <code>plot</code>,  <code>summary</code> - can
be used.
NOTE: this is going to change - in one of the next revisions <code>covMest</code>
will return an S4 class <code>"mest"</code> which is derived (i.e. <code>contains</code>)
form class <code>"cov"</code>.
</p>
<table>
<tr><td><code>center</code></td>
<td>
<p>the final estimate of location.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>the final estimate of scatter.</p>
</td></tr>
<tr><td><code>cor</code></td>
<td>
<p>the estimate of the correlation matrix (only if
<code>cor = TRUE</code>).</p>
</td></tr>
<tr><td><code>mah</code></td>
<td>
<p>mahalanobis distances of the observations using the
M-estimate of the location and scatter.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the input data as a matrix.</p>
</td></tr>
<tr><td><code>n.obs</code></td>
<td>
<p>total number of observations.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>character string naming the method (M-Estimates).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call used (see <code><a href="base.html#topic+match.call">match.call</a></code>).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The psi, rho and weight functions for the M estimation are encapsulated in a
virtual S4 class <code>PsiFun</code> from which a <code>PsiBwt</code> class, implementing
the translated biweight (t-biweight), is dervied. The base class  <code>PsiFun</code>
contains also the M-iteration itself. Although not documented and not
accessibale directly by the user these classes will form the bases for adding
other functions (biweight, LWS, etc.) as well as S-estimates.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>,
</p>
<p>(some code from C. Becker -
http://www.sfb475.uni-dortmund.de/dienst/de/content/struk-d/bereicha-d/tpa1softw-d.html)
</p>


<h3>References</h3>

<p>D.L.Woodruff and D.M.Rocke (1994) Computable robust estimation of multivariate location
and shape on high dimension using compound estimators, <em>Journal of the American
Statistical Association</em>, <b>89</b>, 888&ndash;896.
</p>
<p>D.M.Rocke (1996) Robustness properties of S-estimates of multivariate location and
shape in high dimension, <em>Annals of Statistics</em>, <b>24</b>, 1327-1345.
</p>
<p>D.M.Rocke and D.L.Woodruff (1996) Identification of outliers in multivariate data <em>Journal
of the American Statistical Association</em>, <b>91</b>, 1047&ndash;1061.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="robustbase.html#topic+covMcd">covMcd</a></code>
</p>

<hr>
<h2 id='CovMest'>Constrained M-Estimates of Location and Scatter</h2><span id='topic+CovMest'></span>

<h3>Description</h3>

<p>Computes constrained M-Estimates of multivariate location and scatter
based on the translated biweight function (&lsquo;t-biweight&rsquo;) using
a High breakdown point initial estimate as defined by Rocke (1996).
The default initial estimate is the Minimum Volume Ellipsoid computed
with <code><a href="#topic+CovMve">CovMve</a></code>. The raw (not reweighted) estimates are taken
and the covariance matrix is standardized to determinant 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    CovMest(x, r = 0.45, arp = 0.05, eps=1e-3,
        maxiter=120, control, t0, S0, initcontrol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovMest_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. </p>
</td></tr>
<tr><td><code id="CovMest_+3A_r">r</code></td>
<td>
<p> required breakdown point.  Allowed values are between
<code>(n - p)/(2 * n)</code> and 1 and the default is 0.45</p>
</td></tr>
<tr><td><code id="CovMest_+3A_arp">arp</code></td>
<td>
<p> asympthotic rejection point, i.e. the fraction of points
receiving zero weight (see Rocke (1996)).  Default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="CovMest_+3A_eps">eps</code></td>
<td>
<p> a numeric value specifying the relative precision of the solution of
the M-estimate. Defaults to <code>1e-3</code></p>
</td></tr>
<tr><td><code id="CovMest_+3A_maxiter">maxiter</code></td>
<td>
<p> maximum number of iterations allowed in the computation of
the M-estimate. Defaults to 120</p>
</td></tr>
<tr><td><code id="CovMest_+3A_control">control</code></td>
<td>
<p> a control object (S4) of class <code><a href="#topic+CovControlMest-class">CovControlMest-class</a></code>
containing estimation options - same as these provided in the fucntion
specification. If the control object is supplied, the parameters from it
will be used. If parameters are passed also in the invocation statement, they will
override the corresponding elements of the control object.</p>
</td></tr>
<tr><td><code id="CovMest_+3A_t0">t0</code></td>
<td>
<p> optional initial high breakdown point estimates of the location.
If not supplied MVE will be used. </p>
</td></tr>
<tr><td><code id="CovMest_+3A_s0">S0</code></td>
<td>
<p> optional initial high breakdown point estimates of the
scatter. If not supplied MVE will be used. </p>
</td></tr>
<tr><td><code id="CovMest_+3A_initcontrol">initcontrol</code></td>
<td>
<p> optional control object - of class CovControl - specifing the
initial high breakdown point estimates of location and scatter. If not supplied
MVE will be used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rocke (1996) has shown that the S-estimates of multivariate location and scatter
in high dimensions can be sensitive to outliers even if the breakdown point
is set to be near 0.5. To mitigate this problem he proposed to utilize
the translated  biweight (or t-biweight) method with a
standardization step consisting of equating the median of <code>rho(d)</code>
with the median under normality. This is then not an S-estimate, but is
instead a constrained M-estimate. In order to make the smooth estimators
to work, a reasonable starting point is necessary, which will lead reliably to a
good solution of the estimator. In <code>CovMest</code> the MVE computed by
<code><a href="#topic+CovMve">CovMve</a></code> is used, but the user has the possibility to give her own
initial estimates.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+CovMest-class">CovMest-class</a></code> which is a subclass of the virtual class <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>.
</p>


<h3>Note</h3>

<p>The psi, rho and weight functions for the M estimation are encapsulated in a
virtual S4 class <code>PsiFun</code> from which a <code>PsiBwt</code> class, implementing
the translated biweight (t-biweight), is dervied. The base class  <code>PsiFun</code>
contains also the M-iteration itself. Although not documented and not
accessibale directly by the user these classes will form the bases for adding
other functions (biweight, LWS, etc.) as well as S-estimates.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>,
</p>
<p>(some code from C. Becker -
http://www.sfb475.uni-dortmund.de/dienst/de/content/struk-d/bereicha-d/tpa1softw-d.html)
</p>


<h3>References</h3>

<p>D.L.Woodruff and D.M.Rocke (1994) Computable robust estimation of multivariate location
and shape on high dimension using compound estimators, <em>Journal of the American
Statistical Association</em>, <b>89</b>, 888&ndash;896.
</p>
<p>D.M.Rocke (1996) Robustness properties of S-estimates of multivariate location and
shape in high dimension, <em>Annals of Statistics</em>, <b>24</b>, 1327-1345.
</p>
<p>D.M.Rocke and D.L.Woodruff (1996) Identification of outliers in multivariate data <em>Journal
of the American Statistical Association</em>, <b>91</b>, 1047&ndash;1061.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="robustbase.html#topic+covMcd">covMcd</a></code>, <code><a href="#topic+Cov-class">Cov-class</a></code>,
<code><a href="#topic+CovMve">CovMve</a></code>,
<code><a href="#topic+CovRobust-class">CovRobust-class</a></code>, <code><a href="#topic+CovMest-class">CovMest-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(rrcov)
data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])
CovMest(hbk.x)

## the following four statements are equivalent
c0 &lt;- CovMest(hbk.x)
c1 &lt;- CovMest(hbk.x, r = 0.45)
c2 &lt;- CovMest(hbk.x, control = CovControlMest(r = 0.45))
c3 &lt;- CovMest(hbk.x, control = new("CovControlMest", r = 0.45))

## direct specification overrides control one:
c4 &lt;- CovMest(hbk.x, r = 0.40,
             control = CovControlMest(r = 0.25))
c1
summary(c1)
plot(c1)
</code></pre>

<hr>
<h2 id='CovMest-class'>Constrained M-estimates of Multivariate Location and Scatter </h2><span id='topic+CovMest-class'></span>

<h3>Description</h3>

<p>This class, derived from the virtual class &quot;CovRobust&quot; accomodates
constrained M-Estimates of multivariate location and scatter
based on the translated biweight function (&lsquo;t-biweight&rsquo;) using
a High breakdown point initial estimate (Minimum Covariance Determinant -
&lsquo;Fast MCD&rsquo;)</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovMest", ...)</code>,
but the usual way of creating <code>CovMest</code> objects is a call to the function
<code>CovMest</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>vt</code>:</dt><dd><p>Object of class <code>"vector"</code> - vector of weights (v)</p>
</dd>
<dt><code>iter</code>, <code>crit</code>, <code>wt</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code> class.
</p>
</dd>
<dt><code>call</code>, <code>cov</code>, <code>center</code>,
<code>n.obs</code>, <code>mah</code>, <code>method</code>,
<code>singularity</code>, <code>X</code>:</dt><dd><p>from the <code>"<a href="#topic+Cov-class">Cov</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Cov-class">Cov</a>"</code>, by class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;CovMest&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CovMest">CovMest</a></code>, <code><a href="#topic+Cov-class">Cov-class</a></code>, <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CovMest")
</code></pre>

<hr>
<h2 id='CovMMest'> MM Estimates of Multivariate Location and Scatter </h2><span id='topic+CovMMest'></span>

<h3>Description</h3>

<p>Computes MM-Estimates of multivariate location and scatter starting from an initial S-estimate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    CovMMest(x, bdp = 0.5, eff = 0.95, eff.shape=TRUE, maxiter = 50, 
        trace = FALSE, tolSolve = 1e-7, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovMMest_+3A_x">x</code></td>
<td>
<p> a matrix or data frame. </p>
</td></tr>
<tr><td><code id="CovMMest_+3A_bdp">bdp</code></td>
<td>
<p>a numeric value specifying the required
breakdown point.  Allowed values are between
0.5 and 1 and the default is <code>bdp=0.5</code>.
</p>
</td></tr>
<tr><td><code id="CovMMest_+3A_eff">eff</code></td>
<td>
<p>a numeric value specifying the required efficiency
for the MM estimates.  Default is <code>eff=0.95</code>.
</p>
</td></tr>
<tr><td><code id="CovMMest_+3A_eff.shape">eff.shape</code></td>
<td>
<p>logical; if TRUE, eff is with regard to shape-efficiency, otherwise location-efficiency. Default is <code>eff.shape=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="CovMMest_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed
in the computation of the S-estimate (bisquare and Rocke type).
Default is <code>maxiter=50</code>.
</p>
</td></tr>
<tr><td><code id="CovMMest_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code>.</p>
</td></tr>
<tr><td><code id="CovMMest_+3A_tolsolve">tolSolve</code></td>
<td>
<p>numeric tolerance to be used as a convergence tolerance for the MM-iteration</p>
</td></tr>
<tr><td><code id="CovMMest_+3A_control">control</code></td>
<td>
<p> a control object (S4) of class <code><a href="#topic+CovControlMMest-class">CovControlMMest-class</a></code>
containing estimation options - same as these provided in the fucntion
specification. If the control object is supplied, the parameters from it
will be used. If parameters are passed also in the invocation statement, they will
override the corresponding elements of the control object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes MM-estimates of multivariate location and scatter starting from an initial S-estimate.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+CovMMest-class">CovMMest-class</a></code> which is a subclass of the
virtual class <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Tatsuoka, K.S. and Tyler, D.E. (2000).  
The uniqueness of S and M-functionals under non-elliptical distributions.
<em>Annals of Statistics</em> 28, 1219&ndash;1243
</p>
<p>M. Salibian-Barrera,  S. Van Aelstt and G. Willems (2006). 
Principal components analysis based on multivariate MM-estimators with fast and robust bootstrap.
<em>Journal of the American Statistical Association</em> 101, 1198&ndash;1211.
</p>
<p>R. A. Maronna, D. Martin and V. Yohai (2006). 
<em>Robust Statistics: Theory and Methods</em>.
Wiley, New York.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(rrcov)
data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])
CovMMest(hbk.x)

## the following four statements are equivalent
c0 &lt;- CovMMest(hbk.x)
c1 &lt;- CovMMest(hbk.x, bdp = 0.25)
c2 &lt;- CovMMest(hbk.x, control = CovControlMMest(bdp = 0.25))
c3 &lt;- CovMMest(hbk.x, control = new("CovControlMMest", bdp = 0.25))

## direct specification overrides control one:
c4 &lt;- CovMMest(hbk.x, bdp = 0.40,
             control = CovControlMMest(bdp = 0.25))
c1
summary(c1)
plot(c1)

## Deterministic MM-estmates
CovMMest(hbk.x, control=CovControlMMest(sest=CovControlSest(method="sdet")))

</code></pre>

<hr>
<h2 id='CovMMest-class'> MM Estimates of Multivariate Location and Scatter </h2><span id='topic+CovMMest-class'></span>

<h3>Description</h3>

<p> This class, derived from the virtual class <code>"CovRobust"</code>
accomodates MM Estimates of multivariate location and scatter.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovMMest", ...)</code>,
but the usual way of creating <code>CovSest</code> objects is a call to the function
<code>CovMMest</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>det</code>, <code>flag</code>, <code>iter</code>, <code>crit</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code> class.
</p>
</dd>
<dt>c1</dt><dd><p>tuning parameter of the loss function for MM-estimation 
(depend on control parameters <code>eff</code> and <code>eff.shape</code>). 
Can be computed by the internal function 
<code>.csolve.bw.MM(p, eff, eff.shape=TRUE)</code>.
For the tuning parameters of the underlying S-estimate see the slot <code>sest</code> and
<code>"<a href="#topic+CovSest-class">CovSest</a>"</code>.
</p>
</dd>
<dt>sest</dt><dd><p>an <code>CovSest</code> object containing the initial S-estimate.
</p>
</dd>
<dt><code>call</code>, <code>cov</code>, <code>center</code>,
<code>n.obs</code>, <code>mah</code>, <code>method</code>,
<code>singularity</code>, <code>X</code>:</dt><dd><p>from the <code>"<a href="#topic+Cov-class">Cov</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Cov-class">Cov</a>"</code>, by class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;CovMMest&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CovMMest">CovMMest</a></code>, <code><a href="#topic+Cov-class">Cov-class</a></code>, <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CovMMest")
</code></pre>

<hr>
<h2 id='CovMrcd'> Robust Location and Scatter Estimation via Minimum Regularized Covariance Determonant (MRCD)</h2><span id='topic+CovMrcd'></span>

<h3>Description</h3>

<p>Computes a robust multivariate location and scatter estimate with a high
breakdown point, using the Minimum Regularized Covariance Determonant (MRCD) estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovMrcd(x,
       alpha=control@alpha, 
       h=control@h,
       maxcsteps=control@maxcsteps,
       initHsets=NULL, save.hsets=FALSE,
       rho=control@rho,
       target=control@target,
       maxcond=control@maxcond,
       trace=control@trace,
       control=CovControlMrcd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovMrcd_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. </p>
</td></tr>
<tr><td><code id="CovMrcd_+3A_alpha">alpha</code></td>
<td>
<p>numeric parameter controlling the size of the subsets
over which the determinant is minimized, i.e., <code>alpha*n</code>
observations are used for computing the determinant.  Allowed values
are between 0.5 and 1 and the default is 0.5.</p>
</td></tr>
<tr><td><code id="CovMrcd_+3A_h">h</code></td>
<td>
<p>the size of the subset (can be between ceiling(n/2) and n). 
Normally NULL and then it <code>h</code> will be calculated as 
<code>h=ceiling(alpha*n)</code>. If <code>h</code> is provided, <code>alpha</code> 
will be calculated as <code>alpha=h/n</code>.</p>
</td></tr>
<tr><td><code id="CovMrcd_+3A_maxcsteps">maxcsteps</code></td>
<td>
<p>maximal number of concentration steps in the
deterministic MCD; should not be reached.</p>
</td></tr>
<tr><td><code id="CovMrcd_+3A_inithsets">initHsets</code></td>
<td>
<p>NULL or a <code class="reqn">K x h</code> integer matrix of initial
subsets of observations of size <code class="reqn">h</code> (specified by the indices in
<code>1:n</code>).</p>
</td></tr>
<tr><td><code id="CovMrcd_+3A_save.hsets">save.hsets</code></td>
<td>
<p>(for deterministic MCD) logical indicating if the
initial subsets should be returned as <code>initHsets</code>.</p>
</td></tr>
<tr><td><code id="CovMrcd_+3A_rho">rho</code></td>
<td>
<p>regularization parameter. Normally NULL and will be estimated from the data.</p>
</td></tr>
<tr><td><code id="CovMrcd_+3A_target">target</code></td>
<td>
<p>structure of the robust positive definite target matrix: 
a) &quot;identity&quot;: target matrix is diagonal matrix with robustly estimated 
univariate scales on the diagonal or b) &quot;equicorrelation&quot;: non-diagonal 
target matrix that incorporates an equicorrelation structure 
(see (17) in paper). Default is <code>target="identity"</code></p>
</td></tr>
<tr><td><code id="CovMrcd_+3A_maxcond">maxcond</code></td>
<td>
<p>maximum condition number allowed 
(see step 3.4 in algorithm 1). Default is <code>maxcond=50</code></p>
</td></tr>
<tr><td><code id="CovMrcd_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>
<tr><td><code id="CovMrcd_+3A_control">control</code></td>
<td>
<p> a control object (S4) of class <code><a href="#topic+CovControlMrcd-class">CovControlMrcd-class</a></code>
containing estimation options - same as these provided in the function
specification. If the control object is supplied, the parameters from it
will be used. If parameters are passed also in the invocation statement, they will
override the corresponding elements of the control object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the minimum regularized covariance determinant estimator (MRCD)
of location and scatter and returns an S4 object of class
<code><a href="#topic+CovMrcd-class">CovMrcd-class</a></code> containing the estimates.
Similarly like the MCD method, MRCD looks for the <code class="reqn">h (&gt; n/2)</code>
observations (out of <code class="reqn">n</code>) whose classical
covariance matrix has the lowest possible determinant, but 
replaces the subset-based covariance by a regularized 
covariance estimate, defined as a weighted average of the 
sample covariance of the h-subset and a predetermined 
positive definite target matrix. The Minimum Regularized Covariance 
Determinant (MRCD) estimator is then the regularized covariance 
based on the h-subset which makes the overall determinant the smallest.
A data-driven procedure sets the weight of the target matrix (<code>rho</code>), so that 
the regularization is only used when needed.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+CovMrcd-class">CovMrcd-class</a></code> which is a subclass of the
virtual class <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>.
</p>


<h3>Author(s)</h3>

 
<p>Kris Boudt, Peter Rousseeuw, Steven Vanduffel and Tim Verdonk. Improved by Joachim Schreurs and Iwein Vranckx.
Adapted for <span class="pkg">rrcov</span> by Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Kris Boudt, Peter Rousseeuw, Steven Vanduffel and Tim Verdonck (2020)
The Minimum Regularized Covariance Determinant estimator,
<em>Statistics and Computing</em>, <b>30</b>, pp 113&ndash;128
<a href="https://doi.org/10.1007/s11222-019-09869-x">doi:10.1007/s11222-019-09869-x</a>.
</p>
<p>Mia Hubert, Peter Rousseeuw and Tim Verdonck (2012) A deterministic algorithm
for robust location and scatter.
<em>Journal of Computational and Graphical Statistics</em> <b>21</b>(3), 618&ndash;637.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CovMcd">CovMcd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The result will be (almost) identical to the raw MCD
##  (since we do not do reweighting of MRCD)
##
data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])
c0 &lt;- CovMcd(hbk.x, alpha=0.75, use.correction=FALSE)
cc &lt;- CovMrcd(hbk.x, alpha=0.75)
cc$rho
all.equal(c0$best, cc$best)
all.equal(c0$raw.center, cc$center)
all.equal(c0$raw.cov/c0$raw.cnp2[1], cc$cov/cc$cnp2)

summary(cc)

## the following three statements are equivalent
c1 &lt;- CovMrcd(hbk.x, alpha = 0.75)
c2 &lt;- CovMrcd(hbk.x, control = CovControlMrcd(alpha = 0.75))
## direct specification overrides control one:
c3 &lt;- CovMrcd(hbk.x, alpha = 0.75,
             control = CovControlMrcd(alpha=0.95))
c1

## Not run: 

##  This is the first example from Boudt et al. (2020). The first variable is 
##  the dependent one, which we remove and remain with p=226 NIR absorbance spectra 

data(octane)

octane &lt;- octane[, -1]    # remove the dependent variable y

n &lt;- nrow(octane)
p &lt;- ncol(octane)

##  Compute MRCD with h=33, which gives approximately 15 percent breakdown point.
##  This value of h was found by Boudt et al. (2020) using a data driven approach, 
##  similar to the Forward Search of Atkinson et al. (2004). 
##  The default value of h would be 20 (i.e. alpha=0.5) 

out &lt;- CovMrcd(octane, h=33) 
out$rho

## Please note that in the paper is indicated that the obtained rho=0.1149, however,
##  this value of rho is obtained if the parameter maxcond is set equal to 999 (this was 
##  the default in an earlier version of the software, now the default is maxcond=50). 
##  To reproduce the result from the paper, change the call to CovMrcd() as follows 
##  (this will not influence the results shown further):

##  out &lt;- CovMrcd(octane, h=33, maxcond=999) 
##  out$rho

robpca = PcaHubert(octane, k=2, alpha=0.75, mcd=FALSE)
(outl.robpca = which(robpca@flag==FALSE))

# Observations flagged as outliers by ROBPCA:
# 25, 26, 36, 37, 38, 39

# Plot the orthogonal distances versus the score distances:
pch = rep(20,n); pch[robpca@flag==FALSE] = 17
col = rep('black',n); col[robpca@flag==FALSE] = 'red'
plot(robpca, pch=pch, col=col, id.n.sd=6, id.n.od=6)

## Plot now the MRCD mahalanobis distances
pch = rep(20,n); pch[!getFlag(out)] = 17
col = rep('black',n); col[!getFlag(out)] = 'red'
plot(out, pch=pch, col=col, id.n=6)

## End(Not run)
</code></pre>

<hr>
<h2 id='CovMrcd-class'> MRCD Estimates of Multivariate Location and Scatter </h2><span id='topic+CovMrcd-class'></span>

<h3>Description</h3>

<p>This class, derived from the virtual class <code>"CovRobust"</code> accomodates
MRCD Estimates of multivariate location and scatter computed by a variant of the 
&lsquo;Fast MCD&rsquo; algorithm.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovMrcd", ...)</code>,
but the usual way of creating <code>CovMrcd</code> objects is a call to the function
<code>CovMrcd</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alpha</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the size of the
subsets over which the determinant is minimized (the default is (n+p+1)/2) </p>
</dd>
<dt><code>quan</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the number of
observations on which the MCD is based. If <code>quan</code> equals
<code>n.obs</code>, the MCD is the classical covariance matrix. </p>
</dd>
<dt><code>best</code>:</dt><dd><p>Object of class <code>"Uvector"</code> - the best subset
found and used for computing the raw estimates. The size of <code>best</code>
is equal to <code>quan</code> </p>
</dd>
<dt><code>cnp2</code>:</dt><dd><p>Object of class <code>"numeric"</code> - containing the consistency 
correction factor of the estimate of the covariance matrix.
</p>
</dd>
<dt><code>icov</code>:</dt><dd><p>The inverse of the covariance matrix.
</p>
</dd>
<dt><code>rho</code>:</dt><dd><p>The estimated regularization parameter.
</p>
</dd>
<dt><code>target</code>:</dt><dd><p>The estimated target matrix.
</p>
</dd>
<dt><code>crit</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code> class.
</p>
</dd>
<dt><code>call</code>, <code>cov</code>, <code>center</code>,
<code>n.obs</code>, <code>mah</code>, <code>method</code>,
<code>X</code>:</dt><dd><p>from the <code>"<a href="#topic+Cov-class">Cov</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Cov-class">Cov</a>"</code>, by class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class <code>"CovMrcd"</code> in the signature.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CovMrcd">CovMrcd</a></code>, <code><a href="#topic+Cov-class">Cov-class</a></code>, <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>, <code><a href="#topic+CovMcd-class">CovMcd-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CovMrcd")
</code></pre>

<hr>
<h2 id='CovMve'> Robust Location and Scatter Estimation via MVE </h2><span id='topic+CovMve'></span>

<h3>Description</h3>

<p>Computes a robust multivariate location and scatter estimate with a high
breakdown point, using the &lsquo;MVE&rsquo; (Minimum Volume Ellipsoid)
estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovMve(x, alpha = 1/2, nsamp = 500, seed = NULL, trace = FALSE, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovMve_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. </p>
</td></tr>
<tr><td><code id="CovMve_+3A_alpha">alpha</code></td>
<td>
<p>numeric parameter controlling the size of the subsets
over which the determinant is minimized, i.e., <code>alpha*n</code>
observations are used for computing the determinant.  Allowed values
are between 0.5 and 1 and the default is 0.5.</p>
</td></tr>
<tr><td><code id="CovMve_+3A_nsamp">nsamp</code></td>
<td>
<p> number of subsets used for initial estimates or <code>"best"</code>
or <code>"exact"</code>.  Default is <code>nsamp = 500</code>.  For
<code>nsamp="best"</code> exhaustive enumeration is done, as long as the
number of trials does not exceed 5000. For <code>"exact"</code>,
exhaustive enumeration will be attempted however many samples are
needed.  In this case a warning message will be displayed saying
that the computation can take a very long time.</p>
</td></tr>
<tr><td><code id="CovMve_+3A_seed">seed</code></td>
<td>
<p>starting value for random generator. Default is <code>seed = NULL</code></p>
</td></tr>
<tr><td><code id="CovMve_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>
<tr><td><code id="CovMve_+3A_control">control</code></td>
<td>
<p> a control object (S4) of class <code><a href="#topic+CovControlMve-class">CovControlMve-class</a></code>
containing estimation options - same as these provided in the fucntion
specification. If the control object is supplied, the parameters from it
will be used. If parameters are passed also in the invocation statement, they will
override the corresponding elements of the control object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the minimum volume ellipsoid estimator
of location and scatter and returns an S4 object of class
<code><a href="#topic+CovMve-class">CovMve-class</a></code> containing the estimates.
</p>
<p>The approximate estimate is
based on a subset of size <code>alpha*n</code> with an enclosing ellipsoid of smallest volume.
The mean of the best found subset provides the raw estimate of the location,
and the rescaled covariance matrix is the raw estimate of scatter. The rescaling of
the raw covariance matrix is by <code>median(dist)/qchisq(0.5, p)</code> and this scale factor
is returned in the slot <code>raw.cnp2</code>. Currently no finite sample corrction factor is applied.
The Mahalanobis distances of all observations from the location estimate for the
raw covariance matrix are calculated, and those points within the 97.5
under Gaussian assumptions are declared to be good. The final (reweightd) estimates are the
mean and rescaled covariance of the good points. The reweighted covariance matrix is
rescaled by <code>1/pgamma(qchisq(alpha, p)/2, p/2 + 1)/alpha</code>
(see Croux and Haesbroeck, 1999) and this scale factor is returned
in the slot <code>cnp2</code>.
</p>
<p>The search for the approximate solution is made over ellipsoids determined by the
covariance matrix of <code>p+1</code> of the data points and applying
a simple but effective improvement of the subsampling procedure
as described in Maronna et al. (2006), p. 198.
Although there exists no formal proof of this improvement (as for MCD and LTS),
simulations show that it can be recommended as an approximation of the MVE.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+CovMve-class">CovMve-class</a></code> which is a subclass of the
virtual class <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>.
</p>


<h3>Note</h3>

<p>Main reason for implementing the MVE estimate was that it is the recommended
initial estimate for S estimation (see Maronna et al. (2006), p. 199) and will
be used by default in <code><a href="#topic+CovMest">CovMest</a></code> (after removing the correction
factors from the covariance matrix and rescaling to determinant 1).
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> and
Matias Salibian-Barrera <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p>P. J. Rousseeuw and A. M. Leroy (1987)
<em>Robust Regression and Outlier Detection.</em> Wiley.
</p>
<p>C. Croux and G. Haesbroeck (1999).
Influence function and efficiency of the minimum covariance determinant scatter matrix estimator.
<em>Journal of Multivariate Analysis</em>,
<b>71</b>, 161&ndash;190.
</p>
<p>R. A. Maronna, D. Martin and V. Yohai (2006). <em>Robust Statistics: Theory and Methods</em>.
Wiley, New York.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+cov.rob">cov.rob</a></code> from package <span class="pkg">MASS</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])
CovMve(hbk.x)

## the following three statements are equivalent
c1 &lt;- CovMve(hbk.x, alpha = 0.75)
c2 &lt;- CovMve(hbk.x, control = CovControlMve(alpha = 0.75))
## direct specification overrides control one:
c3 &lt;- CovMve(hbk.x, alpha = 0.75,
             control = CovControlMve(alpha=0.95))
c1
</code></pre>

<hr>
<h2 id='CovMve-class'> MVE Estimates of Multivariate Location and Scatter </h2><span id='topic+CovMve-class'></span>

<h3>Description</h3>

<p>This class, derived from the virtual class <code>"CovRobust"</code> accomodates
MVE Estimates of multivariate location and scatter computed by the
&lsquo;Fast MVE&rsquo; algorithm.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovMve", ...)</code>,
but the usual way of creating <code>CovMve</code> objects is a call to the function
<code>CovMve</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alpha</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the size of the
subsets over which the volume of the ellipsoid is minimized (the default is (n+p+1)/2) </p>
</dd>
<dt><code>quan</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the number of
observations on which the MVE is based. If <code>quan</code> equals
<code>n.obs</code>, the MVE is the classical covariance matrix. </p>
</dd>
<dt><code>best</code>:</dt><dd><p>Object of class <code>"Uvector"</code> - the best subset
found and used for computing the raw estimates. The size of <code>best</code>
is equal to <code>quan</code> </p>
</dd>
<dt><code>raw.cov</code>:</dt><dd><p>Object of class <code>"matrix"</code> the raw
(not reweighted) estimate of location </p>
</dd>
<dt><code>raw.center</code>:</dt><dd><p>Object of class <code>"vector"</code> - the raw
(not reweighted) estimate of scatter</p>
</dd>
<dt><code>raw.mah</code>:</dt><dd><p>Object of class <code>"Uvector"</code> - mahalanobis
distances of the observations based on the raw estimate of the
location and scatter </p>
</dd>
<dt><code>raw.wt</code>:</dt><dd><p>Object of class <code>"Uvector"</code> - weights of
the observations based on the raw estimate of the location and scatter </p>
</dd>
<dt><code>raw.cnp2</code>:</dt><dd><p>Object of class <code>"numeric"</code> - a vector of length
two containing the consistency correction factor and the finite sample
correction factor of the raw estimate of the covariance matrix </p>
</dd>
<dt><code>cnp2</code>:</dt><dd><p>Object of class <code>"numeric"</code> - a vector of length two
containing the consistency correction factor and the finite sample
correction factor of the final estimate of the covariance matrix.
</p>
</dd>
<dt><code>iter</code>, <code>crit</code>, <code>wt</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code> class.
</p>
</dd>
<dt><code>call</code>, <code>cov</code>, <code>center</code>,
<code>n.obs</code>, <code>mah</code>, <code>method</code>,
<code>singularity</code>, <code>X</code>:</dt><dd><p>from the <code>"<a href="#topic+Cov-class">Cov</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Cov-class">Cov</a>"</code>, by class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;CovMve&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CovMve">CovMve</a></code>, <code><a href="#topic+Cov-class">Cov-class</a></code>, <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CovMve")
</code></pre>

<hr>
<h2 id='CovOgk'> Robust Location and Scatter Estimation - Ortogonalized Gnanadesikan-Kettenring (OGK)</h2><span id='topic+CovOgk'></span>

<h3>Description</h3>

<p>Computes a robust multivariate location and scatter estimate with a high
breakdown point, using the pairwise algorithm proposed by Marona and
Zamar (2002) which in turn is based on the pairwise robust estimator
proposed by Gnanadesikan-Kettenring (1972).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovOgk(x, niter = 2, beta = 0.9, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovOgk_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. </p>
</td></tr>
<tr><td><code id="CovOgk_+3A_niter">niter</code></td>
<td>
<p> number of iterations, usually 1 or 2 since iterations
beyond the second do not lead to improvement. </p>
</td></tr>
<tr><td><code id="CovOgk_+3A_beta">beta</code></td>
<td>
<p> coverage parameter for the final reweighted estimate </p>
</td></tr>
<tr><td><code id="CovOgk_+3A_control">control</code></td>
<td>
<p> a control object (S4) of class <code><a href="#topic+CovControlOgk-class">CovControlOgk-class</a></code>
containing estimation options - same as these provided in the function
specification. If the control object is supplied, the parameters from it
will be used. If parameters are passed also in the invocation statement, they will
override the corresponding elements of the control object. The control
object contains also functions for computing the robust univariate location
and dispersion estimate <code>mrob</code> and for computing the robust estimate
of the covariance between two random variables <code>vrob</code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method proposed by Marona and Zamar (2002) allowes to obtain
positive-definite and almost affine equivariant robust scatter matrices
starting from any pairwise robust scatter matrix. The default robust estimate
of covariance between two random vectors used is the one proposed by
Gnanadesikan and Kettenring (1972) but the user can choose any other method by
redefining the function in slot <code>vrob</code> of the control object
<code>CovControlOgk</code>. Similarly, the function for computing the robust
univariate location and dispersion used is the <code>tau scale</code> defined
in Yohai and Zamar (1998) but it can be redefined in the control object.
</p>
<p>The estimates obtained by the OGK method, similarly as in <code>CovMcd</code> are returned
as 'raw' estimates. To improve the estimates a reweighting step is performed using
the coverage parameter <code>beta</code> and these reweighted estimates are returned as
'final' estimates.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+CovOgk-class">CovOgk-class</a></code> which is a subclass of the
virtual class <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>.
</p>


<h3>Note</h3>

<p>If the user does not specify a scale and covariance function to be used in
the computations or specifies one by using the arguments <code>smrob</code> and <code>svrob</code>
(i.e. the names of the functions as strings), a native code written in C will be called which
is by far faster than the R version.
</p>
<p>If the arguments <code>mrob</code> and <code>vrob</code> are not NULL, the specified functions
will be used via the pure R implementation of the algorithm. This could be quite slow.
</p>
<p>See <code><a href="#topic+CovControlOgk">CovControlOgk</a></code> for details.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> and
Kjell Konis <a href="mailto:kjell.konis@epfl.ch">kjell.konis@epfl.ch</a>
</p>


<h3>References</h3>

<p>Maronna, R.A. and Zamar, R.H. (2002)
Robust estimates of location and dispersion of high-dimensional datasets;
<em>Technometrics</em> <b>44</b>(4), 307&ndash;317.
</p>
<p>Yohai, R.A. and Zamar, R.H. (1998)
High breakdown point estimates of regression by means of the minimization of efficient scale
<em>JASA</em> <b>86</b>, 403&ndash;413.
</p>
<p>Gnanadesikan, R. and John R. Kettenring (1972)
Robust estimates, residuals, and outlier detection with multiresponse data.
<em>Biometrics</em> <b>28</b>, 81&ndash;124.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CovMcd">CovMcd</a></code>, <code><a href="#topic+CovMest">CovMest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])
CovOgk(hbk.x)

## the following three statements are equivalent
c1 &lt;- CovOgk(hbk.x, niter=1)
c2 &lt;- CovOgk(hbk.x, control = CovControlOgk(niter=1))

## direct specification overrides control one:
c3 &lt;- CovOgk(hbk.x, beta=0.95,
             control = CovControlOgk(beta=0.99))
c1

x&lt;-matrix(c(1,2,3,7,1,2,3,7), ncol=2)
##  CovOgk(x)   - this would fail because the two columns of x are exactly collinear.
##              In order to fix it, redefine the default 'vrob' function for example
##              in the following way and pass it as a parameter in the control
##              object.
cc &lt;- CovOgk(x, control=new("CovControlOgk",
                            vrob=function(x1, x2, ...)
                            {
                                r &lt;- .vrobGK(x1, x2, ...)
                                if(is.na(r))
                                    r &lt;- 0
                                r
                            })
)
cc
</code></pre>

<hr>
<h2 id='CovOgk-class'> OGK Estimates of Multivariate Location and Scatter </h2><span id='topic+CovOgk-class'></span>

<h3>Description</h3>

<p>This class, derived from the virtual class <code>"CovRobust"</code> accomodates
OGK Estimates of multivariate location and scatter computed by the
algorithm proposed by Marona and Zamar (2002).
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovOgk", ...)</code>,
but the usual way of creating <code>CovOgk</code> objects is a call to the function
<code>CovOgk</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>raw.cov</code>:</dt><dd><p>Object of class <code>"matrix"</code> the raw
(not reweighted) estimate of covariance matrix </p>
</dd>
<dt><code>raw.center</code>:</dt><dd><p>Object of class <code>"vector"</code> - the raw
(not reweighted) estimate of the location vector</p>
</dd>
<dt><code>raw.mah</code>:</dt><dd><p>Object of class <code>"Uvector"</code> - mahalanobis
distances of the observations based on the raw estimate of the
location and scatter </p>
</dd>
<dt><code>raw.wt</code>:</dt><dd><p>Object of class <code>"Uvector"</code> - weights of
the observations based on the raw estimate of the location and scatter </p>
</dd>
<dt><code>iter</code>, <code>crit</code>, <code>wt</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code> class.
</p>
</dd>
<dt><code>call</code>, <code>cov</code>, <code>center</code>,
<code>n.obs</code>, <code>mah</code>, <code>method</code>,
<code>singularity</code>, <code>X</code>:</dt><dd><p>from the <code>"<a href="#topic+Cov-class">Cov</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Cov-class">Cov</a>"</code>, by class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;CovOgk&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CovMcd-class">CovMcd-class</a></code>, <code><a href="#topic+CovMest-class">CovMest-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CovOgk")
</code></pre>

<hr>
<h2 id='CovRobust'> Robust Location and Scatter Estimation </h2><span id='topic+CovRobust'></span>

<h3>Description</h3>

<p>Computes a robust multivariate location and scatter estimate with a high
breakdown point, using one of the available estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovRobust(x, control, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovRobust_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. </p>
</td></tr>
<tr><td><code id="CovRobust_+3A_control">control</code></td>
<td>
<p> a control object (S4) for one of the available control classes,
e.g. <code><a href="#topic+CovControlMcd-class">CovControlMcd-class</a></code>, <code><a href="#topic+CovControlOgk-class">CovControlOgk-class</a></code>,
<code><a href="#topic+CovControlSest-class">CovControlSest-class</a></code>, etc.,
containing estimation options. The class of this object defines
which estimator will be used. Alternatively a character string can be specified
which names the estimator - one of auto, sde, mcd, ogk, m, mve, sfast, surreal,
bisquare, rocke. If 'auto' is specified or the argument is missing, the
function will select the estimator (see below for details)</p>
</td></tr>
<tr><td><code id="CovRobust_+3A_na.action">na.action</code></td>
<td>
<p> A function to specify the action to be taken if
missing values are found. The default action is for the procedure to fail.
An alternative is na.omit, which leads to rejection of cases with missing
values on any required variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply calls the <code>restimate</code> method of the control object
<code>control</code>. If a character string naming an estimator is specified, a
new control object will be created and used (with default estimation options).
If this argument is missing or a character string
'auto' is specified, the function will select the robust estimator
according to the size of the dataset. If there are less than 1000
observations and less than 10 variables or less than 5000 observations
and less than 5 variables, Stahel-Donoho estimator will be used. Otherwise,
if there are less than 50000 observations either bisquare S-estimates
(for less than 10 variables) or Rocke type S-estimates (for 10 to 20 variables)
will be used. In both cases the S iteration starts at the initial MVE estimate.
And finally, if there are more than 50000 observations and/or more than 20 variables the Orthogonalized
Quadrant Correlation estimator (<code>CovOgk</code> with the corresponding parameters) is used.
</p>


<h3>Value</h3>

<p>An object derived from a <code>CovRobust</code> object, depending on the selected estimator.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])
CovRobust(hbk.x)
CovRobust(hbk.x, CovControlSest(method="bisquare"))

</code></pre>

<hr>
<h2 id='CovRobust-class'>Class &quot;CovRobust&quot; - virtual base class for robust
estimates of multivariate location and scatter</h2><span id='topic+CovRobust-class'></span><span id='topic+isClassic+2CCovRobust-method'></span><span id='topic+getMeth+2CCovRobust-method'></span><span id='topic+show+2CCovRobust-method'></span><span id='topic+summary+2CCovRobust-method'></span><span id='topic+getRaw+2CCovRobust-method'></span>

<h3>Description</h3>

  <p><code>CovRobust</code> is a virtual base class used for deriving the concrete classes
representing different robust estimates of multivariate location and scatter. Here are implemeted the
standard methods common for all robust estimates like <code>show</code>, <code>summary</code> and <code>plot</code>.
The derived classes can override these methods and can define new ones.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>iter</code>:</dt><dd><p>number of iterations used to compute the estimates</p>
</dd>
<dt><code>crit</code>:</dt><dd><p>value of the criterion function</p>
</dd>
<dt><code>wt</code>:</dt><dd><p>weights</p>
</dd>
<dt><code>call</code>, <code>cov</code>, <code>center</code>,
<code>n.obs</code>, <code>mah</code>, <code>method</code>,
<code>singularity</code>, <code>X</code>:</dt><dd><p>from the <code>"<a href="#topic+Cov-class">Cov</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Cov-class">Cov</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>isClassic</dt><dd><p><code>signature(obj = "CovRobust")</code>: Will return FALSE, since this is a 'Robust' object </p>
</dd>
<dt>getMeth</dt><dd><p><code>signature(obj = "CovRobust")</code>: Return the name of the particular robust method used (as a character string) </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "CovRobust")</code>: display the object </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "CovRobust")</code>: plot the object </p>
</dd>
<dt>getRaw</dt><dd><p><code>signature(obj = "CovRobust")</code>: Return the object with the reweighted estimates replaced by the raw ones (only relevant for CovMcd, CovMve and CovOgk) </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Cov-class">Cov-class</a></code>, <code><a href="#topic+CovMcd-class">CovMcd-class</a></code>, <code><a href="#topic+CovMest-class">CovMest-class</a></code>, <code><a href="#topic+CovOgk-class">CovOgk-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     data(hbk)
     hbk.x &lt;- data.matrix(hbk[, 1:3])
     cv &lt;- CovMest(hbk.x)               # it is not possible to create an object of
                                        # class CovRobust, since it is a VIRTUAL class
     cv
     summary(cv)                        # summary method for class CovRobust
     plot(cv)                           # plot method for class CovRobust
</code></pre>

<hr>
<h2 id='CovSde'>Stahel-Donoho Estimates of Multivariate Location and Scatter</h2><span id='topic+CovSde'></span>

<h3>Description</h3>

<p>Compute a robust estimate of location and scale using the Stahel-Donoho projection based estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovSde(x, nsamp, maxres, tune = 0.95, eps = 0.5, prob = 0.99, 
seed = NULL, trace = FALSE, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovSde_+3A_x">x</code></td>
<td>
<p> a matrix or data frame.
</p>
</td></tr>
<tr><td><code id="CovSde_+3A_nsamp">nsamp</code></td>
<td>
<p>a positive integer giving the number of resamples required;
<code>nsamp</code> may not be reached if too many of the <code>p</code>-subsamples,
chosen out of the observed vectors, are in a hyperplane.
If <code>nsamp = 0</code> all possible subsamples are taken.
If <code>nsamp</code> is omitted, it is calculated to provide a breakdown point
of <code>eps</code> with probability <code>prob</code>.</p>
</td></tr>
<tr><td><code id="CovSde_+3A_maxres">maxres</code></td>
<td>
<p>a positive integer specifying the maximum number of
resamples to be performed including those that are discarded due to linearly
dependent subsamples.  If <code>maxres</code> is omitted it will be set to 2 times <code>nsamp</code>.</p>
</td></tr>
<tr><td><code id="CovSde_+3A_tune">tune</code></td>
<td>
<p>a numeric value between 0 and 1 giving the fraction of the data to receive non-zero weight.
Defaults to <code>0.95</code></p>
</td></tr>
<tr><td><code id="CovSde_+3A_prob">prob</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the probability of high breakdown point;
used to compute <code>nsamp</code> when <code>nsamp</code> is omitted. Defaults to <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="CovSde_+3A_eps">eps</code></td>
<td>
<p>a numeric value between 0 and 0.5 specifying the breakdown point; used to compute
<code>nsamp</code> when <code>nresamp</code> is omitted. Defaults to <code>0.5</code>. </p>
</td></tr>
<tr><td><code id="CovSde_+3A_seed">seed</code></td>
<td>
<p>starting value for random generator. Default is <code>seed = NULL</code>.</p>
</td></tr>
<tr><td><code id="CovSde_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code>.  </p>
</td></tr>
<tr><td><code id="CovSde_+3A_control">control</code></td>
<td>
<p> a control object (S4) of class <code><a href="#topic+CovControlSde-class">CovControlSde-class</a></code>
containing estimation options - same as these provided in the fucntion
specification. If the control object is supplied, the parameters from it
will be used. If parameters are passed also in the invocation statement, they will
override the corresponding elements of the control object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The projection based Stahel-Donoho estimator posses very good statistical properties, 
but it can be very slow if the number of variables is too large. It is recommended to use
this estimator if <code>n &lt;= 1000</code> and <code>p&lt;=10</code> or <code>n &lt;= 5000</code> and <code>p&lt;=5</code>.
The number of subsamples required is calculated to provide a breakdown point of 
<code>eps</code> with probability <code>prob</code> and can reach values larger than 
the larger integer value - in such case it is limited to <code>.Machine$integer.max</code>.
Of course you could provide <code>nsamp</code> in the call, i.e. <code>nsamp=1000</code> but 
this will not guarantee the required breakdown point of th eestimator.
For larger data sets it is better to use <code><a href="#topic+CovMcd">CovMcd</a></code> or <code><a href="#topic+CovOgk">CovOgk</a></code>. 
If you use <code><a href="#topic+CovRobust">CovRobust</a></code>, the estimator will be selected automatically 
according on the size of the data set.</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+CovSde-class">CovSde-class</a></code> which is a subclass of the
virtual class <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>.
</p>


<h3>Note</h3>

<p>The Fortran code for the Stahel-Donoho method was taken almost with no changes from
package <code>robust</code> which in turn has it from the <em>Insightful Robust Library</em>
(thanks to by Kjell Konis).
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> and
Kjell Konis <a href="mailto:kjell.konis@epfl.ch">kjell.konis@epfl.ch</a>
</p>


<h3>References</h3>

<p>R. A. Maronna and V.J. Yohai (1995) The Behavior of the Stahel-Donoho Robust Multivariate
Estimator. <em>Journal of the American Statistical Association</em> <b>90</b> (429), 330&ndash;341.
</p>
<p>R. A. Maronna, D. Martin and V. Yohai (2006). <em>Robust Statistics: Theory and Methods</em>.
Wiley, New York.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])
CovSde(hbk.x)

## the following four statements are equivalent
c0 &lt;- CovSde(hbk.x)
c1 &lt;- CovSde(hbk.x, nsamp=2000)
c2 &lt;- CovSde(hbk.x, control = CovControlSde(nsamp=2000))
c3 &lt;- CovSde(hbk.x, control = new("CovControlSde", nsamp=2000))

## direct specification overrides control one:
c4 &lt;- CovSde(hbk.x, nsamp=100,
             control = CovControlSde(nsamp=2000))
c1
summary(c1)
plot(c1)

## Use the function CovRobust() - if no estimation method is
##  specified, for small data sets CovSde() will be called
cr &lt;- CovRobust(hbk.x)
cr

</code></pre>

<hr>
<h2 id='CovSde-class'>
Stahel-Donoho Estimates of Multivariate Location and Scatter
</h2><span id='topic+CovSde-class'></span>

<h3>Description</h3>

<p> This class, derived from the virtual class <code>"CovRobust"</code>
accomodates Stahel-Donoho estimates of multivariate location and scatter.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovSde", ...)</code>,
but the usual way of creating <code>CovSde</code> objects is a call to the function
<code>CovSde</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>iter</code>, <code>crit</code>, <code>wt</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code> class.
</p>
</dd>
<dt><code>call</code>, <code>cov</code>, <code>center</code>,
<code>n.obs</code>, <code>mah</code>, <code>method</code>,
<code>singularity</code>, <code>X</code>:</dt><dd><p>from the <code>"<a href="#topic+Cov-class">Cov</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Cov-class">Cov</a>"</code>, by class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;CovSde&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CovSde">CovSde</a></code>, <code><a href="#topic+Cov-class">Cov-class</a></code>, <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CovSde")
</code></pre>

<hr>
<h2 id='CovSest'> S Estimates of Multivariate Location and Scatter </h2><span id='topic+CovSest'></span>

<h3>Description</h3>

<p>Computes S-Estimates of multivariate location and scatter based on Tukey's
biweight function using a fast algorithm similar to the one proposed by
Salibian-Barrera and Yohai (2006) for the case of regression. Alternativley, the
Ruppert's SURREAL algorithm, bisquare or Rocke type estimation can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    CovSest(x, bdp = 0.5, arp = 0.1, eps = 1e-5, maxiter = 120,
        nsamp = 500, seed = NULL, trace = FALSE, tolSolve = 1e-14,
        scalefn, maxisteps=200, 
        initHsets = NULL, save.hsets = missing(initHsets) || is.null(initHsets),
        method = c("sfast", "surreal", "bisquare", "rocke", "suser", "sdet"), 
        control, t0, S0, initcontrol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovSest_+3A_x">x</code></td>
<td>
<p> a matrix or data frame. </p>
</td></tr>
<tr><td><code id="CovSest_+3A_bdp">bdp</code></td>
<td>
<p>a numeric value specifying the required
breakdown point.  Allowed values are between
<code>(n - p)/(2 * n)</code> and 1 and the default is <code>bdp=0.5</code>.
</p>
</td></tr>
<tr><td><code id="CovSest_+3A_arp">arp</code></td>
<td>
<p>a numeric value specifying the asympthotic
rejection point (for the Rocke type S estimates),
i.e. the fraction of points receiving zero
weight (see Rocke (1996)).  Default is <code>arp=0.1</code>.
</p>
</td></tr>
<tr><td><code id="CovSest_+3A_eps">eps</code></td>
<td>
<p>a numeric value specifying the
relative precision of the solution of the S-estimate
(bisquare and Rocke type). Default is to <code>eps=1e-5</code>.
</p>
</td></tr>
<tr><td><code id="CovSest_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed
in the computation of the S-estimate (bisquare and Rocke type).
Default is <code>maxiter=120</code>.
</p>
</td></tr>
<tr><td><code id="CovSest_+3A_nsamp">nsamp</code></td>
<td>
<p>the number of random subsets considered. The default is different for the different methods: 
(i) for <code>sfast</code> it is <code>nsamp = 20</code>, 
(ii) for <code>surreal</code> it is <code>nsamp = 600*p</code> and 
(iii) for <code>bisquare</code> or  <code>rocke</code> it is <code>nsamp = 500</code>.</p>
</td></tr>
<tr><td><code id="CovSest_+3A_seed">seed</code></td>
<td>
<p>starting value for random generator. Default is <code>seed = NULL</code>.</p>
</td></tr>
<tr><td><code id="CovSest_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code>.</p>
</td></tr>
<tr><td><code id="CovSest_+3A_tolsolve">tolSolve</code></td>
<td>
<p>numeric tolerance to be used for inversion
(<code><a href="base.html#topic+solve">solve</a></code>) of the covariance matrix in
<code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code>.</p>
</td></tr>
<tr><td><code id="CovSest_+3A_scalefn">scalefn</code></td>
<td>
<p><code><a href="base.html#topic+function">function</a></code> to compute a robust scale
estimate or character string specifying a rule determining such a
function. Used for computing the &quot;deterministic&quot; S-estimates (<code>method="sdet"</code>).
If <code>scalefn</code> is missing or is <code>NULL</code>, 
the function is selected depending on the data 
set size, following the recomendation of Hubert et al. (2012) - 
<code><a href="robustbase.html#topic+Qn">Qn</a></code> if <code>n &lt;= 1000</code> and <code><a href="robustbase.html#topic+scaleTau2">scaleTau2</a></code> otherwise.</p>
</td></tr>
<tr><td><code id="CovSest_+3A_maxisteps">maxisteps</code></td>
<td>
<p>maximal number of concentration steps in the
deterministic S-estimates; should not be reached.</p>
</td></tr>
<tr><td><code id="CovSest_+3A_inithsets">initHsets</code></td>
<td>
<p>NULL or a <code class="reqn">K x n</code> integer matrix of initial
subsets of observations of size (specified by the indices in
<code>1:n</code>).</p>
</td></tr>
<tr><td><code id="CovSest_+3A_save.hsets">save.hsets</code></td>
<td>
<p>(for deterministic S-estimates) logical indicating if the
initial subsets should be returned as <code>initHsets</code>.</p>
</td></tr>
<tr><td><code id="CovSest_+3A_method">method</code></td>
<td>
<p> Which algorithm to use: 'sfast'=C implementation of FAST-S, 'surreal'=SURREAL, 
'bisquare', 'rocke'. The method 'suser' currently calls the R implementation of FAST-S 
but in the future will allow the user to supply own <code>rho</code> function.
The method 'sdet' invokes the deterministic algorihm of Hubert et al. (2012).</p>
</td></tr>
<tr><td><code id="CovSest_+3A_control">control</code></td>
<td>
<p> a control object (S4) of class <code><a href="#topic+CovControlSest-class">CovControlSest-class</a></code>
containing estimation options - same as these provided in the fucntion
specification. If the control object is supplied, the parameters from it
will be used. If parameters are passed also in the invocation statement, they will
override the corresponding elements of the control object.</p>
</td></tr>
<tr><td><code id="CovSest_+3A_t0">t0</code></td>
<td>
<p> optional initial HBDP estimate for the center </p>
</td></tr>
<tr><td><code id="CovSest_+3A_s0">S0</code></td>
<td>
<p> optional initial HBDP estimate for the covariance matrix </p>
</td></tr>
<tr><td><code id="CovSest_+3A_initcontrol">initcontrol</code></td>
<td>
<p> optional control object to be used for computing the initial HBDP estimates </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes multivariate S-estimator of location and scatter. The computation will be
performed by one of the following algorithms:
</p>

<dl>
<dt>FAST-S</dt><dd><p>An algorithm similar to the one proposed by Salibian-Barrera and Yohai (2006) for the case of regression</p>
</dd>
<dt>SURREAL</dt><dd><p>Ruppert's SURREAL algorithm when <code>method</code> is set to 'surreal'</p>
</dd>
<dt>BISQUARE</dt><dd><p>Bisquare S-Estimate with <code>method</code> set to 'bisquare'</p>
</dd>
<dt>ROCKE</dt><dd><p>Rocke type S-Estimate with <code>method</code> set to 'rocke'</p>
</dd>
</dl>

<p>Except for the last algorithm, <em>ROCKE</em>, all other use Tukey biweight loss function. 
The tuning parameters used in the loss function (as determined by bdp) are 
returned in the slots <code>cc</code> and <code>kp</code> of the result object. They can be computed 
by the internal function <code>.csolve.bw.S(bdp, p)</code>.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+CovSest-class">CovSest-class</a></code> which is a subclass of the
virtual class <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>,
Matias Salibian-Barrera <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a> and
Victor Yohai <a href="mailto:vyohai@dm.uba.ar">vyohai@dm.uba.ar</a>.  See also the code from
Kristel Joossens, K.U. Leuven, Belgium and Ella Roelant, Ghent University, Belgium.
</p>


<h3>References</h3>

<p>M. Hubert, P. Rousseeuw and T. Verdonck (2012) A deterministic algorithm 
for robust location and scatter.
<em>Journal of Computational and Graphical Statistics</em> <b>21</b>(3), 618&ndash;637.
</p>
<p>M. Hubert, P. Rousseeuw, D. Vanpaemel and T. Verdonck (2015) 
The DetS and DetMM estimators for multivariate location and scatter.
<em>Computational Statistics and Data Analysis</em> <b>81</b>, 64&ndash;75.
</p>
<p>H.P. Lopuhaä (1989) On the Relation between S-estimators and M-estimators of
Multivariate Location and Covariance.
<em>Annals of Statistics</em> <b>17</b> 1662&ndash;1683.
</p>
<p>D. Ruppert (1992) Computing S Estimators for Regression and Multivariate
Location/Dispersion.
<em>Journal of Computational and Graphical Statistics</em> <b>1</b> 253&ndash;270.
</p>
<p>M. Salibian-Barrera and V. Yohai (2006) A fast algorithm for S-regression
estimates, <em>Journal of Computational and Graphical Statistics</em>, <b>15</b>,
414&ndash;427.
</p>
<p>R. A. Maronna, D. Martin and V. Yohai (2006). <em>Robust Statistics: Theory and Methods</em>.
Wiley, New York.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(rrcov)
data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])
cc &lt;- CovSest(hbk.x)
cc

## summry and different types of plots
summary(cc)                         
plot(cc)                            
plot(cc, which="dd")
plot(cc, which="pairs")
plot(cc, which="xydist")

## the following four statements are equivalent
c0 &lt;- CovSest(hbk.x)
c1 &lt;- CovSest(hbk.x, bdp = 0.25)
c2 &lt;- CovSest(hbk.x, control = CovControlSest(bdp = 0.25))
c3 &lt;- CovSest(hbk.x, control = new("CovControlSest", bdp = 0.25))

## direct specification overrides control one:
c4 &lt;- CovSest(hbk.x, bdp = 0.40,
             control = CovControlSest(bdp = 0.25))
c1
summary(c1)
plot(c1)

## Use the SURREAL algorithm of Ruppert
cr &lt;- CovSest(hbk.x, method="surreal")
cr

## Use Bisquare estimation
cr &lt;- CovSest(hbk.x, method="bisquare")
cr

## Use Rocke type estimation
cr &lt;- CovSest(hbk.x, method="rocke")
cr

## Use Deterministic estimation
cr &lt;- CovSest(hbk.x, method="sdet")
cr

</code></pre>

<hr>
<h2 id='CovSest-class'> S Estimates of Multivariate Location and Scatter </h2><span id='topic+CovSest-class'></span>

<h3>Description</h3>

<p> This class, derived from the virtual class <code>"CovRobust"</code>
accomodates S Estimates of multivariate location and scatter computed
by the  &lsquo;Fast S&rsquo; or &lsquo;SURREAL&rsquo; algorithm.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("CovSest", ...)</code>,
but the usual way of creating <code>CovSest</code> objects is a call to the function
<code>CovSest</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>iter</code>, <code>crit</code>, <code>wt</code>:</dt><dd><p>from the
<code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code> class.
</p>
</dd>
<dt><code>iBest</code>, <code>nsteps</code>, <code>initHsets</code>:</dt><dd><p>parameters for 
deterministic S-estimator (the best initial subset, number of concentration 
steps to convergence for each of the initial subsets, and the computed 
initial subsets, respectively).
</p>
</dd>
<dt><code>cc</code>, <code>kp</code></dt><dd><p>tuning parameters used in Tukey biweight 
loss function, as determined by bdp. Can be computed by the internal function 
<code>.csolve.bw.S(bdp, p)</code>.
</p>
</dd>
<dt><code>call</code>, <code>cov</code>, <code>center</code>,
<code>n.obs</code>, <code>mah</code>, <code>method</code>,
<code>singularity</code>, <code>X</code>:</dt><dd><p>from the <code>"<a href="#topic+Cov-class">Cov</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Cov-class">Cov</a>"</code>, by class <code>"<a href="#topic+CovRobust-class">CovRobust</a>"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;CovSest&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CovSest">CovSest</a></code>, <code><a href="#topic+Cov-class">Cov-class</a></code>, <code><a href="#topic+CovRobust-class">CovRobust-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CovSest")
</code></pre>

<hr>
<h2 id='diabetes'>Reaven and Miller diabetes data</h2><span id='topic+diabetes'></span>

<h3>Description</h3>

<p>The data set contains five measurements made on 145 non-obese adult patients classified into three groups.
</p>
<p>The three primary variables are glucose intolerance (area under the straight
line connecting glucose levels), insulin response to oral glucose (area under
the straight line connecting insulin levels) and insulin resistance (measured
by the steady state plasma glucose (SSPG) determined after chemical suppression
of endogenous insulin secretion). Two additional variables, the relative weight
and fasting plasma glucose, are also included.
</p>
<p>Reaven and Miller, following Friedman and Rubin (1967), applied cluster analysis
to the three primary variables and identified three clusters: &quot;normal&quot;,
&quot;chemical diabetic&quot;, and &quot;overt diabetic&quot; subjects. The column <code>group</code>
contains the classifications of the subjects into these three groups,
obtained by current medical criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(diabetes)
</code></pre>


<h3>Format</h3>

<p>A data frame with the following variables:
</p>

<dl>
<dt>rw</dt><dd><p>relative weight, expressed as the ratio of actual weight to expected weight, given the person's height.</p>
</dd>
<dt>fpg</dt><dd><p>fasting plasma glucose level.</p>
</dd>
<dt>glucose</dt><dd><p>area under plasma glucose curve after a three hour oral glucose tolerance test (OGTT).</p>
</dd>
<dt>insulin</dt><dd><p>area under plasma insulin curve after a three hour oral glucose tolerance test (OGTT).</p>
</dd>
<dt>sspg</dt><dd><p>Steady state plasma glucose, a measure of insulin resistance.</p>
</dd>
<dt>group</dt><dd><p>the type of diabetes: a factor with levels <code>normal</code>, <code>chemical</code> and <code>overt</code>.</p>
</dd></dl>



<h3>Source</h3>

<p>Reaven, G. M. and Miller, R. G. (1979). An attempt to define the nature of chemical diabetes using a multidimensional analysis. <em>Diabetologia</em> 16, 17&ndash;24.
Andrews, D. F. and Herzberg, A. M. (1985). <em>Data: A Collection of Problems from Many Fields for the Student and Research Worker</em>, Springer-Verlag, Ch. 36.
</p>


<h3>References</h3>

<p>Reaven, G. M. and Miller, R. G. (1979). An attempt to define the nature of chemical diabetes using a multidimensional analysis. <em>Diabetologia</em> 16, 17&ndash;24.
</p>
<p>Friedman, H. P. and Rubin, J. (1967). On some invariant criteria for grouping
data. <em>Journal of the American Statistical Association</em> <b>62</b>, 1159&ndash;1178.
</p>
<p>Hawkins, D. M. and McLachlan, G. J., 1997. High-breakdown linear
discriminant analysis. <em>Journal of the American Statistical
Association</em> <b>92</b> (437), 136&ndash;143.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(diabetes)
(cc &lt;- Linda(group~insulin+glucose+sspg, data=diabetes))
(pr &lt;- predict(cc))
</code></pre>

<hr>
<h2 id='fish'> Fish Catch Data Set</h2><span id='topic+fish'></span>

<h3>Description</h3>

<p>The Fish Catch data set contains measurements on 159 fish caught in the lake
Laengelmavesi, Finland.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fish)</code></pre>


<h3>Format</h3>

<p>A data frame with 159 observations on the following 7 variables.
</p>

<dl>
<dt><code>Weight</code></dt><dd><p>Weight of the fish (in grams)</p>
</dd>
<dt><code>Length1</code></dt><dd><p>Length from the nose to the beginning of the tail (in cm)</p>
</dd>
<dt><code>Length2</code></dt><dd><p>Length from the nose to the notch of the tail (in cm)</p>
</dd>
<dt><code>Length3</code></dt><dd><p>Length from the nose to the end of the tail (in cm)</p>
</dd>
<dt><code>Height</code></dt><dd><p>Maximal height as % of Length3</p>
</dd>
<dt><code>Width</code></dt><dd><p>Maximal width as % of Length3</p>
</dd>
<dt><code>Species</code></dt><dd><p>Species</p>
</dd>
</dl>



<h3>Details</h3>

<p>The Fish Catch data set contains measurements on 159 fish caught in the lake
Laengelmavesi, Finland. For the 159 fishes of 7 species the weight,
length, height, and width were measured. Three different length
measurements are recorded: from the nose of the fish to the
beginning of its tail, from the nose to the notch of its tail and
from the nose to the end of its tail. The height and width are
calculated as percentages of the third length variable. This results
in 6 observed variables, Weight, Length1, Length2, Length3, Height, Width.
Observation 14 has a missing value in variable Weight, therefore
this observation is usually excluded from the analysis. The last
variable, Species, represents the grouping structure: the 7
species are 1=Bream, 2=Whitewish, 3=Roach, 4=Parkki, 5=Smelt,
6=Pike, 7=Perch. This data set was also analyzed in the context 
of robust Linear Discriminant Analysis by Todorov (2007), 
Todorov and Pires (2007).
</p>


<h3>Source</h3>

<p>Journal of Statistical Education, Fish Catch Data Set,
[https://jse.amstat.org/datasets/fishcatch.dat.txt] accessed
November, 2023.
</p>


<h3>References</h3>

<p>Todorov, V. (2007 Robust selection of variables in linear
discriminant analysis, <em>Statistical Methods and Applications</em>, <b>15</b>,
395&ndash;407, doi:10.1007/s10260-006-0032-6.
</p>
<p>Todorov, V. and Pires, A.M. (2007) Comparative performance of several robust
linear discriminant analysis methods, <em>REVSTAT Statistical Journal</em>, <b>5</b>,
63&ndash;83.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(fish)

    # remove observation #14 containing missing value
    fish &lt;- fish[-14,]

    # The height and width are calculated as percentages 
    #   of the third length variable
    fish[,5] &lt;- fish[,5]*fish[,4]/100
    fish[,6] &lt;- fish[,6]*fish[,4]/100
 
    # plot a matrix of scatterplots
    pairs(fish[1:6],
          main="Fish Catch Data",
          pch=21,
          bg=c("red", "green3", "blue", "yellow", "magenta", "violet", 
          "turquoise")[unclass(fish$Species)])

</code></pre>

<hr>
<h2 id='fruit'>Fruit data set</h2><span id='topic+fruit'></span>

<h3>Description</h3>

<p>A data set that contains the spectra of six different cultivars of
the same fruit (cantaloupe - <em>Cucumis melo</em> L. Cantaloupensis
group) obtained from Colin Greensill (Faculty of Engineering and Physical Systems, Central Queensland
University, Rockhampton, Australia). The total data set contained 2818 spectra measured in 256 wavelengths.
For illustrative purposes are considered only three cultivars out of it, named D, M and
HA with sizes 490, 106 and 500, respectively. Thus the data set thus contains 1096 observations.
For more details about this data set see the references below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fruit)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1096 rows and 257 variables (one grouping variable &ndash; <code>cultivar</code> &ndash; and 256 measurement variables).
</p>


<h3>Source</h3>

<p>Colin Greensill (Faculty of Engineering and Physical Systems, Central Queensland
University, Rockhampton, Australia).
</p>


<h3>References</h3>

<p>Hubert, M. and Van Driessen, K., (2004). Fast and robust discriminant analysis.
<em>Computational Statistics and Data Analysis</em>, <b>45</b>(2):301&ndash;320.
<a href="https://doi.org/10.1016/S0167-9473%2802%2900299-2">doi:10.1016/S0167-9473(02)00299-2</a>.
</p>
<p>Vanden Branden, K and Hubert, M, (2005). Robust classification in high dimensions based on the SIMCA Method.
<em>Chemometrics and Intelligent Laboratory Systems</em>, <b>79</b>(1-2), pp. 10&ndash;21.
<a href="https://doi.org/10.1016/j.chemolab.2005.03.002">doi:10.1016/j.chemolab.2005.03.002</a>.
</p>
<p>Hubert, M, Rousseeuw, PJ and Verdonck, T, (2012). A Deterministic Algorithm for Robust Location and Scatter.
<em>Journal of Computational and Graphical Statistics</em>, <b>21</b>(3), pp 618&ndash;637.
<a href="https://doi.org/10.1080/10618600.2012.672100">doi:10.1080/10618600.2012.672100</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(fruit)
 table(fruit$cultivar)

</code></pre>

<hr>
<h2 id='getCenter-methods'>Accessor methods to the essential slots of Cov and its subclasses</h2><span id='topic+getCenter'></span><span id='topic+getCenter-methods'></span><span id='topic+getCov'></span><span id='topic+getCov-methods'></span><span id='topic+getCorr'></span><span id='topic+getCorr-methods'></span><span id='topic+getData'></span><span id='topic+getData-methods'></span><span id='topic+getDistance'></span><span id='topic+getDistance-methods'></span><span id='topic+getEvals'></span><span id='topic+getEvals-methods'></span><span id='topic+getDet'></span><span id='topic+getDet-methods'></span><span id='topic+getShape'></span><span id='topic+getShape-methods'></span><span id='topic+getFlag'></span><span id='topic+getFlag-methods'></span><span id='topic+getMeth'></span><span id='topic+getMeth-methods'></span><span id='topic+isClassic'></span><span id='topic+isClassic-methods'></span><span id='topic+getRaw'></span><span id='topic+getRaw-methods'></span><span id='topic+names'></span><span id='topic+names-methods'></span><span id='topic+names+2CCov-method'></span><span id='topic++24-methods'></span><span id='topic++24+2CCov-method'></span>

<h3>Description</h3>

<p>Accessor methods to the slots of objects of class<code>Cov</code> and its subclasses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCenter(obj)
getCov(obj)
getCorr(obj)
getData(obj)
getDistance(obj)
getEvals(obj)
getDet(obj)
getShape(obj)
getFlag(obj, prob=0.975)
getMeth(obj)
isClassic(obj)
getRaw(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCenter-methods_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>"Cov"</code>  or of a class derived from <code>"Cov"</code></p>
</td></tr>
<tr><td><code id="getCenter-methods_+3A_prob">prob</code></td>
<td>
<p>optional argument for <code>getFlag</code> - probability, defaults to 0.975</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;Cov&quot;</dt><dd><p>generic functions - see <code>getCenter</code>, <code>getCov</code>, <code>getCorr</code>, <code>getData</code>, <code>getDistance</code>, <code>getEvals</code>, <code>getDet</code>, <code>getShape</code>, <code>getFlag</code>, <code>isClassic</code></p>
</dd>
<dt>obj = &quot;CovRobust&quot;</dt><dd><p>generic functions - see <code>getCenter</code>, <code>getCov</code>, <code>getCorr</code>, <code>getData</code>, <code>getDistance</code>, <code>getEvals</code>, <code>getDet</code>, <code>getShape</code>, <code>getFlag</code>, <code>getMeth</code>, <code>isClassic</code></p>
</dd>
</dl>

<hr>
<h2 id='getEllipse'>Calculates the points for drawing a confidence ellipsoid</h2><span id='topic+getEllipse'></span>

<h3>Description</h3>

<p>A simple function to calculate the points of
a confidence ellipsoid, by default <code>dist=qchisq(0.975, 2)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEllipse(loc = c(0, 0), cov = matrix(c(1, 0, 0, 1), ncol = 2), crit = 0.975)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEllipse_+3A_loc">loc</code></td>
<td>
<p>location vector</p>
</td></tr>
<tr><td><code id="getEllipse_+3A_cov">cov</code></td>
<td>
<p>a <code>pXp</code> covariance matrix</p>
</td></tr>
<tr><td><code id="getEllipse_+3A_crit">crit</code></td>
<td>
<p>the confidence level, default is <code>crit=0.975</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns containing the calculated points.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(hbk)
cc &lt;- cov.wt(hbk)
e1 &lt;- getEllipse(loc=cc$center[1:2], cov=cc$cov[1:2,1:2])
e2 &lt;- getEllipse(loc=cc$center[1:2], cov=cc$cov[1:2,1:2], crit=0.99)
plot(X2~X1, data=hbk,
    xlim=c(min(X1, e1[,1], e2[,1]), max(X1,e1[,1], e2[,1])),
    ylim=c(min(X2, e1[,2], e2[,2]), max(X2,e1[,2], e2[,2])))
lines(e1, type="l", lty=1, col="red")
lines(e2, type="l", lty=2, col="blue")
legend("topleft", legend=c(0.975, 0.99), lty=1:2, col=c("red", "blue"))

</code></pre>

<hr>
<h2 id='getLoadings-methods'> Accessor methods to the essential slots of Pca and its subclasses</h2><span id='topic+getLoadings-methods'></span><span id='topic+getLoadings'></span><span id='topic+getEigenvalues+2Cmethods'></span><span id='topic+getEigenvalues'></span><span id='topic+getPrcomp+2Cmethods'></span><span id='topic+getPrcomp'></span><span id='topic+getScores+2Cmethods'></span><span id='topic+getScores'></span><span id='topic+getSdev+2Cmethods'></span><span id='topic+getSdev'></span><span id='topic+getQuan+2Cmethods'></span><span id='topic+getQuan'></span><span id='topic+getScale+2Cmethods'></span><span id='topic+getScale'></span><span id='topic+names+2CPca-method'></span><span id='topic++24+2CPca-method'></span>

<h3>Description</h3>

<p>Accessor methods to the slots of objects of class <code>Pca</code> and its subclasses
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLoadings-methods_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>"Pca"</code>  or of a class derived from <code>"Pca"</code> </p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;Pca&quot;</dt><dd><p>Accessors for object of class <code>Pca</code></p>
</dd>
<dt>obj = &quot;PcaRobust&quot;</dt><dd><p>Accessors for object of class <code>PcaRobust</code></p>
</dd>
<dt>obj = &quot;PcaClassic&quot;</dt><dd><p>Accessors for object of class <code>PcaClassic</code></p>
</dd>
</dl>

<hr>
<h2 id='hemophilia'> Hemophilia Data
</h2><span id='topic+hemophilia'></span>

<h3>Description</h3>

<p>The hemophilia data set contains two measured variables on 
75 women, belonging to two groups: n1=30 of them are 
non-carriers (normal group) and n2=45 are known hemophilia 
A carriers (obligatory carriers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hemophilia)</code></pre>


<h3>Format</h3>

<p>A data frame with 75 observations on the following 3 variables.
</p>

<dl>
<dt><code>AHFactivity</code></dt><dd><p>AHF activity</p>
</dd>
<dt><code>AHFantigen</code></dt><dd><p>AHF antigen</p>
</dd>
<dt><code>gr</code></dt><dd><p>group - normal or obligatory carrier</p>
</dd>
</dl>



<h3>Details</h3>

<p>Originally analized in the context of discriminant 
analysis by Habemma and Hermans (1974). The objective 
is to find a procedure for detecting potential hemophilia A 
carriers on the basis of two measured variables: X1=log10(AHV activity) and
X2=log10(AHV-like antigen). The first group of n1=30 women consists
of known non-carriers (normal group) and the second group of n2=45
women is selected from known hemophilia A carriers (obligatory
carriers). This data set was also analyzed by Johnson and Wichern
(1998) as well as, in the context of robust Linear Discriminant Analysis 
by Hawkins and McLachlan (1997) and Hubert and Van Driessen (2004).
</p>


<h3>Source</h3>

<p>Habemma, J.D.F, Hermans, J. and van den Broek, K. (1974) 
Stepwise Discriminant Analysis Program Using Density 
Estimation in <em>Proceedings in Computational statistics, COMPSTAT'1974</em>
(Physica Verlag, Heidelberg, 1974, pp 101&ndash;110).
</p>


<h3>References</h3>

<p>Johnson, R.A. and Wichern, D. W. <em>Applied Multivariate
Statistical Analysis</em> (Prentice Hall, International
Editions, 2002, fifth edition)
</p>
<p>Hawkins, D. M. and McLachlan, G.J. (1997) 
High-Breakdown Linear Discriminant Analysis
<em>J. Amer. Statist. Assoc.</em> <b>92</b> 136&ndash;143. 
</p>
<p>Hubert, M., Van Driessen, K. (2004) Fast and robust discriminant analysis,
<em>Computational Statistics and Data Analysis</em>, <b>45</b>
301&ndash;320.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hemophilia)
plot(AHFantigen~AHFactivity, data=hemophilia, col=as.numeric(as.factor(gr))+1)
##
## Compute robust location and covariance matrix and 
## plot the tolerance ellipses
(mcd &lt;- CovMcd(hemophilia[,1:2]))
col &lt;- ifelse(hemophilia$gr == "carrier", 2, 3) ## define clours for the groups
plot(mcd, which="tolEllipsePlot", class=TRUE, col=col)

</code></pre>

<hr>
<h2 id='ionosphere'>Johns Hopkins University Ionosphere database.</h2><span id='topic+ionosphere'></span>

<h3>Description</h3>

<p>&rdquo;This radar data was collected by a system in Goose Bay, Labrador.  This
system consists of a phased array of 16 high-frequency antennas with a
total transmitted power on the order of 6.4 kilowatts.  The targets
were free electrons in the ionosphere.
&quot;good&quot; radar returns are those showing evidence of some type of structure
in the ionosphere.  &quot;bad&quot; returns are those that do not; their signals pass
through the ionosphere.
Received signals were processed using an autocorrelation function whose
arguments are the time of a pulse and the pulse number.  There were 17
described by 2 attributes per pulse number, corresponding to the complex
values returned by the function resulting from the complex electromagnetic
signal.&rdquo; [UCI archive]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ionosphere)
</code></pre>


<h3>Format</h3>

<p>A data frame with 351 rows and 33 variables: 32 measurements and one
(the last, <code>Class</code>) grouping variable: 225 <code>'good'</code> and 126 <code>'bad'</code>.
</p>
<p>The original dataset at UCI contains 351 rows and 35 columns. The first 34
columns are features, the last column contains the classification label of
'g' and 'b'. The first feature is binary and the second one is only 0s,
one grouping variable - factor with labels 'good' and 'bad'.
</p>


<h3>Source</h3>

<p>Source: Space Physics Group; Applied Physics Laboratory; Johns Hopkins University; Johns Hopkins Road; Laurel; MD 20723
</p>
<p>Donor: Vince Sigillito (vgs@aplcen.apl.jhu.edu)
</p>
<p>The data have been taken from the UCI Repository Of Machine Learning Databases at
<a href="https://archive.ics.uci.edu/ml/datasets/ionosphere">https://archive.ics.uci.edu/ml/datasets/ionosphere</a>
</p>
<p>This data set, with the original 34 features is available in the package <span class="pkg">mlbench</span>
and a different data set (refering to the same UCI repository) is available in
the package <code>dprep</code> (archived on CRAN).
</p>


<h3>References</h3>

<p>Sigillito, V. G., Wing, S. P., Hutton, L. V., and Baker, K. B. (1989).
Classification of radar returns from the ionosphere using neural
networks. Johns Hopkins APL Technical Digest, 10, 262-266.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(ionosphere)
 ionosphere[, 1:6] |&gt; pairs()
</code></pre>

<hr>
<h2 id='isSingular-methods'>
Check if a covariance matrix (object of class 'Cov') is singular 
</h2><span id='topic+isSingular'></span><span id='topic+isSingular-methods'></span><span id='topic+isSingular+2CANY-method'></span><span id='topic+isSingular+2CCov-method'></span>

<h3>Description</h3>

<p>Returns TRUE if the covariance matrix contained in a <code><a href="#topic+Cov-class">Cov-class</a></code> object (or derived from) is singular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S4 method for signature 'Cov'
isSingular(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isSingular-methods_+3A_obj">obj</code></td>
<td>
<p>an object of class (derived from) <code>"Cov"</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>isSingular</dt><dd><p><code>signature(x = Cov)</code>: Check if a covariance matrix 
(object of class <code><a href="#topic+Cov-class">Cov-class</a></code>) is singular.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Cov-class">Cov-class</a></code>,
<code><a href="#topic+CovClassic">CovClassic</a></code>,
<code><a href="#topic+CovRobust-class">CovRobust-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(hbk)
cc &lt;- CovClassic(hbk)
isSingular(cc)
</code></pre>

<hr>
<h2 id='Lda-class'>Class &quot;Lda&quot; - virtual base class for all classic and robust LDA classes 
</h2><span id='topic+Lda-class'></span><span id='topic+predict+2CLda-method'></span><span id='topic+show+2CLda-method'></span><span id='topic+summary+2CLda-method'></span>

<h3>Description</h3>

<p> The class <code>Lda</code> serves as a base class for deriving 
all other classes representing the results of classical 
and robust Linear Discriminant Analisys methods </p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>the (matched) function call.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p>prior probabilities used, default to group proportions</p>
</dd>
<dt><code>counts</code>:</dt><dd><p>number of observations in each class</p>
</dd>
<dt><code>center</code>:</dt><dd><p>the group means</p>
</dd>
<dt><code>cov</code>:</dt><dd><p>the common covariance matrix</p>
</dd>
<dt><code>ldf</code>:</dt><dd><p>a matrix containing the linear discriminant functions</p>
</dd>
<dt><code>ldfconst</code>:</dt><dd><p>a vector containing the constants of each linear discriminant function</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a character string giving the estimation method used</p>
</dd>
<dt><code>X</code>:</dt><dd><p>the training data set (same as the input parameter x of the constructor function)</p>
</dd>
<dt><code>grp</code>:</dt><dd><p>grouping variable:  a factor specifying the class for each observation.</p>
</dd>   
<dt><code>covobj</code>:</dt><dd><p>object of class <code>"Cov"</code> containing the estimate 
of the common covariance matrix of the centered data. It is not NULL 
only in case of method &quot;B&quot;.</p>
</dd> 
<dt><code>control</code>:</dt><dd><p>object of class <code>"CovControl"</code> specifying which estimate 
and with what estimation options to use for the group means and common covariance 
(or <code>NULL</code> for classical linear discriminant analysis)</p>
</dd>   
</dl>



<h3>Methods</h3>


<dl>
<dt>predict</dt><dd><p><code>signature(object = "Lda")</code>: calculates prediction using the results in 
<code>object</code>. An optional data frame or matrix in which to look for variables with which 
to predict. If omitted, the training data set is used. If the original fit used a formula or 
a data frame or a matrix with column names, newdata must contain columns with the 
same names. Otherwise it must contain the same number of columns, 
to be used in the same order. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Lda")</code>: prints the results </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "Lda")</code>: prints summary information </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LdaClassic">LdaClassic</a></code>, <code><a href="#topic+LdaClassic-class">LdaClassic-class</a></code>, <code><a href="#topic+LdaRobust-class">LdaRobust-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Lda")
</code></pre>

<hr>
<h2 id='LdaClassic'> Linear Discriminant Analysis </h2><span id='topic+LdaClassic'></span><span id='topic+LdaClassic.formula'></span><span id='topic+LdaClassic.default'></span>

<h3>Description</h3>

<p>Performs a linear discriminant analysis and returns the results as an object of class <code>LdaClassic</code> (aka constructor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LdaClassic(x, ...)

## Default S3 method:
LdaClassic(x, grouping, prior = proportions, tol = 1.0e-4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LdaClassic_+3A_x">x</code></td>
<td>
<p>a matrix or data frame containing the explanatory variables (training set). </p>
</td></tr>
<tr><td><code id="LdaClassic_+3A_grouping">grouping</code></td>
<td>
<p>grouping variable:  a factor specifying the class for each observation.</p>
</td></tr>
<tr><td><code id="LdaClassic_+3A_prior">prior</code></td>
<td>
<p>prior probabilities, default to the class proportions for the training set.</p>
</td></tr>
<tr><td><code id="LdaClassic_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="LdaClassic_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an S4 object of class <code>LdaClassic</code>
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lda-class">Lda-class</a></code>, <code><a href="#topic+LdaClassic-class">LdaClassic-class</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example anorexia
library(MASS)
data(anorexia)

## rrcov: LdaClassic()
lda &lt;- LdaClassic(Treat~., data=anorexia)
predict(lda)@classification

## MASS: lda()
lda.MASS &lt;- lda(Treat~., data=anorexia)
predict(lda.MASS)$class

## Compare the prediction results of MASS:::lda() and LdaClassic()
all.equal(predict(lda)@classification, predict(lda.MASS)$class)
</code></pre>

<hr>
<h2 id='LdaClassic-class'>Class &quot;LdaClassic&quot; - Linear Discriminant Analysis </h2><span id='topic+LdaClassic-class'></span>

<h3>Description</h3>

<p> Contains the results of a classical Linear Discriminant Analysis </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("LdaClassic", ...)</code> but the 
usual way of creating <code>LdaClassic</code> objects is a call to the function
<code>LdaClassic</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>The (matched) function call.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p>Prior probabilities used, default to group proportions</p>
</dd>
<dt><code>counts</code>:</dt><dd><p>number of observations in each class</p>
</dd>
<dt><code>center</code>:</dt><dd><p>the group means</p>
</dd>
<dt><code>cov</code>:</dt><dd><p>the common covariance matrix</p>
</dd>
<dt><code>ldf</code>:</dt><dd><p>a matrix containing the linear discriminant functions</p>
</dd>
<dt><code>ldfconst</code>:</dt><dd><p>a vector containing the constants of each linear discriminant function</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a character string giving the estimation method used</p>
</dd>
<dt><code>X</code>:</dt><dd><p>the training data set (same as the input parameter x of the constructor function)</p>
</dd>
<dt><code>grp</code>:</dt><dd><p>grouping variable:  a factor specifying the class for each observation.</p>
</dd>   
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Lda-class">Lda</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;LdaClassic&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LdaRobust-class">LdaRobust-class</a></code>, <code><a href="#topic+Lda-class">Lda-class</a></code>, <code><a href="#topic+LdaClassic">LdaClassic</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("LdaClassic")
</code></pre>

<hr>
<h2 id='LdaPP'> Robust Linear Discriminant Analysis by Projection Pursuit</h2><span id='topic+LdaPP'></span><span id='topic+LdaPP.formula'></span><span id='topic+LdaPP.default'></span>

<h3>Description</h3>

<p>Performs robust linear discriminant analysis by the projection-pursuit approach -
proposed by Pires and Branco (2010) - and returns the results as an object of
class <code>LdaPP</code> (aka constructor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LdaPP(x, ...)
## S3 method for class 'formula'
LdaPP(formula, data, subset, na.action, ...)
## Default S3 method:
LdaPP(x, grouping, prior = proportions, tol = 1.0e-4,
                 method = c("huber", "mad", "sest", "class"),
                 optim = FALSE,
                 trace=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LdaPP_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>y~x</code>, it describes the response
and the predictors. The formula can be more complicated, such as
<code>y~log(x)+z</code> etc (see <code><a href="stats.html#topic+formula">formula</a></code> for more details).
The response should
be a factor representing the response variable, or any vector
that can be coerced to such (such as a logical variable).</p>
</td></tr>
<tr><td><code id="LdaPP_+3A_data">data</code></td>
<td>
<p>an optional data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.</p>
</td></tr>
<tr><td><code id="LdaPP_+3A_subset">subset</code></td>
<td>
<p>an optional vector used to select rows (observations) of the
data matrix <code>x</code>.</p>
</td></tr>
<tr><td><code id="LdaPP_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset. The default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.</p>
</td></tr>
<tr><td><code id="LdaPP_+3A_x">x</code></td>
<td>
<p>a matrix or data frame containing the explanatory variables (training set). </p>
</td></tr>
<tr><td><code id="LdaPP_+3A_grouping">grouping</code></td>
<td>
<p>grouping variable:  a factor specifying the class for each observation.</p>
</td></tr>
<tr><td><code id="LdaPP_+3A_prior">prior</code></td>
<td>
<p>prior probabilities, default to the class proportions for the training set.</p>
</td></tr>
<tr><td><code id="LdaPP_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="LdaPP_+3A_method">method</code></td>
<td>
<p>method</p>
</td></tr>
<tr><td><code id="LdaPP_+3A_optim">optim</code></td>
<td>
<p>wheather to perform the approximation using the Nelder and Mead simplex method
(see function <code>optim()</code> from package <code>stats</code>). Default is <code>optim = FALSE</code></p>
</td></tr>
<tr><td><code id="LdaPP_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code>.</p>
</td></tr>
<tr><td><code id="LdaPP_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the algorithm is implemented only for binary classification
and in the following will be assumed that only two groups are present.
</p>
<p>The PP algorithm searches for low-dimensional projections of higher-dimensional
data where a projection index is maximized. Similar to the original Fisher's proposal
the squared standardized distance between the observations in the two groups is maximized.
Instead of the sample univariate mean and standard deviation <code>(T,S)</code> robust
alternatives are used. These are selected through the argument <code>method</code> and can be one of
</p>

<dl>
<dt>huber</dt><dd><p>the pair <code>(T,S)</code> are the robust M-estimates of location and scale</p>
</dd>
<dt>mad</dt><dd><p><code>(T,S)</code> are the Median and the Median Absolute Deviation</p>
</dd>
<dt>sest</dt><dd><p>the pair <code>(T,S)</code> are the robust S-estimates of location and scale</p>
</dd>
<dt>class</dt><dd><p><code>(T,S)</code> are the mean and the standard deviation.</p>
</dd>
</dl>

<p>The first approximation <em>A1</em> to the solution is obtained by investigating
a finite number of candidate directions, the unit vectors defined
by all pairs of points such that one belongs to the first group
and the other to the second group. The found solution is stored in the slots
<code>raw.ldf</code> and <code>raw.ldfconst</code>.
</p>
<p>The second approximation <em>A2</em> (optional) is performed by
a numerical optimization algorithm using <em>A1</em> as initial solution.
The Nelder and Mead method implemented in the function <code><a href="stats.html#topic+optim">optim</a></code> is applied.
Whether this refinement will be used is controlled by the argument <code>optim</code>.
If <code>optim=TRUE</code> the result of the optimization is stored into the slots
<code>ldf</code> and <code>ldfconst</code>. Otherwise these slots are set equal to
<code>raw.ldf</code> and <code>raw.ldfconst</code>.
</p>


<h3>Value</h3>

<p>Returns an S4 object of class <code><a href="#topic+LdaPP-class">LdaPP-class</a></code>
</p>


<h3>Warning </h3>

<p>Still an experimental version! Only binary classification is supported.</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> and
Ana Pires <a href="mailto:apires@math.ist.utl.pt">apires@math.ist.utl.pt</a>
</p>


<h3>References</h3>

<p>Pires, A. M. and A. Branco, J. (2010)
Projection-pursuit approach to robust linear discriminant analysis
<em>Journal Multivariate Analysis</em>, Academic Press, Inc., <b>101</b>, 2464&ndash;2485.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+Linda">Linda</a></code>, <code><a href="#topic+LdaClassic">LdaClassic</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
## Function to plot a LDA separation line
##
lda.line &lt;- function(lda, ...)
{
    ab &lt;- lda@ldf[1,] - lda@ldf[2,]
    cc &lt;- lda@ldfconst[1] - lda@ldfconst[2]
    abline(a=-cc/ab[2], b=-ab[1]/ab[2],...)
}

data(pottery)
x &lt;- pottery[,c("MG", "CA")]
grp &lt;- pottery$origin
col &lt;- c(3,4)
gcol &lt;- ifelse(grp == "Attic", col[1], col[2])
gpch &lt;- ifelse(grp == "Attic", 16, 1)

##
## Reproduce Fig. 2. from Pires and branco (2010)
##
plot(CA~MG, data=pottery, col=gcol, pch=gpch)

## Not run: 

ppc &lt;- LdaPP(x, grp, method="class", optim=TRUE)
lda.line(ppc, col=1, lwd=2, lty=1)

pph &lt;- LdaPP(x, grp, method="huber",optim=TRUE)
lda.line(pph, col=3, lty=3)

pps &lt;- LdaPP(x, grp, method="sest", optim=TRUE)
lda.line(pps, col=4, lty=4)

ppm &lt;- LdaPP(x, grp, method="mad", optim=TRUE)
lda.line(ppm, col=5, lty=5)

rlda &lt;- Linda(x, grp, method="mcd")
lda.line(rlda, col=6, lty=1)

fsa &lt;- Linda(x, grp, method="fsa")
lda.line(fsa, col=8, lty=6)

## Use the formula interface:
##
LdaPP(origin~MG+CA, data=pottery)       ## use the same two predictors
LdaPP(origin~., data=pottery)           ## use all predictor variables

##
## Predict method
data(pottery)
fit &lt;- LdaPP(origin~., data = pottery)
predict(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='LdaPP-class'>Class &quot;LdaPP&quot; - Robust method for Linear Discriminant Analysis by Projection-pursuit</h2><span id='topic+LdaPP-class'></span><span id='topic+predict+2CLdaPP-method'></span>

<h3>Description</h3>

 
<p>The class <code>LdaPP</code> represents an algorithm for robust linear discriminant 
analysis by projection-pursuit approach. The objects of class <code>LdaPP</code> contain the results
of the robust linear discriminant analysis by projection-pursuit approach.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("LdaPP", ...)</code> but the 
usual way of creating <code>LdaPP</code> objects is a call to the function
<code>LdaPP</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>The (matched) function call.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p>Prior probabilities used, default to group proportions</p>
</dd>
<dt><code>counts</code>:</dt><dd><p>number of observations in each class</p>
</dd>
<dt><code>center</code>:</dt><dd><p>the group means</p>
</dd>
<dt><code>cov</code>:</dt><dd><p>the common covariance matrix</p>
</dd>
<dt><code>raw.ldf</code>:</dt><dd><p>a matrix containing the raw linear discriminant functions - see Details in <code><a href="#topic+LdaPP">LdaPP</a></code></p>
</dd>
<dt><code>raw.ldfconst</code>:</dt><dd><p>a vector containing the raw constants of each raw linear discriminant function - see Details in <code><a href="#topic+LdaPP">LdaPP</a></code></p>
</dd>
<dt><code>ldf</code>:</dt><dd><p>a matrix containing the linear discriminant functions</p>
</dd>
<dt><code>ldfconst</code>:</dt><dd><p>a vector containing the constants of each linear discriminant function</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a character string giving the estimation method used</p>
</dd>
<dt><code>X</code>:</dt><dd><p>the training data set (same as the input parameter x of the constructor function)</p>
</dd>
<dt><code>grp</code>:</dt><dd><p>grouping variable:  a factor specifying the class for each observation.</p>
</dd>   
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+LdaRobust-class">LdaRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Lda-class">Lda</a>"</code>, by class &quot;LdaRobust&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>predict</dt><dd><p><code>signature(object = "LdaPP")</code>: calculates prediction using the results in 
<code>object</code>. An optional data frame or matrix in which to look for variables with which 
to predict. If omitted, the training data set is used. If the original fit used a formula or 
a data frame or a matrix with column names, newdata must contain columns with the 
same names. Otherwise it must contain the same number of columns, 
to be used in the same order. If the argument <code>raw=TRUE</code> is set the raw 
(obtained by the first approximation algorithm) linear discriminant 
function and constant will be used.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> and
Ana Pires <a href="mailto:apires@math.ist.utl.pt">apires@math.ist.utl.pt</a> 
</p>


<h3>References</h3>

<p>Pires, A. M. and A. Branco, J. (2010)
Projection-pursuit approach to robust linear discriminant analysis
<em>Journal Multivariate Analysis</em>, Academic Press, Inc., <b>101</b>, 2464&ndash;2485.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LdaRobust-class">LdaRobust-class</a></code>, <code><a href="#topic+Lda-class">Lda-class</a></code>, 
<code><a href="#topic+LdaClassic">LdaClassic</a></code>, <code><a href="#topic+LdaClassic-class">LdaClassic-class</a></code>, 
<code><a href="#topic+Linda">Linda</a></code>, <code><a href="#topic+Linda-class">Linda-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("LdaPP")
</code></pre>

<hr>
<h2 id='LdaRobust-class'>Class &quot;LdaRobust&quot; is a virtual base class for all robust LDA classes </h2><span id='topic+LdaRobust-class'></span>

<h3>Description</h3>

<p> The class <code>LdaRobust</code> searves as a base class for deriving all other 
classes representing the results of the robust Linear Discriminant Analysis methods</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>The (matched) function call.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p>Prior probabilities used, default to group proportions</p>
</dd>
<dt><code>counts</code>:</dt><dd><p>number of observations in each class</p>
</dd>
<dt><code>center</code>:</dt><dd><p>the group means</p>
</dd>
<dt><code>cov</code>:</dt><dd><p>the common covariance matrix</p>
</dd>
<dt><code>ldf</code>:</dt><dd><p>a matrix containing the linear discriminant functions</p>
</dd>
<dt><code>ldfconst</code>:</dt><dd><p>a vector containing the constants of each linear discriminant function</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a character string giving the estimation method used</p>
</dd>
<dt><code>X</code>:</dt><dd><p>the training data set (same as the input parameter x of the constructor function)</p>
</dd>
<dt><code>grp</code>:</dt><dd><p>grouping variable:  a factor specifying the class for each observation.</p>
</dd>   
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Lda-class">Lda</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;LdaRobust&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lda-class">Lda-class</a></code>, <code><a href="#topic+LdaClassic-class">LdaClassic-class</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("LdaRobust")
</code></pre>

<hr>
<h2 id='Linda'> Robust Linear Discriminant Analysis </h2><span id='topic+Linda'></span><span id='topic+Linda.formula'></span><span id='topic+Linda.default'></span>

<h3>Description</h3>

<p>Robust linear discriminant analysis based on MCD and returns
the results as an object of class <code>Linda</code> (aka constructor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Linda(x, ...)

## Default S3 method:
Linda(x, grouping, prior = proportions, tol = 1.0e-4,
                 method = c("mcd", "mcdA", "mcdB", "mcdC", "fsa", "mrcd", "ogk"),
                 alpha=0.5, l1med=FALSE, cov.control, trace=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Linda_+3A_x">x</code></td>
<td>
<p>a matrix or data frame containing the explanatory variables (training set). </p>
</td></tr>
<tr><td><code id="Linda_+3A_grouping">grouping</code></td>
<td>
<p>grouping variable:  a factor specifying the class for each observation.</p>
</td></tr>
<tr><td><code id="Linda_+3A_prior">prior</code></td>
<td>
<p>prior probabilities, default to the class proportions for the training set.</p>
</td></tr>
<tr><td><code id="Linda_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="Linda_+3A_method">method</code></td>
<td>
<p>method</p>
</td></tr>
<tr><td><code id="Linda_+3A_alpha">alpha</code></td>
<td>
<p>this parameter measures the fraction of outliers the algorithm should
resist. In MCD alpha controls the size of the subsets over which the
determinant is minimized, i.e. alpha*n observations are used for
computing the determinant. Allowed values are between 0.5 and 1
and the default is 0.5.</p>
</td></tr>
<tr><td><code id="Linda_+3A_l1med">l1med</code></td>
<td>
<p>whether to use L1 median (space median) instead of MCD to compute
the group means locations in order to center the data in methods <code>mcdB</code> and <code>mcdC</code>. 
useful in case of groups with small size. Default is <code>l1med = FALSE</code>.</p>
</td></tr>
<tr><td><code id="Linda_+3A_cov.control">cov.control</code></td>
<td>
<p>specifies which covariance estimator to use by providing 
a <code><a href="#topic+CovControl-class">CovControl-class</a></code> object. 
The default is <code><a href="#topic+CovControlMcd-class">CovControlMcd-class</a></code> which will 
indirectly call <code><a href="#topic+CovMcd">CovMcd</a></code>. 
If <code>cov.control=NULL</code> is specified, the classical estimates 
will be used by calling <code><a href="#topic+CovClassic">CovClassic</a></code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="Linda_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code>.</p>
</td></tr>
<tr><td><code id="Linda_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>details
</p>


<h3>Value</h3>

<p>Returns an S4 object of class <code>Linda</code>
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Hawkins, D.M. and McLachlan, G.J. (1997) High-Breakdown Linear Discriminant Analysis,
<em>Journal of the American Statistical Association</em>, <b>92</b>, 136&ndash;143.
</p>
<p>Todorov V. (2007) Robust selection of variables in linear discriminant analysis,
<em>Statistical Methods and Applications</em>, <b>15</b>, 395&ndash;407, doi:10.1007/s10260-006-0032-6.
</p>
<p>Todorov, V. and Pires, A.M. (2007) Comparative Performance of Several Robust
Linear Discriminant Analysis Methods.
<em>REVSTAT Statistical Journal</em>, <b>5</b>, p 63&ndash;83.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+CovMcd">CovMcd</a></code>, <code><a href="#topic+CovMrcd">CovMrcd</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example anorexia
library(MASS)
data(anorexia)

## start with the classical estimates
lda &lt;- LdaClassic(Treat~., data=anorexia)
predict(lda)@classification

## try now the robust LDA with the default method (MCD with pooled whitin cov matrix)
rlda &lt;- Linda(Treat~., data= anorexia)
predict(rlda)@classification

## try the other methods
Linda(Treat~., data= anorexia, method="mcdA")
Linda(Treat~., data= anorexia, method="mcdB")
Linda(Treat~., data= anorexia, method="mcdC")

## try the Hawkins&amp;McLachlan method
## use the default method
grp &lt;- anorexia[,1]
grp &lt;- as.factor(grp)
x &lt;- anorexia[,2:3]
Linda(x, grp, method="fsa")

## Do DA with Linda and method mcdB or mcdC, when some classes
## have very few observations. Use L1 median instead of MCD
##  to compute the group means (l1med=TRUE).

data(fish)

# remove observation #14 containing missing value
fish &lt;- fish[-14,]

# The height and width are calculated as percentages 
#   of the third length variable
fish[,5] &lt;- fish[,5]*fish[,4]/100
fish[,6] &lt;- fish[,6]*fish[,4]/100

table(fish$Species) 
Linda(Species~., data=fish, l1med=TRUE)
Linda(Species~., data=fish, method="mcdC", l1med=TRUE)

</code></pre>

<hr>
<h2 id='Linda-class'>Class &quot;Linda&quot; - Robust method for LINear Discriminant Analysis </h2><span id='topic+Linda-class'></span>

<h3>Description</h3>

 
<p>Robust linear discriminant analysis is performed by replacing the classical 
group means and withing group covariance matrix by robust equivalents 
based on MCD. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Linda", ...)</code> but the 
usual way of creating <code>Linda</code> objects is a call to the function
<code>Linda</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>The (matched) function call.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p>Prior probabilities used, default to group proportions</p>
</dd>
<dt><code>counts</code>:</dt><dd><p>number of observations in each class</p>
</dd>
<dt><code>center</code>:</dt><dd><p>the group means</p>
</dd>
<dt><code>cov</code>:</dt><dd><p>the common covariance matrix</p>
</dd>
<dt><code>ldf</code>:</dt><dd><p>a matrix containing the linear discriminant functions</p>
</dd>
<dt><code>ldfconst</code>:</dt><dd><p>a vector containing the constants of each linear discriminant function</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a character string giving the estimation method used</p>
</dd>
<dt><code>X</code>:</dt><dd><p>the training data set (same as the input parameter x of the constructor function)</p>
</dd>
<dt><code>grp</code>:</dt><dd><p>grouping variable:  a factor specifying the class for each observation.</p>
</dd>   
<dt><code>l1med</code>:</dt><dd><p>wheather L1 median was used to compute group means.</p>
</dd>   
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+LdaRobust-class">LdaRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Lda-class">Lda</a>"</code>, by class &quot;LdaRobust&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;Linda&quot; in the signature.</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LdaRobust-class">LdaRobust-class</a></code>, <code><a href="#topic+Lda-class">Lda-class</a></code>, <code><a href="#topic+LdaClassic">LdaClassic</a></code>, <code><a href="#topic+LdaClassic-class">LdaClassic-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Linda")
</code></pre>

<hr>
<h2 id='lmom32'> Hosking and Wallis Data Set, Table 3.2</h2><span id='topic+lmom32'></span>

<h3>Description</h3>

<p>The data on annual maximum streamflow at 18 sites with smallest
drainage area basin in southeastern USA contains the sample
L-moments ratios (L-CV, L-skewness and L-kurtosis) as
used by Hosking and Wallis (1997) to illustrate the discordancy measure
in regional freqency analysis (RFA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lmom32)</code></pre>


<h3>Format</h3>

<p>A data frame with 18 observations on the following 3 variables.
</p>

<dl>
<dt><code>L-CV</code></dt><dd><p>L-coefficient of variation</p>
</dd>
<dt><code>L-skewness</code></dt><dd><p>L-coefficient of skewness</p>
</dd>
<dt><code>L-kurtosis</code></dt><dd><p>L-coefficient of kurtosis</p>
</dd>
</dl>



<h3>Details</h3>

<p>The sample L-moment ratios (L-CV, L-skewness and L-kurtosis) of a
site are regarded as a point in three dimensional space.
</p>


<h3>Source</h3>

<p>Hosking, J. R. M. and J. R. Wallis (1997), <em>Regional Frequency Analysis: An
Approach Based on L-moments.</em> Cambridge University Press, p.49, Table 3.2
</p>


<h3>References</h3>

<p>Neykov, N.M., Neytchev, P.N., Van Gelder, P.H.A.J.M. and Todorov V. (2007),
Robust detection of discordant sites in regional frequency analysis,
<em>Water Resources Research</em>, 43, W06417, doi:10.1029/2006WR005322
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(lmom32)

    # plot a matrix of scatterplots
    pairs(lmom32,
          main="Hosking and Wallis Data Set, Table 3.3",
          pch=21,
          bg=c("red", "green3", "blue"))

    mcd&lt;-CovMcd(lmom32)
    mcd
    plot(mcd, which="dist", class=TRUE)
    plot(mcd, which="dd", class=TRUE)

    ##  identify the discordant sites using robust distances and compare 
    ##  to the classical ones
    mcd &lt;- CovMcd(lmom32)
    rd &lt;- sqrt(getDistance(mcd))
    ccov &lt;- CovClassic(lmom32)
    cd &lt;- sqrt(getDistance(ccov))
    r.out &lt;- which(rd &gt; sqrt(qchisq(0.975,3)))
    c.out &lt;- which(cd &gt; sqrt(qchisq(0.975,3)))
    cat("Robust: ", length(r.out), " outliers: ", r.out,"\n")
    cat("Classical: ", length(c.out), " outliers: ", c.out,"\n")
</code></pre>

<hr>
<h2 id='lmom33'> Hosking and Wallis Data Set, Table 3.3</h2><span id='topic+lmom33'></span>

<h3>Description</h3>

<p>The data on annual maximum streamflow at 17 sites with largest
drainage area basins in southeastern USA contains the sample
L-moments ratios (L-CV, L-skewness and L-kurtosis) as
used by Hosking and Wallis (1997) to illustrate the discordancy measure
in regional freqency analysis (RFA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lmom33)</code></pre>


<h3>Format</h3>

<p>A data frame with 17 observations on the following 3 variables.
</p>

<dl>
<dt><code>L-CV</code></dt><dd><p>L-coefficient of variation</p>
</dd>
<dt><code>L-skewness</code></dt><dd><p>L-coefficient of skewness</p>
</dd>
<dt><code>L-kurtosis</code></dt><dd><p>L-coefficient of kurtosis</p>
</dd>
</dl>



<h3>Details</h3>

<p>The sample L-moment ratios (L-CV, L-skewness and L-kurtosis) of a
site are regarded as a point in three dimensional space.
</p>


<h3>Source</h3>

<p>Hosking, J. R. M. and J. R. Wallis (1997), <em>Regional Frequency Analysis: An
Approach Based on L-moments.</em> Cambridge University Press, p.51, Table 3.3
</p>


<h3>References</h3>

<p>Neykov, N.M., Neytchev, P.N., Van Gelder, P.H.A.J.M. and Todorov V. (2007),
Robust detection of discordant sites in regional frequency analysis,
<em>Water Resources Research</em>, 43, W06417, doi:10.1029/2006WR005322
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(lmom33)

    # plot a matrix of scatterplots
    pairs(lmom33,
          main="Hosking and Wallis Data Set, Table 3.3",
          pch=21,
          bg=c("red", "green3", "blue"))

    mcd&lt;-CovMcd(lmom33)
    mcd
    plot(mcd, which="dist", class=TRUE)
    plot(mcd, which="dd", class=TRUE)

    ##  identify the discordant sites using robust distances and compare 
    ##  to the classical ones
    mcd &lt;- CovMcd(lmom33)
    rd &lt;- sqrt(getDistance(mcd))
    ccov &lt;- CovClassic(lmom33)
    cd &lt;- sqrt(getDistance(ccov))
    r.out &lt;- which(rd &gt; sqrt(qchisq(0.975,3)))
    c.out &lt;- which(cd &gt; sqrt(qchisq(0.975,3)))
    cat("Robust: ", length(r.out), " outliers: ", r.out,"\n")
    cat("Classical: ", length(c.out), " outliers: ", c.out,"\n")

</code></pre>

<hr>
<h2 id='machines'>Computer Hardware</h2><span id='topic+machines'></span>

<h3>Description</h3>

<p>A data set containing relative CPU performance data of 209 machines on 8 variables.
are predictive, one (<code>PRP</code>) is the goal field and one (<code>ERP</code>) is the
linear regression's guess. The estimated relative performance values were
estimated by the authors using a linear regression method.  See their article
(Ein-Dor and Feldmesser, CACM 4/87, pp 308-317) for more details on how the
relative performance values were set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(machines)
</code></pre>


<h3>Format</h3>

<p>A data frame with 209 rows and 8 variables
The variables are as follows:
</p>

<ul>
<li><p> MMIN: minimum main memory in kilobytes (integer)
</p>
</li>
<li><p> MMAX: maximum main memory in kilobytes (integer)
</p>
</li>
<li><p> CACH: cache memory in kilobytes (integer)
</p>
</li>
<li><p> CHMIN: minimum channels in units (integer)
</p>
</li>
<li><p> CHMAX: maximum channels in units (integer)
</p>
</li>
<li><p> PRP: published relative performance (integer)
</p>
</li>
<li><p> ERP: estimated relative performance from the original article (integer)
</p>
</li></ul>



<h3>Source</h3>

<p><a href="http://archive.ics.uci.edu/ml/datasets/Computer+Hardware?ref=datanews.io">UCI Archive</a>
</p>


<h3>References</h3>

<p>Phillip Ein-Dor and Jacob Feldmesser (1987), Attributes of the performance
of central processing units: A relative performance prediction model,
<em>Communications of the ACM</em>, <b>30</b>, 4, pp 308-317.
</p>
<p>M. Hubert, P. J. Rousseeuw and T. Verdonck (2009), Robust PCA for skewed data and
its outlier map, <em>Computational Statistics &amp; Data Analysis</em>, <b>53</b>, 2264&ndash;2274.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(machines)

 ## Compute the medcouple of each variable of the Computer hardware data
     data.frame(MC=round(apply(machines, 2, mc),2))

 ## Plot a pairwise scaterplot matrix
     pairs(machines[,1:6])

     mcd &lt;- CovMcd(machines[,1:6])
     plot(mcd, which="pairs")

 ##  Remove the rownames (too long)
     rownames(machines) &lt;- NULL

 ## Start with robust PCA based on MCD (P &lt;&lt; n)
     (pca1 &lt;- PcaHubert(machines, k=3))
     plot(pca1, main="ROBPCA-MCD", off=0.03)

 ## PCA with the projection algoritm of Hubert
     (pca2 &lt;- PcaHubert(machines, k=3, mcd=FALSE))
     plot(pca2, main="ROBPCA-SD", off=0.03)

 ## PCA with the adjusted for skewness algorithm of Hubert et al (2009)
     (pca3 &lt;- PcaHubert(machines, k=3, mcd=FALSE, skew=TRUE))
     plot(pca3, main="ROBPCA-AO", off=0.03)

</code></pre>

<hr>
<h2 id='maryo'> Marona and Yohai Artificial Data</h2><span id='topic+maryo'></span>

<h3>Description</h3>

<p>Simple artificial data set generated according the example by 
Marona and Yohai (1998). 
The data set consists of 20 bivariate normal observations generated
with zero means, unit variances and correlation 0.8. The sample 
correlation is 0.81. Two outliers are introduced (i.e. these are 
10% of the data) in the following way: two points are modified 
by interchanging the largest (observation 19) and smallest 
(observation 9) value of the first coordinate. The sample correlation 
becomes 0.05. 
This example  provides a good example of the fact that a 
multivariate outlier need not be an outlier in any of its 
coordinate variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(maryo)</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on 2 variables. To introduce the outliers
x[9,1] with x[19,1] are interchanged.
</p>


<h3>Source</h3>

<p>R. A. Marona and V. J. Yohai (1998) Robust estimation of multivariate 
location and scatter. In
<em>Encyclopedia of Statistical Sciences, Updated Volume 2</em> 
(Eds. S.Kotz, C.Read and D.Banks). Wiley, New York p. 590
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(maryo)
getCorr(CovClassic(maryo))          ## the sample correlation is 0.81

## Modify 10%% of the data in the following way:
##  modify two points (out of 20) by interchanging the 
##  largest and smallest value of the first coordinate
imin &lt;- which(maryo[,1]==min(maryo[,1]))        # imin = 9
imax &lt;- which(maryo[,1]==max(maryo[,1]))        # imax = 19
maryo1 &lt;- maryo
maryo1[imin,1] &lt;- maryo[imax,1]
maryo1[imax,1] &lt;- maryo[imin,1]

##  The sample correlation becomes 0.05
plot(maryo1)
getCorr(CovClassic(maryo1))         ## the sample correlation becomes 0.05
getCorr(CovMcd(maryo1))      ## the (reweighted) MCD correlation is 0.79

</code></pre>

<hr>
<h2 id='octane'>  Octane data </h2><span id='topic+octane'></span>

<h3>Description</h3>

<p>The octane data contains near infrared absorbance spectra (NIR) of 
<code>n=39</code> gasoline samples over <code>p=226</code> wavelengths ranging 
from 1102 nm to 1552 nm with measurements every two nanometers. For
each of the 39 production gasoline samples the octane number <code>y</code> was measured.
Six of the samples (25, 26, and 36-39) contain added alcohol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(octane)</code></pre>


<h3>Format</h3>

<p>A data frame with 39 observations and 227 columns, the wavelengts are 
by column and the first variable is the dependent one (<code>y</code>).
</p>


<h3>Source</h3>

<p>K.H. Esbensen, S. Schoenkopf and T. Midtgaard <em>Multivariate Analysis in Practice</em>, Trondheim, Norway: Camo, 1994.
</p>


<h3>References</h3>

<p>M. Hubert, P. J. Rousseeuw, K. Vanden Branden (2005), ROBPCA: a new 
approach to robust principal components analysis, <em>Technometrics</em>, <b>47</b>, 64&ndash;79.   
</p>
<p>P. J. Rousseeuw,  M. Debruyne, S. Engelen and M. Hubert (2006), 
Robustness and Outlier Detection in Chemometrics, 
<em>Critical Reviews in Analytical Chemistry</em>, <b>36</b>(3&ndash;4), 221&ndash;242.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(octane)

octane &lt;- octane[, -1]    # remove the dependent variable y

pca=PcaHubert(octane, k=10)
screeplot(pca, type="lines")

pca2 &lt;- PcaHubert(octane, k=2)
plot(pca2, id.n.sd=6)

pca7 &lt;- PcaHubert(octane, k=7)
plot(pca7, id.n.sd=6)

</code></pre>

<hr>
<h2 id='olitos'>
Olive Oil Data
</h2><span id='topic+olitos'></span>

<h3>Description</h3>

<p>This dataset consists of 120 olive oil samples on measurements on
25 chemical compositions (fatty acids, sterols, triterpenic alcohols) 
of olive oils from Tuscany, Italy (Armanino et al. 1989).
There are 4 classes corresponding to different production areas.
Class 1, Class 2, Class 3, and Class 4 contain 50, 25, 34, and 11
observations, respectively. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(olitos)</code></pre>


<h3>Format</h3>

<p>A data frame with 120 observations on the following 26 variables.
</p>

<dl>
<dt><code>X1</code></dt><dd><p>Free fatty acids</p>
</dd>
<dt><code>X2</code></dt><dd><p>Refractive index</p>
</dd>
<dt><code>X3</code></dt><dd><p>K268</p>
</dd>
<dt><code>X4</code></dt><dd><p>delta K</p>
</dd>
<dt><code>X5</code></dt><dd><p>Palmitic acid</p>
</dd>
<dt><code>X6</code></dt><dd><p>Palmitoleic acid</p>
</dd>
<dt><code>X7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X18</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X19</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X20</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X21</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X22</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X23</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X24</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X25</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>grp</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code> <code>3</code> <code>4</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Prof. Roberto Todeschini, Milano Chemometrics and QSAR Research Group
<a href="https://michem.unimib.it">https://michem.unimib.it</a>
</p>


<h3>References</h3>

<p>C. Armanino, R. Leardi, S. Lanteri and G. Modi, 1989. 
Chemometric analysis of Tuscan olive oils. 
<em>Cbemometrics and Intelligent Laboratoty Sysiem</em>, 5: 343&ndash;354.
</p>
<p>R. Todeschini, V. Consonni, A. Mauri, M. Pavan (2004) 
Software for the calculation of molecular descriptors. 
Pavan M. Talete slr, Milan, Italy, <a href="http://www.talete.mi.it">http://www.talete.mi.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(olitos)
cc &lt;- Linda(grp~., data=olitos, method="mcdC", l1med=TRUE)
cc
pr &lt;- predict(cc)
tt &lt;- mtxconfusion(cc@grp, pr@classification, printit=TRUE)
</code></pre>

<hr>
<h2 id='OsloTransect'> Oslo Transect Data </h2><span id='topic+OsloTransect'></span>

<h3>Description</h3>

<p>The oslo Transect data set contains 360 samples of different 
plant species collected along a 120 km transect running through the city of Oslo,
Norway.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OsloTransect)</code></pre>


<h3>Format</h3>

<p>A data frame with 360 observations on the following 38 variables.
</p>

<dl>
<dt><code>X.ID</code></dt><dd><p>a numeric vector, unique ID of the sample</p>
</dd>
<dt><code>X.MAT</code></dt><dd><p>a factor with levels <code>BBA</code> <code>BIL</code> <code>BWO</code> <code>FER</code> <code>MOS</code> <code>ROG</code> <code>SNE</code> <code>STW</code> <code>TWI</code></p>
</dd>
<dt><code>XCOO</code></dt><dd><p>a numeric vector, X coordinate</p>
</dd>
<dt><code>YCOO</code></dt><dd><p>a numeric vector, Y coordinate</p>
</dd>
<dt><code>XCOO_km</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>YCOO_km</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X.FOREST</code></dt><dd><p>a factor with levels <code>BIRSPR</code> <code>MIXDEC</code> <code>PINE</code> <code>SPRBIR</code> <code>SPRPIN</code> <code>SPRUCE</code></p>
</dd>
<dt><code>DAY</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X.WEATHER</code></dt><dd><p>a factor with levels <code>CLOUD</code> <code>MOIST</code> <code>NICE</code> <code>RAIN</code></p>
</dd>
<dt><code>ALT</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X.ASP</code></dt><dd><p>a factor with levels  <code>E</code> <code>FLAT</code> <code>N</code> <code>NE</code> <code>NW</code> <code>S</code> <code>SE</code> <code>SW</code> <code>W</code></p>
</dd>
<dt><code>X.GRVEG</code></dt><dd><p>a factor with levels <code>BLGR</code> <code>BLLY</code> <code>BLMOLI</code> <code>BLUE</code> <code>BLUGRA</code> <code>GRAS</code> <code>GRBLU</code> <code>GRFE</code> <code>GRMO</code> <code>LYLI</code> <code>MIX</code> <code>MOGR</code> <code>MOSS</code></p>
</dd>
<dt><code>X.FLITHO</code></dt><dd><p>a factor with levels <code>CAMSED</code> <code>GNEID_O</code> <code>GNEIS_O</code> <code>GNEIS_R</code> <code>MAGM</code> <code>MICSH</code></p>
</dd>
<dt><code>Ag_ppb</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>As_ash</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>B</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Ba</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Ca</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Cd</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Co</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Cr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Cu</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Fe</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Hg_ppb</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>K</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>La</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>LOI</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Mg</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Mn</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Mo</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Ni</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>P</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Pb</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>S</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Sb</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Sr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Ti</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Zn</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Samples of different plant species were collected along a 120 km 
transect running through the city of Oslo,
Norway (forty samples each of leaves, needles,roots or 
barks of several plant species), and the concentrations of 
25 chemical elements for the sample materials are reported. 
The factors that influenced the observed element 
concentrations in the sample materials were investigated.
This data set was used in Todorov and Filzmoser (2007) for 
illustration of the robust statistics for one-way MANOVA implemented in the function 
<code><a href="#topic+Wilks.test">Wilks.test</a></code>.
</p>


<h3>Source</h3>

<p>REIMANN,C., ARNOLDUSSEN,A., BOYD,R., FINNE,T.E., 
NORDGULEN,Oe., VOLDEN,T. and  ENGLMAIER,P. (2006) 
The Influence of a city on element contents of a terrestrial moss 
(Hylocomium splendens), <em>The Science of the Total Environment</em> <b>369</b> 419&ndash;432.
</p>
<p>REIMANN,C., ARNOLDUSSEN,A., BOYD,R., FINNE,T.E., KOLLER,F., NORDGULEN,Oe., and ENGLMAIER,P. (2007) 
Element contents in leaves of four plant species (birch, mountain ash, fern and spruce) 
along anthropogenic and geogenic concentration gradients, 
<em>The Science of the Total Environment</em> <b>377</b> 416&ndash;433.
</p>
<p>REIMANN,C., ARNOLDUSSEN,A., FINNE,T.E., KOLLER,F., NORDGULEN,Oe.,  and ENGLMAIER,P., (2007) 
Element contents in birch leaves, bark and wood under different 
anthropogenic and geogenic conditions,
<em>Applied Geochemistry</em>, <b>22</b> 1549&ndash;1566.
</p>


<h3>References</h3>

<p>Todorov V. and Filzmoser P. (2007) Robust statistic for the one-way MANOVA,
<em>submetted to the Journal of Environmetrics</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(OsloTransect)
str(OsloTransect)

##
##  Log-transform the numerical part of the data, 
##  choose the desired groups and variables and 
##  perform the classical Wilks' Lambda test
##
OsloTransect[,14:38] &lt;- log(OsloTransect[,14:38])
grp &lt;- OsloTransect$X.FLITHO
ind &lt;- which(grp =="CAMSED" | grp == "GNEIS_O" |
    grp == "GNEIS_R" | grp=="MAGM")
(cwl &lt;- Wilks.test(X.FLITHO~K+P+Zn+Cu,data=OsloTransect[ind,]))

##
## Perform now the robust MCD based Wilks' Lambda test. 
##  Use the already computed multiplication factor 'xd' and 
##  degrees of freedom 'xq' for the approximate distribution.
##

xd &lt;- -0.003708238
xq &lt;- 11.79073
(mcdwl &lt;- Wilks.test(X.FLITHO~K+P+Zn+Cu,data=OsloTransect[ind,], 
    method="mcd", xd=xd, xq=xq))
</code></pre>

<hr>
<h2 id='Pca-class'>Class &quot;Pca&quot; - virtual base class for all classic and robust PCA classes 
</h2><span id='topic+Pca-class'></span><span id='topic+getCenter+2CPca-method'></span><span id='topic+getScale+2CPca-method'></span><span id='topic+getEigenvalues+2CPca-method'></span><span id='topic+getLoadings+2CPca-method'></span><span id='topic+getPrcomp+2CPca-method'></span><span id='topic+getScores+2CPca-method'></span><span id='topic+getSdev+2CPca-method'></span><span id='topic+plot+2CPca+2Cmissing-method'></span><span id='topic+show+2CPca-method'></span><span id='topic+predict+2CPca-method'></span><span id='topic+predict'></span><span id='topic+screeplot+2CPca-method'></span><span id='topic+screeplot'></span><span id='topic+summary+2CPca-method'></span>

<h3>Description</h3>

<p>  The class <code>Pca</code> searves as a base class for deriving all other 
classes representing the results of the classical and robust Principal 
Component Analisys methods
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"language"</code> </p>
</dd>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"vector"</code> the center of the data </p>
</dd>
<dt><code>scale</code>:</dt><dd><p>Object of class <code>"vector"</code> the scaling applied to each variable of the data </p>
</dd>
<dt><code>rank</code>:</dt><dd><p>Object of class <code>"numeric"</code> the rank of the data matrix </p>
</dd>
<dt><code>loadings</code>:</dt><dd><p>Object of class <code>"matrix"</code> the matrix 
of variable loadings (i.e., a matrix whose columns contain the eigenvectors) </p>
</dd>
<dt><code>eigenvalues</code>:</dt><dd><p>Object of class <code>"vector"</code> the eigenvalues </p>
</dd>
<dt><code>scores</code>:</dt><dd><p>Object of class <code>"matrix"</code> the scores - the value 
of the projected on the space of the principal components data (the centred 
(and scaled if requested) data multiplied 
by the <code>loadings</code> matrix) is returned.  Hence, <code>cov(scores)</code> 
is the diagonal matrix <code>diag(eigenvalues)</code> </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"numeric"</code> number of (choosen) principal components </p>
</dd>
<dt><code>sd</code>:</dt><dd><p>Object of class <code>"Uvector"</code> Score distances within the robust PCA subspace </p>
</dd>
<dt><code>od</code>:</dt><dd><p>Object of class <code>"Uvector"</code> Orthogonal distances to the robust PCA subspace </p>
</dd>
<dt><code>cutoff.sd</code>:</dt><dd><p>Object of class <code>"numeric"</code> Cutoff value for the score distances</p>
</dd>
<dt><code>cutoff.od</code>:</dt><dd><p>Object of class <code>"numeric"</code> Cutoff values for the orthogonal distances </p>
</dd>
<dt><code>flag</code>:</dt><dd><p>Object of class <code>"Uvector"</code> The observations whose score distance is larger 
than cutoff.sd or whose orthogonal distance is larger than cutoff.od can be considered 
as outliers and receive a flag equal to zero.
The regular observations receive a flag 1 </p>
</dd>
<dt>crit.pca.distances</dt><dd><p>criterion to use for computing the cutoff values for the orthogonal and score distances. Default is 0.975.</p>
</dd>
<dt><code>n.obs</code>:</dt><dd><p>Object of class <code>"numeric"</code> the number of observations </p>
</dd>
<dt><code>eig0</code>:</dt><dd><p>Object of class <code>"vector"</code> all eigenvalues </p>
</dd>
<dt><code>totvar0</code>:</dt><dd><p>Object of class <code>"numeric"</code> the total variance explained (<code>=sum(eig0)</code>) </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getCenter</dt><dd><p><code>signature(obj = "Pca")</code>: center of the data </p>
</dd>
<dt>getScale</dt><dd><p><code>signature(obj = "Pca")</code>: return the scaling applied to each variable </p>
</dd>
<dt>getEigenvalues</dt><dd><p><code>signature(obj = "Pca")</code>: the eigenvalues of the 
covariance/correlation matrix, though the calculation is actually done 
with the singular values of the data matrix) </p>
</dd>
<dt>getLoadings</dt><dd><p><code>signature(obj = "Pca")</code>: returns the matrix 
<code>loadings</code> (i.e., a matrix whose columns contain the eigenvectors). 
The function prcomp returns this matrix in the element rotation. </p>
</dd>
<dt>getPrcomp</dt><dd><p><code>signature(obj = "Pca")</code>: returns an S3 object <code>prcomp</code> 
for compatibility with the functions prcomp() and princomp(). Thus the 
standard plots screeplot() and biplot() can be used</p>
</dd>
<dt>getScores</dt><dd><p><code>signature(obj = "Pca")</code>:  returns the rotated data (the centred 
(and scaled if requested) data multiplied by the loadings matrix). </p>
</dd>
<dt>getSdev</dt><dd><p><code>signature(obj = "Pca")</code>: returns the standard deviations of the 
principal components (i.e., the square roots of the eigenvalues of the 
covariance/correlation matrix, though the calculation is actually done 
with the singular values of the data matrix) </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "Pca")</code>: produces a distance plot (if <code>k=rank</code>) or 
distance-distance plot (if<code>k&lt;rank</code>) </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "Pca")</code>: prints the results. The difference to the show()
method is that additional parametesr are possible.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Pca")</code>: prints the results </p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "Pca")</code>: calculates prediction using the results in 
<code>object</code>. An optional data frame or matrix in which to look for variables with which 
to predict. If omitted, the scores are used. If the original fit used a formula or 
a data frame or a matrix with column names, newdata must contain columns with the 
same names. Otherwise it must contain the same number of columns, 
to be used in the same order.  See also <code><a href="stats.html#topic+predict.prcomp">predict.prcomp</a></code> and 
<code><a href="stats.html#topic+predict.princomp">predict.princomp</a></code></p>
</dd>
<dt>screeplot</dt><dd><p><code>signature(x = "Pca")</code>: plots the variances against the 
number of the principal component. See also <code><a href="stats.html#topic+plot.prcomp">plot.prcomp</a></code> and 
<code><a href="stats.html#topic+plot.princomp">plot.princomp</a></code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PcaClassic">PcaClassic</a></code>, <code><a href="#topic+PcaClassic-class">PcaClassic-class</a></code>, <code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Pca")
</code></pre>

<hr>
<h2 id='pca.distances'>
Compute score and orthogonal distances for Principal Components (objects of class 'Pca')
</h2><span id='topic+pca.distances'></span>

<h3>Description</h3>

<p>Compute score and orthogonal distances for an object (derived from)<code><a href="#topic+Pca-class">Pca-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    pca.distances(obj, data, r, crit=0.975)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca.distances_+3A_obj">obj</code></td>
<td>
<p>an object of class (derived from) <code>"Pca"</code>.</p>
</td></tr>
<tr><td><code id="pca.distances_+3A_data">data</code></td>
<td>
<p>The data matrix for which the <code>"Pca"</code> object was computed.</p>
</td></tr>
<tr><td><code id="pca.distances_+3A_r">r</code></td>
<td>
<p>rank of data</p>
</td></tr>
<tr><td><code id="pca.distances_+3A_crit">crit</code></td>
<td>
<p>Criterion to use for computing the cutoff values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the score and orthogonal distances and the
appropriate cutoff values for identifying outlying observations. 
The computed values are used to 
create a vector a of flags, one for each observation, identifying the outliers.
</p>


<h3>Value</h3>

<p>An S4 object of class derived from the virtual class <code><a href="#topic+Pca-class">Pca-class</a></code> - 
the same object passed to the function, but with the score and orthogonal 
distances as well as their cutoff values and the corresponding flags appended to it. 
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>M. Hubert, P. J. Rousseeuw, K. Vanden Branden (2005), ROBPCA: a new 
approach to robust principal components analysis, <em>Technometrics</em>, <b>47</b>, 64&ndash;79.   
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## PCA of the Hawkins Bradu Kass's Artificial Data
##  using all 4 variables
data(hbk)
pca &lt;- PcaHubert(hbk)
pca.distances(pca, hbk, rankMM(hbk))
</code></pre>

<hr>
<h2 id='pca.scoreplot'>
Score plot for Principal Components (objects of class 'Pca')
</h2><span id='topic+pca.scoreplot'></span>

<h3>Description</h3>

<p>Produces a score plot from an object (derived from)  <code><a href="#topic+Pca-class">Pca-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    pca.scoreplot(obj, i=1, j=2, main, id.n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca.scoreplot_+3A_obj">obj</code></td>
<td>
<p>an object of class (derived from) <code>"Pca"</code>.</p>
</td></tr>
<tr><td><code id="pca.scoreplot_+3A_i">i</code></td>
<td>
<p>First score coordinate, defaults to <code>i=1</code>.</p>
</td></tr>
<tr><td><code id="pca.scoreplot_+3A_j">j</code></td>
<td>
<p>Second score coordinate, defaults to <code>j=2</code>.</p>
</td></tr>
<tr><td><code id="pca.scoreplot_+3A_main">main</code></td>
<td>
<p>The main title of the plot.</p>
</td></tr>
<tr><td><code id="pca.scoreplot_+3A_id.n">id.n</code></td>
<td>
<p>Number of observations to identify by a label. If missing and the
total number of observations is less or equal to 10, all observations will
be labelled.</p>
</td></tr>
<tr><td><code id="pca.scoreplot_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the internal graphical functions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Pca-class">Pca-class</a></code>,
<code><a href="#topic+PcaClassic">PcaClassic</a></code>,
<code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)

## PCA of the Hawkins Bradu Kass's Artificial Data
##  using all 4 variables
data(hbk)
pca &lt;- PcaHubert(hbk)
pca
pca.scoreplot(pca)
</code></pre>

<hr>
<h2 id='PcaClassic'> Principal Components Analysis </h2><span id='topic+PcaClassic'></span><span id='topic+PcaClassic.formula'></span><span id='topic+PcaClassic.default'></span>

<h3>Description</h3>

<p>Performs a principal components analysis and returns the results 
as an object of class PcaClassic (aka constructor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PcaClassic(x, ...)
## Default S3 method:
PcaClassic(x, k = ncol(x), kmax = ncol(x), 
    scale=FALSE, signflip=TRUE, crit.pca.distances = 0.975, trace=FALSE, ...)
## S3 method for class 'formula'
PcaClassic(formula, data = NULL, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PcaClassic_+3A_formula">formula</code></td>
<td>
<p>a formula with no response variable, referring only to
numeric variables.</p>
</td></tr>
<tr><td><code id="PcaClassic_+3A_data">data</code></td>
<td>
<p>an optional data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.</p>
</td></tr>
<tr><td><code id="PcaClassic_+3A_subset">subset</code></td>
<td>
<p>an optional vector used to select rows (observations) of the
data matrix <code>x</code>.</p>
</td></tr>
<tr><td><code id="PcaClassic_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset. The default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.</p>
</td></tr>
<tr><td><code id="PcaClassic_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="PcaClassic_+3A_x">x</code></td>
<td>
<p>a numeric matrix (or data frame) which provides
the data for the principal components analysis.</p>
</td></tr>
<tr><td><code id="PcaClassic_+3A_k">k</code></td>
<td>
<p>number of principal components to compute. If <code>k</code> is missing, 
or <code>k = 0</code>, the algorithm itself will determine the number of 
components by finding such <code>k</code> that <code class="reqn">l_k/l_1 &gt;= 10.E-3</code> and 
<code class="reqn">\Sigma_{j=1}^k l_j/\Sigma_{j=1}^r l_j &gt;= 0.8</code>. 
It is preferable to investigate the scree plot in order to choose the number 
of components and then run again. Default is <code>k=ncol(x)</code>. </p>
</td></tr>
<tr><td><code id="PcaClassic_+3A_kmax">kmax</code></td>
<td>
<p>maximal number of principal components to compute.
Default is <code>kmax=10</code>. If <code>k</code> is provided, <code>kmax</code> 
does not need to be specified, unless <code>k</code> is larger than 10.</p>
</td></tr>
<tr><td><code id="PcaClassic_+3A_scale">scale</code></td>
<td>
<p>a value indicating whether and how the variables should be scaled
to have unit variance (only possible if there are no constant 
variables). If <code>scale=FALSE</code> (default) or <code>scale=NULL</code> no scaling is 
performed (a vector of 1s is returned in the scale slot). If <code>scale=TRUE</code>
the data are scaled to have unit variance. Alternatively it can be a function 
like <code>sd</code> or <code>Qn</code> or a vector of length equal the number of columns 
of <code>x</code>. The value is passed to the underlying function and the result 
returned is stored in the scale slot. Default is <code>scale=FALSE</code>.</p>
</td></tr>
<tr><td><code id="PcaClassic_+3A_signflip">signflip</code></td>
<td>
<p>a logical value indicating wheather to try to solve 
the sign indeterminancy of the loadings -   ad hoc approach setting 
the maximum element in a singular vector to be positive. Default is 
<code>signflip = TRUE</code></p>
</td></tr>
<tr><td><code id="PcaClassic_+3A_crit.pca.distances">crit.pca.distances</code></td>
<td>
<p>criterion to use for computing the cutoff 
values for the orthogonal and score distances. Default is 0.975.</p>
</td></tr>
<tr><td><code id="PcaClassic_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+PcaClassic-class">PcaClassic-class</a></code> which is a subclass of the 
virtual class <code><a href="#topic+Pca-class">Pca-class</a></code>.    
</p>


<h3>Note</h3>

<p> This function can be seen as a wrapper arround prcomp() from <code>stats</code> which
returns the results of the PCA in a class compatible with the object model for robust PCA. 
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> 
</p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pca-class">Pca-class</a></code>, <code><a href="#topic+PcaClassic-class">PcaClassic-class</a></code>, 
</p>

<hr>
<h2 id='PcaClassic-class'>Class &quot;PcaClassic&quot; - Principal Components Analysis </h2><span id='topic+PcaClassic-class'></span><span id='topic+getQuan+2CPcaClassic-method'></span>

<h3>Description</h3>

<p> Contains the results of a classical Principal Components Analysis </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PcaClassic", ...)</code> but the 
usual way of creating <code>PcaClassic</code> objects is a call to the function
<code>PcaClassic</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"language"</code> </p>
</dd>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"vector"</code> the center of the data </p>
</dd>
<dt><code>scale</code>:</dt><dd><p>Object of class <code>"vector"</code> the scaling applied to each variable </p>
</dd>
<dt><code>rank</code>:</dt><dd><p>Object of class <code>"numeric"</code> the rank of the data matrix </p>
</dd>
<dt><code>loadings</code>:</dt><dd><p>Object of class <code>"matrix"</code> the matrix 
of variable loadings (i.e., a matrix whose columns contain the eigenvectors) </p>
</dd>
<dt><code>eigenvalues</code>:</dt><dd><p>Object of class <code>"vector"</code> the eigenvalues </p>
</dd>
<dt><code>scores</code>:</dt><dd><p>Object of class <code>"matrix"</code> the scores - the value 
of the projected on the space of the principal components data (the centred 
(and scaled if requested) data multiplied 
by the <code>loadings</code> matrix) is returned.  Hence, <code>cov(scores)</code> 
is the diagonal matrix <code>diag(eigenvalues)</code> </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"numeric"</code> number of (choosen) principal components </p>
</dd>
<dt><code>sd</code>:</dt><dd><p>Object of class <code>"Uvector"</code> Score distances within the robust PCA subspace </p>
</dd>
<dt><code>od</code>:</dt><dd><p>Object of class <code>"Uvector"</code> Orthogonal distances to the robust PCA subspace </p>
</dd>
<dt><code>cutoff.sd</code>:</dt><dd><p>Object of class <code>"numeric"</code> Cutoff value for the score distances</p>
</dd>
<dt><code>cutoff.od</code>:</dt><dd><p>Object of class <code>"numeric"</code> Cutoff values for the orthogonal distances </p>
</dd>
<dt><code>flag</code>:</dt><dd><p>Object of class <code>"Uvector"</code> The observations whose score distance is larger 
than cutoff.sd or whose orthogonal distance is larger than cutoff.od can be considered 
as outliers and receive a flag equal to zero.
The regular observations receive a flag 1 </p>
</dd>
<dt><code>n.obs</code>:</dt><dd><p>Object of class <code>"numeric"</code> the number of observations </p>
</dd>
<dt><code>eig0</code>:</dt><dd><p>Object of class <code>"vector"</code> all eigenvalues </p>
</dd>
<dt><code>totvar0</code>:</dt><dd><p>Object of class <code>"numeric"</code> the total variance explained (<code>=sum(eig0)</code>) </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Pca-class">Pca</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>getQuan</dt><dd><p><code>signature(obj = "PcaClassic")</code>: returns the number of 
observations used in the computation, i.e. n.obs </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>, <code><a href="#topic+Pca-class">Pca-class</a></code>, <code><a href="#topic+PcaClassic">PcaClassic</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PcaClassic")
</code></pre>

<hr>
<h2 id='PcaCov'> Robust PCA based on a robust covariance matrix </h2><span id='topic+PcaCov'></span><span id='topic+PcaCov.formula'></span><span id='topic+PcaCov.default'></span>

<h3>Description</h3>

<p>Robust PCA are obtained by replacing the classical covariance matrix 
by a robust covariance estimator. This can be one of the available 
in <code>rrcov</code> estimators, i.e. MCD, OGK, M or S estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PcaCov(x, ...)
## Default S3 method:
PcaCov(x, k = ncol(x), kmax = ncol(x), cov.control=CovControlMcd(), 
    scale = FALSE, signflip = TRUE, crit.pca.distances = 0.975, trace=FALSE, ...)
## S3 method for class 'formula'
PcaCov(formula, data = NULL, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PcaCov_+3A_formula">formula</code></td>
<td>
<p>a formula with no response variable, referring only to
numeric variables.</p>
</td></tr>
<tr><td><code id="PcaCov_+3A_data">data</code></td>
<td>
<p>an optional data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.</p>
</td></tr>
<tr><td><code id="PcaCov_+3A_subset">subset</code></td>
<td>
<p>an optional vector used to select rows (observations) of the
data matrix <code>x</code>.</p>
</td></tr>
<tr><td><code id="PcaCov_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset. The default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.</p>
</td></tr>
<tr><td><code id="PcaCov_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="PcaCov_+3A_x">x</code></td>
<td>
<p>a numeric matrix (or data frame) which provides
the data for the principal components analysis.</p>
</td></tr>
<tr><td><code id="PcaCov_+3A_k">k</code></td>
<td>
<p>number of principal components to compute. If <code>k</code> is missing, 
or <code>k = 0</code>, the algorithm itself will determine the number of 
components by finding such <code>k</code> that <code class="reqn">l_k/l_1 &gt;= 10.E-3</code> and 
<code class="reqn">\Sigma_{j=1}^k l_j/\Sigma_{j=1}^r l_j &gt;= 0.8</code>. 
It is preferable to investigate the scree plot in order to choose the number 
of components and then run again. Default is <code>k=ncol(x)</code>. </p>
</td></tr>
<tr><td><code id="PcaCov_+3A_kmax">kmax</code></td>
<td>
<p>maximal number of principal components to compute.
Default is <code>kmax=10</code>. If <code>k</code> is provided, <code>kmax</code> 
does not need to be specified, unless <code>k</code> is larger than 10.</p>
</td></tr>
<tr><td><code id="PcaCov_+3A_cov.control">cov.control</code></td>
<td>
<p>specifies which covariance estimator to use by providing 
a <code><a href="#topic+CovControl-class">CovControl-class</a></code> object. 
The default is <code><a href="#topic+CovControlMcd-class">CovControlMcd-class</a></code> which will indirectly call <code><a href="#topic+CovMcd">CovMcd</a></code>. 
If <code>cov.control=NULL</code> is specified, the classical estimates will be used by calling <code><a href="#topic+CovClassic">CovClassic</a></code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="PcaCov_+3A_scale">scale</code></td>
<td>
<p>a value indicating whether and how the variables should be scaled
to have unit variance (only possible if there are no constant 
variables). If <code>scale=FALSE</code> (default) or <code>scale=NULL</code> no scaling is 
performed (a vector of 1s is returned in the scale slot). If <code>scale=TRUE</code>
the data are scaled by the estimator used to compute the covariance matrix 
(<code>MCD</code> by default). Alternatively it can be a function 
like <code>sd</code> or <code>Qn</code> or a vector of length equal the number of columns 
of <code>x</code>. The value is passed to the underlying function and the result 
returned is stored in the scale slot. Default is <code>scale=FALSE</code>.</p>
</td></tr>
<tr><td><code id="PcaCov_+3A_signflip">signflip</code></td>
<td>
<p>a logical value indicating wheather to try to solve the sign indeterminancy of the loadings -   
ad hoc approach setting the maximum element in a singular vector to be positive. Default is <code>signflip = TRUE</code></p>
</td></tr>
<tr><td><code id="PcaCov_+3A_crit.pca.distances">crit.pca.distances</code></td>
<td>
<p>criterion to use for computing the cutoff values for the orthogonal and score distances. Default is 0.975.</p>
</td></tr>
<tr><td><code id="PcaCov_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PcaCov</code>, serving as a constructor for objects of class <code><a href="#topic+PcaCov-class">PcaCov-class</a></code> 
is a generic function with &quot;formula&quot; and &quot;default&quot; methods. For details see the relevant references.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+PcaCov-class">PcaCov-class</a></code> which is a subclass of the 
virtual class <code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>. 
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> 
</p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PCA of the Hawkins Bradu Kass's Artificial Data
##  using all 4 variables
    data(hbk)
    pca &lt;- PcaCov(hbk)
    pca

## Compare with the classical PCA
    prcomp(hbk)

## or  
    PcaClassic(hbk)
    
## If you want to print the scores too, use
    print(pca, print.x=TRUE)

## Using the formula interface
    PcaCov(~., data=hbk)

## To plot the results:

    plot(pca)                    # distance plot
    pca2 &lt;- PcaCov(hbk, k=2)  
    plot(pca2)                   # PCA diagnostic plot (or outlier map)
    
## Use the standard plots available for for prcomp and princomp
    screeplot(pca)    
    biplot(pca)    
</code></pre>

<hr>
<h2 id='PcaCov-class'>Class &quot;PcaCov&quot; - Robust PCA based on a robust covariance matrix </h2><span id='topic+PcaCov-class'></span><span id='topic+getQuan+2CPcaCov-method'></span>

<h3>Description</h3>

<p>Robust PCA are obtained by replacing the classical covariance matrix
by a robust covariance estimator. This can be one of the available
in <code>rrcov</code> estimators, i.e. MCD, OGK, M, S or Stahel-Donoho estimator.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PcaCov", ...)</code> but the
usual way of creating <code>PcaCov</code> objects is a call to the function
<code>PcaCov</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>quan</code>:</dt><dd><p>Object of class <code>"numeric"</code>
The quantile <code>h</code> used throughout the algorithm </p>
</dd>
<dt><code>call</code>, <code>center</code>, <code>rank</code>, <code>loadings</code>,
<code>eigenvalues</code>, <code>scores</code>, <code>k</code>,
<code>sd</code>, <code>od</code>, <code>cutoff.sd</code>, <code>cutoff.od</code>,
<code>flag</code>, <code>n.obs</code>, <code>eig0</code>, <code>totvar0</code>:</dt><dd>
<p>from the <code>"<a href="#topic+Pca-class">Pca</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PcaRobust-class">PcaRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Pca-class">Pca</a>"</code>, by class &quot;PcaRobust&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>getQuan</dt><dd><p><code>signature(obj = "PcaCov")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>, <code><a href="#topic+Pca-class">Pca-class</a></code>, <code><a href="#topic+PcaClassic">PcaClassic</a></code>, <code><a href="#topic+PcaClassic-class">PcaClassic-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PcaCov")
</code></pre>

<hr>
<h2 id='PcaGrid'> Robust Principal Components based on Projection Pursuit (PP): GRID search Algorithm </h2><span id='topic+PcaGrid'></span><span id='topic+PcaGrid.formula'></span><span id='topic+PcaGrid.default'></span>

<h3>Description</h3>

<p>Computes an approximation of the PP-estimators for PCA using the grid search algorithm in the plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    PcaGrid(x, ...)
    ## Default S3 method:
PcaGrid(x, k = 0, kmax = ncol(x), 
        scale=FALSE, na.action = na.fail, crit.pca.distances = 0.975, trace=FALSE, ...)
    ## S3 method for class 'formula'
PcaGrid(formula, data = NULL, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PcaGrid_+3A_formula">formula</code></td>
<td>
<p>a formula with no response variable, referring only to
numeric variables.</p>
</td></tr>
<tr><td><code id="PcaGrid_+3A_data">data</code></td>
<td>
<p>an optional data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.</p>
</td></tr>
<tr><td><code id="PcaGrid_+3A_subset">subset</code></td>
<td>
<p>an optional vector used to select rows (observations) of the
data matrix <code>x</code>.</p>
</td></tr>
<tr><td><code id="PcaGrid_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset. The default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.</p>
</td></tr>
<tr><td><code id="PcaGrid_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="PcaGrid_+3A_x">x</code></td>
<td>
<p>a numeric matrix (or data frame) which provides
the data for the principal components analysis.</p>
</td></tr>
<tr><td><code id="PcaGrid_+3A_k">k</code></td>
<td>
<p>number of principal components to compute. If <code>k</code> is missing, 
or <code>k = 0</code>, it is set to the number of columns of the data. 
It is preferable to investigate the scree plot in order to choose the number 
of components and then run again. Default is <code>k=0</code>. </p>
</td></tr>
<tr><td><code id="PcaGrid_+3A_kmax">kmax</code></td>
<td>
<p>maximal number of principal components to compute.
Default is <code>kmax=10</code>. If <code>k</code> is provided, <code>kmax</code> 
does not need to be specified, unless <code>k</code> is larger than 10.</p>
</td></tr>
<tr><td><code id="PcaGrid_+3A_scale">scale</code></td>
<td>
<p>a value indicating whether and how the variables should be 
scaled. If <code>scale = FALSE</code> (default) or <code>scale = NULL</code> no scaling is 
performed (a vector of 1s is returned in the <code>scale</code> slot). 
If <code>scale = TRUE</code> the data are scaled to have unit variance. Alternatively it can 
be a function like <code>sd</code> or <code>mad</code> or a vector of length equal 
the number of columns of <code>x</code>. The value is passed to the underlying function
and the result returned is stored in the <code>scale</code> slot. 
Default is <code>scale = FALSE</code></p>
</td></tr>
<tr><td><code id="PcaGrid_+3A_crit.pca.distances">crit.pca.distances</code></td>
<td>
<p>criterion to use for computing the cutoff values 
for the orthogonal and score distances. Default is 0.975.</p>
</td></tr>
<tr><td><code id="PcaGrid_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PcaGrid</code>, serving as a constructor for objects of class <code><a href="#topic+PcaGrid-class">PcaGrid-class</a></code> 
is a generic function with &quot;formula&quot; and &quot;default&quot; methods. For details see <code><a href="pcaPP.html#topic+PCAgrid">PCAgrid</a></code> and the relevant references.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+PcaGrid-class">PcaGrid-class</a></code> which is a subclass of the 
virtual class <code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>. 
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> 
</p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, M. Oliveira, (2007).
Algorithms for Projection-Pursuit Robust Principal Component Analysis,
<em>Chemometrics and Intelligent Laboratory Systems</em>, 87, 225.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # multivariate data with outliers
    library(mvtnorm)
    x &lt;- rbind(rmvnorm(200, rep(0, 6), diag(c(5, rep(1,5)))),
                rmvnorm( 15, c(0, rep(20, 5)), diag(rep(1, 6))))
    # Here we calculate the principal components with PCAgrid
    pc &lt;- PcaGrid(x, 6)
    # we could draw a biplot too:
    biplot(pc)
    
    # we could use another objective function, and 
    # maybe only calculate the first three principal components:
    pc &lt;- PcaGrid(x, 3, method="qn")
    biplot(pc)
    
    # now we want to compare the results with the non-robust principal components
    pc &lt;- PcaClassic(x, k=3)
    # again, a biplot for comparision:
    biplot(pc)
</code></pre>

<hr>
<h2 id='PcaGrid-class'>Class &quot;PcaGrid&quot; - Robust PCA using PP - GRID search Algorithm  </h2><span id='topic+PcaGrid-class'></span><span id='topic+getQuan+2CPcaGrid-method'></span>

<h3>Description</h3>

<p>Holds the results of an approximation of the PP-estimators for PCA using the grid search algorithm in the plane.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PcaGrid", ...)</code> but the
usual way of creating <code>PcaGrid</code> objects is a call to the function
<code>PcaGrid()</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>, <code>center</code>, <code>scale</code>, <code>rank</code>, <code>loadings</code>,
<code>eigenvalues</code>, <code>scores</code>, <code>k</code>,
<code>sd</code>, <code>od</code>, <code>cutoff.sd</code>, <code>cutoff.od</code>,
<code>flag</code>, <code>n.obs</code>:</dt><dd>
<p>from the <code>"<a href="#topic+Pca-class">Pca</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PcaRobust-class">PcaRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Pca-class">Pca</a>"</code>, by class <code>"<a href="#topic+PcaRobust-class">PcaRobust</a>"</code>, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>getQuan</dt><dd><p><code>signature(obj = "PcaGrid")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>, <code><a href="#topic+Pca-class">Pca-class</a></code>, <code><a href="#topic+PcaClassic">PcaClassic</a></code>, <code><a href="#topic+PcaClassic-class">PcaClassic-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PcaGrid")
</code></pre>

<hr>
<h2 id='PcaHubert'> ROBPCA - ROBust method for Principal Components Analysis </h2><span id='topic+PcaHubert'></span><span id='topic+PcaHubert.formula'></span><span id='topic+PcaHubert.default'></span>

<h3>Description</h3>

<p>The ROBPCA algorithm was proposed by Hubert et al (2005) and stays for
'ROBust method for Principal Components Analysis'. It is resistant to 
outliers in the data. The robust loadings are computed using 
projection-pursuit techniques and the MCD method. Therefore ROBPCA 
can be applied to both low and high-dimensional data sets. In low 
dimensions, the MCD method is applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PcaHubert(x, ...)
## Default S3 method:
PcaHubert(x, k = 0, kmax = 10, alpha = 0.75, mcd = TRUE, skew=FALSE,
maxdir=250, scale = FALSE, signflip = TRUE, crit.pca.distances = 0.975, trace=FALSE, ...)
## S3 method for class 'formula'
PcaHubert(formula, data = NULL, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PcaHubert_+3A_formula">formula</code></td>
<td>
<p>a formula with no response variable, referring only to
numeric variables.</p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_data">data</code></td>
<td>
<p>an optional data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.</p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_subset">subset</code></td>
<td>
<p>an optional vector used to select rows (observations) of the
data matrix <code>x</code>.</p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset. The default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.</p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_x">x</code></td>
<td>
<p>a numeric matrix (or data frame) which provides
the data for the principal components analysis.</p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_k">k</code></td>
<td>
<p>number of principal components to compute. If <code>k</code> is missing, 
or <code>k = 0</code>, the algorithm itself will determine the number of 
components by finding such <code>k</code> that <code class="reqn">l_k/l_1 &gt;= 10.E-3</code> and 
<code class="reqn">\Sigma_{j=1}^k l_j/\Sigma_{j=1}^r l_j &gt;= 0.8</code>. 
It is preferable to investigate the scree plot in order to choose the number 
of components and then run again. Default is <code>k=0</code>. </p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_kmax">kmax</code></td>
<td>
<p>maximal number of principal components to compute.
Default is <code>kmax=10</code>. If <code>k</code> is provided, <code>kmax</code> 
does not need to be specified, unless <code>k</code> is larger than 10.</p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_alpha">alpha</code></td>
<td>
<p>this parameter measures the fraction of outliers the algorithm should
resist. In MCD alpha controls the size of the subsets over which the 
determinant is minimized, i.e. alpha*n observations are used for 
computing the determinant. Allowed values are between 0.5 and 1 
and the default is 0.75. </p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_mcd">mcd</code></td>
<td>
<p>Logical - when the number of variables is sufficiently small,
the loadings are computed as the eigenvectors of the MCD covariance matrix, 
hence the function <code><a href="#topic+CovMcd">CovMcd</a>()</code> is automatically called. The number of 
principal components is then taken as k = rank(x). Default is <code>mcd=TRUE</code>.
If <code>mcd=FALSE</code>, the ROBPCA algorithm is always applied.</p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_skew">skew</code></td>
<td>
<p>Logical - whether the adjusted outlyingness algorithm for skewed 
data (Hubert et al., 2009) will be used, default is <code>skew=FALSE</code>.</p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_maxdir">maxdir</code></td>
<td>
<p>maximal number of random directions to use for computing the 
outlyingness (or the adjusted outlyingness when <code>skew=TRUE</code>) of the data points, 
see <code><a href="robustbase.html#topic+adjOutlyingness">adjOutlyingness</a></code> for more details.. 
Default is <code>maxdir=250</code>. If the number <code>n</code>
of observations is small all possible <code>n*(n-1)/2</code> pairs of observations 
are taken to generate the directions.</p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_scale">scale</code></td>
<td>
<p>a value indicating whether and how the variables should be scaled. 
If <code>scale=FALSE</code> (default) or <code>scale=NULL</code> no scaling is 
performed (a vector of 1s is returned in the scale slot). If <code>scale=TRUE</code>
the data are scaled to have unit variance. Alternatively it can be a function 
like <code>sd</code> or <code>mad</code> or a vector of length equal the number of columns 
of <code>x</code>. The value is passed to the underlying function and the result 
returned is stored in the scale slot. Default is <code>scale=FALSE</code>.</p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_signflip">signflip</code></td>
<td>
<p>a logical value indicating wheather to try to solve the sign indeterminancy of the loadings -   
ad hoc approach setting the maximum element in a singular vector to be positive. Default is <code>signflip = TRUE</code></p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_crit.pca.distances">crit.pca.distances</code></td>
<td>
<p>criterion to use for computing the cutoff 
values for the orthogonal and score distances. Default is 0.975.</p>
</td></tr>
<tr><td><code id="PcaHubert_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PcaHubert</code>, serving as a constructor for objects of class <code><a href="#topic+PcaHubert-class">PcaHubert-class</a></code> 
is a generic function with &quot;formula&quot; and &quot;default&quot; methods. 
The calculation is done using the ROBPCA method of Hubert et al (2005) which can 
be described briefly as follows. For details see the relevant references.
</p>
<p>Let <code>n</code> denote the number of observations, and <code>p</code> the
number of original variables in the input data matrix <code>X</code>. The
ROBPCA algorithm finds a robust center <code>M (p x 1)</code> of the data
and a loading matrix <code>P</code> which is <code>(p x k)</code> dimensional.
Its columns are orthogonal and define a new coordinate system. The
scores T, an <code>(n x k)</code> matrix, are the coordinates of the
centered observations with respect to the loadings:
</p>
<p style="text-align: center;"><code class="reqn">T=(X-M)P</code>
</p>
<p> The ROBPCA algorithm also yields a robust covariance
matrix (often singular) which can be computed as
</p>
<p style="text-align: center;"><code class="reqn">S=PLP^t</code>
</p>

<p>where <code class="reqn">L</code> is the diagonal matrix with the eigenvalues <code class="reqn">l_1, \dots, l_k</code>.
</p>
<p>This is done in the following three main steps:
</p>
<p><b>Step 1:</b> The data are preprocessed by reducing their data space to
the subspace spanned by the <code>n</code> observations. This is done by
singular value decomposition of the input data matrix. As a result
the data are represented using at most <code>n-1=rank(X)</code> without
loss of information.
</p>
<p><b>Step 2:</b> In this step for each data point a measure of outlyingness
is computed. For this purpose the high-dimensional data points are
projected on many univariate directions, each time the univariate
MCD estimator of location and scale is computed  and the
standardized distance to the center is measured. The largest of
these distances (over all considered directions) is the outlyingness
measure of the data point. The <code>h</code> data points with smallest
outlyingness measure are used to compute the covariance matrix
<code class="reqn">\Sigma_h</code> and to select the number <code>k</code> of principal
components to retain. This is done by finding such <code>k</code> that
<code class="reqn">l_k/l_1 &gt;= 10.E-3</code> and <code class="reqn">\Sigma_{j=1}^k l_j/\Sigma_{j=1}^r l_j &gt;= 0.8</code>
Alternatively the number of principal components <code>k</code> can be
specified by the user after inspecting the scree plot.
</p>
<p><b>Step 3:</b> The data points are projected on the k-dimensional subspace
spanned by the <code>k</code> eigenvectors corresponding to the largest
<code>k</code> eigenvalues of the matrix <code class="reqn">\Sigma_h</code>. The location and
scatter of the projected data are computed using the
reweighted MCD estimator and the eigenvectors of this scatter matrix
yield the robust principal components.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+PcaHubert-class">PcaHubert-class</a></code> which is a subclass of the 
virtual class <code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>. 
</p>


<h3>Note</h3>

<p>The ROBPCA algorithm is implemented on the bases of the Matlab implementation, 
available as part of <em>LIBRA, a Matlab Library for Robust Analysis</em> to be found at  
www.wis.kuleuven.ac.be/stat/robust.html
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> 
</p>


<h3>References</h3>

<p>M. Hubert, P. J. Rousseeuw, K. Vanden Branden (2005), ROBPCA: a new 
approach to robust principal components analysis, <em>Technometrics</em>, <b>47</b>, 64&ndash;79.   
</p>
<p>M. Hubert, P. J. Rousseeuw and T. Verdonck (2009), Robust PCA for skewed data and 
its outlier map, <em>Computational Statistics &amp; Data Analysis</em>, <b>53</b>, 2264&ndash;2274.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PCA of the Hawkins Bradu Kass's Artificial Data
##  using all 4 variables
    data(hbk)
    pca &lt;- PcaHubert(hbk)
    pca

## Compare with the classical PCA
    prcomp(hbk)

## or  
    PcaClassic(hbk)
    
## If you want to print the scores too, use
    print(pca, print.x=TRUE)

## Using the formula interface
    PcaHubert(~., data=hbk)

## To plot the results:

    plot(pca)                    # distance plot
    pca2 &lt;- PcaHubert(hbk, k=2)  
    plot(pca2)                   # PCA diagnostic plot (or outlier map)
    
## Use the standard plots available for prcomp and princomp
    screeplot(pca)    
    biplot(pca)    
    
## Restore the covraiance matrix     
    py &lt;- PcaHubert(hbk)
    cov.1 &lt;- py@loadings %*% diag(py@eigenvalues) %*% t(py@loadings)
    cov.1    
</code></pre>

<hr>
<h2 id='PcaHubert-class'>Class &quot;PcaHubert&quot; - ROBust method for Principal Components Analysis </h2><span id='topic+PcaHubert-class'></span><span id='topic+getQuan+2CPcaHubert-method'></span>

<h3>Description</h3>

<p> The ROBPCA algorithm was proposed by Hubert et al (2005) and stays for
'ROBust method for Principal Components Analysis'. It is resistant to
outliers in the data. The robust loadings are computed using
projection-pursuit techniques and the MCD method. Therefore ROBPCA
can be applied to both low and high-dimensional data sets. In low
dimensions, the MCD method is applied.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PcaHubert", ...)</code> but the
usual way of creating <code>PcaHubert</code> objects is a call to the function
<code>PcaHubert</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>alpha</code>:</dt><dd><p>Object of class <code>"numeric"</code> the fraction of outliers
the algorithm should resist - this is the argument alpha</p>
</dd>
<dt><code>quan</code>:</dt><dd><p>The quantile <code>h</code> used throughout the algorithm </p>
</dd>
<dt><code>skew</code>:</dt><dd><p>Whether the adjusted outlyingness algorithm for skewed data was used</p>
</dd>
<dt><code>ao</code>:</dt><dd><p>Object of class <code>"Uvector"</code> Adjusted outlyingness within the robust PCA subspace </p>
</dd>
<dt><code>call</code>, <code>center</code>, <code>scale</code>, <code>rank</code>, <code>loadings</code>,
<code>eigenvalues</code>, <code>scores</code>, <code>k</code>,
<code>sd</code>, <code>od</code>, <code>cutoff.sd</code>, <code>cutoff.od</code>,
<code>flag</code>, <code>n.obs</code>, <code>eig0</code>, <code>totvar0</code>:</dt><dd>
<p>from the <code>"<a href="#topic+Pca-class">Pca</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PcaRobust-class">PcaRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Pca-class">Pca</a>"</code>, by class &quot;PcaRobust&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>getQuan</dt><dd><p><code>signature(obj = "PcaHubert")</code>: Returns the quantile
used throughout the algorithm </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>, <code><a href="#topic+Pca-class">Pca-class</a></code>, <code><a href="#topic+PcaClassic">PcaClassic</a></code>, <code><a href="#topic+PcaClassic-class">PcaClassic-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PcaHubert")
</code></pre>

<hr>
<h2 id='PcaLocantore'> Spherical Principal Components</h2><span id='topic+PcaLocantore'></span><span id='topic+PcaLocantore.formula'></span><span id='topic+PcaLocantore.default'></span>

<h3>Description</h3>

<p>The Spherical Principal Components procedure was proposed by 
Locantore et al., (1999) as a functional data analysis method.
The idea is to perform classical PCA on the data,
projected onto a unit sphere. The estimates of the eigenvectors are consistent 
and the procedure is extremely fast. The simulations of Maronna (2005) show
that this method has very good performance. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PcaLocantore(x, ...)
## Default S3 method:
PcaLocantore(x, k = ncol(x), kmax = ncol(x), delta = 0.001, 
    na.action = na.fail, scale = FALSE, signflip = TRUE, 
    crit.pca.distances = 0.975, trace=FALSE, ...)
## S3 method for class 'formula'
PcaLocantore(formula, data = NULL, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PcaLocantore_+3A_formula">formula</code></td>
<td>
<p>a formula with no response variable, referring only to
numeric variables.</p>
</td></tr>
<tr><td><code id="PcaLocantore_+3A_data">data</code></td>
<td>
<p>an optional data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.</p>
</td></tr>
<tr><td><code id="PcaLocantore_+3A_subset">subset</code></td>
<td>
<p>an optional vector used to select rows (observations) of the
data matrix <code>x</code>.</p>
</td></tr>
<tr><td><code id="PcaLocantore_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset. The default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.</p>
</td></tr>
<tr><td><code id="PcaLocantore_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="PcaLocantore_+3A_x">x</code></td>
<td>
<p>a numeric matrix (or data frame) which provides
the data for the principal components analysis.</p>
</td></tr>
<tr><td><code id="PcaLocantore_+3A_k">k</code></td>
<td>
<p>number of principal components to compute. If <code>k</code> is missing, 
or <code>k = 0</code>, the algorithm itself will determine the number of 
components by finding such <code>k</code> that <code class="reqn">l_k/l_1 &gt;= 10.E-3</code> and 
<code class="reqn">\Sigma_{j=1}^k l_j/\Sigma_{j=1}^r l_j &gt;= 0.8</code>. 
It is preferable to investigate the scree plot in order to choose the number 
of components and then run again. Default is <code>k=ncol(x)</code>. </p>
</td></tr>
<tr><td><code id="PcaLocantore_+3A_kmax">kmax</code></td>
<td>
<p>maximal number of principal components to compute.
Default is <code>kmax=10</code>. If <code>k</code> is provided, <code>kmax</code> 
does not need to be specified, unless <code>k</code> is larger than 10.</p>
</td></tr>
<tr><td><code id="PcaLocantore_+3A_delta">delta</code></td>
<td>
<p>an accuracy parameter</p>
</td></tr>
<tr><td><code id="PcaLocantore_+3A_scale">scale</code></td>
<td>
<p>a value indicating whether and how the variables should be scaled
to have unit variance (only possible if there are no constant 
variables). If <code>scale=FALSE</code> (default) or <code>scale=NULL</code> no scaling is 
performed (a vector of 1s is returned in the scale slot). If <code>scale=TRUE</code>
the data are scaled by <code>mad</code>. Alternatively it can be a function 
like <code>sd</code> or <code>Qn</code> or a vector of length equal the number of columns 
of <code>x</code>. The value is passed to the underlying function and the result 
returned is stored in the scale slot. Default is <code>scale=FALSE</code>.</p>
</td></tr>
<tr><td><code id="PcaLocantore_+3A_signflip">signflip</code></td>
<td>
<p>a logical value indicating wheather to try to solve 
the sign indeterminancy of the loadings -   ad hoc approach setting 
the maximum element in a singular vector to be positive. Default is 
<code>signflip = TRUE</code></p>
</td></tr>
<tr><td><code id="PcaLocantore_+3A_crit.pca.distances">crit.pca.distances</code></td>
<td>
<p>criterion to use for computing the cutoff 
values for the orthogonal and score distances. Default is 0.975.</p>
</td></tr>
<tr><td><code id="PcaLocantore_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PcaLocantore</code>, serving as a constructor for objects of class 
<code><a href="#topic+PcaLocantore-class">PcaLocantore-class</a></code> is a generic function with &quot;formula&quot; 
and &quot;default&quot; methods. For details see the relevant references.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+PcaLocantore-class">PcaLocantore-class</a></code> which is a subclass of the 
virtual class <code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>. 
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> 
The SPC algorithm is implemented on the bases of the available from 
the web site of the book Maronna et al. (2006) code  
<a href="https://www.wiley.com/legacy/wileychi/robust_statistics/">https://www.wiley.com/legacy/wileychi/robust_statistics/</a>
</p>


<h3>References</h3>

<p>N. Locantore, J. Marron, D. Simpson, N. Tripoli, J. Zhang and K. Cohen K. (1999), 
Robust principal components for functional data. Test, 8, 1-28.
</p>
<p>R. Maronna, D. Martin and V. Yohai (2006), Robust Statistics: 
Theory and Methods. Wiley, New York.
</p>
<p>R. Maronna (2005). Principal components and orthogonal regression based 
on robust scales. Technometrics, 47, 264-273.    
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PCA of the Hawkins Bradu Kass's Artificial Data
##  using all 4 variables
    data(hbk)
    pca &lt;- PcaLocantore(hbk)
    pca

## Compare with the classical PCA
    prcomp(hbk)

## or  
    PcaClassic(hbk)
    
## If you want to print the scores too, use
    print(pca, print.x=TRUE)

## Using the formula interface
    PcaLocantore(~., data=hbk)

## To plot the results:

    plot(pca)                    # distance plot
    pca2 &lt;- PcaLocantore(hbk, k=2)  
    plot(pca2)                   # PCA diagnostic plot (or outlier map)
    
## Use the standard plots available for for prcomp and princomp
    screeplot(pca)    
    biplot(pca)    
</code></pre>

<hr>
<h2 id='PcaLocantore-class'>Class &quot;PcaLocantore&quot; Spherical Principal Components </h2><span id='topic+PcaLocantore-class'></span><span id='topic+getQuan+2CPcaLocantore-method'></span>

<h3>Description</h3>

<p>The Spherical Principal Components procedure was proposed by
Locantore et al., (1999) as a functional data analysis method.
The idea is to perform classical PCA on the the data, \
projected onto a unit sphere. The estimates of the eigenvectors are consistent
and the procedure is extremly fast. The simulations of Maronna (2005) show
that this method has very good performance.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PcaLocantore", ...)</code> but the
usual way of creating <code>PcaLocantore</code> objects is a call to the function
<code>PcaLocantore</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>delta</code>:</dt><dd><p>Accuracy parameter</p>
</dd>
<dt><code>quan</code>:</dt><dd><p>Object of class <code>"numeric"</code> The quantile h used throughout the algorithm </p>
</dd>
<dt><code>call</code>, <code>center</code>, <code>scale</code>, <code>rank</code>, <code>loadings</code>,
<code>eigenvalues</code>, <code>scores</code>, <code>k</code>,
<code>sd</code>, <code>od</code>, <code>cutoff.sd</code>, <code>cutoff.od</code>,
<code>flag</code>, <code>n.obs</code>, <code>eig0</code>, <code>totvar0</code>:</dt><dd>
<p>from the <code>"<a href="#topic+Pca-class">Pca</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PcaRobust-class">PcaRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Pca-class">Pca</a>"</code>, by class &quot;PcaRobust&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>getQuan</dt><dd><p><code>signature(obj = "PcaLocantore")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>, <code><a href="#topic+Pca-class">Pca-class</a></code>, <code><a href="#topic+PcaClassic">PcaClassic</a></code>, <code><a href="#topic+PcaClassic-class">PcaClassic-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PcaLocantore")
</code></pre>

<hr>
<h2 id='PcaProj'> Robust Principal Components based on Projection Pursuit (PP): Croux and Ruiz-Gazen (2005) algorithm </h2><span id='topic+PcaProj'></span><span id='topic+PcaProj.formula'></span><span id='topic+PcaProj.default'></span>

<h3>Description</h3>

<p>A fast and simple algorithm for approximating the PP-estimators for PCA: Croux and Ruiz-Gazen (2005)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    PcaProj(x, ...)
    ## Default S3 method:
PcaProj(x, k = 0, kmax = ncol(x), scale=FALSE, 
        na.action = na.fail, crit.pca.distances = 0.975, trace=FALSE, ...)
    ## S3 method for class 'formula'
PcaProj(formula, data = NULL, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PcaProj_+3A_formula">formula</code></td>
<td>
<p>a formula with no response variable, referring only to
numeric variables.</p>
</td></tr>
<tr><td><code id="PcaProj_+3A_data">data</code></td>
<td>
<p>an optional data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.</p>
</td></tr>
<tr><td><code id="PcaProj_+3A_subset">subset</code></td>
<td>
<p>an optional vector used to select rows (observations) of the
data matrix <code>x</code>.</p>
</td></tr>
<tr><td><code id="PcaProj_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset. The default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.</p>
</td></tr>
<tr><td><code id="PcaProj_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="PcaProj_+3A_x">x</code></td>
<td>
<p>a numeric matrix (or data frame) which provides
the data for the principal components analysis.</p>
</td></tr>
<tr><td><code id="PcaProj_+3A_k">k</code></td>
<td>
<p>number of principal components to compute. If <code>k</code> is missing, 
or <code>k = 0</code>, it is set to the number of columns of the data. 
It is preferable to investigate the scree plot in order to choose the number 
of components and then run again. Default is <code>k=0</code>. </p>
</td></tr>
<tr><td><code id="PcaProj_+3A_kmax">kmax</code></td>
<td>
<p>maximal number of principal components to compute.
Default is <code>kmax=10</code>. If <code>k</code> is provided, <code>kmax</code>
does not need to be specified, unless <code>k</code> is larger than 10.</p>
</td></tr>
<tr><td><code id="PcaProj_+3A_scale">scale</code></td>
<td>
<p>a value indicating whether and how the variables should be
scaled. If <code>scale = FALSE</code> (default) or <code>scale = NULL</code> no scaling is
performed (a vector of 1s is returned in the <code>scale</code> slot).
If <code>scale = TRUE</code> the data are scaled to have unit variance. Alternatively it can
be a function like <code>sd</code> or <code>mad</code> or a vector of length equal
the number of columns of <code>x</code>. The value is passed to the underlying function
and the result returned is stored in the <code>scale</code> slot.
Default is <code>scale = FALSE</code></p>
</td></tr>
<tr><td><code id="PcaProj_+3A_crit.pca.distances">crit.pca.distances</code></td>
<td>
<p>criterion to use for computing the cutoff values 
for the orthogonal and score distances. Default is 0.975.</p>
</td></tr>
<tr><td><code id="PcaProj_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PcaProj</code>, serving as a constructor for objects of class <code><a href="#topic+PcaProj-class">PcaProj-class</a></code>
is a generic function with &quot;formula&quot; and &quot;default&quot; methods. For details see 
<code><a href="pcaPP.html#topic+PCAproj">PCAproj</a></code> and the relevant references.
</p>


<h3>Value</h3>

<p>An S4 object of class <code><a href="#topic+PcaProj-class">PcaProj-class</a></code> which is a subclass of the
virtual class <code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>C. Croux, A. Ruiz-Gazen (2005). High breakdown estimators for principal components: The
projection-pursuit approach revisited, <em>Journal of Multivariate Analysis</em>, 95, 206&ndash;226.
</p>
<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # multivariate data with outliers
    library(mvtnorm)
    x &lt;- rbind(rmvnorm(200, rep(0, 6), diag(c(5, rep(1,5)))),
                rmvnorm( 15, c(0, rep(20, 5)), diag(rep(1, 6))))
    # Here we calculate the principal components with PcaProj
    pc &lt;- PcaProj(x, 6)
    # we could draw a biplot too:
    biplot(pc)

    # we could use another calculation method and another objective function, and
    # maybe only calculate the first three principal components:
    pc &lt;- PcaProj(x, k=3, method="qn", CalcMethod="sphere")
    biplot(pc)

    # now we want to compare the results with the non-robust principal components
    pc &lt;- PcaClassic(x, k=3)
    # again, a biplot for comparision:
    biplot(pc)
</code></pre>

<hr>
<h2 id='PcaProj-class'>Class &quot;PcaProj&quot; - Robust PCA using PP - Croux and Ruiz-Gazen (2005) algorithm </h2><span id='topic+PcaProj-class'></span><span id='topic+getQuan+2CPcaProj-method'></span>

<h3>Description</h3>

<p>Holds the results of an approximation of the PP-estimators for PCA by a fast and simple algorithm: Croux and Ruiz-Gazen (2005) algorithm.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PcaProj", ...)</code> but the
usual way of creating <code>PcaProj</code> objects is a call to the function
<code>PcaProj()</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>, <code>center</code>, <code>scale</code>, <code>rank</code>, <code>loadings</code>,
<code>eigenvalues</code>, <code>scores</code>, <code>k</code>,
<code>sd</code>, <code>od</code>, <code>cutoff.sd</code>, <code>cutoff.od</code>,
<code>flag</code>, <code>n.obs</code>:</dt><dd>
<p>from the <code>"<a href="#topic+Pca-class">Pca</a>"</code> class.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PcaRobust-class">PcaRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Pca-class">Pca</a>"</code>, by class <code>"<a href="#topic+PcaRobust-class">PcaRobust</a>"</code>, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>getQuan</dt><dd><p><code>signature(obj = "PcaProj")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>, <code><a href="#topic+Pca-class">Pca-class</a></code>, <code><a href="#topic+PcaClassic">PcaClassic</a></code>, <code><a href="#topic+PcaClassic-class">PcaClassic-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PcaProj")
</code></pre>

<hr>
<h2 id='PcaRobust-class'>Class &quot;PcaRobust&quot; is a virtual base class for all robust PCA classes </h2><span id='topic+PcaRobust-class'></span>

<h3>Description</h3>

<p> The class <code>PcaRobust</code> searves as a base class for deriving all other 
classes representing the results of the robust Principal Component Analisys methods</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"language"</code> </p>
</dd>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"vector"</code> the center of the data </p>
</dd>
<dt><code>loadings</code>:</dt><dd><p>Object of class <code>"matrix"</code> the matrix 
of variable loadings (i.e., a matrix whose columns contain the eigenvectors) </p>
</dd>
<dt><code>eigenvalues</code>:</dt><dd><p>Object of class <code>"vector"</code> the eigenvalues </p>
</dd>
<dt><code>scores</code>:</dt><dd><p>Object of class <code>"matrix"</code> the scores - the value 
of the projected on the space of the principal components data (the centred 
(and scaled if requested) data multiplied 
by the <code>loadings</code> matrix) is returned.  Hence, <code>cov(scores)</code> 
is the diagonal matrix <code>diag(eigenvalues)</code> </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"numeric"</code> number of (choosen) principal components </p>
</dd>
<dt><code>sd</code>:</dt><dd><p>Object of class <code>"Uvector"</code> Score distances within the robust PCA subspace </p>
</dd>
<dt><code>od</code>:</dt><dd><p>Object of class <code>"Uvector"</code> Orthogonal distances to the robust PCA subspace </p>
</dd>
<dt><code>cutoff.sd</code>:</dt><dd><p>Object of class <code>"numeric"</code> Cutoff value for the score distances</p>
</dd>
<dt><code>cutoff.od</code>:</dt><dd><p>Object of class <code>"numeric"</code> Cutoff values for the orthogonal distances </p>
</dd>
<dt><code>flag</code>:</dt><dd><p>Object of class <code>"Uvector"</code> The observations whose score distance is larger 
than cutoff.sd or whose orthogonal distance is larger than cutoff.od can be considered 
as outliers and receive a flag equal to zero.
The regular observations receive a flag 1 </p>
</dd>
<dt><code>n.obs</code>:</dt><dd><p>Object of class <code>"numeric"</code> the number of observations </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Pca-class">Pca</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;PcaRobust&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pca-class">Pca-class</a></code>, <code><a href="#topic+PcaClassic-class">PcaClassic-class</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PcaRobust")
</code></pre>

<hr>
<h2 id='plot-methods'>Methods for Function 'plot' in Package 'rrcov'</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CCovClassic-method'></span><span id='topic+plot+2CCovClassic+2Cmissing-method'></span><span id='topic+plot+2CCovRobust-method'></span><span id='topic+plot+2CCovRobust+2Cmissing-method'></span>

<h3>Description</h3>

<p>Shows the Mahalanobis distances based on robust and/or classical estimates 
of the location and the covariance matrix in different plots. 
The following plots are available:
</p>
<p>- index plot of the robust and mahalanobis distances
</p>
<p>- distance-distance plot
</p>
<p>- Chisquare QQ-plot of the robust and mahalanobis distances
</p>
<p>- plot of the tolerance ellipses (robust and classic)
</p>
<p>- Scree plot - Eigenvalues comparison plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'CovClassic'
plot(x, which = c("all","distance","qqchi2","tolellipse","screeplot"), 
        ask=(which=="all" &amp;&amp; dev.interactive()), 
        cutoff, id.n, tol=1e-7, ...)
## S4 method for signature 'CovRobust'
plot(x, which = c("all","dd","distance","qqchi2","tolellipse","screeplot"), 
        classic=FALSE, ask=(which=="all" &amp;&amp; dev.interactive()), 
        cutoff, id.n, tol=1e-7, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>"Cov"</code>  or <code>"CovRobust"</code></p>
</td></tr>
<tr><td><code id="plot-methods_+3A_which">which</code></td>
<td>
<p> Which plot to show? See Details for description of the options. Default is <code>which</code>=&quot;all&quot;. </p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="plot-methods_+3A_classic">classic</code></td>
<td>
<p> whether to plot the classical distances too. Default is <code>classic</code>=FALSE. </p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="plot-methods_+3A_ask">ask</code></td>
<td>
<p> logical; if 'TRUE', the user is <em>ask</em>ed before each plot, see 'par(ask=.)'. 
Default is <code>ask = which=="all" &amp;&amp; dev.interactive()</code>.  </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_cutoff">cutoff</code></td>
<td>
<p> The cutoff value for the distances.  </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_id.n">id.n</code></td>
<td>
<p> Number of observations to identify by a label. If not supplied, the number of observations with distance larger than <code>cutoff</code> is used.  </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_tol">tol</code></td>
<td>
<p> tolerance to be used for computing the inverse see 'solve'. Default is <code>tol = 10e-7</code></p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p> other parameters to be passed through to plotting functions. </p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>x = &quot;Cov&quot;, y = &quot;missing&quot;</dt><dd><p>Plot mahalanobis distances for <code>x</code>.</p>
</dd>
<dt>x = &quot;CovRobust&quot;, y = &quot;missing&quot;</dt><dd><p>Plot robust and classical mahalanobis distances for <code>x</code>.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])
cv &lt;- CovClassic(hbk.x)
plot(cv)
rcv &lt;- CovMest(hbk.x)
plot(rcv)
</code></pre>

<hr>
<h2 id='pottery'>Archaic Greek Pottery data</h2><span id='topic+pottery'></span><span id='topic+pottery.test'></span>

<h3>Description</h3>

<p>The Archaic Greek Pottery data set contains data on fragments of Greek
pottery which were classified into two groups according to
their origin: Attic or Eritrean. Six chemical variables, metallic
oxide constituents, were measured: Si, Al, Fe, Ca and Ti. The main data set
consists of 13 Attic objects and 14 Eritrean ones. There is a separate data
set with 13 observations which can be used as a test data set. It consists
of 4 observations classified as &quot;probably Attic&quot; and the remaining 9 as &quot;probably Eritrean&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pottery)
</code></pre>


<h3>Format</h3>

<p>Two data frames with 27 an 13 observations on the following 7 variables.
</p>

<dl>
<dt><code>SI</code></dt><dd><p>Si content</p>
</dd>
<dt><code>AL</code></dt><dd><p>Al content</p>
</dd>
<dt><code>FE</code></dt><dd><p>Fe content</p>
</dd>
<dt><code>MG</code></dt><dd><p>Mg content</p>
</dd>
<dt><code>CA</code></dt><dd><p>Ca content</p>
</dd>
<dt><code>TI</code></dt><dd><p>Ti content</p>
</dd>
<dt><code>origin</code></dt><dd><p>Origin - factor with two levels: <code>Attic</code> and <code>Eritrean</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The Archaic Greek Pottery data set was first published by
Stern and Descoeudres (1977) and later reproduced in
Cooper and Weeks (1983) for illustration of linear discriminant analisys.
The data set was used by Pires and Branco (2010) for illustration
of their projection pursuit approach to linear discriminant analysis.
</p>


<h3>Source</h3>

<p>STERN, W. B. and DESCOEUDRES, J.-P. (1977)
X-RAY FLUORESCENCE ANALYSIS OF ARCHAIC GREEK POTTERY
<em>Archaeometry</em>, Blackwell Publishing Ltd, <b>19</b>, 73&ndash;86.
</p>


<h3>References</h3>

<p>Cooper, R.A. and Weekes, A.J.. 1983
<em>Data, Models, and Statistical Analysis</em>,
(Lanham, MD: Rowman &amp; Littlefield).
</p>
<p>Pires, A. M. and A. Branco, J. (2010)
Projection-pursuit approach to robust linear discriminant analysis
<em>Journal Multivariate Analysis</em>, Academic Press, Inc., <b>101</b>, 2464&ndash;2485.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pottery)
x &lt;- pottery[,c("MG", "CA")]
grp &lt;- pottery$origin

##
## Compute robust location and covariance matrix and
## plot the tolerance ellipses
library(rrcov)
(mcd &lt;- CovMcd(x))
col &lt;- c(3,4)
gcol &lt;- ifelse(grp == "Attic", col[1], col[2])
gpch &lt;- ifelse(grp == "Attic", 16, 1)
plot(mcd, which="tolEllipsePlot", class=TRUE, col=gcol, pch=gpch)

##
## Perform classical LDA and plot the data, 0.975 tolerance ellipses
##  and LDA separation line
##
x &lt;- pottery[,c("MG", "CA")]
grp &lt;- pottery$origin
lda &lt;- LdaClassic(x, grp)
lda
e1 &lt;- getEllipse(loc=lda@center[1,], cov=lda@cov)
e2 &lt;- getEllipse(loc=lda@center[2,], cov=lda@cov)

plot(CA~MG, data=pottery, col=gcol, pch=gpch,
    xlim=c(min(MG,e1[,1], e2[,1]), max(MG,e1[,1], e2[,1])),
    ylim=c(min(CA,e1[,2], e2[,2]), max(CA,e1[,2], e2[,2])))

ab &lt;- lda@ldf[1,] - lda@ldf[2,]
cc &lt;- lda@ldfconst[1] - lda@ldfconst[2]
abline(a=-cc/ab[2], b=-ab[1]/ab[2], col=2, lwd=2)

lines(e1, type="l", col=col[1])
lines(e2, type="l", col=col[2])

##
## Perform robust (MCD) LDA and plot data, classical and
##  robust separation line
##
plot(CA~MG, data=pottery, col=gcol, pch=gpch)
lda &lt;- LdaClassic(x, grp)
ab &lt;- lda@ldf[1,] - lda@ldf[2,]
cc &lt;- lda@ldfconst[1] - lda@ldfconst[2]
abline(a=-cc/ab[2], b=-ab[1]/ab[2], col=2, lwd=2)
abline(a=-cc/ab[2], b=-ab[1]/ab[2], col=4, lwd=2)

rlda &lt;- Linda(x, grp, method="mcd")
rlda
ab &lt;- rlda@ldf[1,] - rlda@ldf[2,]
cc &lt;- rlda@ldfconst[1] - rlda@ldfconst[2]
abline(a=-cc/ab[2], b=-ab[1]/ab[2], col=2, lwd=2)

</code></pre>

<hr>
<h2 id='PredictLda-class'>Class &quot;PredictLda&quot; - prediction of &quot;Lda&quot; objects </h2><span id='topic+PredictLda-class'></span><span id='topic+show+2CPredictLda-method'></span>

<h3>Description</h3>

<p> The prediction of a &quot;Lda&quot; object </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PredictLda", ...)</code>
but most often by invoking 'predict' on a &quot;Lda&quot; object. They contain values 
meant for printing by 'show'</p>


<h3>Slots</h3>


<dl>
<dt><code>classification</code>:</dt><dd><p>a factor variable containing the classification of each object </p>
</dd>
<dt><code>posterior</code>:</dt><dd><p>a matrix containing the posterior probabilities </p>
</dd>
<dt><code>x</code>:</dt><dd><p> matrix with the discriminant scores </p>
</dd>
<dt><code>ct</code>:</dt><dd><p>re-classification table of the training sample</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "PredictLda")</code>: Prints the results </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lda-class">Lda-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PredictLda")
</code></pre>

<hr>
<h2 id='PredictQda-class'>Class &quot;PredictQda&quot; - prediction of &quot;Qda&quot; objects </h2><span id='topic+PredictQda-class'></span><span id='topic+show+2CPredictQda-method'></span>

<h3>Description</h3>

<p> The prediction of a &quot;Qda&quot; object </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PredictQda", ...)</code>
but most often by invoking 'predict' on a &quot;Qda&quot; object. They contain values 
meant for printing by 'show'</p>


<h3>Slots</h3>


<dl>
<dt><code>classification</code>:</dt><dd><p>a factor variable containing the classification of each object </p>
</dd>
<dt><code>posterior</code>:</dt><dd><p>a matrix containing the posterior probabilities </p>
</dd>
<dt><code>x</code>:</dt><dd><p> matrix with the discriminant scores </p>
</dd>
<dt><code>ct</code>:</dt><dd><p>re-classification table of the training sample</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "PredictQda")</code>: prints the results </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qda-class">Qda-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PredictQda")
</code></pre>

<hr>
<h2 id='Qda-class'>Class &quot;Qda&quot; - virtual base class for all classic and robust QDA classes 
</h2><span id='topic+Qda-class'></span><span id='topic+predict+2CQda-method'></span><span id='topic+show+2CQda-method'></span><span id='topic+summary+2CQda-method'></span>

<h3>Description</h3>

<p> The class <code>Qda</code> serves as a base class for deriving 
all other classes representing the results of classical 
and robust Quadratic Discriminant Analisys methods </p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>the (matched) function call.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p>prior probabilities used, default to group proportions</p>
</dd>
<dt><code>counts</code>:</dt><dd><p>number of observations in each class</p>
</dd>
<dt><code>center</code>:</dt><dd><p>the group means</p>
</dd>
<dt><code>cov</code>:</dt><dd><p>the group covariance matrices</p>
</dd>
<dt><code>covinv</code>:</dt><dd><p>the inverse of the group covariance matrices</p>
</dd>
<dt><code>covdet</code>:</dt><dd><p>the determinants of the group covariance matrices</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a character string giving the estimation method used</p>
</dd>
<dt><code>X</code>:</dt><dd><p>the training data set (same as the input parameter x of the constructor function)</p>
</dd>
<dt><code>grp</code>:</dt><dd><p>grouping variable:  a factor specifying the class for each observation.</p>
</dd>   
<dt><code>control</code>:</dt><dd><p>object of class <code>"CovControl"</code> specifying which estimate 
and with what estimation options to use for the group means and covariances 
(or <code>NULL</code> for classical discriminant analysis)</p>
</dd>    
</dl>



<h3>Methods</h3>


<dl>
<dt>predict</dt><dd><p><code>signature(object = "Qda")</code>: calculates prediction using the results in 
<code>object</code>. An optional data frame or matrix in which to look for variables with which 
to predict. If omitted, the scores are used. If the original fit used a formula or 
a data frame or a matrix with column names, newdata must contain columns with the 
same names. Otherwise it must contain the same number of columns, 
to be used in the same order. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Qda")</code>: prints the results </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "Qda")</code>: prints summary information </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QdaClassic">QdaClassic</a></code>, <code><a href="#topic+QdaClassic-class">QdaClassic-class</a></code>, <code><a href="#topic+QdaRobust-class">QdaRobust-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Qda")
</code></pre>

<hr>
<h2 id='QdaClassic'> Quadratic Discriminant Analysis </h2><span id='topic+QdaClassic'></span><span id='topic+QdaClassic.formula'></span><span id='topic+QdaClassic.default'></span>

<h3>Description</h3>

<p>Performs quadratic discriminant analysis and returns the results as an object 
of class <code>QdaClassic</code> (aka constructor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QdaClassic(x, ...)

## Default S3 method:
QdaClassic(x, grouping, prior = proportions, tol = 1.0e-4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QdaClassic_+3A_x">x</code></td>
<td>
<p>a matrix or data frame containing the explanatory variables (training set). </p>
</td></tr>
<tr><td><code id="QdaClassic_+3A_grouping">grouping</code></td>
<td>
<p>grouping variable:  a factor specifying the class for each observation.</p>
</td></tr>
<tr><td><code id="QdaClassic_+3A_prior">prior</code></td>
<td>
<p>prior probabilities, default to the class proportions for the training set.</p>
</td></tr>
<tr><td><code id="QdaClassic_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="QdaClassic_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Returns an S4 object of class <code>QdaClassic</code>
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> 
</p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qda-class">Qda-class</a></code>, <code><a href="#topic+QdaClassic-class">QdaClassic-class</a></code>, 
</p>

<hr>
<h2 id='QdaClassic-class'>Class &quot;QdaClassic&quot; - Quadratic Discriminant Analysis </h2><span id='topic+QdaClassic-class'></span>

<h3>Description</h3>

<p> Contains the results of classical Quadratic Discriminant Analysis </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("QdaClassic", ...)</code> but the 
usual way of creating <code>QdaClassic</code> objects is a call to the function
<code>QdaClassic</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>The (matched) function call.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p>Prior probabilities used, default to group proportions</p>
</dd>
<dt><code>counts</code>:</dt><dd><p>number of observations in each class</p>
</dd>
<dt><code>center</code>:</dt><dd><p>the group means</p>
</dd>
<dt><code>cov</code>:</dt><dd><p>the group covariance matrices</p>
</dd>
<dt><code>covinv</code>:</dt><dd><p>the inverse of the group covariance matrices</p>
</dd>
<dt><code>covdet</code>:</dt><dd><p>the determinants of the group covariance matrices</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a character string giving the estimation method used</p>
</dd>
<dt><code>X</code>:</dt><dd><p>the training data set (same as the input parameter x of the constructor function)</p>
</dd>
<dt><code>grp</code>:</dt><dd><p>grouping variable:  a factor specifying the class for each observation.</p>
</dd> 
<dt><code>control</code>:</dt><dd><p>Object of class <code>"CovControl"</code> inherited from class <code>Qda</code> 
specifying which estimate and with what estimation options to use for the group 
means and covariances. It is always <code>NULL</code> for classical discriminant analysis.</p>
</dd>    
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Qda-class">Qda</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;QdaClassic&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QdaRobust-class">QdaRobust-class</a></code>, <code><a href="#topic+Qda-class">Qda-class</a></code>, <code><a href="#topic+QdaClassic">QdaClassic</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("QdaClassic")
</code></pre>

<hr>
<h2 id='QdaCov'> Robust Quadratic Discriminant Analysis </h2><span id='topic+QdaCov'></span><span id='topic+QdaCov.formula'></span><span id='topic+QdaCov.default'></span>

<h3>Description</h3>

<p>Performs robust quadratic discriminant analysis and returns 
the results as an object of class <code>QdaCov</code> (aka constructor). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QdaCov(x, ...)

## Default S3 method:
QdaCov(x, grouping, prior = proportions, tol = 1.0e-4,
                 method = CovControlMcd(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QdaCov_+3A_x">x</code></td>
<td>
<p>a matrix or data frame containing the explanatory variables (training set). </p>
</td></tr>
<tr><td><code id="QdaCov_+3A_grouping">grouping</code></td>
<td>
<p>grouping variable:  a factor specifying the class for each observation.</p>
</td></tr>
<tr><td><code id="QdaCov_+3A_prior">prior</code></td>
<td>
<p>prior probabilities, default to the class proportions for the training set.</p>
</td></tr>
<tr><td><code id="QdaCov_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="QdaCov_+3A_method">method</code></td>
<td>
<p>method</p>
</td></tr>
<tr><td><code id="QdaCov_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>details
</p>


<h3>Value</h3>

<p>Returns an S4 object of class <code>QdaCov</code>
</p>


<h3>Warning </h3>

<p>Still an experimental version!</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> 
</p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+CovMcd">CovMcd</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example anorexia
library(MASS)
data(anorexia)

## start with the classical estimates
qda &lt;- QdaClassic(Treat~., data=anorexia)
predict(qda)@classification

## try now the robust LDA with the default method (MCD with pooled whitin cov matrix)
rqda &lt;- QdaCov(Treat~., data= anorexia)
predict(rqda)@classification

## try the other methods
QdaCov(Treat~., data= anorexia, method="sde")
QdaCov(Treat~., data= anorexia, method="M")
QdaCov(Treat~., data= anorexia, method=CovControlOgk())

</code></pre>

<hr>
<h2 id='QdaCov-class'>Class &quot;QdaCov&quot; - Robust methods for Quadratic Discriminant Analysis </h2><span id='topic+QdaCov-class'></span>

<h3>Description</h3>

 
<p>Robust quadratic discriminant analysis is performed by replacing the classical 
group means and withing group covariance matrices by their robust equivalents. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("QdaCov", ...)</code> but the 
usual way of creating <code>QdaCov</code> objects is a call to the function
<code>QdaCov</code> which serves as a constructor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>The (matched) function call.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p>Prior probabilities used, default to group proportions</p>
</dd>
<dt><code>counts</code>:</dt><dd><p>number of observations in each class</p>
</dd>
<dt><code>center</code>:</dt><dd><p>the group means</p>
</dd>
<dt><code>cov</code>:</dt><dd><p>the group covariance matrices</p>
</dd>
<dt><code>covinv</code>:</dt><dd><p>the inverse of the group covariance matrices</p>
</dd>
<dt><code>covdet</code>:</dt><dd><p>the determinants of the group covariance matrices</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a character string giving the estimation method used</p>
</dd>
<dt><code>X</code>:</dt><dd><p>the training data set (same as the input parameter x of the constructor function)</p>
</dd>
<dt><code>grp</code>:</dt><dd><p>grouping variable:  a factor specifying the class for each observation.</p>
</dd>  
<dt><code>control</code>:</dt><dd><p>Object of class <code>"CovControl"</code> specifying which estimate to 
use for the group means and covariances </p>
</dd>    
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+QdaRobust-class">QdaRobust</a>"</code>, directly.
Class <code>"<a href="#topic+Qda-class">Qda</a>"</code>, by class &quot;QdaRobust&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;QdaCov&quot; in the signature.</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QdaRobust-class">QdaRobust-class</a></code>, <code><a href="#topic+Qda-class">Qda-class</a></code>, <code><a href="#topic+QdaClassic">QdaClassic</a></code>, <code><a href="#topic+QdaClassic-class">QdaClassic-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("QdaCov")
</code></pre>

<hr>
<h2 id='QdaRobust-class'>Class &quot;QdaRobust&quot; is a virtual base class for all robust QDA classes </h2><span id='topic+QdaRobust-class'></span>

<h3>Description</h3>

<p> The class <code>QdaRobust</code> searves as a base class for deriving all other 
classes representing the results of robust Quadratic Discriminant Analysis methods</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>The (matched) function call.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p>Prior probabilities used, default to group proportions</p>
</dd>
<dt><code>counts</code>:</dt><dd><p>number of observations in each class</p>
</dd>
<dt><code>center</code>:</dt><dd><p>the group means</p>
</dd>
<dt><code>cov</code>:</dt><dd><p>the group covariance matrices</p>
</dd>
<dt><code>covinv</code>:</dt><dd><p>the inverse of the group covariance matrices</p>
</dd>
<dt><code>covdet</code>:</dt><dd><p>the determinants of the group covariance matrices</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a character string giving the estimation method used</p>
</dd>
<dt><code>X</code>:</dt><dd><p>the training data set (same as the input parameter x of the constructor function)</p>
</dd>
<dt><code>grp</code>:</dt><dd><p>grouping variable:  a factor specifying the class for each observation.</p>
</dd> 
<dt><code>control</code>:</dt><dd><p>Object of class <code>"CovControl"</code> specifying which estimate to 
use for the group means and covariances </p>
</dd>    
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Qda-class">Qda</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;QdaRobust&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> </p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qda-class">Qda-class</a></code>, <code><a href="#topic+QdaClassic-class">QdaClassic-class</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("QdaRobust")
</code></pre>

<hr>
<h2 id='restimate-methods'> Methods for Function estimate in Package 'rrcov'</h2><span id='topic+restimate'></span><span id='topic+restimate-methods'></span><span id='topic+restimate+2CCovControlMest-method'></span>

<h3>Description</h3>

<p>Each concrete control class, like <code>CovControlMest</code>, <code>CovControlOgk</code>,
etc., should implement an <code>restimate</code> method which will call the correponding
(constructor)-function and will return the obtained S4 class, derived from
<code>CovRobust</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'CovControlMest'
restimate(obj, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restimate-methods_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>"CovControlEstimate"</code></p>
</td></tr>
<tr><td><code id="restimate-methods_+3A_x">x</code></td>
<td>
<p> Data frame or matrix containing the data </p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="restimate-methods_+3A_...">...</code></td>
<td>
<p> other parameters to be passed through to the estimation function. </p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;CovControlMcd&quot;</dt><dd><p> Compute the MCD estimates of multivariate location and
scatter by calling<code>CovMcd</code> </p>
</dd>
<dt>obj = &quot;CovControlMest&quot;</dt><dd><p> Compute the constrained M-estimates of multivariate location and
scatter by calling<code>CovMest</code> </p>
</dd>
<dt>obj = &quot;CovControlOgk&quot;</dt><dd><p> Compute the Ortogonalized Gnanadesikan-Kettenring (OGK) estimates of multivariate location and
scatter  by calling<code>CovOgk</code> </p>
</dd>
</dl>

<hr>
<h2 id='rice'> Rice taste data</h2><span id='topic+rice'></span>

<h3>Description</h3>

<p>The rice taste data consists of five inputs and a single output whose values 
are associated with subjective evaluations as follows: xl: flavor, 
x2: appearance, x3: taste, x4: stickiness, x5: toughness, y: overall evaluation.
Sensory test data have been obtained by such subjective evaluations for 105 kinds of
rice (e.g., Sasanishiki, Akita-Komachi, etc.). The data set was used by 
Nozaki et al. (1997) to demonstrate the high performance of a proposed 
for automatically generating fuzzy if-then rules from numerical data.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rice)</code></pre>


<h3>Format</h3>

<p>A data frame with 105 observations on the following 6 variables: 
</p>

<dl>
<dt><code>Favor</code></dt><dd><p>compactness</p>
</dd>
<dt><code>Appearance</code></dt><dd><p>circularity</p>
</dd>
<dt><code>Taste</code></dt><dd><p>distance circularity</p>
</dd>
<dt><code>Stickiness</code></dt><dd><p>radius ratio</p>
</dd>
<dt><code>Toughness</code></dt><dd><p>principal axis aspect ratio</p>
</dd>
<dt><code>Overall_evaluation</code></dt><dd><p>maximum length aspect ratio</p>
</dd>
</dl>



<h3>Source</h3>

<p>Nozaki, K., Ishibuchi, H, and Tanaka, H. (1997) 
A simple but powerful heuristic method for generating fuzzy rules from numerical data
<em>Fuzzy Sets and Systems</em> <b>86</b> 3 p. 251&ndash;270. 
</p>

<hr>
<h2 id='rrcov-utils'>Different utility functions to be used in rrcov and packages depending on rrcov</h2><span id='topic+myscreeplot'></span><span id='topic+mtxconfusion'></span><span id='topic+sqrtm'></span><span id='topic+vecnorm'></span>

<h3>Description</h3>

<p>Different utility functions to be used in rrcov and packages depending on rrcov:
</p>

<ul>
<li> <p><code>myscreeplot</code> Plots screeplots for two covariance matrices 
</p>
</li>
<li> <p><code>mtxconfusion</code> Computes a confusion matrix between actual and predicted class membership
</p>
</li>
<li><p> MATLAB-like functions
</p>
 
<ul>
<li> <p><code>sqrtm</code> Returns the square root of a symetric positive definite matrix
</p>
</li>
<li> <p><code>ones</code> Returns a nxp matrix filled with ones 
</p>
</li>
<li> <p><code>zeros</code> Returns a nxp matrix filled with zeros
</p>
</li>
<li> <p><code>vecnorm</code> Returns the norm of a vector
</p>
</li>
<li> <p><code>rankMM</code> Returns the rank of the matrix
</p>
</li>
<li> <p><code>repmat</code> Replicates a matrix
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>    myscreeplot(rcov, ccov)
    mtxconfusion(actual, predicted, prior = NULL, printit=FALSE)
    sqrtm(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrcov-utils_+3A_a">A</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="rrcov-utils_+3A_rcov">rcov</code>, <code id="rrcov-utils_+3A_ccov">ccov</code></td>
<td>
<p>Covariance matrices.</p>
</td></tr>
<tr><td><code id="rrcov-utils_+3A_actual">actual</code></td>
<td>
<p>Actual class membership.</p>
</td></tr>
<tr><td><code id="rrcov-utils_+3A_predicted">predicted</code></td>
<td>
<p>Predicted class membership.</p>
</td></tr>
<tr><td><code id="rrcov-utils_+3A_prior">prior</code></td>
<td>
<p>Prior probabilities.</p>
</td></tr>
<tr><td><code id="rrcov-utils_+3A_printit">printit</code></td>
<td>
<p>Wheather to print the results.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>

<hr>
<h2 id='salmon'>  Salmon data </h2><span id='topic+salmon'></span>

<h3>Description</h3>

<p>The salmon data contains two measurements of the growth rings on 
the scale of Alaskan and Canadian salmon as well as the gender 
of the fishes. There are 50 Alaskan-born and 50 Canadian-born salmon, and this information
is coded in the variable <code>Origin</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(salmon)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 4 variables.
</p>

<dl>
<dt><code>Gender</code></dt><dd><p>female=1 and male=2</p>
</dd>
<dt><code>Freshwater</code></dt><dd><p>diameter of rings for the first-year freshwater growth (hundrets of an inch)</p>
</dd>
<dt><code>Marine</code></dt><dd><p>diameter of rings for the first-year marine growth (hundrets of an inch)</p>
</dd>
<dt><code>Origin</code></dt><dd><p>Origin of the fish: a factor with levels <code>Alaskan</code> <code>Canadian</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Johnson, R.A. and Wichern, D. W. <em>Applied Multivariate
Statistical Analysis</em> (Prentice Hall, International
Editions, 2002, fifth edition)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(salmon)
</code></pre>

<hr>
<h2 id='scorePlot-methods'>
Score plot for Principal Components (objects of class 'Pca')
</h2><span id='topic+scorePlot'></span><span id='topic+scorePlot-methods'></span><span id='topic+scorePlot+2CANY-method'></span><span id='topic+scorePlot+2CPca-method'></span>

<h3>Description</h3>

<p>Produces a score plot from an object (derived from)  <code><a href="#topic+Pca-class">Pca-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S4 method for signature 'Pca'
scorePlot(x, i=1, j=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scorePlot-methods_+3A_x">x</code></td>
<td>
<p>an object of class (derived from) <code>"Pca"</code>.</p>
</td></tr>
<tr><td><code id="scorePlot-methods_+3A_i">i</code></td>
<td>
<p>First score coordinate, defaults to <code>i=1</code>.</p>
</td></tr>
<tr><td><code id="scorePlot-methods_+3A_j">j</code></td>
<td>
<p>Second score coordinate, defaults to <code>j=2</code>.</p>
</td></tr>
<tr><td><code id="scorePlot-methods_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to the internal graphical functions.</p>
</td></tr>
</table>


<h3>Side Effects</h3>

<p>a plot is produced on the current graphics device.
</p>


<h3>Methods</h3>


<dl>
<dt>scorePlot</dt><dd><p><code>signature(x = Pca)</code>: Plot a scatter plot of ith against jth score
of the Pca object with superimposed tollerance (0.975) ellipse. See also <code><a href="#topic+biplot">biplot</a></code>, <code><a href="#topic+screeplot">screeplot</a></code>.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Pca-class">Pca-class</a></code>,
<code><a href="#topic+PcaClassic">PcaClassic</a></code>,
<code><a href="#topic+PcaRobust-class">PcaRobust-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)

## PCA of the Hawkins Bradu Kass's Artificial Data
##  using all 4 variables
data(hbk)
pca &lt;- PcaHubert(hbk)
pca

scorePlot(pca)
</code></pre>

<hr>
<h2 id='soil'>
Exchangable cations in forest soil data set
</h2><span id='topic+soil'></span>

<h3>Description</h3>

<p>The forest soil data set contains measurements on 58 soil 
pits in the Hubbard Brook Experimental Forest in north-central
New Hampshire. The excavations were done in 1983 and 1986. The 
soil samples were analyzed for the exchangeable cations of 
aluminium, calcium, magnesium, potassium and sodium. The pit 
locations in both data sets can be classified by the 
type of the forest: 
</p>

<ul>
<li><p> 1: spruce-fir (11 samples),
</p>
</li>
<li><p> 2: high elevation hardwood (23 samples) and
</p>
</li>
<li><p> 3: low elevation hardwood (24 samples)).
</p>
</li></ul>

<p>Additionally the degree of logging disturbance can be considered
(all 0 in the 1983 data set):
</p>

<ul>
<li><p> 0: uncut forest,
</p>
</li>
<li><p> 1: cut, undisturbed by machinery and
</p>
</li>
<li><p> 2: cut, disturbed.
</p>
</li></ul>

<p>The observations are expressed in grams of exchangeable 
cations per square meter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(soil)</code></pre>


<h3>Format</h3>

<p>A data frame with 116 observations on the following 7 variables.
</p>

<dl>
<dt><code>F</code></dt><dd><p>Type of forest</p>
</dd>
<dt><code>D</code></dt><dd><p>Degree of logging disturbance</p>
</dd>
<dt><code>Al</code></dt><dd><p>Level of the exchangable cations in Al</p>
</dd>
<dt><code>Ca</code></dt><dd><p>Level of the exchangable cations in Ca</p>
</dd>
<dt><code>Mg</code></dt><dd><p>Level of the exchangable cations in Mg</p>
</dd>
<dt><code>K</code></dt><dd><p>Level of the exchangable cations in K</p>
</dd>
<dt><code>Na</code></dt><dd><p>Level of the exchangable cations in Na</p>
</dd>
</dl>



<h3>Source</h3>

<p>Morrison D.F., 2005, Multivariate Statistical Methods, Thompson
</p>


<h3>References</h3>

<p>Vanden Branden K, Hubert M (2005). 
Robust Classiffication in High Dimensions Based on the SIMCA Method. 
<em>Cbemometrics and Intelligent Laboratoty Sysiem</em>, 79: 10&ndash;21.   
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(soil)
soil1983 &lt;- soil[soil$D == 0, -2]       # only 1983, remove column D (always 0)

(cc &lt;- Linda(F~., data=soil))
(pr &lt;- predict(cc))
pr@classification

</code></pre>

<hr>
<h2 id='SummaryCov-class'>Class &quot;SummaryCov&quot; - summary of &quot;Cov&quot; objects  </h2><span id='topic+SummaryCov-class'></span><span id='topic+getCenter+2CSummaryCov-method'></span><span id='topic+getCov+2CSummaryCov-method'></span><span id='topic+getDistance+2CSummaryCov-method'></span><span id='topic+getEvals+2CSummaryCov-method'></span><span id='topic+isClassic+2CSummaryCov-method'></span><span id='topic+show+2CSummaryCov-method'></span>

<h3>Description</h3>

<p>The &quot;Cov&quot; object plus some additional summary information</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SummaryCov", ...)</code>,
but most often by invoking 'summary' on a &quot;Cov&quot; object. They contain values 
meant for printing by 'show'.
</p>


<h3>Slots</h3>


<dl>
<dt><code>covobj</code>:</dt><dd><p>Object of class <code>"Cov"</code></p>
</dd>
<dt><code>evals</code>:</dt><dd><p>eigenvalues of the covariance or correlation matrix </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getCenter</dt><dd><p><code>signature(obj = "SummaryCov")</code>: location vector </p>
</dd>
<dt>getCov</dt><dd><p><code>signature(obj = "SummaryCov")</code>: covariance matrix </p>
</dd>
<dt>getDistance</dt><dd><p><code>signature(obj = "SummaryCov")</code>: vector of distances </p>
</dd>
<dt>getEvals</dt><dd><p><code>signature(obj = "SummaryCov")</code>: vector of eignevalues </p>
</dd>
<dt>isClassic</dt><dd><p><code>signature(obj = "SummaryCov")</code>: is the estimate a classic one </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "SummaryCov")</code>: display the object </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Cov-class">Cov-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SummaryCov")
</code></pre>

<hr>
<h2 id='SummaryCovRobust-class'>Class &quot;SummaryCovRobust&quot; - summary of &quot;CovRobust&quot; objects </h2><span id='topic+SummaryCovRobust-class'></span><span id='topic+isClassic+2CSummaryCovRobust-method'></span><span id='topic+show+2CSummaryCovRobust-method'></span>

<h3>Description</h3>

<p>    Summary information for CovRobust objects meants for printing by 'show' </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SummaryCovRobust", ...)</code>, 
but most often by invoking 'summary' on an &quot;Cov&quot; object. They contain values 
meant for printing by 'show'.
</p>


<h3>Slots</h3>


<dl>
<dt><code>covobj</code>:</dt><dd><p>Object of class <code>"Cov"</code></p>
</dd>
<dt><code>evals</code>:</dt><dd><p>Eigenvalues of the covariance or correlation matrix</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"SummaryCov"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "SummaryCovRobust")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CovRobust-class">CovRobust-class</a></code>,   <code><a href="#topic+SummaryCov-class">SummaryCov-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])
cv &lt;- CovMest(hbk.x)
cv
summary(cv)
</code></pre>

<hr>
<h2 id='SummaryLda-class'> Class &quot;SummaryLda&quot; - summary of &quot;Lda&quot; objects   </h2><span id='topic+SummaryLda-class'></span><span id='topic+show+2CSummaryLda-method'></span>

<h3>Description</h3>

 
<p>Contains summary information about an <code>Lda</code> object - Linear Discriminant Analysis object </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SummaryLda", ...)</code>,
but most often by invoking 'summary' on an &quot;Lda&quot; object. They contain values 
meant for printing by 'show'.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ldaobj</code>:</dt><dd><p>Object of class <code>"Lda"</code></p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "SummaryLda")</code>: display the object </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lda-class">Lda-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SummaryLda")
</code></pre>

<hr>
<h2 id='SummaryPca-class'>Class &quot;SummaryPca&quot; - summary of &quot;Pca&quot; objects  </h2><span id='topic+SummaryPca-class'></span><span id='topic+show+2CSummaryPca-method'></span>

<h3>Description</h3>

<p>The &quot;Pca&quot; object plus some additional summary information</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SummaryPca", ...)</code>,
but most often by invoking 'summary' on a &quot;Pca&quot; object. They contain values 
meant for printing by 'show'.
</p>


<h3>Slots</h3>


<dl>
<dt><code>pcaobj</code>:</dt><dd><p>Object of class <code>"Pca"</code></p>
</dd>
<dt><code>importance</code>:</dt><dd><p>matrix with additional information: importance of components </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "SummaryPca")</code>: display the object </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pca-class">Pca-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SummaryPca")
</code></pre>

<hr>
<h2 id='SummaryQda-class'> Class &quot;SummaryQda&quot; - summary of &quot;Qda&quot; objects   </h2><span id='topic+SummaryQda-class'></span><span id='topic+show+2CSummaryQda-method'></span>

<h3>Description</h3>

 
<p>Summary information about a <code>Qda</code> - Quadratic Discriminant Analysis object </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SummaryQda", ...)</code>,
but most often by invoking 'summary' on an &quot;Qda&quot; object. They contain values 
meant for printing by 'show'.
</p>


<h3>Slots</h3>


<dl>
<dt><code>qdaobj</code>:</dt><dd><p>Object of class <code>"Qda"</code></p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "SummaryQda")</code>: display the object </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a></p>


<h3>References</h3>

<p>Todorov V &amp; Filzmoser P (2009), An Object Oriented Framework for Robust Multivariate Analysis. 
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v032.i03">doi:10.18637/jss.v032.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qda-class">Qda-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SummaryQda")
</code></pre>

<hr>
<h2 id='T2.test'>Robust Hotelling T2 test</h2><span id='topic+T2.test'></span><span id='topic+T2.test.default'></span><span id='topic+T2.test.formula'></span>

<h3>Description</h3>

<p>Performs one and two sample Hotelling T2 tests as well as robust one-sample Hotelling T2 test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T2.test(x, ...)

## Default S3 method:
T2.test(x, y = NULL, mu = 0, conf.level = 0.95, method=c("c", "mcd"), ...)

## S3 method for class 'formula'
T2.test(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T2.test_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric data frame or matrix.</p>
</td></tr>
<tr><td><code id="T2.test_+3A_y">y</code></td>
<td>
<p>an optional (non-empty) numeric data frame or matrix.</p>
</td></tr>
<tr><td><code id="T2.test_+3A_mu">mu</code></td>
<td>
<p>an optional (non-empty) numeric vector of data values (or
a single number which will be repeated p times) indicating the 
true value of the mean (or difference in means if you are 
performing a two sample test).</p>
</td></tr>
<tr><td><code id="T2.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval</p>
</td></tr>
<tr><td><code id="T2.test_+3A_method">method</code></td>
<td>
<p>the method to be used - 'c' for sample mean and covariance matrix and
'mcd' for minimum covariance determinant estimator. A two-sample MCD based T2-test is not 
yet implemented.</p>
</td></tr>
<tr><td><code id="T2.test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code>
is a numeric data frame or matrix giving the observations and <code>rhs</code> a factor
with two levels giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="T2.test_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="T2.test_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used (currently not used)</p>
</td></tr>
<tr><td><code id="T2.test_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to
<code>getOption("na.action")</code> (currently only &quot;na.rm&quot; used)</p>
</td></tr>
<tr><td><code id="T2.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula interface is only applicable for the two-sample tests.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the T2-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the T2-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the mean vector appropriate to the
specified alternative hypothesis.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated mean vector or vectors depending on
whether it was a one-sample test or a two-sample test.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the mean or mean
difference depending on whether it was a one-sample test or a
two-sample test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of T2-test was
performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

 
<p>Willems G., Pison G., Rousseeuw P. and Van Aelst S.  (2002), 
A robust hotelling test, 
<em>Metrika</em>, <b>55</b>, 125&ndash;138.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CovMcd">CovMcd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## One-sample classical test
data(delivery)
delivery.x &lt;- delivery[,1:2]
T2.test(delivery.x)

## One-sample robust test
data(delivery)
delivery.x &lt;- delivery[,1:2]
T2.test(delivery.x, method="mcd")

## Two-sample classical test
data(hemophilia)
grp &lt;-as.factor(hemophilia[,3])
x &lt;- hemophilia[which(grp==levels(grp)[1]),1:2]
y &lt;- hemophilia[which(grp==levels(grp)[2]),1:2]
T2.test(x,y)

## or using the formula interface
T2.test(as.matrix(hemophilia[,-3])~hemophilia[,3])


## Not run: 
## Two-sample robust test
T2.test(x,y, method="mcd")    ## error - not yet implemented

## End(Not run)</code></pre>

<hr>
<h2 id='un86'> United Nations Data - 1986</h2><span id='topic+un86'></span>

<h3>Description</h3>

<p>This data set consists of seven socioeconomic variables observed for 73 countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(un86)</code></pre>


<h3>Format</h3>

<p>A data frame with 73 observations on the following 7 variables.
</p>

<dl>
<dt><code>POP</code></dt><dd><p>Total population in milions</p>
</dd>
<dt><code>MOR</code></dt><dd><p>Number of infant deaths per thousand births</p>
</dd>
<dt><code>CAR</code></dt><dd><p>Number of motorized vehicles per hundred inhabitants</p>
</dd>
<dt><code>DR</code></dt><dd><p>Number of medical doctors per thousand inhabitants</p>
</dd>
<dt><code>GNP</code></dt><dd><p>Gross national product per inhabitant in thousands of US dollars</p>
</dd>
<dt><code>DEN</code></dt><dd><p>Density in inhabitants per square kilometer</p>
</dd>
<dt><code>TB</code></dt><dd><p>Trade balance, defined as total exports/(total exports + total imports)</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data set is from World Statistics in Brief, Number 10, a 1986 UN publication. It was used in Daigle et al. (1992) to illustrate a robust biplot method.
</p>


<h3>Source</h3>

<p>World Statistics in Brief, Number 10, a 1986 United Nations publication 
</p>
<p>Daigle, G. and Rivest, L. (1992) A robust biplot, The canadian Journal of Statistics, 
20, pp 241&ndash;255
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(un86)
pairs(un86)
</code></pre>

<hr>
<h2 id='wages'>Wages and Hours</h2><span id='topic+wages'></span>

<h3>Description</h3>

<p>The data are from a national sample of 6000 households with a male head earning less than 
USD 15,000 annually in 1966. The data were clasified into 39 demographic groups for 
analysis. The study was undertaken in the context of proposals for a guaranteed 
annual wage (negative income tax). At issue was the response of labor supply 
(average hours) to increasing hourly wages. 
The study was undertaken to estimate this response from available data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wages)</code></pre>


<h3>Format</h3>

<p>A data frame with 39 observations on the following 10 variables: 
</p>

<dl>
<dt><code>HRS</code></dt><dd><p>Average hours worked during the year</p>
</dd>
<dt><code>RATE</code></dt><dd><p>Average hourly wage (USD)</p>
</dd>
<dt><code>ERSP</code></dt><dd><p>Average yearly earnings of spouse (USD)</p>
</dd>
<dt><code>ERNO</code></dt><dd><p>Average yearly earnings of other family members (USD)</p>
</dd>
<dt><code>NEIN</code></dt><dd><p>Average yearly non-earned income</p>
</dd>
<dt><code>ASSET</code></dt><dd><p>Average family asset holdings (Bank account, etc.) (USD)</p>
</dd>
<dt><code>AGE</code></dt><dd><p>Average age of respondent</p>
</dd>
<dt><code>DEP</code></dt><dd><p>Average number of dependents</p>
</dd>
<dt><code>RACE</code></dt><dd><p>Percent of white respondents</p>
</dd>
<dt><code>SCHOOL</code></dt><dd><p>Average highest grade of school completed</p>
</dd>
</dl>



<h3>Source</h3>

<p>DASL library
'http://lib.stat.cmu.edu/DASL/Datafiles/wagesdat.html'
</p>


<h3>References</h3>

<p>D.H. Greenberg and M. Kosters, (1970). Income Guarantees and the Working Poor, The Rand Corporation. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(wages)
    names(wages)
    x &lt;- as.matrix(wages)
    ok &lt;- is.finite(x %*% rep(1, ncol(x)))
    wages &lt;- wages[ok, , drop = FALSE]
    wages.lm &lt;- lm(HRS~AGE, data=wages)
    plot(HRS ~ AGE, data = wages)
    abline(wages.lm)
    class(wages.lm)
    names(wages.lm)
    summary(wages.lm)
    
    wages.mm &lt;- lmrob(HRS~AGE, data=wages)
    plot(HRS ~ AGE, data = wages)
    abline(wages.mm)
    class(wages.mm)
    names(wages.mm)
    summary(wages.mm)   
</code></pre>

<hr>
<h2 id='Wilks.test'>
Classical and Robust One-way MANOVA: Wilks Lambda
</h2><span id='topic+Wilks.test'></span><span id='topic+Wilks.test.default'></span><span id='topic+Wilks.test.data.frame'></span><span id='topic+Wilks.test.formula'></span><span id='topic+Wilks.test.matrix'></span><span id='topic+model.frame.Wilks.test'></span>

<h3>Description</h3>

<p>Classical and Robust One-way MANOVA: Wilks Lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'formula'
Wilks.test(formula, data, ..., subset, na.action)

## Default S3 method:
Wilks.test(x, grouping, method=c("c", "mcd", "rank"), 
    approximation=c("Bartlett", "Rao", "empirical"),
    xd=NULL, xq=NULL, xfn = NULL, xwl=NULL, nrep=3000, trace=FALSE, ...)

## S3 method for class 'data.frame'
Wilks.test(x, ...)

## S3 method for class 'matrix'
Wilks.test(x, grouping, ..., subset, na.action)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wilks.test_+3A_formula">formula</code></td>
<td>

<p>A formula of the form <code>groups ~ x1 + x2 + ...</code>  That is, the
response is the grouping factor and the right hand side specifies
the (non-factor) variables.
</p>
</td></tr>
<tr><td><code id="Wilks.test_+3A_data">data</code></td>
<td>

<p>Data frame from which variables specified in <code>formula</code> are
to be taken.
</p>
</td></tr>
<tr><td><code id="Wilks.test_+3A_x">x</code></td>
<td>

<p>(required if no formula is given as the principal argument.)
a matrix or data frame or Matrix containing the explanatory variables.
</p>
</td></tr>
<tr><td><code id="Wilks.test_+3A_grouping">grouping</code></td>
<td>

<p>grouping variable - a factor specifying the class for each 
observation (required if no formula argument is given.)
</p>
</td></tr>
<tr><td><code id="Wilks.test_+3A_subset">subset</code></td>
<td>

<p>An index vector specifying the cases to be used. 
</p>
</td></tr>
<tr><td><code id="Wilks.test_+3A_na.action">na.action</code></td>
<td>

<p>A function to specify the action to be taken if <code>NA</code>s are found.
The default action is for the procedure to fail.  An alternative is
<code>na.omit</code>, which leads to rejection of cases with missing values on
any required variable. 
</p>
</td></tr>
<tr><td><code id="Wilks.test_+3A_method">method</code></td>
<td>

<p><code>"c"</code> for standard estimators of the mean and variance,
<code>"mcd"</code> for MCD estimators of mean and variances and 
<code>"rank"</code> for rank based wilks' lambda as proposed by Nath and Pavur (1985).
</p>
</td></tr>
<tr><td><code id="Wilks.test_+3A_approximation">approximation</code></td>
<td>

<p><code>"Bartlett"</code> for Bartlett approximation (default),
<code>"Rao"</code> for rao approximation (only for method=&quot;c&quot;) and
<code>"empirical"</code> for simulated empirical distribution.
</p>
</td></tr>
<tr><td><code id="Wilks.test_+3A_xd">xd</code></td>
<td>
<p>multiplication factor for the approximate distribution of 
the robust Lambda statistic. If <code>xd=NULL</code> the factor will
computed by simulation and will be returned in the value (see Details)
</p>
</td></tr>
<tr><td><code id="Wilks.test_+3A_xq">xq</code></td>
<td>
<p>the degrees of freedom for the approximate <code class="reqn">\chi^2</code> distribution of 
the robust Lambda statistic. If <code>xq=NULL</code> the degrees of freedom will
computed by simulation and will be returned in the value (see Details)
</p>
</td></tr>
<tr><td><code id="Wilks.test_+3A_xfn">xfn</code></td>
<td>
<p>the empirical distribution function. If <code>xfn=NULL</code> the empirical function  will
be estimated by simulation and will be returned in the value (see Details)
</p>
</td></tr>
<tr><td><code id="Wilks.test_+3A_xwl">xwl</code></td>
<td>
<p>the simulated values of the robust statistic. If <code>xwl=NULL</code> the simulation 
will be performed and the calculated result will be returned in the value (see Details)
</p>
</td></tr>
<tr><td><code id="Wilks.test_+3A_nrep">nrep</code></td>
<td>
<p>number of trials for the simulations for computing the 
multiplication factor <code>xd</code> and the degrees of freedom <code>xq</code>. Default is <code>nrep=3000</code>.
</p>
</td></tr>
<tr><td><code id="Wilks.test_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td></tr>  
<tr><td><code id="Wilks.test_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The classical Wilks' Lambda statistic for testing the equality of 
the group means of two or more groups is modified into a robust 
one through substituting the classical estimates by the highly robust 
and efficient reweighted MCD estimates, which can be computed efficiently 
by the FAST-MCD algorithm - see <code><a href="#topic+CovMcd">CovMcd</a></code>. 
An approximation for the finite sample distribution of the
Lambda statistic is obtained, based on matching the mean and 
variance of a multiple of an <code class="reqn">\chi^2</code> distribution which 
are computed by simultaion.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the Wilks' Lambda statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>The corresponding approximation of the Wilks' lambda statistic and the degrees of freedom.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated mean vectors.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
<tr><td><code>xd</code></td>
<td>
<p>multiplication factor for the approximate distribution of 
the robust Lambda statistic. 
</p>
</td></tr>
<tr><td><code>xq</code></td>
<td>
<p>the degrees of freedom for the approximate <code class="reqn">\chi^2</code> distribution of 
the robust Lambda statistic. 
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function may be called giving either a formula and
optional data frame, or a matrix and grouping factor as the first
two arguments.  All other arguments are optional.
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

 
<p>Todorov, V. and Filzmoser, P. (2007) Robust statistic for the one-way MANOVA,
<em>submetted to the Journal of Environmetrics</em>.
</p>
<p>Todorov, V. (2007) Robust selection of variables in linear discriminant 
analysis, <em>Statistical Methods and Applications</em>, <b>15</b>, 
395.407, doi:10.1007/s10260-006-0032-6.
</p>
<p>Nath, R. and Pavur, R. (1985) A new statistic in the one way 
multivariate analysis of variance, <em>Computatational 
Statistics and Data Analysis</em>, <b>2</b>, 297&ndash;315
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CovMcd">CovMcd</a></code>, <code><a href="#topic+T2.test">T2.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
data(anorexia)
grp &lt;- as.factor(anorexia[,1])
x &lt;- as.matrix(anorexia[,2:3])
##  Using the default interface, classical test
Wilks.test(x, grouping=grp, method="c")

##  Using the default interface, rank based test
Wilks.test(x, grouping=grp, method="rank")

## For this data set: p=2, n=n1+n2+n3=29+26+17
## were computed the following multiplication factor xd and degrees of freedom xq
##  for the MCD estimates with alpha=0.5
xd &lt;-  -0.02162666
xq &lt;- 3.63971
Wilks.test(x, grouping=grp, method="mcd", xd=xd, xq=xq)

## Now the same with the formula interface
Wilks.test(Treat~Prewt+Postwt, data=anorexia, method="mcd", xd=xd, xq=xq)

##Iris data with formula interface
data(iris)
Wilks.test(Species~., data=iris, method="c")

## and with default interface
Wilks.test(iris[,1:4],grouping=iris[,5], method="c")

# hemophilia data - classical, rank and MCD test
data(hemophilia)
hemophilia$gr &lt;- as.factor(hemophilia$gr)

Wilks.test(gr~., data=hemophilia, method="c")
Wilks.test(gr~., data=hemophilia, method="rank")
## already simulated parameters for MCD with alpha=0.5
xd &lt;- -0.01805436
xq &lt;- 1.950301
Wilks.test(gr~., data=hemophilia, xd=xd, xq=xq, method="mcd")

</code></pre>

<hr>
<h2 id='wolves'>Skull dimensions of the wolf <em>Canis lupus</em> L.</h2><span id='topic+wolves'></span>

<h3>Description</h3>

<p>A data set containing skull morphometric measurements on Rocky Mountain
and Arctic wolves (<em>Canis Lupus L.</em>). The tdata are published in Morrison (1990),
originally from Jolicoeur (1959).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wolves)
</code></pre>


<h3>Format</h3>

<p>A data frame with 25 rows and 12 variables.
The variables are as follows (all measurements are in milimeters):
</p>

<ul>
<li> <p><code>class</code>: a factor presenting the combinations of <code>location</code>
and <code>sex</code>. The levels are <code>arf</code> <code>arm</code> <code>rmf</code> and <code>rmm</code>
</p>
</li>
<li> <p><code>location</code>: a factor with levels <code>ar</code>=Arctic, <code>rm</code>=Rocky Mountain
</p>
</li>
<li> <p><code>sex</code>: a factor with levels <code>f</code>=female, <code>m</code>=male
</p>
</li>
<li> <p><code>x1</code>: palatal length
</p>
</li>
<li> <p><code>x2</code>: postpalatal length
</p>
</li>
<li> <p><code>x3</code>: zygomatic width
</p>
</li>
<li> <p><code>x4</code>: palatal width outside first upper molars
</p>
</li>
<li> <p><code>x5</code>: palatal width inside second upper molars
</p>
</li>
<li> <p><code>x6</code>: postglenoid foramina width
</p>
</li>
<li> <p><code>x7</code>: interorbital width
</p>
</li>
<li> <p><code>x8</code>: braincase width
</p>
</li>
<li> <p><code>x9</code>: crown length
</p>
</li></ul>



<h3>Source</h3>

<p>Jolicoeur, P. Multivariate geographical variation in the wolf <em>Canis lupis L.</em>,
<em>Evolution</em>, XIII, 283&ndash;299.
</p>
<p>Morrison, D. F.  <em>Multivariate Statistical Methods</em>,  (3rd ed.), 1990.
New York: McGraw-Hill, p. 288&ndash;289.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(wolves)

 ## Remove the factors location and sex which we will not use for now
 x &lt;- wolves[,-c(2:3)]

 ## Plot a pairwise scaterplot matrix
 pairs(x[,2:10])

 mcd &lt;- CovMcd(x[, 2:10])
 plot(mcd, which="pairs")

 lda &lt;- LdaClassic(class~., data=x)
 lda@center
 lda@cov

 predict(lda)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
