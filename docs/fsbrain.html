<!DOCTYPE html><html lang="en"><head><title>Help for package fsbrain</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fsbrain}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alphablend'><p>Perform alpha blending for pairs of RGBA colors.</p></a></li>
<li><a href='#annot.outline'><p>Compute outline vertex colors from annotation.</p></a></li>
<li><a href='#annot.outline.border.vertices'><p>Compute the border vertices for each region in an annot.</p></a></li>
<li><a href='#apply.label.to.morphdata'><p>Load a label from file and apply it to morphometry data.</p></a></li>
<li><a href='#apply.labeldata.to.morphdata'><p>Apply a label to morphometry data.</p></a></li>
<li><a href='#apply.transform'><p>Apply matmult transformation to input.</p></a></li>
<li><a href='#arrange.brainview.images'><p>Combine several brainview images into a new figure.</p></a></li>
<li><a href='#arrange.brainview.images.grid'><p>Combine several brainview images as a grid into a new figure.</p></a></li>
<li><a href='#boxcoords.from.bbox'><p>Compute the coordinates of the 8 corners of a 3D box.</p></a></li>
<li><a href='#brain'><p>Create fsbrain instance from 2 coloredmeshes.</p></a></li>
<li><a href='#brainview.sd'><p>Visualize a list of colored meshes from a single defined angle.</p></a></li>
<li><a href='#brainview.si'><p>Visualize a list of colored meshes from a single viewpoint, interactively.</p></a></li>
<li><a href='#brainview.sr'><p>Visualize a list of colored meshes, rotating the camera around them.</p></a></li>
<li><a href='#brainview.t4'><p>Visualize a list of colored meshes from four angles.</p></a></li>
<li><a href='#brainview.t9'><p>Visualize a list of colored meshes from nine angles.</p></a></li>
<li><a href='#brainviews'><p>Show one or more views of the given meshes in rgl windows.</p></a></li>
<li><a href='#can.plot.colorbar'><p>Determine whether colorbar can be plotted with given metadata.</p></a></li>
<li><a href='#can.plot.colorbar.from.coloredmeshes'><p>Determine whether colorbar can be plotted with given coloredmeshes.</p></a></li>
<li><a href='#check.subjects.files'><p>Report subjects missing files</p></a></li>
<li><a href='#check.subjectslist'><p>Check whether the subjects_list looks good, warn if not.</p></a></li>
<li><a href='#clip_fun'><p>Get data clipping function.</p></a></li>
<li><a href='#clip.data'><p>Clip data at quantiles to remove outliers.</p></a></li>
<li><a href='#cm.cbry'><p>Get cyan blue red yellow colormap function.</p></a></li>
<li><a href='#cm.div'><p>Return the standard fsbrain diverging colormap.</p></a></li>
<li><a href='#cm.heat'><p>Return the standard fsbrain heat colormap.</p></a></li>
<li><a href='#cm.qual'><p>Return the standard fsbrain qualitative colormap.</p></a></li>
<li><a href='#cm.seq'><p>Return the standard fsbrain sequential colormap.</p></a></li>
<li><a href='#collayer.bg'><p>Compute binarized mean curvature surface color layer.</p></a></li>
<li><a href='#collayer.bg.atlas'><p>Compute atlas or annotation surface color layer.</p></a></li>
<li><a href='#collayer.bg.meancurv'><p>Compute binarized mean curvature surface color layer.</p></a></li>
<li><a href='#collayer.bg.sulc'><p>Compute binarized sulcal depth surface color layer.</p></a></li>
<li><a href='#collayer.from.annot'><p>Compute surface color layer from annotation or atlas data.</p></a></li>
<li><a href='#collayer.from.annotdata'><p>Compute surface color layer from annotation or atlas data.</p></a></li>
<li><a href='#collayer.from.mask.data'><p>Compute surface color layer from morph-like data.</p></a></li>
<li><a href='#collayer.from.morphlike.data'><p>Compute surface color layer from morph-like data.</p></a></li>
<li><a href='#collayers.merge'><p>Merge two or more color layers based on their transparency values.</p></a></li>
<li><a href='#coloredmesh.from.annot'><p>Create a coloredmesh from an annotation of an atlas.</p></a></li>
<li><a href='#coloredmesh.from.color'><p>Create a coloredmesh from a mesh and pre-defined colors.</p></a></li>
<li><a href='#coloredmesh.from.label'><p>Create a coloredmesh from a label.</p></a></li>
<li><a href='#coloredmesh.from.mask'><p>Create a coloredmesh from a mask.</p></a></li>
<li><a href='#coloredmesh.from.morph.native'><p>Create a coloredmesh from native space morphometry data.</p></a></li>
<li><a href='#coloredmesh.from.morph.standard'><p>Create a coloredmesh from standard space morphometry data.</p></a></li>
<li><a href='#coloredmesh.from.morphdata'><p>Create a coloredmesh from arbitrary data.</p></a></li>
<li><a href='#coloredmesh.from.preloaded.data'><p>Generate coloredmesh from loaded data.</p></a></li>
<li><a href='#coloredmesh.plot.colorbar.separate'><p>Draw colorbar for coloredmeshes in separate 2D plot.</p></a></li>
<li><a href='#coloredmeshes.combined.data.range'><p>Retrieve combined data range from hemilist of coloredmeshes.</p></a></li>
<li><a href='#coloredmeshes.from.color'><p>Create coloredmeshes for both hemis using pre-defined colors.</p></a></li>
<li><a href='#coloredmeshes.get.md'><p>Retrieve metadata from hemilist of coloredmeshes.</p></a></li>
<li><a href='#colorlist.brain.clusters'><p>Return diverging color list</p></a></li>
<li><a href='#colors.are.grayscale'><p>Check for the given color strings whether they represent gray scale colors.</p></a></li>
<li><a href='#colors.have.transparency'><p>Check for the given color strings whether they have transparency, i.e., an alpha channel value != fully opaque.</p></a></li>
<li><a href='#combine.colorbar.with.brainview.animation'><p>Combine a colorbar and a brain animation in gif format into a new animation.</p></a></li>
<li><a href='#combine.colorbar.with.brainview.image'><p>Combine a colorbar and a brainview image into a new figure.</p></a></li>
<li><a href='#combine.colorbar.with.brainview.image.vertical'><p>Combine a vertical colorbar and a brainview image into a new figure.</p></a></li>
<li><a href='#common.makecmap.range'><p>Get cmap and colorlayer from data and makecmap_options.</p></a></li>
<li><a href='#constant.pervertexdata'><p>Get vertex data for a single fs.surface or a hemilist of surfaces.</p></a></li>
<li><a href='#cube3D.tris'><p>Return triangles for a 3D cube or cuboid.</p></a></li>
<li><a href='#cubes3D.tris'><p>Vectorized version of cube3D.tris</p></a></li>
<li><a href='#deepcopylist.long'><p>Write deepcopy list for longitudinal subjects.</p></a></li>
<li><a href='#deg2rad'><p>Convert degree to radians</p></a></li>
<li><a href='#delete_all_optional_data'><p>Delete all data in the package cache.</p></a></li>
<li><a href='#demo'><p>Show demo visualization to test whether fsbrain is setup correctly.</p></a></li>
<li><a href='#demographics.to.fsgd.file'><p>Write FreeSurfer Group Descriptor (FSGD) file from demographics dataframe.</p></a></li>
<li><a href='#demographics.to.qdec.table.dat'><p>Convert a dataframe containing demographics data to a qdec.table.dat file and related files.</p></a></li>
<li><a href='#desaturate'><p>Perform simple desaturation or grayscale conversion of RGBA colors.</p></a></li>
<li><a href='#download_fsaverage'><p>Download the FreeSurfer v6 fsaverage subject.</p></a></li>
<li><a href='#download_fsaverage3'><p>Download the FreeSurfer v6 low-resolution fsaverage3 subject.</p></a></li>
<li><a href='#download_optional_data'><p>Download optional data for this package if required.</p></a></li>
<li><a href='#download_optional_paper_data'><p>Download extra data to reproduce the figures from the fsbrain paper.</p></a></li>
<li><a href='#draw.colorbar'><p>Draw colorbar into background of current plot.</p></a></li>
<li><a href='#eeg_coords'><p>Internal function to get some demo EEG electrode coordinates. Will be removed from public API. Do not use this.</p></a></li>
<li><a href='#ensure.fs.surface'><p>Check whether parameter is an fs.surface instance.</p></a></li>
<li><a href='#ensure.tmesh3d'><p>Ensure the mesh is a tmesh3d instance. Will convert fs.surfaces to one automatically.</p></a></li>
<li><a href='#export'><p>Export high-quality brainview image with a colorbar.</p></a></li>
<li><a href='#export.coloredmesh.ply'><p>Export a coloredmeshes with vertexcolors in PLY format.</p></a></li>
<li><a href='#extend_neighbors'><p>Recursive computation of neighborhoods, see surf.sphere.dist</p></a></li>
<li><a href='#extract.volume.3D'><p>Try to extract a 3D volume from the input argument.</p></a></li>
<li><a href='#face.edges'><p>Enumerate all edges of the given faces or mesh.</p></a></li>
<li><a href='#find.freesurferhome'><p>Find the FREESURFER_HOME directory on disk.</p></a></li>
<li><a href='#find.subjectsdir.of'><p>Find the subject directory containing the fsaverage subject (or others) on disk.</p></a></li>
<li><a href='#flc'><p>Given a list of path coordinates, create matrix containing only the first and last point of each path.</p></a></li>
<li><a href='#force.to.range'><p>Change data to ensure requested data_range.</p></a></li>
<li><a href='#fs.coloredmesh'><p>fs.coloredmesh constructor</p></a></li>
<li><a href='#fs.home'><p>Return FreeSurfer path.</p></a></li>
<li><a href='#fs.surface.as.adjacencylist'><p>Turn surface mesh into a igraph and return its adjacency list representation.</p></a></li>
<li><a href='#fs.surface.to.igraph'><p>Create igraph undirected graph from a brain surface mesh.</p></a></li>
<li><a href='#fs.surface.to.tmesh3d'><p>Get an rgl tmesh3d instance from a brain surface mesh.</p></a></li>
<li><a href='#fs.surface.vertex.neighbors'><p>Compute vertex neighborhoods or the full adjacency list for a mesh using the Rvcg or igraph library.</p></a></li>
<li><a href='#fs.value.list.from.agg.res'><p>Create a named value list from a dataframe.</p></a></li>
<li><a href='#fsaverage.path'><p>Return path to fsaverage dir.</p></a></li>
<li><a href='#fsbrain.renderable'><p>Check whether object can be rendered by fsbrain</p></a></li>
<li><a href='#fsbrain.set.default.figsize'><p>Set default figure size for fsbrain visualization functions.</p></a></li>
<li><a href='#fslong.subjects.detect'><p>Get subject names from sub directories of FreeSurfer long directory.</p></a></li>
<li><a href='#fslong.subjects.finished'><p>Find completely run FreeSurfer long subjects in a recon-all long output folder.</p></a></li>
<li><a href='#fup'><p>Transform first character of a string to uppercase.</p></a></li>
<li><a href='#gen.test.volume'><p>Generate test 3D volume of integers. The volume has an outer background area (intensity value 'bg') and an inner foreground areas (intensity value 200L).</p></a></li>
<li><a href='#geod.patches.color.overlay'><p>Generate color overlay from geodesic patches around several vertices.</p></a></li>
<li><a href='#geod.patches.color.overlay.singlehemi'><p>Generate color overlay from geodesic patches around several vertices for a single hemi.</p></a></li>
<li><a href='#geod.patches.pervertexdata'><p>Generate per-vertex distance data from geodesic patches around several vertices.</p></a></li>
<li><a href='#geod.patches.pervertexdata.singlehemi'><p>Generate per-vertex distance data from geodesic patches around several vertices for a single hemi.</p></a></li>
<li><a href='#geod.vert.neighborhood'><p>Compute all vertices within given geodesic distance on the mesh.</p></a></li>
<li><a href='#geodesic.average.distance'><p>Compute the average (pseudo-) geodesic distance on the mesh from each vertex to all other vertices.</p></a></li>
<li><a href='#geodesic.ballstats'><p>Compute geodesic ball area and perimeter at location defined by geodists for all radii.</p></a></li>
<li><a href='#geodesic.circles'><p>Compute geodesic circles and ball stats for given vertices.</p></a></li>
<li><a href='#geodesic.dists.to.vertex'><p>Simple internal wrapper around <code>Rvcg::vcgDijkstra</code> with function check.</p></a></li>
<li><a href='#geodesic.path'><p>Compute geodesic path from a source vertex to one or more target vertices.</p></a></li>
<li><a href='#get_optional_data_filepath'><p>Access a single file from the package cache by its file name.</p></a></li>
<li><a href='#get.atlas.region.names'><p>Determine atlas region names from a subject.</p></a></li>
<li><a href='#get.rglstyle'><p>Get the default visualization style parameters as a named list.</p></a></li>
<li><a href='#get.rglstyle.default'><p>Get the default visualization style parameters as a named list.</p></a></li>
<li><a href='#get.rglstyle.edges'><p>Get the mesh edges visualization style parameters as a named list.</p></a></li>
<li><a href='#get.rglstyle.glass'><p>Get the glass visualization style parameters as a named list.</p></a></li>
<li><a href='#get.rglstyle.glass2'><p>Get the glass2 visualization style parameters as a named list.</p></a></li>
<li><a href='#get.rglstyle.parameters'><p>Produce the named list of style parameters from style definition.</p></a></li>
<li><a href='#get.rglstyle.semitransparent'><p>Get the semi-transparent visualization style parameters as a named list.</p></a></li>
<li><a href='#get.rglstyle.shiny'><p>Get a shiny visualization style.</p></a></li>
<li><a href='#get.slice.indices'><p>Compute slice indices from slice definition.</p></a></li>
<li><a href='#get.subject.class'><p>Construct FSGD Class name from group and non-continuous covariate columns.</p></a></li>
<li><a href='#get.view.angle.names'><p>Get list of valid view angle names.</p></a></li>
<li><a href='#getIn'><p>Retrieve values from nested named lists</p></a></li>
<li><a href='#group.agg.atlas.native'><p>Aggregate native space morphometry data over brain atlas regions and subjects for a group of subjects.</p></a></li>
<li><a href='#group.agg.atlas.standard'><p>Aggregate standard space morphometry data over brain atlas regions and subjects for a group of subjects.</p></a></li>
<li><a href='#group.annot'><p>Load annotations for a group of subjects.</p></a></li>
<li><a href='#group.concat.measures.native'><p>Concatenate native space data for a group of subjects.</p></a></li>
<li><a href='#group.concat.measures.standard'><p>Concatenate standard space data for a group of subjects.</p></a></li>
<li><a href='#group.data.to.array'><p>Convert group 2D data (1 vector per subject) to 4D array format.</p></a></li>
<li><a href='#group.label'><p>Retrieve label data for a group of subjects.</p></a></li>
<li><a href='#group.label.from.annot'><p>Extract a region from an atlas annotation as a label for a group of subjects.</p></a></li>
<li><a href='#group.morph.agg.native'><p>Aggregate native space morphometry data over one hemisphere for a group of subjects.</p></a></li>
<li><a href='#group.morph.agg.standard'><p>Aggregate standard space (fsaverage) morphometry data over one hemisphere for a group of subjects.</p></a></li>
<li><a href='#group.morph.agg.standard.vertex'><p>Aggregate standard space morphometry data over subjects.</p></a></li>
<li><a href='#group.morph.native'><p>Retrieve native space morphometry data for a group of subjects.</p></a></li>
<li><a href='#group.morph.standard'><p>Retrieve standard space morphometry data for a group of subjects.</p></a></li>
<li><a href='#group.morph.standard.sf'><p>Read combined data for a group from a single file.</p></a></li>
<li><a href='#group.multimorph.agg.native'><p>Aggregate native space morphometry data for multiple measures over hemispheres for a group of subjects.</p></a></li>
<li><a href='#group.multimorph.agg.standard'><p>Aggregate standard space (fsaverage) morphometry data for multiple measures over hemispheres for a group of subjects.</p></a></li>
<li><a href='#group.surface'><p>Retrieve surface mesh data for a group of subjects.</p></a></li>
<li><a href='#groupmorph.split.hemilist'><p>Split a per-vertex group data matrix for both hemispheres into a hemilist at given index.</p></a></li>
<li><a href='#handle.rglactions.highlight.points'><p>Highlight requested points (if any), but apply given view rotation before doing so.</p></a></li>
<li><a href='#hasIn'><p>Check for values in nested named lists</p></a></li>
<li><a href='#hemi.lobe.labels'><p>Compute lobe labels for a single hemi from aparc atlas.</p></a></li>
<li><a href='#hemilist'><p>Create a hemilist from lh and rh data.</p></a></li>
<li><a href='#hemilist.derive.hemi'><p>Derive 'hemi' string from the data in a hemilist</p></a></li>
<li><a href='#hemilist.from.prefixed.list'><p>Create a hemilist from a named list with keys prefixed with 'lh_' and 'rh_'.</p></a></li>
<li><a href='#hemilist.get.combined.data'><p>Get combined data of hemi list</p></a></li>
<li><a href='#hemilist.unwrap'><p>Unwrap hemi data from a named hemi list.</p></a></li>
<li><a href='#hemilist.wrap'><p>Wrap data into a named hemi list.</p></a></li>
<li><a href='#hemlist.ensure.contains'><p>title Ensure an key for a hemilist exists.</p></a></li>
<li><a href='#highlight.points.spheres'><p>Draw small 3D spheres at given points.</p></a></li>
<li><a href='#highlight.vertices.on.subject'><p>Highlight vertices given by index on a subject's meshes by coloring faces.</p></a></li>
<li><a href='#highlight.vertices.on.subject.spheres'><p>Highlight vertices given by index on a subject's meshes by coloring faces.</p></a></li>
<li><a href='#highlight.vertices.spheres'><p>Draw small 3D spheres at given brain mesh vertices. Supports full brain (2 meshes) as well.</p></a></li>
<li><a href='#hull.retain.along.axis'><p>Copy the first *n* foreground voxel values.</p></a></li>
<li><a href='#image.remap.color'><p>Remap a color in an image, typically used to set the background color to transparent.</p></a></li>
<li><a href='#images.annotate'><p>Annotate image with text.</p></a></li>
<li><a href='#images.dimmax'><p>Compute max width and height of magick images.</p></a></li>
<li><a href='#images.rescale.to.max.canvas'><p>Rescale all images canvas to match the largest one.</p></a></li>
<li><a href='#images.same.height'><p>Extent all images to the height of the image with maximal height.</p></a></li>
<li><a href='#images.same.width'><p>Extent all images to the width of the image with maximal width.</p></a></li>
<li><a href='#is.fs.coloredmesh'><p>Check whether object is an fs.coloredmesh (S3)</p></a></li>
<li><a href='#is.fs.coloredvoxels'><p>Check whether object is an fs.coloredvoxels instance (S3)</p></a></li>
<li><a href='#is.fsbrain'><p>Check whether object is an fsbrain (S3)</p></a></li>
<li><a href='#is.hemilist'><p>Check whether x is a hemilist</p></a></li>
<li><a href='#is.Triangles3D'><p>Check whether object is a Triangles3D instance</p></a></li>
<li><a href='#label.border'><p>Compute border of a label.</p></a></li>
<li><a href='#label.border.fast'><p>Compute border vertices of a label using Rvcg.</p></a></li>
<li><a href='#label.colFn'><p>A simple colormap function for binary colors.</p></a></li>
<li><a href='#label.colFn.inv'><p>A simple colormap function for binary colors.</p></a></li>
<li><a href='#label.from.annotdata'><p>Extract a region from an annotation as a label.</p></a></li>
<li><a href='#label.to.annot'><p>Merge several labels into an annotation</p></a></li>
<li><a href='#labeldata.from.mask'><p>Create labeldata from a mask.</p></a></li>
<li><a href='#limit_fun'><p>Get data limiting function.</p></a></li>
<li><a href='#limit_fun_na'><p>Get data limiting function to NA.</p></a></li>
<li><a href='#limit_fun_na_inside'><p>Get data limiting function, setting values inside range to NA.</p></a></li>
<li><a href='#list_optional_data'><p>Get file names available in package cache.</p></a></li>
<li><a href='#magick.grid'><p>Arrange a multi-frame ImageMagick image into a grid.</p></a></li>
<li><a href='#mask.from.labeldata.for.hemi'><p>Create a binary mask from labels.</p></a></li>
<li><a href='#mergehemi.annots'><p>Merge the annotations from two hemispheres into one annot.</p></a></li>
<li><a href='#mesh.vertex.included.faces'><p>Return all faces which are made up completely of the listed vertices.</p></a></li>
<li><a href='#mesh.vertex.neighbors'><p>Compute neighborhood of a vertex</p></a></li>
<li><a href='#mkco.cluster'><p>Return recommended 'makecmap_options' for diverging cluster data.</p></a></li>
<li><a href='#mkco.div'><p>Return recommended 'makecmap_options' for diverging data.</p></a></li>
<li><a href='#mkco.heat'><p>Return recommended 'makecmap_options' for sequential data with heatmap style.</p></a></li>
<li><a href='#mkco.seq'><p>Return recommended 'makecmap_options' for sequential data.</p></a></li>
<li><a href='#normalize'><p>Normalize data.</p></a></li>
<li><a href='#numverts.lh'><p>Determine vertex count of left hemi from hemilist of surfaces or the count itself.</p></a></li>
<li><a href='#numverts.rh'><p>Determine vertex count of right hemi from hemilist of surfaces or the count itself.</p></a></li>
<li><a href='#path.colors.from.orientation'><p>Compute path color from its orientation.</p></a></li>
<li><a href='#path.slopes'><p>Compute slopes of paths relative to axes.</p></a></li>
<li><a href='#per.hemi.vertex.indices'><p>Transform surfaces indices which go over two surfaces to per-hemi indices.</p></a></li>
<li><a href='#perform.na.mapping'><p>Perform NA mapping for transparency</p></a></li>
<li><a href='#perform.rglactions'><p>Perform rglactions, like taking screenshots.</p></a></li>
<li><a href='#pervertexdata.smoothgaussian'><p>Perform Gaussian smoothing</p></a></li>
<li><a href='#pervertexdata.smoothnn'><p>Perform iterative nearest-neighbor smoothing of per-vertex data.</p></a></li>
<li><a href='#pervertexdata.smoothnn.compute.fwhm'><p>Compute expected FWHM from given number of neighborhood smoothing iterations.</p></a></li>
<li><a href='#pervertexdata.smoothnn.compute.numiter'><p>Compute number of neighborhood smoothing iterations to reach requested fwhm.</p></a></li>
<li><a href='#plot.fsbrain.colorbar'><p>Draw a simple colorbar from colors.</p></a></li>
<li><a href='#pp.named.list'><p>Pretty-print a named list or vector.</p></a></li>
<li><a href='#principal.curvatures'><p>Computes principal curvatures according to 2 definitions from raw k1 and k2 values.</p></a></li>
<li><a href='#print.fs.coloredmesh'><p>Print description of a brain coloredmesh (S3).</p></a></li>
<li><a href='#print.fs.coloredvoxels'><p>Print description of fs.coloredvoxels (S3).</p></a></li>
<li><a href='#print.fsbrain'><p>Print description of an fsbrain (S3).</p></a></li>
<li><a href='#qc.for.group'><p>Perform data quality check based on computed region stats.</p></a></li>
<li><a href='#qc.from.regionwise.df'><p>Perform data quality check based on a dataframe containing aggregated region-wise data.</p></a></li>
<li><a href='#qc.from.segstats.table'><p>Perform data quality check based on a segstats table.</p></a></li>
<li><a href='#qc.from.segstats.tables'><p>Perform data quality check based on a segstats table.</p></a></li>
<li><a href='#qc.fslong.checkidenticaldata'><p>Check whether subjects for FS longitudinal pipeline contain data that is identical between time points.</p></a></li>
<li><a href='#qc.report.html'><p>Create visual quality check report from QC result.</p></a></li>
<li><a href='#qc.vis.failcount.by.region'><p>Visualize the number of outlier subjects per region in your dataset.</p></a></li>
<li><a href='#qdec.table.filter'><p>Filter QDEC long table for subjects.</p></a></li>
<li><a href='#qdec.table.skeleton'><p>Generate skeleton dataframe for FreeSurfer QDEC long file from subjects list.</p></a></li>
<li><a href='#rad2deg'><p>Convert raduians to degree</p></a></li>
<li><a href='#ras2vox_tkr'><p>The FreeSurfer default ras2vox_tkr matrix.</p></a></li>
<li><a href='#read.colorcsv'><p>Read colors from CSV file.</p></a></li>
<li><a href='#read.md.demographics'><p>Read demographics file</p></a></li>
<li><a href='#read.md.subjects'><p>Read subjects file</p></a></li>
<li><a href='#read.md.subjects.from.fsgd'><p>Read subjects list from an FSGD file.</p></a></li>
<li><a href='#recycle'><p>Recycle parameters or whatever.</p></a></li>
<li><a href='#regions.to.ignore'><p>Give suggestions for regions to ignore for an atlas.</p></a></li>
<li><a href='#report.on.demographics'><p>Print a demographics report</p></a></li>
<li><a href='#rgl.coord.lines'><p>Plot x, y and z axes in R,G,B.</p></a></li>
<li><a href='#rglactions'><p>Create rglactions list, suitable to be passed as parameter to vis functions.</p></a></li>
<li><a href='#rglactions.has.key'><p>Check for a key in names of rglactions.</p></a></li>
<li><a href='#rglactions.transform'><p>Apply data transformation rglactions.</p></a></li>
<li><a href='#rglo'><p>Get rgloptions and consider global options.</p></a></li>
<li><a href='#rglot'><p>Get rgloptions for testing.</p></a></li>
<li><a href='#rglvoxels'><p>Draw 3D boxes at locations using rgl.</p></a></li>
<li><a href='#rotation.matrix.for.axis.rot'><p>Get rotation matrix for a 3D rotation around an axis.</p></a></li>
<li><a href='#scale.to.range.zero.one'><p>Scale given values to range 0..1.</p></a></li>
<li><a href='#scale01'><p>Scale given values to range 0..1.</p></a></li>
<li><a href='#shape.descriptor.names'><p>Get all shape descriptor names.</p></a></li>
<li><a href='#shape.descriptors'><p>Computes geometric curvature-based descriptors.</p></a></li>
<li><a href='#shift.hemis.apart'><p>Shift hemispheres apart.</p></a></li>
<li><a href='#shift.hemis.rglactions'><p>Shift hemis apart if indicated in rglactions</p></a></li>
<li><a href='#sjd.demo'><p>Download optional demo data if needed and return its path.</p></a></li>
<li><a href='#sjld'><p>Get subjects list from subjects.txt file in dir.</p></a></li>
<li><a href='#sortcoloredmeshes.by.hemi'><p>Sort coloredmeshes into 2 lists by their 'hemi' property.</p></a></li>
<li><a href='#sph2fs'><p>Transform spherical coordinates to FreeSurfer surface space to plot things around a brain.</p></a></li>
<li><a href='#spread.values.over.annot'><p>Spread a single value for a region to all region vertices.</p></a></li>
<li><a href='#spread.values.over.hemi'><p>Spread the values in the region_value_list and return them for one hemisphere.</p></a></li>
<li><a href='#spread.values.over.subject'><p>Spread the values in the region_value_list and return them for one hemisphere.</p></a></li>
<li><a href='#subject.annot'><p>Load an annotation for a subject.</p></a></li>
<li><a href='#subject.annot.border'><p>Compute annot border vertices.</p></a></li>
<li><a href='#subject.atlas.agg'><p>Aggregate morphometry data over brain atlas regions for a subject.</p></a></li>
<li><a href='#subject.descriptor.geodesic.average.distance'><p>Compute mean geodesic distance descriptor for a subject.</p></a></li>
<li><a href='#subject.filepath.any'><p>Construct filepath of any freesurfer file.</p></a></li>
<li><a href='#subject.filepath.morph.native'><p>Construct filepath of native space morphometry data file.</p></a></li>
<li><a href='#subject.filepath.morph.standard'><p>Construct filepath of standard space morphometry data file.</p></a></li>
<li><a href='#subject.label'><p>Retrieve label data for a single subject.</p></a></li>
<li><a href='#subject.label.from.annot'><p>Extract a region from an atlas annotation as a label for a subject.</p></a></li>
<li><a href='#subject.lobes'><p>Load labels representing brain lobes.</p></a></li>
<li><a href='#subject.mask'><p>Compute a mask for a subject.</p></a></li>
<li><a href='#subject.morph.native'><p>Retrieve native space morphometry data for a single subject.</p></a></li>
<li><a href='#subject.morph.standard'><p>Retrieve standard space morphometry data for a single subject.</p></a></li>
<li><a href='#subject.num.verts'><p>Get subjects vertex count.</p></a></li>
<li><a href='#subject.report.html'><p>Create visual quality check report from QC result.</p></a></li>
<li><a href='#subject.surface'><p>Load a surface for a subject.</p></a></li>
<li><a href='#subject.volume'><p>Read a brain volume.</p></a></li>
<li><a href='#submesh.vertex'><p>Create a submesh including only the given vertices.</p></a></li>
<li><a href='#surf.avg.vertexradius'><p>Compute average distance from the origin to each vertex.</p></a></li>
<li><a href='#surf.center.fsaverage'><p>Get pre-computed center for fsaverage white surface.</p></a></li>
<li><a href='#surf.metric.properties'><p>Compute metric surface properties.</p></a></li>
<li><a href='#surf.radius.fsaverage'><p>Get pre-computed radius for fsaverage white surface.</p></a></li>
<li><a href='#surf.sphere.dist'><p>Compute vertex neighborhoods on a sphere based on the given max distance along the sphere.</p></a></li>
<li><a href='#surf.sphere.gaussianweights'><p>Compute Gaussian weights</p></a></li>
<li><a href='#surf.sphere.spatialfilter'><p>Apply spatial filter to surface data.</p></a></li>
<li><a href='#surface.curvatures'><p>Compute the k1 and k2 principal curvatures of a mesh.</p></a></li>
<li><a href='#surfs.props'><p>Compute simple version of center and radius of 2 meshes.</p></a></li>
<li><a href='#symmrange'><p>Given data, compute symmetric range around zero.</p></a></li>
<li><a href='#test.numerical.meandiff'><p>Perform tests for group differences on paired or unpaired data for two groups.</p></a></li>
<li><a href='#test.numerical.meandiff.paired'><p>Perform tests for group differences on paired data (repeated measurements) for two conditions or time points.</p></a></li>
<li><a href='#test.numerical.meandiff.unpaired'><p>Perform tests for group differences on unpaired data for two groups.</p></a></li>
<li><a href='#tmesh3d.to.fs.surface'><p>Get an fs.surface brain mesh from an rgl tmesh3d instance.</p></a></li>
<li><a href='#track.length'><p>Compute the total length of a path given by the coordinates of its points.</p></a></li>
<li><a href='#vdata.split.by.hemi'><p>Split morph data vector at hemisphere boundary.</p></a></li>
<li><a href='#vertex.coords'><p>Return coordinates for vertices, supporting entire brain via hemilist.</p></a></li>
<li><a href='#vertex.hemis'><p>Return the proper hemi string ('lh' or 'rh') for each vertex.</p></a></li>
<li><a href='#vis.color.on.subject'><p>Visualize pre-defined vertex colors on a subject.</p></a></li>
<li><a href='#vis.coloredmesh'><p>Draw a coloredmesh using a style.</p></a></li>
<li><a href='#vis.coloredmeshes'><p>Visualize a list of colored meshes in a single scene.</p></a></li>
<li><a href='#vis.coloredmeshes.rotating'><p>Visualize a list of colored meshes in a single scene and rotate them, movie-style.</p></a></li>
<li><a href='#vis.colortable.legend'><p>Create a separate legend plot for a colortable or an annotation.</p></a></li>
<li><a href='#vis.data.on.fsaverage'><p>Visualize arbitrary data on the fsaverage template subject, if available.</p></a></li>
<li><a href='#vis.data.on.group.native'><p>Visualize native space data on a group of subjects.</p></a></li>
<li><a href='#vis.data.on.group.standard'><p>Visualize standard space data for a group on template.</p></a></li>
<li><a href='#vis.data.on.subject'><p>Visualize arbitrary data on the surface of any subject.</p></a></li>
<li><a href='#vis.dti.trk'><p>Visualize DTI tracks from Diffusion Toolkit/TrackVis TRK format file.</p></a></li>
<li><a href='#vis.export.from.coloredmeshes'><p>Export high-quality brainview image with a colorbar.</p></a></li>
<li><a href='#vis.fs.surface'><p>Visualize fs.surface mesh</p></a></li>
<li><a href='#vis.group.annot'><p>Plot atlas annotations for a group of subjects.</p></a></li>
<li><a href='#vis.group.coloredmeshes'><p>Plot coloredmeshes for a group of subjects.</p></a></li>
<li><a href='#vis.group.morph.native'><p>Plot native space morphometry data for a group of subjects.</p></a></li>
<li><a href='#vis.group.morph.standard'><p>Plot standard space morphometry data for a group of subjects.</p></a></li>
<li><a href='#vis.labeldata.on.subject'><p>Visualize a label on the surface of a subject.</p></a></li>
<li><a href='#vis.mask.on.subject'><p>Visualize a vertex mask on the surface of a subject.</p></a></li>
<li><a href='#vis.path.along.verts'><p>Draw a 3D line from vertex to vertex</p></a></li>
<li><a href='#vis.paths'><p>Visualize many paths.</p></a></li>
<li><a href='#vis.paths.along.verts'><p>Visualize several paths in different colors.</p></a></li>
<li><a href='#vis.region.values.on.subject'><p>Visualize arbitrary data, one value per atlas region, on the surface of any subject (including template subjects).</p></a></li>
<li><a href='#vis.renderable'><p>Visualize a renderable object</p></a></li>
<li><a href='#vis.rotated.coloredmeshes'><p>Rotate and visualize coloredmeshes, applying a style.</p></a></li>
<li><a href='#vis.seg.legend'><p>Plot legend for a brain volume segmentation based on colorLUT.</p></a></li>
<li><a href='#vis.subject.annot'><p>Visualize an annotation for a subject.</p></a></li>
<li><a href='#vis.subject.label'><p>Visualize a binary label for a subject.</p></a></li>
<li><a href='#vis.subject.morph.native'><p>Visualize native space morphometry data for a subject.</p></a></li>
<li><a href='#vis.subject.morph.standard'><p>Visualize native space morphometry data for a subject or a group.</p></a></li>
<li><a href='#vis.subject.pre'><p>Visualize pre-loaded data.</p></a></li>
<li><a href='#vis.symmetric.data.on.subject'><p>Visualize clusters or activation data on the surface of any subject.</p></a></li>
<li><a href='#vislayout.from.coloredmeshes'><p>Visualize coloredmeshes from several angles and combine the images into a new figure.</p></a></li>
<li><a href='#vol.boundary.box'><p>Compute 3D bounding box of a volume.</p></a></li>
<li><a href='#vol.boundary.box.apply'><p>Apply a boundary box to a volume, returning the inner volume part</p></a></li>
<li><a href='#vol.boundary.mask'><p>Compute foreground pixels over the whole 3D imagestack.</p></a></li>
<li><a href='#vol.hull'><p>Retain only the outer hull voxels of the foreground.</p></a></li>
<li><a href='#vol.imagestack'><p>Turn volume into an ImageMagick image stack.</p></a></li>
<li><a href='#vol.intensity.to.color'><p>Convert integer intensity image to RGB color string form.</p></a></li>
<li><a href='#vol.mask.from.segmentation'><p>Extract subset from a volume by value.</p></a></li>
<li><a href='#vol.merge'><p>Merge background volume and overlay to new colors.</p></a></li>
<li><a href='#vol.overlay.colors.from.activation'><p>Generate colors for a 3D volume, based on the activation data and a colormap.</p></a></li>
<li><a href='#vol.overlay.colors.from.colortable'><p>Compute voxel colors based on colortable.</p></a></li>
<li><a href='#vol.plane.axes'><p>Get indices of the axes defining the given plane.</p></a></li>
<li><a href='#vol.planes'><p>Translate names and indices of planes.</p></a></li>
<li><a href='#vol.slice'><p>Extract a slice of a 3D image stack.</p></a></li>
<li><a href='#vol.vox.from.crs'><p>Compute R voxel index for FreeSurfer CRS voxel index.</p></a></li>
<li><a href='#volvis.contour'><p>Visualize contour of a volume.</p></a></li>
<li><a href='#volvis.lb'><p>Show continuous 3D voxel/volume data as a lightbox, optionally with a background brain volume and colormap.</p></a></li>
<li><a href='#volvis.lightbox'><p>Draw a lightbox view from volume slices.</p></a></li>
<li><a href='#volvis.voxels'><p>Voxel-based visualization of volume mask at surface RAS positions.</p></a></li>
<li><a href='#vox2ras_tkr'><p>The FreeSurfer default vox2ras_tkr matrix.</p></a></li>
<li><a href='#wrapped.image.append'><p>Wrapper around magick::image_append that allows specifying the background color when working with images of different width/height.</p></a></li>
<li><a href='#write.group.morph.standard'><p>Write standard space group data to a standard FreeSurfer directory stucture.</p></a></li>
<li><a href='#write.group.morph.standard.mf'><p>Write per-vertex standard space data for a group of subjects to given file names.</p></a></li>
<li><a href='#write.group.morph.standard.sf'><p>Reshape and write combined per-vertex data for a group to a single MGH file.</p></a></li>
<li><a href='#write.group.morph.standard.singlehemi'><p>Write single hemi per-vertex data for a group of subjects to given file names.</p></a></li>
<li><a href='#write.region.aggregated'><p>Write data aggregated over regions to morphometry file for group.</p></a></li>
<li><a href='#write.region.values'><p>Write one value per atlas region for a subject.</p></a></li>
<li><a href='#write.region.values.fsaverage'><p>Write one value per atlas region for a template subject.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Managing and Visualizing Brain Surface Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Schäfer &lt;ts+code@rcmd.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides high-level access to neuroimaging data from standard software packages like 'FreeSurfer' <a href="http://freesurfer.net/">http://freesurfer.net/</a> on the level of subjects and groups. Load morphometry data, surfaces and brain parcellations based on atlases. Mask data using labels, load data for specific atlas regions only, and visualize data and statistical results directly in 'R'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dfsp-spirit/fsbrain">https://github.com/dfsp-spirit/fsbrain</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dfsp-spirit/fsbrain/issues">https://github.com/dfsp-spirit/fsbrain/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>reshape, freesurferformats (&ge; 0.1.17), pkgfilecache (&ge;
0.1.1), rgl, squash, fields, viridis, data.table, magick,
methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0), sphereplot (&ge; 1.5),
misc3d, RColorBrewer, Rvcg (&ge; 0.20.2), igraph, pracma</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-03 10:07:23 UTC; spirit</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Schäfer <a href="https://orcid.org/0000-0002-3683-8070"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-03 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alphablend'>Perform alpha blending for pairs of RGBA colors.</h2><span id='topic+alphablend'></span>

<h3>Description</h3>

<p>Implements the *over* alpha blending operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphablend(front_color, back_color, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alphablend_+3A_front_color">front_color</code></td>
<td>
<p>rgba color strings, the upper color layer or foreground</p>
</td></tr>
<tr><td><code id="alphablend_+3A_back_color">back_color</code></td>
<td>
<p>rgba color strings, the lower color layer or background</p>
</td></tr>
<tr><td><code id="alphablend_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rgba color strings, the alpha-blended colors
</p>


<h3>References</h3>

<p>see the *Alpha blending* section on https://en.wikipedia.org/wiki/Alpha_compositing
</p>


<h3>See Also</h3>

<p>Other color functions: 
<code><a href="#topic+desaturate">desaturate</a>()</code>
</p>

<hr>
<h2 id='annot.outline'>Compute outline vertex colors from annotation.</h2><span id='topic+annot.outline'></span>

<h3>Description</h3>

<p>For each region in an atlas, compute the outer border and color the respective vertices in the region-specific color from the annot's colortable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annot.outline(
  annotdata,
  surface_mesh,
  background = "white",
  silent = TRUE,
  expand_inwards = 0L,
  outline_color = NULL,
  limit_to_regions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="annot.outline_+3A_annotdata">annotdata</code></td>
<td>
<p>an annotation, as returned by functions like <code><a href="#topic+subject.annot">subject.annot</a></code>. If a character string, interpreted as a path to a file containing such data, and loaded with <code>freesurferformats::read.fs.annot</code></p>
</td></tr>
<tr><td><code id="annot.outline_+3A_surface_mesh">surface_mesh</code></td>
<td>
<p>brain surface mesh, as returned by functions like <code><a href="#topic+subject.surface">subject.surface</a></code> or <code><a href="freesurferformats.html#topic+read.fs.surface">read.fs.surface</a></code>. If a character string, interpreted as a path to a file containing such data, and loaded with <code>freesurferformats::read.fs.surface</code></p>
</td></tr>
<tr><td><code id="annot.outline_+3A_background">background</code></td>
<td>
<p>color, the background color to assign to the non-border parts of the regions. Defaults to 'white'.</p>
</td></tr>
<tr><td><code id="annot.outline_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress status messages.</p>
</td></tr>
<tr><td><code id="annot.outline_+3A_expand_inwards">expand_inwards</code></td>
<td>
<p>integer, additional thickness of the borders. Increases computation time, defaults to 0L.</p>
</td></tr>
<tr><td><code id="annot.outline_+3A_outline_color">outline_color</code></td>
<td>
<p>NULL or a color string (like 'black' or '#000000'), the color to use for the borders. If left at the default value 'NULL', the colors from the annotation color lookup table will be used.</p>
</td></tr>
<tr><td><code id="annot.outline_+3A_limit_to_regions">limit_to_regions</code></td>
<td>
<p>vector of character strings or NULL, a list of regions for which to draw the outline (see <code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a></code>). If NULL, all regions will be used. If (and only if) this parameter is used, the 'outline_color' parameter can be a vector of color strings, one color per region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of colors, one color for each mesh vertex
</p>


<h3>Note</h3>

<p>Sorry for the computational time, the mesh datastructure is not ideal for neighborhood search.
</p>

<hr>
<h2 id='annot.outline.border.vertices'>Compute the border vertices for each region in an annot.</h2><span id='topic+annot.outline.border.vertices'></span>

<h3>Description</h3>

<p>Compute the border vertices for each region in an annot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annot.outline.border.vertices(
  annotdata,
  surface_mesh,
  silent = TRUE,
  expand_inwards = 0L,
  limit_to_regions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="annot.outline.border.vertices_+3A_annotdata">annotdata</code></td>
<td>
<p>an annotation, as returned by functions like <code><a href="#topic+subject.annot">subject.annot</a></code>. If a character string, interpreted as a path to a file containing such data, and loaded with <code>freesurferformats::read.fs.annot</code></p>
</td></tr>
<tr><td><code id="annot.outline.border.vertices_+3A_surface_mesh">surface_mesh</code></td>
<td>
<p>brain surface mesh, as returned by functions like <code><a href="#topic+subject.surface">subject.surface</a></code> or <code><a href="freesurferformats.html#topic+read.fs.surface">read.fs.surface</a></code>. If a character string, interpreted as a path to a file containing such data, and loaded with <code>freesurferformats::read.fs.surface</code></p>
</td></tr>
<tr><td><code id="annot.outline.border.vertices_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress status messages.</p>
</td></tr>
<tr><td><code id="annot.outline.border.vertices_+3A_expand_inwards">expand_inwards</code></td>
<td>
<p>integer, additional thickness of the borders. Increases computation time, defaults to 0L.</p>
</td></tr>
<tr><td><code id="annot.outline.border.vertices_+3A_limit_to_regions">limit_to_regions</code></td>
<td>
<p>vector of character strings or NULL, a list of regions for which to draw the outline (see <code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a></code>). If NULL, all regions will be used. If (and only if) this parameter is used, the 'outline_color' parameter can be a vector of color strings, one color per region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, the keys are the region names and the values are vectors of integers encoding vertex indices.
</p>

<hr>
<h2 id='apply.label.to.morphdata'>Load a label from file and apply it to morphometry data.</h2><span id='topic+apply.label.to.morphdata'></span>

<h3>Description</h3>

<p>This function will set all values in morphdata which are *not* part of the label loaded from the file to NA (or whatever is specified by 'masked_data_value'). This is typically used to ignore values which are not part of the cortex (or any other label) during your analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply.label.to.morphdata(
  morphdata,
  subjects_dir,
  subject_id,
  hemi,
  label,
  masked_data_value = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply.label.to.morphdata_+3A_morphdata">morphdata</code></td>
<td>
<p>numerical vector, the morphometry data for one hemisphere</p>
</td></tr>
<tr><td><code id="apply.label.to.morphdata_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="apply.label.to.morphdata_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="apply.label.to.morphdata_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="apply.label.to.morphdata_+3A_label">label</code></td>
<td>
<p>string, &lsquo;fs.label' instance, or label vertex data. If a string, interpreted as the file name of the label file, without the hemi part (if any), optionally including the &rsquo;.label' suffix. E.g., 'cortex.label' or 'cortex' for '?h.cortex.label'.</p>
</td></tr>
<tr><td><code id="apply.label.to.morphdata_+3A_masked_data_value">masked_data_value</code></td>
<td>
<p>numerical, the value to set for all morphometry data values of vertices which are *not* part of the label. Defaults to NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical vector, the masked data.
</p>


<h3>See Also</h3>

<p>Other label functions: 
<code><a href="#topic+apply.labeldata.to.morphdata">apply.labeldata.to.morphdata</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>,
<code><a href="#topic+subject.mask">subject.mask</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>
</p>
<p>Other morphometry data functions: 
<code><a href="#topic+apply.labeldata.to.morphdata">apply.labeldata.to.morphdata</a>()</code>,
<code><a href="#topic+group.morph.native">group.morph.native</a>()</code>,
<code><a href="#topic+group.morph.standard">group.morph.standard</a>()</code>,
<code><a href="#topic+subject.morph.native">subject.morph.native</a>()</code>,
<code><a href="#topic+subject.morph.standard">subject.morph.standard</a>()</code>
</p>

<hr>
<h2 id='apply.labeldata.to.morphdata'>Apply a label to morphometry data.</h2><span id='topic+apply.labeldata.to.morphdata'></span>

<h3>Description</h3>

<p>This function will set all values in morphdata which are *not* part of the labeldata to NA (or whatever is specified by 'masked_data_value'). This is typically used to ignore values which are not part of the cortex (or any other label) during your analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply.labeldata.to.morphdata(morphdata, labeldata, masked_data_value = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply.labeldata.to.morphdata_+3A_morphdata">morphdata</code></td>
<td>
<p>numerical vector, the morphometry data for one hemisphere</p>
</td></tr>
<tr><td><code id="apply.labeldata.to.morphdata_+3A_labeldata">labeldata</code></td>
<td>
<p>integer vector or 'fs.label' instance. A label as returned by <code><a href="#topic+subject.label">subject.label</a></code>.</p>
</td></tr>
<tr><td><code id="apply.labeldata.to.morphdata_+3A_masked_data_value">masked_data_value</code></td>
<td>
<p>numerical, the value to set for all morphometry data values of vertices which are *not* part of the label. Defaults to NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical vector, the masked data.
</p>


<h3>See Also</h3>

<p>Other label functions: 
<code><a href="#topic+apply.label.to.morphdata">apply.label.to.morphdata</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>,
<code><a href="#topic+subject.mask">subject.mask</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>
</p>
<p>Other morphometry data functions: 
<code><a href="#topic+apply.label.to.morphdata">apply.label.to.morphdata</a>()</code>,
<code><a href="#topic+group.morph.native">group.morph.native</a>()</code>,
<code><a href="#topic+group.morph.standard">group.morph.standard</a>()</code>,
<code><a href="#topic+subject.morph.native">subject.morph.native</a>()</code>,
<code><a href="#topic+subject.morph.standard">subject.morph.standard</a>()</code>
</p>

<hr>
<h2 id='apply.transform'>Apply matmult transformation to input.</h2><span id='topic+apply.transform'></span>

<h3>Description</h3>

<p>Apply affine transformation, like a *vox2ras_tkr* transformation, to input. This is just matrix multiplication for different input objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply.transform(object, matrix_fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply.transform_+3A_object">object</code></td>
<td>
<p>numerical vector/matrix or Triangles3D instance, the coorindates or object to transform.</p>
</td></tr>
<tr><td><code id="apply.transform_+3A_matrix_fun">matrix_fun</code></td>
<td>
<p>a 4x4 affine matrix or a function returning such a matrix. If 'NULL', the input is returned as-is. In many cases you way want to use a matrix computed from the header of a volume file, e.g., the 'vox2ras' matrix of the respective volume. See the 'mghheader.*' functions in the *freesurferformats* package to obtain these matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input after application of the affine matrix (matrix multiplication)
</p>

<hr>
<h2 id='arrange.brainview.images'>Combine several brainview images into a new figure.</h2><span id='topic+arrange.brainview.images'></span>

<h3>Description</h3>

<p>Create a new image from several image tiles, the exact layout depends on the number of given images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange.brainview.images(
  brainview_images,
  output_img,
  colorbar_img = NULL,
  silent = TRUE,
  grid_like = TRUE,
  border_geometry = "5x5",
  background_color = "white",
  map_bg_to_transparency = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange.brainview.images_+3A_brainview_images">brainview_images</code></td>
<td>
<p>vector of character strings, paths to the brainview images, usually in PNG format</p>
</td></tr>
<tr><td><code id="arrange.brainview.images_+3A_output_img">output_img</code></td>
<td>
<p>path to output image that including the file extension</p>
</td></tr>
<tr><td><code id="arrange.brainview.images_+3A_colorbar_img">colorbar_img</code></td>
<td>
<p>path to the main image containing the separate colorbar, usually an image in PNG format</p>
</td></tr>
<tr><td><code id="arrange.brainview.images_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress messages</p>
</td></tr>
<tr><td><code id="arrange.brainview.images_+3A_grid_like">grid_like</code></td>
<td>
<p>logical, whether to arrange the images in a grid-like fashion. If FALSE, they will all be merged horizontally.</p>
</td></tr>
<tr><td><code id="arrange.brainview.images_+3A_border_geometry">border_geometry</code></td>
<td>
<p>string, a geometry string passed to <code>magick::image_border</code> to define the borders to add to each image tile. The default value adds 5 pixels, both horizontally and vertically.</p>
</td></tr>
<tr><td><code id="arrange.brainview.images_+3A_background_color">background_color</code></td>
<td>
<p>hex color string, such as &quot;#DDDDDD&quot; or &quot;#FFFFFF&quot;. The color to use when extending images (e.g., when creating the border). WARNING: Do not use color names (like 'gray'), as their interpretation differs between rgl and image magick!</p>
</td></tr>
<tr><td><code id="arrange.brainview.images_+3A_map_bg_to_transparency">map_bg_to_transparency</code></td>
<td>
<p>logical, whether to map the background_color to transparency for the final PNG export.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries: 'brainview_images': vector of character strings, the paths to the input images. 'output_img_path': character string, path to the output image. 'merged_img': the magick image instance.
</p>

<hr>
<h2 id='arrange.brainview.images.grid'>Combine several brainview images as a grid into a new figure.</h2><span id='topic+arrange.brainview.images.grid'></span>

<h3>Description</h3>

<p>Create a new image from several image tiles, the exact layout is a grid with n per row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange.brainview.images.grid(
  brainview_images,
  output_img,
  colorbar_img = NULL,
  silent = TRUE,
  num_per_row = 10L,
  border_geometry = "5x5",
  background_color = "white",
  captions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange.brainview.images.grid_+3A_brainview_images">brainview_images</code></td>
<td>
<p>vector of character strings, paths to the brainview images, usually in PNG format</p>
</td></tr>
<tr><td><code id="arrange.brainview.images.grid_+3A_output_img">output_img</code></td>
<td>
<p>path to output image that including the file extension</p>
</td></tr>
<tr><td><code id="arrange.brainview.images.grid_+3A_colorbar_img">colorbar_img</code></td>
<td>
<p>path to the main image containing the separate colorbar, usually an image in PNG format</p>
</td></tr>
<tr><td><code id="arrange.brainview.images.grid_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress messages</p>
</td></tr>
<tr><td><code id="arrange.brainview.images.grid_+3A_num_per_row">num_per_row</code></td>
<td>
<p>positive integer, the number of image tiles per row.</p>
</td></tr>
<tr><td><code id="arrange.brainview.images.grid_+3A_border_geometry">border_geometry</code></td>
<td>
<p>string, a geometry string passed to <code>magick::image_border</code> to define the borders to add to each image tile. The default value adds 5 pixels, both horizontally and vertically.</p>
</td></tr>
<tr><td><code id="arrange.brainview.images.grid_+3A_background_color">background_color</code></td>
<td>
<p>hex color string, such as &quot;#DDDDDD&quot; or &quot;#FFFFFF&quot;. The color to use when extending images (e.g., when creating the border). WARNING: Do not use color names (like 'gray'), as their interpretation differs between rgl and image magick!</p>
</td></tr>
<tr><td><code id="arrange.brainview.images.grid_+3A_captions">captions</code></td>
<td>
<p>vector of character strings or NULL, the (optional) text annotations for the images. Useful to print the subject identifier onto the individual tiles. Length must match number of image tiles in 'brainview_images'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries: 'brainview_images': vector of character strings, the paths to the input images. 'output_img_path': character string, path to the output image. 'merged_img': the magick image instance.
</p>


<h3>Note</h3>

<p>The tiles are written row-wise, in the order in which they occur in the parameter 'brainview_images'.
</p>

<hr>
<h2 id='boxcoords.from.bbox'>Compute the coordinates of the 8 corners of a 3D box.</h2><span id='topic+boxcoords.from.bbox'></span>

<h3>Description</h3>

<p>Given the extreme values (min and max) along the 3 axes, compute the coordinates of the 8 corners of a 3D box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxcoords.from.bbox(axes_min, axes_max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boxcoords.from.bbox_+3A_axes_min">axes_min</code></td>
<td>
<p>numerical vector of length 3, the min values of the 3 axes</p>
</td></tr>
<tr><td><code id="boxcoords.from.bbox_+3A_axes_max">axes_max</code></td>
<td>
<p>numerical vector of length 3, the max values of the 3 axes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical matrix with 3 columns and 8 rows, the edge coordinates
</p>

<hr>
<h2 id='brain'>Create fsbrain instance from 2 coloredmeshes.</h2><span id='topic+brain'></span>

<h3>Description</h3>

<p>Create fsbrain instance from 2 coloredmeshes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brain(lh_cm, rh_cm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brain_+3A_lh_cm">lh_cm</code></td>
<td>
<p>coloredmesh for left hemisphere</p>
</td></tr>
<tr><td><code id="brain_+3A_rh_cm">rh_cm</code></td>
<td>
<p>coloredmesh for right hemisphere</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fsbrain instance
</p>

<hr>
<h2 id='brainview.sd'>Visualize a list of colored meshes from a single defined angle.</h2><span id='topic+brainview.sd'></span>

<h3>Description</h3>

<p>Visualize a list of colored meshes from a single defined angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brainview.sd(
  coloredmeshes,
  view_angle,
  background = "white",
  skip_all_na = TRUE,
  style = "default",
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brainview.sd_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of coloredmesh. A coloredmesh is a named list as returned by the 'coloredmesh.from*' functions (like <code><a href="#topic+coloredmesh.from.morph.native">coloredmesh.from.morph.native</a></code>). It has the entries 'mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh. Note that the 'vis*' functions (like <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>) all return a list of coloredmeshes.</p>
</td></tr>
<tr><td><code id="brainview.sd_+3A_view_angle">view_angle</code></td>
<td>
<p>character string, the view angle. One of 'lateral_lh', 'dorsal', 'lateral_rh', 'medial_lh', 'ventral', 'medial_rh', 'rostral' or 'caudal'. See <code><a href="#topic+get.view.angle.names">get.view.angle.names</a></code>.</p>
</td></tr>
<tr><td><code id="brainview.sd_+3A_background">background</code></td>
<td>
<p>string, background color passed to <code>bg3d</code>.</p>
</td></tr>
<tr><td><code id="brainview.sd_+3A_skip_all_na">skip_all_na</code></td>
<td>
<p>logical, whether to skip (i.e., not render) meshes in the list that have the property 'render' set to FALSE. Defaults to TRUE. Practically, this means that a hemisphere for which the data was not given is not rendered, instead of being rendered in a single color.</p>
</td></tr>
<tr><td><code id="brainview.sd_+3A_style">style</code></td>
<td>
<p>a named list of style parameters or a string specifying an available style by name (e.g., 'shiny'). Defaults to 'default', the default style.</p>
</td></tr>
<tr><td><code id="brainview.sd_+3A_rgloptions">rgloptions</code></td>
<td>
<p>named list. Parameters passed to <code>par3d</code>. Defaults to the empty list. To increase plot resolution to 2000x1600 px, try: <code>rgloptions=list("windowRect"=c(50,50,2000,1600))</code>.</p>
</td></tr>
<tr><td><code id="brainview.sd_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action.</p>
</td></tr>
<tr><td><code id="brainview.sd_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical, whether to draw a colorbar. WARNING: The colorbar is drawn to a subplot, and this only works if there is enough space for it. You will have to increase the plot size using the 'rlgoptions' parameter for the colorbar to show up. Defaults to FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='brainview.si'>Visualize a list of colored meshes from a single viewpoint, interactively.</h2><span id='topic+brainview.si'></span>

<h3>Description</h3>

<p>Visualize a list of colored meshes from a single viewpoint, interactively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brainview.si(
  coloredmeshes,
  background = "white",
  skip_all_na = TRUE,
  style = "default",
  draw_labels = FALSE,
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brainview.si_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of coloredmesh. A coloredmesh is a named list as returned by the coloredmesh.from.* functions. It has the entries 'mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh.</p>
</td></tr>
<tr><td><code id="brainview.si_+3A_background">background</code></td>
<td>
<p>string, background color passed to <code>bg3d</code>.</p>
</td></tr>
<tr><td><code id="brainview.si_+3A_skip_all_na">skip_all_na</code></td>
<td>
<p>logical, whether to skip (i.e., not render) meshes in the list that have the property 'render' set to FALSE. Defaults to TRUE. Practically, this means that a hemisphere for which the data was not given is not rendered, instead of being rendered in a single color.</p>
</td></tr>
<tr><td><code id="brainview.si_+3A_style">style</code></td>
<td>
<p>a named list of style parameters or a string specifying an available style by name (e.g., 'shiny'). Defaults to 'default', the default style.</p>
</td></tr>
<tr><td><code id="brainview.si_+3A_draw_labels">draw_labels</code></td>
<td>
<p>logical, whether to draw label text for the different views that show information on the view direction and hemisphere displayed in a subplot. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="brainview.si_+3A_rgloptions">rgloptions</code></td>
<td>
<p>named list. Parameters passed to <code>par3d</code>. Defaults to the empty list.</p>
</td></tr>
<tr><td><code id="brainview.si_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. Defaults to the empty list.</p>
</td></tr>
<tr><td><code id="brainview.si_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical, whether to draw a colorbar. WARNING: The colorbar is drawn to a subplot, and this only works if there is enough space for it. You will have to increase the plot size using the 'rlgoptions' parameter for the colorbar to show up. Defaults to FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='brainview.sr'>Visualize a list of colored meshes, rotating the camera around them.</h2><span id='topic+brainview.sr'></span>

<h3>Description</h3>

<p>Visualize a list of colored meshes, rotating the camera around them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brainview.sr(
  coloredmeshes,
  background = "white",
  skip_all_na = TRUE,
  style = "default",
  draw_labels = FALSE,
  x = 0,
  y = 1,
  z = 0,
  rpm = 6,
  duration = 10,
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brainview.sr_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of coloredmesh. A coloredmesh is a named list as returned by the coloredmesh.from.* functions. It has the entries 'mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh.</p>
</td></tr>
<tr><td><code id="brainview.sr_+3A_background">background</code></td>
<td>
<p>string, background color passed to <code>bg3d</code>.</p>
</td></tr>
<tr><td><code id="brainview.sr_+3A_skip_all_na">skip_all_na</code></td>
<td>
<p>logical, whether to skip (i.e., not render) meshes in the list that have the property 'render' set to FALSE. Defaults to TRUE. Practically, this means that a hemisphere for which the data was not given is not rendered, instead of being rendered in a single color.</p>
</td></tr>
<tr><td><code id="brainview.sr_+3A_style">style</code></td>
<td>
<p>a named list of style parameters or a string specifying an available style by name (e.g., 'shiny'). Defaults to 'default', the default style.</p>
</td></tr>
<tr><td><code id="brainview.sr_+3A_draw_labels">draw_labels</code></td>
<td>
<p>logical, whether to draw label text for the different views that show information on the view direction and hemisphere displayed in a subplot. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="brainview.sr_+3A_x">x</code></td>
<td>
<p>rotation x axis value, passed to <code>spin3d</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="brainview.sr_+3A_y">y</code></td>
<td>
<p>rotation y axis value, passed to <code>spin3d</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="brainview.sr_+3A_z">z</code></td>
<td>
<p>rotation z axis value, passed to <code>spin3d</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="brainview.sr_+3A_rpm">rpm</code></td>
<td>
<p>rotation rpm value, passed to <code>spin3d</code>. Defaults to 15.</p>
</td></tr>
<tr><td><code id="brainview.sr_+3A_duration">duration</code></td>
<td>
<p>rotation duration value, passed to <code>spin3d</code>. Defaults to 20.</p>
</td></tr>
<tr><td><code id="brainview.sr_+3A_rgloptions">rgloptions</code></td>
<td>
<p>named list. Parameters passed to <code>par3d</code>. Defaults to the empty list.</p>
</td></tr>
<tr><td><code id="brainview.sr_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. Defaults to the empty list.</p>
</td></tr>
<tr><td><code id="brainview.sr_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical, whether to draw a colorbar. WARNING: The colorbar is drawn to a subplot, and this only works if there is enough space for it. You will have to increase the plot size using the 'rlgoptions' parameter for the colorbar to show up. Defaults to FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='brainview.t4'>Visualize a list of colored meshes from four angles.</h2><span id='topic+brainview.t4'></span>

<h3>Description</h3>

<p>Visualize a list of colored meshes from four angles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brainview.t4(
  coloredmeshes,
  background = "white",
  skip_all_na = TRUE,
  style = "default",
  draw_labels = FALSE,
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brainview.t4_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of coloredmesh. A coloredmesh is a named list as returned by the coloredmesh.from.* functions. It has the entries 'mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh.</p>
</td></tr>
<tr><td><code id="brainview.t4_+3A_background">background</code></td>
<td>
<p>string, background color passed to <code>bg3d</code>.</p>
</td></tr>
<tr><td><code id="brainview.t4_+3A_skip_all_na">skip_all_na</code></td>
<td>
<p>logical, whether to skip (i.e., not render) meshes in the list that have the property 'render' set to FALSE. Defaults to TRUE. Practically, this means that a hemisphere for which the data was not given is not rendered, instead of being rendered in a single color.</p>
</td></tr>
<tr><td><code id="brainview.t4_+3A_style">style</code></td>
<td>
<p>a named list of style parameters or a string specifying an available style by name (e.g., 'shiny'). Defaults to 'default', the default style.</p>
</td></tr>
<tr><td><code id="brainview.t4_+3A_draw_labels">draw_labels</code></td>
<td>
<p>logical, whether to draw label text for the different views that show information on the view direction and hemisphere displayed in a subplot. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="brainview.t4_+3A_rgloptions">rgloptions</code></td>
<td>
<p>named list. Parameters passed to <code>par3d</code>. Defaults to the empty list.</p>
</td></tr>
<tr><td><code id="brainview.t4_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action.</p>
</td></tr>
<tr><td><code id="brainview.t4_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical, whether to draw a colorbar. WARNING: The colorbar is drawn to a subplot, and this only works if there is enough space for it. You will have to increase the plot size using the 'rlgoptions' parameter for the colorbar to show up. Defaults to FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='brainview.t9'>Visualize a list of colored meshes from nine angles.</h2><span id='topic+brainview.t9'></span>

<h3>Description</h3>

<p>Visualize a list of colored meshes from nine angles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brainview.t9(
  coloredmeshes,
  background = "white",
  skip_all_na = TRUE,
  style = "default",
  draw_labels = FALSE,
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brainview.t9_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of coloredmesh. A coloredmesh is a named list as returned by the coloredmesh.from.* functions. It has the entries 'mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh.</p>
</td></tr>
<tr><td><code id="brainview.t9_+3A_background">background</code></td>
<td>
<p>string, background color passed to <code>bg3d</code>.</p>
</td></tr>
<tr><td><code id="brainview.t9_+3A_skip_all_na">skip_all_na</code></td>
<td>
<p>logical, whether to skip (i.e., not render) meshes in the list that have the property 'render' set to FALSE. Defaults to TRUE. Practically, this means that a hemisphere for which the data was not given is not rendered, instead of being rendered in a single color.</p>
</td></tr>
<tr><td><code id="brainview.t9_+3A_style">style</code></td>
<td>
<p>a named list of style parameters or a string specifying an available style by name (e.g., 'shiny'). Defaults to 'default', the default style.</p>
</td></tr>
<tr><td><code id="brainview.t9_+3A_draw_labels">draw_labels</code></td>
<td>
<p>logical, whether to draw label text for the different views that show information on the view direction and hemisphere displayed in a subplot. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="brainview.t9_+3A_rgloptions">rgloptions</code></td>
<td>
<p>named list. Parameters passed to <code>par3d</code>. Defaults to the empty list. To increase plot resolution to 2000x1600 px, try: <code>rgloptions=list("windowRect"=c(50,50,2000,1600))</code>.</p>
</td></tr>
<tr><td><code id="brainview.t9_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action.</p>
</td></tr>
<tr><td><code id="brainview.t9_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical, whether to draw a colorbar. WARNING: The colorbar is drawn to a subplot, and this only works if there is enough space for it. You will have to increase the plot size using the 'rlgoptions' parameter for the colorbar to show up. Defaults to FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='brainviews'>Show one or more views of the given meshes in rgl windows.</h2><span id='topic+brainviews'></span>

<h3>Description</h3>

<p>Show one or more views of the given meshes in rgl windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brainviews(
  views,
  coloredmeshes,
  rgloptions = rglo(),
  rglactions = list(),
  style = "default",
  draw_colorbar = FALSE,
  background = "white"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brainviews_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 'sd_&lt;angle&gt;': single view from angle &lt;angle&gt;. The &lt;angle&gt; part must be one of the strings returned by <code><a href="#topic+get.view.angle.names">get.view.angle.names</a></code>. Example: 'sd_caudal'. 'sr': single rotating view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="brainviews_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of coloredmesh or renderable. A coloredmesh is a named list as returned by the coloredmesh.from.* functions. It has the entries 'mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh.</p>
</td></tr>
<tr><td><code id="brainviews_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code></p>
</td></tr>
<tr><td><code id="brainviews_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action.</p>
</td></tr>
<tr><td><code id="brainviews_+3A_style">style</code></td>
<td>
<p>character string, a rendering style, e.g., 'default', 'shiny' or 'semitransparent'.</p>
</td></tr>
<tr><td><code id="brainviews_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical, whether to draw a colorbar. WARNING: The colorbar is drawn to a subplot, and this only works if there is enough space for it. You will have to increase the plot size using the 'rlgoptions' parameter for the colorbar to show up. Defaults to FALSE. See <code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a></code> for an alternative.</p>
</td></tr>
<tr><td><code id="brainviews_+3A_background">background</code></td>
<td>
<p>the background color for the visualization, e.g., 'white' or '#FF0000'. Note that alpha/transparency is not supported by rgl.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.view.angle.names">get.view.angle.names</a></code>
</p>

<hr>
<h2 id='can.plot.colorbar'>Determine whether colorbar can be plotted with given metadata.</h2><span id='topic+can.plot.colorbar'></span>

<h3>Description</h3>

<p>Determine whether colorbar can be plotted with given metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>can.plot.colorbar(combined_data_range, makecmap_options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="can.plot.colorbar_+3A_combined_data_range">combined_data_range</code></td>
<td>
<p>numerical vector of length 2, the combined data range of the meshes as returned by <code>coloredmeshes.combined.data.range</code></p>
</td></tr>
<tr><td><code id="can.plot.colorbar_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>the 'makecmap_options' from the metadata field of the 'coloredmeshes', see <code>coloredmeshes.get.md</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether the metadata suffices to plot a colorbar
</p>

<hr>
<h2 id='can.plot.colorbar.from.coloredmeshes'>Determine whether colorbar can be plotted with given coloredmeshes.</h2><span id='topic+can.plot.colorbar.from.coloredmeshes'></span>

<h3>Description</h3>

<p>Determine whether colorbar can be plotted with given coloredmeshes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>can.plot.colorbar.from.coloredmeshes(coloredmeshes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="can.plot.colorbar.from.coloredmeshes_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>hemilist of coloredmeshes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether the metadata suffices to plot a colorbar
</p>

<hr>
<h2 id='check.subjects.files'>Report subjects missing files</h2><span id='topic+check.subjects.files'></span>

<h3>Description</h3>

<p>Report subjects missing files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.subjects.files(
  subjects_dir,
  subjects_list,
  sfiles = c("surf/lh.thickness", "surf/rh.thickness", "surf/lh.white", "surf/rh.white",
    "label/lh.aparc.annot", "label/rh.aparc.annot")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.subjects.files_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="check.subjects.files_+3A_subjects_list">subjects_list</code></td>
<td>
<p>vector of strings. The subject identifiers.</p>
</td></tr>
<tr><td><code id="check.subjects.files_+3A_sfiles">sfiles</code></td>
<td>
<p>vector of character strings, the file names, relative to the data dir of the subject.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of character strings, the subjects missing any of the files.
</p>

<hr>
<h2 id='check.subjectslist'>Check whether the subjects_list looks good, warn if not.</h2><span id='topic+check.subjectslist'></span>

<h3>Description</h3>

<p>Check whether the subjects_list looks good, warn if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.subjectslist(
  subjects_list,
  subjects_dir = NULL,
  report_name = "subjects_list"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.subjectslist_+3A_subjects_list">subjects_list</code></td>
<td>
<p>vector of character strings, the subject IDs.</p>
</td></tr>
<tr><td><code id="check.subjectslist_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>optional, character string. The full path to the subjects directory containing all subjects. If given, extra checks will be performed, e.g., whether the subjects exist in this directory.</p>
</td></tr>
<tr><td><code id="check.subjectslist_+3A_report_name">report_name</code></td>
<td>
<p>character string, the variable name that should be used for the list in the messages.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function will stop if subjects dirs are missing.
</p>

<hr>
<h2 id='clip_fun'>Get data clipping function.</h2><span id='topic+clip_fun'></span>

<h3>Description</h3>

<p>Get data clipping function to use in <code><a href="#topic+rglactions">rglactions</a></code> as 'trans_fun' to transform data. This is typically used to limit the colorbar in a plot to a certain range. This uses percentiles to clip. Clipping means that values more extreme than the gíven quantiles will be set to the quantile values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clip_fun(lower = 0.05, upper = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clip_fun_+3A_lower">lower</code></td>
<td>
<p>numeric. The probability for the lower quantile, defaults to '0.05'.</p>
</td></tr>
<tr><td><code id="clip_fun_+3A_upper">upper</code></td>
<td>
<p>numeric. The probability for the upper quantile, defaults to '0.95'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that takes as argument the data, and clips it to the requested range. I.e., values outside the range will be set to the closest border value. Designed to be used as <code>rglactions$trans_fun</code> in vis functions, to limit the colorbar and data range.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rglactions">rglactions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   rglactions = list("trans_fun"=clip_fun(0.10, 0.90));
   rglactions = list("trans_fun"=clip_fun());
   f = clip_fun();
   f(rnorm(100));

</code></pre>

<hr>
<h2 id='clip.data'>Clip data at quantiles to remove outliers.</h2><span id='topic+clip.data'></span>

<h3>Description</h3>

<p>Set all data values outside the given quantile range to the border values. This is useful to properly visualize morphometry data that includes outliers. These outliers negatively affect the colormap, as all the non-outlier values become hard to distinguish. This function can be used to filter the data before plotting it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clip.data(data, lower = 0.05, upper = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clip.data_+3A_data">data</code></td>
<td>
<p>numeric vector. The input data. Can also be a <code><a href="#topic+hemilist">hemilist</a></code>.</p>
</td></tr>
<tr><td><code id="clip.data_+3A_lower">lower</code></td>
<td>
<p>numeric. The probability for the lower quantile, defaults to '0.05'.</p>
</td></tr>
<tr><td><code id="clip.data_+3A_upper">upper</code></td>
<td>
<p>numeric. The probability for the upper quantile, defaults to '0.95'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector. The output data.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+clip_fun">clip_fun</a></code> function is more convenient when used in <code><a href="#topic+rglactions">rglactions</a></code>, as it allows specification of custom quantiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   full_data = rnorm(50, 3, 1);
   clipped = clip.data(full_data);

</code></pre>

<hr>
<h2 id='cm.cbry'>Get cyan blue red yellow colormap function.</h2><span id='topic+cm.cbry'></span>

<h3>Description</h3>

<p>Get cyan blue red yellow colormap function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cm.cbry()
</code></pre>


<h3>Note</h3>

<p>Returns a diverging palette with negative values in blue/cyan and positive ones in red/yellow, suitable for visualizing data that is centered around zero. Often used for clusters in neuroscience.
</p>

<hr>
<h2 id='cm.div'>Return the standard fsbrain diverging colormap.</h2><span id='topic+cm.div'></span>

<h3>Description</h3>

<p>Return the standard fsbrain diverging colormap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cm.div(report = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cm.div_+3A_report">report</code></td>
<td>
<p>logical, whether to print a message with a name of the chosen colormap, in format <code>package::function#palette</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Returns some diverging palette, suitable for visualizing data that is centered around zero.
</p>

<hr>
<h2 id='cm.heat'>Return the standard fsbrain heat colormap.</h2><span id='topic+cm.heat'></span>

<h3>Description</h3>

<p>Return the standard fsbrain heat colormap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cm.heat(report = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cm.heat_+3A_report">report</code></td>
<td>
<p>logical, whether to print a message with a name of the chosen colormap, in format <code>package::function#palette</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The heat palette is a sequential, single-hue palette.
</p>

<hr>
<h2 id='cm.qual'>Return the standard fsbrain qualitative colormap.</h2><span id='topic+cm.qual'></span>

<h3>Description</h3>

<p>Return the standard fsbrain qualitative colormap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cm.qual(report = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cm.qual_+3A_report">report</code></td>
<td>
<p>logical, whether to print a message with a name of the chosen colormap, in format <code>package::function#palette</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Returns some qualitative palette, suitable for visualizing categorical data.
</p>

<hr>
<h2 id='cm.seq'>Return the standard fsbrain sequential colormap.</h2><span id='topic+cm.seq'></span>

<h3>Description</h3>

<p>Return the standard fsbrain sequential colormap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cm.seq(report = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cm.seq_+3A_report">report</code></td>
<td>
<p>logical, whether to print a message with a name of the chosen colormap, in format <code>package::function#palette</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This returns a sequential, multi-hue palette.
</p>

<hr>
<h2 id='collayer.bg'>Compute binarized mean curvature surface color layer.</h2><span id='topic+collayer.bg'></span>

<h3>Description</h3>

<p>Compute a binarized mean curvature surface color layer, this is intended as a background color layer. You can merge it with your data layer using <code><a href="#topic+collayers.merge">collayers.merge</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collayer.bg(subjects_dir, subject_id, bg, hemi = "both")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collayer.bg_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>character string, the FreeSurfer SUBJECTS_DIR.</p>
</td></tr>
<tr><td><code id="collayer.bg_+3A_subject_id">subject_id</code></td>
<td>
<p>character string, the subject identifier.</p>
</td></tr>
<tr><td><code id="collayer.bg_+3A_bg">bg</code></td>
<td>
<p>character string, a background name. One of 'curv', 'curv_light', 'sulc', 'sulc_light', or 'aparc'.  If this is already a colorlayer in a hemilist, it will be returned as-is.</p>
</td></tr>
<tr><td><code id="collayer.bg_+3A_hemi">hemi</code></td>
<td>
<p>character string, one of 'lh', 'rh', or 'both'. The latter will merge the data for both hemis into a single vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a color layer, i.e., vector of color strings in a hemilist
</p>


<h3>See Also</h3>

<p>You can plot the return value using <code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a></code>.
</p>
<p>Other surface color layer: 
<code><a href="#topic+collayer.bg.atlas">collayer.bg.atlas</a>()</code>,
<code><a href="#topic+collayer.bg.meancurv">collayer.bg.meancurv</a>()</code>,
<code><a href="#topic+collayer.bg.sulc">collayer.bg.sulc</a>()</code>,
<code><a href="#topic+collayer.from.annotdata">collayer.from.annotdata</a>()</code>,
<code><a href="#topic+collayer.from.annot">collayer.from.annot</a>()</code>,
<code><a href="#topic+collayer.from.mask.data">collayer.from.mask.data</a>()</code>,
<code><a href="#topic+collayer.from.morphlike.data">collayer.from.morphlike.data</a>()</code>,
<code><a href="#topic+collayers.merge">collayers.merge</a>()</code>
</p>

<hr>
<h2 id='collayer.bg.atlas'>Compute atlas or annotation surface color layer.</h2><span id='topic+collayer.bg.atlas'></span>

<h3>Description</h3>

<p>Compute atlas or annotation surface color layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collayer.bg.atlas(
  subjects_dir,
  subject_id,
  hemi = "both",
  atlas = "aparc",
  grayscale = FALSE,
  outline = FALSE,
  outline_surface = "white"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collayer.bg.atlas_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>character string, the FreeSurfer SUBJECTS_DIR.</p>
</td></tr>
<tr><td><code id="collayer.bg.atlas_+3A_subject_id">subject_id</code></td>
<td>
<p>character string, the subject identifier.</p>
</td></tr>
<tr><td><code id="collayer.bg.atlas_+3A_hemi">hemi</code></td>
<td>
<p>character string, one of 'lh', 'rh', or 'both'. The latter will merge the data for both hemis into a single vector.</p>
</td></tr>
<tr><td><code id="collayer.bg.atlas_+3A_atlas">atlas</code></td>
<td>
<p>character string, the atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="collayer.bg.atlas_+3A_grayscale">grayscale</code></td>
<td>
<p>logical, whether to convert the atlas colors to grayscale</p>
</td></tr>
<tr><td><code id="collayer.bg.atlas_+3A_outline">outline</code></td>
<td>
<p>logical, whether to draw an outline only instead of filling the regions. Defaults to 'FALSE'. Instead of passing 'TRUE', one can also pass a list of extra parameters to pass to <code><a href="#topic+annot.outline">annot.outline</a></code>, e.g., <code>outline=list('outline_color'='#000000')</code>.</p>
</td></tr>
<tr><td><code id="collayer.bg.atlas_+3A_outline_surface">outline_surface</code></td>
<td>
<p>character string, the surface to load. Only relevant when 'outline' is used. (In that case the surface mesh is needed to compute the vertices forming the region borders.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a color layer, i.e., vector of color strings in a hemilist
</p>


<h3>Note</h3>

<p>Using 'outline' mode is quite slow, and increasing the border thickness makes it even slower.
</p>


<h3>See Also</h3>

<p>You can plot the return value using <code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a></code>.
</p>
<p>Other surface color layer: 
<code><a href="#topic+collayer.bg.meancurv">collayer.bg.meancurv</a>()</code>,
<code><a href="#topic+collayer.bg.sulc">collayer.bg.sulc</a>()</code>,
<code><a href="#topic+collayer.bg">collayer.bg</a>()</code>,
<code><a href="#topic+collayer.from.annotdata">collayer.from.annotdata</a>()</code>,
<code><a href="#topic+collayer.from.annot">collayer.from.annot</a>()</code>,
<code><a href="#topic+collayer.from.mask.data">collayer.from.mask.data</a>()</code>,
<code><a href="#topic+collayer.from.morphlike.data">collayer.from.morphlike.data</a>()</code>,
<code><a href="#topic+collayers.merge">collayers.merge</a>()</code>
</p>

<hr>
<h2 id='collayer.bg.meancurv'>Compute binarized mean curvature surface color layer.</h2><span id='topic+collayer.bg.meancurv'></span>

<h3>Description</h3>

<p>Compute a binarized mean curvature surface color layer, this is intended as a background color layer. You can merge it with your data layer using <code><a href="#topic+collayers.merge">collayers.merge</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collayer.bg.meancurv(
  subjects_dir,
  subject_id,
  hemi = "both",
  cortex_only = FALSE,
  bin_colors = c("#898989", "#5e5e5e"),
  bin_thresholds = c(0)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collayer.bg.meancurv_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>character string, the FreeSurfer SUBJECTS_DIR.</p>
</td></tr>
<tr><td><code id="collayer.bg.meancurv_+3A_subject_id">subject_id</code></td>
<td>
<p>character string, the subject identifier.</p>
</td></tr>
<tr><td><code id="collayer.bg.meancurv_+3A_hemi">hemi</code></td>
<td>
<p>character string, one of 'lh', 'rh', or 'both'. The latter will merge the data for both hemis into a single vector.</p>
</td></tr>
<tr><td><code id="collayer.bg.meancurv_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to restrict pattern computation to the cortex.</p>
</td></tr>
<tr><td><code id="collayer.bg.meancurv_+3A_bin_colors">bin_colors</code></td>
<td>
<p>vector of two character strings, the two colors to use.</p>
</td></tr>
<tr><td><code id="collayer.bg.meancurv_+3A_bin_thresholds">bin_thresholds</code></td>
<td>
<p>vector of 1 or 2 double values, the curvature threshold values used to separate gyri from sulci.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a color layer, i.e., vector of color strings in a hemilist
</p>


<h3>See Also</h3>

<p>You can plot the return value using <code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a></code>.
</p>
<p>Other surface color layer: 
<code><a href="#topic+collayer.bg.atlas">collayer.bg.atlas</a>()</code>,
<code><a href="#topic+collayer.bg.sulc">collayer.bg.sulc</a>()</code>,
<code><a href="#topic+collayer.bg">collayer.bg</a>()</code>,
<code><a href="#topic+collayer.from.annotdata">collayer.from.annotdata</a>()</code>,
<code><a href="#topic+collayer.from.annot">collayer.from.annot</a>()</code>,
<code><a href="#topic+collayer.from.mask.data">collayer.from.mask.data</a>()</code>,
<code><a href="#topic+collayer.from.morphlike.data">collayer.from.morphlike.data</a>()</code>,
<code><a href="#topic+collayers.merge">collayers.merge</a>()</code>
</p>

<hr>
<h2 id='collayer.bg.sulc'>Compute binarized sulcal depth surface color layer.</h2><span id='topic+collayer.bg.sulc'></span>

<h3>Description</h3>

<p>Compute a binarized sulcal depth surface color layer, this is intended as a background color layer. You can merge it with your data layer using <code><a href="#topic+collayers.merge">collayers.merge</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collayer.bg.sulc(
  subjects_dir,
  subject_id,
  hemi = "both",
  cortex_only = FALSE,
  bin_colors = c("#898989", "#5e5e5e"),
  bin_thresholds = c(0)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collayer.bg.sulc_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>character string, the FreeSurfer SUBJECTS_DIR.</p>
</td></tr>
<tr><td><code id="collayer.bg.sulc_+3A_subject_id">subject_id</code></td>
<td>
<p>character string, the subject identifier.</p>
</td></tr>
<tr><td><code id="collayer.bg.sulc_+3A_hemi">hemi</code></td>
<td>
<p>character string, one of 'lh', 'rh', or 'both'. The latter will merge the data for both hemis into a single vector.</p>
</td></tr>
<tr><td><code id="collayer.bg.sulc_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to restrict pattern computation to the cortex.</p>
</td></tr>
<tr><td><code id="collayer.bg.sulc_+3A_bin_colors">bin_colors</code></td>
<td>
<p>vector of two character strings, the two colors to use.</p>
</td></tr>
<tr><td><code id="collayer.bg.sulc_+3A_bin_thresholds">bin_thresholds</code></td>
<td>
<p>vector of 1 or 2 double values, the curvature threshold values used to separate gyri from sulci.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a color layer, i.e., vector of color strings in a hemilist
</p>


<h3>See Also</h3>

<p>You can plot the return value using <code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a></code>.
</p>
<p>Other surface color layer: 
<code><a href="#topic+collayer.bg.atlas">collayer.bg.atlas</a>()</code>,
<code><a href="#topic+collayer.bg.meancurv">collayer.bg.meancurv</a>()</code>,
<code><a href="#topic+collayer.bg">collayer.bg</a>()</code>,
<code><a href="#topic+collayer.from.annotdata">collayer.from.annotdata</a>()</code>,
<code><a href="#topic+collayer.from.annot">collayer.from.annot</a>()</code>,
<code><a href="#topic+collayer.from.mask.data">collayer.from.mask.data</a>()</code>,
<code><a href="#topic+collayer.from.morphlike.data">collayer.from.morphlike.data</a>()</code>,
<code><a href="#topic+collayers.merge">collayers.merge</a>()</code>
</p>

<hr>
<h2 id='collayer.from.annot'>Compute surface color layer from annotation or atlas data.</h2><span id='topic+collayer.from.annot'></span>

<h3>Description</h3>

<p>Compute surface color layer from annotation or atlas data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collayer.from.annot(subjects_dir, subject_id, hemi, atlas)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collayer.from.annot_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>character string, the FreeSurfer SUBJECTS_DIR.</p>
</td></tr>
<tr><td><code id="collayer.from.annot_+3A_subject_id">subject_id</code></td>
<td>
<p>character string, the subject identifier.</p>
</td></tr>
<tr><td><code id="collayer.from.annot_+3A_hemi">hemi</code></td>
<td>
<p>character string, one of 'lh', 'rh', or 'both'.</p>
</td></tr>
<tr><td><code id="collayer.from.annot_+3A_atlas">atlas</code></td>
<td>
<p>character string, the atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named hemi list, each entry is a vector of color strings, one color per surface vertex. The coloring represents the atlas data.
</p>


<h3>See Also</h3>

<p>You can plot the return value using <code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a></code>.
</p>
<p>Other surface color layer: 
<code><a href="#topic+collayer.bg.atlas">collayer.bg.atlas</a>()</code>,
<code><a href="#topic+collayer.bg.meancurv">collayer.bg.meancurv</a>()</code>,
<code><a href="#topic+collayer.bg.sulc">collayer.bg.sulc</a>()</code>,
<code><a href="#topic+collayer.bg">collayer.bg</a>()</code>,
<code><a href="#topic+collayer.from.annotdata">collayer.from.annotdata</a>()</code>,
<code><a href="#topic+collayer.from.mask.data">collayer.from.mask.data</a>()</code>,
<code><a href="#topic+collayer.from.morphlike.data">collayer.from.morphlike.data</a>()</code>,
<code><a href="#topic+collayers.merge">collayers.merge</a>()</code>
</p>

<hr>
<h2 id='collayer.from.annotdata'>Compute surface color layer from annotation or atlas data.</h2><span id='topic+collayer.from.annotdata'></span>

<h3>Description</h3>

<p>Compute surface color layer from annotation or atlas data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collayer.from.annotdata(lh_annotdata = NULL, rh_annotdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collayer.from.annotdata_+3A_lh_annotdata">lh_annotdata</code></td>
<td>
<p>loaded annotation data for left hemi, as returned by <code><a href="#topic+subject.annot">subject.annot</a></code></p>
</td></tr>
<tr><td><code id="collayer.from.annotdata_+3A_rh_annotdata">rh_annotdata</code></td>
<td>
<p>loaded annotation data for right hemi</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named hemi list, each entry is a vector of color strings, one color per surface vertex. The coloring represents the atlas data.
</p>


<h3>See Also</h3>

<p>You can plot the return value using <code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a></code>.
</p>
<p>Other surface color layer: 
<code><a href="#topic+collayer.bg.atlas">collayer.bg.atlas</a>()</code>,
<code><a href="#topic+collayer.bg.meancurv">collayer.bg.meancurv</a>()</code>,
<code><a href="#topic+collayer.bg.sulc">collayer.bg.sulc</a>()</code>,
<code><a href="#topic+collayer.bg">collayer.bg</a>()</code>,
<code><a href="#topic+collayer.from.annot">collayer.from.annot</a>()</code>,
<code><a href="#topic+collayer.from.mask.data">collayer.from.mask.data</a>()</code>,
<code><a href="#topic+collayer.from.morphlike.data">collayer.from.morphlike.data</a>()</code>,
<code><a href="#topic+collayers.merge">collayers.merge</a>()</code>
</p>

<hr>
<h2 id='collayer.from.mask.data'>Compute surface color layer from morph-like data.</h2><span id='topic+collayer.from.mask.data'></span>

<h3>Description</h3>

<p>Compute surface color layer from morph-like data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collayer.from.mask.data(
  lh_data = NULL,
  rh_data = NULL,
  makecmap_options = list(colFn = label.colFn)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collayer.from.mask.data_+3A_lh_data">lh_data</code></td>
<td>
<p>integer vector, can be NULL</p>
</td></tr>
<tr><td><code id="collayer.from.mask.data_+3A_rh_data">rh_data</code></td>
<td>
<p>numerical vector, can be NULL</p>
</td></tr>
<tr><td><code id="collayer.from.mask.data_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named hemi list, each entry is a vector of color strings, one color per surface vertex. The coloring represents the label data.
</p>


<h3>See Also</h3>

<p>You can plot the return value using <code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a></code>.
</p>
<p>Other surface color layer: 
<code><a href="#topic+collayer.bg.atlas">collayer.bg.atlas</a>()</code>,
<code><a href="#topic+collayer.bg.meancurv">collayer.bg.meancurv</a>()</code>,
<code><a href="#topic+collayer.bg.sulc">collayer.bg.sulc</a>()</code>,
<code><a href="#topic+collayer.bg">collayer.bg</a>()</code>,
<code><a href="#topic+collayer.from.annotdata">collayer.from.annotdata</a>()</code>,
<code><a href="#topic+collayer.from.annot">collayer.from.annot</a>()</code>,
<code><a href="#topic+collayer.from.morphlike.data">collayer.from.morphlike.data</a>()</code>,
<code><a href="#topic+collayers.merge">collayers.merge</a>()</code>
</p>

<hr>
<h2 id='collayer.from.morphlike.data'>Compute surface color layer from morph-like data.</h2><span id='topic+collayer.from.morphlike.data'></span>

<h3>Description</h3>

<p>Compute surface color layer from morph-like data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collayer.from.morphlike.data(
  lh_morph_data = NULL,
  rh_morph_data = NULL,
  makecmap_options = list(colFn = cm.seq()),
  return_metadata = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collayer.from.morphlike.data_+3A_lh_morph_data">lh_morph_data</code></td>
<td>
<p>numerical vector, can be NULL</p>
</td></tr>
<tr><td><code id="collayer.from.morphlike.data_+3A_rh_morph_data">rh_morph_data</code></td>
<td>
<p>numerical vector, can be NULL</p>
</td></tr>
<tr><td><code id="collayer.from.morphlike.data_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'.</p>
</td></tr>
<tr><td><code id="collayer.from.morphlike.data_+3A_return_metadata">return_metadata</code></td>
<td>
<p>logical, whether to return additional metadata as entry 'metadata' in the returned list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named hemi list, each entry is a vector of color strings, one color per surface vertex. The coloring represents the morph data.
</p>


<h3>See Also</h3>

<p>You can plot the return value using <code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a></code>.
</p>
<p>Other surface color layer: 
<code><a href="#topic+collayer.bg.atlas">collayer.bg.atlas</a>()</code>,
<code><a href="#topic+collayer.bg.meancurv">collayer.bg.meancurv</a>()</code>,
<code><a href="#topic+collayer.bg.sulc">collayer.bg.sulc</a>()</code>,
<code><a href="#topic+collayer.bg">collayer.bg</a>()</code>,
<code><a href="#topic+collayer.from.annotdata">collayer.from.annotdata</a>()</code>,
<code><a href="#topic+collayer.from.annot">collayer.from.annot</a>()</code>,
<code><a href="#topic+collayer.from.mask.data">collayer.from.mask.data</a>()</code>,
<code><a href="#topic+collayers.merge">collayers.merge</a>()</code>
</p>

<hr>
<h2 id='collayers.merge'>Merge two or more color layers based on their transparency values.</h2><span id='topic+collayers.merge'></span>

<h3>Description</h3>

<p>Merge several color layers into one based on their transparency and alpha blending. In the final result, the lower layers are visible through the transparent or 'NA' parts (if any) of the upper layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collayers.merge(collayers, opaque_background = "#FFFFFF")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collayers.merge_+3A_collayers">collayers</code></td>
<td>
<p>named list, the values must be vectors, matrices or arrays of color strings (as produced by <code><a href="grDevices.html#topic+rgb">rgb</a></code>. The names are free form and do not really matter. All values must have the same length.</p>
</td></tr>
<tr><td><code id="collayers.merge_+3A_opaque_background">opaque_background</code></td>
<td>
<p>a single color string or 'NULL'. If a color string, this color will be used as a final opaque background layer to ensure that the returned colors are all opaque. Pass 'NULL' to skip this, which may result in a return value that contains non-opaque color values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a color layer, i.e., vector of color strings in a hemilist
</p>


<h3>See Also</h3>

<p>Other surface color layer: 
<code><a href="#topic+collayer.bg.atlas">collayer.bg.atlas</a>()</code>,
<code><a href="#topic+collayer.bg.meancurv">collayer.bg.meancurv</a>()</code>,
<code><a href="#topic+collayer.bg.sulc">collayer.bg.sulc</a>()</code>,
<code><a href="#topic+collayer.bg">collayer.bg</a>()</code>,
<code><a href="#topic+collayer.from.annotdata">collayer.from.annotdata</a>()</code>,
<code><a href="#topic+collayer.from.annot">collayer.from.annot</a>()</code>,
<code><a href="#topic+collayer.from.mask.data">collayer.from.mask.data</a>()</code>,
<code><a href="#topic+collayer.from.morphlike.data">collayer.from.morphlike.data</a>()</code>
</p>

<hr>
<h2 id='coloredmesh.from.annot'>Create a coloredmesh from an annotation of an atlas.</h2><span id='topic+coloredmesh.from.annot'></span>

<h3>Description</h3>

<p>Create a coloredmesh from an annotation of an atlas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloredmesh.from.annot(
  subjects_dir,
  subject_id,
  atlas,
  hemi,
  surface = "white",
  outline = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coloredmesh.from.annot_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.annot_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.annot_+3A_atlas">atlas</code></td>
<td>
<p>string or a loaded annotation. If a string, interpreted as the atlas name that should be loaded to get te annotation. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.annot_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.annot_+3A_surface">surface</code></td>
<td>
<p>character string or 'fs.surface' instance. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.annot_+3A_outline">outline</code></td>
<td>
<p>logical, whether to draw an outline only instead of filling the regions. Defaults to FALSE. Only makes sense if you did not pass an outline already. The current implementation for outline computation is rather slow, so setting this to TRUE will considerably increase computation time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coloredmesh. A named list with entries: &quot;mesh&quot; the <code>tmesh3d</code> mesh object. &quot;col&quot;: the mesh colors. &quot;render&quot;, logical, whether to render the mesh. &quot;hemi&quot;: the hemisphere, one of 'lh' or 'rh'.
</p>


<h3>See Also</h3>

<p>Other coloredmesh functions: 
<code><a href="#topic+coloredmesh.from.label">coloredmesh.from.label</a>()</code>,
<code><a href="#topic+coloredmesh.from.mask">coloredmesh.from.mask</a>()</code>,
<code><a href="#topic+coloredmesh.from.morph.native">coloredmesh.from.morph.native</a>()</code>,
<code><a href="#topic+coloredmesh.from.morph.standard">coloredmesh.from.morph.standard</a>()</code>,
<code><a href="#topic+coloredmesh.from.morphdata">coloredmesh.from.morphdata</a>()</code>,
<code><a href="#topic+coloredmeshes.from.color">coloredmeshes.from.color</a>()</code>
</p>

<hr>
<h2 id='coloredmesh.from.color'>Create a coloredmesh from a mesh and pre-defined colors.</h2><span id='topic+coloredmesh.from.color'></span>

<h3>Description</h3>

<p>Create a coloredmesh from a mesh and pre-defined colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloredmesh.from.color(
  subjects_dir,
  subject_id,
  color_data,
  hemi,
  surface = "white",
  metadata = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coloredmesh.from.color_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.color_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.color_+3A_color_data">color_data</code></td>
<td>
<p>vector of hex color strings, a single one or one per vertex.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.color_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.color_+3A_surface">surface</code></td>
<td>
<p>character string or 'fs.surface' instance. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.color_+3A_metadata">metadata</code></td>
<td>
<p>a named list, can contain whatever you want. Typical entries are: 'src_data' a hemilist containing the source data from which the 'color_data' was created, optional. If available, it is encoded into the coloredmesh and can be used later to plot a colorbar. 'makecmap_options': the options used to created the colormap from the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coloredmesh. A named list with entries: &quot;mesh&quot; the <code>tmesh3d</code> mesh object. &quot;col&quot;: the mesh colors. &quot;render&quot;, logical, whether to render the mesh. &quot;hemi&quot;: the hemisphere, one of 'lh' or 'rh'.
</p>


<h3>Note</h3>

<p>Do not call this directly, use <code><a href="#topic+coloredmeshes.from.color">coloredmeshes.from.color</a></code> instead.
</p>

<hr>
<h2 id='coloredmesh.from.label'>Create a coloredmesh from a label.</h2><span id='topic+coloredmesh.from.label'></span>

<h3>Description</h3>

<p>Create a coloredmesh from a label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloredmesh.from.label(
  subjects_dir,
  subject_id,
  label,
  hemi,
  surface = "white",
  makecmap_options = list(colFn = squash::rainbow2),
  binary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coloredmesh.from.label_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.label_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.label_+3A_label">label</code></td>
<td>
<p>string or vector of integers. If a string, the name of the label file, without the hemi part (if any), but including the '.label' suffix. E.g., 'cortex.label' for '?h.cortex.label'. Alternatively, the already loaded label data as a vector of integers.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.label_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.label_+3A_surface">surface</code></td>
<td>
<p>character string or 'fs.surface' instance. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.label_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.label_+3A_binary">binary</code></td>
<td>
<p>logical, whether to treat the label as binary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coloredmesh. A named list with entries: &quot;mesh&quot; the <code>tmesh3d</code> mesh object. &quot;col&quot;: the mesh colors. &quot;render&quot;, logical, whether to render the mesh. &quot;hemi&quot;: the hemisphere, one of 'lh' or 'rh'.
</p>


<h3>See Also</h3>

<p>Other coloredmesh functions: 
<code><a href="#topic+coloredmesh.from.annot">coloredmesh.from.annot</a>()</code>,
<code><a href="#topic+coloredmesh.from.mask">coloredmesh.from.mask</a>()</code>,
<code><a href="#topic+coloredmesh.from.morph.native">coloredmesh.from.morph.native</a>()</code>,
<code><a href="#topic+coloredmesh.from.morph.standard">coloredmesh.from.morph.standard</a>()</code>,
<code><a href="#topic+coloredmesh.from.morphdata">coloredmesh.from.morphdata</a>()</code>,
<code><a href="#topic+coloredmeshes.from.color">coloredmeshes.from.color</a>()</code>
</p>

<hr>
<h2 id='coloredmesh.from.mask'>Create a coloredmesh from a mask.</h2><span id='topic+coloredmesh.from.mask'></span>

<h3>Description</h3>

<p>Create a coloredmesh from a mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloredmesh.from.mask(
  subjects_dir,
  subject_id,
  mask,
  hemi,
  surface = "white",
  surface_data = NULL,
  makecmap_options = list(colFn = squash::rainbow2)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coloredmesh.from.mask_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.mask_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.mask_+3A_mask">mask</code></td>
<td>
<p>logical vector, contains one logical value per vertex.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.mask_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.mask_+3A_surface">surface</code></td>
<td>
<p>character string or 'fs.surface' instance. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.mask_+3A_surface_data">surface_data</code></td>
<td>
<p>optional surface mesh object, as returned by <code><a href="#topic+subject.surface">subject.surface</a></code>. If given, used instead of loading the surface data from disk (which users of this function may already have done). Defaults to NULL.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.mask_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coloredmesh. A named list with entries: &quot;mesh&quot; the <code>tmesh3d</code> mesh object. &quot;col&quot;: the mesh colors. &quot;render&quot;, logical, whether to render the mesh. &quot;hemi&quot;: the hemisphere, one of 'lh' or 'rh'.
</p>


<h3>See Also</h3>

<p>Other mask functions: 
<code><a href="#topic+mask.from.labeldata.for.hemi">mask.from.labeldata.for.hemi</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>
</p>
<p>Other coloredmesh functions: 
<code><a href="#topic+coloredmesh.from.annot">coloredmesh.from.annot</a>()</code>,
<code><a href="#topic+coloredmesh.from.label">coloredmesh.from.label</a>()</code>,
<code><a href="#topic+coloredmesh.from.morph.native">coloredmesh.from.morph.native</a>()</code>,
<code><a href="#topic+coloredmesh.from.morph.standard">coloredmesh.from.morph.standard</a>()</code>,
<code><a href="#topic+coloredmesh.from.morphdata">coloredmesh.from.morphdata</a>()</code>,
<code><a href="#topic+coloredmeshes.from.color">coloredmeshes.from.color</a>()</code>
</p>

<hr>
<h2 id='coloredmesh.from.morph.native'>Create a coloredmesh from native space morphometry data.</h2><span id='topic+coloredmesh.from.morph.native'></span>

<h3>Description</h3>

<p>Create a coloredmesh from native space morphometry data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloredmesh.from.morph.native(
  subjects_dir,
  subject_id,
  measure,
  hemi,
  surface = "white",
  clip = NULL,
  cortex_only = FALSE,
  makecmap_options = mkco.seq()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coloredmesh.from.morph.native_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.native_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.native_+3A_measure">measure</code></td>
<td>
<p>string. The morphometry data to use. E.g., 'area' or 'thickness'. Pass NULL to render the surface in white, without any data. One can also pass the pre-loaded morphometry data as a numerical vector, the length of which must match the number of surface vertices.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.native_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.native_+3A_surface">surface</code></td>
<td>
<p>character string or 'fs.surface' instance. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.native_+3A_clip">clip</code></td>
<td>
<p>numeric vector of length 2 or NULL. If given, the 2 values are interpreted as lower and upper percentiles, and the morph data is clipped at the given lower and upper percentile (see <code><a href="#topic+clip.data">clip.data</a></code>). Defaults to NULL (no data clipping).</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.native_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to mask the medial wall, i.e., whether the morphometry data for all vertices which are *not* part of the cortex (as defined by the label file 'label/?h.cortex.label') should be replaced with NA values. In other words, setting this to TRUE will ignore the values of the medial wall between the two hemispheres. If set to true, the mentioned label file needs to exist for the subject. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.native_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coloredmesh. A named list with entries: &quot;mesh&quot; the <code>tmesh3d</code> mesh object. &quot;col&quot;: the mesh colors. &quot;render&quot;, logical, whether to render the mesh. &quot;hemi&quot;: the hemisphere, one of 'lh' or 'rh'.
</p>


<h3>See Also</h3>

<p>Other coloredmesh functions: 
<code><a href="#topic+coloredmesh.from.annot">coloredmesh.from.annot</a>()</code>,
<code><a href="#topic+coloredmesh.from.label">coloredmesh.from.label</a>()</code>,
<code><a href="#topic+coloredmesh.from.mask">coloredmesh.from.mask</a>()</code>,
<code><a href="#topic+coloredmesh.from.morph.standard">coloredmesh.from.morph.standard</a>()</code>,
<code><a href="#topic+coloredmesh.from.morphdata">coloredmesh.from.morphdata</a>()</code>,
<code><a href="#topic+coloredmeshes.from.color">coloredmeshes.from.color</a>()</code>
</p>

<hr>
<h2 id='coloredmesh.from.morph.standard'>Create a coloredmesh from standard space morphometry data.</h2><span id='topic+coloredmesh.from.morph.standard'></span>

<h3>Description</h3>

<p>Create a coloredmesh from standard space morphometry data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloredmesh.from.morph.standard(
  subjects_dir,
  subject_id,
  measure,
  hemi,
  fwhm,
  surface = "white",
  template_subject = "fsaverage",
  template_subjects_dir = NULL,
  clip = NULL,
  cortex_only = FALSE,
  makecmap_options = mkco.seq()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coloredmesh.from.morph.standard_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.standard_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.standard_+3A_measure">measure</code></td>
<td>
<p>string. The morphometry data to use. E.g., 'area' or 'thickness'. Pass NULL to render the surface in white, without any data. One can also pass the pre-loaded morphometry data as a numerical vector, the length of which must match the number of surface vertices.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.standard_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.standard_+3A_fwhm">fwhm</code></td>
<td>
<p>string, smoothing setting. The smoothing part of the filename, typically something like '0', '5', '10', ...,  or '25'.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.standard_+3A_surface">surface</code></td>
<td>
<p>character string or 'fs.surface' instance. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.standard_+3A_template_subject">template_subject</code></td>
<td>
<p>The template subject used. This will be used as part of the filename, and its surfaces are loaded for data visualization. Defaults to 'fsaverage'.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.standard_+3A_template_subjects_dir">template_subjects_dir</code></td>
<td>
<p>The template subjects dir. If &lsquo;NULL', the value of the parameter &rsquo;subjects_dir' is used. Defaults to NULL. If you have FreeSurfer installed and configured, and are using the standard fsaverage subject, try passing the result of calling 'file.path(Sys.getenv('FREESURFER_HOME'), 'subjects')'.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.standard_+3A_clip">clip</code></td>
<td>
<p>numeric vector of length 2 or NULL. If given, the 2 values are interpreted as lower and upper percentiles, and the morph data is clipped at the given lower and upper percentile (see <code><a href="#topic+clip.data">clip.data</a></code>). Defaults to NULL (no data clipping).</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.standard_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to mask the medial wall, i.e., whether the morphometry data for all vertices which are *not* part of the cortex (as defined by the label file 'label/?h.cortex.label') should be replaced with NA values. In other words, setting this to TRUE will ignore the values of the medial wall between the two hemispheres. If set to true, the mentioned label file needs to exist for the subject. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morph.standard_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coloredmesh. A named list with entries: &quot;mesh&quot; the <code>tmesh3d</code> mesh object. &quot;col&quot;: the mesh colors. &quot;render&quot;, logical, whether to render the mesh. &quot;hemi&quot;: the hemisphere, one of 'lh' or 'rh'.
</p>


<h3>See Also</h3>

<p>Other coloredmesh functions: 
<code><a href="#topic+coloredmesh.from.annot">coloredmesh.from.annot</a>()</code>,
<code><a href="#topic+coloredmesh.from.label">coloredmesh.from.label</a>()</code>,
<code><a href="#topic+coloredmesh.from.mask">coloredmesh.from.mask</a>()</code>,
<code><a href="#topic+coloredmesh.from.morph.native">coloredmesh.from.morph.native</a>()</code>,
<code><a href="#topic+coloredmesh.from.morphdata">coloredmesh.from.morphdata</a>()</code>,
<code><a href="#topic+coloredmeshes.from.color">coloredmeshes.from.color</a>()</code>
</p>

<hr>
<h2 id='coloredmesh.from.morphdata'>Create a coloredmesh from arbitrary data.</h2><span id='topic+coloredmesh.from.morphdata'></span>

<h3>Description</h3>

<p>Create a coloredmesh from arbitrary data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloredmesh.from.morphdata(
  subjects_dir,
  vis_subject_id,
  morph_data,
  hemi,
  surface = "white",
  makecmap_options = mkco.seq()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coloredmesh.from.morphdata_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morphdata_+3A_vis_subject_id">vis_subject_id</code></td>
<td>
<p>string. The subject identifier from which to obtain the surface for data visualization. Example: 'fsaverage'.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morphdata_+3A_morph_data">morph_data</code></td>
<td>
<p>string. The morphometry data to use. E.g., 'area' or 'thickness.'</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morphdata_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morphdata_+3A_surface">surface</code></td>
<td>
<p>character string or 'fs.surface' instance. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.morphdata_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coloredmesh. A named list with entries: &quot;mesh&quot; the <code>tmesh3d</code> mesh object. &quot;col&quot;: the mesh colors. &quot;render&quot;, logical, whether to render the mesh. &quot;hemi&quot;: the hemisphere, one of 'lh' or 'rh'.
</p>


<h3>See Also</h3>

<p>Other coloredmesh functions: 
<code><a href="#topic+coloredmesh.from.annot">coloredmesh.from.annot</a>()</code>,
<code><a href="#topic+coloredmesh.from.label">coloredmesh.from.label</a>()</code>,
<code><a href="#topic+coloredmesh.from.mask">coloredmesh.from.mask</a>()</code>,
<code><a href="#topic+coloredmesh.from.morph.native">coloredmesh.from.morph.native</a>()</code>,
<code><a href="#topic+coloredmesh.from.morph.standard">coloredmesh.from.morph.standard</a>()</code>,
<code><a href="#topic+coloredmeshes.from.color">coloredmeshes.from.color</a>()</code>
</p>

<hr>
<h2 id='coloredmesh.from.preloaded.data'>Generate coloredmesh from loaded data.</h2><span id='topic+coloredmesh.from.preloaded.data'></span>

<h3>Description</h3>

<p>Generate coloredmesh from loaded data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloredmesh.from.preloaded.data(
  fs_surface,
  morph_data = NULL,
  col = NULL,
  hemi = "lh",
  makecmap_options = mkco.seq()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coloredmesh.from.preloaded.data_+3A_fs_surface">fs_surface</code></td>
<td>
<p>an fs.surface instance or a character string, which will be interpreted as the path to a file and loaded with <code>freesurferformats::read.fs.surface</code>.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.preloaded.data_+3A_morph_data">morph_data</code></td>
<td>
<p>numerical vector, per-vertex data (typically morphometry) for the mesh. If given, takes precedence over 'col' parameter.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.preloaded.data_+3A_col">col</code></td>
<td>
<p>vector of colors, typically hex color strings like '#FF00FF'. The per-vertex-colors for the mesh. Alternative to morph_data.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.preloaded.data_+3A_hemi">hemi</code></td>
<td>
<p>character string, one of 'lh' or 'rh'. Metadata, the hemisphere. May be used by visualization functions to decide whether to draw the mesh in certain views.</p>
</td></tr>
<tr><td><code id="coloredmesh.from.preloaded.data_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>as fs.coloredmesh instance
</p>

<hr>
<h2 id='coloredmesh.plot.colorbar.separate'>Draw colorbar for coloredmeshes in separate 2D plot.</h2><span id='topic+coloredmesh.plot.colorbar.separate'></span>

<h3>Description</h3>

<p>Draw a colorbar for the coloredmeshes to a separate 2D plot. Due to the suboptimal handling of colorbar drawing in the three-dimensional multi-panel views, it is often desirable to plot the colorbar in a separate window, export it from there and then manually add it to the final plot version in some image manipulation software like Inkscape. If you need more control over the colormap than offered by this function (e.g., setting the color value for NA values or making a symmetric colormap to ensure that the zero point for divergent colormaps is a neutral color), you should write custom code, and the return value from this function will come in handy to do that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloredmesh.plot.colorbar.separate(
  coloredmeshes,
  show = FALSE,
  image.plot_extra_options = list(horizontal = FALSE, legend.cex = 1.8, legend.width = 2,
    legend.mar = 12, axis.args = list(cex.axis = 5)),
  png_options = list(filename = "fsbrain_cbar.png", width = 1400, height = 1400, bg =
    "#FFFFFF00"),
  silent = FALSE,
  trim_png = TRUE,
  log_breaks = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coloredmesh.plot.colorbar.separate_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of coloredmeshes. A coloredmesh is a named list as returned by the &lsquo;coloredmesh.from' functions. It has the entries &rsquo;mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh. The 'vis*' functions (like <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>) all return a list of coloredmeshes.</p>
</td></tr>
<tr><td><code id="coloredmesh.plot.colorbar.separate_+3A_show">show</code></td>
<td>
<p>logical, Whether to open the resulting plot. Defaults to 'TRUE'.</p>
</td></tr>
<tr><td><code id="coloredmesh.plot.colorbar.separate_+3A_image.plot_extra_options">image.plot_extra_options</code></td>
<td>
<p>named list of extra optins to pass to <code><a href="fields.html#topic+image.plot">image.plot</a></code>. This can be used to add a legend to the colorbar, rotate the colorbar, or whatever. The options &quot;legend_only&quot;, &quot;zlim&quot;, and &quot;col&quot; are computed and set for you  by this function, so there is no need to pass these. Your list will be merged with the internal options, so you could overwrite named arguments if needed.</p>
</td></tr>
<tr><td><code id="coloredmesh.plot.colorbar.separate_+3A_png_options">png_options</code></td>
<td>
<p>Options to pass to <code><a href="grDevices.html#topic+png">png</a></code>, see the docs of that function for details. Allow you to save the plot as a png bitmap image. Example: <code>png_options = list("filename"="fsbrain_cbar.png", "width"=800)</code>. Defaults to NULL, which will not save anything.</p>
</td></tr>
<tr><td><code id="coloredmesh.plot.colorbar.separate_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress messages. Defaults to 'FALSE'.</p>
</td></tr>
<tr><td><code id="coloredmesh.plot.colorbar.separate_+3A_trim_png">trim_png</code></td>
<td>
<p>logical, whether to trim the output PNG image using image magick, i.e., remove everything but the foreground. Ignored unless an output PNG image is actually written (see 'png_options') and the 'magick' package is installed.</p>
</td></tr>
<tr><td><code id="coloredmesh.plot.colorbar.separate_+3A_log_breaks">log_breaks</code></td>
<td>
<p>logical, scalar int, or vector of ints. Whether to use log10 scale for plotting the cbar. If logical and TRUE, uses log scale with default number (=5) ticks auto-computed from the data. If a single integer N, uses N ticks auto-computed from the data instead. If a numeric vector, uses the supplied values in the vector as ticks, note that they must be on a &lsquo;log(data)' scale. If the &rsquo;makecmap_options' stored in the passed 'coloredmeshes' contain a 'base' value of 10, log 10 is assumed (with the default 5 ticks), even if this parameter is left at its default value, logical FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, entries: 'output_img_path': character string, the path to the output file, or NULL.
</p>


<h3>Note</h3>

<p>If you increase the output resolution of the colorbar (using 'png_options'), you will have to increase the font sizes as well (using 'image.plot_extra_options'), otherwise the axis and legend labels will be hard to read.
</p>


<h3>See Also</h3>

<p>Other colorbar functions: 
<code><a href="#topic+combine.colorbar.with.brainview.animation">combine.colorbar.with.brainview.animation</a>()</code>,
<code><a href="#topic+combine.colorbar.with.brainview.image">combine.colorbar.with.brainview.image</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   coloredmeshes = vis.subject.morph.native(subjects_dir, 'subject1',
    'thickness', 'lh', views=c('t4'));
   coloredmesh.plot.colorbar.separate(coloredmeshes);

   # Or plot a colorbar with a label:
   coloredmesh.plot.colorbar.separate(coloredmeshes,
    image.plot_extra_options = list("legend.lab"="Thickness [mm]",
    horizontal=TRUE, legend.cex=1.5, legend.line=-3));

## End(Not run)

</code></pre>

<hr>
<h2 id='coloredmeshes.combined.data.range'>Retrieve combined data range from hemilist of coloredmeshes.</h2><span id='topic+coloredmeshes.combined.data.range'></span>

<h3>Description</h3>

<p>Retrieve combined data range from hemilist of coloredmeshes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloredmeshes.combined.data.range(coloredmeshes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coloredmeshes.combined.data.range_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>hemilist of coloredmeshes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of length 2, the finite data range
</p>

<hr>
<h2 id='coloredmeshes.from.color'>Create coloredmeshes for both hemis using pre-defined colors.</h2><span id='topic+coloredmeshes.from.color'></span>

<h3>Description</h3>

<p>Create coloredmeshes for both hemis using pre-defined colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloredmeshes.from.color(
  subjects_dir,
  subject_id,
  color_data,
  hemi,
  surface = "white",
  metadata = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coloredmeshes.from.color_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmeshes.from.color_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="coloredmeshes.from.color_+3A_color_data">color_data</code></td>
<td>
<p>a hemilist containing vectors of hex color strings</p>
</td></tr>
<tr><td><code id="coloredmeshes.from.color_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="coloredmeshes.from.color_+3A_surface">surface</code></td>
<td>
<p>character string or 'fs.surface' instance. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="coloredmeshes.from.color_+3A_metadata">metadata</code></td>
<td>
<p>a named list, can contain whatever you want. Typical entries are: 'src_data' a hemilist containing the source data from which the 'color_data' was created, optional. If available, it is encoded into the coloredmesh and can be used later to plot a colorbar. 'makecmap_options': the options used to created the colormap from the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of coloredmeshes. Each entry is a named list with entries: &quot;mesh&quot; the <code>tmesh3d</code> mesh object. &quot;col&quot;: the mesh colors. &quot;render&quot;, logical, whether to render the mesh. &quot;hemi&quot;: the hemisphere, one of 'lh' or 'rh'.
</p>


<h3>See Also</h3>

<p>Other coloredmesh functions: 
<code><a href="#topic+coloredmesh.from.annot">coloredmesh.from.annot</a>()</code>,
<code><a href="#topic+coloredmesh.from.label">coloredmesh.from.label</a>()</code>,
<code><a href="#topic+coloredmesh.from.mask">coloredmesh.from.mask</a>()</code>,
<code><a href="#topic+coloredmesh.from.morph.native">coloredmesh.from.morph.native</a>()</code>,
<code><a href="#topic+coloredmesh.from.morph.standard">coloredmesh.from.morph.standard</a>()</code>,
<code><a href="#topic+coloredmesh.from.morphdata">coloredmesh.from.morphdata</a>()</code>
</p>

<hr>
<h2 id='coloredmeshes.get.md'>Retrieve metadata from hemilist of coloredmeshes.</h2><span id='topic+coloredmeshes.get.md'></span>

<h3>Description</h3>

<p>Retrieve metadata from hemilist of coloredmeshes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloredmeshes.get.md(coloredmeshes, mdname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coloredmeshes.get.md_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>hemilist of coloredmeshes</p>
</td></tr>
<tr><td><code id="coloredmeshes.get.md_+3A_mdname">mdname</code></td>
<td>
<p>the key in the named metadata list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the metadata value at the given key/mdname
</p>

<hr>
<h2 id='colorlist.brain.clusters'>Return diverging color list</h2><span id='topic+colorlist.brain.clusters'></span>

<h3>Description</h3>

<p>Return diverging color list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorlist.brain.clusters(num_colors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colorlist.brain.clusters_+3A_num_colors">num_colors</code></td>
<td>
<p>integer, the number of colors you want</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of colors
</p>

<hr>
<h2 id='colors.are.grayscale'>Check for the given color strings whether they represent gray scale colors.</h2><span id='topic+colors.are.grayscale'></span>

<h3>Description</h3>

<p>Check for the given color strings whether they represent gray scale colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colors.are.grayscale(col_strings, accept_col_names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colors.are.grayscale_+3A_col_strings">col_strings</code></td>
<td>
<p>vector of RGB(A) color strings, like <code>c("#FFFFFF", ("#FF00FF"))</code>.</p>
</td></tr>
<tr><td><code id="colors.are.grayscale_+3A_accept_col_names">accept_col_names</code></td>
<td>
<p>logical, whether to accept color names like 'white'. Disables all sanity checks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colors.are.grayscale(c("#FFFFFF", "#FF00FF"));
all((colors.are.grayscale(c("#FFFFFF00", "#ABABABAB"))));

</code></pre>

<hr>
<h2 id='colors.have.transparency'>Check for the given color strings whether they have transparency, i.e., an alpha channel value != fully opaque.</h2><span id='topic+colors.have.transparency'></span>

<h3>Description</h3>

<p>Check for the given color strings whether they have transparency, i.e., an alpha channel value != fully opaque.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colors.have.transparency(col_strings, accept_col_names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colors.have.transparency_+3A_col_strings">col_strings</code></td>
<td>
<p>vector of RGB(A) color strings, like <code>c("#FFFFFF", ("#FF00FF"))</code>.</p>
</td></tr>
<tr><td><code id="colors.have.transparency_+3A_accept_col_names">accept_col_names</code></td>
<td>
<p>logical, whether to accept color names like 'white'. Disables all sanity checks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colors.have.transparency(c("#FFFFFF", "#FF00FF", "#FF00FF00", "red", "#FF00FFDD"));
all((colors.have.transparency(c("#FFFFFF00", "#ABABABAB"))));

</code></pre>

<hr>
<h2 id='combine.colorbar.with.brainview.animation'>Combine a colorbar and a brain animation in gif format into a new animation.</h2><span id='topic+combine.colorbar.with.brainview.animation'></span>

<h3>Description</h3>

<p>Combine a colorbar and a brain animation in gif format into a new animation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.colorbar.with.brainview.animation(
  brain_animation,
  colorbar_img,
  output_animation,
  offset = "+0+0",
  extend_brainview_img_height_by = 0L,
  silent = FALSE,
  allow_colorbar_shrink = TRUE,
  background_color = "white"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine.colorbar.with.brainview.animation_+3A_brain_animation">brain_animation</code></td>
<td>
<p>path to the brain animation in GIF format</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.animation_+3A_colorbar_img">colorbar_img</code></td>
<td>
<p>path to the main image containing the separate colorbar, usually an image in PNG format</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.animation_+3A_output_animation">output_animation</code></td>
<td>
<p>path to output image in gif format, must include the '.gif' file extension</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.animation_+3A_offset">offset</code></td>
<td>
<p>offset string passed to <code>magick::image_composite</code>. Allows you to shift the location of the colorbar in the final image.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.animation_+3A_extend_brainview_img_height_by">extend_brainview_img_height_by</code></td>
<td>
<p>integer value in pixels, the size of the lower border to add to the brainview_img. Use this if the lower part of the colorbar is off the image canvas.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.animation_+3A_silent">silent</code></td>
<td>
<p>logical, whether to silence all messages</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.animation_+3A_allow_colorbar_shrink">allow_colorbar_shrink</code></td>
<td>
<p>logical, whether to shrink the colorbar to the width of the animation in case it is considerably wider (more than 20 percent). Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.animation_+3A_background_color">background_color</code></td>
<td>
<p>color string, the background color to use. Use 'transparency_color' if you want a transparent background.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other colorbar functions: 
<code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a>()</code>,
<code><a href="#topic+combine.colorbar.with.brainview.image">combine.colorbar.with.brainview.image</a>()</code>
</p>

<hr>
<h2 id='combine.colorbar.with.brainview.image'>Combine a colorbar and a brainview image into a new figure.</h2><span id='topic+combine.colorbar.with.brainview.image'></span>

<h3>Description</h3>

<p>Combine a colorbar and a brainview image into a new figure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.colorbar.with.brainview.image(
  brainview_img = "fsbrain_arranged.png",
  colorbar_img = "fsbrain_cbar.png",
  output_img = "fsbrain_merged.png",
  offset = "+0+0",
  extend_brainview_img_height_by = NULL,
  silent = FALSE,
  allow_colorbar_shrink = TRUE,
  horizontal = FALSE,
  background_color = "#FFFFFF",
  transparency_color = NULL,
  delete_colorbar_img = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine.colorbar.with.brainview.image_+3A_brainview_img">brainview_img</code></td>
<td>
<p>path to the main image containing the view of the brain, usually an image in PNG format.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image_+3A_colorbar_img">colorbar_img</code></td>
<td>
<p>path to the main image containing the separate colorbar, usually an image in PNG format.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image_+3A_output_img">output_img</code></td>
<td>
<p>path to output image, including the file extension.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image_+3A_offset">offset</code></td>
<td>
<p>offset string passed to <code>magick::image_composite</code>. Allows you to shift the location of the colorbar in the final image.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image_+3A_extend_brainview_img_height_by">extend_brainview_img_height_by</code></td>
<td>
<p>integer value in pixels, the size of the lower border to add to the brainview_img. Increase this if the lower part of the colorbar is off the image canvas.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image_+3A_silent">silent</code></td>
<td>
<p>logical, whether to silence all messages</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image_+3A_allow_colorbar_shrink">allow_colorbar_shrink</code></td>
<td>
<p>logical, whether to shrink the colorbar to the width of the animation in case it is considerably wider (more than 20 percent). Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image_+3A_horizontal">horizontal</code></td>
<td>
<p>logical, whether the colorbar is horizontal. If so, it will be added below the 'brainview_img'. If it is vertical, it will be added to the right of the 'brainview_img'.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image_+3A_background_color">background_color</code></td>
<td>
<p>color string, the background color to use. Use 'transparency_color' if you want a transparent background.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image_+3A_transparency_color">transparency_color</code></td>
<td>
<p>the temporary background color that will get mapped to transparency, or NULL if you do not want a transparent background. If used, it can be any color that does not occur in the foreground. Try 'white' or 'black' if in doubt.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image_+3A_delete_colorbar_img">delete_colorbar_img</code></td>
<td>
<p>logical, whether to delete the colorbar_img after the combine operation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries 'output_img_path': character string, path to saved image. 'merged_img': magick image instance, the merged image
</p>


<h3>See Also</h3>

<p>Other colorbar functions: 
<code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a>()</code>,
<code><a href="#topic+combine.colorbar.with.brainview.animation">combine.colorbar.with.brainview.animation</a>()</code>
</p>

<hr>
<h2 id='combine.colorbar.with.brainview.image.vertical'>Combine a vertical colorbar and a brainview image into a new figure.</h2><span id='topic+combine.colorbar.with.brainview.image.vertical'></span>

<h3>Description</h3>

<p>Combine a vertical colorbar and a brainview image into a new figure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.colorbar.with.brainview.image.vertical(
  brainview_img,
  colorbar_img,
  output_img,
  offset = "+0+0",
  extend_brainview_img_width_by = NULL,
  silent = FALSE,
  allow_colorbar_shrink = TRUE,
  background_color = "#FFFFFF",
  transparency_color = NULL,
  delete_colorbar_img = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine.colorbar.with.brainview.image.vertical_+3A_brainview_img">brainview_img</code></td>
<td>
<p>path to the main image containing the view of the brain, usually an image in PNG format.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image.vertical_+3A_colorbar_img">colorbar_img</code></td>
<td>
<p>path to the main image containing the separate colorbar, usually an image in PNG format.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image.vertical_+3A_output_img">output_img</code></td>
<td>
<p>path to output image, including the file extension.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image.vertical_+3A_offset">offset</code></td>
<td>
<p>offset string passed to <code>magick::image_composite</code>. Allows you to shift the location of the colorbar in the final image.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image.vertical_+3A_extend_brainview_img_width_by">extend_brainview_img_width_by</code></td>
<td>
<p>integer value in pixels, the size of the right border to add to the brainview_img. Increase this if the right part of the colorbar is off the image canvas.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image.vertical_+3A_silent">silent</code></td>
<td>
<p>logical, whether to silence all messages</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image.vertical_+3A_allow_colorbar_shrink">allow_colorbar_shrink</code></td>
<td>
<p>logical, whether to shrink the colorbar to the width of the animation in case it is considerably wider (more than 20 percent). Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image.vertical_+3A_background_color">background_color</code></td>
<td>
<p>color string, the background color to use. Use 'transparency_color' if you want a transparent background.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image.vertical_+3A_transparency_color">transparency_color</code></td>
<td>
<p>the temporary background color that will get mapped to transparency, or NULL if you do not want a transparent background. If used, it can be any color that does not occur in the foreground. Try 'white' or 'black' if in doubt.</p>
</td></tr>
<tr><td><code id="combine.colorbar.with.brainview.image.vertical_+3A_delete_colorbar_img">delete_colorbar_img</code></td>
<td>
<p>logical, whether to delete the colorbar_img after the combine operation.</p>
</td></tr>
</table>

<hr>
<h2 id='common.makecmap.range'>Get cmap and colorlayer from data and makecmap_options.</h2><span id='topic+common.makecmap.range'></span>

<h3>Description</h3>

<p>Applies a requested 'range' setting if present in makecmap_options. A shared colormap is used for the data of both hemispheres (if present).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common.makecmap.range(
  makecmap_options,
  lh_data = NULL,
  rh_data = NULL,
  return_metadata = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="common.makecmap.range_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'.</p>
</td></tr>
<tr><td><code id="common.makecmap.range_+3A_lh_data">lh_data</code></td>
<td>
<p>numeric vector, data for left hemisphere.</p>
</td></tr>
<tr><td><code id="common.makecmap.range_+3A_rh_data">rh_data</code></td>
<td>
<p>numeric vector, data for right hemisphere.</p>
</td></tr>
<tr><td><code id="common.makecmap.range_+3A_return_metadata">return_metadata</code></td>
<td>
<p>logical, whether to return additional metadata as entry 'metadata' in the returned list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, with entries 'map': named list, the squash cmap, and 'collayer': hemilist of color vectors
</p>

<hr>
<h2 id='constant.pervertexdata'>Get vertex data for a single fs.surface or a hemilist of surfaces.</h2><span id='topic+constant.pervertexdata'></span>

<h3>Description</h3>

<p>Get vertex data for a single fs.surface or a hemilist of surfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constant.pervertexdata(surfaces, value = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constant.pervertexdata_+3A_surfaces">surfaces</code></td>
<td>
<p>an fs.surface instance or a <code><a href="#topic+hemilist">hemilist</a></code> of the latter</p>
</td></tr>
<tr><td><code id="constant.pervertexdata_+3A_value">value</code></td>
<td>
<p>the morphometry data value you want.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or hemilist of vectors of values
</p>

<hr>
<h2 id='cube3D.tris'>Return triangles for a 3D cube or cuboid.</h2><span id='topic+cube3D.tris'></span>

<h3>Description</h3>

<p>Each row of the returned matrix encodes a point (the x, y, and z coordinates), and 3 consecutive rows encode a triangle. Obvisouly, a point will occur several times (as part of several triangles). The result can be passed to <code>triangles3d</code> to render a 3D box. The defaults for the parameters will create a cube with edge length 1 centered at (0, 0, 0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cube3D.tris(
  xmin = -0.5,
  xmax = 0.5,
  ymin = -0.5,
  ymax = 0.5,
  zmin = -0.5,
  zmax = 0.5,
  center = NULL,
  edge_length = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cube3D.tris_+3A_xmin">xmin</code></td>
<td>
<p>numeric, minimal x coordinate</p>
</td></tr>
<tr><td><code id="cube3D.tris_+3A_xmax">xmax</code></td>
<td>
<p>numeric, maximal x coordinate</p>
</td></tr>
<tr><td><code id="cube3D.tris_+3A_ymin">ymin</code></td>
<td>
<p>numeric, minimal y coordinate</p>
</td></tr>
<tr><td><code id="cube3D.tris_+3A_ymax">ymax</code></td>
<td>
<p>numeric, maximal y coordinate</p>
</td></tr>
<tr><td><code id="cube3D.tris_+3A_zmin">zmin</code></td>
<td>
<p>numeric, minimal z coordinate</p>
</td></tr>
<tr><td><code id="cube3D.tris_+3A_zmax">zmax</code></td>
<td>
<p>numeric, maximal z coordinate</p>
</td></tr>
<tr><td><code id="cube3D.tris_+3A_center">center</code></td>
<td>
<p>numeric vector of length 3 or NULL, coordinates where to center a cube with the edge length defined in parameter 'edge_length'. If this is not 'NULL', the parameters 'xmin', 'xmax', ... will be ignored, and their values will be computed for a cube based on the 'center' and 'edge_length'. Note that you can only create cubes using 'center' and 'edge_length', while the min/max methods allows the construction of cuboids.</p>
</td></tr>
<tr><td><code id="cube3D.tris_+3A_edge_length">edge_length</code></td>
<td>
<p>numeric, the edge length of the cube. Only used if parameter 'center' is used, ignored otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical matrix with 36 rows and 3 columns, the 3D coordinates. Each row encodes a point (the x, y, and z coordinates), and 3 consecutive rows encode a triangle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # Create a cube with edge length 2, centered at (3,4,5):
   cube_coords = cube3D.tris(center=c(3,4,5), edge_length=2.0);
   # Create the same cube using the min/max method:
   cube_coords = cube3D.tris(xmin=2, xmax=4, ymin=3, ymax=5, zmin=4, zmax=6);
   # Create a cuboid:
   cuboid_coords = cube3D.tris(xmin=2, xmax=4, ymin=3, ymax=9, zmin=4, zmax=5);
   # To render the cuboid:
   #rgl::triangles3d(cuboid_coords, col="red");

</code></pre>

<hr>
<h2 id='cubes3D.tris'>Vectorized version of cube3D.tris</h2><span id='topic+cubes3D.tris'></span>

<h3>Description</h3>

<p>Vectorized version of cube3D.tris
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubes3D.tris(centers, edge_length = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cubes3D.tris_+3A_centers">centers</code></td>
<td>
<p>numerical matrix with 3 columns. Each column represents the x, y, z coordinates of a center at which to create a cube.</p>
</td></tr>
<tr><td><code id="cubes3D.tris_+3A_edge_length">edge_length</code></td>
<td>
<p>numerical vector or scalar, the edge length. Must have length 1 (same edge length for all cubes), or the length must be identical to the number of rows in parameter 'centers'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of triangle coordinates, see <code><a href="#topic+cube3D.tris">cube3D.tris</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # Plot a 3D cloud of 20000 voxels:
   centers = matrix(rnorm(20000*3)*100, ncol=3);
   rgl::triangles3d(cubes3D.tris(centers));

</code></pre>

<hr>
<h2 id='deepcopylist.long'>Write deepcopy list for longitudinal subjects.</h2><span id='topic+deepcopylist.long'></span>

<h3>Description</h3>

<p>Write deepcopy list for longitudinal subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deepcopylist.long(
  measures = c("thickness", "area", "volume"),
  fwhms = c("5", "10", "15"),
  hemis = c("lh", "rh"),
  long_measures = c("avg", "rate", "spc", "pc1"),
  template = "fsaverage",
  has_stacked_file = TRUE,
  output_file = NULL
)
</code></pre>


<h3>Value</h3>

<p>vector of character strings, the file entries. Set ouput_file to also write them to a file.
</p>

<hr>
<h2 id='deg2rad'>Convert degree to radians</h2><span id='topic+deg2rad'></span>

<h3>Description</h3>

<p>Convert degree to radians
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg2rad(deg)
</code></pre>

<hr>
<h2 id='delete_all_optional_data'>Delete all data in the package cache.</h2><span id='topic+delete_all_optional_data'></span>

<h3>Description</h3>

<p>Delete all data in the package cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_all_optional_data()
</code></pre>


<h3>Value</h3>

<p>integer. The return value of the unlink() call: 0 for success, 1 for failure. See the unlink() documentation for details.
</p>

<hr>
<h2 id='demo'>Show demo visualization to test whether fsbrain is setup correctly.</h2><span id='topic+demo'></span>

<h3>Description</h3>

<p>Show demo visualization to test whether fsbrain is setup correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo()
</code></pre>


<h3>Note</h3>

<p>This function will try to download optional data from the internet (unless the data have already been downloaded).
</p>

<hr>
<h2 id='demographics.to.fsgd.file'>Write FreeSurfer Group Descriptor (FSGD) file from demographics dataframe.</h2><span id='topic+demographics.to.fsgd.file'></span>

<h3>Description</h3>

<p>Write FreeSurfer Group Descriptor (FSGD) file from demographics dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demographics.to.fsgd.file(
  filepath,
  demographics_df,
  group_column_name = "group",
  subject_id_column_name = "id",
  var_columns = NULL,
  ftitle = "OSGM",
  fsgd_flag_lines = c("DeMeanFlag 1", "ReScaleFlag 1")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="demographics.to.fsgd.file_+3A_filepath">filepath</code></td>
<td>
<p>character string, the path to the output file in FSGD format</p>
</td></tr>
<tr><td><code id="demographics.to.fsgd.file_+3A_demographics_df">demographics_df</code></td>
<td>
<p>data.frame, as returned by <code>read.md.demographics</code> or created manually. Note that the data.frame must not contain any character columns, they should be converted to factors.</p>
</td></tr>
<tr><td><code id="demographics.to.fsgd.file_+3A_group_column_name">group_column_name</code></td>
<td>
<p>character string, the column name of the group column in the 'demographics_df'</p>
</td></tr>
<tr><td><code id="demographics.to.fsgd.file_+3A_subject_id_column_name">subject_id_column_name</code></td>
<td>
<p>character string, the column name of the subject identifier column in the 'demographics_df'</p>
</td></tr>
<tr><td><code id="demographics.to.fsgd.file_+3A_var_columns">var_columns</code></td>
<td>
<p>vector of character strings, the column names to include as variables in the FSGD file. If NULL (the default), all columns will be included (with the exception of the group column and the subject id column).</p>
</td></tr>
<tr><td><code id="demographics.to.fsgd.file_+3A_ftitle">ftitle</code></td>
<td>
<p>character string, freeform title for the FSGD file</p>
</td></tr>
<tr><td><code id="demographics.to.fsgd.file_+3A_fsgd_flag_lines">fsgd_flag_lines</code></td>
<td>
<p>vector of character strings, extra flag lines to write to the file. The default setting will activate de-meaning and rescaling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of character strings, the lines written to the 'filepath', invisible.
</p>


<h3>See Also</h3>

<p>Other metadata functions: 
<code><a href="#topic+read.md.demographics">read.md.demographics</a>()</code>,
<code><a href="#topic+read.md.subjects">read.md.subjects</a>()</code>,
<code><a href="#topic+report.on.demographics">report.on.demographics</a>()</code>
</p>

<hr>
<h2 id='demographics.to.qdec.table.dat'>Convert a dataframe containing demographics data to a qdec.table.dat file and related files.</h2><span id='topic+demographics.to.qdec.table.dat'></span>

<h3>Description</h3>

<p>This creates the 'qdec.table.dat' and all required related files (the factor level files) in a directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demographics.to.qdec.table.dat(
  df,
  output_path = ".",
  long = FALSE,
  add_fake_level2 = FALSE,
  long_timecolumn = "years",
  qdec_file_name = "qdec.table.dat"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="demographics.to.qdec.table.dat_+3A_df">df</code></td>
<td>
<p>a data.frame containing demographics information. Make sure to have factors encoded as factors (not strings), so that the QDEC level files get created for them. Must contain a column named 'fsid' with the subject IDs as first column. If you want a long table, make sure to use <code><a href="#topic+qdec.table.skeleton">qdec.table.skeleton</a></code> to generate the timepoint information instead of doing it manually.</p>
</td></tr>
<tr><td><code id="demographics.to.qdec.table.dat_+3A_output_path">output_path</code></td>
<td>
<p>character string, existing directory into which to write the QDEC files. If the last directory level does not exist, it will be created.</p>
</td></tr>
<tr><td><code id="demographics.to.qdec.table.dat_+3A_long">long</code></td>
<td>
<p>logical, whether this is for a longitudinal run. If so, the df must contain a column named 'fsid-base' as the second column. It must also contain some column that gives the inter-scan time (from this scan timepoint to the previous one). The time unit (years, days, ...) is up to you, but typically one is interested in yearly change, the unit should be years. The name of the column (e.g., 'years') must be given to 'mris_slopes' later on the command line with the <code>--time &lt;column_name&gt;</code> argument. The requires information can be generated conveniently with the <code><a href="#topic+qdec.table.skeleton">qdec.table.skeleton</a></code> function.</p>
</td></tr>
<tr><td><code id="demographics.to.qdec.table.dat_+3A_add_fake_level2">add_fake_level2</code></td>
<td>
<p>logical, whether to add a 2nd fake level to the level files of factors with only a single level. Such factors make little sense, but QDEC refuses to open the resulting files at all in such a case, which seems a bit overkill. If TRUE, a 2nd level named 'level2' will be added so that one can open the output in QDEC.</p>
</td></tr>
<tr><td><code id="demographics.to.qdec.table.dat_+3A_long_timecolumn">long_timecolumn</code></td>
<td>
<p>character string, the name of the column holding the inter-scan time. Ignored unless parameter <code>long</code> is <code>TRUE</code>. See the description for parameter <code>long</code> for details.</p>
</td></tr>
<tr><td><code id="demographics.to.qdec.table.dat_+3A_qdec_file_name">qdec_file_name</code></td>
<td>
<p>character string, the filename of the QDEC file to write. Must be only the file name (with extension if you want). See <code>output_path</code> to set the ouput directory where this will be created.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>IMPORTANT: If you import the dataframe from a text file with functions like <code>read.table</code>, they will by default replace dashes in column names with dots. So if you have a column named <code>fsid-base</code> in there, after loading it will be named <code>fsid.base</code>. See the <code>check.names</code> parameter for <code>read.table</code> to prevent that.
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+qdec.table.skeleton">qdec.table.skeleton</a></code> to generate the data.frame used as the 'df' argument for this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   dem = readxl::read_xls("~/data/study1/demographics.xsl");
   # or: dem = read.table("~/demographics.csv", check.names=FALSE);
   # You may want to rearrange/rename/delete some columns here.
   demographics.to.qdec.table.dat(dem, "~/data/study1/qdec/");
   #
   # a second one with real data:
   dem = data.frame("ID"=paste("subject", seq(5), sep=""),
      "age"=sample.int(20, 5)+10L, "isi"=rnorm(5, 2.0, 0.1)); #sample data.
   long_table = qdec.table.skeleton(dem$ID, dem$isi);
   demographics.to.qdec.table.dat(long_table, long=TRUE);

## End(Not run)
</code></pre>

<hr>
<h2 id='desaturate'>Perform simple desaturation or grayscale conversion of RGBA colors.</h2><span id='topic+desaturate'></span>

<h3>Description</h3>

<p>Perform simple desaturation or grayscale conversion of RGBA colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desaturate(color, gamma_correct = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="desaturate_+3A_color">color</code></td>
<td>
<p>rgba color strings</p>
</td></tr>
<tr><td><code id="desaturate_+3A_gamma_correct">gamma_correct</code></td>
<td>
<p>logical, whether to apply non-linear gamma correction. First performs gamma expansion, then applies the gray-scale channel weigths, then gamma compression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rgba color strings, the grayscale colors. The information from one of the three rgb channels would be enough. The alpha value is not touched.
</p>


<h3>Note</h3>

<p>Assumes sRGB color space.
</p>


<h3>References</h3>

<p>see https://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
</p>


<h3>See Also</h3>

<p>Other color functions: 
<code><a href="#topic+alphablend">alphablend</a>()</code>
</p>

<hr>
<h2 id='download_fsaverage'>Download the FreeSurfer v6 fsaverage subject.</h2><span id='topic+download_fsaverage'></span>

<h3>Description</h3>

<p>Download some relevant files from the FreeSurfer v6 fsaverage subject. The files are subject to the FreeSurfer software license, see parameter 'accept_freesurfer_license' for details. This data is not required for the package to work. If you are working on a machine that has FreeSurfer installed, you already have this data anyways and do not need to download it. If not, it is very convenient to have it if you are using the fsaverage template subject to analyze your standard space data, as it is required for visualization of such data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_fsaverage(accept_freesurfer_license = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="download_fsaverage_+3A_accept_freesurfer_license">accept_freesurfer_license</code></td>
<td>
<p>logical, whether you accept the FreeSurfer license for fsaverage, available at https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list. The list has entries: &quot;available&quot;: vector of strings. The names of the files that are available in the local file cache. You can access them using get_optional_data_file(). &quot;missing&quot;: vector of strings. The names of the files that this function was unable to retrieve.
</p>

<hr>
<h2 id='download_fsaverage3'>Download the FreeSurfer v6 low-resolution fsaverage3 subject.</h2><span id='topic+download_fsaverage3'></span>

<h3>Description</h3>

<p>Download some relevant files from the FreeSurfer v6 fsaverage3 subject. The files are subject to the FreeSurfer software license, see parameter 'accept_freesurfer_license' for details. This data is not required for the package to work. If you are working on a machine that has FreeSurfer installed, you already have this data anyways and do not need to download it. Also downloads data for subject1 that has been mapped to fsaverage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_fsaverage3(accept_freesurfer_license = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="download_fsaverage3_+3A_accept_freesurfer_license">accept_freesurfer_license</code></td>
<td>
<p>logical, whether you accept the FreeSurfer license for fsaverage, available at https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list. The list has entries: &quot;available&quot;: vector of strings. The names of the files that are available in the local file cache. You can access them using get_optional_data_file(). &quot;missing&quot;: vector of strings. The names of the files that this function was unable to retrieve.
</p>


<h3>Note</h3>

<p>The subject fsaverage3 is a downsampled (low mesh resolution) version of the standard fsaverage. If you never heard about fsaverage3, you do not need it. You will have to manually re-sample your data in FreeSurfer if you want to use it with fsaverage3.
</p>

<hr>
<h2 id='download_optional_data'>Download optional data for this package if required.</h2><span id='topic+download_optional_data'></span>

<h3>Description</h3>

<p>Ensure that the optioanl data is available locally in the package cache. Will try to download the data only if it is not available. This data is not required for the package to work, but it is used in the examples, in the unit tests and also in the example code from the vignette. Downloading it is highly recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_optional_data()
</code></pre>


<h3>Value</h3>

<p>Named list. The list has entries: &quot;available&quot;: vector of strings. The names of the files that are available in the local file cache. You can access them using get_optional_data_file(). &quot;missing&quot;: vector of strings. The names of the files that this function was unable to retrieve.
</p>

<hr>
<h2 id='download_optional_paper_data'>Download extra data to reproduce the figures from the fsbrain paper.</h2><span id='topic+download_optional_paper_data'></span>

<h3>Description</h3>

<p>Download extra data to reproduce the figures from the fsbrain paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_optional_paper_data()
</code></pre>


<h3>Value</h3>

<p>Named list. The list has entries: &quot;available&quot;: vector of strings. The names of the files that are available in the local file cache. You can access them using get_optional_data_file(). &quot;missing&quot;: vector of strings. The names of the files that this function was unable to retrieve.
</p>


<h3>Note</h3>

<p>Called for side effect of data download.
</p>

<hr>
<h2 id='draw.colorbar'>Draw colorbar into background of current plot.</h2><span id='topic+draw.colorbar'></span>

<h3>Description</h3>

<p>Requires a rgl 3d visualisation to be open that already contains a rendered object. Uses <code>bgplot3d</code> to add a colorbar in the background of the plot using <code><a href="fields.html#topic+image.plot">image.plot</a></code>. Experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.colorbar(coloredmeshes, horizontal = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw.colorbar_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>fs.coloredmesh as returned by the coloredmesh.from.* functions.</p>
</td></tr>
<tr><td><code id="draw.colorbar_+3A_horizontal">horizontal</code></td>
<td>
<p>logical, whether the colorbar should be drawn in horizontal orientation. Defaults to 'TRUE'.</p>
</td></tr>
<tr><td><code id="draw.colorbar_+3A_...">...</code></td>
<td>
<p>extra params passed to <code><a href="fields.html#topic+image.plot">image.plot</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>To adapt or change the colormap, you should use the 'makecmap_options' parameter of the vis.* function used to construct the coloredmeshes (e.g., <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>).
</p>

<hr>
<h2 id='eeg_coords'>Internal function to get some demo EEG electrode coordinates. Will be removed from public API. Do not use this.</h2><span id='topic+eeg_coords'></span>

<h3>Description</h3>

<p>Internal function to get some demo EEG electrode coordinates. Will be removed from public API. Do not use this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eeg_coords(label_subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eeg_coords_+3A_label_subset">label_subset</code></td>
<td>
<p>vector of character strings, electrode names like 'Nz' or 'RPA'. ÖLeave at the default value 'NULL' to get all available ones.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with one row per electrode, and the following 3 columns: 'label': the electrode name, 'theta': the azimuth in degrees, 'phi': the latitude in degrees.
</p>


<h3>Note</h3>

<p>There are lots of different naming conventions for spherical coordinates, see https://en.wikipedia.org/wiki/Spherical_coordinate_system.
</p>


<h3>References</h3>

<p>See http://wiki.besa.de/index.php?title=Electrodes_and_Surface_Locations
</p>

<hr>
<h2 id='ensure.fs.surface'>Check whether parameter is an fs.surface instance.</h2><span id='topic+ensure.fs.surface'></span>

<h3>Description</h3>

<p>Check whether parameter is an fs.surface instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensure.fs.surface(surface)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensure.fs.surface_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance which will be returned as-is, a tmesh3d which will be converted to a surface using <code><a href="#topic+tmesh3d.to.fs.surface">tmesh3d.to.fs.surface</a></code>, or a character string which will be interpreted as a file system path and loaded with <code>freesurferformats::read.fs.surface</code>. Anything else will stop with an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an fs.surface instance, unless an error occurs.
</p>

<hr>
<h2 id='ensure.tmesh3d'>Ensure the mesh is a tmesh3d instance. Will convert fs.surfaces to one automatically.</h2><span id='topic+ensure.tmesh3d'></span>

<h3>Description</h3>

<p>Ensure the mesh is a tmesh3d instance. Will convert fs.surfaces to one automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensure.tmesh3d(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensure.tmesh3d_+3A_mesh">mesh</code></td>
<td>
<p>whatever, but hopefully an <code>rgl::tmesh3d</code> or <code>freesurferformats::fs.surface</code> instance. Can be a character string, which will be loaded as a surface file if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tmesh3d instance, the input or converted from the input.
</p>


<h3>Note</h3>

<p>This function will stop if the mesh cannot be converted to tmesh3d.
</p>

<hr>
<h2 id='export'>Export high-quality brainview image with a colorbar.</h2><span id='topic+export'></span>

<h3>Description</h3>

<p>This function serves as an easy (but slightly inflexible) way to export a high-quality, tight-layout, colorbar figure to disk. If no colorbar is required, one can use <code>vislayout.from.coloredmeshes</code> instead. It is an alias for 'vis.export.from.coloredmeshes' that requires less typing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export(
  coloredmeshes,
  colorbar_legend = NULL,
  img_only = TRUE,
  draw_colorbar = "horizontal",
  horizontal = NULL,
  silent = TRUE,
  quality = 1L,
  output_img = "fsbrain_arranged.png",
  image.plot_extra_options = NULL,
  large_legend = TRUE,
  view_angles = get.view.angle.names(angle_set = "t4"),
  style = "default",
  grid_like = TRUE,
  background_color = "white",
  transparency_color = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of coloredmesh. A coloredmesh is a named list as returned by the 'coloredmesh.from*' functions (like <code><a href="#topic+coloredmesh.from.morph.native">coloredmesh.from.morph.native</a></code>). It has the entries 'mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh. The 'vis*' functions (like <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>) all return a list of coloredmeshes.</p>
</td></tr>
<tr><td><code id="export_+3A_colorbar_legend">colorbar_legend</code></td>
<td>
<p>character string or NULL, the title for the colorbar.</p>
</td></tr>
<tr><td><code id="export_+3A_img_only">img_only</code></td>
<td>
<p>logical, whether to return only the resulting image</p>
</td></tr>
<tr><td><code id="export_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical or one of the character strings 'vertical' or 'horizontal', whether to draw a colorbar. Defaults to 'horizontal'.</p>
</td></tr>
<tr><td><code id="export_+3A_horizontal">horizontal</code></td>
<td>
<p>deprecated (since 0.5.0) and ignored, use parameter 'draw_colorbar' instead.</p>
</td></tr>
<tr><td><code id="export_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress messages</p>
</td></tr>
<tr><td><code id="export_+3A_quality">quality</code></td>
<td>
<p>integer, an arbitrary quality. This is the resolution per tile before trimming, divided by 1000, in pixels. Example: 1L means 1000x1000 pixels per tile before trimming. Currently supported values: <code>1L..2L</code>. Note that the resolution you can get is also limited by your screen resolution.</p>
</td></tr>
<tr><td><code id="export_+3A_output_img">output_img</code></td>
<td>
<p>string, path to the output file. Defaults to &quot;fsbrain_arranged.png&quot;</p>
</td></tr>
<tr><td><code id="export_+3A_image.plot_extra_options">image.plot_extra_options</code></td>
<td>
<p>named list, custom options for fields::image.plot. Overwrites those derived from the quality setting. If in doubt, leave this alone.</p>
</td></tr>
<tr><td><code id="export_+3A_large_legend">large_legend</code></td>
<td>
<p>logical, whether to plot extra large legend text, affects the font size of the colorbar_legend and the tick labels.</p>
</td></tr>
<tr><td><code id="export_+3A_view_angles">view_angles</code></td>
<td>
<p>list of strings. See <code><a href="#topic+get.view.angle.names">get.view.angle.names</a></code> for all valid strings.</p>
</td></tr>
<tr><td><code id="export_+3A_style">style</code></td>
<td>
<p>the rendering style, see <code>material3d</code> or use a predefined style like 'default' or 'shiny'.</p>
</td></tr>
<tr><td><code id="export_+3A_grid_like">grid_like</code></td>
<td>
<p>logical, passed to <code>vislayout.from.coloredmeshes</code>.</p>
</td></tr>
<tr><td><code id="export_+3A_background_color">background_color</code></td>
<td>
<p>hex color string (like '#FFFFFF'), the color to use for the background. Ignored if 'transparency_color' is not NULL. To get a transparent background, use 'transparency_color' instead of this parameter. WARNING: Do not use color names (like 'gray'), as their interpretation differs between rgl and image magick!</p>
</td></tr>
<tr><td><code id="export_+3A_transparency_color">transparency_color</code></td>
<td>
<p>hex color string (like '#FFFFFF'), the temporary background color that will get mapped to transparency, or NULL if you do not want a transparent background. If used, it can be any color that does not occur in the foreground. Try '#FFFFFF' (white) or '#000000' (black) if in doubt. WARNING: Do not use color names (like 'gray'), as their interpretation differs between rgl and image magick!</p>
</td></tr>
<tr><td><code id="export_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code>vislayout.from.coloredmeshes</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>magick image instance or named list, depending on the value of 'img_only'. If the latter, the list contains the fields 'rev_vl', 'rev_cb', and 'rev_ex', which are the return values of the functions <code>vislayout.from.coloredmeshes</code>, <code>coloredmesh.plot.colorbar.separate</code>, and <code>combine.colorbar.with.brainview.image</code>, respectively.
</p>


<h3>Note</h3>

<p>Note that your screen resolution has to be high enough to generate the final image in the requested resolution, see the 'fsbrain FAQ' vignette for details and solutions if you run into trouble.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    rand_data = rnorm(327684, 5, 1.5);
    cm = vis.data.on.fsaverage(morph_data_both=rand_data,
      rglactions=list('no_vis'=T));
    export(cm, colorbar_legend='Random data',
      output_img="~/fsbrain_arranged.png");

## End(Not run)

</code></pre>

<hr>
<h2 id='export.coloredmesh.ply'>Export a coloredmeshes with vertexcolors in PLY format.</h2><span id='topic+export.coloredmesh.ply'></span>

<h3>Description</h3>

<p>Exports coloredmeshes with vertex coloring to standard mesh files in Stanford Triangle (PLY) format. This is very hand for rendering in external standard 3D modeling software like Blender.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export.coloredmesh.ply(filepath, coloredmesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export.coloredmesh.ply_+3A_filepath">filepath</code></td>
<td>
<p>The export filepath, including file name and extension.</p>
</td></tr>
<tr><td><code id="export.coloredmesh.ply_+3A_coloredmesh">coloredmesh</code></td>
<td>
<p>an 'fs.coloredmesh' instance, as returned (silently) by all surface visualization functions, like <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   coloredmeshes = vis.subject.morph.native(subjects_dir, 'subject1', 'thickness');
   export.coloredmesh.ply('~/subject1_thickness_lh.ply', coloredmeshed$lh);

## End(Not run)

</code></pre>

<hr>
<h2 id='extend_neighbors'>Recursive computation of neighborhoods, see surf.sphere.dist</h2><span id='topic+extend_neighbors'></span>

<h3>Description</h3>

<p>Compute neighborhood of the current vertex (=target vertex). The computation follows the mesh edges while there are still vertices which fullfil the dotproduct distance threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend_neighbors(
  spherical_surface,
  targetvidx,
  currentvidx,
  min_dotp_thresh,
  ref_visited,
  ref_neighbors,
  ref_neighbor_dpdists
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extend_neighbors_+3A_spherical_surface">spherical_surface</code></td>
<td>
<p>an fs.surface instance representing the spherical version (<code>lh.sphere</code> or <code>rh.sphere</code> of the subject).</p>
</td></tr>
<tr><td><code id="extend_neighbors_+3A_targetvidx">targetvidx</code></td>
<td>
<p>positive integer, initial target vertex. The vertex for which to compute the neighborhood.</p>
</td></tr>
<tr><td><code id="extend_neighbors_+3A_currentvidx">currentvidx</code></td>
<td>
<p>positive integer, initial current vertex. Pass identical value as in targetvidx, this is changed later in the recursion.</p>
</td></tr>
<tr><td><code id="extend_neighbors_+3A_min_dotp_thresh">min_dotp_thresh</code></td>
<td>
<p>double, the minimal dotproduct distance threshold to use. Only vertices along the structural mesh neighborhood with values greater this will be included in the neighborhood. Yes, greater.</p>
</td></tr>
<tr><td><code id="extend_neighbors_+3A_ref_visited">ref_visited</code></td>
<td>
<p>pass-by-reference (via RefClasses) integer vector of length <code>num_mesh_vertices</code>: whether the respective vertex has been visited already.</p>
</td></tr>
<tr><td><code id="extend_neighbors_+3A_ref_neighbors">ref_neighbors</code></td>
<td>
<p>pass-by-reference (via RefClasses) integer vector of length <code>num_mesh_vertices</code>: whether the respective vertex is part of the current neighborhood.</p>
</td></tr>
<tr><td><code id="extend_neighbors_+3A_ref_neighbor_dpdists">ref_neighbor_dpdists</code></td>
<td>
<p>pass-by-reference (via RefClasses) double vector of length <code>num_mesh_vertices</code>: the dotproduct distance to the respective vertex (if it is part of the neighborhood).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, invisible. Either <code>0L</code> or <code>1L</code>. Used in the recursion only, ignore. The return values of interest are in the 3 <code>ref_*</code> parameters.
</p>

<hr>
<h2 id='extract.volume.3D'>Try to extract a 3D volume from the input argument.</h2><span id='topic+extract.volume.3D'></span>

<h3>Description</h3>

<p>Check whether it already is such an array, whether it is a filename that can be loaded with <code>freesurferformats::read.fs.volume</code> into such an array, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.volume.3D(stats, silent = getOption("fsbrain.silent", default = FALSE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract.volume.3D_+3A_stats">stats</code></td>
<td>
<p>a 3D array, 4D array or a string that can be treated as a filename to a volume image containing such an array.</p>
</td></tr>
<tr><td><code id="extract.volume.3D_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress file reading messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the obtained 3D array
</p>


<h3>Note</h3>

<p>This function stops with an error if the input cannot be returned as a 3D array.
</p>

<hr>
<h2 id='face.edges'>Enumerate all edges of the given faces or mesh.</h2><span id='topic+face.edges'></span>

<h3>Description</h3>

<p>Compute edges of a tri-mesh. Can compute all edges, or only a subset, given by the face indices in the mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>face.edges(surface_mesh, face_indices = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="face.edges_+3A_surface_mesh">surface_mesh</code></td>
<td>
<p>surface mesh, as loaded by <code><a href="#topic+subject.surface">subject.surface</a></code> or <code><a href="freesurferformats.html#topic+read.fs.surface">read.fs.surface</a></code>.</p>
</td></tr>
<tr><td><code id="face.edges_+3A_face_indices">face_indices</code></td>
<td>
<p>integer vector, the face indices. Can also be the character string 'all' to use all faces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer matrix of size (n, 2) where n is the number of edges. The indices (source and target vertex) in each row are **not** sorted, and the edges are **not** unique. I.e., each undirected edge 'u, v' (with the exception of edges on the mesh border) will occur twice in the result: once as 'u, v' and once as 'v, u'.
</p>


<h3>See Also</h3>

<p>Other surface mesh functions: 
<code><a href="#topic+label.border">label.border</a>()</code>,
<code><a href="#topic+mesh.vertex.included.faces">mesh.vertex.included.faces</a>()</code>,
<code><a href="#topic+mesh.vertex.neighbors">mesh.vertex.neighbors</a>()</code>,
<code><a href="#topic+subject.surface">subject.surface</a>()</code>,
<code><a href="#topic+vis.path.along.verts">vis.path.along.verts</a>()</code>
</p>

<hr>
<h2 id='find.freesurferhome'>Find the FREESURFER_HOME directory on disk.</h2><span id='topic+find.freesurferhome'></span>

<h3>Description</h3>

<p>Try to find directory containing the FreeSurfer installation, based on environment variables and *educated guessing*.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.freesurferhome(mustWork = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.freesurferhome_+3A_mustwork">mustWork</code></td>
<td>
<p>logical. Whether the function should with an error stop if the directory cannot be found. If this is TRUE, the return value will be only the 'found_at' entry of the list (i.e., only the path of the FreeSurfer installation dir).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with the following entries: &quot;found&quot;: logical, whether it was found. &quot;found_at&quot;: Only set if found=TRUE, the path to the FreeSurfer installation directory (including the directory itself). See 'mustWork' for important information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fs.home">fs.home</a></code>
</p>

<hr>
<h2 id='find.subjectsdir.of'>Find the subject directory containing the fsaverage subject (or others) on disk.</h2><span id='topic+find.subjectsdir.of'></span>

<h3>Description</h3>

<p>Try to find directory containing the fsaverage subject (or any other subject) by checking in the following places and returning the first path where it is found: first, the directory given by the environment variable SUBJECTS_DIR, then in the subir 'subjects' of the directory given by the environment variable FREESURFER_HOME, and finally the base dir of the package cache. See the function <code><a href="#topic+download_fsaverage">download_fsaverage</a></code> if you want to download fsaverage to your package cache and ensure it always gets found, no matter whether the environment variables are set or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.subjectsdir.of(subject_id = "fsaverage", mustWork = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.subjectsdir.of_+3A_subject_id">subject_id</code></td>
<td>
<p>string, the subject id of the subject. Defaults to 'fsaverage'.</p>
</td></tr>
<tr><td><code id="find.subjectsdir.of_+3A_mustwork">mustWork</code></td>
<td>
<p>logical. Whether the function should with an error stop if the directory cannot be found. If this is TRUE, the return value will be only the 'found_at' entry of the list (i.e., only the path of the subjects dir).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with the following entries: &quot;found&quot;: logical, whether it was found. &quot;found_at&quot;: Only set if found=TRUE, the path to the fsaverage directory (NOT including the fsaverage dir itself). &quot;found_all_locations&quot;: list of all locations in which it was found. See 'mustWork' for important information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fsaverage.path">fsaverage.path</a></code>
</p>

<hr>
<h2 id='flc'>Given a list of path coordinates, create matrix containing only the first and last point of each path.</h2><span id='topic+flc'></span>

<h3>Description</h3>

<p>Given a list of path coordinates, create matrix containing only the first and last point of each path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flc(coords_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flc_+3A_coords_list">coords_list</code></td>
<td>
<p>list of <code>m</code> matrices, each <code>n</code> x 3 matrix must contain the 3D coords for one path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>m x 6 numeric matrix, containing the first and last point of a path per row (two 3D xyz-coords, so 6 values per row).
</p>

<hr>
<h2 id='force.to.range'>Change data to ensure requested data_range.</h2><span id='topic+force.to.range'></span>

<h3>Description</h3>

<p>Change data to ensure requested data_range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force.to.range(x, data_range, allow_append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="force.to.range_+3A_x">x</code></td>
<td>
<p>numerical vector, the input data.</p>
</td></tr>
<tr><td><code id="force.to.range_+3A_data_range">data_range</code></td>
<td>
<p>numerical vector of length 2, the range into which to force the data values in 'x'. If &lsquo;NULL', the input data in &rsquo;x' is returned as is.</p>
</td></tr>
<tr><td><code id="force.to.range_+3A_allow_append">allow_append</code></td>
<td>
<p>logical, whether to allow adding of more extreme data values. Allows a range larger than the data range. If set to 'TRUE', you will have to remove the extra values from the colors after generation of the colormap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified version of x. The data will be clamped and / or at most 2 values may be appended to x.
</p>


<h3>Note</h3>

<p>This is an artificial modification of the data used for plotting a colormap with a fixed range.
</p>

<hr>
<h2 id='fs.coloredmesh'>fs.coloredmesh constructor</h2><span id='topic+fs.coloredmesh'></span>

<h3>Description</h3>

<p>fs.coloredmesh constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.coloredmesh(
  mesh,
  col,
  hemi,
  render = TRUE,
  metadata = NULL,
  add_normals = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fs.coloredmesh_+3A_mesh">mesh</code></td>
<td>
<p>a 'mesh3d' instance as returned by <code>tmesh3d</code> or an 'fs.surface' brain surface mesh as returned by functions like <code><a href="#topic+subject.surface">subject.surface</a></code>.</p>
</td></tr>
<tr><td><code id="fs.coloredmesh_+3A_col">col</code></td>
<td>
<p>vector of vertex colors for the mesh, one color per vertex. Expanded if exactly one color.</p>
</td></tr>
<tr><td><code id="fs.coloredmesh_+3A_hemi">hemi</code></td>
<td>
<p>character string, one of 'lh' or 'rh'. This may be used by visualization functions to decide whether or not to show this mesh in a certain view.</p>
</td></tr>
<tr><td><code id="fs.coloredmesh_+3A_render">render</code></td>
<td>
<p>logical, whether to render this mesh during visualization</p>
</td></tr>
<tr><td><code id="fs.coloredmesh_+3A_metadata">metadata</code></td>
<td>
<p>optional, named list containing metadata</p>
</td></tr>
<tr><td><code id="fs.coloredmesh_+3A_add_normals">add_normals</code></td>
<td>
<p>logical, whether to compute normals and save them in the mesh.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an &lsquo;fs.coloredmesh' instance. The only fields one should use in client code are &rsquo;mesh', 'hemi' and 'col', all others are considered internal and may change without notice.
</p>

<hr>
<h2 id='fs.home'>Return FreeSurfer path.</h2><span id='topic+fs.home'></span>

<h3>Description</h3>

<p>Return FreeSurfer path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.home()
</code></pre>


<h3>Value</h3>

<p>the FreeSurfer path, typically what the environment variable 'FREESURFER_HOME' points to.
</p>


<h3>Note</h3>

<p>This function will stop (i.e., raise an error) if the directory cannot be found.
</p>

<hr>
<h2 id='fs.surface.as.adjacencylist'>Turn surface mesh into a igraph and return its adjacency list representation.</h2><span id='topic+fs.surface.as.adjacencylist'></span>

<h3>Description</h3>

<p>Turn surface mesh into a igraph and return its adjacency list representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.surface.as.adjacencylist(surface)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fs.surface.as.adjacencylist_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance as returned by <code>subject.surface</code>, an existing igraph (which will be returned as-is) or a string which is interpreted as a path to a surface file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of integer vectors, the adjacency list.
</p>

<hr>
<h2 id='fs.surface.to.igraph'>Create igraph undirected graph from a brain surface mesh.</h2><span id='topic+fs.surface.to.igraph'></span>

<h3>Description</h3>

<p>Create igraph undirected graph from a brain surface mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.surface.to.igraph(surface)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fs.surface.to.igraph_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance as returned by <code>subject.surface</code>, an existing igraph (which will be returned as-is) or a string which is interpreted as a path to a surface file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph::graph instance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Find the one-ring neighbors of vertex 15 on the fsaverage left hemi:
  sf = subject.surface(fsaverage.path(T), "fsaverage", "white", "lh");
  g = fs.surface.to.igraph(sf);
  igraph::neighborhood(g, order = 1, nodes = 15);

## End(Not run)

</code></pre>

<hr>
<h2 id='fs.surface.to.tmesh3d'>Get an rgl tmesh3d instance from a brain surface mesh.</h2><span id='topic+fs.surface.to.tmesh3d'></span>

<h3>Description</h3>

<p>Get an rgl tmesh3d instance from a brain surface mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.surface.to.tmesh3d(surface)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fs.surface.to.tmesh3d_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance, as returned by <code>subject.surface</code> or <code>freesurferformats::read.fs.surface</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tmesh3d instance, see <code>rgl::tmesh3d</code> for details.
</p>

<hr>
<h2 id='fs.surface.vertex.neighbors'>Compute vertex neighborhoods or the full adjacency list for a mesh using the Rvcg or igraph library.</h2><span id='topic+fs.surface.vertex.neighbors'></span>

<h3>Description</h3>

<p>This is a faster replacement for <code>mesh.vertex.neighbors</code> that requires the optional dependency package 'igraph' or 'Rvcg'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.surface.vertex.neighbors(
  surface,
  nodes = NULL,
  order = 1L,
  simplify = TRUE,
  include_self = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fs.surface.vertex.neighbors_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance as returned by <code>subject.surface</code>, an existing igraph (which will be returned as-is) or a string which is interpreted as a path to a surface file.</p>
</td></tr>
<tr><td><code id="fs.surface.vertex.neighbors_+3A_nodes">nodes</code></td>
<td>
<p>the source vertex. Passed on to <code>igraph::neighborhood</code>. Can be a vector, in which case the neighborhoods for all these vertices are computed separately. If NULL, all graph vertices are used.</p>
</td></tr>
<tr><td><code id="fs.surface.vertex.neighbors_+3A_order">order</code></td>
<td>
<p>integer, the max graph distance of vertices to consider neighbors (number of neighborhood rings). Passed on to <code>igraph::neighborhood</code></p>
</td></tr>
<tr><td><code id="fs.surface.vertex.neighbors_+3A_simplify">simplify</code></td>
<td>
<p>logical, whether to return only an integer vector if the 'nodes' parameter has length 1 (instead of a list where the first element is such a vector).</p>
</td></tr>
<tr><td><code id="fs.surface.vertex.neighbors_+3A_include_self">include_self</code></td>
<td>
<p>logical, whether to include vertices in their own neighborhood</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of integer vectors (see <code>igraph::neighborhood</code>), unless 'simplify' is TRUE, see there for details.
</p>


<h3>Note</h3>

<p>If you intend to call several functions on the igraph, it is faster to construct it with <code>fs.surface.to.igraph</code> and keep it.
</p>


<h3>See Also</h3>

<p>The <code>fs.surface.as.adjacencylist</code> function computes the 1-ring neighborhood for the whole graph.
</p>

<hr>
<h2 id='fs.value.list.from.agg.res'>Create a named value list from a dataframe.</h2><span id='topic+fs.value.list.from.agg.res'></span>

<h3>Description</h3>

<p>Given the result of the group.agg.atlas.native() function, extract a named region value list (typically for use with the spread.values.over.annot() function) for a single subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.value.list.from.agg.res(agg_res, subject_id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fs.value.list.from.agg.res_+3A_agg_res">agg_res</code></td>
<td>
<p>a dataframe. The result of calling group.agg.atlas.native().</p>
</td></tr>
<tr><td><code id="fs.value.list.from.agg.res_+3A_subject_id">subject_id</code></td>
<td>
<p>string. A subject identifier, must occur in the subject column of the dataframe agg_res.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>region_value_list, named list of strings. Each name must is a region name from the annotation, and the value is a scalar that resulting from aggregating the morphometry data for that region and subject.
</p>

<hr>
<h2 id='fsaverage.path'>Return path to fsaverage dir.</h2><span id='topic+fsaverage.path'></span>

<h3>Description</h3>

<p>Return path to fsaverage dir.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsaverage.path(allow_fetch = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fsaverage.path_+3A_allow_fetch">allow_fetch</code></td>
<td>
<p>logical, whether to allow trying to download it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the path to the fsaverage directory (NOT including the 'fsaverage' dir itself).
</p>


<h3>Note</h3>

<p>This function will stop (i.e., raise an error) if the directory cannot be found. The fsaverage template is part of FreeSurfer, and distributed under the FreeSurfer software license.
</p>

<hr>
<h2 id='fsbrain.renderable'>Check whether object can be rendered by fsbrain</h2><span id='topic+fsbrain.renderable'></span>

<h3>Description</h3>

<p>Check whether object can be rendered by fsbrain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsbrain.renderable(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fsbrain.renderable_+3A_x">x</code></td>
<td>
<p>any 'R' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if *x* is an instance of a class that can be rendered by fsbrain visualization functions, and FALSE otherwise. Currently, the following types are renderable: 'fs.coloredvoxels', 'fs.coloredmesh', 'Triangles3D'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.Triangles3D">is.Triangles3D</a></code>
</p>

<hr>
<h2 id='fsbrain.set.default.figsize'>Set default figure size for fsbrain visualization functions.</h2><span id='topic+fsbrain.set.default.figsize'></span>

<h3>Description</h3>

<p>Set default figure size for fsbrain visualization functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsbrain.set.default.figsize(width, height, xstart = 50L, ystart = 50L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fsbrain.set.default.figsize_+3A_width">width</code></td>
<td>
<p>integer, default figure width in pixels</p>
</td></tr>
<tr><td><code id="fsbrain.set.default.figsize_+3A_height">height</code></td>
<td>
<p>integer, default figure height in pixels</p>
</td></tr>
<tr><td><code id="fsbrain.set.default.figsize_+3A_xstart">xstart</code></td>
<td>
<p>integer, default horizontal position of plot window on screen, left border is 0. The max value (right border) depends on your screen resolution.</p>
</td></tr>
<tr><td><code id="fsbrain.set.default.figsize_+3A_ystart">ystart</code></td>
<td>
<p>integer, default vertical position of plot window on screen, upper border is 0. The max value (lower border) depends on your screen resolution.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function overwrites <code>options("fsbrain.rgloptions")</code>. Output size is limited by your screen resolution. To set your preferred figure size for future R sessions, you could call this function in your <code>'~/.Rprofile'</code> file.
</p>

<hr>
<h2 id='fslong.subjects.detect'>Get subject names from sub directories of FreeSurfer long directory.</h2><span id='topic+fslong.subjects.detect'></span>

<h3>Description</h3>

<p>Find all subject names for which the FreeSurfer longitudinal pipeline may have finished. These are the subjects that have the <code>_MR1</code> and <code>_MR2</code> directories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fslong.subjects.detect(subjects_dir, timepoint_names = c("_MR1", "_MR2"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fslong.subjects.detect_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>character string, path to a single recon-all longitudinal output dir from FreeSurfer.</p>
</td></tr>
</table>

<hr>
<h2 id='fslong.subjects.finished'>Find completely run FreeSurfer long subjects in a recon-all long output folder.</h2><span id='topic+fslong.subjects.finished'></span>

<h3>Description</h3>

<p>This finds all subjects for which the FreeSurfer long pipeline finished. It can work without a subjects file, by scanning the directory names to find all potential subjects. It checks only whether the expected folder for each subject exists. For a subject named 'subject1' and 2 timepoints, these folders are checked for existence: subject1, subject1_MR1, subject1_MR2, subject1_MR1.long.subject1, subject1_MR2.long.subject1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fslong.subjects.finished(
  subjects_dir,
  subjects_to_check = NULL,
  timepoints = seq.int(2)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fslong.subjects.finished_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>char, the recon-all long output directory</p>
</td></tr>
<tr><td><code id="fslong.subjects.finished_+3A_subjects_to_check">subjects_to_check</code></td>
<td>
<p>a vector of chars, the subject names (the cross-sectional names, without the '_MR1' or '_MR2' or 'long' suffixes). If NULL, the folder will be scanned for subjects, by looking for all '_MR1' folders and stripping the '_MR1' suffix.</p>
</td></tr>
<tr><td><code id="fslong.subjects.finished_+3A_timepoints">timepoints</code></td>
<td>
<p>vector of integers, the timepoints to check. E.g., <code>c(1,2)</code> or <code>seq.int(2)</code> if you want to check scan timepoints '_MR1' and 'MR2'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with entries 'subjects_okay' and 'subjects_missing_dirs'. Each of these two keys contains a vector of character strings, the respective subjects (a subset if 'subjects_to_check'). In 'subjects_okay' are all subjects for which the expected long directories were found, the rest is in 'subjects_missing_dirs'.
</p>

<hr>
<h2 id='fup'>Transform first character of a string to uppercase.</h2><span id='topic+fup'></span>

<h3>Description</h3>

<p>Transform first character of a string to uppercase. This is useful when labeling plots. Important: this function does not know about different encodings, languages or anything, it just calls <code><a href="base.html#topic+toupper">toupper</a></code> for the first character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fup(word)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fup_+3A_word">word</code></td>
<td>
<p>string. Any string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string, the input string with the first character transformed to uppercase.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   word_up = fup("word");

</code></pre>

<hr>
<h2 id='gen.test.volume'>Generate test 3D volume of integers. The volume has an outer background area (intensity value 'bg') and an inner foreground areas (intensity value 200L).</h2><span id='topic+gen.test.volume'></span>

<h3>Description</h3>

<p>Generate test 3D volume of integers. The volume has an outer background area (intensity value 'bg') and an inner foreground areas (intensity value 200L).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.test.volume(vdim = c(256L, 256L, 256L), bg = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.test.volume_+3A_vdim">vdim</code></td>
<td>
<p>integer vector of length 3, the dimensions</p>
</td></tr>
<tr><td><code id="gen.test.volume_+3A_bg">bg</code></td>
<td>
<p>value to use for outer background voxels. Typically '0L' or 'NA'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3d array of integers
</p>


<h3>Note</h3>

<p>This function exists for software testing purposes only, you should not use it in client code.
</p>

<hr>
<h2 id='geod.patches.color.overlay'>Generate color overlay from geodesic patches around several vertices.</h2><span id='topic+geod.patches.color.overlay'></span>

<h3>Description</h3>

<p>Works across hemispheres (for a whole brain) if you pass a <code><a href="#topic+hemilist">hemilist</a></code> of meshes as parameter 'mesh', see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geod.patches.color.overlay(
  mesh,
  vertex,
  color = "#FF0000",
  bg_color = "#FEFEFE",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geod.patches.color.overlay_+3A_mesh">mesh</code></td>
<td>
<p>a single <code>fs.surface</code> instance, or a <code><a href="#topic+hemilist">hemilist</a></code> of two such meshes. If a hemilist, the vertex indices can go from 1 to the sum of vertices in both meshes, and the proper hemisphere will be used automatically.</p>
</td></tr>
<tr><td><code id="geod.patches.color.overlay_+3A_vertex">vertex</code></td>
<td>
<p>positive integer (or vector of the latter), the index of the source vertex in the mesh. If a vector, the neighborhoods for all vertices will be computed separately.</p>
</td></tr>
<tr><td><code id="geod.patches.color.overlay_+3A_color">color</code></td>
<td>
<p>single color string like <code>'#FF0000'</code> or vector of such strings. If a vector, the length should match the number of vertices in parameter 'vertex'.</p>
</td></tr>
<tr><td><code id="geod.patches.color.overlay_+3A_bg_color">bg_color</code></td>
<td>
<p>character string, the background color.</p>
</td></tr>
<tr><td><code id="geod.patches.color.overlay_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code>geod.vert.neighborhood</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of color strings (or a <code><a href="#topic+hemilist">hemilist</a></code> of 2 such vectors if 'mesh' is a hemilist), an overlay suitable for visualization using <code>vis.color.on.subject</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  sjd = fsaverage.path(TRUE);
  surfaces = subject.surface(sjd, 'fsaverage', surface = "white", hemi = "both");
  colors = geod.patches.color.overlay(surfaces, vertex = c(12345L, 45L),
    color = c("#FF0000", "#00FF00"), max_distance = 45.0);
  vis.color.on.subject(sjd, 'fsaverage', color_lh=colors$lh, color_rh=colors$rh);

## End(Not run)

</code></pre>

<hr>
<h2 id='geod.patches.color.overlay.singlehemi'>Generate color overlay from geodesic patches around several vertices for a single hemi.</h2><span id='topic+geod.patches.color.overlay.singlehemi'></span>

<h3>Description</h3>

<p>Generate color overlay from geodesic patches around several vertices for a single hemi.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geod.patches.color.overlay.singlehemi(
  mesh,
  vertex,
  color = "#FF0000",
  bg_color = "#FEFEFE",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geod.patches.color.overlay.singlehemi_+3A_mesh">mesh</code></td>
<td>
<p>a single <code>fs.surface</code> instance.</p>
</td></tr>
<tr><td><code id="geod.patches.color.overlay.singlehemi_+3A_vertex">vertex</code></td>
<td>
<p>positive integer (or vector of the latter), the index of the source vertex in the mesh. If a vector, the neighborhoods for all vertices will be computed separately.</p>
</td></tr>
<tr><td><code id="geod.patches.color.overlay.singlehemi_+3A_color">color</code></td>
<td>
<p>single color string like <code>'#FF0000'</code> or vector of such strings. If a vector, the length should match the number of vertices in parameter 'vertex'.</p>
</td></tr>
<tr><td><code id="geod.patches.color.overlay.singlehemi_+3A_bg_color">bg_color</code></td>
<td>
<p>character string, the background color.</p>
</td></tr>
<tr><td><code id="geod.patches.color.overlay.singlehemi_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code>geod.vert.neighborhood</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='geod.patches.pervertexdata'>Generate per-vertex distance data from geodesic patches around several vertices.</h2><span id='topic+geod.patches.pervertexdata'></span>

<h3>Description</h3>

<p>Works across hemispheres (for a whole brain) if you pass a <code><a href="#topic+hemilist">hemilist</a></code> of meshes as parameter 'mesh', see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geod.patches.pervertexdata(mesh, vertex, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geod.patches.pervertexdata_+3A_mesh">mesh</code></td>
<td>
<p>a single <code>fs.surface</code> instance, or a <code><a href="#topic+hemilist">hemilist</a></code> of two such meshes. If a hemilist, the vertex indices can go from 1 to the sum of vertices in both meshes, and the proper hemisphere will be used automatically.</p>
</td></tr>
<tr><td><code id="geod.patches.pervertexdata_+3A_vertex">vertex</code></td>
<td>
<p>positive integer (or vector of the latter), the index of the source vertex in the mesh. If a vector, the neighborhoods for all vertices will be computed separately.</p>
</td></tr>
<tr><td><code id="geod.patches.pervertexdata_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code>geod.vert.neighborhood</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of doubles (or a <code><a href="#topic+hemilist">hemilist</a></code> of 2 such vectors if 'mesh' is a hemilist), the per-vertex distance data. Data for vertices outside neighborhoods will be NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  sjd = fsaverage.path(TRUE);
  surfaces = subject.surface(sjd, 'fsaverage',
    surface = "white", hemi = "both");
  res = geod.patches.pervertexdata(surfaces,
    vertex = c(12345L, 45L),
    max_distance = 25.0);
  # res$lh and res$rh now hold the per-vertex data.

## End(Not run)

</code></pre>

<hr>
<h2 id='geod.patches.pervertexdata.singlehemi'>Generate per-vertex distance data from geodesic patches around several vertices for a single hemi.</h2><span id='topic+geod.patches.pervertexdata.singlehemi'></span>

<h3>Description</h3>

<p>Generate per-vertex distance data from geodesic patches around several vertices for a single hemi.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geod.patches.pervertexdata.singlehemi(mesh, vertex, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geod.patches.pervertexdata.singlehemi_+3A_mesh">mesh</code></td>
<td>
<p>a single <code>fs.surface</code> instance.</p>
</td></tr>
<tr><td><code id="geod.patches.pervertexdata.singlehemi_+3A_vertex">vertex</code></td>
<td>
<p>positive integer (or vector of the latter), the index of the source vertex in the mesh. If a vector, the neighborhoods for all vertices will be computed separately.</p>
</td></tr>
<tr><td><code id="geod.patches.pervertexdata.singlehemi_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code>geod.vert.neighborhood</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>geod.patches.pervertexdata
</p>

<hr>
<h2 id='geod.vert.neighborhood'>Compute all vertices within given geodesic distance on the mesh.</h2><span id='topic+geod.vert.neighborhood'></span>

<h3>Description</h3>

<p>Compute all vertices within given geodesic distance on the mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geod.vert.neighborhood(
  mesh,
  vertex,
  max_distance = 5,
  include_max = TRUE,
  return_distances = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geod.vert.neighborhood_+3A_mesh">mesh</code></td>
<td>
<p>an instance of <code>rgl::tmesh3d</code> or <code>freesurferformats::fs.surface</code>.</p>
</td></tr>
<tr><td><code id="geod.vert.neighborhood_+3A_vertex">vertex</code></td>
<td>
<p>positive integer (or vector of the latter), the index of the source vertex in the mesh. If a vector, the neighborhoods for all vertices will be computed separately.</p>
</td></tr>
<tr><td><code id="geod.vert.neighborhood_+3A_max_distance">max_distance</code></td>
<td>
<p>double, the neighborhood size. All mesh vertices in geodesic distance smaller than / up to this distance will be returned.</p>
</td></tr>
<tr><td><code id="geod.vert.neighborhood_+3A_include_max">include_max</code></td>
<td>
<p>logical, whether the max_distance value is inclusive.</p>
</td></tr>
<tr><td><code id="geod.vert.neighborhood_+3A_return_distances">return_distances</code></td>
<td>
<p>logical, whether to compute the 'distances' entry in the returned list. Doing so is a little bit slower, so it can be turned off if not needed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with the following entries: 'vertices': integer vector, the indices of all vertices in the neigborhood. 'distances': double vector, the distances to the respective vertices (unless 'return_distances' is FALSE).
</p>


<h3>Note</h3>

<p>This function uses the pseudo-geodesic distance along the mesh edges.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  sjd = fsaverage.path(TRUE);
  surface = subject.surface(sjd, 'fsaverage', surface = "white", hemi = "lh");
  res = geod.vert.neighborhood(surface, 12345L, max_distance = 10.0);
  res$vertices;

## End(Not run)

</code></pre>

<hr>
<h2 id='geodesic.average.distance'>Compute the average (pseudo-) geodesic distance on the mesh from each vertex to all other vertices.</h2><span id='topic+geodesic.average.distance'></span>

<h3>Description</h3>

<p>Compute the average (pseudo-) geodesic distance on the mesh from each vertex to all other vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodesic.average.distance(surfaces)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geodesic.average.distance_+3A_surfaces">surfaces</code></td>
<td>
<p>fs.surface instance or a <code><a href="#topic+hemilist">hemilist</a></code> of the latter.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This may take a while. It requires the 'Rvcg' package.
</p>

<hr>
<h2 id='geodesic.ballstats'>Compute geodesic ball area and perimeter at location defined by geodists for all radii.</h2><span id='topic+geodesic.ballstats'></span>

<h3>Description</h3>

<p>Compute geodesic ball area and perimeter at location defined by geodists for all radii.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodesic.ballstats(mesh, geodist, sample_at_radii)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geodesic.ballstats_+3A_mesh">mesh</code></td>
<td>
<p>tmesh3d instance</p>
</td></tr>
<tr><td><code id="geodesic.ballstats_+3A_geodist">geodist</code></td>
<td>
<p>vector of geodesic distance for current mesh vertex under consideration (no need for the index)</p>
</td></tr>
<tr><td><code id="geodesic.ballstats_+3A_sample_at_radii">sample_at_radii</code></td>
<td>
<p>double vector, the different ball radii for which to perform the computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries: 'ball_area': vector of double, ball area at each sample radius. 'ball_perimeter': vector of double, ball perimeter at each sample radius.
</p>


<h3>Note</h3>

<p>This is called from <code>geodesic.circles</code>, there should be no need to call it directly.
</p>

<hr>
<h2 id='geodesic.circles'>Compute geodesic circles and ball stats for given vertices.</h2><span id='topic+geodesic.circles'></span>

<h3>Description</h3>

<p>Compute geodesic circles and ball stats for given vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodesic.circles(surface, vertices = NULL, scale = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geodesic.circles_+3A_surface">surface</code></td>
<td>
<p>an <code>rgl::tmesh3d</code> or <code>freesurferformats::fs.surface</code> instance. Can be a character string, which will be loaded as a surface file if it exists.</p>
</td></tr>
<tr><td><code id="geodesic.circles_+3A_vertices">vertices</code></td>
<td>
<p>positive integer vector, the vertex indices for which to compute the stats. If NULL, it is computed for all vertices.</p>
</td></tr>
<tr><td><code id="geodesic.circles_+3A_scale">scale</code></td>
<td>
<p>double, surface area to be covered by patch in percent</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This takes a while for large meshes, try it with single vertices or with a surface like fsaverage3 if you want it for all vertices. This requires the optional dependency package 'pracma'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  sjd = fsaverage.path(TRUE);
  surface = subject.surface(sjd, 'fsaverage3', hemi='lh');
  gc = geodesic.circles(surface);
  vis.data.on.subject(sjd, 'fsaverage3', morph_data_lh = gc$radius);
  vis.data.on.subject(sjd, 'fsaverage3', morph_data_lh = gc$perimeter);

## End(Not run)

</code></pre>

<hr>
<h2 id='geodesic.dists.to.vertex'>Simple internal wrapper around <code>Rvcg::vcgDijkstra</code> with function check.</h2><span id='topic+geodesic.dists.to.vertex'></span>

<h3>Description</h3>

<p>Simple internal wrapper around <code>Rvcg::vcgDijkstra</code> with function check.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodesic.dists.to.vertex(mesh, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geodesic.dists.to.vertex_+3A_mesh">mesh</code></td>
<td>
<p>a tmesh3d instance.</p>
</td></tr>
<tr><td><code id="geodesic.dists.to.vertex_+3A_v">v</code></td>
<td>
<p>positive integer, a vertex index in the mesh.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double vector with length equal to num vertices in the mesh, the geodesic distances from all other vertices to the query vertex <code>v</code>.
</p>

<hr>
<h2 id='geodesic.path'>Compute geodesic path from a source vertex to one or more target vertices.</h2><span id='topic+geodesic.path'></span>

<h3>Description</h3>

<p>Compute geodesic path from a source vertex to one or more target vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodesic.path(surface, source_vertex, target_vertices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geodesic.path_+3A_surface">surface</code></td>
<td>
<p>an <code>rgl::tmesh3d</code> or <code>freesurferformats::fs.surface</code> instance. Can be a character string, which will be loaded as a surface file if it exists.</p>
</td></tr>
<tr><td><code id="geodesic.path_+3A_source_vertex">source_vertex</code></td>
<td>
<p>a scalar positive integer, the source vertex index in the mesh</p>
</td></tr>
<tr><td><code id="geodesic.path_+3A_target_vertices">target_vertices</code></td>
<td>
<p>single integer or vector of integers, the target vertices to which to compute the paths from the source_vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of integer vectors, the paths
</p>


<h3>Note</h3>

<p>This can take a bit for very large graphs. This requires the optional dependency package 'Rvcg'. The backtracking is currently done in R, which is not optimal from a performance perspective. If you have a recent Rvcg version with the Rvcg::vcgGeodesicPath function, that one will be used instead, and the performance will be better.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  sjd = fsaverage.path(TRUE);
  surface = subject.surface(sjd, 'fsaverage3',
    surface = "white", hemi = "lh");
  p = geodesic.path(surface, 5, c(10, 20));
  vis.subject.morph.native(sjd, 'fsaverage3', 'thickness', views='si');
  vis.paths.along.verts(surface$vertices, p$paths, color=c("red", "yellow"));

## End(Not run)

</code></pre>

<hr>
<h2 id='get_optional_data_filepath'>Access a single file from the package cache by its file name.</h2><span id='topic+get_optional_data_filepath'></span>

<h3>Description</h3>

<p>Access a single file from the package cache by its file name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_optional_data_filepath(filename, mustWork = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_optional_data_filepath_+3A_filename">filename</code></td>
<td>
<p>string. The filename of the file in the package cache.</p>
</td></tr>
<tr><td><code id="get_optional_data_filepath_+3A_mustwork">mustWork</code></td>
<td>
<p>logical. Whether an error should be created if the file does not exist. If mustWork=FALSE and the file does not exist, the empty string is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string. The full path to the file in the package cache or the empty string if there is no such file available. Use this in your application code to open the file.
</p>

<hr>
<h2 id='get.atlas.region.names'>Determine atlas region names from a subject.</h2><span id='topic+get.atlas.region.names'></span>

<h3>Description</h3>

<p>Determine atlas region names from a subject. WARNING: Not all subjects have all regions of an atlas. You should use an average subject like fsaverage to get all regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.atlas.region.names(
  atlas,
  template_subjects_dir = NULL,
  template_subject = "fsaverage",
  hemi = "lh"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.atlas.region.names_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="get.atlas.region.names_+3A_template_subjects_dir">template_subjects_dir</code></td>
<td>
<p>string. The directory containing the dir of the template_subject. E.g., the path to FREESURFER_HOME/subjects. If NULL, env vars will be searched for candidates, and the function will fail if they are not set correctly. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="get.atlas.region.names_+3A_template_subject">template_subject</code></td>
<td>
<p>string. The subject identifier. Defaults to 'fsaverage'.</p>
</td></tr>
<tr><td><code id="get.atlas.region.names_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded. Defaults to 'lh'. Should not matter much, unless you do not have the file for one of the hemis for some reason.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of strings, the region names.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 fsbrain::download_optional_data();
 subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
 atlas_regions = get.atlas.region.names('aparc',
 template_subjects_dir=subjects_dir, template_subject='subject1');

## End(Not run)

</code></pre>

<hr>
<h2 id='get.rglstyle'>Get the default visualization style parameters as a named list.</h2><span id='topic+get.rglstyle'></span>

<h3>Description</h3>

<p>Run <code>material3d</code> without arguments to see valid style keywords to create new styles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rglstyle(style)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.rglstyle_+3A_style">style</code></td>
<td>
<p>string. A style name. Available styles are one of: &quot;default&quot;, &quot;shiny&quot;, &quot;semitransparent&quot;, &quot;glass&quot;, &quot;edges&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a style, resolved to a parameter list compatible with <code>material3d</code>.
</p>


<h3>See Also</h3>

<p><code>shade3d</code> can use the returned style
</p>

<hr>
<h2 id='get.rglstyle.default'>Get the default visualization style parameters as a named list.</h2><span id='topic+get.rglstyle.default'></span>

<h3>Description</h3>

<p>The default rendering style, which is is rather plain. Does not look super fancy, but allows for clear data visualization without distractions. Hint: Run <code>material3d</code> without arguments to see valid style keywords to create new styles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rglstyle.default()
</code></pre>


<h3>Value</h3>

<p>named list, style parameters that can be passed to <code>shade3d</code> via <code><a href="base.html#topic+do.call">do.call</a></code>.
</p>

<hr>
<h2 id='get.rglstyle.edges'>Get the mesh edges visualization style parameters as a named list.</h2><span id='topic+get.rglstyle.edges'></span>

<h3>Description</h3>

<p>Mesh edges rendering style. Zoom in enough to see them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rglstyle.edges()
</code></pre>


<h3>Value</h3>

<p>named list, style parameters that can be passed to <code>shade3d</code> via <code><a href="base.html#topic+do.call">do.call</a></code>.
</p>

<hr>
<h2 id='get.rglstyle.glass'>Get the glass visualization style parameters as a named list.</h2><span id='topic+get.rglstyle.glass'></span>

<h3>Description</h3>

<p>Glass-brain rendering style. This style has a very negative impact on rendering performance (especially in interactive mode). Hint: Run <code>material3d</code> without arguments to see valid style keywords to create new styles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rglstyle.glass()
</code></pre>


<h3>Value</h3>

<p>named list, style parameters that can be passed to <code>shade3d</code> via <code><a href="base.html#topic+do.call">do.call</a></code>.
</p>

<hr>
<h2 id='get.rglstyle.glass2'>Get the glass2 visualization style parameters as a named list.</h2><span id='topic+get.rglstyle.glass2'></span>

<h3>Description</h3>

<p>Glass-brain rendering style. This style has a very negative impact on rendering performance (especially in interactive mode). Hint: Run <code>material3d</code> without arguments to see valid style keywords to create new styles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rglstyle.glass2()
</code></pre>


<h3>Value</h3>

<p>named list, style parameters that can be passed to <code>shade3d</code> via <code><a href="base.html#topic+do.call">do.call</a></code>.
</p>

<hr>
<h2 id='get.rglstyle.parameters'>Produce the named list of style parameters from style definition.</h2><span id='topic+get.rglstyle.parameters'></span>

<h3>Description</h3>

<p>A style definition can be a character string like &quot;shiny&quot;, already a parameter list, or a command like 'from_mesh' that tells us to get the style from the renderable. This function creates the final parameters from the definition and the renderable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rglstyle.parameters(renderable, style)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.rglstyle.parameters_+3A_renderable">renderable</code></td>
<td>
<p>A renderable (or any list) which includes a 'style' key. If it does not include such a key, the 'default' style will be used.</p>
</td></tr>
<tr><td><code id="get.rglstyle.parameters_+3A_style">style</code></td>
<td>
<p>A style definition. Can be a character string like 'shiny' or 'from_mesh', or already a named list of material properties (which will be returned as-is).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a style, resolved to a parameter list compatible with <code>material3d</code>.
</p>

<hr>
<h2 id='get.rglstyle.semitransparent'>Get the semi-transparent visualization style parameters as a named list.</h2><span id='topic+get.rglstyle.semitransparent'></span>

<h3>Description</h3>

<p>Semitransparent rendering style. This style has a very negative impact on rendering performance (in interactive mode). Hint: Run <code>material3d</code> without arguments to see valid style keywords to create new styles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rglstyle.semitransparent()
</code></pre>


<h3>Value</h3>

<p>named list, style parameters that can be passed to <code>shade3d</code> via <code><a href="base.html#topic+do.call">do.call</a></code>.
</p>

<hr>
<h2 id='get.rglstyle.shiny'>Get a shiny visualization style.</h2><span id='topic+get.rglstyle.shiny'></span>

<h3>Description</h3>

<p>A shiny or glossy rendering style. Looks a bit more modern, but the resulting highlights may make the interpretation of the plotted data a bit harder in some areas. Hint: Run <code>material3d</code> without arguments to see valid style keywords to create new styles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rglstyle.shiny()
</code></pre>


<h3>Value</h3>

<p>named list, style parameters that can be passed to to <code>shade3d</code> via <code><a href="base.html#topic+do.call">do.call</a></code>.
</p>

<hr>
<h2 id='get.slice.indices'>Compute slice indices from slice definition.</h2><span id='topic+get.slice.indices'></span>

<h3>Description</h3>

<p>Compute slice indices from slice definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.slice.indices(voldim, axis, slices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.slice.indices_+3A_voldim">voldim</code></td>
<td>
<p>integer vector, the dimension of the volume</p>
</td></tr>
<tr><td><code id="get.slice.indices_+3A_axis">axis</code></td>
<td>
<p>integer, the axis</p>
</td></tr>
<tr><td><code id="get.slice.indices_+3A_slices">slices</code></td>
<td>
<p>slice index definition. If a vector of integers, interpreted as slice indices. If a single negative interger &lsquo;-n', interpreted as every 'nth' slice, starting at slice 1. The character string &rsquo;all' or the value 'NULL' will be interpreted as *all slices*.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector, the computed slice indices. They are guaranteed to be valid indices into the volume.
</p>

<hr>
<h2 id='get.subject.class'>Construct FSGD Class name from group and non-continuous covariate columns.</h2><span id='topic+get.subject.class'></span>

<h3>Description</h3>

<p>Construct FSGD Class name from group and non-continuous covariate columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.subject.class(demographics_df, row_idx, class_columns, collapse = "_")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.subject.class_+3A_demographics_df">demographics_df</code></td>
<td>
<p>data.frame, as returned by <code>read.md.demographics</code> or created manually. Note that the data.frame must not contain any character columns, they should be converted to factors.</p>
</td></tr>
<tr><td><code id="get.subject.class_+3A_row_idx">row_idx</code></td>
<td>
<p>integer, the row in the df that belongs to this subject</p>
</td></tr>
<tr><td><code id="get.subject.class_+3A_class_columns">class_columns</code></td>
<td>
<p>the column names to use</p>
</td></tr>
<tr><td><code id="get.subject.class_+3A_collapse">collapse</code></td>
<td>
<p>character string, the separator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string, the Class name for this subject, derived from the values in the 'class_columns'.
</p>

<hr>
<h2 id='get.view.angle.names'>Get list of valid view angle names.</h2><span id='topic+get.view.angle.names'></span>

<h3>Description</h3>

<p>The returned strings are used as constants to identify a view of type 'sd_&lt;angle&gt;'. They can be used to construct entries for the parameter 'views' of functions like <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>, or directly as parameter 'view_angles' for functions like <code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.view.angle.names(angle_set = "all", add_sd_prefix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.view.angle.names_+3A_angle_set">angle_set</code></td>
<td>
<p>string, which view subset to return. Available subsets are: 'all' (or alias 't9'): for all 9 angles. 't4': for the t4 views. 'medial': the 2 medial views, one for each hemi. 'lateral': the 2 lateral views, one for each hemi. 'lh': medial and laterial for the left hemisphere. 'rh': medial and laterial for the right hemisphere.</p>
</td></tr>
<tr><td><code id="get.view.angle.names_+3A_add_sd_prefix">add_sd_prefix</code></td>
<td>
<p>logical, whether the prefix 'sd_' should be added to the string. This will construct full view names. If set to false, only the substring after the prefix 'sd_' will be returned. This is used internally only and should not be needed in general.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of character strings, all valid view angle strings.
</p>

<hr>
<h2 id='getIn'>Retrieve values from nested named lists</h2><span id='topic+getIn'></span>

<h3>Description</h3>

<p>Retrieve values from nested named lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIn(named_list, listkeys, default = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getIn_+3A_named_list">named_list</code></td>
<td>
<p>a named list</p>
</td></tr>
<tr><td><code id="getIn_+3A_listkeys">listkeys</code></td>
<td>
<p>vector of character strings, the nested names of the lists</p>
</td></tr>
<tr><td><code id="getIn_+3A_default">default</code></td>
<td>
<p>the default value to return in case the requested value is 'NULL'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value at the path through the lists, or &lsquo;NULL' (or the &rsquo;default') if no such path exists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data = list("regions"=list("frontal"=list("thickness"=2.3, "area"=2345)));
   getIn(data, c("regions", "frontal", "thickness"));       # 2.3
   getIn(data, c("regions", "frontal", "nosuchentry"));     # NULL
   getIn(data, c("regions", "nosuchregion", "thickness"));  # NULL
   getIn(data, c("regions", "nosuchregion", "thickness"), default=14);  # 14

</code></pre>

<hr>
<h2 id='group.agg.atlas.native'>Aggregate native space morphometry data over brain atlas regions and subjects for a group of subjects.</h2><span id='topic+group.agg.atlas.native'></span>

<h3>Description</h3>

<p>Aggregate native space morphometry data over brain atlas regions, e.g., compute the mean thickness value over all regions in an atlas for all subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.agg.atlas.native(
  subjects_dir,
  subjects_list,
  measure,
  hemi,
  atlas,
  agg_fun = mean,
  cache_file = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.agg.atlas.native_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.native_+3A_subjects_list">subjects_list</code></td>
<td>
<p>string vector. A vector of subject identifiers that match the directory names within subjects_dir.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.native_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.native_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', 'split', or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded. If set to 'both', combined data for 'lh' and 'rh' will be used. If 'split', the data for hte two hemispheres will go into seprate columns, with column names having 'lh_' and 'rh_' prefixes.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.native_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.native_+3A_agg_fun">agg_fun</code></td>
<td>
<p>function. An R function that aggregates data, typically max, mean, min or something similar. Note: this is NOT a string, put the function name without quotes. Defaults to mean.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.native_+3A_cache_file">cache_file</code></td>
<td>
<p>string or NULL. If given, it is interpreted as path of a file, and the data will be cached in the file cache_file in RData format. If the file does not exist yet, the function will run and cache the data in the file. If the file exists, the function will load the data from the file instead of running. The filename should end in '.RData', but that is not enforced or checked in any way. WARNING: If cached data is returned, all parameters passed to this function (with the exception of 'cache_file') are ignored! Whether the cached data is for another subjects_list or hemi is NOT checked! You have to ensure this yourself, by using different filenames. Defaults to NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with aggregated values for all regions and subjects, with n columns and m rows, where n is the number of subjects and m is the number of regions.
</p>


<h3>See Also</h3>

<p>Other aggregation functions: 
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.morph.agg.standard.vertex">group.morph.agg.standard.vertex</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>
</p>
<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   agg = group.agg.atlas.native(subjects_dir, c('subject1', 'subject2'),
    'thickness', 'lh', 'aparc');
   # Visualize the mean values. Could use any subject, typically
   # one would use fsaverage. Here we use subject1:
   agg$subject = NULL;   # remove non-numeric column.
   vis.region.values.on.subject(subjects_dir, 'subject1', 'aparc',
    lh_region_value_list=colMeans(agg), rh_region_value_list=NULL);

## End(Not run)

</code></pre>

<hr>
<h2 id='group.agg.atlas.standard'>Aggregate standard space morphometry data over brain atlas regions and subjects for a group of subjects.</h2><span id='topic+group.agg.atlas.standard'></span>

<h3>Description</h3>

<p>Aggregate standard space morphometry data over brain atlas regions, e.g., compute the mean thickness value over all regions in an atlas for all subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.agg.atlas.standard(
  subjects_dir,
  subjects_list,
  measure,
  hemi,
  atlas,
  fwhm,
  agg_fun = mean,
  template_subject = "fsaverage",
  cache_file = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.agg.atlas.standard_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.standard_+3A_subjects_list">subjects_list</code></td>
<td>
<p>string vector. A vector of subject identifiers that match the directory names within subjects_dir.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.standard_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.standard_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded. If set to 'both', combined data for 'lh' and 'rh' will be used.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.standard_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.standard_+3A_fwhm">fwhm</code></td>
<td>
<p>string. The smoothing setting which was applied when mapping data to the template subject. Usually one of '0', '5', '10', '15', '20', or '25'.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.standard_+3A_agg_fun">agg_fun</code></td>
<td>
<p>function. An R function that aggregates data, typically max, mean, min or something similar. Note: this is NOT a string, put the function name without quotes. Defaults to mean.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.standard_+3A_template_subject">template_subject</code></td>
<td>
<p>string. The template subject name. Defaults to 'fsaverage'. Must have its data in subjects_dir.</p>
</td></tr>
<tr><td><code id="group.agg.atlas.standard_+3A_cache_file">cache_file</code></td>
<td>
<p>string or NULL. If given, it is interpreted as path of a file, and the data will be cached in the file cache_file in RData format. If the file does not exist yet, the function will run and cache the data in the file. If the file exists, the function will load the data from the file instead of running. The filename should end in '.RData', but that is not enforced or checked in any way. WARNING: If cached data is returned, all parameters passed to this function (with the exception of 'cache_file') are ignored! Whether the cached data is for another subjects_list or hemi is NOT checked! You have to ensure this yourself, by using different filenames. Defaults to NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with aggregated values for all regions and subjects, with n columns and m rows, where n is the number of subjects and m is the number of regions.
</p>


<h3>See Also</h3>

<p>Other aggregation functions: 
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.morph.agg.standard.vertex">group.morph.agg.standard.vertex</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>
</p>
<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   agg = group.agg.atlas.standard(subjects_dir, c('subject1', 'subject2'),
    'thickness', 'lh', 'aparc', fwhm='10');
   # Visualize the mean values. Could use any subject, typically
   #  one would use fsaverage. Here we use subject1:
   agg$subject = NULL;   # remove non-numeric column.
   vis.region.values.on.subject(subjects_dir, 'subject1', 'aparc',
    lh_region_value_list=colMeans(agg), rh_region_value_list=NULL);

## End(Not run)

</code></pre>

<hr>
<h2 id='group.annot'>Load annotations for a group of subjects.</h2><span id='topic+group.annot'></span>

<h3>Description</h3>

<p>Load a brain surface annotation, i.e., a cortical parcellation based on an atlas, for a group of subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.annot(subjects_dir, subjects_list, hemi, atlas)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.annot_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.annot_+3A_subjects_list">subjects_list</code></td>
<td>
<p>vector of strings. The subject identifiers.</p>
</td></tr>
<tr><td><code id="group.annot_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="group.annot_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of annotations, as returned by freesurferformats::read.fs.annot(). If hemi is 'both', the annotations are the results of merging over the hemispheres for each subject.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   subjects_list = c("subject1", "subject2");
   annotations = group.annot(subjects_dir, subjects_list, "lh", "aparc");

## End(Not run)

</code></pre>

<hr>
<h2 id='group.concat.measures.native'>Concatenate native space data for a group of subjects.</h2><span id='topic+group.concat.measures.native'></span>

<h3>Description</h3>

<p>A measure is something like 'thickness' or 'area'. This function concatenates the native space data for all subjects into a single long vector for each measure. A dataframe is then created, in which each column is one such vector. This can be used to compute the correlation between measures on vertex level, for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.concat.measures.native(
  subjects_dir,
  subjects_list,
  measures,
  hemi,
  cortex_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.concat.measures.native_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.concat.measures.native_+3A_subjects_list">subjects_list</code></td>
<td>
<p>string vector. A vector of subject identifiers that match the directory names within subjects_dir.</p>
</td></tr>
<tr><td><code id="group.concat.measures.native_+3A_measures">measures</code></td>
<td>
<p>vector of strings. Names of the vertex-wise morhometry measures. E.g., c(&quot;area&quot;, &quot;thickness&quot;). Used to construct the names of the morphometry file to be loaded. The data of each measure will be one column in the resulting dataframe.</p>
</td></tr>
<tr><td><code id="group.concat.measures.native_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="group.concat.measures.native_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to set non-cortex data to NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with concatenated vertex values. Each column contains the values for one measure, concatenated for all subjects. WARNING: This dataframe can get large if you have many subjects.
</p>


<h3>See Also</h3>

<p>Other concatination functions: 
<code><a href="#topic+group.concat.measures.standard">group.concat.measures.standard</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   subjects_list = c('subject1', 'subject2');
   cm = group.concat.measures.native(subjects_dir, subjects_list,
    c("thickness", "area"), "lh");

## End(Not run)

</code></pre>

<hr>
<h2 id='group.concat.measures.standard'>Concatenate standard space data for a group of subjects.</h2><span id='topic+group.concat.measures.standard'></span>

<h3>Description</h3>

<p>A measure is something like 'thickness' or 'area'. This function concatenates the standard space data for all subjects into a single long vector for each measure. A dataframe is then created, in which each column is one such vector. This can be used to compute the correlation between measures on vertex level, for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.concat.measures.standard(
  subjects_dir,
  subjects_list,
  measures,
  hemi,
  fwhm_per_measure,
  cortex_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.concat.measures.standard_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.concat.measures.standard_+3A_subjects_list">subjects_list</code></td>
<td>
<p>string vector. A vector of subject identifiers that match the directory names within subjects_dir.</p>
</td></tr>
<tr><td><code id="group.concat.measures.standard_+3A_measures">measures</code></td>
<td>
<p>vector of strings. Names of the vertex-wise morhometry measures. E.g., c(&quot;area&quot;, &quot;thickness&quot;). Used to construct the names of the morphometry file to be loaded. The data of each measure will be one column in the resulting dataframe.</p>
</td></tr>
<tr><td><code id="group.concat.measures.standard_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="group.concat.measures.standard_+3A_fwhm_per_measure">fwhm_per_measure</code></td>
<td>
<p>vector of strings. The fwhm settings to use, for each measure. If this is a string instead of a vector of strings, the same fwhm will be used for all measures.</p>
</td></tr>
<tr><td><code id="group.concat.measures.standard_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to set non-cortex data to NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with concatenated vertex values. Each column contains the values for one measure, concatenated for all subjects. The column names are a concatination of the measure, &quot;_fwhm&quot;, and the fwhm for that measure. WARNING: This dataframe can get large if you have many subjects.
</p>


<h3>See Also</h3>

<p>Other concatination functions: 
<code><a href="#topic+group.concat.measures.native">group.concat.measures.native</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   subjects_list = c('subject1', 'subject2');
   cm = group.concat.measures.standard(subjects_dir, subjects_list,
    c("thickness", "area"), "lh", "10");

## End(Not run)

</code></pre>

<hr>
<h2 id='group.data.to.array'>Convert group 2D data (1 vector per subject) to 4D array format.</h2><span id='topic+group.data.to.array'></span>

<h3>Description</h3>

<p>In general, 1D morphometry data for a group can be stored in a dataframe, a named list, or already a 4D array. This function will convert the given format to 4D array format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.data.to.array(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.data.to.array_+3A_data">data</code></td>
<td>
<p>2D matrix, named list, or data.frame of group data. The data is expected to be a vector (1D) per subject, as suitable for surface based (vertex-wise) measures. Subjects in rows, per-vertex data in columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the 4D array form of the group data. No values are changed, this is only a different data layout. In neuroimaging, the first 3 dimensions are space, and the 4th is the time/subject dimension.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # create per-vertex data for 255 subjects.
    mat = matrix(rnorm(255 * 163842, 3.0, 0.5), nrow=255, ncol = 163842);
    fsbrain:::group.data.to.array(mat);

</code></pre>

<hr>
<h2 id='group.label'>Retrieve label data for a group of subjects.</h2><span id='topic+group.label'></span>

<h3>Description</h3>

<p>Load a label (like 'label/lh.cortex.label') for a group of subjects from disk. Uses knowledge about the FreeSurfer directory structure to load the correct file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.label(
  subjects_dir,
  subjects_list,
  label,
  hemi,
  return_one_based_indices = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.label_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.label_+3A_subjects_list">subjects_list</code></td>
<td>
<p>vector of strings. The subject identifiers.</p>
</td></tr>
<tr><td><code id="group.label_+3A_label">label</code></td>
<td>
<p>string. Name of the label file, without the hemi part (if any), but including the '.label' suffix. E.g., 'cortex.label' for '?h.cortex.label'</p>
</td></tr>
<tr><td><code id="group.label_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="group.label_+3A_return_one_based_indices">return_one_based_indices</code></td>
<td>
<p>logical. Whether the indices should be 1-based. Indices are stored zero-based in the file, but R uses 1-based indices. Defaults to TRUE, which means that 1 will be added to all indices read from the file before returning them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of integer vectors with label data: Each name is a subject identifier from subjects_list, and the values are lists of the vertex indices in the respective label. See 'return_one_based_indices' for important information.
</p>


<h3>See Also</h3>

<p>Other label data functions: 
<code><a href="#topic+labeldata.from.mask">labeldata.from.mask</a>()</code>,
<code><a href="#topic+mask.from.labeldata.for.hemi">mask.from.labeldata.for.hemi</a>()</code>,
<code><a href="#topic+subject.label">subject.label</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   subjects_list = c("subject1", "subject2");
   labels = group.label(subjects_dir, subjects_list, 'cortex.label', "lh");

## End(Not run)

</code></pre>

<hr>
<h2 id='group.label.from.annot'>Extract a region from an atlas annotation as a label for a group of subjects.</h2><span id='topic+group.label.from.annot'></span>

<h3>Description</h3>

<p>The returned label can be used to mask morphometry data, e.g., to set the values of a certain region to NaN or to extract only values from a certain region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.label.from.annot(
  subjects_dir,
  subjects_list,
  hemi,
  atlas,
  region,
  return_one_based_indices = TRUE,
  invert = FALSE,
  error_on_invalid_region = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.label.from.annot_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.label.from.annot_+3A_subjects_list">subjects_list</code></td>
<td>
<p>vector of string. The subject identifiers.</p>
</td></tr>
<tr><td><code id="group.label.from.annot_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="group.label.from.annot_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="group.label.from.annot_+3A_region">region</code></td>
<td>
<p>string. A valid region name for the annotation, i.e., one of the regions of the atlas.</p>
</td></tr>
<tr><td><code id="group.label.from.annot_+3A_return_one_based_indices">return_one_based_indices</code></td>
<td>
<p>logical. Whether the indices should be 1-based. Indices are stored zero-based in label files, but R uses 1-based indices. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="group.label.from.annot_+3A_invert">invert</code></td>
<td>
<p>logical. If TRUE, return the indices of all vertices which are NOT part of the region. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="group.label.from.annot_+3A_error_on_invalid_region">error_on_invalid_region</code></td>
<td>
<p>logical. Whether to throw an error if the given region does not appear in the region list of the annotation. If set to FALSE, this will be ignored and an empty vertex list will be returned. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of integer vectors with label data: for each subject, the list of vertex indices in the label.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>

<hr>
<h2 id='group.morph.agg.native'>Aggregate native space morphometry data over one hemisphere for a group of subjects.</h2><span id='topic+group.morph.agg.native'></span>

<h3>Description</h3>

<p>Compute the mean (or other aggregates) over all vertices of a subject from native space morphometry data (like 'surf/lh.area'). Uses knowledge about the FreeSurfer directory structure to load the correct file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.morph.agg.native(
  subjects_dir,
  subjects_list,
  measure,
  hemi,
  agg_fun = mean,
  cast = TRUE,
  format = "curv",
  cortex_only = FALSE,
  agg_fun_extra_params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.morph.agg.native_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.morph.agg.native_+3A_subjects_list">subjects_list</code></td>
<td>
<p>string vector. A vector of subject identifiers that match the directory names within subjects_dir.</p>
</td></tr>
<tr><td><code id="group.morph.agg.native_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="group.morph.agg.native_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="group.morph.agg.native_+3A_agg_fun">agg_fun</code></td>
<td>
<p>function. An R function that aggregates data, typically <code><a href="base.html#topic+max">max</a></code>, mean, min or something similar. Note: this is NOT a string, put the function name without quotes. Defaults to mean.</p>
</td></tr>
<tr><td><code id="group.morph.agg.native_+3A_cast">cast</code></td>
<td>
<p>Whether a separate 'hemi' column should exist.</p>
</td></tr>
<tr><td><code id="group.morph.agg.native_+3A_format">format</code></td>
<td>
<p>string. One of 'mgh', 'mgz', 'curv'. Defaults to 'mgh'.</p>
</td></tr>
<tr><td><code id="group.morph.agg.native_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to mask the medial wall, i.e., whether the morphometry data for all vertices which are *not* part of the cortex (as defined by the label file &lsquo;label/?h.cortex.label') should be replaced with NA values. In other words, setting this to TRUE will ignore the values of the medial wall between the two hemispheres. If set to true, the mentioned label file needs to exist for the subjects. Also not that the aggregation function will need to be able to cope with NA values if you set this to TRUE. You can use &rsquo;agg_fun_extra_params' if needed to achieve that, depending on the function. Foe example, if you use the <code><a href="base.html#topic+mean">mean</a></code> function, you could set <code>agg_fun_extra_params=list("na.rm"=TRUE)</code> to get the mean of the vertices which are not masked. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="group.morph.agg.native_+3A_agg_fun_extra_params">agg_fun_extra_params</code></td>
<td>
<p>named list, extra parameters to pass to the aggregation function 'agg_fun' besides the loaded morphometry data. This is useful if you have masked the data and need to ignore NA values in the agg_fun.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with aggregated values for all subjects, with 3 columns and n rows, where n is the number of subjects. The 3 columns are 'subject_id', 'hemi', and '&lt;measure&gt;' (e.g., &quot;thickness&quot;), the latter contains the aggregated data.
</p>


<h3>See Also</h3>

<p>Other global aggregation functions: 
<code><a href="#topic+group.morph.agg.standard">group.morph.agg.standard</a>()</code>,
<code><a href="#topic+group.multimorph.agg.native">group.multimorph.agg.native</a>()</code>,
<code><a href="#topic+group.multimorph.agg.standard">group.multimorph.agg.standard</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   subjects_list = c("subject1", "subject2");
   fulldata = group.morph.agg.native(subjects_dir, subjects_list, "thickness", "lh");
   head(fulldata);

## End(Not run)

</code></pre>

<hr>
<h2 id='group.morph.agg.standard'>Aggregate standard space (fsaverage) morphometry data over one hemisphere for a group of subjects.</h2><span id='topic+group.morph.agg.standard'></span>

<h3>Description</h3>

<p>Compute the mean (or other aggregates) over all vertices of a subject from standard space morphometry data (like 'surf/lh.area.fwhm10.fsaverage.mgh'). Uses knowledge about the FreeSurfer directory structure to load the correct file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.morph.agg.standard(
  subjects_dir,
  subjects_list,
  measure,
  hemi,
  fwhm,
  agg_fun = mean,
  template_subject = "fsaverage",
  format = "mgh",
  cast = TRUE,
  cortex_only = FALSE,
  agg_fun_extra_params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.morph.agg.standard_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard_+3A_subjects_list">subjects_list</code></td>
<td>
<p>string vector. A vector of subject identifiers that match the directory names within subjects_dir.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard_+3A_fwhm">fwhm</code></td>
<td>
<p>string. Smoothing as string, e.g. '10' or '25'.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard_+3A_agg_fun">agg_fun</code></td>
<td>
<p>function. An R function that aggregates data, typically <code><a href="base.html#topic+max">max</a></code>, mean, min or something similar. Note: this is NOT a string, put the function name without quotes. Defaults to mean.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard_+3A_template_subject">template_subject</code></td>
<td>
<p>string. Template subject name, defaults to 'fsaverage'.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard_+3A_format">format</code></td>
<td>
<p>string. One of 'mgh', 'mgz', 'curv'. Defaults to 'mgh'.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard_+3A_cast">cast</code></td>
<td>
<p>Whether a separate 'hemi' column should exist.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to mask the medial wall, i.e., whether the morphometry data for all vertices which are *not* part of the cortex (as defined by the label file &lsquo;label/?h.cortex.label') should be replaced with NA values. In other words, setting this to TRUE will ignore the values of the medial wall between the two hemispheres. If set to true, the mentioned label file needs to exist for the subjects. Also not that the aggregation function will need to be able to cope with NA values if you set this to TRUE. You can use &rsquo;agg_fun_extra_params' if needed to achieve that, depending on the function. Foe example, if you use the <code><a href="base.html#topic+mean">mean</a></code> function, you could set <code>agg_fun_extra_params=list("na.rm"=TRUE)</code> to get the mean of the vertices which are not masked. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard_+3A_agg_fun_extra_params">agg_fun_extra_params</code></td>
<td>
<p>named list, extra parameters to pass to the aggregation function 'agg_fun' besides the loaded morphometry data. This is useful if you have masked the data and need to ignore NA values in the agg_fun.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with aggregated values for all subjects, with 2 columns and n rows, where n is the number of subjects. The 2 columns are 'subject_id' and '&lt;hemi&gt;.&lt;measure&gt;' (e.g., &quot;lh.thickness&quot;), the latter contains the aggregated data.
</p>


<h3>See Also</h3>

<p>Other global aggregation functions: 
<code><a href="#topic+group.morph.agg.native">group.morph.agg.native</a>()</code>,
<code><a href="#topic+group.multimorph.agg.native">group.multimorph.agg.native</a>()</code>,
<code><a href="#topic+group.multimorph.agg.standard">group.multimorph.agg.standard</a>()</code>
</p>

<hr>
<h2 id='group.morph.agg.standard.vertex'>Aggregate standard space morphometry data over subjects.</h2><span id='topic+group.morph.agg.standard.vertex'></span>

<h3>Description</h3>

<p>Aggregate vertex-wise values over subjects, leading to one aggregated measure per vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.morph.agg.standard.vertex(
  subjects_dir,
  subjects_list,
  measure,
  hemi,
  fwhm,
  agg_fun = mean,
  template_subject = "fsaverage",
  format = "mgh",
  cortex_only = FALSE,
  agg_fun_extra_params = NULL,
  split_by_hemi = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.morph.agg.standard.vertex_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard.vertex_+3A_subjects_list">subjects_list</code></td>
<td>
<p>string vector. A vector of subject identifiers that match the directory names within subjects_dir.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard.vertex_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard.vertex_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard.vertex_+3A_fwhm">fwhm</code></td>
<td>
<p>string. Smoothing as string, e.g. '10' or '25'.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard.vertex_+3A_agg_fun">agg_fun</code></td>
<td>
<p>function. An R function that aggregates data, typically <code><a href="base.html#topic+max">max</a></code>, mean, min or something similar. Note: this is NOT a string, put the function name without quotes. Defaults to mean.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard.vertex_+3A_template_subject">template_subject</code></td>
<td>
<p>string. Template subject name, defaults to 'fsaverage'.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard.vertex_+3A_format">format</code></td>
<td>
<p>string. One of 'mgh', 'mgz', 'curv'. Defaults to 'mgh'.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard.vertex_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to mask the medial wall, i.e., whether the morphometry data for all vertices which are *not* part of the cortex (as defined by the label file &lsquo;label/?h.cortex.label') should be replaced with NA values. In other words, setting this to TRUE will ignore the values of the medial wall between the two hemispheres. If set to true, the mentioned label file needs to exist for the subjects. Also not that the aggregation function will need to be able to cope with NA values if you set this to TRUE. You can use &rsquo;agg_fun_extra_params' if needed to achieve that, depending on the function. Foe example, if you use the <code><a href="base.html#topic+mean">mean</a></code> function, you could set <code>agg_fun_extra_params=list("na.rm"=TRUE)</code> to get the mean of the vertices which are not masked. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard.vertex_+3A_agg_fun_extra_params">agg_fun_extra_params</code></td>
<td>
<p>named list, extra parameters to pass to the aggregation function 'agg_fun' besides the loaded morphometry data. This is useful if you have masked the data and need to ignore NA values in the agg_fun.</p>
</td></tr>
<tr><td><code id="group.morph.agg.standard.vertex_+3A_split_by_hemi">split_by_hemi</code></td>
<td>
<p>logical, whether to return a hemilist</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other aggregation functions: 
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>
</p>

<hr>
<h2 id='group.morph.native'>Retrieve native space morphometry data for a group of subjects.</h2><span id='topic+group.morph.native'></span>

<h3>Description</h3>

<p>Load native space morphometry data (like 'surf/lh.area') for a group of subjects from disk. Uses knowledge about the FreeSurfer directory structure to load the correct file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.morph.native(
  subjects_dir,
  subjects_list,
  measure,
  hemi,
  format = "curv",
  cortex_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.morph.native_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.morph.native_+3A_subjects_list">subjects_list</code></td>
<td>
<p>vector of strings. The subject identifiers.</p>
</td></tr>
<tr><td><code id="group.morph.native_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="group.morph.native_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="group.morph.native_+3A_format">format</code></td>
<td>
<p>string. One of 'mgh', 'mgz', 'curv'. Defaults to 'curv'.</p>
</td></tr>
<tr><td><code id="group.morph.native_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to mask the medial wall, i.e., whether the morphometry data for all vertices which are *not* part of the cortex (as defined by the label file 'label/?h.cortex.label') should be replaced with NA values. In other words, setting this to TRUE will ignore the values of the medial wall between the two hemispheres. If set to true, the mentioned label file needs to exist for the subjects. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with native space morph data, the names are the subject identifiers from the subjects_list, and the values are morphometry data vectors (of different length, as each subject has a different vertex count in native space).
</p>


<h3>See Also</h3>

<p>Other morphometry data functions: 
<code><a href="#topic+apply.label.to.morphdata">apply.label.to.morphdata</a>()</code>,
<code><a href="#topic+apply.labeldata.to.morphdata">apply.labeldata.to.morphdata</a>()</code>,
<code><a href="#topic+group.morph.standard">group.morph.standard</a>()</code>,
<code><a href="#topic+subject.morph.native">subject.morph.native</a>()</code>,
<code><a href="#topic+subject.morph.standard">subject.morph.standard</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   subjects_list = c("subject1", "subject2");
   data = group.morph.native(subjects_dir, subjects_list, "thickness", "lh");

## End(Not run)

</code></pre>

<hr>
<h2 id='group.morph.standard'>Retrieve standard space morphometry data for a group of subjects.</h2><span id='topic+group.morph.standard'></span>

<h3>Description</h3>

<p>Load standard space morphometry data (like 'surf/lh.area') for a group of subjects from disk. Uses knowledge about the FreeSurfer directory structure to load the correct file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.morph.standard(
  subjects_dir,
  subjects_list,
  measure,
  hemi = "both",
  fwhm = "10",
  template_subject = "fsaverage",
  format = "mgh",
  cortex_only = FALSE,
  df = FALSE,
  df_t = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.morph.standard_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.morph.standard_+3A_subjects_list">subjects_list</code></td>
<td>
<p>vector of strings. The subject identifiers.</p>
</td></tr>
<tr><td><code id="group.morph.standard_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="group.morph.standard_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="group.morph.standard_+3A_fwhm">fwhm</code></td>
<td>
<p>string. Smoothing as string, e.g. '10' or '25'.</p>
</td></tr>
<tr><td><code id="group.morph.standard_+3A_template_subject">template_subject</code></td>
<td>
<p>string. Template subject name, defaults to 'fsaverage'.</p>
</td></tr>
<tr><td><code id="group.morph.standard_+3A_format">format</code></td>
<td>
<p>string. One of 'mgh', 'mgz', 'curv'. Defaults to 'mgh'.</p>
</td></tr>
<tr><td><code id="group.morph.standard_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to mask the medial wall, i.e., whether the morphometry data for all vertices which are *not* part of the cortex (as defined by the label file 'label/?h.cortex.label') should be replaced with NA values. In other words, setting this to TRUE will ignore the values of the medial wall between the two hemispheres. If set to true, the mentioned label file needs to exist for the template subject. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="group.morph.standard_+3A_df">df</code></td>
<td>
<p>logical, whether to return a dataframe instead of the named list. The dataframe will have one subject per column, and *n* rows, where *n* is the number of vertices of the template subject surface.</p>
</td></tr>
<tr><td><code id="group.morph.standard_+3A_df_t">df_t</code></td>
<td>
<p>logical, whether to return a transposed dataframe. Only one of df or df_t must be TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with standard space morph data, the names are the subject identifiers from the subjects_list, and the values are morphometry data vectors (all with identical length, the data is mapped to a template subject).
</p>


<h3>See Also</h3>

<p>Other morphometry data functions: 
<code><a href="#topic+apply.label.to.morphdata">apply.label.to.morphdata</a>()</code>,
<code><a href="#topic+apply.labeldata.to.morphdata">apply.labeldata.to.morphdata</a>()</code>,
<code><a href="#topic+group.morph.native">group.morph.native</a>()</code>,
<code><a href="#topic+subject.morph.native">subject.morph.native</a>()</code>,
<code><a href="#topic+subject.morph.standard">subject.morph.standard</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   subjects_list = c("subject1", "subject2");
   fulldata = group.morph.standard(subjects_dir, subjects_list, "thickness", "lh", fwhm='10');
   mean(fulldata$subject1);

   cortexdata = group.morph.standard(subjects_dir, subjects_list, "thickness",
    "lh", fwhm='10', cortex_only=FALSE);
   mean(cortexdata$subject1, na.rm=TRUE);

## End(Not run)

</code></pre>

<hr>
<h2 id='group.morph.standard.sf'>Read combined data for a group from a single file.</h2><span id='topic+group.morph.standard.sf'></span>

<h3>Description</h3>

<p>Read morphometry data for a group from a matrix in a single MGH or MGZ file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.morph.standard.sf(filepath, df = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.morph.standard.sf_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to a file in MGH or MGZ format</p>
</td></tr>
<tr><td><code id="group.morph.standard.sf_+3A_df">df</code></td>
<td>
<p>logical, whether to return a data.frame, like <code>group.morph.standard</code>. If FALSE, the raw 4d matrix is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe or 4d matrix, the morph data. See parameter 'df' for details.
</p>


<h3>Note</h3>

<p>The file has typically been generated by running <code>mris_preproc</code> and/or <code>mri_surf2surf</code> on the command line, or written from R using <code><a href="#topic+write.group.morph.standard.sf">write.group.morph.standard.sf</a></code>. The file contains no information on the subject identifiers, you need to know the subjects and their order in the file. Same goes for the hemisphere.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.group.morph.standard.mf">write.group.morph.standard.mf</a></code> to write the data to one file per hemi per subject instead. If you have created the input data file in FreeSurfer based on an FSGD file, you can read the subject identifiers from that FSGD file using <code><a href="#topic+read.md.subjects.from.fsgd">read.md.subjects.from.fsgd</a></code>.
</p>

<hr>
<h2 id='group.multimorph.agg.native'>Aggregate native space morphometry data for multiple measures over hemispheres for a group of subjects.</h2><span id='topic+group.multimorph.agg.native'></span>

<h3>Description</h3>

<p>Compute the mean (or other aggregates) over all vertices of a subject from native space morphometry data (like 'surf/lh.area'). You can specify several measures and hemispheres. Uses knowledge about the FreeSurfer directory structure to load the correct files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.multimorph.agg.native(
  subjects_dir,
  subjects_list,
  measures,
  hemis,
  agg_fun = mean,
  format = "curv",
  cast = TRUE,
  cortex_only = FALSE,
  agg_fun_extra_params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.multimorph.agg.native_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.native_+3A_subjects_list">subjects_list</code></td>
<td>
<p>string vector. A vector of subject identifiers that match the directory names within subjects_dir.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.native_+3A_measures">measures</code></td>
<td>
<p>vector of strings. Names of the vertex-wise morphometry measures. E.g., c(&quot;area&quot;, &quot;thickness&quot;). Used to construct the names of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.native_+3A_hemis">hemis</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.native_+3A_agg_fun">agg_fun</code></td>
<td>
<p>function. An R function that aggregates data, typically <code><a href="base.html#topic+max">max</a></code>, mean, min or something similar. Note: this is NOT a string, put the function name without quotes. Defaults to mean.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.native_+3A_format">format</code></td>
<td>
<p>string. One of 'mgh', 'mgz', 'curv'. Defaults to 'mgh'.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.native_+3A_cast">cast</code></td>
<td>
<p>Whether a separate 'hemi' column should exist.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.native_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to mask the medial wall, i.e., whether the morphometry data for all vertices which are *not* part of the cortex (as defined by the label file &lsquo;label/?h.cortex.label') should be replaced with NA values. In other words, setting this to TRUE will ignore the values of the medial wall between the two hemispheres. If set to true, the mentioned label file needs to exist for the subjects. Also not that the aggregation function will need to be able to cope with NA values if you set this to TRUE. You can use &rsquo;agg_fun_extra_params' if needed to achieve that, depending on the function. Foe example, if you use the <code><a href="base.html#topic+mean">mean</a></code> function, you could set <code>agg_fun_extra_params=list("na.rm"=TRUE)</code> to get the mean of the vertices which are not masked. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.native_+3A_agg_fun_extra_params">agg_fun_extra_params</code></td>
<td>
<p>named list, extra parameters to pass to the aggregation function 'agg_fun' besides the loaded morphometry data. This is useful if you have masked the data and need to ignore NA values in the agg_fun.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with aggregated values over all measures and hemis for all subjects, with m columns and n rows, where n is the number of subjects. The m columns are 'subject_id' and '&lt;hemi&gt;.&lt;measure&gt;' (e.g., &quot;lh.thickness&quot;) for all combinations of hemi and measure, the latter contains the aggregated data.
</p>


<h3>See Also</h3>

<p>Other global aggregation functions: 
<code><a href="#topic+group.morph.agg.native">group.morph.agg.native</a>()</code>,
<code><a href="#topic+group.morph.agg.standard">group.morph.agg.standard</a>()</code>,
<code><a href="#topic+group.multimorph.agg.standard">group.multimorph.agg.standard</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
    subjects_list = c("subject1", "subject2")
    data = group.multimorph.agg.native(subjects_dir, subjects_list, c("thickness", "area"),
     c("lh", "rh"), cast=FALSE, cortex_only=TRUE, agg_fun=mean,
     agg_fun_extra_params=list("na.rm"=TRUE));
    head(data);

## End(Not run)

</code></pre>

<hr>
<h2 id='group.multimorph.agg.standard'>Aggregate standard space (fsaverage) morphometry data for multiple measures over hemispheres for a group of subjects.</h2><span id='topic+group.multimorph.agg.standard'></span>

<h3>Description</h3>

<p>Compute the mean (or other aggregates) over all vertices of a subject from standard space morphometry data (like 'surf/lh.area.fwhm10.fsaverage.mgh'). You can specify several measures and hemispheres. Uses knowledge about the FreeSurfer directory structure to load the correct files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.multimorph.agg.standard(
  subjects_dir,
  subjects_list,
  measures,
  hemis,
  fwhm,
  agg_fun = mean,
  template_subject = "fsaverage",
  format = "mgh",
  cast = TRUE,
  cortex_only = FALSE,
  agg_fun_extra_params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.multimorph.agg.standard_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.standard_+3A_subjects_list">subjects_list</code></td>
<td>
<p>string vector. A vector of subject identifiers that match the directory names within subjects_dir.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.standard_+3A_measures">measures</code></td>
<td>
<p>vector of strings. Names of the vertex-wise morphometry measures. E.g., c(&quot;area&quot;, &quot;thickness&quot;). Used to construct the names of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.standard_+3A_hemis">hemis</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.standard_+3A_fwhm">fwhm</code></td>
<td>
<p>string. Smoothing as string, e.g. '10' or '25'.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.standard_+3A_agg_fun">agg_fun</code></td>
<td>
<p>function. An R function that aggregates data, typically <code><a href="base.html#topic+max">max</a></code>, mean, min or something similar. Note: this is NOT a string, put the function name without quotes. Defaults to mean.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.standard_+3A_template_subject">template_subject</code></td>
<td>
<p>string. Template subject name, defaults to 'fsaverage'.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.standard_+3A_format">format</code></td>
<td>
<p>string. One of 'mgh', 'mgz', 'curv'. Defaults to 'mgh'.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.standard_+3A_cast">cast</code></td>
<td>
<p>Whether a separate 'hemi' column should exist.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.standard_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to mask the medial wall, i.e., whether the morphometry data for all vertices which are *not* part of the cortex (as defined by the label file &lsquo;label/?h.cortex.label') should be replaced with NA values. In other words, setting this to TRUE will ignore the values of the medial wall between the two hemispheres. If set to true, the mentioned label file needs to exist for the subjects. Also not that the aggregation function will need to be able to cope with NA values if you set this to TRUE. You can use &rsquo;agg_fun_extra_params' if needed to achieve that, depending on the function. Foe example, if you use the <code><a href="base.html#topic+mean">mean</a></code> function, you could set <code>agg_fun_extra_params=list("na.rm"=TRUE)</code> to get the mean of the vertices which are not masked. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="group.multimorph.agg.standard_+3A_agg_fun_extra_params">agg_fun_extra_params</code></td>
<td>
<p>named list, extra parameters to pass to the aggregation function 'agg_fun' besides the loaded morphometry data. This is useful if you have masked the data and need to ignore NA values in the agg_fun.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with aggregated values over all measures and hemis for all subjects, with m columns and n rows, where n is the number of subjects. The m columns are 'subject_id' and '&lt;hemi&gt;.&lt;measure&gt;' (e.g., &quot;lh.thickness&quot;) for all combinations of hemi and measure, the latter contains the aggregated data.
</p>


<h3>See Also</h3>

<p>Other global aggregation functions: 
<code><a href="#topic+group.morph.agg.native">group.morph.agg.native</a>()</code>,
<code><a href="#topic+group.morph.agg.standard">group.morph.agg.standard</a>()</code>,
<code><a href="#topic+group.multimorph.agg.native">group.multimorph.agg.native</a>()</code>
</p>

<hr>
<h2 id='group.surface'>Retrieve surface mesh data for a group of subjects.</h2><span id='topic+group.surface'></span>

<h3>Description</h3>

<p>Retrieve surface mesh data for a group of subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.surface(
  subjects_dir,
  subjects_list,
  surface,
  hemi = "both",
  force_hemilist = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.surface_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="group.surface_+3A_subjects_list">subjects_list</code></td>
<td>
<p>vector of strings. The subject identifiers.</p>
</td></tr>
<tr><td><code id="group.surface_+3A_surface">surface</code></td>
<td>
<p>character string, the surface to load. Something like 'white' or 'pial'.</p>
</td></tr>
<tr><td><code id="group.surface_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the mesh files to be loaded.</p>
</td></tr>
<tr><td><code id="group.surface_+3A_force_hemilist">force_hemilist</code></td>
<td>
<p>logical, whether to force the individual values inside the named return value list to be hemilists (even if the 'hemi' parameter is not set to 'both'). If this is FALSE, the inner values will contain the respective (lh or rh) surface only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of surfaces: Each name is a subject identifier from subjects_list, and the values are hemilists of 'fs.surface' instances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   subjects_list = c("subject1", "subject2");
   surfaces = group.surface(subjects_dir, subjects_list, 'white', "both");

## End(Not run)

</code></pre>

<hr>
<h2 id='groupmorph.split.hemilist'>Split a per-vertex group data matrix for both hemispheres into a hemilist at given index.</h2><span id='topic+groupmorph.split.hemilist'></span>

<h3>Description</h3>

<p>Split a per-vertex group data matrix for both hemispheres into a hemilist at given index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupmorph.split.hemilist(data, numverts_lh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupmorph.split.hemilist_+3A_data">data</code></td>
<td>
<p>numerical matrix or dataframe of per-vertex data, with subjects in columns</p>
</td></tr>
<tr><td><code id="groupmorph.split.hemilist_+3A_numverts_lh">numverts_lh</code></td>
<td>
<p>scalar positive integer, the number of vertices in the left hemisphere mesh (defining the index where to split).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+hemilist">hemilist</a></code> of the data, split at the index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   fsbrain::download_fsaverage(TRUE);
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   subjects_list = c("subject1", "subject2");
   data = group.morph.standard(subjects_dir, subjects_list, "thickness", "lh", fwhm='10');
   numverts_lh = subject.num.verts(subjects_dir, "fsaverage", hemi="lh");
   data_hemilist = groupmorph.split.hemilist(data, numverts_lh);

## End(Not run)

</code></pre>

<hr>
<h2 id='handle.rglactions.highlight.points'>Highlight requested points (if any), but apply given view rotation before doing so.</h2><span id='topic+handle.rglactions.highlight.points'></span>

<h3>Description</h3>

<p>Highlight requested points (if any), but apply given view rotation before doing so.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle.rglactions.highlight.points(
  rglactions,
  angle_rad,
  x,
  y,
  z,
  hemi = "both"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle.rglactions.highlight.points_+3A_hemi">hemi</code></td>
<td>
<p>character string, one of 'lh', 'rh' or 'both'. If lh or rh, plots only points from that hemi (if hemi info is available for the points).</p>
</td></tr>
</table>

<hr>
<h2 id='hasIn'>Check for values in nested named lists</h2><span id='topic+hasIn'></span>

<h3>Description</h3>

<p>Check for values in nested named lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasIn(named_list, listkeys)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hasIn_+3A_named_list">named_list</code></td>
<td>
<p>a named list</p>
</td></tr>
<tr><td><code id="hasIn_+3A_listkeys">listkeys</code></td>
<td>
<p>vector of character strings, the nested names of the lists</p>
</td></tr>
</table>


<h3>Value</h3>

<p>whether a non-NULL value exists at the path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data = list("regions"=list("frontal"=list("thickness"=2.3, "area"=2345)));
   hasIn(data, c("regions", "nosuchregion"));   # FALSE

</code></pre>

<hr>
<h2 id='hemi.lobe.labels'>Compute lobe labels for a single hemi from aparc atlas.</h2><span id='topic+hemi.lobe.labels'></span>

<h3>Description</h3>

<p>Compute lobe labels for a single hemi from aparc atlas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hemi.lobe.labels(
  subjects_dir,
  subject_id,
  hemi,
  include_cingulate = TRUE,
  as_annot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hemi.lobe.labels_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="hemi.lobe.labels_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="hemi.lobe.labels_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name.</p>
</td></tr>
<tr><td><code id="hemi.lobe.labels_+3A_include_cingulate">include_cingulate</code></td>
<td>
<p>logical, whether to include the vertices of the cingulate in the lobes</p>
</td></tr>
<tr><td><code id="hemi.lobe.labels_+3A_as_annot">as_annot</code></td>
<td>
<p>return a hemilist of annotations instead of the return value described in the *value* section</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See <code><a href="#topic+subject.lobes">subject.lobes</a></code> for details.
</p>

<hr>
<h2 id='hemilist'>Create a hemilist from lh and rh data.</h2><span id='topic+hemilist'></span>

<h3>Description</h3>

<p>Simply runs <code>list('lh' = lh_data, 'rh' = rh_data)</code>: A hemilist (short for hemisphere list) is just a named list with entries 'lh' and/or 'rh', which may contain anything. Hemilists are used as parameters and return values in many <code>fsbrain</code> functions. The 'lh' and 'rh' keys typically contain surfaces or vectors of morphometry data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hemilist(lh_data = NULL, rh_data = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hemilist_+3A_lh_data">lh_data</code></td>
<td>
<p>something to wrap, typically some data for a hemisphere, e.g., a vector of morphometry data values.</p>
</td></tr>
<tr><td><code id="hemilist_+3A_rh_data">rh_data</code></td>
<td>
<p>something to wrap, typically some data for a hemisphere, e.g., a vector of morphometry data values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, with the 'lh_data' in the 'lh' key and the 'rh_data' in the 'rh' key.
</p>


<h3>See Also</h3>

<p>Other hemilist functions: 
<code><a href="#topic+hemilist.derive.hemi">hemilist.derive.hemi</a>()</code>,
<code><a href="#topic+hemilist.from.prefixed.list">hemilist.from.prefixed.list</a>()</code>,
<code><a href="#topic+hemilist.get.combined.data">hemilist.get.combined.data</a>()</code>,
<code><a href="#topic+hemilist.unwrap">hemilist.unwrap</a>()</code>,
<code><a href="#topic+hemilist.wrap">hemilist.wrap</a>()</code>,
<code><a href="#topic+is.hemilist">is.hemilist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  lh_data = rnorm(163842, 5.0, 1.0);
  rh_data = rnorm(163842, 5.0, 1.0);
  hl = hemilist(lh_data, rh_data);

</code></pre>

<hr>
<h2 id='hemilist.derive.hemi'>Derive 'hemi' string from the data in a hemilist</h2><span id='topic+hemilist.derive.hemi'></span>

<h3>Description</h3>

<p>Derive 'hemi' string from the data in a hemilist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hemilist.derive.hemi(hemilist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hemilist.derive.hemi_+3A_hemilist">hemilist</code></td>
<td>
<p>hemilist, an existing hemilist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string, one of 'lh', 'rh' or 'both'
</p>


<h3>Note</h3>

<p>See <code><a href="#topic+hemilist">hemilist</a></code> for details.
</p>


<h3>See Also</h3>

<p>Other hemilist functions: 
<code><a href="#topic+hemilist.from.prefixed.list">hemilist.from.prefixed.list</a>()</code>,
<code><a href="#topic+hemilist.get.combined.data">hemilist.get.combined.data</a>()</code>,
<code><a href="#topic+hemilist.unwrap">hemilist.unwrap</a>()</code>,
<code><a href="#topic+hemilist.wrap">hemilist.wrap</a>()</code>,
<code><a href="#topic+hemilist">hemilist</a>()</code>,
<code><a href="#topic+is.hemilist">is.hemilist</a>()</code>
</p>

<hr>
<h2 id='hemilist.from.prefixed.list'>Create a hemilist from a named list with keys prefixed with 'lh_' and 'rh_'.</h2><span id='topic+hemilist.from.prefixed.list'></span>

<h3>Description</h3>

<p>A hemilist is a named list with entries 'lh' and/or 'rh', see <code><a href="#topic+hemilist">hemilist</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hemilist.from.prefixed.list(
  named_list,
  report_ignored = TRUE,
  return_ignored = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hemilist.from.prefixed.list_+3A_named_list">named_list</code></td>
<td>
<p>a named list, the keys must start with 'lh_' or 'rh_' to be assigned to the 'lh' and 'rh' entries of the returned hemilist. Other entries will be ignored.</p>
</td></tr>
<tr><td><code id="hemilist.from.prefixed.list_+3A_report_ignored">report_ignored</code></td>
<td>
<p>logical, whether to print a message with the ignored entries, if any.</p>
</td></tr>
<tr><td><code id="hemilist.from.prefixed.list_+3A_return_ignored">return_ignored</code></td>
<td>
<p>logical, whether to add a key 'ignored' to the returned hemilist, containing the ignored entries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a hemilist
</p>


<h3>See Also</h3>

<p>Other hemilist functions: 
<code><a href="#topic+hemilist.derive.hemi">hemilist.derive.hemi</a>()</code>,
<code><a href="#topic+hemilist.get.combined.data">hemilist.get.combined.data</a>()</code>,
<code><a href="#topic+hemilist.unwrap">hemilist.unwrap</a>()</code>,
<code><a href="#topic+hemilist.wrap">hemilist.wrap</a>()</code>,
<code><a href="#topic+hemilist">hemilist</a>()</code>,
<code><a href="#topic+is.hemilist">is.hemilist</a>()</code>
</p>

<hr>
<h2 id='hemilist.get.combined.data'>Get combined data of hemi list</h2><span id='topic+hemilist.get.combined.data'></span>

<h3>Description</h3>

<p>Get combined data of hemi list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hemilist.get.combined.data(hemi_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hemilist.get.combined.data_+3A_hemi_list">hemi_list</code></td>
<td>
<p>named list, can have entries 'lh' and/or 'rh', see <code><a href="#topic+hemilist">hemilist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data combined with <code><a href="base.html#topic+c">c</a></code>, or NULL if both entries are NULL.
</p>


<h3>See Also</h3>

<p>Other hemilist functions: 
<code><a href="#topic+hemilist.derive.hemi">hemilist.derive.hemi</a>()</code>,
<code><a href="#topic+hemilist.from.prefixed.list">hemilist.from.prefixed.list</a>()</code>,
<code><a href="#topic+hemilist.unwrap">hemilist.unwrap</a>()</code>,
<code><a href="#topic+hemilist.wrap">hemilist.wrap</a>()</code>,
<code><a href="#topic+hemilist">hemilist</a>()</code>,
<code><a href="#topic+is.hemilist">is.hemilist</a>()</code>
</p>

<hr>
<h2 id='hemilist.unwrap'>Unwrap hemi data from a named hemi list.</h2><span id='topic+hemilist.unwrap'></span>

<h3>Description</h3>

<p>Unwrap hemi data from a named hemi list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hemilist.unwrap(hemi_list, hemi = NULL, allow_null_list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hemilist.unwrap_+3A_hemi_list">hemi_list</code></td>
<td>
<p>named list, can have entries 'lh' and/or 'rh', see <code><a href="#topic+hemilist">hemilist</a></code>.</p>
</td></tr>
<tr><td><code id="hemilist.unwrap_+3A_hemi">hemi</code></td>
<td>
<p>character string, the hemi data name to retrieve from the list. Can be NULL if the list only has a single entry.</p>
</td></tr>
<tr><td><code id="hemilist.unwrap_+3A_allow_null_list">allow_null_list</code></td>
<td>
<p>logical, whether to silently return NULL instead of raising an error if 'hemi_list' is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data
</p>


<h3>See Also</h3>

<p>Other hemilist functions: 
<code><a href="#topic+hemilist.derive.hemi">hemilist.derive.hemi</a>()</code>,
<code><a href="#topic+hemilist.from.prefixed.list">hemilist.from.prefixed.list</a>()</code>,
<code><a href="#topic+hemilist.get.combined.data">hemilist.get.combined.data</a>()</code>,
<code><a href="#topic+hemilist.wrap">hemilist.wrap</a>()</code>,
<code><a href="#topic+hemilist">hemilist</a>()</code>,
<code><a href="#topic+is.hemilist">is.hemilist</a>()</code>
</p>

<hr>
<h2 id='hemilist.wrap'>Wrap data into a named hemi list.</h2><span id='topic+hemilist.wrap'></span>

<h3>Description</h3>

<p>Wrap data into a named hemi list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hemilist.wrap(data, hemi, hemilist = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hemilist.wrap_+3A_data">data</code></td>
<td>
<p>something to wrap, typically some data for a hemisphere, e.g., a vector of morphometry data values. If NULL, the name will not be created.</p>
</td></tr>
<tr><td><code id="hemilist.wrap_+3A_hemi">hemi</code></td>
<td>
<p>character string, one of 'lh' or 'rh'. The name to use for the data in the returned list.</p>
</td></tr>
<tr><td><code id="hemilist.wrap_+3A_hemilist">hemilist</code></td>
<td>
<p>optional <code><a href="#topic+hemilist">hemilist</a></code>, an existing hemilist to add the entry to. If left at the default value 'NULL', a new list will be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+hemilist">hemilist</a></code>: a named list, with the 'data' in the name given by parameter 'hemi'
</p>


<h3>See Also</h3>

<p>Other hemilist functions: 
<code><a href="#topic+hemilist.derive.hemi">hemilist.derive.hemi</a>()</code>,
<code><a href="#topic+hemilist.from.prefixed.list">hemilist.from.prefixed.list</a>()</code>,
<code><a href="#topic+hemilist.get.combined.data">hemilist.get.combined.data</a>()</code>,
<code><a href="#topic+hemilist.unwrap">hemilist.unwrap</a>()</code>,
<code><a href="#topic+hemilist">hemilist</a>()</code>,
<code><a href="#topic+is.hemilist">is.hemilist</a>()</code>
</p>

<hr>
<h2 id='hemlist.ensure.contains'>title Ensure an key for a hemilist exists.</h2><span id='topic+hemlist.ensure.contains'></span>

<h3>Description</h3>

<p>title Ensure an key for a hemilist exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hemlist.ensure.contains(hemilist, required_hemi, error_tag = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hemlist.ensure.contains_+3A_hemilist">hemilist</code></td>
<td>
<p>a hemilist</p>
</td></tr>
<tr><td><code id="hemlist.ensure.contains_+3A_required_hemi">required_hemi</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'.</p>
</td></tr>
</table>

<hr>
<h2 id='highlight.points.spheres'>Draw small 3D spheres at given points.</h2><span id='topic+highlight.points.spheres'></span>

<h3>Description</h3>

<p>Draw small 3D spheres at given points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highlight.points.spheres(coords, color = "#FF0000", radius = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="highlight.points.spheres_+3A_coords">coords</code></td>
<td>
<p>double vector or nx3 double matrix, the xyz point coordinates.</p>
</td></tr>
<tr><td><code id="highlight.points.spheres_+3A_color">color</code></td>
<td>
<p>the sphere color, like <code>'#FF0000'</code> or <code>"red"</code>.</p>
</td></tr>
<tr><td><code id="highlight.points.spheres_+3A_radius">radius</code></td>
<td>
<p>double, the sphere radius</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other 3d utility functions: 
<code><a href="#topic+highlight.vertices.spheres">highlight.vertices.spheres</a>()</code>,
<code><a href="#topic+vertex.coords">vertex.coords</a>()</code>
</p>

<hr>
<h2 id='highlight.vertices.on.subject'>Highlight vertices given by index on a subject's meshes by coloring faces.</h2><span id='topic+highlight.vertices.on.subject'></span>

<h3>Description</h3>

<p>Highlight vertices given by index on a subject's meshes by coloring faces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highlight.vertices.on.subject(
  subjects_dir,
  vis_subject_id,
  verts_lh = NULL,
  verts_rh = NULL,
  surface = "white",
  views = c("t4"),
  rgloptions = rglo(),
  rglactions = list(),
  color_bg = "#FEFEFE",
  color_verts_lh = "#FF0000",
  color_verts_rh = "#FF4500",
  k = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="highlight.vertices.on.subject_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject_+3A_vis_subject_id">vis_subject_id</code></td>
<td>
<p>string. The subject identifier from which to obtain the surface for data visualization. Example: 'fsaverage'.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject_+3A_verts_lh">verts_lh</code></td>
<td>
<p>integer vector, the indices of left hemisphere vertices.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject_+3A_verts_rh">verts_rh</code></td>
<td>
<p>integer vector, the indices of right hemisphere vertices.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject_+3A_color_bg">color_bg</code></td>
<td>
<p>background color.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject_+3A_color_verts_lh">color_verts_lh</code></td>
<td>
<p>vector of colors to visualize on the left hemisphere surface. Length must match number of vertices in 'verts_lh', or be a single color.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject_+3A_color_verts_rh">color_verts_rh</code></td>
<td>
<p>vector of colors to visualize on the right hemisphere surface. Length must match number of vertices in 'verts_rh', or be a single color.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject_+3A_k">k</code></td>
<td>
<p>integer, radius to extend neighborhood (for better visibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization.
</p>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>
<p>Other surface visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   highlight.vertices.on.subject(subjects_dir, 'subject1',
     verts_lh=c(5000, 100000), verts_rh=c(300, 66666), views="si");

## End(Not run)

</code></pre>

<hr>
<h2 id='highlight.vertices.on.subject.spheres'>Highlight vertices given by index on a subject's meshes by coloring faces.</h2><span id='topic+highlight.vertices.on.subject.spheres'></span>

<h3>Description</h3>

<p>Highlight vertices given by index on a subject's meshes by coloring faces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highlight.vertices.on.subject.spheres(
  subjects_dir,
  vis_subject_id,
  vertices,
  surface = "white",
  patch_size = 25,
  show_patch = TRUE,
  style = "glass2",
  export_img = NULL,
  sphere_colors = c("#FF0000"),
  sphere_radius = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="highlight.vertices.on.subject.spheres_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject.spheres_+3A_vis_subject_id">vis_subject_id</code></td>
<td>
<p>string. The subject identifier from which to obtain the surface for data visualization. Example: 'fsaverage'.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject.spheres_+3A_vertices">vertices</code></td>
<td>
<p>positive integer vector, the vertex indices over both hemispheres. Alternative to using verts_lh and verts_rh parameters, only one of them must be used at once.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject.spheres_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject.spheres_+3A_patch_size">patch_size</code></td>
<td>
<p>double, geodesic radius in which to draw a patch on the mesh around the verts. Pass <code>NULL</code> to disable.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject.spheres_+3A_show_patch">show_patch</code></td>
<td>
<p>logical (or a vector with one logical value per entry in 'vertices'), whether to show colored geodesic patches at the highlighted vertices.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject.spheres_+3A_style">style</code></td>
<td>
<p>character string or rgl rendering style, see <code><a href="#topic+get.rglstyle">get.rglstyle</a></code>.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject.spheres_+3A_export_img">export_img</code></td>
<td>
<p>character string, the path to the output image if you want to export a high-quality image, NULL if you want live visualization instead.</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject.spheres_+3A_sphere_colors">sphere_colors</code></td>
<td>
<p>the sphere colors like '#FF0000', can be a single one for all or one per sphere</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject.spheres_+3A_sphere_radius">sphere_radius</code></td>
<td>
<p>double, a single radius for all spheres</p>
</td></tr>
<tr><td><code id="highlight.vertices.on.subject.spheres_+3A_...">...</code></td>
<td>
<p>extra parameters passed on to <code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a></code>. Use this to set a custom colormap etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization. If export_img is set, the export return value is returned instead.
</p>


<h3>Note</h3>

<p>If no patches are visualized, the color used for the brain can be set with <code>options("fsbrain.brain_na_color"="#FF0000")</code>.
</p>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>
<p>Other surface visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_fsaverage(T);
   subjects_dir = fsaverage.path();
   mkco = list('colFn'=viridis::viridis, 'n'=300);
   # Ex.1: highlight with patches and custom colormap:
   highlight.vertices.on.subject.spheres(subjects_dir, 'fsaverage',
     vertices=c(300, 5000, 100000), makecmap_options = mkco);
   # Ex.2: show patches on some (red) vertices, not on blue ones:
   highlight.vertices.on.subject.spheres(subjects_dir, 'fsaverage',
     vertices=c(300, 5000, 100000, 300000), show_patch = c(T,F,T,F),
     sphere_colors = c("red", "blue", "red", "blue"));

## End(Not run)

</code></pre>

<hr>
<h2 id='highlight.vertices.spheres'>Draw small 3D spheres at given brain mesh vertices. Supports full brain (2 meshes) as well.</h2><span id='topic+highlight.vertices.spheres'></span>

<h3>Description</h3>

<p>Draw small 3D spheres at given brain mesh vertices. Supports full brain (2 meshes) as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highlight.vertices.spheres(surface, vertices, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="highlight.vertices.spheres_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance, see <code><a href="#topic+subject.surface">subject.surface</a></code> function. Can also be a hemilist of surfaces, in which case the vertices can be indices over both meshes (in range <code>1..(nv(lh)+nv(rh))</code>).</p>
</td></tr>
<tr><td><code id="highlight.vertices.spheres_+3A_vertices">vertices</code></td>
<td>
<p>vector of positive integers, the vertex indices. Values which are outside of the valid indices for the surface will be silently ignored, making it easier to work with the two hemispheres.</p>
</td></tr>
<tr><td><code id="highlight.vertices.spheres_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="#topic+highlight.points.spheres">highlight.points.spheres</a></code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function will draw into the current window and add to the scene, so it can be called after visualizing a mesh. See the example.
</p>


<h3>See Also</h3>

<p>Other 3d utility functions: 
<code><a href="#topic+highlight.points.spheres">highlight.points.spheres</a>()</code>,
<code><a href="#topic+vertex.coords">vertex.coords</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
lh_surf = subject.surface('~/data/study1', 'subject1',
 surface = "white", hemi = "lh");
vis.fs.surface(lh_surf, style="semitransparent");
highlight.vertices.spheres(lh_surf,
  vertices = c(3225L, 4300L, 5500L),
  color = c("green", "blue", "red"));

## End(Not run)

</code></pre>

<hr>
<h2 id='hull.retain.along.axis'>Copy the first *n* foreground voxel values.</h2><span id='topic+hull.retain.along.axis'></span>

<h3>Description</h3>

<p>Copy the first *n* foreground voxel values along the axis and direction from the volume to the hull, thus adding foreground voxels to the hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hull.retain.along.axis(
  volume,
  hull,
  dim_check = 2L,
  upwards = TRUE,
  thickness = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hull.retain.along.axis_+3A_volume">volume</code></td>
<td>
<p>numeric 3d array, the full source volume.</p>
</td></tr>
<tr><td><code id="hull.retain.along.axis_+3A_hull">hull</code></td>
<td>
<p>numeric 3d array, the input hull volume.</p>
</td></tr>
<tr><td><code id="hull.retain.along.axis_+3A_dim_check">dim_check</code></td>
<td>
<p>integer, the array dimension to use. Must be 1L, 2L or 3L.</p>
</td></tr>
<tr><td><code id="hull.retain.along.axis_+3A_upwards">upwards</code></td>
<td>
<p>logical, whether to use upwards direction (increasing indices) in the array dimension</p>
</td></tr>
<tr><td><code id="hull.retain.along.axis_+3A_thickness">thickness</code></td>
<td>
<p>integer, the width of the border in voxels, i.e., how many of the foreground voxels to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric 3d array, the updated hull volume.
</p>

<hr>
<h2 id='image.remap.color'>Remap a color in an image, typically used to set the background color to transparent.</h2><span id='topic+image.remap.color'></span>

<h3>Description</h3>

<p>Offers 2 algorithm: remap color by flood-filling from a given pixel, or remap a hardcoded color throughout the entire image. Provide one of 'source_color' or 'source_point' by setting the other to NULL. If both are given, source_color takes precedence and source_point is silently ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'remap.color'
image(
  source_img,
  source_color = NULL,
  source_point = "+1+1",
  target_color = "none"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image.remap.color_+3A_source_color">source_color</code></td>
<td>
<p>the source color that should be replaced in the whole image. Set to NULL to disable.</p>
</td></tr>
<tr><td><code id="image.remap.color_+3A_source_point">source_point</code></td>
<td>
<p>the source pixel in which to start the flood filling. Set to NULL to disable.</p>
</td></tr>
<tr><td><code id="image.remap.color_+3A_target_color">target_color</code></td>
<td>
<p>an image magick color string, use 'none' for transparency. Only used with flood fill.</p>
</td></tr>
</table>

<hr>
<h2 id='images.annotate'>Annotate image with text.</h2><span id='topic+images.annotate'></span>

<h3>Description</h3>

<p>Annotate image with text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>images.annotate(images, annotations, do_extend = TRUE, background = "white")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="images.annotate_+3A_images">images</code></td>
<td>
<p>vector of magick images</p>
</td></tr>
<tr><td><code id="images.annotate_+3A_annotations">annotations</code></td>
<td>
<p>vector of character strings, the strings to print onto the tiles</p>
</td></tr>
<tr><td><code id="images.annotate_+3A_do_extend">do_extend</code></td>
<td>
<p>logical, whether to add the space for the annotation text below the existing image tile</p>
</td></tr>
<tr><td><code id="images.annotate_+3A_background">background</code></td>
<td>
<p>color string, like 'white' or '#00FF00'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of magick images, the annotated images
</p>

<hr>
<h2 id='images.dimmax'>Compute max width and height of magick images.</h2><span id='topic+images.dimmax'></span>

<h3>Description</h3>

<p>Compute max width and height of magick images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>images.dimmax(images)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="images.dimmax_+3A_images">images</code></td>
<td>
<p>a vector/stack of magick images. See <code>magick::image_blank</code> or other methods to get one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries 'width' and 'height'
</p>

<hr>
<h2 id='images.rescale.to.max.canvas'>Rescale all images canvas to match the largest one.</h2><span id='topic+images.rescale.to.max.canvas'></span>

<h3>Description</h3>

<p>Rescale all images canvas to match the largest one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>images.rescale.to.max.canvas(images, background = "white")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="images.rescale.to.max.canvas_+3A_images">images</code></td>
<td>
<p>vector of magick images</p>
</td></tr>
<tr><td><code id="images.rescale.to.max.canvas_+3A_background">background</code></td>
<td>
<p>color string, like 'white' or '#00FF00'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of magick images, the rescaled images
</p>

<hr>
<h2 id='images.same.height'>Extent all images to the height of the image with maximal height.</h2><span id='topic+images.same.height'></span>

<h3>Description</h3>

<p>Extent all images to the height of the image with maximal height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>images.same.height(images, background_color = "white")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="images.same.height_+3A_images">images</code></td>
<td>
<p>a vector/stack of magick images. See <code>magick::image_blank</code> or other methods to get one.</p>
</td></tr>
<tr><td><code id="images.same.height_+3A_background_color">background_color</code></td>
<td>
<p>hex color string, the background color to use if the images have different sizes and one needs to be extended. Do not use color names like 'gray', which differ between R and magick.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector/stack of magick images, all with the same height.
</p>

<hr>
<h2 id='images.same.width'>Extent all images to the width of the image with maximal width.</h2><span id='topic+images.same.width'></span>

<h3>Description</h3>

<p>Extent all images to the width of the image with maximal width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>images.same.width(images, background_color = "white")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="images.same.width_+3A_images">images</code></td>
<td>
<p>a vector/stack of magick images. See <code>magick::image_blank</code> or other methods to get one.</p>
</td></tr>
<tr><td><code id="images.same.width_+3A_background_color">background_color</code></td>
<td>
<p>hex color string, the background color to use if the images have different sizes and one needs to be extended. Do not use color names like 'gray', which differ between R and magick.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector/stack of magick images, all with the same width.
</p>

<hr>
<h2 id='is.fs.coloredmesh'>Check whether object is an fs.coloredmesh (S3)</h2><span id='topic+is.fs.coloredmesh'></span>

<h3>Description</h3>

<p>Check whether object is an fs.coloredmesh (S3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fs.coloredmesh(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.fs.coloredmesh_+3A_x">x</code></td>
<td>
<p>any 'R' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if its argument is a coloredmesh (that is, has &quot;fs.coloredmesh&quot; amongst its classes) and FALSE otherwise.
</p>

<hr>
<h2 id='is.fs.coloredvoxels'>Check whether object is an fs.coloredvoxels instance (S3)</h2><span id='topic+is.fs.coloredvoxels'></span>

<h3>Description</h3>

<p>Check whether object is an fs.coloredvoxels instance (S3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fs.coloredvoxels(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.fs.coloredvoxels_+3A_x">x</code></td>
<td>
<p>any 'R' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if its argument is a fs.coloredvoxels instance (that is, has &quot;fs.coloredvoxels&quot; among its classes) and FALSE otherwise.
</p>

<hr>
<h2 id='is.fsbrain'>Check whether object is an fsbrain (S3)</h2><span id='topic+is.fsbrain'></span>

<h3>Description</h3>

<p>Check whether object is an fsbrain (S3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fsbrain(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.fsbrain_+3A_x">x</code></td>
<td>
<p>any 'R' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if its argument is an fsbrain (that is, has &quot;fsbrain&quot; amongst its classes) and FALSE otherwise.
</p>

<hr>
<h2 id='is.hemilist'>Check whether x is a hemilist</h2><span id='topic+is.hemilist'></span>

<h3>Description</h3>

<p>A hemilist is a named list with entries 'lh' and/or 'rh', see <code><a href="#topic+hemilist">hemilist</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.hemilist(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.hemilist_+3A_x">x</code></td>
<td>
<p>any R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>whether 'x' is a hemilist
</p>


<h3>See Also</h3>

<p>Other hemilist functions: 
<code><a href="#topic+hemilist.derive.hemi">hemilist.derive.hemi</a>()</code>,
<code><a href="#topic+hemilist.from.prefixed.list">hemilist.from.prefixed.list</a>()</code>,
<code><a href="#topic+hemilist.get.combined.data">hemilist.get.combined.data</a>()</code>,
<code><a href="#topic+hemilist.unwrap">hemilist.unwrap</a>()</code>,
<code><a href="#topic+hemilist.wrap">hemilist.wrap</a>()</code>,
<code><a href="#topic+hemilist">hemilist</a>()</code>
</p>

<hr>
<h2 id='is.Triangles3D'>Check whether object is a Triangles3D instance</h2><span id='topic+is.Triangles3D'></span>

<h3>Description</h3>

<p>Check whether object is a Triangles3D instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Triangles3D(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.Triangles3D_+3A_x">x</code></td>
<td>
<p>any 'R' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if its argument is a Triangles3D instance (that is, has &quot;Triangles3D&quot; amongst its classes) and FALSE otherwise.
</p>

<hr>
<h2 id='label.border'>Compute border of a label.</h2><span id='topic+label.border'></span>

<h3>Description</h3>

<p>Compute the border of a label (i.e., a subset of the vertices of a mesh). The border thickness can be specified. Useful to draw the outline of a region, e.g., a significant cluster on the surface or a part of a ROI from a brain parcellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label.border(
  surface_mesh,
  label,
  inner_only = TRUE,
  expand_inwards = 0L,
  derive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label.border_+3A_surface_mesh">surface_mesh</code></td>
<td>
<p>surface mesh, as loaded by <code><a href="#topic+subject.surface">subject.surface</a></code> or <code><a href="freesurferformats.html#topic+read.fs.surface">read.fs.surface</a></code>.</p>
</td></tr>
<tr><td><code id="label.border_+3A_label">label</code></td>
<td>
<p>instance of class 'fs.label' or an integer vector, the vertex indices. This function only makes sense if they form a patch on the surface, but that is not checked.</p>
</td></tr>
<tr><td><code id="label.border_+3A_inner_only">inner_only</code></td>
<td>
<p>logical, whether only faces consisting only of label_vertices should be considered to be label faces. If FALSE, faces containing at least one label vertex will be used. Defaults to TRUE. Leave this alone if in doubt, especially if you want to draw several label borders which are directly adjacent on the surface.</p>
</td></tr>
<tr><td><code id="label.border_+3A_expand_inwards">expand_inwards</code></td>
<td>
<p>integer, border thickness extension. If given, once the border has been computed, it is extended by the given graph distance. It is guaranteed that the border only extends inwards, i.e., it will never extend to vertices which are not part of the label.</p>
</td></tr>
<tr><td><code id="label.border_+3A_derive">derive</code></td>
<td>
<p>logical, whether the returned result should also include the border edges and faces in addition to the border vertices. Takes longer if requested, defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the border as a list with the following entries: 'vertices': integer vector, the vertex indices of the border. Iff the parameter 'derive' is TRUE, the following two additional fields are included: 'edges': integer matrix of size (n, 2) for n edges. Each row defines an edge by its start and target vertex. 'faces': integer vector, the face indices of the border.
</p>


<h3>See Also</h3>

<p>Other surface mesh functions: 
<code><a href="#topic+face.edges">face.edges</a>()</code>,
<code><a href="#topic+mesh.vertex.included.faces">mesh.vertex.included.faces</a>()</code>,
<code><a href="#topic+mesh.vertex.neighbors">mesh.vertex.neighbors</a>()</code>,
<code><a href="#topic+subject.surface">subject.surface</a>()</code>,
<code><a href="#topic+vis.path.along.verts">vis.path.along.verts</a>()</code>
</p>

<hr>
<h2 id='label.border.fast'>Compute border vertices of a label using Rvcg.</h2><span id='topic+label.border.fast'></span>

<h3>Description</h3>

<p>Compute border vertices of a label using Rvcg.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label.border.fast(surface_mesh, label)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label.border.fast_+3A_surface_mesh">surface_mesh</code></td>
<td>
<p>an fs.surface instance, see <code><a href="#topic+subject.surface">subject.surface</a></code>.</p>
</td></tr>
<tr><td><code id="label.border.fast_+3A_label">label</code></td>
<td>
<p>an fs.label instance (see <code><a href="#topic+subject.label">subject.label</a></code>) or an integer vector, the vertex indices of the label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entry 'vertices' containing an integer vector with the indices of the border vertices.
</p>


<h3>Note</h3>

<p>This is faster than using the <code><a href="#topic+label.border">label.border</a></code> function, but it does not fully match its functionality (some parameter are not implemented for this function), and it requires the <code>Rvcg</code> package, which is an optional dependency.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+label.border">label.border</a></code>, which is slower but provides more options and does not require Rvcg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sjd = fsaverage.path(T);
sj = "fsaverage";
mesh = subject.surface(sjd, sj, hemi="lh");
lab = subject.label(sjd, sj, "cortex", hemi = "lh");
col = rep("white", nrow(mesh$vertices));
bd = fsbrain:::label.border.fast &lt;- function(surface_mesh, label);
col[bd$vertices] = "red";
vis.fs.surface(mesh, col=col);

## End(Not run)

</code></pre>

<hr>
<h2 id='label.colFn'>A simple colormap function for binary colors.</h2><span id='topic+label.colFn'></span>

<h3>Description</h3>

<p>Useful for plotting labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label.colFn(n = 2L, col_a = "#228B22", col_b = "#FFFFFF")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label.colFn_+3A_n">n</code></td>
<td>
<p>positive integer, the number of colors. Must be 1 or 2 for this function.</p>
</td></tr>
<tr><td><code id="label.colFn_+3A_col_a">col_a</code></td>
<td>
<p>color string, the foreground color</p>
</td></tr>
<tr><td><code id="label.colFn_+3A_col_b">col_b</code></td>
<td>
<p>color string, the background color</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of 'n' RGB colorstrings
</p>

<hr>
<h2 id='label.colFn.inv'>A simple colormap function for binary colors.</h2><span id='topic+label.colFn.inv'></span>

<h3>Description</h3>

<p>Useful for plotting labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label.colFn.inv(n = 2L, col_a = "#228B22", col_b = "#FFFFFF")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label.colFn.inv_+3A_n">n</code></td>
<td>
<p>positive integer, the number of colors. Must be 1 or 2 for this function.</p>
</td></tr>
<tr><td><code id="label.colFn.inv_+3A_col_a">col_a</code></td>
<td>
<p>color string, the foreground color</p>
</td></tr>
<tr><td><code id="label.colFn.inv_+3A_col_b">col_b</code></td>
<td>
<p>color string, the background color</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of 'n' RGB colorstrings
</p>

<hr>
<h2 id='label.from.annotdata'>Extract a region from an annotation as a label.</h2><span id='topic+label.from.annotdata'></span>

<h3>Description</h3>

<p>The returned label can be used to mask morphometry data, e.g., to set the values of a certain region to 'NaN' or to extract only values from a certain region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label.from.annotdata(
  annotdata,
  region,
  return_one_based_indices = TRUE,
  invert = FALSE,
  error_on_invalid_region = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label.from.annotdata_+3A_annotdata">annotdata</code></td>
<td>
<p>annotation. An annotation for one hemisphere, as returned by <code><a href="#topic+subject.annot">subject.annot</a></code>. This must be the loaded data, not a path to a file.</p>
</td></tr>
<tr><td><code id="label.from.annotdata_+3A_region">region</code></td>
<td>
<p>string. A valid region name for the annotation, i.e., one of the regions of the atlas used to create the annotation.</p>
</td></tr>
<tr><td><code id="label.from.annotdata_+3A_return_one_based_indices">return_one_based_indices</code></td>
<td>
<p>logical. Whether the indices should be 1-based. Indices are stored zero-based in label files, but R uses 1-based indices. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="label.from.annotdata_+3A_invert">invert</code></td>
<td>
<p>logical. If TRUE, return the indices of all vertices which are NOT part of the region. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="label.from.annotdata_+3A_error_on_invalid_region">error_on_invalid_region</code></td>
<td>
<p>logical. Whether to throw an error if the given region does not appear in the region list of the annotation. If set to FALSE, this will be ignored and an empty vertex list will be returned. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector with label data: the list of vertex indices in the label. See 'return_one_based_indices' for important information.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>

<hr>
<h2 id='label.to.annot'>Merge several labels into an annotation</h2><span id='topic+label.to.annot'></span>

<h3>Description</h3>

<p>Merge several labels and a colortable into an annotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label.to.annot(
  label_vertices_by_region,
  num_vertices_in_surface,
  colortable_df = NULL,
  index_of_unknown_region = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label.to.annot_+3A_label_vertices_by_region">label_vertices_by_region</code></td>
<td>
<p>named list of integer vectors, the keys are strings which define region names, and the values are integer vectors: the vertex indices of the region.</p>
</td></tr>
<tr><td><code id="label.to.annot_+3A_num_vertices_in_surface">num_vertices_in_surface</code></td>
<td>
<p>integer, total number of vertices in the surface mesh</p>
</td></tr>
<tr><td><code id="label.to.annot_+3A_colortable_df">colortable_df</code></td>
<td>
<p>NULL or dataframe, a colortable. It must contain the columns 'struct_name', 'r', 'g', 'b', and 'a'. All other columns will be derived if missing. The entries in 'struct_name' must match keys from the 'label_vertices_by_region' parameter. There must be one more row in here than there are labels. This row identifies the 'unknown' region (see also parameter 'index_of_unknown_region'). If NULL, a colortable will be auto-generated.</p>
</td></tr>
<tr><td><code id="label.to.annot_+3A_index_of_unknown_region">index_of_unknown_region</code></td>
<td>
<p>positive integer, the index of the row in 'colortable_df' that defines the 'unknown' or 'background' region to which all vertices will be assigned which are *not* part of any of the given labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an annotation, see <code><a href="freesurferformats.html#topic+read.fs.annot">read.fs.annot</a></code> for details.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create two labels. Real-word labels would have more vertices, of course.
  label1 = c(46666, 467777);
  label2 = c(99888, 99889);
  label_vertices = list("region1"=label1, "region2"=label2);
  colortable_df = data.frame("struct_index"=seq(0, 2),
   "struct_name"=c("unknown", "region1", "region2"),
   "r"=c(255L, 255L, 0L), "g"=c(255L, 0L, 255L), "b"=c(255L, 0L, 0L), "a"=c(0L, 0L, 0L));
  annot = label.to.annot(label_vertices, 100000, colortable_df);

</code></pre>

<hr>
<h2 id='labeldata.from.mask'>Create labeldata from a mask.</h2><span id='topic+labeldata.from.mask'></span>

<h3>Description</h3>

<p>Create labeldata from a mask. This function is trivial and only calls <code><a href="base.html#topic+which">which</a></code> after performing basic sanity checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labeldata.from.mask(mask, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labeldata.from.mask_+3A_mask">mask</code></td>
<td>
<p>a logical vector</p>
</td></tr>
<tr><td><code id="labeldata.from.mask_+3A_invert">invert</code></td>
<td>
<p>Whether to report the inverse the mask before determining the indices. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>labeldata. The list of indices which are TRUE in the mask (or the ones which FALSE if 'invert' is TRUE).
</p>


<h3>See Also</h3>

<p>Other label data functions: 
<code><a href="#topic+group.label">group.label</a>()</code>,
<code><a href="#topic+mask.from.labeldata.for.hemi">mask.from.labeldata.for.hemi</a>()</code>,
<code><a href="#topic+subject.label">subject.label</a>()</code>
</p>

<hr>
<h2 id='limit_fun'>Get data limiting function.</h2><span id='topic+limit_fun'></span>

<h3>Description</h3>

<p>Get data limiting function to use in rglactions as 'trans_fun' to transform data. This is typically used to limit the colorbar in a plot to a certain range. This is similar to <code><a href="#topic+clip.data">clip.data</a></code> or <code><a href="#topic+clip_fun">clip_fun</a></code>, but uses absolute values instead of percentiles to clip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limit_fun(vmin, vmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="limit_fun_+3A_vmin">vmin</code></td>
<td>
<p>numerical scalar, the lower border. Data values below this will be set to vmin in the return value.</p>
</td></tr>
<tr><td><code id="limit_fun_+3A_vmax">vmax</code></td>
<td>
<p>numerical scalar, the upper border. Data values above this will be set to vmax in the return value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that takes as argument the data, and clips it to the requested range. I.e., values outside the range will be set to the closest border value ('vmin' or 'vmax'). Designed to be used as <code>rglactions$trans_fun</code> in vis functions, to limit the colorbar and data range.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rglactions">rglactions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   rglactions = list("trans_fun"=limit_fun(2,3));

</code></pre>

<hr>
<h2 id='limit_fun_na'>Get data limiting function to NA.</h2><span id='topic+limit_fun_na'></span>

<h3>Description</h3>

<p>Get data limiting function to use in <code><a href="#topic+rglactions">rglactions</a></code> as 'trans_fun' to transform data. This is typically used to limit the colorbar in a plot to a certain range. This is similar to <code><a href="#topic+clip.data">clip.data</a></code>, but uses absolute values instead of percentiles to clip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limit_fun_na(vmin, vmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="limit_fun_na_+3A_vmin">vmin</code></td>
<td>
<p>numerical scalar, the lower border. Data values below this will be set to 'NA' in the return value.</p>
</td></tr>
<tr><td><code id="limit_fun_na_+3A_vmax">vmax</code></td>
<td>
<p>numerical scalar, the upper border. Data values above this will be set to 'NA' in the return value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that takes as argument the data, and clips it to the requested range. I.e., values outside the range will be set to 'NA'. Designed to be used as <code>rglactions$trans_fun</code> in vis functions, to limit the colorbar and data range.
</p>


<h3>Note</h3>

<p>This is useful for thresholding stuff like t-value maps. All values outside the range will be displayed as the background color.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+limit_fun_na_inside">limit_fun_na_inside</a></code> which will set the values inside the range to 'NA'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   rglactions = list("trans_fun"=limit_fun_na(2,3));

</code></pre>

<hr>
<h2 id='limit_fun_na_inside'>Get data limiting function, setting values inside range to NA.</h2><span id='topic+limit_fun_na_inside'></span>

<h3>Description</h3>

<p>Get data limiting function to use in <code><a href="#topic+rglactions">rglactions</a></code> as 'trans_fun' to transform data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limit_fun_na_inside(vmin, vmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="limit_fun_na_inside_+3A_vmin">vmin</code></td>
<td>
<p>numerical scalar, the lower border. Data values between this and vmax will be set to 'NA' in the return value.</p>
</td></tr>
<tr><td><code id="limit_fun_na_inside_+3A_vmax">vmax</code></td>
<td>
<p>numerical scalar, the upper border. See 'vmin'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that takes as argument the data, and clips it to the requested range. I.e., values inside the range will be set to 'NA'. Designed to be used as <code>rglactions$trans_fun</code> in vis functions.
</p>


<h3>Note</h3>

<p>This is useful for thresholding data plotted with a background. All values inside the range will set to NA and be transparent, and thus be displayed as the background color.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+limit_fun_na">limit_fun_na</a></code> which will set the values outside the range to 'NA'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   rglactions = list("trans_fun"=limit_fun_na_inside(2,3));

</code></pre>

<hr>
<h2 id='list_optional_data'>Get file names available in package cache.</h2><span id='topic+list_optional_data'></span>

<h3>Description</h3>

<p>Get file names of optional data files which are available in the local package cache. You can access these files with get_optional_data_file().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_optional_data()
</code></pre>


<h3>Value</h3>

<p>vector of strings. The file names available, relative to the package cache.
</p>

<hr>
<h2 id='magick.grid'>Arrange a multi-frame ImageMagick image into a grid.</h2><span id='topic+magick.grid'></span>

<h3>Description</h3>

<p>Arrange all subimages of the given ImageMagick image into a single 2D image, that contains the subimages arranged in a grid-like structure. Consecutive subimages will be appear the same row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magick.grid(
  magickimage,
  per_row = 5L,
  per_col = NULL,
  background_color = "#000000"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="magick.grid_+3A_magickimage">magickimage</code></td>
<td>
<p>an ImageMagick image</p>
</td></tr>
<tr><td><code id="magick.grid_+3A_per_row">per_row</code></td>
<td>
<p>positive integer, the number of subimages per row in the output image. If 'NULL', automatically computed from the number of slices and the 'per_col' parameter.</p>
</td></tr>
<tr><td><code id="magick.grid_+3A_per_col">per_col</code></td>
<td>
<p>positive integer, the number of subimages per column in the output image. If 'NULL', automatically computed from the number of slices and the 'per_row' parameter.</p>
</td></tr>
<tr><td><code id="magick.grid_+3A_background_color">background_color</code></td>
<td>
<p>string, a valid ImageMagick color string such as &quot;white&quot; or &quot;#000080&quot;. The color to use when extending images (e.g., when creating the border). Defaults to black.</p>
</td></tr>
</table>

<hr>
<h2 id='mask.from.labeldata.for.hemi'>Create a binary mask from labels.</h2><span id='topic+mask.from.labeldata.for.hemi'></span>

<h3>Description</h3>

<p>Create a binary mask for the data of a single hemisphere from one or more labels. A label contains the vertex indices which are part of it, but often having a mask in more convenient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask.from.labeldata.for.hemi(
  labels,
  num_vertices_in_hemi,
  invert_labels = FALSE,
  existing_mask = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mask.from.labeldata.for.hemi_+3A_labels">labels</code></td>
<td>
<p>list of labels. A label is just a vector of vertex indices. It can be created manually, but is typically loaded from a label file using <code><a href="#topic+subject.label">subject.label</a></code>.</p>
</td></tr>
<tr><td><code id="mask.from.labeldata.for.hemi_+3A_num_vertices_in_hemi">num_vertices_in_hemi</code></td>
<td>
<p>integer. The number of vertices of the surface for which the mask is created. This must be for a single hemisphere.</p>
</td></tr>
<tr><td><code id="mask.from.labeldata.for.hemi_+3A_invert_labels">invert_labels</code></td>
<td>
<p>logical, whether to invert the label data.</p>
</td></tr>
<tr><td><code id="mask.from.labeldata.for.hemi_+3A_existing_mask">existing_mask</code></td>
<td>
<p>an existing mask to modify or NULL. If it is NULL, a new mask will be created before applying any labels, and the values set during initialization of this new mask are the negation of the 'invert_label' parameter. Defaults to NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector. The mask. It contains a logical value for each vertex. By default, the vertex indices from the labels are FALSE and the rest are TRUE, but this can be changed with the parameter 'invert_labels'.
</p>


<h3>See Also</h3>

<p>Other label data functions: 
<code><a href="#topic+group.label">group.label</a>()</code>,
<code><a href="#topic+labeldata.from.mask">labeldata.from.mask</a>()</code>,
<code><a href="#topic+subject.label">subject.label</a>()</code>
</p>
<p>Other mask functions: 
<code><a href="#topic+coloredmesh.from.mask">coloredmesh.from.mask</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();

  # Define the data to use:
  subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
  subject_id = 'subject1';
  surface = 'white';
  hemi = 'both';
  atlas = 'aparc';
  region = 'bankssts';

  # Create a mask from a region of an annotation:
  lh_annot = subject.annot(subjects_dir, subject_id, 'lh', atlas);
  rh_annot = subject.annot(subjects_dir, subject_id, 'rh', atlas);
  lh_label = label.from.annotdata(lh_annot, region);
  rh_label = label.from.annotdata(rh_annot, region);
  lh_mask = mask.from.labeldata.for.hemi(lh_label, length(lh_annot$vertices));
  rh_mask = mask.from.labeldata.for.hemi(rh_label, length(rh_annot$vertices));

  # Edit the mask: add the vertices from another region to it:
  region2 = 'medialorbitofrontal';
  lh_label2 = label.from.annotdata(lh_annot, region2);
  rh_label2 = label.from.annotdata(rh_annot, region2);
  lh_mask2 = mask.from.labeldata.for.hemi(lh_label2, length(lh_annot$vertices),
   existing_mask = lh_mask);
  rh_mask2 = mask.from.labeldata.for.hemi(rh_label2, length(rh_annot$vertices),
   existing_mask = rh_mask);

## End(Not run)

</code></pre>

<hr>
<h2 id='mergehemi.annots'>Merge the annotations from two hemispheres into one annot.</h2><span id='topic+mergehemi.annots'></span>

<h3>Description</h3>

<p>Merge the annotations from two hemispheres into one annot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergehemi.annots(lh_annot, rh_annot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergehemi.annots_+3A_lh_annot">lh_annot</code></td>
<td>
<p>annot. An annotation, as returned by freesurferformats::read.fs.annot().</p>
</td></tr>
<tr><td><code id="mergehemi.annots_+3A_rh_annot">rh_annot</code></td>
<td>
<p>annot. An annotation, as returned by freesurferformats::read.fs.annot().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>annot, the merged annotation.
</p>

<hr>
<h2 id='mesh.vertex.included.faces'>Return all faces which are made up completely of the listed vertices.</h2><span id='topic+mesh.vertex.included.faces'></span>

<h3>Description</h3>

<p>Return all faces which are made up completely of the listed vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh.vertex.included.faces(surface_mesh, source_vertices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mesh.vertex.included.faces_+3A_surface_mesh">surface_mesh</code></td>
<td>
<p>surface mesh, as loaded by <code><a href="#topic+subject.surface">subject.surface</a></code> or <code><a href="freesurferformats.html#topic+read.fs.surface">read.fs.surface</a></code>.</p>
</td></tr>
<tr><td><code id="mesh.vertex.included.faces_+3A_source_vertices">source_vertices</code></td>
<td>
<p>integer vector, the vertex indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector, the face indices
</p>


<h3>See Also</h3>

<p>Other surface mesh functions: 
<code><a href="#topic+face.edges">face.edges</a>()</code>,
<code><a href="#topic+label.border">label.border</a>()</code>,
<code><a href="#topic+mesh.vertex.neighbors">mesh.vertex.neighbors</a>()</code>,
<code><a href="#topic+subject.surface">subject.surface</a>()</code>,
<code><a href="#topic+vis.path.along.verts">vis.path.along.verts</a>()</code>
</p>

<hr>
<h2 id='mesh.vertex.neighbors'>Compute neighborhood of a vertex</h2><span id='topic+mesh.vertex.neighbors'></span>

<h3>Description</h3>

<p>Given a set of query vertex indices and a mesh *m*, compute all vertices which are adjacent to the query vertices in the mesh. A vertex *u* is *adjacent* to another vertex *v* iff there exists an edge *e = (u, v)* in *m*. While you could call this function repeatedly with the old output as its new input to extend the neighborhood, you should maybe use a proper graph library for this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh.vertex.neighbors(
  surface,
  source_vertices,
  k = 1L,
  restrict_to_vertices = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mesh.vertex.neighbors_+3A_surface">surface</code></td>
<td>
<p>a surface as returned by functions like <code><a href="#topic+subject.surface">subject.surface</a></code> or <code><a href="freesurferformats.html#topic+read.fs.surface">read.fs.surface</a></code>.</p>
</td></tr>
<tr><td><code id="mesh.vertex.neighbors_+3A_source_vertices">source_vertices</code></td>
<td>
<p>Vector of source vertex indices.</p>
</td></tr>
<tr><td><code id="mesh.vertex.neighbors_+3A_k">k</code></td>
<td>
<p>positive integer, how often to repeat the procedure and grow the neighborhood, using the output 'vertices' as the 'source_vertices' for the next iteration. Warning: settings this to high values will be very slow for large meshes.</p>
</td></tr>
<tr><td><code id="mesh.vertex.neighbors_+3A_restrict_to_vertices">restrict_to_vertices</code></td>
<td>
<p>integer vector of vertex indices. If given, the neighborhood growth will be limited to the given vertex indices. Defaults to NULL, which means the neighborhood is not restricted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the neighborhood as a list with two entries: &quot;faces&quot;: integer vector, the face indices of all faces the source_vertices are a part of. &quot;vertices&quot;: integer vector, the unique vertex indices of all vertices of the faces in the 'faces' property. These vertex indices include the indices of the source_vertices themselves.
</p>


<h3>See Also</h3>

<p>Other surface mesh functions: 
<code><a href="#topic+face.edges">face.edges</a>()</code>,
<code><a href="#topic+label.border">label.border</a>()</code>,
<code><a href="#topic+mesh.vertex.included.faces">mesh.vertex.included.faces</a>()</code>,
<code><a href="#topic+subject.surface">subject.surface</a>()</code>,
<code><a href="#topic+vis.path.along.verts">vis.path.along.verts</a>()</code>
</p>

<hr>
<h2 id='mkco.cluster'>Return recommended 'makecmap_options' for diverging cluster data.</h2><span id='topic+mkco.cluster'></span>

<h3>Description</h3>

<p>This function returns recommended visualization settings (a colormap function and suitable other settings) for the given type of data. The return value is meant to be passed as parameter 'makecmap_options' to the vis.* functions, e.g., <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkco.cluster()
</code></pre>


<h3>Value</h3>

<p>named list, visualization settings to be used as 'makecmap_options' for diverging data.
</p>


<h3>Note</h3>

<p>This uses a cyan blue red yellow colormap, which is popular for displaying clusters in neuroscience.
</p>

<hr>
<h2 id='mkco.div'>Return recommended 'makecmap_options' for diverging data.</h2><span id='topic+mkco.div'></span>

<h3>Description</h3>

<p>This function returns recommended visualization settings (a colormap function and suitable other settings) for the given type of data. The return value is meant to be passed as parameter 'makecmap_options' to the vis.* functions, e.g., <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkco.div()
</code></pre>


<h3>Value</h3>

<p>named list, visualization settings to be used as 'makecmap_options' for diverging data.
</p>

<hr>
<h2 id='mkco.heat'>Return recommended 'makecmap_options' for sequential data with heatmap style.</h2><span id='topic+mkco.heat'></span>

<h3>Description</h3>

<p>This function returns recommended visualization settings (a colormap function and suitable other settings) for the given type of data. The return value is meant to be passed as parameter 'makecmap_options' to the vis.* functions, e.g., <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkco.heat()
</code></pre>


<h3>Value</h3>

<p>named list, visualization settings to be used as 'makecmap_options' for sequential data with heatmap style.
</p>

<hr>
<h2 id='mkco.seq'>Return recommended 'makecmap_options' for sequential data.</h2><span id='topic+mkco.seq'></span>

<h3>Description</h3>

<p>This function returns recommended visualization settings (a colormap function and suitable other settings) for the given type of data. The return value is meant to be passed as parameter 'makecmap_options' to the vis.* functions, e.g., <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkco.seq()
</code></pre>


<h3>Value</h3>

<p>named list, visualization settings to be used as 'makecmap_options' for sequential data.
</p>

<hr>
<h2 id='normalize'>Normalize data.</h2><span id='topic+normalize'></span>

<h3>Description</h3>

<p>Scales data to the range '[0, 1]' based on min and max values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_+3A_x">x</code></td>
<td>
<p>the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the scaled data
</p>

<hr>
<h2 id='numverts.lh'>Determine vertex count of left hemi from hemilist of surfaces or the count itself.</h2><span id='topic+numverts.lh'></span>

<h3>Description</h3>

<p>Determine vertex count of left hemi from hemilist of surfaces or the count itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numverts.lh(surfaces)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numverts.lh_+3A_surfaces">surfaces</code></td>
<td>
<p>hemilist of surfaces, or a single integer, which will be interpreted as the number of vertices of the left hemisphere surface.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, the number of vertices.
</p>

<hr>
<h2 id='numverts.rh'>Determine vertex count of right hemi from hemilist of surfaces or the count itself.</h2><span id='topic+numverts.rh'></span>

<h3>Description</h3>

<p>Determine vertex count of right hemi from hemilist of surfaces or the count itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numverts.rh(surfaces)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numverts.rh_+3A_surfaces">surfaces</code></td>
<td>
<p>hemilist of surfaces, or a single integer, which will be interpreted as the number of vertices of the right hemisphere surface.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, the number of vertices.
</p>

<hr>
<h2 id='path.colors.from.orientation'>Compute path color from its orientation.</h2><span id='topic+path.colors.from.orientation'></span>

<h3>Description</h3>

<p>Compute path color from its orientation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path.colors.from.orientation(coords_list, use_three_colors_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="path.colors.from.orientation_+3A_coords_list">coords_list</code></td>
<td>
<p>list of <code>m</code> matrices, each <code>n</code> x 3 matrix must contain the 3D coords for one path.</p>
</td></tr>
<tr><td><code id="path.colors.from.orientation_+3A_use_three_colors_only">use_three_colors_only</code></td>
<td>
<p>logical, whether to use only three different colors, based on closest axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>m</code> x 3 matrix, each row corresponds to a path and contains its color value (RGB, range 0..255).
</p>

<hr>
<h2 id='path.slopes'>Compute slopes of paths relative to axes.</h2><span id='topic+path.slopes'></span>

<h3>Description</h3>

<p>Compute slopes of paths relative to axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path.slopes(coords_list, return_angles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="path.slopes_+3A_coords_list">coords_list</code></td>
<td>
<p>list of <code>m</code> matrices, each <code>n</code> x 3 matrix must contain the 3D coords for one path.</p>
</td></tr>
<tr><td><code id="path.slopes_+3A_return_angles">return_angles</code></td>
<td>
<p>logical, whether to return angles instead of slopes. Angles are returned in degrees, and will range from <code>-90</code> to <code>+90</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>m</code> x 3 matrix, each row corresponds to a path and describes the 3 slopes of the path against the 3 planes/ x, y, and z axes (in that order).
</p>

<hr>
<h2 id='per.hemi.vertex.indices'>Transform surfaces indices which go over two surfaces to per-hemi indices.</h2><span id='topic+per.hemi.vertex.indices'></span>

<h3>Description</h3>

<p>Transform surfaces indices which go over two surfaces to per-hemi indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>per.hemi.vertex.indices(surfaces, vertices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="per.hemi.vertex.indices_+3A_surfaces">surfaces</code></td>
<td>
<p>hemilist of surfaces, or a single integer, which will be interpreted as the number of vertices of the left hemisphere surface.</p>
</td></tr>
<tr><td><code id="per.hemi.vertex.indices_+3A_vertices">vertices</code></td>
<td>
<p>positive integer vector, the query vertex indices. Must be in range 1 to (num_verts_lh + num_verts_rh).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with the following entries: 'vertices', hemilist of indices for the hemispheres. 'query_indices', hemilist of the indices of the respective vertices in the vector that was passed as parameter vertices. 'vertices_hemi': vector of character strings containing the hemi value (lh or rh) for the query vertices.
</p>

<hr>
<h2 id='perform.na.mapping'>Perform NA mapping for transparency</h2><span id='topic+perform.na.mapping'></span>

<h3>Description</h3>

<p>Usually this is done so that the 'NA' values are plotted transparently, so your can see a background color through the respective colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perform.na.mapping(data, map_to_NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perform.na.mapping_+3A_data">data</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="perform.na.mapping_+3A_map_to_na">map_to_NA</code></td>
<td>
<p>the value or value range that should be mapped to 'NA'. If a single value, only exactly this value is used. If two values, they are interpreted as a range, and a values between them are mapped to 'NA'. If you pass 'NULL', the data are returned as-is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mapped data
</p>

<hr>
<h2 id='perform.rglactions'>Perform rglactions, like taking screenshots.</h2><span id='topic+perform.rglactions'></span>

<h3>Description</h3>

<p>Take a list specifying actions, see <code><a href="#topic+rglactions">rglactions</a></code>, and execute them. This function should be called once an rgl scene has been setup and rendered. A typical use case is to save a screenshot of the scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perform.rglactions(rglactions, at_index = NULL, silent = TRUE, ignore = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perform.rglactions_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="perform.rglactions_+3A_at_index">at_index</code></td>
<td>
<p>integer, the index to use in case of vectorized entries. Allows using different output_images for different views or similar.</p>
</td></tr>
<tr><td><code id="perform.rglactions_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress messages</p>
</td></tr>
<tr><td><code id="perform.rglactions_+3A_ignore">ignore</code></td>
<td>
<p>vector of character strings, actions to ignore</p>
</td></tr>
</table>

<hr>
<h2 id='pervertexdata.smoothgaussian'>Perform Gaussian smoothing</h2><span id='topic+pervertexdata.smoothgaussian'></span>

<h3>Description</h3>

<p>Perform Gaussian smoothing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pervertexdata.smoothgaussian(
  spherical_surface,
  data,
  fwhm = 15,
  truncfactor = 3.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pervertexdata.smoothgaussian_+3A_spherical_surface">spherical_surface</code></td>
<td>
<p>an fs.surface instance representing the spherical version (<code>lh.sphere</code> or <code>rh.sphere</code> of the subject).</p>
</td></tr>
<tr><td><code id="pervertexdata.smoothgaussian_+3A_data">data</code></td>
<td>
<p>numerical vector of per-vertex data for the surface</p>
</td></tr>
<tr><td><code id="pervertexdata.smoothgaussian_+3A_fwhm">fwhm</code></td>
<td>
<p>double, the full width at half maximum for the Gaussian kernel</p>
</td></tr>
<tr><td><code id="pervertexdata.smoothgaussian_+3A_truncfactor">truncfactor</code></td>
<td>
<p>the factor after how many stddevs to truncate the Gaussian kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the smoothed data
</p>


<h3>Note</h3>

<p>This function has been adapted from FreeSurfer and it is subject to the FreeSurfer software license.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sjd = fsaverage.path();
spherical_surface = subject.surface(sjd, "fsaverage3",
  surface="sphere", hemi="lh");
vdata = subject.morph.native(sjd, "fsaverage3", "thickness", hemi="lh");
vdata_smoothed = pervertexdata.smoothgaussian(spherical_surface,
 vdata, fwhm = 15);
vis.data.on.subject(sjd, "fsaverage3", morph_data_lh = vdata);
vis.data.on.subject(sjd, "fsaverage3", morph_data_lh = vdata_smoothed);

## End(Not run)

</code></pre>

<hr>
<h2 id='pervertexdata.smoothnn'>Perform iterative nearest-neighbor smoothing of per-vertex data.</h2><span id='topic+pervertexdata.smoothnn'></span>

<h3>Description</h3>

<p>Smoothing of surface data by iterative mesh neighborhood averaging. Assigns to each vertex the average of the values in its 1-ring neighborhood (based on the mesh edges).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pervertexdata.smoothnn(surface, data, num_iter, k = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pervertexdata.smoothnn_+3A_surface">surface</code></td>
<td>
<p>an <code>fs.surface</code> instance</p>
</td></tr>
<tr><td><code id="pervertexdata.smoothnn_+3A_data">data</code></td>
<td>
<p>numerical vector, the per-vertex data for the surface. Values set to <code>NA</code> will be ignore, so you can apply a mask before this operation (e.g., by setting the values for all vertices of the medial mask to <code>NA</code>).</p>
</td></tr>
<tr><td><code id="pervertexdata.smoothnn_+3A_num_iter">num_iter</code></td>
<td>
<p>positive scalar integer, the number of times to perform the averaging. Depends on the mesh resolution and desired smoothing, higher resolution meshes will need more passes. Typical values are in range 20 to 150, but also depend on the setting of parameter 'k', of course.</p>
</td></tr>
<tr><td><code id="pervertexdata.smoothnn_+3A_k">k</code></td>
<td>
<p>positive scalar integer, the neighborhood size in hops along the mesh edges (the k for the k-ring neighborhood). For higher resolution meshes it makes sense to increase this, typical values are roughly in range 1 to 10.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The iteration is currently done in R, which means the performance is not great.
</p>
<p>This does NOT smooth the mesh, it smoothes per-vertex values assigned to mesh vertices.
</p>
<p>To see relevant smoothing for full-resolution FreeSurfer meshes, try setting <code>num_iter=50, k=8</code> for a start.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sjd = fsaverage.path(T);
sj = "fsaverage3";
surface = subject.surface(sjd, sj, hemi = "lh");
th = subject.morph.native(sjd, sj, "thickness", hemi="lh", cortex_only=T);
th_smooth = pervertexdata.smoothnn(surface, th, num_iter=15L);
vis.data.on.subject(sjd, sj, morph_data_lh = th);
vis.data.on.subject(sjd, sj, morph_data_lh = th_smooth);

## End(Not run)

</code></pre>

<hr>
<h2 id='pervertexdata.smoothnn.compute.fwhm'>Compute expected FWHM from given number of neighborhood smoothing iterations.</h2><span id='topic+pervertexdata.smoothnn.compute.fwhm'></span>

<h3>Description</h3>

<p>Compute expected FWHM from given number of neighborhood smoothing iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pervertexdata.smoothnn.compute.fwhm(surface, niters, is_template)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pervertexdata.smoothnn.compute.fwhm_+3A_surface">surface</code></td>
<td>
<p>an <code>fs.surface</code> instance</p>
</td></tr>
<tr><td><code id="pervertexdata.smoothnn.compute.fwhm_+3A_niters">niters</code></td>
<td>
<p>positive integer, the nn iteration count</p>
</td></tr>
<tr><td><code id="pervertexdata.smoothnn.compute.fwhm_+3A_is_template">is_template</code></td>
<td>
<p>logical, whether the surface belongs to a template subject</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double, the expected FWHM
</p>


<h3>Note</h3>

<p>This function has been adapted from FreeSurfer and it is subject to the FreeSurfer software license.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
spherical_surface = subject.surface(fsaverage.path(), "fsaverage3", surface="sphere", hemi="lh");
fsbrain:::pervertexdata.smoothnn.compute.fwhm(spherical_surface, 5L);

## End(Not run)


</code></pre>

<hr>
<h2 id='pervertexdata.smoothnn.compute.numiter'>Compute number of neighborhood smoothing iterations to reach requested fwhm.</h2><span id='topic+pervertexdata.smoothnn.compute.numiter'></span>

<h3>Description</h3>

<p>Compute number of neighborhood smoothing iterations to reach requested fwhm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pervertexdata.smoothnn.compute.numiter(surface, fwhm, is_template)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pervertexdata.smoothnn.compute.numiter_+3A_surface">surface</code></td>
<td>
<p>an <code>fs.surface</code> instance</p>
</td></tr>
<tr><td><code id="pervertexdata.smoothnn.compute.numiter_+3A_is_template">is_template</code></td>
<td>
<p>logical, whether the surface belongs to a template subject</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, the iteration count
</p>


<h3>Note</h3>

<p>This function has been adapted from FreeSurfer and it is subject to the FreeSurfer software license.
</p>

<hr>
<h2 id='plot.fsbrain.colorbar'>Draw a simple colorbar from colors.</h2><span id='topic+plot.fsbrain.colorbar'></span>

<h3>Description</h3>

<p>Draw a simple colorbar from colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsbrain.colorbar'
plot(colors, horizontal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fsbrain.colorbar_+3A_colors">colors</code></td>
<td>
<p>vector of colors, no special ordering is assumed</p>
</td></tr>
<tr><td><code id="plot.fsbrain.colorbar_+3A_horizontal">horizontal</code></td>
<td>
<p>logical, whether the colorbar should be plotted horizontally (or vertically).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function assumes that there is an open plot, use <code>plot.new()</code> to create one before calling this function if that is not the case.
</p>

<hr>
<h2 id='pp.named.list'>Pretty-print a named list or vector.</h2><span id='topic+pp.named.list'></span>

<h3>Description</h3>

<p>Pretty-print a named list or vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp.named.list(named_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pp.named.list_+3A_named_list">named_list</code></td>
<td>
<p>a named list or vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string, the printed list
</p>

<hr>
<h2 id='principal.curvatures'>Computes principal curvatures according to 2 definitions from raw k1 and k2 values.</h2><span id='topic+principal.curvatures'></span>

<h3>Description</h3>

<p>Computes principal curvatures according to 2 definitions from raw k1 and k2 values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>principal.curvatures(k1_raw, k2_raw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="principal.curvatures_+3A_k1_raw">k1_raw</code></td>
<td>
<p>numerical vector, one of the two principal curvatures, one value per vertex</p>
</td></tr>
<tr><td><code id="principal.curvatures_+3A_k2_raw">k2_raw</code></td>
<td>
<p>numerical vector, the other one of the two principal curvatures, one value per vertex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named 'principal_curvatures' list, with entries 'principal_curvature_k1': larger value of k1_raw, k2_raw. 'principal_curvature_k2': smaller value of k1_raw, k2_raw. 'principal_curvature_k_major': larger value of abs(k1_raw), abs(k2_raw). 'principal_curvature_k_minor': smaller value of abs(k1_raw), abs(k2_raw).
</p>


<h3>Note</h3>

<p>To obtain k1_raw and k2_raw, use <code>surface.curvatures</code> to compute it from a mesh, or load the FreeSurfer files <code>'surf/?h.white.max'</code> and <code>'surf/?h.white.min'</code>.
</p>

<hr>
<h2 id='print.fs.coloredmesh'>Print description of a brain coloredmesh (S3).</h2><span id='topic+print.fs.coloredmesh'></span>

<h3>Description</h3>

<p>Print description of a brain coloredmesh (S3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fs.coloredmesh'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.fs.coloredmesh_+3A_x">x</code></td>
<td>
<p>brain surface with class 'fs.coloredmesh'.</p>
</td></tr>
<tr><td><code id="print.fs.coloredmesh_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='print.fs.coloredvoxels'>Print description of fs.coloredvoxels (S3).</h2><span id='topic+print.fs.coloredvoxels'></span>

<h3>Description</h3>

<p>Print description of fs.coloredvoxels (S3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fs.coloredvoxels'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.fs.coloredvoxels_+3A_x">x</code></td>
<td>
<p>brain voxel tris with class 'fs.coloredvoxels'.</p>
</td></tr>
<tr><td><code id="print.fs.coloredvoxels_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='print.fsbrain'>Print description of an fsbrain (S3).</h2><span id='topic+print.fsbrain'></span>

<h3>Description</h3>

<p>Print description of an fsbrain (S3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsbrain'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.fsbrain_+3A_x">x</code></td>
<td>
<p>fsbrain instance with class 'fsbrain'.</p>
</td></tr>
<tr><td><code id="print.fsbrain_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='qc.for.group'>Perform data quality check based on computed region stats.</h2><span id='topic+qc.for.group'></span>

<h3>Description</h3>

<p>Determine subjects that potentially failed segmentation, based on region-wise morphometry data. The stats can be computed from any kind of data, but something like area or volume most likely works best. The stats are based on the mean of the region values, so the measure should at least roughly follow a normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc.for.group(subjects_dir, subjects_list, measure, atlas, hemi = "both", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc.for.group_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="qc.for.group_+3A_subjects_list">subjects_list</code></td>
<td>
<p>string vector. A vector of subject identifiers that match the directory names within subjects_dir.</p>
</td></tr>
<tr><td><code id="qc.for.group_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="qc.for.group_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="qc.for.group_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', 'split', or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded. If set to 'both', combined data for 'lh' and 'rh' will be used. If 'split', the data for hte two hemispheres will go into seprate columns, with column names having 'lh_' and 'rh_' prefixes.</p>
</td></tr>
<tr><td><code id="qc.for.group_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="#topic+qc.from.regionwise.df">qc.from.regionwise.df</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>qc result as a hemilist, each entry contains a named list as returned by <code><a href="#topic+qc.from.regionwise.df">qc.from.regionwise.df</a></code>.
</p>


<h3>See Also</h3>

<p>Other quality check functions: 
<code><a href="#topic+qc.from.regionwise.df">qc.from.regionwise.df</a>()</code>,
<code><a href="#topic+qc.from.segstats.table">qc.from.segstats.table</a>()</code>
</p>

<hr>
<h2 id='qc.from.regionwise.df'>Perform data quality check based on a dataframe containing aggregated region-wise data.</h2><span id='topic+qc.from.regionwise.df'></span>

<h3>Description</h3>

<p>Determine subjects that potentially failed segmentation, based on region-wise data. The data can be anything, but there must be one numerical value per subject per region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc.from.regionwise.df(
  rdf,
  z_threshold = 2.8,
  verbosity = 0L,
  num_bad_regions_allowed = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc.from.regionwise.df_+3A_rdf">rdf</code></td>
<td>
<p>data.frame, the region data. The first column must contain the subject identifier, all other columns should contain numerical data for a single region. (Each row represents a subject.) This can be produced by calling <code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a></code> or by parsing a text file produced by the FreeSurfer tool 'aparcstats2table' (see <code>fsbrain:::qc.from.segstats.table</code> for parsing code).</p>
</td></tr>
<tr><td><code id="qc.from.regionwise.df_+3A_z_threshold">z_threshold</code></td>
<td>
<p>numerical, the cutoff value for considering a subject an outlier (in standard deviations).</p>
</td></tr>
<tr><td><code id="qc.from.regionwise.df_+3A_verbosity">verbosity</code></td>
<td>
<p>integer, controls the output to stdout. 0=off, 1=normal, 2=verbose.</p>
</td></tr>
<tr><td><code id="qc.from.regionwise.df_+3A_num_bad_regions_allowed">num_bad_regions_allowed</code></td>
<td>
<p>integer, the number of regions in which subjects are allowed to be outliers without being reported as potentially failed segmentation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries: 'failed_subjects': vector of character strings, the subject identifiers which potentially failed segmentation. 'mean_dists_z': distance to mean, in standard deviations, per subject per region. 'num_outlier_subjects_per_region': number of outlier subjects by region. 'metadata': named list of metadata, e.g., hemi, atlas and measure used to compute these QC results.
</p>


<h3>See Also</h3>

<p>Other quality check functions: 
<code><a href="#topic+qc.for.group">qc.for.group</a>()</code>,
<code><a href="#topic+qc.from.segstats.table">qc.from.segstats.table</a>()</code>
</p>

<hr>
<h2 id='qc.from.segstats.table'>Perform data quality check based on a segstats table.</h2><span id='topic+qc.from.segstats.table'></span>

<h3>Description</h3>

<p>Perform data quality check based on a segstats table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc.from.segstats.table(filepath, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc.from.segstats.table_+3A_filepath">filepath</code></td>
<td>
<p>path to input file, a tab-separated file generated by running the FreeSurfer tools 'aparcstats2table' or 'asegstats2table'. The command line in the system shell would be something like 'aparcstats2table_bin &ndash;subjectsfile $subjects_file &ndash;meas $measure &ndash;hemi $hemi -t $aparc_output_table'.</p>
</td></tr>
<tr><td><code id="qc.from.segstats.table_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="#topic+qc.from.regionwise.df">qc.from.regionwise.df</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see <code><a href="#topic+qc.from.regionwise.df">qc.from.regionwise.df</a></code>
</p>


<h3>See Also</h3>

<p>Other quality check functions: 
<code><a href="#topic+qc.for.group">qc.for.group</a>()</code>,
<code><a href="#topic+qc.from.regionwise.df">qc.from.regionwise.df</a>()</code>
</p>

<hr>
<h2 id='qc.from.segstats.tables'>Perform data quality check based on a segstats table.</h2><span id='topic+qc.from.segstats.tables'></span>

<h3>Description</h3>

<p>Determine subjects that potentially failed segmentation, based on segstats table data. The input table file must be a segmentation or parcellation table, generated by running the FreeSurfer tools 'aparcstats2table' or 'asegstats2table' for your subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc.from.segstats.tables(filepath_lh, filepath_rh, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc.from.segstats.tables_+3A_filepath_lh">filepath_lh</code></td>
<td>
<p>path to left hemisphere input file, a tab-separated file generated by running the FreeSurfer tools 'aparcstats2table' or 'asegstats2table'. The command line in the system shell would be something like 'aparcstats2table_bin &ndash;subjectsfile $subjects_file &ndash;meas $measure &ndash;hemi $hemi -t $aparc_output_table'.</p>
</td></tr>
<tr><td><code id="qc.from.segstats.tables_+3A_filepath_rh">filepath_rh</code></td>
<td>
<p>path to equivalent right hemisphere input file.</p>
</td></tr>
<tr><td><code id="qc.from.segstats.tables_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="#topic+qc.from.regionwise.df">qc.from.regionwise.df</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>qc result as a hemilist, each entry contains a named list as returned by <code><a href="#topic+qc.from.regionwise.df">qc.from.regionwise.df</a></code>.
</p>

<hr>
<h2 id='qc.fslong.checkidenticaldata'>Check whether subjects for FS longitudinal pipeline contain data that is identical between time points.</h2><span id='topic+qc.fslong.checkidenticaldata'></span>

<h3>Description</h3>

<p>Check whether subjects for FS longitudinal pipeline contain data that is identical between time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc.fslong.checkidenticaldata(
  subjects_dir,
  subjects_to_check = NULL,
  timepoint_names = c("_MR1", "_MR2"),
  measure = "thickness",
  surface = "white"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc.fslong.checkidenticaldata_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="qc.fslong.checkidenticaldata_+3A_timepoint_names">timepoint_names</code></td>
<td>
<p>vector of character strings, the timepoint names. These are mandatory for QDEC, so there should be very little reason to change them. Leave along unless you know what you are doing.</p>
</td></tr>
<tr><td><code id="qc.fslong.checkidenticaldata_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Keep in mind that this checks on the level of the FreeSurfer reconstruction, which is not 100
</p>

<hr>
<h2 id='qc.report.html'>Create visual quality check report from QC result.</h2><span id='topic+qc.report.html'></span>

<h3>Description</h3>

<p>Create visual quality check report from QC result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc.report.html(
  subjects_dir,
  subjects_list,
  out_dir = "fsbrain_qc_report",
  subjects_metadata = list(),
  qc = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc.report.html_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="qc.report.html_+3A_subjects_list">subjects_list</code></td>
<td>
<p>string vector. A vector of subject identifiers that match the directory names within subjects_dir.</p>
</td></tr>
<tr><td><code id="qc.report.html_+3A_out_dir">out_dir</code></td>
<td>
<p>character string, path to output dir. The last directory part will be created if it does not exist (but not recursively).</p>
</td></tr>
<tr><td><code id="qc.report.html_+3A_subjects_metadata">subjects_metadata</code></td>
<td>
<p>named list, keys can be subjects from subjects_list. Each key can hold another named list of strings, represeting arbitrary metadata for that subject that will be displayed in the report.</p>
</td></tr>
<tr><td><code id="qc.report.html_+3A_qc">qc</code></td>
<td>
<p>optional qc result. If NULL, a QC report is created using standard settings 'aparc' and 'thickness'.</p>
</td></tr>
<tr><td><code id="qc.report.html_+3A_...">...</code></td>
<td>
<p>passed on to <code>subject.report.html</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
s = sjld("~/data/IXI_min/mri/freesurfer");
s$l = s$l[1:100]; # first few subjects are enough
fsbrain:::qc.report.html(s$d, s$l);

## End(Not run)

</code></pre>

<hr>
<h2 id='qc.vis.failcount.by.region'>Visualize the number of outlier subjects per region in your dataset.</h2><span id='topic+qc.vis.failcount.by.region'></span>

<h3>Description</h3>

<p>The function helps you to see which regions are affected the most by QC issues: for each region, it plots the number of subjects which are outliers in the region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc.vis.failcount.by.region(
  qc_res,
  atlas,
  subjects_dir = fsaverage.path(),
  subject_id = "fsaverage",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc.vis.failcount.by.region_+3A_qc_res">qc_res</code></td>
<td>
<p>hemilist of QC results, as returned by functions like <code><a href="#topic+qc.for.group">qc.for.group</a></code> or <code><a href="#topic+qc.from.segstats.tables">qc.from.segstats.tables</a></code>.</p>
</td></tr>
<tr><td><code id="qc.vis.failcount.by.region_+3A_atlas">atlas</code></td>
<td>
<p>string. The brain atlas to use. E.g., 'aparc' or 'aparc.a2009s'.</p>
</td></tr>
<tr><td><code id="qc.vis.failcount.by.region_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="qc.vis.failcount.by.region_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="qc.vis.failcount.by.region_+3A_...">...</code></td>
<td>
<p>extra parameters passed to <code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a></code>. E.g., to change to interactive view, get a colorbar and better resolution, try: <code>draw_colorbar=T, rgloptions = rglo(), views='si'</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>You can visualize this on any subject you like, 'fsaverage' is a typical choice. The atlas must be the one used during the QC step.
</p>

<hr>
<h2 id='qdec.table.filter'>Filter QDEC long table for subjects.</h2><span id='topic+qdec.table.filter'></span>

<h3>Description</h3>

<p>Filter QDEC long table for subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdec.table.filter(qdec_file, subjects_list, output_qdec_file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qdec.table.filter_+3A_qdec_file">qdec_file</code></td>
<td>
<p>the source QDEC table</p>
</td></tr>
<tr><td><code id="qdec.table.filter_+3A_subjects_list">subjects_list</code></td>
<td>
<p>the subjects to extract from the QDEC file</p>
</td></tr>
<tr><td><code id="qdec.table.filter_+3A_output_qdec_file">output_qdec_file</code></td>
<td>
<p>optional character string, a file name to which to write the resulting, filtered table. If not given, no file is created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data.frame containing the subset of subjects from the original QDEC file.
</p>


<h3>Note</h3>

<p>This assumes that there are 2 time points per subject and warns if not all requested subjects were found.
</p>

<hr>
<h2 id='qdec.table.skeleton'>Generate skeleton dataframe for FreeSurfer QDEC long file from subjects list.</h2><span id='topic+qdec.table.skeleton'></span>

<h3>Description</h3>

<p>Generate skeleton dataframe for FreeSurfer QDEC long file from subjects list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdec.table.skeleton(
  subjects_list,
  isi = rep(0.8, length(subjects_list)),
  isi_name = "years",
  timepoint_names = c("_MR1", "_MR2")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qdec.table.skeleton_+3A_subjects_list">subjects_list</code></td>
<td>
<p>vector of character strings, the Freesurfer subject IDs (cross-sectional names, without any suffixes like <code>_MR1, long,</code> etc.)</p>
</td></tr>
<tr><td><code id="qdec.table.skeleton_+3A_isi">isi</code></td>
<td>
<p>numerical vector, the inter-scan interval for the subjects, in a unit of your choice. Typically in years.</p>
</td></tr>
<tr><td><code id="qdec.table.skeleton_+3A_isi_name">isi_name</code></td>
<td>
<p>character string, the name for the isi columns. Defaults to &quot;years&quot;.</p>
</td></tr>
<tr><td><code id="qdec.table.skeleton_+3A_timepoint_names">timepoint_names</code></td>
<td>
<p>vector of character strings, the timepoint names. These are mandatory for QDEC, so there should be very little reason to change them. Leave along unless you know what you are doing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with 3 columns named fsid and fsid-base and 'isi_name', a data.frame to use with the <code><a href="#topic+demographics.to.qdec.table.dat">demographics.to.qdec.table.dat</a></code> function.
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+demographics.to.qdec.table.dat">demographics.to.qdec.table.dat</a></code> to write the result to a QDEC file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    dem = data.frame("ID"=paste("subject", seq(5), sep=""),
      "age"=sample.int(20, 5)+10L, "isi"=rnorm(5, 2.0, 0.1)); #sample data.
    qdec.table.skeleton(dem$ID, dem$isi);

</code></pre>

<hr>
<h2 id='rad2deg'>Convert raduians to degree</h2><span id='topic+rad2deg'></span>

<h3>Description</h3>

<p>Convert raduians to degree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rad2deg(rad)
</code></pre>

<hr>
<h2 id='ras2vox_tkr'>The FreeSurfer default ras2vox_tkr matrix.</h2><span id='topic+ras2vox_tkr'></span>

<h3>Description</h3>

<p>Applying this matrix to a FreeSurfer surface RAS coordinate (from a surface file like 'lh.white') will give you the voxel index (CRS) in a conformed FreeSurfer volume.  The returned matrix is the inverse of the 'vox2ras_tkr' matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ras2vox_tkr()
</code></pre>


<h3>Value</h3>

<p>numeric 4x4 matrix, the FreeSurfer ras2vox_tkr matrix.
</p>


<h3>See Also</h3>

<p>Other surface and volume coordinates: 
<code><a href="#topic+vox2ras_tkr">vox2ras_tkr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # Compute the FreeSurfer CRS voxel index of surface RAS coordinate (0.0, 0.0, 0.0):
   ras2vox_tkr() %*% c(0, 0, 0, 1);
   # Show that the voxel at surface RAS corrds (0.0, 0.0, 0.0) is the one with CRS (128, 128, 128):
   ras2vox_tkr() %*% c(0.0, 0.0, 0.0, 1);

</code></pre>

<hr>
<h2 id='read.colorcsv'>Read colors from CSV file.</h2><span id='topic+read.colorcsv'></span>

<h3>Description</h3>

<p>Read colors from CSV file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.colorcsv(filepath)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.colorcsv_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to a CSV file containing colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of hex color strings
</p>

<hr>
<h2 id='read.md.demographics'>Read demographics file</h2><span id='topic+read.md.demographics'></span>

<h3>Description</h3>

<p>Load a list of subjects and metadata from a demographics file, i.e., a tab-separated file containing an arbitrary number of columns, one of which must be the subject id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.md.demographics(
  demographics_file,
  column_names = NULL,
  header = FALSE,
  scale_and_center = FALSE,
  sep = "",
  report = FALSE,
  stringsAsFactors = TRUE,
  group_column_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.md.demographics_+3A_demographics_file">demographics_file</code></td>
<td>
<p>string. The path to the file.</p>
</td></tr>
<tr><td><code id="read.md.demographics_+3A_column_names">column_names</code></td>
<td>
<p>vector of strings. The column names to set in the returned dataframe. The length must match the number of columns in the file.</p>
</td></tr>
<tr><td><code id="read.md.demographics_+3A_header">header</code></td>
<td>
<p>logical. Whether the file starts with a header line.</p>
</td></tr>
<tr><td><code id="read.md.demographics_+3A_scale_and_center">scale_and_center</code></td>
<td>
<p>logical. Whether to center and scale the data. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="read.md.demographics_+3A_sep">sep</code></td>
<td>
<p>string. Separator passed to <code><a href="utils.html#topic+read.table">read.table</a></code>, defaults to tabulator.</p>
</td></tr>
<tr><td><code id="read.md.demographics_+3A_report">report</code></td>
<td>
<p>logical. Whether to write an overview, i.e., some descriptive statistics for each column, to STDOUT. Defaults to FALSE. See <code><a href="#topic+report.on.demographics">report.on.demographics</a></code>.</p>
</td></tr>
<tr><td><code id="read.md.demographics_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical. Whether to convert strings in the input data to factors. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="read.md.demographics_+3A_group_column_name">group_column_name</code></td>
<td>
<p>string or NULL. If given, the column name of the group column. It must be a factor column with 2 levels. Enables group-comparison tests. Defaults to NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe. The data in the file. String columns will be returned as factors, which you may want to adapt afterwards for the subject identifier column.
</p>


<h3>See Also</h3>

<p>Other metadata functions: 
<code><a href="#topic+demographics.to.fsgd.file">demographics.to.fsgd.file</a>()</code>,
<code><a href="#topic+read.md.subjects">read.md.subjects</a>()</code>,
<code><a href="#topic+report.on.demographics">report.on.demographics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   demographics_file =
   system.file("extdata", "demographics.tsv", package = "fsbrain", mustWork = TRUE);
   column_names = c("subject_id", "group", "age");
   demographics = read.md.demographics(demographics_file,
   header = TRUE, column_names = column_names, report = FALSE);

</code></pre>

<hr>
<h2 id='read.md.subjects'>Read subjects file</h2><span id='topic+read.md.subjects'></span>

<h3>Description</h3>

<p>Load a list of subjects from a subjects file, i.e., a simple text file containing one subject name per line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.md.subjects(subjects_file, header)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.md.subjects_+3A_subjects_file">subjects_file</code></td>
<td>
<p>character string, the path to the subjects file.</p>
</td></tr>
<tr><td><code id="read.md.subjects_+3A_header">header</code></td>
<td>
<p>logical, whether the file starts with a header line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of strings, the subject identifiers.
</p>


<h3>See Also</h3>

<p>Other metadata functions: 
<code><a href="#topic+demographics.to.fsgd.file">demographics.to.fsgd.file</a>()</code>,
<code><a href="#topic+read.md.demographics">read.md.demographics</a>()</code>,
<code><a href="#topic+report.on.demographics">report.on.demographics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   subjects_file = system.file("extdata", "subjects.txt", package = "fsbrain", mustWork = TRUE);
   subjects_list = read.md.subjects(subjects_file, header = FALSE);

</code></pre>

<hr>
<h2 id='read.md.subjects.from.fsgd'>Read subjects list from an FSGD file.</h2><span id='topic+read.md.subjects.from.fsgd'></span>

<h3>Description</h3>

<p>Read subjects list from an FSGD file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.md.subjects.from.fsgd(filepath)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.md.subjects.from.fsgd_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to a FreeSurfer Group Descriptor (FSGD) file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of character strings, the subject identifiers
</p>


<h3>Note</h3>

<p>This is not a parser for all data in an FSGD file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demographics.to.fsgd.file">demographics.to.fsgd.file</a></code>
</p>

<hr>
<h2 id='recycle'>Recycle parameters or whatever.</h2><span id='topic+recycle'></span>

<h3>Description</h3>

<p>Recycle parameters or whatever.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recycle(x, times)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recycle_+3A_x">x</code></td>
<td>
<p>a vector of whatever</p>
</td></tr>
<tr><td><code id="recycle_+3A_times">times</code></td>
<td>
<p>positive integer, the required length of the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length 'times', with the recycled 'x'
</p>


<h3>Note</h3>

<p>Todo: most likely there is an R function for this already, find it.
</p>

<hr>
<h2 id='regions.to.ignore'>Give suggestions for regions to ignore for an atlas.</h2><span id='topic+regions.to.ignore'></span>

<h3>Description</h3>

<p>Give suggestions for regions to ignore for an atlas. These are regions for which many subjects do not have any vertices in them, or the Medial Wall and Unknown regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regions.to.ignore(atlas)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regions.to.ignore_+3A_atlas">atlas</code></td>
<td>
<p>string. The name of an atlas. Supported strings are 'aparc' and 'aparc.a2009s'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of strings, the region names.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   aparc_regions_ign = regions.to.ignore('aparc');
   aparc_a2009s_regions_ign = regions.to.ignore('aparc.a2009s');

</code></pre>

<hr>
<h2 id='report.on.demographics'>Print a demographics report</h2><span id='topic+report.on.demographics'></span>

<h3>Description</h3>

<p>Print a demographics report
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report.on.demographics(
  demographics_df,
  group_column_name = NULL,
  paired = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="report.on.demographics_+3A_demographics_df">demographics_df</code></td>
<td>
<p>a demographics data.frame, as returned by  <code><a href="#topic+read.md.demographics">read.md.demographics</a></code>.</p>
</td></tr>
<tr><td><code id="report.on.demographics_+3A_group_column_name">group_column_name</code></td>
<td>
<p>string or NULL. If given, the column name of the group column. It must be a factor column with 2 levels. Enables group-comparison tests. Defaults to 'NULL'.</p>
</td></tr>
<tr><td><code id="report.on.demographics_+3A_paired">paired</code></td>
<td>
<p>Whether the data of the two groups if paired (repeated measurements). Only relevant if group_column_name is given and tests for group differences are included in the report. Defaults to 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of character strings, the lines of the demographics report.
</p>


<h3>See Also</h3>

<p>Other metadata functions: 
<code><a href="#topic+demographics.to.fsgd.file">demographics.to.fsgd.file</a>()</code>,
<code><a href="#topic+read.md.demographics">read.md.demographics</a>()</code>,
<code><a href="#topic+read.md.subjects">read.md.subjects</a>()</code>
</p>

<hr>
<h2 id='rgl.coord.lines'>Plot x, y and z axes in R,G,B.</h2><span id='topic+rgl.coord.lines'></span>

<h3>Description</h3>

<p>Plot positive x, y, and z axes from the center to 'len'. Gets added to current plot. Useful for debugging and understanding the 'rgl' coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.coord.lines(len = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgl.coord.lines_+3A_len">len</code></td>
<td>
<p>numeric scalar or vector of length 3, length of axes. You can specify a negative value to see the negative directions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'NULL', called for the plotting side effect.
</p>


<h3>Note</h3>

<p>The x, y and z axes are plotted in red, green, and blue, respectively.
</p>

<hr>
<h2 id='rglactions'>Create rglactions list, suitable to be passed as parameter to vis functions.</h2><span id='topic+rglactions'></span>

<h3>Description</h3>

<p>Create rglactions list, suitable to be passed as parameter to vis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglactions()
</code></pre>


<h3>Value</h3>

<p>named list, an example 'rlgactions' instance that will save a screenshot of the plot produced by the vis function in the current working directory (see <code>getwd</code>), under the name 'fsbrain_out.png'.
</p>


<h3>Note</h3>

<p>List of all available rglactions: (1) 'snapshot_png=filepath' takes a screenshot in PNG format and saves it in at 'filepath'. (2) 'trans_fun=function' uses the transformation function trans_fun to the data before mapping data values to colors and plotting. Popular transformation functions are <code><a href="#topic+limit_fun">limit_fun</a></code>, <code><a href="#topic+limit_fun_na">limit_fun_na</a></code>, and <code><a href="#topic+clip_fun">clip_fun</a></code>. (3) 'text=arglist' calls <code>text3d</code> with the given args after plotting. (4) &lsquo;snapshot_vec=filepath' takes a screenshot in vector format and saves it in at 'filepath'. You also need to set the format via 'snapshot_vec_format', valid entries are one of &quot;ps&quot;, &quot;eps&quot;, &quot;tex&quot;, &quot;pdf&quot;, &quot;svg&quot;, &quot;pgf&quot; (default is &rsquo;eps'). This is experimental and may take a while.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   rgla_screenie = list('snapshot_png'='fsbain_out.png');
   rgla_screenie = rglactions();   # same as above
   rgla_vec_scr = list('snapshot_vec'="~/fsbrain.pdf",
     "snapshot_vec_format"="pdf");
   rgla_clamp = list('trans_fun'=clip.data); # old style
   rgla_clamp = list('trans_fun'=clip_fun(0.05, 0.95)); # new style
   rgla_clamp = list('trans_fun'=clip_fun());            # equivalent.
   rgla_limit = list('trans_fun'=limit_fun(2,5));
   rgla_ls = list('trans_fun'=limit_fun_na(2,5), 'snapshot_png'='~/fig1.png');
</code></pre>

<hr>
<h2 id='rglactions.has.key'>Check for a key in names of rglactions.</h2><span id='topic+rglactions.has.key'></span>

<h3>Description</h3>

<p>Check for a key in names of rglactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglactions.has.key(rglactions, key)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rglactions.has.key_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions, see <code><a href="#topic+rglactions">rglactions</a></code>. The values can be used to specify parameters for the action.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether the <code><a href="#topic+rglactions">rglactions</a></code> instance has the requested key as a name.
</p>

<hr>
<h2 id='rglactions.transform'>Apply data transformation rglactions.</h2><span id='topic+rglactions.transform'></span>

<h3>Description</h3>

<p>Apply data transformation rglactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglactions.transform(measure_data, rglactions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rglactions.transform_+3A_measure_data">measure_data</code></td>
<td>
<p>numeric vector, or hemilist of numeric vectors. The data, usually vertex-wise morphometry data.</p>
</td></tr>
<tr><td><code id="rglactions.transform_+3A_rglactions">rglactions</code></td>
<td>
<p>named list, passed as parameter '<code><a href="#topic+rglactions">rglactions</a></code>' to functions like <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the transformed data
</p>

<hr>
<h2 id='rglo'>Get rgloptions and consider global options.</h2><span id='topic+rglo'></span>

<h3>Description</h3>

<p>This function retrieves the global rgloptions defined in <code>getOption('fsbrain.rgloptions')</code>, or, if this is not set, returns the value from <code><a href="#topic+rglot">rglot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglo()
</code></pre>


<h3>Value</h3>

<p>named list, usable as 'rgloptions' parameter for vis functions like <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>.
</p>


<h3>Note</h3>

<p>You can set the default size for all fsbrain figures to 1200x1200 pixels like this: <code>options("fsbrain.rgloptions"=list("windowRect"=c(50,50,1200,1200)))</code>.
</p>

<hr>
<h2 id='rglot'>Get rgloptions for testing.</h2><span id='topic+rglot'></span>

<h3>Description</h3>

<p>This function defines the figure size that is used during the unit tests. Currently <code>list('windowRect' = c(50, 50, 800, 800)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglot()
</code></pre>


<h3>Value</h3>

<p>named list, usable as 'rgloptions' parameter for vis functions like <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>.
</p>

<hr>
<h2 id='rglvoxels'>Draw 3D boxes at locations using rgl.</h2><span id='topic+rglvoxels'></span>

<h3>Description</h3>

<p>Draw 3D boxes at all given coordinates using rgl, analogous to <code>spheres3d</code>. Constructs the coordinates for triangles making up the boxes, then uses <code>triangles3d</code> to render them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglvoxels(centers, r = 1, voxelcol = NULL, do_show = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rglvoxels_+3A_centers">centers</code></td>
<td>
<p>numerical matrix with 3 columns. Each column represents the x, y, z coordinates of a center at which to create a cube.</p>
</td></tr>
<tr><td><code id="rglvoxels_+3A_r">r</code></td>
<td>
<p>numerical vector or scalar, the cube edge length. This is the length of the axis-parallel edges of the cube. The vector must have length 1 (same edge length for all cubes), or the length must be identical to the number of rows in parameter 'centers'.</p>
</td></tr>
<tr><td><code id="rglvoxels_+3A_voxelcol">voxelcol</code></td>
<td>
<p>vector of rgb color strings for the individual voxels. Its length must be identical to <code>nrow(centers)</code> if given.</p>
</td></tr>
<tr><td><code id="rglvoxels_+3A_do_show">do_show</code></td>
<td>
<p>logical, whether to visualize the result in the current rgl scene</p>
</td></tr>
<tr><td><code id="rglvoxels_+3A_...">...</code></td>
<td>
<p>material properties, passed to <code>triangles3d</code>. Example: <code>color = "#0000ff", lit=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 'fs.coloredvoxels' instances, invisible. The function is called for the side effect of visualizing the data, and usually you can ignore the return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # Plot a 3D cloud of 500 red voxels:
   centers = matrix(rnorm(500*3)*100, ncol=3);
   rglvoxels(centers, voxelcol="red");

## End(Not run)
</code></pre>

<hr>
<h2 id='rotation.matrix.for.axis.rot'>Get rotation matrix for a 3D rotation around an axis.</h2><span id='topic+rotation.matrix.for.axis.rot'></span>

<h3>Description</h3>

<p>Get rotation matrix for a 3D rotation around an axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotation.matrix.for.axis.rot(angle_rad, x, y, z, with_trans = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotation.matrix.for.axis.rot_+3A_angle_rad">angle_rad</code></td>
<td>
<p>doule, the angle in radians</p>
</td></tr>
<tr><td><code id="rotation.matrix.for.axis.rot_+3A_x">x</code></td>
<td>
<p>rotation axis</p>
</td></tr>
<tr><td><code id="rotation.matrix.for.axis.rot_+3A_y">y</code></td>
<td>
<p>rotation axis</p>
</td></tr>
<tr><td><code id="rotation.matrix.for.axis.rot_+3A_z">z</code></td>
<td>
<p>rotation axis</p>
</td></tr>
<tr><td><code id="rotation.matrix.for.axis.rot_+3A_with_trans">with_trans</code></td>
<td>
<p>logical, whether to extend the 3x3 rotation matrix to a 4x4 rotation and tranlsation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3x3 or 4x4 double matrix
</p>

<hr>
<h2 id='scale.to.range.zero.one'>Scale given values to range 0..1.</h2><span id='topic+scale.to.range.zero.one'></span>

<h3>Description</h3>

<p>Scale given values to range 0..1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'to.range.zero.one'
scale(x, ...)
</code></pre>

<hr>
<h2 id='scale01'>Scale given values to range 0..1.</h2><span id='topic+scale01'></span>

<h3>Description</h3>

<p>Scale given values to range 0..1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale01(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale01_+3A_x">x</code></td>
<td>
<p>the numeric data</p>
</td></tr>
<tr><td><code id="scale01_+3A_...">...</code></td>
<td>
<p>the numeric data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the scaled data
</p>

<hr>
<h2 id='shape.descriptor.names'>Get all shape descriptor names.</h2><span id='topic+shape.descriptor.names'></span>

<h3>Description</h3>

<p>Get all shape descriptor names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape.descriptor.names()
</code></pre>


<h3>Value</h3>

<p>vector of character strings, the names
</p>

<hr>
<h2 id='shape.descriptors'>Computes geometric curvature-based descriptors.</h2><span id='topic+shape.descriptors'></span>

<h3>Description</h3>

<p>Computes geometric curvature-based descriptors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape.descriptors(pc, descriptors = shape.descriptor.names())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shape.descriptors_+3A_pc">pc</code></td>
<td>
<p>a 'principal_curvatures' data list, see <code><a href="#topic+principal.curvatures">principal.curvatures</a></code> for details.</p>
</td></tr>
<tr><td><code id="shape.descriptors_+3A_descriptors">descriptors</code></td>
<td>
<p>vector of character strings, the descriptors you want. See <code><a href="#topic+shape.descriptor.names">shape.descriptor.names</a></code> for all available names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe of descriptor values, each columns contains one descriptor.
</p>


<h3>References</h3>

<p>Shimony et al. (2016). Comparison of cortical folding measures for evaluation of developing human brain. Neuroimage, 125, 780-790.
</p>

<hr>
<h2 id='shift.hemis.apart'>Shift hemispheres apart.</h2><span id='topic+shift.hemis.apart'></span>

<h3>Description</h3>

<p>Modify mesh coordinates of a hemilist of coloredmeshes to introduce a gap between the two hemispheres.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift.hemis.apart(
  coloredmeshes_hl,
  shift_by = NULL,
  axis = 1L,
  hemi_order_on_axis = "lr",
  min_dist = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shift.hemis.apart_+3A_coloredmeshes_hl">coloredmeshes_hl</code></td>
<td>
<p>hemilist of coloredmeshes</p>
</td></tr>
<tr><td><code id="shift.hemis.apart_+3A_shift_by">shift_by</code></td>
<td>
<p>numerical vector of length 2, the amount by which to shift the hemis. The first value is for the left hemi, the second for the right hemi (values can be negative). Pass &lsquo;NULL' to determine the shift automatically from the mesh coordinates, and adapt &rsquo;hemi_order_on_axis' to define how that happens.</p>
</td></tr>
<tr><td><code id="shift.hemis.apart_+3A_axis">axis</code></td>
<td>
<p>positive integer, one of 1L, 2L or 3L. The axis on which to shift (x,y,z).</p>
</td></tr>
<tr><td><code id="shift.hemis.apart_+3A_hemi_order_on_axis">hemi_order_on_axis</code></td>
<td>
<p>character string, one of 'auto', 'auto_flipped', 'lr' or 'rl'. Defines how to determine the order of the hemis on the axes. This is ignored unless 'shift_by' is &lsquo;NULL'. The &rsquo;auto' setting assumes that the hemisphere with the smaller minimal vertex coordinate (on the given axis) comes first. Note that if the overlap (or shift) is extreme, this may not hold anymore. Therefore, the default value is 'lr', which works for FreeSurfer data. The 'auto_flipped' setting will always return the inverse of 'auto', so if 'auto' did not work, 'auto_flipped' will.</p>
</td></tr>
<tr><td><code id="shift.hemis.apart_+3A_min_dist">min_dist</code></td>
<td>
<p>numerical scalar, the minimal distance of the hemispheres. Ignored unless 'shift_by' is 'NULL'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hemilist of coloredmeshes, the shifted meshes
</p>

<hr>
<h2 id='shift.hemis.rglactions'>Shift hemis apart if indicated in rglactions</h2><span id='topic+shift.hemis.rglactions'></span>

<h3>Description</h3>

<p>Shift hemis apart if indicated in rglactions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift.hemis.rglactions(coloredmeshes, rglactions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shift.hemis.rglactions_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>hemilist of coloredmeshes</p>
</td></tr>
<tr><td><code id="shift.hemis.rglactions_+3A_rglactions">rglactions</code></td>
<td>
<p>the <code><a href="#topic+rglactions">rglactions</a></code>, a named list as passed to functions like vis.subject.morph.native.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hemilist of coloredmeshes, the coordinates may or may not have been shifted, depending on the <code><a href="#topic+rglactions">rglactions</a></code>.
</p>

<hr>
<h2 id='sjd.demo'>Download optional demo data if needed and return its path.</h2><span id='topic+sjd.demo'></span>

<h3>Description</h3>

<p>This is a wrapper around <code>download_optional_data()</code> and <code>get_optional_data_filepath("subjects_dir")</code>. It will download the optional fsbrain demo data unless it already exists locally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sjd.demo(accept_freesurfer_license = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sjd.demo_+3A_accept_freesurfer_license">accept_freesurfer_license</code></td>
<td>
<p>logical, whether you want to also download fsaverage and fsaverage3, and accept the FreeSurfer license for fsaverage and fsaverage3, available at https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense. Defaults to FALSE. If FALSE, only the demo data from fsbrain itself ('subject1') will be downloaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string, the path to the 'subjects_dir' directory within the downloaded optional data directory.
</p>


<h3>Note</h3>

<p>This function will stop if the data cannot be accessed, i.e., the 'subjects_dir' does not exist after trying to download the data.
</p>

<hr>
<h2 id='sjld'>Get subjects list from subjects.txt file in dir.</h2><span id='topic+sjld'></span>

<h3>Description</h3>

<p>Get subjects list from subjects.txt file in dir.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sjld(subjects_dir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sjld_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>character string, existing subjects dir with a subjects.txt file containing one subject per line and no header line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries: 'd', the query subjects_dir (repeated from the parameter), 'l', vector of character strings, the subjects_list read from the file, 'f', the subjects_file.
</p>


<h3>Note</h3>

<p>This function stops if the file does not exist or cannot be read.
</p>

<hr>
<h2 id='sortcoloredmeshes.by.hemi'>Sort coloredmeshes into 2 lists by their 'hemi' property.</h2><span id='topic+sortcoloredmeshes.by.hemi'></span>

<h3>Description</h3>

<p>Sort coloredmeshes into 2 lists by their 'hemi' property.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortcoloredmeshes.by.hemi(coloredmeshes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sortcoloredmeshes.by.hemi_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of coloredmeshes or other renderables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with two entries: &quot;lh&quot;: list of coloredmeshes that have property hemi set to 'lh'. &quot;rh&quot;: list of coloredmeshes that have property hemi set to 'rh'. The rest is ignored.
</p>

<hr>
<h2 id='sph2fs'>Transform spherical coordinates to FreeSurfer surface space to plot things around a brain.</h2><span id='topic+sph2fs'></span>

<h3>Description</h3>

<p>Transform spherical coordinates to FreeSurfer surface space to plot things around a brain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sph2fs(
  lon,
  lat,
  radius = surf.radius.fsaverage(),
  center = surf.center.fsaverage(),
  deg = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sph2fs_+3A_lon">lon</code></td>
<td>
<p>numerical vector, the longitudes, passed to <code>sphereplot::sph2car</code>. See 'deg' for unit information.</p>
</td></tr>
<tr><td><code id="sph2fs_+3A_lat">lat</code></td>
<td>
<p>numerical vector, the latitudes, passed to <code>sphereplot::sph2car</code>. See 'deg' for unit information.</p>
</td></tr>
<tr><td><code id="sph2fs_+3A_radius">radius</code></td>
<td>
<p>numerical vector, the radii, passed to <code>sphereplot::sph2car</code>. Defaults to the radius of the combined mesh from the fsaverage lh and rh surfaces.</p>
</td></tr>
<tr><td><code id="sph2fs_+3A_center">center</code></td>
<td>
<p>numerical vector of length 3, the x, y, and z coordinates of the target center. The <code>sphereplot::sph2car</code> function operates on the unit sphere, and this parameter is used to translate the resulting cartesian coordinates to a new center, typically the center of the surface meshes or MRI volume or substructures. If you want no translation, pass <code>c(0,0,0)</code>.</p>
</td></tr>
<tr><td><code id="sph2fs_+3A_deg">deg</code></td>
<td>
<p>logical, whether to use degrees (as opposed to radians) as the unit for 'lat' and 'lon'. Passed to <code>sphereplot::sph2car</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function can be used to plot things in FreeSurfer space using spherical coordinates, as commonly used in EEG to define electrode positions. Requires the 'sphereplot' package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # Draw voxels on a sphere around fsaverage:
    lat = seq.int(from=0, to=360, by=30);
    lon = rep(0, length(lat));
    vis.fs.surface('~/software/freesurfer/subjects/fsaverage/surf/lh.white');
    fsbrain::rglvoxels(sph2fs(lat, lon), voxelcol = 'red');
    fsbrain::rglvoxels(sph2fs(lon, lat), voxelcol = 'green');

## End(Not run)

</code></pre>

<hr>
<h2 id='spread.values.over.annot'>Spread a single value for a region to all region vertices.</h2><span id='topic+spread.values.over.annot'></span>

<h3>Description</h3>

<p>Given an annotation and a list of values (one per brain region), return data that has the values for each region mapped to all region vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread.values.over.annot(
  annot,
  region_value_list,
  value_for_unlisted_regions = NaN,
  warn_on_unmatched_list_regions = FALSE,
  warn_on_unmatched_atlas_regions = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spread.values.over.annot_+3A_annot">annot</code></td>
<td>
<p>annotation. The result of calling fs.read.annot.</p>
</td></tr>
<tr><td><code id="spread.values.over.annot_+3A_region_value_list">region_value_list</code></td>
<td>
<p>named list of strings. Each name must be a region name from the annotation, and the value must be the value to spread to all region vertices.</p>
</td></tr>
<tr><td><code id="spread.values.over.annot_+3A_value_for_unlisted_regions">value_for_unlisted_regions</code></td>
<td>
<p>numeric scalar. The value to assign to vertices which are part of atlas regions that are not listed in region_value_list. Defaults to NaN.</p>
</td></tr>
<tr><td><code id="spread.values.over.annot_+3A_warn_on_unmatched_list_regions">warn_on_unmatched_list_regions</code></td>
<td>
<p>logical. Whether to print a warning when a region occurs in the region_value_list that is not part of the given atlas (and the value assigned to this region is thus ignored in the output file and data). Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="spread.values.over.annot_+3A_warn_on_unmatched_atlas_regions">warn_on_unmatched_atlas_regions</code></td>
<td>
<p>logical. Whether to print a warning when a region occurs in the atlas that is not part of the given region_value_list (and thus the vertices of the region will be assigned the value 'value_for_unlisted_regions' in the output file and data). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with following entries: &quot;spread_data&quot;: a vector of length n, where n is the number of vertices in the annotation. One could write this to an MGH or curv file for visualization. &quot;regions_not_in_annot&quot;: list of regions which are not in the annotation, but in the region_value_list. Their values were ignored.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   annot = subject.annot(subjects_dir, 'subject1', 'lh', 'aparc');
   region_value_list = list("bankssts"=0.9, "precuneus"=0.7);
   morph_like_data =
   spread.values.over.annot(annot, region_value_list, value_for_unlisted_regions=0.0);

## End(Not run)

</code></pre>

<hr>
<h2 id='spread.values.over.hemi'>Spread the values in the region_value_list and return them for one hemisphere.</h2><span id='topic+spread.values.over.hemi'></span>

<h3>Description</h3>

<p>Given an atlas and a list that contains one value for each atlas region, create morphometry data in which all region vertices are assigned the value. Can be used to plot stuff like p-values or effect sizes onto brain regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread.values.over.hemi(
  subjects_dir,
  subject_id,
  hemi,
  atlas,
  region_value_list,
  value_for_unlisted_regions = NA,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spread.values.over.hemi_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="spread.values.over.hemi_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="spread.values.over.hemi_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="spread.values.over.hemi_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="spread.values.over.hemi_+3A_region_value_list">region_value_list</code></td>
<td>
<p>named list. A list in which the names are atlas regions, and the values are the value to write to all vertices of that region. You can pass an unnamed list or vector, but then the length must exactly match the number of regions in the atlas, and the order must match the annotation file of the subject and hemisphere. Use with care, and keep in mind that some subjects do not have all regions.</p>
</td></tr>
<tr><td><code id="spread.values.over.hemi_+3A_value_for_unlisted_regions">value_for_unlisted_regions</code></td>
<td>
<p>numeric scalar. The value to assign to vertices which are part of atlas regions that are not listed in region_value_list. Defaults to NaN.</p>
</td></tr>
<tr><td><code id="spread.values.over.hemi_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress mapping info in case of unnamed region value lists (see 'lh_region_value_list' description).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector containing the data.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   region_value_list = list("bankssts"=0.9, "precuneus"=0.7);
   morph_like_data =
   spread.values.over.hemi(subjects_dir, 'subject1', 'lh', 'aparc', region_value_list);

## End(Not run)

</code></pre>

<hr>
<h2 id='spread.values.over.subject'>Spread the values in the region_value_list and return them for one hemisphere.</h2><span id='topic+spread.values.over.subject'></span>

<h3>Description</h3>

<p>Given an atlas and a list that contains one value for each atlas region, create morphometry data in which all region vertices are assigned the value. Can be used to plot stuff like p-values or effect sizes onto brain regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread.values.over.subject(
  subjects_dir,
  subject_id,
  atlas,
  lh_region_value_list,
  rh_region_value_list,
  value_for_unlisted_regions = NaN,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spread.values.over.subject_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="spread.values.over.subject_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="spread.values.over.subject_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="spread.values.over.subject_+3A_lh_region_value_list">lh_region_value_list</code></td>
<td>
<p>named list. A list in which the names are atlas regions, and the values are the value to write to all vertices of that region. Applied to the left hemisphere.</p>
</td></tr>
<tr><td><code id="spread.values.over.subject_+3A_rh_region_value_list">rh_region_value_list</code></td>
<td>
<p>named list. A list in which the names are atlas regions, and the values are the value to write to all vertices of that region. Applied to the right hemisphere.</p>
</td></tr>
<tr><td><code id="spread.values.over.subject_+3A_value_for_unlisted_regions">value_for_unlisted_regions</code></td>
<td>
<p>numeric scalar. The value to assign to vertices which are part of atlas regions that are not listed in region_value_list. Defaults to NaN.</p>
</td></tr>
<tr><td><code id="spread.values.over.subject_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress mapping info in case of unnamed region value lists (see 'lh_region_value_list' description).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries 'lh' and 'rh'. Each value is a numeric vector containing the data for the respective hemisphere.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   lh_region_value_list = list("bankssts"=0.9, "precuneus"=0.7);
   rh_region_value_list = list("bankssts"=0.5);
   morph_like_data =
   spread.values.over.subject(subjects_dir, 'subject1', 'aparc',
   lh_region_value_list, rh_region_value_list);

## End(Not run)

</code></pre>

<hr>
<h2 id='subject.annot'>Load an annotation for a subject.</h2><span id='topic+subject.annot'></span>

<h3>Description</h3>

<p>Load a brain surface annotation, i.e., a cortical parcellation based on an atlas, for a subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.annot(subjects_dir, subject_id, hemi, atlas)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.annot_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.annot_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="subject.annot_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="subject.annot_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the annotation, as returned by <code><a href="freesurferformats.html#topic+read.fs.annot">read.fs.annot</a></code>. It is a named list, enties are: &quot;vertices&quot; vector of n vertex indices, starting with 0. &quot;label_codes&quot;: vector of n integers, each entry is a color code, i.e., a value from the 5th column in the table structure included in the &quot;colortable&quot; entry (see below). &quot;label_names&quot;: the n brain structure names for the vertices, already retrieved from the colortable using the code. &quot;hex_colors_rgb&quot;: Vector of hex color for each vertex.
The &quot;colortable&quot; is another named list with 3 entries: &quot;num_entries&quot;: int, number of brain structures. &quot;struct_names&quot;: vector of strings, the brain structure names. &quot;table&quot;: numeric matrix with num_entries rows and 5 colums. The 5 columns are: 1 = color red channel, 2=color blue channel, 3=color green channel, 4=color alpha channel, 5=unique color code. &quot;colortable_df&quot;: The same information as a dataframe. Contains the extra columns &quot;hex_color_string_rgb&quot; and &quot;hex_color_string_rgba&quot; that hold the color as an RGB(A) hex string, like &quot;#rrggbbaa&quot;.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   annot_lh = subject.annot(subjects_dir, "subject1", "lh", "aparc");

## End(Not run)

</code></pre>

<hr>
<h2 id='subject.annot.border'>Compute annot border vertices.</h2><span id='topic+subject.annot.border'></span>

<h3>Description</h3>

<p>Compute annot border vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.annot.border(
  subjects_dir,
  subject_id,
  hemi,
  atlas,
  surface = "white",
  expand_inwards = 0L,
  limit_to_regions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.annot.border_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.annot.border_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="subject.annot.border_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or 'both'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="subject.annot.border_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="subject.annot.border_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="subject.annot.border_+3A_expand_inwards">expand_inwards</code></td>
<td>
<p>integer, additional thickness of the borders. Increases computation time, defaults to 0L.</p>
</td></tr>
<tr><td><code id="subject.annot.border_+3A_limit_to_regions">limit_to_regions</code></td>
<td>
<p>vector of character strings or NULL, a list of regions for which to draw the outline (see <code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a></code>). If NULL, all regions will be used. If (and only if) this parameter is used, the 'outline_color' parameter can be a vector of color strings, one color per region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hemilist of integer vectors, the vertices in the border
</p>

<hr>
<h2 id='subject.atlas.agg'>Aggregate morphometry data over brain atlas regions for a subject.</h2><span id='topic+subject.atlas.agg'></span>

<h3>Description</h3>

<p>Aggregate morphometry data over brain atlas regions, e.g., compute the mean thickness value over all regions in an atlas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.atlas.agg(
  vertex_morph_data,
  vertex_label_names,
  agg_fun = base::mean,
  requested_label_names = c()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.atlas.agg_+3A_vertex_morph_data">vertex_morph_data</code></td>
<td>
<p>numeric vector. The morphometry data, one value per vertex. The morphometry data are typically loaded from an MGZ or curv format file with the read.fs.curv or read.fs.mgh functions.</p>
</td></tr>
<tr><td><code id="subject.atlas.agg_+3A_vertex_label_names">vertex_label_names</code></td>
<td>
<p>string vector. The region names for the vertices, one string per vertex. The region names are typically loaded from an annotation file with the read.fs.annot function.</p>
</td></tr>
<tr><td><code id="subject.atlas.agg_+3A_agg_fun">agg_fun</code></td>
<td>
<p>function. An R function that aggregates data, typically max, mean, min or something similar. Note: this is NOT a string, put the function name without quotes. Defaults to <code>base::mean</code>.</p>
</td></tr>
<tr><td><code id="subject.atlas.agg_+3A_requested_label_names">requested_label_names</code></td>
<td>
<p>string vector. The label (or region) names that you want to occur in the output. If not specified, all region names which occur in the data are used. If given, and one of the requested names does NOT occur in the data, it will occur in the output with aggregation value NaN. If given, and one of the names from the data does NOT occur in the requested list, it will NOT occur in the output. So if you specify this, the output dataframe will contain a row for a region if and only if it is in the requested list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with aggregated values for all regions, with 2 columns and n rows, where n is the number of effective regions. The columns are: &quot;region&quot;: string, contains the region name. &quot;aggregated&quot;: numeric, contains the result of applying agg_fun to the morphometry data in that region.
</p>


<h3>See Also</h3>

<p>Other aggregation functions: 
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.morph.agg.standard.vertex">group.morph.agg.standard.vertex</a>()</code>
</p>
<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   morph_data = subject.morph.native(subjects_dir, 'subject1', 'thickness', 'lh');
   annot = subject.annot(subjects_dir, 'subject1', 'lh', 'aparc');
   agg = subject.atlas.agg(morph_data, annot$label_names);

## End(Not run)

</code></pre>

<hr>
<h2 id='subject.descriptor.geodesic.average.distance'>Compute mean geodesic distance descriptor for a subject.</h2><span id='topic+subject.descriptor.geodesic.average.distance'></span>

<h3>Description</h3>

<p>For all vertices: compute the mean pseudo-geodesic distance from this vertex to all others in the same hemisphere. Computes <code>|V|^2</code> geodesic distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.descriptor.geodesic.average.distance(
  subjects_dir,
  subject_id,
  surface = "white",
  hemi = "both",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.descriptor.geodesic.average.distance_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.descriptor.geodesic.average.distance_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="subject.descriptor.geodesic.average.distance_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="subject.descriptor.geodesic.average.distance_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or 'both'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="subject.descriptor.geodesic.average.distance_+3A_...">...</code></td>
<td>
<p>extra parameters passed on to <code>geodesic.average.distance</code>. Ignored if 'cortex_only' is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+hemilist">hemilist</a></code> containing vectors with the descriptor data for the requested hemisphere(s). The length of the vectors is the number of vertices in the surface, and the value for a vertex is the mean geodesic distance to all other vertices for this vertex.
</p>


<h3>Note</h3>

<p>This takes quite a while for full-resolution meshes. Use down-sampled versions to quickly try it (see example).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  download_fsaverage3(TRUE);
  sjd = fsaverage.path();
  dist = subject.descriptor.geodesic.average.distance(sjd,
    "fsaverage3", surface = "white", hemi = "both");
  vis.data.on.subject(sjd, "fsaverage3", morph_data_lh = dist$lh);

## End(Not run)

</code></pre>

<hr>
<h2 id='subject.filepath.any'>Construct filepath of any freesurfer file.</h2><span id='topic+subject.filepath.any'></span>

<h3>Description</h3>

<p>Construct filepath of any freesurfer file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.filepath.any(
  subjects_dir,
  subject_id,
  relative_path_parts,
  hemi = NULL,
  file_tag = "",
  warn_if_nonexistent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.filepath.any_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>character string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.filepath.any_+3A_subject_id">subject_id</code></td>
<td>
<p>character string. The subject identifier. Can be a vector of subject identifiers.</p>
</td></tr>
<tr><td><code id="subject.filepath.any_+3A_relative_path_parts">relative_path_parts</code></td>
<td>
<p>vector of strings. The path to the file, e.g., c(&quot;surf&quot;, &quot;lh.area&quot;).</p>
</td></tr>
<tr><td><code id="subject.filepath.any_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or NULL. Defaults to NULL. If a hemisphere name is given, it is added as a prefix to the last entry in relative_path_parts, separated by a dot.</p>
</td></tr>
<tr><td><code id="subject.filepath.any_+3A_file_tag">file_tag</code></td>
<td>
<p>string. A one-word description of the file type that will show up in the error message to describe the file if it is missing. Leads to a better error message. Examples: 'morphometry' or 'label'. Only relevant if warn_if_nonexistent is TRUE. Defaults to the empty string.</p>
</td></tr>
<tr><td><code id="subject.filepath.any_+3A_warn_if_nonexistent">warn_if_nonexistent</code></td>
<td>
<p>logical. Whether to print a warning if the file does not exist or cannot be accessed. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string, the file path. (Or a vector of strings if 'subject_id' is a vector).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fsbrain:::subject.filepath.any("/data/study1", "subject1",
  c("surf", "area"), hemi="lh");
fsbrain:::subject.filepath.any("/data/study1", c("subject1", "subject2"),
  c("surf", "area"), hemi="lh");

## End(Not run)

</code></pre>

<hr>
<h2 id='subject.filepath.morph.native'>Construct filepath of native space morphometry data file.</h2><span id='topic+subject.filepath.morph.native'></span>

<h3>Description</h3>

<p>Construct filepath of native space morphometry data file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.filepath.morph.native(
  subjects_dir,
  subject_id,
  measure,
  hemi,
  format = "curv",
  warn_if_nonexistent = FALSE,
  error_if_nonexistent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.filepath.morph.native_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.native_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.native_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.native_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name.</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.native_+3A_format">format</code></td>
<td>
<p>string. One of 'mgh', 'mgz', 'curv'. Defaults to 'curv'.</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.native_+3A_warn_if_nonexistent">warn_if_nonexistent</code></td>
<td>
<p>logical. Whether to print a warning if the file does not exist or cannot be accessed. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.native_+3A_error_if_nonexistent">error_if_nonexistent</code></td>
<td>
<p>logical. Whether to raise an error if the file does not exist or cannot be accessed. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string, the file path.
</p>

<hr>
<h2 id='subject.filepath.morph.standard'>Construct filepath of standard space morphometry data file.</h2><span id='topic+subject.filepath.morph.standard'></span>

<h3>Description</h3>

<p>Construct filepath of standard space morphometry data file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.filepath.morph.standard(
  subjects_dir,
  subject_id,
  measure,
  hemi,
  fwhm = "10",
  template_subject = "fsaverage",
  format = "auto",
  warn_if_nonexistent = FALSE,
  error_if_nonexistent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.filepath.morph.standard_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.standard_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier. Can be a vector.</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.standard_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.standard_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name.</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.standard_+3A_fwhm">fwhm</code></td>
<td>
<p>string. Smoothing as string, e.g. '10' or '25'. Defaults to '10'.</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.standard_+3A_template_subject">template_subject</code></td>
<td>
<p>string. Template subject name, defaults to 'fsaverage'.</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.standard_+3A_format">format</code></td>
<td>
<p>string. One of 'mgh', 'mgz', 'curv'. Defaults to 'mgh'.</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.standard_+3A_warn_if_nonexistent">warn_if_nonexistent</code></td>
<td>
<p>logical. Whether to print a warning if the file does not exist or cannot be accessed. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="subject.filepath.morph.standard_+3A_error_if_nonexistent">error_if_nonexistent</code></td>
<td>
<p>logical. Whether to raise an error if the file does not exist or cannot be accessed. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string, the file path. (Or a vector if 'subject_id' is a vector.)
</p>

<hr>
<h2 id='subject.label'>Retrieve label data for a single subject.</h2><span id='topic+subject.label'></span>

<h3>Description</h3>

<p>Load a label (like 'label/lh.cortex.label') for a subject from disk. Uses knowledge about the FreeSurfer directory structure to load the correct file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.label(
  subjects_dir,
  subject_id,
  label,
  hemi,
  return_one_based_indices = TRUE,
  full = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.label_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.label_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="subject.label_+3A_label">label</code></td>
<td>
<p>string. Name of the label file, without the hemi part. You can include the '.label' suffix. E.g., 'cortex.label' for '?h.cortex.label'. You can also pass just the label (e.g., 'cortex'): if the string does not end with the suffix '.label', that suffix gets added auomatically.</p>
</td></tr>
<tr><td><code id="subject.label_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or 'both'. The hemisphere name. Used to construct the names of the label data files to be loaded. For 'both', see the information on the return value.</p>
</td></tr>
<tr><td><code id="subject.label_+3A_return_one_based_indices">return_one_based_indices</code></td>
<td>
<p>logical. Whether the indices should be 1-based. Indices are stored zero-based in the file, but R uses 1-based indices. Defaults to TRUE, which means that 1 will be added to all indices read from the file before returning them.</p>
</td></tr>
<tr><td><code id="subject.label_+3A_full">full</code></td>
<td>
<p>logical, whether to return the full label structure instead of only the vertex indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector with label data: the list of vertex indices in the label. See 'return_one_based_indices' for important information. If parameter 'hemi' is set to 'both', a named list with entries 'lh' and 'rh' is returned, and the values of are the respective labels.
</p>


<h3>See Also</h3>

<p>Other label data functions: 
<code><a href="#topic+group.label">group.label</a>()</code>,
<code><a href="#topic+labeldata.from.mask">labeldata.from.mask</a>()</code>,
<code><a href="#topic+mask.from.labeldata.for.hemi">mask.from.labeldata.for.hemi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   cortex_lh = subject.label(subjects_dir, "subject1", "cortex.label", "lh");

## End(Not run)

</code></pre>

<hr>
<h2 id='subject.label.from.annot'>Extract a region from an atlas annotation as a label for a subject.</h2><span id='topic+subject.label.from.annot'></span>

<h3>Description</h3>

<p>The returned label can be used to mask morphometry data, e.g., to set the values of a certain region to NaN or to extract only values from a certain region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.label.from.annot(
  subjects_dir,
  subject_id,
  hemi,
  atlas,
  region,
  return_one_based_indices = TRUE,
  invert = FALSE,
  error_on_invalid_region = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.label.from.annot_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.label.from.annot_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="subject.label.from.annot_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="subject.label.from.annot_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="subject.label.from.annot_+3A_region">region</code></td>
<td>
<p>string. A valid region name for the annotation, i.e., one of the regions of the atlas.</p>
</td></tr>
<tr><td><code id="subject.label.from.annot_+3A_return_one_based_indices">return_one_based_indices</code></td>
<td>
<p>logical. Whether the indices should be 1-based. Indices are stored zero-based in label files, but R uses 1-based indices. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="subject.label.from.annot_+3A_invert">invert</code></td>
<td>
<p>logical. If TRUE, return the indices of all vertices which are NOT part of the region. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="subject.label.from.annot_+3A_error_on_invalid_region">error_on_invalid_region</code></td>
<td>
<p>logical. Whether to throw an error if the given region does not appear in the region list of the annotation. If set to FALSE, this will be ignored and an empty vertex list will be returned. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector with label data: the list of vertex indices in the label.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>
</p>

<hr>
<h2 id='subject.lobes'>Load labels representing brain lobes.</h2><span id='topic+subject.lobes'></span>

<h3>Description</h3>

<p>This gives you labels that represent brain lobes for a subject. The lobe definition is based on the Desikan-Killiany atlas (Desikan *et al.*, 2010) as suggested on the FreeSurfer website at https://surfer.nmr.mgh.harvard.edu/fswiki/CorticalParcellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.lobes(
  subjects_dir,
  subject_id,
  hemi = "both",
  include_cingulate = TRUE,
  as_annot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.lobes_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.lobes_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="subject.lobes_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or 'both'. The hemisphere name. Used to construct the names of the surface file to be loaded. For 'both', see the information on the return value.</p>
</td></tr>
<tr><td><code id="subject.lobes_+3A_include_cingulate">include_cingulate</code></td>
<td>
<p>logical, whether to include the vertices of the cingulate in the lobes</p>
</td></tr>
<tr><td><code id="subject.lobes_+3A_as_annot">as_annot</code></td>
<td>
<p>return a hemilist of annotations instead of the return value described in the *value* section</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hemilist of integer vectors, the vectors represent vertex indices of the hemispheres, and each vertex is assigned one of the following values: '0'=no_lobe, '1'=frontal, '2'=parietal, '3'=temporal, '4'=occipital.
</p>


<h3>See Also</h3>

<p>Other atlas functions: 
<code><a href="#topic+get.atlas.region.names">get.atlas.region.names</a>()</code>,
<code><a href="#topic+group.agg.atlas.native">group.agg.atlas.native</a>()</code>,
<code><a href="#topic+group.agg.atlas.standard">group.agg.atlas.standard</a>()</code>,
<code><a href="#topic+group.annot">group.annot</a>()</code>,
<code><a href="#topic+group.label.from.annot">group.label.from.annot</a>()</code>,
<code><a href="#topic+label.from.annotdata">label.from.annotdata</a>()</code>,
<code><a href="#topic+label.to.annot">label.to.annot</a>()</code>,
<code><a href="#topic+regions.to.ignore">regions.to.ignore</a>()</code>,
<code><a href="#topic+spread.values.over.annot">spread.values.over.annot</a>()</code>,
<code><a href="#topic+spread.values.over.hemi">spread.values.over.hemi</a>()</code>,
<code><a href="#topic+spread.values.over.subject">spread.values.over.subject</a>()</code>,
<code><a href="#topic+subject.annot">subject.annot</a>()</code>,
<code><a href="#topic+subject.atlas.agg">subject.atlas.agg</a>()</code>,
<code><a href="#topic+subject.label.from.annot">subject.label.from.annot</a>()</code>
</p>
<p>Other label functions: 
<code><a href="#topic+apply.label.to.morphdata">apply.label.to.morphdata</a>()</code>,
<code><a href="#topic+apply.labeldata.to.morphdata">apply.labeldata.to.morphdata</a>()</code>,
<code><a href="#topic+subject.mask">subject.mask</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>
</p>

<hr>
<h2 id='subject.mask'>Compute a mask for a subject.</h2><span id='topic+subject.mask'></span>

<h3>Description</h3>

<p>Compute a binary vertex mask for the surface vertices of a subject. By defaults, the medial wall is masked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.mask(
  subjects_dir,
  subject_id,
  hemi = "both",
  from_label = "cortex",
  surf_num_verts = "white",
  invert_mask = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.mask_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.mask_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="subject.mask_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="subject.mask_+3A_from_label">from_label</code></td>
<td>
<p>string, the label file to use. Defaults to 'cortex', which will result in a mask of the medial wall versus cortex vertices.</p>
</td></tr>
<tr><td><code id="subject.mask_+3A_surf_num_verts">surf_num_verts</code></td>
<td>
<p>string or integer. If an integer, interpreted as the number of vertices in the respective surface (lh or rh). If a character string, interpreted as a surface name, (e.g.,'white' or 'pial'), and the respective surface will be loaded to determine the number of vertices in it. If parameter 'hemi' is set to 'both' and you supply the vertex count as an integer, this can be a vector of length 2 if the surfaces have different vertex counts (the first entry for 'lh', the second for 'rh').</p>
</td></tr>
<tr><td><code id="subject.mask_+3A_invert_mask">invert_mask</code></td>
<td>
<p>logical, whether to invert the mask. E.g., when the mask is loaded from the cortex labels, if this is set to FALSE, the cortex would be masked (set to 0 in the final mask). If you want **everything but the cortex** to be masked (set to 0), you should set this to 'TRUE'. Defaults to 'TRUE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mask, a logical vector with the length of the vertices in the surface. If parameter 'hemi' is set to 'both', a named list with entries 'lh' and 'rh' is returned, and the values of are the respective masks.
</p>


<h3>See Also</h3>

<p>Other label functions: 
<code><a href="#topic+apply.label.to.morphdata">apply.label.to.morphdata</a>()</code>,
<code><a href="#topic+apply.labeldata.to.morphdata">apply.labeldata.to.morphdata</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # Generate a binary mask of the medial wall. Wall vertices will
   #  be set to 0, cortex vertices will be set to 1.
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   mask = subject.mask(subjects_dir, "subject1");
   # Print some information on the mask:
   #cat(sprintf("lh: %d verts, %d in cortex, %d medial wall.\n", length(mask$lh),
   # sum(mask$lh), (length(mask$lh)- sum(mask$lh))))
   # Output: lh: 149244 verts, 140891 in cortex, 8353 medial wall.
   # Now visualize the mask to illustrate that it is correct:
   vis.mask.on.subject(subjects_dir, "subject1", mask$lh, mask$rh);

## End(Not run)

</code></pre>

<hr>
<h2 id='subject.morph.native'>Retrieve native space morphometry data for a single subject.</h2><span id='topic+subject.morph.native'></span>

<h3>Description</h3>

<p>Load native space morphometry data (like 'surf/lh.area') for a subject from disk. Uses knowledge about the FreeSurfer directory structure to load the correct file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.morph.native(
  subjects_dir,
  subject_id,
  measure,
  hemi,
  format = "curv",
  cortex_only = FALSE,
  split_by_hemi = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.morph.native_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.morph.native_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="subject.morph.native_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="subject.morph.native_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="subject.morph.native_+3A_format">format</code></td>
<td>
<p>string. One of 'mgh', 'mgz', 'curv'. Defaults to 'curv'.</p>
</td></tr>
<tr><td><code id="subject.morph.native_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to mask the medial wall, i.e., whether the morphometry data for all vertices which are *not* part of the cortex (as defined by the label file 'label/?h.cortex.label') should be replaced with NA values. In other words, setting this to TRUE will ignore the values of the medial wall between the two hemispheres. If set to true, the mentioned label file needs to exist for the subject. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="subject.morph.native_+3A_split_by_hemi">split_by_hemi</code></td>
<td>
<p>logical, whether the returned data should be encapsulated in a named list, where the names are from 'lh' and 'rh', and the values are the respective data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with native space morph data, as returned by <code><a href="freesurferformats.html#topic+read.fs.morph">read.fs.morph</a></code>.
</p>


<h3>See Also</h3>

<p>Other morphometry data functions: 
<code><a href="#topic+apply.label.to.morphdata">apply.label.to.morphdata</a>()</code>,
<code><a href="#topic+apply.labeldata.to.morphdata">apply.labeldata.to.morphdata</a>()</code>,
<code><a href="#topic+group.morph.native">group.morph.native</a>()</code>,
<code><a href="#topic+group.morph.standard">group.morph.standard</a>()</code>,
<code><a href="#topic+subject.morph.standard">subject.morph.standard</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");

   # Load the full data:
   thickness_lh = subject.morph.native(subjects_dir, "subject1", "thickness", "lh");
   mean(thickness_lh);  # prints 2.437466

   # Load the data again, but this time exclude the medial wall:
   thickness_lh_cortex = subject.morph.native(subjects_dir, "subject1", "thickness",
    "lh", cortex_only=TRUE);
   mean(thickness_lh_cortex, na.rm=TRUE);     # prints 2.544132
   vis.data.on.subject(subjects_dir, "subject1", thickness_lh_cortex, NULL);

## End(Not run)

</code></pre>

<hr>
<h2 id='subject.morph.standard'>Retrieve standard space morphometry data for a single subject.</h2><span id='topic+subject.morph.standard'></span>

<h3>Description</h3>

<p>Load standard space morphometry data (like 'surf/lh.area.fwhm10.fsaverage.mgh') for a subject from disk. Uses knowledge about the FreeSurfer directory structure to load the correct file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.morph.standard(
  subjects_dir,
  subject_id,
  measure,
  hemi,
  fwhm = "10",
  template_subject = "fsaverage",
  format = "mgh",
  cortex_only = FALSE,
  split_by_hemi = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.morph.standard_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.morph.standard_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="subject.morph.standard_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="subject.morph.standard_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="subject.morph.standard_+3A_fwhm">fwhm</code></td>
<td>
<p>string. Smoothing as string, e.g. '10' or '25'.</p>
</td></tr>
<tr><td><code id="subject.morph.standard_+3A_template_subject">template_subject</code></td>
<td>
<p>string. Template subject name, defaults to 'fsaverage'.</p>
</td></tr>
<tr><td><code id="subject.morph.standard_+3A_format">format</code></td>
<td>
<p>string. One of 'mgh', 'mgz', 'curv'. Defaults to 'mgh'.</p>
</td></tr>
<tr><td><code id="subject.morph.standard_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to mask the medial wall, i.e., whether the morphometry data for all vertices which are *not* part of the cortex (as defined by the label file 'label/?h.cortex.label') should be replaced with NA values. In other words, setting this to TRUE will ignore the values of the medial wall between the two hemispheres. If set to true, the mentioned label file needs to exist for the template subject. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="subject.morph.standard_+3A_split_by_hemi">split_by_hemi</code></td>
<td>
<p>logical, whether the returned data should be encapsulated in a named list, where the names are from 'lh' and 'rh', and the values are the respective data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with standard space morph data
</p>


<h3>See Also</h3>

<p>Other morphometry data functions: 
<code><a href="#topic+apply.label.to.morphdata">apply.label.to.morphdata</a>()</code>,
<code><a href="#topic+apply.labeldata.to.morphdata">apply.labeldata.to.morphdata</a>()</code>,
<code><a href="#topic+group.morph.native">group.morph.native</a>()</code>,
<code><a href="#topic+group.morph.standard">group.morph.standard</a>()</code>,
<code><a href="#topic+subject.morph.native">subject.morph.native</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   thickness_lh = subject.morph.standard(subjects_dir, "subject1", "thickness", "lh", fwhm='10');

## End(Not run)

</code></pre>

<hr>
<h2 id='subject.num.verts'>Get subjects vertex count.</h2><span id='topic+subject.num.verts'></span>

<h3>Description</h3>

<p>Determine vertex counts for the brain meshes of a subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.num.verts(
  subjects_dir,
  subject_id,
  surface = "white",
  hemi = "both",
  do_sum = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.num.verts_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.num.verts_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="subject.num.verts_+3A_surface">surface</code></td>
<td>
<p>string. The surface name. E.g., &quot;white&quot;, or &quot;pial&quot;. Used to construct the name of the surface file to be loaded.</p>
</td></tr>
<tr><td><code id="subject.num.verts_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or 'both'. The hemisphere name. Used to construct the names of the surface file to be loaded. For 'both', see the information on the return value.</p>
</td></tr>
<tr><td><code id="subject.num.verts_+3A_do_sum">do_sum</code></td>
<td>
<p>logical, whether to return the sum of the vertex counts for lh and rh. Ignored unless 'hemi' is 'both'. If set, a single scalar will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hemilist of integers, the vertex count. If hemi is 'both' and 'do_sum' is 'FALSE', a hemilist of integers is returned. Otherwise, a single integer.
</p>

<hr>
<h2 id='subject.report.html'>Create visual quality check report from QC result.</h2><span id='topic+subject.report.html'></span>

<h3>Description</h3>

<p>Create visual quality check report from QC result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.report.html(
  subjects_dir,
  subjects_list,
  subjects_metadata = list(),
  out_dir = "fsbrain_qc_report",
  keep_existing_images = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.report.html_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.report.html_+3A_subjects_list">subjects_list</code></td>
<td>
<p>string vector. A vector of subject identifiers that match the directory names within subjects_dir.</p>
</td></tr>
<tr><td><code id="subject.report.html_+3A_subjects_metadata">subjects_metadata</code></td>
<td>
<p>named list, keys can be subjects from subjects_list. Each key can hold another named list of strings, represeting arbitrary metadata for that subject that will be displayed in the report.</p>
</td></tr>
<tr><td><code id="subject.report.html_+3A_out_dir">out_dir</code></td>
<td>
<p>character string, path to output dir. The last directory part will be created if it does not exist (but not recursively).</p>
</td></tr>
<tr><td><code id="subject.report.html_+3A_keep_existing_images">keep_existing_images</code></td>
<td>
<p>logical, whether to keep existing images. A lot faster on 2nd call.</p>
</td></tr>
</table>

<hr>
<h2 id='subject.surface'>Load a surface for a subject.</h2><span id='topic+subject.surface'></span>

<h3>Description</h3>

<p>Load a brain surface mesh for a subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.surface(
  subjects_dir,
  subject_id,
  surface = "white",
  hemi = "both",
  force_hemilist = FALSE,
  as_tm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.surface_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.surface_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="subject.surface_+3A_surface">surface</code></td>
<td>
<p>string. The surface name. E.g., &quot;white&quot;, or &quot;pial&quot;. Used to construct the name of the surface file to be loaded.</p>
</td></tr>
<tr><td><code id="subject.surface_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or 'both'. The hemisphere name. Used to construct the names of the surface file to be loaded. For 'both', see the information on the return value.</p>
</td></tr>
<tr><td><code id="subject.surface_+3A_force_hemilist">force_hemilist</code></td>
<td>
<p>logical, whether to return a hemilist even if the 'hemi' parameter is not set to 'both'</p>
</td></tr>
<tr><td><code id="subject.surface_+3A_as_tm">as_tm</code></td>
<td>
<p>logical, whether to return an <code>rgl::tmesh3d</code> instead of an <code>fs.surface</code> instance by applying the <code>fs.surface.to.tmesh3d</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the 'fs.surface' instance, as returned by <code><a href="freesurferformats.html#topic+read.fs.surface">read.fs.surface</a></code>. If parameter 'hemi' is set to 'both', a named list with entries 'lh' and 'rh' is returned, and the values of are the respective surfaces. The mesh data structure used in 'fs.surface' is a *face index set*.
</p>


<h3>See Also</h3>

<p>Other surface mesh functions: 
<code><a href="#topic+face.edges">face.edges</a>()</code>,
<code><a href="#topic+label.border">label.border</a>()</code>,
<code><a href="#topic+mesh.vertex.included.faces">mesh.vertex.included.faces</a>()</code>,
<code><a href="#topic+mesh.vertex.neighbors">mesh.vertex.neighbors</a>()</code>,
<code><a href="#topic+vis.path.along.verts">vis.path.along.verts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   lh_white = subject.surface(subjects_dir, "subject1", "white", "lh");

## End(Not run)

</code></pre>

<hr>
<h2 id='subject.volume'>Read a brain volume.</h2><span id='topic+subject.volume'></span>

<h3>Description</h3>

<p>Load a brain volume (like 'mri/brain.mgz') for a subject from disk. Uses knowledge about the FreeSurfer directory structure to load the correct file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject.volume(
  subjects_dir,
  subject_id,
  volume,
  format = "auto",
  drop_empty_dims = TRUE,
  with_header = FALSE,
  mri_subdir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject.volume_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>character string, the FreeSurfer 'SUBJECTS_DIR', i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.volume_+3A_subject_id">subject_id</code></td>
<td>
<p>character string, the subject identifier.</p>
</td></tr>
<tr><td><code id="subject.volume_+3A_volume">volume</code></td>
<td>
<p>character string, name of the volume file without file extension. Examples: 'brain' or 'aseg'.</p>
</td></tr>
<tr><td><code id="subject.volume_+3A_format">format</code></td>
<td>
<p>string. One of 'mgh', 'mgz', 'AUTO'. If left at the default value 'AUTO', the function will look for files with extensions 'mgh' and 'mgz' (in that order) and use the first one that exists.</p>
</td></tr>
<tr><td><code id="subject.volume_+3A_drop_empty_dims">drop_empty_dims</code></td>
<td>
<p>logical, whether to drop empty dimensions of the returned data. Passed to <code><a href="freesurferformats.html#topic+read.fs.mgh">read.fs.mgh</a></code>.</p>
</td></tr>
<tr><td><code id="subject.volume_+3A_with_header">with_header</code></td>
<td>
<p>logical. Whether to return the header as well. If TRUE, return a named list with entries &quot;data&quot; and &quot;header&quot;. The latter is another named list which contains the header data. These header entries exist: &quot;dtype&quot;: int, one of: 0=MRI_UCHAR; 1=MRI_INT; 3=MRI_FLOAT; 4=MRI_SHORT. &quot;voldim&quot;: integer vector. The volume (=data) dimensions. E.g., c(256, 256, 256, 1). These header entries may exist: &quot;vox2ras_matrix&quot; (exists if &quot;ras_good_flag&quot; is 1), &quot;mr_params&quot; (exists if &quot;has_mr_params&quot; is 1). Passed to <code><a href="freesurferformats.html#topic+read.fs.mgh">read.fs.mgh</a></code>.</p>
</td></tr>
<tr><td><code id="subject.volume_+3A_mri_subdir">mri_subdir</code></td>
<td>
<p>character string or NULL, the subdir to use within the 'mri' directory. Defaults to 'NULL', which means to read directly from the 'mri' dir. You could use this to read volumes from the 'mri/orig/' directory by setting it to 'orig'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical array, the voxel data. If 'with_header', the full volume datastructure (see above).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   brain = subject.volume(subjects_dir, 'subject1', 'brain', with_header = TRUE);
   # Use the vox2ras matrix from the header to compute RAS coordinates at CRS voxel (0, 0, 0):
   brain$header$vox2ras_matrix %*% c(0,0,0,1);

## End(Not run)

</code></pre>

<hr>
<h2 id='submesh.vertex'>Create a submesh including only the given vertices.</h2><span id='topic+submesh.vertex'></span>

<h3>Description</h3>

<p>Create a submesh including only the given vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submesh.vertex(surface_mesh, old_vertex_indices_to_use, ret_mappings = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="submesh.vertex_+3A_surface_mesh">surface_mesh</code></td>
<td>
<p>an fs.surface instance, the original mesh</p>
</td></tr>
<tr><td><code id="submesh.vertex_+3A_old_vertex_indices_to_use">old_vertex_indices_to_use</code></td>
<td>
<p>integer vector, the vertex indices of the 'surface_mesh' that should be used to construct the new sub mesh.</p>
</td></tr>
<tr><td><code id="submesh.vertex_+3A_ret_mappings">ret_mappings</code></td>
<td>
<p>whether to return the vertex mappings. If TRUE, the return value becomes a list with entries 'submesh', 'vmap_full_to_submesh', and 'vmap_submesh_to_full'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the new mesh, made up of the given 'old_vertex_indices_to_use' and all (complete) faces that exist between the query vertices in the source mesh. But see 'ret_mapping' parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sjd = fsaverage.path(T);
sj = "fsaverage";
mesh = subject.surface(sjd, sj, hemi="lh");
lab = subject.label(sjd, sj, "cortex", hemi = "lh");
sm = fsbrain:::submesh.vertex(mesh, lab);
vis.fs.surface(mesh);
vis.fs.surface(sm);

## End(Not run)

</code></pre>

<hr>
<h2 id='surf.avg.vertexradius'>Compute average distance from the origin to each vertex.</h2><span id='topic+surf.avg.vertexradius'></span>

<h3>Description</h3>

<p>Compute average distance from the origin to each vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf.avg.vertexradius(surface, with_stddev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surf.avg.vertexradius_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance, and for the typical use case of this function, a spherical surface.</p>
</td></tr>
<tr><td><code id="surf.avg.vertexradius_+3A_with_stddev">with_stddev</code></td>
<td>
<p>logical, whether to compute the standard deviation as well and return a named list with the 'avg' and the 'stddev' instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar double, the average distance.
</p>


<h3>Note</h3>

<p>This is used to determine the sphere radius for spherical surfaces. It is assumed that the sphere is centered at the origin <code>(0,0,0)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
spherical_surface = subject.surface(fsaverage.path(), "fsaverage3",
  surface="sphere", hemi="lh");
vr = fsbrain:::surf.avg.vertexradius(spherical_surface);
# Show histogram to verify that the surface is a sphere centered at 0,0,0:
hist(freesurferformats::vertexdists.to.point(spherical_surface, c(0,0,0)));
# Plot the coords and a point at the origin:
fsbrain::highlight.points.spheres(rbind(spherical_surface$vertices, c(0,0,0)));

## End(Not run)

</code></pre>

<hr>
<h2 id='surf.center.fsaverage'>Get pre-computed center for fsaverage white surface.</h2><span id='topic+surf.center.fsaverage'></span>

<h3>Description</h3>

<p>Get pre-computed center for fsaverage white surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf.center.fsaverage()
</code></pre>


<h3>Value</h3>

<p>A numerical vector of length 3 with the x, y, and z coordinates of the center. The center was computed as the point halfway between the min and max mesh coordinates, on each axis separately.
</p>


<h3>Note</h3>

<p>The coordinates are for the white surface and in surface space, i.e., based on the raw values stored in the 'fsaverae/surf/lh.white' and 'fsaverage/surf/rh.white' files, without applying any transformation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfs.props">surfs.props</a></code>, which was used to compute the returned values.
</p>

<hr>
<h2 id='surf.metric.properties'>Compute metric surface properties.</h2><span id='topic+surf.metric.properties'></span>

<h3>Description</h3>

<p>Compute metric surface properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf.metric.properties(surface, is_template, template_scale_factor = 1.56)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surf.metric.properties_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance, and for the typical use case of this function, a spherical surface.</p>
</td></tr>
<tr><td><code id="surf.metric.properties_+3A_is_template">is_template</code></td>
<td>
<p>logical, whether the surface comes from a template subject.</p>
</td></tr>
<tr><td><code id="surf.metric.properties_+3A_template_scale_factor">template_scale_factor</code></td>
<td>
<p>double, the template scale factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of metric surface properties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
surface = subject.surface(fsaverage.path(), "fsaverage3", hemi="lh");
mp = surf.metric.properties(surface, is_template = TRUE);

## End(Not run)

</code></pre>

<hr>
<h2 id='surf.radius.fsaverage'>Get pre-computed radius for fsaverage white surface.</h2><span id='topic+surf.radius.fsaverage'></span>

<h3>Description</h3>

<p>Get pre-computed radius for fsaverage white surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf.radius.fsaverage(maxr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surf.radius.fsaverage_+3A_maxr">maxr</code></td>
<td>
<p>logical, whether to return the maximum of the x, y, and z radii.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'maxr' is TRUE, a numeric scalar representing the max of the x, y, and z radii, otherwise, a numerical vector of length 3 with all radii.
</p>


<h3>Note</h3>

<p>The coordinates are for the white surface and in surface space, i.e., based on the raw values stored in the 'fsaverae/surf/lh.white' and 'fsaverage/surf/rh.white' files, without applying any transformation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfs.props">surfs.props</a></code>, which was used to compute the returned values.
</p>

<hr>
<h2 id='surf.sphere.dist'>Compute vertex neighborhoods on a sphere based on the given max distance along the sphere.</h2><span id='topic+surf.sphere.dist'></span>

<h3>Description</h3>

<p>Compute neighborhood of the current vertex (=target vertex). The computation follows the mesh edges while there are still vertices which fullfil the dotproduct distance threshold. Alternatively, one could compute geodesic neighborhoods on the original mesh, but that is a lot slower. If no spherical surface is available, it has to be done though.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf.sphere.dist(spherical_surface, maxdist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surf.sphere.dist_+3A_spherical_surface">spherical_surface</code></td>
<td>
<p>an fs.surface instance representing the spherical version (<code>lh.sphere</code> or <code>rh.sphere</code> of the subject).</p>
</td></tr>
<tr><td><code id="surf.sphere.dist_+3A_maxdist">maxdist</code></td>
<td>
<p>double, the neighborhood size along the sphere, or to be more precise the maximal distance to travel along the sphere (using mesh edges) when searching for neighbors. The maxdist value can be computed from the definition of the Gaussian kernel parameters, i.e., its FWHM and truncation factor. See <code>pervertexdata.smoothgaussian</code> for an example of how to do that. Note that if the distance is smaller than the edge length, the neighborhoods for the vertices will only contain the vertex itself.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with 3 entries. Each is a vector with neighborhood information: 'neigh' is an int vector of the neighbor vertices, 'neigh_dist_dotproduct' a numerical vector of dp distances for these neighbors, and 'neigh_dist_surface' the same for along-the-surface-distances instead of dp distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
spherical_surface = subject.surface(fsaverage.path(), "fsaverage3",
  surface="sphere", hemi="lh");
sphere_dist = surf.sphere.dist(spherical_surface, 20.0);
highlight.vertices.on.subject(fsaverage.path(), "fsaverage3",
  verts_lh = sphere_dist$neigh[[500]], surface="sphere");

## End(Not run)

</code></pre>

<hr>
<h2 id='surf.sphere.gaussianweights'>Compute Gaussian weights</h2><span id='topic+surf.sphere.gaussianweights'></span>

<h3>Description</h3>

<p>Compute Gaussian weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf.sphere.gaussianweights(spherical_surface, sphere_dists, gstd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surf.sphere.gaussianweights_+3A_spherical_surface">spherical_surface</code></td>
<td>
<p>an fs.surface instance representing the spherical version (<code>lh.sphere</code> or <code>rh.sphere</code> of the subject).</p>
</td></tr>
<tr><td><code id="surf.sphere.gaussianweights_+3A_sphere_dists">sphere_dists</code></td>
<td>
<p>list of vectors, as returned by surf.sphere.dist</p>
</td></tr>
<tr><td><code id="surf.sphere.gaussianweights_+3A_gstd">gstd</code></td>
<td>
<p>double, Gaussian standard deviation, can be computed from the FWHM as <code>gstd = fwhm / sqrt(log(256.0))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of Gaussian weights for vertices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fwhm = 20.0; truncfactor = 3.5; sjd = fsaverage.path();
gstd = fwhm / sqrt(log(256.0)); maxdist = truncfactor * gstd;
spherical_surface = subject.surface(sjd, "fsaverage3", surface="sphere", hemi="lh");
sphere_dists = surf.sphere.dist(spherical_surface, maxdist = maxdist);
gaussian_weights = fsbrain:::surf.sphere.gaussianweights(spherical_surface,
 sphere_dists, gstd);
morph_data = rep(NA, nrow(spherical_surface$vertices));
morph_data[sphere_dists$neigh[[500]]] = gaussian_weights[[500]];
vis.data.on.subject(sjd, "fsaverage3", morph_data_lh=morph_data);

## End(Not run)

</code></pre>

<hr>
<h2 id='surf.sphere.spatialfilter'>Apply spatial filter to surface data.</h2><span id='topic+surf.sphere.spatialfilter'></span>

<h3>Description</h3>

<p>Apply spatial filter to surface data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf.sphere.spatialfilter(source_data, sphere_dists, gaussian_weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surf.sphere.spatialfilter_+3A_source_data">source_data</code></td>
<td>
<p>numerical vector, per-vertex data for a surface.</p>
</td></tr>
<tr><td><code id="surf.sphere.spatialfilter_+3A_sphere_dists">sphere_dists</code></td>
<td>
<p>named list with 3 entries, as returned by <code>surf.sphere.dist</code></p>
</td></tr>
<tr><td><code id="surf.sphere.spatialfilter_+3A_gaussian_weights">gaussian_weights</code></td>
<td>
<p>list of double vectors, the Gaussian weights for all neighbors of the respective vertex. As returned by <code>surf.sphere.gaussianweights</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical vector, the spatially filtered per-vertex data.
</p>

<hr>
<h2 id='surface.curvatures'>Compute the k1 and k2 principal curvatures of a mesh.</h2><span id='topic+surface.curvatures'></span>

<h3>Description</h3>

<p>Compute the k1 and k2 principal curvatures of a mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surface.curvatures(surface)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surface.curvatures_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance, as returned by <code>subject.surface</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, the entries 'K1' and 'K2' contain the principal curvatures.
</p>


<h3>Note</h3>

<p>Require the optional dependency package 'Rvcg'.
</p>

<hr>
<h2 id='surfs.props'>Compute simple version of center and radius of 2 meshes.</h2><span id='topic+surfs.props'></span>

<h3>Description</h3>

<p>Compute simple version of center and radius of 2 meshes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfs.props(lh, rh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surfs.props_+3A_lh">lh</code></td>
<td>
<p>'fs.surface' instance, the mesh for the left hemisphere. If a string, assumed to be the path to a surface mesh file that should be loaded.</p>
</td></tr>
<tr><td><code id="surfs.props_+3A_rh">rh</code></td>
<td>
<p>'fs.surface' instance, the mesh for the right hemisphere. If a string, assumed to be the path to a surface mesh file that should be loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with entries 'center', 'radius', 'min' and 'max', each of which are numerical vectors of length 3, holding the x, y and z coordinates or values.
</p>


<h3>Note</h3>

<p>This function treats the 'lh' and 'rh' meshes as a single mesh, and computes the properties for this combined mesh.
</p>

<hr>
<h2 id='symmrange'>Given data, compute symmetric range around zero.</h2><span id='topic+symmrange'></span>

<h3>Description</h3>

<p>Given data, compute symmetric range around zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmrange(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symmrange_+3A_x">x</code></td>
<td>
<p>the data, could be a range of course.</p>
</td></tr>
</table>

<hr>
<h2 id='test.numerical.meandiff'>Perform tests for group differences on paired or unpaired data for two groups.</h2><span id='topic+test.numerical.meandiff'></span>

<h3>Description</h3>

<p>This function is intended to give you a quick overview of your demographics data, it is in no way intended to replace a detailed analysis of your data. You should always visualize and analyze your data interactively instead of relying on automated methods like this. Outliers and are very common in real-world data while perfectly normal data is very rare, multiple testing may affect your results. Look at your data!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.numerical.meandiff(
  colname,
  group1_name,
  group2_name,
  group1_data_column,
  group2_data_column,
  paired
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.numerical.meandiff_+3A_colname">colname</code></td>
<td>
<p>string, the name of the data (used to label the data in the output)</p>
</td></tr>
<tr><td><code id="test.numerical.meandiff_+3A_group1_name">group1_name</code></td>
<td>
<p>string, the name of the first group (used to label the data in the output)</p>
</td></tr>
<tr><td><code id="test.numerical.meandiff_+3A_group2_name">group2_name</code></td>
<td>
<p>string, the name of the first group (used to label the data in the output)</p>
</td></tr>
<tr><td><code id="test.numerical.meandiff_+3A_group1_data_column">group1_data_column</code></td>
<td>
<p>the data for group1 as a numerical vector. Typically a column from your demographics dataframe.</p>
</td></tr>
<tr><td><code id="test.numerical.meandiff_+3A_group2_data_column">group2_data_column</code></td>
<td>
<p>the data for group2 as a numerical vector. Typically a column from your demographics dataframe.</p>
</td></tr>
<tr><td><code id="test.numerical.meandiff_+3A_paired">paired</code></td>
<td>
<p>logical, whether the data is paired (repeated measures).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of strings, the lines of the report. You can print to STDOUT or write it to a file.
</p>

<hr>
<h2 id='test.numerical.meandiff.paired'>Perform tests for group differences on paired data (repeated measurements) for two conditions or time points.</h2><span id='topic+test.numerical.meandiff.paired'></span>

<h3>Description</h3>

<p>This function is intended to give you a quick overview of your demographics data, it is in no way intended to replace a detailed analysis of your data. You should always visualize and analyze your data interactively instead of relying on automated methods like this. Outliers and are very common in real-world data while perfectly normal data is very rare, multiple testing may affect your results. Look at your data!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.numerical.meandiff.paired(
  colname,
  condition1_name,
  condition2_name,
  condition1_data_column,
  condition2_data_column
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.numerical.meandiff.paired_+3A_colname">colname</code></td>
<td>
<p>string, the name of the data (used to label the data in the output)</p>
</td></tr>
<tr><td><code id="test.numerical.meandiff.paired_+3A_condition1_name">condition1_name</code></td>
<td>
<p>string, the name of the first condition (used to label the data in the output)</p>
</td></tr>
<tr><td><code id="test.numerical.meandiff.paired_+3A_condition2_name">condition2_name</code></td>
<td>
<p>string, the name of the first condition (used to label the data in the output)</p>
</td></tr>
<tr><td><code id="test.numerical.meandiff.paired_+3A_condition1_data_column">condition1_data_column</code></td>
<td>
<p>the data for condition1 as a numerical vector. Typically a column from your demographics dataframe.</p>
</td></tr>
<tr><td><code id="test.numerical.meandiff.paired_+3A_condition2_data_column">condition2_data_column</code></td>
<td>
<p>the data for condition2 as a numerical vector. Typically a column from your demographics dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of strings, the lines of the report. You can print to STDOUT or write it to a file.
</p>

<hr>
<h2 id='test.numerical.meandiff.unpaired'>Perform tests for group differences on unpaired data for two groups.</h2><span id='topic+test.numerical.meandiff.unpaired'></span>

<h3>Description</h3>

<p>This function is intended to give you a quick overview of your demographics data, it is in no way intended to replace a detailed analysis of your data. You should always visualize and analyze your data interactively instead of relying on automated methods like this. Outliers and are very common in real-world data while perfectly normal data is very rare, multiple testing may affect your results. Look at your data!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.numerical.meandiff.unpaired(
  colname,
  group1_name,
  group2_name,
  group1_data_column,
  group2_data_column
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.numerical.meandiff.unpaired_+3A_colname">colname</code></td>
<td>
<p>string, the name of the data (used to label the data in the output)</p>
</td></tr>
<tr><td><code id="test.numerical.meandiff.unpaired_+3A_group1_name">group1_name</code></td>
<td>
<p>string, the name of the first group (used to label the data in the output)</p>
</td></tr>
<tr><td><code id="test.numerical.meandiff.unpaired_+3A_group2_name">group2_name</code></td>
<td>
<p>string, the name of the first group (used to label the data in the output)</p>
</td></tr>
<tr><td><code id="test.numerical.meandiff.unpaired_+3A_group1_data_column">group1_data_column</code></td>
<td>
<p>the data for group1 as a numerical vector. Typically a column from your demographics dataframe.</p>
</td></tr>
<tr><td><code id="test.numerical.meandiff.unpaired_+3A_group2_data_column">group2_data_column</code></td>
<td>
<p>the data for group2 as a numerical vector. Typically a column from your demographics dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of strings, the lines of the report. You can print to STDOUT or write it to a file.
</p>

<hr>
<h2 id='tmesh3d.to.fs.surface'>Get an fs.surface brain mesh from an rgl tmesh3d instance.</h2><span id='topic+tmesh3d.to.fs.surface'></span>

<h3>Description</h3>

<p>Get an fs.surface brain mesh from an rgl tmesh3d instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmesh3d.to.fs.surface(tmesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tmesh3d.to.fs.surface_+3A_tmesh">tmesh</code></td>
<td>
<p>a tmesh3d instance, see <code>rgl::tmesh3d</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an fs.surface instance, as returned by <code>subject.surface</code> or <code>freesurferformats::read.fs.surface</code>.
</p>

<hr>
<h2 id='track.length'>Compute the total length of a path given by the coordinates of its points.</h2><span id='topic+track.length'></span>

<h3>Description</h3>

<p>Compute the total length of a path given by the coordinates of its points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track.length(point_coords)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="track.length_+3A_point_coords">point_coords</code></td>
<td>
<p>n x 3 numerical matrix of 3D point coordinates, in the order of traversal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>float, the sum of the length of all segments of the path.
</p>

<hr>
<h2 id='vdata.split.by.hemi'>Split morph data vector at hemisphere boundary.</h2><span id='topic+vdata.split.by.hemi'></span>

<h3>Description</h3>

<p>Given a single vector of per-vertex data for a mesh, split it at the hemi boundary. This is achieved by loading the respective surface and checking the number of vertices for the 2 hemispheres.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vdata.split.by.hemi(
  subjects_dir,
  subject_id,
  vdata,
  surface = "white",
  expand = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vdata.split.by.hemi_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vdata.split.by.hemi_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="vdata.split.by.hemi_+3A_vdata">vdata</code></td>
<td>
<p>numerical vector of data for both hemispheres, one value per vertex</p>
</td></tr>
<tr><td><code id="vdata.split.by.hemi_+3A_surface">surface</code></td>
<td>
<p>the surface to load to determine the vertex counts</p>
</td></tr>
<tr><td><code id="vdata.split.by.hemi_+3A_expand">expand</code></td>
<td>
<p>logical, whether to allow input of length 1, and expand (repeat) it to the length of the hemispheres.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a hemilist, each entry contains the data part of the respective hemisphere.
</p>


<h3>Note</h3>

<p>Instead of calling this function to split the data, you could use the 'split_by_hemi' parameter of <code><a href="#topic+subject.morph.native">subject.morph.native</a></code>.
</p>

<hr>
<h2 id='vertex.coords'>Return coordinates for vertices, supporting entire brain via hemilist.</h2><span id='topic+vertex.coords'></span>

<h3>Description</h3>

<p>Return coordinates for vertices, supporting entire brain via hemilist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex.coords(surface, vertices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vertex.coords_+3A_surface">surface</code></td>
<td>
<p>an fs.surface instance, see <code><a href="#topic+subject.surface">subject.surface</a></code> function. Can also be a hemilist of surfaces, in which case the vertices must be indices over both meshes (in range <code>1..(nv(lh)+nv(rh))</code>). If a hemilist, both entries must be surfaces (non-NULL).</p>
</td></tr>
<tr><td><code id="vertex.coords_+3A_vertices">vertices</code></td>
<td>
<p>vector of positive integers, the vertex indices. Values which are outside of the valid indices for the surface will be silently ignored, making it easier to work with the two hemispheres.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double nx3 matrix of vertex coordinates.
</p>


<h3>See Also</h3>

<p>Other 3d utility functions: 
<code><a href="#topic+highlight.points.spheres">highlight.points.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.spheres">highlight.vertices.spheres</a>()</code>
</p>

<hr>
<h2 id='vertex.hemis'>Return the proper hemi string ('lh' or 'rh') for each vertex.</h2><span id='topic+vertex.hemis'></span>

<h3>Description</h3>

<p>Return the proper hemi string ('lh' or 'rh') for each vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex.hemis(surface, vertices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vertex.hemis_+3A_surface">surface</code></td>
<td>
<p>hemilist of surfaces or a single integer which will be interpreted as the vertex count of the left hemisphere.</p>
</td></tr>
<tr><td><code id="vertex.hemis_+3A_vertices">vertices</code></td>
<td>
<p>vector of positive integers, the query vertex indices. Can be in range <code>1..(nv(lh)+nv(rh))</code>, i.e., across the whole brain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of character strings, each string is 'lh' or 'rh'.
</p>


<h3>Note</h3>

<p>It is not checked in any way whether the vertex indices are out of bounds on the upper side (higher than the highest rh vertex index).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  vertex.hemis(100L, vertices=c(99L, 100L, 101L));

</code></pre>

<hr>
<h2 id='vis.color.on.subject'>Visualize pre-defined vertex colors on a subject.</h2><span id='topic+vis.color.on.subject'></span>

<h3>Description</h3>

<p>Visualize pre-defined vertex colors on a subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.color.on.subject(
  subjects_dir,
  vis_subject_id,
  color_lh = NULL,
  color_rh = NULL,
  surface = "white",
  views = c("t4"),
  rgloptions = rglo(),
  rglactions = list(),
  color_both = NULL,
  style = "default"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.color.on.subject_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.color.on.subject_+3A_vis_subject_id">vis_subject_id</code></td>
<td>
<p>string. The subject identifier from which to obtain the surface for data visualization. Example: 'fsaverage'.</p>
</td></tr>
<tr><td><code id="vis.color.on.subject_+3A_color_lh">color_lh</code></td>
<td>
<p>vector of colors to visualize on the left hemisphere surface. Length must match number of vertices in hemi surface, or be a single color.</p>
</td></tr>
<tr><td><code id="vis.color.on.subject_+3A_color_rh">color_rh</code></td>
<td>
<p>vector of colors to visualize on the right hemisphere surface. Length must match number of vertices in hemi surface, or be a single color.</p>
</td></tr>
<tr><td><code id="vis.color.on.subject_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="vis.color.on.subject_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="vis.color.on.subject_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="vis.color.on.subject_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.color.on.subject_+3A_color_both">color_both</code></td>
<td>
<p>vector of colors to visualize on the left and right hemispheres. Alternative to 'color_lh' and 'color_rh'. Length must match sum of vertices in both hemis. Can also be a hemilist.</p>
</td></tr>
<tr><td><code id="vis.color.on.subject_+3A_style">style</code></td>
<td>
<p>character string or rgl rendering style, see <code><a href="#topic+get.rglstyle">get.rglstyle</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization.
</p>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>
<p>Other surface visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   color_lh = '#ff0000';
   num_verts_subject1_rh = 153333;
   color_rh = rep('#333333', num_verts_subject1_rh);
   color_rh[1:30000] = '#00ff00';
   color_rh[30001:60000] = '#ff0000';
   color_rh[60001:90000] = '#0000ff';
   color_rh[90001:120000] = '#ffff00';
   color_rh[120001:150000] = '#00ffff';
   vis.color.on.subject(subjects_dir, 'subject1', color_lh, color_rh);

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.coloredmesh'>Draw a coloredmesh using a style.</h2><span id='topic+vis.coloredmesh'></span>

<h3>Description</h3>

<p>Draw a coloredmesh using a style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.coloredmesh(cmesh, style = "default")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.coloredmesh_+3A_cmesh">cmesh</code></td>
<td>
<p>a coloredmesh. A coloredmesh is a named list as returned by the coloredmesh.from.* functions. It has the entries 'mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh.</p>
</td></tr>
<tr><td><code id="vis.coloredmesh_+3A_style">style</code></td>
<td>
<p>a named list of style parameters or a string specifying an available style by name (e.g., 'shiny'). Defaults to 'default', the default style. Pass the magic word 'from_mesh' to try to retrieve a style (as a name or a style list) from the field 'style' of the mesh, or default to &quot;default&quot; if the mesh has no such field.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+vis.renderable">vis.renderable</a></code>
</p>

<hr>
<h2 id='vis.coloredmeshes'>Visualize a list of colored meshes in a single scene.</h2><span id='topic+vis.coloredmeshes'></span>

<h3>Description</h3>

<p>Visualize a list of colored meshes in a single scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.coloredmeshes(
  coloredmeshes,
  background = "white",
  skip_all_na = TRUE,
  style = "default",
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.coloredmeshes_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of coloredmesh. A coloredmesh is a named list as returned by the coloredmesh.from.* functions. It has the entries 'mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh.</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes_+3A_background">background</code></td>
<td>
<p>string, background color passed to rgl::bg3d()</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes_+3A_skip_all_na">skip_all_na</code></td>
<td>
<p>logical, whether to skip (i.e., not render) meshes in the list that have the property 'render' set to FALSE. Defaults to TRUE. Practically, this means that a hemisphere for which the data was not given is not rendered, instead of being rendered in a single color.</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes_+3A_style">style</code></td>
<td>
<p>a named list of style parameters or a string specifying an available style by name (e.g., 'shiny'). Defaults to 'default', the default style.</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>;</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. Defaults to the empty list.</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical. Whether to draw a colorbar. WARNING: Will only show up if there is enough space in the plot area and does not resize properly. Defaults to FALSE. See <code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a></code> for an alternative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of visualized coloredmeshes
</p>


<h3>Note</h3>

<p>To change or adapt the colorbar, you should use the makecmap_options parameter when constructing them in a vis function. See the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   cm = vis.subject.morph.native(subjects_dir, 'subject1', 'thickness',
    makecmap_options=list('n'=100, 'colFn'=viridis::viridis));
   # You could mess with the meshes here.
   vis.coloredmeshes(cm);

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.coloredmeshes.rotating'>Visualize a list of colored meshes in a single scene and rotate them, movie-style.</h2><span id='topic+vis.coloredmeshes.rotating'></span>

<h3>Description</h3>

<p>Visualize a list of colored meshes in a single scene and rotate them, movie-style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.coloredmeshes.rotating(
  coloredmeshes,
  background = "white",
  skip_all_na = TRUE,
  style = "default",
  x = 0,
  y = 0,
  z = 1,
  rpm = 6,
  duration = 10,
  rgloptions = rglo(),
  rglactions = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.coloredmeshes.rotating_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of coloredmesh. A coloredmesh is a named list as returned by the coloredmesh.from.* functions. It has the entries 'mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh.</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes.rotating_+3A_background">background</code></td>
<td>
<p>string, background color passed to rgl::bg3d()</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes.rotating_+3A_skip_all_na">skip_all_na</code></td>
<td>
<p>logical, whether to skip (i.e., not render) meshes in the list that have the property 'rendner' set to FALSE. Defaults to TRUE. Practically, this means that a hemisphere for which the data was not given is not rendered, instead of being rendered in a single color.</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes.rotating_+3A_style">style</code></td>
<td>
<p>a named list of style parameters or a string specifying an available style by name (e.g., 'shiny'). Defaults to 'default', the default style.</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes.rotating_+3A_x">x</code></td>
<td>
<p>rotation x axis value, passed to <code>spin3d</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes.rotating_+3A_y">y</code></td>
<td>
<p>rotation y axis value, passed to <code>spin3d</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes.rotating_+3A_z">z</code></td>
<td>
<p>rotation z axis value, passed to <code>spin3d</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes.rotating_+3A_rpm">rpm</code></td>
<td>
<p>rotation rpm value, passed to <code>spin3d</code>. Defaults to 15.</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes.rotating_+3A_duration">duration</code></td>
<td>
<p>rotation duration value, passed to <code>spin3d</code>. Defaults to 20.</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes.rotating_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: rgloptions = list(&quot;windowRect&quot;=c(50,50,1000,1000));</p>
</td></tr>
<tr><td><code id="vis.coloredmeshes.rotating_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. Defaults to the empty list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of visualized coloredmeshes
</p>

<hr>
<h2 id='vis.colortable.legend'>Create a separate legend plot for a colortable or an annotation.</h2><span id='topic+vis.colortable.legend'></span>

<h3>Description</h3>

<p>This plots a legend for a colortable or an atlas (annotation), showing the region names and their assigned colors. This function creates a new plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.colortable.legend(colortable, ncols = 1L, plot_struct_index = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.colortable.legend_+3A_colortable">colortable</code></td>
<td>
<p>dataframe, a colortable as returned by <code><a href="freesurferformats.html#topic+read.fs.colortable">read.fs.colortable</a></code> or the inner 'colortable_df' returned by <code><a href="#topic+subject.annot">subject.annot</a></code>. One can also pass an annotation (*fs.annot* instance).</p>
</td></tr>
<tr><td><code id="vis.colortable.legend_+3A_ncols">ncols</code></td>
<td>
<p>positive integer, the number of columns to use when plotting</p>
</td></tr>
<tr><td><code id="vis.colortable.legend_+3A_plot_struct_index">plot_struct_index</code></td>
<td>
<p>logical, whether to plot the region index from tge 'struct_index' field. If there is no such field, this is silently ignored.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function plots one or more legends (see <code><a href="graphics.html#topic+legend">legend</a></code>). You may have to adapt the device size before calling this function if you inted to plot a large colortable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   annot = subject.annot(subjects_dir, 'subject1', 'lh', 'aparc');
   vis.colortable.legend(annot$colortable_df, ncols=3);

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.data.on.fsaverage'>Visualize arbitrary data on the fsaverage template subject, if available.</h2><span id='topic+vis.data.on.fsaverage'></span>

<h3>Description</h3>

<p>Creates a surface mesh, applies a colormap transform the morphometry data values into colors, and renders the resulting colored mesh in an interactive window. If hemi is 'both', the data is rendered for the whole brain. This function tries to automatically retrieve the subjects dir of the fsaverage template subject by checking the environment variables SUBJECTS_DIR and FREESURFER_HOME for the subject. The subject is required for its surfaces, which are not shipped with this package for licensing reasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.data.on.fsaverage(
  subjects_dir = NULL,
  vis_subject_id = "fsaverage",
  morph_data_lh = NULL,
  morph_data_rh = NULL,
  surface = "white",
  views = c("t4"),
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE,
  makecmap_options = mkco.seq(),
  bg = NULL,
  morph_data_both = NULL,
  style = "default"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.data.on.fsaverage_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.data.on.fsaverage_+3A_vis_subject_id">vis_subject_id</code></td>
<td>
<p>string. The subject identifier from which to obtain the surface for data visualization. Defaults to 'fsaverage'.</p>
</td></tr>
<tr><td><code id="vis.data.on.fsaverage_+3A_morph_data_lh">morph_data_lh</code></td>
<td>
<p>numeric vector or character string or NULL, the data to visualize on the left hemisphere surface. If a string, it is treated as a filename and data is loaded from it first. When it is a numerical vector, this is assumed to be the data already. The data must have the same length as the surface of the vis_subject_id has vertices. If NULL, this surface will not be rendered. Only one of morph_data_lh or morph_data_rh is allowed to be NULL.</p>
</td></tr>
<tr><td><code id="vis.data.on.fsaverage_+3A_morph_data_rh">morph_data_rh</code></td>
<td>
<p>numeric vector or character string or NULL, the data to visualize on the right hemisphere surface. If a string, it is treated as a filename and data is loaded from it first. When it is a numerical vector, this is assumed to be the data already.  The data must have the same length as the surface of the vis_subject_id has vertices. If NULL, this surface will not be rendered. Only one of morph_data_lh or morph_data_rh is allowed to be NULL.</p>
</td></tr>
<tr><td><code id="vis.data.on.fsaverage_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="vis.data.on.fsaverage_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="vis.data.on.fsaverage_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="vis.data.on.fsaverage_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.data.on.fsaverage_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical or one of the character strings 'vertical' or 'horizontal', whether to draw a colorbar. Notice: the colorbar is drawn to a separate subplot, and this only works if there is enough space for it, i.e., the plot resolution must be high enough. You may have to increase the plot size for the colorbar to show up, see the vignette for instructions. Defaults to 'FALSE'. See  <code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a></code> for an alternative.</p>
</td></tr>
<tr><td><code id="vis.data.on.fsaverage_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'. Should include at least a colormap function as name 'colFn'.</p>
</td></tr>
<tr><td><code id="vis.data.on.fsaverage_+3A_bg">bg</code></td>
<td>
<p>a background definition. Can be a surface color layer or a character string like 'curv_light' to select a pre-defined layer, see <code><a href="#topic+collayer.bg">collayer.bg</a></code> for valid strings.</p>
</td></tr>
<tr><td><code id="vis.data.on.fsaverage_+3A_morph_data_both">morph_data_both</code></td>
<td>
<p>numeric vector or NULL, the data to visualize on both hemispheres. This must be a single vector with length equal to the sum of the vertex counts of the left and the right hemisphere. The data for the left hemisphere must come first. If this is given, 'morph_data_lh' and 'morph_data_rh' must be NULL.</p>
</td></tr>
<tr><td><code id="vis.data.on.fsaverage_+3A_style">style</code></td>
<td>
<p>character string, a rendering style, e.g., 'default', 'shiny' or 'semitransparent'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization.
</p>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>
<p>Other morphometry visualization functions: 
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>
</p>

<hr>
<h2 id='vis.data.on.group.native'>Visualize native space data on a group of subjects.</h2><span id='topic+vis.data.on.group.native'></span>

<h3>Description</h3>

<p>Plot surface data on the native space surfaces of a group of subjects and combine the tiles into a single large image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.data.on.group.native(
  subjects_dir,
  subject_id,
  morph_data_both,
  view_angles = "sd_dorsal",
  output_img = "fsbrain_group_morph.png",
  num_per_row = 5L,
  captions = subject_id,
  rglactions = list(no_vis = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.data.on.group.native_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.native_+3A_subject_id">subject_id</code></td>
<td>
<p>vector of character strings, the subject identifiers</p>
</td></tr>
<tr><td><code id="vis.data.on.group.native_+3A_morph_data_both">morph_data_both</code></td>
<td>
<p>named list of numerical vectors, the morph data for both hemispheres of all subjects. Can be loaded with <code><a href="#topic+group.morph.native">group.morph.native</a></code>.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.native_+3A_view_angles">view_angles</code></td>
<td>
<p>see <code><a href="#topic+get.view.angle.names">get.view.angle.names</a></code>.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.native_+3A_output_img">output_img</code></td>
<td>
<p>character string, the file path for the output image. Should end with '.png'.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.native_+3A_num_per_row">num_per_row</code></td>
<td>
<p>positive integer, the number of tiles per row.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.native_+3A_captions">captions</code></td>
<td>
<p>optional vector of character strings, the short text annotations for the individual tiles. Typically used to plot the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.native_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.native_+3A_...">...</code></td>
<td>
<p>extra parameters passed to the subject level visualization function. Not all may make sense in this context. Example: <code>surface='pial'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, see the return value of <code><a href="#topic+arrange.brainview.images.grid">arrange.brainview.images.grid</a></code> for details.
</p>


<h3>Note</h3>

<p>The subjects are plotted row-wise, in the order in which they appear in the 'morph_data_both' parameter. The surfaces are loaded in the order of the 'subject_id' parameter, so the order in both must match.
</p>
<p>You can force an identical plot range for all subjects, so that one color represents identical values across subjects, via 'makecmap_options'. E.g., for the ... parameter, pass <code>makecmap_options=list('colFn'=viridis::viridis, 'range'=c(0, 4)))</code>.
</p>


<h3>See Also</h3>

<p>Other group visualization functions: 
<code><a href="#topic+vis.data.on.group.standard">vis.data.on.group.standard</a>()</code>,
<code><a href="#topic+vis.group.annot">vis.group.annot</a>()</code>,
<code><a href="#topic+vis.group.coloredmeshes">vis.group.coloredmeshes</a>()</code>,
<code><a href="#topic+vis.group.morph.native">vis.group.morph.native</a>()</code>,
<code><a href="#topic+vis.group.morph.standard">vis.group.morph.standard</a>()</code>
</p>

<hr>
<h2 id='vis.data.on.group.standard'>Visualize standard space data for a group on template.</h2><span id='topic+vis.data.on.group.standard'></span>

<h3>Description</h3>

<p>Plot standard space data for a group of subjects onto a template brain and combine the tiles into a single large image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.data.on.group.standard(
  subjects_dir,
  vis_subject_id,
  morph_data_both,
  captions = NULL,
  view_angles = "sd_dorsal",
  output_img = "fsbrain_group_morph.png",
  num_per_row = 5L,
  rglactions = list(no_vis = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.data.on.group.standard_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>character string, the path to the SUBJECTS_DIR containing the template subject</p>
</td></tr>
<tr><td><code id="vis.data.on.group.standard_+3A_vis_subject_id">vis_subject_id</code></td>
<td>
<p>character string, the template subject name. A typical choice is 'fsaverage'.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.standard_+3A_morph_data_both">morph_data_both</code></td>
<td>
<p>named list of numerical vectors, 4D array or dataframe, the morph data for both hemispheres of all subjects. Can be loaded with <code><a href="#topic+group.morph.standard">group.morph.standard</a></code> or <code><a href="#topic+group.morph.standard.sf">group.morph.standard.sf</a></code>.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.standard_+3A_captions">captions</code></td>
<td>
<p>optional vector of character strings, the short text annotations for the individual tiles. Typically used to plot the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.standard_+3A_view_angles">view_angles</code></td>
<td>
<p>see <code><a href="#topic+get.view.angle.names">get.view.angle.names</a></code>.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.standard_+3A_output_img">output_img</code></td>
<td>
<p>character string, the file path for the output image. Should end with '.png'.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.standard_+3A_num_per_row">num_per_row</code></td>
<td>
<p>positive integer, the number of tiles per row.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.standard_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.data.on.group.standard_+3A_...">...</code></td>
<td>
<p>extra parameters passed to the subject level visualization function. Not all may make sense in this context. Example: <code>surface='pial'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, see the return value of <code><a href="#topic+arrange.brainview.images.grid">arrange.brainview.images.grid</a></code> for details.
</p>


<h3>Note</h3>

<p>The subject data are plotted row-wise, in the order in which they appear in the 'morph_data_both' parameter.
</p>
<p>You can force an identical plot range for all subjects, so that one color represents identical values across subjects, via 'makecmap_options'. E.g., for the ... parameter, pass <code>makecmap_options=list('colFn'=viridis::viridis, 'range'=c(0, 4)))</code>.
</p>


<h3>See Also</h3>

<p>Other group visualization functions: 
<code><a href="#topic+vis.data.on.group.native">vis.data.on.group.native</a>()</code>,
<code><a href="#topic+vis.group.annot">vis.group.annot</a>()</code>,
<code><a href="#topic+vis.group.coloredmeshes">vis.group.coloredmeshes</a>()</code>,
<code><a href="#topic+vis.group.morph.native">vis.group.morph.native</a>()</code>,
<code><a href="#topic+vis.group.morph.standard">vis.group.morph.standard</a>()</code>
</p>

<hr>
<h2 id='vis.data.on.subject'>Visualize arbitrary data on the surface of any subject.</h2><span id='topic+vis.data.on.subject'></span>

<h3>Description</h3>

<p>Creates a surface mesh, applies a colormap transform the morphometry data values into colors, and renders the resulting colored mesh in an interactive window. If hemi is 'both', the data is rendered for the whole brain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.data.on.subject(
  subjects_dir,
  vis_subject_id,
  morph_data_lh = NULL,
  morph_data_rh = NULL,
  surface = "white",
  views = c("t4"),
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE,
  makecmap_options = mkco.seq(),
  bg = NULL,
  morph_data_both = NULL,
  style = "default"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.data.on.subject_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.data.on.subject_+3A_vis_subject_id">vis_subject_id</code></td>
<td>
<p>string. The subject identifier from which to obtain the surface for data visualization. Example: 'fsaverage'.</p>
</td></tr>
<tr><td><code id="vis.data.on.subject_+3A_morph_data_lh">morph_data_lh</code></td>
<td>
<p>numeric vector or character string or NULL, the data to visualize on the left hemisphere surface. If a string, it is treated as a filename and data is loaded from it first. When it is a numerical vector, this is assumed to be the data already. The data must have the same length as the surface of the vis_subject_id has vertices. If NULL, this surface will not be rendered. Only one of morph_data_lh or morph_data_rh is allowed to be NULL.</p>
</td></tr>
<tr><td><code id="vis.data.on.subject_+3A_morph_data_rh">morph_data_rh</code></td>
<td>
<p>numeric vector or character string or NULL, the data to visualize on the right hemisphere surface. If a string, it is treated as a filename and data is loaded from it first. When it is a numerical vector, this is assumed to be the data already.  The data must have the same length as the surface of the vis_subject_id has vertices. If NULL, this surface will not be rendered. Only one of morph_data_lh or morph_data_rh is allowed to be NULL.</p>
</td></tr>
<tr><td><code id="vis.data.on.subject_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="vis.data.on.subject_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="vis.data.on.subject_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="vis.data.on.subject_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.data.on.subject_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical or one of the character strings 'vertical' or 'horizontal', whether to draw a colorbar. Notice: the colorbar is drawn to a separate subplot, and this only works if there is enough space for it, i.e., the plot resolution must be high enough. You may have to increase the plot size for the colorbar to show up, see the vignette for instructions. Defaults to 'FALSE'. See  <code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a></code> for an alternative.</p>
</td></tr>
<tr><td><code id="vis.data.on.subject_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'. Should include at least a colormap function as name 'colFn'.</p>
</td></tr>
<tr><td><code id="vis.data.on.subject_+3A_bg">bg</code></td>
<td>
<p>a background definition. Can be a surface color layer or a character string like 'curv_light' to select a pre-defined layer, see <code><a href="#topic+collayer.bg">collayer.bg</a></code> for valid strings.</p>
</td></tr>
<tr><td><code id="vis.data.on.subject_+3A_morph_data_both">morph_data_both</code></td>
<td>
<p>numeric vector or NULL, the data to visualize on both hemispheres. This must be a single vector with length equal to the sum of the vertex counts of the left and the right hemisphere. The data for the left hemisphere must come first. If this is given, 'morph_data_lh' and 'morph_data_rh' must be NULL.</p>
</td></tr>
<tr><td><code id="vis.data.on.subject_+3A_style">style</code></td>
<td>
<p>character string, a rendering style, e.g., 'default', 'shiny' or 'semitransparent'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization.
</p>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>
<p>Other morphometry visualization functions: 
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   morph_data_lh = subject.morph.native(subjects_dir, 'subject1', 'thickness', 'lh');
   morph_data_rh = NULL;
   vis.data.on.subject(subjects_dir, 'subject1', morph_data_lh, morph_data_rh);

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.dti.trk'>Visualize DTI tracks from Diffusion Toolkit/TrackVis TRK format file.</h2><span id='topic+vis.dti.trk'></span>

<h3>Description</h3>

<p>Visualize DTI tracks from Diffusion Toolkit/TrackVis TRK format file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.dti.trk(
  trk,
  filter_tracks = list(min_length = 15, min_segment_count = 6),
  color_by_orientation = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.dti.trk_+3A_trk">trk</code></td>
<td>
<p>character string, the path to a TRK file that should be loaded. Alternatively, a loaded <code>trk</code> instance as returned by <code>freesurferformats::read.dti.trk</code>.</p>
</td></tr>
<tr><td><code id="vis.dti.trk_+3A_filter_tracks">filter_tracks</code></td>
<td>
<p>optional, named list of filters. Can contain fields <code>min_length</code> and <code>min_segment_count</code>. Set the whole thing to <code>NULL</code> or an entry to 0 for no filtering.</p>
</td></tr>
<tr><td><code id="vis.dti.trk_+3A_color_by_orientation">color_by_orientation</code></td>
<td>
<p>logical, whether to color the tracks by orientation. Slower, but may make the resulting visualization easier to interprete.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (loaded or received) <code>trk</code> instance. Note that this function is typically called for the side effect of visualization.
</p>


<h3>Note</h3>

<p>The current simple implementation is very slow if the number of tracks becomes large (several thousand tracks).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create the following file with Diffusion Toolkit from your DTI data:
trk = freesurferformats::read.dti.trk("~/data/tim_only/tim/DICOM/dti.trk");
vis.dti.trk(trk);

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.export.from.coloredmeshes'>Export high-quality brainview image with a colorbar.</h2><span id='topic+vis.export.from.coloredmeshes'></span>

<h3>Description</h3>

<p>This function serves as an easy (but slightly inflexible) way to export a high-quality, tight-layout, colorbar figure to disk. If no colorbar is required, one can use <code>vislayout.from.coloredmeshes</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.export.from.coloredmeshes(
  coloredmeshes,
  colorbar_legend = NULL,
  img_only = TRUE,
  horizontal = TRUE,
  silent = TRUE,
  quality = 1L,
  output_img = "fsbrain_arranged.png",
  image.plot_extra_options = NULL,
  large_legend = TRUE,
  view_angles = get.view.angle.names(angle_set = "t4"),
  style = "default",
  grid_like = TRUE,
  background_color = "white",
  transparency_color = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.export.from.coloredmeshes_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of coloredmesh. A coloredmesh is a named list as returned by the 'coloredmesh.from*' functions (like <code><a href="#topic+coloredmesh.from.morph.native">coloredmesh.from.morph.native</a></code>). It has the entries 'mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh. The 'vis*' functions (like <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>) all return a list of coloredmeshes.</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_colorbar_legend">colorbar_legend</code></td>
<td>
<p>character string or NULL, the title for the colorbar.</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_img_only">img_only</code></td>
<td>
<p>logical, whether to return only the resulting image</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_horizontal">horizontal</code></td>
<td>
<p>logical, whether to plot the colorbar horizontally (TRUE) or vertically (FALSE). Pass 'NULL' to force no colorbar at all.</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress messages</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_quality">quality</code></td>
<td>
<p>integer, an arbitrary quality. This is the resolution per tile before trimming, divided by 1000, in pixels. Example: 1L means 1000x1000 pixels per tile before trimming. Currently supported values: <code>1L..2L</code>. Note that the resolution you can get is also limited by your screen resolution.</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_output_img">output_img</code></td>
<td>
<p>string, path to the output file. Defaults to &quot;fsbrain_arranged.png&quot;</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_image.plot_extra_options">image.plot_extra_options</code></td>
<td>
<p>named list, custom options for fields::image.plot. Overwrites those derived from the quality setting. If in doubt, leave this alone.</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_large_legend">large_legend</code></td>
<td>
<p>logical, whether to plot extra large legend text, affects the font size of the colorbar_legend and the tick labels.</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_view_angles">view_angles</code></td>
<td>
<p>list of strings. See <code><a href="#topic+get.view.angle.names">get.view.angle.names</a></code> for all valid strings.</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_style">style</code></td>
<td>
<p>the rendering style, see <code>material3d</code> or use a predefined style like 'default' or 'shiny'.</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_grid_like">grid_like</code></td>
<td>
<p>logical, passed to <code>vislayout.from.coloredmeshes</code>.</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_background_color">background_color</code></td>
<td>
<p>hex color string (like '#FFFFFF'), the color to use for the background. Ignored if 'transparency_color' is not NULL. To get a transparent background, use 'transparency_color' instead of this parameter. WARNING: Do not use color names (like 'gray'), as their interpretation differs between rgl and image magick!</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_transparency_color">transparency_color</code></td>
<td>
<p>hex color string (like '#FFFFFF'), the temporary background color that will get mapped to transparency, or NULL if you do not want a transparent background. If used, it can be any color that does not occur in the foreground. Try '#FFFFFF' (white) or '#000000' (black) if in doubt. WARNING: Do not use color names (like 'gray'), as their interpretation differs between rgl and image magick!</p>
</td></tr>
<tr><td><code id="vis.export.from.coloredmeshes_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code>vislayout.from.coloredmeshes</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>magick image instance or named list, depending on the value of 'img_only'. If the latter, the list contains the fields 'rev_vl', 'rev_cb', and 'rev_ex', which are the return values of the functions <code>vislayout.from.coloredmeshes</code>, <code>coloredmesh.plot.colorbar.separate</code>, and <code>combine.colorbar.with.brainview.image</code>, respectively.
</p>


<h3>Note</h3>

<p>Note that your screen resolution has to be high enough to generate the final image in the requested resolution, see the 'fsbrain FAQ' vignette for details and solutions if you run into trouble.
</p>


<h3>See Also</h3>

<p>This function should not be used anymore, it will be deprecated soon. Please use the <code><a href="#topic+export">export</a></code> function instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    rand_data = rnorm(327684, 5, 1.5);
    cm = vis.data.on.fsaverage(morph_data_both=rand_data,
      rglactions=list('no_vis'=T));
    vis.export.from.coloredmeshes(cm, colorbar_legend='Random data',
      output_img="~/fsbrain_arranged.png");

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.fs.surface'>Visualize fs.surface mesh</h2><span id='topic+vis.fs.surface'></span>

<h3>Description</h3>

<p>Render a mesh. All mesh formats supported by the *freesurferformats* package are supported, including OFF, PLY, OBJ, STL, and many more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.fs.surface(
  fs_surface,
  col = "white",
  per_vertex_data = NULL,
  hemi = "lh",
  makecmap_options = mkco.seq(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.fs.surface_+3A_fs_surface">fs_surface</code></td>
<td>
<p>an fs.surface instance, as returned by function like <code><a href="#topic+subject.surface">subject.surface</a></code> or <code><a href="freesurferformats.html#topic+read.fs.surface">read.fs.surface</a></code>. If a character string, it is assumed to be the full path of a surface file, and the respective file is loaded with <code><a href="freesurferformats.html#topic+read.fs.surface">read.fs.surface</a></code>. If parameter 'hemi' is 'both', this must be a hemilist. A single <code>rgl::tmesh</code> is also fine.</p>
</td></tr>
<tr><td><code id="vis.fs.surface_+3A_col">col</code></td>
<td>
<p>vector of colors, the per-vertex-colors. Defaults to white. Must be a single color or one color per vertex. If parameter 'hemi' is 'both', this must be a hemilist.</p>
</td></tr>
<tr><td><code id="vis.fs.surface_+3A_per_vertex_data">per_vertex_data</code></td>
<td>
<p>numerical vector, per-vertex data. If given, takes precedence over 'col'. Used to color the mesh using the colormap options in parameter 'makecmap_options'. If a character string, it is assumed to be the full path of a morphometry data file, and the respective file is loaded with <code><a href="freesurferformats.html#topic+read.fs.morph">read.fs.morph</a></code>. If parameter 'hemi' is 'both', this must be a hemilist.</p>
</td></tr>
<tr><td><code id="vis.fs.surface_+3A_hemi">hemi</code></td>
<td>
<p>character string, one of 'lh' or 'rh'. This may be used by visualization functions to decide whether or not to show this mesh in a certain view.</p>
</td></tr>
<tr><td><code id="vis.fs.surface_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'. Should include at least a colormap function as name 'colFn'.</p>
</td></tr>
<tr><td><code id="vis.fs.surface_+3A_...">...</code></td>
<td>
<p>extra parameters to pass to <code><a href="#topic+vis.coloredmeshes">vis.coloredmeshes</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see <code><a href="#topic+vis.coloredmeshes">vis.coloredmeshes</a></code>
</p>


<h3>Note</h3>

<p>This function can be used to visualize arbitrary triangular meshes in R. Despite its name, it is not limited to brain surface meshes.
</p>

<hr>
<h2 id='vis.group.annot'>Plot atlas annotations for a group of subjects.</h2><span id='topic+vis.group.annot'></span>

<h3>Description</h3>

<p>Plot atlas annotations for a group of subjects and combine them into a single large image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.group.annot(
  subjects_dir,
  subject_id,
  atlas,
  view_angles = "sd_dorsal",
  output_img = "fsbrain_group_annot.png",
  num_per_row = 5L,
  captions = subject_id,
  rglactions = list(no_vis = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.group.annot_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.group.annot_+3A_subject_id">subject_id</code></td>
<td>
<p>vector of character strings, the subject identifiers</p>
</td></tr>
<tr><td><code id="vis.group.annot_+3A_atlas">atlas</code></td>
<td>
<p>vector of character strings, the atlas names. Example: <code>c('aparc', 'aparc.a2009s')</code></p>
</td></tr>
<tr><td><code id="vis.group.annot_+3A_view_angles">view_angles</code></td>
<td>
<p>see <code><a href="#topic+get.view.angle.names">get.view.angle.names</a></code>.</p>
</td></tr>
<tr><td><code id="vis.group.annot_+3A_output_img">output_img</code></td>
<td>
<p>character string, the file path for the output image. Should end with '.png'.</p>
</td></tr>
<tr><td><code id="vis.group.annot_+3A_num_per_row">num_per_row</code></td>
<td>
<p>positive integer, the number of tiles per row.</p>
</td></tr>
<tr><td><code id="vis.group.annot_+3A_captions">captions</code></td>
<td>
<p>optional vector of character strings, the short text annotations for the individual tiles. Typically used to plot the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.group.annot_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.group.annot_+3A_...">...</code></td>
<td>
<p>extra parameters passed to the subject level visualization function. Not all may make sense in this context. Example: <code>surface='pial'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, see the return value of <code><a href="#topic+arrange.brainview.images.grid">arrange.brainview.images.grid</a></code> for details.
</p>


<h3>Note</h3>

<p>The subjects are plotted row-wise, in the order in which they appear in the 'subject_id' parameter. This function is vectorized over 'subject_id' and 'atlas'.
</p>


<h3>See Also</h3>

<p>Other group visualization functions: 
<code><a href="#topic+vis.data.on.group.native">vis.data.on.group.native</a>()</code>,
<code><a href="#topic+vis.data.on.group.standard">vis.data.on.group.standard</a>()</code>,
<code><a href="#topic+vis.group.coloredmeshes">vis.group.coloredmeshes</a>()</code>,
<code><a href="#topic+vis.group.morph.native">vis.group.morph.native</a>()</code>,
<code><a href="#topic+vis.group.morph.standard">vis.group.morph.standard</a>()</code>
</p>

<hr>
<h2 id='vis.group.coloredmeshes'>Plot coloredmeshes for a group of subjects.</h2><span id='topic+vis.group.coloredmeshes'></span>

<h3>Description</h3>

<p>Plot coloredmeshes for a group of subjects into a single image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.group.coloredmeshes(
  coloredmeshes,
  view_angles = "sd_dorsal",
  output_img = "fsbrain_group_annot.png",
  num_per_row = 5L,
  captions = NULL,
  background_color = "white"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.group.coloredmeshes_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>a list of coloredmeshes lists, each entry in the outer list contains the hemilist of coloredmeshes (lefgt and right hemisphere mesh) for one subject.</p>
</td></tr>
<tr><td><code id="vis.group.coloredmeshes_+3A_view_angles">view_angles</code></td>
<td>
<p>see <code><a href="#topic+get.view.angle.names">get.view.angle.names</a></code>.</p>
</td></tr>
<tr><td><code id="vis.group.coloredmeshes_+3A_output_img">output_img</code></td>
<td>
<p>character string, the file path for the output image. Should end with '.png'.</p>
</td></tr>
<tr><td><code id="vis.group.coloredmeshes_+3A_num_per_row">num_per_row</code></td>
<td>
<p>positive integer, the number of tiles per row.</p>
</td></tr>
<tr><td><code id="vis.group.coloredmeshes_+3A_captions">captions</code></td>
<td>
<p>optional vector of character strings, the short text annotations for the individual tiles. Typically used to plot the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.group.coloredmeshes_+3A_background_color">background_color</code></td>
<td>
<p>color for image background (transparency is not supported).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, see the return value of <code><a href="#topic+arrange.brainview.images.grid">arrange.brainview.images.grid</a></code> for details.
</p>


<h3>Note</h3>

<p>This is a mid-level function, end users may want to call high-level functions like <code><a href="#topic+vis.group.annot">vis.group.annot</a></code> instead.
</p>


<h3>See Also</h3>

<p>Other group visualization functions: 
<code><a href="#topic+vis.data.on.group.native">vis.data.on.group.native</a>()</code>,
<code><a href="#topic+vis.data.on.group.standard">vis.data.on.group.standard</a>()</code>,
<code><a href="#topic+vis.group.annot">vis.group.annot</a>()</code>,
<code><a href="#topic+vis.group.morph.native">vis.group.morph.native</a>()</code>,
<code><a href="#topic+vis.group.morph.standard">vis.group.morph.standard</a>()</code>
</p>

<hr>
<h2 id='vis.group.morph.native'>Plot native space morphometry data for a group of subjects.</h2><span id='topic+vis.group.morph.native'></span>

<h3>Description</h3>

<p>Plot native space morphometry data for a group of subjects and combine them into a single large image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.group.morph.native(
  subjects_dir,
  subject_id,
  measure,
  view_angles = "sd_dorsal",
  output_img = "fsbrain_group_morph.png",
  num_per_row = 5L,
  captions = subject_id,
  rglactions = list(no_vis = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.group.morph.native_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.group.morph.native_+3A_subject_id">subject_id</code></td>
<td>
<p>vector of character strings, the subject identifiers</p>
</td></tr>
<tr><td><code id="vis.group.morph.native_+3A_measure">measure</code></td>
<td>
<p>vector of character strings, the morphometry measures, e.g., <code>c('thickness', 'area')</code></p>
</td></tr>
<tr><td><code id="vis.group.morph.native_+3A_view_angles">view_angles</code></td>
<td>
<p>see <code><a href="#topic+get.view.angle.names">get.view.angle.names</a></code>.</p>
</td></tr>
<tr><td><code id="vis.group.morph.native_+3A_output_img">output_img</code></td>
<td>
<p>character string, the file path for the output image. Should end with '.png'.</p>
</td></tr>
<tr><td><code id="vis.group.morph.native_+3A_num_per_row">num_per_row</code></td>
<td>
<p>positive integer, the number of tiles per row.</p>
</td></tr>
<tr><td><code id="vis.group.morph.native_+3A_captions">captions</code></td>
<td>
<p>optional vector of character strings, the short text annotations for the individual tiles. Typically used to plot the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.group.morph.native_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.group.morph.native_+3A_...">...</code></td>
<td>
<p>extra parameters passed to the subject level visualization function. Not all may make sense in this context. Example: <code>surface='pial'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, see the return value of <code><a href="#topic+arrange.brainview.images.grid">arrange.brainview.images.grid</a></code> for details.
</p>


<h3>Note</h3>

<p>The subjects are plotted row-wise, in the order in which they appear in the 'subject_id' parameter. This function is vectorized over 'subject_id' and 'measure'.
</p>
<p>You can force an identical plot range for all subjects, so that one color represents identical values across subjects, via 'makecmap_options'. E.g., for the ... parameter, pass <code>makecmap_options=list('colFn'=viridis::viridis, 'range'=c(0, 4)))</code>.
</p>


<h3>See Also</h3>

<p>Other group visualization functions: 
<code><a href="#topic+vis.data.on.group.native">vis.data.on.group.native</a>()</code>,
<code><a href="#topic+vis.data.on.group.standard">vis.data.on.group.standard</a>()</code>,
<code><a href="#topic+vis.group.annot">vis.group.annot</a>()</code>,
<code><a href="#topic+vis.group.coloredmeshes">vis.group.coloredmeshes</a>()</code>,
<code><a href="#topic+vis.group.morph.standard">vis.group.morph.standard</a>()</code>
</p>

<hr>
<h2 id='vis.group.morph.standard'>Plot standard space morphometry data for a group of subjects.</h2><span id='topic+vis.group.morph.standard'></span>

<h3>Description</h3>

<p>Plot standard space morphometry data for a group of subjects and combine them into a single large image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.group.morph.standard(
  subjects_dir,
  subject_id,
  measure,
  fwhm = "10",
  view_angles = "sd_dorsal",
  output_img = "fsbrain_group_morph.png",
  num_per_row = 5L,
  captions = subject_id,
  rglactions = list(no_vis = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.group.morph.standard_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.group.morph.standard_+3A_subject_id">subject_id</code></td>
<td>
<p>vector of character strings, the subject identifiers</p>
</td></tr>
<tr><td><code id="vis.group.morph.standard_+3A_measure">measure</code></td>
<td>
<p>vector of character strings, the morphometry measures, e.g., <code>c('thickness', 'area')</code></p>
</td></tr>
<tr><td><code id="vis.group.morph.standard_+3A_fwhm">fwhm</code></td>
<td>
<p>vector of character strings, the smoothing kernel FWHM strings, e.g., <code>c('0', '10', '15')</code></p>
</td></tr>
<tr><td><code id="vis.group.morph.standard_+3A_view_angles">view_angles</code></td>
<td>
<p>see <code><a href="#topic+get.view.angle.names">get.view.angle.names</a></code>.</p>
</td></tr>
<tr><td><code id="vis.group.morph.standard_+3A_output_img">output_img</code></td>
<td>
<p>character string, the file path for the output image. Should end with '.png'.</p>
</td></tr>
<tr><td><code id="vis.group.morph.standard_+3A_num_per_row">num_per_row</code></td>
<td>
<p>positive integer, the number of tiles per row.</p>
</td></tr>
<tr><td><code id="vis.group.morph.standard_+3A_captions">captions</code></td>
<td>
<p>optional vector of character strings, the short text annotations for the individual tiles. Typically used to plot the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.group.morph.standard_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.group.morph.standard_+3A_...">...</code></td>
<td>
<p>extra parameters passed to the subject level visualization function. Not all may make sense in this context. Example: <code>surface='pial'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, see the return value of <code><a href="#topic+arrange.brainview.images.grid">arrange.brainview.images.grid</a></code> for details.
</p>


<h3>Note</h3>

<p>The subjects are plotted row-wise, in the order in which they appear in the 'subject_id' parameter. This function is vectorized over 'subject_id', 'measure' and 'fwhm'.
</p>
<p>You can force an identical plot range for all subjects, so that one color represents identical values across subjects, via 'makecmap_options'. E.g., for the ... parameter, pass <code>makecmap_options=list('colFn'=viridis::viridis, 'range'=c(0, 4)))</code>.
</p>


<h3>See Also</h3>

<p>Other group visualization functions: 
<code><a href="#topic+vis.data.on.group.native">vis.data.on.group.native</a>()</code>,
<code><a href="#topic+vis.data.on.group.standard">vis.data.on.group.standard</a>()</code>,
<code><a href="#topic+vis.group.annot">vis.group.annot</a>()</code>,
<code><a href="#topic+vis.group.coloredmeshes">vis.group.coloredmeshes</a>()</code>,
<code><a href="#topic+vis.group.morph.native">vis.group.morph.native</a>()</code>
</p>

<hr>
<h2 id='vis.labeldata.on.subject'>Visualize a label on the surface of a subject.</h2><span id='topic+vis.labeldata.on.subject'></span>

<h3>Description</h3>

<p>Visualizes a label. Note that a label is just a set of vertices, and that you can use this function to visualize sets of vertices, e.g., to see where on the mesh a certain vertex lies. It may be helpful the visualize the vertex with its neighbors, because otherwise it may be too small to spot. Use the function [fsbrain::mesh.vertex.neighbors] to get them. It is advisable to set the view to the interactive 'si' mode and use the 'inflated' surface to identify single vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.labeldata.on.subject(
  subjects_dir,
  vis_subject_id,
  lh_labeldata,
  rh_labeldata,
  surface = "white",
  views = c("t4"),
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE,
  makecmap_options = list(colFn = label.colFn.inv),
  style = "default",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.labeldata.on.subject_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.labeldata.on.subject_+3A_vis_subject_id">vis_subject_id</code></td>
<td>
<p>string. The subject identifier from which to obtain the surface for data visualization. Example: 'fsaverage'.</p>
</td></tr>
<tr><td><code id="vis.labeldata.on.subject_+3A_lh_labeldata">lh_labeldata</code></td>
<td>
<p>integer vector of vertex indices for the left hemisphere</p>
</td></tr>
<tr><td><code id="vis.labeldata.on.subject_+3A_rh_labeldata">rh_labeldata</code></td>
<td>
<p>integer vector of vertex indices for the right hemisphere</p>
</td></tr>
<tr><td><code id="vis.labeldata.on.subject_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="vis.labeldata.on.subject_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="vis.labeldata.on.subject_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="vis.labeldata.on.subject_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.labeldata.on.subject_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical or one of the character strings 'vertical' or 'horizontal', whether to draw a colorbar. Notice: the colorbar is drawn to a separate subplot, and this only works if there is enough space for it, i.e., the plot resolution must be high enough. You may have to increase the plot size for the colorbar to show up, see the vignette for instructions. Defaults to 'FALSE'. See  <code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a></code> for an alternative.</p>
</td></tr>
<tr><td><code id="vis.labeldata.on.subject_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'. Should include at least a colormap function as name 'colFn'.</p>
</td></tr>
<tr><td><code id="vis.labeldata.on.subject_+3A_style">style</code></td>
<td>
<p>character string, a rendering style, e.g., 'default', 'shiny' or 'semitransparent'.</p>
</td></tr>
<tr><td><code id="vis.labeldata.on.subject_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to <code><a href="#topic+coloredmesh.from.label">coloredmesh.from.label</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization.
</p>


<h3>Note</h3>

<p>Drawing a colorbar for label data makes limited sense, use a legend instead. The colorbar can give a rough overview of the relative number of label and non-label vertices though, so it is possible to request one.
</p>


<h3>See Also</h3>

<p>Other label functions: 
<code><a href="#topic+apply.label.to.morphdata">apply.label.to.morphdata</a>()</code>,
<code><a href="#topic+apply.labeldata.to.morphdata">apply.labeldata.to.morphdata</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>,
<code><a href="#topic+subject.mask">subject.mask</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>
</p>
<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();

  # Define the data to use:
  subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
  lh_labeldata = c(1000, 1001, 1002);   # only the vertices, will be tiny.
  subject_id = 'subject1';
  surface = 'white'; # Should use 'inflated', but we do not currently
                     # ship it for the example subject to reduce download size.

  # For the right hemi, extend them to neighborhood for better visibility:
  rh_labeldata = c(500, 5000);
  rh_surface = subject.surface(subjects_dir, subject_id, surface, 'rh');
  rh_labeldata_neighborhood = mesh.vertex.neighbors(rh_surface, rh_labeldata);
  vis.labeldata.on.subject(subjects_dir, subject_id, lh_labeldata,
   rh_labeldata_neighborhood$vertices, surface=surface, views=c('si'));

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.mask.on.subject'>Visualize a vertex mask on the surface of a subject.</h2><span id='topic+vis.mask.on.subject'></span>

<h3>Description</h3>

<p>A mask is a logical vector that contains one value per vertex. You can create it manually, or use functions like <code><a href="#topic+mask.from.labeldata.for.hemi">mask.from.labeldata.for.hemi</a></code> to create and modify it. Check the example for this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.mask.on.subject(
  subjects_dir,
  vis_subject_id,
  mask_lh,
  mask_rh,
  surface = "white",
  views = c("t4"),
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE,
  makecmap_options = list(colFn = label.colFn.inv),
  style = "default"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.mask.on.subject_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.mask.on.subject_+3A_vis_subject_id">vis_subject_id</code></td>
<td>
<p>string. The subject identifier from which to obtain the surface for data visualization. Example: 'fsaverage'.</p>
</td></tr>
<tr><td><code id="vis.mask.on.subject_+3A_mask_lh">mask_lh</code></td>
<td>
<p>logical vector or NULL, the mask to visualize on the left hemisphere surface. Must have the same length as the lh surface of the vis_subject_id has vertices. If NULL, this surface will not be rendered. Only one of mask_lh or mask_rh is allowed to be NULL.</p>
</td></tr>
<tr><td><code id="vis.mask.on.subject_+3A_mask_rh">mask_rh</code></td>
<td>
<p>logical vector or NULL, the mask to visualize on the right hemisphere surface. Must have the same length as the rh surface of the vis_subject_id has vertices. If NULL, this surface will not be rendered. Only one of mask_lh or mask_rh is allowed to be NULL.</p>
</td></tr>
<tr><td><code id="vis.mask.on.subject_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="vis.mask.on.subject_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="vis.mask.on.subject_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="vis.mask.on.subject_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.mask.on.subject_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical or one of the character strings 'vertical' or 'horizontal', whether to draw a colorbar. Notice: the colorbar is drawn to a separate subplot, and this only works if there is enough space for it, i.e., the plot resolution must be high enough. You may have to increase the plot size for the colorbar to show up, see the vignette for instructions. Defaults to 'FALSE'. See  <code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a></code> for an alternative.</p>
</td></tr>
<tr><td><code id="vis.mask.on.subject_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'. Should include at least a colormap function as name 'colFn'.</p>
</td></tr>
<tr><td><code id="vis.mask.on.subject_+3A_style">style</code></td>
<td>
<p>character string, a rendering style, e.g., 'default', 'shiny' or 'semitransparent'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization.
</p>


<h3>Note</h3>

<p>Drawing a colorbar for label data makes limited sense, use a legend instead. The colorbar can give a rough overview of the relative number of label and non-label vertices though, so it is possible to request one.
</p>


<h3>See Also</h3>

<p>Other mask functions: 
<code><a href="#topic+coloredmesh.from.mask">coloredmesh.from.mask</a>()</code>,
<code><a href="#topic+mask.from.labeldata.for.hemi">mask.from.labeldata.for.hemi</a>()</code>
</p>
<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();

  # Define the data to use:
  subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
  subject_id = 'subject1';
  surface = 'white';
  hemi = 'both';
  atlas = 'aparc';
  region = 'bankssts';

  # Create a mask from a region of an annotation:
  lh_annot = subject.annot(subjects_dir, subject_id, 'lh', atlas);
  rh_annot = subject.annot(subjects_dir, subject_id, 'rh', atlas);
  lh_label = label.from.annotdata(lh_annot, region);
  rh_label = label.from.annotdata(rh_annot, region);
  lh_mask = mask.from.labeldata.for.hemi(lh_label, length(lh_annot$vertices));
  rh_mask = mask.from.labeldata.for.hemi(rh_label, length(rh_annot$vertices));

  # Edit the mask: add the vertices from another region to it:
  region2 = 'medialorbitofrontal';
  lh_label2 = label.from.annotdata(lh_annot, region2);
  rh_label2 = label.from.annotdata(rh_annot, region2);
  lh_mask2 = mask.from.labeldata.for.hemi(lh_label2, length(lh_annot$vertices),
   existing_mask = lh_mask);
  rh_mask2 = mask.from.labeldata.for.hemi(rh_label2, length(rh_annot$vertices),
   existing_mask = rh_mask);
  # Visualize the mask:
  vis.mask.on.subject(subjects_dir, subject_id, lh_mask2, rh_mask2);

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.path.along.verts'>Draw a 3D line from vertex to vertex</h2><span id='topic+vis.path.along.verts'></span>

<h3>Description</h3>

<p>To get a nice path along the surface, pass the vertex indices along a geodesic path. Note: You can first open an interactive brain view (&lsquo;views=&rsquo;si'') with a vis* function like <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>, then run this function to draw into the active plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.path.along.verts(
  surface_vertices,
  path_vertex_indices = NULL,
  do_vis = TRUE,
  color = "#FF0000",
  no_material = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.path.along.verts_+3A_surface_vertices">surface_vertices</code></td>
<td>
<p>float matrix of size (n, 3), the surface vertex coordinates, as returned as part of <code><a href="#topic+subject.surface">subject.surface</a></code> or <code><a href="freesurferformats.html#topic+read.fs.surface">read.fs.surface</a></code>, in the member &quot;vertices&quot;. Can also be a <code>freesurferformats::fs.surface</code> or <code>rgl::tmesh3d</code> instance, in which case the coordinates are extracted automatically.</p>
</td></tr>
<tr><td><code id="vis.path.along.verts_+3A_path_vertex_indices">path_vertex_indices</code></td>
<td>
<p>vector of vertex indices, the path. You will need to have it computed already. (This function does **not** compute geodesic paths, see <code><a href="#topic+geodesic.path">geodesic.path</a></code> for that. You can use it to visualize such a path though.) If omitted, the vertex coordinates will be traversed in their given order to create the path.</p>
</td></tr>
<tr><td><code id="vis.path.along.verts_+3A_do_vis">do_vis</code></td>
<td>
<p>logical, whether to actually draw the path.</p>
</td></tr>
<tr><td><code id="vis.path.along.verts_+3A_color">color</code></td>
<td>
<p>a color string, like '#FF0000' to color the path.</p>
</td></tr>
<tr><td><code id="vis.path.along.verts_+3A_no_material">no_material</code></td>
<td>
<p>logical, whether to use set the custom rendering material properties for path visualization using <code>rgl::material3d</code> before plotting. If you set this to FALSE, no material will be set and you should set it yourself before calling this function, otherwise the looks of the path are undefined (dependent on the default material on your system, or the last material call). Setting this to TRUE also means that the 'color' argument is ignored of course, as the color is part of the material.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n x 3 matrix, the coordinates of the path, with appropriate ones duplicated for rgl pair-wise segments3d rendering.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vis.paths">vis.paths</a></code> if you need to draw many paths, <code><a href="#topic+geodesic.path">geodesic.path</a></code> to compute a geodesic path.
</p>
<p>Other surface mesh functions: 
<code><a href="#topic+face.edges">face.edges</a>()</code>,
<code><a href="#topic+label.border">label.border</a>()</code>,
<code><a href="#topic+mesh.vertex.included.faces">mesh.vertex.included.faces</a>()</code>,
<code><a href="#topic+mesh.vertex.neighbors">mesh.vertex.neighbors</a>()</code>,
<code><a href="#topic+subject.surface">subject.surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  sjd = fsaverage.path(TRUE);
  surface = subject.surface(sjd, 'fsaverage3',
    surface = "white", hemi = "lh");
  p = geodesic.path(surface, 5, c(10, 20));
  vis.subject.morph.native(sjd, 'fsaverage3', views='si');
  vis.path.along.verts(surface$vertices, p[[1]]);

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.paths'>Visualize many paths.</h2><span id='topic+vis.paths'></span>

<h3>Description</h3>

<p>Visualize many paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.paths(coords_list, path_color = "#FF0000")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.paths_+3A_coords_list">coords_list</code></td>
<td>
<p>list of <code>m</code> matrices, each <code>n</code> x 3 matrix must contain the 3D coords for one path.</p>
</td></tr>
<tr><td><code id="vis.paths_+3A_path_color">path_color</code></td>
<td>
<p>a color value, the color in which to plot the paths.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is a lot faster than calling <code>vis.path.along.verts</code> many times and having it draw each time.
</p>

<hr>
<h2 id='vis.paths.along.verts'>Visualize several paths in different colors.</h2><span id='topic+vis.paths.along.verts'></span>

<h3>Description</h3>

<p>Visualize several paths in different colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.paths.along.verts(
  surface_vertices,
  paths,
  color = viridis::viridis(length(paths))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.paths.along.verts_+3A_surface_vertices">surface_vertices</code></td>
<td>
<p>float matrix of size (n, 3), the surface vertex coordinates, as returned as part of <code><a href="#topic+subject.surface">subject.surface</a></code> or <code><a href="freesurferformats.html#topic+read.fs.surface">read.fs.surface</a></code>, in the member &quot;vertices&quot;. Can also be a <code>freesurferformats::fs.surface</code> or <code>rgl::tmesh3d</code> instance, in which case the coordinates are extracted automatically.</p>
</td></tr>
<tr><td><code id="vis.paths.along.verts_+3A_paths">paths</code></td>
<td>
<p>list of positive integer vectors, the vertex indices of the paths</p>
</td></tr>
<tr><td><code id="vis.paths.along.verts_+3A_color">color</code></td>
<td>
<p>a color string, like '#FF0000' to color the path.</p>
</td></tr>
</table>

<hr>
<h2 id='vis.region.values.on.subject'>Visualize arbitrary data, one value per atlas region, on the surface of any subject (including template subjects).</h2><span id='topic+vis.region.values.on.subject'></span>

<h3>Description</h3>

<p>This function can be used for rendering a single value (color) for all vertices of an atlas region. The typical usecase is the visualization of results of atlas-based analyses, e.g., p-value, means or other aggregated values over all vertices of a region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.region.values.on.subject(
  subjects_dir,
  subject_id,
  atlas,
  lh_region_value_list,
  rh_region_value_list,
  surface = "white",
  views = c("t4"),
  rgloptions = rglo(),
  rglactions = list(),
  value_for_unlisted_regions = NA,
  draw_colorbar = FALSE,
  makecmap_options = mkco.heat(),
  bg = NULL,
  silent = FALSE,
  style = "default",
  border = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.region.values.on.subject_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_atlas">atlas</code></td>
<td>
<p>string. The brain atlas to use. E.g., 'aparc' or 'aparc.a2009s'.</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_lh_region_value_list">lh_region_value_list</code></td>
<td>
<p>named list. A list for the left hemisphere in which the names are atlas regions, and the values are the value to write to all vertices of that region. You can pass an unnamed list, but then the its length must exactly match the number of atlas regions. The order of values must also match the order of regions in the annotation, of course. The resulting mapping will be printed so you can check it (unless 'silent' is set).</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_rh_region_value_list">rh_region_value_list</code></td>
<td>
<p>named list. A list for the right hemisphere in which the names are atlas regions, and the values are the value to write to all vertices of that region.</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_value_for_unlisted_regions">value_for_unlisted_regions</code></td>
<td>
<p>numerical scalar or 'NA', the value to assign to regions which do not occur in the region_value_lists. Defaults to 'NA'.</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical or one of the character strings 'vertical' or 'horizontal', whether to draw a colorbar. Notice: the colorbar is drawn to a separate subplot, and this only works if there is enough space for it, i.e., the plot resolution must be high enough. You may have to increase the plot size for the colorbar to show up, see the vignette for instructions. Defaults to 'FALSE'. See  <code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a></code> for an alternative.</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'. Should include at least a colormap function as name 'colFn'.</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_bg">bg</code></td>
<td>
<p>a background definition. Can be a surface color layer or a character string like 'curv_light' to select a pre-defined layer, see <code><a href="#topic+collayer.bg">collayer.bg</a></code> for valid strings.</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress mapping info in case of unnamed region value lists (see 'lh_region_value_list' description).</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_style">style</code></td>
<td>
<p>character string, a rendering style, e.g., 'default', 'shiny' or 'semitransparent'.</p>
</td></tr>
<tr><td><code id="vis.region.values.on.subject_+3A_border">border</code></td>
<td>
<p>logical, whether to add a black border around the regions. Alternatively, the parameter can be given as a named list with entries 'color' and 'expand_inwards', where the latter defines the borders thickness. E.g., <code>border = list('color'='#FF0000', 'expand_inwards'=2L)</code>. Border computation is slow, sorry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization.
</p>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>
<p>Other region-based visualization functions: 
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   atlas = 'aparc';   # Desikan atlas
   # For the left hemisphere, we just assign a subset of the
   # atlas regions. The others will get the default value.
   lh_region_value_list = list("bankssts"=0.9, "precuneus"=0.7, "postcentral"=0.8, "lingual"=0.6);
   # For the right hemisphere, we retrieve the full list of regions for
   # the atlas, and assign random values to all of them.
   atlas_region_names = get.atlas.region.names(atlas, template_subjects_dir = subjects_dir,
    template_subject='subject1');
   rh_region_value_list = rnorm(length(atlas_region_names), 3.0, 1.0);
   names(rh_region_value_list) = atlas_region_names;
   vis.region.values.on.subject(subjects_dir, 'subject1', atlas,
    lh_region_value_list, rh_region_value_list);

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.renderable'>Visualize a renderable object</h2><span id='topic+vis.renderable'></span>

<h3>Description</h3>

<p>Renders instances of 'coloredmesh', 'coloredvoxels' and 'Triangles3D'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.renderable(cmesh, skip_all_na = TRUE, style = "default")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.renderable_+3A_cmesh">cmesh</code></td>
<td>
<p>an instance of one of the supported renderable classes</p>
</td></tr>
<tr><td><code id="vis.renderable_+3A_skip_all_na">skip_all_na</code></td>
<td>
<p>logical, whether to skip rendering hidden instances</p>
</td></tr>
<tr><td><code id="vis.renderable_+3A_style">style</code></td>
<td>
<p>a rendering style, can be a style name or a list defining an rgl material style</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fsbrain.renderable">fsbrain.renderable</a></code>
</p>

<hr>
<h2 id='vis.rotated.coloredmeshes'>Rotate and visualize coloredmeshes, applying a style.</h2><span id='topic+vis.rotated.coloredmeshes'></span>

<h3>Description</h3>

<p>Rotate and visualize coloredmeshes, applying a style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.rotated.coloredmeshes(
  renderables,
  rotation_angle,
  x,
  y,
  z,
  style = "default",
  draw_colorbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.rotated.coloredmeshes_+3A_rotation_angle">rotation_angle</code></td>
<td>
<p>angle in radians. Passed to <code>rotate3d</code>.</p>
</td></tr>
<tr><td><code id="vis.rotated.coloredmeshes_+3A_x">x</code></td>
<td>
<p>x value passed to <code>rotate3d</code>.</p>
</td></tr>
<tr><td><code id="vis.rotated.coloredmeshes_+3A_y">y</code></td>
<td>
<p>y value passed to <code>rotate3d</code>.</p>
</td></tr>
<tr><td><code id="vis.rotated.coloredmeshes_+3A_z">z</code></td>
<td>
<p>z value passed to <code>rotate3d</code>.</p>
</td></tr>
<tr><td><code id="vis.rotated.coloredmeshes_+3A_style">style</code></td>
<td>
<p>a named list of style parameters or a string specifying an available style by name (e.g., 'shiny'). Defaults to 'default', the default style.</p>
</td></tr>
<tr><td><code id="vis.rotated.coloredmeshes_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical. Whether to draw a colorbar.</p>
</td></tr>
<tr><td><code id="vis.rotated.coloredmeshes_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of renderables. A coloredmesh is a named list as returned by the coloredmesh.from.* functions. It has the entries 'mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh.</p>
</td></tr>
</table>

<hr>
<h2 id='vis.seg.legend'>Plot legend for a brain volume segmentation based on colorLUT.</h2><span id='topic+vis.seg.legend'></span>

<h3>Description</h3>

<p>Plot legend for a brain volume segmentation based on colorLUT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.seg.legend(colortable, segvol, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.seg.legend_+3A_colortable">colortable</code></td>
<td>
<p>a colortable data.frame, or a character string, which will be treated as a filename and loaded with <code><a href="freesurferformats.html#topic+read.fs.colortable">read.fs.colortable</a></code>. Typically <code>FS_HOME/FreeSurferColorLUT.txt</code>.</p>
</td></tr>
<tr><td><code id="vis.seg.legend_+3A_segvol">segvol</code></td>
<td>
<p>optional 3D or 4D array of integer data, the brain segmentation. Or a character string, which will be treated as a filename and loaded with <code><a href="freesurferformats.html#topic+read.fs.volume">read.fs.volume</a></code>. If given, only colortable entries which actually occur in the volume data are plotted. If <code>NULL</code>, all entries are plotted, which may be a lot.</p>
</td></tr>
<tr><td><code id="vis.seg.legend_+3A_...">...</code></td>
<td>
<p>passed on to <a href="#topic+vis.colortable.legend">vis.colortable.legend</a></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ct = file.path(fs.home(), "FreeSurferColorLUT.txt");
seg = file.path(fs.home(), "subjects", "fsaverage", "mri", "aseg.mgz");
vis.seg.legend(ct, seg);


## End(Not run)

</code></pre>

<hr>
<h2 id='vis.subject.annot'>Visualize an annotation for a subject.</h2><span id='topic+vis.subject.annot'></span>

<h3>Description</h3>

<p>Creates a surface mesh, loads the colors from the annotation, and renders the resulting colored mesh in an interactive window. If hemi is 'both', the data is rendered for the whole brain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.subject.annot(
  subjects_dir,
  subject_id,
  atlas,
  hemi = "both",
  surface = "white",
  views = c("t4"),
  rgloptions = rglo(),
  rglactions = list(),
  outline = FALSE,
  style = "default"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.subject.annot_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.subject.annot_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="vis.subject.annot_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded. Can also be a hemilist of already loaded annotations.</p>
</td></tr>
<tr><td><code id="vis.subject.annot_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or 'both'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="vis.subject.annot_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="vis.subject.annot_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="vis.subject.annot_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="vis.subject.annot_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.subject.annot_+3A_outline">outline</code></td>
<td>
<p>logical, whether to draw an outline only instead of filling the regions. Defaults to 'FALSE'. Instead of passing 'TRUE', one can also pass a list of extra parameters to pass to <code><a href="#topic+annot.outline">annot.outline</a></code>, e.g., <code>outline=list('outline_color'='#000000')</code>. Using this increases computation time dramatically, sorry for the performance.</p>
</td></tr>
<tr><td><code id="vis.subject.annot_+3A_style">style</code></td>
<td>
<p>character string, a rendering style, e.g., 'default', 'shiny' or 'semitransparent'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization.
</p>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>
<p>Other region-based visualization functions: 
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   vis.subject.annot(subjects_dir, 'subject1', 'aparc', 'both');

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.subject.label'>Visualize a binary label for a subject.</h2><span id='topic+vis.subject.label'></span>

<h3>Description</h3>

<p>Visualize a label for a subject. A label is just a logical vector with one entry for each vertex in the mesh. Each vertex may additionally be associated with a scalar value, but this function ignored that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.subject.label(
  subjects_dir,
  subject_id,
  label,
  hemi,
  surface = "white",
  views = c("t4"),
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE,
  makecmap_options = list(colFn = label.colFn.inv, col.na = "#FFFFFF00"),
  map_to_NA = 0L,
  bg = NULL,
  style = "default"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.subject.label_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.subject.label_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="vis.subject.label_+3A_label">label</code></td>
<td>
<p>string. Name of the label file, without the hemi part (if any), but including the '.label' suffix. E.g., 'cortex.label' for '?h.cortex.label'.</p>
</td></tr>
<tr><td><code id="vis.subject.label_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or 'both'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="vis.subject.label_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="vis.subject.label_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="vis.subject.label_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="vis.subject.label_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.subject.label_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical or one of the character strings 'vertical' or 'horizontal', whether to draw a colorbar. Notice: the colorbar is drawn to a separate subplot, and this only works if there is enough space for it, i.e., the plot resolution must be high enough. You may have to increase the plot size for the colorbar to show up, see the vignette for instructions. Defaults to 'FALSE'. See  <code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a></code> for an alternative.</p>
</td></tr>
<tr><td><code id="vis.subject.label_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'. Should include at least a colormap function as name 'colFn'.</p>
</td></tr>
<tr><td><code id="vis.subject.label_+3A_map_to_na">map_to_NA</code></td>
<td>
<p>the value or value range that should **not** be considered part of the label, and should thus be plotted as background color. Only used if 'bg' is not 'NULL'. If a single value, only excatly this value is used (typically 0). If two values, they are interpreted as a range, and a values between them are mapped to NA. If you prefer to map the data to NA yourself before using this function, pass 'NULL'.</p>
</td></tr>
<tr><td><code id="vis.subject.label_+3A_bg">bg</code></td>
<td>
<p>a background definition. Can be a surface color layer or a character string like 'curv_light' to select a pre-defined layer, see <code><a href="#topic+collayer.bg">collayer.bg</a></code> for valid strings.</p>
</td></tr>
<tr><td><code id="vis.subject.label_+3A_style">style</code></td>
<td>
<p>character string, a rendering style, e.g., 'default', 'shiny' or 'semitransparent'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization.
</p>


<h3>Note</h3>

<p>Drawing a colorbar for label data makes limited sense, use a legend instead. The colorbar can give a rough overview of the relative number of label and non-label vertices though, so it is possible to request one.
</p>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>
<p>Other label functions: 
<code><a href="#topic+apply.label.to.morphdata">apply.label.to.morphdata</a>()</code>,
<code><a href="#topic+apply.labeldata.to.morphdata">apply.labeldata.to.morphdata</a>()</code>,
<code><a href="#topic+subject.lobes">subject.lobes</a>()</code>,
<code><a href="#topic+subject.mask">subject.mask</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   subject_id = 'subject1';
   surface = 'white';
   hemi = 'both';
   label = 'cortex.label';
   vis.subject.label(subjects_dir, subject_id, label, hemi, views="si");

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.subject.morph.native'>Visualize native space morphometry data for a subject.</h2><span id='topic+vis.subject.morph.native'></span>

<h3>Description</h3>

<p>Creates a surface mesh, applies a colormap transform the morphometry data values into colors, and renders the resulting colored mesh in an interactive window. If hemi is 'both', the data is rendered for the whole brain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.subject.morph.native(
  subjects_dir,
  subject_id,
  measure,
  hemi = "both",
  surface = "white",
  views = c("t4"),
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE,
  cortex_only = FALSE,
  style = "default",
  makecmap_options = mkco.seq(),
  bg = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.subject.morph.native_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.native_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.native_+3A_measure">measure</code></td>
<td>
<p>string. The morphometry data to use. E.g., 'area' or 'thickness'. Pass NULL to render just the surface in white, without any data.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.native_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or 'both'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.native_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.native_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.native_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.native_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.native_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical or one of the character strings 'vertical' or 'horizontal', whether to draw a colorbar. Notice: the colorbar is drawn to a separate subplot, and this only works if there is enough space for it, i.e., the plot resolution must be high enough. You may have to increase the plot size for the colorbar to show up, see the vignette for instructions. Defaults to 'FALSE'. See  <code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a></code> for an alternative.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.native_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to mask the medial wall, i.e., whether the morphometry data for all vertices which are *not* part of the cortex (as defined by the label file 'label/?h.cortex.label') should be replaced with NA values. In other words, setting this to TRUE will ignore the values of the medial wall between the two hemispheres. If set to true, the mentioned label file needs to exist for the subject. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.native_+3A_style">style</code></td>
<td>
<p>character string, a rendering style, e.g., 'default', 'shiny' or 'semitransparent'.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.native_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'. Should include at least a colormap function as name 'colFn'.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.native_+3A_bg">bg</code></td>
<td>
<p>a background definition. Can be a surface color layer or a character string like 'curv_light' to select a pre-defined layer, see <code><a href="#topic+collayer.bg">collayer.bg</a></code> for valid strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization.
</p>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>
<p>Other morphometry visualization functions: 
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   vis.subject.morph.native(subjects_dir, 'subject1', 'thickness', 'lh', views=c("t9"));

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.subject.morph.standard'>Visualize native space morphometry data for a subject or a group.</h2><span id='topic+vis.subject.morph.standard'></span>

<h3>Description</h3>

<p>Renders standard space morphometry data for a single subject, or the group mean for a group of subjects. The default template subject is fsaverage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.subject.morph.standard(
  subjects_dir,
  subject_id,
  measure,
  hemi = "both",
  fwhm = "10",
  surface = "white",
  template_subject = "fsaverage",
  template_subjects_dir = NULL,
  views = c("t4"),
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE,
  cortex_only = FALSE,
  makecmap_options = mkco.seq(),
  bg = NULL,
  style = "default"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.subject.morph.standard_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_subject_id">subject_id</code></td>
<td>
<p>character string or vector of character strings, the subject or subjects. For a single subjects, its data will be plotted. If a group of subjects is given instead, at each vertex the mean value over all the subjects will be plotted.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_measure">measure</code></td>
<td>
<p>string. The morphometry data to use. E.g., 'area' or 'thickness'. Pass NULL to render just the surface in white, without any data.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or 'both'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_fwhm">fwhm</code></td>
<td>
<p>string, smoothing setting (full width at half maximum of the kernel). The smoothing part of the filename, typically something like '0', '5', '10', ...,  or '25'.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_template_subject">template_subject</code></td>
<td>
<p>The template subject used. This will be used as part of the filename, and its surfaces are loaded for data visualization. Defaults to 'fsaverage'.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_template_subjects_dir">template_subjects_dir</code></td>
<td>
<p>The template subjects dir. If NULL, the value of the parameter 'subjects_dir' is used. If you have FreeSurfer installed and configured, and are using the standard fsaverage subject, try passing the result of calling 'file.path(Sys.getenv('FREESURFER_HOME'), 'subjects')'.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical or one of the character strings 'vertical' or 'horizontal', whether to draw a colorbar. Notice: the colorbar is drawn to a separate subplot, and this only works if there is enough space for it, i.e., the plot resolution must be high enough. You may have to increase the plot size for the colorbar to show up, see the vignette for instructions. Defaults to 'FALSE'. See  <code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a></code> for an alternative.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_cortex_only">cortex_only</code></td>
<td>
<p>logical, whether to mask the medial wall, i.e., whether the morphometry data for all vertices which are *not* part of the cortex (as defined by the label file 'label/?h.cortex.label') should be replaced with NA values. In other words, setting this to TRUE will ignore the values of the medial wall between the two hemispheres. If set to true, the mentioned label file needs to exist for the subject. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'. Should include at least a colormap function as name 'colFn'.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_bg">bg</code></td>
<td>
<p>a background definition. Can be a surface color layer or a character string like 'curv_light' to select a pre-defined layer, see <code><a href="#topic+collayer.bg">collayer.bg</a></code> for valid strings.</p>
</td></tr>
<tr><td><code id="vis.subject.morph.standard_+3A_style">style</code></td>
<td>
<p>character string, a rendering style, e.g., 'default', 'shiny' or 'semitransparent'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization.
</p>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>
<p>Other morphometry visualization functions: 
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   fsaverage_dir = file.path(Sys.getenv('FREESURFER_HOME'), 'subjects');
   if(dir.exists(fsaverage_dir)) {
       vis.subject.morph.standard(subjects_dir, 'subject1', 'thickness', 'lh',
       '10', template_subjects_dir=fsaverage_dir);
   }
   # The last command will load the file
   #  *&lt;subjects_dir&gt;/subject1/surf/lh.thickness.fwhm10.fsaverage.mgh* and
   #  visualize the data on *$FREESURFER_HOME/subjects/fsaverage/surf/lh.white*.

## End(Not run)

</code></pre>

<hr>
<h2 id='vis.subject.pre'>Visualize pre-loaded data.</h2><span id='topic+vis.subject.pre'></span>

<h3>Description</h3>

<p>Visualize pre-loaded data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.subject.pre(
  surfaces,
  pervertex_data,
  hemi = "both",
  views = c("t4"),
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = FALSE,
  style = "default",
  makecmap_options = mkco.seq()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.subject.pre_+3A_surfaces">surfaces</code></td>
<td>
<p>a <code><a href="#topic+hemilist">hemilist</a></code> of surfaces loaded with a function like <code>freesurferformats::read.fs.surface</code>.</p>
</td></tr>
<tr><td><code id="vis.subject.pre_+3A_pervertex_data">pervertex_data</code></td>
<td>
<p>a <code><a href="#topic+hemilist">hemilist</a></code> of per-vertex data for the surfaces, i.e., a list of numeric vectors. E.g., loaded  from a moorphometry data file with a function like <code>freesurferformats::read.fs.morph</code>.
´</p>
</td></tr>
<tr><td><code id="vis.subject.pre_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh', or 'both'. The hemisphere name. Used to construct the names of the label data files to be loaded.</p>
</td></tr>
<tr><td><code id="vis.subject.pre_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="vis.subject.pre_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="vis.subject.pre_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.subject.pre_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical or one of the character strings 'vertical' or 'horizontal', whether to draw a colorbar. Notice: the colorbar is drawn to a separate subplot, and this only works if there is enough space for it, i.e., the plot resolution must be high enough. You may have to increase the plot size for the colorbar to show up, see the vignette for instructions. Defaults to 'FALSE'. See  <code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a></code> for an alternative.</p>
</td></tr>
<tr><td><code id="vis.subject.pre_+3A_style">style</code></td>
<td>
<p>character string, a rendering style, e.g., 'default', 'shiny' or 'semitransparent'.</p>
</td></tr>
<tr><td><code id="vis.subject.pre_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'. Should include at least a colormap function as name 'colFn'.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>

<hr>
<h2 id='vis.symmetric.data.on.subject'>Visualize clusters or activation data on the surface of any subject.</h2><span id='topic+vis.symmetric.data.on.subject'></span>

<h3>Description</h3>

<p>This function is intended to plot symmetric data around zero (like positive and negative activation data, signed p-values, etc.) on a subject's surface. It is a thin wrapper around <code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.symmetric.data.on.subject(
  subjects_dir,
  vis_subject_id,
  morph_data_lh = NULL,
  morph_data_rh = NULL,
  surface = "white",
  views = c("t4"),
  rgloptions = rglo(),
  rglactions = list(),
  draw_colorbar = TRUE,
  makecmap_options = list(colFn = cm.cbry(), symm = TRUE, col.na = "#FFFFFF00", n = 200),
  map_to_NA = c(0),
  bg = NULL,
  morph_data_both = NULL,
  style = "default"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.symmetric.data.on.subject_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="vis.symmetric.data.on.subject_+3A_vis_subject_id">vis_subject_id</code></td>
<td>
<p>string. The subject identifier from which to obtain the surface for data visualization. Example: 'fsaverage'.</p>
</td></tr>
<tr><td><code id="vis.symmetric.data.on.subject_+3A_morph_data_lh">morph_data_lh</code></td>
<td>
<p>numeric vector or character string or NULL, the data to visualize on the left hemisphere surface. If a string, it is treated as a filename and data is loaded from it first. When it is a numerical vector, this is assumed to be the data already. The data must have the same length as the surface of the vis_subject_id has vertices. If NULL, this surface will not be rendered. Only one of morph_data_lh or morph_data_rh is allowed to be NULL.</p>
</td></tr>
<tr><td><code id="vis.symmetric.data.on.subject_+3A_morph_data_rh">morph_data_rh</code></td>
<td>
<p>numeric vector or character string or NULL, the data to visualize on the right hemisphere surface. If a string, it is treated as a filename and data is loaded from it first. When it is a numerical vector, this is assumed to be the data already.  The data must have the same length as the surface of the vis_subject_id has vertices. If NULL, this surface will not be rendered. Only one of morph_data_lh or morph_data_rh is allowed to be NULL.</p>
</td></tr>
<tr><td><code id="vis.symmetric.data.on.subject_+3A_surface">surface</code></td>
<td>
<p>string. The display surface. E.g., &quot;white&quot;, &quot;pial&quot;, or &quot;inflated&quot;. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="vis.symmetric.data.on.subject_+3A_views">views</code></td>
<td>
<p>list of strings. Valid entries include: 'si': single interactive view. 't4': tiled view showing the brain from 4 angles. 't9': tiled view showing the brain from 9 angles.</p>
</td></tr>
<tr><td><code id="vis.symmetric.data.on.subject_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="vis.symmetric.data.on.subject_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action. The following example clips outliers in the data before plotting and writes a screenshot in PNG format: <code>rglactions = list("snapshot_png"="~/fsbrain.png", "clip_data"=c(0.05, 0.95))</code>. See <code><a href="#topic+rglactions">rglactions</a></code>.</p>
</td></tr>
<tr><td><code id="vis.symmetric.data.on.subject_+3A_draw_colorbar">draw_colorbar</code></td>
<td>
<p>logical or one of the character strings 'vertical' or 'horizontal', whether to draw a colorbar. Notice: the colorbar is drawn to a separate subplot, and this only works if there is enough space for it, i.e., the plot resolution must be high enough. You may have to increase the plot size for the colorbar to show up, see the vignette for instructions. Defaults to 'FALSE'. See  <code><a href="#topic+coloredmesh.plot.colorbar.separate">coloredmesh.plot.colorbar.separate</a></code> for an alternative.</p>
</td></tr>
<tr><td><code id="vis.symmetric.data.on.subject_+3A_makecmap_options">makecmap_options</code></td>
<td>
<p>named list of parameters to pass to <code>makecmap</code>. Must not include the unnamed first parameter, which is derived from 'measure'. Should include at least a colormap function as name 'colFn'.</p>
</td></tr>
<tr><td><code id="vis.symmetric.data.on.subject_+3A_map_to_na">map_to_NA</code></td>
<td>
<p>the value or value range that should **not** be considered a cluster, and should thus be plotted as background color. These values will be set to NA, leading to transparcent rendering, so the background will be visible instead. If a single value, only exactly this value is used (typically 0). If two values, they are interpreted as a range, and a values between them are mapped to NA. If you prefer to map the data to NA yourself before using this function or do not want to use a , pass 'NULL'.</p>
</td></tr>
<tr><td><code id="vis.symmetric.data.on.subject_+3A_bg">bg</code></td>
<td>
<p>a background definition. Can be a surface color layer or a character string like 'curv_light' to select a pre-defined layer, see <code><a href="#topic+collayer.bg">collayer.bg</a></code> for valid strings.</p>
</td></tr>
<tr><td><code id="vis.symmetric.data.on.subject_+3A_morph_data_both">morph_data_both</code></td>
<td>
<p>numeric vector or NULL, the data to visualize on both hemispheres. This must be a single vector with length equal to the sum of the vertex counts of the left and the right hemisphere. The data for the left hemisphere must come first. If this is given, 'morph_data_lh' and 'morph_data_rh' must be NULL.</p>
</td></tr>
<tr><td><code id="vis.symmetric.data.on.subject_+3A_style">style</code></td>
<td>
<p>character string, a rendering style, e.g., 'default', 'shiny' or 'semitransparent'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coloredmeshes. The coloredmeshes used for the visualization.
</p>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vislayout.from.coloredmeshes">vislayout.from.coloredmeshes</a>()</code>
</p>
<p>Other morphometry visualization functions: 
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   morph_data_lh = subject.morph.native(subjects_dir, 'subject1', 'thickness', 'lh');
   morph_data_rh = NULL;
   vis.symmetric.data.on.subject(subjects_dir, 'subject1', morph_data_lh, morph_data_rh);

## End(Not run)

</code></pre>

<hr>
<h2 id='vislayout.from.coloredmeshes'>Visualize coloredmeshes from several angles and combine the images into a new figure.</h2><span id='topic+vislayout.from.coloredmeshes'></span>

<h3>Description</h3>

<p>Create a tight layout view of coloredmeshes from several angles. Creates separate 'sd_&lt;angle&gt;' images, then crops and finally merges them into a single output image with image magick. The 'coloredmeshes' to pass to this function are usually obtained by running any 'vis*' function (like <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>, <code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a></code>, <code><a href="#topic+vis.subject.label">vis.subject.label</a></code>, <code><a href="#topic+vis.subject.annot">vis.subject.annot</a></code>, and others). That means you can use this function to visualize all kinds of data, e.g., morphometry data in native and standard space, labels, and brain atlases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vislayout.from.coloredmeshes(
  coloredmeshes,
  view_angles = get.view.angle.names(angle_set = "t4"),
  rgloptions = rglo(),
  rglactions = list(),
  style = "default",
  output_img = "fsbrain_arranged.png",
  silent = FALSE,
  grid_like = TRUE,
  background_color = "white",
  transparency_color = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vislayout.from.coloredmeshes_+3A_coloredmeshes">coloredmeshes</code></td>
<td>
<p>list of coloredmesh. A coloredmesh is a named list as returned by the 'coloredmesh.from*' functions (like <code><a href="#topic+coloredmesh.from.morph.native">coloredmesh.from.morph.native</a></code>). It has the entries 'mesh' of type tmesh3d, a 'col', which is a color specification for such a mesh. The 'vis*' functions (like <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>) all return a list of coloredmeshes.</p>
</td></tr>
<tr><td><code id="vislayout.from.coloredmeshes_+3A_view_angles">view_angles</code></td>
<td>
<p>list of strings. See <code><a href="#topic+get.view.angle.names">get.view.angle.names</a></code> for all valid strings.</p>
</td></tr>
<tr><td><code id="vislayout.from.coloredmeshes_+3A_rgloptions">rgloptions</code></td>
<td>
<p>option list passed to <code>par3d</code>. Example: <code>rgloptions = list("windowRect"=c(50,50,1000,1000))</code>.</p>
</td></tr>
<tr><td><code id="vislayout.from.coloredmeshes_+3A_rglactions">rglactions</code></td>
<td>
<p>named list. A list in which the names are from a set of pre-defined actions. The values can be used to specify parameters for the action.</p>
</td></tr>
<tr><td><code id="vislayout.from.coloredmeshes_+3A_style">style</code></td>
<td>
<p>character string, a rendering style, e.g., 'default', 'shiny' or 'semitransparent'. Alternatively, a named list of style parameters (see <code>material3d</code>), e.g., <code>list("shininess"=50, specular="black", alpha=0.5)</code>. Use the magic word 'from_mesh' to use the 'style' field of each coloredmesh instead of a single, global style. In that case, you will have to make sure your meshes have such a field, if not, the style 'default' is used as a fallback for those which don't.</p>
</td></tr>
<tr><td><code id="vislayout.from.coloredmeshes_+3A_output_img">output_img</code></td>
<td>
<p>string, path to the output file. Defaults to &quot;fsbrain_arranged.png&quot;</p>
</td></tr>
<tr><td><code id="vislayout.from.coloredmeshes_+3A_silent">silent</code></td>
<td>
<p>logical, whether to suppress all messages</p>
</td></tr>
<tr><td><code id="vislayout.from.coloredmeshes_+3A_grid_like">grid_like</code></td>
<td>
<p>logical, whether to arrange the images in a grid-like fashion. If FALSE, they will all be merged horizontally. Passed to <code><a href="#topic+arrange.brainview.images">arrange.brainview.images</a></code>.</p>
</td></tr>
<tr><td><code id="vislayout.from.coloredmeshes_+3A_background_color">background_color</code></td>
<td>
<p>hex color string (like '#FFFFFF'), the color to use for the background. Ignored if 'transparency_color' is not NULL. To get a transparent background, use 'transparency_color' instead of this parameter. WARNING: Do not use color names (like 'gray'), as their interpretation differs between rgl and image magick!</p>
</td></tr>
<tr><td><code id="vislayout.from.coloredmeshes_+3A_transparency_color">transparency_color</code></td>
<td>
<p>hex color string (like '#FFFFFF'), the temporary background color that will get mapped to transparency, or NULL if you do not want a transparent background. If used, it can be any color that does not occur in the foreground. Try '#FFFFFF' (white) or '#000000' (black) if in doubt. WARNING: Do not use color names (like 'gray'), as their interpretation differs between rgl and image magick!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, see <code><a href="#topic+arrange.brainview.images">arrange.brainview.images</a></code> for details
</p>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+highlight.vertices.on.subject.spheres">highlight.vertices.on.subject.spheres</a>()</code>,
<code><a href="#topic+highlight.vertices.on.subject">highlight.vertices.on.subject</a>()</code>,
<code><a href="#topic+vis.color.on.subject">vis.color.on.subject</a>()</code>,
<code><a href="#topic+vis.data.on.fsaverage">vis.data.on.fsaverage</a>()</code>,
<code><a href="#topic+vis.data.on.subject">vis.data.on.subject</a>()</code>,
<code><a href="#topic+vis.labeldata.on.subject">vis.labeldata.on.subject</a>()</code>,
<code><a href="#topic+vis.mask.on.subject">vis.mask.on.subject</a>()</code>,
<code><a href="#topic+vis.region.values.on.subject">vis.region.values.on.subject</a>()</code>,
<code><a href="#topic+vis.subject.annot">vis.subject.annot</a>()</code>,
<code><a href="#topic+vis.subject.label">vis.subject.label</a>()</code>,
<code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a>()</code>,
<code><a href="#topic+vis.subject.morph.standard">vis.subject.morph.standard</a>()</code>,
<code><a href="#topic+vis.subject.pre">vis.subject.pre</a>()</code>,
<code><a href="#topic+vis.symmetric.data.on.subject">vis.symmetric.data.on.subject</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   # Use any vis function to get coloredmeshes. You can visualize morphometry,
   #  labels, an atlas, whatever. You can suppress the view unless you need it.
   coloredmeshes = vis.subject.morph.native(subjects_dir, "subject1", "thickness",
    cortex_only=TRUE, rglactions=list("clip_data"=c(0.05, 0.95)),
    views=NULL);
   # The meshes contain the surface, data, and color information and can be
   #  visualized. You could adapt the rendering style while doing so:
   vislayout.from.coloredmeshes(coloredmeshes, style='shiny');
   # You could change the rendering style on a per-mesh basis.
   coloredmeshes[[1]]$style = list("shininess"=50, alpha=0.5);
   vislayout.from.coloredmeshes(coloredmeshes, style='from_mesh');

## End(Not run)


</code></pre>

<hr>
<h2 id='vol.boundary.box'>Compute 3D bounding box of a volume.</h2><span id='topic+vol.boundary.box'></span>

<h3>Description</h3>

<p>Compute the axis-aligned foreground bounding box of a 3D volume, i.e. the inner foreground area that must be retained if you want to remove all background from the corners of the volume. The foreground is determined by thresholding, such that all values greater than 0 are considered foreground. See <code><a href="#topic+vol.boundary.mask">vol.boundary.mask</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.boundary.box(volume, threshold = 0L, apply = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.boundary.box_+3A_volume">volume</code></td>
<td>
<p>a 3D image volume</p>
</td></tr>
<tr><td><code id="vol.boundary.box_+3A_threshold">threshold</code></td>
<td>
<p>numerical, the threshold intensity used to separate background and foreground. All voxels with intensity values greater than this value will be considered 'foreground' voxels.</p>
</td></tr>
<tr><td><code id="vol.boundary.box_+3A_apply">apply</code></td>
<td>
<p>logical, whether to directly apply the bounding box and return the resulting volume instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with 2 entries: 'from' is an integer vector of length 3, defining the minimal (x,y,z) foreground indices. 'to' is an integer vector of length 3, defining the maximal (x,y,z) foreground indices.
</p>


<h3>See Also</h3>

<p>Other volume utility: 
<code><a href="#topic+vol.imagestack">vol.imagestack</a>()</code>,
<code><a href="#topic+vol.merge">vol.merge</a>()</code>,
<code><a href="#topic+vol.overlay.colors.from.activation">vol.overlay.colors.from.activation</a>()</code>,
<code><a href="#topic+vol.planes">vol.planes</a>()</code>,
<code><a href="#topic+vol.slice">vol.slice</a>()</code>
</p>

<hr>
<h2 id='vol.boundary.box.apply'>Apply a boundary box to a volume, returning the inner volume part</h2><span id='topic+vol.boundary.box.apply'></span>

<h3>Description</h3>

<p>Apply a boundary box to a volume, returning the inner volume part
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.boundary.box.apply(volume, bbox)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.boundary.box.apply_+3A_volume">volume</code></td>
<td>
<p>a 3D image volume</p>
</td></tr>
<tr><td><code id="vol.boundary.box.apply_+3A_bbox">bbox</code></td>
<td>
<p>the boundary box</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3D image volume, the inner volume part, resulting from the application of the boundary box
</p>

<hr>
<h2 id='vol.boundary.mask'>Compute foreground pixels over the whole 3D imagestack.</h2><span id='topic+vol.boundary.mask'></span>

<h3>Description</h3>

<p>Compute, over all images in a stack along an axis, the foreground and background pixels as a binary mask. A pixel is a 'foreground' pixel iff its value is greater than the 'threshold' parameter in at least one of the slices. A pixel is a 'background' pixel iff its value is below or euqal to the 'threshold' in all slices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.boundary.mask(volume, plane = 1L, threshold = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.boundary.mask_+3A_volume">volume</code></td>
<td>
<p>a 3D image volume</p>
</td></tr>
<tr><td><code id="vol.boundary.mask_+3A_plane">plane</code></td>
<td>
<p>integer vector of length 2 or something that will be turned into one by <code><a href="#topic+vol.plane.axes">vol.plane.axes</a></code>.</p>
</td></tr>
<tr><td><code id="vol.boundary.mask_+3A_threshold">threshold</code></td>
<td>
<p>numerical, the threshold intensity used to separate background and foreground. All voxels with intensity values greater than this value will be considered 'foreground' voxels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer 2D matrix with dimensions of a slice of the volume. Positions set to 1 are 'foreground' pixels and positions set to 0 are 'background' pixels (see 'Details' section).
</p>

<hr>
<h2 id='vol.hull'>Retain only the outer hull voxels of the foreground.</h2><span id='topic+vol.hull'></span>

<h3>Description</h3>

<p>Filters the *foreground* voxel in the volume by keeping only an outer border of voxels, and setting the inner core voxels to 'NA'. This is a utility function for voxel-based visualization. The goal is to remove the inner voxels, which will not be visible anyways, and thus to dramatically reduce the number of triangles that will need to be computed for the mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.hull(volume, thickness = 1L, axes = c(2L))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.hull_+3A_volume">volume</code></td>
<td>
<p>numeric 3d array, must contain foreground voxel and background voxels. The latter must have value 'NA'. This function assumes that a solid foreground object surrounded by background exists in the volume.</p>
</td></tr>
<tr><td><code id="vol.hull_+3A_thickness">thickness</code></td>
<td>
<p>integer, the width of the border in voxels, i.e., how many of the voxels in each upright column to keep at the top and at the bottom.</p>
</td></tr>
<tr><td><code id="vol.hull_+3A_axes">axes</code></td>
<td>
<p>integer vector, the axes to use. Valid values in the vector are 1L, 2L and 3L. You will have to use all 3 axes if you do not want any holes in the object. (Obvisouly, having noise around the object can still lead to holes.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric 3d array, a filtered version of the input. It contains at least as many 'NA' voxels as the input. If the function had any effect, it contains a lot more 'NA' values. The other values and the volume dimensions are left unchanged.
</p>

<hr>
<h2 id='vol.imagestack'>Turn volume into an ImageMagick image stack.</h2><span id='topic+vol.imagestack'></span>

<h3>Description</h3>

<p>Create an image from each slice along the axis, then stack those into an ImageMagick image stack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.imagestack(volume, axis = 1L, intensity_scale = 255)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.imagestack_+3A_volume">volume</code></td>
<td>
<p>a 3D image volume. Can be numeric, or something that can be read directly by <code>magick::image_read</code> in 2D matrices (slices along the axis), e.g., a 3D array of color strings. If a 2D matrix is passed, the resulting stack will contain a single image.</p>
</td></tr>
<tr><td><code id="vol.imagestack_+3A_axis">axis</code></td>
<td>
<p>positive integer in range 1L..3L or an axis name, the axis to use.</p>
</td></tr>
<tr><td><code id="vol.imagestack_+3A_intensity_scale">intensity_scale</code></td>
<td>
<p>integer, value by which to scale the intensities in the volume to the range '[0, 1]'. Only used for numeric volumes. Set to NULL for data that can be read directly by <code>magick::image_read</code>, and to 1 for intensity data that requires no scaling. Defaults to 255, which is suitable for 8 bit image data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vectorized ImageMagick image, containing one subimage per slice. This can be interpreted as an animation or whatever.
</p>


<h3>See Also</h3>

<p>Other volume utility: 
<code><a href="#topic+vol.boundary.box">vol.boundary.box</a>()</code>,
<code><a href="#topic+vol.merge">vol.merge</a>()</code>,
<code><a href="#topic+vol.overlay.colors.from.activation">vol.overlay.colors.from.activation</a>()</code>,
<code><a href="#topic+vol.planes">vol.planes</a>()</code>,
<code><a href="#topic+vol.slice">vol.slice</a>()</code>
</p>

<hr>
<h2 id='vol.intensity.to.color'>Convert integer intensity image to RGB color string form.</h2><span id='topic+vol.intensity.to.color'></span>

<h3>Description</h3>

<p>Convert a gray-scale image defined by intensity values in range '[0, 1]' to an image with identical dimensions that contains an R color string (like '#222222') at each position. The color strings are computed from the intensities, by taking the intensity value as the value for all three RGB channels. I.e., the output is still gray-scale, but defined in RGB space. To make it clear, this function does **not** apply a colormap. It only changes the representation of the data, not the resulting colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.intensity.to.color(volume, scale = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.intensity.to.color_+3A_volume">volume</code></td>
<td>
<p>numeric array, typically a 3D image with intensities in range '[0, 1]'. This function now also supports numeric matrices (2D images, slices) and numeric vectors (1D).</p>
</td></tr>
<tr><td><code id="vol.intensity.to.color_+3A_scale">scale</code></td>
<td>
<p>numeric or character string, a scaling to apply to the values. Defaults to NULL, which means *no scaling* and requires the values in &lsquo;volume' to be in rage '[0, 1]'. You can pass a number like 255 or the string &rsquo;normalize' to scale based on the data. You can pass the string 'normalize_if_needed' to scale only if the data is *outside* the range '[0, 1]', so that data in range '[0.3, 0.5]' would **not** be rescaled to '[0, 1]'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array (or matrix, or vector) of RGB color strings. All of them will represent gray values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   vol.intensity.to.color(c(0.0, 0.5, 1.0));
   # output: "#000000" "#808080" "#FFFFFF"
   vol.intensity.to.color(c(20, 186, 240), scale="normalize");
   vol.intensity.to.color(c(20, 186, 240), scale=255);
   vol.intensity.to.color(c(0.0, 0.5, 0.8), scale="normalize");
   vol.intensity.to.color(c(0.0, 0.5, 0.8), scale="normalize_if_needed");

</code></pre>

<hr>
<h2 id='vol.mask.from.segmentation'>Extract subset from a volume by value.</h2><span id='topic+vol.mask.from.segmentation'></span>

<h3>Description</h3>

<p>Extract subset from a volume by value, set all other voxel values to 'NA'. Typically used to extract a brain structure (like corpus callosum) from a volume segmentation (like the 'mri/aseg.mgz' file of a subject). You should consider passing the volume and the include values as integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.mask.from.segmentation(volume, include_values)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.mask.from.segmentation_+3A_volume">volume</code></td>
<td>
<p>numeric 3D array</p>
</td></tr>
<tr><td><code id="vol.mask.from.segmentation_+3A_include_values">include_values</code></td>
<td>
<p>numerical vector, the intensity values which qualify a voxel to be part of the result (without being set to NA)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical array with same dimensions as the input volume. All values which are not part of 'include_values' replaced with 'NA'.
</p>

<hr>
<h2 id='vol.merge'>Merge background volume and overlay to new colors.</h2><span id='topic+vol.merge'></span>

<h3>Description</h3>

<p>Merge background volume and overlay to new colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.merge(
  volume,
  overlay_colors,
  bbox_threshold = 0L,
  forced_overlay_color = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.merge_+3A_volume">volume</code></td>
<td>
<p>3D array, can be numeric (gray-scale intensity values) or color strings. If numeric, the intensity values must be in range '[0, 1]'.</p>
</td></tr>
<tr><td><code id="vol.merge_+3A_overlay_colors">overlay_colors</code></td>
<td>
<p>3D array of color strings, values which are not part of the overlay (and should display background in the result) must have 'NA' instead of a color string. Must have same dimensions as the 'volume'.</p>
</td></tr>
<tr><td><code id="vol.merge_+3A_bbox_threshold">bbox_threshold</code></td>
<td>
<p>numerical, the threshold intensity used to separate background and foreground. All voxels with intensity values greater than this value in the background 'volume' will be considered 'foreground' voxels. Background-only slices at the borders of the volume will be discarded (in the merged, final image). Pass 'NULL' to use the full image without applying any bounding box.</p>
</td></tr>
<tr><td><code id="vol.merge_+3A_forced_overlay_color">forced_overlay_color</code></td>
<td>
<p>NULL or an rgb color string, like '#FF0000' for red. If NULL, the activation colors will be used as foreground colors. Otherwise, the given color will be for all foreground vertices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3D array of color strings, the merged colors
</p>


<h3>See Also</h3>

<p>Other volume utility: 
<code><a href="#topic+vol.boundary.box">vol.boundary.box</a>()</code>,
<code><a href="#topic+vol.imagestack">vol.imagestack</a>()</code>,
<code><a href="#topic+vol.overlay.colors.from.activation">vol.overlay.colors.from.activation</a>()</code>,
<code><a href="#topic+vol.planes">vol.planes</a>()</code>,
<code><a href="#topic+vol.slice">vol.slice</a>()</code>
</p>

<hr>
<h2 id='vol.overlay.colors.from.activation'>Generate colors for a 3D volume, based on the activation data and a colormap.</h2><span id='topic+vol.overlay.colors.from.activation'></span>

<h3>Description</h3>

<p>Applies the colormap function to the data, then sets the alpha value (transparency) to full in all areas without any activation. Feel free to clip data or whatever before passing it, so that all your no-activation data has the same value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.overlay.colors.from.activation(
  volume,
  colormap_fn = squash::blueorange,
  no_act_source_value = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.overlay.colors.from.activation_+3A_volume">volume</code></td>
<td>
<p>a 3D array, the activation data (or p-values, effect sizes, or whatever)</p>
</td></tr>
<tr><td><code id="vol.overlay.colors.from.activation_+3A_colormap_fn">colormap_fn</code></td>
<td>
<p>function, a colormap function</p>
</td></tr>
<tr><td><code id="vol.overlay.colors.from.activation_+3A_no_act_source_value">no_act_source_value</code></td>
<td>
<p>numerical scalar, the value from the data in 'volume' that means no activation. The output colors for this value will be set to 'NA'. Set to NULL to not change anything.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3D matrix of color strings, with the same dimensions as the input volume
</p>


<h3>See Also</h3>

<p>Other volume utility: 
<code><a href="#topic+vol.boundary.box">vol.boundary.box</a>()</code>,
<code><a href="#topic+vol.imagestack">vol.imagestack</a>()</code>,
<code><a href="#topic+vol.merge">vol.merge</a>()</code>,
<code><a href="#topic+vol.planes">vol.planes</a>()</code>,
<code><a href="#topic+vol.slice">vol.slice</a>()</code>
</p>

<hr>
<h2 id='vol.overlay.colors.from.colortable'>Compute voxel colors based on colortable.</h2><span id='topic+vol.overlay.colors.from.colortable'></span>

<h3>Description</h3>

<p>Use the intensity values of the voxels in volume and lookup the respective colors in a colortable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.overlay.colors.from.colortable(
  volume,
  colortable,
  ignored_struct_indices = c(),
  ignored_struct_names = c("unknown", "Unknown")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.overlay.colors.from.colortable_+3A_volume">volume</code></td>
<td>
<p>numeric 3D array, the values should be integers present in the 'struct_index' column of the colortable. All other values will be assigned 'NA' as a color.</p>
</td></tr>
<tr><td><code id="vol.overlay.colors.from.colortable_+3A_colortable">colortable</code></td>
<td>
<p>a colortable, as returned by <code><a href="freesurferformats.html#topic+read.fs.colortable">read.fs.colortable</a></code>, or a character string representing a path to a colortable file.</p>
</td></tr>
<tr><td><code id="vol.overlay.colors.from.colortable_+3A_ignored_struct_indices">ignored_struct_indices</code></td>
<td>
<p>integer vector, 'struct_index' entries in the colortable that should be ignored</p>
</td></tr>
<tr><td><code id="vol.overlay.colors.from.colortable_+3A_ignored_struct_names">ignored_struct_names</code></td>
<td>
<p>vector of character strings, 'struct_name' entries in the colortable that should be ignored. Can be combined with 'ignored_struct_indices'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string 3D array, the colors. Voxels in the volume which were not matched by the colortable are set to 'NA' in it.
</p>

<hr>
<h2 id='vol.plane.axes'>Get indices of the axes defining the given plane.</h2><span id='topic+vol.plane.axes'></span>

<h3>Description</h3>

<p>When using plane names, this function assumes that the volume is in the standard FreeSurfer orientation, as returned by reading a conformed volume with functions like <code><a href="#topic+subject.volume">subject.volume</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.plane.axes(plane)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.plane.axes_+3A_plane">plane</code></td>
<td>
<p>integer or string. If a string, one of &quot;axial&quot;, &quot;coronal&quot;, or &quot;sagittal&quot;. If this is an integer vector of length 2 already, it is returned as given. If it is a single integer, it is interpreted as an axis index, and the plane orthogonal to the axis is returned. A warning on using the plane names: these only make sense if the volume is in the expected orientation, no checking whatsoever on this is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector of length 2, the axes indices.
</p>

<hr>
<h2 id='vol.planes'>Translate names and indices of planes.</h2><span id='topic+vol.planes'></span>

<h3>Description</h3>

<p>Translate names and indices of 3D image planes. The names only make sense if the data in the volume is in the default FreeSurfer conformed orientation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.planes(plane = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.planes_+3A_plane">plane</code></td>
<td>
<p>NULL, a plane index, or a plane name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if 'plane' is NULL, all available planes and their indices as a named list. If 'plane' is an integer (a plane index), its name. If 'plane' is an characters string (a plane name), its index.
</p>


<h3>See Also</h3>

<p>Other volume utility: 
<code><a href="#topic+vol.boundary.box">vol.boundary.box</a>()</code>,
<code><a href="#topic+vol.imagestack">vol.imagestack</a>()</code>,
<code><a href="#topic+vol.merge">vol.merge</a>()</code>,
<code><a href="#topic+vol.overlay.colors.from.activation">vol.overlay.colors.from.activation</a>()</code>,
<code><a href="#topic+vol.slice">vol.slice</a>()</code>
</p>

<hr>
<h2 id='vol.slice'>Extract a slice of a 3D image stack.</h2><span id='topic+vol.slice'></span>

<h3>Description</h3>

<p>Extracts one or more 2D slices from a 3D image (or a frame of a 4D image). To display the result, you can use <code><a href="#topic+volvis.lightbox">volvis.lightbox</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.slice(
  volume,
  slice_index = NULL,
  frame = 1L,
  axis = 1L,
  rotation = 0L,
  flip = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.slice_+3A_volume">volume</code></td>
<td>
<p>a 3D or 4D image volume. Note that empty dimensions will be dropped before any processing, and the remaining volume must have 3 or 4 dimensions.</p>
</td></tr>
<tr><td><code id="vol.slice_+3A_slice_index">slice_index</code></td>
<td>
<p>positive integer or vector of positive integers, the index into the slices (for the axis). A *slice* in the sense of this function is any 2D image plane extracted from the 3D volume (no matter the axis). If NULL, the slice in the middle of the volume is used. One can pass the magic character string 'all' to use all slice indices along the axis.</p>
</td></tr>
<tr><td><code id="vol.slice_+3A_frame">frame</code></td>
<td>
<p>positive integer, optional. The frame (time point) to use, only relevant for 4D volumes. The last (i.e. 4th) dimension is assumed to be the time dimension in that case.</p>
</td></tr>
<tr><td><code id="vol.slice_+3A_axis">axis</code></td>
<td>
<p>positive integer, the axis to use when indexing the slices. Defaults to 1.</p>
</td></tr>
<tr><td><code id="vol.slice_+3A_rotation">rotation</code></td>
<td>
<p>integer, rotation in degrees. Defaults to 0 (no ratation). Must be a multiple of 90L if given.</p>
</td></tr>
<tr><td><code id="vol.slice_+3A_flip">flip</code></td>
<td>
<p>NULL or one of the character strings 'vertically' or 'horizontally'. Note that flipping *horizontally* means that the image will be mirrored along the central *vertical* axis. If 'NULL' is passed, nothing is flipped. Flipping occurs after rotation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>slice data. If 'slice_index' is a scalar, a numerical 2D matrix (a 2D image from the stack). Otherwise, a numerical 3D array that contains the selected 2D images.
</p>


<h3>See Also</h3>

<p>Other volume utility: 
<code><a href="#topic+vol.boundary.box">vol.boundary.box</a>()</code>,
<code><a href="#topic+vol.imagestack">vol.imagestack</a>()</code>,
<code><a href="#topic+vol.merge">vol.merge</a>()</code>,
<code><a href="#topic+vol.overlay.colors.from.activation">vol.overlay.colors.from.activation</a>()</code>,
<code><a href="#topic+vol.planes">vol.planes</a>()</code>
</p>

<hr>
<h2 id='vol.vox.from.crs'>Compute R voxel index for FreeSurfer CRS voxel index.</h2><span id='topic+vol.vox.from.crs'></span>

<h3>Description</h3>

<p>Performs a vox2vos transform from FreeSurfer to R indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.vox.from.crs(fs_crs, add_affine = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol.vox.from.crs_+3A_fs_crs">fs_crs</code></td>
<td>
<p>integer vector of length 3, Freesurfer indices for column, row, and slice (CRS).</p>
</td></tr>
<tr><td><code id="vol.vox.from.crs_+3A_add_affine">add_affine</code></td>
<td>
<p>logical, whether to add 1 to the output vector as the 4th value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the R indices into the volume data for the given FreeSurfer CRS indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # Get voxel intensity data on the command line, based
   #  on the FreeSUrfer (zero-based) CRS voxel indices:
   #  `mri_info --voxel 127 100 100 ~/data/tim_only/tim/mri/brain.mgz`
   # (the result is: 106.0)
   #
   # That should be identical to:
   # our_crs = vol.vox.from.crs(c(127,100,100), add_affine = FALSE);
   # brain$data[our_crs[1], our_crs[2], our_crs[3]];   # gives 106
</code></pre>

<hr>
<h2 id='volvis.contour'>Visualize contour of a volume.</h2><span id='topic+volvis.contour'></span>

<h3>Description</h3>

<p>Compute a smoothed surface from the voxel intensities in the given volume and render it. Requires the 'misc3d' package to be installed, which is an optional dependency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volvis.contour(volume, level = 80, show = TRUE, frame = 1L, color = "white")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="volvis.contour_+3A_volume">volume</code></td>
<td>
<p>a 3D brain volume</p>
</td></tr>
<tr><td><code id="volvis.contour_+3A_level">level</code></td>
<td>
<p>numeric, intensity threshold for the data. Voxels with intensity value smaller than 'level' will be ignored when creating the contour surface.</p>
</td></tr>
<tr><td><code id="volvis.contour_+3A_show">show</code></td>
<td>
<p>logical, whether to display the triangles. Defaults to 'TRUE'.</p>
</td></tr>
<tr><td><code id="volvis.contour_+3A_frame">frame</code></td>
<td>
<p>integer, the frame to show in case of a 4D input volume. Can also be the character string 'all' to draw the contents of all frames at once. Useful to plot white matter tracts from DTI data, where each tract is stored in a different frame.</p>
</td></tr>
<tr><td><code id="volvis.contour_+3A_color">color</code></td>
<td>
<p>the color to use when plotting. Can be a vector of colors when plotting all frames of a 4D image (one color per frame).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the rendered triangles (a &lsquo;Triangles3D' instance) with coordinates in surface RAS space if any, 'NULL' otherwise. This will be a list if you pass a 4D volume and select &rsquo;all' frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   brain = subject.volume(subjects_dir, 'subject1', 'brain');
   # Plot all voxels of the brain:
   volvis.contour(brain);

## End(Not run)

</code></pre>

<hr>
<h2 id='volvis.lb'>Show continuous 3D voxel/volume data as a lightbox, optionally with a background brain volume and colormap.</h2><span id='topic+volvis.lb'></span>

<h3>Description</h3>

<p>This function is the main way to visualize 3D volume images that contain raw MRI scans or statistical results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volvis.lb(
  volume,
  background = NULL,
  colFn = viridis::viridis,
  colortable = NULL,
  no_act_source_value = 0,
  bbox_threshold = NULL,
  bbox_of_volume = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="volvis.lb_+3A_volume">volume</code></td>
<td>
<p>numerical 3D array of per-voxel data, typically activation data, a raw MRI image, or a segmentation to show. Can also be a filename if the file can be loaded as such a volume with <code><a href="freesurferformats.html#topic+read.fs.volume">read.fs.volume</a></code>.</p>
</td></tr>
<tr><td><code id="volvis.lb_+3A_background">background</code></td>
<td>
<p>numerical 3D array or 3D array of color strings, the background volume. Typically a raw brain volume. Dimensions and space must match those of the 'volume' for an array. Can also be a single file name as a character string. Can also be a single color name, like '#FEFEFE' but the string then must start with '#' (color names like 'red' are not allowed, they would be treated as file names). If a color string, be sure to use the <code>...</code> parameter to set the same color as <code>background_color</code> for the tiles.</p>
</td></tr>
<tr><td><code id="volvis.lb_+3A_colfn">colFn</code></td>
<td>
<p>a colormap function, passed to <code>vol.overlay.colors.from.activation</code> and used as colormap for the 'volume' data. Pass NULL to derive gray-scale values from the raw data (only recommended with single-color backgrounds). Note that the colormap is not used for the the background data (if any), which will be shown in grayscale (unless it is a 3D array of color strings).</p>
</td></tr>
<tr><td><code id="volvis.lb_+3A_colortable">colortable</code></td>
<td>
<p>optional, only makes sense for categorical 'volume' data like segmentations. If not NULL, a colortable as returned by <code><a href="freesurferformats.html#topic+read.fs.colortable">read.fs.colortable</a></code>, or a character string representing a path to a colortable file (like <code>"FREESURFER_HOME/FreeSurferColorLUT.txt"]</code>).</p>
</td></tr>
<tr><td><code id="volvis.lb_+3A_no_act_source_value">no_act_source_value</code></td>
<td>
<p>numerical value, passed to <code>vol.overlay.colors.from.activation</code>. Specifies the value which is treated as transparent in the 'volume' parameter data (where you will see the background). If you need more control, e.g., you want to treat one or morge ranges of values as NA, you should load the 'volume' data first, modify it as needed, as pass it to this function afterwards. Set this parameter to <code>NULL</code> to disable it. Only for 'colFn', ignored if a 'colortable' is used.</p>
</td></tr>
<tr><td><code id="volvis.lb_+3A_bbox_threshold">bbox_threshold</code></td>
<td>
<p>numerical scalar, passed on to <code>vol.merge</code>. If set, voxels with intensities smaller than this threshold will be dropped at the outside of the image. If <code>bbox_of_volume</code> parameter is <code>TRUE</code> (the default), this threshold applies to the 'volume', otherwise to the 'background'. Set to <code>NULL</code> to disable bounding box and show the full image.</p>
</td></tr>
<tr><td><code id="volvis.lb_+3A_bbox_of_volume">bbox_of_volume</code></td>
<td>
<p>logical, whether the bounding box is computed on the volume (foreground), which typically is what you want. Leave alone if in doubt.</p>
</td></tr>
<tr><td><code id="volvis.lb_+3A_...">...</code></td>
<td>
<p>extra parameters to be passed to <code><a href="#topic+volvis.lightbox">volvis.lightbox</a></code>, can be used to select specific slices, set the <code>backgroud_color</code> for the border between and around the image tiles, etc.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should be preferred over manually calling <code><a href="#topic+volvis.lightbox">volvis.lightbox</a></code>.
</p>


<h3>See Also</h3>

<p>Other volume visualization: 
<code><a href="#topic+volvis.lightbox">volvis.lightbox</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
volume = subject.volume(subjects_dir, subject_id, 'brain');
volvis.lb(volume);
volvis.lb("~/study1/subject1/mri/brain.mgz");
volvis.lb("~/study1/subject1/mri/brain.mgz", bbox_threshold = 1L);
volvis.lb("~/study1/subject1/mri/brain.mgz", background = "~/data/study1/subject1/mri/T1.mgz");
volvis.lb("~/study1/subject1/mri/brain.mgz", background = "#FEFEFE", background_color="#FEFEFE");
ct = file.path(find.freesurferhome(mustWork = T), "FreeSurferColorLUT.txt"); # ct = "color table"
volvis.lb("~/study1/subject1/mri/aseg.mgz", background="~/study1/subject1/mri/T1.mgz",
 colortable = ct, colFn=NULL, axis=2L);
volvis.lb("~/study1/subject1/mri/aseg.mgz", background = "~/study1/subject1/mri/T1.mgz",
 colortable = ct, colFn=NULL, bbox_threshold = 0);

## End(Not run)

</code></pre>

<hr>
<h2 id='volvis.lightbox'>Draw a lightbox view from volume slices.</h2><span id='topic+volvis.lightbox'></span>

<h3>Description</h3>

<p>A lightbox is a single image that holds a set of subimages, arranged in a grid. The images can have a small border or spacing between them. Consecutive subimages will be appear the same row of the grid.
</p>
<p>If overlay_colors are given, the volume will be used as the background, and it will only be visible where overlay_colors has transparency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volvis.lightbox(
  volume,
  slices = -5,
  axis = 1L,
  per_row = 5L,
  per_col = NULL,
  border_geometry = "5x5",
  background_color = "#000000",
  arrange_single_image = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="volvis.lightbox_+3A_volume">volume</code></td>
<td>
<p>3D array, can be numeric (gray-scale intensity values) or color strings. If numeric, the intensity values must be in range '[0, 1]'.</p>
</td></tr>
<tr><td><code id="volvis.lightbox_+3A_slices">slices</code></td>
<td>
<p>slice index definition. If a vector of integers, interpreted as slice indices. If a single negative interger &lsquo;-n', interpreted as every 'nth' slice, starting at slice 1. The character string &rsquo;all' or the value 'NULL' will be interpreted as *all slices*.</p>
</td></tr>
<tr><td><code id="volvis.lightbox_+3A_axis">axis</code></td>
<td>
<p>positive integer in range 1L..3L, the axis to use.</p>
</td></tr>
<tr><td><code id="volvis.lightbox_+3A_per_row">per_row</code></td>
<td>
<p>positive integer, the number of subimages per row in the output image. If 'NULL', automatically computed from the number of slices and the 'per_col' parameter.</p>
</td></tr>
<tr><td><code id="volvis.lightbox_+3A_per_col">per_col</code></td>
<td>
<p>positive integer, the number of subimages per column in the output image. If 'NULL', automatically computed from the number of slices and the 'per_row' parameter.</p>
</td></tr>
<tr><td><code id="volvis.lightbox_+3A_border_geometry">border_geometry</code></td>
<td>
<p>string, a geometry string passed to <code>magick::image_border</code> to define the borders to add to each image tile. The default value adds 5 pixels, both horizontally and vertically.</p>
</td></tr>
<tr><td><code id="volvis.lightbox_+3A_background_color">background_color</code></td>
<td>
<p>string, a valid ImageMagick color string such as &quot;white&quot; or &quot;#000080&quot;. The color to use when extending images (e.g., when creating the border). Defaults to black.</p>
</td></tr>
<tr><td><code id="volvis.lightbox_+3A_arrange_single_image">arrange_single_image</code></td>
<td>
<p>logical, whether to apply the given arrangement (from parameters 'per_row' and 'per_column') even if a single slice (a 2D image) is passed as 'volume'. Defaults to FALSE, which prevents that background tiles are added to fill the row up to 'per_row' images. This also prevents the border from getting added to a single image, so all you see is the raw image. Set to 'TRUE' if you want to arrange even a single image in a row with a border.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a magick image instance
</p>


<h3>Note</h3>

<p>You should, in most cases, not call this function directly. Use <code><a href="#topic+volvis.lb">volvis.lb</a></code> instead, which has a more intuitive interface.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+volvis.lb">volvis.lb</a></code>
</p>
<p>Other volume visualization: 
<code><a href="#topic+volvis.lb">volvis.lb</a>()</code>
</p>

<hr>
<h2 id='volvis.voxels'>Voxel-based visualization of volume mask at surface RAS positions.</h2><span id='topic+volvis.voxels'></span>

<h3>Description</h3>

<p>Plots a 3D box at every *foreground* voxel in the given volume. All voxels which do not have their intensity value set to 'NA' are considered *foreground* voxels. The locations at which to plot the voxels is computed from the voxel CRS indices using the FreeSurfer <code><a href="#topic+vox2ras_tkr">vox2ras_tkr</a></code> matrix. This means that the position of the rendered data fits to the surface coordinates (in files like 'surf/lh.white'), and that you can call this function while an active surface rendering window is open (e.g., from calling <code><a href="#topic+vis.subject.morph.native">vis.subject.morph.native</a></code>), to superimpose the surface and volume data. **On coloring the voxels** (using *rgl materials*): Note that you can call this function several times for the active plot, and color the voxels differently by passing different material properties in each call. Alternatively, check the 'voxelcol' parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volvis.voxels(volume, render_every = 1, voxelcol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="volvis.voxels_+3A_volume">volume</code></td>
<td>
<p>numeric 3d array, voxels which should not be plotted must have value 'NA'. Take care not to plot too many.</p>
</td></tr>
<tr><td><code id="volvis.voxels_+3A_render_every">render_every</code></td>
<td>
<p>integer, how many to skip before rendering the next one (to improve performance and/or see deeper structures). Use higher values to see a less dense representation of your data that usually still allows you to see the general shape, but at lower computational burden. Set to 1 to render every (foreground) voxel.</p>
</td></tr>
<tr><td><code id="volvis.voxels_+3A_voxelcol">voxelcol</code></td>
<td>
<p>character string or a *voxel coloring*. A *voxel coloring* can be specified in three ways: 1) the string 'from_intensity' will compute colors based on the intensity values of the foreground voxels in the volume, applying normalization of the intensity values if needed. 2) an array of RGB color strings: will be used to retrieve the colors for all foreground vertices, at their CRS indices. 3) A vector with length identical to the number of foreground voxels in the volume: will be applied directly.  Obvisouly, you should not pass a color material parameter (see '...') when using this.</p>
</td></tr>
<tr><td><code id="volvis.voxels_+3A_...">...</code></td>
<td>
<p>material properties, passed to <code>triangles3d</code>. Example: <code>color = "#0000ff", lit=FALSE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   brain = subject.volume(subjects_dir, 'subject1', 'brain');
   # Plot all voxels of the brain:
   brain[which(brain==0L, arr.ind = TRUE)] = NA;  # mark background
   brain = vol.hull(brain); # remove inner triangles
   volvis.voxels(brain);

## End(Not run)

</code></pre>

<hr>
<h2 id='vox2ras_tkr'>The FreeSurfer default vox2ras_tkr matrix.</h2><span id='topic+vox2ras_tkr'></span>

<h3>Description</h3>

<p>Applying this matrix to a FreeSurfer CRS index of a conformed volume will give you the RAS coordinates of the voxel in surface coordinates, i.e., in the coordinates used in surface file like 'lh.white'. The central voxel is 127,127,127 when using zero-based indices (or 128,128,128 when using one-based indices), meaning its surface RAS coordinates are 0.0, 0.0, 0.0. The returned matrix is the inverse of the 'ras2vox_tkr' matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vox2ras_tkr()
</code></pre>


<h3>Value</h3>

<p>numeric 4x4 matrix, the FreeSurfer vox2ras_tkr matrix.
</p>


<h3>See Also</h3>

<p>Other surface and volume coordinates: 
<code><a href="#topic+ras2vox_tkr">ras2vox_tkr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # Compute surface RAS coordinate of voxel with CRS (0L, 0L, 0L):
   vox2ras_tkr() %*% c(0, 0, 0, 1);
   # Show that voxel with CRS (128,128,128) is at the
   #  origin (0.0, 0.0, 0.0) of the surface RAS coordinate system:
   (vox2ras_tkr() %*% c(128, 128, 128, 1))[1:3];

</code></pre>

<hr>
<h2 id='wrapped.image.append'>Wrapper around magick::image_append that allows specifying the background color when working with images of different width/height.</h2><span id='topic+wrapped.image.append'></span>

<h3>Description</h3>

<p>Wrapper around magick::image_append that allows specifying the background color when working with images of different width/height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapped.image.append(images, stack = FALSE, background_color = "#FFFFFF")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrapped.image.append_+3A_images">images</code></td>
<td>
<p>a vector/stack of magick images. See <code>magick::image_blank</code> or other methods to get one.</p>
</td></tr>
<tr><td><code id="wrapped.image.append_+3A_stack">stack</code></td>
<td>
<p>whether to append vertically, default is FALSE / horizontally.</p>
</td></tr>
<tr><td><code id="wrapped.image.append_+3A_background_color">background_color</code></td>
<td>
<p>hex color string, the background color to use if the images have different sizes and one needs to be extended. Do not use color names like 'gray', which differ between R and magick.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single magick image, the stacked version.
</p>

<hr>
<h2 id='write.group.morph.standard'>Write standard space group data to a standard FreeSurfer directory stucture.</h2><span id='topic+write.group.morph.standard'></span>

<h3>Description</h3>

<p>Write standard space group data to a standard FreeSurfer directory stucture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.group.morph.standard(
  subjects_dir,
  subjects_list,
  data,
  measure_name,
  hemi = "both",
  fwhm = "10",
  template_subject = "fsaverage",
  format = "mgh",
  create_dirs = TRUE,
  template_lh_numverts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.group.morph.standard_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard_+3A_subjects_list">subjects_list</code></td>
<td>
<p>vector of strings. The subject identifiers.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard_+3A_data">data</code></td>
<td>
<p>the data matrix</p>
</td></tr>
<tr><td><code id="write.group.morph.standard_+3A_measure_name">measure_name</code></td>
<td>
<p>character string, the data part of the generated file names, e.g., 'thickness' or 'area'.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh', 'rh' or 'both'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard_+3A_fwhm">fwhm</code></td>
<td>
<p>string. Smoothing as string, e.g. '10' or '25'.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard_+3A_template_subject">template_subject</code></td>
<td>
<p>string. Template subject name, defaults to 'fsaverage'.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard_+3A_format">format</code></td>
<td>
<p>string. One of 'mgh', 'mgz', 'curv'. Defaults to 'mgh'.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard_+3A_create_dirs">create_dirs</code></td>
<td>
<p>logical, whether to create missing (sub) directories which occur in the 'filepaths'.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard_+3A_template_lh_numverts">template_lh_numverts</code></td>
<td>
<p>positive integer, the vertex count of the left hemi of the template subject, only used if 'hemi' is 'both'. If hemi is both and this is unspecified (left at the default value <code>NULL</code>), the template subject needs to exist in the 'subjects_dir' to determine the vertex count of the left hemisphere, so that the data can be split into the <code>lh</code> and <code>rh</code> files at the correct index.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+write.group.morph.standard.sf">write.group.morph.standard.sf</a></code> and <code><a href="#topic+write.group.morph.standard.mf">write.group.morph.standard.mf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dm = matrix(rnorm(325684 * 6, 5.0, 1.2), ncol = 6);
subjects = paste("subject", seq(6), sep="");
write.group.morph.standard("/tmp/groupdata", subjects, dm,
  "rand", template_lh_numverts = 325684 / 2);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.group.morph.standard.mf'>Write per-vertex standard space data for a group of subjects to given file names.</h2><span id='topic+write.group.morph.standard.mf'></span>

<h3>Description</h3>

<p>Write per-vertex standard space data for a group of subjects to given file names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.group.morph.standard.mf(
  filepaths_hl,
  data_hl,
  format = "auto",
  create_dirs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.group.morph.standard.mf_+3A_filepaths_hl">filepaths_hl</code></td>
<td>
<p><code><a href="#topic+hemilist">hemilist</a></code> of vectors of character strings, the full paths to the output files, including file names and extension.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard.mf_+3A_data_hl">data_hl</code></td>
<td>
<p><code><a href="#topic+hemilist">hemilist</a></code> of numerical matrix or data.frame, the morph data for the hemispheres of all subjects. See <code>groupmorph.split.hemilist</code> to get this format if you have a full matrix or dataframe for both hemispheres.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard.mf_+3A_format">format</code></td>
<td>
<p>character string, a valid format spec for <code>freesurferformats::write.fs.morph</code>, e.g., &quot;auto&quot; to derive from filename, &quot;mgh&quot;, &quot;mgz&quot;, &quot;curv&quot; or others.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard.mf_+3A_create_dirs">create_dirs</code></td>
<td>
<p>logical, whether to create missing (sub) directories which occur in the 'filepaths'.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+write.group.morph.standard.sf">write.group.morph.standard.sf</a></code> to write the data to a single stacked file instead.
</p>

<hr>
<h2 id='write.group.morph.standard.sf'>Reshape and write combined per-vertex data for a group to a single MGH file.</h2><span id='topic+write.group.morph.standard.sf'></span>

<h3>Description</h3>

<p>Write morphometry data for a group into a single MGH or MGZ file. In neuroimaging, the first 3 dimensions in the resulting 4D volume file are space, and the 4th is the time/subject dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.group.morph.standard.sf(filepath, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.group.morph.standard.sf_+3A_filepath">filepath</code></td>
<td>
<p>character string, path to the target file, should end with '.mgh' or '.mgz'.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard.sf_+3A_data">data</code></td>
<td>
<p>numerical 2D matrix, with the rows identifying the subjects and the columns identifying the vertices.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The file will contain no information on the subject identifiers. The data can be for one or both hemispheres. See <code><a href="#topic+group.morph.standard.sf">group.morph.standard.sf</a></code> to read the data back into R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create per-vertex data for 5 subjects.
mat = matrix(rnorm(5 * 163842, 3.0, 0.5), nrow=5, ncol = 163842);
fsbrain::write.group.morph.standard.sf("~/group_pvd.mgz", mat);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.group.morph.standard.singlehemi'>Write single hemi per-vertex data for a group of subjects to given file names.</h2><span id='topic+write.group.morph.standard.singlehemi'></span>

<h3>Description</h3>

<p>Write single hemi per-vertex data for a group of subjects to given file names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.group.morph.standard.singlehemi(
  filepaths,
  data,
  format = "auto",
  create_dirs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.group.morph.standard.singlehemi_+3A_filepaths">filepaths</code></td>
<td>
<p>vector of character strings, the full paths to the output files, including file names and extension.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard.singlehemi_+3A_data">data</code></td>
<td>
<p>numerical matrix or data.frame, the morph data for a single hemi (as returned by <code>group.morph.standard</code>). Number of subjects (columns) must match the length of the 'filepaths'.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard.singlehemi_+3A_format">format</code></td>
<td>
<p>character string, a valid format spec for <code>freesurferformats::write.fs.morph</code>, e.g., &quot;auto&quot; to derive from filename, &quot;mgh&quot;, &quot;mgz&quot;, &quot;curv&quot; or others.</p>
</td></tr>
<tr><td><code id="write.group.morph.standard.singlehemi_+3A_create_dirs">create_dirs</code></td>
<td>
<p>logical, whether to create missing (sub) directories which occur in the 'filepaths'.</p>
</td></tr>
</table>

<hr>
<h2 id='write.region.aggregated'>Write data aggregated over regions to morphometry file for group.</h2><span id='topic+write.region.aggregated'></span>

<h3>Description</h3>

<p>Given an atlas, a subjects list and a measure, aggregate the measure over each region (e.g., mean) and write an output morphometry file in which the value for all region vertices is set to the aggregated value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.region.aggregated(
  subjects_dir,
  subjects_list,
  measure,
  hemi,
  atlas,
  agg_fun = mean,
  outfile_morph_name = "",
  format = "mgz"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.region.aggregated_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="write.region.aggregated_+3A_subjects_list">subjects_list</code></td>
<td>
<p>string vector. A vector of subject identifiers that match the directory names within subjects_dir.</p>
</td></tr>
<tr><td><code id="write.region.aggregated_+3A_measure">measure</code></td>
<td>
<p>string. Name of the vertex-wise measure of morphometry data file. E.g., &quot;area&quot; or &quot;thickness&quot;. Used to construct the name of the morphometry file to be loaded.</p>
</td></tr>
<tr><td><code id="write.region.aggregated_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="write.region.aggregated_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="write.region.aggregated_+3A_agg_fun">agg_fun</code></td>
<td>
<p>function. An R function that aggregates data, typically max, mean, min or something similar. Note: this is NOT a string, put the function name without quotes. Defaults to mean.</p>
</td></tr>
<tr><td><code id="write.region.aggregated_+3A_outfile_morph_name">outfile_morph_name</code></td>
<td>
<p>string. The measure part of the output file name. E.g., 'agg_thickness' will write the file '&lt;subject&gt;/surf/&lt;hemi&gt;.agg_thickness.mgh'. Defaults to 'agg_&lt;measure&gt;'.</p>
</td></tr>
<tr><td><code id="write.region.aggregated_+3A_format">format</code></td>
<td>
<p>string. A morphometry file format. One of 'mgh', 'mgz' or 'curv.' The output file name extension will be set accordingly. Defaults to 'mgz'.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other output functions: 
<code><a href="#topic+write.region.values.fsaverage">write.region.values.fsaverage</a>()</code>,
<code><a href="#topic+write.region.values">write.region.values</a>()</code>
</p>

<hr>
<h2 id='write.region.values'>Write one value per atlas region for a subject.</h2><span id='topic+write.region.values'></span>

<h3>Description</h3>

<p>Given an atlas and a list that contains one value for each atlas region, write a morphometry file in which all region vertices are assigned the value. Can be used to plot stuff like p-values or effect sizes onto brain regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.region.values(
  subjects_dir,
  subject_id,
  hemi,
  atlas,
  region_value_list,
  outfile_morph_name,
  format = "mgz",
  do_write_file = TRUE,
  output_path = NULL,
  value_for_unlisted_regions = NaN
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.region.values_+3A_subjects_dir">subjects_dir</code></td>
<td>
<p>string. The FreeSurfer SUBJECTS_DIR, i.e., a directory containing the data for all your subjects, each in a subdir named after the subject identifier.</p>
</td></tr>
<tr><td><code id="write.region.values_+3A_subject_id">subject_id</code></td>
<td>
<p>string. The subject identifier</p>
</td></tr>
<tr><td><code id="write.region.values_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="write.region.values_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="write.region.values_+3A_region_value_list">region_value_list</code></td>
<td>
<p>named list. A list in which the names are atlas regions, and the values are the value to write to all vertices of that region.</p>
</td></tr>
<tr><td><code id="write.region.values_+3A_outfile_morph_name">outfile_morph_name</code></td>
<td>
<p>string. The measure part of the output file name. E.g., 'agg_thickness' will write the file '&lt;subject&gt;/surf/&lt;hemi&gt;.agg_thickness.mgh'.</p>
</td></tr>
<tr><td><code id="write.region.values_+3A_format">format</code></td>
<td>
<p>string. A morphometry file format. One of 'mgh', 'mgz' or 'curv.' The output file name extension will be set accordingly. Defaults to 'mgz'.</p>
</td></tr>
<tr><td><code id="write.region.values_+3A_do_write_file">do_write_file</code></td>
<td>
<p>logical. Whether to write the data to a file on the disk. If FALSE, the data are only returned (and the outfile_morph_name parameter gets ignored). Default to TRUE.</p>
</td></tr>
<tr><td><code id="write.region.values_+3A_output_path">output_path</code></td>
<td>
<p>string, path to the output directory. If omitted, defaults to the 'surf' directory of the subject (i.e., '&lt;subjects_dir&gt;/&lt;subject_id&gt;/surf/').</p>
</td></tr>
<tr><td><code id="write.region.values_+3A_value_for_unlisted_regions">value_for_unlisted_regions</code></td>
<td>
<p>numeric scalar. The value to assign to vertices which are part of atlas regions that are not listed in region_value_list. Defaults to NaN.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with the following entries: &quot;data&quot;: a vector containing the data. &quot;file_written&quot;: string, path to the file that was written, only exists if do_write = TRUE.
</p>


<h3>See Also</h3>

<p>Other output functions: 
<code><a href="#topic+write.region.aggregated">write.region.aggregated</a>()</code>,
<code><a href="#topic+write.region.values.fsaverage">write.region.values.fsaverage</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fsbrain::download_optional_data();
   subjects_dir = fsbrain::get_optional_data_filepath("subjects_dir");
   region_value_list = list("bankssts"=0.9, "precuneus"=0.7);
   write.region.values(subjects_dir, 'subject1', 'lh', 'aparc',
    region_value_list, 'pvalues.mgz', do_write_file = FALSE);

## End(Not run)

</code></pre>

<hr>
<h2 id='write.region.values.fsaverage'>Write one value per atlas region for a template subject.</h2><span id='topic+write.region.values.fsaverage'></span>

<h3>Description</h3>

<p>Given an atlas and a list that contains one value for each atlas region, write a morphometry file in which all region vertices are assigned the value. Can be used to plot stuff like p-values or effect sizes onto brain regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.region.values.fsaverage(
  hemi,
  atlas,
  region_value_list,
  output_file,
  template_subject = "fsaverage",
  template_subjects_dir = NULL,
  show_freeview_tip = FALSE,
  value_for_unlisted_regions = NaN
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.region.values.fsaverage_+3A_hemi">hemi</code></td>
<td>
<p>string, one of 'lh' or 'rh'. The hemisphere name. Used to construct the names of the annotation and morphometry data files to be loaded.</p>
</td></tr>
<tr><td><code id="write.region.values.fsaverage_+3A_atlas">atlas</code></td>
<td>
<p>string. The atlas name. E.g., &quot;aparc&quot;, &quot;aparc.2009s&quot;, or &quot;aparc.DKTatlas&quot;. Used to construct the name of the annotation file to be loaded.</p>
</td></tr>
<tr><td><code id="write.region.values.fsaverage_+3A_region_value_list">region_value_list</code></td>
<td>
<p>named list. A list in which the names are atlas regions, and the values are the value to write to all vertices of that region.</p>
</td></tr>
<tr><td><code id="write.region.values.fsaverage_+3A_output_file">output_file</code></td>
<td>
<p>string or 'NULL'. Path of the output file, including file name and extension. The format is determined from the (absence of a) file extension. If NULL, no file will be written.</p>
</td></tr>
<tr><td><code id="write.region.values.fsaverage_+3A_template_subject">template_subject</code></td>
<td>
<p>string, template subject name. Defaults to 'fsaverage'.</p>
</td></tr>
<tr><td><code id="write.region.values.fsaverage_+3A_template_subjects_dir">template_subjects_dir</code></td>
<td>
<p>string, the path to the subjects directory containing the template subject directory. If this is 'NULL', the function will try to find it using the environment, see the function <code><a href="#topic+find.subjectsdir.of">find.subjectsdir.of</a></code> for details. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="write.region.values.fsaverage_+3A_show_freeview_tip">show_freeview_tip</code></td>
<td>
<p>logical, whether to print the freeview command on howto use the overlay to the console. (Only happens if the output_file is not 'NULL'.)</p>
</td></tr>
<tr><td><code id="write.region.values.fsaverage_+3A_value_for_unlisted_regions">value_for_unlisted_regions</code></td>
<td>
<p>numeric scalar. The value to assign to vertices which are part of atlas regions that are not listed in region_value_list. Defaults to NaN.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with the following entries: &quot;data&quot;: a vector containing the data. &quot;file_written&quot;: string, path to the file that was written, only exists if do_write = TRUE.
</p>


<h3>See Also</h3>

<p>Other output functions: 
<code><a href="#topic+write.region.aggregated">write.region.aggregated</a>()</code>,
<code><a href="#topic+write.region.values">write.region.values</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
