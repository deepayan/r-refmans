<!DOCTYPE html><html lang="en"><head><title>Help for package upndown</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {upndown}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bcdmat'><p>Transition Probability Matrices for Up-and-Down Designs</p></a></li>
<li><a href='#dfboot'><p>Generic percentile dose-response / dose-finding bootstrap routine</p></a></li>
<li><a href='#dfsim'><p>Generalized Dose-Finding Ensemble Simulator</p></a></li>
<li><a href='#dixonmood'><p>Original Dixon and Mood (1948) point estimate</p></a></li>
<li><a href='#drplot'><p>Visualizing the dose-response summary of an up-and-down experiment</p></a></li>
<li><a href='#dynamean'><p>Up-and-Down target-dose averaging estimate, with dynamic cutoff-point</p></a></li>
<li><a href='#k2targ'><p>Up-and-Down Target Calculation and Design Guidance</p></a></li>
<li><a href='#krow'><p>Up-and-Down Design Rules for use in Dose-Finding Simulator</p></a></li>
<li><a href='#pivec'><p>Key Probability Vectors of Up-and-Down Designs</p></a></li>
<li><a href='#reversmean'><p>Reversal-anchored averaging estimators for Up-and-Down</p></a></li>
<li><a href='#udest'><p>Centered-Isotonic-Regression (CIR) Estimate for the Up-and-Down Target Dose</p></a></li>
<li><a href='#udplot'><p>Visualizing the time series of an up-and-down experiment</p></a></li>
<li><a href='#validUDinput'><p>Data Validation Utilities for <code>upndown</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Utilities and Design Aids for Up-and-Down Dose-Finding Studies</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-15</td>
</tr>
<tr>
<td>Description:</td>
<td>Up-and-Down is the most popular design approach for dose-finding, but has been severely under-served by the statistical computing community. This is the first package to address Up-and-Down's needs. For a recent methodological tutorial on Up-and-Down, see Oron et al. (2022) &lt;<a href="https://doi.org/10.1097%2FALN.0000000000004282">doi:10.1097/ALN.0000000000004282</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>cir, expm, numbers, plyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-10 05:02:56 UTC; assaf</td>
</tr>
<tr>
<td>Author:</td>
<td>Assaf P. Oron [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Assaf P. Oron &lt;assaf.oron@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-10 05:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bcdmat'>Transition Probability Matrices for Up-and-Down Designs</h2><span id='topic+bcdmat'></span><span id='topic+classicmat'></span><span id='topic+kmatMarg'></span><span id='topic+kmatFull'></span><span id='topic+gudmat'></span>

<h3>Description</h3>

<p>Transition Probability Matrices for Common Up-and-Down Designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcdmat(cdf, target)

classicmat(cdf)

kmatMarg(cdf, k, lowTarget)

kmatFull(cdf, k, lowTarget, fluffup = FALSE)

gudmat(cdf, cohort, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bcdmat_+3A_cdf">cdf</code></td>
<td>
<p>monotone increasing vector with positive-response probabilities. The number of dose levels <code class="reqn">M</code> is deduced from vector's length.</p>
</td></tr>
<tr><td><code id="bcdmat_+3A_target">target</code></td>
<td>
<p>the design's target response rate (<code>bcdmat()</code> only).</p>
</td></tr>
<tr><td><code id="bcdmat_+3A_k">k</code></td>
<td>
<p>the number of consecutive identical responses required for dose transitions (k-in-a-row functions only).</p>
</td></tr>
<tr><td><code id="bcdmat_+3A_lowtarget">lowTarget</code></td>
<td>
<p>logical k-in-a-row functions only: is the design targeting below-median percentiles, with <code class="reqn">k</code> repeated negative responses needed to level up and only one to level down - or vice versa? Default <code>FALSE</code>. See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="bcdmat_+3A_fluffup">fluffup</code></td>
<td>
<p>logical (<code>kmatFull</code> only): in the full k-in-a-row internal-state representation, should we <em>&quot;fluff&quot;</em> the matrix up so that it has <code class="reqn">Mk</code> rows and columns (<code>TRUE</code>), or exclude <code class="reqn">k-1</code> &quot;phantom&quot; states near the less-likely-to-be-visited boundary (<code>FALSE</code>, default)?</p>
</td></tr>
<tr><td><code id="bcdmat_+3A_cohort">cohort</code></td>
<td>
<p><code>gudmat</code> only: the cohort (group) size</p>
</td></tr>
<tr><td><code id="bcdmat_+3A_lower">lower</code>, <code id="bcdmat_+3A_upper">upper</code></td>
<td>
<p>(<code>gudmat</code> only) how many positive responses are allowed for a move upward, and how many are required for a move downward, respectively. For example <code style="white-space: pre;">&#8288;cohort=3, lower=0, upper=2&#8288;</code> evaluates groups of 3 observations at a time, moves up if none are positive, down if <code class="reqn">&gt;=2</code> are positive, and repeats the same dose with 1 positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Up-and-Down designs (UDDs) generate random walk behavior, whose theoretical properties can be summarized via a transition probability matrix (TPM). Given the number of doses <code class="reqn">M</code>, and the value of the cdf <code class="reqn">F</code> at each dose (i.e., the positive-response probabilities), the specific UDD rules uniquely determine the TPM.
</p>
<p>The utilities described here calculate the TPMs of the most common and simplest UDDs:
</p>

<ul>
<li><p> The k-in-a-row or <strong>fixed staircase</strong> design common in sensory studies: <code style="white-space: pre;">&#8288;kmatMarg(), kmatFull()&#8288;</code> (Gezmu, 1996; Oron and Hoff, 2009; see Note). Design parameters are k, a natural number, and whether k negative responses are required for dose transition, or k positive responses. The former is for targets below the median and vice versa.
</p>
</li>
<li><p> The Durham-Flournoy Biased Coin Design: <code>bcdmat()</code>. This design can target any percentile via the <code>target</code> argument (Durham and Flournoy, 1994).
</p>
</li>
<li><p> The original <em>&quot;classical&quot;</em> median-targeting UDD: <code>classicmat()</code> (Dixon and Mood, 1948). This is simply a wrapper for <code>bcdmat()</code> with <code>target</code> set to 0.5.
</p>
</li>
<li><p> Cohort or group UDD: <code>gudmat()</code>, with three design parameters for the group size and the up/down rule thresholds  (Gezmu and Flournoy, 2006).
</p>
</li></ul>



<h3>Value</h3>

<p>An <code class="reqn">M\times M</code> transition probability matrix, except for <code>kmatFull()</code> with <code class="reqn">k&gt;1</code> which returns a larger square matrix.
</p>


<h3>Note</h3>

<p>As Gezmu (1996) discovered and Oron and Hoff (2009) further extended, k-in-a-row UDDs with <code class="reqn">k&gt;1</code> generate a random walk <em>with internal states</em>. Their full TPM is therefore larger than <code class="reqn">M\times M.</code> However, in terms of random-walk behavior, most salient properties are better represented via an <code class="reqn">M\times M</code> matrix analogous to those of the other designs, with transition probabilities marginalized over internal states using their asymptotic frequencies. This matrix is provided by <code>kmatMarg()</code>, while <code>kmatFull()</code> returns the full matrix including internal states.
</p>
<p>Also, in <code>kmatFull()</code> there are two matrix-size options. Near one of the boundaries (upper boundary with <code>lowTarget = TRUE</code>, and vice versa), the most extreme <code class="reqn">k</code> internal states are practically indistinguishable, so in some sense only one of them really exists. Using the <code>fluffup</code> argument, users can choose between having a more aesthetically symmetric (but a bit misleading) full <code class="reqn">Mk\times Mk</code> matrix, or reducing it to its effectivelly true size by removing <code class="reqn">k-1</code> rows and columns.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>


<ul>
<li><p> Dixon WJ, Mood AM. A method for obtaining and analyzing sensitivity data. <em>J Am Stat Assoc.</em> 1948;43:109-126.
</p>
</li>
<li><p> Durham SD, Flournoy N. Random walks for quantile estimation. In: <em>Statistical Decision Theory and Related Topics V</em> (West Lafayette, IN, 1992). Springer; 1994:467-476.
</p>
</li>
<li><p> Gezmu M. The Geometric Up-and-Down Design for Allocating Dosage Levels. PhD Thesis. American University; 1996.
</p>
</li>
<li><p> Gezmu M, Flournoy N. Group up-and-down designs for dose-finding. <em>J Stat Plan Inference.</em> 2006;136(6):1749-1764.
</p>
</li>
<li><p> Oron AP, Hoff PD. The k-in-a-row up-and-down design, revisited. <em>Stat Med.</em> 2009;28:1805-1820.
</p>
</li>
<li><p> Oron AP, Souter MJ, Flournoy N. Understanding Research Methods: Up-and-down Designs for Dose-finding. <em>Anesthesiology</em> 2022; 137:137–50.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+k2targ">k2targ</a></code>, <code><a href="#topic+ktargOptions">ktargOptions</a></code> to find the k-in-a-row target-response rate for specific k and vice versa.
</p>
</li>
<li> <p><code><a href="#topic+g2targ">g2targ</a></code>, , <code><a href="#topic+gtargOptions">gtargOptions</a></code> likewise for group up-and-down.
</p>
</li>
<li> <p><code><a href="#topic+pivec">pivec</a></code>, <code><a href="#topic+currentvec">currentvec</a></code>, <code><a href="#topic+cumulvec">cumulvec</a></code>, which provide probability vectors of dose-allocation distributions using Up-and-Down TPMs.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#  Let's use an 8-dose design, and  a somewhat asymmetric CDF

exampleF = pweibull(1:8, shape = 2, scale = 4)
# You can plot if you want: plot(exampleF)

# Here's how the transition matrix looks for the median-finding classic up-and-down

round(classicmat(exampleF), 2)
# Note how the only nonzero diagonals are at the opposite corners. That's how 
#   odd-n and even-n distributions communicate (see examples for vector functions).
# Also note how "up" probabilities (the 1st upper off-diagnoal) are decreasing, 
#   while "down" probabilities (1st lower off-diagonal) are increasing, and 
#   start exceeding "up" moves at row 4.

# Now, let's use the same F to target the 90th percentile, which is often
#    the goal of anesthesiology dose-finding studies.
#    We use the biased-coin design (BCD) presented by Durham and Flournoy (1994):

round(bcdmat(exampleF, target = 0.9), 2)

# Note that now there's plenty of probability mass on the diagonal (i.e., repeating same dose).

# Another option, actually with somewhat better operational characteristics, 
#   is "k-in-a-row". Let's see what k to use:

ktargOptions(.9, tolerance = 0.05)

# Even though nominally k=7's target is closest to 0.9, it's generally preferable
#    to choose a somewhat smaller k. So let's go with k=6.
# We must also specify whether this is a low (&lt;0.5) or high target.

round(kmatMarg(exampleF, k = 6, lowTarget = FALSE), 2)

# Compare and contrast with the BCD matrix above! At what dose do the "up" and "down"
#   probabilities flip? 

# Lastly, if you want to see a 43 x 43 matrix - the full state matrix for k-in-a-row, 
#      run the following line:



  round(kmatFull(exampleF, k = 6, lowTarget = FALSE), 2)




</code></pre>

<hr>
<h2 id='dfboot'>Generic percentile dose-response / dose-finding bootstrap routine</h2><span id='topic+dfboot'></span>

<h3>Description</h3>

<p>Bootstrap routine for resampling a dose-finding or dose-response experiment. The bootstrap replicates are generated from a centered-isotonic-regression (CIR) estimate of the dose-response function, rather than resampled directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfboot(
  x,
  y,
  doses = NULL,
  estfun = dynamean,
  design,
  desArgs,
  target,
  balancePt = target,
  conf = 0.9,
  B = 1000,
  seed = NULL,
  randstart = TRUE,
  showdots = TRUE,
  full = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dfboot_+3A_x">x</code></td>
<td>
<p>numeric vector: sequence of administered doses, treatments, stimuli, etc.</p>
</td></tr>
<tr><td><code id="dfboot_+3A_y">y</code></td>
<td>
<p>numeric vector: sequence of observed responses. Must be same length as <code>x</code> or shorter by 1, and must be coded <code>TRUE/FALSE</code> or 0/1.</p>
</td></tr>
<tr><td><code id="dfboot_+3A_doses">doses</code></td>
<td>
<p>the complete set of dose values that <em>could</em> have been included in the experiment. Must include all unique values in <code>x</code>.</p>
</td></tr>
<tr><td><code id="dfboot_+3A_estfun">estfun</code></td>
<td>
<p>the estimation function to be bootstrapped. Default <code><a href="#topic+dynamean">dynamean</a></code></p>
</td></tr>
<tr><td><code id="dfboot_+3A_design">design</code>, <code id="dfboot_+3A_desargs">desArgs</code></td>
<td>
<p>design details passed on to <code><a href="#topic+dfsim">dfsim</a></code>; the former is a function and the latter a list of its arguments and values. For self-consistent bootstrapping, this must specify the design used in the actual experiment. See <code><a href="#topic+dfsim">dfsim</a></code>.</p>
</td></tr>
<tr><td><code id="dfboot_+3A_target">target</code></td>
<td>
<p>The target percentile to be estimated (as a fraction). Again must be the same one estimated in the actual experiment. Default 0.5.</p>
</td></tr>
<tr><td><code id="dfboot_+3A_balancept">balancePt</code></td>
<td>
<p>In case the design's inherent balance point differs somewhat from <code>target</code>, specify it here to improve estimation accuracy. See Details for further explanation. Otherwise, this argument defaults to be equal to <code>target</code>.</p>
</td></tr>
<tr><td><code id="dfboot_+3A_conf">conf</code></td>
<td>
<p>the CI's confidence level, as a fraction in (0,1).</p>
</td></tr>
<tr><td><code id="dfboot_+3A_b">B</code></td>
<td>
<p>Size of bootstrap ensemble, default 1000.</p>
</td></tr>
<tr><td><code id="dfboot_+3A_seed">seed</code></td>
<td>
<p>Random seed; default <code>NULL</code> which leads to a &quot;floating&quot; seed, varying between calls.</p>
</td></tr>
<tr><td><code id="dfboot_+3A_randstart">randstart</code></td>
<td>
<p>Logical: should the bootstrap runs randomize the starting dose, or use the same starting dose as the actual experiment? Default <code>TRUE</code>, which we expect to produce better properties. The randomization will be weighted by the real data's dose-specific sample sizes.</p>
</td></tr>
<tr><td><code id="dfboot_+3A_showdots">showdots</code></td>
<td>
<p>Logical: should &quot;progress dots&quot; be printed out as the bootstrap runs progress? Default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="dfboot_+3A_full">full</code></td>
<td>
<p>Logical: controls how detailed the output is. Default (<code>FALSE</code>) is only the resulting interval bounds, while <code>TRUE</code> returns a list with the full bootstrap ensemble of doses, responses and estimates, as well as the generating dose-response curve and the bootstrap's dose set.</p>
</td></tr>
<tr><td><code id="dfboot_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to estimation functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function should be able to generate bootstrap resamples of any dose-finding design, as long as <code style="white-space: pre;">&#8288;design, desArgs&#8288;</code> are specified correctly. For the &quot;Classical&quot; median-finding UDD, use <code style="white-space: pre;">&#8288;design = krow, desArgs = list(k=1)&#8288;</code>. For other UDDs, see <code><a href="#topic+dfsim">dfsim</a></code>.
</p>
<p>Like Chao and Fuh (2001) and Stylianou et al. (2003), the bootstrap samples are generated indirectly, by estimating a dose-response curve F from the data, then generating an ensemble of bootstrap experiments using the same design used in the original experiment. Unlike these two which used parametric or isotonic regression, respectively, with no bias-mitigation and no additional provisions to improve coverage, our implementation uses CIR with the Flournoy and Oron (2020) bias-mitigation. When feasible, it also allows the bootstrap runs to extend up to 2 dose-levels in each direction, beyond the doses visited in the actual experiment.
</p>


<h3>Note</h3>

<p>This function can be run stand-alone, but it is mostly meant to be called in the backend, in case a dose-averaging estimate &quot;wants&quot; a confidence interval (which is default behavior for <code style="white-space: pre;">&#8288;dynamean(), reversmean()&#8288;</code> at present). You are welcome to figure out how to run it stand-alone, but I do not provide example code here since we still recommend CIR and its analytically-informed intervals over dose-averaging with bootstrap intervals. If you would like to run general up-and-down or dose-finding simulations, see <code>dfsim()</code> and its code example.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>


<ul>
<li><p> Chao MT, Fuh CD. Bootstrap methods for the up and down test on pyrotechnics sensitivity analysis. Statistica Sinica. 2001 Jan 1:1-21.
</p>
</li>
<li><p> Flournoy N, Oron AP. Bias induced by adaptive dose-finding designs. J Appl Stat. 2020;47(13-15):2431-2442.
</p>
</li>
<li><p> Stylianou M, Proschan M, Flournoy N. Estimating the probability of toxicity at the target dose following an up‐and‐down design. Statistics in medicine. 2003 Feb 28;22(4):535-43.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+dfsim">dfsim</a></code>
</p>

<hr>
<h2 id='dfsim'>Generalized Dose-Finding Ensemble Simulator</h2><span id='topic+dfsim'></span>

<h3>Description</h3>

<p>This function simulates sequential dose-finding experiments on a fixed dose grid. The response function is (implicitly) assumed monotone in <code style="white-space: pre;">&#8288;(0,1)&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfsim(
  n,
  starting = NULL,
  sprobs = NULL,
  cohort = 1,
  Fvals,
  ensemble = dim(Fvals)[2],
  design = krow,
  desArgs = list(k = 1),
  thresholds = NULL,
  seed = NULL,
  showdots = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dfsim_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="dfsim_+3A_starting">starting</code></td>
<td>
<p>the starting dose level. If <code>NULL</code> (default), will be randomized.</p>
</td></tr>
<tr><td><code id="dfsim_+3A_sprobs">sprobs</code></td>
<td>
<p>the probability weights if using a randomized starting dose. If <code>NULL</code> (default) will be discrete-uniform.</p>
</td></tr>
<tr><td><code id="dfsim_+3A_cohort">cohort</code></td>
<td>
<p>the cohort (group) size, default 1.</p>
</td></tr>
<tr><td><code id="dfsim_+3A_fvals">Fvals</code></td>
<td>
<p>(vector or matrix): the true values of the response function on the dose grid. These are the dose-response scenarios from which the experimental runs will be simulated. If running an ensemble with different scenarios, each scenarios is a column. If running an identical-scenario ensemble, provide a single vector as well as <code>ensemble</code>.</p>
</td></tr>
<tr><td><code id="dfsim_+3A_ensemble">ensemble</code></td>
<td>
<p>the number of different runs/scenarios to be simulated. Will be determined automatically if <code>Fvals</code> is a matrix, as the number of columns.</p>
</td></tr>
<tr><td><code id="dfsim_+3A_design">design</code></td>
<td>
<p>the dose-finding design function used to determine the next dose. Default <code>krow</code>; see <code><a href="#topic+krow">krow</a></code> for options.</p>
</td></tr>
<tr><td><code id="dfsim_+3A_desargs">desArgs</code></td>
<td>
<p>List of arguments passed on to <code>design</code>. Need to be compatible for use in <code>mapply</code>. Default is <code>list(k=1)</code>, which together with <code>design = krow</code> will generate a Clasical (median-finding) UDD simulation.</p>
</td></tr>
<tr><td><code id="dfsim_+3A_thresholds">thresholds</code></td>
<td>
<p>Matrix of size (at least) <code>n</code> by <code>ensemble</code>, the response thresholds of participants, presented as percentiles (i.e., output of <code>runif()</code>) rather than physical values. If <code>NULL</code> (default), they will be simulated on the fly. When running comparative performance simulations, we recommend providing the same thresholds to everything you want to compare on equal footing.</p>
</td></tr>
<tr><td><code id="dfsim_+3A_seed">seed</code></td>
<td>
<p>The random seed if simulating the thresholds. Can be kept <em>&quot;floating&quot;</em> (i.e., varying between calls) if left as <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="dfsim_+3A_showdots">showdots</code></td>
<td>
<p>Logical: print out a dot (<code>.</code>) after each designion step in <code>1:n</code>, and the start/end time stamps? Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A vectorized dose-finding simulator, set up to run an entire ensemble simultaneously.
The simulated doses are indices <code>1:nlev</code> with <code>nlev</code> being the number of dose levels.
Upon output they can be optionally &quot;dressed up&quot; with physical values using the <code>xvals</code> argument.
</p>
<p>The simulator's essential use within the <code>upndown</code> package is to estimate bootstrap confidence intervals for dose-averaging target estimates, via <code><a href="#topic+dfboot">dfboot</a></code>. But it can be also used stand-alone as a study-design aid.
</p>
<p>The particular dose-finding design simulated is determined by <code>design</code> and its argument list <code>desArgs</code>. The 3 straightforward extensions of the median-finding &quot;Classical&quot; UDD are available, namely &quot;k-in-a-row&quot;, biased-coin and group (cohort) UDD. To simulate the the median-finding &quot;Classical&quot; UDD itself, use <code>krow</code> with <code>desArgs = list(k=1)</code>.
Other non-UDD dose-finding designs - e.g., CRM, CCD, BOIN, etc. - can also be made compatible with <code>dfsim</code>. Utilities to run those 3 in particular are available on GitHub, under <code>assaforon/UpndownBook/P3_Practical/OtherDesigns.r</code>.
</p>
<p>If you want to create a <code>design</code> function yourself, it would need to accept <code style="white-space: pre;">&#8288;doses, responses&#8288;</code> as input, and return the next dose allocation (as an integer index).
The main progression loop is run via <code>mapply</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>scenarios</code>: <code>Fvals</code>
</p>
</li>
<li> <p><code>sample</code>: <code>thresholds</code>
</p>
</li>
<li> <p><code>doses</code>: The matrix of simulated dose allocations for each run (<code>n+1</code> by <code>ensemble</code>)
</p>
</li>
<li> <p><code>responses</code>: The matrix of simulated responses (0 or 1) for each run (<code>n</code> by <code>ensemble</code>)
</p>
</li>
<li> <p><code>cohort</code>: <code>cohort</code>
</p>
</li>
<li> <p><code>details</code>: <code>desArgs</code>
</p>
</li></ul>



<h3>Note</h3>

<p>This is an adaptation of a non-package function used by the author for well over a decade before incorporating it into <code>upndown</code> in late 2023. For initial guidance, see the code example. If you encounter any funny behavior please let me know. Thank you!
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+dfboot">dfboot</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>### dfsim example

# We provide a "toy example" for how randomized-F simulations might work.
# We have been strong advocated of this simulation approach, especially for performance comparison
#   between designs and between estimators. It is far preferable to the "cherry-picked F" approach.
# Unfortunately, the latter is still more commonly found in dose-finding literature.

# At core is a randomized ensemble of F(x) ("dose-response") curves. It is far easier
#   to generate parametric ensembles rather than nonparametric or semi-parametric ones.
# So this is what we do here. We use the Weibull, being capable of the most diverse ensembles
#   among common parametric families.

# This being a toy example, it is more simplistic than our current practice. For the latter,
#   see either the supplement to Oron et al. 2022, or the NE Journal of SDS due online
#   late 2024 or early 2025.  Ok, let's go!

# We simulate 7-level experiments.
m = 7
# And 10 curves in total
B = 10
# Parameter generation (I chose the parameter bounds after some trial and error)
# Note I am not fixing a seed, so each time you run this you'll get a different ensemble!
wparams = cbind(2^runif(B, -2, 2.5), runif(B, 1, 10) )
round(wparams, 2)
# Now the F(x) curves; they should be in columns
ensemble = apply(wparams, 1, function(x, doses = m) 
                  pweibull(1:doses, shape = x[1], scale = x[2]) )

# Let's see what we got!
round(ensemble, 3)
# The experiment will be "Classical" median-targeting. In real life if 0.5 falls outside
#     of the range of doses, it's not great. For simulation it's fine; it'll enable us to 
#     watch the allocations for such curves heap near the edge with F closest to 0.5.

# Let the experiments be a measly n=15, to keep runtime under the menacing 5 seconds.
# We start all runs smack in the middle, level 4:
sout = dfsim(n = 15, starting = 4, Fvals = ensemble, design = krow, desArgs = list(k=1) )
names(sout)

# "scenarios" are the F values we provided, while "sample" is the set of randomized thresholds
#   simulated from the uniform distribution. If you run comparisons, we recommend that
#   you only randomize the first set in the comparison, and feed the very same thresholds to 
#   all the rest.

# Anyhoo, here are the simulated trajectories. Note that there are n+1 of them, because after 
#     seeing x_n and y_n, the n+1-th allocation can be determined.
sout$doses
# Compare with the F ensemble. Is it what you expected? 
# Probably more random-walky than you thought :)

# The binary responses are below. Before going big on the simulation, it's a good idea to
#    sanity-check and see that the doses and responses match according to the design's rules.
sout$responses
# Some meta details about the design and simulation settings are available here:
sout$details


</code></pre>

<hr>
<h2 id='dixonmood'>Original Dixon and Mood (1948) point estimate</h2><span id='topic+dixonmood'></span>

<h3>Description</h3>

<p>Basic version; formula assumes uniform spacing but should work anyway
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dixonmood(x, y, full = FALSE, flip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dixonmood_+3A_x">x</code></td>
<td>
<p>numeric vector: sequence of administered doses, treatments, stimuli, etc.</p>
</td></tr>
<tr><td><code id="dixonmood_+3A_y">y</code></td>
<td>
<p>numeric vector: sequence of observed responses. Must be same length as <code>x</code> or shorter by 1, and must be coded <code>TRUE/FALSE</code> or 0/1. <code>dynamean()</code> only uses <code>y</code> for bootstrap confidence intervals.</p>
</td></tr>
<tr><td><code id="dixonmood_+3A_full">full</code></td>
<td>
<p>logical: should more detailed information be returned, or only the estimate? (default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="dixonmood_+3A_flip">flip</code></td>
<td>
<p>logical: should we flip D-M's approach and use the more-common outcome? (default <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In their documentation of the Up-and-Down algorithm, Dixon and Mood (1948) presented an estimation method based on tallying and averaging responses, choosing to use only the positive or negative responses (the less-common of the two), since they reasoned the two mirror each other. This is not strictly true: it ignores both leading/trailing &quot;tail&quot; sequences of identical responses, and repeated visits to the boundary dose in case there are dose boundaries.
</p>
<p>The Dixon-Mood estimate (sometimes called Dixon-Massey) is provided here mostly for historical reasons and comparative-simulation uses, and also because this estimate is apparently <em>(and unfortunately)</em> still in use in some fields. <strong>It should not be used for actual target-dose estimation in real experiments.</strong> It behaves very poorly even under minor deviations from the most optimal conditions (see, e.g., simulations in the supplement to Oron et al. 2022.).
</p>
<p>In order to discourage from actual use in experiments, we do not provide a method for the Dixon-Mood estimator's confidence interval, even though the original article did include one. The interval estimate behaves even more poorly than the point estimate.
</p>
<p>For UDD target estimation we recommend using centered isotonic regression, available via <code><a href="#topic+udest">udest</a></code>, an up-and-down adapted wrapper to <code>cir::quickInverse()</code>. See Oron et al. 2022 (both article and supplement) for further information, as well as the <code>cir</code> package vignette.
</p>


<h3>Value</h3>

<p>The point estimate
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>


<ul>
<li><p> Dixon WJ, Mood AM. A method for obtaining and analyzing sensitivity data. <em>J Am Stat Assoc.</em> 1948;43:109-126.
</p>
</li>
<li><p> Oron AP, Souter MJ, Flournoy N. Understanding Research Methods: Up-and-down Designs for Dose-finding. <em>Anesthesiology</em> 2022; 137:137–50. <a href="https://cdn-links.lww.com/permalink/aln/c/aln_2022_05_25_oron_aln-d-21-01101_sdc1.pdf">See in particular the open-access Supplement.</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+udest">udest</a></code>, the recommended estimation method for up-and-down targets.
</p>
</li>
<li> <p><code><a href="#topic+reversmean">reversmean</a></code>, The most commonly-used dose-averaging approach (<em>not</em> recommended; the recommended one is <code><a href="#topic+udest">udest</a></code> referenced above).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#'  **An up-and-down experiment that has generated some controversy**
#'  
#' Van Elstraete, AC et al. The Median Effective Dose of Preemptive Gabapentin 
#'      on Postoperative Morphine Consumption After Posterior Lumbar Spinal Fusion. 
#'      *Anesthesia &amp; Analgesia* 2008, 106: 305-308.


# It was a classical median-finding up-and-down study.

doses = c(4:7, 6:13, 12:19, 18:21, 20, 19:23, 22, 21:23, 22:19, 20:23, 
          22:24, 23, 22, 23, 22:25, 24:22, rep(23:24,2), 23, 22)
# With U&amp;D, responses (except the last one) can be read off the doses:
responses = c( (1 - sign(diff(doses)))/2, 0 )


### Let us plot the dose-allocation time series.

# Saving current settings as now required by the CRAN powers-that-be :0
op &lt;- par(no.readonly = TRUE)

par(mar=c(4,4,4,1), mgp=c(2.5,0.8,0), cex.axis = 0.7, las = 1)
udplot(doses, responses, main='Van Elstraete et al. 2008 Study', 
       xtitle = "Patient Number", ytitle = 'Gabapentin (mg/kg)') 


#' Overlay the ED50 reported in the article (21.7 mg/kg):
abline(h = 21.7)

#' The authors cite a little-known 1991 article by Dixon as the method source.
#' However, in their author rejoinder they claim to have used the Dixon-Mood (1948) estimate.


# Our package does include the Dixon-Mood point estimate.
#  (w/o the CIs, because we do not endorse this estimation approach)
# Does it reproduce the article estimate?
dixonmood(x = doses, y = responses)

# Not at all! Let us overlay this one in red
abline(h = dixonmood(x = doses, y = responses), col=2)

# We have found that many articles claiming to use Dixon-Mood (or Dixon-Massey) actually
# Do something else. For example, in this article they report that 
#   "it is necessary to reject sequences with three to six identical results".
# Nothing like this appears in the original Dixon-Mood article, where the estimation method
#   involves identifying the less-common response (either 0 or 1), and using only x values
#   associated with these responses; obviating the need to exclude specific sequences.
#
# More generally, these historical estimates have long passed their expiry dates. 
#   Their foundation is not nearly as solid as, e.g., linear regression, 
#      and it's time to stop using them.

# That said, our package does offer two more types of dose-averaging estimates.
# Both are able to take advantage of the "n+1" dose-allocation, which is determined by
#    the last dose and response:
n = length(doses)
dosePlus1 = doses[n] + ifelse(responses[n]==0, 1, -1)
reversmean(c(doses, dosePlus1), responses, conf = NULL)
# Interestingly, in this particular case the answer is very similar to the Dixon-Mood estimate.

# The `reversmean()` default averages all doses from the 3rd reversal point onwards.
# By the way, at what point did the third reversal happen? 
#     It'll be the 3rd number in this vector:
reversals(x = doses, y = responses)

# Far more commonly in literature, particularly in sensory studies, 
#   one encounters the 1960s-era approach (led by Wetherill) of taking *only doses  
#   at reversal points, usually starting from the first one. `reversmean()` can do that too:
wetherill = reversmean(c(doses, dosePlus1), responses, all = FALSE, rstart = 1, conf = NULL)
wetherill
# This one gives an even lower result than the previous ones.
abline(h = wetherill, col = 3)

# There's another approach to dose-averaging, although it is not in use anywhere that we know of.
# It does not require the y values at all. The underlying assumption is that the dose 
#   sequence has done enough meandering around the true balance point, to provide information
#   about where (approximately) the starting-dose effect is neutralized.
# This function now also provides bootstrap CIs, so we need to give it the y values. 
# The default forces the final 2/3 of observations to be included; here in view of the long run-in
#     we are relaxing this
dynamean(c(doses, dosePlus1), responses, maxExclude = 0.5, conf = NULL)
# Again a bit curiously, this relatively recent approach gives a result similar to what
#   the authors reported (but not similar to the original Dixon-Mood).
# This is not too surprising, since here `dynamean()` excludes the first one-third of doses,
#   which is approximately what happened if indeed the authors excluded all those long dose-increase
#   sequences at the start.

# All this shows how dicey dose-averaging, at face value a simple and effective method, can become.
# The sample size here is rather large for up-and-down studies, and yet because of the unlucky
#    choice of starting point (which in many studies, due to safety concerns cannot be evaded)
#    there is really no good option of which observations to exclude.

# This is one reason why we strongly recommend using Centered Isotonic Regression as default. 
# Figure soon to follow.
# But first, have you noted how we keep specifying "conf = NULL"? 
# This is because now at default, these averages calculate
# A bootstrap confidence-interval. 
# These intervals are generally deficient but are the best anyone can do at present.

# If you want to use a confidence interval, you must provide the experiment's target, 
#    or more precisely its balance point, as well as the parameters to use in 
# the bootstrap simulation (which should be the ones generating the original experiment).

# Like this (not run, to avoid violating CRAN's very narrow limits on example runtime):
# dynamean(c(doses, dosePlus1), responses, maxExclude = 0.5, target = 0.5, 
#                  design = krow, desArgs = list(k=1) )


defest = udest(doses, responses, target = 0.5)
abline(h = defest$point, col = 'purple')
# For this dataset, it is the highest of all the estimates.

legend('bottomright', col = c(1:3, 'purple'), 
       legend = c("Article's estimate", 'Dixon-Mood', 'Reversals (Wetherill)', 'Standard (CIR)'), 
       lty = 1, bty='n', cex = 0.8)


par(op) # Back to business as usual ;)
</code></pre>

<hr>
<h2 id='drplot'>Visualizing the dose-response summary of an up-and-down experiment</h2><span id='topic+drplot'></span>

<h3>Description</h3>

<p>Dose-response plotting function for up-and-down data, with doses/stimuli on the x-axis, and the proportion of positive responses on the y-axis. Includes an option to plot the target-dose estimate. Uses utilities from the <code>cir</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drplot(
  x,
  y,
  shape = "X",
  connect = FALSE,
  symbcol = 1,
  percents = FALSE,
  addest = FALSE,
  addcurve = FALSE,
  target = NULL,
  balancePt = target,
  conf = 0.9,
  estcol = "purple",
  estsize = 2,
  estsymb = 19,
  esthick = 2,
  curvecol = "blue",
  allow1extra = FALSE,
  ytitle = "Frequency of Positive Response",
  xtitle = "Dose / Stimulus",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drplot_+3A_x">x</code></td>
<td>
<p>numeric vector: sequence of administered doses, treatments, stimuli, etc.</p>
</td></tr>
<tr><td><code id="drplot_+3A_y">y</code></td>
<td>
<p>numeric vector: sequence of observed responses. Must be same length as <code>x</code>, and must be coded <code>TRUE/FALSE</code> or 0/1.</p>
</td></tr>
<tr><td><code id="drplot_+3A_shape">shape</code></td>
<td>
<p>the plotting shape (DRtrace only): <code>'circle'</code> (default), <code>'square'</code>, or <code>'triangle'</code>.</p>
</td></tr>
<tr><td><code id="drplot_+3A_connect">connect</code></td>
<td>
<p>logical: whether to connect the symbols (generic plotting type <code>'b'</code>). Default <code>TRUE</code> for <code>udplot()</code> and <code>FALSE</code> for <code>drplot()</code>.</p>
</td></tr>
<tr><td><code id="drplot_+3A_symbcol">symbcol</code></td>
<td>
<p>The color of the main plotting symbols and connecting lines. Default 1 (the current palette's first color). Note: if you change the color and inadvertently use <code>col</code> instead, there might be an error message.</p>
</td></tr>
<tr><td><code id="drplot_+3A_percents">percents</code></td>
<td>
<p>logical, whether to represent the y-axis as percents rather than a fraction.</p>
</td></tr>
<tr><td><code id="drplot_+3A_addest">addest</code></td>
<td>
<p>logical: should we add the CIR target-dose estimate and its confidence interval? If <code>FALSE</code> (default), then arguments <code style="white-space: pre;">&#8288;addcurve, target, balancePt, conf, estcol, estsize, estsymb, esthick, curvecol&#8288;</code> - are all ignored.</p>
</td></tr>
<tr><td><code id="drplot_+3A_addcurve">addcurve</code></td>
<td>
<p>logical: should we add the complete estimated CIR dose-response curve? Default <code>FALSE</code>, and only relevant when <code>addest = TRUE</code>.</p>
</td></tr>
<tr><td><code id="drplot_+3A_target">target</code></td>
<td>
<p>The target response rate for which target dose estimate is requested. Must be a single number in <code class="reqn">(0,1).</code></p>
</td></tr>
<tr><td><code id="drplot_+3A_balancept">balancePt</code></td>
<td>
<p>In case the design's inherent balance point differs somewhat from <code>target</code>, specify it here to improve estimation accuracy. See Details for further explanation. Otherwise, this argument defaults to be equal to <code>target</code>.</p>
</td></tr>
<tr><td><code id="drplot_+3A_conf">conf</code></td>
<td>
<p>The desired confidence level for the confidence interval. Default <code class="reqn">90\%.</code> We do not recommend increasing to <code class="reqn">95\%</code> unless you have <code class="reqn">\sim 100</code> or more observations. Setting to <code>NULL</code> triggers special behavior; see under &quot;Value&quot;.</p>
</td></tr>
<tr><td><code id="drplot_+3A_estcol">estcol</code>, <code id="drplot_+3A_estsize">estsize</code>, <code id="drplot_+3A_estsymb">estsymb</code>, <code id="drplot_+3A_esthick">esthick</code>, <code id="drplot_+3A_curvecol">curvecol</code></td>
<td>
<p>graphical parameters controlling the colors, symbol choice, size, thickness, of the target-dose and CIR-curve visuals.</p>
</td></tr>
<tr><td><code id="drplot_+3A_allow1extra">allow1extra</code></td>
<td>
<p>logical: allow <code>length(x)</code> to be either equal or 1 greater than <code>length(y)</code>? (default <code>FALSE</code>) The <em>&quot;n+1&quot;</em> dose-allocation, determined from the last allocations and responses, might be tagged onto <code>x</code>. If this point is provided and <code>allow1extra=TRUE</code>, <code>udplot()</code> will show it as a grey diamond; the other functions will ignore it.</p>
</td></tr>
<tr><td><code id="drplot_+3A_xtitle">xtitle</code>, <code id="drplot_+3A_ytitle">ytitle</code></td>
<td>
<p>x-axis and y-axis titles. Some reasonable defaults are provided, to avoid an annoying error message.</p>
</td></tr>
<tr><td><code id="drplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="graphics.html#topic+plot">plot</a></code> (e.g., <code>main</code> for the main title).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After an up-and-down experiment, it is highly recommended to plot not just the experiment's <em>&quot;trace&quot;</em>  time-series (<code><a href="#topic+udplot">udplot</a></code>), but also the dose-response summaries. This utility provides a convenient interface for doing that.
</p>

<ul>
<li><p> It summarizes the response rates at each participating dose, and plots them. At default, symbol area is proportional to the number of observations at each dose.
</p>
</li>
<li><p> Optionally, the centered-isotonic-regression (CIR) target-dose estimate and its confidence interval are also calculated and plotted.
</p>
</li>
<li><p> A further option allows for plotting the entire estimated CIR dose-response curve.
</p>
</li></ul>

<p><code>drplot()</code> is a convenience wrapper to <code>cir::plot.doseResponse</code>, with the added option of plotting the estimate. Some specific options, such as disabling the proportional-area symbol plotting, are accessible only via <code>plot.doseResponse</code> arguments (specified in your <code>drplot()</code> call and passed through the <code>...</code>).
</p>
<p>This is a base-R plot, so you can use additional options, including preceding the plot command with <code><a href="graphics.html#topic+par">par</a></code> statements, or following up with <code><a href="graphics.html#topic+legend">legend</a></code>. When wishing to save to a file, I recommend utilities such as <code>png()</code> or <code>pdf()</code>.
</p>


<h3>Value</h3>

<p>Returns invisibly after plotting. If you would like to save the plot to a file, embed the plotting code in a standard R graphics export code sequence, (e.g., <code>pdf(...)</code> before the plotting function, and <code>dev.off()</code> after it).
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>


<ul>
<li><p> Oron AP, Souter MJ, Flournoy N. Understanding Research Methods: Up-and-down Designs for Dose-finding. <em>Anesthesiology</em> 2022; 137:137–50.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="cir.html#topic+plot.doseResponse">plot.doseResponse</a></code>, <code>cir</code> package.
</p>
</li>
<li> <p><code><a href="#topic+udplot">udplot</a></code> for the &quot;trace&quot; time-series plot.
</p>
</li>
<li> <p><code>cir</code> package vignette.
</p>
</li></ul>


<hr>
<h2 id='dynamean'>Up-and-Down target-dose averaging estimate, with dynamic cutoff-point</h2><span id='topic+dynamean'></span>

<h3>Description</h3>

<p>A dose-averaging estimate based on a concept from Oron (2007). Provides a more robust alternative to reversal-based averaging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynamean(
  x,
  y = NULL,
  maxExclude = 1/2,
  before = FALSE,
  full = FALSE,
  conf = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynamean_+3A_x">x</code></td>
<td>
<p>numeric vector: sequence of administered doses, treatments, stimuli, etc.</p>
</td></tr>
<tr><td><code id="dynamean_+3A_y">y</code></td>
<td>
<p>numeric vector: sequence of observed responses. Must be same length as <code>x</code> or shorter by 1, and must be coded <code>TRUE/FALSE</code> or 0/1. <code>dynamean()</code> only uses <code>y</code> for bootstrap confidence intervals.</p>
</td></tr>
<tr><td><code id="dynamean_+3A_maxexclude">maxExclude</code></td>
<td>
<p>a fraction in <code class="reqn">0,1</code> indicating the maximum initial fraction of the vector <code>x</code> to exclude from averaging, in case the algorithm-identified transition point occurs late in the experiment. Default 1/2.</p>
</td></tr>
<tr><td><code id="dynamean_+3A_before">before</code></td>
<td>
<p>logical: whether to start the averaging one observation earlier than the cutoff point. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dynamean_+3A_full">full</code></td>
<td>
<p>logical: should more detailed information be returned, or only the estimate? (default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="dynamean_+3A_conf">conf</code></td>
<td>
<p>the CI's confidence level, as a fraction in (0,1). To skip CI calculation set <code>conf = NULL</code>.</p>
</td></tr>
<tr><td><code id="dynamean_+3A_...">...</code></td>
<td>
<p>Additional parameters, mostly ones passed on to <code>dfboot</code> if <code>conf</code> is not <code>NULL</code>. See that function's help for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Historically, most up-and-down studies have used dose-averaging estimates. Many of them focus on reversal points either as anchor/cutoff points &ndash; points where the averaging begins &ndash; or as the <strong>only</strong> doses to use in the estimate.  Excluding doses before the anchor/cutoff is done in order to mitigate the bias due to the arbitrary location of the starting dose. The extent of excluded sample depends on the distance between the starting dose and the
up-and-down balance point, as well as the random-walk vagaries of an individual experimental run.
</p>
<p>Oron (2007) showed that using only reversals and skipping other doses is generally a bad idea, and also noted that a reversal anchor point is not directly tied to the conceptual motivation for having an anchor/cutoff point.
</p>
<p>In practice, some <em>&quot;lucky&quot;</em> experiments might not need any exclusion at all (because they started right at the balance point), while others might need to exclude dozens of observations. Reversals do not capture this variability well.
</p>
<p>The estimation method coded in <code>dynamean()</code> works from a different principle. It identifies <strong>the first crossing point:</strong> the first point at which
the dose is <em>&quot;on the other side&quot;</em> from the starting point, compared with the average of all remaining doses.
The average of all remaining doses is used as a proxy to the (unobservable) balance point.
This approach is far closer to capturing the dynamics described above, and indeed performs well
in comparative simulations (Oron et al. 2022, Supplement).
</p>
<p>Starting version 0.2.0, a bootstrap confidence interval (CI) is also provided. See <code><a href="#topic+dfboot">dfboot</a></code>, <code><a href="#topic+dfsim">dfsim</a></code> for additional parameters to pass to the bootstrap routine via <code>...</code>, beyond the confidence level <code>conf</code>. For the &quot;Classical&quot; median-finding UDD, use <code style="white-space: pre;">&#8288;design = krow, desArgs = list(k=1)&#8288;</code>. To skip CI estimation, set <code>conf = NULL</code>.
The experiment's binary responses (<code>y</code>) are only needed as input for confidence interval calculations; otherwise, only the dose-allocation sequence (<code>x</code>) is required.
</p>
<p><code>dynamean()</code> is recommended only for median-targeting UDDs, e.g., the &quot;Classical&quot; (traditional) design of Dixon and Mood. For off-median percentiles it might not work as well, and CI coverage will be lacking.
</p>
<p>For such targets we recommend using centered isotonic regression, a more robust method available
together with a confidence interval via <code><a href="#topic+udest">udest</a></code>, an up-and-down adapted wrapper to <code>cir::quickInverse()</code>.
See Oron et al. 2022 (both article and supplement) for further information, as well as the <code>cir</code> package vignette.
</p>


<h3>Value</h3>

<p>If <code>full=FALSE</code> returns the point estimate. Otherwise returns a list with the index of the cutoff point used to start the averaging, and a 2-row matrix with full sequence of estimates and the tail vs. starting point indicator signs.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>


<ul>
<li><p> Oron AP. <a href="https://arxiv.org/abs/0808.3004"><em>Up-and-Down and the Percentile-finding Problem.</em></a> Ph.D. Dissertation, University of Washington, 2007.
</p>
</li>
<li><p> Oron AP, Souter MJ, Flournoy N. Understanding Research Methods: Up-and-down Designs for Dose-finding. <em>Anesthesiology</em> 2022; 137:137–50. <a href="https://cdn-links.lww.com/permalink/aln/c/aln_2022_05_25_oron_aln-d-21-01101_sdc1.pdf">See in particular the open-access Supplement.</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+udest">udest</a></code>, the recommended estimation method for up-and-down targets.
</p>
</li>
<li> <p><code><a href="#topic+reversmean">reversmean</a></code> for the commonly-used reversal-anchored averages mentioned in Details.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#'  **An up-and-down experiment that has generated some controversy**
#'  
#' Van Elstraete, AC et al. The Median Effective Dose of Preemptive Gabapentin 
#'      on Postoperative Morphine Consumption After Posterior Lumbar Spinal Fusion. 
#'      *Anesthesia &amp; Analgesia* 2008, 106: 305-308.


# It was a classical median-finding up-and-down study.

doses = c(4:7, 6:13, 12:19, 18:21, 20, 19:23, 22, 21:23, 22:19, 20:23, 
          22:24, 23, 22, 23, 22:25, 24:22, rep(23:24,2), 23, 22)
# With U&amp;D, responses (except the last one) can be read off the doses:
responses = c( (1 - sign(diff(doses)))/2, 0 )


### Let us plot the dose-allocation time series.

# Saving current settings as now required by the CRAN powers-that-be :0
op &lt;- par(no.readonly = TRUE)

par(mar=c(4,4,4,1), mgp=c(2.5,0.8,0), cex.axis = 0.7, las = 1)
udplot(doses, responses, main='Van Elstraete et al. 2008 Study', 
       xtitle = "Patient Number", ytitle = 'Gabapentin (mg/kg)') 


#' Overlay the ED50 reported in the article (21.7 mg/kg):
abline(h = 21.7)

#' The authors cite a little-known 1991 article by Dixon as the method source.
#' However, in their author rejoinder they claim to have used the Dixon-Mood (1948) estimate.


# Our package does include the Dixon-Mood point estimate.
#  (w/o the CIs, because we do not endorse this estimation approach)
# Does it reproduce the article estimate?
dixonmood(x = doses, y = responses)

# Not at all! Let us overlay this one in red
abline(h = dixonmood(x = doses, y = responses), col=2)

# We have found that many articles claiming to use Dixon-Mood (or Dixon-Massey) actually
# Do something else. For example, in this article they report that 
#   "it is necessary to reject sequences with three to six identical results".
# Nothing like this appears in the original Dixon-Mood article, where the estimation method
#   involves identifying the less-common response (either 0 or 1), and using only x values
#   associated with these responses; obviating the need to exclude specific sequences.
#
# More generally, these historical estimates have long passed their expiry dates. 
#   Their foundation is not nearly as solid as, e.g., linear regression, 
#      and it's time to stop using them.

# That said, our package does offer two more types of dose-averaging estimates.
# Both are able to take advantage of the "n+1" dose-allocation, which is determined by
#    the last dose and response:
n = length(doses)
dosePlus1 = doses[n] + ifelse(responses[n]==0, 1, -1)
reversmean(c(doses, dosePlus1), responses, conf = NULL)
# Interestingly, in this particular case the answer is very similar to the Dixon-Mood estimate.

# The `reversmean()` default averages all doses from the 3rd reversal point onwards.
# By the way, at what point did the third reversal happen? 
#     It'll be the 3rd number in this vector:
reversals(x = doses, y = responses)

# Far more commonly in literature, particularly in sensory studies, 
#   one encounters the 1960s-era approach (led by Wetherill) of taking *only doses  
#   at reversal points, usually starting from the first one. `reversmean()` can do that too:
wetherill = reversmean(c(doses, dosePlus1), responses, all = FALSE, rstart = 1, conf = NULL)
wetherill
# This one gives an even lower result than the previous ones.
abline(h = wetherill, col = 3)

# There's another approach to dose-averaging, although it is not in use anywhere that we know of.
# It does not require the y values at all. The underlying assumption is that the dose 
#   sequence has done enough meandering around the true balance point, to provide information
#   about where (approximately) the starting-dose effect is neutralized.
# This function now also provides bootstrap CIs, so we need to give it the y values. 
# The default forces the final 2/3 of observations to be included; here in view of the long run-in
#     we are relaxing this
dynamean(c(doses, dosePlus1), responses, maxExclude = 0.5, conf = NULL)
# Again a bit curiously, this relatively recent approach gives a result similar to what
#   the authors reported (but not similar to the original Dixon-Mood).
# This is not too surprising, since here `dynamean()` excludes the first one-third of doses,
#   which is approximately what happened if indeed the authors excluded all those long dose-increase
#   sequences at the start.

# All this shows how dicey dose-averaging, at face value a simple and effective method, can become.
# The sample size here is rather large for up-and-down studies, and yet because of the unlucky
#    choice of starting point (which in many studies, due to safety concerns cannot be evaded)
#    there is really no good option of which observations to exclude.

# This is one reason why we strongly recommend using Centered Isotonic Regression as default. 
# Figure soon to follow.
# But first, have you noted how we keep specifying "conf = NULL"? 
# This is because now at default, these averages calculate
# A bootstrap confidence-interval. 
# These intervals are generally deficient but are the best anyone can do at present.

# If you want to use a confidence interval, you must provide the experiment's target, 
#    or more precisely its balance point, as well as the parameters to use in 
# the bootstrap simulation (which should be the ones generating the original experiment).

# Like this (not run, to avoid violating CRAN's very narrow limits on example runtime):
# dynamean(c(doses, dosePlus1), responses, maxExclude = 0.5, target = 0.5, 
#                  design = krow, desArgs = list(k=1) )


defest = udest(doses, responses, target = 0.5)
abline(h = defest$point, col = 'purple')
# For this dataset, it is the highest of all the estimates.

legend('bottomright', col = c(1:3, 'purple'), 
       legend = c("Article's estimate", 'Dixon-Mood', 'Reversals (Wetherill)', 'Standard (CIR)'), 
       lty = 1, bty='n', cex = 0.8)


par(op) # Back to business as usual ;)
</code></pre>

<hr>
<h2 id='k2targ'>Up-and-Down Target Calculation and Design Guidance</h2><span id='topic+k2targ'></span><span id='topic+ktargOptions'></span><span id='topic+g2targ'></span><span id='topic+gtargOptions'></span><span id='topic+bcoin'></span>

<h3>Description</h3>

<p>Up-and-down target calculation, as well as design options/guidance given a user-desired target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k2targ(k, lowTarget = FALSE)

ktargOptions(target, tolerance = 0.1, maxk = 20)

g2targ(cohort, lower, upper)

gtargOptions(target, minsize = 2, maxsize = 6, tolerance = 0.1)

bcoin(target, fraction = FALSE, nameplate = FALSE, tolerance = 0.02)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="k2targ_+3A_k">k</code></td>
<td>
<p>the number of consecutive identical responses required for dose transitions (k-in-a-row functions only).</p>
</td></tr>
<tr><td><code id="k2targ_+3A_lowtarget">lowTarget</code></td>
<td>
<p>logical, <code>k2targ()</code> only: is the design targeting below-median percentiles, with <code class="reqn">k</code> repeated negative responses needed to level up and only one to level down - or vice versa? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="k2targ_+3A_target">target</code></td>
<td>
<p>the desired target response rate (as a fraction in <code class="reqn">(0,1)</code>), where relevant.</p>
</td></tr>
<tr><td><code id="k2targ_+3A_tolerance">tolerance</code></td>
<td>

<ul>
<li><p> For <code style="white-space: pre;">&#8288;ktargOptions(), gtargOptions()&#8288;</code>: the half-width of the interval around <code>target</code> in which to search for design options. Default 0.1.
</p>
</li>
<li><p> For <code>bcoin()</code>: the half-width of the interval around 0.5 in which the function recommends to simply use classical UD without a coin, as well as the approximate amount of rounding to the returned coin probability (whether in decimal on rational terms). Default 0.02, and hard-coded to be no less than 0.0001.
</p>
</li></ul>
</td></tr>
<tr><td><code id="k2targ_+3A_maxk">maxk</code></td>
<td>
<p><code>ktargOptions()</code> only: the maximum value of <code class="reqn">k</code> to consider.</p>
</td></tr>
<tr><td><code id="k2targ_+3A_cohort">cohort</code>, <code id="k2targ_+3A_lower">lower</code>, <code id="k2targ_+3A_upper">upper</code></td>
<td>
<p><code>g2targ()</code> only: the cohort (group) size, how many positive responses are allowed for a move upward, and how many are required for a move downward, respectively. For example <code style="white-space: pre;">&#8288;cohort=3, lower=0, upper=2&#8288;</code> evaluates groups of 3 observations at a time, moves up if none are positive, down if <code class="reqn">&gt;=2</code> are positive, and repeats the same dose with 1 positive.</p>
</td></tr>
<tr><td><code id="k2targ_+3A_minsize">minsize</code>, <code id="k2targ_+3A_maxsize">maxsize</code></td>
<td>
<p><code>gtargOptions()</code> only: the minimum and maximum cohort size to consider. <code>minsize</code> has to be at least 2 (cohort size 1 is equivalent to classical UD).</p>
</td></tr>
<tr><td><code id="k2targ_+3A_fraction">fraction</code></td>
<td>
<p><code>bcoin()</code> only: whether to report the coin probability as a rational rather than decimal fraction. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="k2targ_+3A_nameplate">nameplate</code></td>
<td>
<p><code>bcoin()</code> only: in case <code>fraction = TRUE</code>, whether to return the &quot;exact&quot; rational probability, or allow some nudging of the resulting balance point towards the median. Default <code>FALSE</code>, and moot when <code>fraction = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This suite of utilities helps users
</p>

<ul>
<li><p> Figure out the approximate target response-rate (a.k.a. the <em>balance point</em>), given design parameters;
</p>
</li>
<li><p> Suggest potential design parameters, given user's desired target response-rate and other constraints.
</p>
</li></ul>

<p>Up-and-down designs (UDDs) generate random walks over dose space, with most dose-allocations usually taking place near the design's de-facto target percentile, called the <strong>&quot;balance point&quot;</strong> by some theorists to distinguish it from the user-designated target in case they differ (Oron and Hoff 2009, Oron et al. 2022).
</p>
<p>Most k-in-a-row and group UDD parameter combinations yield balance points that are irrational percentiles of the dose-response function, and therefore are unappealing as official experimental targets.
</p>
<p>However, since the UD dose distribution has some width, and since even the balance point itself is only a close approximation for the actual average of allocated doses, the user's target <strong>does not have to be identical to the balance point.</strong> It only needs to be <em>&quot;close enough&quot;</em>.
</p>
<p>The <code>k2targ()</code> and <code>g2targ()</code> utilities are intended for users who already have a specific k-in-a-row or group design in mind, and only want to verify its balance point. The complementary utilities <code style="white-space: pre;">&#8288;ktargOptions(), gtargOptions()&#8288;</code> provide a broader survey of design-parameter options within user-specified constraints, given a desired target.
</p>
<p>Lastly, <code>bcoin()</code> returns the biased-coin probabilities given the user's designated target. In contrast to the two other UDDs described above, the biased-coin design can target any percentile with a precisely matched balance point. That said, k-in-a-row and group UDDs offer some advantages over biased-coin in terms of properties and operational simplicity.
</p>
<p><code>bcoin()</code> can return the probability as a decimal (default) or approximate rational fraction. In the latter case, if <code>nameplate</code> is set to <code>TRUE</code>, you will get the exact <em>&quot;nameplate&quot;</em> coin probability <code class="reqn">\Gamma/(1 - \Gamma)</code>, with <code class="reqn">\Gamma</code> being the target percentile between 0 and 1. However, the default <code>nameplate = FALSE</code> might nudge the coin to yield a balance point somewhat closer to the median. This choice is based upon the theoretical finding that the biased-coin design does tend to concentrate doses a bit further away from the median than the balance point would suggest (Oron and Hoff, 2009). See more information in <code>bcoin()</code>'s argument descriptions.
</p>


<h3>Value</h3>


<ul>
<li> <p><code style="white-space: pre;">&#8288;k2targ(), g2targ()&#8288;</code>: the official balance point given the user-provided design parameters.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;ktargOptions(), gtargOptions()&#8288;</code>: a <code>data.frame</code> with design parameters and official balance point, for all options that meet user-provided constraints. A printed string provides dose transition rule guidance.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;bcoin():&#8288;</code> a printed string that informs user of the biased-coin design rules, including the 'coin' probability in its user-chosen format (decimal or fraction). In case the user-desired target is 0.5 or very close to it, the string will inform user that they are better off just using classical UDD without a coin.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>


<ul>
<li><p> Durham SD, Flournoy N. Random walks for quantile estimation. In: <em>Statistical Decision Theory and Related Topics V</em> (West Lafayette, IN, 1992). Springer; 1994:467-476.
</p>
</li>
<li><p> Gezmu M, Flournoy N. Group up-and-down designs for dose-finding. <em>J Stat Plan Inference.</em> 2006;136(6):1749-1764.
</p>
</li>
<li><p> Oron AP, Hoff PD. The k-in-a-row up-and-down design, revisited. <em>Stat Med.</em> 2009;28:1805-1820.
</p>
</li>
<li><p> Oron AP, Souter MJ, Flournoy N. Understanding Research Methods: Up-and-down Designs for Dose-finding. <em>Anesthesiology</em> 2022; 137:137–50.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bcdmat">bcdmat</a></code> for the functions calculating transition probability matrices for various up-and-down designs.
</p>
</li>
<li> <p><code><a href="#topic+pivec">pivec</a></code> for functions calculating key probability vectors for the designs.
</p>
</li></ul>


<hr>
<h2 id='krow'>Up-and-Down Design Rules for use in Dose-Finding Simulator</h2><span id='topic+krow'></span><span id='topic+bcd'></span><span id='topic+groupUD'></span>

<h3>Description</h3>

<p>Rules for k-in-a-row, Biased-Coin UD, and Group UD, coded as functions compatible with
the generic dose-finding simulator <code>dfsim()</code>
</p>
<p>These functions work on each virtual experimental run individually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krow(doses, responses, k, lowTarget = NULL, fastStart = FALSE, ...)

bcd(doses, responses, coin, lowTarget, fastStart = FALSE, ...)

groupUD(doses, responses, s, ll, ul, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="krow_+3A_doses">doses</code>, <code id="krow_+3A_responses">responses</code></td>
<td>
<p>(mandatory arguments) vectors of the run's current sequence of doses (in ordinal/index scale) and responses</p>
</td></tr>
<tr><td><code id="krow_+3A_k">k</code></td>
<td>
<p>the number of consecutive identical responses required for dose transitions (k-in-a-row functions only).</p>
</td></tr>
<tr><td><code id="krow_+3A_lowtarget">lowTarget</code></td>
<td>
<p>(<code>krow</code> and <code>bcd</code>) logical: is the target below 0.5 (median threshold)?</p>
</td></tr>
<tr><td><code id="krow_+3A_faststart">fastStart</code></td>
<td>
<p>(<code>krow</code> and <code>bcd</code>) logical: should the experiment begin with a classical-UD-like stage until the first &quot;minority&quot; response is observed (i.e., a 1 for below-median targets and vice versa)? Even though <code>TRUE</code> delivers better experimental performance and is recommended when allowed, default is <code>FALSE</code> because toxicity/safety studies are unlikely to allow it.</p>
</td></tr>
<tr><td><code id="krow_+3A_...">...</code></td>
<td>
<p>Technical pass-through argument, to allow for flexibility when constructing design-comparison simulation ensembles.</p>
</td></tr>
<tr><td><code id="krow_+3A_coin">coin</code></td>
<td>
<p>(<code>bcd</code> only) the biased-coin probability. Note that unlike <code>bcdmat()</code>, here the function does not figure out automatically the coin probability and upper/lower target location from the provided target.</p>
</td></tr>
<tr><td><code id="krow_+3A_s">s</code></td>
<td>
<p>(<code>groupUD</code> only) the group/cohort size, analogous to <code>cohort</code> in <code>gudmat()</code>. We use a different name here because <code>cohort</code> is already used in <code>dfsim</code> that calls these utilities.</p>
</td></tr>
<tr><td><code id="krow_+3A_ll">ll</code>, <code id="krow_+3A_ul">ul</code></td>
<td>
<p>(<code>groupUD</code> only) how many positive responses are allowed for a move upward, and how many are required for a move downward, respectively. Analogous to <code style="white-space: pre;">&#8288;lower, upper&#8288;</code> in <code>gudmat()</code>. For example <code style="white-space: pre;">&#8288;s=3, ll=0, ul=2&#8288;</code> evaluates groups of 3 observations at a time, moves up if none are positive, down if <code class="reqn">&gt;=2</code> are positive, and repeats the same dose with 1 positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rules for some popular or well-studied non-up-and-down
</p>


<h3>Value</h3>

<p>the next dose allocation
</p>

<hr>
<h2 id='pivec'>Key Probability Vectors of Up-and-Down Designs</h2><span id='topic+pivec'></span><span id='topic+currentvec'></span><span id='topic+cumulvec'></span>

<h3>Description</h3>

<p>Dose-allocation probability vectors that quantify the instantaneous, cumulative, and asymptotic behavior of Up-and-Down designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivec(cdf, matfun, ...)

currentvec(cdf, matfun, n, startdose = NULL, marginalize = TRUE, ...)

cumulvec(
  cdf,
  matfun,
  n,
  startdose = NULL,
  proportions = TRUE,
  exclude = 0,
  marginalize = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivec_+3A_cdf">cdf</code></td>
<td>
<p>monotone increasing vector with positive-response probabilities. The number of dose levels <code class="reqn">M</code> is deduced from vector's length.</p>
</td></tr>
<tr><td><code id="pivec_+3A_matfun">matfun</code></td>
<td>
<p>The function to calculate the TPM. Depends on the specific design; see <code><a href="#topic+bcdmat">bcdmat</a></code>. For all functions except <code>classicmat</code>, user must provide auxiliary parameters via <code>...</code>. For the k-in-a-row design, use <code>kmatMarg</code> for <code>pivec()</code> and <code>kmatFull</code> otherwise.</p>
</td></tr>
<tr><td><code id="pivec_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the design's matrix-calculating function.</p>
</td></tr>
<tr><td><code id="pivec_+3A_n">n</code></td>
<td>
<p>For <code style="white-space: pre;">&#8288;currentvec, cumulvec&#8288;</code>, at what step (= after how many observations) in the experiment would you like the vector calculated?</p>
</td></tr>
<tr><td><code id="pivec_+3A_startdose">startdose</code></td>
<td>
<p>(for <code style="white-space: pre;">&#8288;currentvec, cumulvec&#8288;</code>), where does the experiment start? To be given as a dose-level index between 1 and <code class="reqn">M</code>. If left as <code>NULL</code> (default), function will assume the equivalent of <em>&quot;fair die roll&quot;</em> among all doses. User can also specify your own <code class="reqn">M</code>-length probability vector.</p>
</td></tr>
<tr><td><code id="pivec_+3A_marginalize">marginalize</code></td>
<td>
<p>logical (for <code style="white-space: pre;">&#8288;currentvec, cumulvec&#8288;</code> when <code>matfun = kmatFull</code>) should the returned vector be marginalized over dose levels (<code>TRUE</code>, default), or should the full set with internal states be returned?</p>
</td></tr>
<tr><td><code id="pivec_+3A_proportions">proportions</code></td>
<td>
<p>Logical (<code>cumulvec</code> only) Would you like the results returned as proportions (= a probability vector; <code>TRUE</code>, default), or as cumulative allocation counts?</p>
</td></tr>
<tr><td><code id="pivec_+3A_exclude">exclude</code></td>
<td>
<p>Integer (<code>cumulvec</code> only) Should the cumulative distribution exclude a certain number of initial observations? Default 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Up-and-Down designs (UDDs) generate random walk behavior, which concentrates doses around the target quantile. Asymptotically, dose allocations follow a stationary distribution <code class="reqn">\boldsymbol{\pi}</code> which can be calculated given the number of doses <code class="reqn">M</code>, and the value of the cdf <code class="reqn">F</code> at each dose (i.e., the positive-response probabilities), and the specific UDD rules. No matter the starting dose, the allocation distribution converges to <code class="reqn">\boldsymbol{\pi}</code> at a geometric rate (Diaconis and Stroock, 1991).
</p>
<p>Three functions are offered:
</p>

<ul>
<li> <p><code>pivec()</code> returns <code class="reqn">\boldsymbol{\pi}</code>.
</p>
</li>
<li> <p><code>currentvec()</code> returns the current (instantaneous) allocation distribution at step <code>n</code>, using the formula from Diaconis and Stroock (1991).
</p>
</li>
<li> <p><code>cumulvec()</code> returns the <em>cumulative</em> allocations, i.e., the expected proportions (or counts) of allocations during the experiment after <code>n</code> observations. This function is perhaps of greatest practical use.
</p>
</li></ul>

<p>All functions first calculate the transition probability matrix (TPM), by calling one of the functions described under <code><a href="#topic+bcdmat">bcdmat</a></code>. See that help page for more details.
</p>


<h3>Value</h3>

<p>A vector of allocation frequencies/probabilities for the doses, summing up to 1. Exception: <code>cumulvec(propotions = FALSE)</code> returns a vector of expected allocation counts, summing up to <code>n - exclude</code>.
</p>


<h3>Note</h3>

<p>When using the k-in-a-row design, set <code>matfun = kmatMarg</code> if using <code>pivec</code>, and otherwise <code>kmatFull</code>.
</p>
<p>At present, these functions are unable to incorporate in the calculations the impact of the recommended &quot;fast start&quot; stage for k-in-a-row and biased-coin designs. Such a stage begins with a classic UD run, until the first &quot;minority&quot; outcome is encountered (1 for below-median targets and vice versa). Generally such a fast start would make small-sample probability vectors approach the asymptotic distribution more quickly.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>


<ul>
<li><p> Diaconis P, Stroock D. Geometric Bounds for Eigenvalues of Markov Chains. <em>Ann. Appl. Probab.</em> 1991;1(1):36-61.
</p>
</li>
<li><p> Hughes BD. <em>Random Walks and Random Environments, Vol. 1.</em> Oxford University Press, 1995.
</p>
</li>
<li><p> Oron AP, Souter MJ, Flournoy N. Understanding Research Methods: Up-and-down Designs for Dose-finding. <em>Anesthesiology</em> 2022; 137:137–50.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bcdmat">bcdmat</a></code> for the functions calculating transition probability matrices for various up-and-down designs.
</p>
</li>
<li> <p><code><a href="#topic+k2targ">k2targ</a></code> for target-finding design aids.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#----- Classical UD Example -----#

# An example used in Oron et al. 2022, Fig. 2.
# It is presented here via the original motivating story:
# "Ketofol"  is a commonly-used anesthesia-inducing mix known to combine its 2 components' 
# beneficial properties, while each component mitigates the other's harmful side-effects. 
# In particular:
#     Propofol reduces blood pressure while ketamine raises it.
# What is *not* known at present, is which mix proportions produce 
# 0 "delta-BP" on average among the population. 

# The classical UD design below administers the mix 0-100% ketamine in 10% increments.
#    The design will concentrate doses around the point where half the population 
#    experiences 0 "delta-BP". (the 'zeroPt' parameter in the code)

doses = seq(0, 100, 10)
m=length(doses) # 11 dose levels

zeroPt=63 # the zero-BP point, in units of percent ketamine

# We assume a Normal ("Probit") dose-response curve,
#   and calculate the value of F (i.e.,  prob (delta BP &gt; 0) at the doses:
equivF = pnorm( (doses - zeroPt) / 20)
round(equivF, 3)

# The vector below represents the values feeding into the Fig. 2B barplot.
# "startdose = 6" means the experiment begins from the 6th out of 11 doses, i.e., a 50:50 mix.


round(cumulvec(cdf = equivF, matfun = classicmat, startdose = 6, n = 30), 3)

# Compare with the *instantaneous* probability distribution to the 30th patient:

round(currentvec(cdf = equivF, matfun = classicmat, startdose = 6, n = 30), 3)
# Classic up-and-down has quasi-periodic behavior with a (quasi-)period of 2. 
# Compare the instantaneous vectors at n=30 and 29:
round(currentvec(cdf = equivF, matfun = classicmat, startdose = 6, n = 29), 3)
# Note the alternating near-zero values. Distributions at even/odd n "communicate"
#    with each other only via the dose boundaries.

# Lastly, the asymptotic/stationary distribution. Notice there is no 'n' argument.

round(pivec(cdf = equivF, matfun = classicmat), 3)

# The cumulative vector at n=30 is not very far from the asymptotic vector. 
# The main difference is that at n=30 there's still a bit more
#    probability weight at the starting dose.
# We can check how much of that extra weight is from the 1st patient, by excluding that data point:

round(cumulvec(cdf = equivF, matfun = classicmat, startdose = 6, n = 30, exclude = 1), 3)


</code></pre>

<hr>
<h2 id='reversmean'>Reversal-anchored averaging estimators for Up-and-Down</h2><span id='topic+reversmean'></span><span id='topic+reversals'></span>

<h3>Description</h3>

<p>Dose-averaging target estimation for Up-and-Down experiments, historically the most popular approach, but not recommended as primary nowadays. Provided for completeness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reversmean(
  x,
  y,
  rstart = 3,
  all = TRUE,
  before = FALSE,
  conf = 0.9,
  maxExclude = NULL,
  full = FALSE,
  weth66revs = TRUE,
  evenrevs = !all,
  ...
)

reversals(y, x = NULL, directional = TRUE, evenrevs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reversmean_+3A_x">x</code></td>
<td>
<p>numeric vector: sequence of administered doses, treatments, stimuli, etc.</p>
</td></tr>
<tr><td><code id="reversmean_+3A_y">y</code></td>
<td>
<p>numeric vector: sequence of observed responses. Must be same length as <code>x</code> or shorter by 1, and must be coded <code>TRUE/FALSE</code> or 0/1. <code>dynamean()</code> only uses <code>y</code> for bootstrap confidence intervals.</p>
</td></tr>
<tr><td><code id="reversmean_+3A_rstart">rstart</code></td>
<td>
<p>the reversal point from which the averaging begins. Default 3, considered a good compromise between performance and robustness. See Details.</p>
</td></tr>
<tr><td><code id="reversmean_+3A_all">all</code></td>
<td>
<p>logical: from the cutoff point onwards, should all values of <code>x</code> be used (<code>TRUE</code>, default), or only reversal points as in the Wetherill et al. approach? If set to <code>FALSE</code>, then the <code>before</code> flag also defaults to <code>FALSE</code> regardless of user choice.</p>
</td></tr>
<tr><td><code id="reversmean_+3A_before">before</code></td>
<td>
<p>logical: whether to start the averaging one observation earlier than the cutoff point. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="reversmean_+3A_conf">conf</code></td>
<td>
<p>the CI's confidence level, as a fraction in (0,1). To skip CI calculation set <code>conf = NULL</code>.</p>
</td></tr>
<tr><td><code id="reversmean_+3A_maxexclude">maxExclude</code></td>
<td>
<p>a fraction in <code class="reqn">0,1</code> indicating the maximum initial fraction of the vector <code>x</code> to exclude from averaging, in case the algorithm-identified transition point occurs late in the experiment. Default 1/2.</p>
</td></tr>
<tr><td><code id="reversmean_+3A_full">full</code></td>
<td>
<p>logical: should more detailed information be returned, or only the estimate? (default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="reversmean_+3A_weth66revs">weth66revs</code></td>
<td>
<p>(in <code>reversmean()</code>) logical: identical to <code>directional</code>. The argument name used in <code>reversmean()</code> stems from the article that switched to this definition of reversals when introducing reversal-averaging.</p>
</td></tr>
<tr><td><code id="reversmean_+3A_evenrevs">evenrevs</code></td>
<td>
<p>logical: should only an even number of reversals be used, meaning that if the total number is odd the last one is discarded? Default <code>TRUE</code> per common practice. However, when setting <code>all=TRUE</code> it makes sense to also set <code>evenrevs=FALSE</code>.</p>
</td></tr>
<tr><td><code id="reversmean_+3A_...">...</code></td>
<td>
<p>Additional parameters, mostly ones passed on to <code>dfboot</code> if <code>conf</code> is not <code>NULL</code>. See that function's help for details.</p>
</td></tr>
<tr><td><code id="reversmean_+3A_directional">directional</code></td>
<td>
<p>(in <code>reversals()</code>) logical: should reversals be defined as change in direction (i.e., <code>x</code>; <code>TRUE</code> which is default), or in response (<code>y</code>)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Up-and-Down designs (UDDs) allocate doses in a random walk centered nearly symmetrically around a balance point. Therefore, a modified average of allocated doses could be a plausible estimate of the balance point's location.
</p>
<p>During UDDs' first generation, a variety of dose-averaging estimators was developed, with the one proposed by Wetherill et al. (1966) eventually becoming the most popular. This estimator uses only doses observed at <em>reversal</em> points: points with a negative response following a positive one, or vice versa. More recent research (Kershaw 1985, 1987; Oron et al. 2022, supplement) strongly indicates that in fact it is better to use all doses beginning from some cutoff point, rather than skip most of them and choose only reversals.
</p>
<p>The <code>reversals()</code> utility identifies reversal points, whereas <code>reversmean()</code> produces a dose-averaging estimate whose cutoff point (which should perhaps be called the <em>'cut-on'</em> point) is determined by a reversal. User can choose whether to use all doses from that cut-point onwards, or only the reversals as in the older approaches. A few additional options make the estimate even more flexible.
</p>
<p>Starting version 0.2.0, a bootstrap confidence interval (CI) is also provided. See <code><a href="#topic+dfboot">dfboot</a></code>, <code><a href="#topic+dfsim">dfsim</a></code> for additional parameters to pass to the bootstrap routine via <code>...</code>, beyond the confidence level <code>conf</code>. For the &quot;Classical&quot; median-finding UDD, use <code style="white-space: pre;">&#8288;design = krow, desArgs = list(k=1)&#8288;</code>. To skip CI estimation, set <code>conf = NULL</code>.
<code>reversmean()</code> is compatible mostly with median-targeting UDDs such as the &quot;Classical&quot; (traditional) design of Dixon and Mood.
For general UDD target estimation, particularly off-median targeting designs, we recommend using centered isotonic regression, available via <code><a href="#topic+udest">udest</a></code>, an up-and-down adapted wrapper to <code>cir::quickInverse()</code>. See Oron et al. 2022 (both article and supplement) for further information, as well as the <code>cir</code> package vignette.
</p>


<h3>Value</h3>

<p>For <code>reversals()</code>, the indices of reversal points. For <code>reversmean()</code>, if <code>full=FALSE</code> returns the point estimate and otherwise returns a data frame with the estimate, as well as the index of the cutoff point used to start the averaging.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>


<ul>
<li><p> Kershaw CD: A comparison of the estimators of the ED50 in up-and-down experiments. <em>J Stat Comput Simul</em> 1987; 27:175–84.
</p>
</li>
<li><p> Oron AP, Souter MJ, Flournoy N. Understanding Research Methods: Up-and-down Designs for Dose-finding. <em>Anesthesiology</em> 2022; 137:137–50. <a href="https://cdn-links.lww.com/permalink/aln/c/aln_2022_05_25_oron_aln-d-21-01101_sdc1.pdf">See in particular the open-access Supplement.</a>
</p>
</li>
<li><p> Wetherill GB, Chen H, Vasudeva RB: Sequential estimation of quantal response curves: A new method of estimation. <em>Biometrika</em> 1966; 53:439–54
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+udest">udest</a></code>, the recommended estimation method for up-and-down targets.
</p>
</li>
<li> <p><code><a href="#topic+dynamean">dynamean</a></code>, an unpublished but arguably better approach to dose-averaging (this is <em>not</em> the recommended method though; that would be <code><a href="#topic+udest">udest</a></code> referenced above).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#'  **An up-and-down experiment that has generated some controversy**
#'  
#' Van Elstraete, AC et al. The Median Effective Dose of Preemptive Gabapentin 
#'      on Postoperative Morphine Consumption After Posterior Lumbar Spinal Fusion. 
#'      *Anesthesia &amp; Analgesia* 2008, 106: 305-308.


# It was a classical median-finding up-and-down study.

doses = c(4:7, 6:13, 12:19, 18:21, 20, 19:23, 22, 21:23, 22:19, 20:23, 
          22:24, 23, 22, 23, 22:25, 24:22, rep(23:24,2), 23, 22)
# With U&amp;D, responses (except the last one) can be read off the doses:
responses = c( (1 - sign(diff(doses)))/2, 0 )


### Let us plot the dose-allocation time series.

# Saving current settings as now required by the CRAN powers-that-be :0
op &lt;- par(no.readonly = TRUE)

par(mar=c(4,4,4,1), mgp=c(2.5,0.8,0), cex.axis = 0.7, las = 1)
udplot(doses, responses, main='Van Elstraete et al. 2008 Study', 
       xtitle = "Patient Number", ytitle = 'Gabapentin (mg/kg)') 


#' Overlay the ED50 reported in the article (21.7 mg/kg):
abline(h = 21.7)

#' The authors cite a little-known 1991 article by Dixon as the method source.
#' However, in their author rejoinder they claim to have used the Dixon-Mood (1948) estimate.


# Our package does include the Dixon-Mood point estimate.
#  (w/o the CIs, because we do not endorse this estimation approach)
# Does it reproduce the article estimate?
dixonmood(x = doses, y = responses)

# Not at all! Let us overlay this one in red
abline(h = dixonmood(x = doses, y = responses), col=2)

# We have found that many articles claiming to use Dixon-Mood (or Dixon-Massey) actually
# Do something else. For example, in this article they report that 
#   "it is necessary to reject sequences with three to six identical results".
# Nothing like this appears in the original Dixon-Mood article, where the estimation method
#   involves identifying the less-common response (either 0 or 1), and using only x values
#   associated with these responses; obviating the need to exclude specific sequences.
#
# More generally, these historical estimates have long passed their expiry dates. 
#   Their foundation is not nearly as solid as, e.g., linear regression, 
#      and it's time to stop using them.

# That said, our package does offer two more types of dose-averaging estimates.
# Both are able to take advantage of the "n+1" dose-allocation, which is determined by
#    the last dose and response:
n = length(doses)
dosePlus1 = doses[n] + ifelse(responses[n]==0, 1, -1)
reversmean(c(doses, dosePlus1), responses, conf = NULL)
# Interestingly, in this particular case the answer is very similar to the Dixon-Mood estimate.

# The `reversmean()` default averages all doses from the 3rd reversal point onwards.
# By the way, at what point did the third reversal happen? 
#     It'll be the 3rd number in this vector:
reversals(x = doses, y = responses)

# Far more commonly in literature, particularly in sensory studies, 
#   one encounters the 1960s-era approach (led by Wetherill) of taking *only doses  
#   at reversal points, usually starting from the first one. `reversmean()` can do that too:
wetherill = reversmean(c(doses, dosePlus1), responses, all = FALSE, rstart = 1, conf = NULL)
wetherill
# This one gives an even lower result than the previous ones.
abline(h = wetherill, col = 3)

# There's another approach to dose-averaging, although it is not in use anywhere that we know of.
# It does not require the y values at all. The underlying assumption is that the dose 
#   sequence has done enough meandering around the true balance point, to provide information
#   about where (approximately) the starting-dose effect is neutralized.
# This function now also provides bootstrap CIs, so we need to give it the y values. 
# The default forces the final 2/3 of observations to be included; here in view of the long run-in
#     we are relaxing this
dynamean(c(doses, dosePlus1), responses, maxExclude = 0.5, conf = NULL)
# Again a bit curiously, this relatively recent approach gives a result similar to what
#   the authors reported (but not similar to the original Dixon-Mood).
# This is not too surprising, since here `dynamean()` excludes the first one-third of doses,
#   which is approximately what happened if indeed the authors excluded all those long dose-increase
#   sequences at the start.

# All this shows how dicey dose-averaging, at face value a simple and effective method, can become.
# The sample size here is rather large for up-and-down studies, and yet because of the unlucky
#    choice of starting point (which in many studies, due to safety concerns cannot be evaded)
#    there is really no good option of which observations to exclude.

# This is one reason why we strongly recommend using Centered Isotonic Regression as default. 
# Figure soon to follow.
# But first, have you noted how we keep specifying "conf = NULL"? 
# This is because now at default, these averages calculate
# A bootstrap confidence-interval. 
# These intervals are generally deficient but are the best anyone can do at present.

# If you want to use a confidence interval, you must provide the experiment's target, 
#    or more precisely its balance point, as well as the parameters to use in 
# the bootstrap simulation (which should be the ones generating the original experiment).

# Like this (not run, to avoid violating CRAN's very narrow limits on example runtime):
# dynamean(c(doses, dosePlus1), responses, maxExclude = 0.5, target = 0.5, 
#                  design = krow, desArgs = list(k=1) )


defest = udest(doses, responses, target = 0.5)
abline(h = defest$point, col = 'purple')
# For this dataset, it is the highest of all the estimates.

legend('bottomright', col = c(1:3, 'purple'), 
       legend = c("Article's estimate", 'Dixon-Mood', 'Reversals (Wetherill)', 'Standard (CIR)'), 
       lty = 1, bty='n', cex = 0.8)


par(op) # Back to business as usual ;)
</code></pre>

<hr>
<h2 id='udest'>Centered-Isotonic-Regression (CIR) Estimate for the Up-and-Down Target Dose</h2><span id='topic+udest'></span>

<h3>Description</h3>

<p>Centered Isotonic Regression (CIR) is an extension of isotonic regression (IR), substantially improving upon IR's estimation performance in the dose-response and dose-finding contexts (Oron and Flournoy 2017, Flournoy and Oron 2020). CIR is the recommended method for estimating up-and-down targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>udest(
  x,
  y,
  target,
  balancePt = target,
  conf = 0.9,
  allow1extra = FALSE,
  curvedCI = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="udest_+3A_x">x</code></td>
<td>
<p>numeric vector: sequence of administered doses, treatments, stimuli, etc.</p>
</td></tr>
<tr><td><code id="udest_+3A_y">y</code></td>
<td>
<p>numeric vector: sequence of observed responses. Must be same length as <code>x</code>, and must be coded <code>TRUE/FALSE</code> or 0/1.</p>
</td></tr>
<tr><td><code id="udest_+3A_target">target</code></td>
<td>
<p>The target response rate for which target dose estimate is requested. Must be a single number in <code class="reqn">(0,1).</code></p>
</td></tr>
<tr><td><code id="udest_+3A_balancept">balancePt</code></td>
<td>
<p>In case the design's inherent balance point differs somewhat from <code>target</code>, specify it here to improve estimation accuracy. See Details for further explanation. Otherwise, this argument defaults to be equal to <code>target</code>.</p>
</td></tr>
<tr><td><code id="udest_+3A_conf">conf</code></td>
<td>
<p>The desired confidence level for the confidence interval. Default <code class="reqn">90\%.</code> We do not recommend increasing to <code class="reqn">95\%</code> unless you have <code class="reqn">\sim 100</code> or more observations. Setting to <code>NULL</code> triggers special behavior; see under &quot;Value&quot;.</p>
</td></tr>
<tr><td><code id="udest_+3A_allow1extra">allow1extra</code></td>
<td>
<p>logical: allow <code>length(x)</code> to be either equal or 1 greater than <code>length(y)</code>? (default <code>FALSE</code>) The <em>&quot;n+1&quot;</em> dose-allocation, determined from the last allocations and responses, might be tagged onto <code>x</code>. If this point is provided and <code>allow1extra=TRUE</code>, <code>udplot()</code> will show it as a grey diamond; the other functions will ignore it.</p>
</td></tr>
<tr><td><code id="udest_+3A_curvedci">curvedCI</code></td>
<td>
<p>logical: should confidence-interval boundaries rely upon an outwardly-curving interpolation (<code>TRUE</code>) or linear? If <code>NULL</code> (default), it will be <code>TRUE</code> for targets outside the 40th-60th percentile range.</p>
</td></tr>
<tr><td><code id="udest_+3A_...">...</code></td>
<td>
<p>Pass-through argument added for flexible calling context.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CIR and related methods are available in the <code>cir</code> package. The <code>udest()</code> function in the present package provides a convenient wrapper for <code>cir::quickInverse()</code>, with arguments already set to the appropriate values for estimating the target dose after an up-and-down experiment. The function also returns a confidence interval as default.
</p>
<p><strong>WARNING!</strong> You should not estimate target doses too far removed from the design's actual balance point (definitely no further than 0.1, e.g., estimating the 33rd percentile for a design whose balance point is the median). As Flournoy and Oron (2020) explain, observed response rates are biased away from the balance point. Even though <code>udest()</code> performs the rudimentary bias correction described in that article, practically speaking this correction's role is mostly to expand the confidence intervals in response to the bias. It cannot guarantee to provide reliable off-balance-point estimates.
</p>


<h3>Value</h3>

<p>Geneally, a one-row data frame with 4 variables: <code>target</code>, <code>point</code> (the point estimate), <code style="white-space: pre;">&#8288;lowerXYconf, upperXYconf&#8288;</code> (the confidence bounds, with <code>XY</code> standing for the percents, default <code>90</code>).
</p>
<p>However, if <code>conf = NULL</code> only the point estimate will be returned. This is for compatibility with bootstrap confidence intervals (which is not implemented as default for CIR), and with UD ensemble simulation in general.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>


<ul>
<li><p> Oron AP, Flournoy N.  Centered Isotonic Regression: Point and Interval Estimation for Dose-Response Studies. <em>Statistics in Biopharmaceutical Research</em> 2017; 9, 258-267. <a href="https://arxiv.org/pdf/1701.05964">Author's public version available on arxiv.org.</a>
</p>
</li>
<li><p> Flournoy N, Oron AP. Bias Induced by Adaptive Dose-Finding Designs. <em>Journal of Applied Statistics</em> 2020; 47, 2431-2442.
</p>
</li>
<li><p> Oron AP, Souter MJ, Flournoy N. Understanding Research Methods: Up-and-down Designs for Dose-finding. <em>Anesthesiology</em> 2022; 137:137–50. <a href="https://cdn-links.lww.com/permalink/aln/c/aln_2022_05_25_oron_aln-d-21-01101_sdc1.pdf">See in particular the open-access Supplement.</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="cir.html#topic+quickInverse">quickInverse</a></code>, <code>cir</code> package.
</p>
</li>
<li> <p><code>cir</code> package vignette.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
#'  **An up-and-down experiment that has generated some controversy**
#'  
#' Van Elstraete, AC et al. The Median Effective Dose of Preemptive Gabapentin 
#'      on Postoperative Morphine Consumption After Posterior Lumbar Spinal Fusion. 
#'      *Anesthesia &amp; Analgesia* 2008, 106: 305-308.

# It was a classical median-finding up-and-down study.

doses = c(4:7, 6:13, 12:19, 18:21, 20, 19:23, 22, 21:23, 22:19, 20:23, 
          22:24, 23, 22, 23, 22:25, 24:22, rep(23:24,2), 23, 22)
# With U&amp;D, responses (except the last one) can be read off the doses:
responses = c( (1 - sign(diff(doses)))/2, 0 )


#' ### Plots plots plots!

# Saving current settings as now required by the CRAN powers-that-be :0
op &lt;- par(no.readonly = TRUE)

layout(t(1:2), widths=3:2)
par(mar=c(4,4,4,1), mgp=c(2.5,0.8,0), cex.axis = 0.7, las = 1)

#' The experimental trajectory / time-series / "trace" (pick your favorite name!)
#' Note the changed argument names for x and y axis titles
udplot(doses, responses, main='', 
        xtitle = "Patient Number", ytitle = 'Gabapentin (mg/kg)') 
#' Compare with the article's Figure 1; the line below makes it look more similar
udplot(doses, responses, shape='square', connect=TRUE)

# The dose-response plot, rarely encountered in U&amp;D articles. 
# We can also add the CIR estimate right there:
drplot(doses, responses, main=' Dose-Response', percents = TRUE,
       addest = TRUE, target = 0.5, addcurve = TRUE,
       xtitle = 'Gabapentin (mg/kg)', ytitle = "Percent Effective")

#' ### Estimates

#' Let us actually see the numbers of those Centered-Isotonic-Regression (CIR) estimates!
#' Note that our default confidence-interval is 90%. Change it via the 'conf' argument.

udest(doses, responses, target = 0.5)
#' Compare with the article: 21.7 mg/kg (95% CI 19.9–23.5). 
#' They cite a little-known 1991 article by Dixon as the method source.
#' However, in their author rejoinder they claim to have used the Dixon-Mood estimate.
#' 
#' ## Toy example of plotting a group UD dataset
#' 
#' Also showing off some udplot() options
#' 
#' Not an actual experiment (made-up data)
#' The design is purportedly GUD (3,0,1), targeting the 20th percentile
#' 

gsize = 3
x = rep(c(1:3, 2:4), each = gsize)
y = c(rep(0, 8), 1, rep(0,7), 1, 1)

udplot(x=x, y=y, cohort=gsize, connect=FALSE, shape='triangle')

par(op) # Back to business as usual ;)
</code></pre>

<hr>
<h2 id='udplot'>Visualizing the time series of an up-and-down experiment</h2><span id='topic+udplot'></span>

<h3>Description</h3>

<p>Plotting function for the &quot;trace&quot; (time series) of an up-and-down experiment, showing the observation order on the x-axis, and the dose <em>(treatment, stimulus, etc.)</em> strength on the y-axis. Uses utilities from the <code>cir</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>udplot(
  x,
  y,
  cohort = NULL,
  shape = "circle",
  connect = TRUE,
  symbcol = 1,
  doselabels = NULL,
  allow1extra = FALSE,
  xtitle = "Observation Order",
  ytitle = "Dose / Stimulus",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="udplot_+3A_x">x</code></td>
<td>
<p>numeric vector: sequence of administered doses, treatments, stimuli, etc.</p>
</td></tr>
<tr><td><code id="udplot_+3A_y">y</code></td>
<td>
<p>numeric vector: sequence of observed responses. Must be same length as <code>x</code>, and must be coded <code>TRUE/FALSE</code> or 0/1.</p>
</td></tr>
<tr><td><code id="udplot_+3A_cohort">cohort</code></td>
<td>
<p>for a group/cohort UD design, the cohort/group size (a single number). In case of variable cohort size, this can be a vector the same length as <code style="white-space: pre;">&#8288;x, y&#8288;</code>, with each observation's cohort assignment.</p>
</td></tr>
<tr><td><code id="udplot_+3A_shape">shape</code></td>
<td>
<p>the plotting shape (DRtrace only): <code>'circle'</code> (default), <code>'square'</code>, or <code>'triangle'</code>.</p>
</td></tr>
<tr><td><code id="udplot_+3A_connect">connect</code></td>
<td>
<p>logical: whether to connect the symbols (generic plotting type <code>'b'</code>). Default <code>TRUE</code> for <code>udplot()</code> and <code>FALSE</code> for <code>drplot()</code>.</p>
</td></tr>
<tr><td><code id="udplot_+3A_symbcol">symbcol</code></td>
<td>
<p>The color of the main plotting symbols and connecting lines. Default 1 (the current palette's first color). Note: if you change the color and inadvertently use <code>col</code> instead, there might be an error message.</p>
</td></tr>
<tr><td><code id="udplot_+3A_doselabels">doselabels</code></td>
<td>
<p>(<code>DRtrace</code> only) Dose values to be plotted along the y-axis. If <code>NULL</code> (default), those will be the doses in the dataset (i.e., <code>sort(unique(x))</code>).</p>
</td></tr>
<tr><td><code id="udplot_+3A_allow1extra">allow1extra</code></td>
<td>
<p>logical: allow <code>length(x)</code> to be either equal or 1 greater than <code>length(y)</code>? (default <code>FALSE</code>) The <em>&quot;n+1&quot;</em> dose-allocation, determined from the last allocations and responses, might be tagged onto <code>x</code>. If this point is provided and <code>allow1extra=TRUE</code>, <code>udplot()</code> will show it as a grey diamond; the other functions will ignore it.</p>
</td></tr>
<tr><td><code id="udplot_+3A_xtitle">xtitle</code>, <code id="udplot_+3A_ytitle">ytitle</code></td>
<td>
<p>x-axis and y-axis titles. Some reasonable defaults are provided, to avoid an annoying error message.</p>
</td></tr>
<tr><td><code id="udplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="graphics.html#topic+plot">plot</a></code> (e.g., <code>main</code> for the main title).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simple and handy visualization approach was presented already by Dixon and Mood (1948).
</p>

<ul>
<li><p> It conveys directly the meaning of <em>&quot;up-and-down&quot;</em>, because the administered dose/stimulus strength is on the y-axis, whereas observation order is on the x-axis.
</p>
</li>
<li><p> Filled symbols stand for positive responses and open symbols for negative.
</p>
</li>
<li><p> The design's transition rules can be usually inferred directly from the plot.
</p>
</li></ul>

<p><code>udplot()</code> is a convenience wrapper to <code>cir::plot.DRtrace</code>. This is a base-R plot, so you can use additional options, including preceding the plot command with <code><a href="graphics.html#topic+par">par</a></code> statements, or following up with <code><a href="graphics.html#topic+legend">legend</a></code>. When wishing to save to a file, I recommend utilities such as <code>png()</code> or <code>pdf()</code>.
</p>


<h3>Value</h3>

<p>Returns invisibly after plotting. If you would like to save the plot to a file, embed the plotting code in a standard R graphics export code sequence, (e.g., <code>pdf(...)</code> before the plotting function, and <code>dev.off()</code> after it).
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>


<ul>
<li><p> Dixon WJ, Mood AM. A method for obtaining and analyzing sensitivity data. <em>J Am Stat Assoc.</em> 1948;43:109-126.
</p>
</li>
<li><p> Oron AP, Souter MJ, Flournoy N. Understanding Research Methods: Up-and-down Designs for Dose-finding. <em>Anesthesiology</em> 2022; 137:137–50.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="cir.html#topic+plot.DRtrace">plot.DRtrace</a></code>, <code>cir</code> package.
</p>
</li>
<li> <p><code><a href="#topic+drplot">drplot</a></code> for the up-and-down dose-response and estimate plotting.
</p>
</li>
<li> <p><code>cir</code> package vignette.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
#'  **An up-and-down experiment that has generated some controversy**
#'  
#' Van Elstraete, AC et al. The Median Effective Dose of Preemptive Gabapentin 
#'      on Postoperative Morphine Consumption After Posterior Lumbar Spinal Fusion. 
#'      *Anesthesia &amp; Analgesia* 2008, 106: 305-308.

# It was a classical median-finding up-and-down study.

doses = c(4:7, 6:13, 12:19, 18:21, 20, 19:23, 22, 21:23, 22:19, 20:23, 
          22:24, 23, 22, 23, 22:25, 24:22, rep(23:24,2), 23, 22)
# With U&amp;D, responses (except the last one) can be read off the doses:
responses = c( (1 - sign(diff(doses)))/2, 0 )


#' ### Plots plots plots!

# Saving current settings as now required by the CRAN powers-that-be :0
op &lt;- par(no.readonly = TRUE)

layout(t(1:2), widths=3:2)
par(mar=c(4,4,4,1), mgp=c(2.5,0.8,0), cex.axis = 0.7, las = 1)

#' The experimental trajectory / time-series / "trace" (pick your favorite name!)
#' Note the changed argument names for x and y axis titles
udplot(doses, responses, main='', 
        xtitle = "Patient Number", ytitle = 'Gabapentin (mg/kg)') 
#' Compare with the article's Figure 1; the line below makes it look more similar
udplot(doses, responses, shape='square', connect=TRUE)

# The dose-response plot, rarely encountered in U&amp;D articles. 
# We can also add the CIR estimate right there:
drplot(doses, responses, main=' Dose-Response', percents = TRUE,
       addest = TRUE, target = 0.5, addcurve = TRUE,
       xtitle = 'Gabapentin (mg/kg)', ytitle = "Percent Effective")

#' ### Estimates

#' Let us actually see the numbers of those Centered-Isotonic-Regression (CIR) estimates!
#' Note that our default confidence-interval is 90%. Change it via the 'conf' argument.

udest(doses, responses, target = 0.5)
#' Compare with the article: 21.7 mg/kg (95% CI 19.9–23.5). 
#' They cite a little-known 1991 article by Dixon as the method source.
#' However, in their author rejoinder they claim to have used the Dixon-Mood estimate.
#' 
#' ## Toy example of plotting a group UD dataset
#' 
#' Also showing off some udplot() options
#' 
#' Not an actual experiment (made-up data)
#' The design is purportedly GUD (3,0,1), targeting the 20th percentile
#' 

gsize = 3
x = rep(c(1:3, 2:4), each = gsize)
y = c(rep(0, 8), 1, rep(0,7), 1, 1)

udplot(x=x, y=y, cohort=gsize, connect=FALSE, shape='triangle')

par(op) # Back to business as usual ;)
</code></pre>

<hr>
<h2 id='validUDinput'>Data Validation Utilities for <code>upndown</code></h2><span id='topic+validUDinput'></span><span id='topic+checkTarget'></span><span id='topic+checkCDF'></span><span id='topic+checkNatural'></span><span id='topic+checkDose'></span><span id='topic+checkResponse'></span>

<h3>Description</h3>

<p>Validation of input values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validUDinput(cdf, target)

checkTarget(target, tname = "Target")

checkCDF(cdf, flatOK = TRUE)

checkNatural(k, parname, toolarge = 1000)

checkDose(x, maxfrac = 0.9)

checkResponse(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validUDinput_+3A_cdf">cdf</code></td>
<td>
<p>vector of values, should be nondecreasing between 0 and 1 (inclusive)</p>
</td></tr>
<tr><td><code id="validUDinput_+3A_target">target</code></td>
<td>
<p>numeric value(s), should be between 0 and 1 (exclusive)</p>
</td></tr>
<tr><td><code id="validUDinput_+3A_flatok">flatOK</code></td>
<td>
<p>logical (<code>checkCDF()</code> only) if the CDF is completely flat, should function issue a warning (<code>TRUE</code>, default) - or stop with an error (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="validUDinput_+3A_k">k</code></td>
<td>
<p>(<code>checkNatural()</code> only) input number to check whether it's a natural number</p>
</td></tr>
<tr><td><code id="validUDinput_+3A_parname">parname</code>, <code id="validUDinput_+3A_tname">tname</code></td>
<td>
<p>string, name of variable to plug in for reporting the error back</p>
</td></tr>
<tr><td><code id="validUDinput_+3A_toolarge">toolarge</code></td>
<td>
<p>(<code>checkNatural()</code> only) what number would be considered too large to be realistic?</p>
</td></tr>
<tr><td><code id="validUDinput_+3A_x">x</code></td>
<td>
<p>(<code>checkDose()</code> only) input object to be verified as valid dose values</p>
</td></tr>
<tr><td><code id="validUDinput_+3A_maxfrac">maxfrac</code></td>
<td>
<p>(<code>checkDose()</code> only) maximum number of unique values (as fraction of sample size) considered realistic for up-and-down data. Default $0.9n.$ Function also gives a warning if number exceeds $n/2$, since typically this suggests the effective sample size around target is too small.</p>
</td></tr>
<tr><td><code id="validUDinput_+3A_y">y</code></td>
<td>
<p>(<code>checkResponse()</code> only) input object to be verified as valid response values ('TRUE/FALSE or 0/1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a validation issue is found, these functions stop with a relevant error message. If no issue is found, they run through without returning a value.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
