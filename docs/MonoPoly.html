<!DOCTYPE html><html lang="en"><head><title>Help for package MonoPoly</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MonoPoly}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.monpol'>
<p>Extract Model Coefficients</p></a></li>
<li><a href='#curvPol'>
<p>Evaluating the Curvature of Polynomials</p></a></li>
<li><a href='#evalPol'>
<p>Evaluating Polynomials</p></a></li>
<li><a href='#fitted.monpol'>
<p>Extract Model Fitted Values</p></a></li>
<li><a href='#hawkins'>
<p>hawkins</p></a></li>
<li><a href='#ismonotone'>
<p>Check whether a polynomial is monotone</p></a></li>
<li><a href='#model.matrix.monpol'>
<p>Construct Design Matrices</p></a></li>
<li><a href='#monpol'><p>Monotone Polynomials</p></a></li>
<li><a href='#monpol.control'>
<p>Control the Iterations in monpol</p></a></li>
<li><a href='#monpol.fit'><p>Monotone Polynomials</p></a></li>
<li><a href='#predict.monpol'><p>Predicting from Monotone Polynomial Fits</p></a></li>
<li><a href='#print.monpol'>
<p>Printing Monotone Polynomials</p></a></li>
<li><a href='#residuals.monpol'>
<p>Extract Model Residuals</p></a></li>
<li><a href='#w0'><p>Simulated w0 data used in Murray et al. (2013)</p></a></li>
<li><a href='#w2'><p>Simulated w2 data used in Murray et al. (2013)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions to Fit Monotone Polynomials</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-04-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for fitting monotone polynomials to data.
             Detailed discussion of the methodologies used can be
             found in Murray, Mueller and Turlach (2013)
             &lt;<a href="https://doi.org/10.1007%2Fs00180-012-0390-5">doi:10.1007/s00180-012-0390-5</a>&gt; and Murray, Mueller and
             Turlach (2016) &lt;<a href="https://doi.org/10.1080%2F00949655.2016.1139582">doi:10.1080/00949655.2016.1139582</a>&gt;.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), quadprog</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-24 07:46:56 UTC; berwin</td>
</tr>
<tr>
<td>Author:</td>
<td>Berwin A. Turlach <a href="https://orcid.org/0000-0001-8795-471X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kevin Murray <a href="https://orcid.org/0000-0002-8856-6046"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Berwin A. Turlach &lt;Berwin.Turlach@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-24 08:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.monpol'>
Extract Model Coefficients
</h2><span id='topic+coef.monpol'></span>

<h3>Description</h3>

<p><code>coef</code> method for &lsquo;monpol&rsquo; objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'monpol'
coef(object, scale = c("original", "fitted"), type = c("beta", "monpar"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.monpol_+3A_object">object</code></td>
<td>
<p>A &lsquo;monpol&rsquo; object.</p>
</td></tr>
<tr><td><code id="coef.monpol_+3A_scale">scale</code></td>
<td>
<p>Extract coefficients on the original scale of the data
or on the scale used during fitting.</p>
</td></tr>
<tr><td><code id="coef.monpol_+3A_type">type</code></td>
<td>
<p>Extract coefficients in the &lsquo;beta&rsquo;
parameterisation of the polynomial or for the monotone
parameterisation used in the algorithm.</p>
</td></tr>
<tr><td><code id="coef.monpol_+3A_...">...</code></td>
<td>
<p>Additional optionals arguments.  At present no optional
arguments are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code><a href="stats.html#topic+coef">coef</a></code> method for objects inheriting from
class <code>"monpol"</code>.
</p>


<h3>Value</h3>

<p>Coefficients extracted from the model object <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Berwin A Turlach &lt;Berwin.Turlach@gmail.com&gt;
</p>

<hr>
<h2 id='curvPol'>
Evaluating the Curvature of Polynomials
</h2><span id='topic+curvPol'></span>

<h3>Description</h3>

<p>Function to evaluate the curvature of polynomials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curvPol(x, beta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="curvPol_+3A_x">x</code></td>
<td>
<p>numerical values at which to evaluate the curvature of
polynomials, can be 
provided in a vector, matrix, array or data frame</p>
</td></tr>
<tr><td><code id="curvPol_+3A_beta">beta</code></td>
<td>
<p>numerical vector containing the coefficient of the
polynomial</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of evaluating the curvature of the polynomial at the values
in <code>x</code>, 
returned in the same dimension as <code>x</code> has.
</p>


<h3>Author(s)</h3>

<p>Berwin A Turlach &lt;Berwin.Turlach@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beta &lt;- c(1,2,1)

x &lt;- 0:10
curvPol(x, beta)
str(curvPol(x, beta))

x &lt;- cbind(0:10, 10:0)
curvPol(x, beta)
str(curvPol(x, beta))


x &lt;- data.frame(x=0:10, y=10:0)
curvPol(x, beta)
str(curvPol(x, beta))
</code></pre>

<hr>
<h2 id='evalPol'>
Evaluating Polynomials
</h2><span id='topic+evalPol'></span>

<h3>Description</h3>

<p>Function to evaluate polynomials in a numerical robust way using the
Horner scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalPol(x, beta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evalPol_+3A_x">x</code></td>
<td>
<p>numerical values at which to evaluate polynomials, can be
provided in a vector, matrix, array or data frame</p>
</td></tr>
<tr><td><code id="evalPol_+3A_beta">beta</code></td>
<td>
<p>numerical vector containing the coefficient of the
polynomial</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of evaluating the polynomial at the values in <code>x</code>,
returned in the same dimension as <code>x</code> has.
</p>


<h3>Author(s)</h3>

<p>Berwin A Turlach &lt;Berwin.Turlach@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beta &lt;- c(1,2,1)

x &lt;- 0:10
evalPol(x, beta)
str(evalPol(x, beta))

x &lt;- cbind(0:10, 10:0)
evalPol(x, beta)
str(evalPol(x, beta))


x &lt;- data.frame(x=0:10, y=10:0)
evalPol(x, beta)
str(evalPol(x, beta))
</code></pre>

<hr>
<h2 id='fitted.monpol'>
Extract Model Fitted Values
</h2><span id='topic+fitted.monpol'></span><span id='topic+fitted.values.monpol'></span>

<h3>Description</h3>

<p><code>fitted</code> method for &lsquo;monpol&rsquo; objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'monpol'
fitted(object, scale = c("original", "fitted"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.monpol_+3A_object">object</code></td>
<td>
<p>A &lsquo;monpol&rsquo; object.</p>
</td></tr>
<tr><td><code id="fitted.monpol_+3A_scale">scale</code></td>
<td>
<p>Extract fitted values on the original scale of the data
or on the scale used during fitting.</p>
</td></tr>
<tr><td><code id="fitted.monpol_+3A_...">...</code></td>
<td>
<p>Additional optionals arguments.  At present no optional
arguments are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code><a href="stats.html#topic+fitted">fitted</a></code> method for objects inheriting from
class <code>"monpol"</code>.
</p>


<h3>Value</h3>

<p>Fitted values extracted from the model object <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Berwin A Turlach &lt;Berwin.Turlach@gmail.com&gt;
</p>

<hr>
<h2 id='hawkins'>
hawkins
</h2><span id='topic+hawkins'></span>

<h3>Description</h3>

<p>This data gives x and y variables for the data published in Hawkins'
1994 article.  This data was originally simulated from a standard cubic
polynomial with equally spaced x values between -1 and 1. 
</p>


<h3>Format</h3>

<p>A data frame with 50 simulated observations on the following 2 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Hawkins, D. M. (1994) Fitting monotonic polynomials to
data. <em>Computational Statistics</em> <b>9</b>(3):
233&ndash;247. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hawkins)
</code></pre>

<hr>
<h2 id='ismonotone'>
Check whether a polynomial is monotone
</h2><span id='topic+ismonotone'></span><span id='topic+ismonotone.monpol'></span><span id='topic+ismonotone.default'></span>

<h3>Description</h3>

<p>Function to check whether a polynomial is montone over a given interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ismonotone(object, ...)

## S3 method for class 'monpol'
ismonotone(object, a = -Inf, b = Inf, EPS = 1e-06, ...)

## Default S3 method:
ismonotone(object, a = -Inf, b = Inf, EPS = 1e-06, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ismonotone_+3A_object">object</code></td>
<td>

<p>Either an object of class &lsquo;</p>
<pre>monpol</pre>&rsquo;<p> or a
numeric vector containing the coefficient of the polynomial.
</p>
</td></tr>
<tr><td><code id="ismonotone_+3A_a">a</code></td>
<td>

<p>Lower limit of the interval over which the polynomial should be
montone. 
</p>
</td></tr>
<tr><td><code id="ismonotone_+3A_b">b</code></td>
<td>

<p>Upper limit of the interval over which the polynomial should be
montone. 
</p>
</td></tr>
<tr><td><code id="ismonotone_+3A_eps">EPS</code></td>
<td>

<p>Numerical precision, values with absolute value smaller than EPS are
treated as zero.
</p>
</td></tr>
<tr><td><code id="ismonotone_+3A_...">...</code></td>
<td>

<p>Further arguments passed to or from other methods.
</p>
</td></tr></table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code> depending on whether the polynomial is
montone over (a,b) or not.
</p>
<p>Note that due to numerical precision issues it is possible that a
polynomial that should be monotone is declared to be not monotone.
</p>


<h3>Author(s)</h3>

<p>Kevin Murray &lt;Kevin.Murray@uwa.edu.au&gt;
</p>
<p>Berwin A Turlach &lt;Berwin.Turlach@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- monpol(y~x, w0)
  ismonotone(fit)

  beta &lt;- c(1,0,2)  ## the polynomial 1 + 2*x^2
  ismonotone(beta)
  ismonotone(beta, a=0)
  ismonotone(beta, b=0)
</code></pre>

<hr>
<h2 id='model.matrix.monpol'>
Construct Design Matrices
</h2><span id='topic+model.matrix.monpol'></span>

<h3>Description</h3>

<p><code>model.matrix</code> creates a design (or model) matrix for
&lsquo;monpol&rsquo; objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'monpol'
model.matrix(object, scale = c("original", "fitted"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.matrix.monpol_+3A_object">object</code></td>
<td>
<p>A &lsquo;monpol&rsquo; object.</p>
</td></tr>
<tr><td><code id="model.matrix.monpol_+3A_scale">scale</code></td>
<td>
<p>Create design matrix on the original scale of the data
or on the scale used during fitting.</p>
</td></tr>
<tr><td><code id="model.matrix.monpol_+3A_...">...</code></td>
<td>
<p>Additional optionals arguments.  At present no optional
arguments are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> method for objects inheriting
from class <code>"monpol"</code>.
</p>


<h3>Value</h3>

<p>Design matrix created from the model object <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Berwin A Turlach &lt;Berwin.Turlach@gmail.com&gt;
</p>

<hr>
<h2 id='monpol'>Monotone Polynomials</h2><span id='topic+monpol'></span>

<h3>Description</h3>

<p>Determine the least-squares estimates of the parameters of a monotone
polynomial 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monpol(formula, data, subset, weights, na.action,
       degree = 3, K, start,
       a = -Inf, b=Inf,
       trace = FALSE, plot.it = FALSE,
       control = monpol.control(),
       algorithm = c("Full", "Hawkins", "BCD", "CD1", "CD2"),
       ptype = c("SOS", "Elphinstone", "EHH", "Penttila"),
       ctype = c("cge0", "c2"),
       monotone,
       model=FALSE, x=FALSE, y=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monpol_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one that
can be coerced to that class): a symbolic description of the
model to be fitted.</p>
</td></tr>
<tr><td><code id="monpol_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>monpol</code> is called.</p>
</td></tr>
<tr><td><code id="monpol_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="monpol_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="monpol_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &lsquo;factory-fresh&rsquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="monpol_+3A_degree">degree</code></td>
<td>
<p>positive integer, a polynomial with highest power equal
to <code>degree</code> will be fitted to the data.</p>
</td></tr>
<tr><td><code id="monpol_+3A_k">K</code></td>
<td>
<p>non-negative integer, a polynomial with highest power
<code class="reqn">2K+1</code> will be fitted to the data.</p>
</td></tr>
<tr><td><code id="monpol_+3A_start">start</code></td>
<td>
<p>optional starting value for the iterative fitting.</p>
</td></tr>
<tr><td><code id="monpol_+3A_a">a</code>, <code id="monpol_+3A_b">b</code></td>
<td>
<p>polynomial should be monotone on the interval from a to b.
If either parameter is finite, parameterisation &ldquo;SOS&rdquo; has to be used.</p>
</td></tr>
<tr><td><code id="monpol_+3A_trace">trace</code></td>
<td>
<p>print out information about the progress of the
interative fitting at the start and then every <code>trace</code>
iterations.</p>
</td></tr>
<tr><td><code id="monpol_+3A_plot.it">plot.it</code></td>
<td>
<p>plot the data and initial fit, then plot current fit
every <code>plot.it</code> iterations.</p>
</td></tr>
<tr><td><code id="monpol_+3A_control">control</code></td>
<td>
<p>settings that control the iterative fit; see
<code><a href="#topic+monpol.control">monpol.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="monpol_+3A_algorithm">algorithm</code></td>
<td>
<p>algorithm to be used.  It is recommended to use
either &ldquo;Full&rdquo; or &ldquo;Hawkins&rdquo;; see both papers in
&lsquo;References&rsquo; for details.</p>
</td></tr> 
<tr><td><code id="monpol_+3A_ptype">ptype</code></td>
<td>
<p>parameterisation to be used.  It is recommended to use
the &ldquo;SOS&rdquo; parameterisation; see the 2016 paper in
&lsquo;References&rsquo; for details.</p>
</td></tr>
<tr><td><code id="monpol_+3A_ctype">ctype</code></td>
<td>
<p>parameterisation to be used; see paper in
&lsquo;References&rsquo; for details.</p>
</td></tr>
<tr><td><code id="monpol_+3A_monotone">monotone</code></td>
<td>
<p>only used for parameterisation &ldquo;SOS&rdquo; to enforce the
kind of monotonicity desired over the interval <code class="reqn">[a,b]</code>, should
be &ldquo;increasing&rdquo; or &ldquo;decreasing&rdquo;.</p>
</td></tr>
<tr><td><code id="monpol_+3A_model">model</code>, <code id="monpol_+3A_x">x</code>, <code id="monpol_+3A_y">y</code></td>
<td>
<p>logicals.  If <code>TRUE</code> the corresponding
components of the fit (the model frame, the model matrix, the
response, the QR decomposition) are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>monpol</code> object is a type of fitted model object. It has
methods for the generic function <code><a href="stats.html#topic+coef">coef</a></code>,
<code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>,
<code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>.
</p>
<p>The parameterisation type &ldquo;SOS&rdquo; with the &ldquo;Full&rdquo;
algorithm is currently the recommended fitting procedure and is
discussed in the 2016 paper in &lsquo;References&rsquo;.  For this
parameterisation the argument <code>ctype</code> is ignored.
</p>
<p>The &ldquo;Hawkins&rdquo; algorithm is also recommended and discussed in
both papers in the &lsquo;References&rsquo;.
</p>
<p>The parameterisations &ldquo;Elphinstone&rdquo;, &ldquo;EHH&rdquo; and
&ldquo;Pentilla&rdquo;, for which the argument &ldquo;ctype&rdquo; defines a
further variation of parameterisation, work together with algorithms
&ldquo;Full&rdquo;, &ldquo;BCD&rdquo;, &ldquo;CD1&rdquo; and &ldquo;CD2&rdquo;.  These
parameterisations and algorithms are discussed in the 2013 paper in
&lsquo;References&rsquo;. 
</p>


<h3>Value</h3>

<p><code>monpol</code> returns an object of <code><a href="base.html#topic+class">class</a></code> <code>"monpol"</code>
</p>


<h3>Author(s)</h3>

<p>Berwin A Turlach &lt;Berwin.Turlach@gmail.com&gt;
</p>


<h3>References</h3>

<p>Murray, K., Müller, S. and Turlach, B.A. (2016). Fast and
flexible methods for monotone polynomial fitting, <em>Journal of
Statistical Computation and Simulation</em> <b>86</b>(15):
2946&ndash;2966, doi: <a href="http://doi.org/10.1080/00949655.2016.1139582">10.1080/00949655.2016.1139582</a>.
</p>
<p>Murray, K., Müller, S. and Turlach,
B.A. (2013). Revisiting fitting monotone polynomials to data,
<em>Computational Statistics</em> <b>28</b>(5):
1989&ndash;2005, doi: <a href="http://doi.org/10.1007/s00180-012-0390-5">10.1007/s00180-012-0390-5</a>.    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>monpol(y~x, w0)
</code></pre>

<hr>
<h2 id='monpol.control'>
Control the Iterations in monpol
</h2><span id='topic+monpol.control'></span>

<h3>Description</h3>

<p>Allow the user to set some characteristics of the <code>monpol</code>
monotone polynomial fitting algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monpol.control(maxiter = 1000, tol = 1e-05,
               tol1=1e-10, tol2=1e-07, tolqr=1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monpol.control_+3A_maxiter">maxiter</code></td>
<td>
<p>A positive integer specifying the maximum number of
iterations allowed, used in all algorithms.</p>
</td></tr>
<tr><td><code id="monpol.control_+3A_tol">tol</code></td>
<td>
<p>A positive numeric value specifying an absolute tolerance
for determining whether entries in the gradient are zero for
algorithms &lsquo;Full&rsquo;, &lsquo;BCD&rsquo;, &lsquo;CD1&rsquo; and &lsquo;CD2&rsquo;.</p>
</td></tr>
<tr><td><code id="monpol.control_+3A_tol1">tol1</code></td>
<td>
<p>A positive numeric value, used in algorithm
&lsquo;Hawkins&rsquo;. Any number not smaller than <code>-tol1</code> is deemed
to be non-negative.</p>
</td></tr>
<tr><td><code id="monpol.control_+3A_tol2">tol2</code></td>
<td>
<p>A positive numeric value, used in algorithm
&lsquo;Hawkins&rsquo;.  Any number whose absolute value is smaller than
<code>tol2</code> is taken to be zero.</p>
</td></tr>
<tr><td><code id="monpol.control_+3A_tolqr">tolqr</code></td>
<td>
<p>A positive numeric value, used in algorithm
&lsquo;Hawkins&rsquo; as tolerance for the QR factorisation of the
design matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with exactly five components:
</p>
<table role = "presentation">
<tr><td><code>maxiter</code></td>
<td>
</td></tr>
<tr><td><code>tol</code></td>
<td>
</td></tr>
<tr><td><code>tol1</code></td>
<td>
</td></tr>
<tr><td><code>tol2</code></td>
<td>
</td></tr>
<tr><td><code>tolqr</code></td>
<td>
</td></tr>
</table>
<p>with meanings as explained under &lsquo;Arguments&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Berwin A Turlach &lt;Berwin.Turlach@gmail.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+monpol">monpol</a></code>, <code><a href="#topic+monpol.fit">monpol.fit</a></code>, <code><a href="base.html#topic+qr">qr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>monpol.control(maxiter = 2000)
monpol.control(tolqr = 1e-10)
</code></pre>

<hr>
<h2 id='monpol.fit'>Monotone Polynomials</h2><span id='topic+monpol.fit'></span><span id='topic+SOSpol.fit'></span>

<h3>Description</h3>

<p>This is the basic computing engine called by <code><a href="#topic+monpol">monpol</a></code> used to fit
monotonic polynomials.  These should usually <em>not</em> be used
directly unless by experienced users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monpol.fit(x, y, w, K=1, start, trace = FALSE, plot.it = FALSE,
           control = monpol.control(),
           algorithm = c("Full", "Hawkins", "BCD", "CD1", "CD2"),
           ptype = c("Elphinstone", "EHH", "Penttila"),
           ctype = c("cge0", "c2"))
SOSpol.fit(x, y, w = NULL, deg.is.odd, K, start, a, b,
           monotone = c("increasing", "decreasing"),
           trace = FALSE, plot.it = FALSE, type,
           control = monpol.control())

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monpol.fit_+3A_x">x</code></td>
<td>
<p>vector containing the observed values for the regressor variable.</p>
</td></tr>
<tr><td><code id="monpol.fit_+3A_y">y</code></td>
<td>
<p>vector containing the observed values for the response
variable; should be of same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="monpol.fit_+3A_w">w</code></td>
<td>
<p>optional vector of weights; should be of the same length as
<code>x</code> if specified.</p>
</td></tr>
<tr><td><code id="monpol.fit_+3A_deg.is.odd">deg.is.odd</code>, <code id="monpol.fit_+3A_k">K</code></td>
<td>
<p>&ldquo;deg.is.odd&rdquo; is a logical, &ldquo;K&rdquo; is a
non negative integer. If &ldquo;deg.is.odd&rdquo; is <code>TRUE</code> then a
polynomial with highest power <code class="reqn">2K+1</code> will be fitted to 
the data, otherwise the highest order will be <code class="reqn">2K</code>.</p>
</td></tr>
<tr><td><code id="monpol.fit_+3A_start">start</code></td>
<td>
<p>optional starting value for the iterative fitting.</p>
</td></tr>
<tr><td><code id="monpol.fit_+3A_a">a</code>, <code id="monpol.fit_+3A_b">b</code>, <code id="monpol.fit_+3A_type">type</code></td>
<td>
<p>polynomial should be monotone on the interval from <code class="reqn">a</code>
to <code class="reqn">b</code>; &ldquo;type&rdquo; should be 0 if neither of the boundaries
is finite, 1 if <code class="reqn">a</code> if finite but not <code class="reqn">b</code> and 2 if both
boundaries are finite.</p>
</td></tr>
<tr><td><code id="monpol.fit_+3A_monotone">monotone</code></td>
<td>
<p>force the desired monotonicity in case the default
choice is wrong.</p>
</td></tr>
<tr><td><code id="monpol.fit_+3A_trace">trace</code></td>
<td>
<p>print out information about the progress of the
interative fitting at the start and then every <code>trace</code>
iterations.</p>
</td></tr>
<tr><td><code id="monpol.fit_+3A_plot.it">plot.it</code></td>
<td>
<p>plot the data and initial fit, then plot current fit
every <code>plot.it</code> iterations.</p>
</td></tr>
<tr><td><code id="monpol.fit_+3A_control">control</code></td>
<td>
<p>settings that control the iterative fit; see
<code><a href="#topic+monpol.control">monpol.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="monpol.fit_+3A_algorithm">algorithm</code></td>
<td>
<p>algorithm to be used; see <code><a href="#topic+monpol">monpol</a></code> for
details.</p>
</td></tr> 
<tr><td><code id="monpol.fit_+3A_ptype">ptype</code></td>
<td>
<p>parameterisation to be used; see <code><a href="#topic+monpol">monpol</a></code> for
details.</p>
</td></tr> 
<tr><td><code id="monpol.fit_+3A_ctype">ctype</code></td>
<td>
<p>parameterisation to be used; see <code><a href="#topic+monpol">monpol</a></code> for
details.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a list with components
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p>the fitted parameters.</p>
</td></tr>
<tr><td><code>grad</code></td>
<td>
<p>the gradient of the objective function at the fitted
parameters.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the coefficients of the fitted polynomial in the
&lsquo;beta&rsquo; parameterisation; on the fitted scale.</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p>the value of the objective function; on the fitted scale.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>indicates whether algorithm has converged.</p>
</td></tr>
<tr><td><code>ptype</code></td>
<td>
<p>input parameter <code>ptype</code>.</p>
</td></tr>
<tr><td><code>ctype</code></td>
<td>
<p>input parameter <code>cptype</code>.</p>
</td></tr>
<tr><td><code>beta.raw</code></td>
<td>
<p>the coefficients of the fitted polynomial in the
&lsquo;beta&rsquo; parameterisation; on the original scale.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted values; on the fitted scale.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals; on the fitted scale.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>input parameter <code>K</code>.</p>
</td></tr>
<tr><td><code>minx</code></td>
<td>
<p>the minimum value in the vector <code>x</code>.</p>
</td></tr>
<tr><td><code>sclx</code></td>
<td>
<p>the difference between the maximum and minimum values in
the vector <code>x</code>.</p>
</td></tr> 
<tr><td><code>miny</code></td>
<td>
<p>the minimum value in the vector <code>y</code>.</p>
</td></tr>
<tr><td><code>scly</code></td>
<td>
<p>the difference between the maximum and minimum values in
the vector <code>y</code>.</p>
</td></tr>
<tr><td><code>algorithm</code></td>
<td>
<p>input paramater <code>algorithm</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Berwin A Turlach &lt;Berwin.Turlach@gmail.com&gt;
</p>


<h3>References</h3>

<p>Murray, K., Müller, S. and Turlach, B.A. (2016). Fast and
flexible methods for monotone polynomial fitting, <em>Journal of
Statistical Computation and Simulation</em> <b>86</b>(15):
2946&ndash;2966, doi: <a href="http://doi.org/10.1080/00949655.2016.1139582">10.1080/00949655.2016.1139582</a>.
</p>
<p>Murray, K., Müller, S. and Turlach,
B.A. (2013). Revisiting fitting monotone polynomials to data,
<em>Computational Statistics</em> <b>28</b>(5):
1989&ndash;2005, doi: <a href="http://doi.org/10.1007/s00180-012-0390-5">10.1007/s00180-012-0390-5</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+monpol">monpol</a></code> which you should use for fitting monotonic
polynomials unless you know better.
</p>

<hr>
<h2 id='predict.monpol'>Predicting from Monotone Polynomial Fits</h2><span id='topic+predict.monpol'></span>

<h3>Description</h3>

<p><code>predict.monpol</code> produces predicted values, obtained by evaluating
the monotone polynomial in the frame <code>newdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'monpol'
predict(object, newdata, scale = c("original", "fitted"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.monpol_+3A_object">object</code></td>
<td>
<p>A &lsquo;monpol&rsquo; object.</p>
</td></tr>
<tr><td><code id="predict.monpol_+3A_newdata">newdata</code></td>
<td>
<p>A named list or data frame in which to look for variables with
which to predict.  If <code>newdata</code> is
missing the fitted values at the original data points are returned.</p>
</td></tr>
<tr><td><code id="predict.monpol_+3A_scale">scale</code></td>
<td>
<p>Predict values on the original scale of the data
or on the scale used during fitting.  Data in <code>newdata</code> is
assumed to be on the indicated scale.</p>
</td></tr>
<tr><td><code id="predict.monpol_+3A_...">...</code></td>
<td>
<p>Additional optionals arguments.  At present no optional
arguments are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code><a href="stats.html#topic+predict">predict</a></code> method for objects inheriting from
class <code>"monpol"</code>.
</p>


<h3>Value</h3>

<p><code>predict.monpol</code> produces a vector of predictions.
</p>


<h3>Author(s)</h3>

<p>Berwin A Turlach &lt;Berwin.Turlach@gmail.com&gt;
</p>

<hr>
<h2 id='print.monpol'>
Printing Monotone Polynomials
</h2><span id='topic+print.monpol'></span>

<h3>Description</h3>

<p><code>print</code> method for &lsquo;monpol&rsquo; objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'monpol'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.monpol_+3A_x">x</code></td>
<td>
<p>A &lsquo;monpol&rsquo; object.</p>
</td></tr>
<tr><td><code id="print.monpol_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.monpol_+3A_...">...</code></td>
<td>
<p>Additional optionals arguments.  At present only the
additional arguments for <a href="#topic+coef.monpol">coef.monpol</a> are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code><a href="base.html#topic+print">print</a></code> method for objects inheriting from
class <code>"monpol"</code>.
</p>


<h3>Value</h3>

<p><code>x</code> returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Berwin A Turlach &lt;Berwin.Turlach@gmail.com&gt;
</p>

<hr>
<h2 id='residuals.monpol'>
Extract Model Residuals
</h2><span id='topic+residuals.monpol'></span><span id='topic+resid.monpol'></span>

<h3>Description</h3>

<p><code>residuals</code> method for &lsquo;monpol&rsquo; objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'monpol'
residuals(object, scale = c("original", "fitted"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.monpol_+3A_object">object</code></td>
<td>
<p>A &lsquo;monpol&rsquo; object.</p>
</td></tr>
<tr><td><code id="residuals.monpol_+3A_scale">scale</code></td>
<td>
<p>Extract residuals on the original scale of the data
or on the scale used during fitting.</p>
</td></tr>
<tr><td><code id="residuals.monpol_+3A_...">...</code></td>
<td>
<p>Additional optionals arguments.  At present no optional
arguments are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code><a href="stats.html#topic+residuals">residuals</a></code> method for objects inheriting from
class <code>"monpol"</code>.
</p>


<h3>Value</h3>

<p>Residuals extracted from the model object <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Berwin A Turlach &lt;Berwin.Turlach@gmail.com&gt;
</p>

<hr>
<h2 id='w0'>Simulated w0 data used in Murray et al. (2013)</h2><span id='topic+w0'></span>

<h3>Description</h3>

<p>This data set gives simulated data from the function  
</p>
<p style="text-align: center;"><code class="reqn">y = 0.1x^3 + e</code>
</p>

<p>for <code class="reqn">e \sim N(0,0.01^2)</code> and <code class="reqn">x</code>
evenly spaced between -1 and 1. 
</p>


<h3>Format</h3>

<p>A data frame with 21 observations on the following 2 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Murray, K., Müller, S. and Turlach,
B.A. (2013). Revisiting fitting monotone polynomials to data,
<em>Computational Statistics</em> <b>28</b>(5):
1989&ndash;2005, doi: <a href="http://doi.org/10.1007/s00180-012-0390-5">10.1007/s00180-012-0390-5</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(w0)
plot(y~x, w0)
monpol(y~x, w0)
</code></pre>

<hr>
<h2 id='w2'>Simulated w2 data used in Murray et al. (2013)</h2><span id='topic+w2'></span>

<h3>Description</h3>

<p>Simulated data from the function 
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} = 4 \pi - x_i + \cos(x_i - \frac{\pi}{2}) + e_{ij}</code>
</p>

<p>for <code class="reqn">x_i = 0,1, \ldots , 12</code> ; <code class="reqn">n_i = 5</code> for <code class="reqn">i=0</code> and
<code class="reqn">n_i=3</code> otherwise; <code class="reqn">e_{ij} \sim N(0,0.5^2)</code>
</p>


<h3>Format</h3>

<p>A data frame with 41 observations on the following 2 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Murray, K., Müller, S. and Turlach,
B.A. (2013). Revisiting fitting monotone polynomials to data,
<em>Computational Statistics</em> <b>28</b>(5):
1989&ndash;2005, doi: <a href="http://doi.org/10.1007/s00180-012-0390-5">10.1007/s00180-012-0390-5</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(w2)
plot(y~x, w2)
monpol(y~x, w2)
monpol(y~x, w2, K=2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
