<!DOCTYPE html><html><head><title>Help for package precommit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {precommit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autoupdate'><p>Auto-update your hooks</p></a></li>
<li><a href='#call_and_capture'><p>Make a call with <code>system2()</code> and capture the effects.</p></a></li>
<li><a href='#call_precommit'><p>Call pre-commit</p></a></li>
<li><a href='#communicate_captured_call'><p>Communicate a captured call</p></a></li>
<li><a href='#copy_artifacts'><p>Copy some file to the test directory that must be present, but are not</p>
passed to the hook as a file argument.</a></li>
<li><a href='#diff_requires_run_roxygenize'><p>Check if we should run roxygen.</p></a></li>
<li><a href='#dirs_R.cache'><p>Create the path to the precommit R.cache cache</p></a></li>
<li><a href='#ensure_named'><p>Name the input</p></a></li>
<li><a href='#fallback_doc'><p>Fallback doc</p></a></li>
<li><a href='#generate_uninstalled_pkg_name'><p>Generate a random package name that is not installed</p></a></li>
<li><a href='#git_init'><p>Initiate git and configure it</p></a></li>
<li><a href='#hook_state_assert'><p>Check if the hook produced what you want</p></a></li>
<li><a href='#hook_state_create'><p>Create a hook state</p></a></li>
<li><a href='#install_impl'><p>Install pre-commit on your system with conda</p></a></li>
<li><a href='#install_precommit'><p>Install pre-commit on your system</p></a></li>
<li><a href='#local_test_setup'><p>Testing utilities</p></a></li>
<li><a href='#may_require_permanent_cache'><p>Issue a warning if {R.cache} uses temporary cache only</p></a></li>
<li><a href='#not_conda'><p>The testing environment does not use a conda environment if the env variable</p>
PRECOMMIT_INSTALLATION_METHOD is not 'conda'.</a></li>
<li><a href='#open_config'><p>Open pre-commit related files</p></a></li>
<li><a href='#path_derive_precommit_exec'><p>Derive the path to the pre-commit executable</p></a></li>
<li><a href='#path_derive_precommit_exec_conda'><p>Derive the path to the conda pre-commit executable</p></a></li>
<li><a href='#path_derive_precommit_exec_impl'><p>Find an executable</p></a></li>
<li><a href='#path_derive_precommit_exec_path'><p>Derive the pre-commit executable from the path</p></a></li>
<li><a href='#path_derive_precommit_exec_win_python3plus_base'><p>Where are executables on Windows for Python 3 and higher?</p></a></li>
<li><a href='#path_precommit_exec'><p>Locate the pre-commit executable</p></a></li>
<li><a href='#precommit_docopt'><p>Provide a singular interface for hook calls to docopt</p></a></li>
<li><a href='#precommit_executable_file'><p>The name of the executable file</p></a></li>
<li><a href='#precommit-package'><p>precommit: Pre-Commit Hooks</p></a></li>
<li><a href='#release_complete'><p>Complete the release</p></a></li>
<li><a href='#release_gh'><p>Create a new release on GitHub</p></a></li>
<li><a href='#rev_read'><p>Read the refs corresponding to a hooks repo</p></a></li>
<li><a href='#robust_purl'><p>Run <code>knitr::purl()</code>, setting the chunk option <code>purl</code> to <code>TRUE</code> if it's not</p>
already set to a literal value.</a></li>
<li><a href='#roxygen_assert_additional_dependencies'><p>Assert if all dependencies are installed</p></a></li>
<li><a href='#roxygenize_with_cache'><p>Roxygen and add a cache entry</p></a></li>
<li><a href='#run_test'><p>Run a test</p></a></li>
<li><a href='#run_test_impl'><p>Implement a test run</p></a></li>
<li><a href='#set_config_source'><p>Set the location to a config file</p></a></li>
<li><a href='#snippet_generate'><p>Generate code snippets</p></a></li>
<li><a href='#uninstall_precommit'><p>Uninstall pre-commit</p></a></li>
<li><a href='#update_impl'><p>Updates pre-commit on your system with conda</p></a></li>
<li><a href='#update_precommit'><p>Update the pre-commit executable</p></a></li>
<li><a href='#update_rev_in_config'><p>Updates the hook version ref of {precommit} in a <code>.pre-commit-config</code> file</p></a></li>
<li><a href='#use_ci'><p>Use continuous integration with pre-commit</p></a></li>
<li><a href='#use_precommit'><p>Get started with pre-commit</p></a></li>
<li><a href='#use_precommit_config'><p>Initiate a pre-commit config file</p></a></li>
<li><a href='#version_precommit'><p>Retrieve the version of the pre-commit executable used</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Pre-Commit Hooks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Lorenz Walthert</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lorenz Walthert &lt;lorenz.walthert@icloud.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Useful git hooks for R building on top of the multi-language
    framework 'pre-commit' for hook management. This package provides git
    hooks for common tasks like formatting files with 'styler' or spell
    checking as well as wrapper functions to access the 'pre-commit'
    executable.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lorenzwalthert.github.io/precommit/">https://lorenzwalthert.github.io/precommit/</a>,
<a href="https://github.com/lorenzwalthert/precommit">https://github.com/lorenzwalthert/precommit</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, fs, here, magrittr, purrr, R.cache, rlang, rprojroot,
withr, yaml</td>
</tr>
<tr>
<td>Suggests:</td>
<td>desc, docopt (&ge; 0.7.1), git2r, glue, knitr, lintr, mockery,
pkgload, pkgdown, reticulate (&ge; 1.16), rmarkdown, roxygen2,
rstudioapi, spelling, styler, testthat (&ge; 2.1.0), tibble,
usethis (&ge; 2.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>git</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-21 13:59:32 UTC; lorenz</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-21 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='autoupdate'>Auto-update your hooks</h2><span id='topic+autoupdate'></span>

<h3>Description</h3>

<p>Runs <a href="https://pre-commit.com/#pre-commit-autoupdate"><code style="white-space: pre;">&#8288;pre-commit autoupdate&#8288;</code></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoupdate(root = here::here())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoupdate_+3A_root">root</code></td>
<td>
<p>The path to the root directory of your project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The exit status from <code style="white-space: pre;">&#8288;pre-commit autoupdate&#8288;</code> (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
autoupdate()

## End(Not run)
</code></pre>

<hr>
<h2 id='call_and_capture'>Make a call with <code><a href="base.html#topic+system2">system2()</a></code> and capture the effects.</h2><span id='topic+call_and_capture'></span>

<h3>Description</h3>

<p>Make a call with <code><a href="base.html#topic+system2">system2()</a></code> and capture the effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_and_capture(command, args, ..., wait = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_and_capture_+3A_command">command</code></td>
<td>
<p>The command to issue. A character string of length one.</p>
</td></tr>
<tr><td><code id="call_and_capture_+3A_args">args</code></td>
<td>
<p>The command line arguments.</p>
</td></tr>
<tr><td><code id="call_and_capture_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="base.html#topic+system2">system2()</a></code>.</p>
</td></tr>
<tr><td><code id="call_and_capture_+3A_wait">wait</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+system2">system2()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with:
</p>

<ul>
<li><p> content of stderr
</p>
</li>
<li><p> content of stdout
</p>
</li>
<li><p> exit status
</p>
</li></ul>


<hr>
<h2 id='call_precommit'>Call pre-commit</h2><span id='topic+call_precommit'></span>

<h3>Description</h3>

<p>Either via <code style="white-space: pre;">&#8288;conda run&#8288;</code> (because conda env needs to be activated in general to
ensure an executable to runs successfully) or, if the installation method was
not conda, as a plain bash command.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_precommit(..., wait = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_precommit_+3A_...">...</code></td>
<td>
<p>Arguments passed to the command line call <code>pre-commit</code>.</p>
</td></tr>
<tr><td><code id="call_precommit_+3A_wait">wait</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+system2">base::system2()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='communicate_captured_call'>Communicate a captured call</h2><span id='topic+communicate_captured_call'></span>

<h3>Description</h3>

<p>Communicates a captured call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>communicate_captured_call(x, preamble = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="communicate_captured_call_+3A_x">x</code></td>
<td>
<p>The output of <code><a href="#topic+call_and_capture">call_and_capture()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='copy_artifacts'>Copy some file to the test directory that must be present, but are not
passed to the hook as a file argument.</h2><span id='topic+copy_artifacts'></span>

<h3>Description</h3>

<p>Copy some file to the test directory that must be present, but are not
passed to the hook as a file argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_artifacts(artifacts, tempdir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_artifacts_+3A_artifacts">artifacts</code></td>
<td>
<p>Artifacts to copy.</p>
</td></tr>
<tr><td><code id="copy_artifacts_+3A_tempdir">tempdir</code></td>
<td>
<p>The temporary directory.</p>
</td></tr>
</table>

<hr>
<h2 id='diff_requires_run_roxygenize'>Check if we should run roxygen.</h2><span id='topic+diff_requires_run_roxygenize'></span>

<h3>Description</h3>

<p>This is the case if a new or replaced/removed line contains a roxygen2
comment in a file that is staged.
This function is only exported for use in hook scripts, but it's not intended
to be called by the end-user directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_requires_run_roxygenize(root = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_requires_run_roxygenize_+3A_root">root</code></td>
<td>
<p>The root of the git repo.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of length 1.
</p>


<h3>See Also</h3>

<p>Other hook script helpers: 
<code><a href="#topic+dirs_R.cache">dirs_R.cache</a>()</code>,
<code><a href="#topic+may_require_permanent_cache">may_require_permanent_cache</a>()</code>,
<code><a href="#topic+precommit_docopt">precommit_docopt</a>()</code>,
<code><a href="#topic+robust_purl">robust_purl</a>()</code>,
<code><a href="#topic+roxygen_assert_additional_dependencies">roxygen_assert_additional_dependencies</a>()</code>,
<code><a href="#topic+roxygenize_with_cache">roxygenize_with_cache</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
diff_requires_run_roxygenize()

## End(Not run)
</code></pre>

<hr>
<h2 id='dirs_R.cache'>Create the path to the precommit R.cache cache</h2><span id='topic+dirs_R.cache'></span>

<h3>Description</h3>

<p>This function is only exported for use in hook scripts, but it's not intended
to be called by the end-user directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirs_R.cache(hook_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirs_R.cache_+3A_hook_id">hook_id</code></td>
<td>
<p>The id of the hook for which we want the relative cache
directory.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other hook script helpers: 
<code><a href="#topic+diff_requires_run_roxygenize">diff_requires_run_roxygenize</a>()</code>,
<code><a href="#topic+may_require_permanent_cache">may_require_permanent_cache</a>()</code>,
<code><a href="#topic+precommit_docopt">precommit_docopt</a>()</code>,
<code><a href="#topic+robust_purl">robust_purl</a>()</code>,
<code><a href="#topic+roxygen_assert_additional_dependencies">roxygen_assert_additional_dependencies</a>()</code>,
<code><a href="#topic+roxygenize_with_cache">roxygenize_with_cache</a>()</code>
</p>

<hr>
<h2 id='ensure_named'>Name the input</h2><span id='topic+ensure_named'></span>

<h3>Description</h3>

<p>Name the input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensure_named(x, candidate_name = NULL, f = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensure_named_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="ensure_named_+3A_f">f</code></td>
<td>
<p>How to transform the input <code>x</code> into a name.</p>
</td></tr>
</table>

<hr>
<h2 id='fallback_doc'>Fallback doc</h2><span id='topic+fallback_doc'></span>

<h3>Description</h3>

<p>Fallback doc
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="fallback_doc_+3A_root">root</code></td>
<td>
<p>The path to the root directory of your project.</p>
</td></tr>
</table>

<hr>
<h2 id='generate_uninstalled_pkg_name'>Generate a random package name that is not installed</h2><span id='topic+generate_uninstalled_pkg_name'></span>

<h3>Description</h3>

<p>Generate a random package name that is not installed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_uninstalled_pkg_name(n = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_uninstalled_pkg_name_+3A_n">n</code></td>
<td>
<p>The number of times we should try</p>
</td></tr>
</table>

<hr>
<h2 id='git_init'>Initiate git and configure it</h2><span id='topic+git_init'></span>

<h3>Description</h3>

<p>In particular, to avoid CRAN errors
<a href="https://github.com/lorenzwalthert/precommit/issues/320">lorenzwalthert/precommit#320</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>git_init(path = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="git_init_+3A_path">path</code></td>
<td>
<p>The root of the repo.</p>
</td></tr>
</table>

<hr>
<h2 id='hook_state_assert'>Check if the hook produced what you want</h2><span id='topic+hook_state_assert'></span>

<h3>Description</h3>

<p>Match the resulting state after the hook run with the expected state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hook_state_assert(
  path_candidate,
  tempdir,
  path_candidate_temp,
  file_transformer,
  path_stdout,
  path_stderr,
  expect_success,
  std_err,
  std_out,
  exit_status
)
</code></pre>

<hr>
<h2 id='hook_state_create'>Create a hook state</h2><span id='topic+hook_state_create'></span>

<h3>Description</h3>

<p>Runs the hook script to create a hook state, i.e. exit code, transformed
files and emitted messages of the hook run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hook_state_create(
  tempdir,
  path_candidate_temp,
  path_executable,
  cmd_args,
  path_stdout,
  path_stderr,
  env
)
</code></pre>

<hr>
<h2 id='install_impl'>Install pre-commit on your system with conda</h2><span id='topic+install_impl'></span>

<h3>Description</h3>

<p>Install pre-commit on your system with conda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_impl()
</code></pre>

<hr>
<h2 id='install_precommit'>Install pre-commit on your system</h2><span id='topic+install_precommit'></span>

<h3>Description</h3>

<p>This installs pre-commit in the conda environment r-precommit. It
will be available to use across different git repositories. To update,
refer to <code><a href="#topic+update_precommit">update_precommit()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_precommit(force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_precommit_+3A_force">force</code></td>
<td>
<p>Whether or not to force a re-installation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path to the pre-commit executable (invisibly).
</p>


<h3>See Also</h3>

<p>Other executable managers: 
<code><a href="#topic+uninstall_precommit">uninstall_precommit</a>()</code>,
<code><a href="#topic+update_precommit">update_precommit</a>()</code>,
<code><a href="#topic+version_precommit">version_precommit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
install_precommit()

## End(Not run)
</code></pre>

<hr>
<h2 id='local_test_setup'>Testing utilities</h2><span id='topic+local_test_setup'></span>

<h3>Description</h3>

<p>Similar to the <code>local_()</code> family from <code>{withr}</code>, this function creates a
temporary directory and optionally initiates git and pre-commit in it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_test_setup(
  git = TRUE,
  use_precommit = FALSE,
  package = FALSE,
  quiet = TRUE,
  autoupdate = FALSE,
  ...,
  .local_envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_test_setup_+3A_git">git</code></td>
<td>
<p>Whether or not to init git in the local directory.</p>
</td></tr>
<tr><td><code id="local_test_setup_+3A_use_precommit">use_precommit</code></td>
<td>
<p>Whether or not to <code><a href="#topic+use_precommit">use_precommit()</a></code>.</p>
</td></tr>
<tr><td><code id="local_test_setup_+3A_autoupdate">autoupdate</code></td>
<td>
<p>Whether or not to run <code><a href="#topic+autoupdate">autoupdate()</a></code> as part of this
fixture.</p>
</td></tr>
<tr><td><code id="local_test_setup_+3A_.local_envir">.local_envir</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[environment]&#8288;</code><br /> The environment to use for scoping.</p>
</td></tr>
</table>

<hr>
<h2 id='may_require_permanent_cache'>Issue a warning if {R.cache} uses temporary cache only</h2><span id='topic+may_require_permanent_cache'></span>

<h3>Description</h3>

<p>This function used to check if a permanent cache was available and issue a
warning if not, but since {R.cache} version <code style="white-space: pre;">&#8288;0.15.0&#8288;</code> (release date
2021-04-27), a permanent directory will be used automatically, so this check
if redundant. the function is kept in the package for compatibility, i.e.
if someone updates the R package {precommit} but not the hook revisions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>may_require_permanent_cache(temp_cache_is_enough = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="may_require_permanent_cache_+3A_temp_cache_is_enough">temp_cache_is_enough</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other hook script helpers: 
<code><a href="#topic+diff_requires_run_roxygenize">diff_requires_run_roxygenize</a>()</code>,
<code><a href="#topic+dirs_R.cache">dirs_R.cache</a>()</code>,
<code><a href="#topic+precommit_docopt">precommit_docopt</a>()</code>,
<code><a href="#topic+robust_purl">robust_purl</a>()</code>,
<code><a href="#topic+roxygen_assert_additional_dependencies">roxygen_assert_additional_dependencies</a>()</code>,
<code><a href="#topic+roxygenize_with_cache">roxygenize_with_cache</a>()</code>
</p>

<hr>
<h2 id='not_conda'>The testing environment does not use a conda environment if the env variable
PRECOMMIT_INSTALLATION_METHOD is not 'conda'.</h2><span id='topic+not_conda'></span>

<h3>Description</h3>

<p>The testing environment does not use a conda environment if the env variable
PRECOMMIT_INSTALLATION_METHOD is not 'conda'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not_conda()
</code></pre>

<hr>
<h2 id='open_config'>Open pre-commit related files</h2><span id='topic+open_config'></span><span id='topic+open_wordlist'></span>

<h3>Description</h3>

<p>Open pre-commit related files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>open_config(root = here::here())

open_wordlist(root = here::here())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="open_config_+3A_root">root</code></td>
<td>
<p>The path to the root directory of your project.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>open_config()</code>: opens the pre-commit config file.
</p>
</li>
<li> <p><code>open_wordlist()</code>: opens the the WORDLIST file for the check-spelling hook
in inst/WORDLIST.
</p>
</li></ul>



<h3>Value</h3>

<p><code>NULL</code> (invisibly). The function is called for its side effects.
</p>


<h3>See Also</h3>

<p>Other helpers: 
<code><a href="#topic+use_precommit">use_precommit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
open_config()

## End(Not run)
## Not run: 
open_wordlist()

## End(Not run)
</code></pre>

<hr>
<h2 id='path_derive_precommit_exec'>Derive the path to the pre-commit executable</h2><span id='topic+path_derive_precommit_exec'></span>

<h3>Description</h3>

<p>Returns &quot;&quot; if search was not successful, the path otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_derive_precommit_exec()
</code></pre>


<h3>Heuristic</h3>


<ul>
<li><p> First check if there is an executable on the <code style="white-space: pre;">&#8288;$PATH&#8288;</code> using
<code><a href="#topic+path_derive_precommit_exec_path">path_derive_precommit_exec_path()</a></code>
</p>
</li>
<li><p> Search os dependent for other possible locations for common installation
methods.
</p>
</li>
<li><p> If not, check if we can find one in a conda environment with
<code><a href="#topic+path_derive_precommit_exec_conda">path_derive_precommit_exec_conda()</a></code>. Do this last as it's the slowest.
</p>
</li></ul>


<hr>
<h2 id='path_derive_precommit_exec_conda'>Derive the path to the conda pre-commit executable</h2><span id='topic+path_derive_precommit_exec_conda'></span>

<h3>Description</h3>

<p>Only checks the conda env <code>r-precommit</code>.
If we can't find the executable, the empty string is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_derive_precommit_exec_conda()
</code></pre>

<hr>
<h2 id='path_derive_precommit_exec_impl'>Find an executable</h2><span id='topic+path_derive_precommit_exec_impl'></span>

<h3>Description</h3>

<p>Evaluates if the pre-commit executable exists in one or more candidate
locations. If so, return one, else return the empty string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_derive_precommit_exec_impl(candidate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_derive_precommit_exec_impl_+3A_candidate">candidate</code></td>
<td>
<p>A directory to check for the pre-commit executable. The
directory may also not exist.</p>
</td></tr>
</table>

<hr>
<h2 id='path_derive_precommit_exec_path'>Derive the pre-commit executable from the path</h2><span id='topic+path_derive_precommit_exec_path'></span>

<h3>Description</h3>

<p>Tries to derive the <code>pre-commit</code> executable from the <code style="white-space: pre;">&#8288;$PATH&#8288;</code>.
Returns <code>""</code> if no executable is found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_derive_precommit_exec_path()
</code></pre>

<hr>
<h2 id='path_derive_precommit_exec_win_python3plus_base'>Where are executables on Windows for Python 3 and higher?</h2><span id='topic+path_derive_precommit_exec_win_python3plus_base'></span>

<h3>Description</h3>

<p>Heuristic to determine the directory where the pre-commit executable on
Windows lives for Python versions 3 and above.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_derive_precommit_exec_win_python3plus_base()
</code></pre>

<hr>
<h2 id='path_precommit_exec'>Locate the pre-commit executable</h2><span id='topic+path_precommit_exec'></span><span id='topic+path_pre_commit_exec'></span>

<h3>Description</h3>

<p><code><a href="#topic+path_precommit_exec">path_precommit_exec()</a></code> simply reads the R option <code>precommit.executable</code>,
<code><a href="#topic+path_pre_commit_exec">path_pre_commit_exec()</a></code> is the old spelling and deprecated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_precommit_exec(check_if_exists = TRUE)

path_pre_commit_exec(check_if_exists = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_precommit_exec_+3A_check_if_exists">check_if_exists</code></td>
<td>
<p>Whether or not to make sure the returned path also
exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length one with the path to the pre-commit executable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+path_derive_precommit_exec">path_derive_precommit_exec()</a></code> for the heuristic to derive it from scratch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path_precommit_exec()

## End(Not run)
## Not run: 
path_pre_commit_exec()

## End(Not run)
</code></pre>

<hr>
<h2 id='precommit_docopt'>Provide a singular interface for hook calls to docopt</h2><span id='topic+precommit_docopt'></span>

<h3>Description</h3>

<p>docopt provides different processing for a single string
than an array/vector. As <code style="white-space: pre;">&#8288;"string"`` and &#8288;</code>c(&quot;string&quot;)'
are semantically equivalent in R, this can create problems
when a single parameter is provided. Thus, this function
wraps docopt to ensure that the args will always be
interpreted as a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precommit_docopt(doc, args = commandArgs(trailingOnly = TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precommit_docopt_+3A_doc">doc</code></td>
<td>
<p><code>character</code> vector with command line specification.</p>
</td></tr>
<tr><td><code id="precommit_docopt_+3A_args">args</code></td>
<td>
<p><code>character</code> vector of command line arguments.
Defaults to <code>commandArgs(trailingOnly=TRUE)</code>.</p>
</td></tr>
<tr><td><code id="precommit_docopt_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>docopt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only exported for use in hook scripts, but it's not intended
to be called by the end-user directly.
</p>


<h3>See Also</h3>

<p>Other hook script helpers: 
<code><a href="#topic+diff_requires_run_roxygenize">diff_requires_run_roxygenize</a>()</code>,
<code><a href="#topic+dirs_R.cache">dirs_R.cache</a>()</code>,
<code><a href="#topic+may_require_permanent_cache">may_require_permanent_cache</a>()</code>,
<code><a href="#topic+robust_purl">robust_purl</a>()</code>,
<code><a href="#topic+roxygen_assert_additional_dependencies">roxygen_assert_additional_dependencies</a>()</code>,
<code><a href="#topic+roxygenize_with_cache">roxygenize_with_cache</a>()</code>
</p>

<hr>
<h2 id='precommit_executable_file'>The name of the executable file</h2><span id='topic+precommit_executable_file'></span>

<h3>Description</h3>

<p>This is platform dependent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precommit_executable_file()
</code></pre>

<hr>
<h2 id='precommit-package'>precommit: Pre-Commit Hooks</h2><span id='topic+precommit'></span><span id='topic+precommit-package'></span>

<h3>Description</h3>

<p>Useful git hooks for R building on top of the multi-language framework 'pre-commit' for hook management. This package provides git hooks for common tasks like formatting files with 'styler' or spell checking as well as wrapper functions to access the 'pre-commit' executable.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://lorenzwalthert.github.io/precommit/">https://lorenzwalthert.github.io/precommit/</a>
</p>
</li>
<li> <p><a href="https://github.com/lorenzwalthert/precommit">https://github.com/lorenzwalthert/precommit</a>
</p>
</li></ul>


<hr>
<h2 id='release_complete'>Complete the release</h2><span id='topic+release_complete'></span>

<h3>Description</h3>

<p>Bumps the version to devel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>release_complete(ask = TRUE, is_cran = ask, tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="release_complete_+3A_tag">tag</code></td>
<td>
<p>The tag to push. <code>NULL</code> will derive the tag from <code>DESCRIPTION</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='release_gh'>Create a new release on GitHub</h2><span id='topic+release_gh'></span>

<h3>Description</h3>

<p>This must be done <strong>before</strong> a CRAN release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>release_gh(bump = "dev", is_cran = bump != "dev")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="release_gh_+3A_bump">bump</code></td>
<td>
<p>The bump increment, either &quot;dev&quot;, &quot;patch&quot;, &quot;minor&quot; or &quot;major&quot;.</p>
</td></tr>
<tr><td><code id="release_gh_+3A_is_cran">is_cran</code></td>
<td>
<p>Is this release a CRAN release?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does the following:
</p>

<ul>
<li><p> bump description.
</p>
</li>
<li><p> update default config in inst/
</p>
</li>
<li><p> commit
</p>
</li>
<li><p> git tag
</p>
</li>
<li><p> run <code>inst/hooks/local/consistent-release-tag.R</code> hook with &ndash;release-mode (passing args to hooks
not possible interactively, hence we run in advance).
</p>
</li>
<li><p> commit and push with skipping <code>inst/hooks/local/consistent-release-tag.R</code>.
</p>
</li>
<li><p> autoupdate own config file
</p>
</li>
<li><p> bump description with dev
</p>
</li>
<li><p> commit and push DESCRIPTION and .pre-commit-config.yaml
</p>
</li></ul>



<h3>CRAN release</h3>

<p>If <code>is_cran</code> is <code>TRUE</code>, the workflow is changed slightly:
</p>

<ul>
<li><p> push to release branch, not main.
</p>
</li>
<li><p> doesn't run <code><a href="#topic+release_complete">release_complete()</a></code>. This must be done manually after accepted
on CRAN.
</p>
</li></ul>


<hr>
<h2 id='rev_read'>Read the refs corresponding to a hooks repo</h2><span id='topic+rev_read'></span>

<h3>Description</h3>

<p>Read the refs corresponding to a hooks repo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rev_read(path = ".pre-commit-config.yaml", repo = hooks_repo)
</code></pre>

<hr>
<h2 id='robust_purl'>Run <code><a href="knitr.html#topic+knit">knitr::purl()</a></code>, setting the chunk option <code>purl</code> to <code>TRUE</code> if it's not
already set to a literal value.</h2><span id='topic+robust_purl'></span>

<h3>Description</h3>

<p>This function is only exported for use in hook scripts, but it's not intended
to be called by the end-user directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust_purl(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robust_purl_+3A_path">path</code></td>
<td>
<p>The path to the file you want to <code><a href="knitr.html#topic+knit">knitr::purl()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other hook script helpers: 
<code><a href="#topic+diff_requires_run_roxygenize">diff_requires_run_roxygenize</a>()</code>,
<code><a href="#topic+dirs_R.cache">dirs_R.cache</a>()</code>,
<code><a href="#topic+may_require_permanent_cache">may_require_permanent_cache</a>()</code>,
<code><a href="#topic+precommit_docopt">precommit_docopt</a>()</code>,
<code><a href="#topic+roxygen_assert_additional_dependencies">roxygen_assert_additional_dependencies</a>()</code>,
<code><a href="#topic+roxygenize_with_cache">roxygenize_with_cache</a>()</code>
</p>

<hr>
<h2 id='roxygen_assert_additional_dependencies'>Assert if all dependencies are installed</h2><span id='topic+roxygen_assert_additional_dependencies'></span>

<h3>Description</h3>

<p>This function is only exported for use in hook scripts, but it's not intended
to be called by the end-user directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roxygen_assert_additional_dependencies()
</code></pre>


<h3>See Also</h3>

<p>Other hook script helpers: 
<code><a href="#topic+diff_requires_run_roxygenize">diff_requires_run_roxygenize</a>()</code>,
<code><a href="#topic+dirs_R.cache">dirs_R.cache</a>()</code>,
<code><a href="#topic+may_require_permanent_cache">may_require_permanent_cache</a>()</code>,
<code><a href="#topic+precommit_docopt">precommit_docopt</a>()</code>,
<code><a href="#topic+robust_purl">robust_purl</a>()</code>,
<code><a href="#topic+roxygenize_with_cache">roxygenize_with_cache</a>()</code>
</p>

<hr>
<h2 id='roxygenize_with_cache'>Roxygen and add a cache entry</h2><span id='topic+roxygenize_with_cache'></span>

<h3>Description</h3>

<p>This function is only exported for use in hook scripts, but it's not intended
to be called by the end-user directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roxygenize_with_cache(key, dirs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roxygenize_with_cache_+3A_key">key</code></td>
<td>
<p>An optional object from which a hexadecimal hash
code will be generated and appended to the filename.</p>
</td></tr>
<tr><td><code id="roxygenize_with_cache_+3A_dirs">dirs</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> <code><a href="base.html#topic+vector">vector</a></code> constituting the path to the
cache subdirectory (of the <em>cache root directory</em>
as returned by <code><a href="R.cache.html#topic+getCacheRootPath">getCacheRootPath</a></code>()) to be used.
If <code><a href="base.html#topic+NULL">NULL</a></code>, the path will be the cache root path.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other hook script helpers: 
<code><a href="#topic+diff_requires_run_roxygenize">diff_requires_run_roxygenize</a>()</code>,
<code><a href="#topic+dirs_R.cache">dirs_R.cache</a>()</code>,
<code><a href="#topic+may_require_permanent_cache">may_require_permanent_cache</a>()</code>,
<code><a href="#topic+precommit_docopt">precommit_docopt</a>()</code>,
<code><a href="#topic+robust_purl">robust_purl</a>()</code>,
<code><a href="#topic+roxygen_assert_additional_dependencies">roxygen_assert_additional_dependencies</a>()</code>
</p>

<hr>
<h2 id='run_test'>Run a test</h2><span id='topic+run_test'></span>

<h3>Description</h3>

<p>Tests for the executables used as pre-commit hooks via <code>entrypoint</code> in
<code>.pre-commit-config.yaml</code>. Set's the env variable <code>R_PRECOMMIT_HOOK_ENV</code> to
when running.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_test(
  hook_name,
  file_name = hook_name,
  suffix = ".R",
  std_err = NULL,
  std_out = NULL,
  cmd_args = NULL,
  artifacts = NULL,
  file_transformer = function(files) files,
  env = character(),
  expect_success = is.null(std_err),
  read_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_test_+3A_hook_name">hook_name</code></td>
<td>
<p>The name of the hook in <code style="white-space: pre;">&#8288;inst/hooks/exported/&#8288;</code>, without
file extension.</p>
</td></tr>
<tr><td><code id="run_test_+3A_file_name">file_name</code></td>
<td>
<p>The file to test in <code style="white-space: pre;">&#8288;tests/in&#8288;</code> (without extension). Can be
a named vector of length one where the name is the target location relative
to the temporary location and the value is the source of the file.</p>
</td></tr>
<tr><td><code id="run_test_+3A_suffix">suffix</code></td>
<td>
<p>The suffix of <code>file_name</code>.</p>
</td></tr>
<tr><td><code id="run_test_+3A_std_err">std_err</code></td>
<td>
<p>An expected error message. If no error is expected, this
can be <code>NULL</code>. In that case, the <code>comparator</code> is applied.</p>
</td></tr>
<tr><td><code id="run_test_+3A_std_out">std_out</code></td>
<td>
<p>The expected stdout message. If <code>NULL</code>, this check is omitted.</p>
</td></tr>
<tr><td><code id="run_test_+3A_cmd_args">cmd_args</code></td>
<td>
<p>More arguments passed to the file. Pre-commit handles it as
described <a href="https://pre-commit.com/#arguments-pattern-in-hooks">here</a>.</p>
</td></tr>
<tr><td><code id="run_test_+3A_artifacts">artifacts</code></td>
<td>
<p>Path with artifact files to copy to the temp directory root where
the test is run. If you don't target the root, this can be a named vector
of length one where the name is the target location relative to the
temporary location and the value is the source of the file.</p>
</td></tr>
<tr><td><code id="run_test_+3A_file_transformer">file_transformer</code></td>
<td>
<p>A function that takes the file names as input and is
ran right before the hook script is invoked, returning the path to the
files, potentially modified (if renamed). This can be useful if you need to
make in-place modifications to the file, e.g. to test hooks that operate on
<code>.Rprofile</code>. You can't have different names for different tests on that
file because it must be called <code>.Rprofile</code> all the time. And R CMD check
seems to remove hidden files, so we must also rename it. The transformation
is also applied to a temp copy of the reference file before a comparison is
made.</p>
</td></tr>
<tr><td><code id="run_test_+3A_env">env</code></td>
<td>
<p>The environment variables to set with <code><a href="base.html#topic+system2">base::system2()</a></code>.</p>
</td></tr>
<tr><td><code id="run_test_+3A_expect_success">expect_success</code></td>
<td>
<p>Whether or not an exit code 0 is expected. This can
be derived from <code>std_err</code>, but sometimes, non-empty stderr does not mean
error, but just a message.</p>
</td></tr>
<tr><td><code id="run_test_+3A_read_only">read_only</code></td>
<td>
<p>If <code>TRUE</code> and <code>artifacts</code> are not <code>NULL</code>, then assert that hook
did not modify the artifacts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two potential outcomes of a hooks are pass or fail. This is reflected on the
level of the executable: Fail means the executable fails or the file is
changed. Pass means the executable succeeds and the file is unchanged.
We check if the executable passes as follows:
</p>

<ul>
<li><p> If we expect success (by setting <code>std_err</code> to <code>NULL</code>), we make sure
nothing was written to sterr and the file content does not change.
</p>
</li>
<li><p> If we expect failure, it can be due to changed file or due to failed
executable. To check for failed executable, we set <code>std_err</code> to
the message we expect. To check changed file content, we set <code>std_err</code> to
<code>NA</code>.
</p>
</li></ul>


<hr>
<h2 id='run_test_impl'>Implement a test run</h2><span id='topic+run_test_impl'></span>

<h3>Description</h3>

<p>Implement a test run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_test_impl(
  path_executable,
  path_candidate,
  std_err,
  std_out,
  cmd_args,
  artifacts,
  file_transformer,
  env,
  expect_success,
  read_only
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_test_impl_+3A_path_executable">path_executable</code></td>
<td>
<p>The path to the executable bash script.</p>
</td></tr>
<tr><td><code id="run_test_impl_+3A_path_candidate">path_candidate</code></td>
<td>
<p>The path to a file that should be modified by the
executable.</p>
</td></tr>
<tr><td><code id="run_test_impl_+3A_std_err">std_err</code></td>
<td>
<p>An expected error message. If no error is expected, this
can be <code>NULL</code>. In that case, the <code>comparator</code> is applied.</p>
</td></tr>
<tr><td><code id="run_test_impl_+3A_std_out">std_out</code></td>
<td>
<p>The expected stdout message. If <code>NULL</code>, this check is omitted.</p>
</td></tr>
<tr><td><code id="run_test_impl_+3A_cmd_args">cmd_args</code></td>
<td>
<p>More arguments passed to the file. Pre-commit handles it as
described <a href="https://pre-commit.com/#arguments-pattern-in-hooks">here</a>.</p>
</td></tr>
<tr><td><code id="run_test_impl_+3A_artifacts">artifacts</code></td>
<td>
<p>Path with artifact files to copy to the temp directory root where
the test is run. If you don't target the root, this can be a named vector
of length one where the name is the target location relative to the
temporary location and the value is the source of the file.</p>
</td></tr>
<tr><td><code id="run_test_impl_+3A_env">env</code></td>
<td>
<p>The environment variables to set with <code><a href="base.html#topic+system2">base::system2()</a></code>.</p>
</td></tr>
<tr><td><code id="run_test_impl_+3A_expect_success">expect_success</code></td>
<td>
<p>Whether or not an exit code 0 is expected. This can
be derived from <code>std_err</code>, but sometimes, non-empty stderr does not mean
error, but just a message.</p>
</td></tr>
<tr><td><code id="run_test_impl_+3A_read_only">read_only</code></td>
<td>
<p>If <code>TRUE</code> and <code>artifacts</code> are not <code>NULL</code>, then assert that hook
did not modify the artifacts.</p>
</td></tr>
</table>

<hr>
<h2 id='set_config_source'>Set the location to a config file</h2><span id='topic+set_config_source'></span>

<h3>Description</h3>

<p>If a remote location is specified, the file is downloaded to a temporary
location and the path to this location is returned. If <code>NULL</code>, we'll resort
to a default config. We'll perform some checks on the existence of the file
too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_config_source(config_source, root, verbose = TRUE)
</code></pre>

<hr>
<h2 id='snippet_generate'>Generate code snippets</h2><span id='topic+snippet_generate'></span>

<h3>Description</h3>

<p>Utility function to generate code snippets:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snippet_generate(
  snippet = "",
  open = rstudioapi::isAvailable(),
  root = here::here()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snippet_generate_+3A_snippet">snippet</code></td>
<td>
<p>Name of the snippet.</p>
</td></tr>
<tr><td><code id="snippet_generate_+3A_open">open</code></td>
<td>
<p>Whether or not to open the .pre-commit-config.yaml. The default
is <code>TRUE</code> when working in  RStudio. Otherwise, we recommend manually opening
the file.</p>
</td></tr>
<tr><td><code id="snippet_generate_+3A_root">root</code></td>
<td>
<p>The path to the root directory of your project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently supported:
</p>

<ul>
<li><p> additional-deps-roxygenize: Code to paste into
<code>.pre-commit-config.yaml</code> for the additional dependencies required by
the roxygenize hook.
</p>
</li></ul>


<hr>
<h2 id='uninstall_precommit'>Uninstall pre-commit</h2><span id='topic+uninstall_precommit'></span>

<h3>Description</h3>

<p>Remove pre-commit from a repo or from your system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uninstall_precommit(scope = "repo", ask = "user", root = here::here())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uninstall_precommit_+3A_scope">scope</code></td>
<td>
<p>Either &quot;repo&quot; or &quot;user&quot;. &quot;repo&quot; removes pre-commit from your
project, but you will be able to use it in other projects. With &quot;user&quot;,
you remove the pre-commit executable in the virtual python environment
r-precommit so it won't be available in any project. When you want to do
the latter, you should first do the former.</p>
</td></tr>
<tr><td><code id="uninstall_precommit_+3A_ask">ask</code></td>
<td>
<p>Either &quot;user&quot;, &quot;repo&quot; or &quot;none&quot; to determine in which case
a prompt should show up to let the user confirm his action.</p>
</td></tr>
<tr><td><code id="uninstall_precommit_+3A_root">root</code></td>
<td>
<p>The path to the root directory of your project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly). The function is called for its side effects.
</p>


<h3>See Also</h3>

<p>Other executable managers: 
<code><a href="#topic+install_precommit">install_precommit</a>()</code>,
<code><a href="#topic+update_precommit">update_precommit</a>()</code>,
<code><a href="#topic+version_precommit">version_precommit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
uninstall_precommit()

## End(Not run)
</code></pre>

<hr>
<h2 id='update_impl'>Updates pre-commit on your system with conda</h2><span id='topic+update_impl'></span>

<h3>Description</h3>

<p>Updates pre-commit on your system with conda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_impl()
</code></pre>

<hr>
<h2 id='update_precommit'>Update the pre-commit executable</h2><span id='topic+update_precommit'></span>

<h3>Description</h3>

<p>Updates the conda installation of the upstream framework pre-commit. This
does not update the R package <code>{precommit}</code> and only works if you choose
conda as your installation method. If you have problems updating, we suggest
deleting the conda environment <code>r-precommit</code> (if you are sure nothing but
pre-commit depend on it) and do a fresh installation with
<code><a href="#topic+install_precommit">install_precommit()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_precommit()
</code></pre>


<h3>Value</h3>

<p>The exit status of the conda update command (invisible).
</p>


<h3>See Also</h3>

<p>Other executable managers: 
<code><a href="#topic+install_precommit">install_precommit</a>()</code>,
<code><a href="#topic+uninstall_precommit">uninstall_precommit</a>()</code>,
<code><a href="#topic+version_precommit">version_precommit</a>()</code>
</p>

<hr>
<h2 id='update_rev_in_config'>Updates the hook version ref of {precommit} in a <code>.pre-commit-config</code> file</h2><span id='topic+update_rev_in_config'></span>

<h3>Description</h3>

<p>This is useful in the release process because when releasing a new version,
we must make sure the template that is used with <code>precommit::use_precommit()</code>
is up-to date. Also, after we pushed the release to GitHub, we want to update
the hooks from our own hook repo in the source repo too (we could also do that
with <code>precommit::autoupdate()</code> though).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_rev_in_config(new_version, path = "inst/pre-commit-config.yaml")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_rev_in_config_+3A_new_version">new_version</code></td>
<td>
<p>The version string of the new version.</p>
</td></tr>
<tr><td><code id="update_rev_in_config_+3A_path">path</code></td>
<td>
<p>The path to a pre-commit config file.</p>
</td></tr>
</table>

<hr>
<h2 id='use_ci'>Use continuous integration with pre-commit</h2><span id='topic+use_ci'></span>

<h3>Description</h3>

<p>Sets up continuous integration, or prompts the user to do it manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_ci(
  ci = getOption("precommit.ci", "native"),
  force = FALSE,
  open = rstudioapi::isAvailable(),
  root = here::here()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_ci_+3A_ci">ci</code></td>
<td>
<p>Specifies which continuous integration service to use. See
<code>vignette("ci", package = "precommit")</code> for details. Defaults to
<code>getOption("precommit.ci", "native")</code>, which is set to
<code>"native"</code> on package loading (if unset). <code>"native"</code> sets up
<a href="https://pre-commit.ci">pre-commit.ci</a>. Alternatively, <code>"gha"</code> can be used
to set up <a href="https://github.com/features/actions">GitHub Actions</a>. Set value
to <code>NA</code> if you don't want to use a continuous integration.</p>
</td></tr>
<tr><td><code id="use_ci_+3A_force">force</code></td>
<td>
<p>Whether or not to overwrite an existing ci config file (only
relevant for <code>ci = "gha"</code>).</p>
</td></tr>
<tr><td><code id="use_ci_+3A_open">open</code></td>
<td>
<p>Whether or not to open <a href="https://pre-commit.ci">pre-commit.ci</a>
(if <code>ci = "native"</code>). The default is <code>TRUE</code> when working in RStudio.</p>
</td></tr>
<tr><td><code id="use_ci_+3A_root">root</code></td>
<td>
<p>The path to the root directory of your project.</p>
</td></tr>
</table>

<hr>
<h2 id='use_precommit'>Get started with pre-commit</h2><span id='topic+use_precommit'></span>

<h3>Description</h3>

<p>This function sets up pre-commit for your git repo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_precommit(
  config_source = getOption("precommit.config_source"),
  force = FALSE,
  legacy_hooks = "forbid",
  open = rstudioapi::isAvailable(),
  install_hooks = TRUE,
  ci = getOption("precommit.ci", "native"),
  autoupdate = install_hooks,
  root = here::here()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_precommit_+3A_config_source">config_source</code></td>
<td>
<p>Path or URL to a <code>.pre-commit-config.yaml</code>. This
config file will be hard-copied into <code>root</code>. If <code>NULL</code>, we check if
<code>root</code> is a package or project directory using
<code><a href="rprojroot.html#topic+find_root_file">rprojroot::find_package_root_file()</a></code>, and resort to an appropriate default
config. See section 'Copying an existing config file'.</p>
</td></tr>
<tr><td><code id="use_precommit_+3A_force">force</code></td>
<td>
<p>Whether or not to overwrite an existing ci config file (only
relevant for <code>ci = "gha"</code>).</p>
</td></tr>
<tr><td><code id="use_precommit_+3A_legacy_hooks">legacy_hooks</code></td>
<td>
<p>How to treat hooks already in the repo which are not
managed by pre-commit. &quot;forbid&quot;, the default, will cause  <code>use_precommit()</code>
to fail if there are such hooks. &quot;allow&quot; will run these along with
pre-commit. &quot;remove&quot; will delete them.</p>
</td></tr>
<tr><td><code id="use_precommit_+3A_open">open</code></td>
<td>
<p>Whether or not to open <code>.pre-commit-config.yaml</code> after
it's been placed in your repo as well as
<a href="https://pre-commit.ci">pre-commit.ci</a> (if <code>ci = "native"</code>). The default is
<code>TRUE</code> when working in RStudio.</p>
</td></tr>
<tr><td><code id="use_precommit_+3A_install_hooks">install_hooks</code></td>
<td>
<p>Whether to install environments for all available hooks.
If <code>FALSE</code>, environments are installed with first commit.</p>
</td></tr>
<tr><td><code id="use_precommit_+3A_ci">ci</code></td>
<td>
<p>Specifies which continuous integration service to use. See
<code>vignette("ci", package = "precommit")</code> for details. Defaults to
<code>getOption("precommit.ci", "native")</code>, which is set to
<code>"native"</code> on package loading (if unset). <code>"native"</code> sets up
<a href="https://pre-commit.ci">pre-commit.ci</a>. Alternatively, <code>"gha"</code> can be used
to set up <a href="https://github.com/features/actions">GitHub Actions</a>. Set value
to <code>NA</code> if you don't want to use a continuous integration.</p>
</td></tr>
<tr><td><code id="use_precommit_+3A_autoupdate">autoupdate</code></td>
<td>
<p>Whether or not to run <code><a href="#topic+autoupdate">autoupdate()</a></code> as part of this
function call.</p>
</td></tr>
<tr><td><code id="use_precommit_+3A_root">root</code></td>
<td>
<p>The path to the root directory of your project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly). The function is called for its side effects.
</p>


<h3>When to call this function?</h3>


<ul>
<li><p> You want to add pre-commit support to a git repo which does not have a
<code>.pre-commit-config.yaml</code>. This involves adding
a pre-commit config file and making sure git will call the hooks before
the next commit.
</p>
</li>
<li><p> You cloned a repo that has a <code>.pre-commit-config.yaml</code> already. You need
to make sure git calls the hooks before the next commit.
</p>
</li></ul>



<h3>What does the function do?</h3>


<ul>
<li><p> Sets up a template <code>.pre-commit-config.yaml</code>.
</p>
</li>
<li><p> Autoupdates the template to make sure you get the latest versions of the
hooks.
</p>
</li>
<li><p> Installs the pre-commit script along with the hook environments with
<code style="white-space: pre;">&#8288;$ pre-commit install --install-hooks&#8288;</code>.
</p>
</li>
<li><p> Opens the config file if RStudio is running.
</p>
</li></ul>



<h3>Copying an existing config file</h3>

<p>You can use an existing <code>.pre-commit-config.yaml</code> file when initializing
pre-commit with <code><a href="#topic+use_precommit">use_precommit()</a></code> using the argument <code>config_source</code> to
copy an existing config file into your repo. This argument defaults to the R
option <code>precommit.config_source</code>, so you may want to set this option in
your <code>.Rprofile</code> for convenience. Note that this is <strong>not</strong> equivalent to the
<code>--config</code> option in the CLI command <code style="white-space: pre;">&#8288;pre-commit install&#8288;</code> and similar,
which do <em>not</em> copy a config file into a project root (and allow to put it
under version control), but rather link it in some more or less transparent
way.
</p>


<h3>See Also</h3>

<p>Other helpers: 
<code><a href="#topic+open_config">open_config</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
use_precommit()

## End(Not run)
</code></pre>

<hr>
<h2 id='use_precommit_config'>Initiate a pre-commit config file</h2><span id='topic+use_precommit_config'></span>

<h3>Description</h3>

<p>Initiate a pre-commit config file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_precommit_config(
  config_source = getOption("precommit.config_source"),
  force = FALSE,
  open = rstudioapi::isAvailable(),
  verbose = FALSE,
  root = here::here()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_precommit_config_+3A_config_source">config_source</code></td>
<td>
<p>Path or URL to a <code>.pre-commit-config.yaml</code>. This
config file will be hard-copied into <code>root</code>. If <code>NULL</code>, we check if
<code>root</code> is a package or project directory using
<code><a href="rprojroot.html#topic+find_root_file">rprojroot::find_package_root_file()</a></code>, and resort to an appropriate default
config. See section 'Copying an existing config file'.</p>
</td></tr>
<tr><td><code id="use_precommit_config_+3A_force">force</code></td>
<td>
<p>Whether to replace an existing config file.</p>
</td></tr>
<tr><td><code id="use_precommit_config_+3A_open">open</code></td>
<td>
<p>Whether or not to open the .pre-commit-config.yaml after
it's been placed in your repo. The default is <code>TRUE</code> when working in
RStudio. Otherwise, we recommend manually inspecting the file.</p>
</td></tr>
<tr><td><code id="use_precommit_config_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to communicate what's happening.</p>
</td></tr>
<tr><td><code id="use_precommit_config_+3A_root">root</code></td>
<td>
<p>The path to the root directory of your project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of length one with the path to the config file used.
</p>


<h3>Copying an existing config file</h3>

<p>You can use an existing <code>.pre-commit-config.yaml</code> file when initializing
pre-commit with <code><a href="#topic+use_precommit">use_precommit()</a></code> using the argument <code>config_source</code> to
copy an existing config file into your repo. This argument defaults to the R
option <code>precommit.config_source</code>, so you may want to set this option in
your <code>.Rprofile</code> for convenience. Note that this is <strong>not</strong> equivalent to the
<code>--config</code> option in the CLI command <code style="white-space: pre;">&#8288;pre-commit install&#8288;</code> and similar,
which do <em>not</em> copy a config file into a project root (and allow to put it
under version control), but rather link it in some more or less transparent
way.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
use_precommit_config()

## End(Not run)
</code></pre>

<hr>
<h2 id='version_precommit'>Retrieve the version of the pre-commit executable used</h2><span id='topic+version_precommit'></span>

<h3>Description</h3>

<p>Retrieves the version of the pre-commit executable used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>version_precommit()
</code></pre>


<h3>See Also</h3>

<p>Other executable managers: 
<code><a href="#topic+install_precommit">install_precommit</a>()</code>,
<code><a href="#topic+uninstall_precommit">uninstall_precommit</a>()</code>,
<code><a href="#topic+update_precommit">update_precommit</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
