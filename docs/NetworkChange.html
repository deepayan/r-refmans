<!DOCTYPE html><html><head><title>Help for package NetworkChange</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NetworkChange}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BreakDiagnostic'><p>Detect a break number using different metrics</p></a></li>
<li><a href='#BreakPointLoss'><p>Compute the Average Loss of Hidden State Changes from Expected Break Points</p></a></li>
<li><a href='#drawPostAnalysis'><p>Plot of latent node cluster</p></a></li>
<li><a href='#drawRegimeRaw'><p>Plot of network by hidden regime</p></a></li>
<li><a href='#kmeansU'><p>K-mean clustering of latent node positions</p></a></li>
<li><a href='#MajorAlly'><p>Major Power Alliance Network (1816 - 2012)</p></a></li>
<li><a href='#MakeBlockNetworkChange'><p>Build a synthetic block-structured temporal data with breaks</p></a></li>
<li><a href='#MarginalCompare'><p>Compare Log Marginal Likelihood</p></a></li>
<li><a href='#multiplot'><p>Printing multiple ggplots in oone file</p></a></li>
<li><a href='#NetworkChange'><p>Changepoint analysis of a degree-corrected multilinear tensor model</p></a></li>
<li><a href='#NetworkChangeRobust'><p>Changepoint analysis of a degree-corrected multilinear tensor model with t-distributed error</p></a></li>
<li><a href='#NetworkStatic'><p>Degree-corrected multilinear tensor model</p></a></li>
<li><a href='#plotContour'><p>Contour plot of latent node positions</p></a></li>
<li><a href='#plotnetarray'><p>Plot of network array data</p></a></li>
<li><a href='#plotU'><p>Plot of latent node positions</p></a></li>
<li><a href='#plotV'><p>Plot of layer-specific network generation rules.</p></a></li>
<li><a href='#PostwarAlly'><p>Postwar Alliance Network (1846 - 2012)</p></a></li>
<li><a href='#startS'><p>Sample a starting value of hidden states</p></a></li>
<li><a href='#startUV'><p>Starting values of U and V</p></a></li>
<li><a href='#ULUstateSample'><p>Hidden State Sampler</p></a></li>
<li><a href='#ULUstateSample.mpfr'><p>Hidden State Sampler with precision</p></a></li>
<li><a href='#updateb'><p>Update time-constant regression parameters</p></a></li>
<li><a href='#updatebm'><p>Update regime-changing regression parameters</p></a></li>
<li><a href='#updateP'><p>Update transition matrix</p></a></li>
<li><a href='#updateS'><p>Update latent states</p></a></li>
<li><a href='#updates2m'><p>Update regime-specific variance</p></a></li>
<li><a href='#updateU'><p>Update time-constant latent node positions</p></a></li>
<li><a href='#updateUm'><p>Regime-specific latent node positions</p></a></li>
<li><a href='#updateV'><p>Update layer specific network generation rules</p></a></li>
<li><a href='#updateVm'><p>Update V from a change-point network process</p></a></li>
<li><a href='#WaicCompare'><p>Compare WAIC</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Package for Network Changepoint Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-03-03 14:17:31 UTC</td>
</tr>
<tr>
<td>Author:</td>
<td>Jong Hee Park [aut,cre], Yunkyu Sohn [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jong Hee Park &lt;jongheepark@snu.ac.kr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), MCMCpack, ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, Rmpfr, abind, mvtnorm, tidyr, igraph, qgraph, network,
stats, MASS, methods, RColorBrewer, reshape, ggrepel,
gridExtra, rlang, GGally, ggvis</td>
</tr>
<tr>
<td>Description:</td>
<td>Network changepoint analysis for undirected network data. The package implements a hidden Markov network change point model (Park and Sohn (2020)). Functions for break number detection using the approximate marginal likelihood and WAIC are also provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jongheepark/NetworkChange">https://github.com/jongheepark/NetworkChange</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-04 07:00:27 UTC; park</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-04 07:30:02 UTC</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
</table>
<hr>
<h2 id='BreakDiagnostic'>Detect a break number using different metrics</h2><span id='topic+BreakDiagnostic'></span>

<h3>Description</h3>

<p>Detect a break number using different metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BreakDiagnostic(
  Y,
  R = 2,
  mcmc = 100,
  burnin = 100,
  verbose = 100,
  thin = 1,
  UL.Normal = "Orthonormal",
  v0 = NULL,
  v1 = NULL,
  break.upper = 3,
  a = 1,
  b = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BreakDiagnostic_+3A_y">Y</code></td>
<td>
<p>Reponse tensor</p>
</td></tr>
<tr><td><code id="BreakDiagnostic_+3A_r">R</code></td>
<td>
<p>Dimension of latent space. The default is 2.</p>
</td></tr>
<tr><td><code id="BreakDiagnostic_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="BreakDiagnostic_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="BreakDiagnostic_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the <code class="reqn">\beta</code> vector, and the error variance are
printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="BreakDiagnostic_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="BreakDiagnostic_+3A_ul.normal">UL.Normal</code></td>
<td>
<p>Transformation of sampled U. Users can choose &quot;NULL&quot;, &quot;Normal&quot; or &quot;Orthonormal.&quot;
&quot;NULL&quot; is no normalization. &quot;Normal&quot; is the standard normalization.
&quot;Orthonormal&quot; is the Gram-Schmidt orthgonalization. Default is &quot;NULL.&quot;</p>
</td></tr>
<tr><td><code id="BreakDiagnostic_+3A_v0">v0</code></td>
<td>
<p><code class="reqn">v_0/2</code> is the shape parameter for the inverse
Gamma prior on variance parameters for V.
If <code>v0 = NULL</code>, a value is computed from a test run of <code>NetworkStatic</code>.</p>
</td></tr>
<tr><td><code id="BreakDiagnostic_+3A_v1">v1</code></td>
<td>
<p><code class="reqn">v_1/2</code> is the scale parameter for the
inverse Gamma prior on variance parameters for V.
If <code>v1 = NULL</code>, a value is computed from a test run of <code>NetworkStatic</code>.</p>
</td></tr>
<tr><td><code id="BreakDiagnostic_+3A_break.upper">break.upper</code></td>
<td>
<p>Upper threshold for break number detection.
The default is <code>break.upper = 3</code>.</p>
</td></tr>
<tr><td><code id="BreakDiagnostic_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition probabilities. By default,
the expected duration is computed and corresponding a and b values are assigned. The expected
duration is the sample period divided by the number of states.</p>
</td></tr>
<tr><td><code id="BreakDiagnostic_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition probabilities. By default,
the expected duration is computed and corresponding a and b values are assigned. The expected
duration is the sample period divided by the number of states.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jong Hee Park and Yunkyun Sohn. 2020. &quot;Detecting Structural Change
in Longitudinal Network Data.&quot; <em>Bayesian Analysis</em>. Vol.15, No.1, pp.133-157.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## Not run: 
   set.seed(19333)
   ## Generate an array (15 by 15 by 20) with a block merging transition
   Y &lt;- MakeBlockNetworkChange(n=5, T=20, type ="merge")

   ## Fit 3 models (no break, one break, and two break) for break number detection 
   detect &lt;- BreakDiagnostic(Y, R=2, break.upper = 2)
   
   ## Look at the graph
   detect[[1]]; print(detect[[2]])


## End(Not run)



</code></pre>

<hr>
<h2 id='BreakPointLoss'>Compute the Average Loss of Hidden State Changes from Expected Break Points</h2><span id='topic+BreakPointLoss'></span>

<h3>Description</h3>

<p>Compute the Average Loss of Hidden State Changes from Expected Break Points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BreakPointLoss(model.list, waic = FALSE, display = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BreakPointLoss_+3A_model.list">model.list</code></td>
<td>
<p>MCMC output objects. These have to be of class
<code>mcmc</code> and have a <code>logmarglike</code> attribute. In what
follows, we let <code>M</code> denote the total number of models to be
compared.</p>
</td></tr>
<tr><td><code id="BreakPointLoss_+3A_waic">waic</code></td>
<td>
<p>If <code>waic</code> is TRUE, <code>waic</code>(Watanabe information criterion) will be reported.</p>
</td></tr>
<tr><td><code id="BreakPointLoss_+3A_display">display</code></td>
<td>
<p>If <code>display</code> is TRUE, a plot of <code>ave.loss</code> will be produced.
</p>
<p><code>BreakPointLoss</code>. ave.loss, logmarglike, State, Tau, Tau.samp</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>BreakPointLoss</code> returns five objects. They are: <code>ave.loss</code> the expected loss for each model
computed by the mean sqaured distance of hidden state changes from the expected break points.
<code>logmarglike</code> the natural log of the marginal likelihood for each model; <code>State</code> sampled state vectors;
<code>Tau</code> expected break points for each model; and <code>Tau.samp</code> sampled break points from hidden state draws.
</p>


<h3>References</h3>

<p>Jong Hee Park and Yunkyun Sohn. 2020. &quot;Detecting Structural Change
in Longitudinal Network Data.&quot; <em>Bayesian Analysis</em>. Vol.15, No.1, pp.133-157.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## Not run: 
   set.seed(1973)
   ## Generate an array (30 by 30 by 40) with block transitions
   from 2 blocks to 3 blocks
   Y &lt;- MakeBlockNetworkChange(n=10, T=40, type ="split")
   G &lt;- 100 ## Small mcmc scans to save time

   ## Fit multiple models for break number detection using Bayesian model comparison
   out0 &lt;- NetworkStatic(Y, R=2, mcmc=G, burnin=G, verbose=G, Waic=TRUE)
   out1 &lt;- NetworkChange(Y, R=2, m=1, mcmc=G, burnin=G, verbose=G, Waic=TRUE)
   out2 &lt;- NetworkChange(Y, R=2, m=2, mcmc=G, burnin=G, verbose=G, Waic=TRUE)
   out3 &lt;- NetworkChange(Y, R=2, m=3, mcmc=G, burnin=G, verbose=G, Waic=TRUE)

   ## The most probable model given break number 0 to 3 and data is out1 according to WAIC 
   out &lt;- BreakPointLoss(out0, out1, out2, out3, waic=TRUE)

   print(out[["ave.loss"]])

## End(Not run)


</code></pre>

<hr>
<h2 id='drawPostAnalysis'>Plot of latent node cluster</h2><span id='topic+drawPostAnalysis'></span>

<h3>Description</h3>

<p>Plot latent node cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawPostAnalysis(
  mcmcout,
  Y,
  point.cex = 3,
  text.cex = 3,
  segment.size = 0.1,
  n.cluster = NULL,
  start = 1,
  frequency = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawPostAnalysis_+3A_mcmcout">mcmcout</code></td>
<td>
<p>NetworkChange output</p>
</td></tr>
<tr><td><code id="drawPostAnalysis_+3A_y">Y</code></td>
<td>
<p>Input raw data</p>
</td></tr>
<tr><td><code id="drawPostAnalysis_+3A_point.cex">point.cex</code></td>
<td>
<p>node point size.  Default is 3.</p>
</td></tr>
<tr><td><code id="drawPostAnalysis_+3A_text.cex">text.cex</code></td>
<td>
<p>node label size.  Default is 3.</p>
</td></tr>
<tr><td><code id="drawPostAnalysis_+3A_segment.size">segment.size</code></td>
<td>
<p>segment size.  Default is 0.1.</p>
</td></tr>
<tr><td><code id="drawPostAnalysis_+3A_n.cluster">n.cluster</code></td>
<td>
<p>number of cluster. Default is 3.</p>
</td></tr>
<tr><td><code id="drawPostAnalysis_+3A_start">start</code></td>
<td>
<p>start of ts object</p>
</td></tr>
<tr><td><code id="drawPostAnalysis_+3A_frequency">frequency</code></td>
<td>
<p>frequency of ts object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object
</p>


<h3>References</h3>

<p>Jong Hee Park and Yunkyun Sohn. 2020. &quot;Detecting Structural Change
in Longitudinal Network Data.&quot; <em>Bayesian Analysis</em>. Vol.15, No.1, pp.133-157.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   set.seed(1973)
   ## generate an array with two constant blocks
   data(MajorAlly)
   Y &lt;- MajorAlly
   fit &lt;- NetworkChange(newY, R=2, m=2, mcmc=G, initial.s = initial.s,
          burnin=G, verbose=0, v0=v0, v1=v1)
   drawPostAnalysis(fit, Y, n.cluster=c(4, 4, 3))
   
## End(Not run)
</code></pre>

<hr>
<h2 id='drawRegimeRaw'>Plot of network by hidden regime</h2><span id='topic+drawRegimeRaw'></span>

<h3>Description</h3>

<p>Plot latent node cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawRegimeRaw(mcmcout, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawRegimeRaw_+3A_mcmcout">mcmcout</code></td>
<td>
<p>NetworkChange output</p>
</td></tr>
<tr><td><code id="drawRegimeRaw_+3A_y">Y</code></td>
<td>
<p>Input raw data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object
</p>


<h3>References</h3>

<p>Jong Hee Park and Yunkyun Sohn. 2020. &quot;Detecting Structural Change
in Longitudinal Network Data.&quot; <em>Bayesian Analysis</em>. Vol.15, No.1, pp.133-157.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   set.seed(1973)
   ## generate an array with two constant blocks
   data(MajorAlly)
   Y &lt;- MajorAlly
   fit &lt;- NetworkChange(newY, R=2, m=2, mcmc=G, initial.s = initial.s,
          burnin=G, verbose=0, v0=v0, v1=v1)
   drawRegimeRaw(fit, newY)
   
## End(Not run)
</code></pre>

<hr>
<h2 id='kmeansU'>K-mean clustering of latent node positions</h2><span id='topic+kmeansU'></span>

<h3>Description</h3>

<p>K-mean clustering of latent node positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeansU(out, R = 2, n.cluster = 3, layer = 1, main = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmeansU_+3A_out">out</code></td>
<td>
<p>Output of networkchange objects.</p>
</td></tr>
<tr><td><code id="kmeansU_+3A_r">R</code></td>
<td>
<p>Number of latent space dimensions</p>
</td></tr>
<tr><td><code id="kmeansU_+3A_n.cluster">n.cluster</code></td>
<td>
<p>Number of latent cluster</p>
</td></tr>
<tr><td><code id="kmeansU_+3A_layer">layer</code></td>
<td>
<p>Layer id for the cluster analysis</p>
</td></tr>
<tr><td><code id="kmeansU_+3A_main">main</code></td>
<td>
<p>Title</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: set.seed(1973)
   ## generate an array with two constant blocks
   Y &lt;- MakeBlockNetworkChange(n=10, shape=10, T=10, type ="constant")
   out0 &lt;- NetworkStatic(Y, R=2, mcmc=10, burnin=10,
   verbose=10, UL.Normal = "Orthonormal")
   ## latent node positions
   kmeansU(out0)
   
## End(Not run)
</code></pre>

<hr>
<h2 id='MajorAlly'>Major Power Alliance Network (1816 - 2012)</h2><span id='topic+MajorAlly'></span>

<h3>Description</h3>

<p>This dataframe contains major power alliance network data from 1816 to 2012 (2 year interval).
</p>


<h3>Format</h3>

<p>The dataframe has contains data for major power alliance network data
from 1816 to 2012. Major power definition is the COW data set, which incldues
USA, UK, France, Germany (West Germany during 1954-1989), Austria, Italy,
Russia, China, and Japan. In this data set, a defense pact (Type I),
which is the highest level of military commitment, is coded as 1,
and 0 otherwise.
</p>


<h3>Source</h3>

<p>Correlates of War Project. 2017. &quot;State System Membership List,
v2016.&quot; Online, <a href="https://correlatesofwar.org/">https://correlatesofwar.org/</a>.
Gibler, Douglas M. 2009. <em>International military alliances, 1648-2008.</em>
CQ Press.
</p>

<hr>
<h2 id='MakeBlockNetworkChange'>Build a synthetic block-structured temporal data with breaks</h2><span id='topic+MakeBlockNetworkChange'></span>

<h3>Description</h3>

<p>MakeBlockNetworkChange generates a block-structured temporal data with breaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeBlockNetworkChange(
  n = 10,
  break.point = 0.5,
  base.prob = 0.05,
  block.prob = 0.5,
  shape = 1,
  T = 40,
  break.point1 = 0.25,
  break.point2 = 0.75,
  type = "merge"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeBlockNetworkChange_+3A_n">n</code></td>
<td>
<p>The number of nodes within a block. The total number of nodes is n*block.number.</p>
</td></tr>
<tr><td><code id="MakeBlockNetworkChange_+3A_break.point">break.point</code></td>
<td>
<p>The point of break. 0 indicates the beginning, 0.5 indicates the middle,
and 1 indicates the end.</p>
</td></tr>
<tr><td><code id="MakeBlockNetworkChange_+3A_base.prob">base.prob</code></td>
<td>
<p>The probability of link among non-block members.</p>
</td></tr>
<tr><td><code id="MakeBlockNetworkChange_+3A_block.prob">block.prob</code></td>
<td>
<p>The probability of link among within-block members.</p>
</td></tr>
<tr><td><code id="MakeBlockNetworkChange_+3A_shape">shape</code></td>
<td>
<p>The speed of breaks.
The larger shape is, the faster the transition is. shape &gt; 0 and shape &lt; 8.</p>
</td></tr>
<tr><td><code id="MakeBlockNetworkChange_+3A_t">T</code></td>
<td>
<p>The length of time.</p>
</td></tr>
<tr><td><code id="MakeBlockNetworkChange_+3A_break.point1">break.point1</code></td>
<td>
<p>The point of the first break in &quot;merge-split&quot; or &quot;split-merge&quot;. Any number between 0 and 0.5 can be chosen.
For example, 0 indicates #' the beginning, 0.25 indicates the 1/4th point, and 0.5 indicates the half point.</p>
</td></tr>
<tr><td><code id="MakeBlockNetworkChange_+3A_break.point2">break.point2</code></td>
<td>
<p>The point of the second breakin &quot;merge-split&quot; or &quot;split-merge&quot;. Any number between 0.5 and 1 can be chosen.
For example, 0.5 indicates the beginning, 0.75 indicates the 3/4th point, and 1 indicates the end point.</p>
</td></tr>
<tr><td><code id="MakeBlockNetworkChange_+3A_type">type</code></td>
<td>
<p>The type of network changes. Options are &quot;constant&quot;, &quot;merge&quot;, &quot;split&quot;,
&quot;merge-split&quot;, &quot;split-merge.&quot; If &quot;constant&quot; is chosen, the number of breaks is zero.
If &quot;merge&quot; or &quot;split&quot; is chosen, the number of breaks is one.
If either &quot;merge-split&quot; or &quot;split-merge&quot; is chosen, the number of breaks is two.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output  An output of <code>MakeBlockNetworkChange</code> contains a symmetric block-structured temporal network data set with breaks.
</p>

<hr>
<h2 id='MarginalCompare'>Compare Log Marginal Likelihood</h2><span id='topic+MarginalCompare'></span>

<h3>Description</h3>

<p>Compare Log Marginal Likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MarginalCompare(outlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MarginalCompare_+3A_outlist">outlist</code></td>
<td>
<p>List of NetworkChange objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of log marginal likelihoods.
</p>


<h3>References</h3>

<p>Siddhartha Chib. 1995. &ldquo;Marginal Likelihood from the Gibbs Output.&rdquo;
<em>Journal of the American Statistical Association</em>. 90: 1313-1321.
</p>
<p>Jong Hee Park and Yunkyun Sohn. 2020. &quot;Detecting Structural Change
in Longitudinal Network Data.&quot; <em>Bayesian Analysis</em>. Vol.15, No.1, pp.133-157.
</p>
<p>Sumio Watanabe. 2010. &quot;Asymptotic equivalence of Bayes cross validation and widely
applicable information criterion in singular learning theory.&quot;
<em>Journal of Machine Learning Research</em>. 11: 3571-3594.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WaicCompare">WaicCompare</a></code>
</p>

<hr>
<h2 id='multiplot'>Printing multiple ggplots in oone file</h2><span id='topic+multiplot'></span>

<h3>Description</h3>

<p>Print multiple ggplots in one file. Slightly modified for packaging from the original version in the web.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiplot(..., plotlist = NULL, cols = 1, layout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiplot_+3A_...">...</code></td>
<td>
<p>A list of ggplot objects separated by commas.</p>
</td></tr>
<tr><td><code id="multiplot_+3A_plotlist">plotlist</code></td>
<td>
<p>A list of ggplot objects</p>
</td></tr>
<tr><td><code id="multiplot_+3A_cols">cols</code></td>
<td>
<p>The number of columns.</p>
</td></tr>
<tr><td><code id="multiplot_+3A_layout">layout</code></td>
<td>
<p>A matrix specifying the layout. If present, 'cols' is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object
</p>


<h3>Author(s)</h3>

<p><a href="http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/">http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/</a>
</p>

<hr>
<h2 id='NetworkChange'>Changepoint analysis of a degree-corrected multilinear tensor model</h2><span id='topic+NetworkChange'></span>

<h3>Description</h3>

<p>NetworkChange implements Bayesian multiple changepoint models to network time series data
using a degree-corrected multilinear tensor decomposition method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetworkChange(
  Y,
  R = 2,
  m = 1,
  initial.s = NULL,
  mcmc = 100,
  burnin = 100,
  verbose = 0,
  thin = 1,
  reduce.mcmc = NULL,
  degree.normal = "eigen",
  UL.Normal = "Orthonormal",
  DIC = FALSE,
  Waic = FALSE,
  marginal = FALSE,
  plotUU = FALSE,
  plotZ = FALSE,
  constant = FALSE,
  b0 = 0,
  B0 = 1,
  c0 = NULL,
  d0 = NULL,
  u0 = NULL,
  u1 = NULL,
  v0 = NULL,
  v1 = NULL,
  a = NULL,
  b = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetworkChange_+3A_y">Y</code></td>
<td>
<p>Reponse tensor</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_r">R</code></td>
<td>
<p>Dimension of latent space. The default is 2.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_m">m</code></td>
<td>
<p>Number of change point.
If <code>m = 0</code> is specified, the result should be the same as <code>NetworkStatic</code>.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_initial.s">initial.s</code></td>
<td>
<p>The starting value of latent state vector. The default is
sampling from equal probabilities for all states.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the <code class="reqn">\beta</code> vector, and the error variance are
printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_reduce.mcmc">reduce.mcmc</code></td>
<td>
<p>The number of reduced MCMC iterations for marginal likelihood computations.
If <code>reduce.mcmc = NULL</code>, <code>mcmc/thin</code> is used.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_degree.normal">degree.normal</code></td>
<td>
<p>A null model for degree correction. Users can choose &quot;NULL&quot;, &quot;eigen&quot; or &quot;Lsym.&quot;
&quot;NULL&quot; is no degree correction. &quot;eigen&quot; is a principal eigen-matrix consisting of
the first eigenvalue and the corresponding eigenvector. &quot;
Lsym&quot; is a modularity matrix. Default is &quot;eigen.&quot;</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_ul.normal">UL.Normal</code></td>
<td>
<p>Transformation of sampled U. Users can choose &quot;NULL&quot;, &quot;Normal&quot; or &quot;Orthonormal.&quot;
&quot;NULL&quot; is no normalization. &quot;Normal&quot; is the standard normalization.
&quot;Orthonormal&quot; is the Gram-Schmidt orthgonalization. Default is &quot;NULL.&quot;</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_dic">DIC</code></td>
<td>
<p>If <code>DIC = TRUE</code>, the deviation information criterion is computed.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_waic">Waic</code></td>
<td>
<p>If <code>Waic = TRUE</code>, the Watanabe information criterion is computed.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_marginal">marginal</code></td>
<td>
<p>If <code>marginal = TRUE</code>, the log marignal likelihood is computed using the method of Chib (1995).</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_plotuu">plotUU</code></td>
<td>
<p>If <code>plotUU = TRUE</code> and <code>verbose &gt; 0</code>,
then the plot of the latent space will be
printed to the screen at every <code>verbose</code>th iteration.
The default is <code>plotUU = FALSE</code>.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_plotz">plotZ</code></td>
<td>
<p>If <code>plotZ = TRUE</code> and <code>verbose &gt; 0</code>,
then the plot of the degree-corrected input matrix will be
printed to the screen with the sampled mean values at every <code>verbose</code>th iteration.
The default is <code>plotUU = FALSE</code>.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_constant">constant</code></td>
<td>
<p>If <code>constant = TRUE</code>, constant parameter is sampled
and saved in the output as attribute <code>bmat</code>. Default is <code>constant = FALSE</code>.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>. This must be a scalar. The default value is 0.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_b0">B0</code></td>
<td>
<p>The prior variance of <code class="reqn">\beta</code>. This must be a scalar.  The default value is 1.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_c0">c0</code></td>
<td>
<p>= 0.1</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_d0">d0</code></td>
<td>
<p>= 0.1</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_u0">u0</code></td>
<td>
<p><code class="reqn">u_0/2</code> is the shape parameter for the inverse
Gamma prior on variance parameters for U. The default is 10.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_u1">u1</code></td>
<td>
<p><code class="reqn">u_1/2</code> is the scale parameter for the
inverse Gamma prior on variance parameters for U.
The default is 1.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_v0">v0</code></td>
<td>
<p><code class="reqn">v_0/2</code> is the shape parameter for the inverse
Gamma prior on variance parameters for V.
The default is 10.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_v1">v1</code></td>
<td>
<p><code class="reqn">v_1/2</code> is the scale parameter for the
inverse Gamma prior on variance parameters for V.
The default is the time length of Y.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition probabilities. By default,
the expected duration is computed and corresponding a and b values are assigned. The expected
duration is the sample period divided by the number of states.</p>
</td></tr>
<tr><td><code id="NetworkChange_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition probabilities. By default,
the expected duration is computed and corresponding a and b values are assigned. The expected
duration is the sample period divided by the number of states.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample. This object can
be summarized by functions provided by the coda package. The object
contains an attribute <code>Waic.out</code> that contains results of WAIC and the log-marginal
likelihood of the model (<code>logmarglike</code>). The object
also contains an attribute <code>prob.state</code> storage matrix that contains the
probability of <code class="reqn">state_i</code> for each period
</p>


<h3>References</h3>

<p>Jong Hee Park and Yunkyun Sohn. 2020. &quot;Detecting Structural Change
in Longitudinal Network Data.&quot; <em>Bayesian Analysis</em>. Vol.15, No.1, pp.133-157.
</p>
<p>Peter D. Hoff 2011. &quot;Hierarchical Multilinear Models for Multiway Data.&quot;
<em>Computational Statistics \&amp; Data Analysis</em>. 55: 530-543.
</p>
<p>Siddhartha Chib. 1998. &quot;Estimation and comparison of multiple change-point models.&quot;
<em>Journal of Econometrics</em>. 86: 221-241.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NetworkStatic">NetworkStatic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   set.seed(1973)
   \## Generate an array (30 by 30 by 40) with block transitions
   from 2 blocks to 3 blocks
   Y &lt;- MakeBlockNetworkChange(n=10, T=40, type ="split")
   G &lt;- 100 ## Small mcmc scans to save time

   \## Fit multiple models for break number detection using Bayesian model comparison
   out0 &lt;- NetworkStatic(Y, R=2, mcmc=G, burnin=G, verbose=G, Waic=TRUE)
   out1 &lt;- NetworkChange(Y, R=2, m=1, mcmc=G, burnin=G, verbose=G, Waic=TRUE)
   out2 &lt;- NetworkChange(Y, R=2, m=2, mcmc=G, burnin=G, verbose=G, Waic=TRUE)
   out3 &lt;- NetworkChange(Y, R=2, m=3, mcmc=G, burnin=G, verbose=G, Waic=TRUE)
   outlist &lt;- list(out0, out1, out2, out3)

   \## The most probable model given break number 0 to 3 and data is out1 according to WAIC 
   WaicCompare(outlist)

   plotU(out1)
 
   plotV(out1)
   
## End(Not run)
</code></pre>

<hr>
<h2 id='NetworkChangeRobust'>Changepoint analysis of a degree-corrected multilinear tensor model with t-distributed error</h2><span id='topic+NetworkChangeRobust'></span>

<h3>Description</h3>

<p>NetworkChangeRobust implements Bayesian multiple changepoint models to network time series data
using a degree-corrected multilinear tensor decomposition method with t-distributed error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetworkChangeRobust(
  Y,
  R = 2,
  m = 1,
  initial.s = NULL,
  mcmc = 100,
  burnin = 100,
  verbose = 0,
  thin = 1,
  degree.normal = "eigen",
  UL.Normal = "Orthonormal",
  plotUU = FALSE,
  plotZ = FALSE,
  b0 = 0,
  B0 = 1,
  c0 = NULL,
  d0 = NULL,
  n0 = 2,
  m0 = 2,
  u0 = NULL,
  u1 = NULL,
  v0 = NULL,
  v1 = NULL,
  a = NULL,
  b = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetworkChangeRobust_+3A_y">Y</code></td>
<td>
<p>Reponse tensor</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_r">R</code></td>
<td>
<p>Dimension of latent space. The default is 2.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_m">m</code></td>
<td>
<p>Number of change point.
If <code>m = 0</code> is specified, the result should be the same as <code>NetworkStatic</code>.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_initial.s">initial.s</code></td>
<td>
<p>The starting value of latent state vector. The default is
sampling from equal probabilities for all states.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the <code class="reqn">\beta</code> vector, and the error variance are
printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_degree.normal">degree.normal</code></td>
<td>
<p>A null model for degree correction. Users can choose &quot;NULL&quot;, &quot;eigen&quot; or &quot;Lsym.&quot;
&quot;NULL&quot; is no degree correction. &quot;eigen&quot; is a principal eigen-matrix consisting of
the first eigenvalue and the corresponding eigenvector. &quot;
Lsym&quot; is a modularity matrix. Default is &quot;eigen.&quot;</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_ul.normal">UL.Normal</code></td>
<td>
<p>Transformation of sampled U. Users can choose &quot;NULL&quot;, &quot;Normal&quot; or &quot;Orthonormal.&quot;
&quot;NULL&quot; is no normalization. &quot;Normal&quot; is the standard normalization.
&quot;Orthonormal&quot; is the Gram-Schmidt orthgonalization. Default is &quot;NULL.&quot;</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_plotuu">plotUU</code></td>
<td>
<p>If <code>plotUU = TRUE</code> and <code>verbose &gt; 0</code>,
then the plot of the latent space will be
printed to the screen at every <code>verbose</code>th iteration.
The default is <code>plotUU = FALSE</code>.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_plotz">plotZ</code></td>
<td>
<p>If <code>plotZ = TRUE</code> and <code>verbose &gt; 0</code>,
then the plot of the degree-corrected input matrix will be
printed to the screen with the sampled mean values at every <code>verbose</code>th iteration.
The default is <code>plotUU = FALSE</code>.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>. This must be a scalar. The default value is 0.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_b0">B0</code></td>
<td>
<p>The prior variance of <code class="reqn">\beta</code>. This must be a scalar.  The default value is 1.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_c0">c0</code></td>
<td>
<p>= 0.1 The shape parameter of inverse gamma prior for <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_d0">d0</code></td>
<td>
<p>= 0.1 The rate parameter of inverse gamma prior for <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_n0">n0</code></td>
<td>
<p>= 0.1 The shape parameter of inverse gamma prior for <code class="reqn">\gamma</code> of Student-t distribution.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_m0">m0</code></td>
<td>
<p>= 0.1 The rate parameter of inverse gamma prior for <code class="reqn">\gamma</code> of Student-t distribution.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_u0">u0</code></td>
<td>
<p><code class="reqn">u_0/2</code> is the shape parameter for the inverse
Gamma prior on variance parameters for U. The default is 10.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_u1">u1</code></td>
<td>
<p><code class="reqn">u_1/2</code> is the scale parameter for the
inverse Gamma prior on variance parameters for U.
The default is 1.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_v0">v0</code></td>
<td>
<p><code class="reqn">v_0/2</code> is the shape parameter for the inverse
Gamma prior on variance parameters for V.
The default is 10.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_v1">v1</code></td>
<td>
<p><code class="reqn">v_1/2</code> is the scale parameter for the
inverse Gamma prior on variance parameters for V.
The default is the time length of Y.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_a">a</code></td>
<td>
<p><code class="reqn">a</code> is the shape1 beta prior for transition probabilities. By default,
the expected duration is computed and corresponding a and b values are assigned. The expected
duration is the sample period divided by the number of states.</p>
</td></tr>
<tr><td><code id="NetworkChangeRobust_+3A_b">b</code></td>
<td>
<p><code class="reqn">b</code> is the shape2 beta prior for transition probabilities. By default,
the expected duration is computed and corresponding a and b values are assigned. The expected
duration is the sample period divided by the number of states.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample. This object can
be summarized by functions provided by the coda package. The object
contains an attribute <code>Waic.out</code> that contains results of WAIC and the log-marginal
likelihood of the model (<code>logmarglike</code>). The object
also contains an attribute <code>prob.state</code> storage matrix that contains the
probability of <code class="reqn">state_i</code> for each period
</p>


<h3>References</h3>

<p>Jong Hee Park and Yunkyun Sohn. 2020. &quot;Detecting Structural Change
in Longitudinal Network Data.&quot; <em>Bayesian Analysis</em>. Vol.15, No.1, pp.133-157.
</p>
<p>Peter D. Hoff 2011. &quot;Hierarchical Multilinear Models for Multiway Data.&quot;
<em>Computational Statistics \&amp; Data Analysis</em>. 55: 530-543.
</p>
<p>Siddhartha Chib. 1998. &quot;Estimation and comparison of multiple change-point models.&quot;
<em>Journal of Econometrics</em>. 86: 221-241.
</p>
<p>Sumio Watanabe. 2010. &quot;Asymptotic equivalence of Bayes cross validation and widely
applicable information criterion in singular learning theory.&quot;
<em>Journal of Machine Learning Research</em>. 11: 3571-3594.
Siddhartha Chib. 1995. &ldquo;Marginal Likelihood from the Gibbs Output.&rdquo;
<em>Journal of the American Statistical Association</em>. 90: 1313-1321.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NetworkStatic">NetworkStatic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   set.seed(1973)
   ## Generate an array (30 by 30 by 40) with block transitions
   from 2 blocks to 3 blocks
   Y &lt;- MakeBlockNetworkChange(n=10, T=40, type ="split")
   G &lt;- 100 ## only 100 mcmc scans to save time
   ## Fit models
   out1 &lt;- NetworkChangeRobust(Y, R=2, m=1, mcmc=G, burnin=G, verbose=G)
   ## plot latent node positions
   plotU(out1)
   ## plot layer-specific network generation rules
   plotV(out1)
   
## End(Not run)
</code></pre>

<hr>
<h2 id='NetworkStatic'>Degree-corrected multilinear tensor model</h2><span id='topic+NetworkStatic'></span>

<h3>Description</h3>

<p>NetworkStatic implements a degree-corrected Bayesian multilinear tensor decomposition method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetworkStatic(
  Y,
  R = 2,
  mcmc = 100,
  burnin = 100,
  verbose = 0,
  thin = 1,
  reduce.mcmc = NULL,
  degree.normal = "eigen",
  UL.Normal = "Orthonormal",
  plotUU = FALSE,
  plotZ = FALSE,
  constant = FALSE,
  b0 = 0,
  B0 = 1,
  c0 = NULL,
  d0 = NULL,
  u0 = NULL,
  u1 = NULL,
  v0 = NULL,
  v1 = NULL,
  marginal = FALSE,
  DIC = FALSE,
  Waic = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetworkStatic_+3A_y">Y</code></td>
<td>
<p>Reponse tensor</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_r">R</code></td>
<td>
<p>Dimension of latent space. The default is 2.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_mcmc">mcmc</code></td>
<td>
<p>The number of MCMC iterations after burnin.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_verbose">verbose</code></td>
<td>
<p>A switch which determines whether or not the progress of the
sampler is printed to the screen.  If <code>verbose</code> is greater than 0 the
iteration number, the <code class="reqn">\beta</code> vector, and the error variance are
printed to the screen every <code>verbose</code>th iteration.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_thin">thin</code></td>
<td>
<p>The thinning interval used in the simulation.  The number of
MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_reduce.mcmc">reduce.mcmc</code></td>
<td>
<p>The number of reduced MCMC iterations for marginal likelihood computations.
If <code>reduce.mcmc = NULL</code>, <code>mcmc/thin</code> is used.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_degree.normal">degree.normal</code></td>
<td>
<p>A null model for degree correction. Users can choose &quot;NULL&quot;, &quot;eigen&quot; or &quot;Lsym.&quot;
&quot;NULL&quot; is no degree correction. &quot;eigen&quot; is a principal eigen-matrix consisting of
the first eigenvalue and the corresponding eigenvector. &quot;
Lsym&quot; is a modularity matrix. Default is &quot;eigen.&quot;</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_ul.normal">UL.Normal</code></td>
<td>
<p>Transformation of sampled U. Users can choose &quot;NULL&quot;, &quot;Normal&quot; or &quot;Orthonormal.&quot;
&quot;NULL&quot; is no normalization. &quot;Normal&quot; is the standard normalization.
&quot;Orthonormal&quot; is the Gram-Schmidt orthgonalization. Default is &quot;NULL.&quot;</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_plotuu">plotUU</code></td>
<td>
<p>If <code>plotUU = TRUE</code> and <code>verbose &gt; 0</code>,
then the plot of the latent space will be
printed to the screen at every <code>verbose</code>th iteration.
The default is <code>plotUU = FALSE</code>.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_plotz">plotZ</code></td>
<td>
<p>If <code>plotZ = TRUE</code> and <code>verbose &gt; 0</code>,
then the plot of the degree-corrected input matrix will be
printed to the screen with the sampled mean values at every <code>verbose</code>th iteration.
The default is <code>plotUU = FALSE</code>.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_constant">constant</code></td>
<td>
<p>If <code>constant = TRUE</code>, constant parameter is sampled
and saved in the output as attribute <code>bmat</code>. Default is <code>constant = FALSE</code>.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_b0">b0</code></td>
<td>
<p>The prior mean of <code class="reqn">\beta</code>. This must be a scalar. The default value is 0.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_b0">B0</code></td>
<td>
<p>The prior variance of <code class="reqn">\beta</code>. This must be a scalar.  The default value is 1.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_c0">c0</code></td>
<td>
<p>= 0.1</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_d0">d0</code></td>
<td>
<p>= 0.1</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_u0">u0</code></td>
<td>
<p><code class="reqn">u_0/2</code> is the shape parameter for the inverse
Gamma prior on variance parameters for U. The default is 10.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_u1">u1</code></td>
<td>
<p><code class="reqn">u_1/2</code> is the scale parameter for the
inverse Gamma prior on variance parameters for U.
The default is 1.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_v0">v0</code></td>
<td>
<p><code class="reqn">v_0/2</code> is the shape parameter for the inverse
Gamma prior on variance parameters for V.
The default is 10.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_v1">v1</code></td>
<td>
<p><code class="reqn">v_1/2</code> is the scale parameter for the
inverse Gamma prior on variance parameters for V.
The default is the time length of Y.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_marginal">marginal</code></td>
<td>
<p>If <code>marginal = TRUE</code>, the log marignal likelihood is computed using the method of Chib (1995).</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_dic">DIC</code></td>
<td>
<p>If <code>DIC = TRUE</code>, the deviation information criterion is computed.</p>
</td></tr>
<tr><td><code id="NetworkStatic_+3A_waic">Waic</code></td>
<td>
<p>If <code>Waic = TRUE</code>, the Watanabe information criterion is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An mcmc object that contains the posterior sample. This object can
be summarized by functions provided by the coda package.  The object
contains an attribute <code>Waic.out</code> that contains results of WAIC and the log-marginal
likelihood of the model (<code>logmarglike</code>).
</p>


<h3>References</h3>

<p>Jong Hee Park and Yunkyun Sohn. 2020. &quot;Detecting Structural Change
in Longitudinal Network Data.&quot; <em>Bayesian Analysis</em>. Vol.15, No.1, pp.133-157.
</p>
<p>Peter D. Hoff 2011. &quot;Hierarchical Multilinear Models for Multiway Data.&quot;
<em>Computational Statistics \&amp; Data Analysis</em>. 55: 530-543.
</p>
<p>Sumio Watanabe. 2010. &quot;Asymptotic equivalence of Bayes cross validation and widely
applicable information criterion in singular learning theory.&quot;
<em>Journal of Machine Learning Research</em>. 11: 3571-3594.
Siddhartha Chib. 1995. &ldquo;Marginal Likelihood from the Gibbs Output.&rdquo;
<em>Journal of the American Statistical Association</em>. 90: 1313-1321.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NetworkChange">NetworkChange</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   set.seed(1973)

   \## generate an array with three constant blocks
   Y &lt;- MakeBlockNetworkChange(n=10, shape=10, T=10, type ="constant")
   G &lt;- 100 ## Small mcmc scans to save time
   out0 &lt;- NetworkStatic(Y, R=2, mcmc=G, burnin=G, verbose=G)

   \## recovered latent blocks
   Kmeans(out0, n.cluster=3, main="Recovered Blocks")

   \## contour plot of latent node positions
   plotContour(out0)

   \## plot latent node positions
   plotU(out0)

   \## plot layer-specific network connection rules
   plotV(out0)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='plotContour'>Contour plot of latent node positions</h2><span id='topic+plotContour'></span>

<h3>Description</h3>

<p>Draw a contour plot of latent node positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotContour(OUT, main = "", k = 8, my.cols = brewer.pal(k, "Spectral"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotContour_+3A_out">OUT</code></td>
<td>
<p>Output of networkchange objects.</p>
</td></tr>
<tr><td><code id="plotContour_+3A_main">main</code></td>
<td>
<p>The title of plot</p>
</td></tr>
<tr><td><code id="plotContour_+3A_k">k</code></td>
<td>
<p>The number of levels (nlevels in contour ()).</p>
</td></tr>
<tr><td><code id="plotContour_+3A_my.cols">my.cols</code></td>
<td>
<p>Color scale. Use brewer.pal() from RColorBrewer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: set.seed(1973)
   \## generate an array with two constant blocks
   Y &lt;- MakeBlockNetworkChange(n=10, shape=10, T=40, type ="constant")
   out0 &lt;- NetworkStatic(Y, R=2, mcmc=10, burnin=10,
   verbose=10, UL.Normal = "Orthonormal")
   \## contour plot of latent node positions
   plotContour(out0)
   
## End(Not run)
</code></pre>

<hr>
<h2 id='plotnetarray'>Plot of network array data</h2><span id='topic+plotnetarray'></span>

<h3>Description</h3>

<p>Plot network array data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotnetarray(
  Y,
  n.graph = 4,
  node.size = 2,
  node.color = "brown",
  edge.alpha = 0.5,
  edge.size = 0.2,
  edge.color = "grey"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotnetarray_+3A_y">Y</code></td>
<td>
<p>network array data</p>
</td></tr>
<tr><td><code id="plotnetarray_+3A_n.graph">n.graph</code></td>
<td>
<p>number of subgraphs. Default is 4.</p>
</td></tr>
<tr><td><code id="plotnetarray_+3A_node.size">node.size</code></td>
<td>
<p>node size.  Default is 2.</p>
</td></tr>
<tr><td><code id="plotnetarray_+3A_node.color">node.color</code></td>
<td>
<p>node color.  Default is &quot;brown.&quot;</p>
</td></tr>
<tr><td><code id="plotnetarray_+3A_edge.alpha">edge.alpha</code></td>
<td>
<p>transparency of edge.  Default is 0.5.</p>
</td></tr>
<tr><td><code id="plotnetarray_+3A_edge.size">edge.size</code></td>
<td>
<p>edge size.  Default is 0.2.</p>
</td></tr>
<tr><td><code id="plotnetarray_+3A_edge.color">edge.color</code></td>
<td>
<p>edge color.  Default is &quot;grey.&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object
</p>


<h3>References</h3>

<p>Jong Hee Park and Yunkyun Sohn. 2020. &quot;Detecting Structural Change
in Longitudinal Network Data.&quot; <em>Bayesian Analysis</em>. Vol.15, No.1, pp.133-157.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   set.seed(1973)
   ## generate an array with two constant blocks
   Y &lt;- MakeBlockNetworkChange(n=10, shape=1, T=20, type ="split")
   plotnetarray(Y)
   
## End(Not run)
</code></pre>

<hr>
<h2 id='plotU'>Plot of latent node positions</h2><span id='topic+plotU'></span>

<h3>Description</h3>

<p>Plot latent node positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotU(OUT, Time = NULL, names = NULL, main = NULL, label.prob = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotU_+3A_out">OUT</code></td>
<td>
<p>Output of networkchange objects.</p>
</td></tr>
<tr><td><code id="plotU_+3A_time">Time</code></td>
<td>
<p>Starting of the time period. If NULL, 1.</p>
</td></tr>
<tr><td><code id="plotU_+3A_names">names</code></td>
<td>
<p>Node names. If NULL, use natural numbers.</p>
</td></tr>
<tr><td><code id="plotU_+3A_main">main</code></td>
<td>
<p>The title of plot</p>
</td></tr>
<tr><td><code id="plotU_+3A_label.prob">label.prob</code></td>
<td>
<p>Label print threshold. 0.9 is the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
   set.seed(1973)
   \## generate an array with two constant blocks
   Y &lt;- MakeBlockNetworkChange(n=10, shape=10, T=40, type ="constant")
   out0 &lt;- NetworkStatic(Y, R=2, mcmc=10, burnin=10,
   verbose=10, UL.Normal = "Orthonormal")
   \## latent node positions
   plotU(out0)
   
## End(Not run)
</code></pre>

<hr>
<h2 id='plotV'>Plot of layer-specific network generation rules.</h2><span id='topic+plotV'></span>

<h3>Description</h3>

<p>Plot layer-specific network generation rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotV(OUT, main = "", cex = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotV_+3A_out">OUT</code></td>
<td>
<p>Output of networkchange objects.</p>
</td></tr>
<tr><td><code id="plotV_+3A_main">main</code></td>
<td>
<p>The title of plot</p>
</td></tr>
<tr><td><code id="plotV_+3A_cex">cex</code></td>
<td>
<p>point size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: set.seed(1973)
   \## generate an array with two constant blocks
   Y &lt;- MakeBlockNetworkChange(n=10, shape=10, T=40, type ="constant")
   out0 &lt;- NetworkStatic(Y, R=2, mcmc=10, burnin=10,
   verbose=10, UL.Normal = "Orthonormal")
   \## latent node positions
   plotV(out0)
   
## End(Not run)
</code></pre>

<hr>
<h2 id='PostwarAlly'>Postwar Alliance Network (1846 - 2012)</h2><span id='topic+PostwarAlly'></span>

<h3>Description</h3>

<p>This dataframe contains postwar alliance network data from 1946 to 2012 (2 year interval).
</p>


<h3>Format</h3>

<p>The dataframe has contains data for postwar alliance network data
from 1946 to 2012 with 2 year interval. After removing disconnected components,
104 countries are included. In this data set, a defense pact (Type I),
which is the highest level of military commitment, is coded as 1,
and 0 otherwise.
</p>


<h3>Source</h3>

<p>Correlates of War Project. 2017. &quot;State System Membership List,
v2016.&quot; Online, <a href="https://correlatesofwar.org/">https://correlatesofwar.org/</a>.
Gibler, Douglas M. 2009. <em>International military alliances, 1648-2008.</em>
CQ Press.
</p>

<hr>
<h2 id='startS'>Sample a starting value of hidden states</h2><span id='topic+startS'></span>

<h3>Description</h3>

<p>Sample a starting value of hidden states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startS(Z, Time, m, initial.U, V, s2, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="startS_+3A_z">Z</code></td>
<td>
<p>Degree-corrected network array data</p>
</td></tr>
<tr><td><code id="startS_+3A_time">Time</code></td>
<td>
<p>The length of time.</p>
</td></tr>
<tr><td><code id="startS_+3A_m">m</code></td>
<td>
<p>The number of breaks</p>
</td></tr>
<tr><td><code id="startS_+3A_initial.u">initial.U</code></td>
<td>
<p>Initialized U matrix.</p>
</td></tr>
<tr><td><code id="startS_+3A_v">V</code></td>
<td>
<p>Initialized V matrix.</p>
</td></tr>
<tr><td><code id="startS_+3A_s2">s2</code></td>
<td>
<p>Initialized error variance</p>
</td></tr>
<tr><td><code id="startS_+3A_r">R</code></td>
<td>
<p>The dimensionality of latent space</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A state vector
</p>

<hr>
<h2 id='startUV'>Starting values of U and V</h2><span id='topic+startUV'></span>

<h3>Description</h3>

<p>Initialize starting values of U and V
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startUV(Z, R, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="startUV_+3A_z">Z</code></td>
<td>
<p>Degree-corrected network array data.</p>
</td></tr>
<tr><td><code id="startUV_+3A_r">R</code></td>
<td>
<p>The dimensionality of latent space.</p>
</td></tr>
<tr><td><code id="startUV_+3A_k">K</code></td>
<td>
<p>The dimensionality of Z.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of U and V
</p>

<hr>
<h2 id='ULUstateSample'>Hidden State Sampler</h2><span id='topic+ULUstateSample'></span>

<h3>Description</h3>

<p>Sample hidden states from hidden Markov multilinear model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ULUstateSample(m, s, ZMUt, s2, P, SOS.random)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ULUstateSample_+3A_m">m</code></td>
<td>
<p>The number of break</p>
</td></tr>
<tr><td><code id="ULUstateSample_+3A_s">s</code></td>
<td>
<p>Latent state vector</p>
</td></tr>
<tr><td><code id="ULUstateSample_+3A_zmut">ZMUt</code></td>
<td>
<p>Z - MU</p>
</td></tr>
<tr><td><code id="ULUstateSample_+3A_s2">s2</code></td>
<td>
<p>error variance</p>
</td></tr>
<tr><td><code id="ULUstateSample_+3A_p">P</code></td>
<td>
<p>Transition matrix</p>
</td></tr>
<tr><td><code id="ULUstateSample_+3A_sos.random">SOS.random</code></td>
<td>
<p>single observation state random perturbation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of a state vector, state probabilities, and SOS.random.
</p>

<hr>
<h2 id='ULUstateSample.mpfr'>Hidden State Sampler with precision</h2><span id='topic+ULUstateSample.mpfr'></span>

<h3>Description</h3>

<p>Sample hidden states from hidden Markov multilinear model with precision using Rmpfr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ULUstateSample.mpfr(m, s, ZMUt, s2, P, SOS.random)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ULUstateSample.mpfr_+3A_m">m</code></td>
<td>
<p>The number of break</p>
</td></tr>
<tr><td><code id="ULUstateSample.mpfr_+3A_s">s</code></td>
<td>
<p>Latent state vector</p>
</td></tr>
<tr><td><code id="ULUstateSample.mpfr_+3A_zmut">ZMUt</code></td>
<td>
<p>Z - MU</p>
</td></tr>
<tr><td><code id="ULUstateSample.mpfr_+3A_s2">s2</code></td>
<td>
<p>error variance</p>
</td></tr>
<tr><td><code id="ULUstateSample.mpfr_+3A_p">P</code></td>
<td>
<p>Transition matrix</p>
</td></tr>
<tr><td><code id="ULUstateSample.mpfr_+3A_sos.random">SOS.random</code></td>
<td>
<p>single observation state random perturbation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of a state vector, state probabilities, and SOS.random.
</p>

<hr>
<h2 id='updateb'>Update time-constant regression parameters</h2><span id='topic+updateb'></span>

<h3>Description</h3>

<p>Update time-constant regression parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateb(Z, MU, s2, XtX, b0, B0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateb_+3A_z">Z</code></td>
<td>
<p>Degree corrected response tensor</p>
</td></tr>
<tr><td><code id="updateb_+3A_mu">MU</code></td>
<td>
<p>Mean array</p>
</td></tr>
<tr><td><code id="updateb_+3A_s2">s2</code></td>
<td>
<p>Error variance</p>
</td></tr>
<tr><td><code id="updateb_+3A_xtx">XtX</code></td>
<td>
<p>X'X</p>
</td></tr>
<tr><td><code id="updateb_+3A_b0">b0</code></td>
<td>
<p>Prior mean of beta</p>
</td></tr>
<tr><td><code id="updateb_+3A_b0">B0</code></td>
<td>
<p>Prior variance of beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of regression parameters
</p>

<hr>
<h2 id='updatebm'>Update regime-changing regression parameters</h2><span id='topic+updatebm'></span>

<h3>Description</h3>

<p>Update regime-changing beta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updatebm(ns, K, s, s2, B0, p, ZU)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatebm_+3A_ns">ns</code></td>
<td>
<p>The number of hidden states</p>
</td></tr>
<tr><td><code id="updatebm_+3A_k">K</code></td>
<td>
<p>The dimensionality of Z</p>
</td></tr>
<tr><td><code id="updatebm_+3A_s">s</code></td>
<td>
<p>Latent state vector</p>
</td></tr>
<tr><td><code id="updatebm_+3A_s2">s2</code></td>
<td>
<p>The variance of error</p>
</td></tr>
<tr><td><code id="updatebm_+3A_b0">B0</code></td>
<td>
<p>The prior variance of beta</p>
</td></tr>
<tr><td><code id="updatebm_+3A_p">p</code></td>
<td>
<p>The rank of X</p>
</td></tr>
<tr><td><code id="updatebm_+3A_zu">ZU</code></td>
<td>
<p>Z - ULU</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of regime-changing regression parameters
</p>

<hr>
<h2 id='updateP'>Update transition matrix</h2><span id='topic+updateP'></span>

<h3>Description</h3>

<p>Update transition matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateP(s, ns, P, A0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateP_+3A_s">s</code></td>
<td>
<p>Latent state vector</p>
</td></tr>
<tr><td><code id="updateP_+3A_ns">ns</code></td>
<td>
<p>The number of hidden states</p>
</td></tr>
<tr><td><code id="updateP_+3A_p">P</code></td>
<td>
<p>Transition matrix</p>
</td></tr>
<tr><td><code id="updateP_+3A_a0">A0</code></td>
<td>
<p>Prior of transition matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transtion matrix
</p>

<hr>
<h2 id='updateS'>Update latent states</h2><span id='topic+updateS'></span>

<h3>Description</h3>

<p>Update latent states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateS(
  iter,
  s,
  V,
  m,
  Zb,
  Zt,
  Time,
  MU.state,
  P,
  s2,
  N.upper.tri,
  random.perturb
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateS_+3A_iter">iter</code></td>
<td>
<p>iteration number</p>
</td></tr>
<tr><td><code id="updateS_+3A_s">s</code></td>
<td>
<p>the most recent latent states</p>
</td></tr>
<tr><td><code id="updateS_+3A_v">V</code></td>
<td>
<p>Network generation rules</p>
</td></tr>
<tr><td><code id="updateS_+3A_m">m</code></td>
<td>
<p>The number of breaks</p>
</td></tr>
<tr><td><code id="updateS_+3A_zb">Zb</code></td>
<td>
<p>Z - b</p>
</td></tr>
<tr><td><code id="updateS_+3A_zt">Zt</code></td>
<td>
<p>Z stacked by time</p>
</td></tr>
<tr><td><code id="updateS_+3A_time">Time</code></td>
<td>
<p>The length of time</p>
</td></tr>
<tr><td><code id="updateS_+3A_mu.state">MU.state</code></td>
<td>
<p>UVU for each state</p>
</td></tr>
<tr><td><code id="updateS_+3A_p">P</code></td>
<td>
<p>Transition matrix</p>
</td></tr>
<tr><td><code id="updateS_+3A_s2">s2</code></td>
<td>
<p>error variance</p>
</td></tr>
<tr><td><code id="updateS_+3A_n.upper.tri">N.upper.tri</code></td>
<td>
<p>The number of upper triangular elements</p>
</td></tr>
<tr><td><code id="updateS_+3A_random.perturb">random.perturb</code></td>
<td>
<p>If <code>random.perturb</code> = TRUE and a single state observation is found,
the latent state is randomly selected by equal weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors containing latent states and their probabilities
</p>

<hr>
<h2 id='updates2m'>Update regime-specific variance</h2><span id='topic+updates2m'></span>

<h3>Description</h3>

<p>Update regime-specific variance parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updates2m(ns, Zm, MU, c0, d0, Km)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updates2m_+3A_ns">ns</code></td>
<td>
<p>The number of hidden states</p>
</td></tr>
<tr><td><code id="updates2m_+3A_zm">Zm</code></td>
<td>
<p>The regime-specific holder of Z - beta</p>
</td></tr>
<tr><td><code id="updates2m_+3A_mu">MU</code></td>
<td>
<p>The mean array.</p>
</td></tr>
<tr><td><code id="updates2m_+3A_c0">c0</code></td>
<td>
<p>Scalar shape parameter</p>
</td></tr>
<tr><td><code id="updates2m_+3A_d0">d0</code></td>
<td>
<p>Scalar scale parameter</p>
</td></tr>
<tr><td><code id="updates2m_+3A_km">Km</code></td>
<td>
<p>Regime-specific dimensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar for a regime-specific variance
</p>

<hr>
<h2 id='updateU'>Update time-constant latent node positions</h2><span id='topic+updateU'></span>

<h3>Description</h3>

<p>Update time-constant latent node positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateU(K, U, V, R, Zb, s2, eU, iVU)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateU_+3A_k">K</code></td>
<td>
<p>The dimensionality of Z</p>
</td></tr>
<tr><td><code id="updateU_+3A_u">U</code></td>
<td>
<p>The most recent draw of latent node positions</p>
</td></tr>
<tr><td><code id="updateU_+3A_v">V</code></td>
<td>
<p>Layer-specific network generation rule</p>
</td></tr>
<tr><td><code id="updateU_+3A_r">R</code></td>
<td>
<p>The dimensionality of latent space</p>
</td></tr>
<tr><td><code id="updateU_+3A_zb">Zb</code></td>
<td>
<p>Z - beta</p>
</td></tr>
<tr><td><code id="updateU_+3A_s2">s2</code></td>
<td>
<p>error variance</p>
</td></tr>
<tr><td><code id="updateU_+3A_eu">eU</code></td>
<td>
<p>The mean of U</p>
</td></tr>
<tr><td><code id="updateU_+3A_ivu">iVU</code></td>
<td>
<p>The variance of U</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of time-constant latent node positions
</p>

<hr>
<h2 id='updateUm'>Regime-specific latent node positions</h2><span id='topic+updateUm'></span>

<h3>Description</h3>

<p>Update regime-specific latent node positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateUm(ns, U, V, R, Zm, Km, ej, s2, eU, iVU, UL.Normal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateUm_+3A_ns">ns</code></td>
<td>
<p>The number of latent states</p>
</td></tr>
<tr><td><code id="updateUm_+3A_u">U</code></td>
<td>
<p>THe latent node positions</p>
</td></tr>
<tr><td><code id="updateUm_+3A_v">V</code></td>
<td>
<p>Layer-specific network generation rule.</p>
</td></tr>
<tr><td><code id="updateUm_+3A_r">R</code></td>
<td>
<p>The dimensionality of latent space</p>
</td></tr>
<tr><td><code id="updateUm_+3A_zm">Zm</code></td>
<td>
<p>Regim-specific Z - beta</p>
</td></tr>
<tr><td><code id="updateUm_+3A_km">Km</code></td>
<td>
<p>The dimension of regime-specific Z.</p>
</td></tr>
<tr><td><code id="updateUm_+3A_ej">ej</code></td>
<td>
<p>Regime indicator.</p>
</td></tr>
<tr><td><code id="updateUm_+3A_s2">s2</code></td>
<td>
<p>The variance of error.</p>
</td></tr>
<tr><td><code id="updateUm_+3A_eu">eU</code></td>
<td>
<p>The regim-specific mean of U.</p>
</td></tr>
<tr><td><code id="updateUm_+3A_ivu">iVU</code></td>
<td>
<p>The regim-specific variance of U.</p>
</td></tr>
<tr><td><code id="updateUm_+3A_ul.normal">UL.Normal</code></td>
<td>
<p>Normalization method for U. &quot;Normal&quot; or &quot;Orthonormal&quot; are supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of regime-specific latent node positions
</p>

<hr>
<h2 id='updateV'>Update layer specific network generation rules</h2><span id='topic+updateV'></span>

<h3>Description</h3>

<p>Update layer specific network generation rules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateV(Zb, U, R, K, s2, eV, iVV, UTA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateV_+3A_zb">Zb</code></td>
<td>
<p>Z - beta.</p>
</td></tr>
<tr><td><code id="updateV_+3A_u">U</code></td>
<td>
<p>The latent node positions.</p>
</td></tr>
<tr><td><code id="updateV_+3A_r">R</code></td>
<td>
<p>The dimension of latent space.</p>
</td></tr>
<tr><td><code id="updateV_+3A_k">K</code></td>
<td>
<p>The dimension of Z.</p>
</td></tr>
<tr><td><code id="updateV_+3A_s2">s2</code></td>
<td>
<p>The variance of error.</p>
</td></tr>
<tr><td><code id="updateV_+3A_ev">eV</code></td>
<td>
<p>The mean of V.</p>
</td></tr>
<tr><td><code id="updateV_+3A_ivv">iVV</code></td>
<td>
<p>The variance of V.</p>
</td></tr>
<tr><td><code id="updateV_+3A_uta">UTA</code></td>
<td>
<p>Indicator of upper triangular array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of layer specific network generation rules
</p>

<hr>
<h2 id='updateVm'>Update V from a change-point network process</h2><span id='topic+updateVm'></span>

<h3>Description</h3>

<p>Update layer specific network generation rules from a change-point network process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateVm(ns, U, V, Zm, Km, R, s2, eV, iVV, UTA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateVm_+3A_ns">ns</code></td>
<td>
<p>The number of hidden regimes.</p>
</td></tr>
<tr><td><code id="updateVm_+3A_u">U</code></td>
<td>
<p>The latent node positions.</p>
</td></tr>
<tr><td><code id="updateVm_+3A_v">V</code></td>
<td>
<p>The layer-specific network generation rule.</p>
</td></tr>
<tr><td><code id="updateVm_+3A_zm">Zm</code></td>
<td>
<p>The holder of Z - beta.</p>
</td></tr>
<tr><td><code id="updateVm_+3A_km">Km</code></td>
<td>
<p>The dimension of regime-specific Z.</p>
</td></tr>
<tr><td><code id="updateVm_+3A_r">R</code></td>
<td>
<p>The dimension of latent space.</p>
</td></tr>
<tr><td><code id="updateVm_+3A_s2">s2</code></td>
<td>
<p>The variance of error.</p>
</td></tr>
<tr><td><code id="updateVm_+3A_ev">eV</code></td>
<td>
<p>The mean of V</p>
</td></tr>
<tr><td><code id="updateVm_+3A_ivv">iVV</code></td>
<td>
<p>The variance of V</p>
</td></tr>
<tr><td><code id="updateVm_+3A_uta">UTA</code></td>
<td>
<p>Indicator of upper triangular array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of regime-specific layer specific network generation rules
</p>

<hr>
<h2 id='WaicCompare'>Compare WAIC</h2><span id='topic+WaicCompare'></span>

<h3>Description</h3>

<p>Compare Widely Applicable Information Criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WaicCompare(outlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WaicCompare_+3A_outlist">outlist</code></td>
<td>
<p>List of NetworkChange objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results of WAIC computation
</p>
<p>A matrix of log marginal likelihoods.
</p>


<h3>References</h3>

<p>Sumio Watanabe. 2010. &quot;Asymptotic equivalence of Bayes cross validation and widely
applicable information criterion in singular learning theory.&quot;
<em>Journal of Machine Learning Research</em>. 11: 3571-3594.
</p>
<p>Andrew Gelman, Jessica Hwang, and Aki Vehtari. 2014. &quot;Understanding predictive information
criteria for Bayesian models.&quot; <em>Statistics and Computing</em>. 24(6):997-1016.
</p>
<p>Jong Hee Park and Yunkyun Sohn. 2020. &quot;Detecting Structural Change
in Longitudinal Network Data.&quot; <em>Bayesian Analysis</em>. Vol.15, No.1, pp.133-157.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MarginalCompare">MarginalCompare</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
