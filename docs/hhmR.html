<!DOCTYPE html><html lang="en-UK"><head><title>Help for package hhmR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hhmR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#cg'><p>cg</p></a></li>
<li><a href='#decimalplaces'><p>decimalplaces</p></a></li>
<li><a href='#example_migration'><p>example_migration</p></a></li>
<li><a href='#example_time_series'><p>example_time_series</p></a></li>
<li><a href='#exp_seq'><p>exp_seq</p></a></li>
<li><a href='#hhm'><p>Hierarchical Heatmap</p></a></li>
<li><a href='#log_seq'><p>log_seq</p></a></li>
<li><a href='#plt_ttl'><p>plt_ttl</p></a></li>
<li><a href='#tshhm'><p>Time-series Hierarchical Heatmap</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hierarchical Heatmaps</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Mahony &lt;michael.mahony@cantab.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows users to create high-quality heatmaps from labelled, hierarchical data. Specifically, for data with a two-level hierarchical structure, it will produce a heatmap where each row and column represents a category at the lower level. These rows and columns are then grouped by the higher-level group each category belongs to, with the names for each category and groups shown in the margins. While other packages (e.g. 'dendextend') allow heatmap rows and columns to be arranged by groups only, 'hhmR' also allows the labelling of the data at both the category and group level.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sgmmahon/hhmR">https://github.com/sgmmahon/hhmR</a>, <a href="https://sgmmahon.github.io/hhmR/">https://sgmmahon.github.io/hhmR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sgmmahon/hhmR/issues">https://github.com/sgmmahon/hhmR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, purrr, tidyr, rlang, grid, ggplot2, patchwork,
grDevices, magrittr, utils</td>
</tr>
<tr>
<td>Language:</td>
<td>en-UK</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-13 19:56:44 UTC; MAH113916</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Mahony <a href="https://orcid.org/0000-0003-2784-2745"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut, cph],
  Francisco Rowe <a href="https://orcid.org/0000-0003-4137-0246"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Carmen Cabrera-Arnau
    <a href="https://orcid.org/0000-0002-2732-6436"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-14 15:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='cg'>cg</h2><span id='topic+cg'></span>

<h3>Description</h3>

<p>Creates colour gradient between two hexcodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cg(colour1, colour2, n = 15)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cg_+3A_colour1">colour1</code></td>
<td>
<p>The first hexcode colour.</p>
</td></tr>
<tr><td><code id="cg_+3A_colour2">colour2</code></td>
<td>
<p>The second hexcode colour.</p>
</td></tr>
<tr><td><code id="cg_+3A_n">n</code></td>
<td>
<p>The length of the vector returned by the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of hexcodes of length n, containing a colour gradient between colour =1 and colour2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cg("white","black",20)

</code></pre>

<hr>
<h2 id='decimalplaces'>decimalplaces</h2><span id='topic+decimalplaces'></span>

<h3>Description</h3>

<p>Tests the number of non-zero decimal places within a number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decimalplaces(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decimalplaces_+3A_x">x</code></td>
<td>
<p>The number for the number of decimal places is to be measured.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number, indicating the number of non-zero decimal places in 'x'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decimalplaces(23.43234525)
decimalplaces(334.3410000000000000)
decimalplaces(2.000)

</code></pre>

<hr>
<h2 id='example_migration'>example_migration</h2><span id='topic+example_migration'></span>

<h3>Description</h3>

<p>Fake migration dataset used to demonstrate the functionality of the hhm function in the hhmR package.
It contains the information on the number of people who have moved between a series of fictional
geographies. The geographies themselves have a hierarchical structure, with each county existing within
a smaller subset of regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(example_migration)
</code></pre>


<h3>Format</h3>

<p>A data frame with 324 rows and 5 variables.
</p>

<dl>
<dt>Origin County     </dt><dd><p>The county (lower-level geography) that each migrant began in.    </p>
</dd>
<dt>Destination County</dt><dd><p>The county (lower-level geography) that each migrant ended up in. </p>
</dd>
<dt>Origin Region     </dt><dd><p>The region (higher-level geography) that each migrant began in.   </p>
</dd>
<dt>Destination Region</dt><dd><p>The region (higher-level geography) that each migrant ended up in.</p>
</dd>
<dt>Migration         </dt><dd><p>The number of migrants that moved from each origin county to each destination county.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Code to create dataset

# Define names of fake counties
fake_counties = c("Greenridge","Windermoor","Bramblewood","Silverlake",
                  "Thornbury","Maplewood","Hawthorne","Pinehurst",
                  "Riverton","Meadowbrook","Fairhaven","Oakdale","Stonebridge",
                  "Brookfield","Ashford","Glenville","Sunnyvale","Westfield")

# Create region county lookup tables
rc_lkp = data.frame(region = c(rep("North",3),rep("Midlands",5),
                               rep("South West",4),rep("South East",6)),
                    county = fake_counties)
og_lkp = rc_lkp %&gt;% setNames(c("Origin Region"     ,"Origin County"     ))
dn_lkp = rc_lkp %&gt;% setNames(c("Destination Region","Destination County"))

# Create dataframe of fake migration data
set.seed(1234)
example_migration = expand.grid(fake_counties,fake_counties) %&gt;%
                    setNames(paste(c("Origin","Destination"),"County",sep=" ")) %&gt;%
                    full_join(og_lkp) %&gt;% full_join(dn_lkp) %&gt;%
                    mutate(Migration = (1/rgamma(18*18, shape = 17, rate = 0.5)) %&gt;%
                                       {. * 1000} %&gt;% round())
example_migration[example_migration$`Origin County` ==
                  example_migration$`Destination County`,"Migration"] =
 example_migration[example_migration$`Origin County` ==
                   example_migration$`Destination County`,"Migration"] * 10
</code></pre>

<hr>
<h2 id='example_time_series'>example_time_series</h2><span id='topic+example_time_series'></span>

<h3>Description</h3>

<p>Fake migration dataset used to demonstrate the functionality of the tshm function in the hhmR package.
It contains the information on the number of people who have immigrated a series of fictional
geographies over the years 2011 to 2015. The geographies themselves have a hierarchical structure,
with each county existing within a smaller subset of regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(example_time_series)
</code></pre>


<h3>Format</h3>

<p>A data frame with 90 rows and 4 variables.
</p>

<dl>
<dt>County     </dt><dd><p>The county (lower-level geography) that immigrants move to.    </p>
</dd>
<dt>Region     </dt><dd><p>The region (higher-level geography) that immigrants move to.   </p>
</dd>
<dt>Year       </dt><dd><p>The year during which each wave of immigration occured.        </p>
</dd>
<dt>Immigration</dt><dd><p>The number of immigrants that moved each county in each year.  </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tidyr)

# Define names of fake counties
fake_counties = c("Greenridge","Windermoor","Bramblewood","Silverlake",
                  "Thornbury","Maplewood","Hawthorne","Pinehurst",
                  "Riverton","Meadowbrook","Fairhaven","Oakdale","Stonebridge",
                  "Brookfield","Ashford","Glenville","Sunnyvale","Westfield")

# Create dataframe of fake migration data
set.seed(1234)
example_time_series = data.frame(region = c(rep("North",3),rep("Midlands",5),
                                            rep("South West",4),rep("South East",6)),
                                 county = fake_counties,
                                 year_2011 = sample(1:10000,length(fake_counties)),
                                 year_2012 = sample(1:10000,length(fake_counties)),
                                 year_2013 = sample(1:10000,length(fake_counties)),
                                 year_2014 = sample(1:10000,length(fake_counties)),
                                 year_2015 = sample(1:10000,length(fake_counties))) %&gt;%
  setNames(c("Region","County",2011:2015)) %&gt;%
  pivot_longer(cols = `2011`:`2015`,
                      names_to = "Year",
                      values_to = "Immigration") %&gt;%
  mutate(Year = as.numeric(Year))
example_time_series[sample(1:(length(fake_counties)*5),5),"Immigration"] = NA
</code></pre>

<hr>
<h2 id='exp_seq'>exp_seq</h2><span id='topic+exp_seq'></span>

<h3>Description</h3>

<p>Creates a vector of exponentially increasing values between 0 and a specified value 'n'.
If 'n' is specified as 1, the vector will be scaled to between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp_seq(n, ln = 15, exponent = 2, round_values = TRUE, rmv_extremes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exp_seq_+3A_n">n</code></td>
<td>
<p>The maximum value that the values in the sequence are scaled to.</p>
</td></tr>
<tr><td><code id="exp_seq_+3A_ln">ln</code></td>
<td>
<p>How long the vector should be (defaults to 15).</p>
</td></tr>
<tr><td><code id="exp_seq_+3A_exponent">exponent</code></td>
<td>
<p>The exponential power with which to multiply the sequence by (defaults to 2).</p>
</td></tr>
<tr><td><code id="exp_seq_+3A_round_values">round_values</code></td>
<td>
<p>Option to round values to whole numbers (defaults to 'TRUE'). If 'n' equals 1,
round_values will automatically be set to FALSE.</p>
</td></tr>
<tr><td><code id="exp_seq_+3A_rmv_extremes">rmv_extremes</code></td>
<td>
<p>Option to remove zero and the maximum value (i.e. 'n') from the beginning
and the end of the returned vector (defaults to 'FALSE'). Note that this will mean the length
of the returned vector will be 'n' - 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing exponentially increasing values between 0 and a specified value 'n'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create sequence of length 8, scaled between 0 and 10000
exp_seq(10000,8)
# Set rmv_extremes = FALSE to get full sequence
exp_seq(10000,8,rmv_extremes = FALSE)
# The exponent defaults to 2. Setting it to between 1 and 2 causes it to converge on
# a linear sequence. When exponent is set to 1 the sequence increases linearly
exp_seq(10000,8,exponent=1)
# Setting it to greater than 2 will cause it the values in the sequence to shift towards zero
exp_seq(10000,8,exponent=4)

# Create sequence of length 12, scaled between 0 and 1
exp_seq(1,12)
exp_seq(1,12,rmv_extremes = FALSE)
exp_seq(1,12,exponent=1)
exp_seq(1,12,exponent=4)

</code></pre>

<hr>
<h2 id='hhm'>Hierarchical Heatmap</h2><span id='topic+hhm'></span>

<h3>Description</h3>

<p>Creates a labelled heatmap from heirarchical data. This function is
useful if you wish to create a heatmap where the categories shown on both the x
and y axis can be grouped in some way. This heatmap will order the categories by
their assigned group and present both the categories and group labels along the
axes. An example might be a series of smaller geographies (lower categories) which
aggregate into larger geographical regions (upper groups).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hhm(
  df,
  ylower,
  yupper,
  xlower,
  xupper,
  values,
  rm_diag = FALSE,
  lgttl = NULL,
  bins = NULL,
  cbrks = NULL,
  cclrs = NULL,
  norm_lgd = FALSE,
  lgdps = 0,
  xttl_height = 0.15,
  yttl_width = 0.15
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hhm_+3A_df">df</code></td>
<td>
<p>A data.frame with containing values with which to populate the heatmap.
The data.frame must include columns specifying the lower categories ('ylower',
'xlower') and upper groups ('yupper', 'xupper') that each value corresponds to.
These categories and groups will be used to arrange and label the rows and
columns of the heatmap. It must also contain a 'values' variable containing the
values used to populate the heatmap. Note that the groups will by default be
arranged alphabetically (top to bottom / left to right). The ordering of the
groups can be manually specified by converting yupper and/or xupper to factors.
In this case, the groups will be ordered based on the ordering of the factor
levels.</p>
</td></tr>
<tr><td><code id="hhm_+3A_ylower">ylower</code></td>
<td>
<p>A column in 'df' containing the categories that will be presented
as rows along the y-axis of the heatmap.</p>
</td></tr>
<tr><td><code id="hhm_+3A_yupper">yupper</code></td>
<td>
<p>A column in 'df' containing the groupings that will be used to
arrange the heatmap rows.</p>
</td></tr>
<tr><td><code id="hhm_+3A_xlower">xlower</code></td>
<td>
<p>A column in 'df' containing the categories that will be presented
as columns along the x-axis of the heatmap.</p>
</td></tr>
<tr><td><code id="hhm_+3A_xupper">xupper</code></td>
<td>
<p>A column in 'df' containing the groupings that will be used to
arrange the heatmap columns.</p>
</td></tr>
<tr><td><code id="hhm_+3A_values">values</code></td>
<td>
<p>A column in 'df' containing the values used to populate the
heatmap.</p>
</td></tr>
<tr><td><code id="hhm_+3A_rm_diag">rm_diag</code></td>
<td>
<p>Do not show values for categories along the x and y axes that
are identical (defaults to 'FALSE'). This is particularly useful for
origin-destination heatmaps, where the user may want to hide the diagonal
values.</p>
</td></tr>
<tr><td><code id="hhm_+3A_lgttl">lgttl</code></td>
<td>
<p>Option to manually define legend title.</p>
</td></tr>
<tr><td><code id="hhm_+3A_bins">bins</code></td>
<td>
<p>Option to break the data into a specified number of groups
(defaults to 'NULL'). The thresholds between these groups will be equally
spaced between zero and the maximum value observed in 'values'.</p>
</td></tr>
<tr><td><code id="hhm_+3A_cbrks">cbrks</code></td>
<td>
<p>Vector of custom breaks, if users wish to use a discrete legend
colour scheme (defaults to 'NULL'). For example, a supplied vector of 'c(5,10,
20)' would break he values up into 5 ordered groups of ranges 0, 0-5, 5-10,
10-20 and 20+.</p>
</td></tr>
<tr><td><code id="hhm_+3A_cclrs">cclrs</code></td>
<td>
<p>Vector of hexcodes, which to create a custom legend colour scheme
(defaults to 'NULL'). If 'cbrks' is supplied, 'cclrs' must have a length
two longer than 'cbrks'. If 'bins' is supplied, 'cclrs' must have a length
equal to the values provided to 'bins'.</p>
</td></tr>
<tr><td><code id="hhm_+3A_norm_lgd">norm_lgd</code></td>
<td>
<p>Normalised to between 0 and 1 in legend (defaults to 'FALSE').
Allows for consistency when comparing heatmaps across different datasets. At
present, this only works if all heatmap values are positive.</p>
</td></tr>
<tr><td><code id="hhm_+3A_lgdps">lgdps</code></td>
<td>
<p>If using custom breaks, define the number of decimal points to
round the legend scale to (defaults to 0). If 'norm_lgd' is 'TRUE', it will
default to 3.</p>
</td></tr>
<tr><td><code id="hhm_+3A_xttl_height">xttl_height</code></td>
<td>
<p>The space allocated to the group titles on the x-axis as a
proportion of the heatmap's height (defaults to 0.15).</p>
</td></tr>
<tr><td><code id="hhm_+3A_yttl_width">yttl_width</code></td>
<td>
<p>The space allocated to the group titles on the y-axis as a
proportion of the heatmap's width (defaults to 0.15).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object containing the final heatmap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import toy demonstration dataset (see `?example_migration` for see details)
data(example_migration)

# Intial heatmap
hierarchical_heatmap = hhm(df = example_migration,
                           ylower = "Origin County",
                           xlower = "Destination County",
                           yupper = "Origin Region",
                           xupper = "Destination Region",
                           values = "Migration",
                           yttl_width = 0.22,
                           xttl_height = 0.4)

# For more details, see the package vignette at
# https://sgmmahon.github.io/hhmR/articles/hhmR_overview.html
</code></pre>

<hr>
<h2 id='log_seq'>log_seq</h2><span id='topic+log_seq'></span>

<h3>Description</h3>

<p>Creates a vector of logarithmicly increasing values between 0 and a specified value 'n'.
If 'n' is specified as 1, the vector will be scaled to between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_seq(n, ln = 15, round_values = TRUE, rmv_extremes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_seq_+3A_n">n</code></td>
<td>
<p>The maximum value that the values in the sequence are scaled to.</p>
</td></tr>
<tr><td><code id="log_seq_+3A_ln">ln</code></td>
<td>
<p>How long the vector should be (defaults to 15).</p>
</td></tr>
<tr><td><code id="log_seq_+3A_round_values">round_values</code></td>
<td>
<p>Option to round values to whole numbers (defaults to 'TRUE').</p>
</td></tr>
<tr><td><code id="log_seq_+3A_rmv_extremes">rmv_extremes</code></td>
<td>
<p>Option to remove zero and the maximum value (i.e. 'n') from the beginning
and the end of the returned vector (defaults to 'FALSE'). Note that this will mean the length
of the returned vector will be 'n' - 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing logarithmicly increasing values between 0 and a specified value 'n'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create sequence of length 20, scaled between 0 and 500
log_seq(500,20)

# Create sequence of length 15, scaled between 0 and 1
log_seq(1,12)

</code></pre>

<hr>
<h2 id='plt_ttl'>plt_ttl</h2><span id='topic+plt_ttl'></span>

<h3>Description</h3>

<p>Creates plot containing the name of a given upper group. Used in combination with the
patchwork package to plot the names of the upper groups within the hhm function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt_ttl(ttl, axs = "x", rotate_title = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plt_ttl_+3A_ttl">ttl</code></td>
<td>
<p>The name of the upper group.</p>
</td></tr>
<tr><td><code id="plt_ttl_+3A_axs">axs</code></td>
<td>
<p>The axis on which the name will appear (defaults to &quot;x&quot;). If 'x', the text will be
written at the top-centre of the plot. If 'y', the text will be written at the middle-right of the
plot.</p>
</td></tr>
<tr><td><code id="plt_ttl_+3A_rotate_title">rotate_title</code></td>
<td>
<p>Whether the title should be rotate to be perpendicular to the axis (defaults
to TRUE). If TRUE, the title text on the x and y axes will be printed horizontally and vertically
respectively, with the reverse orientation if set to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object containing the title of a given upper group, for use in the hhm function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plt_ttl("Group 1", axs = "y")
plt_ttl("Group 2")
plt_ttl("Group 1", axs = "y",rotate_title = FALSE)
plt_ttl("Group 2"           ,rotate_title = FALSE)

</code></pre>

<hr>
<h2 id='tshhm'>Time-series Hierarchical Heatmap</h2><span id='topic+tshhm'></span>

<h3>Description</h3>

<p>Creates a labelled time-series heatmap from heirarchical data. This
function is useful if you wish to create a time-series heatmap where the
categories shown on the y axis can be grouped in some way. This heatmap
will order the categories by their assigned group and present both the categories
and group labels along the y-axis. An example might be series of smaller
geographies (lower categories) which aggregate into larger geographical regions
(upper groups).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tshhm(
  df,
  lower,
  upper,
  times,
  values,
  sort_lower = "alphabetical",
  lgttl = NULL,
  bins = NULL,
  cbrks = NULL,
  cclrs = NULL,
  norm_lgd = FALSE,
  lgdps = 0,
  na_colour = NULL,
  xttl_height = 0.05,
  yttl_width = 0.15
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tshhm_+3A_df">df</code></td>
<td>
<p>A data.frame with containing values with which to populate the heatmap.
The data.frame must include columns specifying the lower categories ('lower') and
upper groups ('upper') that each value corresponds to. These categories and
groups will be used to arrange and label the rows of the heatmap. 'df' must also
contain a 'values' variable, containing the values used to populate the heatmap,
and a 'times' variable, containing the time period during which each value was
observed. Note that the groups in 'upper' will by default be arranged
alphabetically (top to bottom). The ordering of the groups can be manually
specified by converting 'upper' to a factor. In this case, the groups
will be ordered based on the ordering of the factor levels. The ordering of rows
within each group can also be specified using the 'sort_lower' variable.</p>
</td></tr>
<tr><td><code id="tshhm_+3A_lower">lower</code></td>
<td>
<p>A column in 'df' containing the categories that will be presented
as rows along the y-axis of the heatmap.</p>
</td></tr>
<tr><td><code id="tshhm_+3A_upper">upper</code></td>
<td>
<p>A column in 'df' containing the groupings that will be used to
arrange the heatmap rows.</p>
</td></tr>
<tr><td><code id="tshhm_+3A_times">times</code></td>
<td>
<p>A column in 'df' containing the time-period during which each
each value in 'values' was observed.</p>
</td></tr>
<tr><td><code id="tshhm_+3A_values">values</code></td>
<td>
<p>A column in 'df' containing the values used to populate the
heatmap.</p>
</td></tr>
<tr><td><code id="tshhm_+3A_sort_lower">sort_lower</code></td>
<td>
<p>Option to define how rows (lower) within each group (upper)
are ordered. The default option is 'alphabetical', which orders rows in
alphabetical order from top to bottom. Other options include 'sum_ascend' and
'mean_ascend', which order rows in ascending order (top to bottom) based on
the row totals and row means respectively. This order can be reversed with the
options 'sum_descend' and 'mean_descend'.</p>
</td></tr>
<tr><td><code id="tshhm_+3A_lgttl">lgttl</code></td>
<td>
<p>Option to manually define legend title.</p>
</td></tr>
<tr><td><code id="tshhm_+3A_bins">bins</code></td>
<td>
<p>Option to break the data into a specified number of groups
(defaults to 'NULL'). The thresholds between these groups will be equally
spaced between the minimum and maximum values observed in 'values'.</p>
</td></tr>
<tr><td><code id="tshhm_+3A_cbrks">cbrks</code></td>
<td>
<p>Vector of custom breaks, if users wish to use a discrete legend
colour scheme (defaults to 'NULL'). For example, a supplied vector of 'c(5,10,
20)' would break he values up into 5 ordered groups of ranges 0, 0-5, 5-10,
10-20 and 20+.</p>
</td></tr>
<tr><td><code id="tshhm_+3A_cclrs">cclrs</code></td>
<td>
<p>Vector of hexcodes, which to create a custom legend colour scheme
(defaults to 'NULL'). If 'cbrks' is supplied, 'cclrs' must have a length
two longer than 'cbrks'. If 'bins' is supplied, 'cclrs' must have a length
equal to the values provided to 'bins'.</p>
</td></tr>
<tr><td><code id="tshhm_+3A_norm_lgd">norm_lgd</code></td>
<td>
<p>Normalised to between 0 and 1 in legend (defaults to 'FALSE').
Allows for consistency when comparing heatmaps across different datasets. At
present, this only works if all heatmap values are positive.</p>
</td></tr>
<tr><td><code id="tshhm_+3A_lgdps">lgdps</code></td>
<td>
<p>If using custom breaks, define the number of decimal points to
round the legend scale to (defaults to 0). If 'norm_lgd' is 'TRUE', it will
default to 3.</p>
</td></tr>
<tr><td><code id="tshhm_+3A_na_colour">na_colour</code></td>
<td>
<p>Option to define the colour of NA values in the legend (defaults
to 'NULL', meaning NA values will be assigned no colour).</p>
</td></tr>
<tr><td><code id="tshhm_+3A_xttl_height">xttl_height</code></td>
<td>
<p>The space allocated to the title on the x-axis as a
proportion of the heatmap's height (defaults to 0.05).</p>
</td></tr>
<tr><td><code id="tshhm_+3A_yttl_width">yttl_width</code></td>
<td>
<p>The space allocated to the group titles on the y-axis as a
proportion of the heatmap's width (defaults to 0.15).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object containing the final heatmap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Import toy demonstration dataset (see `?example_time_series` for see details)
data(example_time_series)

# Intial heatmap
time_series_heatmap = tshhm(df = example_time_series,
                            lower  = "County",
                            upper  = "Region",
                            times  = "Year",
                            values = "Immigration",
                            yttl_width  = 0.25)

# View result
time_series_heatmap

# For more details, see the package vignette at
# https://sgmmahon.github.io/hhmR/articles/hhmR_overview.html
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
