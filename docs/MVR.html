<!DOCTYPE html><html><head><title>Help for package MVR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MVR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cluster.diagnostic'><p>Function for Plotting Summary Cluster Diagnostic Plots</p></a></li>
<li><a href='#mvr'><p>Function for Mean-Variance Regularization and Variance Stabilization</p></a></li>
<li><a href='#MVR-package'><p>Mean-Variance Regularization Package</p></a></li>
<li><a href='#MVR.news'><p>Function to Display the NEWS File</p></a></li>
<li><a href='#mvrt.test'><p>Function for Computing Mean-Variance Regularized T-test Statistic and Its Significance</p></a></li>
<li><a href='#normalization.diagnostic'><p>Function for Plotting Summary Normalization Diagnostic Plots</p></a></li>
<li><a href='#Real'><p>Real Proteomics Dataset</p></a></li>
<li><a href='#stabilization.diagnostic'><p>Function for Plotting Summary Variance Stabilization Diagnostic Plots</p></a></li>
<li><a href='#Synthetic'><p>Multi-Groups Synthetic Dataset</p></a></li>
<li><a href='#target.diagnostic'><p>Function for Plotting Summary Target Moments Diagnostic Plots</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mean-Variance Regularization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.33.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-09-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Jean-Eudes Dazard [aut, cre],
  Hua Xu [ctb],
  Alberto Santana [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jean-Eudes Dazard &lt;jean-eudes.dazard@case.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This is a non-parametric method for joint adaptive mean-variance regularization and variance stabilization of high-dimensional data. It is suited for handling difficult problems posed by high-dimensional multivariate datasets (p &gt;&gt; n paradigm). Among those are that the variance is often a function of the mean, variable-specific estimators of variances are not reliable, and tests statistics have low powers due to a lack of degrees of freedom. Key features include:
            (i) Normalization and/or variance stabilization of the data,
            (ii) Computation of mean-variance-regularized t-statistics (F-statistics to follow),
            (iii) Generation of diverse diagnostic plots,
            (iv) Computationally efficient implementation using C/C++ interfacing and an option for parallel computing to enjoy a faster and easier experience in the R environment.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), statmod</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, methods</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jedazard/MVR">https://github.com/jedazard/MVR</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a> | file LICENSE</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Archs:</td>
<td>i386, x64</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-09-10 16:45:39 UTC; Admin</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-09-10 18:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='cluster.diagnostic'>Function for Plotting Summary Cluster Diagnostic Plots</h2><span id='topic+cluster.diagnostic'></span>

<h3>Description</h3>

<p>Plot similarity statistic profiles and the optimal joint clustering configuration for the means and the variances by group.
</p>
<p>Plot quantile profiles of means and standard deviations by group and for each clustering configuration, to check that the distributions 
of first and second moments of the MVR-transformed data approach their respective null distributions under the optimal configuration found, 
assuming independence and normality of all the variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    cluster.diagnostic(obj, 
                       span = 0.75, 
                       degree = 2, 
                       family = "gaussian", 
                       title = "Cluster Diagnostic Plots", 
                       device = NULL, 
                       file = "Cluster Diagnostic Plots",
                       path = getwd(),
                       horizontal = FALSE, 
                       width = 8.5, 
                       height = 11, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster.diagnostic_+3A_obj">obj</code></td>
<td>
<p>Object of class &quot;<code>mvr</code>&quot; returned by <code><a href="#topic+mvr">mvr</a></code>.</p>
</td></tr>
<tr><td><code id="cluster.diagnostic_+3A_title">title</code></td>
<td>
<p>Title of the plot. Defaults to &quot;Cluster Diagnostic Plots&quot;.</p>
</td></tr>
<tr><td><code id="cluster.diagnostic_+3A_span">span</code></td>
<td>
<p>Span parameter of the <code>loess()</code> function (R package <span class="pkg">stats</span>), which controls the degree of smoothing. 
Defaults to 0.75.</p>
</td></tr>
<tr><td><code id="cluster.diagnostic_+3A_degree">degree</code></td>
<td>
<p>Degree parameter of the <code>loess()</code> function (R package <span class="pkg">stats</span>), which controls the degree of the polynomials to be used. 
Defaults to 2. (Normally 1 or 2. Degree 0 is also allowed, but see the &quot;Note&quot; in loess stats package.)</p>
</td></tr>
<tr><td><code id="cluster.diagnostic_+3A_family">family</code></td>
<td>
<p>Family distribution in &quot;gaussian&quot;, &quot;symmetric&quot; of the <code>loess()</code> function (R package <span class="pkg">stats</span>), used for local fitting .
If &quot;gaussian&quot; fitting is by least-squares, and if &quot;symmetric&quot; a re-descending M estimator is used with Tukey's biweight function.</p>
</td></tr>
<tr><td><code id="cluster.diagnostic_+3A_device">device</code></td>
<td>
<p>Graphic display device in {NULL, &quot;PS&quot;, &quot;PDF&quot;}. Defaults to NULL (standard output screen).
Currently implemented graphic display devices are &quot;PS&quot; (Postscript) or &quot;PDF&quot; (Portable Document Format).</p>
</td></tr>
<tr><td><code id="cluster.diagnostic_+3A_file">file</code></td>
<td>
<p>File name for output graphic. Defaults to &quot;Cluster Diagnostic Plots&quot;.</p>
</td></tr>
<tr><td><code id="cluster.diagnostic_+3A_path">path</code></td>
<td>
<p>Absolute path (without final (back)slash separator). Defaults to working directory path.</p>
</td></tr>
<tr><td><code id="cluster.diagnostic_+3A_horizontal">horizontal</code></td>
<td>
<p><code>Logical</code> scalar. Orientation of the printed image. Defaults to <code>FALSE</code>, that is potrait orientation.</p>
</td></tr>
<tr><td><code id="cluster.diagnostic_+3A_width">width</code></td>
<td>
<p><code>Numeric</code> scalar. Width of the graphics region in inches. Defaults to 8.5.</p>
</td></tr>
<tr><td><code id="cluster.diagnostic_+3A_height">height</code></td>
<td>
<p><code>Numeric</code> scalar. Height of the graphics region in inches. Defaults to 11.</p>
</td></tr>
<tr><td><code id="cluster.diagnostic_+3A_...">...</code></td>
<td>
<p>Generic arguments passed to other plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a plot of a similarity statistic profile, one checks the goodness of fit of the transformed data relative to the hypothesized underlying reference 
distribution with mean-0 and standard deviation-1 (e.g. <code class="reqn">N(0, 1)</code>). The red dashed line depicts the LOESS scatterplot smoother estimator.
The subroutine internally generates reference null distributions for computing the similarity statistic under each cluster configuration. 
The optimal cluster configuration (indicated by the vertical red arrow) is found where the similarity statistic reaches its minimum plus/minus 
one standard deviation (applying the conventional one-standard deviation rule). A smaller cluster number configuration indicates under-regularization, 
while over-regularization starts to occur at larger numbers. This over/under-regularization must be viewed as a form of over/under-fitting 
(see <cite>Dazard, J-E. and J. S. Rao (2012)</cite> for more details).
The quantile diagnostic plots uses empirical quantiles of the transformed means and standard deviations to check how 
closely they are approximated by theoretical quantiles derived from a standard normal <em>equal-mean</em>/<em>homoscedastic</em> 
model (solid green lines) under a given cluster configuration. To assess this goodness of fit of the transformed data, theoretical null distributions 
of the mean and variance are derived from a standard normal <em>equal-mean</em>/<em>homoscedastic</em> model with independence of the first two moments, 
i.e. assuming i.i.d. normality of the raw data. However, we do not require i.i.d. normality of the data in general: these theoretical null distributions are 
just used here as convenient ones to draw from. Note that under the assumptions that the raw data is i.i.d. standard normal ($N(0, 1)$) 
with independence of first two moments, the theoretical null distributions of means and standard deviations for each variable 
are respectively: <code class="reqn">N(0, \frac{1}{n})</code> and <code class="reqn">\sqrt{\frac{\chi_{n - G}^{2}}{n - G}}</code>, where <code class="reqn">G</code> denotes the number of sample groups. 
The optimal cluster configuration found is indicated by the most horizontal red curve. The single cluster configuration, corresponding to no transformation, 
is the most vertical curve, while the largest cluster number configuration reaches horizontality. Notice how empirical quantiles of transformed
pooled means and standard deviations converge (from red to black) to the theoretical null distributions (solid green lines) for the optimal 
configuration. One should see a convergence towards the target null, after which overfitting starts to occur (see <cite>Dazard, J-E. and J. S. Rao (2012)</cite> 
for more details).
Both cluster diagnostic plots help determine (i) whether the minimum of the <em>Similarity Statistic</em> is observed within the range of clusters 
(i.e. a large enough number of clusters has been accommodated), and (ii) whether the corresponding cluster configuration is a good fit. 
If necessary, run the procedure again with larger value of the <code>nc.max</code> parameter in the <code><a href="#topic+mvr">mvr</a></code> as well as 
in <code><a href="#topic+mvrt.test">mvrt.test</a></code> functions until the minimum of the similarity statistic profile is reached.       
</p>
<p>Option <code>file</code> is used only if device is specified (i.e. non <code>NULL</code>).
</p>


<h3>Value</h3>

<p>None. Displays the plots on the chosen <code>device</code>.
</p>


<h3>Acknowledgments</h3>

<p>This work made use of the High Performance Computing Resource in the Core Facility for Advanced Research Computing at Case Western Reserve University. 
This project was partially funded by the National Institutes of Health (P30-CA043703).
</p>


<h3>Note</h3>

<p>End-user function.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>
</p>
</li>
<li><p> &quot;Hua Xu, Ph.D.&quot; <a href="mailto:huaxu77@gmail.com">huaxu77@gmail.com</a>
</p>
</li>
<li><p> &quot;Alberto Santana, MBA.&quot; <a href="mailto:ahs4@case.edu">ahs4@case.edu</a>
</p>
</li></ul>

<p>Maintainer: &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>    
</p>


<h3>References</h3>


<ul>
<li><p> Dazard J-E. and J. S. Rao (2010). &quot;<em>Regularized Variance Estimation and Variance Stabilization of High-Dimensional Data.</em>&quot;
In JSM Proceedings, Section for High-Dimensional Data Analysis and Variable Selection. 
Vancouver, BC, Canada: American Statistical Association IMS - JSM, 5295-5309.
</p>
</li>
<li><p> Dazard J-E., Hua Xu and J. S. Rao (2011). &quot;<em>R package MVR for Joint Adaptive Mean-Variance Regularization and Variance Stabilization.</em>&quot;
In JSM Proceedings, Section for Statistical Programmers and Analysts. 
Miami Beach, FL, USA: American Statistical Association IMS - JSM, 3849-3863.
</p>
</li>
<li><p> Dazard J-E. and J. S. Rao (2012). &quot;<em>Joint Adaptive Mean-Variance Regularization and Variance Stabilization of High Dimensional Data.</em>&quot;
Comput. Statist. Data Anal. 56(7):2317-2333.
</p>
</li></ul>



<h3>See Also</h3>

<p><code>loess</code> (R package <span class="pkg">stats</span>) Fit a polynomial surface determined by one or more numerical predictors, using local fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    #===================================================
    # Loading the library and its dependencies
    #===================================================
    library("MVR")

    #===================================================
    # MVR package news
    #===================================================
    MVR.news()

    #================================================
    # MVR package citation
    #================================================
    citation("MVR")

    #===================================================
    # Loading of the Synthetic and Real datasets
    # (see description of datasets)
    #===================================================
    data("Synthetic", "Real", package="MVR")
    ?Synthetic
    ?Real

    #===================================================
    # Mean-Variance Regularization (Real dataset)
    # Multi-Group Assumption
    # Assuming unequal variance between groups
    # Without cluster usage
    ===================================================
    nc.min &lt;- 1
    nc.max &lt;- 30
    probs &lt;- seq(0, 1, 0.01)
    n &lt;- 6
    GF &lt;- factor(gl(n = 2, k = n/2, length = n), 
                 ordered = FALSE, 
                 labels = c("M", "S"))
    mvr.obj &lt;- mvr(data = Real, 
                   block = GF, 
                   log = FALSE, 
                   nc.min = nc.min, 
                   nc.max = nc.max, 
                   probs = probs,
                   B = 100, 
                   parallel = FALSE, 
                   conf = NULL,
                   verbose = TRUE,
                   seed = 1234)

    #===================================================
    # Summary Cluster Diagnostic Plots (Real dataset)
    # Multi-Group Assumption
    # Assuming unequal variance between groups
    #===================================================
    cluster.diagnostic(obj = mvr.obj, 
                       title = "Cluster Diagnostic Plots 
                       (Real - Multi-Group Assumption)",
                       span = 0.75, 
                       degree = 2, 
                       family = "gaussian",
                       device = NULL,
                       horizontal = FALSE, 
                       width = 8.5, 
                       height = 11)

    
## End(Not run)
</code></pre>

<hr>
<h2 id='mvr'>Function for Mean-Variance Regularization and Variance Stabilization</h2><span id='topic+mvr'></span>

<h3>Description</h3>

<p>End-user function for Mean-Variance Regularization (MVR) and Variance Stabilization by similarity statistic
under sample group homoscedasticity or heteroscedasticity assumptions.
</p>
<p>Return an object of class &quot;<code>mvr</code>&quot;. Offers the option of parallel computation for improved efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    mvr(data,
        block = rep(1,nrow(data)),
        tolog = FALSE,
        nc.min = 1,
        nc.max = 30,
        probs = seq(0, 1, 0.01),
        B = 100,
        parallel = FALSE,
        conf = NULL,
        verbose = TRUE, 
        seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvr_+3A_data">data</code></td>
<td>
<p><code>numeric</code> <code>matrix</code> of untransformed (raw) data,
where samples are by rows and variables (to be clustered) are by columns,
or an object that can be coerced to such a <code>matrix</code> (such as a <code>numeric</code> <code>vector</code>
or a <code>data.frame</code> with all <code>numeric</code> columns).
Missing values (<code>NA</code>), NotANumber values (<code>NaN</code>) or Infinite values (<code>Inf</code>) are not allowed.</p>
</td></tr>
<tr><td><code id="mvr_+3A_block">block</code></td>
<td>
<p><code>character</code> or <code>numeric</code> <code>vector</code>, or <code>factor</code> of group membership indicator variable 
(grouping/blocking variable) of length the data sample size with as many different values or <code>levels</code> 
as the number of data sample groups. Defaults to single group situation. See details.</p>
</td></tr>
<tr><td><code id="mvr_+3A_tolog">tolog</code></td>
<td>
<p><code>logical</code> scalar. Is the data to be log2-transformed first? Optional, defaults to <code>FALSE</code>.
Note that negative or null values will be changed to 1 before taking log2-transformation.</p>
</td></tr>
<tr><td><code id="mvr_+3A_nc.min">nc.min</code></td>
<td>
<p>Positive <code>integer</code> scalar of the minimum number of clusters, defaults to 1</p>
</td></tr>
<tr><td><code id="mvr_+3A_nc.max">nc.max</code></td>
<td>
<p>Positive <code>integer</code> scalar of the maximum number of clusters, defaults to 30</p>
</td></tr>
<tr><td><code id="mvr_+3A_probs">probs</code></td>
<td>
<p><code>numeric</code> <code>vector</code> of probabilities for quantile diagnostic plots. Defaults to <code>seq</code>(0, 1, 0.01).</p>
</td></tr>
<tr><td><code id="mvr_+3A_b">B</code></td>
<td>
<p>Positive <code>integer</code> scalar of the number of Monte Carlo replicates of the inner loop
of the sim statistic function (see details).</p>
</td></tr>
<tr><td><code id="mvr_+3A_parallel">parallel</code></td>
<td>
<p><code>logical</code> scalar. Is parallel computing to be performed? Optional, defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mvr_+3A_conf">conf</code></td>
<td>

<p><code>list</code> of 5 fields containing the parameters values needed for creating the parallel backend (cluster configuration).
See details below for usage. Optional, defaults to <code>NULL</code>, but all fields are required if used:
</p>

<ul>
<li> <p><code>type</code> : <code>character</code> <code>vector</code> specifying the cluster type (&quot;SOCKET&quot;, &quot;MPI&quot;).
</p>
</li>
<li> <p><code>spec</code> : A specification (<code>character</code> <code>vector</code> or <code>integer</code> scalar) appropriate to the type of cluster.
</p>
</li>
<li> <p><code>homogeneous</code> : <code>logical</code> scalar to be set to <code>FALSE</code> for inhomogeneous clusters.
</p>
</li>
<li> <p><code>verbose</code> : <code>logical</code> scalar to be set to <code>FALSE</code> for quiet mode.
</p>
</li>
<li> <p><code>outfile</code> : <code>character</code> <code>vector</code> of an output log file name to direct the stdout and stderr
connection output from the workernodes. &quot;&quot; indicates no redirection.
</p>
</li></ul>

</td></tr>
<tr><td><code id="mvr_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> scalar. Is the output to be verbose? Optional, defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mvr_+3A_seed">seed</code></td>
<td>
<p>Positive <code>integer</code> scalar of the user seed to reproduce the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>block</code> will be converted to a factor, whose levels will match the data groups. It defaults to a single group situation, 
that is, under the assumption of equal variance between sample groups. All group sample sizes must be greater than 1, 
otherwise the program will stop.
</p>
<p>Argument <code>nc.max</code> currently defaults to 30. Empirically, we found that this is enough for most datasets tested.
This depends on (i) the dimensionality/sample size ratio <code class="reqn">\frac{p}{n}</code>, (ii) the signal/noise ratio, and
(iii) whether a pre-transformation has been applied (see <cite>Dazard, J-E. and J. S. Rao (2012)</cite> for more details).
See the cluster diagnostic function <code><a href="#topic+cluster.diagnostic">cluster.diagnostic</a></code> for more details, whether larger values of <code>nc.max</code> may be required.
</p>
<p>The function <code>mvr</code> relies on the R package <span class="pkg">parallel</span> to create a parallel backend within an R session. This enables access to a cluster
of compute cores and/or nodes on a local and/or remote machine(s) and scaling-up with the number of CPU cores available and efficient parallel 
execution. To run a procedure in parallel (with parallel RNG), argument <code>parallel</code> is to be set to <code>TRUE</code> and argument <code>conf</code> 
is to be specified (i.e. non <code>NULL</code>). Argument <code>conf</code> uses the options described in function <code>makeCluster</code> of the R packages 
<span class="pkg">parallel</span> and <span class="pkg">snow</span>. <span class="pkg">PRIMsrc</span> supports two types of communication mechanisms between master and worker processes: 
'Socket' or  'Message-Passing Interface' ('MPI'). In <span class="pkg">PRIMsrc</span>, parallel 'Socket' clusters use sockets communication mechanisms only 
(no forking) and are therefore available on all platforms, including Windows, while parallel 'MPI' clusters use high-speed interconnects 
mechanism in networks of computers (with distributed memory) and are therefore available only in these architectures. A parallel 'MPI' 
cluster also requires R package <span class="pkg">Rmpi</span> to be installed first. Value <code>type</code> is used to setup a cluster of type 'Socket' (&quot;SOCKET&quot;) 
or 'MPI' (&quot;MPI&quot;), respectively. Depending on this type, values of <code>spec</code> are to be used alternatively:
</p>

<ul>
<li><p> For 'Socket' clusters (<code>conf$type="SOCKET"</code>), <code>spec</code> should be a <code>character</code> <code>vector</code> naming the hosts on which 
to run the job; it can default to a unique local machine, in which case, one may use the unique host name &quot;localhost&quot;.
Each host name can potentially be repeated to the number of CPU cores available on the local machine.
It can also be an <code>integer</code> scalar specifying the number of processes to spawn on the local machine; 
or a list of machine specifications (a character value named host specifying the name or address of the host to use).
</p>
</li>
<li><p> For 'MPI' clusters (<code>conf$type="MPI"</code>), <code>spec</code> should be an <code>integer</code> scalar 
specifying the total number of processes to be spawned across the network of available nodes, counting the workernodes and masternode.
</p>
</li></ul>

<p>The actual creation of the cluster, its initialization, and closing are all done internally. For more details, 
see the reference manual of R package <span class="pkg">snow</span> and examples below.
</p>
<p>When random number generation is needed, the creation of separate streams of parallel RNG per node is done internally by 
distributing the stream states to the nodes. For more details, see the vignette of R package <span class="pkg">parallel</span>. 
The use of a seed allows to reproduce the results within the same type of session: the same seed will reproduce the same results within 
a non-parallel session or within a parallel session, but it will not necessarily give the exact same results (up to sampling variability)
between a non-parallelized and parallelized session due to the difference of management of the seed between the two (see parallel RNG and 
value of returned seed below).
</p>


<h3>Value</h3>

<table>
<tr><td><code>Xraw</code></td>
<td>
<p><code>numeric</code> <code>matrix</code> of original data.</p>
</td></tr>
<tr><td><code>Xmvr</code></td>
<td>
<p><code>numeric</code> <code>matrix</code> of MVR-transformed data.</p>
</td></tr>
<tr><td><code>centering</code></td>
<td>
<p><code>numeric</code> <code>vector</code> of centering values for standardization (cluster mean of pooled sample mean).</p>
</td></tr>
<tr><td><code>scaling</code></td>
<td>
<p><code>numeric</code> <code>vector</code> of scaling values for standardization (cluster mean of pooled sample std dev).</p>
</td></tr>
<tr><td><code>MVR</code></td>
<td>
<p><code>list</code> (of size the number of groups) containing for each group:
</p>

<ul>
<li><p> membership <code>numeric</code> <code>vector</code> of cluster membership of each variable
</p>
</li>
<li><p> nc Positive <code>integer</code> scalar of number of clusters found in optimal cluster configuration
</p>
</li>
<li><p> gap <code>numeric</code> <code>vector</code> of the similarity statistic values
</p>
</li>
<li><p> sde <code>numeric</code> <code>vector</code> of the standard errors of the similarity statistic values
</p>
</li>
<li><p> mu.std <code>numeric</code> <code>matrix</code> (<code>K</code> x p) of the vector of standardized means by groups (rows), 
where <code>K</code> = \#groups and <code>p</code> = \#variables
</p>
</li>
<li><p> sd.std <code>numeric</code> <code>matrix</code> (<code>K</code> x p) of the vector of standardized standard deviations by groups (rows),
where <code>K</code> = \#groups and <code>p</code> = \#variables
</p>
</li>
<li><p> mu.quant <code>numeric</code> <code>matrix</code> (<code>nc.max</code> - <code>nc.min</code> + 1) x (length(<code>probs</code>)) of quantiles of means
</p>
</li>
<li><p> sd.quant <code>numeric</code> <code>matrix</code> (<code>nc.max</code> - <code>nc.min</code> + 1) x (length(<code>probs</code>)) of quantiles of standard deviations
</p>
</li></ul>

</td></tr>
<tr><td><code>block</code></td>
<td>
<p>Value of argument <code>block</code>.</p>
</td></tr>
<tr><td><code>tolog</code></td>
<td>
<p>Value of argument <code>tolog</code>.</p>
</td></tr>
<tr><td><code>nc.min</code></td>
<td>
<p>Value of argument <code>nc.min</code>.</p>
</td></tr>
<tr><td><code>nc.max</code></td>
<td>
<p>Value of argument <code>nc.max</code>.</p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p>Value of argument <code>probs</code>.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>User seed(s) used: <code>integer</code> of a single value, if parallelization is used. 
<code>integer</code> <code>vector</code> of values, one for each replication, if parallelization is not used.</p>
</td></tr>
</table>


<h3>Acknowledgments</h3>

<p>This work made use of the High Performance Computing Resource in the Core Facility for Advanced Research Computing at Case Western Reserve University. 
This project was partially funded by the National Institutes of Health (P30-CA043703).
</p>


<h3>Note</h3>

<p>End-user function.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>
</p>
</li>
<li><p> &quot;Hua Xu, Ph.D.&quot; <a href="mailto:huaxu77@gmail.com">huaxu77@gmail.com</a>
</p>
</li>
<li><p> &quot;Alberto Santana, MBA.&quot; <a href="mailto:ahs4@case.edu">ahs4@case.edu</a>
</p>
</li></ul>

<p>Maintainer: &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>    
</p>


<h3>References</h3>


<ul>
<li><p> Dazard J-E. and J. S. Rao (2010). &quot;<em>Regularized Variance Estimation and Variance Stabilization of High-Dimensional Data.</em>&quot;
In JSM Proceedings, Section for High-Dimensional Data Analysis and Variable Selection. 
Vancouver, BC, Canada: American Statistical Association IMS - JSM, 5295-5309.
</p>
</li>
<li><p> Dazard J-E., Hua Xu and J. S. Rao (2011). &quot;<em>R package MVR for Joint Adaptive Mean-Variance Regularization and Variance Stabilization.</em>&quot;
In JSM Proceedings, Section for Statistical Programmers and Analysts. 
Miami Beach, FL, USA: American Statistical Association IMS - JSM, 3849-3863.
</p>
</li>
<li><p> Dazard J-E. and J. S. Rao (2012). &quot;<em>Joint Adaptive Mean-Variance Regularization and Variance Stabilization of High Dimensional Data.</em>&quot;
Comput. Statist. Data Anal. 56(7):2317-2333.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code>makeCluster</code> (R package <span class="pkg">parallel</span>).
</p>
</li>
<li> <p><code>justvsn</code> (R package <span class="pkg">vsn</span>) Variance stabilization and calibration for microarray data <cite>Huber, 2002</cite>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#===================================================
# Loading the library and its dependencies
#===================================================
library("MVR")

## Not run: 
    #===================================================
    # MVR package news
    #===================================================
    MVR.news()

    #================================================
    # MVR package citation
    #================================================
    citation("MVR")

    #===================================================
    # Loading of the Synthetic and Real datasets
    # Use help for descriptions
    #===================================================
    data("Synthetic", "Real", package="MVR")
    ?Synthetic
    ?Real

## End(Not run)

#===================================================
# Mean-Variance Regularization (Synthetic dataset)
# Single-Group Assumption
# Assuming equal variance between groups
# Without cluster usage
#===================================================
nc.min &lt;- 1
nc.max &lt;- 10
probs &lt;- seq(0, 1, 0.01)
n &lt;- 10
mvr.obj &lt;- mvr(data = Synthetic,
               block = rep(1,n),
               tolog = FALSE,
               nc.min = nc.min,
               nc.max = nc.max,
               probs = probs,
               B = 100,
               parallel = FALSE,
               conf = NULL,
               verbose = TRUE,
               seed = 1234)

## Not run: 
    #===================================================
    # Examples of parallel backend parametrization 
    #===================================================
    if (require("parallel")) {
       print("'parallel' is attached correctly \n")
    } else {
       stop("'parallel' must be attached first \n")
    }
    #===================================================
    # Ex. #1 - Multicore PC
    # Running WINDOWS
    # SOCKET communication cluster
    # Shared memory parallelization
    #===================================================
    cpus &lt;- detectCores(logical = TRUE)
    conf &lt;- list("spec" = rep("localhost", cpus),
                 "type" = "SOCKET",
                 "homo" = TRUE,
                 "verbose" = TRUE,
                 "outfile" = "")
    #===================================================
    # Ex. #2 - Master node + 3 Worker nodes cluster
    # All nodes equipped with identical setups of multicores 
    # (8 core CPUs per machine for a total of 32)
    # SOCKET communication cluster
    # Distributed memory parallelization
    #===================================================
    masterhost &lt;- Sys.getenv("HOSTNAME")
    slavehosts &lt;- c("compute-0-0", "compute-0-1", "compute-0-2")
    nodes &lt;- length(slavehosts) + 1
    cpus &lt;- 8
    conf &lt;- list("spec" = c(rep(masterhost, cpus),
                            rep(slavehosts, cpus)),
                 "type" = "SOCKETs",
                 "homo" = TRUE,
                 "verbose" = TRUE,
                 "outfile" = "")
    #===================================================
    # Ex. #3 - Enterprise Multinode Cluster w/ multicore/node  
    # Running LINUX with SLURM scheduler
    # MPI communication cluster
    # Distributed memory parallelisation
    #==================================================
    if (require("Rmpi")) {
        print("'Rmpi' is attached correctly \n")
    } else {
        stop("'Rmpi' must be attached first \n")
    }
    # Below, variable 'cpus' is the total number of requested 
    # taks (threads/CPUs), which is specified from within a 
    # SLURM script.
    cpus &lt;- as.numeric(Sys.getenv("SLURM_NTASKS"))
    conf &lt;- list("spec" = cpus,
                 "type" = "MPI",
                 "homo" = TRUE,
                 "verbose" = TRUE,
                 "outfile" = "")
    #===================================================
    # Mean-Variance Regularization (Real dataset)
    # Multi-Group Assumption
    # Assuming unequal variance between groups
    #===================================================
    nc.min &lt;- 1
    nc.max &lt;- 30
    probs &lt;- seq(0, 1, 0.01)
    n &lt;- 6
    GF &lt;- factor(gl(n = 2, k = n/2, length = n),
                 ordered = FALSE,
                 labels = c("M", "S"))
    mvr.obj &lt;- mvr(data = Real,
                   block = GF,
                   tolog = FALSE,
                   nc.min = nc.min,
                   nc.max = nc.max,
                   probs = probs,
                   B = 100,
                   parallel = TRUE,
                   conf = conf,
                   verbose = TRUE,
                   seed = 1234)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='MVR-package'>Mean-Variance Regularization Package</h2><span id='topic+MVR'></span>

<h3>Description</h3>

<p>MVR is a non-parametric method for joint adaptive mean-variance regularization
and variance stabilization of high-dimensional data.
</p>
<p>It is suited for handling difficult problems posed by high-dimensional multivariate datasets 
(<code class="reqn">p \gg n</code> paradigm), such as in omics-type data, among which are that the variance is 
often a function of the mean, variable-specific estimators of variances are not reliable, 
and tests statistics have low powers due to a lack of degrees of freedom.
</p>
<p>Key features include:
</p>

<ol>
<li><p>Normalization and/or variance stabilization of the data
</p>
</li>
<li><p>Computation of mean-variance-regularized <em>t</em>-statistics (<em>F</em>-statistics to come)
</p>
</li>
<li><p>Generation of diverse diagnostic plots
</p>
</li>
<li><p>Computationally efficient implementation using C/C++ interfacing 
and an option for parallel computing to enjoy a fast and easy experience 
in the R environment <br />
</p>
</li></ol>



<h3>Details</h3>

<p>The following describes all the end-user functions, and internal R subroutines 
needed for running a complete MVR procedure. Other internal subroutines are not 
to be called by the end-user at any time. For computational efficiency, 
end-user regularization functions offer the option to configure a cluster.
This is indicated by an asterisk (* = optionally involving cluster usage).
The R functions are categorized as follows:
</p>

<ol>
<li><p>END-USER REGULARIZATION &amp; VARIANCE STABILIZATION FUNCTION <br />
<code><a href="#topic+mvr">mvr</a></code> (*) 
<b>Function for Mean-Variance Regularization and Variance Stabilization.</b> <br />
End-user function for Mean-Variance Regularization (MVR) and Variance Stabilization 
by similarity statistic under sample group homoscedasticity or heteroscedasticity assumption.
The function takes advantage of the R package <span class="pkg">parallel</span>, which allows users 
to create a cluster of workstations on a local and/or remote machine(s), 
enabling parallel execution of this function and scaling up with the number of CPU 
cores available.<br />
</p>
</li>
<li><p>END-USER REGULARIZED TESTS-STATISTICS FUNCTIONS <br />
<code><a href="#topic+mvrt.test">mvrt.test</a></code> (*)
<b>Function for Computing Mean-Variance Regularized T-test Statistic and Its Significance.</b><br />
End-user function for computing MVR t-test statistic and its significance (p-value) 
under sample group homoscedasticity or heteroscedasticity assumption.
The function takes advantage of the R package <span class="pkg">parallel</span>, which allows users 
to create a cluster of workstations on a local and/or remote machine(s), 
enabling parallel execution of this function and scaling up with the number of CPU 
cores available.<br />
</p>
</li>
<li><p>END-USER DIAGNOSTIC PLOTS FOR QUALITY CONTROL <br />
<code><a href="#topic+cluster.diagnostic">cluster.diagnostic</a></code>
<b>Function for Plotting Summary Cluster Diagnostic Plots.</b><br />
Plot similarity statistic profiles and the optimal joint clustering configuration for the means and the variances by group.
Plot quantile profiles of means and standard deviations by group and for each clustering configuration, to check that the distributions 
of first and second moments of the MVR-transformed data approach their respective null distributions under the optimal configuration found, 
assuming independence and normality of all the variables.<br />
</p>
<p><code><a href="#topic+target.diagnostic">target.diagnostic</a></code>
<b>Function for Plotting Summary Target Moments Diagnostic Plots.</b><br />
Plot comparative distribution densities of means and standard deviations of the data before and after Mean-Variance Regularization
to check for location shifts between observed first and second moments and their expected target values under a target centered homoscedastic model. 
Plot comparative QQ scatterplots to look at departures between observed distributions of first and second moments of the MVR-transformed data
and their theoretical distributions assuming independence and normality of all the variables.<br />
</p>
<p><code><a href="#topic+stabilization.diagnostic">stabilization.diagnostic</a></code>
<b>Function for Plotting Summary Variance Stabilization Diagnostic Plots.</b><br />
Plot comparative variance-mean plots to check the variance stabilization across variables before and after Mean-Variance Regularization.<br />
</p>
<p><code><a href="#topic+normalization.diagnostic">normalization.diagnostic</a></code>
<b>Function for Plotting Summary Normalization Diagnostic Plots.</b><br />
Plot comparative Box-Whisker and Heatmap plots of variables across samples check the effectiveness of normalization before and after 
Mean-Variance Regularization.<br />
</p>
</li>
<li><p>OTHER END-USER FUNCTIONS <br />
<code><a href="#topic+MVR.news">MVR.news</a></code>
<b>Display the <span class="pkg">MVR</span> Package News</b><br />
Function to display the log file <code>NEWS</code> of updates of the <span class="pkg">MVR</span> package.<br />
</p>
</li>
<li><p>END-USER DATASETS <br />
A <code>Real</code> dataset coming from a quantitative proteomics experiment, consisting of <code class="reqn">n=6</code> 
samples split into a control (&quot;<em>M</em>&quot;) and a treated group (&quot;<em>S</em>&quot;) with <code class="reqn">p=9052</code> 
unique peptides or predictor variables. This is a balanced design with two sample groups (<code class="reqn">G=2</code>), 
under unequal sample group variance.<br />
</p>
<p>A <code>Synthetic</code> dataset with <code class="reqn">n=10</code> observations (samples) and <code class="reqn">p=100</code> variables, 
where <code class="reqn">nvar=20</code> of them are significantly different between the two sample groups.
This is a balanced design with two sample groups (<code class="reqn">G=2</code>), under unequal sample group variance.<br />
</p>
</li></ol>

<p>Known Bugs/Problems : None at this time.
</p>


<h3>Acknowledgments</h3>

<p>This work made use of the High Performance Computing Resource in the Core Facility for Advanced Research Computing at Case Western Reserve University. 
This project was partially funded by the National Institutes of Health (P30-CA043703).
</p>


<h3>Author(s)</h3>


<ul>
<li><p> &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>
</p>
</li>
<li><p> &quot;Hua Xu, Ph.D.&quot; <a href="mailto:huaxu77@gmail.com">huaxu77@gmail.com</a>
</p>
</li>
<li><p> &quot;Alberto Santana, MBA.&quot; <a href="mailto:ahs4@case.edu">ahs4@case.edu</a>
</p>
</li></ul>

<p>Maintainer: &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>    
</p>


<h3>References</h3>


<ul>
<li><p> Dazard J-E. and J. S. Rao (2010). &quot;<em>Regularized Variance Estimation and Variance Stabilization of High-Dimensional Data.</em>&quot;
In JSM Proceedings, Section for High-Dimensional Data Analysis and Variable Selection. 
Vancouver, BC, Canada: American Statistical Association IMS - JSM, 5295-5309.
</p>
</li>
<li><p> Dazard J-E., Hua Xu and J. S. Rao (2011). &quot;<em>R package MVR for Joint Adaptive Mean-Variance Regularization and Variance Stabilization.</em>&quot;
In JSM Proceedings, Section for Statistical Programmers and Analysts. 
Miami Beach, FL, USA: American Statistical Association IMS - JSM, 3849-3863.
</p>
</li>
<li><p> Dazard J-E. and J. S. Rao (2012). &quot;<em>Joint Adaptive Mean-Variance Regularization and Variance Stabilization of High Dimensional Data.</em>&quot;
Comput. Statist. Data Anal. 56(7):2317-2333.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code>makeCluster</code> (R package <span class="pkg">parallel</span>)
</p>
</li>
<li> <p><code>justvsn</code> (R package <span class="pkg">vsn</span>) Variance stabilization and calibration for microarray data <cite>Huber, 2002</cite>
</p>
</li>
<li> <p><code>eBayes</code> (R package <span class="pkg">limma</span>) Bayesian Regularized t-test statistic <cite>Smyth, 2004</cite>
</p>
</li>
<li> <p><code>samr</code> (R package <span class="pkg">samr</span>) SAM Regularized t-test statistic <cite>Tusher et al., 2001, Storey, 2003</cite>
</p>
</li>
<li> <p><code>matest</code> (R package <span class="pkg">maanova</span>) James-Stein shrinkage estimator-based Regularized t-test statistic <cite>Cui et al., 2005</cite>
</p>
</li>
<li> <p><code>ebam</code> (R package <span class="pkg">siggenes</span>) Empirical Bayes Regularized z-test statistic <cite>Efron, 2001</cite>
</p>
</li>
<li> <p><code>bayesT</code> Hierarchical Bayesian Regularized t-test statistic <cite>Baldi et al., 2001</cite>
</p>
</li></ul>


<hr>
<h2 id='MVR.news'>Function to Display the NEWS File</h2><span id='topic+MVR.news'></span>

<h3>Description</h3>

<p>Function to display the NEWS file of the <span class="pkg">MVR</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    MVR.news(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVR.news_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Acknowledgments</h3>

<p>This work made use of the High Performance Computing Resource in the Core Facility for Advanced Research Computing at Case Western Reserve University. 
This project was partially funded by the National Institutes of Health (P30-CA043703).
</p>


<h3>Note</h3>

<p>End-user function. 
</p>


<h3>Author(s)</h3>


<ul>
<li><p> &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>
</p>
</li>
<li><p> &quot;Hua Xu, Ph.D.&quot; <a href="mailto:huaxu77@gmail.com">huaxu77@gmail.com</a>
</p>
</li>
<li><p> &quot;Alberto Santana, MBA.&quot; <a href="mailto:ahs4@case.edu">ahs4@case.edu</a>
</p>
</li></ul>

<p>Maintainer: &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>    
</p>


<h3>References</h3>


<ul>
<li><p> Dazard J-E. and J. S. Rao (2010). &quot;<em>Regularized Variance Estimation and Variance Stabilization of High-Dimensional Data.</em>&quot;
In JSM Proceedings, Section for High-Dimensional Data Analysis and Variable Selection. 
Vancouver, BC, Canada: American Statistical Association IMS - JSM, 5295-5309.
</p>
</li>
<li><p> Dazard J-E., Hua Xu and J. S. Rao (2011). &quot;<em>R package MVR for Joint Adaptive Mean-Variance Regularization and Variance Stabilization.</em>&quot;
In JSM Proceedings, Section for Statistical Programmers and Analysts. 
Miami Beach, FL, USA: American Statistical Association IMS - JSM, 3849-3863.
</p>
</li>
<li><p> Dazard J-E. and J. S. Rao (2012). &quot;<em>Joint Adaptive Mean-Variance Regularization and Variance Stabilization of High Dimensional Data.</em>&quot;
Comput. Statist. Data Anal. 56(7):2317-2333.
</p>
</li></ul>


<hr>
<h2 id='mvrt.test'>Function for Computing Mean-Variance Regularized T-test Statistic and Its Significance</h2><span id='topic+mvrt.test'></span>

<h3>Description</h3>

<p>End-user function for computing MVR t-test statistic and its significance (p-value) 
under sample group homoscedasticity or heteroscedasticity assumption. 
</p>
<p>Return an object of class &quot;<code>mvrt.test</code>&quot;. Offers the option of parallel computation for 
improved efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    mvrt.test(data, 
              obj=NULL,
              block,
              tolog = FALSE, 
              nc.min = 1, 
              nc.max = 30, 
              pval = FALSE, 
              replace = FALSE, 
              n.resamp = 100, 
              parallel = FALSE,
              conf = NULL,
              verbose = TRUE, 
              seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvrt.test_+3A_data">data</code></td>
<td>
<p><code>numeric</code> <code>matrix</code> of untransformed (raw) data, 
where samples are by rows and variables (to be clustered) are by columns, 
or an object that can be coerced to such a <code>matrix</code> (such as a <code>numeric</code> <code>vector</code> 
or a <code>data.frame</code> with all <code>numeric</code> columns). 
Missing values (<code>NA</code>), NotANumber values (<code>NaN</code>) or Infinite values (<code>Inf</code>) are not allowed.</p>
</td></tr>
<tr><td><code id="mvrt.test_+3A_obj">obj</code></td>
<td>
<p>Object of class <code>mvr</code> returned by <code><a href="#topic+mvr">mvr</a></code>.</p>
</td></tr>
<tr><td><code id="mvrt.test_+3A_block">block</code></td>
<td>
<p><code>character</code> or <code>numeric</code> <code>vector</code>, or <code>factor</code> of group membership indicator variable 
(grouping/blocking variable) of length the data sample size with as many different values or <code>levels</code> 
as the number of data sample groups. Defaults to single group situation. See details.</p>
</td></tr>
<tr><td><code id="mvrt.test_+3A_tolog">tolog</code></td>
<td>
<p><code>logical</code> scalar. Is the data to be log2-transformed first? Optional, defaults to <code>FALSE</code>.
Note that negative or null values will be changed to 1 before taking log2-transformation.</p>
</td></tr>
<tr><td><code id="mvrt.test_+3A_nc.min">nc.min</code></td>
<td>
<p>Positive <code>integer</code> scalar of the minimum number of clusters, defaults to 1</p>
</td></tr>
<tr><td><code id="mvrt.test_+3A_nc.max">nc.max</code></td>
<td>
<p>Positive <code>integer</code> scalar of the maximum number of clusters, defaults to 30</p>
</td></tr>
<tr><td><code id="mvrt.test_+3A_pval">pval</code></td>
<td>
<p><code>logical</code> scalar. Shall p-values be computed? If not, <code>n.resamp</code> and <code>replace</code> will be ignored.
If <code>FALSE</code> (default), t-statistic only will be computed,  
If <code>TRUE</code>, exact (permutation test) or approximate (bootstrap test) p-values will be computed.</p>
</td></tr>
<tr><td><code id="mvrt.test_+3A_replace">replace</code></td>
<td>
<p><code>logical</code> scalar. Shall permutation test (default) or bootstrap test be computed?
If <code>FALSE</code> (default), permutation test will be computed with null permutation distribution,
If <code>TRUE</code>, bootstrap test will be computed with null bootstrap distribution.</p>
</td></tr>
<tr><td><code id="mvrt.test_+3A_n.resamp">n.resamp</code></td>
<td>
<p>Positive <code>integer</code> scalar of the number of resamplings to compute (default=100) by permutation or 
bootstsrap (see details).</p>
</td></tr>
<tr><td><code id="mvrt.test_+3A_parallel">parallel</code></td>
<td>
<p><code>logical</code> scalar. Is parallel computing to be performed? Optional, defaults to <code>FALSE</code>.</p>
</td></tr>           
<tr><td><code id="mvrt.test_+3A_conf">conf</code></td>
<td>

<p><code>list</code> of 5 fields containing the parameters values needed for creating the parallel backend (cluster configuration).
See details below for usage. Optional, defaults to <code>NULL</code>, but all fields are required if used:
</p>

<ul>
<li> <p><code>type</code> : <code>character</code> <code>vector</code> specifying the cluster type (&quot;SOCKET&quot;, &quot;MPI&quot;).
</p>
</li>
<li> <p><code>spec</code> : A specification (<code>character</code> <code>vector</code> or <code>integer</code> scalar) appropriate to the type of cluster.
</p>
</li>
<li> <p><code>homogeneous</code> : <code>logical</code> scalar to be set to <code>FALSE</code> for inhomogeneous clusters.
</p>
</li>
<li> <p><code>verbose</code> : <code>logical</code> scalar to be set to <code>FALSE</code> for quiet mode.
</p>
</li>
<li> <p><code>outfile</code> : <code>character</code> <code>vector</code> of an output log file name to direct the stdout and stderr
connection output from the workernodes. &quot;&quot; indicates no redirection.
</p>
</li></ul>

</td></tr>
<tr><td><code id="mvrt.test_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> scalar. Is the output to be verbose? Optional, defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mvrt.test_+3A_seed">seed</code></td>
<td>
<p>Positive <code>integer</code> scalar of the user seed to reproduce the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>block</code> will be converted to a factor, whose levels will match the data groups. It defaults to a single group situation, 
that is, under the assumption of equal variance between sample groups. All group sample sizes must be greater than 1, 
otherwise the program will stop.
</p>
<p>Argument <code>nc.max</code> currently defaults to 30. Empirically, we found that this is enough for most datasets tested.
This depends on (i) the dimensionality/sample size ratio <code class="reqn">\frac{p}{n}</code>, (ii) the signal/noise ratio, and 
(iii) whether a pre-transformation has been applied (see <cite>Dazard, J-E. and J. S. Rao (2012)</cite> for more details).
See the cluster diagnostic function <code><a href="#topic+cluster.diagnostic">cluster.diagnostic</a></code> for more details, whether larger values of <code>nc.max</code> may be required.
</p>
<p>To save un-necessary computations, previously computed MVR clustering can be provided through option <code>obj</code> (i.e. <code>obj</code> is fully 
specified as a <code><a href="#topic+mvr">mvr</a></code> object). In this case, arguments <code>data</code>, <code>block</code>, <code>tolog</code>, <code>nc.min</code>, <code>nc.max</code> 
are ignored. If <code>obj</code> is fully specified (i.e. an object of class &quot;<code>mvr</code>&quot; returned by <code><a href="#topic+mvr">mvr</a></code>), the 
the MVR clustering provided by <code>obj</code> will be used for the computation of the regularized t-test statistics. 
If <code>obj</code>=<code>NULL</code>, a MVR clustering computation for the regularized t-test statistics and/or p-values will be performed.
</p>
<p>The function <code>mvrt.test</code> relies on the R package <span class="pkg">parallel</span> to create a parallel backend within an R session, enabling access to a cluster
of compute cores and/or nodes on a local and/or remote machine(s) and scaling-up with the number of CPU cores available and efficient parallel 
execution. To run a procedure in parallel (with parallel RNG), argument <code>parallel</code> is to be set to <code>TRUE</code> and argument <code>conf</code> 
is to be specified (i.e. non <code>NULL</code>). Argument <code>conf</code> uses the options described in function <code>makeCluster</code> of the R packages 
<span class="pkg">parallel</span> and <span class="pkg">snow</span>. <span class="pkg">PRIMsrc</span> supports two types of communication mechanisms between master and worker processes: 
'Socket' or  'Message-Passing Interface' ('MPI'). In <span class="pkg">PRIMsrc</span>, parallel 'Socket' clusters use sockets communication mechanisms only 
(no forking) and are therefore available on all platforms, including Windows, while parallel 'MPI' clusters use high-speed interconnects 
mechanism in networks of computers (with distributed memory) and are therefore available only in these architectures. A parallel 'MPI' 
cluster also requires R package <span class="pkg">Rmpi</span> to be installed first. Value <code>type</code> is used to setup a cluster of type 'Socket' (&quot;SOCKET&quot;) 
or 'MPI' (&quot;MPI&quot;), respectively. Depending on this type, values of <code>spec</code> are to be used alternatively:
</p>

<ul>
<li><p> For 'Socket' clusters (<code>conf$type="SOCKET"</code>), <code>spec</code> should be a <code>character</code> <code>vector</code> naming the hosts on which 
to run the job; it can default to a unique local machine, in which case, one may use the unique host name &quot;localhost&quot;.
Each host name can potentially be repeated to the number of CPU cores available on the local machine.
It can also be an <code>integer</code> scalar specifying the number of processes to spawn on the local machine; 
or a list of machine specifications (a character value named host specifying the name or address of the host to use).
</p>
</li>
<li><p> For 'MPI' clusters (<code>conf$type="MPI"</code>), <code>spec</code> should be an <code>integer</code> scalar 
specifying the total number of processes to be spawned across the network of available nodes, counting the workernodes and masternode.
</p>
</li></ul>

<p>The actual creation of the cluster, its initialization, and closing are all done internally. For more details, 
see the reference manual of R package <span class="pkg">snow</span> and examples below.
</p>
<p>When random number generation is needed, the creation of separate streams of parallel RNG per node is done internally by 
distributing the stream states to the nodes. For more details, see the vignette of R package <span class="pkg">parallel</span>. 
The use of a seed allows to reproduce the results within the same type of session: the same seed will reproduce the same results within 
a non-parallel session or within a parallel session, but it will not necessarily give the exact same results (up to sampling variability)
between a non-parallelized and parallelized session due to the difference of management of the seed between the two (see parallel RNG and 
value of returned seed below).
</p>
<p>In case p-values are desired (<code>pval</code>=<code>TRUE</code>), the use of a cluster is highly recommended. 
It is ideal for computing embarassingly parallel tasks such as permutation or bootstrap resamplings.
Note that in case both regularized t-test statistics and p-values are desired, in order to maximize computational efficiency and 
avoid multiple configurations (since a cluster can only be configured and used one session at a time, which otherwise would result in a run stop), 
the cluster configuration will only be used for the parallel computation of p-values, but not for the MVR clustering computation 
of the regularized t-test statistics.
</p>


<h3>Value</h3>

<table>
<tr><td><code>statistic</code></td>
<td>
<p><code>vector</code>, of size the number of variables, 
where entries are the t-statistics values of each variable.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p><code>vector</code>, of size the number of variables, 
where entries are the p-values (if requested, otherwise <code>NULL</code> value) of each variable.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>User seed(s) used: <code>integer</code> of a single value, if parallelization is used. 
<code>integer</code> <code>vector</code> of values, one for each replication, if parallelization is not used.</p>
</td></tr>
</table>


<h3>Acknowledgments</h3>

<p>This work made use of the High Performance Computing Resource in the Core Facility for Advanced Research Computing at Case Western Reserve University. 
This project was partially funded by the National Institutes of Health (P30-CA043703).
</p>


<h3>Note</h3>

<p>End-user function.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>
</p>
</li>
<li><p> &quot;Hua Xu, Ph.D.&quot; <a href="mailto:huaxu77@gmail.com">huaxu77@gmail.com</a>
</p>
</li>
<li><p> &quot;Alberto Santana, MBA.&quot; <a href="mailto:ahs4@case.edu">ahs4@case.edu</a>
</p>
</li></ul>

<p>Maintainer: &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>    
</p>


<h3>References</h3>


<ul>
<li><p> Dazard J-E. and J. S. Rao (2010). &quot;<em>Regularized Variance Estimation and Variance Stabilization of High-Dimensional Data.</em>&quot;
In JSM Proceedings, Section for High-Dimensional Data Analysis and Variable Selection. 
Vancouver, BC, Canada: American Statistical Association IMS - JSM, 5295-5309.
</p>
</li>
<li><p> Dazard J-E., Hua Xu and J. S. Rao (2011). &quot;<em>R package MVR for Joint Adaptive Mean-Variance Regularization and Variance Stabilization.</em>&quot;
In JSM Proceedings, Section for Statistical Programmers and Analysts. 
Miami Beach, FL, USA: American Statistical Association IMS - JSM, 3849-3863.
</p>
</li>
<li><p> Dazard J-E. and J. S. Rao (2012). &quot;<em>Joint Adaptive Mean-Variance Regularization and Variance Stabilization of High Dimensional Data.</em>&quot;
Comput. Statist. Data Anal. 56(7):2317-2333.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code>makeCluster</code> (R package <span class="pkg">parallel</span>)
</p>
</li>
<li> <p><code>eBayes</code> (R package <span class="pkg">limma</span>) Bayesian Regularized t-test statistic <cite>Smyth, 2004</cite>
</p>
</li>
<li> <p><code>samr</code> (R package <span class="pkg">samr</span>) SAM Regularized t-test statistic <cite>Tusher et al., 2001, Storey, 2003</cite>
</p>
</li>
<li> <p><code>matest</code> (R package <span class="pkg">maanova</span>) James-Stein shrinkage estimator-based Regularized t-test statistic <cite>Cui et al., 2005</cite>
</p>
</li>
<li> <p><code>ebam</code> (R package <span class="pkg">siggenes</span>) Empirical Bayes Regularized z-test statistic <cite>Efron, 2001</cite>
</p>
</li>
<li> <p><code>bayesT</code> Hierarchical Bayesian Regularized t-test statistic <cite>Baldi et al., 2001</cite>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#================================================
# Loading the library and its dependencies
#================================================
library("MVR")

## Not run: 
    #===================================================
    # MVR package news
    #===================================================
    MVR.news()

    #================================================
    # MVR package citation
    #================================================
    citation("MVR")

    #===================================================
    # Loading of the Synthetic and Real datasets
    # Use help for descriptions
    #===================================================
    data("Synthetic", "Real", package="MVR")
    ?Synthetic
    ?Real

## End(Not run)

#================================================
# Regularized t-test statistics (Synthetic dataset) 
# Multi-Group Assumption
# Assuming unequal variance between groups
# With option to use prior MVR clustering results
# Without computation of p-values
# Without cluster usage
#================================================
nc.min &lt;- 1
nc.max &lt;- 10
probs &lt;- seq(0, 1, 0.01)
n &lt;- 10
GF &lt;- factor(gl(n = 2, k = n/2, length = n), 
             ordered = FALSE, 
             labels = c("G1", "G2"))
mvr.obj &lt;- mvr(data = Synthetic, 
               block = GF, 
               tolog = FALSE, 
               nc.min = nc.min, 
               nc.max = nc.max, 
               probs = probs,
               B = 100,
               parallel = FALSE, 
               conf = NULL,
               verbose = TRUE,
               seed = 1234)
mvrt.obj &lt;- mvrt.test(data = NULL,
                      obj = mvr.obj,
                      block = NULL,
                      pval = FALSE,
                      replace = FALSE,
                      n.resamp = 100,
                      parallel = FALSE,
                      conf = NULL,
                      verbose = TRUE,
                      seed = 1234)       
## Not run: 
    #===================================================
    # Examples of parallel backend parametrization 
    #===================================================
    if (require("parallel")) {
       print("'parallel' is attached correctly \n")
    } else {
       stop("'parallel' must be attached first \n")
    }
    #===================================================
    # Example #1 - Quad core PC 
    # Running WINDOWS with SOCKET communication
    #===================================================
    cpus &lt;- parallel::detectCores(logical = TRUE)
    conf &lt;- list("spec" = rep("localhost", cpus),
                 "type" = "SOCKET",
                 "homo" = TRUE,
                 "verbose" = TRUE,
                 "outfile" = "")
    #===================================================
    # Example #2 - Master node + 3 Worker nodes cluster
    # Running LINUX with SOCKET communication
    # All nodes equipped with identical setups of 
    # multicores (8 core CPUs per machine for a total of 32)
    #===================================================
    masterhost &lt;- Sys.getenv("HOSTNAME")
    slavehosts &lt;- c("compute-0-0", "compute-0-1", "compute-0-2")
    nodes &lt;- length(slavehosts) + 1
    cpus &lt;- 8
    conf &lt;- list("spec" = c(rep(masterhost, cpus),
                            rep(slavehosts, cpus)),
                 "type" = "SOCKET",
                 "homo" = TRUE,
                 "verbose" = TRUE,
                 "outfile" = "")
    #===================================================
    # Example #3 - Multinode of multicore per node cluster
    # Running LINUX with SLURM scheduler and MPI communication
    # Below, variable 'cpus' is the total number 
    # of requested core CPUs, which is specified from  
    # within a SLURM script.
    #===================================================
    if (require("Rmpi")) {
        print("'Rmpi' is attached correctly \n")
    } else {
        stop("'Rmpi' must be attached first \n")
    }
    cpus &lt;- as.numeric(Sys.getenv("SLURM_NTASKS"))
    conf &lt;- list("spec" = cpus,
                 "type" = "MPI",
                 "homo" = TRUE,
                 "verbose" = TRUE,
                 "outfile" = "")
    #===================================================
    # Mean-Variance Regularization (Real dataset)
    # Multi-Group Assumption
    # Assuming unequal variance between groups
    #===================================================
    nc.min &lt;- 1
    nc.max &lt;- 30
    probs &lt;- seq(0, 1, 0.01)
    n &lt;- 6
    GF &lt;- factor(gl(n = 2, k = n/2, length = n), 
                 ordered = FALSE, 
                 labels = c("M", "S"))
    mvr.obj &lt;- mvr(data = Real, 
                   block = GF, 
                   tolog = FALSE, 
                   nc.min = nc.min, 
                   nc.max = nc.max, 
                   probs = probs,
                   B = 100, 
                   parallel = TRUE, 
                   conf = conf,
                   verbose = TRUE,
                   seed = 1234)
    #===================================================
    # Regularized t-test statistics (Real dataset) 
    # Multi-Group Assumption
    # Assuming unequal variance between groups
    # With option to use prior MVR clustering results
    # With computation of p-values
    #===================================================
    mvrt.obj &lt;- mvrt.test(data = NULL,
                          obj = mvr.obj,
                          block = NULL,
                          pval = TRUE,
                          replace = FALSE,
                          n.resamp = 100,
                          parallel = TRUE,
                          conf = conf,
                          verbose = TRUE,
                          seed = 1234)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='normalization.diagnostic'>Function for Plotting Summary Normalization Diagnostic Plots</h2><span id='topic+normalization.diagnostic'></span>

<h3>Description</h3>

    
<p>Plot comparative Box-Whisker and Heatmap plots of variables across samples check the effectiveness 
of normalization before and after Mean-Variance Regularization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    normalization.diagnostic(obj, 
                             pal,
                             title = "Normalization Diagnostic Plots",
                             device = NULL, 
                             file = "Normalization Diagnostic Plots",
                             path = getwd(),
                             horizontal = FALSE, 
                             width = 7, 
                             height = 8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalization.diagnostic_+3A_obj">obj</code></td>
<td>
<p>Object of class &quot;<code>mvr</code>&quot; returned by <code><a href="#topic+mvr">mvr</a></code>.</p>
</td></tr>
<tr><td><code id="normalization.diagnostic_+3A_title">title</code></td>
<td>
<p>Title of the plot. Defaults to &quot;Normalization Diagnostic Plots&quot;.</p>
</td></tr>
<tr><td><code id="normalization.diagnostic_+3A_pal">pal</code></td>
<td>
<p>Color palette.</p>
</td></tr>
<tr><td><code id="normalization.diagnostic_+3A_device">device</code></td>
<td>
<p>Graphic display device in {NULL, &quot;PS&quot;, &quot;PDF&quot;}. Defaults to NULL (standard output screen).
Currently implemented graphic display devices are &quot;PS&quot; (Postscript) or &quot;PDF&quot; (Portable Document Format).</p>
</td></tr>
<tr><td><code id="normalization.diagnostic_+3A_file">file</code></td>
<td>
<p>File name for output graphic. Defaults to &quot;Normalization Diagnostic Plots&quot;.</p>
</td></tr>
<tr><td><code id="normalization.diagnostic_+3A_path">path</code></td>
<td>
<p>Absolute path (without final (back)slash separator). Defaults to working directory path.</p>
</td></tr>
<tr><td><code id="normalization.diagnostic_+3A_horizontal">horizontal</code></td>
<td>
<p><code>Logical</code> scalar. Orientation of the printed image. Defaults to <code>FALSE</code>, that is potrait orientation.</p>
</td></tr>
<tr><td><code id="normalization.diagnostic_+3A_width">width</code></td>
<td>
<p><code>Numeric</code> scalar. Width of the graphics region in inches. Defaults to 7.</p>
</td></tr>
<tr><td><code id="normalization.diagnostic_+3A_height">height</code></td>
<td>
<p><code>Numeric</code> scalar. Height of the graphics region in inches. Defaults to 8.</p>
</td></tr>
<tr><td><code id="normalization.diagnostic_+3A_...">...</code></td>
<td>
<p>Generic arguments passed to other plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Option <code>file</code> is used only if device is specified (i.e. non <code>NULL</code>).
The argument <code>pal</code> can be any color palette, e.g. as provided by R package <span class="pkg">RColorBrewer</span>.
</p>


<h3>Value</h3>

<p>None. Displays the plots on the chosen <code>device</code>.
</p>


<h3>Acknowledgments</h3>

<p>This work made use of the High Performance Computing Resource in the Core Facility for Advanced Research Computing at Case Western Reserve University. 
This project was partially funded by the National Institutes of Health (P30-CA043703).
</p>


<h3>Note</h3>

<p>End-user function.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>
</p>
</li>
<li><p> &quot;Hua Xu, Ph.D.&quot; <a href="mailto:huaxu77@gmail.com">huaxu77@gmail.com</a>
</p>
</li>
<li><p> &quot;Alberto Santana, MBA.&quot; <a href="mailto:ahs4@case.edu">ahs4@case.edu</a>
</p>
</li></ul>

<p>Maintainer: &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>    
</p>


<h3>References</h3>


<ul>
<li><p> Dazard J-E. and J. S. Rao (2010). &quot;<em>Regularized Variance Estimation and Variance Stabilization of High-Dimensional Data.</em>&quot;
In JSM Proceedings, Section for High-Dimensional Data Analysis and Variable Selection. 
Vancouver, BC, Canada: American Statistical Association IMS - JSM, 5295-5309.
</p>
</li>
<li><p> Dazard J-E., Hua Xu and J. S. Rao (2011). &quot;<em>R package MVR for Joint Adaptive Mean-Variance Regularization and Variance Stabilization.</em>&quot;
In JSM Proceedings, Section for Statistical Programmers and Analysts. 
Miami Beach, FL, USA: American Statistical Association IMS - JSM, 3849-3863.
</p>
</li>
<li><p> Dazard J-E. and J. S. Rao (2012). &quot;<em>Joint Adaptive Mean-Variance Regularization and Variance Stabilization of High Dimensional Data.</em>&quot;
Comput. Statist. Data Anal. 56(7):2317-2333.
</p>
</li></ul>



<h3>See Also</h3>

<p><code>justvsn</code> (R package <span class="pkg">vsn</span>) Variance stabilization and calibration for microarray data.
<code>loess</code> (R package <span class="pkg">stats</span>) Fit a polynomial surface determined by one or more numerical predictors, using local fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    #===================================================
    # Loading the library and its dependencies
    #===================================================
    library("MVR")
    library("RColorBrewer")

    #===================================================
    # MVR package news
    #===================================================
    MVR.news()

    #================================================
    # MVR package citation
    #================================================
    citation("MVR")

    #===================================================
    # Loading of the Synthetic and Real datasets
    # (see description of datasets)
    #===================================================
    data("Synthetic", "Real", package="MVR")
    ?Synthetic
    ?Real
    
    #===================================================
    # Mean-Variance Regularization (Real dataset)
    # Multi-Group Assumption
    # Assuming unequal variance between groups
    # Without cluster usage
    #===================================================
    nc.min &lt;- 1
    nc.max &lt;- 30
    probs &lt;- seq(0, 1, 0.01)
    n &lt;- 6
    GF &lt;- factor(gl(n = 2, k = n/2, length = n), 
                 ordered = FALSE, 
                 labels = c("M", "S"))
    mvr.obj &lt;- mvr(data = Real, 
                   block = GF, 
                   log = FALSE, 
                   nc.min = nc.min, 
                   nc.max = nc.max, 
                   probs = probs,
                   B = 100, 
                   parallel = FALSE, 
                   conf = NULL,
                   verbose = TRUE,
                   seed = 1234)

    #===================================================
    # Summary Normalization Diagnostic Plots (Real dataset)
    # Multi-Group Assumption
    # Assuming unequal variance between groups
    #===================================================
    normalization.diagnostic(obj = mvr.obj, 
                             title = "Normalization Diagnostic Plots 
                             (Real - Multi-Group Assumption)",
                             pal = brewer.pal(n=11, name="RdYlGn"),
                             device = NULL,
                             horizontal = FALSE, 
                             width = 7, 
                             height = 8)

    
## End(Not run)
</code></pre>

<hr>
<h2 id='Real'>Real Proteomics Dataset</h2><span id='topic+Real'></span>

<h3>Description</h3>

<p>The dataset comes from a quantitative Liquid Chromatography/Mass-Spectrometry (LC/MS) 
shotgun (bottom-up) proteomics experiment. It consists of <code class="reqn">n=6</code> independent cell cultures 
of human of Myeloid Dendritic Cells (MDCs) from normal subjects. Samples were split 
into a control (&quot;<em>M</em>&quot;) and a treated group (&quot;<em>S</em>&quot;), stimulated with either media alone 
or a Toll-Like receptor-3 Ligand respectively. The goal was to identify differentially expressed 
peptides (or proteins) between the two groups involved in the immune response
of human MDCs upon TLR-3 Ligand binding.
</p>
<p>The dataset is assumed to have been pre-processed for non-ignorable missing values, 
leaving a complete dataset with <code class="reqn">p=9052</code> unique peptides or predictor variables.
</p>
<p>This is a balanced design with two sample groups (<code class="reqn">G=2</code>), under unequal sample group variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Real</code></pre>


<h3>Format</h3>

<p>A numeric matrix containing <code class="reqn">n=6</code> observations (samples) by rows and 
<code class="reqn">p=9052</code> variables by columns, named after peptide names (<code class="reqn">diffset_{1}, ..., diffset_{p}</code>).
Samples are balanced (<code class="reqn">n_{1}=3</code>,<code class="reqn">n_{2}=3</code>) between the two groups (&quot;<em>M</em>&quot;, &quot;<em>S</em>&quot;).
Compressed Rda data file.
</p>


<h3>Acknowledgments</h3>

<p>This work made use of the High Performance Computing Resource in the Core Facility for Advanced Research Computing at Case Western Reserve University. 
This project was partially funded by the National Institutes of Health (P30-CA043703).
</p>


<h3>Author(s)</h3>


<ul>
<li><p> &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>
</p>
</li>
<li><p> &quot;Hua Xu, Ph.D.&quot; <a href="mailto:huaxu77@gmail.com">huaxu77@gmail.com</a>
</p>
</li>
<li><p> &quot;Alberto Santana, MBA.&quot; <a href="mailto:ahs4@case.edu">ahs4@case.edu</a>
</p>
</li></ul>

<p>Maintainer: &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>    
</p>


<h3>Source</h3>

<p>See real proteomics data application in Dazard et al., 2011, 2012.</p>


<h3>References</h3>


<ul>
<li><p> Dazard J-E. and J. S. Rao (2010). &quot;<em>Regularized Variance Estimation and Variance Stabilization of High-Dimensional Data.</em>&quot;
In JSM Proceedings, Section for High-Dimensional Data Analysis and Variable Selection. 
Vancouver, BC, Canada: American Statistical Association IMS - JSM, 5295-5309.
</p>
</li>
<li><p> Dazard J-E., Hua Xu and J. S. Rao (2011). &quot;<em>R package MVR for Joint Adaptive Mean-Variance Regularization and Variance Stabilization.</em>&quot;
In JSM Proceedings, Section for Statistical Programmers and Analysts. 
Miami Beach, FL, USA: American Statistical Association IMS - JSM, 3849-3863.
</p>
</li>
<li><p> Dazard J-E. and J. S. Rao (2012). &quot;<em>Joint Adaptive Mean-Variance Regularization and Variance Stabilization of High Dimensional Data.</em>&quot;
Comput. Statist. Data Anal. 56(7):2317-2333.
</p>
</li></ul>


<hr>
<h2 id='stabilization.diagnostic'>Function for Plotting Summary Variance Stabilization Diagnostic Plots</h2><span id='topic+stabilization.diagnostic'></span>

<h3>Description</h3>

<p>Plot comparative variance-mean plots to check the variance stabilization across variables before and after Mean-Variance Regularization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    stabilization.diagnostic(obj, 
                             span = 0.5, 
                             degree = 2, 
                             family = "gaussian", 
                             title = "Stabilization Diagnostic Plots", 
                             device = NULL, 
                             file = "Stabilization Diagnostic Plots",
                             path = getwd(),
                             horizontal = FALSE, 
                             width = 7, 
                             height = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabilization.diagnostic_+3A_obj">obj</code></td>
<td>
<p>Object of class &quot;<code>mvr</code>&quot; returned by <code><a href="#topic+mvr">mvr</a></code>.</p>
</td></tr>
<tr><td><code id="stabilization.diagnostic_+3A_title">title</code></td>
<td>
<p>Title of the plot. Defaults to &quot;Stabilization Diagnostic Plots&quot;.</p>
</td></tr>
<tr><td><code id="stabilization.diagnostic_+3A_span">span</code></td>
<td>
<p>Span parameter of the <code>loess()</code> function (R package <span class="pkg">stats</span>), which controls the degree of smoothing. 
Defaults to 0.75.</p>
</td></tr>
<tr><td><code id="stabilization.diagnostic_+3A_degree">degree</code></td>
<td>
<p>Degree parameter of the <code>loess()</code> function (R package <span class="pkg">stats</span>), which controls the degree of the polynomials to be used. 
Defaults to 2. (Normally 1 or 2. Degree 0 is also allowed, but see the &quot;Note&quot; in loess stats package.)</p>
</td></tr>
<tr><td><code id="stabilization.diagnostic_+3A_family">family</code></td>
<td>
<p>Family distribution in &quot;gaussian&quot;, &quot;symmetric&quot; of the <code>loess()</code> function (R package <span class="pkg">stats</span>), used for local fitting .
If &quot;gaussian&quot; fitting is by least-squares, and if &quot;symmetric&quot; a re-descending M estimator is used with Tukey's biweight function.</p>
</td></tr>
<tr><td><code id="stabilization.diagnostic_+3A_device">device</code></td>
<td>
<p>Graphic display device in {NULL, &quot;PS&quot;, &quot;PDF&quot;}. Defaults to NULL (standard output screen).
Currently implemented graphic display devices are &quot;PS&quot; (Postscript) or &quot;PDF&quot; (Portable Document Format).</p>
</td></tr>
<tr><td><code id="stabilization.diagnostic_+3A_file">file</code></td>
<td>
<p>File name for output graphic. Defaults to &quot;Stabilization Diagnostic Plots&quot;.</p>
</td></tr>
<tr><td><code id="stabilization.diagnostic_+3A_path">path</code></td>
<td>
<p>Absolute path (without final (back)slash separator). Defaults to working directory path.</p>
</td></tr>
<tr><td><code id="stabilization.diagnostic_+3A_horizontal">horizontal</code></td>
<td>
<p><code>Logical</code> scalar. Orientation of the printed image. Defaults to <code>FALSE</code>, that is potrait orientation.</p>
</td></tr>
<tr><td><code id="stabilization.diagnostic_+3A_width">width</code></td>
<td>
<p><code>Numeric</code> scalar. Width of the graphics region in inches. Defaults to 7.</p>
</td></tr>
<tr><td><code id="stabilization.diagnostic_+3A_height">height</code></td>
<td>
<p><code>Numeric</code> scalar. Height of the graphics region in inches. Defaults to 5.</p>
</td></tr>
<tr><td><code id="stabilization.diagnostic_+3A_...">...</code></td>
<td>
<p>Generic arguments passed to other plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the plots of standard deviations vs. means, standard deviations and means are calculated in a feature-wise manner from the expression matrix.
The scatterplot allows to visually verify whether there is a dependence of the standard deviation (or variance) on the mean. 
The black dotted line depicts the LOESS scatterplot smoother estimator. If there is no variance-mean dependence, 
then this line should be approximately horizontal.
</p>
<p>Option <code>file</code> is used only if device is specified (i.e. non <code>NULL</code>).
</p>


<h3>Value</h3>

<p>None. Displays the plots on the chosen <code>device</code>.
</p>


<h3>Acknowledgments</h3>

<p>This work made use of the High Performance Computing Resource in the Core Facility for Advanced Research Computing at Case Western Reserve University. 
This project was partially funded by the National Institutes of Health (P30-CA043703).
</p>


<h3>Note</h3>

<p>End-user function.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>
</p>
</li>
<li><p> &quot;Hua Xu, Ph.D.&quot; <a href="mailto:huaxu77@gmail.com">huaxu77@gmail.com</a>
</p>
</li>
<li><p> &quot;Alberto Santana, MBA.&quot; <a href="mailto:ahs4@case.edu">ahs4@case.edu</a>
</p>
</li></ul>

<p>Maintainer: &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>    
</p>


<h3>References</h3>


<ul>
<li><p> Dazard J-E. and J. S. Rao (2010). &quot;<em>Regularized Variance Estimation and Variance Stabilization of High-Dimensional Data.</em>&quot;
In JSM Proceedings, Section for High-Dimensional Data Analysis and Variable Selection. 
Vancouver, BC, Canada: American Statistical Association IMS - JSM, 5295-5309.
</p>
</li>
<li><p> Dazard J-E., Hua Xu and J. S. Rao (2011). &quot;<em>R package MVR for Joint Adaptive Mean-Variance Regularization and Variance Stabilization.</em>&quot;
In JSM Proceedings, Section for Statistical Programmers and Analysts. 
Miami Beach, FL, USA: American Statistical Association IMS - JSM, 3849-3863.
</p>
</li>
<li><p> Dazard J-E. and J. S. Rao (2012). &quot;<em>Joint Adaptive Mean-Variance Regularization and Variance Stabilization of High Dimensional Data.</em>&quot;
Comput. Statist. Data Anal. 56(7):2317-2333.
</p>
</li></ul>



<h3>See Also</h3>

<p><code>justvsn</code> (R package <span class="pkg">vsn</span>) Variance stabilization and calibration for microarray data.
<code>loess</code> (R package <span class="pkg">stats</span>) Fit a polynomial surface determined by one or more numerical predictors, using local fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    #===================================================
    # Loading the library and its dependencies
    #===================================================
    library("MVR")

    #===================================================
    # MVR package news
    #===================================================
    MVR.news()

    #================================================
    # MVR package citation
    #================================================
    citation("MVR")

    #===================================================
    # Loading of the Synthetic and Real datasets
    # (see description of datasets)
    #===================================================
    data("Synthetic", "Real", package="MVR")
    ?Synthetic
    ?Real

    #===================================================
    # Mean-Variance Regularization (Real dataset)
    # Multi-Group Assumption
    # Assuming unequal variance between groups
    # Without cluster usage
    #===================================================
    nc.min &lt;- 1
    nc.max &lt;- 30
    probs &lt;- seq(0, 1, 0.01)
    n &lt;- 6
    GF &lt;- factor(gl(n = 2, k = n/2, length = n), 
                 ordered = FALSE, 
                 labels = c("M", "S"))
    mvr.obj &lt;- mvr(data = Real, 
                   block = GF, 
                   log = FALSE, 
                   nc.min = nc.min, 
                   nc.max = nc.max, 
                   probs = probs,
                   B = 100, 
                   parallel = FALSE, 
                   conf = NULL,
                   verbose = TRUE,
                   seed = 1234)

    #===================================================
    # Summary Stabilization Diagnostic Plots (Real dataset)
    # Multi-Group Assumption
    # Assuming unequal variance between groups
    #===================================================
    stabilization.diagnostic(obj = mvr.obj, 
                             title = "Stabilization Diagnostic Plots 
                             (Real - Multi-Group Assumption)",
                             span = 0.75, 
                             degree = 2, 
                             family = "gaussian",
                             device = NULL,
                             horizontal = FALSE, 
                             width = 7, 
                             height = 5)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='Synthetic'>Multi-Groups Synthetic Dataset</h2><span id='topic+Synthetic'></span>

<h3>Description</h3>

<p>Generation of a synthetic dataset with <em>n</em>=10 observations (samples) and <code class="reqn">p=100</code> variables, 
where <code class="reqn">nvar=20</code> of them are significantly different between the two sample groups.
</p>
<p>This is a balanced design with two sample groups (<code class="reqn">G=2</code>), under unequal sample group variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Synthetic</code></pre>


<h3>Format</h3>

<p>A numeric matrix containing <code class="reqn">n=10</code> observations (samples) by rows 
and <code class="reqn">p=100</code> variables by columns, named <code class="reqn">v_{1},...,v_{p}</code>.
Samples are balanced (<code class="reqn">n_{1}=5</code>,<code class="reqn">n_{2}=5</code>) between the two groups (<code class="reqn">G_{1}, G_{2}</code>).
Compressed Rda data file.
</p>


<h3>Acknowledgments</h3>

<p>This work made use of the High Performance Computing Resource in the Core Facility for Advanced Research Computing at Case Western Reserve University. 
This project was partially funded by the National Institutes of Health (P30-CA043703).
</p>


<h3>Author(s)</h3>


<ul>
<li><p> &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>
</p>
</li>
<li><p> &quot;Hua Xu, Ph.D.&quot; <a href="mailto:huaxu77@gmail.com">huaxu77@gmail.com</a>
</p>
</li>
<li><p> &quot;Alberto Santana, MBA.&quot; <a href="mailto:ahs4@case.edu">ahs4@case.edu</a>
</p>
</li></ul>

<p>Maintainer: &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>    
</p>


<h3>Source</h3>

<p>See model #2 in Dazard et al., 2011, 2012.</p>


<h3>References</h3>


<ul>
<li><p> Dazard J-E. and J. S. Rao (2010). &quot;<em>Regularized Variance Estimation and Variance Stabilization of High-Dimensional Data.</em>&quot;
In JSM Proceedings, Section for High-Dimensional Data Analysis and Variable Selection. 
Vancouver, BC, Canada: American Statistical Association IMS - JSM, 5295-5309.
</p>
</li>
<li><p> Dazard J-E., Hua Xu and J. S. Rao (2011). &quot;<em>R package MVR for Joint Adaptive Mean-Variance Regularization and Variance Stabilization.</em>&quot;
In JSM Proceedings, Section for Statistical Programmers and Analysts. 
Miami Beach, FL, USA: American Statistical Association IMS - JSM, 3849-3863.
</p>
</li>
<li><p> Dazard J-E. and J. S. Rao (2012). &quot;<em>Joint Adaptive Mean-Variance Regularization and Variance Stabilization of High Dimensional Data.</em>&quot;
Comput. Statist. Data Anal. 56(7):2317-2333.
</p>
</li></ul>


<hr>
<h2 id='target.diagnostic'>Function for Plotting Summary Target Moments Diagnostic Plots</h2><span id='topic+target.diagnostic'></span>

<h3>Description</h3>

<p>Plot comparative distribution densities of means and standard deviations of the data before and after Mean-Variance Regularization
to check for location shifts between observed first and second moments and their expected target values under a target centered homoscedastic model. 
</p>
<p>Plot comparative QQ scatterplots to look at departures between observed distributions of first and second moments of the MVR-transformed data
and their theoretical distributions assuming independence and normality of all the variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    target.diagnostic(obj, 
                      title = "Target Moments Diagnostic Plots",
                      device = NULL, 
                      file = "Target Moments Diagnostic Plots",
                      path = getwd(),
                      horizontal = FALSE, 
                      width = 8.5, 
                      height = 6.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.diagnostic_+3A_obj">obj</code></td>
<td>
<p>Object of class &quot;<code>mvr</code>&quot; returned by <code><a href="#topic+mvr">mvr</a></code>.</p>
</td></tr>
<tr><td><code id="target.diagnostic_+3A_title">title</code></td>
<td>
<p>Title of the plot. Defaults to &quot;Target Moments Diagnostic Plots&quot;.</p>
</td></tr>
<tr><td><code id="target.diagnostic_+3A_device">device</code></td>
<td>
<p>Graphic display device in {NULL, &quot;PS&quot;, &quot;PDF&quot;}. Defaults to NULL (standard output screen).
Currently implemented graphic display devices are &quot;PS&quot; (Postscript) or &quot;PDF&quot; (Portable Document Format).</p>
</td></tr>
<tr><td><code id="target.diagnostic_+3A_file">file</code></td>
<td>
<p>File name for output graphic. Defaults to &quot;Target Moments Diagnostic Plots&quot;.</p>
</td></tr>
<tr><td><code id="target.diagnostic_+3A_path">path</code></td>
<td>
<p>Absolute path (without final (back)slash separator). Defaults to working directory path.</p>
</td></tr>
<tr><td><code id="target.diagnostic_+3A_horizontal">horizontal</code></td>
<td>
<p><code>Logical</code> scalar. Orientation of the printed image. Defaults to <code>FALSE</code>, that is potrait orientation.</p>
</td></tr>
<tr><td><code id="target.diagnostic_+3A_width">width</code></td>
<td>
<p><code>Numeric</code> scalar. Width of the graphics region in inches. Defaults to 8.5.</p>
</td></tr>
<tr><td><code id="target.diagnostic_+3A_height">height</code></td>
<td>
<p><code>Numeric</code> scalar. Height of the graphics region in inches. Defaults to 6.5.</p>
</td></tr>
<tr><td><code id="target.diagnostic_+3A_...">...</code></td>
<td>
<p>Generic arguments passed to other plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plots of the density distribution of means and standard deviations checks that the distributions of means and standard deviations 
of the MVR-transformed data have correct target first moments, i.e. with mean ~ 0 and mean ~ 1. The expected target mean and standard 
deviation are shown in red (before and) after MVR-transformation. Caption shows the p-values from the parametric two-sample two-sided t-tests 
for the equality of parameters to their expectations (assuming normality since usually sample sizes are large : <code class="reqn">p \gg 1</code>, 
or a relative robustness to moderate violations of the normality assumption).
</p>
<p>In the general case, the variables are not normally distributed and not even independent and identically distributed before 
and after MVR-transformation. Therefore, the distributions of untransformed first and second moments usually differ from their respective 
theoretical null distributions, i.e., from <code class="reqn">N(0, \frac{1}{n})</code> for the means and from <code class="reqn">\sqrt{\frac{\chi_{n - G}^{2}}{n - G}}</code> for the standard 
deviations, where <code class="reqn">G</code> denotes the number of sample groups (see <cite>Dazard, J-E. and J. S. Rao (2012)</cite> for more details). 
Also, the observed distributions of transformed first and second moments are unknown. This is reflected in the QQ plots, 
where theoretical and empirical quantiles do not necessarily align with each other. Caption shows the p-values from the nonparametric two-sample 
two-sided Kolmogorov-Smirnov tests of the null hypothesis that a parameter distribution differs from its theoretical distribution. 
Each black dot represents a variable. The red solid line depicts the interquartile line, which passes through the first and third quartiles. 
</p>
<p>Option <code>file</code> is used only if device is specified (i.e. non <code>NULL</code>).
</p>


<h3>Value</h3>

<p>None. Displays the plots on the chosen <code>device</code>.
</p>


<h3>Acknowledgments</h3>

<p>This work made use of the High Performance Computing Resource in the Core Facility for Advanced Research Computing at Case Western Reserve University. 
This project was partially funded by the National Institutes of Health (P30-CA043703).
</p>


<h3>Note</h3>

<p>End-user function.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>
</p>
</li>
<li><p> &quot;Hua Xu, Ph.D.&quot; <a href="mailto:huaxu77@gmail.com">huaxu77@gmail.com</a>
</p>
</li>
<li><p> &quot;Alberto Santana, MBA.&quot; <a href="mailto:ahs4@case.edu">ahs4@case.edu</a>
</p>
</li></ul>

<p>Maintainer: &quot;Jean-Eudes Dazard, Ph.D.&quot; <a href="mailto:jean-eudes.dazard@case.edu">jean-eudes.dazard@case.edu</a>    
</p>


<h3>References</h3>


<ul>
<li><p> Dazard J-E. and J. S. Rao (2010). &quot;<em>Regularized Variance Estimation and Variance Stabilization of High-Dimensional Data.</em>&quot;
In JSM Proceedings, Section for High-Dimensional Data Analysis and Variable Selection. 
Vancouver, BC, Canada: American Statistical Association IMS - JSM, 5295-5309.
</p>
</li>
<li><p> Dazard J-E., Hua Xu and J. S. Rao (2011). &quot;<em>R package MVR for Joint Adaptive Mean-Variance Regularization and Variance Stabilization.</em>&quot;
In JSM Proceedings, Section for Statistical Programmers and Analysts. 
Miami Beach, FL, USA: American Statistical Association IMS - JSM, 3849-3863.
</p>
</li>
<li><p> Dazard J-E. and J. S. Rao (2012). &quot;<em>Joint Adaptive Mean-Variance Regularization and Variance Stabilization of High Dimensional Data.</em>&quot;
Comput. Statist. Data Anal. 56(7):2317-2333.
</p>
</li></ul>



<h3>See Also</h3>

<p><code>justvsn</code> (R package <span class="pkg">vsn</span>) Variance stabilization and calibration for microarray data.
<code>loess</code> (R package <span class="pkg">stats</span>) Fit a polynomial surface determined by one or more numerical predictors, using local fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    #===================================================
    # Loading the library and its dependencies
    #===================================================
    library("MVR")
    library("RColorBrewer")

    #===================================================
    # MVR package news
    #===================================================
    MVR.news()

    #================================================
    # MVR package citation
    #================================================
    citation("MVR")

    #===================================================
    # Loading of the Synthetic and Real datasets
    # (see description of datasets)
    #===================================================
    data("Synthetic", "Real", package="MVR")
    ?Synthetic
    ?Real

    #===================================================
    # Mean-Variance Regularization (Real dataset)
    # Multi-Group Assumption
    # Assuming unequal variance between groups
    # Without cluster usage
    #===================================================
    nc.min &lt;- 1
    nc.max &lt;- 30
    probs &lt;- seq(0, 1, 0.01)
    n &lt;- 6
    GF &lt;- factor(gl(n = 2, k = n/2, length = n), 
                 ordered = FALSE, 
                 labels = c("M", "S"))
    mvr.obj &lt;- mvr(data = Real, 
                   block = GF, 
                   log = FALSE, 
                   nc.min = nc.min, 
                   nc.max = nc.max, 
                   probs = probs,
                   B = 100, 
                   parallel = FALSE, 
                   conf = NULL,
                   verbose = TRUE,
                   seed = 1234)

    #===================================================
    # Summary Target Moments Diagnostic Plots (Real dataset)
    # Multi-Group Assumption
    # Assuming unequal variance between groups
    #===================================================
    target.diagnostic(obj = mvr.obj, 
                      title = "Target Moments Diagnostic Plots 
                      (Real - Multi-Group Assumption)",
                      device = NULL,
                      horizontal = FALSE, 
                      width = 8.5, 
                      height = 6.5)
    
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
