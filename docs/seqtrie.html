<!DOCTYPE html><html lang="en"><head><title>Help for package seqtrie</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {seqtrie}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#covid_cdr3'><p>Adaptive COVID TCRB CDR3 data</p></a></li>
<li><a href='#dist_matrix'><p>Compute distances between all combinations of two sets of sequences</p></a></li>
<li><a href='#dist_pairwise'><p>Pairwise distance between two sets of sequences</p></a></li>
<li><a href='#dist_search'><p>Distance search for similar sequences</p></a></li>
<li><a href='#generate_cost_matrix'><p>Generate a simple cost matrix</p></a></li>
<li><a href='#RadixForest'><p>RadixForest</p></a></li>
<li><a href='#RadixTree'><p>RadixTree</p></a></li>
<li><a href='#split_search'><p>split_search</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Radix Tree and Trie-Based String Distances</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-01</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of Radix Tree and Trie algorithms for finding similar sequences and calculating sequence distances (Levenshtein and other distance metrics). This work was inspired by a trie implementation in Python: "Fast and Easy Levenshtein distance using a Trie." Hanov (2011) <a href="https://stevehanov.ca/blog/index.php?id=114">https://stevehanov.ca/blog/index.php?id=114</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel, BH</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.18.3), RcppParallel (&ge; 5.1.3), R6, rlang,
dplyr, stringi</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, stringdist, qs, Biostrings, pwalign,
igraph, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Copyright:</td>
<td>This package includes code from the 'span-lite' library
owned by Martin Moene under Boost Software License 1.0. This
package includes code from the 'ankerl' library owned by Martin
Leitner-Ankerl under MIT License. This package contains data
derived from Adaptive Biotechnologies "ImmuneCODE" dataset
under Creative Commons Attribution 4.0.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/traversc/seqtrie">https://github.com/traversc/seqtrie</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/traversc/seqtrie/issues">https://github.com/traversc/seqtrie/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-02 09:03:51 UTC; tching</td>
</tr>
<tr>
<td>Author:</td>
<td>Travers Ching [aut, cre, cph],
  Martin Moene [ctb, cph] (span-lite C++ library),
  Steve Hanov [ctb] (Trie levenshtein implementation in Python),
  Martin Leitner-Ankerl [ctb] (Ankerl unordered dense hashmap)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Travers Ching &lt;traversc@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-02 09:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='covid_cdr3'>Adaptive COVID TCRB CDR3 data</h2><span id='topic+covid_cdr3'></span>

<h3>Description</h3>

<p>Unique TCRB CDR3 sequences from the Nolan et al. 2020. CDR3s were extracted via IgBLAST. The license for this data is Creative Commons Attribution 4.0 International License.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(covid_cdr3)
</code></pre>


<h3>Format</h3>

<p>A character vector of length 133,034.
</p>


<h3>References</h3>

<p>Nolan, Sean, et al. &quot;A large-scale database of T-cell receptor beta (TCRB) sequences and binding associations from natural and synthetic exposure to SARS-CoV-2.&quot; (2020). doi: 10.21203/rs.3.rs-51964/v1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(covid_cdr3)
# Average CDR3 length
mean(nchar(covid_cdr3)) # [1] 43.56821

</code></pre>

<hr>
<h2 id='dist_matrix'>Compute distances between all combinations of two sets of sequences</h2><span id='topic+dist_matrix'></span>

<h3>Description</h3>

<p>Compute distances between all combinations of query and target sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_matrix(
  query,
  target,
  mode,
  cost_matrix = NULL,
  gap_cost = NULL,
  gap_open_cost = NULL,
  nthreads = 1,
  show_progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_matrix_+3A_query">query</code></td>
<td>
<p>A character vector of query sequences.</p>
</td></tr>
<tr><td><code id="dist_matrix_+3A_target">target</code></td>
<td>
<p>A character vector of target sequences.</p>
</td></tr>
<tr><td><code id="dist_matrix_+3A_mode">mode</code></td>
<td>
<p>The distance metric to use. One of hamming (hm), global (gb) or anchored (an).</p>
</td></tr>
<tr><td><code id="dist_matrix_+3A_cost_matrix">cost_matrix</code></td>
<td>
<p>A custom cost matrix for use with the &quot;global&quot; or &quot;anchored&quot; distance metrics. See details.</p>
</td></tr>
<tr><td><code id="dist_matrix_+3A_gap_cost">gap_cost</code></td>
<td>
<p>The cost of a gap for use with the &quot;global&quot; or &quot;anchored&quot; distance metrics. See details.</p>
</td></tr>
<tr><td><code id="dist_matrix_+3A_gap_open_cost">gap_open_cost</code></td>
<td>
<p>The cost of a gap opening. See details.</p>
</td></tr>
<tr><td><code id="dist_matrix_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads to use for parallel computation.</p>
</td></tr>
<tr><td><code id="dist_matrix_+3A_show_progress">show_progress</code></td>
<td>
<p>Whether to show a progress bar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates all combinations of pairwise distances based on Hamming, Levenshtein or Anchored algorithms.
The output is a NxM matrix where N = length(query) and M = length(target).
Note: this can take a <em>really</em> long time; be careful with input size.
</p>
<p>Three types of distance metrics are supported, based on the form of alignment performed. These are: Hamming, Global (Levenshtein) and Anchored.
</p>
<p>An anchored alignment is a form of semi-global alignment, where the query sequence is &quot;anchored&quot; (global) to the beginning of both the query and target sequences,
but is semi-global in that the end of the either the query sequence or target sequence (but not both) can be unaligned. This type of alignment is sometimes called an &quot;extension&quot; alignment in literature.
</p>
<p>In contrast a global alignment must align the entire query and target sequences. When mismatch and indel costs are equal to 1, this is also known as the Levenshtein distance.
</p>
<p>By default, if mode == &quot;global&quot; or &quot;anchored&quot;, all mismatches and indels are given a cost of 1. However, you can define your own distance metric by setting the cost_matrix and gap parameters.
The cost_matrix is a strictly positive square integer matrix and should include all characters in query and target as column- and rownames.
To set the cost of a gap (insertion or deletion) you can include a row and column named &quot;gap&quot; in the cost_matrix <em>OR</em> set the gap_cost parameter (a single positive integer).
Similarly, the affine gap alignment can be set by including a row and column named &quot;gap_open&quot; in the cost_matrix <em>OR</em> setting the gap_open_cost parameter (a single positive integer).
If affine alignment is used, the cost of a gap is defined as:
TOTAL_GAP_COST = gap_open_cost + (gap_cost * gap_length).
</p>
<p>If mode == &quot;hamming&quot; all alignment parameters are ignored; mismatch is given a distance of 1 and gaps are not allowed.
</p>


<h3>Value</h3>

<p>The output is a distance matrix between all query (rows) and target (columns) sequences.
For anchored searches, the output also includes attributes &quot;query_size&quot; and &quot;target_size&quot; which are matrices containing the lengths of the query and target sequences that are aligned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist_matrix(c("ACGT", "AAAA"), c("ACG", "ACGT"), mode = "global")
</code></pre>

<hr>
<h2 id='dist_pairwise'>Pairwise distance between two sets of sequences</h2><span id='topic+dist_pairwise'></span>

<h3>Description</h3>

<p>Compute the pairwise distance between two sets of sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_pairwise(
  query,
  target,
  mode,
  cost_matrix = NULL,
  gap_cost = NULL,
  gap_open_cost = NULL,
  nthreads = 1,
  show_progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_pairwise_+3A_query">query</code></td>
<td>
<p>A character vector of query sequences.</p>
</td></tr>
<tr><td><code id="dist_pairwise_+3A_target">target</code></td>
<td>
<p>A character vector of target sequences.. Must be the same length as query.</p>
</td></tr>
<tr><td><code id="dist_pairwise_+3A_mode">mode</code></td>
<td>
<p>The distance metric to use. One of hamming (hm), global (gb) or anchored (an).</p>
</td></tr>
<tr><td><code id="dist_pairwise_+3A_cost_matrix">cost_matrix</code></td>
<td>
<p>A custom cost matrix for use with the &quot;global&quot; or &quot;anchored&quot; distance metrics. See details.</p>
</td></tr>
<tr><td><code id="dist_pairwise_+3A_gap_cost">gap_cost</code></td>
<td>
<p>The cost of a gap for use with the &quot;global&quot; or &quot;anchored&quot; distance metrics. See details.</p>
</td></tr>
<tr><td><code id="dist_pairwise_+3A_gap_open_cost">gap_open_cost</code></td>
<td>
<p>The cost of a gap opening. See details.</p>
</td></tr>
<tr><td><code id="dist_pairwise_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads to use for parallel computation.</p>
</td></tr>
<tr><td><code id="dist_pairwise_+3A_show_progress">show_progress</code></td>
<td>
<p>Whether to show a progress bar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates pairwise distances based on Hamming, Levenshtein or Anchored algorithms. <em>query</em> and <em>target</em> must be the same length.
</p>
<p>Three types of distance metrics are supported, based on the form of alignment performed. These are: Hamming, Global (Levenshtein) and Anchored.
</p>
<p>An anchored alignment is a form of semi-global alignment, where the query sequence is &quot;anchored&quot; (global) to the beginning of both the query and target sequences,
but is semi-global in that the end of the either the query sequence or target sequence (but not both) can be unaligned. This type of alignment is sometimes called an &quot;extension&quot; alignment in literature.
</p>
<p>In contrast a global alignment must align the entire query and target sequences. When mismatch and indel costs are equal to 1, this is also known as the Levenshtein distance.
</p>
<p>By default, if mode == &quot;global&quot; or &quot;anchored&quot;, all mismatches and indels are given a cost of 1. However, you can define your own distance metric by setting the cost_matrix and gap parameters.
The cost_matrix is a strictly positive square integer matrix and should include all characters in query and target as column- and rownames.
To set the cost of a gap (insertion or deletion) you can include a row and column named &quot;gap&quot; in the cost_matrix <em>OR</em> set the gap_cost parameter (a single positive integer).
Similarly, the affine gap alignment can be set by including a row and column named &quot;gap_open&quot; in the cost_matrix <em>OR</em> setting the gap_open_cost parameter (a single positive integer).
If affine alignment is used, the cost of a gap is defined as:
TOTAL_GAP_COST = gap_open_cost + (gap_cost * gap_length).
</p>
<p>If mode == &quot;hamming&quot; all alignment parameters are ignored; mismatch is given a distance of 1 and gaps are not allowed.
</p>


<h3>Value</h3>

<p>The output of this function is a vector of distances. If mode == &quot;anchored&quot; then the output also includes attributes &quot;query_size&quot; and
&quot;target_size&quot; which are vectors containing the lengths of the query and target sequences that are aligned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist_pairwise(c("ACGT", "AAAA"), c("ACG", "ACGT"), mode = "global")
</code></pre>

<hr>
<h2 id='dist_search'>Distance search for similar sequences</h2><span id='topic+dist_search'></span>

<h3>Description</h3>

<p>Find similar sequences within a distance threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_search(
  query,
  target,
  max_distance = NULL,
  max_fraction = NULL,
  mode = "levenshtein",
  cost_matrix = NULL,
  gap_cost = NULL,
  gap_open_cost = NULL,
  tree_class = "RadixTree",
  nthreads = 1,
  show_progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_search_+3A_query">query</code></td>
<td>
<p>A character vector of query sequences.</p>
</td></tr>
<tr><td><code id="dist_search_+3A_target">target</code></td>
<td>
<p>A character vector of target sequences.</p>
</td></tr>
<tr><td><code id="dist_search_+3A_max_distance">max_distance</code></td>
<td>
<p>how far to search in units of absolute distance. Can be a single value or a vector. Mutually exclusive with max_fraction.</p>
</td></tr>
<tr><td><code id="dist_search_+3A_max_fraction">max_fraction</code></td>
<td>
<p>how far to search in units of relative distance to each query sequence length. Can be a single value or a vector. Mutually exclusive with max_distance.</p>
</td></tr>
<tr><td><code id="dist_search_+3A_mode">mode</code></td>
<td>
<p>The distance metric to use. One of hamming (hm), global (gb) or anchored (an).</p>
</td></tr>
<tr><td><code id="dist_search_+3A_cost_matrix">cost_matrix</code></td>
<td>
<p>A custom cost matrix for use with the &quot;global&quot; or &quot;anchored&quot; distance metrics. See details.</p>
</td></tr>
<tr><td><code id="dist_search_+3A_gap_cost">gap_cost</code></td>
<td>
<p>The cost of a gap for use with the &quot;global&quot; or &quot;anchored&quot; distance metrics. See details.</p>
</td></tr>
<tr><td><code id="dist_search_+3A_gap_open_cost">gap_open_cost</code></td>
<td>
<p>The cost of a gap opening. See details.</p>
</td></tr>
<tr><td><code id="dist_search_+3A_tree_class">tree_class</code></td>
<td>
<p>Which R6 class to use. Either RadixTree or RadixForest (default: RadixTree)</p>
</td></tr>
<tr><td><code id="dist_search_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads to use for parallel computation.</p>
</td></tr>
<tr><td><code id="dist_search_+3A_show_progress">show_progress</code></td>
<td>
<p>Whether to show a progress bar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds all sequences in <em>target</em> that are within a distance threshold of any sequence in <em>query</em>.
This function uses either a RadixTree or RadixForest to store <em>target</em> sequences. See the R6 class documentation for additional details.
</p>
<p>Three types of distance metrics are supported, based on the form of alignment performed. These are: Hamming, Global (Levenshtein) and Anchored.
</p>
<p>An anchored alignment is a form of semi-global alignment, where the query sequence is &quot;anchored&quot; (global) to the beginning of both the query and target sequences,
but is semi-global in that the end of the either the query sequence or target sequence (but not both) can be unaligned. This type of alignment is sometimes called an &quot;extension&quot; alignment in literature.
</p>
<p>In contrast a global alignment must align the entire query and target sequences. When mismatch and indel costs are equal to 1, this is also known as the Levenshtein distance.
</p>
<p>By default, if mode == &quot;global&quot; or &quot;anchored&quot;, all mismatches and indels are given a cost of 1. However, you can define your own distance metric by setting the cost_matrix and gap parameters.
The cost_matrix is a strictly positive square integer matrix and should include all characters in query and target as column- and rownames.
To set the cost of a gap (insertion or deletion) you can include a row and column named &quot;gap&quot; in the cost_matrix <em>OR</em> set the gap_cost parameter (a single positive integer).
Similarly, the affine gap alignment can be set by including a row and column named &quot;gap_open&quot; in the cost_matrix <em>OR</em> setting the gap_open_cost parameter (a single positive integer).
If affine alignment is used, the cost of a gap is defined as:
TOTAL_GAP_COST = gap_open_cost + (gap_cost * gap_length).
</p>
<p>If mode == &quot;hamming&quot; all alignment parameters are ignored; mismatch is given a distance of 1 and gaps are not allowed.
</p>


<h3>Value</h3>

<p>The output is a data.frame of all matches with columns &quot;query&quot; and &quot;target&quot;.
For anchored searches, the output also includes attributes &quot;query_size&quot; and &quot;target_size&quot;
which are vectors containing the portion of the query and target sequences that are aligned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist_search(c("ACGT", "AAAA"), c("ACG", "ACGT"), max_distance = 1, mode = "levenshtein")
</code></pre>

<hr>
<h2 id='generate_cost_matrix'>Generate a simple cost matrix</h2><span id='topic+generate_cost_matrix'></span>

<h3>Description</h3>

<p>Generate a cost matrix for use with the <code>search</code> method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_cost_matrix(
  charset,
  match = 0L,
  mismatch = 1L,
  gap = NULL,
  gap_open = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_cost_matrix_+3A_charset">charset</code></td>
<td>
<p>A string representing all possible characters in both query and target sequences (e.g. &quot;ACGT&quot;)</p>
</td></tr>
<tr><td><code id="generate_cost_matrix_+3A_match">match</code></td>
<td>
<p>The cost of a match</p>
</td></tr>
<tr><td><code id="generate_cost_matrix_+3A_mismatch">mismatch</code></td>
<td>
<p>The cost of a mismatch</p>
</td></tr>
<tr><td><code id="generate_cost_matrix_+3A_gap">gap</code></td>
<td>
<p>The cost of a gap or NULL if this parameter will be set later.</p>
</td></tr>
<tr><td><code id="generate_cost_matrix_+3A_gap_open">gap_open</code></td>
<td>
<p>The cost of a gap opening or NULL. If this parameter is set, gap must also be set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cost matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generate_cost_matrix("ACGT", match = 0, mismatch = 1)
</code></pre>

<hr>
<h2 id='RadixForest'>RadixForest</h2><span id='topic+RadixForest'></span>

<h3>Description</h3>

<p>Radix Forest class implementation
</p>


<h3>Details</h3>

<p>The RadixForest class is a specialization of the RadixTree implementation. Instead of putting sequences into
a single tree, the RadixForest class puts sequences into separate trees based on sequence length. This allows for faster
searching of similar sequences based on Hamming or Levenshtein distance metrics.
Unlike the RadixTree class, the RadixForest class does not support anchored searches or a custom cost matrix.
See <em>RadixTree</em> for additional details.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>forest_pointer</code></dt><dd><p>Map of sequence length to RadixTree</p>
</dd>
<dt><code>char_counter_pointer</code></dt><dd><p>Character count data for the purpose of validating input</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RadixForest-new"><code>RadixForest$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixForest-show"><code>RadixForest$show()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixForest-to_string"><code>RadixForest$to_string()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixForest-graph"><code>RadixForest$graph()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixForest-to_vector"><code>RadixForest$to_vector()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixForest-size"><code>RadixForest$size()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixForest-insert"><code>RadixForest$insert()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixForest-erase"><code>RadixForest$erase()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixForest-find"><code>RadixForest$find()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixForest-prefix_search"><code>RadixForest$prefix_search()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixForest-search"><code>RadixForest$search()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixForest-validate"><code>RadixForest$validate()</code></a>
</p>
</li></ul>


<hr>
<a id="method-RadixForest-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new RadixForest object
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixForest$new(sequences = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sequences</code></dt><dd><p>A character vector of sequences to insert into the forest</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RadixForest-show"></a>



<h4>Method <code>show()</code></h4>

<p>Print the forest to screen
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixForest$show()</pre></div>


<hr>
<a id="method-RadixForest-to_string"></a>



<h4>Method <code>to_string()</code></h4>

<p>Print the forest to a string
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixForest$to_string()</pre></div>


<hr>
<a id="method-RadixForest-graph"></a>



<h4>Method <code>graph()</code></h4>

<p>Plot of the forest using igraph
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixForest$graph(depth = -1, root_label = "root", plot = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>depth</code></dt><dd><p>The tree depth to plot for each tree in the forest.</p>
</dd>
<dt><code>root_label</code></dt><dd><p>The label of the root node(s) in the plot.</p>
</dd>
<dt><code>plot</code></dt><dd><p>Whether to create a plot or return the data used to generate the plot.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A data frame of parent-child relationships used to generate the igraph plot OR a ggplot2 object
</p>


<hr>
<a id="method-RadixForest-to_vector"></a>



<h4>Method <code>to_vector()</code></h4>

<p>Output all sequences held by the forest as a character vector
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixForest$to_vector()</pre></div>



<h5>Returns</h5>

<p>A character vector of all sequences contained in the forest.
</p>


<hr>
<a id="method-RadixForest-size"></a>



<h4>Method <code>size()</code></h4>

<p>Output the size of the forest (i.e. how many sequences are contained)
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixForest$size()</pre></div>



<h5>Returns</h5>

<p>The size of the forest
</p>


<hr>
<a id="method-RadixForest-insert"></a>



<h4>Method <code>insert()</code></h4>

<p>Insert new sequences into the forest
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixForest$insert(sequences)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sequences</code></dt><dd><p>A character vector of sequences to insert into the forest</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A logical vector indicating whether the sequence was inserted (TRUE) or already existing in the forest (FALSE)
</p>


<hr>
<a id="method-RadixForest-erase"></a>



<h4>Method <code>erase()</code></h4>

<p>Erase sequences from the forest
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixForest$erase(sequences)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sequences</code></dt><dd><p>A character vector of sequences to erase from the forest</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A logical vector indicating whether the sequence was erased (TRUE) or not found in the forest (FALSE)
</p>


<hr>
<a id="method-RadixForest-find"></a>



<h4>Method <code>find()</code></h4>

<p>Find sequences in the forest
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixForest$find(query)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt><dd><p>A character vector of sequences to find in the forest</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A logical vector indicating whether the sequence was found (TRUE) or not found in the forest (FALSE)
</p>


<hr>
<a id="method-RadixForest-prefix_search"></a>



<h4>Method <code>prefix_search()</code></h4>

<p>Search for sequences in the forest that start with a specified prefix.
E.g.: a query of &quot;CAR&quot; will find &quot;CART&quot;, &quot;CARBON&quot;, &quot;CARROT&quot;, etc. but not &quot;CATS&quot;.
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixForest$prefix_search(query)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt><dd><p>A character vector of sequences to search for in the forest</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A data frame of all matches with columns &quot;query&quot; and &quot;target&quot;.
</p>


<hr>
<a id="method-RadixForest-search"></a>



<h4>Method <code>search()</code></h4>

<p>Search for sequences in the forest that are with a specified distance metric to a specified query.
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixForest$search(
  query,
  max_distance = NULL,
  max_fraction = NULL,
  mode = "levenshtein",
  nthreads = 1,
  show_progress = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt><dd><p>A character vector of query sequences.</p>
</dd>
<dt><code>max_distance</code></dt><dd><p>how far to search in units of absolute distance. Can be a single value or a vector. Mutually exclusive with max_fraction.</p>
</dd>
<dt><code>max_fraction</code></dt><dd><p>how far to search in units of relative distance to each query sequence length. Can be a single value or a vector. Mutually exclusive with max_distance.</p>
</dd>
<dt><code>mode</code></dt><dd><p>The distance metric to use. One of hamming (hm), global (gb) or anchored (an).</p>
</dd>
<dt><code>nthreads</code></dt><dd><p>The number of threads to use for parallel computation.</p>
</dd>
<dt><code>show_progress</code></dt><dd><p>Whether to show a progress bar.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The output is a data.frame of all matches with columns &quot;query&quot; and &quot;target&quot;.
</p>


<hr>
<a id="method-RadixForest-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Validate the forest
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixForest$validate()</pre></div>



<h5>Returns</h5>

<p>A logical indicating whether the forest is valid (TRUE) or not (FALSE). This is mostly an internal function for debugging purposes and should always return TRUE.
</p>




<h3>Examples</h3>

<pre><code class='language-R'>forest &lt;- RadixForest$new()
forest$insert(c("ACGT", "AAAA"))
forest$erase("AAAA")
forest$search("ACG", max_distance = 1, mode = "levenshtein")
 #   query target distance
 # 1   ACG   ACGT        1
 
forest$search("ACG", max_distance = 1, mode = "hamming")
 # query    target   distance
 # &lt;0 rows&gt; (or 0-length row.names)
</code></pre>

<hr>
<h2 id='RadixTree'>RadixTree</h2><span id='topic+RadixTree'></span>

<h3>Description</h3>

<p>Radix Tree (trie) class implementation
</p>


<h3>Details</h3>

<p>The RadixTree class is a trie implementation. The primary usage is to be able to search of similar sequences based on a dynamic programming framework.
This can be done using the <em>search</em> method which searches for similar sequences based on the Global, Anchored or Hamming distance metrics.
</p>
<p>Three types of distance metrics are supported, based on the form of alignment performed. These are: Hamming, Global (Levenshtein) and Anchored.
</p>
<p>An anchored alignment is a form of semi-global alignment, where the query sequence is &quot;anchored&quot; (global) to the beginning of both the query and target sequences,
but is semi-global in that the end of the either the query sequence or target sequence (but not both) can be unaligned. This type of alignment is sometimes called an &quot;extension&quot; alignment in literature.
</p>
<p>In contrast a global alignment must align the entire query and target sequences. When mismatch and indel costs are equal to 1, this is also known as the Levenshtein distance.
</p>
<p>By default, if mode == &quot;global&quot; or &quot;anchored&quot;, all mismatches and indels are given a cost of 1. However, you can define your own distance metric by setting the cost_matrix and gap parameters.
The cost_matrix is a strictly positive square integer matrix and should include all characters in query and target as column- and rownames.
To set the cost of a gap (insertion or deletion) you can include a row and column named &quot;gap&quot; in the cost_matrix <em>OR</em> set the gap_cost parameter (a single positive integer).
Similarly, the affine gap alignment can be set by including a row and column named &quot;gap_open&quot; in the cost_matrix <em>OR</em> setting the gap_open_cost parameter (a single positive integer).
If affine alignment is used, the cost of a gap is defined as:
TOTAL_GAP_COST = gap_open_cost + (gap_cost * gap_length).
</p>
<p>If mode == &quot;hamming&quot; all alignment parameters are ignored; mismatch is given a distance of 1 and gaps are not allowed.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>root_pointer</code></dt><dd><p>Root of the RadixTree</p>
</dd>
<dt><code>char_counter_pointer</code></dt><dd><p>Character count data for the purpose of validating input</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RadixTree-new"><code>RadixTree$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-show"><code>RadixTree$show()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-to_string"><code>RadixTree$to_string()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-graph"><code>RadixTree$graph()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-to_vector"><code>RadixTree$to_vector()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-size"><code>RadixTree$size()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-insert"><code>RadixTree$insert()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-erase"><code>RadixTree$erase()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-find"><code>RadixTree$find()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-prefix_search"><code>RadixTree$prefix_search()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-search"><code>RadixTree$search()</code></a>
</p>
</li>
<li> <p><a href="#method-RadixTree-validate"><code>RadixTree$validate()</code></a>
</p>
</li></ul>


<hr>
<a id="method-RadixTree-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new RadixTree object
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$new(sequences = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sequences</code></dt><dd><p>A character vector of sequences to insert into the tree</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RadixTree-show"></a>



<h4>Method <code>show()</code></h4>

<p>Print the tree to screen
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$show()</pre></div>


<hr>
<a id="method-RadixTree-to_string"></a>



<h4>Method <code>to_string()</code></h4>

<p>Print the tree to a string
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$to_string()</pre></div>



<h5>Returns</h5>

<p>A string representation of the tree
</p>


<hr>
<a id="method-RadixTree-graph"></a>



<h4>Method <code>graph()</code></h4>

<p>Plot of the tree using igraph (needs to be installed separately)
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$graph(depth = -1, root_label = "root", plot = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>depth</code></dt><dd><p>The tree depth to plot. If -1 (default), plot the entire tree.</p>
</dd>
<dt><code>root_label</code></dt><dd><p>The label of the root node in the plot.</p>
</dd>
<dt><code>plot</code></dt><dd><p>Whether to create a plot or return the data used to generate the plot.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A data frame of parent-child relationships used to generate the igraph plot OR a ggplot2 object
</p>


<hr>
<a id="method-RadixTree-to_vector"></a>



<h4>Method <code>to_vector()</code></h4>

<p>Output all sequences held by the tree as a character vector
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$to_vector()</pre></div>



<h5>Returns</h5>

<p>A character vector of all sequences contained in the tree. Return order is not guaranteed.
</p>


<hr>
<a id="method-RadixTree-size"></a>



<h4>Method <code>size()</code></h4>

<p>Output the size of the tree (i.e. how many sequences are contained)
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$size()</pre></div>



<h5>Returns</h5>

<p>The size of the tree
</p>


<hr>
<a id="method-RadixTree-insert"></a>



<h4>Method <code>insert()</code></h4>

<p>Insert new sequences into the tree
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$insert(sequences)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sequences</code></dt><dd><p>A character vector of sequences to insert into the tree</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A logical vector indicating whether the sequence was inserted (TRUE) or already existing in the tree (FALSE)
</p>


<hr>
<a id="method-RadixTree-erase"></a>



<h4>Method <code>erase()</code></h4>

<p>Erase sequences from the tree
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$erase(sequences)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sequences</code></dt><dd><p>A character vector of sequences to erase from the tree</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A logical vector indicating whether the sequence was erased (TRUE) or not found in the tree (FALSE)
</p>


<hr>
<a id="method-RadixTree-find"></a>



<h4>Method <code>find()</code></h4>

<p>Find sequences in the tree
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$find(query)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt><dd><p>A character vector of sequences to find in the tree</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A logical vector indicating whether the sequence was found (TRUE) or not found in the tree (FALSE)
</p>


<hr>
<a id="method-RadixTree-prefix_search"></a>



<h4>Method <code>prefix_search()</code></h4>

<p>Search for sequences in the tree that start with a specified prefix.
E.g.: a query of &quot;CAR&quot; will find &quot;CART&quot;, &quot;CARBON&quot;, &quot;CARROT&quot;, etc. but not &quot;CATS&quot;.
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$prefix_search(query)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt><dd><p>A character vector of sequences to search for in the tree</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A data frame of all matches with columns &quot;query&quot; and &quot;target&quot;.
</p>


<hr>
<a id="method-RadixTree-search"></a>



<h4>Method <code>search()</code></h4>

<p>Search for sequences in the tree that are with a specified distance metric to a specified query.
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$search(
  query,
  max_distance = NULL,
  max_fraction = NULL,
  mode = "levenshtein",
  cost_matrix = NULL,
  gap_cost = NULL,
  gap_open_cost = NULL,
  nthreads = 1,
  show_progress = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt><dd><p>A character vector of query sequences.</p>
</dd>
<dt><code>max_distance</code></dt><dd><p>how far to search in units of absolute distance. Can be a single value or a vector. Mutually exclusive with max_fraction.</p>
</dd>
<dt><code>max_fraction</code></dt><dd><p>how far to search in units of relative distance to each query sequence length. Can be a single value or a vector. Mutually exclusive with max_distance.</p>
</dd>
<dt><code>mode</code></dt><dd><p>The distance metric to use. One of hamming (hm), global (gb) or anchored (an).</p>
</dd>
<dt><code>cost_matrix</code></dt><dd><p>A custom cost matrix for use with the &quot;global&quot; or &quot;anchored&quot; distance metrics. See details.</p>
</dd>
<dt><code>gap_cost</code></dt><dd><p>The cost of a gap for use with the &quot;global&quot; or &quot;anchored&quot; distance metrics. See details.</p>
</dd>
<dt><code>gap_open_cost</code></dt><dd><p>The cost of a gap opening. See details.</p>
</dd>
<dt><code>nthreads</code></dt><dd><p>The number of threads to use for parallel computation.</p>
</dd>
<dt><code>show_progress</code></dt><dd><p>Whether to show a progress bar.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The output is a data.frame of all matches with columns &quot;query&quot; and &quot;target&quot;.
For anchored searches, the output also includes attributes &quot;query_size&quot; and &quot;target_size&quot; which are vectors containing the portion of the query and target sequences that are aligned.
</p>


<hr>
<a id="method-RadixTree-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Validate the tree
</p>


<h5>Usage</h5>

<div class="r"><pre>RadixTree$validate()</pre></div>



<h5>Returns</h5>

<p>A logical indicating whether the tree is valid (TRUE) or not (FALSE). This is mostly an internal function for debugging purposes and should always return TRUE.
</p>




<h3>See Also</h3>

<p>https://en.wikipedia.org/wiki/Radix_tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- RadixTree$new()
tree$insert(c("ACGT", "AAAA"))
tree$erase("AAAA")
tree$search("ACG", max_distance = 1, mode = "levenshtein")
#   query target distance
# 1   ACG   ACGT        1

tree$search("ACG", max_distance = 1, mode = "hamming")
# query    target   distance
# &lt;0 rows&gt; (or 0-length row.names)
</code></pre>

<hr>
<h2 id='split_search'>split_search</h2><span id='topic+split_search'></span>

<h3>Description</h3>

<p>Search for similar sequences based on splitting sequences into left and right sides
and searching for matches in each side using a bi-directional anchored alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_search(
  query,
  target,
  query_split,
  target_split,
  edge_trim = 0L,
  max_distance = 0L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_search_+3A_query">query</code></td>
<td>
<p>A character vector of query sequences.</p>
</td></tr>
<tr><td><code id="split_search_+3A_target">target</code></td>
<td>
<p>A character vector of target sequences.</p>
</td></tr>
<tr><td><code id="split_search_+3A_query_split">query_split</code></td>
<td>
<p>index to split query sequence. Should be within (edge_trim, nchar(query)-edge_trim] or -1 to indicate no split.</p>
</td></tr>
<tr><td><code id="split_search_+3A_target_split">target_split</code></td>
<td>
<p>index to split target sequence. Should be within (edge_trim, nchar(query)-edge_trim] or -1 to indicate no split.</p>
</td></tr>
<tr><td><code id="split_search_+3A_edge_trim">edge_trim</code></td>
<td>
<p>number of bases to trim from each side of the sequence (default value: 0).</p>
</td></tr>
<tr><td><code id="split_search_+3A_max_distance">max_distance</code></td>
<td>
<p>how far to search in units of absolute distance. Can be a single value or a vector. Mutually exclusive with max_fraction.</p>
</td></tr>
<tr><td><code id="split_search_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>RadixTree$search</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for searching for similar sequences that may have variable windows of sequencing (e.g. different 5' and 3' primers)
but contain the same core sequence or position.
The two split parameters partition the query and target sequences into left and right sides,
where left = stri_sub(sequence, edge_trim+1, split) and right = stri_sub(query, split+1, -edge_trim-1).
</p>


<h3>Value</h3>

<p>data.frame with columns query, target, and distance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider two sets of sequences
# query1   AGACCTAA CCC
# target1 AAGACCTAA CC
# query2   GGGTGTAA CCACCC
# target2   GGTGTAA CCAC
# Despite having different frames, query1 and query2 and clearly 
# match to target1 and target2, respectively.
# One could consider splitting based on a common core sequence, 
# e.g. a common TAA stop codon. 
split_search(query=c(  "AGACCTAACCC", "GGGTGTAACCACCC"),
             target=c("AAGACCTAACC",   "GGTGTAACCAC"),
             query_split=c(8, 8),
             target_split=c(9, 7),
             edge_trim=0,
             max_distance=0)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
