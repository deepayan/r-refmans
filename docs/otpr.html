<!DOCTYPE html><html><head><title>Help for package otpr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {otpr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#otp_check_mode'><p>Check and process transport mode</p></a></li>
<li><a href='#otp_check_params'><p>Check OTP parameters</p></a></li>
<li><a href='#otp_connect'><p>Set up and confirm a connection to an OTP instance.</p></a></li>
<li><a href='#otp_create_surface'><p>Creates a travel time surface (OTPv1 only).</p></a></li>
<li><a href='#otp_evaluate_surface'><p>Evaluates an existing travel time surface (OTPv1 only).</p></a></li>
<li><a href='#otp_from_epoch'><p>Convert time from EPOCH format</p></a></li>
<li><a href='#otp_get_distance'><p>Finds the distance in metres between supplied origin and destination</p></a></li>
<li><a href='#otp_get_isochrone'><p>Returns one or more travel time isochrones (OTPv1 only)</p></a></li>
<li><a href='#otp_get_times'><p>Queries OTP for the time or detailed itinerary for a trip between an origin</p>
and destination</a></li>
<li><a href='#otp_is_date'><p>Checks the date format</p></a></li>
<li><a href='#otp_is_time'><p>Checks the time format</p></a></li>
<li><a href='#otp_vector_match'><p>Checks if two vectors are the same but where order doesn't matter</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>An R Wrapper for the 'OpenTripPlanner' REST API</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A wrapper for the 'OpenTripPlanner' <a href="http://www.opentripplanner.org/">http://www.opentripplanner.org/</a>
    REST API. Queries are submitted to the relevant 'OpenTripPlanner' API resource, the response
    is parsed and useful R objects are returned.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, httr, geojsonsf, janitor, jsonlite, sf, urltools,
dplyr, rrapply, rlang</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-07 13:07:17 UTC; myoun</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcus Young <a href="https://orcid.org/0000-0003-4627-1116"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marcus Young &lt;M.A.Young@soton.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-07 13:22:45 UTC</td>
</tr>
</table>
<hr>
<h2 id='otp_check_mode'>Check and process transport mode</h2><span id='topic+otp_check_mode'></span>

<h3>Description</h3>

<p>Check and process transport mode
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otp_check_mode(mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otp_check_mode_+3A_mode">mode</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>

<hr>
<h2 id='otp_check_params'>Check OTP parameters</h2><span id='topic+otp_check_params'></span>

<h3>Description</h3>

<p>Check OTP parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otp_check_params(otpcon, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otp_check_params_+3A_otpcon">otpcon</code></td>
<td>
<p>Object of otpcon class</p>
</td></tr>
<tr><td><code id="otp_check_params_+3A_...">...</code></td>
<td>
<p>Other optional parameters</p>
</td></tr>
</table>

<hr>
<h2 id='otp_connect'>Set up and confirm a connection to an OTP instance.</h2><span id='topic+otp_connect'></span>

<h3>Description</h3>

<p>Defines the parameters required to connect to a router on an OTP instance and,
if required, confirms that the instance and router are queryable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otp_connect(
  hostname = "localhost",
  router = "default",
  port = 8080,
  tz = Sys.timezone(),
  ssl = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otp_connect_+3A_hostname">hostname</code></td>
<td>
<p>A string, e.g. &quot;ec2-34-217-73-26.us-west-2.compute.amazonaws.com&quot;.
Optional, default is &quot;localhost&quot;.</p>
</td></tr>
<tr><td><code id="otp_connect_+3A_router">router</code></td>
<td>
<p>A string, e.g. &quot;UK2018&quot;. Optional, default is &quot;default&quot;. Do not
specify for OTPv2 which does not support named routers.</p>
</td></tr>
<tr><td><code id="otp_connect_+3A_port">port</code></td>
<td>
<p>A positive integer. Optional, default is 8080.</p>
</td></tr>
<tr><td><code id="otp_connect_+3A_tz">tz</code></td>
<td>
<p>A string, containing the time zone of the router's graph. Optional.
This should be a valid time zone (checked against vector returned by
'OlsonNames()'). For example: &quot;Europe/Berlin&quot;. Default is the timezone of the
current system (obtained from <code>Sys.timezone()</code>). Using the default will
be ok if the current system time zone is the same as the time zone of the OTP
graph.</p>
</td></tr>
<tr><td><code id="otp_connect_+3A_ssl">ssl</code></td>
<td>
<p>Logical, indicates whether to use https. Optional, default is FALSE.</p>
</td></tr>
<tr><td><code id="otp_connect_+3A_check">check</code></td>
<td>
<p>Deprecated and has no effect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns S3 object of class otpconnect if reachable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
otpcon &lt;- otpr_connect()
otpcon &lt;- otpr_connect(router = "UK2018",
                      ssl = TRUE)
otpcon &lt;- otpr_connect(hostname = "ec2.us-west-2.compute.amazonaws.com",
                      router = "UK2018",
                      port = 8888,
                      ssl = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='otp_create_surface'>Creates a travel time surface (OTPv1 only).</h2><span id='topic+otp_create_surface'></span>

<h3>Description</h3>

<p>Creates a travel time surface for an origin point. A surface contains the travel time
to every geographic coordinate that can be reached from that origin (up to a hard coded
limit in OTP of 120 minutes). Optionally, the surface can be saved as a raster file (GeoTIFF)
to a designated directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otp_create_surface(
  otpcon,
  getRaster = FALSE,
  rasterPath = tempdir(),
  fromPlace,
  mode = "TRANSIT",
  date = format(Sys.Date(), "%m-%d-%Y"),
  time = format(Sys.time(), "%H:%M:%S"),
  maxWalkDistance = NULL,
  walkReluctance = 2,
  waitReluctance = 1,
  transferPenalty = 0,
  minTransferTime = 0,
  batch = TRUE,
  arriveBy = TRUE,
  extra.params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otp_create_surface_+3A_otpcon">otpcon</code></td>
<td>
<p>An OTP connection object produced by <code><a href="#topic+otp_connect">otp_connect</a></code>.</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_getraster">getRaster</code></td>
<td>
<p>Logical. Whether or not to download a raster (geoTIFF) of the generated
surface. Default FALSE.</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_rasterpath">rasterPath</code></td>
<td>
<p>Character. Path of a directory where the the surface raster
should be saved if <code>getRaster</code> is TRUE. Default is <code>tempdir()</code>. Use forward slashes on Windows.
The file will be named surface_id.tiff, with id replaced by the OTP id assigned
to the surface.</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_fromplace">fromPlace</code></td>
<td>
<p>Numeric vector, Latitude/Longitude pair, e.g. 'c(53.48805, -2.24258)'. This is
the origin of the surface to be created.</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_mode">mode</code></td>
<td>
<p>Character vector, mode(s) of travel. Valid values are: WALK, BICYCLE,
CAR, TRANSIT, BUS, RAIL, TRAM, SUBWAY OR 'c(&quot;TRANSIT&quot;, &quot;BICYCLE&quot;)'. TRANSIT will use all
available transit modes. Default is CAR. WALK mode is automatically
added for TRANSIT, BUS, RAIL, TRAM, and SUBWAY.</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_date">date</code></td>
<td>
<p>Character, must be in the format mm-dd-yyyy. This is the desired date of travel.
Only relevant for transit modes. Default is the current system date.</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_time">time</code></td>
<td>
<p>Character, must be in the format hh:mm:ss.
If <code>arriveBy</code> is FALSE (the default) this is the desired departure time, otherwise the
desired arrival time. Only relevant for transit modes. Default is the current system time.</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_maxwalkdistance">maxWalkDistance</code></td>
<td>
<p>Numeric. The maximum distance (in meters) that the user is
willing to walk. Default is NULL (the parameter is not passed to the API and the OTP
default of unlimited takes effect).
This is a soft limit in OTPv1 and is ignored if the mode is WALK only. In OTPv2
this parameter imposes a hard limit on WALK, CAR and BICYCLE modes (see:
<a href="http://docs.opentripplanner.org/en/latest/OTP2-MigrationGuide/#router-config">http://docs.opentripplanner.org/en/latest/OTP2-MigrationGuide/#router-config</a>).</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_walkreluctance">walkReluctance</code></td>
<td>
<p>A single numeric value. A multiplier for how bad walking is
compared to being in transit for equal lengths of time. Default = 2.</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_waitreluctance">waitReluctance</code></td>
<td>
<p>A single numeric value. A multiplier for how bad waiting for a
transit vehicle is compared to being on a transit vehicle. This should be greater
than 1 and less than <code>walkReluctance</code> (see API docs). Default = 1.</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_transferpenalty">transferPenalty</code></td>
<td>
<p>Integer. An additional penalty added to boardings after
the first. The value is in OTP's internal weight units, which are roughly equivalent to seconds.
Set this to a high value to discourage transfers. Default is 0.</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_mintransfertime">minTransferTime</code></td>
<td>
<p>Integer. The minimum time, in seconds, between successive
trips on different vehicles. This is designed to allow for imperfect schedule
adherence. This is a minimum; transfers over longer distances might use a longer time.
Default is 0.</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_batch">batch</code></td>
<td>
<p>Logical. Set to TRUE by default. This is required to tell OTP
to allow a query without the  <code>toPlace</code> parameter. This is necessary as we want to build
paths to all destinations from one origin.</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_arriveby">arriveBy</code></td>
<td>
<p>Logical. Whether a trip should depart (FALSE) or arrive (TRUE) at the specified
date and time. Default is FALSE.</p>
</td></tr>
<tr><td><code id="otp_create_surface_+3A_extra.params">extra.params</code></td>
<td>
<p>A list of any other parameters accepted by the OTP API SurfaceResource entry point. For
advanced users. Be aware that otpr will carry out no validation of these additional
parameters. They will be passed directly to the API.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are a few things to note regarding the raster image that OTP creates:
</p>

<ul>
<li><p> The travel time cutoff for a surface is hard-coded within OTP at 120 minutes. Every grid
cell within the extent of the graph that is 120 minutes travel time or beyond, or not accessible,
is given the value of 120.
</p>
</li>
<li><p> Any grid cell outside of the extent of the network (i.e. unreachable) is given the value 128.
</p>
</li>
<li><p> It is advisable to interpret the raster of a surface in conjunction with results from 
evaluating the surface.
</p>
</li>
<li><p> OTP can take a while the first time a raster of a surface is generated after starting up. Subsequent
rasters (even for different origins) are much faster to generate.
</p>
</li></ul>



<h3>Value</h3>

<p>Assuming no error, returns a list of 5 elements:
</p>

<ul>
<li> <p><code>errorId</code> Will be &quot;OK&quot; if no error condition.
</p>
</li>
<li> <p><code>surfaceId</code> The id of the surface that was evaluated.
</p>
</li>
<li> <p><code>surfaceRecord</code> Details of the parameters used to create the surface.
</p>
</li>
<li> <p><code>rasterDownload</code> The path to the saved raster file (if <code>getRaster</code> was
set to TRUE and a valid path was provided via <code>rasterPath</code>.)
</p>
</li>
<li> <p><code>query</code> The URL that was submitted to the OTP API.
</p>
</li></ul>

<p>If there is an error, a list containing 3 elements is returned:
</p>

<ul>
<li> <p><code>errorId</code> The id code of the error.
</p>
</li>
<li> <p><code>errorMessage</code> The error message.
</p>
</li>
<li> <p><code>query</code> The URL that was submitted to the OTP API.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
otp_create_surface(otpcon, fromPlace = c(53.43329,-2.13357), mode = "TRANSIT",
maxWalkDistance = 1600, getRaster = TRUE)

otp_create_surface(otpcon, fromPlace = c(53.43329,-2.13357), date = "03-26-2019",
time = "08:00:00", mode = "BUS", maxWalkDistance = 1600, getRaster = TRUE,
rasterPath = "C:/temp")

## End(Not run)
</code></pre>

<hr>
<h2 id='otp_evaluate_surface'>Evaluates an existing travel time surface (OTPv1 only).</h2><span id='topic+otp_evaluate_surface'></span>

<h3>Description</h3>

<p>Evaluates an existing travel time surface. Using a pointset from a specified CSV file,
the travel time to each point is obtained from the specified surface. Accessibility
indicators are then generated for one or more 'opportunity' columns in the pointset.
For example, you might have the number of jobs available at each location, or
the number of hospital beds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otp_evaluate_surface(otpcon, surfaceId, pointset, detail = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otp_evaluate_surface_+3A_otpcon">otpcon</code></td>
<td>
<p>An OTP connection object produced by <code><a href="#topic+otp_connect">otp_connect</a></code>.</p>
</td></tr>
<tr><td><code id="otp_evaluate_surface_+3A_surfaceid">surfaceId</code></td>
<td>
<p>Integer, the id number of an existing surface created using
<code>otp_create_surface()</code>.</p>
</td></tr>
<tr><td><code id="otp_evaluate_surface_+3A_pointset">pointset</code></td>
<td>
<p>Character string, the name of a pointset known to OTP. A pointset
is contained in a CSV file present in the pointset directory location passed to
OTP at startup. The name of the pointset is the name of the file (without extension).</p>
</td></tr>
<tr><td><code id="otp_evaluate_surface_+3A_detail">detail</code></td>
<td>
<p>logical, whether the travel time from the surface origin to each
location in the pointset should be returned. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires OTP to have been started with the <code>--analyst</code> switch and
the <code>--pointset</code> parameter set to the path of a directory containing the pointset file(s).
</p>


<h3>Value</h3>

<p>Assuming no error, returns a list containing 4 or more elements:
</p>

<ul>
<li> <p><code>errorId</code> Will be &quot;OK&quot; if no error condition.
</p>
</li>
<li> <p><code>surfaceId</code> The id of the surface that was evaluated.
</p>
</li>
<li><p> One or more dataframes for each of the 'opportunity' columns in the pointset
CSV file. Each dataframe contains four columns:
</p>

<ul>
<li><p> minutes. The time from the surface origin in one-minute increments.
</p>
</li>
<li><p> counts. The number of the opportunity locations
reached within each minute interval.
</p>
</li>
<li><p> sum. The sum of the opportunities at each of
the locations reached within each minute interval.
</p>
</li>
<li><p> cumsums. A cumulative sum of the opportunities reached.
</p>
</li></ul>

</li>
<li><p> If <code>detail</code> was set to TRUE then an additional dataframe containing
the time taken (in seconds) to reach each point in the pointset CSV file. If a
point was not reachable the time will be recorded as NA.
</p>
</li>
<li> <p><code>query</code> The URL that was submitted to the OTP API.
</p>
</li></ul>

<p>If there is an error, a list containing 3 elements is returned:
</p>

<ul>
<li> <p><code>errorId</code> The id code of the error.
</p>
</li>
<li> <p><code>errorMessage</code> The error message.
</p>
</li>
<li> <p><code>query</code> The URL that was submitted to the OTP API.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
otp_evaluate_surface(otpcon, surfaceId = 0, pointset = "jobs", detail = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='otp_from_epoch'>Convert time from EPOCH format</h2><span id='topic+otp_from_epoch'></span>

<h3>Description</h3>

<p>Convert time from EPOCH format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otp_from_epoch(epoch, tz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otp_from_epoch_+3A_epoch">epoch</code></td>
<td>
<p>time since EPOCH (milliseconds)</p>
</td></tr>
<tr><td><code id="otp_from_epoch_+3A_tz">tz</code></td>
<td>
<p>timezone (string)</p>
</td></tr>
</table>

<hr>
<h2 id='otp_get_distance'>Finds the distance in metres between supplied origin and destination</h2><span id='topic+otp_get_distance'></span>

<h3>Description</h3>

<p>Finds the distance in metres between supplied origin and destination. Only makes
sense for walk, cycle or car modes (not transit)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otp_get_distance(otpcon, fromPlace, toPlace, mode = "CAR")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otp_get_distance_+3A_otpcon">otpcon</code></td>
<td>
<p>An OTP connection object produced by <code><a href="#topic+otp_connect">otp_connect</a></code>.</p>
</td></tr>
<tr><td><code id="otp_get_distance_+3A_fromplace">fromPlace</code></td>
<td>
<p>Numeric vector, Latitude/Longitude pair, e.g. 'c(53.48805, -2.24258)'</p>
</td></tr>
<tr><td><code id="otp_get_distance_+3A_toplace">toPlace</code></td>
<td>
<p>Numeric vector, Latitude/Longitude pair, e.g. 'c(53.36484, -2.27108)'</p>
</td></tr>
<tr><td><code id="otp_get_distance_+3A_mode">mode</code></td>
<td>
<p>Character vector, single mode of travel. Valid values are WALK, BICYCLE, or CAR. Default is CAR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If OTP has not returned an error then a list containing <code>errorId</code>
with the value &quot;OK&quot;, and the <code>distance</code> in metres. If OTP has returned an
error then a list containing <code>errorId</code> with the OTP error code and <code>errorMessage</code>
with the error message returned by OTP. In both cases there will be a third element
named <code>query</code> which is a character string containing the URL that was submitted to the OTP API.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
otp_get_distance(otpcon, fromPlace = c(53.48805, -2.24258), toPlace = c(53.36484, -2.27108))

otp_get_distance(otpcon, fromPlace = c(53.48805, -2.24258), toPlace = c(53.36484, -2.27108),
mode = "WALK")

## End(Not run)
</code></pre>

<hr>
<h2 id='otp_get_isochrone'>Returns one or more travel time isochrones (OTPv1 only)</h2><span id='topic+otp_get_isochrone'></span>

<h3>Description</h3>

<p>Returns one or more travel time isochrones in either GeoJSON format or as an
<strong>sf</strong> object. Only works correctly for walk and/or transit modes - a limitation
of OTP. Isochrones can be generated either <em>from</em> a location or <em>to</em>
a location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otp_get_isochrone(
  otpcon,
  location,
  fromLocation = TRUE,
  format = "JSON",
  mode = "TRANSIT",
  date = format(Sys.Date(), "%m-%d-%Y"),
  time = format(Sys.time(), "%H:%M:%S"),
  cutoffs,
  batch = TRUE,
  arriveBy = FALSE,
  maxWalkDistance = NULL,
  walkReluctance = 2,
  waitReluctance = 1,
  transferPenalty = 0,
  minTransferTime = 0,
  extra.params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otp_get_isochrone_+3A_otpcon">otpcon</code></td>
<td>
<p>An OTP connection object produced by <code><a href="#topic+otp_connect">otp_connect</a></code>.</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_location">location</code></td>
<td>
<p>Numeric vector, Latitude/Longitude pair, e.g. 'c(53.48805, -2.24258)'</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_fromlocation">fromLocation</code></td>
<td>
<p>Logical. If TRUE (default) the isochrone
will be generated <em>from</em> the <code>location</code>. If FALSE the isochrone will
be generated <em>to</em> the <code>location</code>.</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_format">format</code></td>
<td>
<p>Character, required format of returned isochrone(s). Either JSON
(returns GeoJSON) or SF (returns simple feature collection). Default is JSON.</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_mode">mode</code></td>
<td>
<p>Character vector, mode(s) of travel. Valid values are: WALK,
TRANSIT, BUS, RAIL, TRAM, SUBWAY. TRANSIT will use all available transit modes.
Default is TRANSIT. WALK mode is automatically added to
TRANSIT, BUS, RAIL, TRAM, and SUBWAY. Due to an OTP limitation this
function is <em>not</em> suitable for CAR or BICYCLE modes.</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_date">date</code></td>
<td>
<p>Character, must be in the format mm-dd-yyyy. This is the desired date of travel.
Only relevant for transit modes. Default is the current system date.</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_time">time</code></td>
<td>
<p>Character, must be in the format hh:mm:ss.
If <code>arriveBy</code> is FALSE (the default) this is the desired departure time, otherwise the
desired arrival time. Only relevant for transit modes. Default is the current system time.</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_cutoffs">cutoffs</code></td>
<td>
<p>Numeric vector, containing the cutoff times in seconds. for
example: 'c(900, 1800, 2700)' would request 15, 30 and 60 minute isochrones.
Can be a single value.</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_batch">batch</code></td>
<td>
<p>Logical. If true, goal direction is turned off and a full path tree is built</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_arriveby">arriveBy</code></td>
<td>
<p>Logical. Whether a trip should depart (FALSE) or arrive (TRUE) at the specified
date and time. Default is FALSE.</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_maxwalkdistance">maxWalkDistance</code></td>
<td>
<p>Numeric. The maximum distance (in meters) that the user is
willing to walk. Default is NULL (the parameter is not passed to the API and the OTP
default of unlimited takes effect).
This is a soft limit in OTPv1 and is ignored if the mode is WALK only. In OTPv2
this parameter imposes a hard limit on WALK, CAR and BICYCLE modes (see:
<a href="http://docs.opentripplanner.org/en/latest/OTP2-MigrationGuide/#router-config">http://docs.opentripplanner.org/en/latest/OTP2-MigrationGuide/#router-config</a>).</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_walkreluctance">walkReluctance</code></td>
<td>
<p>A single numeric value. A multiplier for how bad walking is
compared to being in transit for equal lengths of time. Default = 2.</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_waitreluctance">waitReluctance</code></td>
<td>
<p>A single numeric value. A multiplier for how bad waiting for a
transit vehicle is compared to being on a transit vehicle. This should be greater
than 1 and less than <code>walkReluctance</code> (see API docs). Default = 1.</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_transferpenalty">transferPenalty</code></td>
<td>
<p>Integer. An additional penalty added to boardings after
the first. The value is in OTP's internal weight units, which are roughly equivalent to seconds.
Set this to a high value to discourage transfers. Default is 0.</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_mintransfertime">minTransferTime</code></td>
<td>
<p>Integer. The minimum time, in seconds, between successive
trips on different vehicles. This is designed to allow for imperfect schedule
adherence. This is a minimum; transfers over longer distances might use a longer time.
Default is 0.</p>
</td></tr>
<tr><td><code id="otp_get_isochrone_+3A_extra.params">extra.params</code></td>
<td>
<p>A list of any other parameters accepted by the OTP API LIsochrone entry point. For
advanced users. Be aware that otpr will carry out no validation of these additional
parameters. They will be passed directly to the API. Do not pass 'fromPlace' or 'toPlace'
to this function. These parameters are handled internally based on the values of <code>location</code>
and <code>fromLocation</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list. First element in the list is <code>errorId</code>. This is &quot;OK&quot; if
OTP successfully returned the isochrone(s), otherwise it is &quot;ERROR&quot;. The second
element of list varies:
</p>

<ul>
<li><p> If <code>errorId</code> is &quot;ERROR&quot; then <code>response</code> contains the OTP error message.
</p>
</li>
<li><p> If <code>errorId</code> is &quot;OK&quot; then <code>response</code> contains the the isochrone(s) in
either GeoJSON format or as an <strong>sf</strong> object, depending on the value of the
<code>format</code> argument.
</p>
</li></ul>

<p>The third element of the list is <code>query</code> which is a character string containing the URL
that was submitted to the OTP API.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
otp_get_isochrone(otpcon, location = c(53.48805, -2.24258), cutoffs = c(900, 1800, 2700))

otp_get_isochrone(otpcon, location = c(53.48805, -2.24258), fromLocation = FALSE,
cutoffs = c(900, 1800, 2700), mode = "BUS")

## End(Not run)
</code></pre>

<hr>
<h2 id='otp_get_times'>Queries OTP for the time or detailed itinerary for a trip between an origin
and destination</h2><span id='topic+otp_get_times'></span>

<h3>Description</h3>

<p>In its simplest use case the function returns the time in minutes between an origin
and destination by the specified mode(s) for the top itinerary returned by OTP. If
<code>detail</code> is set to TRUE one or more detailed trip itineraries are returned,
including the time by each mode (if a multimodal trip), waiting time and the
number of transfers. Optionally, the details of each journey leg for each itinerary
can also be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otp_get_times(
  otpcon,
  fromPlace,
  toPlace,
  mode = "CAR",
  date = format(Sys.Date(), "%m-%d-%Y"),
  time = format(Sys.time(), "%H:%M:%S"),
  maxWalkDistance = NULL,
  walkReluctance = 2,
  waitReluctance = 1,
  arriveBy = FALSE,
  transferPenalty = 0,
  minTransferTime = 0,
  maxItineraries = 1,
  detail = FALSE,
  includeLegs = FALSE,
  extra.params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otp_get_times_+3A_otpcon">otpcon</code></td>
<td>
<p>An OTP connection object produced by <code><a href="#topic+otp_connect">otp_connect</a></code>.</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_fromplace">fromPlace</code></td>
<td>
<p>Numeric vector, Latitude/Longitude pair, e.g. 'c(53.48805, -2.24258)'</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_toplace">toPlace</code></td>
<td>
<p>Numeric vector, Latitude/Longitude pair, e.g. 'c(53.36484, -2.27108)'</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_mode">mode</code></td>
<td>
<p>Character vector, mode(s) of travel. Valid values are: WALK, BICYCLE,
CAR, TRANSIT, BUS, RAIL, TRAM, SUBWAY OR 'c(&quot;TRANSIT&quot;, &quot;BICYCLE&quot;)'. TRANSIT will use all
available transit modes. Default is CAR. WALK mode is automatically
added for TRANSIT, BUS, RAIL, TRAM, and SUBWAY.</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_date">date</code></td>
<td>
<p>Character, must be in the format mm-dd-yyyy. This is the desired date of travel.
Only relevant for transit modes. Default is the current system date.</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_time">time</code></td>
<td>
<p>Character, must be in the format hh:mm:ss.
If <code>arriveBy</code> is FALSE (the default) this is the desired departure time, otherwise the
desired arrival time. Only relevant for transit modes. Default is the current system time.</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_maxwalkdistance">maxWalkDistance</code></td>
<td>
<p>Numeric. The maximum distance (in meters) that the user is
willing to walk. Default is NULL (the parameter is not passed to the API and the OTP
default of unlimited takes effect).
This is a soft limit in OTPv1 and is ignored if the mode is WALK only. In OTPv2
this parameter imposes a hard limit on WALK, CAR and BICYCLE modes (see:
<a href="http://docs.opentripplanner.org/en/latest/OTP2-MigrationGuide/#router-config">http://docs.opentripplanner.org/en/latest/OTP2-MigrationGuide/#router-config</a>).</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_walkreluctance">walkReluctance</code></td>
<td>
<p>A single numeric value. A multiplier for how bad walking is
compared to being in transit for equal lengths of time. Default = 2.</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_waitreluctance">waitReluctance</code></td>
<td>
<p>A single numeric value. A multiplier for how bad waiting for a
transit vehicle is compared to being on a transit vehicle. This should be greater
than 1 and less than <code>walkReluctance</code> (see API docs). Default = 1.</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_arriveby">arriveBy</code></td>
<td>
<p>Logical. Whether a trip should depart (FALSE) or arrive (TRUE) at the specified
date and time. Default is FALSE.</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_transferpenalty">transferPenalty</code></td>
<td>
<p>Integer. An additional penalty added to boardings after
the first. The value is in OTP's internal weight units, which are roughly equivalent to seconds.
Set this to a high value to discourage transfers. Default is 0.</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_mintransfertime">minTransferTime</code></td>
<td>
<p>Integer. The minimum time, in seconds, between successive
trips on different vehicles. This is designed to allow for imperfect schedule
adherence. This is a minimum; transfers over longer distances might use a longer time.
Default is 0.</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_maxitineraries">maxItineraries</code></td>
<td>
<p>Integer. Controls the number of trip itineraries that
are returned when <code>detail</code> is set to TRUE. This is not an OTP parameter.
All suggested itineraries are allowed to be returned by the OTP server. The function
will return them to the user in the order they were provided by OTP up to the maximum
specified by this parameter. Default is 1. This is an alternative to using the
OTP <code>maxNumItineraries</code> parameter which has problematic behaviour.</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_detail">detail</code></td>
<td>
<p>Logical. When set to FALSE a single trip time is returned.
When set to TRUE one or more detailed trip itineraries are returned (dependent on <code>maxItineraries</code>).
Default is FALSE.</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_includelegs">includeLegs</code></td>
<td>
<p>Logical. Determines whether or not details of each
journey leg are returned. If TRUE then a nested dataframe of journeys legs will be returned
for each itinerary if <code>detail</code> is also TRUE. Default is FALSE.</p>
</td></tr>
<tr><td><code id="otp_get_times_+3A_extra.params">extra.params</code></td>
<td>
<p>A list of any other parameters accepted by the OTP API PlannerResource entry point. For
advanced users. Be aware that otpr will carry out no validation of these additional
parameters. They will be passed directly to the API.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you plan to use the function in simple-mode - where just the duration of the top itinerary is returned -
it is advisable to first review several detailed itineraries to ensure that the parameters
you have set are producing sensible results.
</p>
<p>If requested using <code>includeLegs</code>, the itineraries dataframe will contain a column called 'legs'
which has a nested legs dataframe for each itinerary. Each legs dataframe will contain
a set of core columns that are consistent across all queries. However, as the OTP
API does not consistently return the same attributes for legs, there will be some variation
in columns returned. You should bare this in mind if your post processing
uses these columns (e.g. by checking for column existence).
</p>


<h3>Value</h3>

<p>Returns a list of three or four elements. The first element in the list is <code>errorId</code>.
This is &quot;OK&quot; if OTP has not returned an error. Otherwise it is the OTP error code. The second element of list
varies:
</p>

<ul>
<li><p> If OTP has returned an error then <code>errorMessage</code> contains the OTP error message.
</p>
</li>
<li><p> If there is no error and <code>detail</code> is FALSE then the <code>duration</code> in minutes is
returned as an integer. This is the duration of the top itinerary returned by the OTP server.
</p>
</li>
<li><p> If there is no error and <code>detail</code> is TRUE then <code>itineraries</code> as a dataframe.
</p>
</li></ul>

<p>The third element of the list is <code>query</code>. This is a character string containing the URL
that was submitted to the OTP API.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
otp_get_times(otpcon, fromPlace = c(53.48805, -2.24258), toPlace = c(53.36484, -2.27108))

otp_get_times(otpcon, fromPlace = c(53.48805, -2.24258), toPlace = c(53.36484, -2.27108),
mode = "BUS", date = "03-26-2019", time = "08:00:00")

otp_get_times(otpcon, fromPlace = c(53.48805, -2.24258), toPlace = c(53.36484, -2.27108),
mode = "BUS", date = "03-26-2019", time = "08:00:00", detail = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='otp_is_date'>Checks the date format</h2><span id='topic+otp_is_date'></span>

<h3>Description</h3>

<p>Checks the date format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otp_is_date(date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otp_is_date_+3A_date">date</code></td>
<td>
<p>the supplied date.</p>
</td></tr>
</table>

<hr>
<h2 id='otp_is_time'>Checks the time format</h2><span id='topic+otp_is_time'></span>

<h3>Description</h3>

<p>Checks the time format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otp_is_time(time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otp_is_time_+3A_time">time</code></td>
<td>
<p>the supplied time.</p>
</td></tr>
</table>

<hr>
<h2 id='otp_vector_match'>Checks if two vectors are the same but where order doesn't matter</h2><span id='topic+otp_vector_match'></span>

<h3>Description</h3>

<p>Checks if two vectors are the same but where order doesn't matter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otp_vector_match(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otp_vector_match_+3A_a">a</code></td>
<td>
<p>vector, to be matched</p>
</td></tr>
<tr><td><code id="otp_vector_match_+3A_b">b</code></td>
<td>
<p>vector, to be matched</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
