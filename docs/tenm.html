<!DOCTYPE html><html lang="en"><head><title>Help for package tenm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tenm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abronia'><p>Occurrence records of Abronia graminea</p></a></li>
<li><a href='#bg_by_date'><p>Function to obtain environmental background organized by date</p></a></li>
<li><a href='#cells2samp'><p>Helper function to randomly select cell IDs for generating</p>
environmental background data.</a></li>
<li><a href='#clean_dup'><p>Function to thin longitude and latitude data</p></a></li>
<li><a href='#clean_dup_by_date'><p>Function to thin occurrence data</p>
Cleans up duplicated longitude and latitude data by year using a specified
distance threshold. The distance can be specified as a geographic distance
or, if a raster_mask is provided, as a pixel distance.</a></li>
<li><a href='#colors'><p>Colors for plotting</p></a></li>
<li><a href='#correlation_finder'><p>Function to find strong correlations within environmental predictors</p></a></li>
<li><a href='#cov_center'><p>Function to compute the covariance matrix of an ellipsoid niche model.</p></a></li>
<li><a href='#ellipsoid_omr'><p>Compute omission rate and statistical metrics for ellipsoid models.</p></a></li>
<li><a href='#ellipsoid_projection'><p>ellipsoid_projection: function to project an ellipsoid model</p></a></li>
<li><a href='#ellipsoid_selection'><p>ellipsoid_selection: Performs models selection for ellipsoid models</p></a></li>
<li><a href='#ex_by_date'><p>Extract environmental data by date</p></a></li>
<li><a href='#inEllipsoid'><p>inEllipsoid: Determine if a point is inside or outside an ellipsoid</p></a></li>
<li><a href='#metaras'><p>Helper function to obtain layer name from a raster layer</p></a></li>
<li><a href='#plot_ellipsoid'><p>Function to plot ellipsoid models in E-space</p></a></li>
<li><a href='#predict+2Csp.temporal.selection-method'><p>Predict the potential distribution of species based on environmental</p>
conditions</a></li>
<li><a href='#pROC'><p>Partial ROC calculation for Niche Models</p></a></li>
<li><a href='#sp_temporal_data'><p>Function to create a Species Temporal Data object (STD object).</p></a></li>
<li><a href='#sp.temporal.bg-class'><p>S3 classes to organize data and results of <code>tenm</code> objects</p></a></li>
<li><a href='#sp.temporal.env-class'><p>S3 classes to organize data and results of <code>tenm</code> objects</p></a></li>
<li><a href='#sp.temporal.modeling-class'><p>S3 classes to organize data and results of <code>tenm</code> objects</p></a></li>
<li><a href='#sp.temporal.selection-class'><p>S3 classes to organize data and results of <code>tenm</code> objects</p></a></li>
<li><a href='#tdf2swd'><p>Temporal data.frame to Samples With Data format</p></a></li>
<li><a href='#tenm_selection'><p>Function to find the best n-dimensional ellipsoid model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Temporal Ecological Niche Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements methods and functions to calibrate 
  time-specific niche models (multi-temporal calibration), letting users 
  execute a strict calibration and selection process of niche models based 
  on ellipsoids, as well as functions to project the potential distribution in 
  the present and in global change  scenarios.The 'tenm' package has functions
  to recover information that may be lost or overlooked while applying a data 
  curation protocol. This curation involves preserving occurrences that may 
  appear spatially redundant (occurring in the same pixel) but originate from 
  different time periods. A novel aspect of this package is that it might 
  reconstruct the fundamental niche more accurately than mono-calibrated 
  approaches. The theoretical background of the package can be found in 
  Peterson et al. (2011)&lt;<a href="https://doi.org/10.5860%2FCHOICE.49-6266">doi:10.5860/CHOICE.49-6266</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://luismurao.github.io/tenm/">https://luismurao.github.io/tenm/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/luismurao/tenm/issues">https://github.com/luismurao/tenm/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, terra (&gt; 1.7.5), sf, purrr, dplyr, stringr, rgl (&gt; 1.2),
future, tidyr, furrr, lubridate, methods</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-21 15:50:20 UTC; luis.osorio</td>
</tr>
<tr>
<td>Author:</td>
<td>Luis Osorio-Olvera
    <a href="https://orcid.org/0000-0003-0701-5398"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Miguel Hernández <a href="https://orcid.org/0000-0002-6086-3460"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Rusby G. Contreras-Díaz
    <a href="https://orcid.org/0000-0002-0569-8984"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Xavier Chiappa-Carrara
    <a href="https://orcid.org/0000-0002-1708-2095"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Fernanda Rosales-Ramos
    <a href="https://orcid.org/0009-0004-7805-4735"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Mariana Munguía-Carrara
    <a href="https://orcid.org/0000-0003-3514-3397"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Oliver López-Corona
    <a href="https://orcid.org/0000-0002-2926-7791"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Townsend Peterson <a href="https://orcid.org/0000-0003-0243-2379"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Jorge Soberón <a href="https://orcid.org/0000-0003-2160-4148"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luis Osorio-Olvera &lt;luismurao@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-23 00:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='abronia'>Occurrence records of Abronia graminea</h2><span id='topic+abronia'></span>

<h3>Description</h3>

<p>A dataset containing occurrence records for Abronia graminea.
The data was downloaded from GBIF (GBIF, 2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abronia
</code></pre>


<h3>Format</h3>

<p>A data frame with 106 rows and 5 variables:
</p>

<dl>
<dt>species</dt><dd><p>Scientific name of the species</p>
</dd>
<dt>decimalLongitude</dt><dd><p>Longitude</p>
</dd>
<dt>decimalLatitude</dt><dd><p>Latitude</p>
</dd>
<dt>year</dt><dd><p>Observation year</p>
</dd>
<dt>gbif_doi</dt><dd><p>DOI id for citing the dataset</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>GBIF.org (22 February 2022) GBIF Occurrence
Download <a href="https://doi.org/10.15468/dl.teyjm9">doi:10.15468/dl.teyjm9</a>
</p>

<hr>
<h2 id='bg_by_date'>Function to obtain environmental background organized by date</h2><span id='topic+bg_by_date'></span>

<h3>Description</h3>

<p>Function to retrieve background data from occurrence records.
The background data is organized as a function of the dated
environmental data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bg_by_date(
  this_species,
  buffer_ngbs = NULL,
  buffer_distance = 1000,
  n_bg = 50000,
  process_ngbs_by = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bg_by_date_+3A_this_species">this_species</code></td>
<td>
<p>An object of class sp.temporal.env representing species
occurrence data organized by date. See <code><a href="#topic+ex_by_date">ex_by_date</a></code>.</p>
</td></tr>
<tr><td><code id="bg_by_date_+3A_buffer_ngbs">buffer_ngbs</code></td>
<td>
<p>Number of pixel neighbors used to build the buffer around
each occurrence point.</p>
</td></tr>
<tr><td><code id="bg_by_date_+3A_buffer_distance">buffer_distance</code></td>
<td>
<p>Distance (in the same units as raster layers) used to
create a buffer around occurrence points to sample background data.</p>
</td></tr>
<tr><td><code id="bg_by_date_+3A_n_bg">n_bg</code></td>
<td>
<p>Number of background points to sample.</p>
</td></tr>
<tr><td><code id="bg_by_date_+3A_process_ngbs_by">process_ngbs_by</code></td>
<td>
<p>Numeric parameter to improve memory management.
It process neighbor cells by a quantity specified by the user.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function retrieves background data around species occurrence points,
sampled based on the dated environmental data provided in <code>this_species</code>.
Background points are sampled within a buffer around each occurrence point.
The function returns an object of class sp.temporal.bg, which contains
background data organized by date. This object is the input of the function
<code><a href="#topic+tenm_selection">tenm_selection</a></code>.
</p>


<h3>Value</h3>

<p>An object of class sp.temporal.bg containing background data
organized by date. The object is a list with the following components:
</p>

<ul>
<li><p> &quot;bg_df&quot;: A data.frame with columns for longitude, latitude, year,
layer_date, layer_path, cell_ids_year, and environmental information.
</p>
</li>
<li><p> Other metadata relevant to background sampling.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(tenm)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
abtc &lt;- tenm::clean_dup_by_date(abt,threshold = 10/60)
#This code is for running in parallel
future::plan("multisession",workers=2)
abex &lt;- tenm::ex_by_date(this_species = abtc,train_prop=0.7)
abbg &lt;- tenm::bg_by_date(this_species = abex,
                         buffer_ngbs=10,n_bg=50000)
future::plan("sequential")

</code></pre>

<hr>
<h2 id='cells2samp'>Helper function to randomly select cell IDs for generating
environmental background data.</h2><span id='topic+cells2samp'></span>

<h3>Description</h3>

<p>This function returns pixel IDs to be sampled for generating environmental
background data around species occurrence points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cells2samp(
  data,
  longitude,
  latitude,
  cell_ids = NULL,
  buffer_ngbs = 2,
  raster_mask,
  process_ngbs_by = 10,
  n_bg = 50000,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cells2samp_+3A_data">data</code></td>
<td>
<p>A data.frame containing longitude and latitude data of occurrence
points.</p>
</td></tr>
<tr><td><code id="cells2samp_+3A_longitude">longitude</code></td>
<td>
<p>A character vector specifying the column name of longitude
in 'data'.</p>
</td></tr>
<tr><td><code id="cells2samp_+3A_latitude">latitude</code></td>
<td>
<p>A character vector specifying the column name of latitude
in 'data'.</p>
</td></tr>
<tr><td><code id="cells2samp_+3A_cell_ids">cell_ids</code></td>
<td>
<p>A numeric vector indicating the IDs of cells that serve as
geographic centers for buffers. Default is NULL.</p>
</td></tr>
<tr><td><code id="cells2samp_+3A_buffer_ngbs">buffer_ngbs</code></td>
<td>
<p>Number of neighboring pixels around occurrence points
used to build the buffer for sampling.</p>
</td></tr>
<tr><td><code id="cells2samp_+3A_raster_mask">raster_mask</code></td>
<td>
<p>An object of class SpatRaster used to obtain pixel IDs.</p>
</td></tr>
<tr><td><code id="cells2samp_+3A_process_ngbs_by">process_ngbs_by</code></td>
<td>
<p>Numeric parameter to improve memory management.
It process neighbor cells by a quantity specified by the user.</p>
</td></tr>
<tr><td><code id="cells2samp_+3A_n_bg">n_bg</code></td>
<td>
<p>Number of background pixels to sample.</p>
</td></tr>
<tr><td><code id="cells2samp_+3A_progress">progress</code></td>
<td>
<p>Logical. If <code>TRUE</code>, show computation progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of cell IDs to be sampled for environmental
background data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# cells to sample
data(abronia)
temporal_layer &lt;- system.file("extdata/bio/2016/bio_01.tif",package = "tenm")
raster_mask &lt;- terra::rast(temporal_layer)
set.seed(123)
samp_01 &lt;- tenm::cells2samp(data = abronia,
                            longitude = "decimalLongitude",
                            latitude = "decimalLatitude",
                            cell_ids = NULL,
                            buffer_ngbs = 4,
                            raster_mask = raster_mask,
                            process_ngbs_by = 10,
                            n_bg = 50000,
                            progress =TRUE)
# Generete a sample using pixel IDs
samp_02 &lt;- tenm::cells2samp(data = abronia,
                            longitude = NULL,
                            latitude = NULL,
                            cell_ids = c(256,290,326),
                            buffer_ngbs = 4,
                            raster_mask = raster_mask,
                            process_ngbs_by = 10,
                            n_bg = 50000,
                            progress =TRUE)


</code></pre>

<hr>
<h2 id='clean_dup'>Function to thin longitude and latitude data</h2><span id='topic+clean_dup'></span>

<h3>Description</h3>

<p>Cleans up duplicated or redundant occurrence records that present overlapping
longitude and latitude coordinates. Thinning can be performed using either a
geographical distance threshold or a pixel neighborhood approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_dup(
  data,
  longitude,
  latitude,
  threshold = 0,
  by_mask = FALSE,
  raster_mask = NULL,
  n_ngbs = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_dup_+3A_data">data</code></td>
<td>
<p>A data.frame with longitude and latitude of occurrence records.</p>
</td></tr>
<tr><td><code id="clean_dup_+3A_longitude">longitude</code></td>
<td>
<p>A character vector indicating the column name of the
&quot;longitude&quot; variable.</p>
</td></tr>
<tr><td><code id="clean_dup_+3A_latitude">latitude</code></td>
<td>
<p>A character vector indicating the column name of the
&quot;latitude&quot; variable.</p>
</td></tr>
<tr><td><code id="clean_dup_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value representing the distance threshold between
coordinates to be considered duplicates. Units depend on whether
<code>by_mask</code> is <code>T</code> or <code>F</code>. If <code>T</code>, the user needs to specify the number
of pixels that define the neighborhood of duplicates (see n_ngbs parameter).</p>
</td></tr>
<tr><td><code id="clean_dup_+3A_by_mask">by_mask</code></td>
<td>
<p>Logical. If <code>T</code>, the thinning process will use a raster layer
as a mask for defining distance in pixel units.</p>
</td></tr>
<tr><td><code id="clean_dup_+3A_raster_mask">raster_mask</code></td>
<td>
<p>An object of class SpatRaster that serves as a reference
to thin the occurrence data. Required if <code>by_mask</code> is <code>T</code>.</p>
</td></tr>
<tr><td><code id="clean_dup_+3A_n_ngbs">n_ngbs</code></td>
<td>
<p>Number of pixels used to define the neighborhood matrix that
helps determine which occurrences are duplicates:
</p>

<ul>
<li><p> 0 removes occurrences within the same pixel, keeping one.
</p>
</li>
<li><p> 1 considers duplicates all occurrences within a distance of one pixel.
</p>
</li>
<li><p> n considers duplicates all occurrences within a distance of n pixels.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function cleans up duplicated occurrences based on the specified
distance threshold. If <code>by_mask</code> is <code>T</code>, the distance is interpreted as
pixel distance using the provided raster_mask; otherwise, it is interpreted
as geographic distance.
</p>


<h3>Value</h3>

<p>Returns a data.frame with cleaned occurrence records, excluding
duplicates based on the specified criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abronia)
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
tenm_mask &lt;- terra::rast(file.path(tempora_layers_dir,"1939/bio_01.tif"))
# Clean duplicates without raster mask (just by distance threshold)
# First check the number of occurrence records
print(nrow(abronia))
# Clean duplicated records using a distance of ~ 18 km (0.1666667 grades)
ab_1 &lt;- tenm::clean_dup(data =abronia,
                        longitude = "decimalLongitude",
                        latitude = "decimalLatitude",
                        threshold = terra::res(tenm_mask),
                        by_mask = FALSE,
                        raster_mask = NULL)
# Check number of records
print(nrow(ab_1))
# Clean duplicates using a raster mask
ab_2 &lt;- tenm::clean_dup(data =abronia,
                        longitude = "decimalLongitude",
                        latitude = "decimalLatitude",
                        threshold = terra::res(tenm_mask)[1],
                        by_mask = TRUE,
                        raster_mask = tenm_mask,
                        n_ngbs = 1)
# Check number of records
print(nrow(ab_2))
</code></pre>

<hr>
<h2 id='clean_dup_by_date'>Function to thin occurrence data
Cleans up duplicated longitude and latitude data by year using a specified
distance threshold. The distance can be specified as a geographic distance
or, if a raster_mask is provided, as a pixel distance.</h2><span id='topic+clean_dup_by_date'></span>

<h3>Description</h3>

<p>Function to thin occurrence data
Cleans up duplicated longitude and latitude data by year using a specified
distance threshold. The distance can be specified as a geographic distance
or, if a raster_mask is provided, as a pixel distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_dup_by_date(
  this_species,
  threshold,
  by_mask = FALSE,
  raster_mask = NULL,
  n_ngbs = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_dup_by_date_+3A_this_species">this_species</code></td>
<td>
<p>An object of class sp.temporal.modeling representing
species occurrence data organized by date.
See <code><a href="#topic+sp_temporal_data">sp_temporal_data</a></code>.</p>
</td></tr>
<tr><td><code id="clean_dup_by_date_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value representing the distance threshold between
coordinates to be considered duplicates. Units depend on whether
<code>by_mask</code> is <code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, the user needs
to specify the number of pixels that define the neighborhood of duplicates
(see n_ngbs parameter).</p>
</td></tr>
<tr><td><code id="clean_dup_by_date_+3A_by_mask">by_mask</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the thinning process will use a
raster layer as a mask for defining distance in pixel units.</p>
</td></tr>
<tr><td><code id="clean_dup_by_date_+3A_raster_mask">raster_mask</code></td>
<td>
<p>An object of class SpatRaster that serves as a reference
to thin the occurrence data. Required if <code>by_mask</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="clean_dup_by_date_+3A_n_ngbs">n_ngbs</code></td>
<td>
<p>Number of pixels used to define the neighborhood matrix that
helps determine which occurrences are duplicates:
</p>

<ul>
<li><p> 0 removes occurrences within the same pixel, keeping one.
</p>
</li>
<li><p> 1 considers duplicates all occurrences within a distance of one pixel.
</p>
</li>
<li><p> n considers duplicates all occurrences within a distance of n pixels.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on <code><a href="#topic+clean_dup">clean_dup</a></code>. It cleans up
duplicated occurrences based on the specified threshold. If <code>by_mask</code>
is <code>TRUE</code>, the distance is interpreted as pixel distance using the provided
raster_mask; otherwise, it is interpreted as geographic distance.
</p>


<h3>Value</h3>

<p>An object of class sp.temporal.modeling containing a temporal
data.frame with cleaned occurrence data, including columns for
longitude, latitude, date variable, layers_dates, and layers_path.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tenm)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
tenm_mask &lt;- terra::rast(file.path(tempora_layers_dir,"1939/bio_01.tif"))
# Clean duplicates without raster mask (just by distance threshold)
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
abtc1 &lt;- tenm::clean_dup_by_date(abt,threshold = terra::res(tenm_mask)[1])
# Check number of records
print(nrow(abtc1$temporal_df))
# Clean duplicates using a raster mask
abtc2 &lt;- tenm::clean_dup_by_date(this_species = abt,
                                by_mask = TRUE,
                                threshold = terra::res(tenm_mask)[1],
                                raster_mask = tenm_mask,
                                n_ngbs = 0)
# Check number of records
print(nrow(abtc2$temporal_df))

abtc3 &lt;- tenm::clean_dup_by_date(this_species = abt,
                                by_mask = TRUE,
                                threshold = terra::res(tenm_mask)[1],
                                raster_mask = tenm_mask,
                                n_ngbs = 2)
# Check number of records
print(nrow(abtc3$temporal_df))
</code></pre>

<hr>
<h2 id='colors'>Colors for plotting</h2><span id='topic+colors'></span>

<h3>Description</h3>

<p>A string vector of colors for plotting the vignette example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colors
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 40.
</p>

<hr>
<h2 id='correlation_finder'>Function to find strong correlations within environmental predictors</h2><span id='topic+correlation_finder'></span>

<h3>Description</h3>

<p>This function identifies variables with strong correlations based on a
specified threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation_finder(
  environmental_data,
  method = "spearman",
  threshold,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correlation_finder_+3A_environmental_data">environmental_data</code></td>
<td>
<p>A matrix or data.frame containing
environmental data.</p>
</td></tr>
<tr><td><code id="correlation_finder_+3A_method">method</code></td>
<td>
<p>Method used to estimate the correlation matrix. Possible
options include &quot;spearman&quot; (Spearman's rank correlation),
&quot;pearson&quot; (Pearson's correlation),
or &quot;kendall&quot; (Kendall's tau correlation).</p>
</td></tr>
<tr><td><code id="correlation_finder_+3A_threshold">threshold</code></td>
<td>
<p>Correlation threshold value. Variables with absolute
correlation values greater than or equal to this threshold are considered
strongly correlated.</p>
</td></tr>
<tr><td><code id="correlation_finder_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints verbose output detailing
correlations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>

<ul>
<li> <p><code>not_correlated_vars</code>: A vector containing names of variables that are
not strongly correlated.
</p>
</li>
<li> <p><code>correlation_values</code>: A list with correlation values for all pairs of
variables.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

library(tenm)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
abtc &lt;- tenm::clean_dup_by_date(abt,threshold = 10/60)
future::plan("multisession",workers=2)
abex &lt;- tenm::ex_by_date(abtc,train_prop=0.7)
future::plan("sequential")
envdata &lt;- abex$env_data[,-ncol(abex$env_data)]
ecors &lt;- tenm::correlation_finder(environmental_data =envdata,
                                  method="spearman",
                                  threshold = 0.7 )


</code></pre>

<hr>
<h2 id='cov_center'>Function to compute the covariance matrix of an ellipsoid niche model.</h2><span id='topic+cov_center'></span>

<h3>Description</h3>

<p>Computes the covariance matrix, niche centroid, volume, and other
ellipsoid parameter based on the values of niche variables from
occurrence points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_center(data, mve = TRUE, level, vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_center_+3A_data">data</code></td>
<td>
<p>A data.frame or matrix containing numeric values of variables
used to model the niche.</p>
</td></tr>
<tr><td><code id="cov_center_+3A_mve">mve</code></td>
<td>
<p>Logical. If <code>TRUE</code>, computes a minimum volume ellipsoid using
the <code><a href="MASS.html#topic+cov.mve">cov.mve</a></code> function from the MASS package. If
<code>FALSE</code>, uses the covariance matrix of the input data.</p>
</td></tr>
<tr><td><code id="cov_center_+3A_level">level</code></td>
<td>
<p>Proportion of data to be used for computing the ellipsoid,
applicable when mve is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cov_center_+3A_vars">vars</code></td>
<td>
<p>Vector specifying column indexes or names of variables in
the input data used to fit the ellipsoid model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<ul>
<li> <p><code>centroid</code>: Centroid (mean vector) of the ellipsoid.
</p>
</li>
<li> <p><code>covariance_matrix</code>: Covariance matrix based on the input data.
</p>
</li>
<li> <p><code>volume</code>: Volume of the ellipsoid.
</p>
</li>
<li> <p><code>semi_axes_lengths</code>: Lengths of semi-axes of the ellipsoid.
</p>
</li>
<li> <p><code>axis_coordinates</code>: Coordinates of ellipsoid axes.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(tenm)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
abtc &lt;- tenm::clean_dup_by_date(abt,threshold = 10/60)
future::plan("multisession",workers=2)
abex &lt;- tenm::ex_by_date(abtc,train_prop=0.7)
future::plan("sequential")
mod &lt;- tenm::cov_center(data = abex$env_data,
                        mve = TRUE,
                        level = 0.975,
                        vars = c("bio_05","bio_06","bio_12"))
# Print model parameters
print(mod)

</code></pre>

<hr>
<h2 id='ellipsoid_omr'>Compute omission rate and statistical metrics for ellipsoid models.</h2><span id='topic+ellipsoid_omr'></span>

<h3>Description</h3>

<p>Computes omission rate and statistical metrics for ellipsoid models using
environmental data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipsoid_omr(
  env_data,
  env_test = NULL,
  env_bg,
  cf_level,
  mve = TRUE,
  proc = FALSE,
  proc_iter = 100,
  rseed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipsoid_omr_+3A_env_data">env_data</code></td>
<td>
<p>A data frame containing the environmental data used for
modeling.</p>
</td></tr>
<tr><td><code id="ellipsoid_omr_+3A_env_test">env_test</code></td>
<td>
<p>A data frame with environmental testing data.
Default is NULL. If provided, the selection process includes p-values
from a binomial test.</p>
</td></tr>
<tr><td><code id="ellipsoid_omr_+3A_env_bg">env_bg</code></td>
<td>
<p>Environmental data sampled from the calibration area to compute
the approximated prevalence of the model.</p>
</td></tr>
<tr><td><code id="ellipsoid_omr_+3A_cf_level">cf_level</code></td>
<td>
<p>Proportion of points to be included in the ellipsoids.
Equivalent to the error (E) proposed by Peterson et al. (2008).
<a href="https://doi.org/10.1016/j.ecolmodel.2007.11.008">doi:10.1016/j.ecolmodel.2007.11.008</a>.</p>
</td></tr>
<tr><td><code id="ellipsoid_omr_+3A_mve">mve</code></td>
<td>
<p>Logical. If <code>TRUE</code>, computes a minimum volume ellipsoid using
<code><a href="MASS.html#topic+cov.rob">cov.rob</a></code> from the MASS package. If <code>FALSE</code>,
uses the covariance matrix of the input data.</p>
</td></tr>
<tr><td><code id="ellipsoid_omr_+3A_proc">proc</code></td>
<td>
<p>Logical. If <code>TRUE</code>, performs a partial ROC test.</p>
</td></tr>
<tr><td><code id="ellipsoid_omr_+3A_proc_iter">proc_iter</code></td>
<td>
<p>Numeric. Total number of iterations for the partial ROC
bootstrap.</p>
</td></tr>
<tr><td><code id="ellipsoid_omr_+3A_rseed">rseed</code></td>
<td>
<p>Logical. If <code>TRUE</code>, sets a random seed for the partial
ROC bootstrap. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the following columns:
</p>

<ul>
<li><p> &quot;fitted_vars&quot;: Names of variables that were fitted.
</p>
</li>
<li><p> &quot;nvars&quot;: Number of fitted variables
</p>
</li>
<li><p> &quot;om_rate_train&quot;: Omission rate of the training data.
</p>
</li>
<li><p> &quot;non_pred_train_ids&quot;: Row IDs of non-predicted training data.
</p>
</li>
<li><p> &quot;om_rate_test&quot;': Omission rate of the testing data.
</p>
</li>
<li><p> &quot;non_pred_test_ids&quot;: Row IDs of non-predicted testing data.
</p>
</li>
<li><p> &quot;bg_prevalence&quot;: Approximated prevalence of the model (see details).
</p>
</li>
<li><p> &quot;pval_bin&quot;: p-value of the binomial test.
</p>
</li>
<li><p> &quot;pval_proc&quot;: p-value of the partial ROC test.
</p>
</li>
<li><p> &quot;env_bg_paucratio&quot;: Environmental partial AUC ratio value.
</p>
</li>
<li><p> &quot;env_bg_auc&quot;: Environmental AUC value.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(tenm)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
abtc &lt;- tenm::clean_dup_by_date(abt,threshold = 10/60)
#This code is for running in parallel
future::plan("multisession",workers=2)
abex &lt;- tenm::ex_by_date(this_species = abtc,train_prop=0.7)
abbg &lt;- tenm::bg_by_date(this_species = abex,
                         buffer_ngbs=10,n_bg=50000)
future::plan("sequential")
edata &lt;- abex$env_data
etrain &lt;- edata[edata$trian_test=="Train",c("bio_05","bio_06","bio_12")]
etest &lt;- edata[edata$trian_test=="Test",c("bio_05","bio_06","bio_12")]
bg &lt;- abbg$env_bg[,c("bio_05","bio_06","bio_12")]
eor &lt;- ellipsoid_omr(env_data=etrain,env_test=etest,env_bg=bg,
                     cf_level=0.975,proc=TRUE)
eor

</code></pre>

<hr>
<h2 id='ellipsoid_projection'>ellipsoid_projection: function to project an ellipsoid model</h2><span id='topic+ellipsoid_projection'></span>

<h3>Description</h3>

<p>Function to project an ellipsoid model using the shape matrix
(covariance matrix) of the niche variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipsoid_projection(
  envlayers,
  centroid,
  covar,
  level = 0.95,
  output = "suitability",
  plot = TRUE,
  size,
  xlab1 = "niche var 1",
  ylab1 = "niche var 2",
  zlab1 = "S",
  alpha = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipsoid_projection_+3A_envlayers">envlayers</code></td>
<td>
<p>A SpatRaster object of the niche variables.</p>
</td></tr>
<tr><td><code id="ellipsoid_projection_+3A_centroid">centroid</code></td>
<td>
<p>A vector with the values of the centers of the ellipsoid
(see <code><a href="#topic+cov_center">cov_center</a></code>).</p>
</td></tr>
<tr><td><code id="ellipsoid_projection_+3A_covar">covar</code></td>
<td>
<p>The shape matrix (covariance) of the ellipsoid
(see <code><a href="#topic+cov_center">cov_center</a></code>).</p>
</td></tr>
<tr><td><code id="ellipsoid_projection_+3A_level">level</code></td>
<td>
<p>The proportion of points  to be included inside the ellipsoid</p>
</td></tr>
<tr><td><code id="ellipsoid_projection_+3A_output">output</code></td>
<td>
<p>The output distance: two possible values &quot;suitability&quot; or
&quot;mahalanobis&quot;. By default the function uses &quot;suitability&quot;.</p>
</td></tr>
<tr><td><code id="ellipsoid_projection_+3A_plot">plot</code></td>
<td>
<p>Logical If <code>TRUE</code> a plot of the niche will be shown.</p>
</td></tr>
<tr><td><code id="ellipsoid_projection_+3A_size">size</code></td>
<td>
<p>The size of the points of the niche plot.</p>
</td></tr>
<tr><td><code id="ellipsoid_projection_+3A_xlab1">xlab1</code></td>
<td>
<p>For x label for 2-dimensional histogram</p>
</td></tr>
<tr><td><code id="ellipsoid_projection_+3A_ylab1">ylab1</code></td>
<td>
<p>For y label for 2-dimensional histogram</p>
</td></tr>
<tr><td><code id="ellipsoid_projection_+3A_zlab1">zlab1</code></td>
<td>
<p>For z label for 2-dimensional histogram</p>
</td></tr>
<tr><td><code id="ellipsoid_projection_+3A_alpha">alpha</code></td>
<td>
<p>Control the transparency of the 3-dimensional ellipsoid</p>
</td></tr>
<tr><td><code id="ellipsoid_projection_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="rgl.html#topic+plot3d">plot3d</a></code> function from rgl</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a SpatRaster of suitability values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tenm)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
abtc &lt;- tenm::clean_dup_by_date(abt,threshold = 10/60)
future::plan("multisession",workers=2)
abex &lt;- tenm::ex_by_date(this_species = abtc,train_prop=0.7)
abbg &lt;- tenm::bg_by_date(this_species = abex,
                         buffer_ngbs=10,n_bg=50000)
future::plan("sequential")
mod &lt;- tenm::cov_center(data = abex$env_data,
                        mve = TRUE,
                        level = 0.975,
                        vars = c("bio_05","bio_06","bio_12"))
layers_path &lt;-   list.files(file.path(tempora_layers_dir,
                                      "2016"),
                            pattern = ".tif$",full.names = TRUE)
elayers &lt;- terra::rast(layers_path)
nmod &lt;- ellipsoid_projection(envlayers = elayers[[names(mod$centroid)]],
                             centroid = mod$centroid,
                             covar = mod$covariance,
                             level = 0.99999,
                             output = "suitability",
                             size = 3,
                             plot = TRUE)


</code></pre>

<hr>
<h2 id='ellipsoid_selection'>ellipsoid_selection: Performs models selection for ellipsoid models</h2><span id='topic+ellipsoid_selection'></span>

<h3>Description</h3>

<p>The function performs model selection for ellipsoid models
using three criteria: a) the omission rate, b) the significance of partial
ROC and binomial tests and c) the AUC value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipsoid_selection(
  env_train,
  env_test = NULL,
  env_vars,
  nvarstest,
  level = 0.95,
  mve = TRUE,
  env_bg = NULL,
  omr_criteria,
  parallel = FALSE,
  ncores = NULL,
  comp_each = 100,
  proc = FALSE,
  proc_iter = 100,
  rseed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipsoid_selection_+3A_env_train">env_train</code></td>
<td>
<p>A data frame with the environmental training data.</p>
</td></tr>
<tr><td><code id="ellipsoid_selection_+3A_env_test">env_test</code></td>
<td>
<p>A data frame with the environmental testing data.
Default is NULL.</p>
</td></tr>
<tr><td><code id="ellipsoid_selection_+3A_env_vars">env_vars</code></td>
<td>
<p>A vector with the names of environmental variables used in
the selection process. To help choosing which variables to use see
<code><a href="#topic+correlation_finder">correlation_finder</a></code>.</p>
</td></tr>
<tr><td><code id="ellipsoid_selection_+3A_nvarstest">nvarstest</code></td>
<td>
<p>A vector indicating the number of variables to fit the
ellipsoids during model selection.</p>
</td></tr>
<tr><td><code id="ellipsoid_selection_+3A_level">level</code></td>
<td>
<p>Proportion of points to be included in the ellipsoids,
equivalent to the error (E) proposed by Peterson et al. (2008).</p>
</td></tr>
<tr><td><code id="ellipsoid_selection_+3A_mve">mve</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a minimum volume ellipsoid will be computed.
using <code><a href="MASS.html#topic+cov.rob">cov.rob</a></code> from <span class="pkg">MASS</span>. If <code>FALSE</code>, the covariance
matrix of the input data will be used.</p>
</td></tr>
<tr><td><code id="ellipsoid_selection_+3A_env_bg">env_bg</code></td>
<td>
<p>Environmental data to compute the approximated prevalence
of the model, should be a sample of the environmental layers of
the calibration area.</p>
</td></tr>
<tr><td><code id="ellipsoid_selection_+3A_omr_criteria">omr_criteria</code></td>
<td>
<p>Omission rate criteria: the allowable omission rate for
the selection process. Default is NULL (see details).</p>
</td></tr>
<tr><td><code id="ellipsoid_selection_+3A_parallel">parallel</code></td>
<td>
<p>Logical. If <code>TRUE</code>, computations will run in parallel.
Default is <code>F</code>.</p>
</td></tr>
<tr><td><code id="ellipsoid_selection_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel processing. Default uses
all available cores minus one.</p>
</td></tr>
<tr><td><code id="ellipsoid_selection_+3A_comp_each">comp_each</code></td>
<td>
<p>Number of models to run in each job in parallel computation.
Default is 100.</p>
</td></tr>
<tr><td><code id="ellipsoid_selection_+3A_proc">proc</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a partial ROC test will be run.</p>
</td></tr>
<tr><td><code id="ellipsoid_selection_+3A_proc_iter">proc_iter</code></td>
<td>
<p>Numeric. Total iterations for the partial ROC bootstrap.</p>
</td></tr>
<tr><td><code id="ellipsoid_selection_+3A_rseed">rseed</code></td>
<td>
<p>Logical. If <code>TRUE</code>, set a random seed for partial ROC bootstrap.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model selection occurs in environmental space (E-space). For each variable
combination specified in nvarstest, the omission rate (omr) in E-space is
computed using <code><a href="#topic+inEllipsoid">inEllipsoid</a></code> function.
Results are ordered by omr of the testing data. If env_bg is provided,
an estimated prevalence is computed and results are additionally ordered
by partial AUC. Model selection can be run in parallel.
For more details and examples go to <code><a href="#topic+ellipsoid_omr">ellipsoid_omr</a></code> help.
</p>


<h3>Value</h3>

<p>A data.frame with the following columns:
</p>

<ul>
<li><p> &quot;fitted_vars&quot;: Names of variables that were fitted.
</p>
</li>
<li><p> &quot;nvars&quot;: Number of fitted variables
</p>
</li>
<li><p> &quot;om_rate_train&quot;: Omission rate of the training data.
</p>
</li>
<li><p> &quot;non_pred_train_ids&quot;: Row IDs of non-predicted training data.
</p>
</li>
<li><p> &quot;om_rate_test&quot;': Omission rate of the testing data.
</p>
</li>
<li><p> &quot;non_pred_test_ids&quot;: Row IDs of non-predicted testing data.
</p>
</li>
<li><p> &quot;bg_prevalence&quot;: Approximated prevalence of the model (see details).
</p>
</li>
<li><p> &quot;pval_bin&quot;: p-value of the binomial test.
</p>
</li>
<li><p> &quot;pval_proc&quot;: p-value of the partial ROC test.
</p>
</li>
<li><p> &quot;env_bg_paucratio&quot;: Environmental partial AUC ratio value.
</p>
</li>
<li><p> &quot;env_bg_auc&quot;: Environmental AUC value.
</p>
</li>
<li><p> &quot;mean_omr_train_test&quot;: Mean value of omission rates (train and test).
</p>
</li>
<li><p> &quot;rank_by_omr_train_test&quot;: Rank value of importance in model selection
by omission rate.
</p>
</li>
<li><p> &quot;rank_omr_aucratio&quot;: Rank value by AUC ratio.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Luis Osorio-Olvera <a href="mailto:luismurao@gmail.com">luismurao@gmail.com</a>
</p>


<h3>References</h3>

<p>Peterson, A.T. et al. (2008) Rethinking receiver operating
characteristic analysis applications in ecological niche modeling. Ecol.
Modell. 213, 63–72. <a href="https://doi.org/10.1016/j.ecolmodel.2007.11.008">doi:10.1016/j.ecolmodel.2007.11.008</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tenm)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
abtc &lt;- tenm::clean_dup_by_date(abt,threshold = 10/60)
future::plan("multisession",workers=2)
abex &lt;- tenm::ex_by_date(this_species = abtc,train_prop=0.7)
abbg &lt;- tenm::bg_by_date(this_species = abex,
                         buffer_ngbs=10,n_bg=50000)
future::plan("sequential")
varcorrs &lt;- tenm::correlation_finder(environmental_data =
                                     abex$env_data[,-ncol(abex$env_data)],
                                     method = "spearman",
                                     threshold = 0.8,
                                     verbose = FALSE)
edata &lt;- abex$env_data
etrain &lt;- edata[edata$trian_test=="Train",] |&gt; data.frame()
etest &lt;- edata[edata$trian_test=="Test",] |&gt; data.frame()
bg &lt;- abbg$env_bg
res1 &lt;- tenm::ellipsoid_selection(env_train = etrain,
                                  env_test = etest,
                                  env_vars = varcorrs$descriptors,
                                  nvarstest = 3,
                                  level = 0.975,
                                  mve = TRUE,
                                  env_bg = bg,
                                  omr_criteria = 0.1,
                                  parallel = FALSE,proc = TRUE)
head(res1)


</code></pre>

<hr>
<h2 id='ex_by_date'>Extract environmental data by date</h2><span id='topic+ex_by_date'></span>

<h3>Description</h3>

<p>Function to extract environmental data by date. It generates training and
testing datasets using a random partition with a specified proportion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_by_date(this_species, train_prop = 0.7)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_by_date_+3A_this_species">this_species</code></td>
<td>
<p>Species Temporal Data object. See
<code><a href="#topic+sp_temporal_data">sp_temporal_data</a></code> for details.</p>
</td></tr>
<tr><td><code id="ex_by_date_+3A_train_prop">train_prop</code></td>
<td>
<p>Numeric. Proportion of data to use for training.
For example, a train_prop of 0.7 means 70% of the data will be used for
training and 30% for testing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class sp.temporal.env that consists in a list of five
elements:
</p>

<ol>
<li><p> &quot;temporal_df&quot;: a temporal data.frame (temporal_df) with the following
columns: latitude, longitude, year, layer_dates, layers_path,
cell_ids_year, and environmental data.
</p>
</li>
<li><p> &quot;sp_date_var&quot;: Name of date variable.
</p>
</li>
<li><p> &quot;lon_lat_vars&quot;: Names of the longitude and latitude variables.
</p>
</li>
<li><p> &quot;layers_ext&quot;: Environmental layers extension.
</p>
</li>
<li><p> &quot;env_data&quot;: Environmental data of occurrences.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
library(tenm)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
abtc &lt;- tenm::clean_dup_by_date(abt,threshold = 10/60)
future::plan("multisession",workers=2)
abex &lt;- tenm::ex_by_date(this_species = abtc,
                         train_prop=0.7)
future::plan("sequential")

</code></pre>

<hr>
<h2 id='inEllipsoid'>inEllipsoid: Determine if a point is inside or outside an ellipsoid</h2><span id='topic+inEllipsoid'></span>

<h3>Description</h3>

<p>Determine if a point is inside or outside an ellipsoid based on
a confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inEllipsoid(centroid, eShape, env_data, level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inEllipsoid_+3A_centroid">centroid</code></td>
<td>
<p>Numeric vector of centroids for each environmental variable.</p>
</td></tr>
<tr><td><code id="inEllipsoid_+3A_eshape">eShape</code></td>
<td>
<p>Shape matrix of the ellipsoid (can be a covariance matrix or a
minimum volume ellipsoid).</p>
</td></tr>
<tr><td><code id="inEllipsoid_+3A_env_data">env_data</code></td>
<td>
<p>Data frame with the environmental data.</p>
</td></tr>
<tr><td><code id="inEllipsoid_+3A_level">level</code></td>
<td>
<p>Proportion of points to be included in the ellipsoids,
equivalent to the error (E) proposed by Peterson et al. (2008).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with 2 columns:
</p>

<ul>
<li><p> &quot;in_Ellipsoid&quot;: Binary response indicating if each point is inside (1)
or outside (0) the ellipsoid.
</p>
</li>
<li><p> &quot;mh_dist&quot;: Mahalanobis distance from each point to the centroid.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(tenm)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
abtc &lt;- tenm::clean_dup_by_date(abt,threshold = 10/60)
future::plan("multisession",workers=2)
abex &lt;- tenm::ex_by_date(abtc,train_prop=0.7)
varcorrs &lt;- tenm::correlation_finder(environmental_data = abex$env_data[,-ncol(abex$env_data)],
                                     method = "spearman",
                                     threshold = 0.8,
                                     verbose = FALSE)
future::plan("sequential")
mod &lt;- tenm::cov_center(data = abex$env_data,
                        mve = TRUE,
                        level = 0.975,
                        vars = c("bio_05","bio_06","bio_12"))
in_elip &lt;- tenm::inEllipsoid(centroid = mod$centroid,
                       eShape = mod$covariance,
                       env_data = abex$env_data[,c("bio_05","bio_06","bio_12")],
                       level = 0.975)
# 1 = Inside the ellipsoid; 0 = Outside the ellipsoid
print(in_elip)

</code></pre>

<hr>
<h2 id='metaras'>Helper function to obtain layer name from a raster layer</h2><span id='topic+metaras'></span>

<h3>Description</h3>

<p>Returns a character vector with the name of the raster layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaras(r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metaras_+3A_r">r</code></td>
<td>
<p>An object of class SpatRaster representing the raster layer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the name of the raster layer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
p1 &lt;- list.files(tempora_layers_dir,full.names=TRUE,
                 pattern=".tif$",recursive=TRUE)[1]
r1 &lt;- terra::rast(p1)
print(tenm::metaras(r1))
</code></pre>

<hr>
<h2 id='plot_ellipsoid'>Function to plot ellipsoid models in E-space</h2><span id='topic+plot_ellipsoid'></span>

<h3>Description</h3>

<p>The function plots 2D and 3D ellipsoids using environmental
information as coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ellipsoid(
  x,
  y,
  z = NULL,
  xlab = "x",
  ylab = "y",
  zlab = "x",
  mve = TRUE,
  level = 0.975,
  col = NULL,
  lwd_axes = 2,
  lty_axes = 2,
  semiaxes = FALSE,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ellipsoid_+3A_x">x</code></td>
<td>
<p>Numeric vector representing the x coordinate of the ellipsoid.</p>
</td></tr>
<tr><td><code id="plot_ellipsoid_+3A_y">y</code></td>
<td>
<p>Numeric vector representing the y coordinate of the ellipsoid.</p>
</td></tr>
<tr><td><code id="plot_ellipsoid_+3A_z">z</code></td>
<td>
<p>Numeric vector representing the z coordinate of the ellipsoid.
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="plot_ellipsoid_+3A_xlab">xlab</code></td>
<td>
<p>Character vector with the name of the x-axis label.</p>
</td></tr>
<tr><td><code id="plot_ellipsoid_+3A_ylab">ylab</code></td>
<td>
<p>Character vector with the name of the y-axis label.</p>
</td></tr>
<tr><td><code id="plot_ellipsoid_+3A_zlab">zlab</code></td>
<td>
<p>Character vector with the name of the z-axis label
(if plotting in 3D).</p>
</td></tr>
<tr><td><code id="plot_ellipsoid_+3A_mve">mve</code></td>
<td>
<p>Logical. If <code>TRUE</code>, fits a minimum volume ellipsoid model.</p>
</td></tr>
<tr><td><code id="plot_ellipsoid_+3A_level">level</code></td>
<td>
<p>Numeric value indicating the proportion of points to be
included inside the ellipsoid model.</p>
</td></tr>
<tr><td><code id="plot_ellipsoid_+3A_col">col</code></td>
<td>
<p>Plot color</p>
</td></tr>
<tr><td><code id="plot_ellipsoid_+3A_lwd_axes">lwd_axes</code></td>
<td>
<p>Line width for ellipsoid semi-axes.</p>
</td></tr>
<tr><td><code id="plot_ellipsoid_+3A_lty_axes">lty_axes</code></td>
<td>
<p>Line type for ellipsoid semi-axes.</p>
</td></tr>
<tr><td><code id="plot_ellipsoid_+3A_semiaxes">semiaxes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, shows semi-axes of the ellipsoid.</p>
</td></tr>
<tr><td><code id="plot_ellipsoid_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, add plot to existing plot (for 2D plots only).</p>
</td></tr>
<tr><td><code id="plot_ellipsoid_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to base::plot,
rgl::plot3d, rgl::wire3d, or other plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-dimensional or 3-dimensional plot depending on the input
coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
y &lt;- rnorm(100)
z &lt;- rnorm(100)
# 2 dimensional plot
plot_ellipsoid(x, y, col = "darkgreen", xlab = "X-axis", ylab = "Y-axis",
               mve = TRUE, level = 0.95)
# 3 dimensional plot
plot_ellipsoid(x, y, z, col = "blue", xlab = "X-axis", ylab = "Y-axis",
               zlab = "Z-axis", mve = TRUE, level = 0.95)

# Examples using functions of the package
library(tenm)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
abtc &lt;- tenm::clean_dup_by_date(abt,threshold = 10/60)
future::plan("multisession",workers=2)
abex &lt;- tenm::ex_by_date(abtc,train_prop=0.7)
future::plan("sequential")
x &lt;- abex$temporal_df$bio_05
y &lt;- abex$temporal_df$bio_06
z &lt;- abex$temporal_df$bio_12
# 2D ellipsoid
tenm::plot_ellipsoid(x = x, y=y, semiaxes= TRUE,xlim=c(140,390))
tenm::plot_ellipsoid(x = x+100, y=y, semiaxes= TRUE,add=TRUE)
# 3D ellipsoid
tenm::plot_ellipsoid(x = x, y=y, z=z ,semiaxes= FALSE)
tenm::plot_ellipsoid(x = x+100, y=y, z=z ,semiaxes= FALSE,add=TRUE)

</code></pre>

<hr>
<h2 id='predict+2Csp.temporal.selection-method'>Predict the potential distribution of species based on environmental
conditions</h2><span id='topic+predict+2Csp.temporal.selection-method'></span><span id='topic+predict'></span>

<h3>Description</h3>

<p>Predict the potential distribution of species based on environmental
conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sp.temporal.selection'
predict(
  object,
  model_variables = NULL,
  layers = NULL,
  layers_path = NULL,
  layers_ext = NULL,
  mve = TRUE,
  level = 0.975,
  output = "suitability",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict+2B2Csp.temporal.selection-method_+3A_object">object</code></td>
<td>
<p>An object of class sp.temporal.selection</p>
</td></tr>
<tr><td><code id="predict+2B2Csp.temporal.selection-method_+3A_model_variables">model_variables</code></td>
<td>
<p>A character vector specifying the variable names used
to build the model.</p>
</td></tr>
<tr><td><code id="predict+2B2Csp.temporal.selection-method_+3A_layers">layers</code></td>
<td>
<p>A SpatRaster object or a list where each element is a
SpatRaster.</p>
</td></tr>
<tr><td><code id="predict+2B2Csp.temporal.selection-method_+3A_layers_path">layers_path</code></td>
<td>
<p>Path to the directory containing raster layers.</p>
</td></tr>
<tr><td><code id="predict+2B2Csp.temporal.selection-method_+3A_layers_ext">layers_ext</code></td>
<td>
<p>File extension of the raster layers.</p>
</td></tr>
<tr><td><code id="predict+2B2Csp.temporal.selection-method_+3A_mve">mve</code></td>
<td>
<p>Logical indicating whether to use the minimum volume
ellipsoid algorithm.</p>
</td></tr>
<tr><td><code id="predict+2B2Csp.temporal.selection-method_+3A_level">level</code></td>
<td>
<p>Proportion of data to include inside the ellipsoid
if mve is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict+2B2Csp.temporal.selection-method_+3A_output">output</code></td>
<td>
<p>Character indicating if the model outputs &quot;suitability&quot; values
or &quot;mahalanobis&quot; distances.</p>
</td></tr>
<tr><td><code id="predict+2B2Csp.temporal.selection-method_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to
<code><a href="#topic+ellipsoid_projection">ellipsoid_projection</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function predicts the potential distribution of a species based on
environmental conditions represented by raster layers. The prediction is
based on the model statistics and environmental variables specified in
'model_variables'. If 'mve' is <code>TRUE</code>, the minimum volume ellipsoid algorithm
is used to model the niche space. The output can be either &quot;suitability&quot;,
or &quot;mahalanobis&quot;, indicating distance to the niche center.
Note that each SpatRaster in the 'layers' parameter should have the
same number of elements (layers) as 'model_variables'. The predict method
assumes that variables in each SpatRaster correspond to those in
'model_variables'. If layers in the 'layers' parameter are given as a
list of objects of class SpatRaster, then the number of prediction layers
will have the same number of elements in the list.
</p>


<h3>Value</h3>

<p>A SpatRaster object representing predicted suitability values or
Mahalanobis distances to niche center.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tenm)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
abtc &lt;- tenm::clean_dup_by_date(abt,threshold = 10/60)
future::plan("multisession",workers=2)
abex &lt;- tenm::ex_by_date(this_species = abtc,train_prop=0.7)
abbg &lt;- tenm::bg_by_date(this_species = abex,
                         buffer_ngbs=NULL,n_bg=50000)
abbg &lt;- tenm::bg_by_date(this_species = abex,
                         buffer_ngbs=10,n_bg=50000)
future::plan("sequential")
varcorrs &lt;- tenm::correlation_finder(environmental_data =
                                       abex$env_data[,-ncol(abex$env_data)],
                                     method = "spearman",
                                     threshold = 0.8,
                                     verbose = FALSE)
mod_sel &lt;- tenm::tenm_selection(this_species = abbg,
                                omr_criteria =0.1,
                                ellipsoid_level=0.975,
                                vars2fit = varcorrs$descriptors,
                                nvars_to_fit=c(3,4),
                                proc = TRUE,
                                RandomPercent = 50,
                                NoOfIteration=1000,
                                parallel=TRUE,
                                n_cores=2)
# Prediction using variables path
layers_70_00_dir &lt;- system.file("extdata/bio_1970_2000",package = "tenm")
# The if the 'model_variables' parameter is set to NULL, the method uses
# the first model in the results table (mod_sel$mods_table)
suit_1970_2000 &lt;- predict(mod_sel,
                          model_variables = NULL,
                          layers_path = layers_70_00_dir,
                          layers_ext = ".tif$")
# You can select the modeling variables used to project the model
suit_1970_2000 &lt;- predict(mod_sel,
                          model_variables = c("bio_01","bio_04",
                                              "bio_07","bio_12"),
                          layers_path = layers_70_00_dir,
                          layers_ext = ".tif$")

# Pass a list containing the paths of the modeling layers
layers_1939_2016 &lt;- file.path(tempora_layers_dir,c("1939","2016"))
suit_1939_2016 &lt;- predict(mod_sel,model_variables = NULL,
                          layers_path = layers_1939_2016,
                          layers_ext = ".tif$")
# Pass a list of raster layers
layers_1939 &lt;- terra::rast(list.files(layers_1939_2016[1],
                                      pattern = ".tif$",full.names = TRUE))
layers_2016 &lt;- terra::rast(list.files(layers_1939_2016[2],
                                      pattern = ".tif$",full.names = TRUE))
layers_1939 &lt;- layers_1939[[c("bio_01","bio_04","bio_07")]]
layers_2016 &lt;- layers_2016[[c("bio_01","bio_04","bio_07")]]
layers_list &lt;- list(layers_1939,layers_2016)
suit_1939_2016 &lt;- predict(object = mod_sel,
                          model_variables = c("bio_01","bio_04","bio_07"),
                          layers_path = NULL,
                          layers = layers_list,
                          layers_ext = ".tif$")



</code></pre>

<hr>
<h2 id='pROC'>Partial ROC calculation for Niche Models</h2><span id='topic+pROC'></span>

<h3>Description</h3>

<p>Apply partial ROC tests to continuous niche models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pROC(
  continuous_mod,
  test_data,
  n_iter = 1000,
  E_percent = 5,
  boost_percent = 50,
  rseed = FALSE,
  sub_sample = TRUE,
  sub_sample_size = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pROC_+3A_continuous_mod">continuous_mod</code></td>
<td>
<p>A SpatRaster or numeric vector of the ecological
niche model to be evaluated. If a numeric vector is provided, it should
contain the values of the predicted suitability.</p>
</td></tr>
<tr><td><code id="pROC_+3A_test_data">test_data</code></td>
<td>
<p>A numerical matrix, data.frame, or numeric vector:
</p>

<ul>
<li><p> If data.frame or matrix, it should contain coordinates of the
occurrences used to test the ecological niche model.
Columns must be: longitude and latitude.
</p>
</li>
<li><p> If numeric vector, it should contain the values of the predicted
suitability.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pROC_+3A_n_iter">n_iter</code></td>
<td>
<p>Number of bootstrap iterations to perform for partial ROC
calculations. Default is 1000.</p>
</td></tr>
<tr><td><code id="pROC_+3A_e_percent">E_percent</code></td>
<td>
<p>Numeric value from 0 to 100 used as the threshold (E)
for partial ROC calculations. Default is 5.</p>
</td></tr>
<tr><td><code id="pROC_+3A_boost_percent">boost_percent</code></td>
<td>
<p>Numeric value from 0 to 100 representing the
percentage of testing data to use for bootstrap iterations in partial ROC.
Default is 50.</p>
</td></tr>
<tr><td><code id="pROC_+3A_rseed">rseed</code></td>
<td>
<p>Logical. Whether or not to set a random seed for
reproducibility. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pROC_+3A_sub_sample">sub_sample</code></td>
<td>
<p>Logical. Indicates whether to use a subsample of
the test data. Recommended for large datasets.</p>
</td></tr>
<tr><td><code id="pROC_+3A_sub_sample_size">sub_sample_size</code></td>
<td>
<p>Size of the subsample to use for computing pROC
values when sub_sample is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Partial ROC is calculated following Peterson et al.
(2008; <a href="https://doi.org/10.1016/j.ecolmodel.2007.11.008">doi:10.1016/j.ecolmodel.2007.11.008</a>).
This function is a modification of the PartialROC function, available
at <a href="https://github.com/narayanibarve/ENMGadgets">https://github.com/narayanibarve/ENMGadgets</a>.
</p>


<h3>Value</h3>

<p>A list of two elements:
</p>

<ul>
<li><p> &quot;pROC_summary&quot;: a data.frame containing the mean
AUC value, AUC ratio calculated for each iteration and the p-value of the
test.
</p>
</li>
<li><p> &quot;pROC_results&quot;: a data.frame with four columns containing the AUC
(auc_model), partial AUC (auc_pmodel), partial AUC of the random model
(auc_prand) and the AUC ratio (auc_ratio) for each iteration.
</p>
</li></ul>



<h3>References</h3>

<p>Peterson, A.T. et al. (2008) Rethinking receiver operating
characteristic analysis applications in ecological niche modeling.
Ecol. Modell., 213, 63–72. <a href="https://doi.org/10.1016/j.ecolmodel.2007.11.008">doi:10.1016/j.ecolmodel.2007.11.008</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abronia)
suit_1970_2000 &lt;- terra::rast(system.file("extdata/suit_1970_2000.tif",
                                          package = "tenm"))
print(suit_1970_2000)
proc_test &lt;- tenm::pROC(continuous_mod = suit_1970_2000,
                        test_data = abronia[,c("decimalLongitude",
                                               "decimalLatitude")],
                        n_iter = 500, E_percent=5,
                        boost_percent=50)
print(proc_test$pROC_summary)

</code></pre>

<hr>
<h2 id='sp_temporal_data'>Function to create a Species Temporal Data object (STD object).</h2><span id='topic+sp_temporal_data'></span>

<h3>Description</h3>

<p>Creates an object of class sp.temporal.modeling that contains
a list with four attributes:
</p>

<ul>
<li><p> temporal_df: A data frame with the following columns:
</p>

<ul>
<li><p> Longitude: Longitude coordinates of occurrence records.
</p>
</li>
<li><p> Latitude: Latitude coordinates of occurrence records.
</p>
</li>
<li><p> Date: Date variable indicating when the species were observed.
</p>
</li>
<li><p> Layer Dates: Format of dates for each layer of environmental data.
</p>
</li>
<li><p> Layers Path: Path to the bioclimatic layer corresponding to each year.
</p>
</li></ul>

</li>
<li><p> sp_date_var: Name of the date variable column in the occurrence records.
</p>
</li>
<li><p> lon_lat_vars: Names of the longitude and latitude columns.
</p>
</li>
<li><p> layers_ext: Final extension format of the environmental information
(e.g., &quot;.tif&quot;).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sp_temporal_data(
  occs,
  longitude,
  latitude,
  sp_date_var,
  occ_date_format = "y",
  layers_date_format = "y",
  layers_by_date_dir,
  layers_ext = "*.tif$"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sp_temporal_data_+3A_occs">occs</code></td>
<td>
<p>A data.frame with information about occurrence records of the
species being modeled.</p>
</td></tr>
<tr><td><code id="sp_temporal_data_+3A_longitude">longitude</code></td>
<td>
<p>Name of the variable in 'occs' containing longitude data.</p>
</td></tr>
<tr><td><code id="sp_temporal_data_+3A_latitude">latitude</code></td>
<td>
<p>Name of the variable in 'occs' containing latitude data.</p>
</td></tr>
<tr><td><code id="sp_temporal_data_+3A_sp_date_var">sp_date_var</code></td>
<td>
<p>Name of the date variable.</p>
</td></tr>
<tr><td><code id="sp_temporal_data_+3A_occ_date_format">occ_date_format</code></td>
<td>
<p>Format of dates in occurrence records.
Options: &quot;y&quot;, &quot;ym&quot;, &quot;ymd&quot;, &quot;mdy&quot;, &quot;my&quot;, &quot;dmy&quot;.</p>
</td></tr>
<tr><td><code id="sp_temporal_data_+3A_layers_date_format">layers_date_format</code></td>
<td>
<p>Format of dates in raster layers. Options:
&quot;y&quot;, &quot;ym&quot;, &quot;ymd&quot;, &quot;mdy&quot;, &quot;my&quot;, &quot;dmy&quot;.</p>
</td></tr>
<tr><td><code id="sp_temporal_data_+3A_layers_by_date_dir">layers_by_date_dir</code></td>
<td>
<p>Directory containing folders organized by date
with raster layers of environmental information.</p>
</td></tr>
<tr><td><code id="sp_temporal_data_+3A_layers_ext">layers_ext</code></td>
<td>
<p>Extension or path of each raster layer archive
(e.g., &quot;.tif&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The format of dates for each layer can be organized in a particular pattern,
for example year/month/day (&quot;ymd&quot;), year/month (&quot;ym&quot;), just year (&quot;y&quot;) or
some other arrangement like month/year (&quot;my&quot;), month/year/day (&quot;myd&quot;),
day/month/year (&quot;dmy&quot;).
</p>


<h3>Value</h3>

<p>Returns a  sp.temporal.modeling object (list) with the coordinates
of each occurrences points, the years of observation and the path to the
temporal layers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tenm)
#A data.frame with occurrences points information of Abronia graminea.
# See help(abronia)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
</code></pre>

<hr>
<h2 id='sp.temporal.bg-class'>S3 classes to organize data and results of <code>tenm</code> objects</h2><span id='topic+sp.temporal.bg-class'></span>

<h3>Description</h3>

<p>S3 classes to organize data and results of <code>tenm</code> objects
</p>


<h3>Value</h3>

<p>An object of class 'sp.temporal.bg'. The object inherits information
from objects of classes 'sp.temporal.modeling' and 'sp.temporal.env'. This
class adds environmental background information.
</p>


<h3>Author(s)</h3>

<p>Luis Osorio-Olvera
</p>

<hr>
<h2 id='sp.temporal.env-class'>S3 classes to organize data and results of <code>tenm</code> objects</h2><span id='topic+sp.temporal.env-class'></span>

<h3>Description</h3>

<p>S3 classes to organize data and results of <code>tenm</code> objects
</p>


<h3>Value</h3>

<p>An object of class 'sp.temporal.env' inheriting information from
'sp.temporal.env'. This object adds a data.frame of environmental values
associated with occurrence data.
</p>


<h3>Author(s)</h3>

<p>Luis Osorio-Olvera
</p>

<hr>
<h2 id='sp.temporal.modeling-class'>S3 classes to organize data and results of <code>tenm</code> objects</h2><span id='topic+sp.temporal.modeling-class'></span>

<h3>Description</h3>

<p>S3 classes to organize data and results of <code>tenm</code> objects
</p>


<h3>Value</h3>

<p>This object is a list comprising four elements: a) A data.frame
containing occurrence records and layer information. b) A character vector
specifying variable names. c) A character vector indicating the names of
longitude and latitude variables. d) A character vector denoting the
layers extension.
</p>


<h3>Author(s)</h3>

<p>Luis Osorio-Olvera
</p>

<hr>
<h2 id='sp.temporal.selection-class'>S3 classes to organize data and results of <code>tenm</code> objects</h2><span id='topic+sp.temporal.selection-class'></span>

<h3>Description</h3>

<p>S3 classes to organize data and results of <code>tenm</code> objects
</p>


<h3>Value</h3>

<p>An object of class 'sp.temporal.selection'. This object inherits
information from objects of classes 'sp.temporal.modeling', 'sp.temporal.env'
and 'sp.temporal.bg'. The object stores the results of
the model calibration and selection process in a data.frame.
</p>


<h3>Author(s)</h3>

<p>Luis Osorio-Olvera
</p>

<hr>
<h2 id='tdf2swd'>Temporal data.frame to Samples With Data format</h2><span id='topic+tdf2swd'></span>

<h3>Description</h3>

<p>Converts a temporal data.frame to Samples With Data (SWD) table for use
with other modeling platforms such as MaxEnt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tdf2swd(this_species, sp_name = "sp")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tdf2swd_+3A_this_species">this_species</code></td>
<td>
<p>An object of class sp.temporal.env
(see <code><a href="#topic+ex_by_date">ex_by_date</a></code> ) or sp.temporal.bg
(see <code><a href="#topic+bg_by_date">bg_by_date</a></code>).</p>
</td></tr>
<tr><td><code id="tdf2swd_+3A_sp_name">sp_name</code></td>
<td>
<p>Character vector specifying the species name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame formatted as Samples With Data (SWD) table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tenm)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
abtc &lt;- tenm::clean_dup_by_date(abt,threshold = 10/60)
future::plan("multisession",workers=2)
abex &lt;- tenm::ex_by_date(this_species = abtc,
                         train_prop=0.7)
abbg &lt;- tenm::bg_by_date(abex,
                         buffer_ngbs=10,n_bg=50000)
future::plan("sequential")
# SWD table for occurrence records
occ_swd &lt;- tdf2swd(this_species=abex,sp_name="abro_gram")
# SWD table for background data
bg_swd &lt;- tdf2swd(this_species=abbg)

</code></pre>

<hr>
<h2 id='tenm_selection'>Function to find the best n-dimensional ellipsoid model</h2><span id='topic+tenm_selection'></span>

<h3>Description</h3>

<p>Finds the best n-dimensional ellipsoid model using a model
calibration and selection protocol for ellipsoid models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tenm_selection(
  this_species,
  omr_criteria = 0.1,
  ellipsoid_level = 0.975,
  vars2fit,
  nvars_to_fit = c(2, 3),
  mve = TRUE,
  proc = TRUE,
  sub_sample = TRUE,
  sub_sample_size = 1000,
  RandomPercent = 50,
  NoOfIteration = 1000,
  parallel = TRUE,
  n_cores = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tenm_selection_+3A_this_species">this_species</code></td>
<td>
<p>An object of class sp.temporal.env representing species
occurrence data organized by date. See <code><a href="#topic+ex_by_date">ex_by_date</a></code>.</p>
</td></tr>
<tr><td><code id="tenm_selection_+3A_omr_criteria">omr_criteria</code></td>
<td>
<p>Omission rate criterion used to select the best models.
See <code><a href="#topic+ellipsoid_selection">ellipsoid_selection</a></code> for details</p>
</td></tr>
<tr><td><code id="tenm_selection_+3A_ellipsoid_level">ellipsoid_level</code></td>
<td>
<p>Proportion of points to include inside the ellipsoid.</p>
</td></tr>
<tr><td><code id="tenm_selection_+3A_vars2fit">vars2fit</code></td>
<td>
<p>A vector of variable names to use in building the models.</p>
</td></tr>
<tr><td><code id="tenm_selection_+3A_nvars_to_fit">nvars_to_fit</code></td>
<td>
<p>Number of variables used to build the models.</p>
</td></tr>
<tr><td><code id="tenm_selection_+3A_mve">mve</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a minimum volume ellipsoid will be computed.</p>
</td></tr>
<tr><td><code id="tenm_selection_+3A_proc">proc</code></td>
<td>
<p>Logical. If <code>TRUE</code>, compute the partial ROC test for each model.</p>
</td></tr>
<tr><td><code id="tenm_selection_+3A_sub_sample">sub_sample</code></td>
<td>
<p>Logical. Indicates whether to use a subsample of size
sub_sample_size for computing pROC values, recommended for large datasets.</p>
</td></tr>
<tr><td><code id="tenm_selection_+3A_sub_sample_size">sub_sample_size</code></td>
<td>
<p>Size of the sub_sample to use for
computing pROC values when sub_sample is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tenm_selection_+3A_randompercent">RandomPercent</code></td>
<td>
<p>Percentage of occurrence points to sample randomly for
bootstrap in the Partial ROC test. See <code><a href="#topic+pROC">pROC</a></code>.</p>
</td></tr>
<tr><td><code id="tenm_selection_+3A_noofiteration">NoOfIteration</code></td>
<td>
<p>Number of iterations for the bootstrap in the
Partial ROC test. See <code><a href="#topic+pROC">pROC</a></code>.</p>
</td></tr>
<tr><td><code id="tenm_selection_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Whether to run computations in parallel.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tenm_selection_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of cores to use for parallelization. Default is 4.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;sp.temporal.selection&quot; containing metadata of
model statistics of the calibrated models, obtainable from the &quot;mods_table&quot;
attribute. The function internally uses
<code><a href="#topic+ellipsoid_selection">ellipsoid_selection</a></code>
to obtain model statistics. Note that this function inherits attributes
from classes &quot;sp.temporal.modeling&quot;
(see <code><a href="#topic+sp_temporal_data">sp_temporal_data</a></code>),
&quot;sp.temporal.env&quot; (see <code><a href="#topic+ex_by_date">ex_by_date</a></code>),
and &quot;sp.temporal.bg&quot; (see <code><a href="#topic+bg_by_date">bg_by_date</a></code>), thus all
information from these classes can be extracted from this object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tenm)
data("abronia")
tempora_layers_dir &lt;- system.file("extdata/bio",package = "tenm")
abt &lt;- tenm::sp_temporal_data(occs = abronia,
                              longitude = "decimalLongitude",
                              latitude = "decimalLatitude",
                              sp_date_var = "year",
                              occ_date_format="y",
                              layers_date_format= "y",
                              layers_by_date_dir = tempora_layers_dir,
                              layers_ext="*.tif$")
abtc &lt;- tenm::clean_dup_by_date(abt,threshold = 10/60)
future::plan("multisession",workers=2)
abex &lt;- tenm::ex_by_date(this_species = abtc,
                         train_prop=0.7)
abbg &lt;- tenm::bg_by_date(abex,
                         buffer_ngbs=10,n_bg=50000)
future::plan("sequential")
varcorrs &lt;- tenm::correlation_finder(environmental_data = abex$env_data[,-ncol(abex$env_data)],
                                     method = "spearman",
                                     threshold = 0.8,
                                     verbose = FALSE)
vars2fit &lt;- varcorrs$descriptors
mod_sel &lt;- tenm::tenm_selection(this_species = abbg,
                                omr_criteria =0.1,
                                ellipsoid_level=0.975,
                                vars2fit = vars2fit,
                                nvars_to_fit=c(2,3),
                                proc = TRUE,
                                RandomPercent = 50,
                                NoOfIteration=1000,
                                parallel=TRUE,
                                n_cores=20)
# Project potential distribution using bioclimatic layers for 1970-2000
# period.
layers_70_00_dir &lt;- system.file("extdata/bio_1970_2000",package = "tenm")
suit_1970_2000 &lt;- predict(mod_sel,model_variables = NULL,
                          layers_path = layers_70_00_dir,
                          layers_ext = ".tif$")
terra::plot(suit_1970_2000)
colors &lt;- c('#000004FF', '#040312FF', '#0B0725FF',
            '#0B0725FF', '#160B38FF', '#160B38FF',
            '#230C4CFF', '#310A5CFF', '#3F0966FF',
            '#4D0D6CFF', '#5A116EFF', '#67166EFF',
            '#741A6EFF', '#81206CFF', '#81206CFF',
            '#8E2469FF', '#9B2964FF', '#A82E5FFF',
            '#B53359FF', '#B53359FF', '#C03A50FF',
            '#CC4248FF', '#D74B3FFF', '#E05536FF',
            '#E9602CFF', '#EF6E21FF', '#F57B17FF',
            '#F8890CFF', '#FB9806FF', '#FB9806FF',
            '#FCA70DFF', '#FBB81DFF', '#F9C72FFF',
            '#F9C72FFF', '#F6D847FF', '#F2E763FF',
            '#F2E763FF', '#F3F585FF', '#FCFFA4FF',
            '#FCFFA4FF')
points(abtc$temporal_df[,1:2],pch=17,cex=1,
       col=rev(colors))
legend("topleft",legend = abtc$temporal_df$year[1:18],
       col =rev(colors[1:18]),
       cex=0.75,pch=17)
legend("topright",legend = unique(abtc$temporal_df$year[19:40]),
       col = rev(colors[19:40]),
       cex=0.75,pch=17)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
