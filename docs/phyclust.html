<!DOCTYPE html><html><head><title>Help for package phyclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phyclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.boundary.method'><p>Boundary Methods for Population Proportions</p></a></li>
<li><a href='#.code.type'><p>Code Types of Dataset and Substitution Models</p></a></li>
<li><a href='#.Color'><p>Colors for Identifying Clusters in Plots</p></a></li>
<li><a href='#.edist.model'><p>Evolution Distance Model</p></a></li>
<li><a href='#.em.method'><p>EM Methods and Algorithms</p></a></li>
<li><a href='#.EMC'><p>EM Control</p></a></li>
<li><a href='#.EMControl'><p>EM Control Generator</p></a></li>
<li><a href='#.identifier'><p>Identifiers for Evolution Models</p></a></li>
<li><a href='#.init.method'><p>Initialization Methods for EM Algorithms</p></a></li>
<li><a href='#.init.procedure'><p>Initialization Procedures for EM Algorithms</p></a></li>
<li><a href='#.label.method'><p>Label Method</p></a></li>
<li><a href='#.se.model'><p>Sequencing Error Model</p></a></li>
<li><a href='#.show.option'><p>Show Available Options</p></a></li>
<li><a href='#.substitution.model'><p>Substitution Models for Mutation Processes</p></a></li>
<li><a href='#all.internal'><p> All Internal Functions of phyclust</p></a></li>
<li><a href='#all.internal.tzeng'><p> All Internal Functions of Tzeng's Methods</p></a></li>
<li><a href='#as.star.tree'><p>Coerce a Rooted Tree to a Star Tree in Class phylo</p></a></li>
<li><a href='#bootstrap.seq'><p>Bootstrap Sequences from a Fitted Model and Star Tree.</p></a></li>
<li><a href='#bootstrap.seq.data'><p>Bootstrap a seq.data from a Fitted Model.</p></a></li>
<li><a href='#bootstrap.star.trees'><p>Bootstrap a Star Tree from a Fitted Model.</p></a></li>
<li><a href='#bootstrap.star.trees.seq'><p>Bootstrap Sequences from a Fitted Model.</p></a></li>
<li><a href='#code2nid'><p>Transfer Codes (A, G, C, T, -) and nids (0, 1, 2, 3, 4)</p></a></li>
<li><a href='#code2snp'><p>Transfer Nucleotide Codes / nids and SNPs / sids</p></a></li>
<li><a href='#data.fasta.pony'><p>Great Pony 625 EIAV rev Dataset in the Fasta Format</p></a></li>
<li><a href='#data.phylip.crohn'><p>Crohn's Disease SNP Dataset in the phylip Format</p></a></li>
<li><a href='#data.phylip.pony'><p>Great Pony 524 EIAV rev Dataset in the phylip Format</p></a></li>
<li><a href='#file.read'><p>Read Data from Files by Formats and Return a seq.data Object</p></a></li>
<li><a href='#file.write'><p>Write Data to Files by Formats</p></a></li>
<li><a href='#find.best'><p>Find the Best Solution of phyclust</p></a></li>
<li><a href='#find.consensus'><p>Find the Consensus Sequence</p></a></li>
<li><a href='#gen.equal.star.anc.dec'><p>Generate Comprehensive Trees.</p></a></li>
<li><a href='#gen.seq'><p>Generate Sequences Given a Rooted Tree.</p></a></li>
<li><a href='#gen.star.tree'><p>Generate a Rooted Tree with a Star Shape</p></a></li>
<li><a href='#gen.unit.K'><p>Generate Comprehensive Trees.</p></a></li>
<li><a href='#get.rooted.tree.height'><p>Get a Rooted Tree Height</p></a></li>
<li><a href='#getcut.fun'><p>Tzeng's Method: Finding the Best Number of Clusters</p></a></li>
<li><a href='#haplo.post.prob'><p>Tzeng's Method: Haplotype Grouping for SNP Sequences</p></a></li>
<li><a href='#ms'><p>Generating Samples under a Wright-Fisher Neutral Model of Genetic Variation</p></a></li>
<li><a href='#nid.aid.cid'><p>Transfer nids (0, 1, ..., 4) , aids (0, 1, ..., 21) and cids (0, 1, ..., 64)</p></a></li>
<li><a href='#paml.baseml'><p>Phylogenetic Analysis by Maximum Likelihood for Nucleotide Sequences</p></a></li>
<li><a href='#phyclust'><p>The Main Function of phyclust</p></a></li>
<li><a href='#phyclust-package'><p>Phyloclustering &ndash; Phylogenetic Clustering</p></a></li>
<li><a href='#phyclust.e.step'><p>One E-Step of phyclust</p></a></li>
<li><a href='#phyclust.edist'><p>Evolution Distance of Sequences</p></a></li>
<li><a href='#phyclust.em.step'><p>One EM-step of phyclust</p></a></li>
<li><a href='#phyclust.logL'><p>Log-Likelihood of phyclust</p></a></li>
<li><a href='#phyclust.m.step'><p>One M-Step of phyclust</p></a></li>
<li><a href='#phyclust.Pt'><p>Transition Probabilities of phyclust Given Time</p></a></li>
<li><a href='#phyclust.se'><p>The Main Function of phyclust for Sequencing Error Models</p></a></li>
<li><a href='#phyclust.se.update'><p>Update phyclust Results by the Sequencing Error Model</p></a></li>
<li><a href='#phyclust.update'><p>Update phyclust Results</p></a></li>
<li><a href='#plotdots'><p>Dots Plots of Sequences for Visual Comparisons</p></a></li>
<li><a href='#plotgaps'><p>Gaps Plots of Sequences for Visual Comparisons</p></a></li>
<li><a href='#plothist'><p>Plot Histogram to Compare Number of Mutations.</p></a></li>
<li><a href='#plotnj'><p>Plot an Unrooted Trees.</p></a></li>
<li><a href='#plotstruct'><p>Struct Plots of Observations Based on Posterior Probabilities</p></a></li>
<li><a href='#print.object'><p>Functions for Printing or Summarizing Objects According to Classes</p></a></li>
<li><a href='#prune.Mu'><p>Prune the Center Sequences Mu</p></a></li>
<li><a href='#read.seqgen'><p>Read seqgen's Results and Return a seq.data</p></a></li>
<li><a href='#rescale.rooted.tree'><p>Rescale a Rooted Tree's Height</p></a></li>
<li><a href='#RRand'><p>Rand Index and Adjusted Rand Index</p></a></li>
<li><a href='#seq.data'><p>A Toy Dataset in Class seq.data</p></a></li>
<li><a href='#seqgen'><p>Seq-Gen</p></a></li>
<li><a href='#snp2sid'><p>Transfer SNP codes (1, 2, -) and sids (0, 1, 2)</p></a></li>
<li><a href='#standard.code'><p>Standard Codes and ids for Nucleotides, SNPs, Codon, Amino Acid and Genetic Code</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1-34</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-03</td>
</tr>
<tr>
<td>Title:</td>
<td>Phylogenetic Clustering (Phyloclustering)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), ape</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Copyright:</td>
<td>See phyclust/inst/Documents/ for files in src/msdir/,
src/seq-gen/, src/paml_baseml, and R/ttzeng-*.r.</td>
</tr>
<tr>
<td>Description:</td>
<td>Phylogenetic clustering (phyloclustering) is an evolutionary
        Continuous Time Markov Chain model-based approach to identify
        population structure from molecular data without assuming
        linkage equilibrium. The package phyclust (Chen 2011) provides a
        convenient implementation of phyloclustering for DNA and SNP data,
        capable of clustering individuals into subpopulations and identifying
        molecular sequences representative of those subpopulations. It is
        designed in C for performance, interfaced with R for visualization,
        and incorporates other popular open source programs including
        ms (Hudson 2002) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2F18.2.337">doi:10.1093/bioinformatics/18.2.337</a>&gt;,
        seq-gen (Rambaut and Grassly 1997)
        &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2F13.3.235">doi:10.1093/bioinformatics/13.3.235</a>&gt;,
        Hap-Clustering (Tzeng 2005) &lt;<a href="https://doi.org/10.1002%2Fgepi.20063">doi:10.1002/gepi.20063</a>&gt; and
        PAML baseml (Yang 1997, 2007) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2F13.5.555">doi:10.1093/bioinformatics/13.5.555</a>&gt;,
        &lt;<a href="https://doi.org/10.1093%2Fmolbev%2Fmsm088">doi:10.1093/molbev/msm088</a>&gt;,
        for simulating data, additional analyses, and searching the best tree.
        See the phyclust website for more information, documentations and
        examples.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/snoweye/phyclust/issues">https://github.com/snoweye/phyclust/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wei-Chen Chen &lt;wccsnow@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-06 02:49:20 UTC; snoweye</td>
</tr>
<tr>
<td>Author:</td>
<td>Wei-Chen Chen [aut, cre],
  Karin Dorman [aut],
  Yan-Han Chen [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-06 04:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.boundary.method'>Boundary Methods for Population Proportions</h2><span id='topic+.boundary.method'></span>

<h3>Description</h3>

<p>Methods used in EM Algorithms to deal with boundary problems of
population proportions, <code class="reqn">\eta_k</code>.
The first element is the default value.
<strong>This is a read-only object and the elemental order is followed in C.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.boundary.method</code></pre>


<h3>Format</h3>

<p>A character vector contains implemented boundary methods in C.
</p>


<h3>Details</h3>

<p>The boundary value 0 of the population proportions makes the log
likelihood as -Inf. Since degeneracy of subpopulations can affect
the maximizing processes in EM steps. This problem is usually caused
by bad initializations, and may suggest that number of cluster
<code class="reqn">K</code> may be too large.
</p>
<p>Two methods have been implemented when any <code class="reqn">\eta_k</code> less than
the lower bound (<code class="reqn">1/N</code> or <code class="reqn">1e-16</code>).
The <code>ADJUST</code> (default) will adjust the <code class="reqn">\eta_k</code> to the
lower bound, and the <code>IGNORE</code> will stop the iterations and return
errors.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.show.option">.show.option</a></code>,
<code><a href="#topic+.init.procedure">.init.procedure</a></code>,
<code><a href="#topic+.init.method">.init.method</a></code>,
<code><a href="#topic+.EMControl">.EMControl</a></code>,
<code><a href="#topic+phyclust">phyclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.boundary.method

## End(Not run)
</code></pre>

<hr>
<h2 id='.code.type'>Code Types of Dataset and Substitution Models</h2><span id='topic+.code.type'></span>

<h3>Description</h3>

<p>Indicate the types of codes for datasets and functions.
The first element is the default value.
<strong>This is a read-only object and the elemental order is followed in C.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.code.type</code></pre>


<h3>Format</h3>

<p>A character vector contains implemented code types in C.
</p>


<h3>Details</h3>

<p>Two possible types are implemented,
&quot;NUCLEOTIDE&quot; (default) and &quot;SNP&quot;, used in
data transfers and indicating substitution models.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.show.option">.show.option</a></code>,
<code><a href="#topic+.substitution.model">.substitution.model</a></code>,
<code><a href="#topic+.EMControl">.EMControl</a></code>,
<code><a href="#topic+phyclust">phyclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.code.type

## End(Not run)
</code></pre>

<hr>
<h2 id='.Color'>Colors for Identifying Clusters in Plots</h2><span id='topic+.Color'></span>

<h3>Description</h3>

<p>Color themes as used in the package <span class="pkg">lattice</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.Color</code></pre>


<h3>Format</h3>

<p>A character vector contains colors used in plots to identify clusters.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotnj">plotnj</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.Color

## End(Not run)
</code></pre>

<hr>
<h2 id='.edist.model'>Evolution Distance Model</h2><span id='topic+.edist.model'></span>

<h3>Description</h3>

<p>Evolution distances based on certain evolution models as in <span class="pkg">ape</span>. 
The implemented model is used in <code>phyclust.edist</code> and initializations
of EM algorithms. The first element is the default value.
<strong>This is a read-only object and the elemental order is followed in C.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.edist.model</code></pre>


<h3>Format</h3>

<p>A character vector contains implemented evolution distances in C.
</p>


<h3>Details</h3>

<p>This vector stores possible evolution distances implemented in <span class="pkg">phyclust</span>.
The default value is <code>D_JC69</code> computed form the probability of
<em>JC69</em> model.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.show.option">.show.option</a></code>,
<code><a href="#topic+phyclust.edist">phyclust.edist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.edist.model

## End(Not run)
</code></pre>

<hr>
<h2 id='.em.method'>EM Methods and Algorithms</h2><span id='topic+.em.method'></span>

<h3>Description</h3>

<p>The varied EM algorithms are implemented in C.
The first element is the default value.
<strong>This is a read-only object and the elemental order is followed in C.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.em.method</code></pre>


<h3>Format</h3>

<p>A character vector contains implemented EM algorithms in C.
</p>


<h3>Details</h3>

<p><code>EM</code> (default) stands for the standard EM algorithm, <code>ECM</code>
stands for Expectation/Conditional Maximization algorithm, and <code>AECM</code>
stands for Alternating ECM algorithm.
The performance is roughly about <code>AECM</code> &gt; <code>EM</code> ~ <code>ECM</code> which
are dependent on the separations of data set.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Dempster, A. and Laird, N. and Rubin, D. (1977)
&ldquo;Maximum Likelihood Estimation from Incomplete Data
via the EM Algorithm&rdquo;,
<em>Journal of the Royal Statistical Society Series B</em>, <b>39:3</b>, 1-38.
</p>
<p>Meng, X.-L. and Rubin, D. (1993)
&ldquo;Maximum likelihood estimation via the ECM algorithm: A general
framework&rdquo;,
<em>Biometrika</em>, <b>80:2</b>, 511-567.
</p>
<p>Meng, X.-L. and van Dyk, D. (1997)
&ldquo;The EM Algorithm &mdash; an Old Folk-song Sung to a Fast New Tune
(with discussion)&rdquo;,
<em>Journal of the Royal Statistical Society Series B</em>, <b>59</b>, 511-567.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.show.option">.show.option</a></code>,
<code><a href="#topic+.EMC">.EMC</a></code>,
<code><a href="#topic+.EMControl">.EMControl</a></code>,
<code><a href="#topic+phyclust">phyclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.em.method

## End(Not run)
</code></pre>

<hr>
<h2 id='.EMC'>EM Control</h2><span id='topic+.EMC'></span>

<h3>Description</h3>

<p>An default template object stores controlling options for <code>phyclust</code>
to perform EM algorithms. This object combines all other read-only
objects and more required options for EM algorithms. This is essential
for <code>phyclust</code> and other related functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.EMC</code></pre>


<h3>Format</h3>

<p>A list contains all controlling options
</p>


<h3>Details</h3>

<p>A list created by <code>.EMControl</code> contains all controlling options for
EM algorithms. This list will be directly passed to C codes and control
the every things of EM algorithms.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.show.option">.show.option</a></code>,
<code><a href="#topic+.EMControl">.EMControl</a></code>,
<code><a href="#topic+phyclust">phyclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.EMC

## End(Not run)
</code></pre>

<hr>
<h2 id='.EMControl'>EM Control Generator</h2><span id='topic+.EMControl'></span>

<h3>Description</h3>

<p>Generate an EM control (<code>.EMC</code>) controlling the options,
methods, conditions and models of EM algorithms.
As <code>.EMC</code>, this function generate a default template.
One can either modify <code>.EMC</code> or employ this function to
control EM algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.EMControl(exhaust.iter = 1, fixed.iter = 5,
    short.iter = 100, EM.iter = 1000,
    short.eps = 1e-2, EM.eps = 1e-6,
    cm.reltol = 1e-8, cm.maxit = 5000,
    nm.abstol.Mu.given.QA = 1e-8, nm.reltol.Mu.given.QA = 1e-8,
    nm.maxit.Mu.given.QA = 500,
    nm.abstol.QA.given.Mu = 1e-8, nm.reltol.QA.given.Mu = 1e-8,
    nm.maxit.QA.given.Mu = 5000,
    est.non.seg.site = FALSE, max.init.iter = 50,
    init.procedure = .init.procedure[1],
    init.method = .init.method[1],
    substitution.model = .substitution.model$model[1],
    edist.model = .edist.model[1], identifier = .identifier[1],
    code.type = .code.type[1], em.method = .em.method[1],
    boundary.method = .boundary.method[1], min.n.class = 1,
    se.type = FALSE, se.model = .se.model[1], se.constant = 1e-2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".EMControl_+3A_exhaust.iter">exhaust.iter</code></td>
<td>
<p>number of iterations for &quot;exhaustEM&quot;, default = 1.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_fixed.iter">fixed.iter</code></td>
<td>
<p>number of iterations for &quot;RndpEM&quot;, default = 5.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_short.iter">short.iter</code></td>
<td>
<p>number of short-EM steps, default = 100.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_em.iter">EM.iter</code></td>
<td>
<p>number of long-EM steps, default = 1000.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_short.eps">short.eps</code></td>
<td>
<p>tolerance of short-EM steps, default = 1e-2.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_em.eps">EM.eps</code></td>
<td>
<p>tolerance of long-EM steps, default = 1e-6.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_cm.reltol">cm.reltol</code></td>
<td>
<p>relative tolerance for a CM step, default = 1e-8</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_cm.maxit">cm.maxit</code></td>
<td>
<p>maximum number iteration for a CM step, default = 5000.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_nm.abstol.mu.given.qa">nm.abstol.Mu.given.QA</code></td>
<td>
<p>see &lsquo;Details&rsquo;, default = 1e-8</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_nm.reltol.mu.given.qa">nm.reltol.Mu.given.QA</code></td>
<td>
<p>see &lsquo;Details&rsquo;, default = 1e-8</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_nm.maxit.mu.given.qa">nm.maxit.Mu.given.QA</code></td>
<td>
<p>see &lsquo;Details&rsquo;, default = 500.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_nm.abstol.qa.given.mu">nm.abstol.QA.given.Mu</code></td>
<td>
<p>see &lsquo;Details&rsquo;, default = 1e-8</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_nm.reltol.qa.given.mu">nm.reltol.QA.given.Mu</code></td>
<td>
<p>see &lsquo;Details&rsquo;, default = 1e-8</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_nm.maxit.qa.given.mu">nm.maxit.QA.given.Mu</code></td>
<td>
<p> see &lsquo;Details&rsquo;, default = 5000.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_est.non.seg.site">est.non.seg.site</code></td>
<td>
<p>estimate non-segregation sites, default = FALSE.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_max.init.iter">max.init.iter</code></td>
<td>
<p>maximum number of initialization iteration, default = 50.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_init.procedure">init.procedure</code></td>
<td>
<p>initialization procedure, default = &quot;exhaustEM&quot;.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_init.method">init.method</code></td>
<td>
<p>initialization method, default = &quot;randomMu&quot;.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_substitution.model">substitution.model</code></td>
<td>
<p>substitution model, default = &quot;JC69&quot;.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_edist.model">edist.model</code></td>
<td>
<p>evolution distance, default = <code>D_J69</code>.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_identifier">identifier</code></td>
<td>
<p>identifier, default = &quot;EE&quot;.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_code.type">code.type</code></td>
<td>
<p>code type, default = &quot;NUCLEOTIDE&quot;.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_em.method">em.method</code></td>
<td>
<p>EM method, default = &quot;EM&quot;.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_boundary.method">boundary.method</code></td>
<td>
<p>boundary method, default = <code>ADJUST</code>.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_min.n.class">min.n.class</code></td>
<td>
<p>minimum number of sequences in a cluster, default = 1.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_se.type">se.type</code></td>
<td>
<p>sequencing error type, default = FALSE.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_se.model">se.model</code></td>
<td>
<p>sequencing error model, default = &quot;CONVOLUTION&quot;.</p>
</td></tr>
<tr><td><code id=".EMControl_+3A_se.constant">se.constant</code></td>
<td>
<p>constrained constant, default = 1e-2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>exhaust.iter</code>, <code>fixed.iter</code>, <code>short.iter</code>, and
<code>short.eps</code> are used to control the iterations of initialization
procedures and methods.
</p>
<p><code>EM.iter</code> and <code>EM.eps</code> are used to control the EM iterations.
</p>
<p><code>cm.reltol</code> and <code>cm.maxit</code> are used to control the ECM
iterations.
</p>
<p>Arguments starting with <code>nm.</code> are options for the Nelder-Mead
method as in <code>optim</code>. The C codes of Nelder-Mead are modified
from the R math library and the options are all followed.
<code>abstol</code> and <code>reltol</code> are for absolute and relative tolerances. 
<code>Mu.given.QA</code> is for maximizing the profile function of
<code class="reqn">\mu_k</code> given <code class="reqn">Q_k</code>, and
<code>QA.given.Mu</code> is for maximizing the profile function of
<code class="reqn">Q_k</code> given <code class="reqn">\mu_k</code>.
</p>
<p><code>est.non.seg.site</code> indicates whether to estimate the states of
center sequences. If FALSE, the states will be fixed as the
non segregating sites. Usually, there is no need to estimate.
</p>
<p><code>max.init.iter</code> is for certain initialization methods, e.g.
<code>randomNJ</code> and <code>K-Medoids</code> need few tries to obtain an
appropriate initial state.
</p>
<p><code>init.procedure</code> and <code>init.method</code> are for initializations.
</p>
<p><code>min.n.class</code> is the minimum number of sequences in a cluster to
avoid bad initialization state and degenerated clusters.
</p>
<p><code>se.type</code>, <code>se.model</code>, and <code>se.constant</code> which are used only
for sequencing error models and only for nucleotide data without labels.
</p>


<h3>Value</h3>

<p>This function returns a list as <code>.EMC</code>. 
</p>
<p>The sequencing error controls are stored in
<code>se.type</code>, <code>se.model</code>, and <code>se.constant</code>, for
sequencing error type, model, and constrained constant of errors,
respectively.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.show.option">.show.option</a></code>,
<code><a href="#topic+.EMC">.EMC</a></code>,
<code><a href="#topic+.boundary.method">.boundary.method</a></code>,
<code><a href="#topic+.code.type">.code.type</a></code>,
<code><a href="#topic+.edist.model">.edist.model</a></code>,
<code><a href="#topic+.em.method">.em.method</a></code>,
<code><a href="#topic+.identifier">.identifier</a></code>,
<code><a href="#topic+.init.method">.init.method</a></code>,
<code><a href="#topic+.init.procedure">.init.procedure</a></code>,
<code><a href="#topic+.substitution.model">.substitution.model</a></code>,
<code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+phyclust.se">phyclust.se</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

# The same as .EMC
.EMControl()

# Except code.type, all others are the same as .EMC
.EMControl(code.type = "SNP")
.EMControl(code.type = .code.type[2])

## End(Not run)
</code></pre>

<hr>
<h2 id='.identifier'>Identifiers for Evolution Models</h2><span id='topic+.identifier'></span>

<h3>Description</h3>

<p>Identifiers for evolution models identify the <code class="reqn">Q_k</code> matrix and
evolution time <code class="reqn">t_k</code> for subpopulations.
The first element is the default value.
<strong>This is a read-only object and the elemental order is followed in C.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.identifier</code></pre>


<h3>Format</h3>

<p>A character vector contains implemented identifiers in C.
</p>


<h3>Details</h3>

<p>Four major identifiers are implemented in C, <code>EE</code>, <code>EV</code>,
<code>VE</code>, and <code>VV</code>. The first letter indicates the structure
for <code class="reqn">Q_k</code> matrix, and the second letter indicates the
evolution time <code class="reqn">t_k</code> for subpopulations. <code>E</code> and
<code>V</code> indicate equal and varied for all subpopulations.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.show.option">.show.option</a></code>,
<code><a href="#topic+.EMC">.EMC</a></code>,
<code><a href="#topic+.EMControl">.EMControl</a></code>,
<code><a href="#topic+phyclust">phyclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.identifier

## End(Not run)
</code></pre>

<hr>
<h2 id='.init.method'>Initialization Methods for EM Algorithms</h2><span id='topic+.init.method'></span>

<h3>Description</h3>

<p>The varied initialization methods are implemented in C.
The first element is the default value.
<strong>This is a read-only object and the elemental order is followed in C.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.init.method</code></pre>


<h3>Format</h3>

<p>A character vector contains implemented initialization methods in C.
</p>


<h3>Details</h3>

<p><code>randomMu</code>, <code>NJ</code>, <code>randomNJ</code>, <code>PAM</code>,
<code>K-Medoids</code> and <code>manualMu</code> are implemented where
the codes for the NJ are modified from <span class="pkg">ape</span>, and the codes
for the PAM method are modified from <span class="pkg">cluster</span>.
These methods are only provide initializations for EM algorithms.
</p>

<ul>
<li><p>'randomMu'randomly picks centers and assigns all sequences near by
the center according an evolution distance.
</p>
</li>
<li><p>'NJ'bases on a neighbor-joining tree and partitions the tree by
the long branches into subtrees to form clusters.
</p>
</li>
<li><p>'randomNJ'randomly partition a neighbor-joining tree into subtrees
to form clusters.
</p>
</li>
<li><p>'PAM'uses the partition around medoids algorithm
to locate the centers of dataset.
</p>
</li>
<li><p>'K-Medoids'performs K-Means types algorithms to randomly and roughly
locate centers and form clusters.
</p>
</li>
<li><p>'manualMu'requires a vector containing class ids for all sequences.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Saitou, N. and Nei, M. (1987),
&ldquo;The Neighbor-Joining Method: A New Method for Reconstructing
Phylogenetic Trees&rdquo;,
<em>Molecular Biology and Evolution</em>, <b>4:4</b>, 406-425.
</p>
<p>Kaufman, L. and Rousseeuw, P.J. (1990),
<em>Finding Groups in Data: An Introduction to Cluster Analysis</em>,
Wiley.
</p>
<p>Theodoridis, S. and Koutroumbas, K. (2006),
<em>Pattern Recognition</em>, 3rd ed., pp. 635.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.show.option">.show.option</a></code>,
<code><a href="#topic+.init.procedure">.init.procedure</a></code>,
<code><a href="#topic+.EMControl">.EMControl</a></code>,
<code><a href="#topic+phyclust">phyclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.init.method

## End(Not run)
</code></pre>

<hr>
<h2 id='.init.procedure'>Initialization Procedures for EM Algorithms</h2><span id='topic+.init.procedure'></span>

<h3>Description</h3>

<p>The varied initialization procedures are implemented in C.
The first element is the default value.
<strong>This is a read-only object and the elemental order is followed in C.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.init.procedure</code></pre>


<h3>Format</h3>

<p>A character vector contains implemented initialization procedures in C.
</p>


<h3>Details</h3>

<p><code>exhaustEM</code>, <code>emEM</code>, <code>RndEM</code>, and <code>RndpEM</code> are
implemented. Based on initialization states given by a initialization
method, see <code>.init.method</code> for more information. These procedures
will search a better starting states for final EM steps.
</p>

<ul>
<li><p>'exhaustEM'runs each initialization with EM steps
until convergent, and pick the best one of the
convergence as the return result.
</p>
</li>
<li><p>'emEM'uses few short EM steps to improve initialization, then
pick the best of initialization state for long EM steps,
and returns the final result.
</p>
</li>
<li><p>'RandEM'bases on initialization methods to generate initialization
states, the number is equal to short EM steps,
then pick the best of initialization state for long EM steps,
and returns the final result.
</p>
</li>
<li><p>'RandEM'bases on initialization methods to generate initialization
states and run a fixed number of EM steps,
until total steps exhaust short EM steps,
then pick the best of initialization state for long EM steps,
and returns the final result.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Biernacki, C. and Celeux, G. and Govaert, G. (2003)
&ldquo;Choosing starting values for the EM algorithm for getting the
highest likelihood in multivariate Gaussian mixture models&rdquo;,
<em>Computational Statistics and Data Analysis</em>, <b>41:3</b>, 561-575.
</p>
<p>Maitra, R. (2009)
&ldquo;Initializing partition-optimization algorithms&rdquo;,
<em>IEEE/ACM Transactions on Computational Biology and Bioinformatics</em>,
<b>6:1</b>, 114-157.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.show.option">.show.option</a></code>,
<code><a href="#topic+.init.method">.init.method</a></code>,
<code><a href="#topic+.EMControl">.EMControl</a></code>,
<code><a href="#topic+phyclust">phyclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.init.procedure

## End(Not run)
</code></pre>

<hr>
<h2 id='.label.method'>Label Method</h2><span id='topic+.label.method'></span>

<h3>Description</h3>

<p>An object stores label method for un-, semi-, and general semi-
supervised clustering..
<strong>This is a read-only object and the elemental order is followed in C.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.label.method</code></pre>


<h3>Format</h3>

<p>A character vector contains implemented evolution distances in C.
</p>


<h3>Details</h3>

<p>This vector stores possible label methods implemented in <span class="pkg">phyclust</span>.
The default value is <code>NONE</code> for unsupervised clustering.
<code>SEMI</code> is for semi-supervised clustering, and
<code>GENERAL</code> is for general semi-supervised clustering.
Only un- and semi-supervised clustering are implemented.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust">phyclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.label.method

## End(Not run)
</code></pre>

<hr>
<h2 id='.se.model'>Sequencing Error Model</h2><span id='topic+.se.model'></span>

<h3>Description</h3>

<p>An object stores sequencing error models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.se.model</code></pre>


<h3>Format</h3>

<p>A character vector contains all possible sequencing models. 
</p>


<h3>Details</h3>

<p>Currently, only a <code>CONVOLUTION</code> model is implemented.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.show.option">.show.option</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.se.model

## End(Not run)
</code></pre>

<hr>
<h2 id='.show.option'>Show Available Options</h2><span id='topic+.show.option'></span>

<h3>Description</h3>

<p>This function show available options for functions in <span class="pkg">phyclust</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  .show.option()
</code></pre>


<h3>Details</h3>

<p>This function show some available options for functions in <span class="pkg">phyclust</span>.
They are used in <code>.EMControl</code>, <code>phyclust</code>, ... etc, and
options are stored in several objects separately. They will be passed 
into C, so the elemental order are important. Basically, they are all
read-only objects.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.boundary.method">.boundary.method</a></code>,
<code><a href="#topic+.code.type">.code.type</a></code>,
<code><a href="#topic+.edist.model">.edist.model</a></code>,
<code><a href="#topic+.em.method">.em.method</a></code>,
<code><a href="#topic+.EMC">.EMC</a></code>,
<code><a href="#topic+.EMControl">.EMControl</a></code>,
<code><a href="#topic+.identifier">.identifier</a></code>,
<code><a href="#topic+.init.method">.init.method</a></code>,
<code><a href="#topic+.init.procedure">.init.procedure</a></code>,
<code><a href="#topic+.nucleotide">.nucleotide</a></code>,
<code><a href="#topic+.snp">.snp</a></code>,
<code><a href="#topic+.substitution.model">.substitution.model</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.show.option()

## End(Not run)
</code></pre>

<hr>
<h2 id='.substitution.model'>Substitution Models for Mutation Processes</h2><span id='topic+.substitution.model'></span>

<h3>Description</h3>

<p>An object stores substitution models for mutation processes
for Continuous Time Markov Chain theory.
<strong>This is a read-only object and the elemental order is followed in C.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.substitution.model</code></pre>


<h3>Format</h3>

<p>A data frame contains two character vectors, <code>mode</code> and <code>code.type</code>.
</p>


<h3>Details</h3>

<p>This data frame indicates substitution models implemented in C.
</p>

<ul>
<li><p> 'model': names of substitution models for mutations.
</p>
</li>
<li><p> 'code.type': code types of substitution models, either NUCLEOTIDE or SNP.
</p>
</li></ul>

<p>The major models are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    Model </td><td style="text-align: left;"> Author and Publication            </td><td style="text-align: left;"> Parameter </td>
</tr>
<tr>
 <td style="text-align: left;">
    JC69  </td><td style="text-align: left;"> Jukes and Cantor 1969.            </td><td style="text-align: left;"> <code class="reqn">t</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    K80   </td><td style="text-align: left;"> Kimura 1980.                      </td><td style="text-align: left;"> <code class="reqn">\kappa, t</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    F81   </td><td style="text-align: left;"> Felsenstein 1981.                 </td><td style="text-align: left;"> <code class="reqn">\pi, t</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    HKY85 </td><td style="text-align: left;"> Hasegawa, Kishino, and Yano 1985. </td><td style="text-align: left;"> <code class="reqn">\pi, \kappa, t</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Other models starting with <code>E_</code> use empirical frequencies for
equilibrium probabilities.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Jukes, T. H. and Cantor, C. R. (1969)
&ldquo;Evolution of Protein Molecules&rdquo;,
<em>Mammalian Protein Metabolism</em>, <b>3</b>, 21-132
</p>
<p>Kimura, M. (1980)
&ldquo;A Simple Method for Estimating Evolutionary Rates of Base
Substitutions through Comparative Studies of Nucleotide Sequences&rdquo;,
<em>Journal of Molecular Evolution</em>, <b>16</b>, 111-120
</p>
<p>Felsenstein, J. (1981)
&ldquo;Evolutionary Trees from DNA Sequences: A Maximum Likelihood
Approach&rdquo;,
<em>Journal of Molecular Evolution</em>, <b>17</b>, 368-376
</p>
<p>Hasegawa, M. and Kishino, H. and Yano, T. (1985)
&ldquo;Dating of the Human-Ape Splitting by a Molecular Clock of
Mitochondrial DNA&rdquo;,
<em>Journal of Molecular Evolution</em>, <b>22:2</b>, 160-174
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.show.option">.show.option</a></code>,
<code><a href="#topic+.code.type">.code.type</a></code>,
<code><a href="#topic+.identifier">.identifier</a></code>,
<code><a href="#topic+.EMControl">.EMControl</a></code>,
<code><a href="#topic+phyclust">phyclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.substitution.model

## End(Not run)
</code></pre>

<hr>
<h2 id='all.internal'> All Internal Functions of phyclust </h2><span id='topic+bootstrap.merge.seq'></span><span id='topic+bootstrap.star.tree'></span><span id='topic+bootstrap.seq.nucleotide'></span><span id='topic+bootstrap.seq.snp'></span><span id='topic+check.EMC'></span><span id='topic+check.label'></span><span id='topic+convert.QA.to.vect'></span><span id='topic+my.cat'></span><span id='topic+my.format'></span><span id='topic+my.print'></span><span id='topic+plotfd'></span><span id='topic+plothist.my'></span><span id='topic+translate.EMC'></span><span id='topic+translate.EMC.se'></span><span id='topic+translate.ret'></span><span id='topic+translate.ret.se'></span><span id='topic+unstrsplit'></span><span id='topic+code2nid.default'></span><span id='topic+code2nid.list'></span><span id='topic+nid2code.default'></span><span id='topic+nid2code.list'></span><span id='topic+code2snp.default'></span><span id='topic+code2snp.list'></span><span id='topic+snp2code.default'></span><span id='topic+snp2code.list'></span><span id='topic+sid2snp.default'></span><span id='topic+sid2snp.list'></span><span id='topic+snp2sid.default'></span><span id='topic+snp2sid.list'></span><span id='topic+nid2aid.default'></span><span id='topic+nid2aid.list'></span><span id='topic+nid2cid.default'></span><span id='topic+nid2cid.list'></span><span id='topic+cid2aid.default'></span><span id='topic+cid2aid.list'></span><span id='topic+aid2acode.default'></span><span id='topic+aid2acode.list'></span><span id='topic+acode2aid.default'></span><span id='topic+acode2aid.list'></span>

<h3>Description</h3>

<p>See <code>all.internal.tzeng</code> for Tzeng's methods (2005).
</p>
<p>The following are all internal functions: <br />
<code>bootstrap.merge.seq</code>,
<code>bootstrap.star.tree</code>, <br />
<code>bootstrap.seq.nucleotide</code>,
<code>bootstrap.seq.snp</code>, <br />
<code>check.EMC</code>,
<code>check.label</code>,
<code>convert.QA.to.vect</code>, <br />
<code>my.cat</code>,
<code>my.format</code>, <br />
<code>my.print</code>,
<code>plotfd</code>, <br />
<code>plothist.my</code>,
<code>translate.EMC</code>, <br />
<code>translate.ret</code>,
<code>unstrsplit</code>.
</p>
<p>The following are all S3 methods: <br />
<code>code2nid.default</code>,
<code>code2nid.list</code>, <br />
<code>nid2code.default</code>,
<code>nid2code.list</code>, <br />
<code>code2snp.default</code>,
<code>code2snp.list</code>, <br />
<code>snp2code.default</code>,
<code>snp2code.list</code>, <br />
<code>sid2snp.default</code>,
<code>sid2snp.list</code>, <br />
<code>snp2sid.default</code>,
<code>snp2sid.list</code>, <br />
<code>nid2aid.default</code>,
<code>nid2aid.list</code>, <br />
<code>nid2cid.default</code>,
<code>nid2cid.list</code>, <br />
<code>cid2aid.default</code>,
<code>cid2aid.list</code>, <br />
<code>aid2acode.default</code>,
<code>aid2acode.list</code>, <br />
<code>acode2aid.default</code>,
<code>acode2aid.list</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>

<hr>
<h2 id='all.internal.tzeng'> All Internal Functions of Tzeng's Methods </h2><span id='topic+.tzengEnv'></span><span id='topic+chkdim.Add.fun'></span><span id='topic+chkdim.Multiply.fun'></span><span id='topic+construct.bigB.dPI'></span><span id='topic+construct.dB.list.fun'></span><span id='topic+final.BigMatB.fun'></span><span id='topic+final.BigMatB.matC.fun'></span><span id='topic+get.allpossROUTE.fun'></span><span id='topic+get.BB.fun'></span><span id='topic+get.deriBigMatB.fun'></span><span id='topic+get.fullBB.fun'></span><span id='topic+get.I.fun'></span><span id='topic+get.ini.possHap.hapReserv.fun'></span><span id='topic+get.medBB.skip.fun'></span><span id='topic+get.preBB.skip.fun'></span><span id='topic+get.step.mut.fun'></span><span id='topic+get.subPI.fun'></span><span id='topic+getBigMatB.fun'></span><span id='topic+getI13.fun'></span><span id='topic+getPIstar.fun'></span><span id='topic+haplo.phase.known'></span><span id='topic+I33Inv.fun'></span><span id='topic+index.k.fun'></span><span id='topic+zero.mat.fun'></span>

<h3>Description</h3>

<p>See <code>all.internal</code> for phyclust.
</p>
<p><code>chkdim.Add.fun</code>,
<code>chkdim.Multiply.fun</code>, <br />
<code>construct.bigB.dPI</code>,
<code>construct.dB.list.fun</code>, <br />
<code>final.BigMatB.fun</code>,
<code>final.BigMatB.matC.fun</code>, <br />
<code>get.allpossROUTE.fun</code>,
<code>get.BB.fun</code>, <br />
<code>get.deriBigMatB.fun</code>,
<code>get.fullBB.fun</code>, <br />
<code>get.I.fun</code>,
<code>get.ini.possHap.hapReserv.fun</code>, <br />
<code>get.medBB.skip.fun</code>, <br />
<code>get.preBB.skip.fun</code>,
<code>get.step.mut.fun</code>, <br />
<code>get.subPI.fun</code>,
<code>getBigMatB.fun</code>, <br />
<code>getI13.fun</code>,
<code>getPIstar.fun</code>, <br />
<code>haplo.phase.known</code>,
<code>I33Inv.fun</code>,
<code>index.k.fun</code>, <br />
<code>zero.mat.fun</code>.
</p>


<h3>Author(s)</h3>

<p>Jung-Ying Tzeng
</p>
<p>Maintain: Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Tzeng, J.Y. (2005)
&ldquo;Evolutionary-Based Grouping of Haplotypes in Association Analysis&rdquo;,
<em>Genetics Epidemiology</em>, <b>28</b>, 220-231.
<a href="https://www4.stat.ncsu.edu/~jytzeng/software.php">https://www4.stat.ncsu.edu/~jytzeng/software.php</a>
</p>

<hr>
<h2 id='as.star.tree'>Coerce a Rooted Tree to a Star Tree in Class phylo</h2><span id='topic+as.star.tree'></span><span id='topic+Class+20phylo'></span>

<h3>Description</h3>

<p>Coerce a rooted tree generating by <code>ms</code> to a star tree and
maintain a bifurcation structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.star.tree(rooted.tree, keep.bifurcation = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.star.tree_+3A_rooted.tree">rooted.tree</code></td>
<td>
<p>a rooted tree in <code>Class phylo</code>.</p>
</td></tr>
<tr><td><code id="as.star.tree_+3A_keep.bifurcation">keep.bifurcation</code></td>
<td>
<p>keep a bifurcation structure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tree with a star shape means that all internal branches are 0 and
all leaf branches are equal.
</p>
<p>The <code>rooted.tree</code> should be in a <code>phylo</code> class of <span class="pkg">ape</span>,
and may be created by <code>ms</code>.
</p>
<p>Basically, it is a list with an attribute that the class is phylo, and
the other elements are:
</p>

<ul>
<li><p>'edge'edge ids.
</p>
</li>
<li><p>'Nnode'number of internal nodes.
</p>
</li>
<li><p>'tip.lab'number of tips (leaves).
</p>
</li>
<li><p>'edge.length'length of edges.
</p>
</li></ul>

<p>If <code>keep.bifurcation</code> is TRUE, then internal branches are set to be 0
and leaves branches are set to the original tree height. Otherwise,
the internal branches will be dropped from rooted.tree.
</p>


<h3>Value</h3>

<p>Return a rooted tree in <code>Class phylo</code> with a star shape.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ms">ms</a></code>,
<code><a href="ape.html#topic+read.tree">read.tree</a></code>,
<code><a href="ape.html#topic+as.phylo">as.phylo</a></code>,
<code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
ret.ms &lt;- ms(5, 1, opts = paste("-T", sep = " "))
tree.ms &lt;- read.tree(text = ret.ms[3])
str(tree.ms)
(tree.star &lt;- as.star.tree(tree.ms))

# Plot results
par(mfrow = c(1, 2))
plot(tree.ms, type = "u", main = "original tree")
plot(tree.star, type = "u", main = "as star tree")

## End(Not run)
</code></pre>

<hr>
<h2 id='bootstrap.seq'>Bootstrap Sequences from a Fitted Model and Star Tree.</h2><span id='topic+bootstrap.seq'></span>

<h3>Description</h3>

<p>This function bootstraps sequences from a model fitted by <code>phyclust</code>
and star trees generated by <code>bootstrap.star.trees</code>.
The fitted model can be varied in <code>.identifier</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap.seq(ret.phyclust, star.trees)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap.seq_+3A_ret.phyclust">ret.phyclust</code></td>
<td>
<p>a phyclust object in <code>Class phyclust</code>.</p>
</td></tr>
<tr><td><code id="bootstrap.seq_+3A_star.trees">star.trees</code></td>
<td>
<p>star trees might be generated by <code>bootstrap.star.trees</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ret.phyclust</code> is a phyclust object in <code>Class phyclust</code> which is usually
fitted by <code>phyclust</code>, or returned by <code>phyclust.m.step</code>.
</p>
<p><code>star.trees</code> should be corresponding to the <code>ret.phyclust</code> which might
be directly bootstrapped from the function <code>bootstrap.star.trees</code>.
</p>


<h3>Value</h3>

<p>Return a list containing sequences in <code class="reqn">K</code> clusters.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+bootstrap.star.trees">bootstrap.star.trees</a></code>,
<code><a href="#topic+bootstrap.star.trees.seq">bootstrap.star.trees.seq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
EMC.1 &lt;- .EMC
EMC.1$EM.iter &lt;- 1
# the same as EMC.1 &lt;- .EMControl(EM.iter = 1)

ret.1 &lt;- phyclust(seq.data.toy$org, 2, EMC = EMC.1)
ret.tree &lt;- bootstrap.star.trees(ret.1)
ret.seq &lt;- bootstrap.seq(ret.1, ret.tree)

## End(Not run)
</code></pre>

<hr>
<h2 id='bootstrap.seq.data'>Bootstrap a seq.data from a Fitted Model.</h2><span id='topic+bootstrap.seq.data'></span>

<h3>Description</h3>

<p>This function simplifies the bootstrap function
<code>bootstrap.star.trees.seq()</code>, and only
return a list object with class <code>seq.data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap.seq.data(ret.phyclust, min.n.class = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap.seq.data_+3A_ret.phyclust">ret.phyclust</code></td>
<td>
<p>a phyclust object in <code>Class phyclust</code>.</p>
</td></tr>
<tr><td><code id="bootstrap.seq.data_+3A_min.n.class">min.n.class</code></td>
<td>
<p>minimum number of sequences for a cluster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ret.phyclust</code> is a phyclust object in <code>Class phyclust</code> which is usually
fitted by <code>phyclust</code>, or returned by <code>phyclust.m.step</code>.
</p>
<p><code>min.n.class</code> is a boundary condition to avoid degenerate clusters
when some population proportions, <code class="reqn">\eta_k</code>, are small in the
fitted model.
</p>


<h3>Value</h3>

<p>Return an object in <code>Class seq.data</code> as
the result from <code>read.*()</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+bootstrap.star.trees">bootstrap.star.trees</a></code>,
<code><a href="#topic+Class+20seq.data">Class seq.data</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
EMC.1 &lt;- .EMC
EMC.1$EM.iter &lt;- 1
# the same as EMC.1 &lt;- .EMControl(EM.iter = 1)

ret.1 &lt;- phyclust(seq.data.toy$org, 2, EMC = EMC.1)
(ret.all &lt;- bootstrap.seq.data(ret.1))

## End(Not run)
</code></pre>

<hr>
<h2 id='bootstrap.star.trees'>Bootstrap a Star Tree from a Fitted Model.</h2><span id='topic+bootstrap.star.trees'></span>

<h3>Description</h3>

<p>This function bootstraps a star tree from a model fitted by <code>phyclust</code>.
Each cluster corresponds to a star tree and a center sequence where
sequences will evolve from. This function is called by
<code>bootstrap.star.trees.seq</code> to generate sequences.
The fitted model can be varied in <code>.identifier</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap.star.trees(ret.phyclust, min.n.class = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap.star.trees_+3A_ret.phyclust">ret.phyclust</code></td>
<td>
<p>a phyclust object in <code>Class phyclust</code>.</p>
</td></tr>
<tr><td><code id="bootstrap.star.trees_+3A_min.n.class">min.n.class</code></td>
<td>
<p>minimum number of sequences for a cluster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ret.phyclust</code> is a phyclust object in <code>Class phyclust</code> which is usually
fitted by <code>phyclust</code>, or returned by <code>phyclust.m.step</code>.
</p>
<p><code>min.n.class</code> is a boundary condition to avoid degenerate clusters
when some population proportions, <code class="reqn">\eta_k</code>, are small in the
fitted model.
</p>


<h3>Value</h3>

<p>Return a list containing <code class="reqn">K</code> star trees according to <code>ret.phyclust</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+bootstrap.seq">bootstrap.seq</a></code>,
<code><a href="#topic+bootstrap.star.trees.seq">bootstrap.star.trees.seq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
EMC.1 &lt;- .EMC
EMC.1$EM.iter &lt;- 1
# the same as EMC.1 &lt;- .EMControl(EM.iter = 1)

ret.1 &lt;- phyclust(seq.data.toy$org, 2, EMC = EMC.1)
ret.trees &lt;- bootstrap.star.trees(ret.1)

## End(Not run)
</code></pre>

<hr>
<h2 id='bootstrap.star.trees.seq'>Bootstrap Sequences from a Fitted Model.</h2><span id='topic+bootstrap.star.trees.seq'></span>

<h3>Description</h3>

<p>This function bootstraps sequences from a model fitted by <code>phyclust</code>
by combining two functions <code>bootstrap.star.trees</code> and
<code>bootstrap.seq</code>.
The fitted model can be varied in <code>.identifier</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap.star.trees.seq(ret.phyclust, min.n.class = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap.star.trees.seq_+3A_ret.phyclust">ret.phyclust</code></td>
<td>
<p>a phyclust object in <code>Class phyclust</code>.</p>
</td></tr>
<tr><td><code id="bootstrap.star.trees.seq_+3A_min.n.class">min.n.class</code></td>
<td>
<p>minimum number of sequences for a cluster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ret.phyclust</code> is a phyclust object in <code>Class phyclust</code> which is usually
fitted by <code>phyclust</code>, or returned by <code>phyclust.m.step</code>.
</p>
<p><code>min.n.class</code> is a boundary condition to avoid degenerate clusters
when some population proportions, <code class="reqn">\eta_k</code>, are small in the
fitted model.
</p>


<h3>Value</h3>

<p>Return a list containing two elements, and both are corresponding to the
model of <code>ret.phyclust</code>, including:
</p>
<table>
<tr><td><code>trees</code></td>
<td>
<p>a list, <code class="reqn">K</code> star trees according to <code>ret.phyclust</code></p>
</td></tr>
<tr><td><code>seq</code></td>
<td>
<p>a list, sequences in <code class="reqn">K</code> clusters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+bootstrap.star.trees">bootstrap.star.trees</a></code>,
<code><a href="#topic+bootstrap.seq">bootstrap.seq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
EMC.1 &lt;- .EMC
EMC.1$EM.iter &lt;- 1
# the same as EMC.1 &lt;- .EMControl(EM.iter = 1)

ret.1 &lt;- phyclust(seq.data.toy$org, 2, EMC = EMC.1)
ret.all &lt;- bootstrap.star.trees.seq(ret.1)

## End(Not run)
</code></pre>

<hr>
<h2 id='code2nid'>Transfer Codes (A, G, C, T, -) and nids (0, 1, 2, 3, 4)</h2><span id='topic+code2nid'></span><span id='topic+nid2code'></span>

<h3>Description</h3>

<p>Transfer nucleotide codes (A, G, C, T, -) and nucleotide ids (0, 1, 2, 3, 4).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>### S3 methods for a list, vector or matrix (default).
code2nid(codeseq)
nid2code(nidseq, lower.case = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="code2nid_+3A_codeseq">codeseq</code></td>
<td>
<p>a character vector contains nucleotide codes, A, G, C, T, or -.</p>
</td></tr>
<tr><td><code id="code2nid_+3A_nidseq">nidseq</code></td>
<td>
<p>a numerical vector contains nucleotide ids, 0, 1, 2, 3, or 4.</p>
</td></tr>
<tr><td><code id="code2nid_+3A_lower.case">lower.case</code></td>
<td>
<p>transfer in lower cases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are based on the internal object <code>.nucleotide</code> to
transfer codes and nids.
</p>


<h3>Value</h3>

<p><code>code2nid</code> returns a numerical vector containing nucleotide ids, and
<code>nid2code</code> returns a character vector containing nucleotide codes. 
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.nucleotide">.nucleotide</a></code>,
<code><a href="#topic+snp2sid">snp2sid</a></code>,
<code><a href="#topic+sid2snp">sid2snp</a></code>,
<code><a href="#topic+code2snp">code2snp</a></code>,
<code><a href="#topic+snp2code">snp2code</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

a &lt;- c("A", "C", "G", "-", "T")
code2nid(a)
nid2code(code2nid(a)) 

## End(Not run)
</code></pre>

<hr>
<h2 id='code2snp'>Transfer Nucleotide Codes / nids and SNPs / sids</h2><span id='topic+code2snp'></span><span id='topic+snp2code'></span><span id='topic+nid2sid'></span><span id='topic+sid2nid'></span>

<h3>Description</h3>

<p>Transfer nucleotide codes (A, G, C, T, -) and SNPs (1, 2, -).
Transfer nucleotide ids (0, 1, 2, 3, 4) and SNP ids (0, 1, 2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>### S3 methods for a list, vector or matrix (default).
code2snp(codeseq)
snp2code(snpseq, half = TRUE)

nid2sid(nidseq)
sid2nid(sidseq, half = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="code2snp_+3A_codeseq">codeseq</code></td>
<td>
<p>a character vector contains nucleotide codes, A, G, C, T, or -.</p>
</td></tr>
<tr><td><code id="code2snp_+3A_snpseq">snpseq</code></td>
<td>
<p>a character vector contains SNPs, 1, 2, or -.</p>
</td></tr>
<tr><td><code id="code2snp_+3A_half">half</code></td>
<td>
<p>nucleotide codes will be half assigned, see the &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="code2snp_+3A_nidseq">nidseq</code></td>
<td>
<p>a numerical vector contains nucleotide ids, 0, 1, 2, 3, or 4.</p>
</td></tr>
<tr><td><code id="code2snp_+3A_sidseq">sidseq</code></td>
<td>
<p>a numerical vector contains SNP ids, 0, 1, or 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are based on the internal object <code>.nucleotide</code> and 
<code>.snp</code> to transfer nucleotide codes and SNPs.
For <code>code2snp</code>, A, G are transfered to 1, and C, T are transfered to 2.
For <code>snp2code</code>, 1 is transfered half to A and G, and 2 is transfered
half to C and T if <code>half = TRUE</code>. Otherwise, 1 is all transfered to A,
and 2 is all transfered to C.
</p>


<h3>Value</h3>

<p><code>code2nid</code> returns a character vector containing nucleotide ids, and
<code>nid2code</code> returns a character vector containing nucleotide codes. 
</p>
<p><code>nid2sid</code> returns a numerical vector containing SNP ids, and
<code>sid2nid</code> returns a numerical vector containing nucleotide ids.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.nucleotide">.nucleotide</a></code>,
<code><a href="#topic+.snp">.snp</a></code>,
<code><a href="#topic+code2nid">code2nid</a></code>,
<code><a href="#topic+nid2code">nid2code</a></code>,
<code><a href="#topic+snp2sid">snp2sid</a></code>,
<code><a href="#topic+sid2snp">sid2snp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

# For codes
a.vector &lt;- c("A", "C", "G", "-", "T")
code2snp(a.vector)
snp2code(code2snp(a.vector))
snp2code(code2snp(a.vector), half = FALSE)

# For ids
a.sid.vector &lt;- c(0, 2, 1, 4, 3)
nid2sid(a.sid.vector)
sid2nid(nid2sid(a.sid.vector))
sid2nid(nid2sid(a.sid.vector), half = FALSE)

# Test list
a.list &lt;- list(a, a)
code2snp(a.list)
snp2code(code2snp(a.list))
snp2code(code2snp(a.list), half = FALSE)

# Test matrix
a.matrix &lt;- rbind(a, a)
code2snp(a.matrix)
snp2code(code2snp(a.matrix))
snp2code(code2snp(a.matrix), half = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='data.fasta.pony'>Great Pony 625 EIAV rev Dataset in the Fasta Format</h2><span id='topic+Data+20Pony+20625'></span><span id='topic+Format+20fasta'></span>

<h3>Description</h3>

<p>Great pony 625 EIAV dataset is published by Baccam, P., et al. (2003),
and they are also available on NCBI database.
This is a follow-up study of <code>Data Pony 618</code>.
</p>


<h3>Format</h3>

<p>A text file in fasta format is stored in the data subdirectory.
</p>


<h3>Details</h3>

<p>EIAV rev dataset contains 62 nucleotide sequences and 406 sites.
</p>


<h3>Author(s)</h3>

<p>Baccam, P., et al. (2003).
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Baccam, P., et al. (2003)
&ldquo;Subpopulations of Equine Infectious Anemia Virus Rev Coexist
In Vivo and Differ in Phenotype&rdquo;,
<em>Journal of Virology</em>, <b>77</b>, 12122-12131.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.phylip">read.phylip</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

data.path &lt;- paste(.libPaths()[1], "/phyclust/data/pony625.fas", sep = "")
# edit(file = data.path)
my.pony.625 &lt;- read.fasta(data.path)
str(my.pony.625)

## End(Not run)
</code></pre>

<hr>
<h2 id='data.phylip.crohn'>Crohn's Disease SNP Dataset in the phylip Format</h2><span id='topic+Data+20Crohn+27s+20Disease'></span>

<h3>Description</h3>

<p>Crohn's disease dataset is published by Hugot, et al. (2001).
</p>


<h3>Format</h3>

<p>A text file in phylip format is stored in the data subdirectory.
</p>


<h3>Details</h3>

<p>Crohn's disease dataset is used to perform haplotype grouping used
in Tzeng's paper (2005).
</p>
<p>Totally, 1102 haplotypes/SNP sequences and 8 sites.
</p>


<h3>Author(s)</h3>

<p>Hugot, J.P., et al. (2001).
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Hugot, J.P., et al. (2001)
&ldquo;Association of NOD2 Leucine-Rich Repeat Variants with
Susceptibility to Crohn's Disease&rdquo;,
<em>Nature</em>, <b>411</b>, 599-603.
</p>
<p>Tzeng, J.Y. (2005)
&ldquo;Evolutionary-Based Grouping of Haplotypes in Association Analysis&rdquo;,
<em>Genetics Epidemiology</em>, <b>28</b>, 220-231.
<a href="https://www4.stat.ncsu.edu/~jytzeng/software.php">https://www4.stat.ncsu.edu/~jytzeng/software.php</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.phylip">read.phylip</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

data.path &lt;- paste(.libPaths()[1], "/phyclust/data/crohn.phy", sep = "")
# edit(file = data.path)
my.snp &lt;- read.phylip(data.path, code.type = "SNP")
str(my.snp)

## End(Not run)
</code></pre>

<hr>
<h2 id='data.phylip.pony'>Great Pony 524 EIAV rev Dataset in the phylip Format</h2><span id='topic+Data+20Pony+20524'></span><span id='topic+Format+20phylip'></span>

<h3>Description</h3>

<p>Great pony 524 EIAV dataset is published by Baccam, P., et al. (2003),
and they are also available on NCBI database.
There is a follow-up study, <code>Data Pony 625</code>.
</p>


<h3>Format</h3>

<p>A text file in phylip format is stored in the data subdirectory.
</p>


<h3>Details</h3>

<p>EIAV rev dataset contains 146 nucleotide sequences and 405 sites.
</p>


<h3>Author(s)</h3>

<p>Belshan, M., et al. (2001).
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Belshan, M., et al. (2001)
&ldquo;Genetic and Biological Variation in Equine Infectious Anemia
Virus Rev Correlates with Variable Stages of Clinical Disease
in an Experimentally Infected Pony&rdquo;,
<em>Virology</em>, <b>279</b>, 185-200.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.fasta">read.fasta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

data.path &lt;- paste(.libPaths()[1], "/phyclust/data/pony524.phy", sep = "")
# edit(file = data.path)
my.pony.524 &lt;- read.phylip(data.path)
str(my.pony.524)

## End(Not run)
</code></pre>

<hr>
<h2 id='file.read'>Read Data from Files by Formats and Return a seq.data Object</h2><span id='topic+read.fasta'></span><span id='topic+read.fasta.format'></span><span id='topic+read.phylip'></span><span id='topic+read.phylip.format'></span>

<h3>Description</h3>

<p>Two major file formats are supported in <span class="pkg">phyclust</span>,
<code>Format phylip</code> and <code>Format fasta</code>.
<strong>These functions only read files in basic syntax</strong>, and
return an object in <code>Class seq.data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fasta(filename, byrow = TRUE, code.type = .code.type[1], aligned = TRUE,
           sep = "")
read.fasta.format(filename, byrow = TRUE, aligned = TRUE, sep = "")

read.phylip(filename, byrow = TRUE, code.type = .code.type[1], sep = "")
read.phylip.format(filename, byrow = TRUE, sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file.read_+3A_filename">filename</code></td>
<td>
<p>a file name where data is read from.</p>
</td></tr>
<tr><td><code id="file.read_+3A_byrow">byrow</code></td>
<td>
<p>advanced option, default = TRUE.</p>
</td></tr>
<tr><td><code id="file.read_+3A_code.type">code.type</code></td>
<td>
<p>either &quot;NUCLEOTIDE&quot; (default) or &quot;SNP&quot;.</p>
</td></tr>
<tr><td><code id="file.read_+3A_aligned">aligned</code></td>
<td>
<p>indicate aligned data.</p>
</td></tr>
<tr><td><code id="file.read_+3A_sep">sep</code></td>
<td>
<p>use to split sites, &quot;&quot; (default) and &quot;,&quot; for &quot;CODON&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For unaligned sequences, <code>read.fasta</code> returns a list storing data.
<code>read.phylip</code> is only for aligned data and returns a matrix.
</p>
<p><code>read.fasta.format</code> and <code>read.phylip.format</code> will read in
original coding without any transformation as <code>code.type = NULL</code>
in <code>write.fasta</code> and <code>write.phylip</code>. Suppose these functions
return an object <code>ret</code>, one can write other functions <code>ret2aa()</code>
to post transform the coding and replace <code>ret$org</code> by the results of
<code>ret2aa(ret$org.code)</code>.
</p>
<p><code>byrow</code> indicates the data will be store by row or not. Usually,
the default is TRUE. The FALSE is only for advance users
with careful manipulations and for speeding up the bootstraps.
</p>
<p><code>sep</code> can specify a character which is used to split sites in file.
By default, &quot;&quot; denote no character between sites. Only &quot;CODON&quot; id requires
a character to avoid ambiguity
</p>


<h3>Value</h3>

<p>Return an object in <code>Class seq.data</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.fasta">write.fasta</a></code>,
<code><a href="#topic+write.phylip">write.phylip</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

# PHYLIP
data.path &lt;- paste(.libPaths()[1], "/phyclust/data/crohn.phy", sep = "")
(my.snp &lt;- read.phylip(data.path, code.type = "SNP"))

# FASTA
data.path &lt;- paste(.libPaths()[1], "/phyclust/data/pony625.fas", sep = "")
(my.pony &lt;- read.fasta(data.path))

## End(Not run)
</code></pre>

<hr>
<h2 id='file.write'>Write Data to Files by Formats</h2><span id='topic+write.fasta'></span><span id='topic+write.fasta.format'></span><span id='topic+write.phylip'></span><span id='topic+write.phylip.format'></span><span id='topic+write.paml'></span><span id='topic+write.paml.format'></span>

<h3>Description</h3>

<p>Two major file formats are supported in <span class="pkg">phyclust</span>,
<code>Format phylip</code> and <code>Format fasta</code>.
<strong>These functions only write files in basic syntax.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fasta(seqdata, filename, classid = NULL, seqname = NULL,
    width.line = 60, lower.case = FALSE, code.type = .code.type[1],
    sep = "")
write.fasta.format(seqdata, filename, classid = NULL, seqname = NULL,
    width.line = 60, sep = "")

write.phylip(seqdata, filename, classid = NULL, seqname = NULL,
    width.seqname = 10, width.line = 60, lower.case = FALSE,
    code.type = .code.type[1], sep = "")

write.phylip.format(seqdata, filename, classid = NULL, seqname = NULL,
    width.seqname = 10, width.line = 60, sep = "")


write.paml(seqdata, filename, classid = NULL, seqname = NULL,
    width.seqname = 10, width.line = 60, lower.case = FALSE,
    code.type = .code.type[1], sep = "")
write.paml.format(seqdata, filename, classid = NULL, seqname = NULL,
    width.seqname = 10, width.line = 60, sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file.write_+3A_seqdata">seqdata</code></td>
<td>
<p>a matrix contains sequence ids as <code>X</code> in <code>phyclust</code>.</p>
</td></tr>
<tr><td><code id="file.write_+3A_filename">filename</code></td>
<td>
<p>a file name where data is written to.</p>
</td></tr>
<tr><td><code id="file.write_+3A_classid">classid</code></td>
<td>
<p>class id of sequences.</p>
</td></tr>
<tr><td><code id="file.write_+3A_seqname">seqname</code></td>
<td>
<p>sequence names.</p>
</td></tr>
<tr><td><code id="file.write_+3A_width.seqname">width.seqname</code></td>
<td>
<p>number of characters of sequence names to be stored.</p>
</td></tr>
<tr><td><code id="file.write_+3A_width.line">width.line</code></td>
<td>
<p>width of lines for breaking lines.</p>
</td></tr>
<tr><td><code id="file.write_+3A_lower.case">lower.case</code></td>
<td>
<p>use lower case of letters to write</p>
</td></tr>
<tr><td><code id="file.write_+3A_code.type">code.type</code></td>
<td>
<p>either &quot;NUCLEOTIDE&quot; (default) or &quot;SNP&quot;.</p>
</td></tr>
<tr><td><code id="file.write_+3A_sep">sep</code></td>
<td>
<p>a character to split sites, &quot;&quot; (default) and &quot;,&quot; for &quot;CODON&quot;.</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>write.fasta</code>, <code>write.phylip</code>, and <code>write.paml</code> are general
functions call <code>write.fasta.format</code>, <code>write.phylip.format</code> and
<code>write.paml.format</code>.
</p>
<p><code>write.fasta.format</code>, <code>write.phylip.format</code>, and
<code>wirte.paml.format</code> will not do any transformation for input sequences,
but directly write them into the file as <code>code.type = NULL</code> in
<code>write.fasta</code>, <code>write.phylip</code> and <code>write.paml</code>.
</p>
<p>Note that PAML uses one of PHYLIP format to deal with sequence files, so
<code>write.paml.format</code> is to write files in a different format of
<code>write.phylip.format</code>. The main purpose of <code>write.paml</code> and
<code>write.paml.format</code> is to generate files for <code>pamle.baseml</code>.
</p>
<p><code>sep</code> can specify a character which is used to split sites in file.
By default, &quot;&quot; denote no character between sites. Only &quot;CODON&quot; id requires
a character to avoid ambiguity.
</p>


<h3>Value</h3>

<p>Save a text file.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.fasta">read.fasta</a></code>,
<code><a href="#topic+read.phylip">read.phylip</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

# PHYLIP
data.path &lt;- paste(.libPaths()[1], "/phyclust/data/crohn.phy", sep = "")
my.snp &lt;- read.phylip(data.path, code.type = "SNP")
write.phylip(my.snp$org, "new.crohn.phy", code.type = "SNP")

# FASTA
data.path &lt;- paste(.libPaths()[1], "/phyclust/data/pony625.fas", sep = "")
(my.pony &lt;- read.fasta(data.path))
write.fasta(my.pony$org, "new.pony.fas")

# PAML
write.paml(my.pony$org, "new.pony.pam")

# Amino acid in PHYLIP
aa.aid &lt;- nid2aid(my.pony$org)
aa.acode &lt;- aid2acode(aa.aid)
write.phylip(aa.aid, "new.pony.aa.phy", code.type = "AMINO_ACID")
write.phylip.format(aa.aid, "new.pony.aa.aid.phy", sep = ",")
write.phylip.format(aa.acode, "new.pony.aa.acode.phy")

# Amino acid in FASTA
write.fasta(aa.aid, "new.pony.aa.phy", code.type = "AMINO_ACID")
write.fasta.format(aa.aid, "new.pony.aa.aid.phy", sep = ",")
write.fasta.format(aa.acode, "new.pony.aa.acode.fas")

# Amino acid in PAML
write.paml(aa.aid, "new.pony.aa.pam", code.type = "AMINO_ACID")
write.paml.format(aa.aid, "new.pony.aa.aid.pam", sep = ",")
write.paml.format(aa.acode, "new.pony.aa.acode.pam")

## End(Not run)
</code></pre>

<hr>
<h2 id='find.best'>Find the Best Solution of phyclust</h2><span id='topic+find.best'></span>

<h3>Description</h3>

<p>Based on input initialization procedures and methods,
this function tries to find the best solution in terms of the highest
log-likelihood value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.best(X, K, EMC = .EMC, manual.id = NULL, byrow = TRUE,
    init.procedure = .init.procedure, init.method = .init.method,
    file.tmp = NULL, visible = FALSE, save.all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.best_+3A_x">X</code></td>
<td>
<p>nid/sid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="find.best_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="find.best_+3A_emc">EMC</code></td>
<td>
<p>EM control.</p>
</td></tr>
<tr><td><code id="find.best_+3A_manual.id">manual.id</code></td>
<td>
<p>manually input class ids.</p>
</td></tr>
<tr><td><code id="find.best_+3A_byrow">byrow</code></td>
<td>
<p>advanced option for <code>X</code>, default = TRUE.</p>
</td></tr>
<tr><td><code id="find.best_+3A_init.procedure">init.procedure</code></td>
<td>
<p>customized initialization procedures.</p>
</td></tr>
<tr><td><code id="find.best_+3A_init.method">init.method</code></td>
<td>
<p>customized initialization methods.</p>
</td></tr>
<tr><td><code id="find.best_+3A_file.tmp">file.tmp</code></td>
<td>
<p>a file for saving temporary results.</p>
</td></tr>
<tr><td><code id="find.best_+3A_visible">visible</code></td>
<td>
<p>TRUE for reporting iterations.</p>
</td></tr>
<tr><td><code id="find.best_+3A_save.all">save.all</code></td>
<td>
<p>TRUE for saving all results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> should be a numerical matrix containing sequence data that
can be transfered by <code>code2nid</code> or <code>code2sid</code>.
</p>
<p><strong>Note</strong>: gaps <code>-</code> are not supported yet, drop them from data.
</p>
<p><code>EMC</code> contains all options used for EM algorithms.
</p>
<p><code>manual.id</code> manually input class ids as an initialization only for
the initialization method, 'manualMu'.
</p>
<p><code>byrow</code> used in bootstraps to avoid transposing matrix 'X'. If
FALSE, then the 'X' should be have the dimension <code class="reqn">L\times K</code>.
</p>
<p><code>init.procedure</code> and <code>init.method</code> are methods for searching
the best result. This function will try all combinations of these two
options.
</p>
<p><code>file.tmp</code> is used to save temporary results due to long computing.
If <code>NULL</code>, there will no saving in each combinations.
</p>


<h3>Value</h3>

<p>An list with class <code>phyclust</code> will be returned containing
several elements, see <code>phyclust</code> for detail. 
</p>


<h3>ToDo(s)</h3>


<ul>
<li><p> implement codes for gaps <code>-</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.EMC">.EMC</a></code>,
<code><a href="#topic+.EMControl">.EMControl</a></code>.
<code><a href="#topic+phyclust">phyclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
EMC.1 &lt;- .EMControl(exhaust.iter = 1, short.iter = 5, EM.iter = 5)
(ret.1 &lt;- find.best(seq.data.toy$org, 2, EMC = EMC.1))

## End(Not run)
</code></pre>

<hr>
<h2 id='find.consensus'>Find the Consensus Sequence</h2><span id='topic+find.consensus'></span>

<h3>Description</h3>

<p>Based on the input data, this function will search all data along
all sites to find a consensus sequence which may be or may not be
one of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.consensus(X, code.type = .code.type[1], with.gap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.consensus_+3A_x">X</code></td>
<td>
<p>nid/sid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="find.consensus_+3A_code.type">code.type</code></td>
<td>
<p>either &quot;NUCLEOTIDE&quot; (default) or &quot;SNP&quot;.</p>
</td></tr>
<tr><td><code id="find.consensus_+3A_with.gap">with.gap</code></td>
<td>
<p>FALSE (default) for no gap in consensus sequence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> should be a numerical matrix containing sequence data that
can be transfered by <code>code2nid</code> or <code>code2sid</code>.
</p>


<h3>Value</h3>

<p>A vector containing the consensus sequence with length <code class="reqn">L</code>
will be returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotdots">plotdots</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

find.consensus(seq.data.toy$org)

## End(Not run)
</code></pre>

<hr>
<h2 id='gen.equal.star.anc.dec'>Generate Comprehensive Trees.</h2><span id='topic+gen.equal.star.anc.dec'></span>

<h3>Description</h3>

<p>Generate comprehensive trees for simulation studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.equal.star.anc.dec(K, N.K, rate.f = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.equal.star.anc.dec_+3A_k">K</code></td>
<td>
<p>number of clusters, <code class="reqn">K</code>.</p>
</td></tr>
<tr><td><code id="gen.equal.star.anc.dec_+3A_n.k">N.K</code></td>
<td>
<p>number of sequences for each cluster, a vector with length <code>K</code>.</p>
</td></tr>
<tr><td><code id="gen.equal.star.anc.dec_+3A_rate.f">rate.f</code></td>
<td>
<p><code class="reqn">r_f</code>, growth rate ratio of ancestral and descendent trees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions generates an ancestral tree in K tips and
generates descendent trees according to <code>N.K</code> tips.
All trees, ancestral and descendent, are coerced to star shapes
and scaled their heights to fit the ratio <code>rate.f</code>, and
the final tree has total height 1.
The returns are stored in a list, and the final tree is stored
with a name <code>equal.star</code>.
</p>


<h3>Value</h3>

<p>A list contains all information of generation and results including:
</p>
<table>
<tr><td><code>'K'</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code>'N.K</code></td>
<td>
<p>number of sequences for each cluster.</p>
</td></tr>
<tr><td><code>'rate.f'</code></td>
<td>
<p><code class="reqn">r_f</code>, growth rate ratio of ancestral and descendent trees.</p>
</td></tr>
<tr><td><code>'anc'</code></td>
<td>
<p>an ancestral tree.</p>
</td></tr>
<tr><td><code>'dec'</code></td>
<td>
<p>all descendent trees.</p>
</td></tr>
<tr><td><code>'equalstar'</code></td>
<td>
<p>a tree that descendants are equal star trees.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.unit.K">gen.unit.K</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
tree.K &lt;- gen.equal.star.anc.dec(6, rep(3:5, 2),
                                 rate.f = 0.7)
X.class &lt;- as.numeric(gsub("d(.).(.)", "\\1",
                           tree.K$equal.star$tip.label))

# Plot results
plotnj(tree.K$equal.star, X.class, type = "p",
       edge.width.class = 2, main = "equal.star")
axis(1)

## End(Not run)
</code></pre>

<hr>
<h2 id='gen.seq'>Generate Sequences Given a Rooted Tree.</h2><span id='topic+gen.seq.HKY'></span><span id='topic+gen.seq.SNP'></span>

<h3>Description</h3>

<p>These functions call <code>seqgen</code> to generate sequences by
evolutions models based on a rooted tree. <code>gen.seq.HKY</code> is to
generate nucleotide sequences, and <code>gen.seq.SNP</code> is to generate
SNP sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.seq.HKY(rooted.tree, pi, kappa, L, rate.scale = 1,
            anc.seq = NULL)
gen.seq.SNP(rooted.tree, pi, L, rate.scale = 1, anc.seq = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.seq_+3A_rooted.tree">rooted.tree</code></td>
<td>
<p>a rooted tree in <code>Class phylo</code>.</p>
</td></tr>
<tr><td><code id="gen.seq_+3A_pi">pi</code></td>
<td>
<p>equilibrium probabilities, sums to 1.</p>
</td></tr>
<tr><td><code id="gen.seq_+3A_kappa">kappa</code></td>
<td>
<p>transition and transversion bias.</p>
</td></tr>
<tr><td><code id="gen.seq_+3A_l">L</code></td>
<td>
<p>number of sites.</p>
</td></tr>
<tr><td><code id="gen.seq_+3A_rate.scale">rate.scale</code></td>
<td>
<p>a scale to all branch lengths.</p>
</td></tr>
<tr><td><code id="gen.seq_+3A_anc.seq">anc.seq</code></td>
<td>
<p>an ancestral sequence either in nids or sids, length = <code class="reqn">L</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rooted.tree</code> should be in a <code>phylo</code> class of <span class="pkg">ape</span>,
and may be created by <code>ms</code>.
</p>
<p>The <code>pi</code> has length 4 for nucleotide sequences, and 2 for SNP sequences.
</p>
<p>The <code>rate.scale</code> is equivalent to rescale the height of
<code>rooted.tree</code>.
</p>


<h3>Value</h3>

<p>Return an object in <code>Class seqgen</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.star.tree">gen.star.tree</a></code>,
<code><a href="#topic+seqgen">seqgen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(phyclust, quiet = TRUE)

# Generate a tree
set.seed(1234)
ret.ms &lt;- ms(nsam = 5, nreps = 1, opts = "-T")
tree.ms &lt;- read.tree(text = ret.ms[3])

# Generate nucleotide sequences
anc.HKY &lt;- rep(0:3, 3)
pi.HKY &lt;- c(0.2, 0.2, 0.3, 0.3)
kappa &lt;- 1.1
L &lt;- length(anc.HKY)
set.seed(1234)
paste(nid2code(anc.HKY, lower.case = FALSE), collapse = "")
(HKY.1 &lt;- gen.seq.HKY(tree.ms, pi.HKY, kappa, L, anc.seq = anc.HKY))

# evolve 5 times longer
(HKY.2 &lt;- gen.seq.HKY(tree.ms, pi.HKY, kappa, L,
                      rate.scale = 5, anc.seq = anc.HKY))

# Generate SNP sequences
anc.SNP &lt;- rep(0:1, 6)
pi.SNP &lt;- c(0.4, 0.6)
L &lt;- length(anc.SNP)
set.seed(1234)
paste(sid2snp(anc.SNP), collapse = "")
(SNP.1 &lt;- gen.seq.SNP(tree.ms, pi.SNP, L, anc.seq = anc.SNP))

# evolve 5 times longer
(SNP.2 &lt;- gen.seq.SNP(tree.ms, pi.SNP, L, rate.scale = 5,
                      anc.seq = anc.SNP))

</code></pre>

<hr>
<h2 id='gen.star.tree'>Generate a Rooted Tree with a Star Shape</h2><span id='topic+gen.star.tree'></span>

<h3>Description</h3>

<p>Generate a rooted tree with a star shape based on a sequence calls
of several functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.star.tree(N, total.height = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.star.tree_+3A_n">N</code></td>
<td>
<p>number of leaves.</p>
</td></tr>
<tr><td><code id="gen.star.tree_+3A_total.height">total.height</code></td>
<td>
<p>total tree height.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tree with a star shape means that all internal branches are 0 and
all leaf branches are equal.
</p>
<p>This function combining with <code>gen.seq.HKY</code> or <code>gen.seq.SNP</code>
is used in simulation studies and bootstrap tree samples 
</p>


<h3>Value</h3>

<p>Return a rooted tree in <code>Class phylo</code> with a star shape.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ms">ms</a></code>.
<code><a href="#topic+as.star.tree">as.star.tree</a></code>,
<code><a href="#topic+get.rooted.tree.height">get.rooted.tree.height</a></code>.
<code><a href="#topic+rescale.rooted.tree">rescale.rooted.tree</a></code>.
<code><a href="ape.html#topic+as.phylo">as.phylo</a></code>,
<code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

ret.star &lt;- gen.star.tree(5)
plot(ret.star, type = "u")

## End(Not run)
</code></pre>

<hr>
<h2 id='gen.unit.K'>Generate Comprehensive Trees.</h2><span id='topic+gen.unit.K'></span>

<h3>Description</h3>

<p>Generate comprehensive trees for simulation studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.unit.K(K, N.K, rate.anc = 10, rate.dec = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.unit.K_+3A_k">K</code></td>
<td>
<p>number of clusters, <code class="reqn">K</code>.</p>
</td></tr>
<tr><td><code id="gen.unit.K_+3A_n.k">N.K</code></td>
<td>
<p>number of sequences for each cluster, a vector with length <code>K</code>.</p>
</td></tr>
<tr><td><code id="gen.unit.K_+3A_rate.anc">rate.anc</code></td>
<td>
<p><code class="reqn">r_a</code>, growth rate of ancestral tree.</p>
</td></tr>
<tr><td><code id="gen.unit.K_+3A_rate.dec">rate.dec</code></td>
<td>
<p><code class="reqn">r_d</code>, growth rate of descendent tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions generates an ancestral tree in K tips and
generates descendent trees according to <code>N.K</code> tips,
and returns several types of trees, <code>org</code>, <code>equal</code>,
<code>max</code>, and <code>star</code>, as the following:
</p>

<ul>
<li><p> 'org': original tree, adjacent the descendent trees to the ancestral
tree.
</p>
</li>
<li><p> 'equal': descendent trees are scaled to the average height and
attached to the ancestral tree, then scale the total
height to be 1.
</p>
</li>
<li><p> 'max': descendent trees are attached to the ancestral tree,
then scale the maximum height to be 1.
</p>
</li>
<li><p> 'star': descendent trees are applied <code>as.star.tree</code> and
attached to the ancestral tree,
then scale the maximum height to be 1.
</p>
</li></ul>



<h3>Value</h3>

<p>A list contains all information of generation and results including:
</p>
<table>
<tr><td><code>'K'</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code>'N.K</code></td>
<td>
<p>number of sequences for each cluster.</p>
</td></tr>
<tr><td><code>'rate.anc'</code></td>
<td>
<p><code class="reqn">r_a</code>, growth rate of ancestral tree.</p>
</td></tr>
<tr><td><code>'rate.dec'</code></td>
<td>
<p><code class="reqn">r_d</code>, growth rate of descendent tree.</p>
</td></tr>
<tr><td><code>'height.anc'</code></td>
<td>
<p>height of ancestral tree.</p>
</td></tr>
<tr><td><code>'height.dec'</code></td>
<td>
<p>height of all descendent trees.</p>
</td></tr>
<tr><td><code>'anc'</code></td>
<td>
<p>an ancestral tree.</p>
</td></tr>
<tr><td><code>'dec'</code></td>
<td>
<p>all descendent trees.</p>
</td></tr>
<tr><td><code>'org'</code></td>
<td>
<p>an original tree.</p>
</td></tr>
<tr><td><code>'equal'</code></td>
<td>
<p>a three that descendants are all equal height.</p>
</td></tr>
<tr><td><code>'max'</code></td>
<td>
<p>a tree that descendants are scaled by the maximum height.</p>
</td></tr>
<tr><td><code>'star'</code></td>
<td>
<p>a tree that descendants are star trees.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.equal.star.anc.dec">gen.equal.star.anc.dec</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

# For gen.unit.K()
set.seed(1234)
tree.K &lt;- gen.unit.K(6, rep(3:5, 2),
                     rate.anc = 0.7, rate.dec = 1.1)
X.class &lt;- as.numeric(gsub("d(.)(.*)", "\\1",
                           tree.K$org$tip.label))

# Plot results
par(mfrow = c(2, 2))
plotnj(tree.K$org, X.class, type = "p",
       edge.width.class = 2, main = "org")
axis(1)
plotnj(tree.K$equal, X.class, type = "p",
       edge.width.class = 2, main = "equal")
axis(1)
plotnj(tree.K$max, X.class, type = "p",
       edge.width.class = 2, main = "max")
axis(1)
plotnj(tree.K$star, X.class, type = "p",
       edge.width.class = 2, main = "star")
axis(1)

## End(Not run)
</code></pre>

<hr>
<h2 id='get.rooted.tree.height'>Get a Rooted Tree Height</h2><span id='topic+get.rooted.tree.height'></span>

<h3>Description</h3>

<p>This function gets a rooted tree height, and only meaningful for
a <strong>ultrametric</strong> tree which has the equal height from the root to
all leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rooted.tree.height(rooted.tree,
    tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.rooted.tree.height_+3A_rooted.tree">rooted.tree</code></td>
<td>
<p>a rooted tree in <code>Class phylo</code>.</p>
</td></tr>
<tr><td><code id="get.rooted.tree.height_+3A_tol">tol</code></td>
<td>
<p>for <code>is.ultrametric</code> of <span class="pkg">ape</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rooted.tree</code> should be in a <code>phylo</code> class of <span class="pkg">ape</span>,
and should be ultrametric that may be created by <code>ms</code>.
</p>


<h3>Value</h3>

<p>Return the rooted tree height.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ms">ms</a></code>,
<code><a href="ape.html#topic+read.tree">read.tree</a></code>,
<code><a href="ape.html#topic+as.phylo">as.phylo</a></code>,
<code><a href="ape.html#topic+is.ultrametric">is.ultrametric</a></code>,
<code><a href="#topic+rescale.rooted.tree">rescale.rooted.tree</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
ret.ms &lt;- ms(5, 1, opts = paste("-T", sep = " "))
tree.ms &lt;- read.tree(text = ret.ms[3])
is.ultrametric(tree.ms)
get.rooted.tree.height(tree.ms)

## End(Not run)
</code></pre>

<hr>
<h2 id='getcut.fun'>Tzeng's Method: Finding the Best Number of Clusters</h2><span id='topic+getcut.fun'></span>

<h3>Description</h3>

<p>For SNP sequences only, Tzeng's method (2005) uses an evolution approach
to group haplotypes based on a deterministic transformation of haplotype
frequency. This function find the best number of clusters based on
Shannon information content.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getcut.fun(pp.org, nn, plot = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getcut.fun_+3A_pp.org">pp.org</code></td>
<td>
<p>frequency of haplotypes, sorted in decreasing order.</p>
</td></tr>
<tr><td><code id="getcut.fun_+3A_nn">nn</code></td>
<td>
<p>number of haplotypes.</p>
</td></tr>
<tr><td><code id="getcut.fun_+3A_plot">plot</code></td>
<td>
<p>illustrated in a plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pp.org</code> is summarized from <code>X</code> in <code>haplo.post.prob</code>,
<code>nn</code> is equal to the number of rows of <code>X</code>.
</p>
<p>This function is called by <code>haplo.post.prob</code> to determine
the best guess of number of clusters.
See Tzeng (2005) and Shannon (1948) for details.
</p>


<h3>Value</h3>

<p>Return the best guess of number of clusters.
</p>


<h3>Author(s)</h3>

<p>Jung-Ying Tzeng.
</p>
<p>Maintain: Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Tzeng, J.Y. (2005)
&ldquo;Evolutionary-Based Grouping of Haplotypes in Association Analysis&rdquo;,
<em>Genetics Epidemiology</em>, <b>28</b>, 220-231.
<a href="https://www4.stat.ncsu.edu/~jytzeng/software.php">https://www4.stat.ncsu.edu/~jytzeng/software.php</a>
</p>
<p>Shannon, C.E. (1948)
&ldquo;A mathematical theory of communication&rdquo;,
<em>Bell System Tech J</em>, <b>27</b>, 379-423, 623-656.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haplo.post.prob">haplo.post.prob</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

data.path &lt;- paste(.libPaths()[1], "/phyclust/data/crohn.phy", sep = "")
my.snp &lt;- read.phylip(data.path, code.type = "SNP")
ret &lt;- haplo.post.prob(my.snp$org, ploidy = 1)
getcut.fun(sort(ret$haplo$hap.prob, decreasing = TRUE),
           nn = my.snp$nseq, plot = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='haplo.post.prob'>Tzeng's Method: Haplotype Grouping for SNP Sequences</h2><span id='topic+haplo.post.prob'></span>

<h3>Description</h3>

<p>For SNP sequences only, Tzeng's method (2005) uses an evolution approach
to group haplotypes based on a deterministic transformation of haplotype
frequency. This is a modified version of original function,
<code>haplo.score.RD.unphased.fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  haplo.post.prob(X, ploidy = 2, skip.haplo = 1e-07, K = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haplo.post.prob_+3A_x">X</code></td>
<td>
<p>sid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="haplo.post.prob_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy, no effect for phase known, keep consistence only.</p>
</td></tr>
<tr><td><code id="haplo.post.prob_+3A_skip.haplo">skip.haplo</code></td>
<td>
<p>lower bound of haplotypes frequencies.</p>
</td></tr>
<tr><td><code id="haplo.post.prob_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> should be a phase known haplotype data. For phase unknown and
Tzeng's method (2006) are not tested yet.
</p>
<p>If <code>K</code> is NULL, the result of <code>getcut.fun</code> will be used.
</p>


<h3>Value</h3>

<p>See the original paper and source codes' documents for details.
The function returns a list contains:
</p>
<table>
<tr><td><code>'haplo'</code></td>
<td>
<p>summarized data set in a list contains:
</p>

<table>
<tr>
 <td style="text-align: left;">
      'haplotype' </td><td style="text-align: left;"> unique haplotypes, dim = <code class="reqn">N_{unique} \times L</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
      'hap.prob'  </td><td style="text-align: left;"> frequency of haplotypes. </td>
</tr>
<tr>
 <td style="text-align: left;">
      'post'      </td><td style="text-align: left;"> posterior probabilities of phase unknown haplotypes. </td>
</tr>
<tr>
 <td style="text-align: left;">
      'hap1code'  </td><td style="text-align: left;"> unique ids of 'haplotype'. </td>
</tr>
<tr>
 <td style="text-align: left;">
      'hap2code'  </td><td style="text-align: left;"> unique ids of 'haplotype', no effect if ploidy = 2. </td>
</tr>
<tr>
 <td style="text-align: left;">
      'indx.subj' </td><td style="text-align: left;"> id of subjects. </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</td></tr>
<tr><td><code>'FD.id'</code></td>
<td>
<p>unique ids of 'haplotype' for full dimension analysis.</p>
</td></tr>
<tr><td><code>'RD.id'</code></td>
<td>
<p>unique ids of 'haplotype' for reduced dimension analysis.</p>
</td></tr>
<tr><td><code>'FD.post'</code></td>
<td>
<p>posterior probabilities for full dimension analysis.</p>
</td></tr>
<tr><td><code>'RD.post'</code></td>
<td>
<p>posterior probabilities for reduced dimension analysis.</p>
</td></tr>
<tr><td><code>'g.truncate'</code></td>
<td>
<p>number of clusters</p>
</td></tr>
</table>


<h3>ToDo(s)</h3>


<ul>
<li><p> test codes for phased unknown cases.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jung-Ying Tzeng.
</p>
<p>Maintain: Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Tzeng, J.Y. (2005)
&ldquo;Evolutionary-Based Grouping of Haplotypes in Association Analysis&rdquo;,
<em>Genetics Epidemiology</em>, <b>28</b>, 220-231.
<a href="https://www4.stat.ncsu.edu/~jytzeng/software.php">https://www4.stat.ncsu.edu/~jytzeng/software.php</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getcut.fun">getcut.fun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

data.path &lt;- paste(.libPaths()[1], "/phyclust/data/crohn.phy", sep = "")
my.snp &lt;- read.phylip(data.path, code.type = "SNP")
ret &lt;- haplo.post.prob(my.snp$org, ploidy = 1)
str(ret)

## End(Not run)
</code></pre>

<hr>
<h2 id='ms'>Generating Samples under a Wright-Fisher Neutral Model of Genetic Variation</h2><span id='topic+ms'></span><span id='topic+Class+20ms'></span>

<h3>Description</h3>

<p>This function modifies the original standalone code of <code>ms()</code> developed by
Hudson (2002) for generating samples/coalescent trees under a Wright-Fisher
neutral model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ms(nsam = NULL, nreps = 1, opts = NULL, temp.file = NULL,
   tbs.matrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ms_+3A_nsam">nsam</code></td>
<td>
<p>number of samples/coalescent trees, usually greater than 2.</p>
</td></tr>
<tr><td><code id="ms_+3A_nreps">nreps</code></td>
<td>
<p>number of replications.</p>
</td></tr>
<tr><td><code id="ms_+3A_opts">opts</code></td>
<td>
<p>options as the standalone version.</p>
</td></tr>
<tr><td><code id="ms_+3A_temp.file">temp.file</code></td>
<td>
<p>temporary file for ms output.</p>
</td></tr>
<tr><td><code id="ms_+3A_tbs.matrix">tbs.matrix</code></td>
<td>
<p>a matrix for 'tbs' options given in opts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function directly reuses the C code of <code>ms</code> by arguments
as input from the <code>opts</code>. The options <code>opts</code> is followed from the
original <code>ms</code> except <code>nsam</code> and <code>nreps</code>.
Note that stdin, stdout, and pipe are all disable from <code>opts</code>.
</p>
<p>For examples, options commonly used in <span class="pkg">phyclust</span> are:
</p>

<ul>
<li><p> &quot;-T&quot;: generate trees in a neutral model.
</p>
</li>
<li><p> &quot;-G&quot;: generate trees with a population growth rate, e.g. &quot;-G 0.5&quot;.
</p>
</li></ul>

<p>These will return trees in a NEWICK format which can be read by the
<code>read.tree()</code> of <span class="pkg">ape</span> and passed to <code>seqgen()</code> to generate
sequences. 
</p>
<p><code>temp.file</code> allows users to specify ms output file themselves, but
this file will not be deleted nor converted into R after the call to
<code>ms()</code>. Users should take care the readings. By default, <code>ms()</code>
uses a system temp file to store the output which is converted into R
after the call and is deleted after converting.
</p>
<p><code>tbs.matrix</code> is a matrix to specify the values of <code>tbs</code> given
in <code>opts</code>. See <code>demo('simu_ms_tbs')</code> for an example how to
use this additional option. This option has been slightly tweaked by
utilizing <code>tbs</code> options in the standalone <code>ms</code>. However,
the output format is not the same as that in the standalone <code>ms</code>.
Post-process is required with caution.
</p>


<h3>Value</h3>

<p>This function returns a vector, and each element stores one line of STDOUT
of <code>ms()</code> separated by newline. The vector stores in a class <code>ms</code>.
The details of output format can found on the website
<a href="http://home.uchicago.edu/~rhudson1/source.html">http://home.uchicago.edu/~rhudson1/source.html</a> and its manual.
</p>


<h3>Warning(s)</h3>

<p>Carefully read the <code>ms</code>'s original document before using the <code>ms()</code>
function.
</p>


<h3>Author(s)</h3>

<p>Hudson, R.R. (2002).
</p>
<p>Maintain: Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Hudson, R.R. (2002)
&ldquo;Generating Samples under a Wright-Fisher Neutral Model of Genetic
Variation&rdquo;,
<em>Bioinformatics</em>, <b>18</b>, 337-338.
<a href="http://home.uchicago.edu/~rhudson1/source.html">http://home.uchicago.edu/~rhudson1/source.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.ms">print.ms</a>()</code>,
<code><a href="ape.html#topic+read.tree">read.tree</a>()</code>,
<code><a href="ape.html#topic+bind.tree">bind.tree</a>()</code>,
<code><a href="#topic+seqgen">seqgen</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

ms()

# an ancestral tree
set.seed(1234)
(ret.ms &lt;- ms(nsam = 3, opts = "-T -G 0.1"))
(tree.anc &lt;- read.tree(text = ret.ms[3]))
tree.anc$tip.label &lt;- paste("a", 1:K, sep = "")

# adjacent descendant trees to the ancestral tree
K &lt;- 3
N &lt;- 12
N.k &lt;- c(3, 4, 5)
ms.dec &lt;- NULL         # a list to store trees of ms
tree.dec &lt;- NULL       # a list to store the trees in phylo class
tree.joint &lt;- tree.anc
for(k in 1:K){
  ms.dec[[k]] &lt;- ms(N.k[k], opts = "-T -G 1.0")
  tree.dec[[k]] &lt;- read.tree(text = ms.dec[[k]][3])
  tree.dec[[k]]$tip.label &lt;- paste("d", k, ".", 1:N.k[k], sep = "")
  tree.joint &lt;- bind.tree(tree.joint, tree.dec[[k]],
                          where = which(tree.joint$tip.label ==
                                        paste("a", k, sep = "")))
}
str(tree.joint)

# plot trees
par(mfrow = c(2, 3))
plot(tree.anc, main = paste("anc (", K, ")", sep = ""))
axis(1)
for(k in 1:K){
  plot(tree.dec[[k]], main = paste("dec", k, " (", N.k[k], ")", sep = ""))
  axis(1)
}
plot(tree.joint, main = paste("joint (", N, ")", sep = ""))
axis(1)

# use tbs option (an example from msdoc.pdf by Hudson, R.R.)
tbs.matrix &lt;- matrix(c(3.0, 3.5, 5.0, 8.5), nrow = 2)
ret &lt;- ms(nsam = 5, nreps = 2, opts = "-t tbs -r tbs 1000",
          tbs.matrix = tbs.matrix)
print(ret)

## End(Not run)
</code></pre>

<hr>
<h2 id='nid.aid.cid'>Transfer nids (0, 1, ..., 4) , aids (0, 1, ..., 21) and cids (0, 1, ..., 64)</h2><span id='topic+nid2aid'></span><span id='topic+nid2cid'></span><span id='topic+cid2aid'></span><span id='topic+aid2acode'></span><span id='topic+acode2aid'></span>

<h3>Description</h3>

<p>Transfer nids (0, 1, ..., 4) , aids (0, 1, ..., 21) and cids (0, 1, ..., 64).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>### S3 methods for a list, vector or matrix (default).
nid2aid(nidseq, start = 1, end = NULL, drop.gap = FALSE, byrow = TRUE)
nid2cid(nidseq, start = 1, end = NULL, drop.gap = FALSE, byrow = TRUE)
cid2aid(cidseq)
aid2acode(aidseq, lower.case = FALSE)
acode2aid(acodeseq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nid.aid.cid_+3A_nidseq">nidseq</code></td>
<td>
<p>a numerical vector contains nucleotide ids, 0, 1, 2, 3, or 4.</p>
</td></tr>
<tr><td><code id="nid.aid.cid_+3A_cidseq">cidseq</code></td>
<td>
<p>a numerical vector contains codon ids, 0, 1, ..., or 64.</p>
</td></tr>
<tr><td><code id="nid.aid.cid_+3A_aidseq">aidseq</code></td>
<td>
<p>a numerical vector contains amino acid ids, 0, 1, ..., or 21.</p>
</td></tr>
<tr><td><code id="nid.aid.cid_+3A_acodeseq">acodeseq</code></td>
<td>
<p>a character vector contains amino acid codes.</p>
</td></tr>
<tr><td><code id="nid.aid.cid_+3A_start">start</code></td>
<td>
<p>the start site to translate.</p>
</td></tr>
<tr><td><code id="nid.aid.cid_+3A_end">end</code></td>
<td>
<p>the end site to translate.</p>
</td></tr>
<tr><td><code id="nid.aid.cid_+3A_drop.gap">drop.gap</code></td>
<td>
<p>ignore gaps if TRUE.</p>
</td></tr>
<tr><td><code id="nid.aid.cid_+3A_byrow">byrow</code></td>
<td>
<p>advanced option, default = TRUE.</p>
</td></tr>
<tr><td><code id="nid.aid.cid_+3A_lower.case">lower.case</code></td>
<td>
<p>transfer in lower cases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are based on the internal object <code>.nucleotide</code>,
<code>.codon</code>, <code>.amino.acid</code>, and <code>.genetic.code</code> to
transfer sequences.
</p>


<h3>Value</h3>

<p><code>nid2aid</code> and <code>cid2aid</code> returns a numerical vector containing
amino acid ids, and <code>nid2cid</code> returns a numerical vector containing
codon ids, <code>aid2acode</code> returns a character vector containing
amino acid codes, and <code>acode2aid</code> returns a numerical vector containing
amino acid ids.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.nucleotide">.nucleotide</a></code>,
<code><a href="#topic+.amino.acid">.amino.acid</a></code>,
<code><a href="#topic+.codon">.codon</a></code>,
<code><a href="#topic+.genetic.code">.genetic.code</a></code>,
<code><a href="#topic+code2nid">code2nid</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

### Test S3 methods by a vector
a.vector &lt;- c("A", "C", "G", "-", "T", "A")
code2nid(a.vector)
nid2cid(code2nid(a.vector))
cid2aid(nid2cid(code2nid(a.vector)))
nid2aid(code2nid(a.vector))
aid2acode(nid2aid(code2nid(a.vector)))
acode2aid(aid2acode(nid2aid(code2nid(a.vector))))

### Test S3 methods by a matrix
a.matrix &lt;- rbind(a.vector, a.vector, a.vector)
code2nid(a.matrix)
nid2cid(code2nid(a.matrix))
cid2aid(nid2cid(code2nid(a.matrix)))
nid2aid(code2nid(a.matrix))
aid2acode(nid2aid(code2nid(a.matrix)))
acode2aid(aid2acode(nid2aid(code2nid(a.matrix))))

### Test S3 methods by a list
a.list &lt;- list(a.vector, a.vector)
code2nid(a.list)
nid2cid(code2nid(a.list))
cid2aid(nid2cid(code2nid(a.list)))
nid2aid(code2nid(a.list))
aid2acode(nid2aid(code2nid(a.list)))
acode2aid(aid2acode(nid2aid(code2nid(a.list))))

## End(Not run)
</code></pre>

<hr>
<h2 id='paml.baseml'>Phylogenetic Analysis by Maximum Likelihood for Nucleotide Sequences</h2><span id='topic+paml.baseml'></span><span id='topic+paml.baseml.control'></span><span id='topic+paml.baseml.show.default'></span><span id='topic+Class+20baseml'></span>

<h3>Description</h3>

<p>This function modifies the original standalone code of <code>baseml</code>
in PAML developed by Yang (1997) for phylogenetic analysis by maximum
likelihood. This function provides a way to generate an ancestral tree
for given central sequences clustered by <code>phyclust</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paml.baseml(X, seqname = NULL, opts = NULL, newick.trees = NULL)
paml.baseml.control(...)
paml.baseml.show.default()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paml.baseml_+3A_x">X</code></td>
<td>
<p>nid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="paml.baseml_+3A_seqname">seqname</code></td>
<td>
<p>sequence names.</p>
</td></tr>
<tr><td><code id="paml.baseml_+3A_opts">opts</code></td>
<td>
<p>options as the standalone version, provided by <code>paml.baseml.contol</code>.</p>
</td></tr>
<tr><td><code id="paml.baseml_+3A_newick.trees">newick.trees</code></td>
<td>
<p>a vector/list contains NEWICK trees for <code>runmode = 2</code>.</p>
</td></tr>
<tr><td><code id="paml.baseml_+3A_...">...</code></td>
<td>
<p>for other possible opts and values. See PAML manual for details.</p>
</td></tr>
<tr><td><code id="paml.baseml_+3A_show">show</code></td>
<td>
<p>show opts and values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>paml.baseml</code> directly reuses the C code of <code>baseml</code>
of PAML, and the function <code>paml.baseml.control</code> is to generate controls
for <code>paml.baseml</code> as the file <code>baseml.ctl</code> of PAML.
</p>
<p>The <code>seqname</code> should be consistent with <code>X</code>, and the leaf nodes
of <code>newick.trees</code>.
</p>
<p>The options <code>opts</code> is followed from the original <code>baseml.ctl</code>
except <code>seqfile</code>, <code>treefile</code> and <code>outputfile</code> will be omitted.
</p>
<p><code>paml.baseml.control</code> generates default <code>opts</code>, and
<code>paml.baseml.show.default</code> displays annotations for the default
<code>opts</code>.
</p>


<h3>Value</h3>

<p>This function returns a list, and each element stores one line of outputs
of <code>baseml</code> separated by newline. The list stores in a class
<code>baseml</code>. All the output of <code>baseml</code> of PAML will be saved in
several files, and these will be read in by <code>scan</code>. Further post
processing can be done by parsing the returning vector. The details of
output format can found on the website
<a href="http://abacus.gene.ucl.ac.uk/software/paml.html">http://abacus.gene.ucl.ac.uk/software/paml.html</a> and its manual.
</p>
<p>Note that some functionalities of <code>baseml</code> of PAML are changed in
<code>paml.baseml</code> due to the complexity of input and output. The changes
include such as disable the option <code>G</code> and rename the file <code>2base.t</code>
to <code>pairbase.t</code>.
</p>
<p>Typically, the list contains the original output of <code>baseml</code> including
<code>pairbase.t</code>, <code>mlb</code>, <code>rst</code>, <code>rst1</code>, and <code>rub</code> if they
are not empty. The best tree (unrooted by default) will be stored in
<code>best.tree</code> parsed from <code>mlb</code> based on the highest log likelihood.
All output to <code>STDOUT</code> are stored in <code>stdout</code>. No <code>STDIN</code> are
allowed.
</p>
<p>Note that the print function for the class <code>baseml</code> will only show
the <code>best.tree</code> only. Use <code>str</code> or <code>names</code> to see the whole
returns of the list.
</p>


<h3>Warning(s)</h3>

<p>Carefully read the PAML's original document before using the
<code>paml.baseml</code> function, and <code>paml.baseml</code> may not be ported
well from <code>baseml</code> of PAML. Please double check with the standalone
version.
</p>
<p><code>baseml</code> may not be a well designed program, and may run slowly.
If it were stuck, temporary files would all store at a directory obtained
by <code>tempfile("/paml.baseml.")</code>.
</p>
<p><code>baseml</code> has its own options and settings which may be different
than <span class="pkg">phyclust</span> and <span class="pkg">ape</span>. For example, the following is from
the PAML's document, &ldquo;In PAML, a rooted tree has a bifurcation at the root,
while an unrooted tree has a trifurcation or multifurcation at the root.&rdquo;
i.e. <code>paml.baseml</code> uses a rooted result for an unrooted tree, as well
as for a rooted tree.
</p>
<p><code>baseml</code> also needs a sequence file which is dumped from R (duplicated
from memory) for <code>paml.baseml</code>, and this file can be very big if
sequences are too long or number of sequences is too large. Also,
<code>paml.baseml</code> may take long time to search the best tree if data are
large or initial trees are not provided.
</p>


<h3>Author(s)</h3>

<p>Yang, Z. (1997) and Yang, Z. (2007)
</p>
<p>Maintain: Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Yang, Z. (1997)
&ldquo;PAML: a program package for phylogenetic analysis by maximum
likelihood&rdquo;,
<em>Computer Applications in BioSciences</em>, <b>13</b>, 555-556.
</p>
<p>Yang, Z. (2007)
&ldquo;PAML 4: a program package for phylogenetic analysis by maximum
likelihood&rdquo;,
<em>Molecular Biology and Evolution</em>, <b>24</b>, 1586-1591.
<a href="http://abacus.gene.ucl.ac.uk/software/paml.html">http://abacus.gene.ucl.ac.uk/software/paml.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.baseml">print.baseml</a></code>,
<code><a href="#topic+write.paml">write.paml</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

paml.baseml.show.default()

### Generate data.
set.seed(123)
ret.ms &lt;- ms(nsam = 5, nreps = 1, opts = "-T")
ret.seqgen &lt;- seqgen(opts = "-mHKY -l40 -s0.2", newick.tree = ret.ms[3])
(ret.nucleotide &lt;- read.seqgen(ret.seqgen))
X &lt;- ret.nucleotide$org
seqname &lt;- ret.nucleotide$seqname

### Run baseml.
opts &lt;- paml.baseml.control(model = 4, clock = 1)
(ret.baseml &lt;- paml.baseml(X, seqname = seqname, opts = opts))
(ret.baseml.init &lt;- paml.baseml(X, seqname = seqname, opts = opts,
   newick.trees = ret.ms[3]))
ret.ms[3]

### Unrooted tree.
opts &lt;- paml.baseml.control(model = 4)
(ret.baseml.unrooted &lt;- paml.baseml(X, seqname = seqname, opts = opts))

### More information.
opts &lt;- paml.baseml.control(noisy = 3, verbose = 1, model = 4, clock = 1)
ret.more &lt;- paml.baseml(X, seqname = seqname, opts = opts)
# ret.more$stdout

### Plot trees
par(mfrow = c(2, 2))
plot(read.tree(text = ret.ms[3]), main = "true")
plot(read.tree(text = ret.baseml$best.tree), main = "baseml")
plot(read.tree(text = ret.baseml.init$best.tree), main = "baseml with initial")
plot(unroot(read.tree(text = ret.baseml.unrooted$best.tree)),
     main = "baseml unrooted")

## End(Not run)
</code></pre>

<hr>
<h2 id='phyclust'>The Main Function of phyclust</h2><span id='topic+phyclust'></span><span id='topic+Class+20phyclust'></span>

<h3>Description</h3>

<p>The main function of <span class="pkg">phyclust</span> implements finite mixture
models for sequence data that the mutation processes are modeled by
evolution processes based on Continuous Time Markov Chain theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyclust(X, K, EMC = .EMC, manual.id = NULL, label = NULL, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyclust_+3A_x">X</code></td>
<td>
<p>nid/sid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="phyclust_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="phyclust_+3A_emc">EMC</code></td>
<td>
<p>EM control.</p>
</td></tr>
<tr><td><code id="phyclust_+3A_manual.id">manual.id</code></td>
<td>
<p>manually input class ids.</p>
</td></tr>
<tr><td><code id="phyclust_+3A_label">label</code></td>
<td>
<p>label of sequences for semi-supervised clustering</p>
</td></tr>
<tr><td><code id="phyclust_+3A_byrow">byrow</code></td>
<td>
<p>advanced option for <code>X</code>, default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> should be a numerical matrix containing sequence data that
can be transfered by <code>code2nid</code> or <code>code2sid</code>.
</p>
<p><code>EMC</code> contains all options used for EM algorithms.
</p>
<p><code>manual.id</code> manually input class ids as an initialization only for
the initialization method, 'manualMu'.
</p>
<p><code>label</code> indicates the known clusters for labeled sequences which is a
vector with length <code>N</code> and has values from <code>0</code> to <code>K</code>.
<code>0</code> indicates clusters are unknown. <code>label = NULL</code> is for
unsupervised clustering. Only un- and semi-supervised clustering are
implemented.
</p>
<p><code>byrow</code> used in bootstraps to avoid transposing matrix 'X'. If
FALSE, then the 'X' should be have the dimension <code class="reqn">L\times K</code>.
</p>


<h3>Value</h3>

<p>A list with class <code>phyclust</code> will be returned containing
several elements as the following:
</p>
<table>
<tr><td><code>'N.X.org'</code></td>
<td>
<p>number of sequences in the <code>X</code> matrix.</p>
</td></tr>
<tr><td><code>'N.X.unique'</code></td>
<td>
<p>number of unique sequences in the <code>X</code> matrix.</p>
</td></tr>
<tr><td><code>'L'</code></td>
<td>
<p>number of sites, length of sequences, number of column of the <code>X</code> matrix.</p>
</td></tr>
<tr><td><code>'K'</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code>'Eta'</code></td>
<td>
<p>proportion of subpopulations, <code class="reqn">\eta_k</code>, length = <code>K</code>, sum to 1.</p>
</td></tr>
<tr><td><code>'Z.normalized'</code></td>
<td>
<p>posterior probabilities, <code class="reqn">Z_{nk}</code>, each row sums to 1.</p>
</td></tr>
<tr><td><code>'Mu'</code></td>
<td>
<p>centers of subpopulations, dim = <code class="reqn">K\times L</code>, each row is a center.</p>
</td></tr>
<tr><td><code>'QA'</code></td>
<td>
<p>Q matrix array, information for the evolution model, a list contains:
</p>

<table>
<tr>
 <td style="text-align: left;">
              'pi'         </td><td style="text-align: left;"> equilibrium probabilities, each row sums to 1. </td>
</tr>
<tr>
 <td style="text-align: left;">
              'kappa'      </td><td style="text-align: left;"> transition and transversion bias. </td>
</tr>
<tr>
 <td style="text-align: left;">
              'Tt'         </td><td style="text-align: left;"> total evolution time, <code class="reqn">t</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
              'identifier' </td><td style="text-align: left;"> identifier for QA. </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td>
</tr>

</table>

</td></tr>
<tr><td><code>'logL'</code></td>
<td>
<p>log likelihood values.</p>
</td></tr>
<tr><td><code>'p'</code></td>
<td>
<p>number of parameters.</p>
</td></tr>
<tr><td><code>'bic'</code></td>
<td>
<p>BIC, <code class="reqn">-2\log L + p \log N</code>.</p>
</td></tr>
<tr><td><code>'aic'</code></td>
<td>
<p>AIC, <code class="reqn">-2\log L + 2p</code>.</p>
</td></tr>
<tr><td><code>'N.seq.site'</code></td>
<td>
<p>number of segregating sites.</p>
</td></tr>
<tr><td><code>'class.id'</code></td>
<td>
<p>class id for each sequences based on the maximum posterior.</p>
</td></tr>
<tr><td><code>'n.class'</code></td>
<td>
<p>number of sequences in each cluster.</p>
</td></tr>
<tr><td><code>'conv'</code></td>
<td>
<p>convergence information, a list contains:
</p>

<table>
<tr>
 <td style="text-align: left;">
                  'eps'         </td><td style="text-align: left;"> relative error. </td>
</tr>
<tr>
 <td style="text-align: left;">
                  'error'       </td><td style="text-align: left;"> error if the likelihood decreased. </td>
</tr>
<tr>
 <td style="text-align: left;">
                  'flag'        </td><td style="text-align: left;"> convergence state. </td>
</tr>
<tr>
 <td style="text-align: left;">
                  'iter'        </td><td style="text-align: left;"> convergence iterations. </td>
</tr>
<tr>
 <td style="text-align: left;">
                  'inner.iter'  </td><td style="text-align: left;"> convergence of inner iterations other than EM. </td>
</tr>
<tr>
 <td style="text-align: left;">
                  'cm.iter'     </td><td style="text-align: left;"> convergence of CM iterations. </td>
</tr>
<tr>
 <td style="text-align: left;">
                  'check.param' </td><td style="text-align: left;"> parameter states. </td>
</tr>
<tr>
 <td style="text-align: left;">
                </td>
</tr>

</table>

</td></tr>
<tr><td><code>'init.procedure'</code></td>
<td>
<p>initialization procedure.</p>
</td></tr>
<tr><td><code>'init.method'</code></td>
<td>
<p>initialization method.</p>
</td></tr>
<tr><td><code>'substitution.model'</code></td>
<td>
<p>substitution model.</p>
</td></tr>
<tr><td><code>'edist.model'</code></td>
<td>
<p>evolution distance model.</p>
</td></tr>
<tr><td><code>'code.type'</code></td>
<td>
<p>code type.</p>
</td></tr>
<tr><td><code>'em.method'</code></td>
<td>
<p>EM algorithm.</p>
</td></tr>
<tr><td><code>'boundary.method'</code></td>
<td>
<p>boundary method.</p>
</td></tr>
<tr><td><code>'label.method'</code></td>
<td>
<p>label method.</p>
</td></tr>
</table>


<h3>ToDo(s)</h3>


<ul>
<li><p> make a general class for <code>Q</code> and <code>QA</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.EMC">.EMC</a></code>,
<code><a href="#topic+.EMControl">.EMControl</a></code>,
<code><a href="#topic+find.best">find.best</a></code>,
<code><a href="#topic+phyclust.se">phyclust.se</a></code>.
<code><a href="#topic+phyclust.se.update">phyclust.se.update</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(phyclust, quiet = TRUE)

X &lt;- seq.data.toy$org

set.seed(1234)
(ret.1 &lt;- phyclust(X, 3))

EMC.2 &lt;- .EMC
EMC.2$substitution.model &lt;- "HKY85"
# the same as EMC.2 &lt;- .EMControl(substitution.model = "HKY85")

(ret.2 &lt;- phyclust(X, 3, EMC = EMC.2))

# for semi-supervised clustering
semi.label &lt;- rep(0, nrow(X))
semi.label[1:3] &lt;- 1
(ret.3 &lt;- phyclust(X, 3, EMC = EMC.2, label = semi.label))

</code></pre>

<hr>
<h2 id='phyclust-package'>Phyloclustering &ndash; Phylogenetic Clustering</h2><span id='topic+phyclust-package'></span>

<h3>Description</h3>

<p>This package <span class="pkg">phyclust</span> (Chen 2011) implements an novel approach
combining model-based clusterings
and phylogenetics to classify DNA sequences and SNP sequences.
Based on evolution models, sequences are assumed to follow a mutation
process/distribution clouding around an unknown center ancestor.
Based on Continuous Time Markov Chain Theory, mixture distributions are
established to model/classify subpopulations or population structures.
</p>
<p>The kernel part of the package are implemented in C.
EM algorithms are performed to find the maximum likelihood estimators.
Initialization methods for EM algorithms are also established.
Several evolution models are also developed.
</p>
<p><code>ms</code> (Hudson 2002) and <code>seq-gen</code> (Rambaut and Grassly 1997)
are two useful programs to generate coalescent trees and sequences, and
both are merged into <span class="pkg">phyclust</span>. <code>baseml</code> of PAML (Yang 1997, 2007)
is also ported into <span class="pkg">phyclust</span> and it is a program to find a phylogenetic
tree by maximizing likelihood. Hap-Clustering method (Tzeng 2005) for
haplotype grouping is also incorporated into <span class="pkg">phyclust</span>.
</p>
<p>Type <code>help(package = phyclust)</code> to see a list of major
functions for which further documentations are available. The on-line
detail instructions are also available and the link is given below in the
&lsquo;References&rsquo; section.
</p>
<p>Some C and R functions and R classes of the <span class="pkg">ape</span> package are also
required and modified in <span class="pkg">phyclust</span>.
</p>


<h3>Details</h3>

<p>The main function is <code>phyclust</code> controlled by an object
<code>.EMC</code> generated by a function <code>.EMControl</code>,
and <code>find.best</code> can find the best solution by repeating
<code>phyclust</code> with different initializations.
</p>
<p><code>ms</code> and <code>seqgen</code> can generate trees and sequences
based on varied conditions, and they can jointly perform simulations.
</p>
<p><code>paml.baseml</code> can estimate trees based on sequences.
</p>
<p><code>haplo.post.prob</code> is a modified version of Tzeng's method
for haplotype grouping which uses a evolution approach to group SNP
sequences.
</p>
<p>Some tool functions of the <span class="pkg">ape</span> package are utilized in this package
to perform trees in plots, check object types, and read sequence data.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Chen, W.-C. (2011)
&ldquo;Overlapping codon model, phylogenetic clustering, and alternative
partial expectation conditional maximization algorithm&rdquo;,
<em>Ph.D. Diss., Iowa Stat University</em>.
</p>
<p>Hudson, R.R. (2002)
&ldquo;Generating Samples under a Wright-Fisher Neutral Model of Genetic
Variation&rdquo;,
<em>Bioinformatics</em>, <b>18</b>, 337-338.
<a href="http://home.uchicago.edu/~rhudson1/source.html">http://home.uchicago.edu/~rhudson1/source.html</a>
</p>
<p>Rambaut, A. and Grassly, N.C. (1997)
&ldquo;Seq-Gen: An Application for the Monte Carlo Simulation of DNA
Sequence Evolution along Phylogenetic Trees&rdquo;,
<em>Computer Applications In The Biosciences</em>, <b>13:3</b>, 235-238.
<a href="http://tree.bio.ed.ac.uk/software/seqgen/">http://tree.bio.ed.ac.uk/software/seqgen/</a>
</p>
<p>Yang, Z. (1997)
&ldquo;PAML: a program package for phylogenetic analysis by maximum
likelihood&rdquo;,
<em>Computer Applications in BioSciences</em>, <b>13</b>, 555-556.
<a href="http://abacus.gene.ucl.ac.uk/software/paml.html">http://abacus.gene.ucl.ac.uk/software/paml.html</a>
</p>
<p>Yang, Z. (2007)
&ldquo;PAML 4: a program package for phylogenetic analysis by maximum
likelihood&rdquo;,
<em>Molecular Biology and Evolution</em>, <b>24</b>, 1586-1591.
</p>
<p>Tzeng, J.Y. (2005)
&ldquo;Evolutionary-Based Grouping of Haplotypes in Association Analysis&rdquo;,
<em>Genetics Epidemiology</em>, <b>28</b>, 220-231.
<a href="https://www4.stat.ncsu.edu/~jytzeng/software.php">https://www4.stat.ncsu.edu/~jytzeng/software.php</a>
</p>
<p>Paradis E., Claude J., and Strimmer K. (2004)
&ldquo;APE: analyses of phylogenetics and evolution in R language&rdquo;,
<em>Bioinformatics</em>, <b>20</b>, 289-290.
<a href="http://ape-package.ird.fr/">http://ape-package.ird.fr/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+.EMC">.EMC</a></code>,
<code><a href="#topic+.EMControl">.EMControl</a></code>,
<code><a href="#topic+find.best">find.best</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

demo(package = "phyclust")
demo("ex_trees", package = "phyclust")

## End(Not run)
</code></pre>

<hr>
<h2 id='phyclust.e.step'>One E-Step of phyclust</h2><span id='topic+phyclust.e.step'></span>

<h3>Description</h3>

<p>This is a single E-step of <code>phyclust</code>, usually following or followed
by the other M-step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyclust.e.step(X, ret.phyclust = NULL, K = NULL, Eta = NULL,
    Mu = NULL, pi = NULL, kappa = NULL, Tt = NULL,
    substitution.model = NULL, identifier = NULL, code.type = NULL,
    Z.state = TRUE, label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyclust.e.step_+3A_x">X</code></td>
<td>
<p>nid/sid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="phyclust.e.step_+3A_ret.phyclust">ret.phyclust</code></td>
<td>
<p>an object with the class <code>phyclust</code>.</p>
</td></tr>
<tr><td><code id="phyclust.e.step_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="phyclust.e.step_+3A_eta">Eta</code></td>
<td>
<p>proportion of subpopulations, <code class="reqn">\eta_k</code>, length = <code>K</code>, sum to 1.</p>
</td></tr>
<tr><td><code id="phyclust.e.step_+3A_mu">Mu</code></td>
<td>
<p>centers of subpopulations, dim = <code class="reqn">K\times L</code>, each row is a center.</p>
</td></tr>
<tr><td><code id="phyclust.e.step_+3A_pi">pi</code></td>
<td>
<p>equilibrium probabilities, each row sums to 1.</p>
</td></tr>
<tr><td><code id="phyclust.e.step_+3A_kappa">kappa</code></td>
<td>
<p>transition and transversion bias.</p>
</td></tr>
<tr><td><code id="phyclust.e.step_+3A_tt">Tt</code></td>
<td>
<p>total evolution time, <code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code id="phyclust.e.step_+3A_substitution.model">substitution.model</code></td>
<td>
<p>substitution model.</p>
</td></tr>
<tr><td><code id="phyclust.e.step_+3A_identifier">identifier</code></td>
<td>
<p>identifier.</p>
</td></tr>
<tr><td><code id="phyclust.e.step_+3A_code.type">code.type</code></td>
<td>
<p>code type.</p>
</td></tr>
<tr><td><code id="phyclust.e.step_+3A_z.state">Z.state</code></td>
<td>
<p>see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="phyclust.e.step_+3A_label">label</code></td>
<td>
<p>label of sequences for semi-supervised clustering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> should be a numerical matrix containing sequence data that
can be transfered by <code>code2nid</code> or <code>code2sid</code>.
</p>
<p>Either input <code>ret.phyclust</code> or all other arguments for this function
except <code>Z.state</code>. <code>ret.phyclust</code> can be obtain either from an
EM iteration of <code>phyclust</code> or from a M step of <code>phyclust.m.step</code>.
</p>
<p><code>Z.state</code> indicates the return values of <code class="reqn">Z_{nk}</code>. If
TRUE, the <code>Z.normalized</code> returned by this function will be
posterior probabilities. Otherwise, it will be <code>logPt</code>, log of
transition probabilities, <code class="reqn">\log(\phi(\cdots))</code>.
</p>
<p>If <code>label</code> is inputted, the label information will be used
the E-step, even the <code>ret.phyclust</code> is the result of unsupervised
clustering.
</p>


<h3>Value</h3>

<p>This function returns a <code class="reqn">Z_{nk}</code> matrix with dimension =
<code class="reqn">N\times K</code>. The values is dependent on <code>Z.state</code>, and
they are either posterior probabilities if TRUE or transition
probabilities otherwise.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+phyclust.em.step">phyclust.em.step</a></code>,
<code><a href="#topic+phyclust.m.step">phyclust.m.step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
EMC.1 &lt;- .EMC
EMC.1$EM.iter &lt;- 1
# the same as EMC.1 &lt;- .EMControl(EM.iter = 1)
X &lt;- seq.data.toy$org

ret.1 &lt;- phyclust(X, 2, EMC = EMC.1)
ret.2 &lt;- phyclust.e.step(X, ret.phyclust = ret.1)
str(ret.2)

# For semi-supervised clustering.
semi.label &lt;- rep(0, nrow(X))
semi.label[1:3] &lt;- 1
ret.3 &lt;- phyclust.e.step(X, ret.phyclust = ret.1, label = semi.label)

## End(Not run)
</code></pre>

<hr>
<h2 id='phyclust.edist'>Evolution Distance of Sequences</h2><span id='topic+phyclust.edist'></span>

<h3>Description</h3>

<p>This computes pair wised evolution distance of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyclust.edist(X, edist.model = .edist.model[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyclust.edist_+3A_x">X</code></td>
<td>
<p>nid/sid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="phyclust.edist_+3A_edist.model">edist.model</code></td>
<td>
<p>evolution distance model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> should be a numerical matrix containing sequence data that
can be transfered by <code>code2nid</code> or <code>code2sid</code>.
</p>


<h3>Value</h3>

<p>This function returns a object with class <code>dist</code>.
</p>


<h3>ToDo(s)</h3>


<ul>
<li><p> incorporate <code>dist.dna</code> of <span class="pkg">ape</span>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.edist.model">.edist.model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

X &lt;- rbind(c(0, 2, 1, 3, 0, 2, 2, 0, 3, 2, 2),
           c(0, 0, 1, 3, 2, 2, 1, 0, 3, 1, 2),
           c(0, 2, 1, 1, 0, 2, 1, 3, 0, 0, 1),
           c(2, 2, 1, 1, 0, 0, 2, 3, 0, 2, 1),
           c(2, 2, 1, 1, 0, 0, 2, 3, 1, 2, 0))
(ret &lt;- phyclust.edist(X, edist.model = "D_HAMMING"))
str(ret)
as.matrix(ret)
plot(nj(ret), type = "u", no.margin = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='phyclust.em.step'>One EM-step of phyclust</h2><span id='topic+phyclust.em.step'></span>

<h3>Description</h3>

<p>This is a single EM-step of <code>phyclust</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyclust.em.step(X, ret.phyclust = NULL, K = NULL, Eta = NULL,
    Mu = NULL, pi = NULL, kappa = NULL, Tt = NULL,
    substitution.model = NULL, identifier = NULL, code.type = NULL,
    label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyclust.em.step_+3A_x">X</code></td>
<td>
<p>nid/sid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="phyclust.em.step_+3A_ret.phyclust">ret.phyclust</code></td>
<td>
<p>an object with the class <code>phyclust</code>.</p>
</td></tr>
<tr><td><code id="phyclust.em.step_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="phyclust.em.step_+3A_eta">Eta</code></td>
<td>
<p>proportion of subpopulations, <code class="reqn">\eta_k</code>, length = <code>K</code>, sum to 1.</p>
</td></tr>
<tr><td><code id="phyclust.em.step_+3A_mu">Mu</code></td>
<td>
<p>centers of subpopulations, dim = <code class="reqn">K\times L</code>, each row is a center.</p>
</td></tr>
<tr><td><code id="phyclust.em.step_+3A_pi">pi</code></td>
<td>
<p>equilibrium probabilities, each row sums to 1.</p>
</td></tr>
<tr><td><code id="phyclust.em.step_+3A_kappa">kappa</code></td>
<td>
<p>transition and transversion bias.</p>
</td></tr>
<tr><td><code id="phyclust.em.step_+3A_tt">Tt</code></td>
<td>
<p>total evolution time, <code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code id="phyclust.em.step_+3A_substitution.model">substitution.model</code></td>
<td>
<p>substitution model.</p>
</td></tr>
<tr><td><code id="phyclust.em.step_+3A_identifier">identifier</code></td>
<td>
<p>identifier.</p>
</td></tr>
<tr><td><code id="phyclust.em.step_+3A_code.type">code.type</code></td>
<td>
<p>code type.</p>
</td></tr>
<tr><td><code id="phyclust.em.step_+3A_label">label</code></td>
<td>
<p>label of sequences for semi-supervised clustering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> should be a numerical matrix containing sequence data that
can be transfered by <code>code2nid</code> or <code>code2sid</code>.
</p>
<p>Either input <code>ret.phyclust</code> or all other arguments for this function.
<code>ret.phyclust</code> can be obtained either from an EM iteration of
<code>phyclust</code> or from a M step of <code>phyclust.m.step</code>.
</p>
<p>If <code>label</code> is inputted, the label information will be used
the EM-step, even the <code>ret.phyclust</code> is the result of unsupervised
clustering.
</p>


<h3>Value</h3>

<p>This function returns an object with class <code>phyclust</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+phyclust.e.step">phyclust.e.step</a></code>,
<code><a href="#topic+phyclust.m.step">phyclust.m.step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(phyclust, quiet = TRUE)

set.seed(1234)
EMC.1 &lt;- .EMC
EMC.1$EM.iter &lt;- 1
# the same as EMC.1 &lt;- .EMControl(EM.iter = 1)
X &lt;- seq.data.toy$org

ret.1 &lt;- phyclust(X, 2, EMC = EMC.1)
ret.2 &lt;- phyclust.em.step(X, ret.phyclust = ret.1)
str(ret.2)

# For semi-supervised clustering.
semi.label &lt;- rep(0, nrow(X))
semi.label[1:3] &lt;- 1
ret.3 &lt;- phyclust.em.step(X, ret.phyclust = ret.1, label = semi.label)
str(ret.3)

</code></pre>

<hr>
<h2 id='phyclust.logL'>Log-Likelihood of phyclust</h2><span id='topic+phyclust.logL'></span>

<h3>Description</h3>

<p>This computes a log-likelihood value of <code>phyclust</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyclust.logL(X, ret.phyclust = NULL, K = NULL, Eta = NULL,
    Mu = NULL, pi = NULL, kappa = NULL, Tt = NULL,
    substitution.model = NULL, identifier = NULL, code.type = NULL,
    label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyclust.logL_+3A_x">X</code></td>
<td>
<p>nid/sid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="phyclust.logL_+3A_ret.phyclust">ret.phyclust</code></td>
<td>
<p>an object with the class <code>phyclust</code>.</p>
</td></tr>
<tr><td><code id="phyclust.logL_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="phyclust.logL_+3A_eta">Eta</code></td>
<td>
<p>proportion of subpopulations, <code class="reqn">\eta_k</code>, length = <code>K</code>, sum to 1.</p>
</td></tr>
<tr><td><code id="phyclust.logL_+3A_mu">Mu</code></td>
<td>
<p>centers of subpopulations, dim = <code class="reqn">K\times L</code>, each row is a center.</p>
</td></tr>
<tr><td><code id="phyclust.logL_+3A_pi">pi</code></td>
<td>
<p>equilibrium probabilities, each row sums to 1.</p>
</td></tr>
<tr><td><code id="phyclust.logL_+3A_kappa">kappa</code></td>
<td>
<p>transition and transversion bias.</p>
</td></tr>
<tr><td><code id="phyclust.logL_+3A_tt">Tt</code></td>
<td>
<p>total evolution time, <code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code id="phyclust.logL_+3A_substitution.model">substitution.model</code></td>
<td>
<p>substitution model.</p>
</td></tr>
<tr><td><code id="phyclust.logL_+3A_identifier">identifier</code></td>
<td>
<p>identifier.</p>
</td></tr>
<tr><td><code id="phyclust.logL_+3A_code.type">code.type</code></td>
<td>
<p>code type.</p>
</td></tr>
<tr><td><code id="phyclust.logL_+3A_label">label</code></td>
<td>
<p>label of sequences for semi-supervised clustering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> should be a numerical matrix containing sequence data that
can be transfered by <code>code2nid</code> or <code>code2sid</code>.
</p>
<p>Either input <code>ret.phyclust</code> or all other arguments for this function.
<code>ret.phyclust</code> can be obtain either from an EM iteration of
<code>phyclust</code> or from a M step of <code>phyclust.m.step</code>.
</p>
<p>If <code>label</code> is inputted, the label information will be used to
calculate log likelihood (complete-data), even the <code>ret.phyclust</code>
is the result of unsupervised clustering.
</p>


<h3>Value</h3>

<p>This function returns a log-likelihood value of <code>phyclust</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+phyclust.em.step">phyclust.em.step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

EMC.1 &lt;- .EMC
EMC.1$EM.iter &lt;- 1
# the same as EMC.1 &lt;- .EMControl(EM.iter = 1)
X &lt;- seq.data.toy$org

ret.1 &lt;- phyclust(X, 2, EMC = EMC.1)
phyclust.logL(X, ret.phyclust = ret.1)

# For semi-supervised clustering.
semi.label &lt;- rep(0, nrow(X))
semi.label[1:3] &lt;- 1
phyclust.logL(X, ret.phyclust = ret.1, label = semi.label)

## End(Not run)
</code></pre>

<hr>
<h2 id='phyclust.m.step'>One M-Step of phyclust</h2><span id='topic+phyclust.m.step'></span>

<h3>Description</h3>

<p>This is a single M-step of <code>phyclust</code>, usually following or followed
by the other E-step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyclust.m.step(X, ret.phyclust = NULL, K = NULL,
    pi = NULL, kappa = NULL, Tt = NULL, Z.normalized = NULL,
    substitution.model = NULL, identifier = NULL, code.type = NULL,
    label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyclust.m.step_+3A_x">X</code></td>
<td>
<p>nid/sid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="phyclust.m.step_+3A_ret.phyclust">ret.phyclust</code></td>
<td>
<p>an object with the class <code>phyclust</code>.</p>
</td></tr>
<tr><td><code id="phyclust.m.step_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="phyclust.m.step_+3A_pi">pi</code></td>
<td>
<p>equilibrium probabilities, each row sums to 1.</p>
</td></tr>
<tr><td><code id="phyclust.m.step_+3A_kappa">kappa</code></td>
<td>
<p>transition and transversion bias.</p>
</td></tr>
<tr><td><code id="phyclust.m.step_+3A_tt">Tt</code></td>
<td>
<p>total evolution time, <code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code id="phyclust.m.step_+3A_z.normalized">Z.normalized</code></td>
<td>
<p>posterior probabilities obtained from an E-step.</p>
</td></tr>
<tr><td><code id="phyclust.m.step_+3A_substitution.model">substitution.model</code></td>
<td>
<p>substitution model.</p>
</td></tr>
<tr><td><code id="phyclust.m.step_+3A_identifier">identifier</code></td>
<td>
<p>identifier.</p>
</td></tr>
<tr><td><code id="phyclust.m.step_+3A_code.type">code.type</code></td>
<td>
<p>code type.</p>
</td></tr>
<tr><td><code id="phyclust.m.step_+3A_label">label</code></td>
<td>
<p>label of sequences for semi-supervised clustering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> should be a numerical matrix containing sequence data that
can be transfered by <code>code2nid</code> or <code>code2sid</code>.
</p>
<p>Either input <code>ret.phyclust</code> or all other arguments for this function.
<code>ret.phyclust</code> can be obtained either from an EM iteration of
<code>phyclust</code> or from a E step of <code>phyclust.e.step</code>.
</p>
<p>If <code>label</code> is inputted, the label information will be used
the M-step and <code>Z.normalized</code> will be replaced, even the
<code>ret.phyclust</code> is the result of unsupervised clustering.
</p>


<h3>Value</h3>

<p>This function returns an object with class <code>phyclust</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+phyclust.em.step">phyclust.em.step</a></code>,
<code><a href="#topic+phyclust.e.step">phyclust.e.step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
EMC.1 &lt;- .EMC
EMC.1$short.iter &lt;- 1
EMC.1$EM.iter &lt;- 1

# Test with phyclust.
X &lt;- seq.data.toy$org
ret.1 &lt;- phyclust(X, 2, EMC = EMC.1)

# Test with an em step.
ret.em &lt;- phyclust.em.step(X, ret.1)

# Test with an E- and M-step.
ret.1$Z.normalized &lt;- phyclust.e.step(X, ret.phyclust = ret.1)
ret.m &lt;- phyclust.m.step(X, ret.phyclust = ret.1)

# Test with 2 em steps.
set.seed(1234)
EMC.2 &lt;- EMC.1
EMC.2$EM.iter &lt;- 2
ret.2 &lt;- phyclust(X, 2, EMC = EMC.2)

# Check logL.
phyclust.logL(X, ret.1)
phyclust.logL(X, ret.em)
phyclust.logL(X, ret.m)
phyclust.logL(X, ret.2)

# For semi-supervised.
semi.label &lt;- rep(0, nrow(X))
semi.label[1:3] &lt;- 1
ret.m.1 &lt;- phyclust.m.step(X, ret.phyclust = ret.1, label = semi.label)

## End(Not run)
</code></pre>

<hr>
<h2 id='phyclust.Pt'>Transition Probabilities of phyclust Given Time</h2><span id='topic+phyclust.Pt'></span>

<h3>Description</h3>

<p>This computes transition probabilities of <code>phyclust</code> given time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyclust.Pt(Q, Tt, substitution.model = .substitution.model$model[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyclust.Pt_+3A_q">Q</code></td>
<td>
<p>a list according to the substitution model.</p>
</td></tr>
<tr><td><code id="phyclust.Pt_+3A_tt">Tt</code></td>
<td>
<p>total evolution time, <code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code id="phyclust.Pt_+3A_substitution.model">substitution.model</code></td>
<td>
<p>substitution model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The major models for <code>Q</code> are:
</p>

<table>
<tr>
 <td style="text-align: left;">
      Model </td><td style="text-align: left;"> Author and Publication            </td><td style="text-align: left;"> Parameter </td>
</tr>
<tr>
 <td style="text-align: left;">
      JC69  </td><td style="text-align: left;"> Jukes and Cantor 1969.            </td><td style="text-align: left;"> <code class="reqn">t</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
      K80   </td><td style="text-align: left;"> Kimura 1980.                      </td><td style="text-align: left;"> <code class="reqn">\kappa, t</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
      F81   </td><td style="text-align: left;"> Felsenstein 1981.                 </td><td style="text-align: left;"> <code class="reqn">\pi, t</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
      HKY85 </td><td style="text-align: left;"> Hasegawa, Kishino, and Yano 1985. </td><td style="text-align: left;"> <code class="reqn">\pi, \kappa, t</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p>A list of <code>Q</code> should contains <code>pi</code>, <code>kappa</code> based on
substitution models and code types. <code>Tt</code> may be separately stored.
Depending on identifiers, <code>Q</code>s can be composite to a <code>QA</code>,
Q matrix array.
</p>


<h3>Value</h3>

<p>A list with class <code>Pt</code> will be returned containing several
elements as the following:
</p>
<table>
<tr><td><code>'Pt'</code></td>
<td>
<p>a transition probability matrix.</p>
</td></tr>
<tr><td><code>'log.Pt'</code></td>
<td>
<p>a log transition probability matrix.</p>
</td></tr>
<tr><td><code>'H'</code></td>
<td>
<p>a negative entropy, <code>diag(Pt %*% t(log.Pt))</code>.</p>
</td></tr>
</table>


<h3>ToDo(s)</h3>


<ul>
<li><p> vectorize <code>Tt</code> for repeated computation in C.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.substitution.model">.substitution.model</a></code>,
<code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+phyclust.em.step">phyclust.em.step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

Tt &lt;- 0.5

Q &lt;- list(pi = c(0.25, 0.25, 0.25, 0.25), kappa = 0.5)
phyclust.Pt(Q, Tt, "HKY85")

Q &lt;- list(pi = c(0.5, 0.5), kappa = 0.5)
phyclust.Pt(Q, Tt, "SNP_JC69")

## End(Not run)
</code></pre>

<hr>
<h2 id='phyclust.se'>The Main Function of phyclust for Sequencing Error Models</h2><span id='topic+phyclust.se'></span>

<h3>Description</h3>

<p>The <code>phyclust.se</code> is an advanced function of <code>phyclust</code>.
The <code>phyclust.se</code> implements finite mixture models for sequence data
with sequencing errors. The same as <code>phyclust</code>,
the mutation processes are modeled by evolution processes based on
Continuous Time Markov Chain theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyclust.se(X, K, EMC = .EMC, manual.id = NULL, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyclust.se_+3A_x">X</code></td>
<td>
<p>nid/sid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="phyclust.se_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="phyclust.se_+3A_emc">EMC</code></td>
<td>
<p>EM control.</p>
</td></tr>
<tr><td><code id="phyclust.se_+3A_manual.id">manual.id</code></td>
<td>
<p>manually input class ids.</p>
</td></tr>
<tr><td><code id="phyclust.se_+3A_byrow">byrow</code></td>
<td>
<p>advanced option for <code>X</code>, default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>phyclust.se</code> considers mutations with sequencing error, but only
for NUCLEOTIDE data and only the EM algorithm is
implemented. Currently, <code>phyclust.se</code> implements the following steps:
</p>

<table>
<tr>
 <td style="text-align: left;">
  1 </td><td style="text-align: left;"> assume non-sequencing errors as the <code>phyclust</code> does. </td>
</tr>
<tr>
 <td style="text-align: left;">
  2 </td><td style="text-align: left;"> use the initialization as the <code>phyclust</code> does. </td>
</tr>
<tr>
 <td style="text-align: left;">
  3 </td><td style="text-align: left;"> run the <code>phyclust</code> to find the non-sequencing error MLE's. </td>
</tr>
<tr>
 <td style="text-align: left;">
  4 </td><td style="text-align: left;"> initial by the results of <code>phyclust</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
  5 </td><td style="text-align: left;"> update all parameters including probabilities of sequencing errors. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>See the help page of <code><a href="#topic+phyclust">phyclust</a></code> for the explanations of
input arguments since both functions share the same arguments. Note that
the underling model assumptions are very different of both functions.
</p>


<h3>Value</h3>

<p>A list with class <code>phyclust</code> will be returned containing
several elements as described in <code><a href="#topic+phyclust">phyclust</a></code>. But, the
<code>phyclust.se</code> returns extra parameters for sequencing errors, and
they are shown in the following:
</p>
<table>
<tr><td><code>'SE'</code></td>
<td>
<p>a list returning parameters of sequencing error models, including:
</p>

<table>
<tr>
 <td style="text-align: left;">
              'type'     </td><td style="text-align: left;"> 'TRUE' for modeling sequencing errors.          </td>
</tr>
<tr>
 <td style="text-align: left;">
              'model'    </td><td style="text-align: left;"> 'CONVOLUTION', the only model implemented.      </td>
</tr>
<tr>
 <td style="text-align: left;">
              'constant' </td><td style="text-align: left;"> the constrained constant for sequencing errors. </td>
</tr>
<tr>
 <td style="text-align: left;">
              'f.err'    </td><td style="text-align: left;"> probability matrix, each row sums to 1.         </td>
</tr>
<tr>
 <td style="text-align: left;">
              </td>
</tr>

</table>

</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.EMC">.EMC</a></code>,
<code><a href="#topic+.EMControl">.EMControl</a></code>,
<code><a href="#topic+phyclust.se">phyclust.se</a></code>,
<code><a href="#topic+phyclust.se.update">phyclust.se.update</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

X &lt;- seq.data.toy$org

set.seed(1234)
(ret.1 &lt;- phyclust.se(X, 3))

## End(Not run)
</code></pre>

<hr>
<h2 id='phyclust.se.update'>Update phyclust Results by the Sequencing Error Model</h2><span id='topic+phyclust.se.update'></span>

<h3>Description</h3>

<p>Since <code>phyclust.se</code> is difficult to optimize on a constrained high
dimension parameter space, the <code>phyclust</code> is relatively easier to
find a better result, as well as the <code>find.best</code> function.
</p>
<p>This function will use the <code>phyclust</code> result as initial parameters and
perform a sequencing error model. All parameters (Eta, Mu, Q, ...) in this
function will be updated through the EM algorithm as <code>phyclust.se</code>.
</p>
<p>Typically, this function run on the <code>find.best</code> results will yield
a better result than on the <code>phyclust.se</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyclust.se.update(X, EMC = .EMC, ret.phyclust = NULL,
    K = NULL, Eta = NULL, Mu = NULL, pi = NULL, kappa = NULL,
    Tt = NULL, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyclust.se.update_+3A_x">X</code></td>
<td>
<p>nid/sid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="phyclust.se.update_+3A_emc">EMC</code></td>
<td>
<p>EM control.</p>
</td></tr>
<tr><td><code id="phyclust.se.update_+3A_ret.phyclust">ret.phyclust</code></td>
<td>
<p>an object with the class <code>phyclust</code>.</p>
</td></tr>
<tr><td><code id="phyclust.se.update_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="phyclust.se.update_+3A_eta">Eta</code></td>
<td>
<p>proportion of subpopulations, <code class="reqn">\eta_k</code>, length = <code>K</code>, sum to 1.</p>
</td></tr>
<tr><td><code id="phyclust.se.update_+3A_mu">Mu</code></td>
<td>
<p>centers of subpopulations, dim = <code class="reqn">K\times L</code>, each row is a center.</p>
</td></tr>
<tr><td><code id="phyclust.se.update_+3A_pi">pi</code></td>
<td>
<p>equilibrium probabilities, each row sums to 1.</p>
</td></tr>
<tr><td><code id="phyclust.se.update_+3A_kappa">kappa</code></td>
<td>
<p>transition and transversion bias.</p>
</td></tr>
<tr><td><code id="phyclust.se.update_+3A_tt">Tt</code></td>
<td>
<p>total evolution time, <code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code id="phyclust.se.update_+3A_byrow">byrow</code></td>
<td>
<p>advanced option for <code>X</code>, default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the input arguments are the same as the inputs of the function
<code>phyclust.em.step</code> and <code>phyclust.update</code>.
</p>


<h3>Value</h3>

<p>This function returns an object with class <code>phyclust</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust.se">phyclust.se</a></code>,
<code><a href="#topic+phyclust.update">phyclust.update</a></code>,
<code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+find.best">find.best</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
X &lt;- seq.data.toy$org

(ret.1 &lt;- find.best(X, 4))
(ret.2 &lt;- phyclust.se.update(X, ret.phyclust = ret.1))
.EMC$se.constant &lt;- 1e-3
(ret.3 &lt;- phyclust.se.update(X, ret.phyclust = ret.2))

### Search optimal error
func &lt;- function(C){
  .EMC$se.constant &lt;&lt;- C
  -phyclust.se.update(X, ret.phyclust = ret.1)$logL
}
(ret.opt &lt;- optimize(f = func, lower = 1e-3, upper = 1e-1))
.EMC$se.constant &lt;- ret.opt$minimum
(ret.se.opt &lt;- phyclust.se.update(X, ret.phyclust = ret.1))

## End(Not run)
</code></pre>

<hr>
<h2 id='phyclust.update'>Update phyclust Results</h2><span id='topic+phyclust.update'></span>

<h3>Description</h3>

<p>This function will run the EM algorithm on initial parameters
specified by users or from other initial procedures. All parameters
(Eta, Mu, Q, ...) in this function will be updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyclust.update(X, EMC = .EMC, ret.phyclust = NULL, K = NULL,
    Eta = NULL, Mu = NULL, pi = NULL, kappa = NULL, Tt = NULL,
    label = NULL, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyclust.update_+3A_x">X</code></td>
<td>
<p>nid/sid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="phyclust.update_+3A_emc">EMC</code></td>
<td>
<p>EM control.</p>
</td></tr>
<tr><td><code id="phyclust.update_+3A_ret.phyclust">ret.phyclust</code></td>
<td>
<p>an object with the class <code>phyclust</code>.</p>
</td></tr>
<tr><td><code id="phyclust.update_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="phyclust.update_+3A_eta">Eta</code></td>
<td>
<p>proportion of subpopulations, <code class="reqn">\eta_k</code>, length = <code>K</code>, sum to 1.</p>
</td></tr>
<tr><td><code id="phyclust.update_+3A_mu">Mu</code></td>
<td>
<p>centers of subpopulations, dim = <code class="reqn">K\times L</code>, each row is a center.</p>
</td></tr>
<tr><td><code id="phyclust.update_+3A_pi">pi</code></td>
<td>
<p>equilibrium probabilities, each row sums to 1.</p>
</td></tr>
<tr><td><code id="phyclust.update_+3A_kappa">kappa</code></td>
<td>
<p>transition and transversion bias.</p>
</td></tr>
<tr><td><code id="phyclust.update_+3A_tt">Tt</code></td>
<td>
<p>total evolution time, <code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code id="phyclust.update_+3A_label">label</code></td>
<td>
<p>label of sequences for semi-supervised clustering.</p>
</td></tr>
<tr><td><code id="phyclust.update_+3A_byrow">byrow</code></td>
<td>
<p>advanced option for <code>X</code>, default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is equivalent to run <code>exhaustEM</code> on one specified
initial parameters, and no initial procedure is involved. While this
function is a little bit different to run <code>phyclust</code> with
<code>manual.id</code> where <code>Mu</code> will be reestimated as the new initials.
Simply speaking, this function only runs the EM algorithm given the
initial parameters.
</p>
<p>All the input arguments are the same as the inputs of the functions
<code>phyclust</code> and <code>phyclust.em.step</code>.
</p>


<h3>Value</h3>

<p>This function returns an object with class <code>phyclust</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+find.best">find.best</a></code>,
<code><a href="#topic+phyclust.se">phyclust.se</a></code>,
<code><a href="#topic+phyclust.se.update">phyclust.se.update</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
EMC.1 &lt;- .EMC
EMC.1$EM.iter &lt;- 1
# the same as EMC.1 &lt;- .EMControl(EM.iter = 1)
X &lt;- seq.data.toy$org

(ret.1 &lt;- phyclust(X, 2, EMC = EMC.1))
(ret.2 &lt;- phyclust.update(X, ret.phyclust = ret.1))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotdots'>Dots Plots of Sequences for Visual Comparisons</h2><span id='topic+plotdots'></span>

<h3>Description</h3>

<p>This function provides dots plots of data set given an idea how diverse
the sequences are by drawing dots with different colors for all mutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotdots(X, X.class = NULL, Mu = NULL, code.type = .code.type[1],
    diff.only = TRUE, fill = FALSE, label = TRUE, with.gap = FALSE,
    xlim = NULL, ylim = NULL, main = "Dots Plot", xlab = "Sites",
    ylab = "Sequences", missing.col = "gray95", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotdots_+3A_x">X</code></td>
<td>
<p>numerical data matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="plotdots_+3A_x.class">X.class</code></td>
<td>
<p>class ids indicated for all sequences.</p>
</td></tr>
<tr><td><code id="plotdots_+3A_mu">Mu</code></td>
<td>
<p>a center sequence with length <code class="reqn">L</code>.</p>
</td></tr>
<tr><td><code id="plotdots_+3A_code.type">code.type</code></td>
<td>
<p>either &quot;NUCLEOTIDE&quot; (default) or &quot;SNP&quot;.</p>
</td></tr>
<tr><td><code id="plotdots_+3A_diff.only">diff.only</code></td>
<td>
<p>draw the segregating sites only, default = TRUE.</p>
</td></tr>
<tr><td><code id="plotdots_+3A_fill">fill</code></td>
<td>
<p>fill in all dots, default = FALSE.</p>
</td></tr>
<tr><td><code id="plotdots_+3A_label">label</code></td>
<td>
<p>indicate segregating sites, default = TRUE.</p>
</td></tr>
<tr><td><code id="plotdots_+3A_with.gap">with.gap</code></td>
<td>
<p>pass to <code>find.consensus</code> if <code>Mu</code> is <code>NULL</code>, default = FALSE</p>
</td></tr>
<tr><td><code id="plotdots_+3A_xlim">xlim</code></td>
<td>
<p>limit of x-axis.</p>
</td></tr>
<tr><td><code id="plotdots_+3A_ylim">ylim</code></td>
<td>
<p>limit of y-axis.</p>
</td></tr>
<tr><td><code id="plotdots_+3A_main">main</code></td>
<td>
<p>main label, default = &quot;Dots Plot&quot;.</p>
</td></tr>
<tr><td><code id="plotdots_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label, default = &quot;Sites&quot;. </p>
</td></tr>
<tr><td><code id="plotdots_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label, default = &quot;Sequences&quot;. </p>
</td></tr>
<tr><td><code id="plotdots_+3A_missing.col">missing.col</code></td>
<td>
<p>color for the missing allele, default = NA. </p>
</td></tr>
<tr><td><code id="plotdots_+3A_...">...</code></td>
<td>
<p>other options passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first rows in <code>Mu</code> will be drawn entirely on dots plots
in colors which are &quot;green3&quot;, &quot;blue2&quot;, <code>#CC00CC</code>, &quot;red2&quot;, &quot;gray&quot;,
and &quot;white&quot;, according the ids + 1. If <code>fill</code> is FALSE, other sequences
will be drawn by the mutation sites comparing to the first sequences.
Otherwise, they be drawn entirely.
</p>
<p>If <code>X.class</code> is set, the sequences will be drawn in cluster order.
</p>
<p>If <code>Mu</code> is <code>NULL</code>, the consensus sequence of <code>X</code> will be drawn.
</p>
<p>If <code>label</code> is TRUE, the bottom row will be drawn in color &quot;orange&quot;
to indicate segregating sites.
</p>
<p><code>with.gap</code> is only used when <code>Mu</code> is <code>NULL</code>.
</p>


<h3>Value</h3>

<p>A dots plot will be drawn.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqgen">seqgen</a></code>,
<code><a href="#topic+plothist">plothist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

# For nucleotide
X &lt;- seq.data.toy$org
par(mfrow = c(2, 2))
plotdots(X)
plotdots(X, diff.only = FALSE)
plotdots(X, diff.only = FALSE, label = FALSE)
plotdots(X, fill = TRUE, diff.only = FALSE, label = FALSE)

# With class ids
X.class &lt;- as.numeric(gsub(".*-(.*)", "\\1", seq.data.toy$seqname))
plotdots(X, X.class)

# For SNP
X.SNP &lt;- nid2sid(X)
plotdots(X.SNP, X.class)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotgaps'>Gaps Plots of Sequences for Visual Comparisons</h2><span id='topic+plotgaps'></span>

<h3>Description</h3>

<p>This function provides gaps plots of data set to identify regions where
gaps enriched. The plot show the proportions of context by sites and the
diverse may be caused by mutations, sequencing errors, or alignment
errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotgaps(X, code.type = .code.type[1], main = "Gaps Plot",
    xlab = "Sites", ylab = "Proportion", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotgaps_+3A_x">X</code></td>
<td>
<p>numerical data matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="plotgaps_+3A_code.type">code.type</code></td>
<td>
<p>either &quot;NUCLEOTIDE&quot; (default) or &quot;SNP&quot;.</p>
</td></tr>
<tr><td><code id="plotgaps_+3A_main">main</code></td>
<td>
<p>main label, default = &quot;Gaps Plot&quot;.</p>
</td></tr>
<tr><td><code id="plotgaps_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label, default = &quot;Sites&quot;. </p>
</td></tr>
<tr><td><code id="plotgaps_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label, default = &quot;Proportion&quot;. </p>
</td></tr>
<tr><td><code id="plotgaps_+3A_...">...</code></td>
<td>
<p>other options passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Proportions of gaps will be drawn.
</p>


<h3>Value</h3>

<p>A gaps plot will be drawn.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotdots">plotdots</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

# For nucleotide
set.seed(1234)
X &lt;- seq.data.toy$org
X[sample(c(T, F), length(X), replace = TRUE, prob = c(0.05, 0.95))] &lt;-
  .nucleotide$nid[.nucleotide$code == "-"]
plotgaps(X)

## End(Not run)
</code></pre>

<hr>
<h2 id='plothist'>Plot Histogram to Compare Number of Mutations.</h2><span id='topic+plothist'></span>

<h3>Description</h3>

<p>Plot histogram to compare number of mutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plothist(X, X.class = NULL, Mu = NULL, fill.color = .Color,
   draw.all = TRUE, main = "Mutation counts",
   xlab = "Difference", ylab = "Counts", append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plothist_+3A_x">X</code></td>
<td>
<p>nid/sid matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="plothist_+3A_x.class">X.class</code></td>
<td>
<p>class ids indicated for all sequences.</p>
</td></tr>
<tr><td><code id="plothist_+3A_mu">Mu</code></td>
<td>
<p>a central sequence with length <code class="reqn">L</code>.</p>
</td></tr>
<tr><td><code id="plothist_+3A_fill.color">fill.color</code></td>
<td>
<p>color to fill the histogram.</p>
</td></tr>
<tr><td><code id="plothist_+3A_draw.all">draw.all</code></td>
<td>
<p>draw a histogram use all sequences.</p>
</td></tr>
<tr><td><code id="plothist_+3A_main">main</code></td>
<td>
<p>main label, default = &quot;Mutation counts&quot;.</p>
</td></tr>
<tr><td><code id="plothist_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label, default = &quot;Difference&quot;. </p>
</td></tr>
<tr><td><code id="plothist_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label, default = &quot;Counts&quot;. </p>
</td></tr>
<tr><td><code id="plothist_+3A_append">append</code></td>
<td>
<p>overwrite histograms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>X.class</code> is set, the histograms will be drawn by classes and
all sequences will be compared to the central sequence <code>Mu</code>.
Otherwise, all sequences will be used to count mutations.
<code>draw.all</code> is not effect if <code>X.class</code> is not set.
</p>
<p>If <code>Mu</code> is set, it will be used to compare to all other sequences
to count mutations. Otherwise, the first sequence of <code>X</code> will be
used, and the first sequence in the first class will be used if
<code>X.class</code> is set. If <code>Mu</code> is a matrix, the first row will be
used as the central sequence.
</p>


<h3>Value</h3>

<p>Histograms will be drawn to show the number of mutations away from
the central sequence.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqgen">seqgen</a></code>,
<code><a href="#topic+plotdots">plotdots</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

X &lt;- seq.data.toy$org
plothist(X)

# With class ids
X.class &lt;- as.numeric(gsub(".*-(.*)", "\\1", seq.data.toy$seqname))
plothist(X, X.class)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotnj'>Plot an Unrooted Trees.</h2><span id='topic+plotnj'></span>

<h3>Description</h3>

<p>This is a enhanced version of <code>plot.phylo</code> in <span class="pkg">ape</span> which
can plot trees in <code>Class phylo</code> including neighbor-joining trees,
unrooted trees, trees with star shapes, ... etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotnj(unrooted.tree, X.class = NULL, type = "u", main = NULL,
   show.tip.label = FALSE, show.node.label = FALSE,
   edge.width = 1, edge.width.class = edge.width, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotnj_+3A_unrooted.tree">unrooted.tree</code></td>
<td>
<p>an unrooted tree in <code>Class phylo</code>.</p>
</td></tr>
<tr><td><code id="plotnj_+3A_x.class">X.class</code></td>
<td>
<p>class ids indicated for all tips.</p>
</td></tr>
<tr><td><code id="plotnj_+3A_type">type</code></td>
<td>
<p>plot types, see <code>plot.phylo</code> in <span class="pkg">ape</span> for details.</p>
</td></tr>
<tr><td><code id="plotnj_+3A_main">main</code></td>
<td>
<p>main label.</p>
</td></tr>
<tr><td><code id="plotnj_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>show tip label if available.</p>
</td></tr>
<tr><td><code id="plotnj_+3A_show.node.label">show.node.label</code></td>
<td>
<p>show node label if available.</p>
</td></tr>
<tr><td><code id="plotnj_+3A_edge.width">edge.width</code></td>
<td>
<p>edge width for all internal branches if <code>X.class</code> is set.</p>
</td></tr>
<tr><td><code id="plotnj_+3A_edge.width.class">edge.width.class</code></td>
<td>
<p>edge width for tip branches if <code>X.class</code> is set.</p>
</td></tr>
<tr><td><code id="plotnj_+3A_...">...</code></td>
<td>
<p>other options passed to <code>plot.phylo</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is built to plot unrooted trees, but it may also apply
for other trees in <code>Class phylo</code>.
</p>
<p><code>type</code> can be &quot;u&quot;, &quot;p&quot;, &quot;c&quot;, &quot;f&quot;, &quot;r&quot; as in <code>plot.phylo</code>.
</p>
<p>If <code>X.class</code> is set, then the tip branches will be drawn with
colors by class ids, and the colors are controlled by <code>.color</code>.
The width of branches is controlled by <code>edge.width</code> for all internal
branches and by <code>edge.width.class</code> for tip branches.
</p>


<h3>Value</h3>

<p>Return a tree plot.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>,
<code><a href="#topic+.Color">.Color</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
ret.ms &lt;- ms(nsam = 24, opts = "-T -G 0.5")
tree.anc &lt;- read.tree(text = ret.ms[3])

is.rooted(tree.anc)
tree.new &lt;- as.star.tree(tree.anc)
X.class &lt;- rep(1:6, each = 4)

par(mfrow = c(2, 2))
plotnj(tree.anc, X.class, type = "u", edge.width.class = 2,
       main = "unrooted tree")
plotnj(tree.new, X.class, type = "u", edge.width.class = 2,
       main = "star tree")
plotnj(tree.anc, X.class, type = "c", edge.width.class = 2,
       main = "unrooted tree in cladogram")
plotnj(tree.new, X.class, type = "r", edge.width.class = 2,
       main = "star tree in radial")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotstruct'>Struct Plots of Observations Based on Posterior Probabilities</h2><span id='topic+plotstruct'></span>

<h3>Description</h3>

<p>This function provides structure plots of data set given based on posterior
probabilities, the <code>Z.normalized</code> matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotstruct(Z, X.class = NULL, sort.inside.class = TRUE,
    direction = "h", main = "Structure Plot", xlab = "Observations",
    ylab = "Posterior Probabilities", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotstruct_+3A_z">Z</code></td>
<td>
<p>a Z matrix as Z.normalized in <code>Class phyclust</code>.</p>
</td></tr>
<tr><td><code id="plotstruct_+3A_x.class">X.class</code></td>
<td>
<p>class ids indicated for all observations</p>
</td></tr>
<tr><td><code id="plotstruct_+3A_sort.inside.class">sort.inside.class</code></td>
<td>
<p>sort observations inside class by max posteriors.</p>
</td></tr>
<tr><td><code id="plotstruct_+3A_direction">direction</code></td>
<td>
<p>either &quot;h&quot; for horizontal or &quot;v&quot; for vertical.</p>
</td></tr>
<tr><td><code id="plotstruct_+3A_main">main</code></td>
<td>
<p>main label, default = &quot;Structure Plot&quot;.</p>
</td></tr>
<tr><td><code id="plotstruct_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label, default = &quot;Observations&quot;. </p>
</td></tr>
<tr><td><code id="plotstruct_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label, default = &quot;Posterior Probabilities&quot;. </p>
</td></tr>
<tr><td><code id="plotstruct_+3A_...">...</code></td>
<td>
<p>other options passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The posterior probabilities in <code>ret.phyclust$Z.normalized</code> will
be drawn in colors.
</p>
<p>If <code>X.class</code> is submitted, the plot will draw in the order of
class ids and the <code>sort.inside.class</code> will be skipped.
</p>


<h3>Value</h3>

<p>A structure plot will be drawn.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+find.best">find.best</a></code>,
<code><a href="#topic+plotdots">plotdots</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
ret.1 &lt;- phyclust(seq.data.toy$org, 3)
plotstruct(ret.1$Z.normalized)
windows()
plotstruct(ret.1$Z.normalized, sort.inside.class = FALSE)

# With class ids
X.class &lt;- as.numeric(gsub(".*-(.*)", "\\1", seq.data.toy$seqname))
windows()
plotstruct(ret.1$Z.normalized, X.class = X.class)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.object'>Functions for Printing or Summarizing Objects According to Classes</h2><span id='topic+print.baseml'></span><span id='topic+print.ms'></span><span id='topic+print.phyclust'></span><span id='topic+print.Pt'></span><span id='topic+print.RRand'></span><span id='topic+print.seq.data'></span><span id='topic+print.seqgen'></span><span id='topic+summary.phyclust'></span>

<h3>Description</h3>

<p>Several classes are declared in <span class="pkg">phyclust</span>, and these are functions
to print and summary objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'baseml'
print(x, ...)
## S3 method for class 'ms'
print(x, ...)
## S3 method for class 'phyclust'
print(x, digits = max(4, getOption("digits") - 3), ...)
## S3 method for class 'Pt'
print(x, ...)
## S3 method for class 'RRand'
print(x, digits = max(4, getOption("digits") - 3), ...)
## S3 method for class 'seq.data'
print(x, ...)
## S3 method for class 'seqgen'
print(x, ...)
## S3 method for class 'phyclust'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.object_+3A_x">x</code></td>
<td>
<p>an object with the class attributes.</p>
</td></tr>
<tr><td><code id="print.object_+3A_digits">digits</code></td>
<td>
<p>for printing out numbers.</p>
</td></tr>
<tr><td><code id="print.object_+3A_object">object</code></td>
<td>
<p>an object with the class attributes.</p>
</td></tr>
<tr><td><code id="print.object_+3A_...">...</code></td>
<td>
<p>other possible options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are useful functions for summarizing and debugging.
</p>
<p>For <code>ms</code>, <code>seqgen</code>, and <code>paml.baseml</code>, it will show the
result as standalone versions on the STDOUT out with line by line.
</p>
<p>For other functions, they only show summaries of objects. Use
<code>names</code> or <code>str</code> to explore the details.
</p>


<h3>Value</h3>

<p>The results will cat or print on the STDOUT by default.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ms">ms</a></code>,
<code><a href="#topic+paml.baseml">paml.baseml</a></code>,
<code><a href="#topic+phyclust">phyclust</a></code>,
<code><a href="#topic+phyclust.Pt">phyclust.Pt</a></code>,
<code><a href="#topic+RRand">RRand</a></code>,
<code><a href="#topic+seqgen">seqgen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

# Functions applied by directly type the names of objects.

## End(Not run)
</code></pre>

<hr>
<h2 id='prune.Mu'>Prune the Center Sequences Mu</h2><span id='topic+prune.Mu'></span>

<h3>Description</h3>

<p>This function prune the center sequences Mu where the sites will be reset
as GAPs if all members within the same cluster are all GAPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune.Mu(X, X.class, Mu, code.type = .code.type[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune.Mu_+3A_x">X</code></td>
<td>
<p>numerical data matrix with <code class="reqn">N</code> rows/sequences and <code class="reqn">L</code> columns/sites.</p>
</td></tr>
<tr><td><code id="prune.Mu_+3A_x.class">X.class</code></td>
<td>
<p>class ids indicated for all sequences.</p>
</td></tr>
<tr><td><code id="prune.Mu_+3A_mu">Mu</code></td>
<td>
<p>a center sequence with length <code class="reqn">L</code>.</p>
</td></tr>
<tr><td><code id="prune.Mu_+3A_code.type">code.type</code></td>
<td>
<p>either &quot;NUCLEOTIDE&quot; (default) or &quot;SNP&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each cluster indicated by <code>X.class</code>, this function will prune
<code>Mu</code> and reset the sites as GAPs if all members within cluster
are all GAPs. <code>Mu</code> are usually the returning values of
<code>phyclust()</code>.
</p>


<h3>Value</h3>

<p>A pruned <code>Mu</code> will be returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyclust">phyclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

X &lt;- seq.data.toy$org
X[, 5] &lt;- .nucleotide$nid[.nucleotide$code == "-"]
ret &lt;- phyclust(X, 2)
Mu.GAPs &lt;- prune.Mu(X, ret$class.id, ret$Mu)

ret$Mu[, 5]
Mu.GAPs[, 5]  # Replace by GAPs.

## End(Not run)
</code></pre>

<hr>
<h2 id='read.seqgen'>Read seqgen's Results and Return a seq.data</h2><span id='topic+read.seqgen'></span>

<h3>Description</h3>

<p>This function can read the results generated by <code>seqgen</code> and
turn into a object in <code>Class seq.data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.seqgen(text, byrow = TRUE, code.type = .code.type[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.seqgen_+3A_text">text</code></td>
<td>
<p>a text vector generated by <code>seqgen</code>.</p>
</td></tr>
<tr><td><code id="read.seqgen_+3A_byrow">byrow</code></td>
<td>
<p>advanced option, default = TRUE.</p>
</td></tr>
<tr><td><code id="read.seqgen_+3A_code.type">code.type</code></td>
<td>
<p>either &quot;NUCLEOTIDE&quot; (default) or &quot;SNP&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>code.type</code> is &quot;SNP&quot;, the A, G will be transfered to 1, and
the C, T will be transfered to 2.
</p>


<h3>Value</h3>

<p>Return an object in <code>Class seq.data</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqgen">seqgen</a></code>,
<code><a href="#topic+gen.seq.HKY">gen.seq.HKY</a></code>,
<code><a href="#topic+gen.seq.SNP">gen.seq.SNP</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(123)
ret.ms &lt;- ms(nsam = 5, nreps = 1, opts = "-T")
ret.seqgen &lt;- seqgen(opts = "-mHKY -l40 -s0.2", newick.tree = ret.ms[3])
(ret.nucleotide &lt;- read.seqgen(ret.seqgen))
(ret.snp &lt;- read.seqgen(ret.seqgen, code.type = "SNP"))

## End(Not run)
</code></pre>

<hr>
<h2 id='rescale.rooted.tree'>Rescale a Rooted Tree's Height</h2><span id='topic+rescale.rooted.tree'></span>

<h3>Description</h3>

<p>This function rescaled the input rooted tree height by a scale.height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale.rooted.tree(rooted.tree, scale.height = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale.rooted.tree_+3A_rooted.tree">rooted.tree</code></td>
<td>
<p>a rooted tree in <code>Class phylo</code>.</p>
</td></tr>
<tr><td><code id="rescale.rooted.tree_+3A_scale.height">scale.height</code></td>
<td>
<p>a scale to all branch lengths.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rooted.tree</code> should be in a <code>phylo</code> class of <span class="pkg">ape</span>,
and may be created by <code>ms</code>.
</p>
<p><code>scale.height</code> is a positive number multiplying on the lengths of
all branches of the rooted tree.
</p>


<h3>Value</h3>

<p>Return a rooted tree in <code>Class phylo</code> with scaled branches.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ms">ms</a></code>,
<code><a href="ape.html#topic+read.tree">read.tree</a></code>,
<code><a href="ape.html#topic+as.phylo">as.phylo</a></code>,
<code><a href="#topic+get.rooted.tree.height">get.rooted.tree.height</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(1234)
ret.ms &lt;- ms(5, 1, opts = paste("-T", sep = " "))
tree.ms &lt;- read.tree(text = ret.ms[3])
get.rooted.tree.height(tree.ms)

tree.scaled &lt;- rescale.rooted.tree(tree.ms, scale.height = 2)
get.rooted.tree.height(tree.scaled)

## End(Not run)
</code></pre>

<hr>
<h2 id='RRand'>Rand Index and Adjusted Rand Index</h2><span id='topic+RRand'></span>

<h3>Description</h3>

<p>This function returns the Rand index and the adjusted Rand index for
given true class ids and predicted class ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRand(trcl, prcl, lab = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RRand_+3A_trcl">trcl</code></td>
<td>
<p>true class ids.</p>
</td></tr>
<tr><td><code id="RRand_+3A_prcl">prcl</code></td>
<td>
<p>predicted class ids.</p>
</td></tr>
<tr><td><code id="RRand_+3A_lab">lab</code></td>
<td>
<p>known ids for semi-supervised clustering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All ids, <code>trcl</code> and <code>prcl</code>, should be positive integers and
started from 1 to K, and the maximums are allowed to be different.
</p>
<p><code>lab</code> used in semi-supervised clustering contains the labels which
are known before clustering. It should be positive integer and
started from 1 for labeled data and 0 for unlabeled data.
</p>


<h3>Value</h3>

<p>Return a <code>Class RRand</code> contains Rand index and adjusted
Rand index.
</p>


<h3>Author(s)</h3>

<p>Ranjan Maitra.
</p>
<p>Maintain: Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

true.id &lt;- c(1, 1, 1, 2, 2, 2, 3, 3, 3)
pred.id &lt;- c(2, 1, 2, 1, 1, 1, 2, 1, 1)
label   &lt;- c(0, 0, 0, 0, 1, 0, 2, 0, 0)

RRand(true.id, pred.id)
RRand(true.id, pred.id, lab = label)

## End(Not run)
</code></pre>

<hr>
<h2 id='seq.data'>A Toy Dataset in Class seq.data</h2><span id='topic+seq.data.toy'></span><span id='topic+seq.data.gap'></span><span id='topic+Class+20seq.data'></span><span id='topic+Data+20Toy'></span>

<h3>Description</h3>

<p>A toy dataset, <code>seq.data.toy</code>, with 100 nucleotide sequences
and 200 sites in 4 clusters.
<code>seq.data.gap</code> contains some missing values indicated by &quot;-&quot;.
</p>


<h3>Format</h3>

<p>This data contains a list with a <code>seq.data</code> structure described
in the &lsquo;Details&rsquo; section.
</p>


<h3>Details</h3>

<p>A toy dataset is generated to demonstrate <span class="pkg">phyclust</span>.
It has 100 nucleotide sequences and 200 sites in 4 clusters
where the ancestral tree height 0.15 and the descendant tree height 0.09,
and sequences are evolved by a HKY85 model.
</p>
<p>The structre of class <code>seq.data</code> is a list containing:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>code.type</code> </td><td style="text-align: left;"> either "NUCLEOTIDE" or "SNP". </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>info</code>      </td><td style="text-align: left;"> header for phylip file. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>nseq</code>      </td><td style="text-align: left;"> number of sequences, <code class="reqn">N</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>seqlen</code>    </td><td style="text-align: left;"> length of sequences, <code class="reqn">L</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>seqname</code>   </td><td style="text-align: left;"> sequence names. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>org.code</code>  </td><td style="text-align: left;"> original codes, dim = <code class="reqn">N\times L</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>org</code>       </td><td style="text-align: left;"> transfered ids, dim = <code class="reqn">N\times L</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>byrow</code>     </td><td style="text-align: left;"> TRUE for dim = <code class="reqn">N\times L</code>, FALSE for transpose. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.seq.data">print.seq.data</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

seq.data.toy
seq.data.gap

par(mfrow = c(1, 2))
plotdots(seq.data.toy$org)
plotdots(seq.data.gap$org)

## End(Not run)
</code></pre>

<hr>
<h2 id='seqgen'>Seq-Gen</h2><span id='topic+seqgen'></span><span id='topic+Class+20seqgen'></span>

<h3>Description</h3>

<p>This function modifies the original standalone code of <code>seq-gen</code>
developed by Rambaut, A. and Grassly, N.C. (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqgen(opts = NULL, rooted.tree = NULL, newick.tree = NULL, input = NULL,
       temp.file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqgen_+3A_opts">opts</code></td>
<td>
<p>options as the standalone version.</p>
</td></tr>
<tr><td><code id="seqgen_+3A_rooted.tree">rooted.tree</code></td>
<td>
<p>a rooted tree which sequences are generated according to.</p>
</td></tr>
<tr><td><code id="seqgen_+3A_newick.tree">newick.tree</code></td>
<td>
<p>a NEWICK tree which sequences are generated according to.</p>
</td></tr>
<tr><td><code id="seqgen_+3A_input">input</code></td>
<td>
<p>optional inputs of seq-gen, e.g. ancestral sequences.</p>
</td></tr>
<tr><td><code id="seqgen_+3A_temp.file">temp.file</code></td>
<td>
<p>temporary file for seqgen output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function directly reuses the C code of <code>seq-gen</code> by arguments
as input from the STDIN. The options <code>opts</code> is followed from the
original <code>seq-gen</code> except an input tree.
</p>
<p>Input either a <code>rooted.tree</code> or a <code>newick.tree</code>, and
<code>rooted.tree</code> should have a <code>Class phylo</code>.
</p>
<p>For examples, options commonly used in <span class="pkg">phyclust</span> are:
</p>

<ul>
<li><p> &quot;-m&quot;: set an evolution model, e.g. &quot;-mHKY&quot;.
</p>
</li>
<li><p> &quot;-t&quot;: set transition/transversion ratio, e.g. &quot;-t0.7&quot;.
</p>
</li>
<li><p> &quot;-f&quot;: equilibrium probabilities of A, C, G, and T, e.g. &quot;-f0.1,0.2,0.3,0.4&quot;.
</p>
</li>
<li><p> &quot;-l&quot;: length of sequences, e.g. &quot;-l10&quot;.
</p>
</li>
<li><p> &quot;-s&quot;: scale rate for the total height of input tree, &quot;-s0.2&quot;.
</p>
</li>
<li><p> &quot;-k&quot;: index of ancestral sequence in input file, see <code>gen.seq.HKY</code>.
</p>
</li></ul>

<p>These will return sequences in <code>Format phylip</code> which can be
read by <code>read.seqgen()</code> and transfered into an object with
<code>Class seq.data</code>.
</p>
<p>The maximum number of tips is 2000 in <code>seqgen()</code> by default, but an
extra option <code>opts = "-u 2014 ..."</code> can be simply increase the size
to 2014.
</p>
<p><strong>Note</strong>:
</p>

<ul>
<li> <p><code>input</code> and <code>rooted.tree</code>/<code>newick.tree</code> can not be
submitted at the same time.
</p>
</li>
<li> <p><code>seq-gen</code> use the order A, C, G, T.
</p>
</li>
<li> <p><code>-t</code> is ts/tv ratio which is not equal to <code class="reqn">\kappa</code>.
</p>
</li>
<li><p> See more examples in <code>gen.seq.HKY()</code> and <code>gen.seq.SNP()</code>.
</p>
</li></ul>

<p><code>temp.file</code> allows users to specify seqgen output file themselves, but
this file will not be deleted nor converted into R after the call to
<code>seqgen()</code>. Users should take care the readings. By default,
<code>seqgen()</code>
uses a system temp file to store the output which is converted into R
after the call and is deleted after converting.
</p>


<h3>Value</h3>

<p>This function returns a vector, and each element stores one line of STDOUT
of <code>seq-gen</code> separated by newline. The vector stores in a class
<code>seqgen</code>. The details of output format can found on the website
<a href="http://tree.bio.ed.ac.uk/software/seqgen/">http://tree.bio.ed.ac.uk/software/seqgen/</a> and its manual.
</p>


<h3>Warning(s)</h3>

<p>Carefully read the <code>seq-gen</code>'s original document before using the
<code>seqgen()</code> function.
</p>


<h3>Author(s)</h3>

<p>Rambaut, A. and Grassly, N.C. (1997).
</p>
<p>Maintain: Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>
<p>Rambaut, A. and Grassly, N.C. (1997)
&ldquo;Seq-Gen: An Application for the Monte Carlo Simulation of DNA
Sequence Evolution along Phylogenetic Trees&rdquo;,
<em>Computer Applications In The Biosciences</em>, <b>13:3</b>, 235-238.
<a href="http://tree.bio.ed.ac.uk/software/seqgen/">http://tree.bio.ed.ac.uk/software/seqgen/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.seqgen">print.seqgen</a>()</code>,
<code><a href="ape.html#topic+read.tree">read.tree</a>()</code>,
<code><a href="#topic+ms">ms</a>()</code>,
<code><a href="#topic+gen.seq.HKY">gen.seq.HKY</a>()</code>,
<code><a href="#topic+gen.seq.SNP">gen.seq.SNP</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

set.seed(123)
ret.ms &lt;- ms(nsam = 5, nreps = 1, opts = "-T")
seqgen(opts = "-mHKY -l40 -s0.2", newick.tree = ret.ms[3])


## End(Not run)
</code></pre>

<hr>
<h2 id='snp2sid'>Transfer SNP codes (1, 2, -) and sids (0, 1, 2)</h2><span id='topic+snp2sid'></span><span id='topic+sid2snp'></span>

<h3>Description</h3>

<p>Transfer SNP codes (1, 2, -) and SNP ids (0, 1, 2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snp2sid(snpseq)
sid2snp(sidseq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snp2sid_+3A_snpseq">snpseq</code></td>
<td>
<p>a character vector contains SNP codes, 1, 2, or -.</p>
</td></tr>
<tr><td><code id="snp2sid_+3A_sidseq">sidseq</code></td>
<td>
<p>a numerical vector contains SNP ids, 0, 1, or 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the internal object <code>.snp</code> to
transfer SNP codes and SNP ids.
</p>


<h3>Value</h3>

<p><code>snp2sid</code> returns a numerical vector containing SNP ids, and
<code>sid2snp</code> returns a character vector containing SNP codes. 
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.show.option">.show.option</a></code>,
<code><a href="#topic+.snp">.snp</a></code>,
<code><a href="#topic+code2nid">code2nid</a></code>,
<code><a href="#topic+nid2code">nid2code</a></code>,
<code><a href="#topic+code2snp">code2snp</a></code>,
<code><a href="#topic+snp2code">snp2code</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

a &lt;- c("1", "2", "1", "-", "2")
snp2sid(a)
sid2snp(snp2sid(a)) 

## End(Not run)
</code></pre>

<hr>
<h2 id='standard.code'>Standard Codes and ids for Nucleotides, SNPs, Codon, Amino Acid and Genetic Code</h2><span id='topic+.nucleotide'></span><span id='topic+.snp'></span><span id='topic+.codon'></span><span id='topic+.amino.acid'></span><span id='topic+.genetic.code'></span><span id='topic+.missing.code'></span>

<h3>Description</h3>

<p>Standard codes and ids for nucleotides, SNPs, codon, amino acid and genetic
code.
All objects are used to transfer data.
<strong>These are read-only objects and the elemental order is followed in C.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.nucleotide
.snp
.codon
.amino.acid
.genetic.code
</code></pre>


<h3>Format</h3>

<p>All objects are data frames containing ids and codes.
</p>


<h3>Details</h3>

<p><strong>Note</strong>: All ids are coding started from <strong>0</strong>.
</p>
<p>Nucleotides, A, G, C, T, and - have codes 0, 1, 2, 3, and 4 where
&quot;-&quot; is for gaps.
SNPs, 1, 2, and - have code codes 0, 1, and 2.
</p>
<p>These are objects are in data frames unlike other internal objects due
to heavily used in processing data. The original data should be transfered
to numerical codes in order to be passed to C codes. In C codes, we use
integers, 0, 1, 2, ..., for coding nucleotides or SNPs and so on.
</p>
<p>Now, models and methods are implemented only for <code>.nucleotide</code> and
<code>.snp</code>. Other objects are leaved for further extension.
</p>
<p>Data frames use factor formats as the default, and <code>as.character</code> is
the way to transfer to the characters.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>
</p>


<h3>References</h3>

<p>Phylogenetic Clustering Website:
<a href="https://snoweye.github.io/phyclust/">https://snoweye.github.io/phyclust/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.show.option">.show.option</a></code>,
<code><a href="#topic+code2nid">code2nid</a></code>,
<code><a href="#topic+nid2code">nid2code</a></code>,
<code><a href="#topic+snp2sid">snp2sid</a></code>,
<code><a href="#topic+sid2snp">sid2snp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(phyclust, quiet = TRUE)

.nucleotide
.snp
.codon
.amino.acid
.genetic.code
.missing.code

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
