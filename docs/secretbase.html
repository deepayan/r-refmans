<!DOCTYPE html><html><head><title>Help for package secretbase</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {secretbase}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#secretbase-package'><p>secretbase: Cryptographic Hash, Extendable-Output and Base64 Functions</p></a></li>
<li><a href='#base64dec'><p>Base64 Decode</p></a></li>
<li><a href='#base64enc'><p>Base64 Encode</p></a></li>
<li><a href='#keccak'><p>Keccak Cryptographic Hash Algorithms</p></a></li>
<li><a href='#sha256'><p>SHA-256 Cryptographic Hash Algorithm</p></a></li>
<li><a href='#sha3'><p>SHA-3 Cryptographic Hash Algorithms</p></a></li>
<li><a href='#shake256'><p>SHAKE256 Extendable Output Function</p></a></li>
<li><a href='#siphash13'><p>SipHash Pseudorandom Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cryptographic Hash, Extendable-Output and Base64 Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast and memory-efficient streaming hash functions and base64
    encoding and decoding. Performs direct hashing of strings and raw vectors.
    Stream hashes files potentially larger than memory, as well as in-memory
    objects through R's serialization mechanism. Implementations include the
    SHA-256, SHA-3 and 'Keccak' cryptographic hash functions, SHAKE256
    extendable-output function (XOF), and 'SipHash' pseudo-random function.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shikokuchuo/secretbase/issues">https://github.com/shikokuchuo/secretbase/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://shikokuchuo.net/secretbase/">https://shikokuchuo.net/secretbase/</a>,
<a href="https://github.com/shikokuchuo/secretbase/">https://github.com/shikokuchuo/secretbase/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-16 11:01:46 UTC; cg334</td>
</tr>
<tr>
<td>Author:</td>
<td>Charlie Gao <a href="https://orcid.org/0000-0002-0750-061X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Hibiki AI Limited [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charlie Gao &lt;charlie.gao@shikokuchuo.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-16 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='secretbase-package'>secretbase: Cryptographic Hash, Extendable-Output and Base64 Functions</h2><span id='topic+secretbase'></span><span id='topic+secretbase-package'></span>

<h3>Description</h3>

<p>Fast and memory-efficient streaming hash functions and base64 encoding and
decoding. Performs direct hashing of strings and raw vectors. Stream
hashes files potentially larger than memory, as well as in-memory objects
through R's serialization mechanism. Implementations include the SHA-256,
SHA-3 and 'Keccak' cryptographic hash functions, SHAKE256
extendable-output function (XOF), and 'SipHash' pseudo-random function.
</p>


<h3>Author(s)</h3>

<p>Charlie Gao <a href="mailto:charlie.gao@shikokuchuo.net">charlie.gao@shikokuchuo.net</a>
(<a href="https://orcid.org/0000-0002-0750-061X">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://shikokuchuo.net/secretbase/">https://shikokuchuo.net/secretbase/</a>
</p>
</li>
<li> <p><a href="https://github.com/shikokuchuo/secretbase/">https://github.com/shikokuchuo/secretbase/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/shikokuchuo/secretbase/issues">https://github.com/shikokuchuo/secretbase/issues</a>
</p>
</li></ul>


<hr>
<h2 id='base64dec'>Base64 Decode</h2><span id='topic+base64dec'></span>

<h3>Description</h3>

<p>Decodes a character string, raw vector or other object from base64 encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base64dec(x, convert = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base64dec_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="base64dec_+3A_convert">convert</code></td>
<td>
<p>[default TRUE] logical TRUE to convert back to a character
string, FALSE to convert back to a raw vector or NA to decode and then
unserialize back to the original object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value of &lsquo;convert&rsquo; should be set to TRUE, FALSE or NA to
be the reverse of the 3 encoding operations (for strings, raw vectors and
arbitrary objects), in order to return the original object.
</p>


<h3>Value</h3>

<p>A character string, raw vector, or other object depending on the
value of &lsquo;convert&rsquo;.
</p>


<h3>References</h3>

<p>This implementation is based that by 'The Mbed TLS Contributors'
under the 'Mbed TLS' Trusted Firmware Project at
<a href="https://www.trustedfirmware.org/projects/mbed-tls">https://www.trustedfirmware.org/projects/mbed-tls</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+base64enc">base64enc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>base64dec(base64enc("secret base"))
base64dec(base64enc(as.raw(c(1L, 2L, 4L))), convert = FALSE)
base64dec(base64enc(data.frame()), convert = NA)

</code></pre>

<hr>
<h2 id='base64enc'>Base64 Encode</h2><span id='topic+base64enc'></span>

<h3>Description</h3>

<p>Encodes a character string, raw vector or other object to base64 encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base64enc(x, convert = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base64enc_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="base64enc_+3A_convert">convert</code></td>
<td>
<p>[default TRUE] logical TRUE to encode to a character string or
FALSE to a raw vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A character string or raw vector (with no attributes) is encoded
<em>as is</em>, whilst all other objects are first serialized (using R
serialisation version 3, big-endian representation).
</p>


<h3>Value</h3>

<p>A character string or raw vector depending on the value of
&lsquo;convert&rsquo;.
</p>


<h3>References</h3>

<p>This implementation is based that by 'The Mbed TLS Contributors'
under the 'Mbed TLS' Trusted Firmware Project at
<a href="https://www.trustedfirmware.org/projects/mbed-tls">https://www.trustedfirmware.org/projects/mbed-tls</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+base64dec">base64dec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>base64enc("secret base")
base64enc(as.raw(c(1L, 2L, 4L)), convert = FALSE)
base64enc(data.frame())

</code></pre>

<hr>
<h2 id='keccak'>Keccak Cryptographic Hash Algorithms</h2><span id='topic+keccak'></span>

<h3>Description</h3>

<p>Returns a Keccak hash of the supplied object or file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keccak(x, bits = 256L, convert = TRUE, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keccak_+3A_x">x</code></td>
<td>
<p>object to hash. A character string or raw vector (without
attributes) is hashed 'as is'. All other objects are stream hashed using
R serialization (but without allocation of the serialized object).</p>
</td></tr>
<tr><td><code id="keccak_+3A_bits">bits</code></td>
<td>
<p>[default 256L] output size of the returned hash. Must be one of
224, 256, 384 or 512.</p>
</td></tr>
<tr><td><code id="keccak_+3A_convert">convert</code></td>
<td>
<p>[default TRUE] if TRUE, the hash is converted to its hex
representation as a character string, if FALSE, output directly as a raw
vector, or if NA, a vector of (32-bit) integer values.</p>
</td></tr>
<tr><td><code id="keccak_+3A_file">file</code></td>
<td>
<p>character file name / path. If specified, 'x' is ignored. The
file is stream hashed, thus capable of handling files larger than memory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string, raw or integer vector depending on 'convert'.
</p>


<h3>R Serialization Stream Hashing</h3>

<p>Where this is used, serialization is always version 3 big-endian
represenation and the headers (containing R version and native encoding
information) are skipped to ensure portability across platforms.
</p>


<h3>References</h3>

<p>Keccak is the underlying algorithm for SHA-3, and is identical
apart from the value of the padding parameter.
</p>
<p>The Keccak algorithm was designed by G. Bertoni, J. Daemen, M. Peeters
and G. Van Assche.
</p>
<p>This implementation is based on one by 'The Mbed TLS Contributors' under
the 'Mbed TLS' Trusted Firmware Project at
<a href="https://www.trustedfirmware.org/projects/mbed-tls">https://www.trustedfirmware.org/projects/mbed-tls</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Keccak-256 hash as character string:
keccak("secret base")

# Keccak-256 hash as raw vector:
keccak("secret base", convert = FALSE)

# Keccak-224 hash as character string:
keccak("secret base", bits = 224)

# Keccak-384 hash as character string:
keccak("secret base", bits = 384)

# Keccak-512 hash as character string:
keccak("secret base", bits = 512)

# Keccak-256 hash a file:
file &lt;- tempfile(); cat("secret base", file = file)
keccak(file = file)
unlink(file)

</code></pre>

<hr>
<h2 id='sha256'>SHA-256 Cryptographic Hash Algorithm</h2><span id='topic+sha256'></span>

<h3>Description</h3>

<p>Returns a SHA-256 hash of the supplied object or file, or HMAC if a secret
key is supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sha256(x, key = NULL, convert = TRUE, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sha256_+3A_x">x</code></td>
<td>
<p>object to hash. A character string or raw vector (without
attributes) is hashed 'as is'. All other objects are stream hashed using
R serialization (but without allocation of the serialized object).</p>
</td></tr>
<tr><td><code id="sha256_+3A_key">key</code></td>
<td>
<p>[default NULL] If NULL, the SHA-256 hash of 'x' is returned.
Alternatively, supply a character string or raw vector as a secret key to
generate an HMAC. Note: for character vectors only the first element is
used.</p>
</td></tr>
<tr><td><code id="sha256_+3A_convert">convert</code></td>
<td>
<p>[default TRUE] if TRUE, the hash is converted to its hex
representation as a character string, if FALSE, output directly as a raw
vector, or if NA, a vector of (32-bit) integer values.</p>
</td></tr>
<tr><td><code id="sha256_+3A_file">file</code></td>
<td>
<p>character file name / path. If specified, 'x' is ignored. The
file is stream hashed, thus capable of handling files larger than memory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string, raw or integer vector depending on 'convert'.
</p>


<h3>R Serialization Stream Hashing</h3>

<p>Where this is used, serialization is always version 3 big-endian
represenation and the headers (containing R version and native encoding
information) are skipped to ensure portability across platforms.
</p>


<h3>References</h3>

<p>The SHA-256 Secure Hash Standard was published by the National
Institute of Standards and Technology (NIST) in 2002 at
<a href="https://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf">https://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf</a>.
</p>
<p>This implementation is based on one by 'The Mbed TLS Contributors' under
the 'Mbed TLS' Trusted Firmware Project at
<a href="https://www.trustedfirmware.org/projects/mbed-tls">https://www.trustedfirmware.org/projects/mbed-tls</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># SHA-256 hash as character string:
sha256("secret base")

# SHA-256 hash as raw vector:
sha256("secret base", convert = FALSE)

# SHA-256 hash a file:
file &lt;- tempfile(); cat("secret base", file = file)
sha256(file = file)
unlink(file)

# SHA-256 HMAC using a character string secret key:
sha256("secret", key = "base")

# SHA-256 HMAC using a raw vector secret key:
sha256("secret", key = charToRaw("base"))

</code></pre>

<hr>
<h2 id='sha3'>SHA-3 Cryptographic Hash Algorithms</h2><span id='topic+sha3'></span>

<h3>Description</h3>

<p>Returns a SHA-3 hash of the supplied object or file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sha3(x, bits = 256L, convert = TRUE, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sha3_+3A_x">x</code></td>
<td>
<p>object to hash. A character string or raw vector (without
attributes) is hashed 'as is'. All other objects are stream hashed using
R serialization (but without allocation of the serialized object).</p>
</td></tr>
<tr><td><code id="sha3_+3A_bits">bits</code></td>
<td>
<p>[default 256L] output size of the returned hash. Must be one of
224, 256, 384 or 512.</p>
</td></tr>
<tr><td><code id="sha3_+3A_convert">convert</code></td>
<td>
<p>[default TRUE] if TRUE, the hash is converted to its hex
representation as a character string, if FALSE, output directly as a raw
vector, or if NA, a vector of (32-bit) integer values.</p>
</td></tr>
<tr><td><code id="sha3_+3A_file">file</code></td>
<td>
<p>character file name / path. If specified, 'x' is ignored. The
file is stream hashed, thus capable of handling files larger than memory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string, raw or integer vector depending on 'convert'.
</p>


<h3>R Serialization Stream Hashing</h3>

<p>Where this is used, serialization is always version 3 big-endian
represenation and the headers (containing R version and native encoding
information) are skipped to ensure portability across platforms.
</p>


<h3>References</h3>

<p>The SHA-3 Secure Hash Standard was published by the National
Institute of Standards and Technology (NIST) in 2015 at
<a href="https://doi.org/10.6028/NIST.FIPS.202">doi:10.6028/NIST.FIPS.202</a>.
</p>
<p>This implementation is based on one by 'The Mbed TLS Contributors' under
the 'Mbed TLS' Trusted Firmware Project at
<a href="https://www.trustedfirmware.org/projects/mbed-tls">https://www.trustedfirmware.org/projects/mbed-tls</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># SHA3-256 hash as character string:
sha3("secret base")

# SHA3-256 hash as raw vector:
sha3("secret base", convert = FALSE)

# SHA3-224 hash as character string:
sha3("secret base", bits = 224)

# SHA3-384 hash as character string:
sha3("secret base", bits = 384)

# SHA3-512 hash as character string:
sha3("secret base", bits = 512)

# SHA3-256 hash a file:
file &lt;- tempfile(); cat("secret base", file = file)
sha3(file = file)
unlink(file)

</code></pre>

<hr>
<h2 id='shake256'>SHAKE256 Extendable Output Function</h2><span id='topic+shake256'></span>

<h3>Description</h3>

<p>Returns a SHAKE256 hash of the supplied object or file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shake256(x, bits = 256L, convert = TRUE, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shake256_+3A_x">x</code></td>
<td>
<p>object to hash. A character string or raw vector (without
attributes) is hashed 'as is'. All other objects are stream hashed using
R serialization (but without allocation of the serialized object).</p>
</td></tr>
<tr><td><code id="shake256_+3A_bits">bits</code></td>
<td>
<p>[default 256L] output size of the returned hash. Must be between
8 and 2^24 and coercible to integer.</p>
</td></tr>
<tr><td><code id="shake256_+3A_convert">convert</code></td>
<td>
<p>[default TRUE] if TRUE, the hash is converted to its hex
representation as a character string, if FALSE, output directly as a raw
vector, or if NA, a vector of (32-bit) integer values.</p>
</td></tr>
<tr><td><code id="shake256_+3A_file">file</code></td>
<td>
<p>character file name / path. If specified, 'x' is ignored. The
file is stream hashed, thus capable of handling files larger than memory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To produce single integer values suitable for use as random seeds
for R's pseudo random number generators (RNGs), set 'bits' to 32 and
'convert' to NA.
</p>


<h3>Value</h3>

<p>A character string, raw or integer vector depending on 'convert'.
</p>


<h3>R Serialization Stream Hashing</h3>

<p>Where this is used, serialization is always version 3 big-endian
represenation and the headers (containing R version and native encoding
information) are skipped to ensure portability across platforms.
</p>


<h3>References</h3>

<p>This implementation is based on one by 'The Mbed TLS
Contributors' under the 'Mbed TLS' Trusted Firmware Project at
<a href="https://www.trustedfirmware.org/projects/mbed-tls">https://www.trustedfirmware.org/projects/mbed-tls</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># SHAKE256 hash as character string:
shake256("secret base")

# SHAKE256 hash as raw vector:
shake256("secret base", convert = FALSE)

# SHAKE256 hash to integer:
shake256("secret base", bits = 32L, convert = NA)

# SHAKE256 hash a file:
file &lt;- tempfile(); cat("secret base", file = file)
shake256(file = file)
unlink(file)

</code></pre>

<hr>
<h2 id='siphash13'>SipHash Pseudorandom Function</h2><span id='topic+siphash13'></span>

<h3>Description</h3>

<p>Returns a fast, cryptographically-strong SipHash keyed hash of the supplied
object or file. SipHash-1-3 is optimised for performance. Note: SipHash
is not a cryptographic hash algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siphash13(x, key = NULL, convert = TRUE, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="siphash13_+3A_x">x</code></td>
<td>
<p>object to hash. A character string or raw vector (without
attributes) is hashed 'as is'. All other objects are stream hashed using
R serialization (but without allocation of the serialized object).</p>
</td></tr>
<tr><td><code id="siphash13_+3A_key">key</code></td>
<td>
<p>[default NULL] a character string or raw vector comprising the 16
byte (128 bit) key data, or else NULL which is equivalent to '0'. If a
longer vector is supplied, only the first 16 bytes are used, and if
shorter, padded with trailing '0'. Note: for character vectors only the
first element is used.</p>
</td></tr>
<tr><td><code id="siphash13_+3A_convert">convert</code></td>
<td>
<p>[default TRUE] if TRUE, the hash is converted to its hex
representation as a character string, if FALSE, output directly as a raw
vector, or if NA, a vector of (32-bit) integer values.</p>
</td></tr>
<tr><td><code id="siphash13_+3A_file">file</code></td>
<td>
<p>character file name / path. If specified, 'x' is ignored. The
file is stream hashed, thus capable of handling files larger than memory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string, raw or integer vector depending on 'convert'.
</p>


<h3>R Serialization Stream Hashing</h3>

<p>Where this is used, serialization is always version 3 big-endian
represenation and the headers (containing R version and native encoding
information) are skipped to ensure portability across platforms.
</p>


<h3>References</h3>

<p>The SipHash family of cryptographically-strong pseudorandom
functions (PRFs) are described in 'SipHash: a fast short-input PRF',
Jean-Philippe Aumasson and Daniel J. Bernstein, Paper 2012/351, 2012,
Cryptology ePrint Archive at <a href="https://ia.cr/2012/351">https://ia.cr/2012/351</a>.
</p>
<p>This implementation is based on the SipHash streaming implementation by
Daniele Nicolodi, David Rheinsberg and Tom Gundersen at
<a href="https://github.com/c-util/c-siphash">https://github.com/c-util/c-siphash</a>. This is in turn based on the
SipHash reference implementation by Jean-Philippe Aumasson and Daniel J.
Bernstein released to the public domain at
<a href="https://github.com/veorq/SipHash">https://github.com/veorq/SipHash</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># SipHash-1-3 hash as character string:
siphash13("secret base")

# SipHash-1-3 hash as raw vector:
siphash13("secret base", convert = FALSE)

# SipHash-1-3 hash using a character string key:
siphash13("secret", key = "base")

# SipHash-1-3 hash using a raw vector key:
siphash13("secret", key = charToRaw("base"))

# SipHash-1-3 hash a file:
file &lt;- tempfile(); cat("secret base", file = file)
siphash13(file = file)
unlink(file)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
