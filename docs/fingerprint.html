<!DOCTYPE html><html><head><title>Help for package fingerprint</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fingerprint}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.character'>
<p>Generates a String Representation of a Fingerprint</p></a></li>
<li><a href='#balance'>
<p>Generate a Balanced Code Fingerprint</p></a></li>
<li><a href='#bit.importance'>
<p>Evaluate the Discriminatory Power of Individual Bits in a Binary Fingerprint</p></a></li>
<li><a href='#bit.spectrum'>
<p>Generate a Bit Spectrum from a List of Fingerprints</p></a></li>
<li><a href='#c'>
<p>Combine Multiple Features to Give a List of Features</p></a></li>
<li><a href='#cdk.lf, moe.lf, bci.lf'>
<p>Functions to parse lines from fingerprint files</p></a></li>
<li><a href='#count-methods'><p>Get or Set Count of Occurence of a Feature</p></a></li>
<li><a href='#distance-methods'><p>Calculates the Similarity or Dissimilarity Between Two Fingerprints</p></a></li>
<li><a href='#euc.vector'>
<p>Euclidean Representation of Binary Fingerprints</p></a></li>
<li><a href='#feature-class'><p>Class &quot;feature&quot;</p></a></li>
<li><a href='#feature-methods'><p>Get or Set the Character String Representing the Feature</p></a></li>
<li><a href='#featvec-class'><p>Class &quot;featvec&quot;</p></a></li>
<li><a href='#fingerprint-class'><p>Class &quot;fingerpint&quot;</p></a></li>
<li><a href='#fold'>
<p>Fold a fingerprint</p></a></li>
<li><a href='#fp.factor.matrix'>
<p>Converts a List of Fingerprints to a data.frame of Factors</p></a></li>
<li><a href='#fp.read, fp.read.to.matrix'>
<p>Functions to Read Fingerprints From Files</p></a></li>
<li><a href='#fp.sim.matrix'>
<p>Calculates a Similarity Matrix for a Set of Fingerprints</p></a></li>
<li><a href='#fp.to.matrix'>
<p>Converts a List of Fingerprints to a Matrix</p></a></li>
<li><a href='#fplogical'>
<p>Logical Operators for Fingerprints</p></a></li>
<li><a href='#length'>
<p>Fingerprint Bit Length</p></a></li>
<li><a href='#random.fingerprint'>
<p>Generate Randomized Fingerprints</p></a></li>
<li><a href='#shannon'>
<p>Evaluate Shannon Entropy for a Set of Fingerprints</p></a></li>
<li><a href='#show'>
<p>String Representation of a Fingerprint or Feature</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.5.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-01-06</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions to Operate on Binary Fingerprint Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Rajarshi Guha &lt;rajarshi.guha@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rajarshi Guha &lt;rajarshi.guha@gmail.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rajarshi/cdkr/issues">https://github.com/rajarshi/cdkr/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to manipulate binary fingerprints
 of arbitrary length. A fingerprint is represented by an object of S4 class 'fingerprint'
 which is internally represented a vector of integers, such
 that each element represents the position in the fingerprint that is set to 1.
 The bitwise logical functions in R are overridden so that they can be used directly
 with 'fingerprint' objects. A number of distance metrics are also
 available (many contributed by Michael Fadock). Fingerprints 
 can be converted to Euclidean vectors (i.e., points on the unit hypersphere) and
 can also be folded using OR.  Arbitrary fingerprint formats can be handled via line
 handlers. Currently handlers are provided for CDK, MOE and BCI fingerprint data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-01-07 00:11:57 UTC; guhar</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-01-07 22:44:58 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.character'>
Generates a String Representation of a Fingerprint
</h2><span id='topic+as.character'></span><span id='topic+as.character+2Cfingerprint-method'></span><span id='topic+as.character+2Cfeatvec-method'></span><span id='topic+as.character+2Cfeature-method'></span>

<h3>Description</h3>

<p>The function returns a string of 1's and 0's or a character vector of
features depending on the nature of the fingerprint supplied.        
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fingerprint'
as.character(x)
## S4 method for signature 'featvec'
as.character(x)
## S4 method for signature 'feature'
as.character(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character_+3A_x">x</code></td>
<td>

<p>An object of class <code>fingerprint</code>, <code>featvec</code> or <code>feature</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string of 1's and 0's or else a character vector of features (with their counts)
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># make a fingerprint vector
fp &lt;- new("fingerprint", nbit=32, bits=sample(1:32, 20))

# print out the string representation
as.character(fp)
</code></pre>

<hr>
<h2 id='balance'>
Generate a Balanced Code Fingerprint
</h2><span id='topic+balance'></span>

<h3>Description</h3>

<p>It has been noted that the bit density in a fingerprint can affect its ability to
retrieve similar compounds from a database primarily due to complexity effects. One
approach to alleviating these effects is to generate fingerprints that have a bit
density of 50
balanced code approach described by Nisius and Bajorath to convert an ordinary
binary fingerprint (whose bit density is not 50
50
(resulting in a fingerprint twice the size of the original).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance(fplist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balance_+3A_fplist">fplist</code></td>
<td>
<p>A single fingerprint or a list of fingerprints</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single fingerprint objects or list of fingerprint objects that are &quot;balanced&quot;,
in that they have a bit density of 50
fingerprints.
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>


<h3>References</h3>

<p>Nisius, B.; Bajorath, J.; <em>ChemMedChem</em>, <b>2010</b>,
<em>5</em>, 859-868.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bit.spectrum">bit.spectrum</a></code>, <code><a href="#topic+bit.importance">bit.importance</a></code>
</p>

<hr>
<h2 id='bit.importance'>
Evaluate the Discriminatory Power of Individual Bits in a Binary Fingerprint
</h2><span id='topic+bit.importance'></span>

<h3>Description</h3>

<p>This method evaluates the Kullback-Leibler (KL) divergence to rank the 
individual bits in a binary fingerprint in their ability to discriminate 
between database and active compounds. This method is implemented based on
Nisius and Bajorath and includes an m-estimate correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bit.importance(actives, background)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bit.importance_+3A_actives">actives</code></td>
<td>
<p>A list of fingerprints for the actives</p>
</td></tr>
<tr><td><code id="bit.importance_+3A_background">background</code></td>
<td>
<p>A list of fingerprints representing the background collection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length equal to the size of the fingerprints. Each element
of the vector is the KL divergence for the corresponding bit. If a bit position
is never set to 1 in any of the compounds from the actives and the background, then
the KL divergence for that position is undefined and <code>NA</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>


<h3>References</h3>

<p>Nisius, B.; Bajorath, J.; <em>ChemMedChem</em>, <b>2010</b>,
<em>5</em>, 859-868.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bit.spectrum">bit.spectrum</a></code>
</p>

<hr>
<h2 id='bit.spectrum'>
Generate a Bit Spectrum from a List of Fingerprints
</h2><span id='topic+bit.spectrum'></span>

<h3>Description</h3>

<p>The idea of comparing datasets using fingerprints was described in
Guha \&amp; Schurer (2008). The idea is that one can summarize the dataset
by counting the frequency of occurrence of each bit position. The
frequency is normalized by the number of fingerprints considered. Thus a
collection of N fingerprints can be converted to a single vector of
numbers highlighting the most frequent bits with respect to a given
dataset. A plot of this vector looks like a traditional spectrum and
hence the name.
</p>
<p>The bit spectra for two datasets (assuming that the same types of
fingerprints have been used) allows one to compare the similarity of
the datasets, without having to do a full pairwise similarity
calculation. The difference between the structural features of the
datasets can be quantified by evaluating the distance between the two
bit spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bit.spectrum(fplist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bit.spectrum_+3A_fplist">fplist</code></td>
<td>

<p>A list structure with each element being an object of class
<code>fingerprint</code>. These will can be constructed by hand or
read from disk via <code><a href="#topic+fp.read">fp.read</a></code>.
</p>
<p>All fingerprints in the list should be of the same length.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length equal to the size of the fingerprints.
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>


<h3>References</h3>

<p>Guha, R.; Schurer, S.; <em>J. Comp. Aid. Molec. Des.</em>, <b>2008</b>,
<em>22</em>, 367-384.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distance">distance</a></code>, <code><a href="#topic+fp.read">fp.read</a></code>
</p>

<hr>
<h2 id='c'>
Combine Multiple Features to Give a List of Features
</h2><span id='topic+c+2Cfeature-method'></span>

<h3>Description</h3>

<p>Combine multiple <code>feature</code> objects to give a list of feature objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'feature'
c(x, ..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_+3A_x">x</code></td>
<td>

<p>An object of class <code>feature</code>
</p>
</td></tr>
<tr><td><code id="c_+3A_...">...</code></td>
<td>

<p>One or more <code>feature</code> objects
</p>
</td></tr>
<tr><td><code id="c_+3A_recursive">recursive</code></td>
<td>
<p> Ignored </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>

<hr>
<h2 id='cdk.lf+2C+20moe.lf+2C+20bci.lf'>
Functions to parse lines from fingerprint files
</h2><span id='topic+cdk.lf'></span><span id='topic+moe.lf'></span><span id='topic+bci.lf'></span><span id='topic+ecfp.lf'></span><span id='topic+fps.lf'></span><span id='topic+jchem.binary.lf'></span>

<h3>Description</h3>

<p>These functions take a single line and parses it to produce 
a vector of integers which represents the position of the 'on' bits in
a fingerprint. This allows the user to use <code>read.fp</code> with arbitrary fingerprint
files. A new file format can be handled by defining a new line parser function.
Currently the first three functions process fingerprint files obtained from the 
CDK (<a href="http://cdk.sourceforge.net">http://cdk.sourceforge.net</a>), MOE (<a href="http://chemcomp.com">http://chemcomp.com</a>), BCI 
(<a href="http://www.digitalchemistry.co.uk/">http://www.digitalchemistry.co.uk/</a>) and the FPS format 
(<a href="http://code.google.com/p/chem-fingerprints/wiki/FPS">http://code.google.com/p/chem-fingerprints/wiki/FPS</a>). The last function can be used
for any fingerprint that generates hashed features (such as ECFPs or other 
circular fingerprints). For these cases, it is assumed that features are unsigned 
integers, so string features are not handled.
</p>
<p>Note that when the <code>fps.lf</code> function is specified, items such as the number of bits
or the header flag do not need to be specified, as the format requires a header block 
containing some of these items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    cdk.lf(line)
    moe.lf(line)
    bci.lf(line)
    ecfp.lf(line)
    fps.lf(line)
    jchem.binary.lf(line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdk.lf+2B2C+2B20moe.lf+2B2C+2B20bci.lf_+3A_line">line</code></td>
<td>

<p>The line to parse
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three componenents - the name associated with the fingerprint (if available)
and a vector of integers representing bits set to 1 (for the case of the first three 
methods) or a vector of characters representing hashed features (characteristic of
circular fingerprints) or more generally, any string feature. The third component is a
(possibly empty) list, which contains the remaining components of a line, when the format
allows items other than an a title and the fingerprint (such as the FPS format). The content
of the third component is dependent on the line function that is being used.
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>

<hr>
<h2 id='count-methods'>Get or Set Count of Occurence of a Feature</h2><span id='topic+count-methods'></span><span id='topic+count'></span><span id='topic+count+2Cfeature-method'></span><span id='topic+count+3C--methods'></span><span id='topic+count+3C-'></span><span id='topic+count+3C-+2Cfeature+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Get or set the count of occurence associated with a
<code><a href="#topic+feature-class">feature-class</a></code> object. The default value for the getter
(as defined in the prototype) is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'feature'
count(object)
## S4 replacement method for signature 'feature,numeric'
count(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count-methods_+3A_object">object</code></td>
<td>

<p>An object of class <code><a href="#topic+feature-class">feature-class</a></code>
</p>
</td></tr>
<tr><td><code id="count-methods_+3A_x">x</code></td>
<td>

<p>An object of class <code><a href="#topic+feature-class">feature-class</a></code>
</p>
</td></tr>
<tr><td><code id="count-methods_+3A_value">value</code></td>
<td>

<p>A numeric (which will be coerced to <code>integer</code>) indicating the
count associated with the feature
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer representing count of occurence of the feature
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "feature")</code></dt><dd><p>Return the count associated with the
feature object</p>
</dd>
<dt><code>signature(x = "feature", value = "numeric")</code></dt><dd><p>Set the count associated with the
feature object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>

<hr>
<h2 id='distance-methods'>Calculates the Similarity or Dissimilarity Between Two Fingerprints</h2><span id='topic+distance'></span><span id='topic+distance-methods'></span><span id='topic+distance+2Cfeatvec+2Cfeatvec+2Ccharacter+2Cmissing+2Cmissing-method'></span><span id='topic+distance+2Cfeatvec+2Cfeatvec+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+distance+2Cfingerprint+2Cfingerprint+2Ccharacter+2Cmissing+2Cmissing-method'></span><span id='topic+distance+2Cfingerprint+2Cfingerprint+2Ccharacter+2Cnumeric+2Cnumeric-method'></span><span id='topic+distance+2Cfingerprint+2Cfingerprint+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>A number of distance metrics can be calculated for binary
fingerprints. Some of these are actually similarity metrics and
thus represent the reverse of a distance metric.
</p>
<p>The following are distance (dissimilarity) metrics
</p>

<ul>
<li><p> Hamming
</p>
</li>
<li><p> Mean Hamming
</p>
</li>
<li><p> Soergel
</p>
</li>
<li><p> Pattern Difference
</p>
</li>
<li><p> Variance
</p>
</li>
<li><p> Size
</p>
</li>
<li><p> Shape
</p>
</li></ul>

<p>The following metrics are similarity metrics and so the distance can
be obtained by subtracting the value fom 1.0
</p>

<ul>
<li><p> Tanimoto
</p>
</li>
<li><p> Dice
</p>
</li>
<li><p> Modified Tanimoto
</p>
</li>
<li><p> Simple
</p>
</li>
<li><p> Jaccard
</p>
</li>
<li><p> Russel-Rao
</p>
</li>
<li><p> Rodgers Tanimoto
</p>
</li>
<li><p> Cosine
</p>
</li>
<li><p> Achiai
</p>
</li>
<li><p> Carbo
</p>
</li>
<li><p> Baroniurbanibuser
</p>
</li>
<li><p> Kulczynski2
</p>
</li>
<li><p> Robust
</p>
</li></ul>
 
<p>Finally the method also provides a set of composite and asymmetric
distance metrics
</p>

<ul>
<li><p> Hamann
</p>
</li>
<li><p> Yule
</p>
</li>
<li><p> Pearson
</p>
</li>
<li><p> Dispersion
</p>
</li>
<li><p> McConnaughey
</p>
</li>
<li><p> Stiles
</p>
</li>
<li><p> Simpson
</p>
</li>
<li><p> Petke
</p>
</li>
<li><p> Tversky
</p>
</li></ul>

<p>The default metric is the Tanimoto coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(fp1, fp2, method, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance-methods_+3A_fp1">fp1</code></td>
<td>

<p>An object of class <code>fingerprint</code> or <code>featvec</code>
</p>
</td></tr>
<tr><td><code id="distance-methods_+3A_fp2">fp2</code></td>
<td>

<p>An object of class <code>fingerprint</code> or <code>featvec</code>
</p>
</td></tr>
<tr><td><code id="distance-methods_+3A_a">a</code></td>
<td>
<p>Parameter for the Tversky index</p>
</td></tr>
<tr><td><code id="distance-methods_+3A_b">b</code></td>
<td>
<p>Parameter for the Tversky index</p>
</td></tr>
<tr><td><code id="distance-methods_+3A_method">method</code></td>
<td>

<p>The type of distance metric desired. Partial matching is
supported and the deault is <code>tanimoto</code>. Alternative values are
</p>

<ul>
<li> <p><code>euclidean</code> 
</p>
</li>
<li> <p><code>hamming</code>
</p>
</li>
<li> <p><code>meanHamming</code>
</p>
</li>
<li> <p><code>soergel</code>
</p>
</li>
<li> <p><code>patternDifference</code>
</p>
</li>
<li> <p><code>variance</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li>
<li> <p><code>shape</code>
</p>
</li>
<li> <p><code>jaccard</code>
</p>
</li>
<li> <p><code>dice</code>
</p>
</li>
<li> <p><code>mt</code>
</p>
</li>
<li> <p><code>simple</code>
</p>
</li>
<li> <p><code>russelrao</code>
</p>
</li>
<li> <p><code>rodgerstanimoto</code>
</p>
</li>
<li> <p><code>cosine</code>
</p>
</li>
<li> <p><code>achiai</code>
</p>
</li>
<li> <p><code>carbo</code>
</p>
</li>
<li> <p><code>baroniurbanibuser</code>
</p>
</li>
<li> <p><code>kulczynski2</code>
</p>
</li>
<li> <p><code>robust</code>
</p>
</li>
<li> <p><code>hamann</code>
</p>
</li>
<li> <p><code>yule</code>
</p>
</li>
<li> <p><code>pearson</code>
</p>
</li>
<li> <p><code>mcconnaughey</code>
</p>
</li>
<li> <p><code>stiles</code>
</p>
</li>
<li> <p><code>simpson</code>
</p>
</li>
<li> <p><code>petke</code>
</p>
</li>
<li> <p><code>tversky</code>
</p>
</li></ul>

<p>If the two fingerprints are of class <code>featvec</code> then the following methods 
may be specified: <code>tanimoto</code>, <code>robust</code> and <code>dice</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value representing the distance in the specified metric between the
supplied fingerprint objects
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(fp1 = "featvec", fp2 = "featvec", method = "character", a = "missing", b = "missing")</code></dt><dd>
<p>Similarity method for feature vector type fingerprints, supporting <code>tanimoto</code>, <code>robust</code> and <code>dice</code>
metrics.
</p>
</dd>
<dt><code>signature(fp1 = "featvec", fp2 = "featvec", method = "missing", a = "missing", b = "missing")</code></dt><dd>
<p>Evaluate Tanimoto similarity between two feature vector fingerprints			  
</p>
</dd>
<dt><code>signature(fp1 = "fingerprint", fp2 = "fingerprint", method = "character", a = "missing", b = "missing")</code></dt><dd>
<p>Evaluate similarity (or dissimilrity) between two binary fingerprints. See below for a list of possible
similarity (or dissimilarity) metrics			  
</p>
</dd>
<dt><code>signature(fp1 = "fingerprint", fp2 = "fingerprint", method = "character", a = "numeric", b = "numeric")</code></dt><dd>
<p>Evaluate Tversky similarity between two binary fingerprints.
</p>
</dd>
<dt><code>signature(fp1 = "fingerprint", fp2 = "fingerprint", method = "missing", a = "missing", b = "missing")</code></dt><dd>
<p>Evaluate Tanimoto similarity between two binary fingerprints
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>


<h3>References</h3>

<p>Fligner, M.A.; Verducci, J.S.; Blower, P.E.;
A Modification of the Jaccard-Tanimoto Similarity Index for
Diverse Selection of Chemical Compounds Using Binary Strings,
<em>Technometrics</em>, 2002, <em>44</em>(2), 110-119
</p>
<p>Monve, V.; Introduction to Similarity Searching in
Chemistry, <em>MATCH - Comm. Math. Comp. Chem.</em>, 2004, <em>51</em>, 7-38
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make a 2 fingerprint vectors
fp1 &lt;- new("fingerprint", nbit=6, bits=c(1,2,5,6))
fp2 &lt;- new("fingerprint", nbit=6, bits=c(1,2,5,6))

# calculate the tanimoto coefficient
distance(fp1,fp2) # should be 1

# Invert the second fingerprint
fp3 &lt;- !fp2

distance(fp1,fp3) # should be 0
</code></pre>

<hr>
<h2 id='euc.vector'>
Euclidean Representation of Binary Fingerprints
</h2><span id='topic+euc.vector'></span>

<h3>Description</h3>

<p>Ordinarily, a binary fingerprint can be considered to represent a 
corner of a nD hypercube. However in many cases using such a representation
can lead to a very sparse space. Consequently one approach is to convert
the fingerprint so that it represents points on a nD unit hypersphere.
</p>
<p>The resultant fingerprint is then a nD coordinate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euc.vector(fp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euc.vector_+3A_fp">fp</code></td>
<td>

<p>An object of class <code>fingerprint</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric of length equal to the bit length of the fingerprint. The
result corresponds to a unit vector for a point
on the nD hypersphere
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rguha@indiana.edu">rguha@indiana.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># make a fingerprint vector
fp &lt;- new("fingerprint", nbit=8, bits=c(1,3,4,5,7))
vec &lt;- euc.vector(fp)
</code></pre>

<hr>
<h2 id='feature-class'>Class &quot;feature&quot;</h2><span id='topic+feature-class'></span>

<h3>Description</h3>

<p>This class represents features - arbitrary alphanumeric sequences
that are used to characterize molecular substructures (though there is no real
restriction to molecules). A feature is associated with an integer count, 
indicating the occurence of that feature in a molecule. The default value is 1.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("feature", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>feature</code>:</dt><dd><p>Object of class <code>"character"</code> ~ The string representation of a feature </p>
</dd>
<dt><code>count</code>:</dt><dd><p>Object of class <code>"integer"</code> ~ The occurence of the feature. Default is 1</p>
</dd>
<dt><code>.Data</code>:</dt><dd><p>???</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>count</dt><dd><p><code>signature(object = "feature")</code>: Return the count associated with the
feature</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+featvec-class">featvec-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## create a new feature
  f &lt;- new("feature", feature='ABCD', count=as.integer(1))

  ## modify the feature string and the count
  feature(f) &lt;- 'UXYZ'
  count(f) &lt;- 10
</code></pre>

<hr>
<h2 id='feature-methods'>Get or Set the Character String Representing the Feature</h2><span id='topic+feature'></span><span id='topic+feature-methods'></span><span id='topic+feature+2Cfeature-method'></span><span id='topic+feature+3C--methods'></span><span id='topic+feature+3C-'></span><span id='topic+feature+3C-+2Cfeature+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Get or set the character string representing a feature of a 
<code><a href="#topic+feature-class">feature-class</a></code> object. The default value for the getter
(as defined in the prototype) is the empty string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'feature'
feature(object)
## S4 replacement method for signature 'feature,character'
feature(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feature-methods_+3A_object">object</code></td>
<td>

<p>An object of class <code><a href="#topic+feature-class">feature-class</a></code>
</p>
</td></tr>
<tr><td><code id="feature-methods_+3A_x">x</code></td>
<td>

<p>An object of class <code><a href="#topic+feature-class">feature-class</a></code>
</p>
</td></tr>
<tr><td><code id="feature-methods_+3A_value">value</code></td>
<td>

<p>The character string to replace the current feature string with
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An character string representing the feature
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "feature")</code></dt><dd><p>Return the feature associated with the
feature object</p>
</dd>
<dt><code>signature(x = "feature", value = "character")</code></dt><dd><p>Set the feature associated with the
feature object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>

<hr>
<h2 id='featvec-class'>Class &quot;featvec&quot;</h2><span id='topic+featvec-class'></span><span id='topic+distance+2Cfeatvec+2Cfeatvec+2Cmissing-method'></span><span id='topic+distance+2Cfeatvec+2Cfeatvec+2Ccharacter-method'></span><span id='topic+length+2Cfeatvec-method'></span>

<h3>Description</h3>

<p>This class represents feature vector style fingerprints, where, rather than
a bit string, the fingerprint is represented as a sequence of (signed) integers or strings.
Each element of the collection is a representation of a structural feature. For cases where the
features are integers, this usually corresponds to a hash of the original feature string.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("featvec", ...)</code>.
In contrast to traditional binary fingerprints, operations on feature vectors
are slightly different and essentially correspond to operations on sets. Thus 
the logical and (&amp;) would correspond to the union of the two feature vectors.
</p>


<h3>Slots</h3>


<dl>
<dt><code>features</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ A vector
containing the numeric or character features. Numeric features are treated
as character strings </p>
</dd>
<dt><code>provider</code>:</dt><dd><p>Object of class <code>"character"</code> ~~
Indicates the source of the fingerprint. Can be useful to keep
track of what software generated the fingerprint.</p>
</dd>
<dt><code>name</code>:</dt><dd><p>Object of class <code>"character"</code> ~~
The name associated with the fingerprint. If not name is available
this gets set to an empty string</p>
</dd>
<dt><code>misc</code>:</dt><dd><p>A list to hold arbitrary items associated with a fingerprint (such as 
extra fields from a fingerprint file)</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>distance</dt><dd><p><code>signature(fp1 = "featvec", fp2 = "featvec", method = "missing")</code>: ... </p>
</dd>
<dt>distance</dt><dd><p><code>signature(fp1 = "featvec", fp2 = "featvec", method = "character")</code>: ... </p>
</dd>
<dt>as.character</dt><dd><p><code>signature(fp = "featvec")</code>: ... </p>
</dd>
<dt>length</dt><dd><p><code>signature(fp = "featvec")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(fp = "featvec")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+fp.read">fp.read</a></code>, <code><a href="#topic+fp.read.to.matrix">fp.read.to.matrix</a></code>
<code><a href="#topic+fp.sim.matrix">fp.sim.matrix</a></code>, <code><a href="#topic+fp.to.matrix">fp.to.matrix</a></code>,
<code><a href="#topic+fp.factor.matrix">fp.factor.matrix</a></code>
<code><a href="#topic+random.fingerprint">random.fingerprint</a></code>
</p>

<hr>
<h2 id='fingerprint-class'>Class &quot;fingerpint&quot;</h2><span id='topic+fingerprint-class'></span><span id='topic+euc.vector+2Cfingerprint-method'></span><span id='topic+fold+2Cfingerprint-method'></span><span id='topic+random.fingerprint+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>This class represents binary fingerprints, usually
generated by a variety of cheminformatics software, but not
restricted to such
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("fingerprint", ...)</code>.
Fingerprints can traditionally thought of as a vector of 1's and
0's. However for large fingerprints this is inefficient and
instead we simply store the positions of the bits that are
on. Certain operations also need to know the length of the
original bit string and this length is stored in the object at
construction. Even though we store extra information along with
the bit positions, conceptually we still consider the objects as
simple bit strings. Thus the usual bitwise logical operations
(&amp;, |, !, xor) can be applied to objects of this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>bits</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ A vector
indicating the bit positions that are on. </p>
</dd>
<dt><code>nbit</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ Indicates the length of the original bit string.</p>
</dd>
<dt><code>folded</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ Indicates
whether the fingerprint has been folded.</p>
</dd>
<dt><code>provider</code>:</dt><dd><p>Object of class <code>"character"</code> ~~
Indicates the source of the fingerprint. Can be useful to keep
track of what software generated the fingerprint.</p>
</dd>
<dt><code>name</code>:</dt><dd><p>Object of class <code>"character"</code> ~~
The name associated with the fingerprint. If not name is available
this gets set to an empty string</p>
</dd>
<dt><code>misc</code>:</dt><dd><p>Object of class <code>"list"</code> ~~
A holder for arbitrary items that may have been stored along with the fingerprint. Only
certain formats allow extra items to be stored with the fingerprint, so in many cases
this field is just an empty list</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>distance</dt><dd><p><code>signature(fp1 = "fingerprint", fp2 = "fingerprint", method = "missing", a = "missing", b = "missing")</code>: ... </p>
</dd>
<dt>distance</dt><dd><p><code>signature(fp1 = "fingerprint", fp2 = "fingerprint", method = "character", a = "missing", b = "missing")</code>: ... </p>
</dd>
<dt>euc.vector</dt><dd><p><code>signature(fp = "fingerprint")</code>: ... </p>
</dd>
<dt>fold</dt><dd><p><code>signature(fp = "fingerprint")</code>: ... </p>
</dd>
<dt>random.fingerprint</dt><dd><p><code>signature(nbit = "numeric", on = "numeric")</code>: ... </p>
</dd>    
</dl>



<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+fp.read">fp.read</a></code>, <code><a href="#topic+fp.read.to.matrix">fp.read.to.matrix</a></code>
<code><a href="#topic+fp.sim.matrix">fp.sim.matrix</a></code>, <code><a href="#topic+fp.to.matrix">fp.to.matrix</a></code>,
<code><a href="#topic+fp.factor.matrix">fp.factor.matrix</a></code>
<code><a href="#topic+random.fingerprint">random.fingerprint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make fingerprints
x &lt;- new("fingerprint", nbit=128, bits=sample(1:128, 100))
y &lt;- x
distance(x,y) # should be 1
x &lt;- new("fingerprint", nbit=128, bits=sample(1:128, 100))
distance(x,y)
folded &lt;- fold(x)

## binary operations on fingerprints
x &lt;- new("fingerprint", nbit=8, bits=c(1,2,3,6,8))
y &lt;- new("fingerprint", nbit=8, bits=c(1,2,4,5,7,8))
x &amp; y
x | y
!x
</code></pre>

<hr>
<h2 id='fold'>
Fold a fingerprint
</h2><span id='topic+fold'></span>

<h3>Description</h3>

<p>In many situations a fingerprint is generated using a large length (such as 1024 bits or more).
As a result of this, the fingerprints for a dataset can be very sparse. One approach to increasing 
bit density of such fingerprints is to fold them. This is performed by dividing the original
fingerprint bitstring into two substrings of equal length and then perform an OR on
the two substrings. 
</p>
<p>It should be noted that many fingerprint generating routines will perform this internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fold(fp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fold_+3A_fp">fp</code></td>
<td>

<p>The fingerprint to fold. Should be of class <code>fingerprint</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fingerprint</code> representing the folded fingerprint.
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rguha@indiana.edu">rguha@indiana.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># make a fingerprint vector
fp &lt;- new("fingerprint", nbit=64, bits=sample(1:64, 30))
fold(fp)
</code></pre>

<hr>
<h2 id='fp.factor.matrix'>
Converts a List of Fingerprints to a data.frame of Factors
</h2><span id='topic+fp.factor.matrix'></span>

<h3>Description</h3>

<p>This function will convert  a <code>list</code> of fingerprint objects
to a <code>data.frame</code> of factors with levels 1 and 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fp.factor.matrix(fplist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fp.factor.matrix_+3A_fplist">fplist</code></td>
<td>

<p>A list structure with each element being an object of class
<code>fingerprint</code>. These will can be constructed by hand or
read from disk via <code><a href="#topic+fp.read">fp.read</a></code>    
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with dimensions equal to <code>(length(fplist), length(fplist))</code>
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rguha@indiana.edu">rguha@indiana.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+distance">distance</a></code>, <code><a href="#topic+fp.read">fp.read</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make fingerprint objects
fp1 &lt;- new("fingerprint", nbit=6, bits=c(1,2,5,6))
fp2 &lt;- new("fingerprint", nbit=6, bits=c(1,4,5,6))
fp3 &lt;- new("fingerprint", nbit=6, bits=c(2,3,4,5,6))

fp.factor.matrix( list(fp1,fp2,fp3) )
</code></pre>

<hr>
<h2 id='fp.read+2C+20fp.read.to.matrix'>
Functions to Read Fingerprints From Files
</h2><span id='topic+fp.read'></span><span id='topic+fp.read.to.matrix'></span>

<h3>Description</h3>

<p><code>fp.read</code> reads in a set of fingerprints from a file. Fingerprint 
output from the CDK, MOE and BCI can be handled.
</p>
<p>Each fingerprint is represented as a <code>fingerprint</code> object.
<code>fp.read</code> returns a <code>list</code> structure, each element being a
<code>fingerprint</code> or <code>nfeatvec</code> object, depending on the value 
of the <code>binary</code> argument.
</p>
<p><code>fp.read.to.matrix</code> is a utility function that reads the fingerprints directly to
matrix form (columns are the bit positions and the rows are the objects whose fingerprints
have been evaluated). Note that this method does not currently work with feature vector
fingerprints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fp.read(f='fingerprint.txt', size=1024, lf=cdk.lf, header=FALSE, binary=TRUE)
fp.read.to.matrix(f='fingerprint.txt', size=1024, lf=cdk.lf, header=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fp.read+2B2C+2B20fp.read.to.matrix_+3A_f">f</code></td>
<td>

<p>File containing the fingperprints
</p>
</td></tr>
<tr><td><code id="fp.read+2B2C+2B20fp.read.to.matrix_+3A_size">size</code></td>
<td>

<p>The bit length of the fingerprints being considered
</p>
</td></tr>
<tr><td><code id="fp.read+2B2C+2B20fp.read.to.matrix_+3A_lf">lf</code></td>
<td>

<p>A line reading function that parses a single line from
a fingerprint file. A number of functions are provided
that parse the fingerprints from the output of the CDK, MOE and the
BCI toolkit. In addition, support is now available for the FPS format
from the chemfp project (<a href="http://code.google.com/p/chem-fingerprints">http://code.google.com/p/chem-fingerprints</a>).
</p>
</td></tr>
<tr><td><code id="fp.read+2B2C+2B20fp.read.to.matrix_+3A_header">header</code></td>
<td>

<p>Indicates whether the first line of the fingerprint file is
a header line
</p>
</td></tr>
<tr><td><code id="fp.read+2B2C+2B20fp.read.to.matrix_+3A_binary">binary</code></td>
<td>

<p>If <code>TRUE</code> indicates that a binary fingerprint will be read in. Otherwise indicates
that a feature vector style fingerprint (such as from a circular fingerprint) is being 
read in
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> or <code>matrix</code> of fingerprints
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+cdk.lf">cdk.lf</a></code>,
<code><a href="#topic+moe.lf">moe.lf</a></code>,
<code><a href="#topic+bci.lf">bci.lf</a></code>,
<code><a href="#topic+ecfp.lf">ecfp.lf</a></code>,
<code><a href="#topic+fps.lf">fps.lf</a></code>
</p>

<hr>
<h2 id='fp.sim.matrix'>
Calculates a Similarity Matrix for a Set of Fingerprints
</h2><span id='topic+fp.sim.matrix'></span>

<h3>Description</h3>

<p>Given a set of fingerprints, a pairwise similarity can be calculated using the
various distance metrics defined for binary strings. This function calculates
the pairwise similarity matrix for a set of <code>fingerprint</code> or
<code>featvec</code> objects supplied in a <code>list</code> 
structure. Any of the distance metrics provided by <code><a href="#topic+distance">distance</a></code> can be used and the 
default is the Tanimoto metric.
</p>
<p>Note that if the the Euclidean distance is specified then the resultant matrix is a
distance matrix and not a similarity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fp.sim.matrix(fplist, fplist2=NULL, method='tanimoto')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fp.sim.matrix_+3A_fplist">fplist</code></td>
<td>

<p>A list structure with each element being an object of class
<code>fingerprint</code> or <code>featvec</code>. These can be constructed by hand or
read from disk via <code><a href="#topic+fp.read">fp.read</a></code>    
</p>
</td></tr>
<tr><td><code id="fp.sim.matrix_+3A_fplist2">fplist2</code></td>
<td>
<p>A list structure with each element being an object of class
<code>fingerprint</code> or <code>featvec</code>. if <code>NULL</code> then traditional pairwise 
similarity is calculated with each member in <code>fplist</code>, otherwise the 
resultant N x M matrix is derived from the similarity between each member of 
<code>fplist</code> and <code>fplist2</code></p>
</td></tr>
<tr><td><code id="fp.sim.matrix_+3A_method">method</code></td>
<td>

<p>The type of distance metric to use. The default is <code>tanimoto</code>. Partial
matching is supported.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with dimensions equal to <code>(length(fplist), length(fplist))</code> if 
<code>fplist2</code> is NULL, otherwise <code>(length(fplist), length(fplist2))</code>
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+distance">distance</a></code>, <code><a href="#topic+fp.read">fp.read</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make fingerprint objects
fp1 &lt;- new("fingerprint", nbit=6, bits=c(1,2,5,6))
fp2 &lt;- new("fingerprint", nbit=6, bits=c(1,4,5,6))
fp3 &lt;- new("fingerprint", nbit=6, bits=c(2,3,4,5,6))

fp.sim.matrix( list(fp1,fp2,fp3) )
</code></pre>

<hr>
<h2 id='fp.to.matrix'>
Converts a List of Fingerprints to a Matrix
</h2><span id='topic+fp.to.matrix'></span>

<h3>Description</h3>

<p>In general, fingerprint data is read from a file or obtained via
calls to an external generator and the return value is a list of fingerprints.
This function takes the list and returns a matrix having number of rows equal to 
the number of fingerprints and the number of columns equal to the length of
the fingerprint. Each element is 1 or 0 (1's being specified by the positions
in each fingerprint vector)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fp.to.matrix(fplist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fp.to.matrix_+3A_fplist">fplist</code></td>
<td>

<p>A list structure with each element being an object of class
<code>fingerprint</code>. These will can be constructed by hand or
read from disk via <code><a href="#topic+fp.read">fp.read</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with dimensions equal to <code>length(fplist), bit length)</code>
where bit length is a property of the fingerprint objects in the list.
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rguha@indiana.edu">rguha@indiana.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+distance">distance</a></code>, <code><a href="#topic+fp.read">fp.read</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make fingerprint objects
fp1 &lt;- new("fingerprint", nbit=6, bits=c(1,2,5,6))
fp2 &lt;- new("fingerprint", nbit=6, bits=c(1,4,5,6))
fp3 &lt;- new("fingerprint", nbit=6, bits=c(2,3,4,5,6))

fp.to.matrix( list(fp1,fp2,fp3) )
</code></pre>

<hr>
<h2 id='fplogical'>
Logical Operators for Fingerprints
</h2><span id='topic++21'></span><span id='topic++7C'></span><span id='topic++26'></span><span id='topic+xor'></span><span id='topic++7C+2Cfingerprint+2Cfingerprint-method'></span><span id='topic++26+2Cfingerprint+2Cfingerprint-method'></span><span id='topic+xor+2Cfingerprint+2Cfingerprint-method'></span><span id='topic++21+2Cfingerprint-method'></span>

<h3>Description</h3>

<p>These functions perform logical operatiosn (AND, OR, NOT, XOR) on the supplied
binary fingerprints. Thus for two fingerprints A and B we have
</p>

<dl>
<dt><code>&amp;</code></dt><dd><p>Logical AND</p>
</dd>
<dt><code>|</code></dt><dd><p>Logical OR</p>
</dd>
<dt><code>xor</code></dt><dd><p>Logical XOR</p>
</dd>
<dt><code>!</code></dt><dd><p>Logical NOT (negation)</p>
</dd>
</dl>



<h3>Arguments</h3>

<table>
<tr><td><code id="fplogical_+3A_e1">e1</code></td>
<td>

<p>An object of class <code>fingerprint</code>
</p>
</td></tr>
<tr><td><code id="fplogical_+3A_e2">e2</code></td>
<td>

<p>An object of class <code>fingerprint</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fingerprint object
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rguha@indiana.edu">rguha@indiana.edu</a></p>

<hr>
<h2 id='length'>
Fingerprint Bit Length
</h2><span id='topic+length'></span><span id='topic+length+2Cfingerprint-method'></span>

<h3>Description</h3>

<p>Returns the length of the fingerprint. That is, this is the length of
the entire bit string and not simply the number of bits that are on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'fingerprint'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length_+3A_x">x</code></td>
<td>

<p>An object of class <code>fingerprint</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The length of the bit string
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rguha@indiana.edu">rguha@indiana.edu</a></p>

<hr>
<h2 id='random.fingerprint'>
Generate Randomized Fingerprints
</h2><span id='topic+random.fingerprint'></span>

<h3>Description</h3>

<p>A utility function that can be used to generate binary fingerprints
of a specified length with a specifed number of bit positions
(selected randomly) set to 1. Currently bit positions are selected uniformly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.fingerprint(nbit,on)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.fingerprint_+3A_nbit">nbit</code></td>
<td>

<p>The length of the fingerprint, that is, the total number of bits.
Must be a positive integer.
</p>
</td></tr>
<tr><td><code id="random.fingerprint_+3A_on">on</code></td>
<td>

<p>How many positions should be set to 1
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fingerprint</code>
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rguha@indiana.edu">rguha@indiana.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># make a fingerprint vector
fp &lt;- random.fingerprint(32, 16)
as.character(fp)
</code></pre>

<hr>
<h2 id='shannon'>
Evaluate Shannon Entropy for a Set of Fingerprints
</h2><span id='topic+shannon'></span><span id='topic+entropy'></span>

<h3>Description</h3>

<p>This method evaluates the Shannon entropy for a set of fingerprints
and utilizes the <code><a href="#topic+bit.spectrum">bit.spectrum</a></code> method to obtain the relative
frequencies of individual bits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shannon(fplist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shannon_+3A_fplist">fplist</code></td>
<td>

<p>A list structure with each element being an object of class
<code>fingerprint</code>. These will can be constructed by hand or
read from disk via <code><a href="#topic+fp.read">fp.read</a></code>.
</p>
<p>All fingerprints in the list should be of the same length.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Shannon entropy for the set of fingerprints
</p>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+bit.spectrum">bit.spectrum</a></code>, <code><a href="#topic+fp.read">fp.read</a></code>
</p>

<hr>
<h2 id='show'>
String Representation of a Fingerprint or Feature
</h2><span id='topic+show+2Cfingerprint-method'></span><span id='topic+show+2Cfeatvec-method'></span><span id='topic+show+2Cfeature-method'></span>

<h3>Description</h3>

<p>Simply summarize the fingerprint or feature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fingerprint'
show(object)
## S4 method for signature 'featvec'
show(object)
## S4 method for signature 'feature'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_+3A_object">object</code></td>
<td>

<p>An object of class <code>fingerprint</code>, <code>featvec</code> or <code>feature</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rajarshi Guha <a href="mailto:rajarshi.guha@gmail.com">rajarshi.guha@gmail.com</a></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
