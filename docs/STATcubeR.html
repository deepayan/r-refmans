<!DOCTYPE html><html lang="en-US"><head><title>Help for package STATcubeR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {STATcubeR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#od_cache'><p>Cache management for Open Data</p></a></li>
<li><a href='#od_catalogue'><p>Get a catalogue for OGD datasets</p></a></li>
<li><a href='#od_list'><p>List available Opendata datasets</p></a></li>
<li><a href='#od_resource'><p>Resource management for open.data</p></a></li>
<li><a href='#od_revisions'><p>Get OGD revisions</p></a></li>
<li><a href='#od_table'><p>Create a table-instance from an open-data dataset</p></a></li>
<li><a href='#od_table_class'><p>Create a table-instance from an open-data dataset</p></a></li>
<li><a href='#od_table_save'><p>Saves/load opendata datasets via tar archives</p></a></li>
<li><a href='#other_endpoints'><p>Other endpoints of the STATcube REST API</p></a></li>
<li><a href='#sc_browse'><p>Links to important 'STATcube' and 'OGD' pages</p></a></li>
<li><a href='#sc_cache'><p>Cache responses from the STATcube REST API</p></a></li>
<li><a href='#sc_data'><p>Common interface for STATcubeR datasets</p></a></li>
<li><a href='#sc_json_get_server'><p>Get the server from a json request</p></a></li>
<li><a href='#sc_key'><p>Manage your API Keys</p></a></li>
<li><a href='#sc_last_error'><p>Error handling for the STATcube REST API</p></a></li>
<li><a href='#sc_recoder'><p>Recode sc_table objects</p></a></li>
<li><a href='#sc_schema'><p>Create a request against the /schema endpoint</p></a></li>
<li><a href='#sc_table'><p>Create a request against the /table endpoint</p></a></li>
<li><a href='#sc_table_class'><p>Class for /table responses</p></a></li>
<li><a href='#sc_table_custom'><p>Create custom tables</p></a></li>
<li><a href='#sc_tabulate'><p>Turn sc_data objects into tidy data frames</p></a></li>
<li><a href='#sdmx_table'><p>Import data from SDMX</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Interface for the 'STATcube' REST API and Open Government Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-29</td>
</tr>
<tr>
<td>Description:</td>
<td>Import data from the 'STATcube' REST API or from the open data
    portal of Statistics Austria. This package includes a client for API
    requests as well as parsing utilities for data which originates from
    'STATcube'. Documentation about 'STATcubeR' is provided by several vignettes 
    included in the package as well as on the public 'pkgdown' page at 
    <a href="https://statistikat.github.io/STATcubeR/">https://statistikat.github.io/STATcubeR/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://statistikat.github.io/STATcubeR/">https://statistikat.github.io/STATcubeR/</a>,
<a href="https://github.com/statistikat/STATcubeR">https://github.com/statistikat/STATcubeR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statistikat/STATcubeR/issues">https://github.com/statistikat/STATcubeR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.4.1), httr, jsonlite, pillar (&ge; 1.5.0), vctrs (&ge;
0.5.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>magrittr, spelling, data.tree, rappdirs, xml2, reactable,
markdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-29 05:30:06 UTC; meindl</td>
</tr>
<tr>
<td>Author:</td>
<td>Bernhard Meindl [ctb, cre],
  Alexander Kowarik <a href="https://orcid.org/0000-0001-8598-4130"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Gregor de Cillia [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bernhard Meindl &lt;Bernhard.Meindl@statistik.gv.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-29 09:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='od_cache'>Cache management for Open Data</h2><span id='topic+od_cache'></span><span id='topic+od_cache_summary'></span><span id='topic+od_downloads'></span>

<h3>Description</h3>

<p>Functions to inspect the contents of the current cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_cache_summary(server = "ext")

od_downloads(server = "ext")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="od_cache_+3A_server">server</code></td>
<td>
<p>the OGD-Server to use. <code>"ext"</code> for the external server (the
default) or <code>"red"</code> for the editing server</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+od_cache_summary">od_cache_summary()</a></code> provides an overview of all contents of the cache through
a data.frame. It has one row for each dataset and returns a <code>data.frame</code> with#
the following columns in which all file sizes are given in bytes.
</p>

<ul>
<li> <p><strong><code>id</code></strong> the dataset id
</p>
</li>
<li> <p><strong><code>updated</code></strong> the last modified time for <code style="white-space: pre;">&#8288;${id}.json&#8288;</code>
</p>
</li>
<li> <p><strong><code>json</code></strong> the file size of <code style="white-space: pre;">&#8288;${id}.json&#8288;</code>
</p>
</li>
<li> <p><strong><code>data</code></strong> the file size of <code style="white-space: pre;">&#8288;${id}.csv&#8288;</code>
</p>
</li>
<li> <p><strong><code>header</code></strong> the file size of <code style="white-space: pre;">&#8288;${id}_HEADER.csv&#8288;</code>
</p>
</li>
<li> <p><strong><code>fields</code></strong> the total file size of all files belonging to fields (<code style="white-space: pre;">&#8288;{id}_C*.csv&#8288;</code>).
</p>
</li>
<li> <p><strong><code>n_fields</code></strong> the number of field files
</p>
</li></ul>

</li>
<li> <p><code><a href="#topic+od_downloads">od_downloads()</a></code> shows a download history for the current cache and returns
a <code>data.frame</code> with the following columns:
</p>

<ul>
<li> <p><strong><code>time</code></strong> a timestamp for the download
</p>
</li>
<li> <p><strong><code>file</code></strong> the filename
</p>
</li>
<li> <p><strong><code>downloaded</code></strong> the download time in milliseconds
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## make sure the cache is not empty
od_table("OGD_krebs_ext_KREBS_1")
od_table("OGD_veste309_Veste309_1")

## inspect
od_cache_summary()
od_downloads()
</code></pre>

<hr>
<h2 id='od_catalogue'>Get a catalogue for OGD datasets</h2><span id='topic+od_catalogue'></span>

<h3>Description</h3>

<p><strong>EXPERIMENTAL</strong> This function parses several json metadata files at once
and combines them into a <code>data.frame</code> so the datasets can easily be
filtered based on categorizations, tags, number of classifications, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_catalogue(server = "ext", local = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="od_catalogue_+3A_server">server</code></td>
<td>
<p>the OGD-server to be used. <code>"ext"</code> (the default) for the
external server or <code>prod</code> for the production server</p>
</td></tr>
<tr><td><code id="od_catalogue_+3A_local">local</code></td>
<td>
<p>If <code>TRUE</code> (the default), the catalogue is created based on
cached json metadata. Otherwise, the cache is updated prior to
creating the catalogue using a &quot;bulk-download&quot; for metadata files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The naming, ordering and choice of the columns is likely to change.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with the following structure</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Column</strong> </td><td style="text-align: left;"> <strong>Type</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   title </td><td style="text-align: left;"> <code>chr</code> </td><td style="text-align: left;"> Title of the dataset </td>
</tr>
<tr>
 <td style="text-align: left;">
   measures </td><td style="text-align: left;"> <code>int</code> </td><td style="text-align: left;"> Number of measure variables </td>
</tr>
<tr>
 <td style="text-align: left;">
   fields </td><td style="text-align: left;"> <code>int</code> </td><td style="text-align: left;"> Number of classification fields </td>
</tr>
<tr>
 <td style="text-align: left;">
   modified </td><td style="text-align: left;"> <code>datetime</code> </td><td style="text-align: left;"> Timestamp when the dataset was last modified </td>
</tr>
<tr>
 <td style="text-align: left;">
   created </td><td style="text-align: left;"> <code>datetime</code> </td><td style="text-align: left;"> Timestamp when the dataset was created </td>
</tr>
<tr>
 <td style="text-align: left;">
   database </td><td style="text-align: left;"> <code>chr</code> </td><td style="text-align: left;"> ID of the corresponding STATcube database </td>
</tr>
<tr>
 <td style="text-align: left;">
   title_en </td><td style="text-align: left;"> <code>chr</code> </td><td style="text-align: left;"> English title </td>
</tr>
<tr>
 <td style="text-align: left;">
   notes </td><td style="text-align: left;"> <code>chr</code> </td><td style="text-align: left;"> Description for the dataset </td>
</tr>
<tr>
 <td style="text-align: left;">
   frequency </td><td style="text-align: left;"> <code>chr</code> </td><td style="text-align: left;"> How often is the dataset updated? </td>
</tr>
<tr>
 <td style="text-align: left;">
   category </td><td style="text-align: left;"> <code>chr</code> </td><td style="text-align: left;"> Category of the dataset </td>
</tr>
<tr>
 <td style="text-align: left;">
   tags </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;list&lt;chr&gt;&#8288;</code> </td><td style="text-align: left;"> tags assigned to the dataset </td>
</tr>
<tr>
 <td style="text-align: left;">
   json </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;list&lt;od_json&gt;&#8288;</code> </td><td style="text-align: left;"> Full json metadata </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The type <code>datetime</code> refers to the <code>POSIXct</code> format as returned by <code><a href="base.html#topic+Sys.time">Sys.time()</a></code>.
The last column <code>"json"</code> contains the full json metadata as returned by
<code><a href="#topic+od_json">od_json()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>catalogue &lt;- od_catalogue()
catalogue
table(catalogue$update_frequency)
table(catalogue$categorization)
catalogue[catalogue$categorization == "Gesundheit", 1:4]
catalogue[catalogue$measures &gt;= 70, 1:3]
catalogue$json[[1]]
head(catalogue$database)
</code></pre>

<hr>
<h2 id='od_list'>List available Opendata datasets</h2><span id='topic+od_list'></span>

<h3>Description</h3>

<p><code><a href="#topic+od_list">od_list()</a></code> returns a <code>data.frame </code> containing all datasets published at
<a href="https://data.statistik.gv.at">data.statistik.gv.at</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_list(unique = TRUE, server = c("ext", "red"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="od_list_+3A_unique">unique</code></td>
<td>
<p>some datasets are published under multiple groups.
They will only be listed once with the first group they appear in unless
this parameter is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="od_list_+3A_server">server</code></td>
<td>
<p>the open data server to use. Either <code>ext</code> for the external
server (the default) or <code>red</code> for the editing server. The editing server
is only accessible for employees of Statistics Austria</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with two columns
</p>

<ul>
<li> <p><code>"category"</code>: Grouping under which a dataset is listed
</p>
</li>
<li> <p><code>"id"</code>: Name of the dataset which can later be used in
<code><a href="#topic+od_table">od_table()</a></code>
</p>
</li>
<li> <p><code>"label"</code>: Description of the dataset
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- od_list()
df
subset(df, category == "Bildung und Forschung")
# use an id to load a dataset
od_table("OGD_fhsstud_ext_FHS_S_1")
</code></pre>

<hr>
<h2 id='od_resource'>Resource management for open.data</h2><span id='topic+od_resource'></span><span id='topic+od_cache_dir'></span><span id='topic+od_cache_clear'></span><span id='topic+od_cache_file'></span><span id='topic+od_json'></span><span id='topic+od_resource_all'></span>

<h3>Description</h3>

<p>Helper functions for caching and parsing open.data resources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_cache_dir(dir = NULL)

od_cache_clear(id, server = "ext")

od_cache_file(id, suffix = NULL, timestamp = NULL, ..., server = "ext")

od_resource(id, suffix = NULL, timestamp = NULL, server = "ext")

od_json(id, timestamp = Sys.time() - 3600, server = "ext")

od_resource_all(id, json = od_json(id), server = "ext")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="od_resource_+3A_dir">dir</code></td>
<td>
<p>If <code>NULL</code>, the cache directory is returned. Otherwise, the
cache directory will be updated to <code>dir</code>.</p>
</td></tr>
<tr><td><code id="od_resource_+3A_id">id</code></td>
<td>
<p>A database id</p>
</td></tr>
<tr><td><code id="od_resource_+3A_server">server</code></td>
<td>
<p>the OGD-Server to use to load update the resources in case they
are outdated. <code>"ext"</code> for the external server (the default) od <code>"red"</code> for
the editing server.</p>
</td></tr>
<tr><td><code id="od_resource_+3A_suffix">suffix</code></td>
<td>
<p>A suffix for the resource: <code>"HEADER"</code> or a field code.</p>
</td></tr>
<tr><td><code id="od_resource_+3A_timestamp">timestamp</code></td>
<td>
<p>A timestamp in <code>POSIXct</code> format. If provided, the
cached resource will be updated if it is older than that value. Otherwise
it will be downloaded only if it does not exist in the cache.</p>
</td></tr>
<tr><td><code id="od_resource_+3A_...">...</code></td>
<td>
<p>For internal use</p>
</td></tr>
<tr><td><code id="od_resource_+3A_json">json</code></td>
<td>
<p>The JSON file belonging to the dataset</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>od_cache_clear(id)</code> removes all files belonging to the specified id.
</p>
<p>By default, downloaded json files will &quot;expire&quot; in one hour or 3600 seconds.
That is, if a json is requested, it will be reused from the cache unless the
<code><a href="base.html#topic+file.mtime">file.mtime()</a></code> is more than one hour behind <code><a href="base.html#topic+Sys.time">Sys.time()</a></code>.
</p>


<h3>Value</h3>

<p>For <code><a href="#topic+od_cache_file">od_cache_file()</a></code> and <code><a href="#topic+od_resource">od_resource()</a></code>, the returned objects
contain a hidden attribute <code>attr(., "od")</code> about the time used for
downloading and parsing the resource. <code><a href="#topic+od_resource_all">od_resource_all()</a></code> converts these
hidden attribute into columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the current cache directory
od_cache_dir()

# Get paths to cached files
od_cache_file("OGD_veste309_Veste309_1")
od_cache_file("OGD_veste309_Veste309_1", "C-A11-0")

# get a parsed verison of the resource
od_resource("OGD_veste309_Veste309_1", "C-A11-0")

# get json metadata about a dataset
od_json('OGD_veste309_Veste309_1')

# Bundle all resources
od_resource_all("OGD_veste309_Veste309_1")
</code></pre>

<hr>
<h2 id='od_revisions'>Get OGD revisions</h2><span id='topic+od_revisions'></span>

<h3>Description</h3>

<p>Use the <code style="white-space: pre;">&#8288;/revision&#8288;</code> endpoint of the OGD server to get a list
of all datasets that have changed since a certain timestamp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_revisions(since = NULL, exclude_ext = TRUE, server = "ext")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="od_revisions_+3A_since">since</code></td>
<td>
<p>(optional) A timestamp. If supplied, only datasets updated
later will be returned. Otherwise, all datasets are returned.
Can be in either one of the following formats
</p>

<ul>
<li><p> a native R time type that is compatible with <code>strftime()</code>
such as the return values of <code>Sys.Date()</code>, <code>Sys.time()</code> and <code>file.mtime()</code>.
</p>
</li>
<li><p> a string of the form <code>YYYY-MM-DD</code> to specify a day.
</p>
</li>
<li><p> a string of the form <code>YYYY-MM-DDThh:mm:ss</code> to specify a day and a time.
</p>
</li></ul>
</td></tr>
<tr><td><code id="od_revisions_+3A_exclude_ext">exclude_ext</code></td>
<td>
<p>If <code>TRUE</code> (default) exclude all results that have
<code>OGDEXT_</code> as a prefix</p>
</td></tr>
<tr><td><code id="od_revisions_+3A_server">server</code></td>
<td>
<p>the open data server to use. Either <code>ext</code> for the external
server (the default) or <code>red</code> for the editing server. The editing server
is only accessible for employees of Statistics Austria</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector with dataset ids
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get all datasets (including OGDEXT_*)
ids &lt;- od_revisions(exclude_ext = FALSE)
ids
sample(ids, 6)

# get all the datasets since the fifteenth of august
od_revisions("2022-09-15")
</code></pre>

<hr>
<h2 id='od_table'>Create a table-instance from an open-data dataset</h2><span id='topic+od_table'></span>

<h3>Description</h3>

<p><code>od_table(id)</code> returns an <code>R6</code>-class object containing all relevant data
and metadata from https://data.statistik.gv.at/data/
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_table(id, language = NULL, server = "ext")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="od_table_+3A_id">id</code></td>
<td>
<p>the id of the dataset that should be accessed</p>
</td></tr>
<tr><td><code id="od_table_+3A_language">language</code></td>
<td>
<p>language to be used for labeling. <code>"en"</code> or <code>"de"</code></p>
</td></tr>
<tr><td><code id="od_table_+3A_server">server</code></td>
<td>
<p>the OGD-server to be used. <code>"ext"</code> (the default) for the
external server or <code>prod</code> for the production server</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned objects is of class <code>sc_table</code> and inherits several parsing
methods from <a href="#topic+sc_data">sc_data</a>. See <a href="#topic+od_table_class">od_table_class</a> for the full class
documentation.
</p>


<h3>Components</h3>


<table>
<tr>
 <td style="text-align: left;">
   <strong>Component</strong> </td><td style="text-align: left;"> <strong>Corresponding File on Server</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code style="white-space: pre;">&#8288;$data         &#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;https://data.statistik.gv.at/data/${id}.csv&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code style="white-space: pre;">&#8288;$header       &#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;https://data.statistik.gv.at/data/${id}_HEADER.csv&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code style="white-space: pre;">&#8288;$field(code)  &#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;https://data.statistik.gv.at/data/${id}_${code}.csv&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code style="white-space: pre;">&#8288;$json         &#8288;</code> </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;https://data.statistik.gv.at/ogd/json?dataset=${id}&#8288;</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- od_table("OGD_krebs_ext_KREBS_1")

## metadata
x
x$meta
x$field("Sex")
x$field(3)

## data
x$data
x$tabulate()

## tabulation: see `?sc_tabulate` for more examples
x$tabulate("Reporting year", "Sex")

## switch language
x$language &lt;- "de"
x
x$tabulate()

## other interesting tables
od_table("OGD_veste309_Veste309_1")
od_table("OGD_konjunkturmonitor_KonMon_1")
od_table("OGD_krankenbewegungen_ex_LEISTUNGEN_1")
od_table("OGD_veste303_Veste203_1")
</code></pre>

<hr>
<h2 id='od_table_class'>Create a table-instance from an open-data dataset</h2><span id='topic+od_table_class'></span>

<h3>Description</h3>

<p>R6 Class open data datasets.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+sc_data">STATcubeR::sc_data</a></code> -&gt; <code>od_table</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>json</code></dt><dd><p>parsed version of <code style="white-space: pre;">&#8288;https://data.statistik.gv.at/ogd/json?dataset=${id}&#8288;</code></p>
</dd>
<dt><code>header</code></dt><dd><p>parsed version of <code style="white-space: pre;">&#8288;https://data.statistik.gv.at/data/${id}_HEADER.csv&#8288;</code>.
</p>
<p>Similar contents can be found in <code style="white-space: pre;">&#8288;$meta&#8288;</code>.</p>
</dd>
<dt><code>resources</code></dt><dd><p>lists all files downloaded from the server to construct this table</p>
</dd>
<dt><code>od_server</code></dt><dd><p>The server used for initialization (see to <code>?od_table</code>)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-od_table-new"><code>od_table_class$new()</code></a>
</p>
</li>
<li> <p><a href="#method-od_table-browse"><code>od_table_class$browse()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="STATcubeR" data-topic="sc_data" data-id="field"><a href='../../STATcubeR/html/sc_data.html#method-sc_data-field'><code>STATcubeR::sc_data$field()</code></a></span></li>
<li><span class="pkg-link" data-pkg="STATcubeR" data-topic="sc_data" data-id="tabulate"><a href='../../STATcubeR/html/sc_data.html#method-sc_data-tabulate'><code>STATcubeR::sc_data$tabulate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="STATcubeR" data-topic="sc_data" data-id="total_codes"><a href='../../STATcubeR/html/sc_data.html#method-sc_data-total_codes'><code>STATcubeR::sc_data$total_codes()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-od_table-new"></a>



<h4>Method <code>new()</code></h4>

<p>This class is not exported. Use <code><a href="#topic+od_table">od_table()</a></code> to
initialize objects of class <code>od_table</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>od_table_class$new(id, language = NULL, server = "ext")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>the id of the dataset that should be accessed</p>
</dd>
<dt><code>language</code></dt><dd><p>language to be used for labeling. <code>"en"</code> or <code>"de"</code></p>
</dd>
<dt><code>server</code></dt><dd><p>the OGD-Server server to be used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-od_table-browse"></a>



<h4>Method <code>browse()</code></h4>

<p>open the metadata for the dataset in a browser
</p>


<h5>Usage</h5>

<div class="r"><pre>od_table_class$browse()</pre></div>



<hr>
<h2 id='od_table_save'>Saves/load opendata datasets via tar archives</h2><span id='topic+od_table_save'></span><span id='topic+od_table_local'></span>

<h3>Description</h3>

<p><code>od_table_save()</code> creates a tar archive containing all relevant data from the
OGD portal. <code>od_table_local()</code> parses the tar archive and recreates the
<code>od_table</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_table_save(x, file = NULL)

od_table_local(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="od_table_save_+3A_x">x</code></td>
<td>
<p>an object of class <code>od_table</code></p>
</td></tr>
<tr><td><code id="od_table_save_+3A_file">file</code></td>
<td>
<p>An archive file file for the dataset. For <code>od_table_save()</code>,
the default is <code style="white-space: pre;">&#8288;{id}.tar.gz&#8288;</code> where <code>id</code> denotes the OGD identifier.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> for <code><a href="#topic+od_table_save">od_table_save()</a></code>: the path to the generated file
</p>
</li>
<li><p> for <code><a href="#topic+od_table_local">od_table_local()</a></code>: the OGD identifier
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- od_table("OGD_krebs_ext_KREBS_1")

# save dataset as an archive
archive &lt;- file.path(tempdir(), "table.tar.gz")
od_table_save(x, archive)

# read the saved archive
x2 &lt;- od_table_local(archive)

# cleanup
file.remove(archive)
</code></pre>

<hr>
<h2 id='other_endpoints'>Other endpoints of the STATcube REST API</h2><span id='topic+other_endpoints'></span><span id='topic+sc_info'></span><span id='topic+sc_rate_limit_table'></span><span id='topic+sc_rate_limit_schema'></span><span id='topic+sc_rate_limits'></span>

<h3>Description</h3>

<p>Utilize the simple endpoints <code style="white-space: pre;">&#8288;/info&#8288;</code> and <code style="white-space: pre;">&#8288;/table_rate_limit&#8288;</code>. Those provide
information about available locales and the amount of requests available
for calls against the <code style="white-space: pre;">&#8288;/table&#8288;</code> endpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_info(language = c("en", "de"), key = NULL, server = "ext")

sc_rate_limit_table(language = c("en", "de"), key = NULL, server = "ext")

sc_rate_limit_schema(language = c("en", "de"), key = NULL, server = "ext")

sc_rate_limits(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="other_endpoints_+3A_language">language</code></td>
<td>
<p>The language to be used for labeling. <code>"en"</code> or <code>"de"</code></p>
</td></tr>
<tr><td><code id="other_endpoints_+3A_key">key</code></td>
<td>
<p>(<code>string</code>) An API key. To display your key, call
<code><a href="#topic+sc_browse_preferences">sc_browse_preferences()</a></code>.</p>
</td></tr>
<tr><td><code id="other_endpoints_+3A_server">server</code></td>
<td>
<p>A STATcube API server. Defaults to the external Server via
<code>"ext"</code>. Other options are <code>"red"</code> for the editing server and <code>"prod"</code> for
the production server. External users should always use the default option <code>"ext"</code>.</p>
</td></tr>
<tr><td><code id="other_endpoints_+3A_x">x</code></td>
<td>
<p>either a response-object (package <code>httr</code>), an object of class
<code>sc_table</code> or an object of class <code>sc_schema</code></p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+sc_info">sc_info()</a></code>: a <code>data.frame</code> with two columns identifying possible languages
</p>
</li>
<li> <p><code><a href="#topic+sc_rate_limit_table">sc_rate_limit_table()</a></code>, <code><a href="#topic+sc_rate_limit_schema">sc_rate_limit_schema()</a></code>, <code><a href="#topic+sc_rate_limits">sc_rate_limits()</a></code>: a <code>list</code> with elements
</p>

<ul>
<li> <p><code>remaining</code>: how much requests can be sent until the rate limit is reached
</p>
</li>
<li> <p><code>limit</code>: the number of requests allowed per hour
</p>
</li>
<li> <p><code>reset</code>: a timestamp when the rate limit will be reset
</p>
</li></ul>

</li>
<li> <p><code><a href="#topic+sc_rate_limits">sc_rate_limits()</a></code>:
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>sc_info()</code>: returns information about all available database languages
</p>
</li>
<li> <p><code>sc_rate_limit_table()</code>: returns a <code>list</code> with information about current requests-limits with
respect to the <code style="white-space: pre;">&#8288;/table&#8288;</code> endpoint. It
also shows when the limits reset which should be less than one hour
after the current time.
</p>
</li>
<li> <p><code>sc_rate_limit_schema()</code>: returns a <code>list</code> with information about current requests-limits with
respect to the <code style="white-space: pre;">&#8288;/schema&#8288;</code> endpoint. It
also shows when the limits reset which should be less than one hour
after the current time.
</p>
</li>
<li> <p><code>sc_rate_limits()</code>: gets rate limits from response headers
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
sc_info()
sc_rate_limit_table()
sc_rate_limit_schema()
sc_rate_limits(sc_schema("str:group:deake005:X_B1"))

</code></pre>

<hr>
<h2 id='sc_browse'>Links to important 'STATcube' and 'OGD' pages</h2><span id='topic+sc_browse'></span><span id='topic+sc_browse_preferences'></span><span id='topic+sc_browse_table'></span><span id='topic+sc_browse_database'></span><span id='topic+sc_browse_catalogue'></span><span id='topic+sc_browse_ogd'></span>

<h3>Description</h3>

<p>A collection of links, to browse important 'STATcube' pages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_browse(server = "ext")

sc_browse_preferences(server = "ext")

sc_browse_table(table, server = "ext")

sc_browse_database(database, server = NULL, open = FALSE)

sc_browse_catalogue(server = "ext")

sc_browse_ogd()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sc_browse_+3A_server">server</code></td>
<td>
<p>A STATcube API server. Defaults to the external Server via
<code>"ext"</code>. Other options are <code>"red"</code> for the editing server and <code>"prod"</code> for
the production server. External users should always use the default option <code>"ext"</code>.</p>
</td></tr>
<tr><td><code id="sc_browse_+3A_table">table</code></td>
<td>
<p>a table id</p>
</td></tr>
<tr><td><code id="sc_browse_+3A_database">database</code></td>
<td>
<p>a database id</p>
</td></tr>
<tr><td><code id="sc_browse_+3A_open">open</code></td>
<td>
<p>If <code>FALSE</code> (the default), open the infopage for the database.
Otherwise, open the table view.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the URL of a specific webpage which is opened by default
in a web browser.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>sc_browse()</code>: opens the home menu of 'STATcube'
</p>
</li>
<li> <p><code>sc_browse_preferences()</code>: opens the preference menu with the API key
</p>
</li>
<li> <p><code>sc_browse_table()</code>: shows the info page for a table
</p>
</li>
<li> <p><code>sc_browse_database()</code>: shows the info page for a database
</p>
</li>
<li> <p><code>sc_browse_catalogue()</code>: shows the data catalogue explorer
</p>
</li>
<li> <p><code>sc_browse_ogd()</code>: shows the landing page for OGD datasets
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>sc_browse()
sc_browse_preferences()
sc_browse_table('defaulttable_deake005')
sc_browse_database('deake005')
sc_browse_catalogue()
sc_browse_ogd()
</code></pre>

<hr>
<h2 id='sc_cache'>Cache responses from the STATcube REST API</h2><span id='topic+sc_cache'></span><span id='topic+sc_cache_enable'></span><span id='topic+sc_cache_disable'></span><span id='topic+sc_cache_enabled'></span><span id='topic+sc_cache_dir'></span><span id='topic+sc_cache_files'></span><span id='topic+sc_cache_clear'></span>

<h3>Description</h3>

<p>Functions to cache requested resources in the directory <code style="white-space: pre;">&#8288;~/.STATcubeR_cache&#8288;</code>
and reuse them in calls to <code><a href="#topic+sc_table">sc_table()</a></code>, <code><a href="#topic+sc_table_custom">sc_table_custom()</a></code> <code><a href="#topic+sc_schema">sc_schema()</a></code> and so forth.
These functions are designed for testing and documentation and should not be
regarded as part of the STATcubeR interface. The caching logic is likely to
change in the future in which case <code><a href="#topic+sc_cache_clear">sc_cache_clear()</a></code> is required to purge
old cache entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_cache_enable(verbose = TRUE)

sc_cache_disable()

sc_cache_enabled()

sc_cache_dir(dir = NULL)

sc_cache_files(x)

sc_cache_clear()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sc_cache_+3A_verbose">verbose</code></td>
<td>
<p>print instructions on how to set up caching persistently
via environment variables?</p>
</td></tr>
<tr><td><code id="sc_cache_+3A_dir">dir</code></td>
<td>
<p>a cache directory</p>
</td></tr>
<tr><td><code id="sc_cache_+3A_x">x</code></td>
<td>
<p>an object of class <code>sc_table</code> or <code>sc_schema</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Caching can be set up using environment variables. To set up a persistent cache
for both Open Data and the REST API, the following lines in <code>.Renviron</code> can
be used.
The paths in this example are only applicable for UNIX-based operating systems.
</p>
<div class="sourceCode sh"><pre>STATCUBE_KEY_EXT   = YOUR_API_KEY_GOES_HERE
STATCUBE_CACHE     = TRUE
OD_CACHE_DIR       = "~/.cache/STATcubeR/open_data/"
STATCUBE_CACHE_DIR = "~/.cache/STATcubeR/api/"
</pre></div>
<p>If caching is enabled, there is no check to verify if the
resources are unchanged in the server.
Caching is not implemented for the
endpoints <code><a href="#topic+sc_info">sc_info()</a></code> and <code><a href="#topic+sc_rate_limit_table">sc_rate_limit_table()</a></code>.
</p>


<h3>Value</h3>


<ul>
<li><p> for <code><a href="#topic+sc_cache_enable">sc_cache_enable()</a></code>, <code><a href="#topic+sc_cache_dir">sc_cache_dir()</a></code>: the path to the cache-directory
</p>
</li>
<li><p> for <code><a href="#topic+sc_cache_disable">sc_cache_disable()</a></code>: <code>TRUE</code>
</p>
</li>
<li><p> for <code><a href="#topic+sc_cache_enabled">sc_cache_enabled()</a></code>: <code>TRUE</code> if caching is enabled, <code>FALSE</code> otherwise
</p>
</li>
<li><p> for <code><a href="#topic+sc_cache_files">sc_cache_files()</a></code>: the content of the cache associated with a file
</p>
</li>
<li><p> for <code><a href="#topic+sc_cache_clear">sc_cache_clear()</a></code>: <code>NULL</code>
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>sc_cache_enable()</code>: enables caching for the current R session
</p>
</li>
<li> <p><code>sc_cache_disable()</code>: disables caching for the current R session
sc_cache_disable()
</p>
</li>
<li> <p><code>sc_cache_enabled()</code>: informs whether the cache is currently enabled
</p>
</li>
<li> <p><code>sc_cache_dir()</code>: get/set the directory used for caching
</p>
</li>
<li> <p><code>sc_cache_files()</code>: get the cache file associated with an object
</p>
</li>
<li> <p><code>sc_cache_clear()</code>: removes all files from the cache
</p>
</li></ul>

<hr>
<h2 id='sc_data'>Common interface for STATcubeR datasets</h2><span id='topic+sc_data'></span>

<h3>Description</h3>

<p>This class represents a common interface for datasets returned from the
STATcube REST API and OGD datasets. <code>sc_data</code> objects are usually created with
<code><a href="#topic+od_table">od_table()</a></code> or <code><a href="#topic+sc_table">sc_table()</a></code>.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>data</code></dt><dd><p>the raw data. A data.frame that uses codes for all field variables and
for all column names. To obtain labeled data, use <code style="white-space: pre;">&#8288;$tabulate()&#8288;</code>.</p>
</dd>
<dt><code>language</code></dt><dd><p>language to be used for labeling. <code>"en"</code> or <code>"de"</code></p>
</dd>
<dt><code>meta</code></dt><dd><p>A list containing metadata about the dataset. It has at least the
following entries
</p>

<ul>
<li> <p><strong><code style="white-space: pre;">&#8288;$source&#8288;</code></strong> is a dataframe with a single row that contains
information on the data source.
</p>
</li>
<li> <p><strong><code style="white-space: pre;">&#8288;$measures&#8288;</code></strong> is a dataframe with one row for every measure in the
dataset. It contains codes and labels for each measure as well as
the number of <code>NAs</code>. Derived classes might add additional columns.
</p>
</li>
<li> <p><strong><code style="white-space: pre;">&#8288;$fields&#8288;</code></strong> is a dataframe with one row for every field in the
dataset. It contains codes and labels for each measure as well as
the total codes. Derived classes might add additional columns
</p>
</li></ul>
</dd>
<dt><code>recode</code></dt><dd><p>An object of class <a href="#topic+sc_recoder">sc_recoder</a> that can be used to change labels
and perform other recoding operations.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-sc_data-new"><code>sc_data$new()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_data-field"><code>sc_data$field()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_data-tabulate"><code>sc_data$tabulate()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_data-total_codes"><code>sc_data$total_codes()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_data-clone"><code>sc_data$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-sc_data-new"></a>



<h4>Method <code>new()</code></h4>

<p>This class is not exported. Use <code><a href="#topic+od_table">od_table()</a></code> or <code><a href="#topic+sc_table">sc_table()</a></code>
to initialize objects of class <code>sc_data</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_data$new(data, meta, fields)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data, meta, fields</code></dt><dd><p>raw data, metadata and field information.
Do not use directly but initialize objects with <code><a href="#topic+sc_table">sc_table()</a></code> or
<code><a href="#topic+od_table">od_table()</a></code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-sc_data-field"></a>



<h4>Method <code>field()</code></h4>

<p>get information about a specific field. The format of
the return value is similar to <code style="white-space: pre;">&#8288;$meta&#8288;</code>. A <code>data.frame</code> that includes
codes and labels for each level of the field.
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_data$field(i = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>specifier for the field. Integer or character. If an integer
is provided, it should match the row number in <code style="white-space: pre;">&#8288;$meta$fields&#8288;</code>. If
a character is provided, the field is matched using <code><a href="base.html#topic+pmatch">pmatch()</a></code> on
all available codes and labels.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- od_table("OGD_krebs_ext_KREBS_1")
x$field(1)
x$field("Sex")
</pre>
</div>


<hr>
<a id="method-sc_data-tabulate"></a>



<h4>Method <code>tabulate()</code></h4>

<p>create a tidy dataset. See <code><a href="#topic+sc_tabulate">sc_tabulate()</a></code> for details.
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_data$tabulate(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>arguments that are passed down to <code><a href="#topic+sc_tabulate">sc_tabulate()</a></code></p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>x &lt;- od_table("OGD_krebs_ext_KREBS_1")
x$tabulate("Reporting year", "Sex")
</pre>
</div>


<hr>
<a id="method-sc_data-total_codes"></a>



<h4>Method <code>total_codes()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>sc_data$total_codes(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>key value pairs to define the total codes. Key should be a
field code and value a code from <code style="white-space: pre;">&#8288;$field(i)&#8288;</code>. If empty, it will
return a data.frame with all specified total codes. Keys and values
can also use labels instead of codes. See examples.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>earnings &lt;- od_table("OGD_veste309_Veste309_1")
earnings$total_codes(Sex = "Sum total", Citizenship = "Total",
                     Region = "Total", `Form of employment` = "Total")
earnings$tabulate("Form of employment")
earnings$tabulate("Sex", "Form of employment")
</pre>
</div>


<hr>
<a id="method-sc_data-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_data$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## create a new sc_data object via od_table()
x &lt;- od_table("OGD_krebs_ext_KREBS_1")

## show data
x$data

## show metadata
x$meta

## ------------------------------------------------
## Method `sc_data$field`
## ------------------------------------------------

x &lt;- od_table("OGD_krebs_ext_KREBS_1")
x$field(1)
x$field("Sex")

## ------------------------------------------------
## Method `sc_data$tabulate`
## ------------------------------------------------

x &lt;- od_table("OGD_krebs_ext_KREBS_1")
x$tabulate("Reporting year", "Sex")

## ------------------------------------------------
## Method `sc_data$total_codes`
## ------------------------------------------------

earnings &lt;- od_table("OGD_veste309_Veste309_1")
earnings$total_codes(Sex = "Sum total", Citizenship = "Total",
                     Region = "Total", `Form of employment` = "Total")
earnings$tabulate("Form of employment")
earnings$tabulate("Sex", "Form of employment")
</code></pre>

<hr>
<h2 id='sc_json_get_server'>Get the server from a json request</h2><span id='topic+sc_json_get_server'></span>

<h3>Description</h3>

<p>parses a json request and returns a short string representing
the corresponding STATcube server
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_json_get_server(json)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sc_json_get_server_+3A_json">json</code></td>
<td>
<p>path to a request json</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"ext"</code>, <code>"red"</code> or <code>"prod"</code> depending on the database uri in the
json request
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc_json_get_server(sc_example('accomodation'))
</code></pre>

<hr>
<h2 id='sc_key'>Manage your API Keys</h2><span id='topic+sc_key'></span><span id='topic+sc_key_set'></span><span id='topic+sc_key_get'></span><span id='topic+sc_key_prompt'></span><span id='topic+sc_key_exists'></span><span id='topic+sc_key_valid'></span>

<h3>Description</h3>

<p>Functions to get/set the STATcube API keys and make them available for calls
against the STATcube API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_key(server = "ext", test = FALSE)

sc_key_set(key, server = "ext", test = TRUE)

sc_key_get(server = "ext")

sc_key_prompt(server = "ext", test = TRUE)

sc_key_exists(server = "ext")

sc_key_valid(key = NULL, server = "ext")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sc_key_+3A_server">server</code></td>
<td>
<p>A STATcube API server. Defaults to the external Server via
<code>"ext"</code>. Other options are <code>"red"</code> for the editing server and <code>"prod"</code> for
the production server. External users should always use the default option <code>"ext"</code>.</p>
</td></tr>
<tr><td><code id="sc_key_+3A_test">test</code></td>
<td>
<p>Use <code>sc_key_valid()</code> to verify the key? If the key is
invalid, an error is returned and the key will not be set or updated.</p>
</td></tr>
<tr><td><code id="sc_key_+3A_key">key</code></td>
<td>
<p>(<code>string</code>) An API key. To display your key, call
<code><a href="#topic+sc_browse_preferences">sc_browse_preferences()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All functions return the key (invisibly) except for
<code>sc_key_exists()</code> and <code>sc_key_valid()</code>, which return a <code><a href="base.html#topic+logical">logical()</a></code> of
length one.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>sc_key()</code>: forwards to <code><a href="#topic+sc_key_get">sc_key_get()</a></code> if the key is already present.
Otherwise, <code><a href="#topic+sc_key_prompt">sc_key_prompt()</a></code> will be invoked.
</p>
</li>
<li> <p><code>sc_key_set()</code>: can be used to pass the key as a parameter (<code>string</code>)
</p>
</li>
<li> <p><code>sc_key_get()</code>: returns the key, if it exists. Otherwise,
an error is thrown.
</p>
</li>
<li> <p><code>sc_key_prompt()</code>: prompts for a key via <code><a href="base.html#topic+readline">readline()</a></code>
</p>
</li>
<li> <p><code>sc_key_exists()</code>: returns <code>TRUE</code> if a key was set and <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>sc_key_valid()</code>: performs a test request and returns <code>TRUE</code> if the
key is valid and <code>FALSE</code> otherwise.
</p>
</li></ul>

<hr>
<h2 id='sc_last_error'>Error handling for the STATcube REST API</h2><span id='topic+sc_last_error'></span><span id='topic+sc_last_error_parsed'></span>

<h3>Description</h3>

<p>In case API requests are unsuccessful, <code>STATcubeR</code> will throw errors
to summarize the httr error type and its meaning.
Requests are considered unsuccessful if one of the following applies
</p>

<ul>
<li><p> The response returns <code>TRUE</code> for <code>httr::http_error()</code>.
</p>
</li>
<li><p> The response is not of type <code>"application/json"</code>
</p>
</li></ul>

<p>In some cases it is useful to get direct access to a faulty response object.
For that purpose, it is possible to use <code><a href="#topic+sc_last_error">sc_last_error()</a></code> which will provide
the httr response object for the last unsuccessful request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_last_error()

sc_last_error_parsed()
</code></pre>


<h3>Value</h3>

<p>The return value from <code>httr::GET()</code> or <code>httr::POST()</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>sc_last_error_parsed()</code>: returns the last error as a list containing
the response content and the response status
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
try(sc_table_saved("invalid_id"))
last_error &lt;- sc_last_error()
httr::content(last_error)
str(sc_last_error_parsed())

</code></pre>

<hr>
<h2 id='sc_recoder'>Recode sc_table objects</h2><span id='topic+sc_recoder'></span>

<h3>Description</h3>

<p>A collection of methods that can be used to modify an object of class
sc_table by reference. Typical usage is to access the <code>recode</code> binding
of an <code>sc_table</code> object and then use method chaining to perform recode
operations.
</p>
<div class="sourceCode"><pre>x &lt;- od_table("OGD_krebs_ext_KREBS_1")
x$recode$
  label_field("C-BERJ-0", "de", "JAHR")$
  label_measure("F-KRE", "de", "Anzahl")
</pre></div>
<p>See the example section for more details.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-sc_recoder-new"><code>sc_recoder$new()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_recoder-label_field"><code>sc_recoder$label_field()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_recoder-label_measure"><code>sc_recoder$label_measure()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_recoder-level"><code>sc_recoder$level()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_recoder-total_codes"><code>sc_recoder$total_codes()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_recoder-visible"><code>sc_recoder$visible()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_recoder-order"><code>sc_recoder$order()</code></a>
</p>
</li></ul>


<hr>
<a id="method-sc_recoder-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new recoder instance. This will automatically
be performed during the setup of <code>sc_data</code> objects
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_recoder$new(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>the private environment of an <code>sc_data</code> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-sc_recoder-label_field"></a>



<h4>Method <code>label_field()</code></h4>

<p>Change the label of a field variable
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_recoder$label_field(field, language, new)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>field</code></dt><dd><p>a field code</p>
</dd>
<dt><code>language</code></dt><dd><p>a language, &quot;de&quot; or &quot;en&quot;</p>
</dd>
<dt><code>new</code></dt><dd><p>the new label</p>
</dd>
</dl>

</div>


<hr>
<a id="method-sc_recoder-label_measure"></a>



<h4>Method <code>label_measure()</code></h4>

<p>Change the label of a measure variable
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_recoder$label_measure(measure, language, new)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>measure</code></dt><dd><p>a measure code</p>
</dd>
<dt><code>language</code></dt><dd><p>a language &quot;de&quot; or &quot;en&quot;</p>
</dd>
<dt><code>new</code></dt><dd><p>the new label</p>
</dd>
</dl>

</div>


<hr>
<a id="method-sc_recoder-level"></a>



<h4>Method <code>level()</code></h4>

<p>Change the labels of a level
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_recoder$level(field, level, language, new)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>field</code></dt><dd><p>a field code</p>
</dd>
<dt><code>level</code></dt><dd><p>a level code for the field</p>
</dd>
<dt><code>language</code></dt><dd><p>a language &quot;de&quot; or &quot;en&quot;</p>
</dd>
<dt><code>new</code></dt><dd><p>the new label for the level</p>
</dd>
</dl>

</div>


<hr>
<a id="method-sc_recoder-total_codes"></a>



<h4>Method <code>total_codes()</code></h4>

<p>Change the total code for a field
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_recoder$total_codes(field, new)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>field</code></dt><dd><p>a field code</p>
</dd>
<dt><code>new</code></dt><dd><p>a level code for the field or <code>NA</code>. Will be used as the
new total code. In case of <code>NA</code>, the total code will be unset.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-sc_recoder-visible"></a>



<h4>Method <code>visible()</code></h4>

<p>set the visibility of a level. Invisible levels are
omitted in the output of <code style="white-space: pre;">&#8288;$tabulate()&#8288;</code> but don't affect aggregation
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_recoder$visible(field, level, new)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>field</code></dt><dd><p>a field code</p>
</dd>
<dt><code>level</code></dt><dd><p>a level code for the field</p>
</dd>
<dt><code>new</code></dt><dd><p>visibility. <code>TRUE</code> or <code>FALSE</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-sc_recoder-order"></a>



<h4>Method <code>order()</code></h4>

<p>set the order of levels.
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_recoder$order(field, new)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>field</code></dt><dd><p>a field code</p>
</dd>
<dt><code>new</code></dt><dd><p>the new order. A permutation of all level codes for the field.
alternatively, an integer vector that defines the permutation.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- od_table("OGD_krebs_ext_KREBS_1")

x$recode$
  label_field("C-KRE_GESCHLECHT-0", "en", "SEX")$
  label_measure("F-KRE", "en", "NUMBER")$
  level("C-KRE_GESCHLECHT-0", "GESCHLECHT-1", "en", "MALE")

x$tabulate("C-KRE_GESCHLECHT-0", "F-KRE")

earnings &lt;- od_table("OGD_veste309_Veste309_1")
earnings$recode$
  total_codes("C-A11-0", "A11-1")$
  total_codes("C-STAATS-0", "STAATS-9")$
  total_codes("C-VEBDL-0", "VEBDL-10")$
  total_codes("C-BESCHV-0", "BESCHV-1")

earnings$total_codes()

earnings$tabulate("C-STAATS-0")
earnings$recode$visible("C-STAATS-0", "STAATS-8", FALSE)
earnings$tabulate("C-STAATS-0")

earnings$recode$
  order("C-A11-0", c("A11-3", "A11-1", "A11-2"))
</code></pre>

<hr>
<h2 id='sc_schema'>Create a request against the /schema endpoint</h2><span id='topic+sc_schema'></span><span id='topic+print.sc_schema'></span><span id='topic+sc_schema_flatten'></span><span id='topic+sc_schema_catalogue'></span><span id='topic+sc_schema_db'></span>

<h3>Description</h3>

<p>Invoke the <a href="https://docs.wingarc.com.au/superstar/9.12/open-data-api/open-data-api-reference/schema-endpoint"><strong>/schema</strong></a> endpoint of the STATcube REST API.
This endpoint can be used to get all available databases and tables
as well as metadata about specific databases.
</p>
<p>The main function <code>sc_schema()</code> can be used with any resource id.
<code><a href="#topic+sc_schema_catalogue">sc_schema_catalogue()</a></code> and <code><a href="#topic+sc_schema_db">sc_schema_db()</a></code> are very simple
wrapper functions around <code><a href="#topic+sc_schema">sc_schema()</a></code> and are comparable to the
catalogue explorer or the
table view of the STATcube GUI.
</p>
<p>The responses of the API are tree-like data structures which
are wrapped into a class called <code>sc_schema</code> to simplify the usage in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_schema(id = NULL, depth = NULL, language = NULL, key = NULL, server = "ext")

## S3 method for class 'sc_schema'
print(x, tree = NULL, ..., limit = 30)

sc_schema_flatten(x, type)

sc_schema_catalogue(depth = "folder", ...)

sc_schema_db(id, depth = "valueset", language = c("en", "de"), key = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sc_schema_+3A_id">id</code></td>
<td>
<p>A resource identifier in uid format. In case of <code>sc_schema_db()</code>,
this should be a database id. For <code>sc_schema()</code> any resource-id
(folder, measure, table, ...) is accepted.</p>
</td></tr>
<tr><td><code id="sc_schema_+3A_depth">depth</code></td>
<td>
<p>If provided, the request will recurse into the given level.
For datasets, available options are <code>NULL</code> (no recursion), <code>"folder"</code>,
<code>"field"</code> and <code>"valueset"</code>. For the catalogue, only <code>NULL</code> and <code>"folder"</code>
are applicable.</p>
</td></tr>
<tr><td><code id="sc_schema_+3A_language">language</code></td>
<td>
<p>The language to be used for labeling. <code>"en"</code> or <code>"de"</code></p>
</td></tr>
<tr><td><code id="sc_schema_+3A_key">key</code></td>
<td>
<p>(<code>string</code>) An API key. To display your key, call
<code><a href="#topic+sc_browse_preferences">sc_browse_preferences()</a></code>.</p>
</td></tr>
<tr><td><code id="sc_schema_+3A_server">server</code></td>
<td>
<p>A STATcube API server. Defaults to the external Server via
<code>"ext"</code>. Other options are <code>"red"</code> for the editing server and <code>"prod"</code> for
the production server. External users should always use the default option <code>"ext"</code>.</p>
</td></tr>
<tr><td><code id="sc_schema_+3A_x">x</code></td>
<td>
<p>an object of class <code>sc_schema()</code> i.e. the return value of
<code><a href="#topic+sc_schema">sc_schema()</a></code>, <code><a href="#topic+sc_schema_db">sc_schema_db()</a></code> or <code><a href="#topic+sc_schema_catalogue">sc_schema_catalogue()</a></code>.</p>
</td></tr>
<tr><td><code id="sc_schema_+3A_tree">tree</code></td>
<td>
<p>whether to use the <a href="https://rdrr.io/cran/data.tree/man/data.tree.html"><code>data.tree</code></a> package for printing.</p>
</td></tr>
<tr><td><code id="sc_schema_+3A_limit">limit</code>, <code id="sc_schema_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="data.tree.html#topic+print.Node">data.tree::print.Node()</a></code> if <code>tree</code> is set
to <code>TRUE</code>. Ignored otherwise.</p>
</td></tr>
<tr><td><code id="sc_schema_+3A_type">type</code></td>
<td>
<p>a schema type such as &quot;DATABASE&quot;, &quot;VALUE&quot; or &quot;TABLE&quot;.
See <a href="https://docs.wingarc.com.au/superstar/9.12/open-data-api/open-data-api-reference/schema-endpoint#id-.SchemaOpenDataAPIv9.9.6-SchemaTypesandAssociatedIDSchemes">the API reference</a> for a list of all schema types.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> for <code><a href="#topic+sc_schema">sc_schema()</a></code> and <code><a href="#topic+sc_schema_db">sc_schema_db()</a></code>: an object of class <code>sc_schema</code>
</p>
</li>
<li><p> for <code><a href="#topic+sc_schema_flatten">sc_schema_flatten()</a></code>: a <code>data.frame</code>
</p>
</li>
<li><p> for <code><a href="#topic+sc_schema_catalogue">sc_schema_catalogue()</a></code>: a <code>list</code>
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>sc_schema_flatten()</code>: turns a <code>sc_schema</code> object into a <code>data.frame</code>
</p>
</li>
<li> <p><code>sc_schema_catalogue()</code>: is similar to the
<a href="https://portal.statistik.at/statistik.at/ext/statcube/jsf/dataCatalogueExplorer.xhtml">catalogue explorer</a> of the STATcube GUI and returns
a tree-type object containing all databases and tables.
</p>
</li>
<li> <p><code>sc_schema_db()</code>: is similar to the
<a href="https://portal.statistik.at/statistik.at/ext/statcube/opendatabase?id=deake005">table view</a>
of the STATcube GUI and gives information about all measures and
classification fields for a specific database
</p>
</li></ul>


<h3>Printing with data.tree</h3>

<p><code>limit</code> and <code>...</code> will simply be ignored if <code>tree</code> is set to <code>FALSE</code>, which is
the default. The printing via <code>data.tree</code> can take longer than the default
implementation because <code>x</code> will need to be converted into a <code>data.tree</code> node.
To use <code>data.tree</code> printing permanently, use
</p>
<div class="sourceCode r"><pre>options(STATcubeR.print_tree = TRUE)
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>
my_catalogue &lt;- sc_schema_catalogue()

## print
my_catalogue

## access the parsed catalogue
my_catalogue$Statistics$`Labour Market`
my_catalogue$Statistics$`Labour Market`$`Working hours (Labour Force Survey)`

db_schema &lt;- sc_schema_db("deake005")

# printing
db_schema

# access child nodes
db_schema$`Demographic Characteristics`
db_schema$`Demographic Characteristics`$Gender$Gender
db_schema$`Demographic Characteristics`$Gender$Gender$male

# access the raw response from httr::GET()
my_response &lt;- attr(db_schema, "response")
my_response$headers$date
my_content &lt;- httr::content(my_response)
my_content$label

# print with data.tree

 treeX_B1 &lt;- sc_schema("str:group:deake005:X_B1", depth = "valueset")
 print(treeX_B1, tree = TRUE)

</code></pre>

<hr>
<h2 id='sc_table'>Create a request against the /table endpoint</h2><span id='topic+sc_table'></span><span id='topic+sc_examples_list'></span><span id='topic+sc_example'></span><span id='topic+sc_table_saved_list'></span><span id='topic+sc_table_saved'></span>

<h3>Description</h3>

<p>Send requests against the <strong><code style="white-space: pre;">&#8288;/table&#8288;</code></strong> endpoint of the STATcube REST API. The
requests can use three formats with corresponding functions
</p>

<ul>
<li> <p><code><a href="#topic+sc_table">sc_table()</a></code> uses a json file downloaded via the STATcube GUI
</p>
</li>
<li> <p><code><a href="#topic+sc_table_custom">sc_table_custom()</a></code> uses the ids of a database, measures and fields
</p>
</li>
<li> <p><code><a href="#topic+sc_table_saved">sc_table_saved()</a></code> uses a table uri of a saved table.
</p>
</li></ul>

<p>Those three functions all return an object of class <code>"sc_table"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_table(json, language = NULL, add_totals = TRUE, key = NULL, json_file = NA)

sc_examples_list()

sc_example(filename)

sc_table_saved_list(key = NULL, server = "ext")

sc_table_saved(table_uri, language = NULL, key = NULL, server = "ext")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sc_table_+3A_json">json</code></td>
<td>
<p>Path to a json file, which was downloaded via the STATcube
GUI (&quot;Open Data API Request&quot;). Alternatively, a json string which
passes <code><a href="jsonlite.html#topic+validate">jsonlite::validate()</a></code>.</p>
</td></tr>
<tr><td><code id="sc_table_+3A_language">language</code></td>
<td>
<p>The language to be used for labeling. <code>"en"</code> (the default)
will use english. <code>"de"</code> uses German.
The third option <code>"both"</code> will import both languages by sending two requests
to the <code style="white-space: pre;">&#8288;/table&#8288;</code> endpoint.</p>
</td></tr>
<tr><td><code id="sc_table_+3A_add_totals">add_totals</code></td>
<td>
<p>Should totals be added for each classification field in
the json request?</p>
</td></tr>
<tr><td><code id="sc_table_+3A_key">key</code></td>
<td>
<p>(<code>string</code>) An API key. To display your key, call
<code><a href="#topic+sc_browse_preferences">sc_browse_preferences()</a></code>.</p>
</td></tr>
<tr><td><code id="sc_table_+3A_json_file">json_file</code></td>
<td>
<p>Deprecated. Use <code>json</code> instead</p>
</td></tr>
<tr><td><code id="sc_table_+3A_filename">filename</code></td>
<td>
<p>The name of an example json file.</p>
</td></tr>
<tr><td><code id="sc_table_+3A_server">server</code></td>
<td>
<p>A STATcube API server. Defaults to the external Server via
<code>"ext"</code>. Other options are <code>"red"</code> for the editing server and <code>"prod"</code> for
the production server. External users should always use the default option <code>"ext"</code>.</p>
</td></tr>
<tr><td><code id="sc_table_+3A_table_uri">table_uri</code></td>
<td>
<p>Identifier of a saved table as returned by
<code><a href="#topic+sc_table_saved_list">sc_table_saved_list()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sc_table</code> which contains the return
value of the <code><a href="httr.html#topic+POST">httr::POST()</a></code> request in <code>obj$response</code>. The object also
provides member functions to parse this response object. See
<a href="#topic+sc_table_class">sc_table_class</a> for the class documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my_table &lt;- sc_table(json = sc_example("population_timeseries.json"))

# print
my_table

# get matadata for the table
my_table$meta

# get a data.frame
as.data.frame(my_table)

# get metadata for field 2
my_table$field(2)


# get the ids and labels of all saved tables
(saved_tables &lt;- sc_table_saved_list())
table_uri &lt;- saved_tables$id[1]

# get a table based on one of these ids
my_response &lt;- sc_table_saved(table_uri)
as.data.frame(my_response)

</code></pre>

<hr>
<h2 id='sc_table_class'>Class for /table responses</h2><span id='topic+sc_table_class'></span>

<h3>Description</h3>

<p>R6 Class for all responses of the /table endpoint of the
'STATcube' REST API.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+sc_data">STATcubeR::sc_data</a></code> -&gt; <code>sc_table</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>response</code></dt><dd><p>the httr response</p>
</dd>
<dt><code>raw</code></dt><dd><p>the raw response content</p>
</dd>
<dt><code>annotation_legend</code></dt><dd><p>list of all annotations occurring in the data as a <code>data.frame</code> with
two columns for the annotation keys and annotation labels.</p>
</dd>
<dt><code>rate_limit</code></dt><dd><p>how much requests were left after the POST request for this table was sent?
Uses the same format as <code><a href="#topic+sc_rate_limit_table">sc_rate_limit_table()</a></code>.</p>
</dd>
<dt><code>json</code></dt><dd><p>an object of class <code>sc_json</code> based the json file used in the request</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-sc_table-new"><code>sc_table_class$new()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_table-update"><code>sc_table_class$update()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_table-tabulate"><code>sc_table_class$tabulate()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_table-browse"><code>sc_table_class$browse()</code></a>
</p>
</li>
<li> <p><a href="#method-sc_table-add_language"><code>sc_table_class$add_language()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="STATcubeR" data-topic="sc_data" data-id="field"><a href='../../STATcubeR/html/sc_data.html#method-sc_data-field'><code>STATcubeR::sc_data$field()</code></a></span></li>
<li><span class="pkg-link" data-pkg="STATcubeR" data-topic="sc_data" data-id="total_codes"><a href='../../STATcubeR/html/sc_data.html#method-sc_data-total_codes'><code>STATcubeR::sc_data$total_codes()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-sc_table-new"></a>



<h4>Method <code>new()</code></h4>

<p>Usually, objects of class <code>sc_table</code> are generated with
one of the factory methods <code><a href="#topic+sc_table">sc_table()</a></code>, <code><a href="#topic+sc_table_saved">sc_table_saved()</a></code> or
<code><a href="#topic+sc_table_custom">sc_table_custom()</a></code>. If this constructor is invoked directly,
either omit the parameters <code>json</code> and <code>file</code> or make sure that they
match with <code>response</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_table_class$new(response, json = NULL, file = NULL, add_totals = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>response</code></dt><dd><p>a response from <code><a href="httr.html#topic+POST">httr::POST()</a></code> against the /table
endpoint.</p>
</dd>
<dt><code>json</code></dt><dd><p>the json file used in the request as a string.</p>
</dd>
<dt><code>file</code></dt><dd><p>the file path to the json file</p>
</dd>
<dt><code>add_totals</code></dt><dd><p>was the json request modified by adding totals via
the add_totals parameter in one of the factory functions (<code>sc_table()</code>,
<code>sc_table_custom()</code>). Necessary, in order to also request totals via
the <code style="white-space: pre;">&#8288;$add_language()&#8288;</code> method.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-sc_table-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the data by re-sending the json to the API. This
is still experimental and could break the object in case new levels
were added to one of the fields. For example, if a new entry is
added to a timeseries
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_table_class$update()</pre></div>


<hr>
<a id="method-sc_table-tabulate"></a>



<h4>Method <code>tabulate()</code></h4>

<p>An extension of <code><a href="#topic+sc_tabulate">sc_tabulate()</a></code> with additional
parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_table_class$tabulate(
  ...,
  round = FALSE,
  annotations = FALSE,
  recode_zeros = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters which are passed down to <code><a href="#topic+sc_tabulate">sc_tabulate()</a></code></p>
</dd>
<dt><code>round</code></dt><dd><p>apply rounding to each measure according to the precision
provided by the API.</p>
</dd>
<dt><code>annotations</code></dt><dd><p>Include separate annotation columns in the returned
table. This parameter is currently broken and needs to be re-implemented</p>
</dd>
<dt><code>recode_zeros</code></dt><dd><p>interpret zero values as missings?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-sc_table-browse"></a>



<h4>Method <code>browse()</code></h4>

<p>open the dataset in a browser
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_table_class$browse()</pre></div>


<hr>
<a id="method-sc_table-add_language"></a>



<h4>Method <code>add_language()</code></h4>

<p>add a second language to the dataset
</p>


<h5>Usage</h5>

<div class="r"><pre>sc_table_class$add_language(language = NULL, key = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>language</code></dt><dd><p>a language to add. <code>"en"</code> or <code>"de"</code>.</p>
</dd>
<dt><code>key</code></dt><dd><p>an API key</p>
</dd>
</dl>

</div>



<hr>
<h2 id='sc_table_custom'>Create custom tables</h2><span id='topic+sc_table_custom'></span><span id='topic+sc_recode'></span>

<h3>Description</h3>

<p>Define requests against the /table endpoint by providing
URIs to databases, measures and fields.
The URIs can be obtained using <code><a href="#topic+sc_schema_db">sc_schema_db()</a></code>.
See the <a href="https://statistikat.github.io/STATcubeR/articles/sc_table_custom.html">Custom tables article</a>
for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_table_custom(
  db,
  measures = c(),
  dimensions = c(),
  language = c("en", "de"),
  add_totals = TRUE,
  key = NULL,
  recodes = NULL,
  dry_run = FALSE
)

sc_recode(field, map = NULL, total = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sc_table_custom_+3A_db">db</code></td>
<td>
<p>The uid of a database. Must be of type <code>DATASET</code></p>
</td></tr>
<tr><td><code id="sc_table_custom_+3A_measures">measures</code></td>
<td>
<p>A character vector of uids for measures. Each entry must be
of type <code>MEASURE</code>, <code>STAT_FUNCTION</code> or <code>COUNT</code>.</p>
</td></tr>
<tr><td><code id="sc_table_custom_+3A_dimensions">dimensions</code></td>
<td>
<p>A character vector of dimensions for the cube. Can be
either of type <code>FIELD</code> or type <code>VALUESET</code>. Those entries are referred to
as <code>fields</code> in the parsed API response</p>
</td></tr>
<tr><td><code id="sc_table_custom_+3A_language">language</code></td>
<td>
<p>The language to be used for labeling. &quot;en&quot;
(the default) will use English. &quot;de&quot; uses German.</p>
</td></tr>
<tr><td><code id="sc_table_custom_+3A_add_totals">add_totals</code></td>
<td>
<p>Should totals be added for each classification field in
the json request? Ignored if <code>recodes</code> is used.</p>
</td></tr>
<tr><td><code id="sc_table_custom_+3A_key">key</code></td>
<td>
<p>(<code>string</code>) An API key. To display your key, call
<code><a href="#topic+sc_browse_preferences">sc_browse_preferences()</a></code>.</p>
</td></tr>
<tr><td><code id="sc_table_custom_+3A_recodes">recodes</code></td>
<td>
<p>One or more recodes that were generated via <code><a href="#topic+sc_recode">sc_recode()</a></code>.
If more than one recode is supplied, recodes should be concatenated with
<code><a href="base.html#topic+c">c()</a></code>.</p>
</td></tr>
<tr><td><code id="sc_table_custom_+3A_dry_run">dry_run</code></td>
<td>
<p>If <code>TRUE</code>, no request is sent to the API. Instead, type
checks are performed and the json request is returned as a string.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sc_table_custom_+3A_field">field</code></td>
<td>
<p>An uid of a classification field to be recoded. The provided
uid should also be passed in the <code>dimensions</code> parameter of
<code><a href="#topic+sc_table_custom">sc_table_custom()</a></code>.</p>
</td></tr>
<tr><td><code id="sc_table_custom_+3A_map">map</code></td>
<td>
<p>A list of ids for values (type <code>VALUE</code>) This can also be a nested
list if items should be grouped. See examples</p>
</td></tr>
<tr><td><code id="sc_table_custom_+3A_total">total</code></td>
<td>
<p>Add totals to the field? If <code>map</code> is provided, the totals
will correspond to the filtered data.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> for <code><a href="#topic+sc_table_custom">sc_table_custom()</a></code>: an object of class <code>sc_table</code>
</p>
</li>
<li><p> for <code><a href="#topic+sc_recode">sc_recode()</a></code>: a <code>list</code> that is a suitable input for parameter
<code>"recode"</code> in <code><a href="#topic+sc_table_custom">sc_table_custom()</a></code>
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>sc_recode()</code>: creates a recode object which can be used
for the <code>recode</code> parameter of <code><a href="#topic+sc_table_custom">sc_table_custom()</a></code>
</p>
</li></ul>


<h3>Schema objects in parameters</h3>

<p>it is possible to pass <code>sc_schema</code> objects (usually generated by
<code><a href="#topic+sc_schema_db">sc_schema_db()</a></code>) instead of ids in <code><a href="#topic+sc_table_custom">sc_table_custom()</a></code> and <code><a href="#topic+sc_recode">sc_recode()</a></code>.
If provided, the schema objects will be converted into ids via <code style="white-space: pre;">&#8288;$id&#8288;</code>.
</p>


<h3>Error handling</h3>

<p>Unfortunately, the API gives fairly vague error messages in case a
custom table request is ill defined. For this reason, <code><a href="#topic+sc_table_custom">sc_table_custom()</a></code>
applies some simple heuristics and throws warnings if inconsistencies
in the provided parameters are recognized. The following conditions are
currently checked
</p>

<ul>
<li><p> the parameter <code>db</code> is of type <code>DATABASE</code>
</p>
</li>
<li><p> all entries in <code>measures</code> are of type <code>MEASURE</code>, <code>COUNT</code> or
<code>STATFN</code>
</p>
</li>
<li><p> all entries in <code>dimensions</code> are of type <code>VALUESET</code> or <code>FIELD</code>
</p>
</li>
<li><p> all entries in <code>field</code> are of type <code>VALUESET</code> or <code>FIELD</code>
</p>
</li>
<li><p> all entries in <code>map</code> are of type <code>VALUE</code>
</p>
</li>
<li><p> all fields in <code>recodes</code> are also present in <code>dimensions</code>
</p>
</li>
<li><p> the first two arguments of <code>sc_recode()</code> are consistent, i.e.
if the provided <code>VALUE</code>s belong to the <code>VALUESET/FIELD</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
sc_table_custom("str:database:detouextregsai")

sc_table_custom(
  "str:database:detouextregsai",
  dimensions = "str:field:detouextregsai:F-DATA1:C-SDB_TIT-0"
)

sc_table_custom(
  db = "str:database:detouextregsai",
  measures = c(
    "str:statfn:detouextregsai:F-DATA1:F-ANK:SUM",
    "str:measure:detouextregsai:F-DATA1:F-UEB"
  ),
  dimensions = c(
    "str:field:detouextregsai:F-DATA1:C-SDB_TIT-0",
    "str:valueset:detouextregsai:F-DATA1:C-C93-2:C-C93SUM-0"
  )
)

schema &lt;- sc_schema_db("detouextregsai")
region &lt;- schema$`Other Classifications`$`Tourism commune [ABO]`$
  `Regionale Gliederung (Ebene +1)`
month &lt;- schema$`Mandatory fields`$`Season/Tourism Month`

x &lt;- sc_table_custom(
  schema,
  schema$Facts$Arrivals,
  list(month, region),
  recodes = c(
    sc_recode(region, total = FALSE, map = list(
      region$Achensee,
      list(region$Arlberg, region$`Ausseerland-Salzkammergut`)
    )),
    sc_recode(month, total = FALSE)
  )
)
x$tabulate()

</code></pre>

<hr>
<h2 id='sc_tabulate'>Turn sc_data objects into tidy data frames</h2><span id='topic+sc_tabulate'></span>

<h3>Description</h3>

<p><code><a href="#topic+sc_tabulate">sc_tabulate()</a></code> extracts the data in the table and turns it into a tidy
data.frame. It applies labeling of the data and transforms time variables
into a <code>Date</code> format if they satisfy certain 'STATcube' standards.
</p>
<p><code>sc_tabulate(table, ...)</code> is just an alias for <code>table$tabulate(...)</code> and
was added so this rather complicated method can have a separate documentation
page. It is recommended to use the <code>table$tabulate()</code> syntax
</p>
<p>the <code>...</code> argument decides which measures and/or fields should be included
in the output. If no measures are given, all measures are included. The same
is true for fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_tabulate(
  table,
  ...,
  .list = NULL,
  raw = FALSE,
  parse_time = TRUE,
  recode_zeros = inherits(table, "sc_table"),
  language = NULL,
  sort = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sc_tabulate_+3A_table">table</code></td>
<td>
<p>An object of class <code>sc_data</code></p>
</td></tr>
<tr><td><code id="sc_tabulate_+3A_...">...</code></td>
<td>
<p>Names of measures and/or fields</p>
</td></tr>
<tr><td><code id="sc_tabulate_+3A_.list">.list</code></td>
<td>
<p>allows to define the arguments for <code>...</code> as a character vector.</p>
</td></tr>
<tr><td><code id="sc_tabulate_+3A_raw">raw</code></td>
<td>
<p>If FALSE (the default), apply labeling to the dataset.
Otherwise, return codes.</p>
</td></tr>
<tr><td><code id="sc_tabulate_+3A_parse_time">parse_time</code></td>
<td>
<p>Should time variables be converted into a <code>Date</code> format?
Ignored if <code>raw</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sc_tabulate_+3A_recode_zeros">recode_zeros</code></td>
<td>
<p>turn zero values into <code>NA</code>s</p>
</td></tr>
<tr><td><code id="sc_tabulate_+3A_language">language</code></td>
<td>
<p>The language to be used for labeling. By default, the
dataset language (<code>table$language</code>) is used.</p>
</td></tr>
<tr><td><code id="sc_tabulate_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, the resulting data will be sorted by all provided
field values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Aggregation is done as follows
</p>

<ul>
<li><p> First, all columns that provide a total code via <code>table$total_codes()</code>
will be used to filter for <code>column == total_code</code> or <code>column != total_code</code>
</p>
</li>
<li><p> Then, the remaining data is aggregated using <code><a href="base.html#topic+rowsum">rowsum()</a></code>
</p>
</li></ul>

<p>The ellipsis (<code>...</code>) supports partial matching of codes and labels.
See Examples
</p>
<p>For objects of class <code>sc_table</code> two additional operations are performed.
</p>

<ul>
<li><p> zeros are recoded to <code>NA</code>s
</p>
</li>
<li><p> rounding is done according to the precision of each measure. Rounding
happens after the recoding to <code>NA</code> values
</p>
</li></ul>



<h3>Value</h3>

<p>a <code>data.frame</code>
</p>


<h3>See Also</h3>

<p>sc_table_class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############################ OGD Data #######################################

table &lt;- od_table("OGD_veste309_Veste309_1")

# no arguments -&gt; same output as `table$data`
table$tabulate()

# provide some fields -&gt; aggregate to keep only these fields
table$tabulate("Sex", "Citizenship")

# provide some measures -&gt; drop all other measures from the output
table$tabulate("Arithmetic mean")

# mixture of measures and fields  -&gt; keep exactly those columns
table$tabulate("Sex", "Arithmetic mean")

## define total codes
table$total_codes(
  `C-A11-0` = "A11-1",
  `C-STAATS-0` = "STAATS-9",
  `C-VEBDL-0` = "VEBDL-10",
  `C-BESCHV-0` = "BESCHV-1"
)

## alternatively, use partial matching to define totals
table$total_codes(
  Sex = "Sum total",
  Citizenship = "Total",
  Region = "Total",
  `Form of employment` = "Total"
)

# filter for totals in `Region (NUTS2)` and `Form of employment`. Drop totals
# in `Sex` and `Citizenship`.
table$tabulate("Sex", "Citizenship")

## switch language
table$language &lt;- "de"

## `...` matches for codes and labels
table$tabulate("C-A11-0", "Staats", "2. Quartil (Median)")

## Keep totals in the output by removing total codes
table$tabulate("C-A11-0")      # -&gt; 2 rows: "male" "female"
table$total_codes(`C-A11-0` = NA)
table$tabulate("C-A11-0")      # -&gt; 3 rows: "total", "male", "female"

## table$tabulate(...) is an alias for sc_tabulate(table, ...)
sc_tabulate(table, "C-A11-0")

######################## 'STATcube' REST API ################################


table_tourism &lt;- sc_table(sc_example("accomodation.json"), "de")

table_tourism$tabulate()
table_tourism$tabulate("Saison/Tourismusmonat")
table_tourism$tabulate("Saison/Tourismusmonat", "Ankünfte")
table_tourism$tabulate("Ankünfte")

</code></pre>

<hr>
<h2 id='sdmx_table'>Import data from SDMX</h2><span id='topic+sdmx_table'></span>

<h3>Description</h3>

<p>Function that reads STATcube data from an sdmx archive - a zip file
consisting of <code>structure.xml</code> with metadata and <code>dataset.xml</code> for the
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdmx_table(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdmx_table_+3A_file">file</code></td>
<td>
<p>a &quot;sdmx archive&quot; file that was downloaded from STATcube.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>sc_data</code>
</p>


<h3>Note</h3>

<p><code><a href="#topic+sdmx_table">sdmx_table()</a></code> should be treated as experimental for now.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sdmx_table(system.file("sdmx/dedemo.zip", package = "STATcubeR"))
# print and tabulate
x
x$tabulate()
# explore hierarchies
nuts2 &lt;- x$field("C-B00-0")
data.frame(label = nuts2$label,
  parent = nuts2$label[match(nuts2$parent, nuts2$code)])
# extract more data from the raw xml
xml2::xml_find_first(x$xml$meta, ".//Name")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
