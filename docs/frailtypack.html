<!DOCTYPE html><html lang="en"><head><title>Help for package frailtypack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {frailtypack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#frailtypack-package'><p>General Frailty models: shared, joint and nested frailty models with</p>
prediction; Evaluation of Failure-Time Surrogate Endpoints
<img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' /></a></li>
<li><a href='#additivePenal'><p>Fit an Additive Frailty model using a semiparametric penalized likelihood</p>
estimation or a parametric estimation</a></li>
<li><a href='#bcos'><p>Breast Cosmesis Data</p></a></li>
<li><a href='#cluster'><p>Identify clusters</p></a></li>
<li><a href='#Cmeasures'><p>Concordance measures in shared frailty and Cox proportional hazard models</p></a></li>
<li><a href='#colorectal'><p>Follow-up of metastatic colorectal cancer patients: times of new lesions</p>
appearance and death</a></li>
<li><a href='#colorectalLongi'><p>Follow-up of metastatic colorectal cancer patients : longitudinal</p>
measurements of tumor size</a></li>
<li><a href='#dataAdditive'><p>Simulated data as a gathering of clinical trials databases</p></a></li>
<li><a href='#dataMultiv'><p>Simulated data for two types of recurrent events and a terminal event</p></a></li>
<li><a href='#dataNCC'><p>Simulated data for recurrent events and a terminal event with weigths using</p>
nested case-control design</a></li>
<li><a href='#dataNested'><p>Simulated data with two levels of grouping</p></a></li>
<li><a href='#dataOvarian'><p>Advanced Ovarian Cancer dataset</p></a></li>
<li><a href='#Diffepoce'><p>Difference of Expected Prognostic Observed Cross-Entropy (EPOCE) estimators</p>
and its 95% tracking interval between two joint models.</a></li>
<li><a href='#epoce'><p>Estimators of the Expected Prognostic Observed Cross-Entropy (EPOCE) for</p>
evaluating predictive accuracy of joint models.</a></li>
<li><a href='#event2'><p>Identify event2 indicator</p></a></li>
<li><a href='#frailtyDesign'><p>Sample Size calculation and Power Analysis using Gamma-Frailty Models</p></a></li>
<li><a href='#frailtyPenal'><p>Fit a Shared, Joint or Nested Frailty model</p></a></li>
<li><a href='#gastadj'><p>Advanced Gastric Cancer dataset</p></a></li>
<li><a href='#GenfrailtyPenal'><p>Fit a Shared or a Joint Frailty Generalized Survival Model</p></a></li>
<li><a href='#hazard'><p>Hazard function.</p></a></li>
<li><a href='#jointRecCompet'><p>Competing Joint Frailty Model: A single type of recurrent event and two</p>
terminal events.</a></li>
<li><a href='#jointSurrCopSimul'><p>Generate survival times for two endpoints using the joint frailty-copula model for surrogacy</p></a></li>
<li><a href='#jointSurroCopPenal'><p>Fit the one-step Joint frailty-copula model for evaluating a canditate surrogate endpoint</p></a></li>
<li><a href='#jointSurroPenal'><p>Fit the one-step Joint surrogate model for evaluating a canditate surrogate endpoint</p></a></li>
<li><a href='#jointSurroPenalSimul'><p>Simulation studies based on the one-step Joint surrogate models for the evaluation of a canditate</p>
surrogate endpoint</a></li>
<li><a href='#jointSurroTKendall'><p>Kendall's <code class="reqn">\tau</code> estimation using numerical integration methods</p></a></li>
<li><a href='#jointSurrSimul'><p>Generate survival times for two endpoints using the joint frailty surrogate model</p></a></li>
<li><a href='#longDat'><p>Longitudinal semicontinuous biomarker dataset (TPJM)</p></a></li>
<li><a href='#longiPenal'><p>Fit a Joint Model for Longitudinal Data and a Terminal Event</p></a></li>
<li><a href='#loocv'><p>The trials leave-one-out crossvalidation for the one-step Joint surrogate model for evaluating a</p>
canditate surrogate endpoint.</a></li>
<li><a href='#multivPenal'><p>Fit a multivariate frailty model for two types of recurrent events and a</p>
terminal event.</a></li>
<li><a href='#num.id'><p>Identify individuals in Joint model for clustered data</p></a></li>
<li><a href='#plot.additivePenal'><p>Plot Method for an Additive frailty model.</p></a></li>
<li><a href='#plot.Diffepoce'><p>Plot difference of EPOCE estimators between two joint frailty models.</p></a></li>
<li><a href='#plot.epoce'><p>Plot values of estimators of the Expected Prognostic Observed Cross-Entropy</p>
(EPOCE).</a></li>
<li><a href='#plot.frailtyPenal'><p>Plot Method for a Shared frailty model.</p></a></li>
<li><a href='#plot.jointNestedPenal'><p>Plot method for a joint nested frailty model.</p></a></li>
<li><a href='#plot.jointPenal'><p>Plot Method for a Joint frailty model.</p></a></li>
<li><a href='#plot.jointRecCompet'><p>Plot Method for a joint competing risk model with one recurrent event and</p>
two terminal events.</a></li>
<li><a href='#plot.jointSurroMed'><p>Plot Method for a joint surrogate mediation analysis model.</p></a></li>
<li><a href='#plot.jointSurroPenal'><p>Plot Method for the one-step Joint surrogate model for the evaluation of a</p>
canditate surrogate endpoint.</a></li>
<li><a href='#plot.jointSurroPenalloocv'><p>Plot of trials leave-one-out crossvalidation Outputs from the one-step Joint surrogate model for evaluating a</p>
canditate surrogate endpoint.</a></li>
<li><a href='#plot.longiPenal'><p>Plot Method for a joint model for longitudinal data and a terminal event.</p></a></li>
<li><a href='#plot.multivPenal'><p>Plot Method for a multivariate frailty model.</p></a></li>
<li><a href='#plot.nestedPenal'><p>Plot Method for a Nested frailty model.</p></a></li>
<li><a href='#plot.predFrailty'><p>Plot predictions using a Cox or a shared frailty model.</p></a></li>
<li><a href='#plot.predJoint'><p>Plot predictions using a joint frailty model.</p></a></li>
<li><a href='#plot.predLongi'><p>Plot predictions using a joint model for longitudinal data and a terminal</p>
event or a trivariate joint model for longitudinal data, recurrent events
and a terminal event.</a></li>
<li><a href='#plot.trivPenal'><p>Plot Method for a trivariate joint model for longitudinal data, recurrent</p>
events and a terminal event.</a></li>
<li><a href='#plot.trivPenalNL'><p>Plot Method for a Non-Linear Trivariate Joint Model for Recurrent Events and</p>
a Terminal Event with a Biomarker Described with an ODE.</a></li>
<li><a href='#plotTreatPredJointSurro'><p>Plot of the prediction of the treatment effect on the true endpoint and the STE</p></a></li>
<li><a href='#predict.jointSurroPenal'><p>S3method predict for the one-step Joint surrogate models for the evaluation of a</p>
canditate surrogate endpoint.</a></li>
<li><a href='#prediction'><p>Prediction probabilities for Cox proportional hazard, Shared, Joint frailty</p>
models, Joint models for longitudinal data and a terminal event and
Trivariate joint model for longitudinal data, recurrent events and a
terminal event (linear and non-linear).</a></li>
<li><a href='#print.additivePenal'><p>Print a Short Summary of parameter estimates of an additive frailty model</p></a></li>
<li><a href='#print.Cmeasures'><p>Print a short summary of results of Cmeasure function.</p></a></li>
<li><a href='#print.frailtyDesign'><p>Print a short table of a 'frailtyDesign' result.</p></a></li>
<li><a href='#print.frailtyPenal'><p>Print a Short Summary of parameter estimates of a shared frailty model</p></a></li>
<li><a href='#print.jointNestedPenal'><p>Print a Short Summary of parameter estimates of a joint nested frailty model</p></a></li>
<li><a href='#print.jointPenal'><p>Print a Short Summary of parameter estimates of a joint frailty model</p></a></li>
<li><a href='#print.jointRecCompet'><p>Print a Short Summary of parameter estimates of a joint competing risks midel</p></a></li>
<li><a href='#print.jointSurroPenal'><p>Summary of the random effects parameters, the fixed treatment</p>
effects, and the surrogacy evaluation criteria estimated from a joint surrogate model</a></li>
<li><a href='#print.longiPenal'><p>Print a Summary of parameter estimates of a joint model for longitudinal</p>
data and a terminal event</a></li>
<li><a href='#print.multivPenal'><p>Print a Short Summary of parameter estimates of a multivariate frailty model</p></a></li>
<li><a href='#print.nestedPenal'><p>Print a Short Summary of parameter estimates of a nested frailty model</p></a></li>
<li><a href='#print.prediction'><p>Print a short summary of results of prediction function.</p></a></li>
<li><a href='#print.trivPenal'><p>Print a Summary of parameter estimates of a joint model for longitudinal</p>
data, recurrent events and a terminal event</a></li>
<li><a href='#print.trivPenalNL'><p>Print a Summary of parameter estimates of a non-linear trivariate joint</p>
model for longitudinal data, recurrent events and a terminal event</a></li>
<li><a href='#readmission'><p>Rehospitalization colorectal cancer</p></a></li>
<li><a href='#reduce'><p>Delirium in critically ill ICU patients dataset: the REDUCE clinical trial</p></a></li>
<li><a href='#runShiny'><p>Shiny application for modelisation and prediction of frailty models</p></a></li>
<li><a href='#simulatejointRecCompet'><p>Generating from a joint competing Joint frailty model with a recurrent event and two</p>
terminal events.</a></li>
<li><a href='#slope'><p>Identify variable associated with the random slope</p></a></li>
<li><a href='#ste'><p>Surrogate threshold effect for the one-step Joint surrogate model for the evaluation of a</p>
canditate surrogate endpoint.</a></li>
<li><a href='#subcluster'><p>Identify subclusters</p></a></li>
<li><a href='#summary.additivePenal'><p>summary of parameter estimates of an additive frailty model</p></a></li>
<li><a href='#summary.frailtyDesign'><p>Summarize a 'frailtyDesign' object.</p></a></li>
<li><a href='#summary.frailtyPenal'><p>summary of parameter estimates of a shared frailty model</p></a></li>
<li><a href='#summary.jointNestedPenal'><p>summary of parameter estimates of a joint nested frailty model</p></a></li>
<li><a href='#summary.jointPenal'><p>summary of parameter estimates of a joint frailty model</p></a></li>
<li><a href='#summary.jointRecCompet'><p>Summary method for a joint competing risks midel</p></a></li>
<li><a href='#summary.jointSurroMed'><p>Short summary of the random effects parameters, the fixed treatment</p>
effects, and the surrogacy evaluation criteria estimated from a joint surrogate mediation model</a></li>
<li><a href='#summary.jointSurroPenal'><p>Short summary of the surrogacy evaluation criteria estimated from a joint surrogate model</p></a></li>
<li><a href='#summary.jointSurroPenalSimul'><p>Short summary of the simulation studies based on a joint surrogate model</p></a></li>
<li><a href='#summary.longiPenal'><p>Short summary of fixed covariates estimates of a joint model for</p>
longitudinal data and a terminal event.</a></li>
<li><a href='#summary.multivPenal'><p>summary of parameter estimates of a multivariate frailty model.</p></a></li>
<li><a href='#summary.nestedPenal'><p>summary of regression coefficient estimates of a nested frailty model</p></a></li>
<li><a href='#summary.trivPenal'><p>Short summary of fixed covariates estimates of a joint model for</p>
longitudinal data, recurrent events and a terminal event</a></li>
<li><a href='#summary.trivPenalNL'><p>Short summary of fixed covariates estimates of a non-linear trivariate joint</p>
model for longitudinal data, recurrent events and a terminal event</a></li>
<li><a href='#survDat'><p>Survival dataset (TPJM)</p></a></li>
<li><a href='#SurvIC'><p>Create a survival object for interval censoring and possibly left truncated</p>
data</a></li>
<li><a href='#survival'><p>Survival function</p></a></li>
<li><a href='#terminal'><p>Identify terminal indicator</p></a></li>
<li><a href='#timedep'><p>Identify time-varying effects</p></a></li>
<li><a href='#trivPenal'><p>Fit a Trivariate Joint Model for Longitudinal Data, Recurrent Events and a</p>
Terminal Event</a></li>
<li><a href='#trivPenalNL'><p>Fit a Non-Linear Trivariate Joint Model for Recurrent Events and a Terminal</p>
Event with a Biomarker Described with an ODE Population Model</a></li>
<li><a href='#wts'><p>Identify weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Shared, Joint (Generalized) Frailty Models; Surrogate Endpoints</td>
</tr>
<tr>
<td>Version:</td>
<td>3.7.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Virginie Rondeau <a href="https://orcid.org/0000-0001-7109-4831"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Juan R. Gonzalez [aut],
  Yassin Mazroui [aut],
  Audrey Mauguen [aut],
  Amadou Diakite [aut],
  Alexandre Laurent [aut],
  Myriam Lopez [aut],
  Agnieszka Krol [aut],
  Casimir L. Sofeu [aut],
  Julien Dumerc [aut],
  Denis Rustand [aut],
  Jocelyn Chauvet [aut],
  Quentin Le Coent [aut],
  Romain Pierlot [aut],
  Lacey Etzkorn [aut],
  Derek Dinart [aut],
  Adrien Orué [aut],
  David Hill [cph],
  John Burkardt [cph],
  Alan Genz [cph],
  Ashwith J. Rego [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Virginie Rondeau &lt;virginie.rondeau@u-bordeaux.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The following several classes of frailty models using a
    penalized likelihood estimation on the hazard function but also a
    parametric estimation can be fit using this R package: 1) A shared
    frailty model (with gamma or log-normal frailty distribution) and Cox
    proportional hazard model. Clustered and recurrent survival times can
    be studied.  2) Additive frailty models for proportional hazard models
    with two correlated random effects (intercept random effect with
    random slope).  3) Nested frailty models for hierarchically clustered
    data (with 2 levels of clustering) by including two iid gamma random
    effects.  4) Joint frailty models in the context of the joint
    modelling for recurrent events with terminal event for clustered data
    or not. A joint frailty model for two semi-competing risks and
    clustered data is also proposed.  5) Joint general frailty models in
    the context of the joint modelling for recurrent events with terminal
    event data with two independent frailty terms.  6) Joint Nested
    frailty models in the context of the joint modelling for recurrent
    events with terminal event, for hierarchically clustered data (with
    two levels of clustering) by including two iid gamma random effects.
    7) Multivariate joint frailty models for two types of recurrent events
    and a terminal event.  8) Joint models for longitudinal data and a
    terminal event.  9) Trivariate joint models for longitudinal data,
    recurrent events and a terminal event.  10) Joint frailty models for
    the validation of surrogate endpoints in multiple randomized clinical
    trials with failure-time and/or longitudinal endpoints with the
    possibility to use a mediation analysis model.  11) Conditional and
    Marginal two-part joint models for longitudinal semicontinuous data
    and a terminal event.  12) Joint frailty-copula models for the
    validation of surrogate endpoints in multiple randomized clinical
    trials with failure-time endpoints.  13) Generalized shared and joint
    frailty models for recurrent and terminal events. Proportional hazards
    (PH), additive hazard (AH), proportional odds (PO) and probit models
    are available in a fully parametric framework. For PH and AH models,
    it is possible to consider type-varying coefficients and flexible
    semiparametric hazard function.  Prediction values are available (for
    a terminal event or for a new recurrent event). Left-truncated (not
    for Joint model), right-censored data, interval-censored data (only
    for Cox proportional hazard and shared frailty model) and strata are
    allowed. In each model, the random effects have the gamma or normal
    distribution. Now, you can also consider time-varying covariates
    effects in Cox, shared and joint frailty models (1-5). The package
    includes concordance measures for Cox proportional hazards models and
    for shared frailty models.  14) Competing Joint Frailty Model: A
    single type of recurrent event and two terminal events.  15) functions 
    to compute power and sample size for four Gamma-frailty-based designs: 
    Shared Frailty Models, Nested Frailty Models, Joint Frailty Models, and 
    General Joint Frailty Models. Each design includes two primary functions: a 
    power function, which computes power given a specified sample size; 
    and a sample size function, which computes the required sample size to achieve 
    a specified power. Moreover, the package can be used with its shiny
    application, in a local mode or by following the link below.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://virginie1rondeau.wixsite.com/virginierondeau/software-frailtypack">https://virginie1rondeau.wixsite.com/virginierondeau/software-frailtypack</a>
<a href="https://frailtypack-pkg.shinyapps.io/shiny_frailtypack/">https://frailtypack-pkg.shinyapps.io/shiny_frailtypack/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>boot, doBy, MASS, R (&ge; 3.5.0), survC1, survival</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, matrixcalc, nlme, rootSolve, shiny, splines,
statmod, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, timereg, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-06 16:20:10 UTC</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>no</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-06 14:39:41 UTC; AD</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
</table>
<hr>
<h2 id='frailtypack-package'>General Frailty models: shared, joint and nested frailty models with
prediction; Evaluation of Failure-Time Surrogate Endpoints 
<img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' /></h2><span id='topic+frailtypack-package'></span><span id='topic+frailtypack'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Frailtypack fits several classes of frailty models using a penalized
likelihood estimation on the hazard function but also a parametric
estimation.
</p>


<h3>Details</h3>

<p>The following several classes of frailty models using a penalized likelihood estimation on the hazard function but also a parametric estimation can be fit using this R package:
</p>
<p>1) A shared frailty model (with gamma or log-normal frailty distribution) and Cox proportional hazard model. Clustered and recurrent survival times can be studied.
</p>
<p>2) Additive frailty models for proportional hazard models with two correlated random effects (intercept random effect with random slope).
</p>
<p>3) Nested frailty models for hierarchically clustered data (with 2 levels of clustering) by including two iid gamma random effects.
</p>
<p>4) Joint frailty models in the context of the joint modelling for recurrent events with terminal event for clustered data or not. A joint frailty model for two semi-competing risks and clustered data is also proposed.
</p>
<p>5) Joint general frailty models in the context of the joint modelling for recurrent events with terminal event data with two independent frailty terms.
</p>
<p>6) Joint Nested frailty models in the context of the joint modelling for recurrent events with terminal event, for hierarchically clustered data (with two levels of clustering) by including two iid gamma random effects.
</p>
<p>7) Multivariate joint frailty models for two types of recurrent events and a terminal event.
</p>
<p>8) Joint models for longitudinal data and a terminal event.
</p>
<p>9) Trivariate joint models for longitudinal data, recurrent events and a terminal event.
</p>
<p>10) Joint frailty models for the validation of surrogate endpoints in multiple randomized clinical trials with failure-time and/or longitudinal endpoints
with the possibility to use a mediation analysis model.
</p>
<p>11) Conditional and Marginal two-part joint models for longitudinal semicontinuous data and a terminal event.
</p>
<p>12) Joint frailty-copula models for the validation of surrogate endpoints in multiple randomized clinical trials with failure-time endpoints.
</p>
<p>13) Generalized shared and joint frailty models for recurrent and terminal events. Proportional hazards (PH), additive hazard (AH), proportional odds (PO) and probit models are available in a fully parametric framework. 
</p>
<p>14) Competing Joint Frailty Model: A single type of recurrent event and two terminal events. 
</p>
<p>15) Functions to compute power and sample size for four Gamma-frailty-based designs: 
Shared Frailty Models, Nested Frailty Models, Joint Frailty Models, and 
General Joint Frailty Models. Each design includes two primary functions: a 
power function, which computes power given a specified sample size; 
and a sample size function, which computes the required sample size to achieve 
a specified power.
</p>
<p>The package includes concordance measures for Cox proportional hazards models and for shared frailty models.
Now, you can also consider time-varying covariates effects in Cox, shared and joint frailty models (1-5).
Some of the Fortran routines in the package can speed-up computation time by making use
of parallelization through OpenMP.  
Moreover, the package can be used with its shiny application, in a local mode or by following the link below. 
</p>

<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> frailtypack</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version:
</td><td style="text-align: left;"> 3.7.0 </td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2025-03-06</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;= 2.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Virginie Rondeau, Juan R. Gonzalez, Yassin Mazroui, Audrey Mauguen, 
Amadou Diakite, Alexandre Laurent, Myriam Lopez, Agnieszka Krol, 
Casimir L. Sofeu, Denis Rustand, Quentin Le Coent, Lacey Etzkorn, Romain Pierlot,
Derek Dinart and Adrien Orué
</p>


<h3>References</h3>

<p>Derek Dinart, Carine Bellera &amp; Virginie Rondeau (09 Feb 2024).
Sample size estimation for recurrent event data using multifrailty
and multilevel survival models. <em>Journal of Biopharmaceutical Statistics</em>,
DOI: 10.1080/10543406.2024.2310306.
</p>
<p>V. Rondeau, Y. Mazroui and J. R. Gonzalez (2012). Frailtypack:
An R package for the analysis of correlated survival data with frailty
models using penalized likelihood estimation or parametric estimation.
<em>Journal of Statistical Software</em> <b>47</b>, 1-28.
</p>
<p>Y. Mazroui, S. Mathoulin-Pelissier,P. Soubeyranb and Virginie Rondeau (2012)
General joint frailty model for recurrent event data with a dependent
terminalevent: Application to follicular lymphoma data. <em>Statistics in
Medecine</em>, <b>31</b>, 11-12, 1162-1176.
</p>
<p>V. Rondeau and J. R. Gonzalez (2005). Frailtypack: A computer program for
the analysis of correlated failure time data using penalized likelihood
estimation. <em>Computer Methods and Programs in Biomedicine</em> <b>80</b>,
2, 154-164.
</p>
<p>V. Rondeau, S. Michiels, B. Liquet, and J. P. Pignon (2008). Investigating
trial and treatment heterogeneity in an individual patient data
meta-analysis of survival data by mean of the maximum penalized likelihood
approach. <em>Statistics in Medecine</em>, <b>27</b>, 1894-1910.
</p>
<p>V. Rondeau, S. Mathoulin-Pellissier, H. Jacqmin-Gadda, V. Brouste, P.
Soubeyran (2007). Joint frailty models for recurring events and death using
maximum penalized likelihood estimation:application on cancer events.
<em>Biostatistics</em>, <b>8</b>, 4, 708-721.
</p>
<p>V. Rondeau, D. Commenges, and P. Joly (2003). Maximum penalized likelihood
estimation in a gamma-frailty model. <em>Lifetime Data Analysis</em> <b>9</b>,
139-153.
</p>
<p>D. Marquardt (1963). An algorithm for least-squares estimation of nonlinear
parameters. <em>SIAM Journal of Applied Mathematics</em>, 431-441.
</p>
<p>V. Rondeau, L. Filleul, P. Joly (2006). Nested frailty models using maximum
penalized likelihood estimation. <em>Statistics in Medecine</em>, <b>25</b>,
4036-4052.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

###--- Additive model with 1 covariate ---###

data(dataAdditive)
modAdd &lt;- additivePenal(Surv(t1,t2,event)~
cluster(group)+var1+slope(var1),
correlation=TRUE,data=dataAdditive,
n.knots=8,kappa=10000,hazard="Splines")

###--- Joint model (recurrent and terminal events) with 2 covariates ---###

data(readmission)
modJoint.gap &lt;- frailtyPenal(Surv(time,event)~
cluster(id)+sex+dukes+charlson+terminal(death),
formula.terminalEvent=~sex+dukes+charlson,
data=readmission,n.knots=10,kappa=c(100,100),
recurrentAG=FALSE,hazard="Splines")

###--- General Joint model (recurrent and terminal events) with 2 covariates ---###
data(readmission)
modJoint.general &lt;- frailtyPenal(Surv(time,event) ~ cluster(id) + dukes +
charlson + sex + chemo + terminal(death),
formula.terminalEvent = ~ dukes + charlson + sex + chemo,
data = readmission, jointGeneral = TRUE, n.knots = 8,
kappa = c(2.11e+08, 9.53e+11))

###--- Nested model (or hierarchical model) with 2 covariates ---###

data(dataNested)
modClu &lt;- frailtyPenal(Surv(t1,t2,event)~
cluster(group)+subcluster(subgroup)+cov1+cov2,
data=dataNested,n.knots=8,kappa=50000,hazard="Splines")

###--- Joint Nested Frailty model ---###

#-- here is generated cluster (30 clusters)
readmissionNested &lt;- transform(readmission,group=id%%30+1)

modJointNested_Splines &lt;- frailtyPenal(formula = Surv(t.start, t.stop, event) 
~ subcluster(id) + cluster(group) + dukes + terminal(death), 
formula.terminalEvent = ~dukes, data = readmissionNested, recurrentAG = TRUE, 
n.knots = 8, kappa = c(9.55e+9, 1.41e+12), initialize = TRUE)

modJointNested_Weib &lt;- frailtyPenal(Surv(t.start,t.stop,event)~subcluster(id)
+cluster(group)+dukes+ terminal(death),formula.terminalEvent=~dukes, 
hazard = ('Weibull'), data=readmissionNested,recurrentAG=TRUE, initialize = FALSE)

JoiNes-GapSpline &lt;- frailtyPenal(formula = Surv(time, event) 
~ subcluster(id) + cluster(group) + dukes + terminal(death), 
formula.terminalEvent = ~dukes, data = readmissionNested, recurrentAG = FALSE, 
n.knots = 8, kappa = c(9.55e+9, 1.41e+12), initialize = TRUE,
init.Alpha = 1.091, Ksi = "None")

###--- Semiparametric Shared model ---###

data(readmission)
sha.sp &lt;- frailtyPenal(Surv(t.start,t.stop,event)~
sex+dukes+charlson+cluster(id),data=readmission,
n.knots=6,kappa=5000,recurrentAG=TRUE,
cross.validation=TRUE,hazard="Splines")

###--- Parametric Shared model ---###

data(readmission)
sha.p &lt;- frailtyPenal(Surv(t.start,t.stop,event)~
cluster(id)+sex+dukes+charlson,
data=readmission,recurrentAG=TRUE,
hazard="Piecewise-per",nb.int=6)

###--- Joint model for longitudinal ---###
###--- data and a terminal event ---###

data(colorectal)
data(colorectalLongi)

# Survival data preparation - only terminal events 
colorectalSurv &lt;- subset(colorectal, new.lesions == 0)

model.weib.RE &lt;- longiPenal(Surv(time1, state) ~ age + treatment + who.PS 
+ prev.resection, tumor.size ~  year * treatment + age + who.PS ,
colorectalSurv,	data.Longi = colorectalLongi, 
random = c("1", "year"), id = "id", link = "Random-effects", 
left.censoring = -3.33, hazard = "Weibull")

###--- Trivariate joint model for longitudinal ---###
###--- data, recurrent and terminal events ---###

data(colorectal)
data(colorectalLongi)

# (computation takes around 40 minutes)

model.spli.RE.cal &lt;-trivPenal(Surv(time0, time1, new.lesions) ~ cluster(id)
+ age + treatment + who.PS +  terminal(state),
formula.terminalEvent =~ age + treatment + who.PS + prev.resection, 
tumor.size ~ year * treatment + age + who.PS, data = colorectal, 
data.Longi = colorectalLongi, random = c("1", "year"), id = "id", 
link = "Random-effects", left.censoring = -3.33, recurrentAG = TRUE,
n.knots = 6, kappa=c(0.01, 2), method.GH="Pseudo-adaptive",
n.nodes=7, init.B = c(-0.07, -0.13, -0.16, -0.17, 0.42, #recurrent events covariates
-0.23, -0.1, -0.09, -0.12, 0.8, -0.23, #terminal event covariates
3.02, -0.30, 0.05, -0.63, -0.02, -0.29, 0.11, 0.74)) #biomarker covariates


##---Surrogacy evaluation based on ganerated data with a combination 
##of Monte Carlo and classical Gaussian Hermite integration.
## (Computation takes around 5 minutes)

# Generation of data to use 
data.sim &lt;- jointSurrSimul(n.obs=600, n.trial = 30,cens.adm=549.24, 
         alpha = 1.5, theta = 3.5, gamma = 2.5, zeta = 1, sigma.s = 0.7, 
         sigma.t = 0.7, rsqrt = 0.8, betas = -1.25, betat = -1.25, 
         full.data = 0, random.generator = 1, seed = 0, nb.reject.data = 0)

# Joint surrogate model estimation
joint.surro.sim.MCGH &lt;- jointSurroPenal(data = data.sim, int.method = 2, 
                   nb.mc = 300, nb.gh = 20)


## End(Not run)
</code></pre>

<hr>
<h2 id='additivePenal'>Fit an Additive Frailty model using a semiparametric penalized likelihood
estimation or a parametric estimation</h2><span id='topic+additivePenal'></span>

<h3>Description</h3>


<p>Fit an additive frailty model using a semiparametric penalized likelihood
estimation or a parametric estimation. The main issue in a meta-analysis
study is how to take into account the heterogeneity between trials and
between the treatment effects across trials. Additive models are
proportional hazard model with two correlated random trial effects that act
either multiplicatively on the hazard function or in interaction with the
treatment, which allows studying for instance meta-analysis or multicentric
datasets.  Right-censored data are allowed, but not the left-truncated data.
A stratified analysis is possible (maximum number of strata = 2). This
approach is different from the shared frailty models.
</p>
<p>In an additive model, the hazard function for the j<sup>th</sup>
subject in the i<sup>th</sup> trial with random trial effect u<sub>i</sub> as
well as the random treatment-by-trial interaction v<sub>i</sub> is:
</p>
<p><img src="../help/figures/additivemodel.png" width="60%" alt="additivemodel.png" />
</p>
<p>where <code class="reqn">\lambda</code><sub>0</sub>(0) is the baseline hazard function, <code class="reqn">\beta</code><sub>k</sub> the
fixed effect associated to the covariate X<sub>ijk</sub> (k=1,..,p),
<code class="reqn">\beta</code><sub>1</sub> is the treatment effect and X<sub>ij1</sub> the treatment
variable. <code class="reqn">\rho</code> is the corresponding correlation coefficient for the two frailty terms.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>additivePenal(formula, data, correlation = FALSE, recurrentAG =
FALSE, cross.validation = FALSE, n.knots, kappa, maxit = 350, hazard =
"Splines", nb.int, LIMparam = 1e-4, LIMlogl = 1e-4, LIMderiv = 1e-3,
print.times = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="additivePenal_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a
<code class="reqn">\sim</code> operator, and the terms on the right.  The response must be a
survival object as returned by the 'Surv' function like in survival package.
The <code>slope()</code> function is required.  Interactions are possible using *
or :.</p>
</td></tr>
<tr><td><code id="additivePenal_+3A_data">data</code></td>
<td>
<p>a 'data.frame' with the variables used in 'formula'.</p>
</td></tr>
<tr><td><code id="additivePenal_+3A_correlation">correlation</code></td>
<td>
<p>Logical value. Are the random effects correlated? If so,
the correlation coefficient is estimated. The default is FALSE.</p>
</td></tr>
<tr><td><code id="additivePenal_+3A_recurrentag">recurrentAG</code></td>
<td>
<p>Always FALSE for additive models (left-truncated data are
not allowed).</p>
</td></tr>
<tr><td><code id="additivePenal_+3A_cross.validation">cross.validation</code></td>
<td>
<p>Logical value. Is cross validation procedure used
for estimating smoothing parameter in the penalized likelihood estimation?
If so a search of the smoothing parameter using cross validation is done,
with kappa as the seed.  The cross validation is not implemented for two
strata. The default is FALSE.</p>
</td></tr>
<tr><td><code id="additivePenal_+3A_n.knots">n.knots</code></td>
<td>
<p>integer giving the number of knots to use. Value required in
the penalized likelihood estimation.  It corresponds to the (n.knots+2)
splines functions for the approximation of the hazard or the survival
functions.  Number of knots must be between 4 and 20. (See Note)</p>
</td></tr>
<tr><td><code id="additivePenal_+3A_kappa">kappa</code></td>
<td>
<p>positive smoothing parameter in the penalized likelihood
estimation. In a stratified additive model, this argument must be a vector
with kappas for both strata. The coefficient kappa of the integral of the
squared second derivative of hazard function in the fit. To obtain an
initial value for <code>kappa</code>, a solution is to fit the corresponding
shared frailty model using cross validation (see cross.validation). We
advise the user to identify several possible tuning parameters, note their
defaults and look at the sensitivity of the results to varying them. Value
required. (See Note)</p>
</td></tr>
<tr><td><code id="additivePenal_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations for the Marquardtt algorithm.
Default is 350</p>
</td></tr>
<tr><td><code id="additivePenal_+3A_hazard">hazard</code></td>
<td>
<p>Type of hazard functions: &quot;Splines&quot; for semiparametric hazard
functions with the penalized likelihood estimation, &quot;Piecewise-per&quot; for
piecewise constant hazards functions using percentile, &quot;Piecewise-equi&quot; for
piecewise constant hazard functions using equidistant intervals, &quot;Weibull&quot;
for parametric Weibull functions. Default is &quot;Splines&quot;.</p>
</td></tr>
<tr><td><code id="additivePenal_+3A_nb.int">nb.int</code></td>
<td>
<p>Number of intervals (between 1 and 20) for the parametric
hazard functions (&quot;Piecewise-per&quot;, &quot;Piecewise-equi&quot;).</p>
</td></tr>
<tr><td><code id="additivePenal_+3A_limparam">LIMparam</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
parameters (see Details), <code class="reqn">10^{-4}</code> by default.</p>
</td></tr>
<tr><td><code id="additivePenal_+3A_limlogl">LIMlogl</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
log-likelihood (see Details), <code class="reqn">10^{-4}</code> by default.</p>
</td></tr>
<tr><td><code id="additivePenal_+3A_limderiv">LIMderiv</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
gradient (see Details), <code class="reqn">10^{-3}</code> by default.</p>
</td></tr>
<tr><td><code id="additivePenal_+3A_print.times">print.times</code></td>
<td>
<p>a logical parameter to print iteration process. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The estimated parameter are obtained by maximizing the penalized
log-likelihood or by a simple log-likelihood (in the parametric case) using
the robust Marquardtt algorithm (Marquardtt,1963).  The parameters are
initialized with values obtained with Cox proportional hazard model. The
iterations are stopped when the difference between two consecutive
loglikelhoods was small <code class="reqn">(&lt;10^{-4})</code>, the estimated coefficients were
stable (consecutive values <code class="reqn">(&lt;10^{-4})</code>, and the gradient small enough
<code class="reqn">(&lt;10^{-3})</code>. To be sure of having a positive function at all stages of
the algorithm, the spline coefficients were reparametrized to be positive at
each stage. The variance space of the two random effects is reduced, so the
variances are positive, and the correlation coefficient values are
constrained to be between -1 and 1.  The marginal log-likelihood depends on
integrations that are approximated by using the Laplace integration
technique with a first order approximation.  The smoothing parameter can be
fixed or estimated by maximizing likelihood cross-validation criterion. The
usual squared Wald statistic was modified to a mixture of two <code class="reqn">\chi^2</code>
distribution to get significance test for the variance of the random
effects.
</p>
<p><b>INITIAL VALUES</b>
</p>
<p>The splines and the regression coefficients are initialized to 0.1. An
adjusted Cox model is fitted, it provides new initial values for the splines
coefficients and the regression coefficients. The variances of the frailties
are initialized to 0.1. Then an additive frailty model with independent
frailties is fitted. At last, an additive frailty model with correlated
frailties is fitted.

</p>


<h3>Value</h3>

<p>An additive model or more generally an object of class
'additivePenal'.  Methods defined for 'additivePenal' objects are provided
for print, plot and summary.
</p>
<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>sequence of the corresponding estimation of the splines
coefficients, the random effects variances and the regression coefficients.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The code used for fitting the model.</p>
</td></tr> <tr><td><code>coef</code></td>
<td>
<p>the regression
coefficients.</p>
</td></tr> <tr><td><code>cov</code></td>
<td>
<p>covariance between the two frailty terms
<code class="reqn">(\bold{cov}(u_i,v_i))</code></p>
</td></tr> <tr><td><code>cross.Val</code></td>
<td>
<p>Logical value. Is cross
validation procedure used for estimating the smoothing parameters in the
penalized likelihood estimation?</p>
</td></tr> <tr><td><code>correlation</code></td>
<td>
<p>Logical value. Are the
random effects correlated?</p>
</td></tr> <tr><td><code>DoF</code></td>
<td>
<p>degrees of freedom associated with
the &quot;kappa&quot;.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula part of the code used for the model.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>the maximum number of groups used in the fit.</p>
</td></tr> <tr><td><code>kappa</code></td>
<td>
<p> A
vector with the smoothing parameters in the penalized likelihood estimation
corresponding to each baseline function as components.</p>
</td></tr>
<tr><td><code>loglikPenal</code></td>
<td>
<p>the complete marginal penalized log-likelihood in the
semiparametric case.</p>
</td></tr> <tr><td><code>loglik</code></td>
<td>
<p>the marginal log-likelihood in the
parametric case.</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>the number of observations used in the fit.</p>
</td></tr>
<tr><td><code>n.events</code></td>
<td>
<p>the number of events observed in the fit.</p>
</td></tr>
<tr><td><code>n.iter</code></td>
<td>
<p>number of iterations needed to converge.</p>
</td></tr> <tr><td><code>n.knots</code></td>
<td>
<p>number of knots for estimating the baseline functions.</p>
</td></tr>
<tr><td><code>n.strat</code></td>
<td>
<p>number of stratum.</p>
</td></tr> <tr><td><code>rho</code></td>
<td>
<p>the corresponding correlation
coefficient for the two frailty terms.</p>
</td></tr> <tr><td><code>sigma2</code></td>
<td>
<p>Variance for the
random intercept (the random effect associated to the baseline hazard
functions).</p>
</td></tr> <tr><td><code>tau2</code></td>
<td>
<p>Variance for the random slope (the random effect
associated to the treatment effect across trials).</p>
</td></tr> <tr><td><code>varH</code></td>
<td>
<p>the variance
matrix of all parameters before positivity constraint transformation
(Sigma2, Tau2, the regression coefficients and the spline coefficients).
Then after, the delta method is needed to obtain the estimated variance
parameters.</p>
</td></tr> <tr><td><code>varHIH</code></td>
<td>
<p>the robust estimation of the variance matrix of
all parameters (Sigma2, Tau2, the regression coefficients and the spline
coefficients).</p>
</td></tr> <tr><td><code>varSigma2</code></td>
<td>
<p> The variance of the estimates of
&quot;sigma2&quot;.</p>
</td></tr> <tr><td><code>varTau2</code></td>
<td>
<p> The variance of the estimates of &quot;tau2&quot;.</p>
</td></tr>
<tr><td><code>varcov</code></td>
<td>
<p> Variance of the estimates of &quot;cov&quot;.</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>matrix of times
where both survival and hazard functions are estimated. By default
seq(0,max(time),length=99), where time is the vector of survival times.</p>
</td></tr>
<tr><td><code>lam</code></td>
<td>
<p>array (dim=3) of hazard estimates and confidence bands.</p>
</td></tr>
<tr><td><code>surv</code></td>
<td>
<p>array (dim=3) of baseline survival estimates and confidence
bands.</p>
</td></tr> <tr><td><code>median</code></td>
<td>
<p>The value of the median survival and its confidence bands. If there are
two stratas or more, the first value corresponds to the value for the 
first strata, etc.</p>
</td></tr> <tr><td><code>type.of.hazard</code></td>
<td>
<p>Type of hazard functions (0:&quot;Splines&quot;,
&quot;1:Piecewise&quot;, &quot;2:Weibull&quot;).</p>
</td></tr> <tr><td><code>type.of.Piecewise</code></td>
<td>
<p>Type of Piecewise
hazard functions (1:&quot;percentile&quot;, 0:&quot;equidistant&quot;).</p>
</td></tr> <tr><td><code>nbintervR</code></td>
<td>
<p>Number
of intervals (between 1 and 20) for the parametric hazard functions
(&quot;Piecewise-per&quot;, &quot;Piecewise-equi&quot;).</p>
</td></tr> <tr><td><code>npar</code></td>
<td>
<p>number of parameters.</p>
</td></tr>
<tr><td><code>nvar</code></td>
<td>
<p>number of explanatory variables.</p>
</td></tr> <tr><td><code>noVar</code></td>
<td>
<p>indicator of
explanatory variable.</p>
</td></tr> <tr><td><code>LCV</code></td>
<td>
<p>the approximated likelihood
cross-validation criterion in the semiparametric case (with H minus the
converged Hessian matrix, and l(.) the full
log-likelihood).</p>
<p style="text-align: center;"><code class="reqn">LCV=\frac{1}{n}(trace(H^{-1}_{pl}H) - l(.))</code>
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike information Criterion for the parametric
case.</p>
<p style="text-align: center;"><code class="reqn">AIC=\frac{1}{n}(np - l(.))</code>
</p>
</td></tr> <tr><td><code>n.knots.temp</code></td>
<td>
<p>initial value
for the number of knots.</p>
</td></tr> <tr><td><code>shape.weib</code></td>
<td>
<p>shape parameter for the Weibull
hazard function.</p>
</td></tr> <tr><td><code>scale.weib</code></td>
<td>
<p>scale parameter for the Weibull hazard
function.</p>
</td></tr> <tr><td><code>martingale.res</code></td>
<td>
<p>martingale residuals for each cluster.</p>
</td></tr>
<tr><td><code>frailty.pred</code></td>
<td>
<p>empirical Bayes prediction of the first frailty term.</p>
</td></tr>
<tr><td><code>frailty.pred2</code></td>
<td>
<p>empirical Bayes prediction of the second frailty term.</p>
</td></tr>
<tr><td><code>linear.pred</code></td>
<td>
<p>linear predictor: uses simply &quot;Beta'X + u_i + v_i * X_1&quot;
in the additive Frailty models.</p>
</td></tr> <tr><td><code>global_chisq</code></td>
<td>
<p>a vector with the
values of each multivariate Wald test.</p>
</td></tr> <tr><td><code>dof_chisq</code></td>
<td>
<p>a vector with the
degree of freedom for each multivariate Wald test.</p>
</td></tr>
<tr><td><code>global_chisq.test</code></td>
<td>
<p>a binary variable equals to 0 when no multivariate
Wald is given, 1 otherwise.</p>
</td></tr> <tr><td><code>p.global_chisq</code></td>
<td>
<p>a vector with the
p_values for each global multivariate Wald test.</p>
</td></tr> <tr><td><code>names.factor</code></td>
<td>
<p>Names
of the &quot;as.factor&quot; variables.</p>
</td></tr> <tr><td><code>Xlevels</code></td>
<td>
<p>vector of the values that
factor might have taken.</p>
</td></tr> <tr><td><code>contrasts</code></td>
<td>
<p>type of contrast for factor
variable.</p>
</td></tr> <tr><td><code>beta_p.value</code></td>
<td>
<p>p-values of the Wald test for the estimated
regression coefficients.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>&quot;kappa&quot; and &quot;n.knots&quot; are the arguments that the user have to change if the
fitted model does not converge.  &quot;n.knots&quot; takes integer values between 4
and 20. But with n.knots=20, the model would take a long time to converge.
So, usually, begin first with n.knots=7, and increase it step by step until
it converges. &quot;kappa&quot; only takes positive values. So, choose a value for
kappa (for instance 10000), and if it does not converge, multiply or divide
this value by 10 or 5 until it converges.
</p>


<h3>References</h3>

<p>V. Rondeau, Y. Mazroui and J. R. Gonzalez (2012). Frailtypack:
An R package for the analysis of correlated survival data with frailty
models using penalized likelihood estimation or parametric estimation.
<em>Journal of Statistical Software</em> <b>47</b>, 1-28.
</p>
<p>V. Rondeau, S. Michiels, B. Liquet, and J. P. Pignon (2008). Investigating
trial and treatment heterogeneity in an individual patient data
meta-analysis of survival data by mean of the maximum penalized likelihood
approach. <em>Statistics in Medecine</em>, <b>27</b>, 1894-1910.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slope">slope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



###--- Additive model with 1 covariate ---###

data(dataAdditive)

modAdd &lt;- additivePenal(Surv(t1,t2,event)~cluster(group)+
var1+slope(var1),correlation=TRUE,data=dataAdditive,
n.knots=8,kappa=10000)

#-- Var1 is boolean as a treatment variable




</code></pre>

<hr>
<h2 id='bcos'>Breast Cosmesis Data</h2><span id='topic+bcos'></span>

<h3>Description</h3>

<p>The often used data set for interval-censored data, described and given in
full in Finkelstein and Wolfe (1985). It involves 94 breast cancer patients
who were randomized to either radiation therapy with chemotherapy or
radiation therapy alone. The outcome is time until the onset of breast
retraction which is interval-censored between the last clinic visit before
the event was observed and the first visit when the event was observed.
Patients without breast retraction were right-censored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bcos)
</code></pre>


<h3>Format</h3>

<p>A data frame with 94 observations and 3 variables: </p>

<dl>
<dt>left</dt><dd><p>left end point of the breast retraction interval</p>
</dd>
<dt>right</dt><dd><p>right end point of the breast retraction interval</p>
</dd>
<dt>treatment</dt><dd><p>type of treatment received</p>
</dd> </dl>



<h3>Source</h3>

<p>Finkelstein, D.M. and Wolfe, R.A. (1985). A semiparametric model for
regression analysis of interval-censored failure time data.
<em>Biometrics</em> <b>41</b>, 731-740.
</p>

<hr>
<h2 id='cluster'>Identify clusters</h2><span id='topic+cluster'></span>

<h3>Description</h3>

<p>This is a special function used in the context of the models for grouped
data. It identifies correlated groups of observations defined by using
'cluster' function, and is used of 'frailtyPenal' formula for fitting
univariate and joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_+3A_x">x</code></td>
<td>
<p>A character, factor, or numeric variable which is supposed to
indicate the variable group</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>A variable identified as a cluster </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



data(readmission)
modSha &lt;- frailtyPenal(Surv(time,event)~as.factor(dukes)+cluster(id),
n.knots=10,kappa=10000,data=readmission,hazard="Splines")

print(modSha)




</code></pre>

<hr>
<h2 id='Cmeasures'>Concordance measures in shared frailty and Cox proportional hazard models</h2><span id='topic+Cmeasures'></span><span id='topic+CbootstrapFP'></span><span id='topic+cindexes.frailty'></span><span id='topic+cindexes.W'></span><span id='topic+cindexes.B'></span><span id='topic+cindexes'></span><span id='topic+statFP'></span>

<h3>Description</h3>

<p>Compute concordance probability estimation for Cox proportional hazard or
shared frailty models in case of grouped data (Mauguen et al. 2012).
Concordance is given at different levels of comparison, taking into account
the cluster membership: between-groups, within-groups and an overall
measure, being a weighted average of the previous two. Can also compute the
c-index (Harrell et al. 1996) at these three levels. It is possible to
exclude tied pairs from concordance estimation (otherwise, account for 1/2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cmeasures(fitc, ties = 1, marginal = 0, cindex = 0, Nboot = 0, tau = 0,
data.val)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cmeasures_+3A_fitc">fitc</code></td>
<td>
<p>A frailtyPenal object, for a shared frailty model. If the fit is
a Cox model, no clustering membership is taken into account and only
marginal concordance probability estimation is provided. Only an overall
measure is given, where all patients are compared two by two. If a counting
process formulation is used to performed the fit, with 't.start' and
't.stop', the gap-times (t.stop-t.start) are used in the concordance
estimation.</p>
</td></tr>
<tr><td><code id="Cmeasures_+3A_ties">ties</code></td>
<td>
<p>Indicates if the tied pairs on prediction value must be included
(ties=1) or excluded (ties=0) from the concordance estimation. Default is
ties=1. When included, tied pairs account for 1/2 in the concordance.</p>
</td></tr>
<tr><td><code id="Cmeasures_+3A_marginal">marginal</code></td>
<td>
<p>Indicates if the concordance based on marginal predictions
must be given (marginal=1) in addition to conditional ones or not
(marginal=0). Marginal predictions do not include the frailty estimation in
the linear predictor computation: uses &quot;&lsquo;Beta&rsquo;X&quot;' instead of &quot;Beta'X + log
z_i&quot;. Default is marginal=0.</p>
</td></tr>
<tr><td><code id="Cmeasures_+3A_cindex">cindex</code></td>
<td>
<p>Indicates if the c-index (Harrell et al. 1996) must be
computed (cindex=1) in addition to the concordance probability estimation or
not (cindex=0). C-index is also given at the three comparison levels
(between, within and overall). Default is cindex=0.</p>
</td></tr>
<tr><td><code id="Cmeasures_+3A_nboot">Nboot</code></td>
<td>
<p>Number of bootstrap resamplings to compute standard-error of
the concordances measures, as well as a percentile 95% confidence interval.
Nboot=0 indicates no bootstrap procedure. Maximum admitted is 1000. Minimum
admitted is 2. Default is 0. Resampling is done at the group level. If Cox
model is used, resampling is done at individual level.</p>
</td></tr>
<tr><td><code id="Cmeasures_+3A_tau">tau</code></td>
<td>
<p>Time used to limit the interval on which the concordance is
estimated. Note that the survival function for the underlying censoring time
distribution needs to be positive at tau. If tau=0, the maximum of the
observed event times is used. Default is tau=0.</p>
</td></tr>
<tr><td><code id="Cmeasures_+3A_data.val">data.val</code></td>
<td>
<p>A dataframe. It is possible to specify a different dataset
than the one used in the model input in the argument 'fitc'. This new
dataset will be a validation population and the function will compute new
concordance measures from the parameters estimated on the development
population. In this case for conditional measures, the frailties are a
posteriori predicted. The two datasets must have the same covariates with
the same coding without missing data.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The shared frailty model evaluated.</p>
</td></tr>
<tr><td><code>Frailty</code></td>
<td>
<p>Logical value. Was model with frailties fitted.</p>
</td></tr>
<tr><td><code>frequencies</code></td>
<td>
<p>Numbers of patients, events and groups used to fit the
model.</p>
</td></tr> <tr><td><code>Npairs</code></td>
<td>
<p>Number of pairs of subjects, between-groups,
within-groups and over all the population. If cindex=1, number of comparable
(useable) pairs also available.</p>
</td></tr> <tr><td><code>Nboot</code></td>
<td>
<p>Number of bootstrap
resamplings required.</p>
</td></tr> <tr><td><code>ties</code></td>
<td>
<p>A binary, indicating if the tied pairs on
prediction were used to compute the concordance.</p>
</td></tr> <tr><td><code>CPEcond</code></td>
<td>
<p>Values of
Gonen &amp; Heller's measure (conditional). If Nboot&gt;0, give SE, the
standard-error of the parameters evaluated by bootstrap, IC.low and IC.high,
the lower and upper bounds of the percentile confidence interval evaluated
by bootstrap (2.5% and 97.5% percentiles).</p>
</td></tr> <tr><td><code>Cunocond</code></td>
<td>
<p>Values of
Uno's measure (conditional). If Nboot&gt;0, give SE, the standard-error of the
parameters evaluated by bootstrap, IC.low and IC.high, the lower and upper
bounds of the percentile confidence interval evaluated by bootstrap (2.5%
and 97.5% percentiles).</p>
</td></tr> <tr><td><code>marginal</code></td>
<td>
<p>A binary, indicating if the
marginal values were computed.</p>
</td></tr> <tr><td><code>CPEmarg</code></td>
<td>
<p>Values of Gonen &amp; Heller's
measure (marginal), if marginal=1. If Nboot&gt;0, give SE, the standard-error
of the parameters evaluated by bootstrap, IC.low and IC.high, the lower and
upper bounds of the percentile confidence interval evaluated by bootstrap
(2.5% and 97.5% percentiles).</p>
</td></tr> <tr><td><code>Cunomarg</code></td>
<td>
<p>Values of Uno's measure
(marginal), if marginal=1. If Nboot&gt;0, give SE, the standard-error of the
parameters evaluated by bootstrap, IC.low and IC.high, the lower and upper
bounds of the percentile confidence interval evaluated by bootstrap (2.5%
and 97.5% percentiles).</p>
</td></tr> <tr><td><code>cindex</code></td>
<td>
<p>A binary, indicating if the
c-indexes were computed.</p>
</td></tr>
<tr><td><code>cindexcond</code></td>
<td>
<p>Values of the C-index of Harrell (conditional). If
Nboot&gt;0, give SE, the standard-error of the parameters evaluated by
bootstrap, IC.low and IC.high, the lower and upper bounds of the percentile
confidence interval evaluated by bootstrap (2.5% and 97.5% percentiles).</p>
</td></tr>
<tr><td><code>cindexmarg</code></td>
<td>
<p>Values of the C-index of Harrell (marginal), if
marginal=1. If Nboot&gt;0, give SE, the standard-error of the parameters
evaluated by bootstrap, IC.low and IC.high, the lower and upper bounds of
the percentile confidence interval evaluated by bootstrap (2.5% and 97.5%
percentiles).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mauguen, A., Collette, S., Pignon, J. P. and Rondeau, V. (2013). Concordance
measures in shared frailty models: application to clustered data in cancer
prognosis. <em>Statistics in Medicine</em> <b>32</b>, 27, 4803-4820
</p>
<p>Harrell, F.E. et al. (1996). Tutorial in biostatistics: multivariable
prognostic models: issues in developing models, evaluating assumptions and
adequacy, and measuring and reducing errors. <em>Statistics in Medicine</em>
<b>15</b>, 361-387.
</p>
<p>Gonen, M., Heller, G. (2005). Concordance probability and discriminatory
power in proportional hazards regression. <em>Biometrika</em> <b>92</b>,
965-970.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Cmeasures">print.Cmeasures</a></code>,<code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



#-- load data
data(readmission)

#-- a frailtypenal fit
fit &lt;- frailtyPenal(Surv(time,event)~cluster(id)+dukes+
charlson+chemo,data=readmission,cross.validation=FALSE,
n.knots=10,kappa=1,hazard="Splines")

#-- a Cmeasures call
fit.Cmeasures &lt;- Cmeasures(fit)
fit.Cmeasures.noties &lt;- Cmeasures(fit, ties=0)
fit.Cmeasures.marginal &lt;- Cmeasures(fit, marginal=1)
fit.Cmeasures.cindex &lt;- Cmeasures(fit, cindex=1)

#-- a short summary
fit.Cmeasures
fit.Cmeasures.noties
fit.Cmeasures.marginal
fit.Cmeasures.cindex




</code></pre>

<hr>
<h2 id='colorectal'>Follow-up of metastatic colorectal cancer patients: times of new lesions
appearance and death</h2><span id='topic+colorectal'></span>

<h3>Description</h3>

<p>Randomly chosen 150 patients from the follow-up of the FFCD 2000-05
multicenter phase III clinical trial originally including 410 patients with
metastatic colorectal cancer randomized into two therapeutic strategies:
combination and sequential. The dataset contains times of observed
appearances of new lesions censored by a terminal event (death or
right-censoring) with baseline characteristics (treatment arm, age, WHO
performance status and previous resection).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(colorectal)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: </p>

<dl>
<dt>id</dt><dd><p>identification of each subject. Repeated for each recurrence</p>
</dd>
<dt>time0</dt><dd><p>start of interval (0 or previous recurrence time)</p>
</dd>
<dt>time1</dt><dd><p>recurrence or censoring time</p>
</dd> <dt>new.lesions</dt><dd><p>Appearance of
new lesions status. 0: censsored or no event, 1: new lesions</p>
</dd>
<dt>treatment</dt><dd><p>To which treatment arm a patient was allocated? 1:
sequential (S); 2: combination (C)</p>
</dd> <dt>age</dt><dd><p>Age at baseline: 1: &lt;50
years, 2: 50-69 years, 3: &gt;69 years</p>
</dd> <dt>who.PS</dt><dd><p>WHO performance status at
baseline: 1: status 0, 2: status 1, 3: status 2</p>
</dd>
<dt>prev.resection</dt><dd><p>Previous resection of the primate tumor?  0: No, 1:
Yes</p>
</dd> <dt>state</dt><dd><p>death indicator. 0: alive, 1: dead</p>
</dd>
<dt>gap.time</dt><dd><p>interocurrence time or censoring time</p>
</dd> </dl>



<h3>Note</h3>

<p>We thank the Federation Francophone de Cancerologie Digestive and
Gustave Roussy for sharing the data of the FFCD 2000-05 trial supported by
an unrestricted Grant from Sanofi.
</p>


<h3>References</h3>

<p>M. Ducreux, D. Malka, J. Mendiboure, P.-L. Etienne, P. Texereau,
D. Auby, P. Rougier, M. Gasmi, M. Castaing, M. Abbas, P. Michel, D. Gargot,
A. Azzedine, C. Lombard- Bohas, P. Geoffroy, B. Denis, J.-P., Pignon,
L.,Bedenne, and O.  Bouche (2011). Sequential versus combination
chemotherapy for the treatment of advanced colorectal cancer (FFCD 2000-05):
an open-label, randomised, phase 3 trial.  <em>The Lancet Oncology</em>
<b>12</b>, 1032-44.
</p>

<hr>
<h2 id='colorectalLongi'>Follow-up of metastatic colorectal cancer patients : longitudinal
measurements of tumor size</h2><span id='topic+colorectalLongi'></span>

<h3>Description</h3>

<p>Randomly chosen 150 patients from the follow-up of the FFCD 2000-05
multicenter phase III clinical trial originally including 410 patients with
metastatic colorectal cancer randomized into two therapeutic strategies:
combination and sequential. The dataset contains measurements of tumor size
(left-censored sums of the longest diameters of target lesions; transformed
using Box-Cox) with baseline characteristics(treatment arm, age, WHO
performance status and previous resection).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(colorectalLongi)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: </p>

<dl>
<dt>id</dt><dd><p>identification of each subject. Repeated for each recurrence</p>
</dd>
<dt>year</dt><dd><p>time of visit counted in years from baseline</p>
</dd>
<dt>tumor.size</dt><dd><p>Individual longitudinal measurement of transformed
(Box-Cox with parameter 0.3) sums of the longest diameters, left-censored
due to a detection limit (threshold <code class="reqn">s=-3.33</code>). </p>
</dd> <dt>treatment</dt><dd><p>To
which treatment arm a patient was allocated? 1: sequential (S); 2:
combination (C)</p>
</dd> <dt>age</dt><dd><p>Age at baseline: 1: &lt;50 years, 2: 50-69 years,
3: &gt;69 years</p>
</dd> <dt>who.PS</dt><dd><p>WHO performance status at baseline: 1: status 0,
2: status 1, 3: status 2</p>
</dd> <dt>prev.resection</dt><dd><p>Previous resection of the
primate tumor?  0: No, 1: Yes</p>
</dd> </dl>



<h3>Note</h3>

<p>We thank the Federation Francophone de Cancerologie Digestive and
Gustave Roussy for sharing the data of the FFCD 2000-05 trial supported by
an unrestricted Grant from Sanofi.
</p>


<h3>References</h3>

<p>Ducreux, M., Malka, D., Mendiboure, J., Etienne, P.-L.,
Texereau, P., Auby, D., Rougier, P., Gasmi, M., Castaing, M., Abbas, M.,
Michel, P., Gargot, D., Azzedine, A., Lombard- Bohas, C., Geoffroy, P.,
Denis, B., Pignon, J.-P., Bedenne, L., and Bouche, O. (2011). Sequential
versus combination chemotherapy for the treatment of advanced colorectal
cancer (FFCD 2000-05): an open-label, randomised, phase 3 trial.  <em>The
Lancet Oncology</em> <b>12</b>, 1032-44.
</p>

<hr>
<h2 id='dataAdditive'>Simulated data as a gathering of clinical trials databases</h2><span id='topic+dataAdditive'></span>

<h3>Description</h3>

<p>This contains simulated samples of 100 clusters with 100 subjects in each
cluster, like a gathering of clinical trials databases. Two correlated
centred gaussian random effects are generated with the same variance fixed
at 0.3 and the covariance at -0.2. The regression coefficient <code class="reqn">\beta</code> is
fixed at -0.11. The percentage of right-censored data is around 30 percent
which are generated from a uniform distribution on [1,150]. The baseline
hazard function is considered as a simple Weibull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataAdditive)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: </p>

<dl>
<dt>group</dt><dd><p>identification variable</p>
</dd> <dt>t1</dt><dd><p>start of interval (=0,
because left-truncated data are not allowed)</p>
</dd> <dt>t2</dt><dd><p>end of interval
(death or censoring time)</p>
</dd> <dt>event</dt><dd><p>censoring status (0:alive, 1:death,
as acensoring indicator</p>
</dd> <dt>var1</dt><dd><p>dichotomous covariate (=0 or 1,as a
treatment variable)</p>
</dd> <dt>var2</dt><dd><p>dichotomous covariate (=0 or 1,as a
treatment variable)</p>
</dd> </dl>



<h3>Source</h3>

<p>V. Rondeau, S. Michiels, B.Liquet, and J.P. Pignon (2008). Investigating
trial and treatment heterogeneity in an individual patient data
meta-analysis of survival data by mean of the maximum penalized likelihood
approach. <em>Statistics in Medecine</em>, <b>27</b>, 1894-1910.
</p>

<hr>
<h2 id='dataMultiv'>Simulated data for two types of recurrent events and a terminal event</h2><span id='topic+dataMultiv'></span>

<h3>Description</h3>

<p>This contains a simulated sample of of 800 subjects and 1652 observations.
This dataset can be used to illustrate how to fit a joint multivariate
frailty model. Two gaussian correlated random effects were generated with
mean 0, variances 0.5 and a correlation coefficient equals to 0.5. The
coefficients <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code> were fixed to 1. The three
baseline hazard functions followed a Weibull distribution and right
censoring was fixed at 5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataMultiv)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: </p>

<dl>
<dt>PATIENT</dt><dd><p>identification of patient</p>
</dd> <dt>obs</dt><dd><p>number of observation
for a patient</p>
</dd> <dt>TIME0</dt><dd><p>start of interval</p>
</dd> <dt>TIME1</dt><dd><p>end of interval
(death or censoring time)</p>
</dd> <dt>INDICREC</dt><dd><p>recurrent of type 1 status (0:no,
1:yes)</p>
</dd> <dt>INDICMETA</dt><dd><p>recurrent of type 2 status (0:no, 1:yes)</p>
</dd>
<dt>INDICDEATH</dt><dd><p>censoring status (0:alive, 1:death)</p>
</dd> <dt>v1</dt><dd><p>dichotomous
covariate (0,1)</p>
</dd> <dt>v2</dt><dd><p>dichotomous covariate (0,1)</p>
</dd>
<dt>v3</dt><dd><p>dichotomous covariate (0,1)</p>
</dd> <dt>TIMEGAP</dt><dd><p>time to event</p>
</dd> </dl>


<hr>
<h2 id='dataNCC'>Simulated data for recurrent events and a terminal event with weigths using
nested case-control design</h2><span id='topic+dataNCC'></span>

<h3>Description</h3>

<p>This contains a simulated sample of of 819 subjects and 1510 observations.
This dataset can be used to illustrate how to fit a joint frailty model for
data from nested case-control studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataNCC)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: </p>

<dl>
<dt>id</dt><dd><p>identification of patient</p>
</dd> <dt>cov1</dt><dd><p>dichotomous covariate
(0,1)</p>
</dd> <dt>cov2</dt><dd><p>dichotomous covariate (0,1)</p>
</dd> <dt>t.start</dt><dd><p>start of
interval</p>
</dd> <dt>t.stop</dt><dd><p>end of interval (death or censoring time)</p>
</dd>
<dt>gaptime</dt><dd><p>time to event</p>
</dd> <dt>event</dt><dd><p>recurrent event status (0:no,
1:yes)</p>
</dd> <dt>deathdays</dt><dd><p>time of terminal event (death or right-censoring)</p>
</dd>
<dt>death</dt><dd><p>censoring status (0:alive, 1:death)</p>
</dd> <dt>ncc.wts</dt><dd><p>weights for
NCC design</p>
</dd> </dl>


<hr>
<h2 id='dataNested'>Simulated data with two levels of grouping</h2><span id='topic+dataNested'></span>

<h3>Description</h3>

<p>This contains a simulated sample of 400 observations which allow
establishing 20 clusters with 4 subgroups and 5 subjects in each subgroup,
in order to obtain two levels of grouping. This data set is useful to
illustrate how to fit a nested model. Two independent gamma frailty
parameters with a variance fixed at 0.1 for the cluster effect and at 0.5
for the subcluster effect were generated. Independent survival times were
generated from a simple Weibull baseline risk function. The percentage of
censoring data was around 30 per cent. The right-censoring variables were
generated from a uniform distribution on [1,36] and a left-truncating
variable was generated with a uniform distribution on [0,10]. Observations
were included only if the survival time is greater than the truncated time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataNested)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: </p>

<dl>
<dt>group</dt><dd><p>group identification variable</p>
</dd> <dt>subgroup</dt><dd><p>subgroup
identification variable</p>
</dd> <dt>t1</dt><dd><p>start of interval (0 or truncated time)</p>
</dd>
<dt>t2</dt><dd><p>end of interval (death or censoring time)</p>
</dd> <dt>event</dt><dd><p>censoring
status (0: alive, 1: death)</p>
</dd> <dt>cov1</dt><dd><p>dichotomous covariate (0,1)</p>
</dd>
<dt>cov2</dt><dd><p>dichotomous covariate (0,1)</p>
</dd> </dl>



<h3>Source</h3>

<p>V. Rondeau, L. Filleul, P. Joly (2006). Nested frailty models using maximum
penalized likelihood estimation. <em>Statistics in Medecine</em>, <b>25</b>,
4036-4052.
</p>

<hr>
<h2 id='dataOvarian'>Advanced Ovarian Cancer dataset</h2><span id='topic+dataOvarian'></span>

<h3>Description</h3>

<p>This dataset combines the data  that were collected in four double-blind randomized
clinical trials in advanced ovarian cancer. In these trials, the objective was to 
examine the efficacy of cyclophosphamide plus cisplatin (CP) versus cyclophosphamide 
plus adriamycin plus cisplatin (CAP) to treat advanced ovarian cancer. The candidate 
surrogate endpoint <b>S</b> is progression-free survival time, defined as the time (in years)
from randomization to clinical progression of the disease or death. The true endpoint
<b>T</b> is survival time, defined as the time (in years) from randomization to death of any 
cause
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataOvarian)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: 
</p>

<dl>
<dt>patientID</dt><dd><p>The identification number of a patient</p>
</dd> 
<dt>trialID</dt><dd><p>The center in which a patient was treated</p>
</dd>
<dt>trt</dt><dd><p>The treatment indicator, coded as 0 = cyclophosphamide plus cisplatin (CP)
and 1 = cyclophosphamide plus adriamycin plus cisplatin(CAP)</p>
</dd>
<dt>timeS</dt><dd><p>The candidate surrogate (progression-free survival)</p>
</dd>
<dt>statusS</dt><dd><p>Censoring indicator for for Progression-free survival</p>
</dd>
<dt>timeT</dt><dd><p>The true endpoint (survival time)</p>
</dd>
<dt>statusT</dt><dd><p>Censoring indicator for survival time</p>
</dd>
</dl>



<h3>Source</h3>

<p>Ovarian cancer Meta-Analysis Project (1991). Cyclophosphamide plus cisplatin plus adriamycin
versus Cyclophosphamide, doxorubicin, and cisplatin chemotherapy of ovarian carcinoma: 
A meta-analysis. <em>Classic Papers and Current Comments</em>, <b>3</b>, 237-234.
</p>

<hr>
<h2 id='Diffepoce'>Difference of Expected Prognostic Observed Cross-Entropy (EPOCE) estimators
and its 95% tracking interval between two joint models.</h2><span id='topic+Diffepoce'></span>

<h3>Description</h3>

<p>This function computes the difference of two EPOCE estimates (CVPOL and
MPOL) and its 95% tracking interval between two joint models estimated
using <code>frailtyPenal</code>, <code>longiPenal</code> or <code>trivPenal</code>. Difference
in CVPOL is computed when the EPOCE was previously estimated on the same
dataset as used for estimation (using an approximated cross-validation), and
difference in MPOL is computed when the EPOCE was previously estimated on an
external dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Diffepoce(epoce1, epoce2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Diffepoce_+3A_epoce1">epoce1</code></td>
<td>
<p>a first object inheriting from class epoce.</p>
</td></tr>
<tr><td><code id="Diffepoce_+3A_epoce2">epoce2</code></td>
<td>
<p>a second object inheriting from class epoce.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From the EPOCE estimates and the individual contributions to the prognostic
observed log-likelihood obtained with <code>epoce</code> function on the same
dataset from two different estimated joint models, the difference of CVPOL
(or MPOL) and its 95% tracking interval is computed. The 95% tracking
interval is : Delta(MPOL) +/- qnorm(0.975)*sqrt(VARIANCE) for an external
dataset Delta(CVPOL) +/- qnorm(0.975)*sqrt(VARIANCE) for the dataset used in
<code>frailtyPenal</code>, <code>longiPenal</code> or <code>trivPenal</code> where
Delta(CVPOL) (or Delta(MPOL)) is the difference of CVPOL (or MPOL) of the
two joint models, and VARIANCE is the empirical variance of the difference
of individuals contributions to the prognostic observed log-likelihoods of
the two joint models.
</p>
<p>The estimators of EPOCE from arguments epoce1 and epoce2 must have been
computed on the same dataset and with the pred.times.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>new.data</code></td>
<td>
<p>a boolean which is FALSE if computation is done on
the same data as for estimation, and TRUE otherwise</p>
</td></tr> <tr><td><code>pred.times</code></td>
<td>
<p>time
or vector of times used in the function</p>
</td></tr> <tr><td><code>DEPOCE</code></td>
<td>
<p>the difference
between the two MPOL or CVPOL for each time</p>
</td></tr> <tr><td><code>TIinf</code></td>
<td>
<p>lower confidence
band for the difference</p>
</td></tr> <tr><td><code>TIsup</code></td>
<td>
<p>upper confidence band for the
difference</p>
</td></tr>
</table>


<h3>References</h3>

<p>D. Commenges, B. Liquet, C. Proust-Lima (2012). Choice of
prognostic estimators in joint models by estimating differences of expected
conditional Kullback-Leibler risks. <em>Biometrics</em>, <b>68(2)</b>,
380-387.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

#Example for joint frailty models
data(readmission)

# first joint frailty model
joint1 &lt;- frailtyPenal(Surv(t.start,t.stop,event)~ cluster(id) +
  dukes + charlson + sex + chemo + terminal(death),
  formula.terminalEvent = ~ dukes + charlson + sex + chemo ,
  data = readmission, n.knots = 8, kappa = c(2.11e+08,9.53e+11),
  recurrentAG=TRUE)

# second joint frailty model without dukes nor charlson as covariates
joint2 &lt;- frailtyPenal(Surv(t.start,t.stop,event)~ cluster(id) +
  sex + chemo + terminal(death),
  formula.terminalEvent = ~ sex + chemo ,
  data = readmission, n.knots = 8, kappa = c(2.11e+08,9.53e+11),
  recurrentAG=TRUE)

temps &lt;- c(200,500,800,1100)

# computation of estimators of EPOCE for the two models
epoce1 &lt;- epoce(joint1,temps)
epoce2 &lt;- epoce(joint2,temps)

# computation of the difference
diff &lt;- Diffepoce(epoce1,epoce2)

print(diff)
plot(diff)


#Example for joint models with a biomarker
data(colorectal)
data(colorectalLongi)

# Survival data preparation - only terminal events 
colorectalSurv &lt;- subset(colorectal, new.lesions == 0)

# first joint model for a biomarker and a terminal event
modLongi &lt;- longiPenal(Surv(time0, time1, state) ~ age +
treatment + who.PS, tumor.size ~  year*treatment + age +
who.PS, colorectalSurv, data.Longi =colorectalLongi,
random = c("1", "year"),  id = "id", link = "Random-effects", 
left.censoring = -3.33, hazard = "Weibull", 
method.GH = "Pseudo-adaptive")

# second joint model for a biomarker, recurrent events and a terminal event
# (computation takes around 30 minutes)
modTriv &lt;- model.weib.RE.gap &lt;-trivPenal(Surv(gap.time, new.lesions) 
~ cluster(id) + age + treatment + who.PS + prev.resection + terminal(state),
formula.terminalEvent =~ age + treatment + who.PS + prev.resection, 
tumor.size ~ year * treatment + age + who.PS, data = colorectal,
data.Longi = colorectalLongi, random = c("1", "year"), id = "id", 
link = "Random-effects", left.censoring = -3.33, recurrentAG = FALSE,
hazard = "Weibull", method.GH="Pseudo-adaptive", n.nodes=7)

time &lt;- c(1, 1.5, 2, 2.5)

# computation of estimators of EPOCE for the two models
epoce1 &lt;- epoce(modLongi, time)
# (computation takes around 10 minutes)
epoce2 &lt;- epoce(modTriv, time)


# computation of the difference
diff &lt;- Diffepoce(epoce1, epoce2)

print(diff)
plot(diff)

## End(Not run)


</code></pre>

<hr>
<h2 id='epoce'>Estimators of the Expected Prognostic Observed Cross-Entropy (EPOCE) for
evaluating predictive accuracy of joint models.</h2><span id='topic+epoce'></span>

<h3>Description</h3>

<p>This function computes estimators of the Expected Prognostic Observed
Cross-Entropy (EPOCE) for evaluating the predictive accuracy of joint models
using <code>frailtyPenal</code>, <code>longiPenal</code>, <code>trivPenal</code> or
<code>trivPenalNL</code>. On the same data as used for estimation of the joint
model, this function computes both the Mean Prognosis Observed Loss (MPOL)
and the Cross-Validated Prognosis Observed Loss (CVPOL), two estimators of
EPOCE. The latter corrects the MPOL estimate for over-optimism by
approximated cross-validation. On external, this function only computes
MPOL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epoce(fit, pred.times, newdata = NULL, newdata.Longi = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="epoce_+3A_fit">fit</code></td>
<td>
<p>A jointPenal, longiPenal, trivPenal or trivPenalNL object.</p>
</td></tr>
<tr><td><code id="epoce_+3A_pred.times">pred.times</code></td>
<td>
<p>Time or vector of times to compute epoce.</p>
</td></tr>
<tr><td><code id="epoce_+3A_newdata">newdata</code></td>
<td>
<p>Optional. In case of joint models obtained with
<code>frailtyPenal</code>, <code>trivPenal</code> or <code>trivPenalNL</code>. For models
inheriting from <code>trivPenal</code> or <code>trivPenalNL</code> class, if
<code>newdata</code> is given, <code>newdata.Longi</code> must be given as well.  When
missing, the data used for estimating the fit are used, and CVPOL and MPOL
are computed (internal validation). When <code>newdata</code> is specified, only
MPOL is computed on this new dataset (external validation). The new dataset
and the dataset used in the estimation must have the same covariates with
the same coding without missing data.</p>
</td></tr>
<tr><td><code id="epoce_+3A_newdata.longi">newdata.Longi</code></td>
<td>
<p>Optional. In case of joint models obtained with
<code>longiPenal</code>, <code>trivPenal</code> or <code>trivPenalNL</code>. For models
inheriting from <code>longiPenal</code>, if the <code>newdata.Longi</code> is given,
<code>newdata</code> must be <code>NULL</code>, but for models from <code>trivPenal</code> or
<code>trivPenalNL</code> class, if <code>newdata.Longi</code> is given, <code>newdata</code>
must be provided as well. The two datasets newdata and newdata.Longi must
include the information concerning the same patients with the same
characteristics and the appropriate data on follow up (recurrences for
<code>newdata</code> and longitudinal measurements for <code>newdata.Longi</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>name of the data used to compute epoce</p>
</td></tr>
<tr><td><code>new.data</code></td>
<td>
<p>a boolean which is FALSE if computation is done on the same
data as for estimation, and TRUE otherwise</p>
</td></tr> <tr><td><code>pred.times</code></td>
<td>
<p>time or vector
of times used in the function</p>
</td></tr> <tr><td><code>mpol</code></td>
<td>
<p>values of MPOL for each
pred.times</p>
</td></tr> <tr><td><code>cvpol</code></td>
<td>
<p>values of CVPOL for each pred.times</p>
</td></tr>
<tr><td><code>IndivContrib</code></td>
<td>
<p>all the contributions to the log-likelihood for each
pred.times</p>
</td></tr> <tr><td><code>AtRisk</code></td>
<td>
<p>number of subject still at risk for each
pred.times</p>
</td></tr>
</table>


<h3>References</h3>

<p>D. Commenges, B. Liquet, C. Proust-Lima (2012). Choice of
prognostic estimators in joint models by estimating differences of expected
conditional Kullback-Leibler risks. <em>Biometrics</em>, <b>68(2)</b>,
380-387.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

########################################
#### EPOCE on a joint frailty model ####
########################################

data(readmission)

modJoint.gap &lt;- frailtyPenal(Surv(t.start,t.stop,event)~ cluster(id) +
  dukes + charlson + sex + chemo + terminal(death),
  formula.terminalEvent = ~ dukes + charlson + sex + chemo ,
  data = readmission, n.knots = 8, kappa =c(2.11e+08,9.53e+11),
  recurrentAG=TRUE)

# computation on the same dataset
temps &lt;- c(200,500,800,1100)
epoce &lt;- epoce(modJoint.gap,temps)

print(epoce)
plot(epoce,type = "cvpol")

# computation on a new dataset
# here a sample of readmission with the first 50 subjects
s &lt;- readmission[1:100,]
epoce &lt;- epoce(modJoint.gap,temps,newdata=s)

print(epoce)
plot(epoce,type = "mpol")

#################################################
#### EPOCE on a joint  model for a biomarker ####
#########   and a terminal event  ###############
#################################################

data(colorectal)
data(colorectalLongi)

# Survival data preparation - only terminal events 
colorectalSurv &lt;- subset(colorectal, new.lesions == 0)

modLongi &lt;- longiPenal(Surv(time0, time1, state) ~ age +
treatment + who.PS, tumor.size ~  year*treatment + age +
who.PS, colorectalSurv, data.Longi =colorectalLongi,
random = c("1", "year"),  id = "id", link = "Random-effects", 
left.censoring = -3.33, hazard = "Weibull", 
method.GH = "Pseudo-adaptive")

# computation on the same dataset
time &lt;- c(1, 1.5, 2, 2.5)
epoce &lt;- epoce(modLongi,time)

print(epoce)
plot(epoce, type = "cvpol")

# computation on a new dataset
# here a sample of colorectal data with the first 50 subjects
s &lt;-  subset(colorectal, new.lesions == 0 &amp; id%in%1:50)
s.Longi &lt;- subset(colorectalLongi, id%in%1:50)
epoce &lt;- epoce(modLongi, time, newdata = s, newdata.Longi = s.Longi)

print(epoce)
plot(epoce, type = "mpol")


###################################################
#### EPOCE on a joint model for a biomarker, ######
#### recurrent events and a terminal event   ######
###################################################

data(colorectal)
data(colorectalLongi)

# Linear model for the biomarker
# (computation takes around 30 minutes)
model.trivPenalNL &lt;-trivPenal(Surv(gap.time, new.lesions) ~ cluster(id)
+ age + treatment + who.PS + prev.resection + terminal(state),
formula.terminalEvent =~ age + treatment + who.PS + prev.resection, 
tumor.size ~ year * treatment + age + who.PS, data = colorectal,
data.Longi = colorectalLongi, random = c("1", "year"), id = "id", 
link = "Random-effects", left.censoring = -3.33, recurrentAG = FALSE,
hazard = "Weibull", method.GH="Pseudo-adaptive", n.nodes=7)

# computation on the same dataset
time &lt;- c(1, 1.5, 2, 2.5)

# (computation takes around 10 minutes)
epoce &lt;- epoce(model.trivPenalNL,time)
print(epoce)
plot(epoce, type = "cvpol")

# computation on a new dataset
# here a sample of colorectal data with the first 100 subjects
s &lt;-  subset(colorectal,  id%in%1:100)
s.Longi &lt;- subset(colorectalLongi, id%in%1:100)
# (computation takes around 10 minutes)
epoce &lt;- epoce(model.trivPenalNL, time, newdata = s, newdata.Longi = s.Longi)

print(epoce)
plot(epoce, type = "mpol")



# Non-linear model for the biomarker

# No information on dose - creation of a dummy variable 
colorectalLongi$dose &lt;- 1

# (computation can take around 40 minutes)
model.trivPenalNL &lt;- trivPenalNL(Surv(time0, time1, new.lesions) ~ cluster(id) + age + treatment
 + terminal(state), formula.terminalEvent =~ age + treatment, biomarker = "tumor.size",
 formula.KG ~ 1, formula.KD ~ treatment, dose = "dose", time.biomarker = "year", 
 data = colorectal, data.Longi =colorectalLongi, random = c("y0", "KG"), id = "id", 
 init.B = c(-0.22, -0.16, -0.35, -0.19, 0.04, -0.41, 0.23), init.Alpha = 1.86,
 init.Eta = c(0.5, 0.57, 0.5, 2.34), init.Biomarker = c(1.24, 0.81, 1.07, -1.53),
 recurrentAG = TRUE, n.knots = 5, kappa = c(0.01, 2), method.GH = "Pseudo-adaptive")

# computation on the same dataset
time &lt;- c(1, 1.5, 2, 2.5)

epoce &lt;- epoce(model.trivPenalNL, time)



## End(Not run)


</code></pre>

<hr>
<h2 id='event2'>Identify event2 indicator</h2><span id='topic+event2'></span>

<h3>Description</h3>

<p>This is a special function used in the context of multivariate frailty model
with two types of recurrent events and a terminal event (e.g., censoring
variable related to both recurrent events). It contains the indicator of the
recurrent event of type 2, normally 0=no event, 1=event, and is used on the
right hand side of a formula of a 'multivPenal' object.  Using
<code>event2()</code> in a formula implies that a multivariate frailty model for
two types of recurrent events and a terminal event is fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="event2_+3A_x">x</code></td>
<td>
<p>A numeric variable but should be a boolean which equals 1 if the
subject has experienced an event of type 2 and 0 if not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>an indicator for an event of type 2</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+multivPenal">multivPenal</a></code>
</p>

<hr>
<h2 id='frailtyDesign'>Sample Size calculation and Power Analysis using Gamma-Frailty Models</h2><span id='topic+frailtyDesign'></span><span id='topic+SFM.power'></span><span id='topic+SFM.ssize'></span><span id='topic+NFM.power'></span><span id='topic+NFM.ssize'></span><span id='topic+JFM.power'></span><span id='topic+JFM.ssize'></span><span id='topic+GJFM.power'></span><span id='topic+GJFM.ssize'></span>

<h3>Description</h3>


<p>A collection of functions to calculate statistical power and required
sample sizes for survival analysis using frailty models, specifically
the Shared Frailty Model (SFM), Nested Frailty Model (NFM), Joint
Frailty Model (JFM), and General Joint Frailty Model (GJFM).
</p>
<p>For each frailty model type (denoted by <code>*</code>, where <code>*</code> corresponds to
SFM, NFM, JFM or GJFM), the package provides two distinct functions:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;*.power&#8288;</code>: Computes the statistical power under given study settings.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;*.ssize&#8288;</code>: Determines the required sample size needed to achieve
a specified target power under given study settings.
</p>
</li></ul>




<h3>Usage</h3>

<pre><code class='language-R'>######################################################
## 1. SHARED FRAILTY MODEL (SFM)
######################################################

# Compute power for a given sample size in a SFM
# --------------------------------------------------
SFM.power(
  Groups = 80, ni = 8, ni.type = "max", Acc.Dur = 0,FUP = 12,
  FUP.type = "UpToEnd", median.H0 = 1, beta.H0 = 0, beta.HA = log(0.75),
  shape.W = 1, theta = 0.25, ratio = 1, samples.mc = 1e4, seed = 42,
  timescale = "gap", data.type = "grouped",
  cens.par = 5, cens.type = "Expo", statistic = "Wald",
  typeIerror = 0.05, test.type = "2-sided"
)

# Compute sample size for a given power in a SFM
# --------------------------------------------------
SFM.ssize(
  power = 0.8, ni = 8, ni.type = "max", Acc.Dur = 0,FUP = 12,
  FUP.type = "UpToEnd", median.H0 = 1, beta.H0 = 0, beta.HA = log(0.75),
  shape.W = 1, theta = 0.25, ratio = 1, samples.mc = 1e4, seed = 42,
  timescale = "gap", data.type = "grouped",
  cens.par = 5, cens.type = "Expo", statistic = "Wald",
  typeIerror = 0.05, test.type = "2-sided"
)

######################################################
## 2. NESTED FRAILTY MODEL (NFM)
######################################################

# Compute power for a given sample size in a NFM
# --------------------------------------------------
NFM.power(
  Groups = 80, ni = 8, ni.type = "max", kij = 15, kij.type = "max",
  Acc.Dur = 0, FUP = 12, FUP.type = "UpToEnd", median.H0 = 1,
  beta.H0 = 0, beta.HA = log(0.75), shape.W = 1, theta = 0.25, eta = 0.5,
  ratio = 1, samples.mc = 1e4, seed = 42,
  timescale = "gap", data.type = "grouped", cens.par = 5, cens.type = "Expo",
  statistic = "Wald", typeIerror = 0.05, test.type = "2-sided"
)

# Compute sample size for a given power in a NFM
# --------------------------------------------------
NFM.ssize(
  power = 0.8, ni = 8, ni.type = "max", kij = 15, kij.type = "max",
  Acc.Dur = 0, FUP = 12, FUP.type = "UpToEnd", median.H0 = 1,
  beta.H0 = 0, beta.HA = log(0.75), shape.W = 1, theta = 0.25, eta = 0.5,
  ratio = 1, samples.mc = 1e4, seed = 42,
  timescale = "gap", data.type = "grouped", cens.par = 5, cens.type = "Expo",
  statistic = "Wald", typeIerror = 0.05, test.type = "2-sided"
)

######################################################
## 3. JOINT FRAILTY MODEL (JFM)
######################################################

# Compute power for a given sample size in a JFM
# --------------------------------------------------
JFM.power(
  Npts = 400, ni = 8, ni.type = "max", Acc.Dur = 0, FUP = 12,
  FUP.type = "UpToEnd", medianR.H0 = 3, medianD.H0 = 10, betaTest.type = "joint",
  betaR.H0 = 0, betaR.HA = log(0.75), betaD.H0 = 0, betaD.HA = log(0.85),
  shapeR.W = 1, shapeD.W = 1, theta = 0.25, alpha = 1, ratio = 1,
  samples.mc = 1e4, seed = 42, timescale = "gap",
  statistic = "Wald", typeIerror = 0.05, test.type = "2-sided"
)

# Compute sample size for a given power in a JFM
# --------------------------------------------------
JFM.ssize(
  power = 0.8, ni = 8, ni.type = "max", Acc.Dur = 0, FUP = 12,
  FUP.type = "UpToEnd", medianR.H0 = 3, medianD.H0 = 10, betaTest.type = "joint",
  betaR.H0 = 0, betaR.HA = log(0.75), betaD.H0 = 0, betaD.HA = log(0.85),
  shapeR.W = 1, shapeD.W = 1, theta = 0.25, alpha = 1, ratio = 1,
  samples.mc = 1e4, seed = 42, timescale = "gap",
  statistic = "Wald", typeIerror = 0.05, test.type = "2-sided"
)

######################################################
## 4. GENERAL JOINT FRAILTY MODEL (GJFM)
######################################################

# Compute power for a given sample size in a GJFM
# --------------------------------------------------
GJFM.power(
  Npts = 400, ni = 8, ni.type = "max", Acc.Dur = 0, FUP = 12,
  FUP.type = "UpToEnd", medianR.H0 = 3, medianD.H0 = 10,
  betaTest.type = "joint", betaR.H0 = 0, betaR.HA = log(0.75),
  betaD.H0 = 0, betaD.HA = log(0.85), shapeR.W = 1, shapeD.W = 1,
  theta = 0.25, eta = 0.5, ratio = 1, samples.mc = 1e4,
  seed = 42, timescale = "gap",
  statistic = "Wald", typeIerror = 0.05, test.type = "2-sided"
)

# Compute sample size for a given power in a GJFM
# --------------------------------------------------
GJFM.ssize(
  power = 0.8, ni = 8, ni.type = "max", Acc.Dur = 0, FUP = 12,
  FUP.type = "UpToEnd", medianR.H0 = 3, medianD.H0 = 10,
  betaTest.type = "joint", betaR.H0 = 0, betaR.HA = log(0.75),
  betaD.H0 = 0, betaD.HA = log(0.85), shapeR.W = 1, shapeD.W = 1,
  theta = 0.25, eta = 0.5, ratio = 1, samples.mc = 1e4,
  seed = 42, timescale = "gap",
  statistic = "Wald", typeIerror = 0.05, test.type = "2-sided"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frailtyDesign_+3A_groups">Groups</code></td>
<td>
<p>Only in SFM and NFM: A numeric value, where interpretation
depends on the <code>data.type</code> parameter and on the model:
</p>

<ul>
<li><p> For SFM, it corresponds to either the number of groups (grouped data)
or the number of subjects (recurrent events data).
</p>
</li>
<li><p> For NFM, it corresponds to either the number of groups (grouped and
recurrent event data) or the number of subjects (multi-type recurrent
events data).
</p>
</li></ul>

<p>Default is 80.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_ni">ni</code></td>
<td>
<p>A numeric value or an array (dim = 2), representing
expected values or distribution parameters. Interpretation depends on
the <code>data.type</code> parameter and on the model:
</p>

<ul>
<li><p> For SFM, it corresponds to either the expected number of subjects per group (grouped data)
or the expected number of recurrent events per subject (recurrent events data).
</p>
</li>
<li><p> For NFM, it corresponds to the expected number of subgroups within each group (grouped data),
the expected number of recurrent events per group (recurrent event data), or the number of
distinct recurrent event type (multi-type recurrent event data).
</p>
</li>
<li><p> For JFM/GJFM, it corresponds to the expected number of recurrent events per subject.
</p>
</li></ul>

<p>The default value is 8.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_ni.type">ni.type</code></td>
<td>
<p>Character value, specifying <code>ni</code>. Valid options:
</p>

<ul>
<li> <p><code>"max"</code>: <code>ni</code> is a fixed number.
</p>
</li>
<li> <p><code>"pois"</code>: <code>ni</code> is a mean (parameter of a Poisson distribution).
</p>
</li>
<li> <p><code>"unif"</code>: <code>ni</code> is the lower and upper bound parameters of a uniform distribution.
</p>
</li></ul>

<p>Options <code>"pois"</code> and <code>"unif"</code> can only be selected for recurrent event data; see Note for details.
Default is <code>"max"</code>.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_acc.dur">Acc.Dur</code></td>
<td>
<p>Non-negative numeric value. Parameter for a uniform accrual
from time 0 to time <code>Acc.Dur</code>. Default is 0.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_fup">FUP</code></td>
<td>
<p>A positive numeric value of follow-up duration as defined in the
study protocol (i.e. administrative censoring). Default is 12.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_fup.type">FUP.type</code></td>
<td>
<p>Character value, indicating the type of follow-up. Valid options:
</p>

<ul>
<li> <p><code>"Fixed"</code>: each subject is followed exactly for <code>FUP</code> time units after enrollment.
</p>
</li>
<li> <p><code>"UptoEnd"</code>: global study cutoff at time <code>FUP</code>; individual follow-up for at most <code>FUP</code>.
</p>
</li></ul>

<p>Default is <code>"Fixed"</code>.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_median.h0">median.H0</code></td>
<td>
<p>Only in SFM and NFM: A positive numeric value, used for the scale parameter (Weibull) calculation.
If recurrent event data, it is the median gap time to event under the null (excluding censoring times).
If grouped data, it is the median time to an event under the null (excluding censoring times).
Default is 1.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_beta.h0">beta.H0</code></td>
<td>
<p>Only in SFM and NFM: log-hazard ratio parameter under the null
hypothesis (H0). Default is 0.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_beta.ha">beta.HA</code></td>
<td>
<p>Only in SFM and NFM: log-hazard ratio parameter under the
alternative hypothesis (HA). Default is log(0.75).</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_shape.w">shape.W</code></td>
<td>
<p>Only in SFM and NFM: A positive numeric value, corresponding to
the shape parameter (Weibull) of the baseline hazard of the recurrent event. Default is 1.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_theta">theta</code></td>
<td>
<p>A positive numeric value, corresponding to the Gamma-frailty
variance for the main random effect. Default is 0.25.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_ratio">ratio</code></td>
<td>
<p>A positive numeric value, corresponding to the allocation ratio
(<em>experimental : control</em>). Default is 1.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_samples.mc">samples.mc</code></td>
<td>
<p>A positive numeric value, corresponding to the number of
Monte Carlo samples used to approximate the Fisher information matrix.
Default is 1e4.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_seed">seed</code></td>
<td>
<p>Integer number for random-number generation seed. Ensures reproducibility
of the Monte-Carlo simulations. Default is 42.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_timescale">timescale</code></td>
<td>
<p>Character value indicating the timescale when recurrent event data type
is considered. Can be either 'gap' or 'calendar'. See note for more detail. Default is 'gap'.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_data.type">data.type</code></td>
<td>
<p>Only in SFM and NFM: Character value indicating what kind of data we
want to consider for the current frailty model. Valid options differ depending on the model:
</p>

<ul>
<li><p> For SFM, can be either <code>"grouped"</code> (corresponding to subjects included in a group)
or <code>"rec_event"</code> (corresponding to subjects experiencing recurrent events).
</p>
</li>
<li><p> For NFM, the hierarchical structure of the data can be either <code>"grouped"</code>
(where subjects are included into subgroup and subgroups into groups),
<code>"rec_event1"</code> (where the group level corresponds to a group (e.g., hospitals)
and subgroup level to a subject) or <code>"rec_event2"</code> (where the group
level corresponds to a subject and subgroup level to a type of recurrent event).
</p>
</li></ul>

<p>Default is &quot;grouped&quot;.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_cens.par">cens.par</code></td>
<td>
<p>Only in SFM and NFM: A numeric value corresponding
to the parameter of the distribution for non-administrative censoring.
Default is 10000.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_cens.type">cens.type</code></td>
<td>
<p>Only in SFM and NFM: Character value, specifying
the distribution for non-administrative censoring. Valid options:
</p>

<ul>
<li> <p><code>"Expo"</code>: in this case, <code>cens.par</code> is the median
from an exponential distribution.
</p>
</li>
<li> <p><code>"Unif"</code>: in this case, <code>cens.par</code> is the lower and upper
bound parameters of a uniform distribution.
</p>
</li></ul>

<p>Default is &quot;Expo&quot;.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_statistic">statistic</code></td>
<td>
<p>Type of test statistic used. Currently, only <code>"Wald"</code> is available.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_typeierror">typeIerror</code></td>
<td>
<p>A numeric value corresponding to the type I error level. Default is 0.05.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_test.type">test.type</code></td>
<td>
<p>Character value indicating whether It is a one-tailed or two-tailed test.
Valid options are either <code>"1-sided"</code> or <code>"2-sided"</code>. Default is &quot;2-sided&quot;.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_power">power</code></td>
<td>
<p>Numeric in (0,0.99]. The target power <code class="reqn">1 - \beta</code>. Default is 0.8.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_kij">kij</code></td>
<td>
<p>Only in NFM: A numeric value or an array (dim = 2), representing
expected values or distribution parameters. Interpretation depends on the <code>data.type</code> parameter:
</p>

<ul>
<li><p> For grouped data: It is the number of observations per subgroup.
</p>
</li>
<li><p> For recurrent events data: It is the number of observation per subjects.
</p>
</li>
<li><p> For multi-type recurrent events data: It is the number of recurrences for
each distinct type of event.
</p>
</li></ul>

<p>Default is 15.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_kij.type">kij.type</code></td>
<td>
<p>Character value, specifying <code>kij</code>. Valid options:
</p>

<ul>
<li> <p><code>"max"</code>: <code>kij</code> is a fixed number.
</p>
</li>
<li> <p><code>"pois"</code>: <code>kij</code> is a mean (parameter of a Poisson distribution).
</p>
</li>
<li> <p><code>"unif"</code>: <code>kij</code> is the lower and upper bound parameters of a uniform distribution.
</p>
</li></ul>

<p>Options <code>"pois"</code> and <code>"unif"</code> can only be selected for recurrent event data; see Note for details.
Default is <code>"max"</code>.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_eta">eta</code></td>
<td>
<p>Only in NFM and GJFM: positive numeric value, corresponding to an
additional Gamma-frailty variance parameter for second-level nesting (NFM)
or inter-recurrence dependence (GJFM). Default is 0.5.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_npts">Npts</code></td>
<td>
<p>Only in JFM and GJFM: positive numeric value, corresponding to the
total number of subjects. Default is 400.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_medianr.h0">medianR.H0</code></td>
<td>
<p>Only in JFM and GJFM: positive numeric value, corresponding
to the expected median time between two recurrent events under the null (H0),
for the scale parameter (Weibull) calculation. Default is 3.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_mediand.h0">medianD.H0</code></td>
<td>
<p>Only in JFM and GJFM: positive numeric value, corresponding
to the expected median time to the terminal event under the null (H0),
for the scale parameter (Weibull) calculation. Default is 10.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_betatest.type">betaTest.type</code></td>
<td>
<p>Only in JFM and GJFM: character value indicating which
hypothesis is tested when computing power. Our implementation allows either
power calculation or sample-size estimation, testing recurrent events alone,
terminal event alone or both. Valid options:
<code>"joint"</code> (for testing both <code class="reqn">\beta_R</code> and <code class="reqn">\beta_D</code>), <code>"betaRtest"</code>
(for testing only <code class="reqn">\beta_R</code>) or <code>"betaDtest"</code>
(for testing only <code class="reqn">\beta_D</code>). Default is <code>"joint"</code>.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_betar.h0">betaR.H0</code></td>
<td>
<p>Only in JFM and GJFM: numeric value, corresponding to the
log-hazard ratios for recurrent events under the null hypothesis (H0). Default is 0.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_betar.ha">betaR.HA</code></td>
<td>
<p>Only in JFM and GJFM: numeric value, corresponding to the
log-hazard ratios for recurrent events under the alternative hypothesis (HA). Default is log(0.75).</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_betad.h0">betaD.H0</code></td>
<td>
<p>Only in JFM and GJFM: numeric value, corresponding to the
log-hazard ratios for terminal events under the null hypothesis (H0). Default is 0.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_betad.ha">betaD.HA</code></td>
<td>
<p>Only in JFM and GJFM: numeric value, corresponding to the
log-hazard ratios for terminal events under the alternative hypothesis (HA). Default is log(0.85).</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_shaper.w">shapeR.W</code></td>
<td>
<p>Only in JFM and GJFM: positive numeric value, corresponding to
the shape parameter (Weibull) of the recurrent-event baseline hazard function. Default is 1.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_shaped.w">shapeD.W</code></td>
<td>
<p>Only in JFM and GJFM: positive numeric value, corresponding to
the shape parameter (Weibull) of the terminal-event baseline hazard function. Default is 1.</p>
</td></tr>
<tr><td><code id="frailtyDesign_+3A_alpha">alpha</code></td>
<td>
<p>Only in JFM: numeric value, corresponding to the parameter <code class="reqn">\alpha</code>
that modulates the association between recurrent and terminal events. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>See Dinart et al. (2024) for the original article. We present here the case
where we want to assess the treatment effect only. Our null hypothesis is that
there is no treatment effect (i.e. zero log-hazard ratio).
</p>
<p>This approach relies on the squared Wald test to assess the presence of a
treatment effect using an estimator <code class="reqn">\hat{\Theta}</code>. Specifically, under
our null hypothesis, the test statistic
<code class="reqn">X_w = Z^2 = (\hat{\Theta} - \Theta)^2 / \mathcal{I}^{-1}(\hat{\Theta})</code>
follows a central <code class="reqn">\chi^2_1</code> distribution (i.e., non-centrality parameter
<code class="reqn">\mu = 0</code>), whereas under the alternative hypothesis, it follows a
non-central <code class="reqn">\chi^2_1(\mu)</code> distribution with <code class="reqn">\mu &gt; 0</code>.
</p>
<p>The parameter <code class="reqn">\mu</code> is estimated algorithmically, and the Fisher
information <code class="reqn">\mathcal{I}_1(\hat{\Theta})</code> is obtained by simulation,
leveraging the law of large numbers. Concretely, for an <code class="reqn">M</code>-sample
generated by simulation, the matrix <code class="reqn">\mathcal{I}(\hat{\Theta})</code> is
approximated via the empirical mean of the products
<code class="reqn">\partial_{\Theta_k} l(\Theta(i)) \times \partial_{\Theta_l} l(\Theta(i))^\top</code>,
<code class="reqn">i \in [\![1, \dots, M]\!]</code>. The algorithmic estimation for <code class="reqn">\mu</code>
follows the three-step procedure described by Dinart et al. (2024):
</p>

<ol>
<li><p> Compute the <code class="reqn">\alpha</code>-quantile (denoted <code class="reqn">q_{1,\alpha}</code>) of a central
chi-square distribution with 1 degree of freedom (<code class="reqn">\chi^2_1</code>),
given a specified type I error rate <code class="reqn">\alpha</code>.
</p>
</li>
<li><p> Determine a non-centrality parameter <code class="reqn">\vartheta</code> such that
<code class="reqn">1 - P\bigl(\chi^2_1(\vartheta) &lt; q_{1,\alpha}\bigr) &gt; 1 - \beta</code>,
where <code class="reqn">1 - \beta</code> represents the desired statistical power and
<code class="reqn">1 - P\bigl(\chi^2_1(\vartheta) &lt; q_{1,\alpha}\bigr)</code> the computed power.
</p>
</li>
<li><p> Optimize <code class="reqn">\mu</code> to find the smallest value satisfying that condition for
all
<code class="reqn">x \in [0,\vartheta]</code>, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">
     \mu
     = \min_{x \in [0,\vartheta]} \Bigl\{ 1 - P\bigl(\chi^2_1(x) &lt; q_{1,\alpha}\bigr)
     - (1 - \beta)\Bigr\}.
   </code>
</p>

</li></ol>

<p>Once <code class="reqn">\mu</code> is estimated, the sample size <code class="reqn">n</code> is derived from
</p>
<p style="text-align: center;"><code class="reqn">
  n \,\geq\, \mu
  \times \Bigl(\Theta_A^2 \times \mathcal{I}_1(\hat{\Theta})\Bigr)^{-1},
</code>
</p>

<p>where <code class="reqn">\Theta_A</code> denotes the parameter value under <code class="reqn">H_A</code>.
If we are interested in the evaluation of the power, we estimate the
non-centrality parameter under <code class="reqn">H_A</code> for a given sample size <code class="reqn">N</code>, then compute
the power as <code class="reqn">P\bigl(\chi^2_1(\vartheta) &gt; q_{1,\alpha}\bigr\vert H_A)</code>.
</p>
<p>For both the joint frailty model and general joint frailty model, by following
the same methodology as in the univariate case, we can derive an expression
for the sample size from the generalized Wald statistic. Let <code class="reqn">H_0:
(\beta_R = 0) \text{ and } (\beta_D = 0)</code> vs. <code class="reqn">H_A: (\beta_R = \beta_R^A)
\text{ or } (\beta_D = \beta_D^A)</code>, be our null and alternative hypotheses respectively.
This multivariate test then follows a <code class="reqn">\chi^2_Q</code> distribution, where
<code class="reqn">Q</code> is the rank of the matrix <code class="reqn">C</code>, corresponding to the number of
constraints applied on the parameters under the null hypothesis. The test
statistic is:
</p>
<p style="text-align: center;"><code class="reqn">
  X_W \;=\; n\,\bigl(C\,\Omega\bigr)^\top
  \Bigl(C\,\mathcal{I}_1^{-1}(\Omega)\,C^\top\Bigr)^{-1}\bigl(C\,\Omega\bigr)
  \;\sim\;\chi^2_q(\mu),
</code>
</p>

<p>where <code class="reqn">\Omega^\top</code> is the vector parameter from the corresponding model.
From this, we derive a sample size formula:
</p>
<p style="text-align: center;"><code class="reqn">
  n \,\geq\, \mu \,\Bigl(\bigl(C\,\Omega\bigr)^\top
  \bigl(C\,\mathcal{I}_1^{-1}(\Omega)\,C^\top\bigr)^{-1}\bigl(C\,\Omega\bigr)\Bigr)^{-1}.
</code>
</p>

<p>For instance, for the JFM, we have
<code class="reqn">\Omega^\top = (\beta_R, \beta_D, r_0(.), h_0(.), \theta, \alpha)^\top)</code>.
If we want to test a treatment effect on both the recurrent and the terminal event
(i.e. <code class="reqn">H_0 : \beta_R=0 \text{ and } \beta_D=0</code>), hence:
<code class="reqn">C\times \Omega = \begin{pmatrix}1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{pmatrix}
\times (\beta_R, \beta_D, r_0(.), h_0(.), \theta, \alpha)^\top</code>

</p>


<h3>Value</h3>

<p>For SFM and NFM, the *.power() function returns a list with:
</p>

<ul>
<li> <p><code>estimated.power</code>: the estimated power.
</p>
</li>
<li> <p><code>number.events</code>: an array (dim = 2) containing the number of recurrent events
under the null and alternative hypotheses, respectively.
</p>
</li></ul>

<p>The *.ssize() function returns a list with:
</p>

<ul>
<li> <p><code>Groups</code>: the total number of subjects (recurrent event data)
or number of groups (clustered data).
</p>
</li>
<li> <p><code>number.events</code>: an array (dim = 2) containing the number of events
under the null and alternative hypotheses, respectively.
</p>
</li></ul>

<p>For JFM and GJFM, the *.power() function returns a list with:
</p>

<ul>
<li> <p><code>estimated.power</code>: the estimated power.
</p>
</li>
<li> <p><code>events.rec</code>: an array (dim = 2) containing the number of recurrent events
under the null and alternative hypotheses, respectively.
</p>
</li>
<li> <p><code>events.D</code>: an array (dim = 2) containing the number of terminal events
under the null and alternative hypotheses, respectively.
</p>
</li></ul>

<p>The *.ssize() function returns a list with:
</p>

<ul>
<li> <p><code>Npts</code>: the computed total number of subjects.
</p>
</li>
<li> <p><code>events.rec</code>: an array (dim = 2) containing the number of recurrent events
under the null and alternative hypotheses, respectively.
</p>
</li>
<li> <p><code>events.D</code>: an array (dim = 2) containing the number of terminal events
under the null and alternative hypotheses, respectively.
</p>
</li></ul>

<p>All returned lists additionally include several input parameters: <code>target.power</code> or
<code>Groups</code>/<code>Npts</code> (depending on the called function), <code>ni</code>, <code>FUP</code>,
<code>FUP.type</code>, <code>Acc.Dur</code>, <code>ratio</code>, <code>data.type</code>, the test type <code>testType</code>,
<code>alpha</code>, <code>theta</code>, <code>eta</code> (for NFM and GJFM) and <code>samplesMC</code>. For SFM and NFM,
we have the corresponding hazard ratios (<code>HR.H0</code>, <code>HR.HA</code>) from the given betas,
<code>median.H0</code>. For JGM and GJFM, we have the corresponding hazard ratios (<code>HR.R0</code>,
<code>HR.RA</code>, <code>HR.D0</code>, <code>HR.DA</code>) from the given betas, <code>medianR.H0</code>, <code>medianD.H0</code>,
and the testing structure <code>tested.structure</code>. Along with that, <code>model</code>
(&quot;SFM&quot;, &quot;NFM&quot;, &quot;JFM&quot; or &quot;GJFM&quot;), <code>method</code> (&quot;power&quot; or &quot;ssize&quot;) and <code>timescale</code>
(&quot;gap&quot; or &quot;calendar&quot;) are also included.
</p>
<p>All these parameters are utilized by the S3 methods <code>print.frailtyDesign</code> and
<code>summary.frailtyDesign</code> for further detailed output.
</p>


<h3>Note</h3>

<p>Internally, these functions rely on extensive numerical integration using Gaussian-Laguerre
quadrature to approximate the Fisher information. As such, computations may become resource-intensive.
You may need to adjust the parameter <code>samples.mc</code> or other integration parameters to enhance
computational performance or precision.
</p>
<p>In this implementation, users must provide both the median time and the shape parameter explicitly;
the scale parameter is then computed automatically. Under the Weibull distribution, the median time
<code class="reqn">t_{1/2}</code> relates to the scale and shape parameters via:
<code class="reqn">t_{1/2} = \text{scale} \times \log(2)^{1/\text{shape}}</code>. Consequently, the scale parameter is
calculated as: <code class="reqn">\text{scale} = \frac{t_{1/2}}{\log(2)^{1/\text{shape}}}</code>.
</p>
<p>For both SFM and NFM, when analyzing grouped data, the arguments <code>ni.type</code>
and <code>kij.type</code> are restricted to the value <code>"max"</code> to define an
exact sample size. For instance, specifying <code>ni.type = "pois"</code> would
represent a mean number of subgroups per group, thereby precluding
the determination of a precise sample size.
</p>
<p>In NFM, the parameter <code>"rec_event2"</code> might initially appear difficult to interpret.
As clarified by Derek et al. (2024), multitype recurrent events include situations such as
transient ischemic attacks classified by anatomical location in cardiovascular studies, or
migraines differentiated according to severity in neurological research.
</p>
<p>In survival analysis involving recurrent events, the interpretation of
regression coefficients (<code class="reqn">\beta</code>) is contingent upon the chosen timescale.
This distinction is crucial, as the timescale directly influences the risk
assessment and the corresponding interpretation of model parameters.
</p>

<ul>
<li><p> When employing a gap timescale, the timescale resets after each event,
measuring the duration until the next occurrence. Consequently, the regression
coefficients represent the modification of the inter-event risk, reflecting
how the treatment influence the hazard of experiencing a subsequent event
after the previous one. This approach focuses on the conditional risk between
events.
</p>
</li>
<li><p> In contrast, utilizing a calendar timescale measures the time from a fixed
origin, such as study entry, without resetting after each event. Here, the
regression coefficients pertain to the modification of the risk since the
initiation of the study, indicating how the treatment affect the hazard of
experiencing events over the entire follow-up period. This approach
focuses on the cumulative risk from the study entry.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Original code by Dinart Derek. Implementation by Adrien Orué.
</p>


<h3>References</h3>

<p>Derek Dinart, Carine Bellera &amp; Virginie Rondeau (09 Feb 2024).
Sample size estimation for recurrent event data using multifrailty
and multilevel survival models,
<em>Journal of Biopharmaceutical Statistics</em>,
DOI: 10.1080/10543406.2024.2310306.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>, <code><a href="#topic+print.frailtyDesign">print.frailtyDesign</a></code>,
<code><a href="#topic+summary.frailtyDesign">summary.frailtyDesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1 (SFM): a total of 400 patients (1:1 randomization scheme),
# with a fixed number of 3 recurrent events per patient. Gamma-frailty
# variance of 0.5. Expected hazard ratio of 0.7, time-to-death are uniformly
# distributed, with a mean time to death of (3+10)/2=6.5 years. Each subject is
# followed-up for a maximum of 6 years, with a median time-to-event of 1.5 years.
# Patients are recruited over a 0.5-year period.
SFM.power(
  Groups = 400, ni = 3, ni.type = "max",
  FUP = 6, Acc.Dur = 0.5, median.H0 = 1.5,
  beta.HA = log(0.7), theta = 0.5,
  cens.par = c(3, 10), cens.type = "Unif",
  data.type = "rec_event"
) # power ~ 90%


# Example 2 (NFM): same parameters as above, but we now assume that we have
# 40 hospitals, 10 subjects per hospital (10 × 40 = 400 subjects in total)
# and 3 recurrent events per subject.
NFM.power(
  Groups = 40, ni = 10, ni.type = "max", kij = 3, kij.type = "max",
  FUP = 6, Acc.Dur = 0.5, median.H0 = 1.5,
  beta.HA = log(0.7), theta = 0.5,
  cens.par = c(3, 10), cens.type = "Unif",
  data.type = "rec_event1"
) # power ~ 83%


# Example 3 (NFM): we aim to compute the required sample size to achieve
# 80% power for detecting a hazard ratio of 0.75 in a neurological study,
# where migraine episodes experienced by subjects are classified into three
# severity subtypes (mild, moderate, severe). For each subject, we anticipate
# a mean number of 2 migraine episodes per severity subtype, with a median
# time-to-event of 6 months. The study duration includes a 1-year accrual period
# followed by a 5-year total follow-up. All subjects will be followed until
# the end of the study.
NFM.ssize(
  power = 0.80, ni = 3, ni.type = "max", kij = 2, kij.type = "pois",
  FUP = 5, Acc.Dur = 1, FUP.type = "uptoend", median.H0 = 0.5,
  beta.HA = log(0.75), data.type = "rec_event2"
) # sample size ~ 363 patients

# Example 4 (JFM): power estimation, testing a treatment effect on recurrent
# events only. We assume a uniformly distributed number of recurrent events,
# ranging from 1 to 6 recurrent events per subject. The allocation ratio
# experimental:control is 2:1, and the follow-up is 10 weeks.
# The expected hazard ratio is 0.70 for recurrent event and 0.90 for the
# terminal event. We have chosen 0.5 as the variance of the frailties.
JFM.power(
  Npts = 400, ni = c(1, 6), ni.type = "unif",
  FUP = 10, FUP.type = "fixed", ratio = 2,
  betaTest.type = "betaRtest", betaR.HA = log(.70), betaD.HA = log(.90),
  theta = .5
) # power ~ 76%


# Example 5 (JFM): sample size calculation, to assess the treatment effect on
# both recurrent and terminal events. We want to achieve an 80% power.
# We anticipate a maximum of 5 recurrent events, over a 6-year period and a
# 0.5-year accrual period. We assume that the gamma-frailty variance is 0.5.
# For the control group, we expect a 2-year and a 5-year median time-to-event
# for recurrent events and terminal events, respectively. We consider a 30%
# and 20% risk reduction for recurrent events and terminal event, respectively.
JFM.ssize(
  power = 0.80, ni = 9,
  FUP = 6, Acc.Dur = 1.5, medianR.H0 = 2, medianD.H0 = 5,
  betaTest.type = "joint", betaR.HA = log(.70), betaD.HA = log(.80), theta = .5
) # sample size ~ 445 patients / ~ approx 


# Example 6: Sample size calculation for GJFM
# Same as above, but with two random effects (with two Gamma-frailty variances
# theta and eta). To ensure sample size estimation stability, we use 10000
# Monte-Carlo samples.
GJFM.ssize(
  power = 0.80, ni = 5,
  FUP = 6, Acc.Dur = 0.5, medianR.H0 = 2, medianD.H0 = 5,
  betaR.HA = log(0.70), betaD.HA = log(0.80), theta = 0.5, eta = 0.75,
  samples.mc = 1e5
) # sample size ~ 705 patients / ~ approx 4 min.


# Example 7:
# --------------------------------------------------
# Post-hoc power analysis for a Joint Frailty Model
# --------------------------------------------------
# See original article by Gonzalez et al. (2005)
data(readmission)
modJFM &lt;- frailtyPenal(
  Surv(time, event) ~ cluster(id) + as.factor(chemo) + terminal(death),
  formula.terminalEvent = ~ as.factor(chemo), data = readmission,
  hazard = "Weibull"
)

# Test both recurrent and death events
# # - Let us assume an underlying Poisson distribution for ni.type. The
# # empirical mean of the number of recurrent events per patients is: ni = 1.136476.
# # - For the null hypothesis, let us consider betaR.H0 = betaD.H0 = 0. For the
# # alternative hypothesis, we use the estimated parameters for betaD.HA and
# # betaR.HA.
# # - "Patients were actively followed up until June 2002" -&gt; the follow-up
# # type is "UpToEnd".
# # - "The study took place in the Hospital de Bellvitge, [...] between
# # January 1996 and December 1998" -&gt; the accrual time is approximately 3 years
# # - We can assume that the study duration is approximately 6 years

ni &lt;- 1.136476
ni.type &lt;- "Pois"
Acc.Dur &lt;- 3 * 365.25 # time unit = days
FUP &lt;- 6 * 365.25     # same as above
betaR.HA &lt;- as.numeric(modJFM$coef[1]) # else "Named numeric"
betaD.HA &lt;- as.numeric(modJFM$coef[2]) # same as above
med &lt;- modJFM$scale.weib * log(2)^(1 / modJFM$shape.weib)
medianR.H0 &lt;- med[1]
medianD.H0 &lt;- med[2]
shapeR.W &lt;- modJFM$shape[1]
shapeD.W &lt;- modJFM$shape[2]
theta &lt;- modJFM$theta
alpha &lt;- modJFM$alpha
Npts &lt;- length(unique(readmission[, "id"])) # 403 patients
nTreated &lt;- length(unique(readmission[readmission$chemo == "Treated", "id"])) #217 treated patients
ratio &lt;- nTreated / (Npts - nTreated)

JFM.power(
  Npts = Npts, ni = ni, ni.type = ni.type,
  Acc.Dur = Acc.Dur, FUP = FUP, medianR.H0 = medianR.H0, medianD.H0 = medianD.H0,
  betaTest.type = "joint", betaR.HA = betaR.HA, betaD.HA = betaD.HA,
  shapeR.W = shapeR.W, shapeD.W = shapeD.W, theta = theta, alpha = alpha,
  ratio = ratio
) # power ~ 92%

# --------------------------------------------------
# Required sample size under the same setting
# --------------------------------------------------
# Here, let us consider that readmission is a “pilot study” with 403 patients,
# from which we estimate parameters. Under this scenario, let us compute the
# needed sample size, but to achieve an 80% power.

JFM.ssize(
  power = 0.80, ni = ni, ni.type = ni.type,
  Acc.Dur = Acc.Dur, FUP = FUP, medianR.H0 = medianR.H0, medianD.H0 = medianD.H0,
  betaTest.type = "joint", betaR.HA = betaR.HA, betaD.HA = betaD.HA,
  shapeR.W = shapeR.W, shapeD.W = shapeD.W, theta = theta, alpha = alpha,
  ratio = ratio
) # 289 patients needed under the same settings vs. 403


</code></pre>

<hr>
<h2 id='frailtyPenal'>Fit a Shared, Joint or Nested Frailty model</h2><span id='topic+frailtyPenal'></span><span id='topic+waldtest'></span><span id='topic+factor.names'></span><span id='topic+timedep.names'></span>

<h3>Description</h3>


<p><b>Shared Frailty model</b>
</p>
<p>Fit a shared gamma or log-normal frailty model using a semiparametric
Penalized Likelihood estimation or parametric estimation on the hazard
function. Left-truncated, right-censored data, interval-censored data and
strata (up to 6 levels) are allowed. It allows to obtain a non-parametric
smooth hazard of survival function. This approach is different from the
partial penalized likelihood approach of Therneau et al.
</p>
<p>The hazard function, conditional on the frailty term <code class="reqn">\omega</code><sub>i</sub>, of a
shared gamma frailty model for the j<sup>th</sup> subject in the i<sup>th</sup>
group: 
</p>
<p><img src="../help/figures/frailtymodel1.1.png" width="70%" alt="frailtymodel1.1.png" />
<img src="../help/figures/frailtymodel1.2.png" width="70%" alt="frailtymodel1.2.png" />
</p>
<p>where <code class="reqn">\lambda</code><sub>0</sub>(t) is the baseline hazard function, <b><code class="reqn">\beta</code></b>
the vector of the regression coefficient associated to the covariate vector
<b><code class="reqn">Z</code><sub>ij</sub></b> for the j<sup>th</sup> individual in the i<sup>th</sup>
group.
</p>
<p>Otherwise, in case of a shared log-normal frailty model, we have for the
j<sup>th</sup> subject in the i<sup>th</sup> group:
</p>
<p><img src="../help/figures/frailtymodel2.1.png" width="70%" alt="frailtymodel2.1.png" />
<img src="../help/figures/frailtymodel2.2.png" width="70%" alt="frailtymodel2.2.png" />
</p>
<p>From now on, you can also consider time-varying effects covariates in your
model, see <code>timedep</code> function for more details.
</p>
<p><b>Joint Frailty model</b>
</p>
<p>Fit a joint either with gamma or log-normal frailty model for recurrent and
terminal events using a penalized likelihood estimation on the hazard
function or a parametric estimation. Right-censored data and strata (up to 6
levels) for the recurrent event part are allowed. Left-truncated data is not
possible. Joint frailty models allow studying, jointly, survival processes
of recurrent and terminal events, by considering the terminal event as an
informative censoring.
</p>
<p>There is two kinds of joint frailty models that can be fitted with
<code>frailtyPenal</code> :
</p>
<p>- The first one (Rondeau et al. 2007) includes a common frailty term to the
individuals <code class="reqn">\omega</code><sub>i</sub> for the two rates which will take into account
the heterogeneity in the data, associated with unobserved covariates. The
frailty term acts differently for the two rates (<code class="reqn">\omega</code><sub>i</sub> for the
recurrent rate and <code class="reqn">\omega</code><sub>i</sub><sup>\eqn{\alpha}</sup> for the death rate). The
covariates could be different for the recurrent rate and death rate.
</p>
<p>For the j<sup>th</sup> recurrence (j=1,...,n<sub>i</sub>) and the
i<sup>th</sup> subject (i=1,...,G), the joint gamma frailty model
for recurrent event hazard function <code class="reqn">r</code><sub>ij</sub>(.) and death rate
<code class="reqn">\lambda</code><sub>i</sub> is :
</p>
<p><img src="../help/figures/frailtymodel3.png" width="70%" alt="frailtymodel3.png" />
</p>
<p>where <code class="reqn">r</code><sub>0</sub>(t) (resp. <code class="reqn">\lambda</code><sub>0</sub>(t)) is the recurrent (resp.
terminal) event baseline hazard function, <b><code class="reqn">\beta</code><sub>1</sub></b> (resp.
<b><code class="reqn">\beta</code><sub>2</sub></b>) the regression coefficient vector, <b><code class="reqn">Z</code><sub>i</sub>(t)</b>
the covariate vector. The random effects of frailties <code class="reqn">\omega</code><sub>i</sub> <span>&#126;</span>  <b><code class="reqn">\Gamma</code>(1/<code class="reqn">\theta</code>,1/<code class="reqn">\theta</code>)</b> and are
iid.
</p>
<p>The joint log-normal frailty model will be :
</p>
<p><img src="../help/figures/frailtymodel4.png" width="70%" alt="frailtymodel4.png" />
<img src="../help/figures/frailtymodel5.png" width="70%" alt="frailtymodel5.png" />
</p>
<p>- The second one (Rondeau et al. 2011) is quite similar but the frailty term
is common to the individuals from a same group. This model is useful for the
joint modelling two clustered survival outcomes. This joint models have been
developed for clustered semi-competing events. The follow-up of each of the
two competing outcomes stops when the event occurs. In this case, j is for
the subject and i for the cluster.
</p>
<p><img src="../help/figures/frailtymodel6.png" width="80%" alt="frailtymodel6.png" />
</p>
<p>It should be noted that in these models it is not recommended to include
<code class="reqn">\alpha</code> parameter as there is not enough information to estimate it and
thus there might be convergence problems.
</p>
<p>In case of a log-normal distribution of the frailties, we will have :
</p>
<p><img src="../help/figures/frailtymodel7.png" width="80%" alt="frailtymodel7.png" />
<img src="../help/figures/frailtymodel8.png" width="80%" alt="frailtymodel8.png" />
</p>
<p>This joint frailty model can also be applied to clustered recurrent events
and a terminal event (example on &quot;readmission&quot; data below).
</p>
<p>From now on, you can also consider time-varying effects covariates in your
model, see <code>timedep</code> function for more details.
</p>
<p>There is a possibility to use a weighted penalized maximum likelihood
approach for nested case-control design, in which risk set sampling is
performed based on a single outcome (Jazic et al., <em>Submitted</em>).
</p>
<p>General Joint Frailty model Fit a general joint frailty model for recurrent
and terminal events considering two independent frailty terms. The frailty
term <code class="reqn">u</code><sub>i</sub> represents the unobserved association between recurrences and
death. The frailty term <code class="reqn">v</code><sub>i</sub> is specific to the recurrent event rate.
Thus, the general joint frailty model is:
</p>
<p><img src="../help/figures/frailtymodel9.png" width="90%" alt="frailtymodel9.png" />
</p>
<p>where the <code class="reqn">iid</code> random effects
<b><code class="reqn">u</code><sub>i</sub></b> &#126; <b><code class="reqn">\Gamma</code>(1/<code class="reqn">\theta</code>,1/<code class="reqn">\theta</code>)</b> and the
<code class="reqn">iid</code> random effects
<b><code class="reqn">v</code><sub>i</sub></b> &#126; <b><code class="reqn">\Gamma</code>(1/<code class="reqn">\eta</code>,1/<code class="reqn">\eta</code>)</b> are independent
from each other.  The joint model is fitted using a penalized likelihood
estimation on the hazard. Right-censored data and time-varying covariates
<b><code class="reqn">Z</code><sub>i</sub>(t)</b> are allowed.
</p>
<p><b>Nested Frailty model</b>
</p>
<p><b><em>Data should be ordered according to cluster and subcluster</em></b>
</p>
<p>Fit a nested frailty model using a Penalized Likelihood on the hazard
function or using a parametric estimation. Nested frailty models allow
survival studies for hierarchically clustered data by including two iid
gamma random effects. Left-truncated and right-censored data are allowed.
Stratification analysis is allowed (maximum of strata = 2).
The hazard function conditional on the two frailties <code class="reqn">v</code><sub>i</sub> and
<code class="reqn">w</code><sub>ij</sub> for the k<sup>th</sup> individual of the j<sup>th</sup> subgroup of
the i<sup>th</sup> group is :
</p>
<p><img src="../help/figures/frailtymodel10.png" width="80%" alt="frailtymodel10.png" />
</p>
<p>where <code class="reqn">\lambda</code><sub>0</sub>(t) is the baseline hazard function, <code class="reqn">X</code><sub>ijk</sub>
denotes the covariate vector and <code class="reqn">\beta</code> the corresponding vector of
regression parameters.
</p>
<p><b>Joint Nested Frailty Model</b>
</p>
<p>Fit a joint model for recurrent and terminal events using a penalized
likelihood on the hazard functions or a parametric estimation.
Right-censored data are allowed but left-truncated data and stratified
analysis are not allowed.
</p>
<p>Joint nested frailty models allow studying, jointly, survival processes of
recurrent and terminal events for hierarchically clustered data, by
considering the terminal event as an informative censoring and by including
two iid gamma random effects.
</p>
<p>The joint nested frailty model includes two shared frailty terms, one for
the subgroup (<code class="reqn">u</code><sub>fi</sub>) and one for the group (<code class="reqn">w</code><sub>f</sub>) into the
hazard functions. This random effects account the heterogeneity in the data,
associated with unobserved covariates. The frailty terms act differently for
the two rates (<code class="reqn">u</code><sub>fi</sub>, <code class="reqn">w</code><sub>f</sub><sup>\eqn{\xi}</sup> for the recurrent rate and
<code class="reqn">u</code><sub>fi</sub><sup>\eqn{\alpha}</sup>, <code class="reqn">w</code><sub>i</sub> for the terminal event rate). The covariates
could be different for the recurrent rate and death rate.
</p>
<p>For the j<sup>th</sup> recurrence (j = 1, ..., <code class="reqn">n</code><sub>i</sub>) of the i<sup>th</sup>
individual (i = 1, ..., <code class="reqn">m</code><sub>f</sub>) of the <code class="reqn">f</code><sup>th</sup> group (f = 1,...,
n), the joint nested gamma frailty model for recurrent event hazard function
<code class="reqn">r</code><sub>fij</sub>(.) and for terminal event hazard function <code class="reqn">\lambda</code><sub>fi</sub>
is :
</p>
<p><img src="../help/figures/frailtymodel11.png" width="90%" alt="frailtymodel11.png" />
</p>
<p>where <code class="reqn">r</code><sub>0</sub>(resp. <code class="reqn">\lambda</code><sub>0</sub>) is the recurrent (resp.
terminal) event baseline hazard function, <code class="reqn">\beta</code> (resp. <code class="reqn">\gamma</code>)
the regression coefficient vector, <b><code class="reqn">X</code><sub>fij</sub></b>(t) the covariates
vector. The random effects are <code class="reqn">\omega</code><sub>f</sub> <span>&#126;</span>  <b><code class="reqn">\Gamma</code>(1/<code class="reqn">\eta</code>,1/<code class="reqn">\eta</code>)</b>
and <code class="reqn">u</code><sub>fi</sub> <span>&#126;</span>  <b><code class="reqn">\Gamma</code>(1/<code class="reqn">\theta</code>,1/<code class="reqn">\theta</code>)</b>.



</p>


<h3>Usage</h3>

<pre><code class='language-R'>frailtyPenal(formula, formula.terminalEvent, data, recurrentAG = FALSE,
cross.validation = FALSE, jointGeneral,n.knots, kappa, maxit = 300, hazard =
"Splines", nb.int, RandDist = "Gamma", nb.gh, nb.gl, betaknots = 1, betaorder = 3,
initialize = TRUE, init.B, init.Theta, init.Alpha, Alpha, init.Ksi, Ksi,
init.Eta, LIMparam = 1e-3, LIMlogl = 1e-3, LIMderiv = 1e-3, print.times =
TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frailtyPenal_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a
<code class="reqn">\sim</code> operator, and the terms on the right. The response must be a
survival object as returned by the 'Surv' function like in survival package.
In case of interval-censored data, the response must be an object as
returned by the 'SurvIC' function from this package.  Interactions are
possible using * or :.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_formula.terminalevent">formula.terminalEvent</code></td>
<td>
<p>only for joint and joint nested frailty models
: a formula object, only requires terms on the right to indicate which
variables are modelling the terminal event.  Interactions are possible using
* or :.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_data">data</code></td>
<td>
<p>a 'data.frame' with the variables used in 'formula'.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_recurrentag">recurrentAG</code></td>
<td>
<p>Logical value. Is Andersen-Gill model fitted? If so
indicates that recurrent event times with the counting process approach of
Andersen and Gill is used. This formulation can be used for dealing with
time-dependent covariates. The default is FALSE.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_cross.validation">cross.validation</code></td>
<td>
<p>Logical value. Is cross validation procedure used
for estimating smoothing parameter in the penalized likelihood estimation?
If so a search of the smoothing parameter using cross validation is done,
with kappa as the seed.  The cross validation is not implemented for several
strata, neither for interval-censored data. The cross validation has been
implemented for a Cox proportional hazard model, with no covariates. The
default is FALSE.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_jointgeneral">jointGeneral</code></td>
<td>
<p>Logical value. Does the model include two independent
random effects? If so, this will fit a general joint frailty model with an
association between the recurrent events and a terminal event (explained by
the variance <code class="reqn">\theta</code>) and an association amongst the recurrent events
(explained by the variance <code class="reqn">\eta</code>).</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_n.knots">n.knots</code></td>
<td>
<p>integer giving the number of knots to use. Value required in
the penalized likelihood estimation.  It corresponds to the (n.knots+2)
splines functions for the approximation of the hazard or the survival
functions.  We estimate I or M-splines of order 4. When the user set a
number of knots equals to k (n.knots=k) then the number of interior knots is
(k-2) and the number of splines is (k-2)+order.  Number of knots must be
between 4 and 20. (See Note)</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_kappa">kappa</code></td>
<td>
<p>positive smoothing parameter in the penalized likelihood
estimation. In a stratified shared model, this argument must be a vector
with kappas for both strata.  In a stratified joint model, this argument
must be a vector with kappas for both strata for recurrent events plus one
kappa for terminal event.  The coefficient kappa of the integral of the
squared second derivative of hazard function in the fit (penalized log
likelihood). To obtain an initial value for <code>kappa</code>, a solution is to
fit the corresponding shared frailty model using cross validation (See
cross.validation).  We advise the user to identify several possible tuning
parameters, note their defaults and look at the sensitivity of the results
to varying them. Value required. (See Note).</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations for the Marquardt algorithm.
Default is 300</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_hazard">hazard</code></td>
<td>
<p>Type of hazard functions: &quot;Splines&quot; for semiparametric hazard
functions using equidistant intervals or &quot;Splines-per&quot; using percentile with
the penalized likelihood estimation, &quot;Piecewise-per&quot; for piecewise constant
hazard function using percentile (not available for interval-censored data),
&quot;Piecewise-equi&quot; for piecewise constant hazard function using equidistant
intervals, &quot;Weibull&quot; for parametric Weibull functions. Default is &quot;Splines&quot;.
In case of <code>jointGeneral = TRUE</code> or if a joint nested frailty model is
fitted, only <code>hazard = "Splines"</code> can be chosen.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_nb.int">nb.int</code></td>
<td>
<p>Number of time intervals (between 1 and 20) for the parametric
hazard functions (&quot;Piecewise-per&quot;, &quot;Piecewise-equi&quot;). In a joint model, you
need to specify a number of time interval for both recurrent hazard function
and the death hazard function (vector of length 2).</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_randdist">RandDist</code></td>
<td>
<p>Type of random effect distribution: &quot;Gamma&quot; for a gamma
distribution, &quot;LogN&quot; for a log-normal distribution. Default is &quot;Gamma&quot;. Not
implemented for nested model. If <code>jointGeneral = TRUE</code> or if a joint
nested frailty model is fitted, the log-normal distribution cannot be
chosen.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_nb.gh">nb.gh</code></td>
<td>
<p>Number of nodes for the Gaussian-Hermite quadrature. 
It can be chosen among 5, 7, 9, 12, 15, 20 and 32. The default is 20 if hazard = &quot;Splines&quot;, 32 otherwise.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_nb.gl">nb.gl</code></td>
<td>
<p>Number of nodes for the Gaussian-Laguerre quadrature. 
It can be chosen between 20 and 32. The default is 20 if hazard = &quot;Splines&quot;, 32 otherwise.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_betaknots">betaknots</code></td>
<td>
<p>Number of inner knots used for the estimation of B-splines.
Default is 1. See 'timedep' function for more details. Not implemented for
nested and joint nested frailty models.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_betaorder">betaorder</code></td>
<td>
<p>Order of the B-splines. Default is cubic B-splines (order =
3). See 'timedep' function for more details. Not implemented for nested and
joint nested frailty models.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_initialize">initialize</code></td>
<td>
<p>Logical value, only for joint nested frailty models.
Option <code>TRUE</code> indicates fitting an appropriate standard joint frailty
model (without group effect, only the subgroup effect) to provide initial
values for the joint nested model. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_init.b">init.B</code></td>
<td>
<p>A vector of initial values for regression coefficients. This
vector should be of the same size as the whole vector of covariates with the
first elements for the covariates related to the recurrent events and then
to the terminal event (interactions in the end of each component). Default
is 0.1 for each (for Cox and shared model) or 0.5 (for joint and joint
nested frailty models).</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_init.theta">init.Theta</code></td>
<td>
<p>Initial value for variance of the frailties.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_init.alpha">init.Alpha</code></td>
<td>
<p>Only for joint and joint nested frailty models : initial
value for parameter alpha.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_alpha">Alpha</code></td>
<td>
<p>Only for joint and joint nested frailty model : input &quot;None&quot; so
as to fit a joint model without the parameter alpha.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_init.ksi">init.Ksi</code></td>
<td>
<p>Only for joint nested frailty model : initial value for
parameter <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_ksi">Ksi</code></td>
<td>
<p>Only for joint nested frailty model : input <code>"None"</code>
indicates a joint nested frailty model without the parameter <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_init.eta">init.Eta</code></td>
<td>
<p>Only for general joint and joint nested frailty models :
initial value for the variance <code class="reqn">\eta</code> of the frailty <code class="reqn">v_i</code> (general
joint model) and of the frailty <code class="reqn">\omega_i</code> (joint nested frailty model).</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_limparam">LIMparam</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
parameters (see Details), <code class="reqn">10^{-3}</code> by default.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_limlogl">LIMlogl</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
log-likelihood (see Details), <code class="reqn">10^{-3}</code> by default.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_limderiv">LIMderiv</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
gradient (see Details), <code class="reqn">10^{-3}</code> by default.</p>
</td></tr>
<tr><td><code id="frailtyPenal_+3A_print.times">print.times</code></td>
<td>
<p>a logical parameter to print iteration process. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>Typical usages are for a Cox model
</p>
<pre>frailtyPenal(Surv(time,event)~var1+var2, data, \dots)</pre>
<p>for a shared model
</p>
<pre>frailtyPenal(Surv(time,event)~cluster(group)+var1+var2, data,
\dots)</pre>
<p>for a joint model
</p>
<pre>frailtyPenal(Surv(time,event)~cluster(group)+var1+var2+
var3+terminal(death), formula.terminalEvent=~ var1+var4, data, \dots)</pre>
<p>for a joint model for clustered data
</p>
<pre>frailtyPenal(Surv(time,event)~cluster(group)+num.id(group2)+
var1+var2+var3+terminal(death), formula.terminalEvent=~var1+var4, data,
\dots)</pre>
<p>for a joint model for data from nested case-control studies
</p>
<pre>frailtyPenal(Surv(time,event)~cluster(group)+num.id(group2)+
var1+var2+var3+terminal(death)+wts(wts.ncc),
formula.terminalEvent=~var1+var4, data, \dots)</pre>
<p>for a nested model
</p>
<pre>frailtyPenal(Surv(time,event)~cluster(group)+subcluster(sbgroup)+
var1+var2, data, \dots)</pre>
<p>for a joint nested frailty model
</p>
<pre>frailtyPenal(Surv(time,event)~cluster(group)+subcluster(sbgroup)+
var1+var2++terminal(death), formula.terminalEvent=~var1+var4, data, \dots)</pre>
<p>The estimated parameter are obtained using the robust Marquardt algorithm
(Marquardt, 1963) which is a combination between a Newton-Raphson algorithm
and a steepest descent algorithm. The iterations are stopped when the
difference between two consecutive log-likelihoods was small
<code class="reqn">(&lt;10^{-3})</code>, the estimated coefficients were stable (consecutive values
<code class="reqn">(&lt;10^{-3})</code>, and the gradient small enough <code class="reqn">(&lt;10^{-3})</code>. When
frailty parameter is small, numerical problems may arise. To solve this
problem, an alternative formula of the penalized log-likelihood is used (see
Rondeau, 2003 for further details). Cubic M-splines of order 4 are used for
the hazard function, and I-splines (integrated M-splines) are used for the
cumulative hazard function.
</p>
<p>The inverse of the Hessian matrix is the variance estimator and to deal with
the positivity constraint of the variance component and the spline
coefficients, a squared transformation is used and the standard errors are
computed by the <code class="reqn">\Delta</code>-method (Knight &amp; Xekalaki, 2000). The smooth
parameter can be chosen by maximizing a likelihood cross validation
criterion (Joly and other, 1998). The integrations in the full log
likelihood were evaluated using Gaussian quadrature. Laguerre polynomials
with 20 points were used to treat the integrations on <code class="reqn">[0,\infty[</code>
</p>
<p><b>INITIAL VALUES</b>
</p>
<p>The splines and the regression coefficients are initialized to 0.1. In case
of shared model, the program fits, firstly, an adjusted Cox model to give
new initial values for the splines and the regression coefficients. The
variance of the frailty term <code class="reqn">\theta</code> is initialized to 0.1. Then, a
shared frailty model is fitted.
</p>
<p>In case of a joint frailty model, the splines and the regression
coefficients are initialized to 0.5. The program fits an adjusted Cox model
to have new initial values for the regression and the splines coefficients.
The variance of the frailty term <code class="reqn">\theta</code> and the coefficient
<code class="reqn">\alpha</code> associated in the death hazard function are initialized to 1.
Then, it fits a joint frailty model.
</p>
<p>In case of a general joint frailty model we need to initialize the
<code>jointGeneral</code> logical value to <code>TRUE</code>.
</p>
<p>In case of a nested model, the program fits an adjusted Cox model to provide
new initial values for the regression and the splines coefficients. The
variances of the frailties are initialized to 0.1. Then, a shared frailty
model with covariates with only subgroup frailty is fitted to give a new
initial value for the variance of the subgroup frailty term. Then, a shared
frailty model with covariates and only group frailty terms is fitted to give
a new initial value for the variance of the group frailties. In a last step,
a nested frailty model is fitted.
</p>
<p>In case of a joint nested model, the splines and the regression coefficients
are initialized to 0.5 and the variances of the frailty terms <code class="reqn">\eta</code> and
<code class="reqn">\xi</code> are initialized to 1.  If the option <code>'initialize'</code> is
<code>TRUE</code>, the program fits a joint frailty model to provide initial
values for the splines, covariates coefficients, variance <code class="reqn">\theta</code> of
the frailty terms and <code class="reqn">\alpha</code>. The variances of the second frailty term
(<code class="reqn">\eta</code>) and the second coefficient <code class="reqn">\xi</code> are initialized to 1.
Then, a joint nested frailty model is fitted.
</p>
<p><b>NCC DESIGN</b>
</p>
<p>It is possible to fit a joint frailty model for data from nested
case-control studies using the approach of weighted penalized maximum
likelihood. For this model, only splines can be used for baseline hazards
and no time-varying effects of covariates can be included. To accommodate
the nested case-control design, the formula for the recurrent events should
simply include the special term wts(wts.ncc), where wts.ncc refers to a
column of prespecified weights in the data set for every observation.  For
details, see Jazic et al., <em>Submitted</em> (available on request from the
package authors).

</p>


<h3>Value</h3>

<p>The following components are included in a 'frailtyPenal' object for each
model.
</p>
<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>sequence of the corresponding estimation of the coefficients for
the hazard functions (parametric or semiparametric), the random effects
variances and the regression coefficients.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The code used for
the model.</p>
</td></tr> <tr><td><code>formula</code></td>
<td>
<p>the formula part of the code used for the model.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>the regression coefficients.</p>
</td></tr> <tr><td><code>cross.Val</code></td>
<td>
<p>Logical value.
Is cross validation procedure used for estimating the smoothing parameters
in the penalized likelihood estimation?</p>
</td></tr> <tr><td><code>DoF</code></td>
<td>
<p>Degrees of freedom
associated with the &quot;kappa&quot;.</p>
</td></tr> <tr><td><code>groups</code></td>
<td>
<p>the maximum number of groups
used in the fit.</p>
</td></tr> <tr><td><code>kappa</code></td>
<td>
<p> A vector with the smoothing parameters in
the penalized likelihood estimation corresponding to each baseline function
as components.</p>
</td></tr> <tr><td><code>loglikPenal</code></td>
<td>
<p>the complete marginal penalized
log-likelihood in the semiparametric case.</p>
</td></tr> <tr><td><code>loglik</code></td>
<td>
<p>the marginal
log-likelihood in the parametric case.</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>the number of observations
used in the fit.</p>
</td></tr> <tr><td><code>n.events</code></td>
<td>
<p>the number of events observed in the fit.</p>
</td></tr>
<tr><td><code>n.iter</code></td>
<td>
<p>number of iterations needed to converge.</p>
</td></tr>
<tr><td><code>n.knots</code></td>
<td>
<p>number of knots for estimating the baseline functions in the
penalized likelihood estimation.</p>
</td></tr> <tr><td><code>n.strat</code></td>
<td>
<p> number of stratum.</p>
</td></tr>
<tr><td><code>varH</code></td>
<td>
<p>the variance matrix of all parameters before positivity
constraint transformation. Then, the delta method is needed to obtain the
estimated variance parameters. That is why some variances don't match with
the printed values at the end of the model.</p>
</td></tr> <tr><td><code>varHIH</code></td>
<td>
<p>the robust
estimation of the variance matrix of all parameters.</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>matrix of
times where both survival and hazard function are estimated. By default
seq(0,max(time),length=99), where time is the vector of survival times.</p>
</td></tr>
<tr><td><code>lam</code></td>
<td>
<p>array (dim=3) of hazard estimates and confidence bands.</p>
</td></tr>
<tr><td><code>surv</code></td>
<td>
<p>array (dim=3) of baseline survival estimates and confidence
bands.</p>
</td></tr> <tr><td><code>median</code></td>
<td>
<p>The value of the median survival and its confidence bands. If there are
two stratas or more, the first value corresponds to the value for the 
first strata, etc.</p>
</td></tr> <tr><td><code>nbintervR</code></td>
<td>
<p>Number of intervals (between 1 and 20) for the
parametric hazard functions (&quot;Piecewise-per&quot;, &quot;Piecewise-equi&quot;).</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>number of parameters.</p>
</td></tr> <tr><td><code>nvar</code></td>
<td>
<p>number of explanatory
variables.</p>
</td></tr> <tr><td><code>LCV</code></td>
<td>
<p>the approximated likelihood cross-validation
criterion in the semiparametric case (with H minus the converged Hessian
matrix, and l(.) the full
log-likelihood).</p>
<p style="text-align: center;"><code class="reqn">LCV=\frac{1}{n}(trace(H^{-1}_{pl}H) - l(.))</code>
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike information Criterion for the parametric
case.</p>
<p style="text-align: center;"><code class="reqn">AIC=\frac{1}{n}(np - l(.))</code>
</p>
</td></tr> <tr><td><code>n.knots.temp</code></td>
<td>
<p>initial value
for the number of knots.</p>
</td></tr> <tr><td><code>shape.weib</code></td>
<td>
<p>shape parameter for the Weibull
hazard function.</p>
</td></tr> <tr><td><code>scale.weib</code></td>
<td>
<p>scale parameter for the Weibull hazard
function.</p>
</td></tr> <tr><td><code>martingale.res</code></td>
<td>
<p>martingale residuals for each cluster.</p>
</td></tr>
<tr><td><code>martingaleCox</code></td>
<td>
<p>martingale residuals for observation in the Cox model.</p>
</td></tr>
<tr><td><code>Frailty</code></td>
<td>
<p>Logical value. Was model with frailties fitted ?</p>
</td></tr>
<tr><td><code>frailty.pred</code></td>
<td>
<p>empirical Bayes prediction of the frailty term (ie,
using conditional posterior distributions).</p>
</td></tr> <tr><td><code>frailty.var</code></td>
<td>
<p>variance of
the empirical Bayes prediction of the frailty term (only for gamma frailty
models).</p>
</td></tr> <tr><td><code>frailty.sd</code></td>
<td>
<p>standard error of the frailty empirical Bayes
prediction (only for gamma frailty models).</p>
</td></tr> <tr><td><code>global_chisq</code></td>
<td>
<p>a vector
with the values of each multivariate Wald test.</p>
</td></tr> <tr><td><code>dof_chisq</code></td>
<td>
<p>a vector
with the degree of freedom for each multivariate Wald test.</p>
</td></tr>
<tr><td><code>global_chisq.test</code></td>
<td>
<p>a binary variable equals to 0 when no multivariate
Wald is given, 1 otherwise.</p>
</td></tr> <tr><td><code>p.global_chisq</code></td>
<td>
<p>a vector with the
p_values for each global multivariate Wald test.</p>
</td></tr> <tr><td><code>names.factor</code></td>
<td>
<p>Names
of the &quot;as.factor&quot; variables.</p>
</td></tr> <tr><td><code>Xlevels</code></td>
<td>
<p>vector of the values that
factor might have taken.</p>
</td></tr> <tr><td><code>contrasts</code></td>
<td>
<p>type of contrast for factor
variable.</p>
</td></tr> <tr><td><code>beta_p.value</code></td>
<td>
<p>p-values of the Wald test for the estimated
regression coefficients.</p>
</td></tr>
</table>
<p>The following components are specific to <b>shared</b> models.
</p>
<table role = "presentation">
<tr><td><code>equidistant</code></td>
<td>
<p>Indicator for the intervals used the estimation of
baseline hazard functions (for splines or pieceiwse-constaant functions) : 1
for equidistant intervals ; 0 for intervals using percentile (note:
<code>equidistant</code> = 2 in case of parametric estimation using Weibull
distribution).</p>
</td></tr> <tr><td><code>intcens</code></td>
<td>
<p>Logical value. Indicator if a joint frailty
model with interval-censored data was fitted)</p>
</td></tr> <tr><td><code>theta</code></td>
<td>
<p>variance of the
gamma frailty parameter <code class="reqn">(\bold{Var}(\omega_i))</code></p>
</td></tr> <tr><td><code>sigma2</code></td>
<td>
<p>variance
of the log-normal frailty parameter <code class="reqn">(\bold{Var}(\eta_i))</code></p>
</td></tr>
<tr><td><code>linear.pred</code></td>
<td>
<p>linear predictor: uses simply &quot;Beta'X&quot; in the cox
proportional hazard model or &quot;Beta'X + log w_i&quot; in the shared gamma frailty
models, otherwise uses &quot;Beta'X + w_i&quot; for log-normal frailty distribution.</p>
</td></tr>
<tr><td><code>BetaTpsMat</code></td>
<td>
<p>matrix of time varying-effects and confidence bands (the
first column used for abscissa of times)</p>
</td></tr> <tr><td><code>theta_p.value</code></td>
<td>
<p>p-value of
the Wald test for the estimated variance of the gamma frailty.</p>
</td></tr>
<tr><td><code>sigma2_p.value</code></td>
<td>
<p>p-value of the Wald test for the estimated variance of
the log-normal frailty.</p>
</td></tr>
</table>
<p>The following components are specific to <b>joint</b> models.
</p>
<table role = "presentation">
<tr><td><code>intcens</code></td>
<td>
<p>Logical value. Indicator if a joint frailty model with
interval-censored data was fitted)</p>
</td></tr> <tr><td><code>theta</code></td>
<td>
<p>variance of the gamma
frailty parameter <code class="reqn">(\bold{Var}(\omega_i))</code> or <code class="reqn">(\bold{Var}(u_i))</code></p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>variance of the log-normal frailty parameter
<code class="reqn">(\bold{Var}(\eta_i))</code> or <code class="reqn">(\bold{Var}(v_i))</code></p>
</td></tr> <tr><td><code>eta</code></td>
<td>
<p>variance
of the second gamma frailty parameter in general joint frailty models
<code class="reqn">(\bold{Var}(v_i))</code></p>
</td></tr> <tr><td><code>indic_alpha</code></td>
<td>
<p>indicator if a joint frailty
model with <code class="reqn">\alpha</code> parameter was fitted</p>
</td></tr> <tr><td><code>alpha</code></td>
<td>
<p>the coefficient
<code class="reqn">\alpha</code> associated with the frailty parameter in the terminal hazard
function.</p>
</td></tr> <tr><td><code>nbintervR</code></td>
<td>
<p>Number of intervals (between 1 and 20) for the
recurrent parametric hazard functions (&quot;Piecewise-per&quot;, &quot;Piecewise-equi&quot;).</p>
</td></tr>
<tr><td><code>nbintervDC</code></td>
<td>
<p>Number of intervals (between 1 and 20) for the death
parametric hazard functions (&quot;Piecewise-per&quot;, &quot;Piecewise-equi&quot;).</p>
</td></tr>
<tr><td><code>nvar</code></td>
<td>
<p>A vector with the number of covariates of each type of hazard
function as components.</p>
</td></tr> <tr><td><code>nvarRec</code></td>
<td>
<p>number of recurrent explanatory
variables.</p>
</td></tr> <tr><td><code>nvarEnd</code></td>
<td>
<p>number of death explanatory variables.</p>
</td></tr>
<tr><td><code>noVar1</code></td>
<td>
<p>indicator of recurrent explanatory variables.</p>
</td></tr>
<tr><td><code>noVar2</code></td>
<td>
<p>indicator of death explanatory variables.</p>
</td></tr> <tr><td><code>xR</code></td>
<td>
<p>matrix of
times where both survival and hazard function are estimated for the
recurrent event. By default seq(0,max(time),length=99), where time is the
vector of survival times.</p>
</td></tr> <tr><td><code>xD</code></td>
<td>
<p>matrix of times for the terminal
event.</p>
</td></tr> <tr><td><code>lamR</code></td>
<td>
<p>array (dim=3) of hazard estimates and confidence bands
for recurrent event.</p>
</td></tr> <tr><td><code>lamD</code></td>
<td>
<p>the same value as lamR for the terminal
event.</p>
</td></tr> <tr><td><code>survR</code></td>
<td>
<p>array (dim=3) of baseline survival estimates and
confidence bands for recurrent event.</p>
</td></tr> <tr><td><code>survD</code></td>
<td>
<p>the same value as survR
for the terminal event.</p>
</td></tr> <tr><td><code>martingale.res</code></td>
<td>
<p>martingale residuals for each
cluster (recurrent).</p>
</td></tr> <tr><td><code>martingaledeath.res</code></td>
<td>
<p>martingale residuals for
each cluster (death).</p>
</td></tr> <tr><td><code>linear.pred</code></td>
<td>
<p>linear predictor: uses &quot;Beta'X +
log w_i&quot; in the gamma frailty model, otherwise uses &quot;Beta'X + eta_i&quot; for
log-normal frailty distribution</p>
</td></tr> <tr><td><code>lineardeath.pred</code></td>
<td>
<p>linear predictor
for the terminal part : &quot;Beta'X + alpha.log w_i&quot; for gamma, &quot;Beta'X +
alpha.eta_i&quot; for log-normal frailty distribution</p>
</td></tr> <tr><td><code>Xlevels</code></td>
<td>
<p>vector of
the values that factor might have taken for the recurrent part.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>type of contrast for factor variable for the recurrent
part.</p>
</td></tr> <tr><td><code>Xlevels2</code></td>
<td>
<p>vector of the values that factor might have taken for
the death part.</p>
</td></tr> <tr><td><code>contrasts2</code></td>
<td>
<p>type of contrast for factor variable for
the death part.</p>
</td></tr> <tr><td><code>BetaTpsMat</code></td>
<td>
<p>matrix of time varying-effects and
confidence bands for recurrent event (the first column used for abscissa of
times of recurrence)</p>
</td></tr> <tr><td><code>BetaTpsMatDc</code></td>
<td>
<p>matrix of time varying-effects and
confidence bands for terminal event (the first column used for abscissa of
times of death)</p>
</td></tr> <tr><td><code>alpha_p.value</code></td>
<td>
<p>p-value of the Wald test for the
estimated <code class="reqn">\alpha</code>.</p>
</td></tr> <tr><td><code>ncc</code></td>
<td>
<p>Logical value whether nested
case-control design with weights was used for the joint model.</p>
</td></tr>
</table>
<p>The following components are specific to <b>nested</b> models.
</p>
<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>variance of the cluster effect <code class="reqn">(\bold{Var}(v_{i}))</code></p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>variance of the subcluster effect <code class="reqn">(\bold{Var}(w_{ij}))</code></p>
</td></tr>
<tr><td><code>subgroups</code></td>
<td>
<p>the maximum number of subgroups used in the fit.</p>
</td></tr>
<tr><td><code>frailty.pred.group</code></td>
<td>
<p>empirical Bayes prediction of the frailty term by
group.</p>
</td></tr> <tr><td><code>frailty.pred.subgroup</code></td>
<td>
<p>empirical Bayes prediction of the
frailty term by subgroup.</p>
</td></tr> <tr><td><code>linear.pred</code></td>
<td>
<p>linear predictor: uses &quot;Beta'X
+ log v_i.w_ij&quot;.</p>
</td></tr> <tr><td><code>subgbyg</code></td>
<td>
<p>subgroup by group.</p>
</td></tr> <tr><td><code>n.strat</code></td>
<td>
<p>A vector
with the number of covariates of each type of hazard function as
components.</p>
</td></tr> <tr><td><code>alpha_p.value</code></td>
<td>
<p>p-value of the Wald test for the estimated
variance of the cluster effect.</p>
</td></tr> <tr><td><code>eta_p.value</code></td>
<td>
<p>p-value of the Wald test
for the estimated variance of the subcluster effect.</p>
</td></tr>
</table>
<p>The following components are specific to <b>joint nested frailty</b> models.
</p>
<table role = "presentation">
<tr><td><code>theta</code></td>
<td>
<p>variance of the subcluster effect <code class="reqn">(\bold{Var}(u_{fi}))</code></p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>variance of the cluster effect <code class="reqn">(\bold{Var}(\omega_f))</code></p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the power coefficient <code class="reqn">\alpha</code> associated with the frailty
parameter (<code class="reqn">u_{fi}</code>) in the terminal event hazard function.</p>
</td></tr>
<tr><td><code>ksi</code></td>
<td>
<p>the power coefficient <code class="reqn">\xi</code> associated with the frailty
parameter (<code class="reqn">\omega_f</code>) in the recurrent event hazard function.</p>
</td></tr>
<tr><td><code>indic_alpha</code></td>
<td>
<p>indicator if a joint frailty model with <code class="reqn">\alpha</code>
parameter was fitted or not.</p>
</td></tr> <tr><td><code>indic_ksi</code></td>
<td>
<p>indicator if a joint frailty
model with <code class="reqn">\xi</code> parameter was fitted or not.</p>
</td></tr>
<tr><td><code>frailty.fam.pred</code></td>
<td>
<p>empirical Bayes prediction of the frailty term by
family.</p>
</td></tr> <tr><td><code>eta_p.value</code></td>
<td>
<p>p-value of the Wald test for the estimated
variance of the cluster effect.</p>
</td></tr> <tr><td><code>alpha_p.value</code></td>
<td>
<p>p-value of the Wald
test for the estimated power coefficient <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>ksi_p.value</code></td>
<td>
<p>p-value of the Wald test for the estimated power
coefficient <code class="reqn">\xi</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>From a prediction aim, we recommend you to input a data sorted by the group
variable with numerical numbers from 1 to n (number of groups). In case of a
nested model, we recommend you to input a data sorted by the group variable
then sorted by the subgroup variable both with numerical numbers from 1 to n
(number of groups) and from 1 to m (number or subgroups). &quot;kappa&quot; and
&quot;n.knots&quot; are the arguments that the user have to change if the fitted model
does not converge. &quot;n.knots&quot; takes integer values between 4 and 20. But with
n.knots=20, the model would take a long time to converge. So, usually, begin
first with n.knots=7, and increase it step by step until it converges.
&quot;kappa&quot; only takes positive values. So, choose a value for kappa (for
instance 10000), and if it does not converge, multiply or divide this value
by 10 or 5 until it converges.
</p>


<h3>References</h3>

<p>I. Jazic, S. Haneuse, B. French, G. MacGrogan, and V. Rondeau.
Design and analysis of nested case-control studies for recurrent events
subject to a terminal event. <em>Submitted</em>.
</p>
<p>A. Krol, A. Mauguen, Y. Mazroui, A. Laurent, S. Michiels and V. Rondeau
(2017). Tutorial in Joint Modeling and Prediction: A Statistical Software
for Correlated Longitudinal Outcomes, Recurrent Events and a Terminal Event.
<em>Journal of Statistical Software</em> <b>81</b>(3), 1-52.
</p>
<p>V. Rondeau, Y. Mazroui and J. R. Gonzalez (2012). Frailtypack: An R package
for the analysis of correlated survival data with frailty models using
penalized likelihood estimation or parametric estimation. <em>Journal of
Statistical Software</em> <b>47</b>, 1-28.
</p>
<p>Y. Mazroui, S. Mathoulin-Pelissier, P. Soubeyranb and V. Rondeau (2012)
General joint frailty model for recurrent event data with a dependent
terminalevent: Application to follicular lymphoma data. <em>Statistics in
Medecine</em>, <b>31</b>, 11-12, 1162-1176.
</p>
<p>V. Rondeau, J.P. Pignon, S. Michiels (2011). A joint model for the
dependance between clustered times to tumour progression and deaths: A
meta-analysis of chemotherapy in head and neck cancer. <em>Statistical
methods in medical research</em> <b>897</b>, 1-19.
</p>
<p>V. Rondeau, S. Mathoulin-Pellissier, H. Jacqmin-Gadda, V. Brouste, P.
Soubeyran (2007). Joint frailty models for recurring events and death using
maximum penalized likelihood estimation:application on cancer events.
<em>Biostatistics</em> <b>8</b>,4, 708-721.
</p>
<p>V. Rondeau, L. Filleul, P. Joly (2006). Nested frailty models using maximum
penalized likelihood estimation. <em>Statistics in Medicine</em>, <b>25</b>,
4036-4052.
</p>
<p>V. Rondeau, D. Commenges, and P. Joly (2003). Maximum penalized likelihood
estimation in a gamma-frailty model. <em>Lifetime Data Analysis</em> <b>9</b>,
139-153.
</p>
<p>C.A. McGilchrist, and C.W. Aisbett (1991). Regression with frailty in
survival analysis. <em>Biometrics</em> <b>47</b>, 461-466.
</p>
<p>D. Marquardt (1963). An algorithm for least-squares estimation of nonlinear
parameters. <em>SIAM Journal of Applied Mathematics</em>, 431-441.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SurvIC">SurvIC</a></code>, <code><a href="#topic+cluster">cluster</a></code>,
<code><a href="#topic+subcluster">subcluster</a></code>, <code><a href="#topic+terminal">terminal</a></code>, <code><a href="#topic+num.id">num.id</a></code>,
<code><a href="#topic+timedep">timedep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



###---  COX proportional hazard model (SHARED without frailties) ---###
###---  estimated with penalized likelihood ---###

data(kidney)
frailtyPenal(Surv(time,status)~sex+age,
n.knots=12,kappa=10000,data=kidney)

###---  Shared Frailty model  ---###

frailtyPenal(Surv(time,status)~cluster(id)+sex+age,
n.knots=12,kappa=10000,data=kidney)

#-- with an initialisation of regression coefficients

frailtyPenal(Surv(time,status)~cluster(id)+sex+age,
n.knots=12,kappa=10000,data=kidney,init.B=c(-1.44,0))

#-- with truncated data

data(dataNested)

frailtyPenal(Surv(t1,t2,event) ~ cluster(group),
data=dataNested,n.knots=10,kappa=10000,
cross.validation=TRUE,recurrentAG=FALSE)

#-- stratified analysis

data(readmission)
frailtyPenal(Surv(time,event)~cluster(id)+dukes+strata(sex),
n.knots=10,kappa=c(10000,10000),data=readmission)

#-- recurrentAG=TRUE

frailtyPenal(Surv(t.start,t.stop,event)~cluster(id)+sex+dukes+
charlson,data=readmission,n.knots=6,kappa=1e5,recurrentAG=TRUE)

#-- cross.validation=TRUE

frailtyPenal(Surv(t.start,t.stop,event)~cluster(id)+sex+dukes+
charlson,data=readmission,n.knots=6,kappa=5000,recurrentAG=TRUE,
cross.validation=TRUE)

#-- log-normal distribution

frailtyPenal(Surv(t.start,t.stop,event)~cluster(id)+sex+dukes+
charlson,data=readmission,n.knots=6,kappa=5000,recurrentAG=TRUE,
RandDist="LogN")

###--- Joint Frailty model (recurrent and terminal events) ---###

data(readmission)
#-- Gap-time
modJoint.gap &lt;- frailtyPenal(Surv(time,event)~cluster(id)+sex+dukes+charlson+
terminal(death),formula.terminalEvent=~sex+dukes+charlson,
data=readmission,n.knots=14,kappa=c(9.55e+9,1.41e+12),
recurrentAG=FALSE)

#-- Calendar time
modJoint.calendar &lt;- frailtyPenal(Surv(t.start,t.stop,event)~cluster(id)+
sex+dukes+charlson+terminal(death),formula.terminalEvent=~sex
+dukes+charlson,data=readmission,n.knots=10,kappa=c(9.55e9,1.41e12),
recurrentAG=TRUE)

#-- without alpha parameter
modJoint.gap &lt;- frailtyPenal(Surv(time,event)~cluster(id)+sex+dukes+charlson+
terminal(death),formula.terminalEvent=~sex+dukes+charlson,
data=readmission,n.knots=10,kappa=c(9.55e9,1.41e12),
recurrentAG=FALSE,Alpha="None")

#-- log-normal distribution

modJoint.log &lt;- frailtyPenal(Surv(t.start,t.stop,event)~cluster(id)+sex
+dukes+charlson+terminal(death),formula.terminalEvent=~sex
+dukes+charlson,data=readmission,n.knots=10,kappa=c(9.55e9,1.41e12),
recurrentAG=TRUE,RandDist="LogN")

###--- Joint frailty model for NCC data ---###
data(dataNCC)
modJoint.ncc &lt;- frailtyPenal(Surv(t.start,t.stop,event)~cluster(id)+cov1
+cov2+terminal(death)+wts(ncc.wts), formula.terminalEvent=~cov1+cov2,
data=dataNCC,n.knots=8,kappa=c(1.6e+10, 5.0e+03),recurrentAG=TRUE, RandDist="LogN") 


###--- Joint Frailty model for clustered data ---###

#-- here is generated cluster (5 clusters)
readmission &lt;- transform(readmission,group=id%%5+1)

#-- exclusion all recurrent events --#
#--  to obtain framework of semi-competing risks --#
readmission2 &lt;- subset(readmission, (t.start == 0 &amp; event == 1) | event == 0)

joi.clus.gap &lt;- frailtyPenal(Surv(time,event)~cluster(group)+
num.id(id)+dukes+charlson+sex+chemo+terminal(death),
formula.terminalEvent=~dukes+charlson+sex+chemo,
data=readmission2,recurrentAG=FALSE, n.knots=8,
kappa=c(1.e+10,1.e+10) ,Alpha="None")


###--- General Joint model (recurrent and terminal events) 
###--- with 2 covariates ---###

data(readmission)
modJoint.general &lt;- frailtyPenal(Surv(time,event) ~ cluster(id) + dukes +
charlson + sex  + chemo + terminal(death), 
formula.terminalEvent = ~ dukes + charlson + sex + chemo,
data = readmission, jointGeneral = TRUE,  n.knots = 8, 
kappa = c(2.11e+08, 9.53e+11))


###--- Nested Frailty model ---###

##***** WARNING *****##
# Data should be ordered according to cluster and subcluster

data(dataNested)
modClu &lt;- frailtyPenal(Surv(t1,t2,event)~cluster(group)+
subcluster(subgroup)+cov1+cov2,data=dataNested,
n.knots=8,kappa=50000)

modClu.str &lt;- frailtyPenal(Surv(t1,t2,event)~cluster(group)+
subcluster(subgroup)+cov1+strata(cov2),data=dataNested,
n.knots=8,kappa=c(50000,50000))


## Not run: 
###--- Joint Nested Frailty model ---###

#-- here is generated cluster (30 clusters)
readmissionNested &lt;- transform(readmission,group=id%%30+1)

modJointNested_Splines &lt;- frailtyPenal(formula = Surv(t.start, t.stop, event) 
~ subcluster(id) + cluster(group) + dukes + terminal(death), 
formula.terminalEvent = ~dukes, data = readmissionNested, recurrentAG = TRUE, 
n.knots = 8, kappa = c(9.55e+9, 1.41e+12), initialize = TRUE)

modJointNested_Weib &lt;- frailtyPenal(Surv(t.start,t.stop,event)~subcluster(id)
+cluster(group)+dukes+ terminal(death),formula.terminalEvent=~dukes, 
hazard = ('Weibull'), data=readmissionNested,recurrentAG=TRUE, initialize = FALSE)

JoiNesGapSpline &lt;- frailtyPenal(formula = Surv(time, event) 
~ subcluster(id) + cluster(group) + dukes + terminal(death), 
formula.terminalEvent = ~dukes, data = readmissionNested, 
recurrentAG = FALSE, n.knots = 8, kappa = c(9.55e+9, 1.41e+12), 
initialize = TRUE, init.Alpha = 1.091, Ksi = "None")

## End(Not run)


</code></pre>

<hr>
<h2 id='gastadj'>Advanced Gastric Cancer dataset</h2><span id='topic+gastadj'></span>

<h3>Description</h3>

<p>This meta-analysis was carried out by the GASTRIC (Global Advanced/Adjuvant Stomach 
Tumor Research international Collaboration) group, using individual data on patients 
with curatively resected gastric cancer. Data from all published randomized trials, 
with a patient recruitment end date before 2004, and comparing adjuvant chemotherapy 
with surgery alone for resectable gastric cancers, were searched electronically. 
The candidate surrogate endpoint <b>S</b> was Desease-free survival time, defined 
as the time (in days) to relapse, second cancer or dead from any cause. The true 
endpoint <b>T</b> was the overall survival time, defined as the time (in days) from 
randomization to death of any cause or to the last follow-up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gastadj)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: 
</p>

<dl>
<dt>trialID</dt><dd><p>The trial in which the patient was treated</p>
</dd>
<dt>patientID</dt><dd><p>The identification number of a patient</p>
</dd> 
<dt>trt</dt><dd><p>The treatment indicator, coded as 0 = Control and 1 = Experimental</p>
</dd>
<dt>timeS</dt><dd><p>The candidate surrogate (progression-free survival in days) </p>
</dd>
<dt>statusS</dt><dd><p>Censoring indicator for for Progression-free survival 
(0 = alive and progression-free, 1 = with progression or dead)</p>
</dd>
<dt>timeT</dt><dd><p>The true endpoint (overall survival time in days)</p>
</dd>
<dt>statusT</dt><dd><p>Censoring indicator for survival time (0 = alive, 1 = dead)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Oba K, Paoletti X, Alberts S, Bang YJ, Benedetti J, Bleiberg H, Catalona P, 
Lordick F, Michiels S, Morita A, Okashi Y, Pignon JP, Rougier P, Sasako M, 
Sakamoto J, Sargent D, Shitara K, Van Cutsem E, Buyse M, Burzykowski T on 
behalf of the GASTRIC group (2013). Disease-Free Survival as a Surrogate 
for Overall Survival in Adjuvant Trials of Gastric Cancer: A Meta-Analysis. 
<em>JNCI: Journal of the National Cancer Institute</em>;<b>105(21)</b>:1600-1607
</p>

<hr>
<h2 id='GenfrailtyPenal'>Fit a Shared or a Joint Frailty Generalized Survival Model</h2><span id='topic+GenfrailtyPenal'></span>

<h3>Description</h3>


<p><b>I. SHARED FRAILTY GENERALIZED SURVIVAL MODELS</b>
</p>
<p>Fit a gamma Shared Frailty Generalized Survival Model using 
a parametric estimation, or a semi-parametric penalized likelihood estimation.
Right-censored data and strata (up to 6 levels) are allowed. 
It allows to obtain a parametric or flexible semi-parametric smooth 
hazard and survival functions.
</p>
<p>Each frailty term <code class="reqn">u</code><sub>i</sub> is assumed 
to act multiplicatively on the hazard function, and to be drawn from a 
Gamma distribution with unit mean and variance <code class="reqn">\theta</code>.
Conditional on the frailty term, the hazard function for the 
<code class="reqn">j</code><sup>th</sup> subject in the <code class="reqn">i</code><sup>th</sup> group 
is then expressed by
</p>
<p><img src="../help/figures/gsm1.png" width="70%" alt="gsm1.png" />
</p>
<p>where <b><code class="reqn">x</code></b><sub>ij</sub> 
is a collection of baseline covariates, 
<b><code class="reqn">\xi</code></b> is a vector of parameters, and 
<code class="reqn">\lambda</code><sub>ij</sub>
(<code class="reqn">t</code> | <b><code class="reqn">x</code></b><sub>ij</sub> ; <b><code class="reqn">\xi</code></b>) 
is the hazard function for an average value of the frailty.
The associated conditional survival function writes
</p>
<p><img src="../help/figures/gsm2.png" width="70%" alt="gsm2.png" />
</p>
<p>where 
<code class="reqn">S</code><sub>ij</sub>
(<code class="reqn">t</code> | <b><code class="reqn">x</code></b><sub>ij</sub> ; <b><code class="reqn">\xi</code></b>)
designates the survival function for an average value of the frailty.
</p>
<p>Following Liu et al. (2017, 2018), the latter function is expressed in terms of 
a link function <code class="reqn">g</code>(.) and a linear predictor 
<code class="reqn">\eta</code><sub>ij</sub>
(<code class="reqn">t</code>, <b><code class="reqn">x</code></b><sub>ij</sub>; <b><code class="reqn">\xi</code></b>) 
such that 
<code class="reqn">g</code>[<code class="reqn">S</code><sub>ij</sub>
(<code class="reqn">t</code> | <b><code class="reqn">x</code></b><sub>ij</sub> ; <b><code class="reqn">\xi</code></b>)] 
= 
<code class="reqn">\eta</code><sub>ij</sub>
(<code class="reqn">t</code>, <b><code class="reqn">x</code></b><sub>ij</sub>; <b><code class="reqn">\xi</code></b>), 
i.e. 
<code class="reqn">S</code><sub>ij</sub>
(<code class="reqn">t</code> | <b><code class="reqn">x</code></b><sub>ij</sub> ; <b><code class="reqn">\xi</code></b>) 
= 
<code class="reqn">h</code>[<code class="reqn">\eta</code><sub>ij</sub>
(<code class="reqn">t</code>, <b><code class="reqn">x</code></b><sub>ij</sub>; <b><code class="reqn">\xi</code></b>)]
with <code class="reqn">h</code>() = <code class="reqn">g</code><sup>-1</sup>().
</p>
<p>The conditional survival function is finally modeled by
</p>
<p><img src="../help/figures/gsm3.png" width="70%" alt="gsm3.png" />
</p>
<p>The table below summarizes the most commonly used (inverse) link functions and 
their associated conditional survival, hazard and cumulative hazard functions.
PHM stands for &quot;Proportional Hazards Model&quot;, 
POM for &quot;Proportional Odds Model, 
PROM for &quot;Probit Model&quot; and AHM for &quot;Additive Hazards Model&quot;.
</p>
<p><img src="../help/figures/gsm4.png" width="100%" alt="gsm4.png" />
</p>
<p><b>I.(a) Fully parametric case</b>
</p>
<p>In the fully parametric case, linear predictors considered are of the form
</p>
<p><img src="../help/figures/gsm5.png" width="70%" alt="gsm5.png" />
</p>
<p>where <code class="reqn">\rho &gt; 0</code> is a shape parameter, 
<code class="reqn">\gamma &gt; 0</code> a scale parameter, 
<b><code class="reqn">\beta</code></b> a vector of regression coefficients, 
and <b><code class="reqn">\xi</code></b> = (<code class="reqn">\rho</code> ,<code class="reqn">\gamma</code>, <b><code class="reqn">\beta</code></b>).
With the appropriate link function, such linear parametric predictors 
make it possible to recover 
a Weibull baseline survival function for PHMs and AHMs, 
a log-logistic baseline survival function for POMs, 
and a log-normal one for PROMs. 
</p>
<p><b>I. (b) Flexible semi-parametric case</b>
</p>
<p>For PHM and AHM, a more flexible splines-based approach is proposed for 
modeling the baseline hazard function and time-varying regression coefficients.
In this case, conditional on the frailty term <code class="reqn">u</code><sub>i</sub>, 
the hazard function for the <code class="reqn">j</code><sup>th</sup> subject 
in the <code class="reqn">i</code><sup>th</sup> group is still expressed by
<code class="reqn">\lambda</code><sub>ij</sub>
(<code class="reqn">t</code> | <b><code class="reqn">x</code></b><sub>ij</sub>, <code class="reqn">u</code><sub>i</sub> ; 
<b><code class="reqn">\xi</code></b>) 
= <code class="reqn">u</code><sub>i</sub> 
<code class="reqn">\lambda</code><sub>ij</sub>
(<code class="reqn">t</code> | <b><code class="reqn">x</code></b><sub>ij</sub> ; <b><code class="reqn">\xi</code></b>), 
but we have this time 
</p>
<p><img src="../help/figures/gsm6.png" width="70%" alt="gsm6.png" />
</p>
<p>The smoothness of baseline hazard function <code class="reqn">\lambda</code><sub>0</sub>() 
is ensured by penalizing the log-likelihood by a term which has 
large values for rough functions. 
</p>
<p>Moreover, for parametric and flexible semi-parametric AHMs, the 
log-likelihood is constrained to ensure the strict positivity of the hazards, 
since the latter is not naturally guaranteed by the model.
</p>
<p><b>II. JOINT FRAILTY GENERALIZED SURVIVAL MODELS</b>
</p>
<p>Fit a gamma Joint Frailty Generalized Survival Model for recurrent and
terminal events using a parametric estimation, 
or a semi-parametric penalized likelihood estimation. 
Right-censored data and strata (up to 6 levels) for the recurrent event part 
are allowed. 
Joint frailty models allow studying, jointly, survival processes
of recurrent and terminal events, by considering the terminal event as an
informative censoring.
</p>
<p>This model includes an common patient-specific frailty term 
<code class="reqn">u</code><sub>i</sub> for the two survival functions which will 
take into account the unmeasured heterogeneity in the data, 
associated with unobserved covariates. 
The frailty term acts differently for the two survival functions 
(<code class="reqn">u</code><sub>i</sub> for the recurrent survival function and 
<code class="reqn">u</code><sub>i</sub><sup>&#945;</sup> for the death one). 
The covariates could be different for the recurrent and terminal event parts.
</p>
<p><b>II.(a) Fully parametric case</b>
</p>
<p>For the <code class="reqn">j</code><sup>th</sup> recurrence (j=1,...,n<sub>i</sub>) 
and the <code class="reqn">i</code><sup>th</sup> patient (i=1,...,N), 
the gamma Joint Frailty Generalized Survival Model 
for recurrent event survival function 
<code class="reqn">S</code><sub>Rij</sub>(.) and death survival function 
<code class="reqn">S</code><sub>Di</sub>(.) is
</p>
<p><img src="../help/figures/gsm7.png" width="70%" alt="gsm7.png" />
</p>
<p>- <code class="reqn">\eta</code><sub>Rij</sub> (resp. <code class="reqn">\eta</code><sub>Di</sub>) 
is the linear predictor for the recurrent (resp. terminal) event process.
The form of these linear predictors is the same as the one presented in I.(a).
</p>
<p>- <code class="reqn">h</code><sub>R</sub>(.) (resp. <code class="reqn">h</code><sub>D</sub>(.)) 
is the inverse link function associated with 
recurrent events (resp. terminal event).
</p>
<p>- <b><code class="reqn">x</code></b><sub>Rij</sub> and <b><code class="reqn">x</code></b><sub>Di</sub>
are two vectors of baseline covariates associated with 
recurrent and terminal events.
</p>
<p>- <b><code class="reqn">\xi</code></b><sub>R</sub> and <b><code class="reqn">\xi</code></b><sub>D</sub> 
are the parameter vectors for recurrent and terminal events.
</p>
<p>- <code class="reqn">\alpha</code> is a parameter allowing more flexibility in the association 
between recurrent and terminal events processes.
</p>
<p>- The random frailties <code class="reqn">u</code><sub>i</sub> are still assumed iid and 
drown from a <code class="reqn">\Gamma</code>(1/<code class="reqn">\theta</code>,1/<code class="reqn">\theta</code>).
</p>
<p><b>II.(b) Flexible semi-parametric case</b>
</p>
<p>If one chooses to fit a PHM or an AHM for recurrent and/or terminal events, 
a splines-based approach for modeling baseline hazard functions 
and time-varying regression coefficients is still available. 
In this approach, the submodel for recurrent events is expressed as
<code class="reqn">\lambda</code><sub>Rij</sub>
(<code class="reqn">t</code> | <b><code class="reqn">x</code></b><sub>Rij</sub>, <code class="reqn">u</code><sub>i</sub> ; 
<b><code class="reqn">\xi</code></b><sub>R</sub>) 
= <code class="reqn">u</code><sub>i</sub> 
<code class="reqn">\lambda</code><sub>Rij</sub>
(<code class="reqn">t</code> | <b><code class="reqn">x</code></b><sub>Rij</sub> ; 
<b><code class="reqn">\xi</code></b><sub>R</sub>), where 
</p>
<p><img src="../help/figures/gsm8.png" width="70%" alt="gsm8.png" />
</p>
<p>The submodel for terminal event is expressed as
<code class="reqn">\lambda</code><sub>Di</sub>
(<code class="reqn">t</code> | <b><code class="reqn">x</code></b><sub>Di</sub>, <code class="reqn">u</code><sub>i</sub> ; 
<b><code class="reqn">\xi</code></b><sub>D</sub>) 
= <code class="reqn">u</code><sub>i</sub><sup>&#945;</sup> 
<code class="reqn">\lambda</code><sub>Di</sub>
(<code class="reqn">t</code> | <b><code class="reqn">x</code></b><sub>Di</sub> ; 
<b><code class="reqn">\xi</code></b><sub>D</sub>), where 
</p>
<p><img src="../help/figures/gsm9.png" width="70%" alt="gsm9.png" />
</p>
<p>Baseline hazard functions 
<code class="reqn">\lambda</code><sub>R0</sub>(.) and <code class="reqn">\lambda</code><sub>D0</sub>(.)
are estimated using cubic M-splines (of order 4) 
with positive coefficients, and the time-varying coefficients 
<code class="reqn">\beta</code><sub>R</sub>(.) and <code class="reqn">\beta</code><sub>D</sub>(.)
are estimated using B-splines of order q.
</p>
<p>The smoothness of baseline hazard functions
is ensured by penalizing the log-likelihood by two terms 
which has large values for rough functions. 
</p>
<p>Moreover, 
if one chooses an AHM for recurrent and/or terminal event submodel,
the log-likelihood is constrained to ensure 
the strict positivity of the hazards, 
since the latter is not naturally guaranteed by the model.
</p>





<h3>Usage</h3>

<pre><code class='language-R'>GenfrailtyPenal(formula, formula.terminalEvent, data, recurrentAG = FALSE,
family, hazard = "Splines", n.knots, kappa, betaknots = 1, betaorder = 3,
RandDist = "Gamma", init.B, init.Theta, init.Alpha, Alpha, maxit = 300, 
nb.gh, nb.gl, LIMparam = 1e-3, LIMlogl = 1e-3, LIMderiv = 1e-3, print.times = TRUE, 
cross.validation, jointGeneral, nb.int, initialize, init.Ksi, Ksi, init.Eta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenfrailtyPenal_+3A_formula">formula</code></td>
<td>
<p>A formula object, with the response on the left of a
<code class="reqn">\sim</code> operator, and the terms on the right. The response must be a
survival object as returned by the '<code>Surv</code>' function 
like in survival package. Interactions are possible using ' * ' or ' : '.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_formula.terminalevent">formula.terminalEvent</code></td>
<td>
<p>Only for joint frailty models: a formula object,
only requires terms on the right to indicate which variables are used for 
the terminal event.  Interactions are possible using ' * ' or ' : '.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_data">data</code></td>
<td>
<p>A 'data.frame' with the variables used in '<code>formula</code>'.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_recurrentag">recurrentAG</code></td>
<td>
<p>Logical value. Is Andersen-Gill model fitted? If so
indicates that recurrent event times with the counting process approach of
Andersen and Gill is used. This formulation can be used for dealing with
time-dependent covariates. The default is FALSE.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_family">family</code></td>
<td>
<p>Type of Generalized Survival Model to fit.
<code>"PH"</code> for a proportional hazards model, 
<code>"AH"</code> for an additive hazards model,
<code>"PO"</code> for a proportional odds model and 
<code>"probit"</code> for a probit model. 
A vector of length 2 is expected for joint models 
(e.g., <code>family=c("PH","PH")</code>).</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_hazard">hazard</code></td>
<td>
<p>Type of hazard functions: 
<code>"Splines"</code> for semi-parametric hazard functions using equidistant 
intervals, or <code>"parametric"</code> for parametric distribution functions.
In case of <code>family="PH"</code> or <code>family="AH"</code>, 
the <code>"parametric"</code> option corresponds to a Weibull distribution. 
In case of <code>family="PO"</code> and <code>family="probit"</code>, 
the <code>"parametric"</code> option corresponds to a log-logistic 
and a log-normal distribution, respectively. 
So far, the <code>"Splines"</code> option is only available for PH and AH submodels. 
Default is <code>"Splines"</code>.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_n.knots">n.knots</code></td>
<td>
<p>Integer giving the number of knots to use. Value required in
the penalized likelihood estimation.  It corresponds to the <code>n.knots+2</code>
splines functions for the approximation of the hazard or the survival
functions. We estimate I- or M-splines of order 4. When the user set a
number of knots equals to <code>k</code> (i.e. <code>n.knots=k</code>),
then the number of interior knots is <code>k-2</code> and the number of splines is 
<code>(k-2)+order</code>. Number of knots must be between 4 and 20. (See Note)</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_kappa">kappa</code></td>
<td>
<p>Positive smoothing parameter in the penalized likelihood
estimation. The coefficient kappa tunes the intensity of the penalization 
(the integral of the squared second derivative of hazard function).
In a stratified shared model, this argument must be a vector
with kappas for both strata. In a stratified joint model, this argument
must be a vector with kappas for both strata for recurrent events plus one
kappa for terminal event.  
We advise the user to identify several possible tuning
parameters, note their defaults and look at the sensitivity of the results
to varying them. Value required. (See Note).</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_betaknots">betaknots</code></td>
<td>
<p>Number of inner knots used for the 
B-splines time-varying coefficient estimation. Default is 1. 
See '<code>timedep</code>' function for more details.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_betaorder">betaorder</code></td>
<td>
<p>Order of the B-splines used for the 
time-varying coefficient estimation. 
Default is cubic B-splines (<code>order=3</code>). 
See '<code>timedep</code>' function for more details. 
Not implemented for Proportional Odds and Probit submodels.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_randdist">RandDist</code></td>
<td>
<p>Type of random effect distribution: 
<code>"Gamma"</code> for a gamma distribution, 
and <code>"LogN"</code> for a log-normal distribution (not implemented yet).
Default is <code>"Gamma"</code>.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_init.b">init.B</code></td>
<td>
<p>A vector of initial values for regression coefficients. This
vector should be of the same size as the whole vector of covariates with the
first elements for the covariates related to the recurrent events and then
to the terminal event (interactions in the end of each component). Default
is 0.1 for each (for Generalized Survival and Shared Frailty Models) 
or 0.5 (for Generalized Joint Frailty Models).</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_init.theta">init.Theta</code></td>
<td>
<p>Initial value for frailty variance.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_init.alpha">init.Alpha</code></td>
<td>
<p>Only for Generalized Joint Frailty Models: 
initial value for parameter alpha.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_alpha">Alpha</code></td>
<td>
<p>Only for Generalized Joint Frailty Models: 
input &quot;None&quot; so as to fit a joint model without the parameter alpha.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for the Marquardt algorithm.
Default is 300</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_nb.gh">nb.gh</code></td>
<td>
<p>Number of nodes for the Gaussian-Hermite quadrature.
It can be chosen among 5, 7, 9, 12, 15, 20 and 32. 
The default is 20 if <code>hazard="Splines"</code>, 32 otherwise.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_nb.gl">nb.gl</code></td>
<td>
<p>Number of nodes for the Gaussian-Laguerre quadrature.
It can be chosen between 20 and 32. 
The default is 20 if <code>hazard="Splines"</code>, 32 otherwise.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_limparam">LIMparam</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
parameters (see Details), <code class="reqn">10</code><sup>-3</sup> by default.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_limlogl">LIMlogl</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
log-likelihood (see Details), <code class="reqn">10</code><sup>-3</sup> by default.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_limderiv">LIMderiv</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
gradient (see Details), <code class="reqn">10</code><sup>-3</sup> by default.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_print.times">print.times</code></td>
<td>
<p>A logical parameter to print iteration process. Default
is TRUE.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_cross.validation">cross.validation</code></td>
<td>
<p>Not implemented yet for the generalized settings.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_jointgeneral">jointGeneral</code></td>
<td>
<p>Not implemented yet for the generalized settings.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_nb.int">nb.int</code></td>
<td>
<p>Not implemented yet for the generalized settings.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_initialize">initialize</code></td>
<td>
<p>Not implemented yet for the generalized settings.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_init.ksi">init.Ksi</code></td>
<td>
<p>Not implemented yet for the generalized settings.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_ksi">Ksi</code></td>
<td>
<p>Not implemented yet for the generalized settings.</p>
</td></tr>
<tr><td><code id="GenfrailtyPenal_+3A_init.eta">init.Eta</code></td>
<td>
<p>Not implemented yet for the generalized settings.</p>
</td></tr>
</table>


<h3>Details</h3>


<p><b>TYPICAL USES</b>
</p>
<p>For a Generalized Survival Model:
</p>
<pre>GenfrailtyPenal(
formula=Surv(time,event)~var1+var2, 
data, family, \dots)</pre>
<p>For a Shared Frailty Generalized Survival Model:
</p>
<pre>GenfrailtyPenal(
formula=Surv(time,event)~cluster(group)+var1+var2, 
data, family, \dots)</pre>
<p>For a Joint Frailty Generalized Survival Model:
</p>
<pre>GenfrailtyPenal(
formula=Surv(time,event)~cluster(group)+var1+var2+var3+terminal(death), 
formula.terminalEvent= ~var1+var4, 
data, family, \dots)</pre>
<p><b>OPTIMIZATION ALGORITHM</b>
</p>
<p>The estimated parameters are obtained using the robust Marquardt algorithm
(Marquardt, 1963) which is a combination between a Newton-Raphson algorithm
and a steepest descent algorithm. The iterations are stopped when 
the difference between two consecutive log-likelihoods is small 
(<code class="reqn">&lt;10</code><sup>-3</sup>), 
the estimated coefficients are stable 
(consecutive values <code class="reqn">&lt;10</code><sup>-3</sup>, 
and the gradient small enough (<code class="reqn">&lt;10</code><sup>-3</sup>). 
When the frailty variance is small, numerical problems may arise. 
To solve this problem, an alternative formula of the penalized log-likelihood 
is used (see Rondeau, 2003 for further details). 
For Proportional Hazards and Additive Hazards submodels, 
cubic M-splines of order 4 can be used to estimate the hazard function. 
In this case, I-splines (integrated M-splines) are used to compute the
cumulative hazard function.
</p>
<p>The inverse of the Hessian matrix is the variance estimator. 
To deal with the positivity constraint of the variance component and the 
spline coefficients, a squared transformation is used and the standard errors 
are computed by the <code class="reqn">\Delta</code>-method (Knight &amp; Xekalaki, 2000). 
The integrations in the full log likelihood are evaluated using 
Gaussian quadrature. Laguerre polynomials with 20 points are used to treat 
the integrations on <code class="reqn">[0,\infty[</code>.
</p>
<p><b>INITIAL VALUES</b>
</p>
<p>In case of a shared frailty model, 
the splines and the regression coefficients are initialized to 0.1. 
The program fits, firstly, an adjusted Cox model to give new initial values 
for the splines and the regression coefficients. 
The variance of the frailty term <code class="reqn">\theta</code> is initialized to 0.1. 
Then, a shared frailty model is fitted.
</p>
<p>In case of a joint frailty model, 
the splines and the regression coefficients are initialized to 0.5. 
The program fits firstly, an adjusted Cox model to have new initial values 
for the splines and the regression coefficients.
The variance of the frailty term <code class="reqn">\theta</code> and the association parameter
<code class="reqn">\alpha</code> are initialized to 1.
Then, a joint frailty model is fitted.
</p>



<h3>Value</h3>

<p>The following components are included in a 'frailtyPenal' object for each
model.
</p>
<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>Sequence of the corresponding estimation of the coefficients for
the hazard functions (parametric or semiparametric), the random effects
variances and the regression coefficients.</p>
</td></tr> 
<tr><td><code>call</code></td>
<td>
<p>The code used for the model.</p>
</td></tr> 
<tr><td><code>formula</code></td>
<td>
<p>The formula part of the code used for the model.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations used in the fit.</p>
</td></tr> 
<tr><td><code>groups</code></td>
<td>
<p>The maximum number of groups used in the fit.</p>
</td></tr> 
<tr><td><code>n.events</code></td>
<td>
<p>The number of events observed in the fit.</p>
</td></tr>
<tr><td><code>n.eventsbygrp</code></td>
<td>
<p>A vector of length the number of groups 
giving the number of observed events in each group.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The marginal log-likelihood in the parametric case.</p>
</td></tr>
<tr><td><code>loglikPenal</code></td>
<td>
<p>The marginal penalized log-likelihood 
in the semiparametric case.</p>
</td></tr>  
<tr><td><code>coef</code></td>
<td>
<p>The regression coefficients.</p>
</td></tr> 
<tr><td><code>varH</code></td>
<td>
<p>The variance matrix of 
the regression coefficients before positivity constraint transformation. 
Then, the delta method is needed to obtain the estimated variance parameters. 
That is why some variances don't match with 
the printed values at the end of the model.</p>
</td></tr> 
<tr><td><code>varHtotal</code></td>
<td>
<p>The variance matrix of 
all the parameters before positivity constraint transformation. 
Then, the delta method is needed to obtain the estimated variance parameters. 
That is why some variances don't match with 
the printed values at the end of the model.</p>
</td></tr> 
<tr><td><code>varHIH</code></td>
<td>
<p>The robust estimation of 
the variance matrix of the regression coefficients</p>
</td></tr> 
<tr><td><code>varHIHtotal</code></td>
<td>
<p>The robust estimation of 
the variance matrix of all parameters.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Matrix of times where the hazard functions are estimated.</p>
</td></tr> 
<tr><td><code>xSu</code></td>
<td>
<p>Matrix of times where the survival functions are estimated.</p>
</td></tr> 
<tr><td><code>lam</code></td>
<td>
<p>Array (dim=3) of baseline hazard estimates 
and confidence bands.</p>
</td></tr>
<tr><td><code>surv</code></td>
<td>
<p>Array (dim=3) of baseline survival estimates 
and confidence bands.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Character string specifying the type of censoring, 
see the <code>Surv</code> function for more details.</p>
</td></tr>
<tr><td><code>n.strat</code></td>
<td>
<p>Number of strata.</p>
</td></tr>
<tr><td><code>n.iter</code></td>
<td>
<p>Number of iterations needed to converge.</p>
</td></tr> 
<tr><td><code>median</code></td>
<td>
<p>The value of the median survival and its confidence bands. 
If there are two strata or more, the first value corresponds to the value 
for the first strata, etc.</p>
</td></tr>
<tr><td><code>LCV</code></td>
<td>
<p>The approximated likelihood cross-validation criterion in the 
semiparametric case. 
With H (resp. H<sub>pen</sub>) the hessian matrix 
of log-likelihood (resp. penalized log-likelihood), 
EDF = H<sub>pen</sub><sup>-1</sup> H 
the effective degrees of freedom,
L(<code class="reqn">\xi</code>,<code class="reqn">\theta</code>) the log-likelihood and 
n the number of observations,
</p>
<p style="text-align: center;"><code class="reqn">LCV = 1/n x (trace(EDF) - L(\xi,\theta)).</code>
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>The Akaike information Criterion for the parametric case.
With p the number of parameters, 
n the number of observations and L(<code class="reqn">\xi</code>,<code class="reqn">\theta</code>) the log-likelihood, 
</p>
<p style="text-align: center;"><code class="reqn">AIC = 1/n x (p - L(\xi,\theta)).</code>
</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>Number of parameters.</p>
</td></tr> 
<tr><td><code>nvar</code></td>
<td>
<p>Number of explanatory variables.</p>
</td></tr> 
<tr><td><code>typeof</code></td>
<td>
<p>Indicator of the type of hazard functions computed : 
0 for &quot;Splines&quot;, 2 for &quot;parametric&quot;.</p>
</td></tr>
<tr><td><code>istop</code></td>
<td>
<p>Convergence indicator: 
1 if convergence is reached, 
2 if convergence is not reached, 
3 if the hessian matrix is not positive definite, 
4 if a numerical problem has occurred in the likelihood calculation</p>
</td></tr>
<tr><td><code>shape.param</code></td>
<td>
<p>Shape parameter for the parametric hazard function 
(a Weibull distribution is used for proportional and additive hazards models, 
a log-logistic distribution is used for proportional odds models, 
a log-normal distribution is used for probit models).</p>
</td></tr> 
<tr><td><code>scale.param</code></td>
<td>
<p>Scale parameter for the parametric hazard function.</p>
</td></tr>
<tr><td><code>Names.data</code></td>
<td>
<p>Name of the dataset.</p>
</td></tr>
<tr><td><code>Frailty</code></td>
<td>
<p>Logical value. Was model with frailties fitted ?</p>
</td></tr>
<tr><td><code>linear.pred</code></td>
<td>
<p>Linear predictor: 
<b><code class="reqn">\beta</code></b>'<b><code class="reqn">X</code></b> in the generalized survival models or 
<b><code class="reqn">\beta</code></b>'<b><code class="reqn">X</code></b> + log(<code class="reqn">u</code><sub>i</sub>)
in the shared frailty generalized survival models.</p>
</td></tr>
<tr><td><code>BetaTpsMat</code></td>
<td>
<p>Matrix of time varying-effects and confidence bands 
(the first column used for abscissa of times).</p>
</td></tr>
<tr><td><code>nvartimedep</code></td>
<td>
<p>Number of covariates with time-varying effects.</p>
</td></tr>
<tr><td><code>Names.vardep</code></td>
<td>
<p>Name of the covariates with time-varying effects.</p>
</td></tr>
<tr><td><code>EPS</code></td>
<td>
<p>Convergence criteria concerning 
the parameters, the likelihood and the gradient.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>Type of Generalized Survival Model fitted 
(0 for PH, 1 for PO, 2 for probit, 3 for AH).</p>
</td></tr>
<tr><td><code>global_chisq.test</code></td>
<td>
<p>A binary variable equals to 0 when no multivariate
Wald is given, 1 otherwise.</p>
</td></tr>
<tr><td><code>beta_p.value</code></td>
<td>
<p>p-values of the Wald test for the estimated
regression coefficients.</p>
</td></tr>  
<tr><td><code>cross.Val</code></td>
<td>
<p>Logical value. Is cross validation procedure used for 
estimating the smoothing parameters in the penalized likelihood estimation?</p>
</td></tr> 
<tr><td><code>DoF</code></td>
<td>
<p>Degrees of freedom associated with the smoothing parameter 
<code>kappa</code>.</p>
</td></tr> 
<tr><td><code>kappa</code></td>
<td>
<p>A vector with the smoothing parameters in the penalized 
likelihood estimation corresponding to each baseline function as components.</p>
</td></tr> 
<tr><td><code>n.knots</code></td>
<td>
<p>Number of knots for estimating the baseline functions in the
penalized likelihood estimation.</p>
</td></tr> 
<tr><td><code>n.knots.temp</code></td>
<td>
<p>Initial value for the number of knots.</p>
</td></tr> 
<tr><td><code>global_chisq</code></td>
<td>
<p>A vector with the values of each multivariate Wald test.</p>
</td></tr> 
<tr><td><code>dof_chisq</code></td>
<td>
<p>A vector with the degree of freedom for each multivariate 
Wald test.</p>
</td></tr>
<tr><td><code>p.global_chisq</code></td>
<td>
<p>A vector with the p-values for each global multivariate 
Wald test.</p>
</td></tr> 
<tr><td><code>names.factor</code></td>
<td>
<p>Names of the &quot;as.factor&quot; variables.</p>
</td></tr> 
<tr><td><code>Xlevels</code></td>
<td>
<p>Vector of the values that factor might have taken.</p>
</td></tr> 
</table>
<p>The following components are specific to <b>shared</b> models.
</p>
<table role = "presentation">
<tr><td><code>equidistant</code></td>
<td>
<p>Indicator for the intervals used in the spline estimation 
of baseline hazard functions : 
1 for equidistant intervals ; 0 for intervals using percentile 
(note: <code>equidistant = 2</code> in case of parametric estimation).</p>
</td></tr> 
<tr><td><code>Names.cluster</code></td>
<td>
<p>Cluster names.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Variance of the gamma frailty parameter, i.e. 
Var(<code class="reqn">u</code><sub>i</sub>).</p>
</td></tr>
<tr><td><code>varTheta</code></td>
<td>
<p>Variance of parameter <code>theta</code>.</p>
</td></tr>
<tr><td><code>theta_p.value</code></td>
<td>
<p>p-value of the Wald test for 
the estimated variance of the gamma frailty.</p>
</td></tr> 
</table>
<p>The following components are specific to <b>joint</b> models.
</p>
<table role = "presentation">
<tr><td><code>formula</code></td>
<td>
<p>The formula part of the code 
used for the recurrent events.</p>
</td></tr>
<tr><td><code>formula.terminalEvent</code></td>
<td>
<p>The formula part of the code 
used for the terminal model.</p>
</td></tr>
<tr><td><code>n.deaths</code></td>
<td>
<p>Number of observed deaths.</p>
</td></tr>
<tr><td><code>n.censored</code></td>
<td>
<p>Number of censored individuals.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Variance of the gamma frailty parameter, i.e. 
Var(<code class="reqn">u</code><sub>i</sub>).</p>
</td></tr>
<tr><td><code>indic_alpha</code></td>
<td>
<p>Indicator if a joint frailty model with 
<code class="reqn">\alpha</code> parameter was fitted.</p>
</td></tr> 
<tr><td><code>alpha</code></td>
<td>
<p>The coefficient <code class="reqn">\alpha</code> associated 
with the frailty parameter in the terminal hazard function.</p>
</td></tr>
<tr><td><code>nvar</code></td>
<td>
<p>A vector with the number of covariates 
of each type of hazard function as components.</p>
</td></tr>
<tr><td><code>nvarnotdep</code></td>
<td>
<p>A vector with the number of constant effect covariates  
of each type of hazard function as components.</p>
</td></tr> 
<tr><td><code>nvarRec</code></td>
<td>
<p>Number of recurrent explanatory variables.</p>
</td></tr> 
<tr><td><code>nvarEnd</code></td>
<td>
<p>Number of death explanatory variables.</p>
</td></tr>
<tr><td><code>noVar1</code></td>
<td>
<p>Indicator of recurrent explanatory variables.</p>
</td></tr>
<tr><td><code>noVar2</code></td>
<td>
<p>Indicator of death explanatory variables.</p>
</td></tr> 
<tr><td><code>Names.vardep</code></td>
<td>
<p>Name of the covariates with time-varying effects 
for the recurrent events.</p>
</td></tr>
<tr><td><code>Names.vardepdc</code></td>
<td>
<p>Name of the covariates with time-varying effects 
for the terminal event.</p>
</td></tr>
<tr><td><code>xR</code></td>
<td>
<p>Matrix of times where both survival and hazard function 
are estimated for the recurrent event.</p>
</td></tr> 
<tr><td><code>xD</code></td>
<td>
<p>Matrix of times for the terminal event.</p>
</td></tr> 
<tr><td><code>lamR</code></td>
<td>
<p>Array (dim=3) of hazard estimates and confidence bands
for recurrent event.</p>
</td></tr> 
<tr><td><code>lamD</code></td>
<td>
<p>The same value as <code>lamR</code> for the terminal event.</p>
</td></tr> 
<tr><td><code>survR</code></td>
<td>
<p>Array (dim=3) of baseline survival estimates and
confidence bands for recurrent event.</p>
</td></tr> 
<tr><td><code>survD</code></td>
<td>
<p>The same value as <code>survR</code> for the terminal event.</p>
</td></tr> 
<tr><td><code>nb.gh</code></td>
<td>
<p>Number of nodes for the Gaussian-Hermite quadrature.</p>
</td></tr>
<tr><td><code>nb.gl</code></td>
<td>
<p>Number of nodes for the Gaussian-Laguerre quadrature.</p>
</td></tr>
<tr><td><code>medianR</code></td>
<td>
<p>The value of the median survival for the recurrent events 
and its confidence bands.</p>
</td></tr>
<tr><td><code>medianD</code></td>
<td>
<p>The value of the median survival for the terminal event 
and its confidence bands.</p>
</td></tr>
<tr><td><code>names.factor</code></td>
<td>
<p>Names of the &quot;as.factor&quot; variables 
for the recurrent events.</p>
</td></tr> 
<tr><td><code>names.factordc</code></td>
<td>
<p>Names of the &quot;as.factor&quot; variables 
for the terminal event.</p>
</td></tr>
<tr><td><code>Xlevels</code></td>
<td>
<p>Vector of the values that factor might have taken 
for the recurrent events.</p>
</td></tr> 
<tr><td><code>Xlevels2</code></td>
<td>
<p>Vector of the values that factor might have taken 
for the terminal event.</p>
</td></tr>  
<tr><td><code>linear.pred</code></td>
<td>
<p>Linear predictor for the recurrent part: 
<b><code class="reqn">\beta</code></b>'<b><code class="reqn">X</code></b> + log(<code class="reqn">u</code><sub>i</sub>).</p>
</td></tr> 
<tr><td><code>lineardeath.pred</code></td>
<td>
<p>Linear predictor for the terminal part: 
<b><code class="reqn">\beta</code></b>'<b><code class="reqn">X</code></b> + <code class="reqn">\alpha</code> x log(<code class="reqn">u</code><sub>i</sub>).</p>
</td></tr> 
<tr><td><code>Xlevels</code></td>
<td>
<p>Vector of the values that factor might have taken 
for the recurrent part.</p>
</td></tr>
<tr><td><code>Xlevels2</code></td>
<td>
<p>vector of the values that factor might have taken 
for the death part.</p>
</td></tr> 
<tr><td><code>BetaTpsMat</code></td>
<td>
<p>Matrix of time varying-effects and confidence bands for 
recurrent event (the first column used for abscissa of times of recurrence).</p>
</td></tr> 
<tr><td><code>BetaTpsMatDc</code></td>
<td>
<p>Matrix of time varying-effects and confidence bands for 
terminal event (the first column used for abscissa of times of death).</p>
</td></tr> 
<tr><td><code>alpha_p.value</code></td>
<td>
<p>p-value of the Wald test for the estimated <code class="reqn">\alpha</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the flexible semiparametric case, smoothing parameters <code>kappa</code> and 
number of knots <code>n.knots</code> are the arguments that the user have to change 
if the fitted model does not converge. 
<code>n.knots</code> takes integer values between 4 and 20. 
But with <code>n.knots=20</code>, the model would take a long time to converge. 
So, usually, begin first with <code>n.knots=7</code>, and increase it step by step 
until it converges.
<code>kappa</code> only takes positive values. So, choose a value for kappa (for
instance 10000), and if it does not converge, multiply or divide this value
by 10 or 5 until it converges.
</p>


<h3>References</h3>

<p>J. Chauvet and V. Rondeau (2021). A flexible class of generalized 
joint frailty models for the analysis of survival endpoints. In revision.
</p>
<p>Liu XR, Pawitan Y, Clements M. (2018)
Parametric and penalized generalized survival models. 
<em>Statistical Methods in Medical Research</em> <b>27</b>(5), 1531-1546.
</p>
<p>Liu XR, Pawitan Y, Clements MS. (2017)
Generalized survival models for correlated time-to-event data. 
<em>Statistics in Medicine</em> <b>36</b>(29), 4743-4762.
</p>
<p>A. Krol, A. Mauguen, Y. Mazroui, A. Laurent, S. Michiels and V. Rondeau
(2017). Tutorial in Joint Modeling and Prediction: A Statistical Software
for Correlated Longitudinal Outcomes, Recurrent Events and a Terminal Event.
<em>Journal of Statistical Software</em> <b>81</b>(3), 1-52.
</p>
<p>V. Rondeau, Y. Mazroui and J. R. Gonzalez (2012). Frailtypack: An R package
for the analysis of correlated survival data with frailty models using
penalized likelihood estimation or parametric estimation. <em>Journal of
Statistical Software</em> <b>47</b>, 1-28.
</p>
<p>V. Rondeau, J.P. Pignon, S. Michiels (2011). A joint model for the
dependance between clustered times to tumour progression and deaths: A
meta-analysis of chemotherapy in head and neck cancer. <em>Statistical
methods in medical research</em> <b>897</b>, 1-19.
</p>
<p>V. Rondeau, S. Mathoulin-Pellissier, H. Jacqmin-Gadda, V. Brouste, P.
Soubeyran (2007). Joint frailty models for recurring events and death using
maximum penalized likelihood estimation:application on cancer events.
<em>Biostatistics</em> <b>8</b>,4, 708-721.
</p>
<p>V. Rondeau, D. Commenges, and P. Joly (2003). Maximum penalized likelihood
estimation in a gamma-frailty model. <em>Lifetime Data Analysis</em> <b>9</b>,
139-153.
</p>
<p>C.A. McGilchrist, and C.W. Aisbett (1991). Regression with frailty in
survival analysis. <em>Biometrics</em> <b>47</b>, 461-466.
</p>
<p>D. Marquardt (1963). An algorithm for least-squares estimation of nonlinear
parameters. <em>SIAM Journal of Applied Mathematics</em>, 431-441.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+Surv">Surv</a></code>,
<code><a href="#topic+terminal">terminal</a></code>, 
<code><a href="#topic+timedep">timedep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#############################################################################
# -----        GENERALIZED SURVIVAL MODELS (without frailties)       -----  #
#############################################################################

adult.retino = retinopathy[retinopathy$type == "adult", ]
adult.retino[adult.retino$futime &gt;= 50, "status"] = 0
adult.retino[adult.retino$futime &gt;= 50, "futime"] = 50

### ---  Parametric PH, AH, PO and probit models  --- ###

GenfrailtyPenal(formula=Surv(futime,status)~trt, data=adult.retino, 
hazard="parametric", family="PH")
GenfrailtyPenal(formula=Surv(futime,status)~trt, data=adult.retino, 
hazard="parametric", family="AH")
GenfrailtyPenal(formula=Surv(futime,status)~trt, data=adult.retino, 
hazard="parametric", family="PO")
GenfrailtyPenal(formula=Surv(futime,status)~trt, data=adult.retino, 
hazard="parametric", family="probit")

### ---  Semi-parametric PH and AH models  --- ###

GenfrailtyPenal(formula=Surv(futime,status)~timedep(trt), data=adult.retino, 
family="PH", hazard="Splines", n.knots=8, kappa=10^6, betaknots=1, betaorder=2)
GenfrailtyPenal(formula=Surv(futime,status)~timedep(trt), data=adult.retino, 
family="AH", hazard="Splines", n.knots=8, kappa=10^10, betaknots=1, betaorder=2)



#############################################################################
# -----          SHARED FRAILTY GENERALIZED SURVIVAL MODELS          -----  #
#############################################################################

adult.retino = retinopathy[retinopathy$type == "adult", ]
adult.retino[adult.retino$futime &gt;= 50, "status"] = 0
adult.retino[adult.retino$futime &gt;= 50, "futime"] = 50

### ---  Parametric PH, AH, PO and probit models  --- ###

GenfrailtyPenal(formula=Surv(futime,status)~trt+cluster(id), data=adult.retino, 
hazard="parametric", family="PH")
GenfrailtyPenal(formula=Surv(futime,status)~trt+cluster(id), data=adult.retino, 
hazard="parametric", family="AH")
GenfrailtyPenal(formula=Surv(futime,status)~trt+cluster(id), data=adult.retino, 
hazard="parametric", family="PO")
GenfrailtyPenal(formula=Surv(futime,status)~trt+cluster(id), data=adult.retino, 
hazard="parametric", family="probit")

### ---  Semi-parametric PH and AH models  --- ###

GenfrailtyPenal(formula=Surv(futime,status)~cluster(id)+timedep(trt), 
data=adult.retino, family="PH", hazard="Splines", 
n.knots=8, kappa=10^6, betaknots=1, betaorder=2)
GenfrailtyPenal(formula=Surv(futime,status)~cluster(id)+timedep(trt), 
data=adult.retino, family="AH", hazard="Splines", 
n.knots=8, kappa=10^10, betaknots=1, betaorder=2)



#############################################################################
# -----         JOINT FRAILTY GENERALIZED SURVIVAL MODELS            -----  #
#############################################################################

data("readmission") 
readmission[, 3:5] = readmission[, 3:5]/365.25

### ---  Parametric dual-PH, AH, PO and probit models  --- ###

GenfrailtyPenal(
formula=Surv(t.start,t.stop,event)~cluster(id)+terminal(death)+sex+dukes+chemo,
formula.terminalEvent=~sex+dukes+chemo, data=readmission, recurrentAG=TRUE, 
hazard="parametric", family=c("PH","PH"))
GenfrailtyPenal(
formula=Surv(t.start,t.stop,event)~cluster(id)+terminal(death)+sex+dukes+chemo,
formula.terminalEvent=~sex+dukes+chemo, data=readmission, recurrentAG=TRUE, 
hazard="parametric", family=c("AH","AH"))
GenfrailtyPenal(
formula=Surv(t.start,t.stop,event)~cluster(id)+terminal(death)+sex+dukes+chemo,
formula.terminalEvent=~sex+dukes+chemo, data=readmission, recurrentAG=TRUE, 
hazard="parametric", family=c("PO","PO"))
GenfrailtyPenal(
formula=Surv(t.start,t.stop,event)~cluster(id)+terminal(death)+sex+dukes+chemo,
formula.terminalEvent=~sex+dukes+chemo, data=readmission, recurrentAG=TRUE, 
hazard="parametric", family=c("probit","probit"))

### ---  Semi-parametric dual-PH and AH models  --- ###

GenfrailtyPenal(
formula=Surv(t.start,t.stop,event)~cluster(id)+terminal(death)+sex+dukes+timedep(chemo),
formula.terminalEvent=~sex+dukes+timedep(chemo), data=readmission, recurrentAG=TRUE, 
hazard="Splines", family=c("PH","PH"), 
n.knots=5, kappa=c(100,100), betaknots=1, betaorder=3)
GenfrailtyPenal(
formula=Surv(t.start,t.stop,event)~cluster(id)+terminal(death)+sex+dukes+timedep(chemo),
formula.terminalEvent=~sex+dukes+timedep(chemo), data=readmission, recurrentAG=TRUE, 
hazard="Splines", family=c("AH","AH"), 
n.knots=5, kappa=c(600,600), betaknots=1, betaorder=3)




</code></pre>

<hr>
<h2 id='hazard'>Hazard function.</h2><span id='topic+hazard'></span>

<h3>Description</h3>

<p>Let t be a continuous variable, we determine the value of the hazard
function to t after run fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hazard(t, ObjFrailty)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hazard_+3A_t">t</code></td>
<td>
<p>time for hazard function.</p>
</td></tr>
<tr><td><code id="hazard_+3A_objfrailty">ObjFrailty</code></td>
<td>
<p>an object from the frailtypack fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return the value of hazard function in t.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

#-- a fit Shared
data(readmission)
fit.shared &lt;- frailtyPenal(Surv(time,event)~dukes+cluster(id)+
strata(sex),n.knots=10,kappa=c(10000,10000),data=readmission)

#-- calling survival
hazard(20,fit.shared)


## End(Not run)


</code></pre>

<hr>
<h2 id='jointRecCompet'>Competing Joint Frailty Model: A single type of recurrent event and two
terminal events.</h2><span id='topic+jointRecCompet'></span>

<h3>Description</h3>

<p>Fit a joint competing frailty model for a single recurrent event
and two terminal events defined as,
</p>
<p style="text-align: center;"><code class="reqn">\text {Recurrent event:} \quad r_{i j}\left(t \mid w_i, 
\boldsymbol{X}_{r, i j}\right)=r_0(t) \exp \left(\boldsymbol{X}_{r, i j} \boldsymbol{\beta}_r+w_i\right)</code>
</p>

<p style="text-align: center;"><code class="reqn">\text{First terminal event:} \quad \lambda_{1, i}\left(t \mid w_i, 
\boldsymbol{X}_{1 i}\right)=\lambda_{1, 0}(t) \exp \left(\boldsymbol{X}_{1, i} \boldsymbol{\beta}_1+\alpha_1 w_i\right)</code>
</p>

<p style="text-align: center;"><code class="reqn">\text{Second terminal event:} \quad \lambda_{2, i}\left(t \mid w_i, 
\boldsymbol{X}_{2, i}\right)=\lambda_{2, 0}(t) \exp \left(\boldsymbol{X}_{2, i} \boldsymbol{\beta}_2+\alpha_2 w_i\right).</code>
</p>

<p>where <code class="reqn">\omega_i \sim \mathcal{N}(0,\theta)</code> is the frailty term and <code class="reqn">\boldsymbol{X}_{r, i j},\boldsymbol{X}_{1, i}</code> and
<code class="reqn">\boldsymbol{X}_{2, i}</code> are vectors of baseline covariates (possibly the same). The parameters <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code>
are power parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointRecCompet(formula,
         formula.terminalEvent = NULL,
         formula.terminalEvent2 = NULL,
         data,
         initialize = TRUE,
         recurrentAG = FALSE,
         maxit = 350,
         hazard = "Weibull",
         n.knots=7,
         kappa = rep(10, 3),
         crossVal=FALSE,
         constraint.frailty = "squared",
         GHpoints = 32,
         tolerance = rep(10^-3, 3),
         init.hazard = NULL,
         init.Sigma = 0.5,
         init.Alpha1 = 0.1,
         init.Alpha2 = -0.1,
         init.B = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jointRecCompet_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response for the first recurrent
event on the left of a <code class="reqn">\sim</code> operator, and the terms on the right.
The response must be in the format Surv(t0, t1, recurrentevent) for a calendar-time
specification where <code>t0</code> is the start time for an at-risk period for the recurrent event,
<code>t1</code> is the end time for an at-risk period for the recurrent event, and
<code>recurrentevent</code> is a numeric indicator for whether an event was observed (1)
or was censored (2).
In a gap-time setting, an object of the format Surv(t, recurrentevent) should be used instead.
Note that to not be confused with a left-truncation setting, when using a calendar-time specification 
argument <code>recurrentAG</code> should be set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_formula.terminalevent">formula.terminalEvent</code></td>
<td>
<p>a formula object,
empty on the left of a <code class="reqn">\sim</code> operator,
and the terms on the right. Leave the formula at
the default value (NULL) for a model with no variables.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_formula.terminalevent2">formula.terminalEvent2</code></td>
<td>
<p>a formula object,
empty on the left of a <code class="reqn">\sim</code> operator,
and the terms on the right.Leave the formula at
the default value (NULL) for a model with no variables.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_data">data</code></td>
<td>
<p>a 'data.frame' with the variables used in 'formula',
'formula.terminalEvent', and 'formula.terminalEvent2'.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_initialize">initialize</code></td>
<td>
<p>Logical value to internally initialize regression coefficients and
baseline hazard functions parameters using simpler models from frailtypack.
When initialization is requested, the
program first fits two joint frailty models for the recurrent
events and each terminal event.
When FALSE, parameters are initialized via the arguments
init.hazard, init.Sigma, init.Alpha1, init.Alpha2, init.B.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_recurrentag">recurrentAG</code></td>
<td>
<p>Logical value. Is Andersen-Gill model fitted? 
If so indicates that recurrent event times with the counting 
process approach of Andersen and Gill is used. This formulation can be 
used for dealing with time-dependent covariates. The default is FALSE.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations for the Marquardt algorithm.
Default is 350.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_hazard">hazard</code></td>
<td>
<p>Type of hazard functions. Available options are <code>"Weibull"</code> 
for parametric Weibull function, <code>"Splines"</code> for semiparametric
hazard functions using equidistant intervals or <code>"Splines-per"</code> for
percentile intervals. Default is <code>"Weibull"</code>.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_n.knots">n.knots</code></td>
<td>
<p>In the case of splines hazard functions, number of knots to be used 
in the splines basis. This number should be between 4 and 20. Default is 7.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_kappa">kappa</code></td>
<td>
<p>In the case of splines hazard functions, a vector of size 3 containing
the values of the smoothing parameters to be used for each baseline hazard function. 
Default value is 10 for each function.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_crossval">crossVal</code></td>
<td>
<p>In the case of splines hazard functions, indicates how 
the smoothing parameters are chosen. If set to &quot;TRUE&quot; then those parameters
are chosen automatically using cross-validation on reduced models for each 
baseline hazard function. If set to &quot;FALSE&quot; then the parameters are those provided 
by the argument <code>kappa</code>. If set to &quot;TRUE&quot; then the argument <code>kappa</code> is 
ignored. Default is &quot;TRUE&quot;.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_constraint.frailty">constraint.frailty</code></td>
<td>
<p>Type of positivity constraint used for the variance of
of the random effect in the likelihood. Possible values are 'squared' or 'exponential'. 
Default is 'squared'. See Details.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_ghpoints">GHpoints</code></td>
<td>
<p>Integer. Number of nodes for Gauss-Hermite integration
to marginalize random effects/frailties. Default is 32.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric, length 3. Optimizer's tolerance for (1) successive change
in parameter values, (2) log likelihood, and (3) score, respectively.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_init.hazard">init.hazard</code></td>
<td>
<p>Numeric. Initialization values for hazard parameters.
If a weibull model is used, the order is:
shapeR, scaleR, shapeTerminal1, scaleTerminal1, shapeTerminal2, scaleTerminal2.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_init.sigma">init.Sigma</code></td>
<td>
<p>Numeric,. Initialization value for the standard deviation of the
normally-distributed random effects.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_init.alpha1">init.Alpha1</code></td>
<td>
<p>Numeric. Initialization value for the parameter alpha that
links the hazard function of the recurrent event to the first terminal event.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_init.alpha2">init.Alpha2</code></td>
<td>
<p>Numeric. Initialization value for the parameter alpha that
links the hazard function of the recurrent event to the second terminal event.</p>
</td></tr>
<tr><td><code id="jointRecCompet_+3A_init.b">init.B</code></td>
<td>
<p>Numeric vector of the same length and order 
as the three covariate vectors for the recurrent, terminal1,
and terminal2 events (in that order).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Right-censored data are allowed.
Left-truncated data and stratified analysis are not possible. 
Prediction options are not yet available. 
The <code>constraint.frailty</code> argument defines the positivity constraint 
used for the frailty variance in the likelihood. By default it uses the square 
so that the absolute value of the parameter is the standard deviation of the frailty
(i.e <code class="reqn">\theta^2 = \beta^2</code>). 
The other parametrization uses the square of the exponential for the variance
so that the parameter is the logarithm of the standard deviation (<code class="reqn">\theta^2 = (\exp{\beta})^2</code>).
For others parameters in the model needing a positivity constraint (parameters related to the
baseline hazard functions), the parametrization used is the exponential squared.
</p>


<h3>Value</h3>

<p>Parameters estimates of a competing joint frailty model, more
generally a 'jointRecCompet' object. Methods defined for 'jointRecCompet' objects
are provided for print, plot and summary. The following components are
included in a 'jointRecCompet' object.
</p>
<table role = "presentation">
<tr><td><code>summary.table</code></td>
<td>
<p>A table describing the estimate, standard error,
confidence interval, and pvalues for each of the parameters in the model.</p>
</td></tr>
<tr><td><code>controls</code></td>
<td>
<p>A vector of named control parameters</p>
</td></tr>
<tr><td><code>k0</code></td>
<td>
<p>For splines baseline hazard functions, vector of penalization terms.</p>
</td></tr>
<tr><td><code>noVarEvent</code></td>
<td>
<p>A vector containing for each event type if there is no covariate used
in the model.</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>Total number of parameters</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Vector containing the estimated coefficients of the model before any positivity constraint.
The values are in order: the coefficients associated with the baseline hazard functions 
(either the splines or the shape and scale parameters for Weibull hazard), 
the random effect variance, the coefficients of the frailty (<code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code>) 
and the regression coefficients.</p>
</td></tr>
<tr><td><code>H_hessOut</code></td>
<td>
<p>Covariance matrix of the estimated parameters</p>
</td></tr>
<tr><td><code>HIHOut</code></td>
<td>
<p>Covariance matrix of the estimated parameters for the penalized likelihood
in the case of Splines baseline hazard functions.</p>
</td></tr>
<tr><td><code>LCV</code></td>
<td>
<p>The approximated likelihood cross-validation criterion in the spline case</p>
</td></tr>
<tr><td><code>critCV</code></td>
<td>
<p>Convergence criteria</p>
</td></tr>
<tr><td><code>x1</code></td>
<td>
<p>Vector of times for which the hazard function of
the recurrent event is estimated.
By default seq(0,max(time),length=99),
where time is the vector of survival times.</p>
</td></tr>
<tr><td><code>lam1</code></td>
<td>
<p>Matrix of hazard estimates and confidence bands for the recurrent
event.</p>
</td></tr>
<tr><td><code>xSu1</code></td>
<td>
<p>Vector of times for the survival function of
the recurrent event.</p>
</td></tr>
<tr><td><code>surv1</code></td>
<td>
<p>Matrix of baseline survival
estimates and confidence bands for recurrent event.</p>
</td></tr>
<tr><td><code>x2</code></td>
<td>
<p>Vector of times for the first terminal event (see x1 value).</p>
</td></tr>
<tr><td><code>lam2</code></td>
<td>
<p>Matrix of hazard estimates and confidence bands for the
first terminal event.</p>
</td></tr>
<tr><td><code>xSu2</code></td>
<td>
<p>Vector of times for the survival function of the first terminal event.</p>
</td></tr>
<tr><td><code>surv2</code></td>
<td>
<p>Vector of the survival function of the first terminal event evaluated at xSu2.</p>
</td></tr>
<tr><td><code>x3</code></td>
<td>
<p>Vector of times for the second terminal event (see x1 value).</p>
</td></tr>
<tr><td><code>lam3</code></td>
<td>
<p>Matrix of hazard estimates and confidence bands for the
second terminal event.</p>
</td></tr>
<tr><td><code>xSu3</code></td>
<td>
<p>Vector of times for the survival function of the second terminal event.</p>
</td></tr>
<tr><td><code>surv3</code></td>
<td>
<p>Vector of the survival function of the second terminal event evaluated at xSu3.</p>
</td></tr>
<tr><td><code>ni</code></td>
<td>
<p>Number of iterations needed to converge.</p>
</td></tr>
<tr><td><code>constraintfrailty</code></td>
<td>
<p>Positivity constraint used for the variance of the random effect</p>
</td></tr> 
<tr><td><code>ziOut1</code></td>
<td>
<p>In the spline case, vector of knots used in the spline basis for the recurrent event</p>
</td></tr>
<tr><td><code>ziOutdc</code></td>
<td>
<p>In the spline case, vector of knots used in the spline basis for the terminal events</p>
</td></tr>
<tr><td><code>ghnodes</code></td>
<td>
<p>Nodes used for the Gauss-Hermite quadrature.</p>
</td></tr>
<tr><td><code>ghweights</code></td>
<td>
<p>Weights used for the Gauss-Hermite quadrature.</p>
</td></tr>
<tr><td><code>tolerance</code></td>
<td>
<p>Numeric, length 3. Optimizer's tolerance for (1) successive change
in parameter values, (2) log likelihood, and (3) score, respectively.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Call of the function.</p>
</td></tr>
<tr><td><code>loglikPenal</code></td>
<td>
<p>Estimated penalized log-likelihood in the spline case</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>Estimated log-likelihood in the Weibull case</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>For the Weibull case, Akaike Information criterion</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Total number of subjects</p>
</td></tr>
<tr><td><code>nevts</code></td>
<td>
<p>Number of events for each event type.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+terminal">terminal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
data=simulatejointRecCompet(n=500,
		par0=c(shapeR = 1.5, scaleR = 10, 
		shapeM = 1.75, scaleM = 16, shapeD = 1.75, scaleD = 16, sigma = 0.5, 
		alphaM = 1, alphaD = 1, betaR = -0.5, betaM = -0.5, betaD = 0) )
mod &lt;-jointRecCompet(formula = Surv(tstart, tstop, event)~cluster(id)+treatment+
                    terminal(terminal1)+terminal2(terminal2),
                    formula.terminalEvent = ~treatment,
                    formula.terminalEvent2 = ~treatment,
                    data = data,
                    recurrentAG = TRUE,
                    initialize = TRUE,
					   n.knots=7,
					   crossVal=TRUE,
                    hazard = "Splines",
                    maxit = 350)

#This example uses an extract of 500 patients of the REDUCE trial
data(reduce)
mod_reduce &lt;-jointRecCompet(formula = Surv(t.start,t.stop, del)~cluster(id)+
					   treatment+terminal(death)+terminal2(discharge),
                    formula.terminalEvent = ~treatment,
                    formula.terminalEvent2 = ~treatment,
                    data = reduce,
                    initialize = TRUE,
                    recurrentAG = TRUE,
                    hazard = "Weibull",
                    constraint.frailty = "exponential",
                    maxit = 350)
print(mod_reduce)

</code></pre>

<hr>
<h2 id='jointSurrCopSimul'>Generate survival times for two endpoints using the joint frailty-copula model for surrogacy</h2><span id='topic+jointSurrCopSimul'></span>

<h3>Description</h3>

<p>Date are generated from the one-step joint frailty-copula model, under the Claton 
copula function (see <code><a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a></code> for more details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointSurrCopSimul(
  n.obs = 600,
  n.trial = 30,
  prop.cens = 0,
  cens.adm = 549,
  alpha = 1.5,
  gamma = 2.5,
  sigma.s = 0.7,
  sigma.t = 0.7,
  cor = 0.9,
  betas = c(-1.25, 0.5),
  betat = c(-1.25, 0.5),
  frailt.base = 1,
  lambda.S = 1.3,
  nu.S = 0.0025,
  lambda.T = 1.1,
  nu.T = 0.0025,
  ver = 2,
  typeOf = 1,
  equi.subj.trial = 1,
  equi.subj.trt = 1,
  prop.subj.trial = NULL,
  prop.subj.trt = NULL,
  full.data = 0,
  random.generator = 1,
  random = 0,
  random.nb.sim = 0,
  seed = 0,
  nb.reject.data = 0,
  thetacopule = 6,
  filter.surr = c(1, 1),
  filter.true = c(1, 1),
  covar.names = "trt",
  pfs = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jointSurrCopSimul_+3A_n.obs">n.obs</code></td>
<td>
<p>Number of considered  subjects. The default is <code>600</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_n.trial">n.trial</code></td>
<td>
<p>Number of considered  trials. The default is <code>30</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_prop.cens">prop.cens</code></td>
<td>
<p>A value between <code>0</code> and <code>1</code>, <code>1-prop.cens</code> is the minimum proportion of 
people who are randomly censored. 
Represents the quantile to use for generating the random censorship time. In this case, the censorship 
time follows a uniform distribution in <code>1</code> and <code>(prop.cens)ieme</code> percentile of the 
generated death times. If this argument is set to <code>0</code>, the fix censorship is considered.
The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_cens.adm">cens.adm</code></td>
<td>
<p>Censorship time. If argument <code>prop.cens</code> is set to <code>0</code>, it represents 
the administrative censorship time, else it represents the fix censoring time. The default is <code>549</code>, 
for about <code>40%</code> of fix censored subjects.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_alpha">alpha</code></td>
<td>
<p>Fixed value for <code class="reqn">\alpha</code>. The default is <code>1.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_gamma">gamma</code></td>
<td>
<p>Fixed value for <code class="reqn">\gamma</code>. The default is <code>2.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_sigma.s">sigma.s</code></td>
<td>
<p>Fixed value for  
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>. The default is <code>0.7</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_sigma.t">sigma.t</code></td>
<td>
<p>Fixed value for 
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub>. The default is <code>0.7</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_cor">cor</code></td>
<td>
<p>Desired level of correlation between v<sub>S<sub>i</sub></sub> and v<sub>T<sub>i</sub></sub>. 

<code>R</code><sup>2</sup><sub>trial</sub> = cor <sup>2</sup>. 
The default is <code>0.8</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_betas">betas</code></td>
<td>
<p>Vector of the fixed effects for  <code class="reqn">\beta</code><sub>S</sub>.
The size must be equal to <code>ver</code> 
The default is <code>c(-1.25,0.5)</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_betat">betat</code></td>
<td>
<p>Vector of the fixed effects for   <code class="reqn">\beta</code><sub>T</sub>.
The size must be equal to <code>ver</code>
The default is <code>c(-1.25,0.5)</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_frailt.base">frailt.base</code></td>
<td>
<p>Considered heterogeneity on the baseline risk <code>(1)</code> or not <code>(0)</code>. 
The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_lambda.s">lambda.S</code></td>
<td>
<p>Desired scale parameter for the <code>Weibull</code> distribution associated with the Surrogate
endpoint. The default is 1.8.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_nu.s">nu.S</code></td>
<td>
<p>Desired shape parameter for the <code>Weibull</code> distribution associated with the Surrogate
endpoint. The default is 0.0045.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_lambda.t">lambda.T</code></td>
<td>
<p>Desired scale parameter for the <code>Weibull</code> distribution associated with the True endpoint.
The default is 3.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_nu.t">nu.T</code></td>
<td>
<p>Desired shape parameter for the <code>Weibull</code> distribution associated with the True endpoint.
The default is 0.0025.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_ver">ver</code></td>
<td>
<p>Number of covariates. The mandatory covariate is the treatment arm. The default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_typeof">typeOf</code></td>
<td>
<p>Type of joint model used for data generation: 0 = classical joint model 
with a shared individual frailty effect (Rondeau, 2007), 1 = joint frailty-copula model with shared frailty 
effects  <code>u</code><sub>i</sub> and two correlated random effects treatment-by-trial interaction 
(v<sub>S<sub>i</sub></sub>, v<sub>T<sub>i</sub></sub>),
see <code><a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a></code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_equi.subj.trial">equi.subj.trial</code></td>
<td>
<p>A binary variable that indicates if the same proportion of subjects should be included per trial (1) 
or not (0). If 0, the proportions of subject per trial are required with parameter <code>prop.subj.trial</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_equi.subj.trt">equi.subj.trt</code></td>
<td>
<p>A binary variable that indicates if the same proportion of subjects is randomized per trial (1) 
or not (0). If 0, the proportions of subject per trial are required with parameter <code>prop.subj.trt</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_prop.subj.trial">prop.subj.trial</code></td>
<td>
<p>The proportions of subjects per trial. Requires if <code>equi.subj.trial = 0</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_prop.subj.trt">prop.subj.trt</code></td>
<td>
<p>The proportions of randomized subject per trial. Requires if <code>equi.subj.trt = 0</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_full.data">full.data</code></td>
<td>
<p>Specified if you want the function to return the full dataset (1), including the random effects, 
or the restictive dataset (0) with at least <code>7</code> columns as required for the function <code><a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a></code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_random.generator">random.generator</code></td>
<td>
<p>The random number generator used by the Fortran compiler, 
<code>1</code> for the intrinsec subroutine <code>Random_number</code> and <code>2</code> for the 
subroutine <code>uniran()</code>. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_random">random</code></td>
<td>
<p>A binary that says if we reset the random number generation with a different environment 
at each call <code>(1)</code> or not <code>(0)</code>. If it is set to <code>1</code>, we use the computer clock 
as seed. In the last case, it is not possible to reproduce the generated datasets. 
The default is <code>0</code>. Required if <code>random.generator</code> is set to 1.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_random.nb.sim">random.nb.sim</code></td>
<td>
<p>required if <code>random.generator</code> is set to 1, and if <code>random</code> is set to 1.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_seed">seed</code></td>
<td>
<p>The seed to use for data (or samples) generation. Required if the argument <code>random.generator</code> is set to 1. 
Must be a positive value. If negative, the program do not account for seed. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_nb.reject.data">nb.reject.data</code></td>
<td>
<p>Number of generation to reject before the considered dataset. This parameter is required
when data generation is for simulation. With a fixed parameter and <code>random.generator</code> set to 1,
all ganerated data are the same. By varying this parameter, different datasets are obtained during data generations. The default value is 0, 
in the event of one dataset.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_thetacopule">thetacopule</code></td>
<td>
<p>The desired value for the copula parameter. The default is <code>6</code>.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_filter.surr">filter.surr</code></td>
<td>
<p>Vector of size the number of covariates, with the i-th element that indicates if the hazard for 
surrogate is adjusted on the i-th covariate (code 1) or not (code 0). By default, 2 covariates are considered.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_filter.true">filter.true</code></td>
<td>
<p>Vector defines as <code>filter.surr</code>, for the true endpoint. <code>filter.true</code> and <code>filter.surr</code>
should have the same size</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_covar.names">covar.names</code></td>
<td>
<p>Vector of the names of covariables. By default it contains &quot;trt&quot; for the 
tratment arm. Should contains the names of all covarites wished in the generated dataset.</p>
</td></tr>
<tr><td><code id="jointSurrCopSimul_+3A_pfs">pfs</code></td>
<td>
<p>Is used to specify if the time to progression should be censored by the death time (0) or not (1). 
The default is 0. In the event with pfs set to 1, death is included in the surrogate endpoint as in the definition of PFS or DFS.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We just considered in this generation, the Gaussian random effects. If the parameter <code>full.data</code> is set to 1,
this function  return a list containning severals parameters, including the generated random effects. 
The desired individual level correlation (Kendall's <code class="reqn">\tau</code>) depend on the values of the copula parameter 
<code class="reqn">\theta</code>, given that <code class="reqn">\tau = \theta /(\theta + 2)</code> under the clayton copula model.
</p>


<h3>Value</h3>

<p>This function returns if the parameter <code>full.data</code> is set to 0, a <code><a href="base.html#topic+data.frame">data.frame</a></code> with columns :
</p>
<table role = "presentation">
<tr><td><code>patientID</code></td>
<td>
<p>A numeric, that represents the patient's identifier, must be unique;</p>
</td></tr>
<tr><td><code>trialID</code></td>
<td>
<p>A numeric, that represents the trial in which each patient was randomized;</p>
</td></tr>
<tr><td><code>trt</code></td>
<td>
<p>The treatment indicator for each patient, with 1 = treated, 0 = untreated;</p>
</td></tr>
<tr><td><code>timeS</code></td>
<td>
<p>The follow up time associated with the surrogate endpoint;</p>
</td></tr>
<tr><td><code>statusS</code></td>
<td>
<p>The event indicator associated with the surrogate endpoint. Normally 
0 = no event, 1 = event;</p>
</td></tr>
<tr><td><code>timeT</code></td>
<td>
<p>The follow up time associated with the true endpoint;</p>
</td></tr>
<tr><td><code>statusT</code></td>
<td>
<p>The event indicator associated with the true endpoint. Normally 
0 = no event, 1 = event;</p>
</td></tr>
</table>
<p>and other covariates named <code>Var2, var3, ..., var[ver-1]</code> if <code>ver &gt; 1</code>.
If the argument <code>full.data</code> is set to 1, additionnal colums corresponding to random effects 
 <code>u</code><sub>i</sub>, <code>v</code><sub>S<sub>i</sub></sub> and
<code>v</code><sub>T<sub>i</sub></sub> are returned.
</p>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a> and 
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>
</p>


<h3>References</h3>

<p>Rondeau V., Mathoulin-Pelissier S., Jacqmin-Gadda H., Brouste V. and Soubeyran P. (2007).
Joint frailty models for recurring events and death using maximum penalized likelihood 
estimation: application on cancer events. Biostatistics 8(4), 708-721.
</p>
<p>Sofeu, C. L., Emura, T., and Rondeau, V. (2020). A joint frailty-copula model for meta-analytic 
validation of failure time surrogate endpoints in clinical trials. <code>Under review</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurrSimul">jointSurrSimul</a>, <a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# dataset with 2 covariates and fixed censorship
data.sim &lt;- jointSurrCopSimul(n.obs=600, n.trial = 30, prop.cens = 0, cens.adm=549, 
            alpha = 1.5, gamma = 2.5, sigma.s = 0.7, sigma.t = 0.7, 
            cor = 0.8, betas = c(-1.25, 0.5), betat = c(-1.25, 0.5), 
            full.data = 0, random.generator = 1,ver = 2, covar.names = "trt", 
            nb.reject.data = 0, thetacopule = 6, filter.surr = c(1,1), 
            filter.true = c(1,1), seed = 0)
            
#dataset with 2 covariates and random censorship

data.sim2 &lt;- jointSurrCopSimul(n.obs=600, n.trial = 30, prop.cens = 0.75, 
            cens.adm = 549, alpha = 1.5, gamma = 2.5, sigma.s = 0.7, 
            sigma.t = 0.7, cor = 0.8, betas = c(-1.25, 0.5), 
            betat = c(-1.25, 0.5), full.data = 0, random.generator = 1,
            ver = 2, covar.names = "trt", nb.reject.data = 0, thetacopule = 6, 
            filter.surr = c(1,1), filter.true = c(1,1), seed = 0)
            

</code></pre>

<hr>
<h2 id='jointSurroCopPenal'>Fit the one-step Joint frailty-copula model for evaluating a canditate surrogate endpoint</h2><span id='topic+jointSurroCopPenal'></span>

<h3>Description</h3>


<p><b>Joint Frailty-Copula model for Surrogacy definition</b>
</p>
<p>Fit the one-step Joint frailty-copula surrogate model for the evaluation of a canditate surrogate endpoint,
with different integration methods on the random effects, using a semiparametric penalized
likelihood estimation. This approach extends that of Burzykowski <code>et al.</code> (2001) by
including in the bivariate copula model the random effects treatment-by-trial interaction.
</p>
<p>Assume S<sub>ij</sub> and T<sub>ij</sub> the failure times associated respectively
with the surrogate and the true endpoints, for subject <code>j(j = 1,..., n</code><sub>i</sub><code>)</code> belonging to
the trial <code>i (i = 1,..., G)</code>.
</p>
<p>Let <strong>v</strong><sub>i</sub> = (u<sub>i</sub>,
v<sub>S<sub>i</sub></sub>, v<sub>T<sub>i</sub></sub>) be the vector of trial
level random effects; <b>Z</b><sub>S,ij</sub> = (Z<sub>Sij1</sub>, ..., Z<sub>Sijp</sub>)<sup>'</sup>
and <b>Z</b><sub>T,ij</sub> = (Z<sub>Tij1</sub>, ..., Z<sub>Tijp</sub>)<sup>'</sup>
be covariates associated with S<sub>ij</sub> and T<sub>ij</sub>.
The joint frailty-copula model is defined as follows:
</p>
<p><img src="../help/figures/jointSurvCop1.png" width="100%" alt="jointSurvCop1.png" />
</p>
<p>where
</p>
<p><img src="../help/figures/jointSurvCop3.png" width="100%" alt="jointSurvCop3.png" />
</p>
<p>and the conditional survival functions are given by
</p>
<p><img src="../help/figures/jointSurvCop2.png" width="100%" alt="jointSurvCop2.png" />
</p>
<p>in which
</p>
<p>u<sub>i</sub> &#126; <code class="reqn">N</code>(0,<code class="reqn">\gamma</code>),
u<sub>i</sub> &#8869; v<sub>S<sub>i</sub></sub>, u<sub>i</sub> &#8869; v<sub>T<sub>i</sub></sub>;
(v<sub>S<sub>i</sub></sub>, v<sub>T<sub>i</sub></sub>)<sup>T</sup> &#126; <code class="reqn">N</code>(0,<code class="reqn">\Sigma</code><sub>v</sub>)
</p>
<p>with
</p>
<p><img src="../help/figures/surromodel2.png" width="100%" alt="surromodel2.png" />
</p>
<p>In this model, <code class="reqn">\lambda</code><sub>0s</sub>(x) is the baseline hazard function associated with the
surrogate endpoint and <code class="reqn">\beta</code><sub>S</sub> the fixed effects (or log-hazard ratio) corresponding
to the covariates <b>Z</b><sub>S,ij</sub>;
<code class="reqn">\lambda</code><sub>0T</sub>(x) is the baseline hazard function associated with the true endpoint
and <code class="reqn">\beta</code><sub>T</sub> the fixed treatment effects corresponding
to the covariates <b>Z</b><sub>T,ij</sub>. The copula model serves to consider dependence between
the surrogate and true endpoints at the individual level. In the copula model, <code class="reqn">\theta</code> is the copula
parameter used to quantify the strength of association. u<sub>i</sub> is a shared frailty effect associated
with the baseline hazard function that serve to take into account the heterogeneity between trials
of the baseline hazard function, associated with the fact that we have several trials in this
meta-analytical design. The power parameter <code class="reqn">\alpha</code> distinguishes
trial-level heterogeneity between the surrogate and the true endpoint.
v<sub>S<sub>i</sub></sub> and v<sub>T<sub>i</sub></sub> are two correlated random effects treatment-by-trial interactions.
<code class="reqn">Z</code><sub>Sij1</sub> or <code class="reqn">Z</code><sub>Tij1</sub> represents the treatment arm to which the patient has been randomized.
</p>
<p>For simplicity, we focus on the Clayton and Gumbel-Hougaard copula functions. In Clayton's
model, the copula function has the form
</p>
<p><img src="../help/figures/jointSurvCop5.png" width="100%" alt="jointSurvCop5.png" />
</p>
<p>and in Gumbel's model, the copula function has the form
</p>
<p><img src="../help/figures/jointSurvCop6.png" width="100%" alt="jointSurvCop6.png" />
</p>
<p><b>Surrogacy evaluation</b>
</p>
<p>We propose to base validation of a candidate surrogate endpoint on Kendall's <code class="reqn">\tau</code> at the individual level and
coefficient of determination at the trial level, as in the classical approach (Burzykowski <code>et al.</code>, 2001).
The formulations are given below.
</p>
<p><b>Individual-level surrogacy</b>
</p>
<p>From the proposed model, according to the copula function, it can be shown that Kendall's <code class="reqn">\tau</code>
is defined as :
</p>
<p><img src="../help/figures/jointSurvCop4.png" width="100%" alt="jointSurvCop4.png" />
</p>
<p>where <code class="reqn">\theta</code> is the copula parameter. Kendall's <code class="reqn">\tau</code> is the difference between the probability of
concordance and the probability of discordance of two realizations of <code class="reqn">S</code><sub>ij</sub> and <code class="reqn">T</code><sub>ij</sub>.
It belongs to the interval [-1,1] and assumes a zero value when <code class="reqn">S</code><sub>ij</sub> and <code class="reqn">T</code><sub>ij</sub> are
independent.
</p>
<p><b>Trial-level surrogacy</b>
</p>
<p>The key motivation for validating a surrogate endpoint is to be able to predict the effect
of treatment on the true endpoint, based on the observed effect of treatment on the
surrogate endpoint. As shown by Buyse <em>et al.</em> (2000), the coefficenient of
determination obtains from the covariance matrix <code class="reqn">\Sigma</code><sub>v</sub> of the random effects
treatment-by-trial interaction can be used to evaluate underlined prediction, and
therefore as surrogacy evaluation measurement at trial-level. It is defined by:
</p>
<p><img src="../help/figures/surromodel4.png" width="100%" alt="surromodel4.png" />
</p>
<p>The SEs of <code class="reqn">R</code><sub>trial</sub><sup>2</sup> and <code class="reqn">\tau</code> are calculated using the Delta-method. We also propose
<code class="reqn">R</code><sub>trial</sub><sup>2</sup> and 95% CI computed using the parametric bootstrap. The use of delta-method
can lead to confidence limits violating the [0,1], as noted by
(Burzykowski <em>et al.</em>, 2001). However, using other methods would not significantly alter
the findings of the surrogacy assessment


</p>



<h3>Usage</h3>

<pre><code class='language-R'>jointSurroCopPenal(data, maxit = 40, indicator.alpha = 1,
   frail.base = 1, n.knots = 6, LIMparam = 0.001, LIMlogl = 0.001,
   LIMderiv = 0.001, nb.mc = 1000, nb.gh = 20, nb.gh2 = 32,
   adaptatif = 0, int.method = 0, nb.iterPGH = 5, true.init.val = 0,
   thetacopula.init = 1, sigma.ss.init = 0.5, sigma.tt.init = 0.5,
   sigma.st.init = 0.48, gamma.init = 0.5, alpha.init = 1,
   betas.init = 0.5, betat.init = 0.5, scale = 1,
   random.generator = 1, kappa.use = 4, random = 0,
   random.nb.sim = 0, seed = 0, init.kappa = NULL, ckappa = c(0,0),
   typecopula = 1, nb.decimal = 4, print.times = TRUE, print.iter = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jointSurroCopPenal_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing at least seven variables entitled:
</p>

<ul>
<li><p><code>patientID:</code> A numeric, that represents the patient's identifier and must be unique;
</p>
</li>
<li><p><code>trialID:</code> A numeric, that represents the trial in which each patient was randomized;
</p>
</li>
<li><p><code>timeS:</code> The follow-up time associated with the surrogate endpoint;
</p>
</li>
<li><p><code>statusS:</code> The event indicator associated with the surrogate endpoint. Normally
0 = no event, 1 = event;
</p>
</li>
<li><p><code>timeT:</code> The follow-up time associated with the true endpoint;
</p>
</li>
<li><p><code>statusT:</code> The event indicator associated with the true endpoint. Normally
0 = no event, 1 = event;
</p>
</li>
<li><p><code>trt:</code> The treatment indicator for each patient, with 1 = treated, 0 = untreated.
</p>
</li></ul>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations for the Marquardt algorithm.
The default being <code>40</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_indicator.alpha">indicator.alpha</code></td>
<td>
<p>A binary, indicating whether the power's parameter <code class="reqn">\alpha</code> should
be estimated (1) or not (0). If <code>0</code>, <code class="reqn">\alpha</code> will be set to <code>1</code> during estimation.
The default is 1.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_frail.base">frail.base</code></td>
<td>
<p>A binary, indicating whether the heterogeneity between trial on the baseline
risk is considered (<code>1</code>) or not (<code>0</code>), using
the shared cluster specific frailties u<sub>i</sub> . The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_n.knots">n.knots</code></td>
<td>
<p>integer giving the number of knots to use. Value required in
the penalized likelihood estimation.  It corresponds to the (n.knots+2)
splines functions for the approximation of the hazard or the survival
functions.  We estimate I or M-splines of order 4. When the user set a
number of knots equals to k (n.knots=k) then the number of interior knots
is (k-2) and the number of splines is (k-2)+order.  Number of knots must be
between 4 and 20. (See <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details).</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_limparam">LIMparam</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
parameters, 10<sup>-3</sup>  by default (See <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details).</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_limlogl">LIMlogl</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
log-likelihood, 10<sup>-3</sup>  by default (See <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details).</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_limderiv">LIMderiv</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the gradient,
10<sup>-3</sup>  by default
(See <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details).</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_nb.mc">nb.mc</code></td>
<td>
<p>Number of samples considered in the Monte-Carlo integration. Required in the event
<code>int.method</code> is equals to <code>0</code>, <code>2</code> or <code>4</code>. A value between 500 and 1000 most often gives
good results. The default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_nb.gh">nb.gh</code></td>
<td>
<p>Number of nodes for the Gaussian-Hermite quadrature. It can
be chosen among 5, 7, 9, 12, 15, 20 and 32. The default is <code>20</code>. A value greater than or equals to <code>15</code>
allowed good results in simulation studies</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_nb.gh2">nb.gh2</code></td>
<td>
<p>Number of nodes for the Gauss-Hermite quadrature used to re-estimate the model,
in the event of non-convergence, defined as previously. The default is <code>32</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_adaptatif">adaptatif</code></td>
<td>
<p>A binary, indicates whether the pseudo adaptive Gaussian-Hermite quadrature <code>(1)</code> or the classical
Gaussian-Hermite quadrature <code>(0)</code> is used. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_int.method">int.method</code></td>
<td>
<p>A numeric, indicates the integration method: <code>0</code> for Monte carlo,
<code>1</code> for Gaussian-Hermite quadrature, <code>3</code> for Laplace approximation. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_nb.iterpgh">nb.iterPGH</code></td>
<td>
<p>Number of iterations before the re-estimation of the posterior random effects,
in the event of the two-steps pseudo-adaptive Gaussian-hermite quadrature. If set to <code>0</code> there is no
re-estimation&quot;. The default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_true.init.val">true.init.val</code></td>
<td>
<p>Numerical value. Indicates if the given initial values to parameters <code>(0)</code> should be considered.
If set to <code>2</code>, <code class="reqn">\alpha</code> and <code class="reqn">\gamma</code> are initialised using two separed shared frailty model
(see <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details);
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>, <code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub> and
<code class="reqn">\sigma</code><sub>v<sub>ST</sub></sub>

are fixed by the user or the default values;
<code class="reqn">\theta</code>, <code class="reqn">\beta</code><sub>S</sub> and <code class="reqn">\beta</code><sub>T</sub>
 are initialized using a classical joint
frailty model, considering individual level random effects, with <code class="reqn">\theta</code> the variance of individual level random effects.
If the joint frailty model is
faced to convergence issues, <code class="reqn">\beta</code><sub>S</sub> and <code class="reqn">\beta</code><sub>T</sub>
 are initialized using
two shared frailty models.  In all other scenarios, if the simplified model does not converge,
default given parameters values are used. Initial values for spline's associated parameters
are fixed to <code>0.5</code>. The default for this argument is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_thetacopula.init">thetacopula.init</code></td>
<td>
<p>Initial values for the copula parameter (<code class="reqn">\theta</code>), required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_sigma.ss.init">sigma.ss.init</code></td>
<td>
<p>Initial values for 
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_sigma.tt.init">sigma.tt.init</code></td>
<td>
<p>Initial values for 
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_sigma.st.init">sigma.st.init</code></td>
<td>
<p>Initial values for 
<code class="reqn">\sigma</code><sub>v<sub>ST</sub></sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.48</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_gamma.init">gamma.init</code></td>
<td>
<p>Initial values for <code class="reqn">\gamma</code>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_alpha.init">alpha.init</code></td>
<td>
<p>Initial values for <code class="reqn">\alpha</code>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_betas.init">betas.init</code></td>
<td>
<p>Initial values for  <code class="reqn">\beta</code><sub>S</sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_betat.init">betat.init</code></td>
<td>
<p>Initial values for  <code class="reqn">\beta</code><sub>T</sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_scale">scale</code></td>
<td>
<p>A numeric that allows to rescale (by multiplication) the survival times, to avoid numerical
problems in the event of some convergence issues. If no change is needed the argument is set to 1, the default value.
eg: <code>1/365</code> aims to convert days to years &quot;.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_random.generator">random.generator</code></td>
<td>
<p>Random number generator used by the Fortran compiler,
<code>1</code> for the intrinsec subroutine <code>Random_number</code> and <code>2</code> for the
subroutine <code>uniran()</code>. The default is <code>1</code>. In the event of convergence problem
with <code>int.method</code> set to <code>0</code>, <code>2</code> or <code>4</code>, that requires
integration by Monte-Carlo, user could change the random numbers generator.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_kappa.use">kappa.use</code></td>
<td>
<p>A numeric, that indicates how to manage the smoothing parameters
 k<sub>1</sub>
and  k<sub>2</sub> in the event of convergence issues. If it is set to <code>1</code>,
the given smoothing parameters or those obtained by cross-validation are used.
If it is set to <code>3</code>, the associated smoothing parameters are successively divided by 10,
in the event of convergence issues until 5 times. If it is set to <code>4</code>, the management of the
smoothing parameter is as in the event <code>1</code>, follows by the successive division as described
in the event <code>3</code> and preceded by the changing of the number of nodes for the Gauss-Hermite quadrature.
The default is <code>4</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_random">random</code></td>
<td>
<p>A binary that says if we reset the random number generation with a different environment
at each call <code>(1)</code> or not <code>(0)</code>. If it is set to <code>1</code>, we use the computer clock
as seed. In the last case, it is not possible to reproduce the generated datasets&quot;.
The default is <code>0</code>. Required if <code>random.generator</code> is set to 1.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_random.nb.sim">random.nb.sim</code></td>
<td>
<p>If <code>random</code> is set to <code>1</code>, a binary that indicates the number
of generations that will be made.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_seed">seed</code></td>
<td>
<p>The seed to use for data (or samples) generation. required if <code>random</code> is set to <code>0</code>.
The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_init.kappa">init.kappa</code></td>
<td>
<p>smoothing parameter used to penalized the log-likelihood. By default (init.kappa = NULL) the values used
are obtain by cross-validation.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_ckappa">ckappa</code></td>
<td>
<p>Vector of two fixed values to add to the smoothing parameters. By default it is set to (0,0). this argument allows
to well manage the smoothing parameters in the event of convergence issues.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_typecopula">typecopula</code></td>
<td>
<p>The copula function used, can be 1 for clayton or 2 for Gumbel-Hougaard. The default is <code>1</code></p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_nb.decimal">nb.decimal</code></td>
<td>
<p>Number of decimal required for results presentation.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_print.times">print.times</code></td>
<td>
<p>a logical parameter to print estimation time. Default
is TRUE.</p>
</td></tr>
<tr><td><code id="jointSurroCopPenal_+3A_print.iter">print.iter</code></td>
<td>
<p>a logical parameter to print iteration process. Default
is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The estimated parameter are obtained using the robust Marquardt algorithm
(Marquardt, 1963) which is a combination between a Newton-Raphson algorithm
and a steepest descent algorithm. The iterations are stopped when the
difference between two consecutive log-likelihoods was small (&lt;
10<sup>-3</sup> ), the estimated
coefficients were stable (consecutive
values (&lt; 10<sup>-3</sup> )), and the gradient
small enough (&lt; 10<sup>-3</sup> ), by default.
Cubic M-splines of order 4 are used for the hazard function, and I-splines
(integrated M-splines) are used for the cumulative hazard function.
</p>
<p>The inverse of the Hessian matrix is the variance estimator and to deal
with the positivity constraint of the variance component and the spline
coefficients, a squared transformation is used and the standard errors are
computed by the <code class="reqn">\Delta</code>-method (Knight &amp; Xekalaki, 2000). The smooth
parameter can be chosen by maximizing a likelihood cross validation
criterion (Joly and other, 1998).
</p>
<p>We proposed based on the joint surrogate model a new definition
of the Kendall's <code class="reqn">\tau</code>. Moreover, distinct numerical integration methods are available to approximate the
integrals in the marginal log-likelihood.
</p>
<p><b>Non-convergence case management procedure</b>
</p>
<p>Special attention must be given to initializing model parameters, the choice of the number of
spline knots, the smoothing parameters and the number of quadrature points to solve convergence
issues. We first initialized parameters using the user's desired strategy, as specified
by the option <code>true.init.val</code>. When numerical or convergence problems are encountered,
with <code>kappa.use</code> set to <code>4</code>, the model is fitted again using a combination of the following strategies:
vary the number of quadrature point (<code>nb.gh</code> to <code>nb.gh2</code> or <code>nb.gh2</code> to <code>nb.gh</code>)
in the event of the use of the Gaussian Hermite quadrature integration (see <code>int.method</code>);
divided or multiplied the smoothing parameters ( k<sub>1</sub>,
 k<sub>2</sub>) by 10 or 100 according to
their preceding values, or used parameter vectors obtained during the last iteration (with a
modification of the number of quadrature points and smoothing parameters). Using this strategy,
we usually obtained during simulation the rejection rate less than 3%. A sensitivity analysis
was conducted without this strategy, and similar results were obtained on the converged samples,
with about a 23% rejection rate.

</p>


<h3>Value</h3>

<p>This function return an object of class jointSurroPenal with elements :
</p>
<table role = "presentation">
<tr><td><code>EPS</code></td>
<td>
<p>A vector containing the obtained convergence thresholds with the Marquardt algorithm,
for the parameters, the log-likelihood and for the gradient;</p>
</td></tr>
<tr><td><code>b</code></td>
<td>

<p>A vector containing estimates for the splines parameter's; elements of the
lower triangular matrix (L) from the Cholesky decomposition such that <code class="reqn">\Sigma</code> = LL<sup>T</sup>, with <code class="reqn">\Sigma</code>
the covariance of the random effects (v<sub>S<sub>i</sub></sub>,v<sub>T<sub>i</sub></sub>);
the coefficient <code class="reqn">\alpha</code> (if <code>indicator.alpha</code> is set to <code>1</code>); the satandard error
of the random effect <code>u</code><sub>i</sub>; the logarithm
of the copula parameter (<code class="reqn">\theta</code>) if the Clayton copula function is considered, or
the squared root of <code class="reqn">\theta</code> if the Gumbel copula is considered. The last two parameters represent
the regression coefficients <code class="reqn">\beta</code><sub>S</sub> and <code class="reqn">\beta</code><sub>T</sub>;</p>
</td></tr>
<tr><td><code>varH</code></td>
<td>
<p>The variance matrix of all parameters in <code>b</code> (before positivity constraint transformation
for the variance of the measurement error, for which the delta method is used);</p>
</td></tr>
<tr><td><code>varHIH</code></td>
<td>
<p>The robust estimation of the variance matrix of all parameters in <code>b</code>;</p>
</td></tr>
<tr><td><code>loglikPenal</code></td>
<td>
<p>The complete marginal penalized log-likelihood;</p>
</td></tr>
<tr><td><code>LCV</code></td>
<td>
<p>the approximated likelihood cross-validation criterion in the semiparametric case (with <code>H</code>
minus the converged Hessian matrix, and <code>l(.)</code> the full log-likelihood).

<img src="../help/figures/lcv.png" width="50%" alt="lcv.png" />
</p>
</td></tr>
<tr><td><code>xS</code></td>
<td>
<p>vector of times for surrogate endpoint where both survival and hazard function are estimated.
By default seq(0,max(time),length=99), where time is the vector of survival times;</p>
</td></tr>
<tr><td><code>lamS</code></td>
<td>
<p>array (dim = 3) of hazard estimates and confidence bands, for surrogate endpoint;</p>
</td></tr>
<tr><td><code>survS</code></td>
<td>
<p>array (dim = 3) of baseline survival estimates and confidence bands, for surrogate endpoint;</p>
</td></tr>
<tr><td><code>xT</code></td>
<td>
<p>vector of times for true endpoint where both survival and hazard function are estimated.
By default seq(0, max(time), length = 99), where time is the vector of survival times;</p>
</td></tr>
<tr><td><code>lamT</code></td>
<td>
<p>array (dim = 3) of hazard estimates and confidence bands, for true endpoint;</p>
</td></tr>
<tr><td><code>survT</code></td>
<td>
<p>array (dim = 3) of baseline survival estimates and confidence bands, for true endpoint;</p>
</td></tr>
<tr><td><code>n.iter</code></td>
<td>
<p>number of iterations needed to converge;</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Estimate for <code class="reqn">\theta</code>;</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>Estimate for <code class="reqn">\gamma</code>;</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Estimate for <code class="reqn">\alpha</code>;</p>
</td></tr>
<tr><td><code>zeta</code></td>
<td>
<p>A value equals to <code>1</code>, no really use in this function;</p>
</td></tr>
<tr><td><code>sigma.s</code></td>
<td>
<p>Estimate for <code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>;</p>
</td></tr>
<tr><td><code>sigma.t</code></td>
<td>
<p>Estimate for <code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub>;</p>
</td></tr>
<tr><td><code>sigma.st</code></td>
<td>
<p>Estimate for  <code class="reqn">\sigma</code><sub>v<sub>ST</sub></sub>;</p>
</td></tr>
<tr><td><code>beta.s</code></td>
<td>
<p>Estimate for  <code class="reqn">\beta</code><sub>S</sub>;</p>
</td></tr>
<tr><td><code>beta.t</code></td>
<td>
<p>Estimate for  <code class="reqn">\beta</code><sub>T</sub>;</p>
</td></tr>
<tr><td><code>ui</code></td>
<td>
<p>A binary, that indicates if the heterogeneity between trial on the baseline risk
has been Considered (<code>1</code>), using the shared cluster specific frailties 
(<code>u</code><sub>i</sub>),
or not (<code>0</code>);</p>
</td></tr>
<tr><td><code>ktau</code></td>
<td>
<p>The Kendall's <code class="reqn">\tau</code> with the correspondant 95  <code class="reqn">\%</code> CI obtained from the delta-method;</p>
</td></tr>
<tr><td><code>R2.boot</code></td>
<td>
<p>The 
<code>R</code><sup>2</sup><sub>trial</sub>
with the correspondant 95 <code class="reqn">\%</code> CI obtained from the parametric bootstrap;</p>
</td></tr>
<tr><td><code>Coefficients</code></td>
<td>
<p>The estimates with the corresponding standard errors and the 95 <code class="reqn">\%</code> CI</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>Positive smoothing parameters used for convergence. These values could be different to initial
values if <code>kappa.use</code> is set to <code>3</code> or <code>4</code>;</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The value used to rescale the survival times</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The dataset used in the model</p>
</td></tr>
<tr><td><code>varcov.Sigma</code></td>
<td>
<p>Covariance matrix of the estimates of 
the estimates of (<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>,<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub>,
<code class="reqn">\sigma</code><sub>v<sub>ST</sub></sub>) obtained from the delta-method</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>List of all arguments used in the model</p>
</td></tr>
<tr><td><code>type.joint</code></td>
<td>
<p>A code <code>3</code> that represents the joint frailty-copula model. This output is used in other functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a> and
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>
</p>


<h3>References</h3>

<p>Burzykowski, T., Molenberghs, G., Buyse, M., Geys, H., and Renard, D. (2001). Validation
of surrogate end points in multiple randomized clinical trials with failure time end points.
Journal of the Royal Statistical Society: Series C (Applied Statistics) 50, 405-422.
</p>
<p>Buyse, M., Molenberghs, G., Burzykowski, T., Renard, D., and Geys, H. (2000). The validation
of surrogate endpoints in meta-analyses of randomized experiments. Biostatistics 1, 49-67
</p>
<p>Sofeu, C. L., Emura, T., and Rondeau, V. (2019). One-step validation method for surrogate
endpoints using data from multiple randomized cancer clinical trials with failure-time endpoints.
Statistics in Medicine 38, 2928-2942.
</p>
<p>R. B. Nelsen. An introduction to Copulas. Springer, 2006
</p>
<p>Prenen, L., Braekers, R., and Duchateau, L. (2017). Extending the archimedean copula methodology
to model multivariate survival data grouped in clusters of variable size. Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 79, 483-505.
</p>
<p>Sofeu, C. L., Emura, T., and Rondeau, V. (2020). A joint frailty-copula model for meta-analytic
validation of failure time surrogate endpoints in clinical trials. <code>Under review</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurrCopSimul">jointSurrCopSimul</a></code>, <code><a href="#topic+summary.jointSurroPenal">summary.jointSurroPenal</a></code>, <code><a href="#topic+jointSurroPenal">jointSurroPenal</a></code>, <code><a href="#topic+jointSurroPenalSimul">jointSurroPenalSimul</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Data from the advanced ovarian cancer randomized clinical trials.
data(dataOvarian)
joint.surro.Gumbel &lt;- jointSurroCopPenal(data = dataOvarian, int.method = 0,
      n.knots = 8, maxit = 50, kappa.use = 4, nb.mc = 1000, typecopula = 2,
      print.iter = FALSE, scale = 1/365)

print(joint.surro.Gumbel)

joint.surro.Clayton &lt;- jointSurroCopPenal(data = dataOvarian, int.method = 0,
      n.knots = 8, maxit = 50, kappa.use = 4, nb.mc = 1000, typecopula = 1,
      print.iter = FALSE, scale = 1/365)

print(joint.surro.Clayton)

## End(Not run)

</code></pre>

<hr>
<h2 id='jointSurroPenal'>Fit the one-step Joint surrogate model for evaluating a canditate surrogate endpoint</h2><span id='topic+jointSurroPenal'></span>

<h3>Description</h3>


<p><b>Joint Frailty Surrogate model definition</b>
</p>
<p>Fit the one-step Joint surrogate model for the evaluation of a canditate surrogate endpoint,
with different integration methods on the random effects, using a semiparametric penalized
likelihood estimation. This approach extends that of Burzykowski <code>et al.</code> (2001) by
including in the same joint frailty model the individual-level and the trial-level random effects.
This function can also be used for mediation analysis where a direct effect of the surrogate time <code class="reqn">S</code>
on the final endpoint <code class="reqn">T</code> is allowed through a function <code class="reqn">g(S)</code>.
</p>
<p>For the j<sup>th</sup> subject (j=1,...,n<sub>i</sub>) of the i<sup>th</sup>
trial (i=1,...,G), the joint surrogate model is defined as follows:
</p>
<p><img src="../help/figures/surromodel1.png" width="100%" alt="surromodel1.png" />
</p>
<p>where,
<code class="reqn">\omega</code><sub>ij</sub> &#126; <code class="reqn">N</code>(0,<code class="reqn">\theta</code>), u<sub>i</sub> &#126; <code class="reqn">N</code>(0,<code class="reqn">\gamma</code>), <code class="reqn">\omega</code><sub>i</sub> &#8869; u<sub>i</sub>,
u<sub>i</sub> &#8869; v<sub>S<sub>i</sub></sub>, u<sub>i</sub> &#8869; v<sub>T<sub>i</sub></sub>
</p>
<p>and
(v<sub>S<sub>i</sub></sub>,v<sub>T<sub>i</sub></sub>)<sup>T</sup> &#126; <code class="reqn">N</code>(0,<code class="reqn">\Sigma</code><sub>v</sub>)
</p>
<p>with
</p>
<p><img src="../help/figures/surromodel2.png" width="100%" alt="surromodel2.png" />
</p>
<p>In this model, <code class="reqn">\lambda</code><sub>0s</sub>(t) is the baseline hazard function associated with the
surrogate endpoint and <code class="reqn">\beta</code><sub>S</sub> the fixed treatment effect (or log-hazard ratio);
<code class="reqn">\lambda</code><sub>0T</sub>(t) is the baseline hazard function associated with the true endpoint
and <code class="reqn">\beta</code><sub>T</sub> the fixed treatment effect. <code class="reqn">\omega</code><sub>ij</sub> is a shared individual-level frailty that serve to take into account the
heterogeneity in the data at the individual level; u<sub>i</sub> is a shared frailty effect associated
with the baseline hazard function that serve to take into account the heterogeneity between trials
of the baseline hazard function, associated with the fact that we have several trials in this
meta-analytical design. The power parameters <code class="reqn">\zeta</code> and <code class="reqn">\alpha</code> distinguish
both individual and trial-level heterogeneities between the surrogate and the true endpoint.
v<sub>S<sub>i</sub></sub> and v<sub>T<sub>i</sub></sub> are two correlated random effects treatment-by-trial interactions.
<code class="reqn">Z</code><sub>ij1</sub> represents the treatment arm to which the patient has been randomized.
In the mediation analysis setting, the hazard function for the true endpoint
becomes:
</p>
<p><img src="../help/figures/jointsurromed.png" width="100%" alt="jointsurromed.png" />
</p>
<p>where the term I(S<sub>ij</sub>&le; t)g(S<sub>ij</sub>) allows
for a direct effect of the surrogate time <code class="reqn">S</code> on the risk
of occurrence of the final endpoint <code class="reqn">T</code>.
</p>
<p><b>Surrogacy evaluation</b>
</p>
<p>We proposed new definitions of Kendall's <code class="reqn">\tau</code> and coefficient of determination as
individual-level and trial-level association measurements, to evaluate a candidate
surrogate endpoint (Sofeu <em>et al.</em>, 2018). For the surrogacy in the mediation analysis setting
see the &quot;Surrogacy through mediation&quot; Section.
</p>
<p><b>Individual-level surrogacy</b>
</p>
<p>To measure the strength of association between <code class="reqn">S</code><sub>ij</sub> and <code class="reqn">T</code><sub>ij</sub> after
adjusting the marginal distributions for the trial and the treatment effects, as show in
Sofeu <em>et al.</em>(2018), we use the Kendall's <code class="reqn">\tau</code> define by :
</p>
<p><img src="../help/figures/surromodel3.png" width="100%" alt="surromodel3.png" />
</p>
<p>where <code class="reqn">\theta</code>, <code class="reqn">\zeta</code>, <code class="reqn">\alpha</code> and <code class="reqn">\gamma</code> are estimated using the joint surrogate model
defined previously. Kendall's <code class="reqn">\tau</code> is the difference between the probability of
concordance and the probability of discordance of two realizations of <code class="reqn">S</code><sub>ij</sub> and <code class="reqn">T</code><sub>ij</sub>.
It belongs to the interval [-1,1] and assumes a zero value when <code class="reqn">S</code><sub>ij</sub> and <code class="reqn">T</code><sub>ij</sub> are
independent. We estimate Kendall's <code class="reqn">\tau</code> using Monte-Carlo or Gaussian Hermite
quadrature integration methods. Its confidence interval is estimated using parametric
bootstrap
</p>
<p><b>Trial-level surrogacy</b>
</p>
<p>The key motivation for validating a surrogate endpoint is to be able to predict the effect
of treatment on the true endpoint, based on the observed effect of treatment on the
surrogate endpoint. As shown by Buyse <em>et al.</em> (2000), the coefficenient of
determination obtains from the covariance matrix <code class="reqn">\Sigma</code><sub>v</sub> of the random effects
treatment-by-trial interaction can be used to evaluate underlined prediction, and
therefore as surrogacy evaluation measurement at trial-level. It is defined by:
</p>
<p><img src="../help/figures/surromodel4.png" width="100%" alt="surromodel4.png" />
</p>
<p>The SEs of <code class="reqn">R</code><sub>trial</sub><sup>2</sup> is calculated using the Delta-method. We also propose
<code class="reqn">R</code><sub>trial</sub><sup>2</sup> and 95% CI computed using the parametric bootstrap. The use of delta-method
can lead to confidence limits violating the [0,1], as noted by
(Burzykowski <em>et al.</em>, 2001). However, using other methods would not significantly alter
the findings of the surrogacy assessment
</p>
<p><b>Surrogacy through mediation</b>
</p>
<p>In the mediation analysis setting, the surrogacy measure is the proportion of treatment effect
on the final endpoint <code class="reqn">T</code> that goes through its effect on the surrogate <code class="reqn">S</code>.
This measure is a time-dependent function <code class="reqn">PTE(t)</code> defined as:
</p>
<p><img src="../help/figures/pte.png" width="50%" alt="pte.png" />
</p>
<p>where <code class="reqn">NIE</code> and <code class="reqn">TE</code> stand for &quot;natual indirect effect&quot; and &quot;total effect&quot;
respectively. The numerator is the difference of the survival function of <code class="reqn">T</code>
for a subject whose treatment has been set to <code class="reqn">1</code>  (experimental arm) for
both <code class="reqn">S</code> and <code class="reqn">T</code> versus a subject for which the treatment for <code class="reqn">T</code>
is still <code class="reqn">1</code> but is set <code class="reqn">0</code> for <code class="reqn">S</code>. This corresponds
to the indirect effect (in ther of survival probability) of the treatment on <code class="reqn">T</code>
through <code class="reqn">S</code>. The denominator is the total effect of the treatment on <code class="reqn">T</code>.

 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointSurroPenal(data, maxit=50, indicator.zeta = 1,
   indicator.alpha = 1, frail.base = 1, n.knots = 6,
   LIMparam = 0.001, LIMlogl = 0.001, LIMderiv = 0.001,
   nb.mc = 300, nb.gh = 32, nb.gh2 = 20, adaptatif = 0,
   int.method = 2, nb.iterPGH = 5, nb.MC.kendall = 10000,
   nboot.kendall = 1000, true.init.val = 0,
   theta.init = 1, sigma.ss.init = 0.5, sigma.tt.init = 0.5,
   sigma.st.init = 0.48, gamma.init = 0.5, alpha.init = 1,
   zeta.init = 1, betas.init = 0.5, betat.init = 0.5, scale = 1,
   random.generator = 1, kappa.use = 4, random = 0,
   random.nb.sim = 0, seed = 0, init.kappa = NULL, ckappa = c(0,0),
   nb.decimal = 4, print.times = TRUE, print.iter=FALSE,mediation=FALSE,
   g.nknots=1,pte.times=NULL,pte.ntimes=NULL,pte.nmc=500,pte.boot=FALSE,
   pte.nboot=2000,pte.boot.nmc=500,pte.integ.type=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jointSurroPenal_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing at least seven variables entitled:
</p>

<ul>
<li><p><code>patientID:</code> A numeric, that represents the patient's identifier and must be unique;
</p>
</li>
<li><p><code>trialID:</code> A numeric, that represents the trial in which each patient was randomized;
</p>
</li>
<li><p><code>timeS:</code> The follow-up time associated with the surrogate endpoint;
</p>
</li>
<li><p><code>statusS:</code> The event indicator associated with the surrogate endpoint. Normally
0 = no event, 1 = event;
</p>
</li>
<li><p><code>timeT:</code> The follow-up time associated with the true endpoint;
</p>
</li>
<li><p><code>statusT:</code> The event indicator associated with the true endpoint. Normally
0 = no event, 1 = event;
</p>
</li>
<li><p><code>trt:</code> The treatment indicator for each patient, with 1 = treated, 0 = untreated.
</p>
</li></ul>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations for the Marquardt algorithm.
The default being <code>40</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_indicator.zeta">indicator.zeta</code></td>
<td>
<p>A binary, indicates whether the power's parameter <code class="reqn">\zeta</code> should
be estimated (1) or not (0). If <code>0</code>, <code class="reqn">\zeta</code> will be set to <code>1</code> during estimation.
The default is <code>1</code>. This parameter can be set to <code>0</code> in the event of convergence and
identification issues.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_indicator.alpha">indicator.alpha</code></td>
<td>
<p>A binary, indicating whether the power's parameter <code class="reqn">\alpha</code> should
be estimated (1) or not (0). If <code>0</code>, <code class="reqn">\alpha</code> will be set to <code>1</code> during estimation.
The default is 1.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_frail.base">frail.base</code></td>
<td>
<p>A binary, indicating whether the heterogeneity between trial on the baseline risk
is  considered (<code>1</code>) or not (<code>0</code>), using
the shared cluster specific frailties u<sub>i</sub> . The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_n.knots">n.knots</code></td>
<td>
<p>integer giving the number of knots to use. Value required in
the penalized likelihood estimation.  It corresponds to the (n.knots+2)
splines functions for the approximation of the hazard or the survival
functions.  We estimate I or M-splines of order 4. When the user set a
number of knots equals to k (n.knots=k) then the number of interior knots
is (k-2) and the number of splines is (k-2)+order.  Number of knots must be
between 4 and 20. (See <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details).</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_limparam">LIMparam</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
parameters, 10<sup>-3</sup>  by default (See <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details).</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_limlogl">LIMlogl</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
log-likelihood, 10<sup>-3</sup>  by default (See <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details).</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_limderiv">LIMderiv</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the gradient, 10<sup>-3</sup>  by default
(See <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details).</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_nb.mc">nb.mc</code></td>
<td>
<p>Number of samples considered in the Monte-Carlo integration. Required in the event
<code>int.method</code> is equals to <code>0</code>, <code>2</code> or <code>4</code>. A value between 100 and 300 most often gives
good results. However, beyond 300, the program takes a lot of time to estimate the parameters.
The default is <code>300</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_nb.gh">nb.gh</code></td>
<td>
<p>Number of nodes for the Gaussian-Hermite quadrature. It can
be chosen among 5, 7, 9, 12, 15, 20 and 32. The default is 32.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_nb.gh2">nb.gh2</code></td>
<td>
<p>Number of nodes for the Gauss-Hermite quadrature used to re-estimate the model,
in the event of non-convergence, defined as previously. The default is <code>20</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_adaptatif">adaptatif</code></td>
<td>
<p>A binary, indicates whether the pseudo adaptive Gaussian-Hermite quadrature <code>(1)</code> or the classical
Gaussian-Hermite quadrature <code>(0)</code> is used. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_int.method">int.method</code></td>
<td>
<p>A numeric, indicates the integration method: <code>0</code> for Monte carlo,
<code>1</code> for Gaussian-Hermite quadrature, <code>2</code> for a combination of both Gaussian-Hermite quadrature to
integrate over the individual-level random effects and Monte carlo to integrate over the trial-level
random effects, <code>4</code> for a combination of both Monte carlo to integrate over
the individual-level random effects and Gaussian-Hermite quadrature to integrate over the trial-level
random effects. The default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_nb.iterpgh">nb.iterPGH</code></td>
<td>
<p>Number of iterations before the re-estimation of the posterior random effects,
in the event of the two-steps pseudo-adaptive Gaussian-hermite quadrature. If set to <code>0</code> there is no
re-estimation&quot;. The default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_nb.mc.kendall">nb.MC.kendall</code></td>
<td>
<p>Number of generated points used with the Monte-Carlo to estimate
integrals in the Kendall's <code class="reqn">\tau</code> formulation. Beter to use at least 4000 points for
stable reseults. The default is <code>10000</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_nboot.kendall">nboot.kendall</code></td>
<td>
<p>Number of samples considered in the parametric bootstrap to estimate the confidence
interval of the Kendall's <code class="reqn">\tau</code>. The default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_true.init.val">true.init.val</code></td>
<td>
<p>Numerical value. Indicates if the given initial values to parameters <code>(0)</code> should be considered.
If set to <code>2</code>, <code class="reqn">\alpha</code> and <code class="reqn">\gamma</code> are initialised using two separed shared frailty model
(see <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details); <code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>,
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub> and
<code class="reqn">\sigma</code><sub>v<sub>ST</sub></sub>
 are fixed by the user or the default values; <code class="reqn">\zeta</code>,
<code class="reqn">\theta</code>, <code class="reqn">\beta</code><sub>S</sub> and <code class="reqn">\beta</code><sub>T</sub>
 are initialized using a classical joint
frailty model, considering individual level random effects. If the joint frailty model is
faced to convergence issues, <code class="reqn">\beta</code><sub>S</sub> and <code class="reqn">\beta</code><sub>T</sub>
 are initialized using
two shared frailty models.  In all other scenarios, if the simplified model does not converge,
default given parameters values are used. Initial values for spline's associated parameters
are fixed to <code>0.5</code>. The default for this argument is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_theta.init">theta.init</code></td>
<td>
<p>Initial values for <code class="reqn">\theta</code>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_sigma.ss.init">sigma.ss.init</code></td>
<td>
<p>Initial values for 
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_sigma.tt.init">sigma.tt.init</code></td>
<td>
<p>Initial values for 
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_sigma.st.init">sigma.st.init</code></td>
<td>
<p>Initial values for
<code class="reqn">\sigma</code><sub>v<sub>ST</sub></sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.48</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_gamma.init">gamma.init</code></td>
<td>
<p>Initial values for <code class="reqn">\gamma</code>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_alpha.init">alpha.init</code></td>
<td>
<p>Initial values for <code class="reqn">\alpha</code>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_zeta.init">zeta.init</code></td>
<td>
<p>Initial values for <code class="reqn">\zeta</code>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_betas.init">betas.init</code></td>
<td>
<p>Initial values for  <code class="reqn">\beta</code><sub>S</sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_betat.init">betat.init</code></td>
<td>
<p>Initial values for  <code class="reqn">\beta</code><sub>T</sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_scale">scale</code></td>
<td>
<p>A numeric that allows to rescale (multiplication) the survival times, to avoid numerical
problems in the event of some convergence issues. If no change is needed the argument is set to 1, the default value.
eg: <code>1/365</code> aims to convert days to years &quot;.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_random.generator">random.generator</code></td>
<td>
<p>Random number generator used by the Fortran compiler,
<code>1</code> for the intrinsec subroutine <code>Random_number</code> and <code>2</code> for the
subroutine <code>uniran()</code>. The default is <code>1</code>. in the event of convergence problem
with <code>int.method</code> set to <code>0</code>, <code>2</code> or <code>4</code>, that requires
integration by Monte-Carlo, user could change the random numbers generator.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_kappa.use">kappa.use</code></td>
<td>
<p>A numeric, that indicates how to manage the smoothing parameters  k<sub>1</sub>
and  k<sub>2</sub>  in the event of convergence issues. If it is set to <code>1</code>,
the given smoothing parameters or those obtained by cross-validation are used.
If it is set to <code>3</code>, the associated smoothing parameters are successively divided by 10,
in the event of convergence issues until 5 times. If it is set to <code>4</code>, the management of the
smoothing parameter is as in the event <code>1</code>, follows by the successive division as described
in the event <code>3</code> and preceded by the changing of the number of nodes for the Gauss-Hermite quadrature.
The default is <code>4</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_random">random</code></td>
<td>
<p>A binary that says if we reset the random number generation with a different environment
at each call <code>(1)</code> or not <code>(0)</code>. If it is set to <code>1</code>, we use the computer clock
as seed. In the last case, it is not possible to reproduce the generated datasets.
The default is <code>0</code>. Required if <code>random.generator</code> is set to 1.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_random.nb.sim">random.nb.sim</code></td>
<td>
<p>If <code>random</code> is set to <code>1</code>, a binary that indicates the number
of generations that will be made.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_seed">seed</code></td>
<td>
<p>The seed to use for data (or samples) generation. required if <code>random</code> is set to <code>0</code>.
The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_init.kappa">init.kappa</code></td>
<td>
<p>smoothing parameter used to penalized the log-likelihood. By default (init.kappa = NULL) the values used
are obtain by cross-validation.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_ckappa">ckappa</code></td>
<td>
<p>Vector of two fixed values to add to the smoothing parameters. By default it is set to (0,0). this argument allows
to well manage the smoothing parameters in the event of convergence issues.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_nb.decimal">nb.decimal</code></td>
<td>
<p>Number of decimal required for results presentation.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_print.times">print.times</code></td>
<td>
<p>a logical parameter to print estimation time. Default
is TRUE.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_print.iter">print.iter</code></td>
<td>
<p>a logical parameter to print iteration process. Default
is FALSE.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_mediation">mediation</code></td>
<td>
<p>a logical value indicating if the mediation analysis method is used.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_g.nknots">g.nknots</code></td>
<td>
<p>In the case of a mediation analysis, indicates how many inner knots
are used in the splines basis for estimating the function <code class="reqn">g(s)</code>.
The value of <code>g.nknots</code> should be between 1 and 5. Default is 1.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_pte.times">pte.times</code></td>
<td>
<p>In the mediation analysis setting, a vector of times for which the
funtion <code class="reqn">PTE(t)</code> is evaluated. Specified time points must be in the range of
the observed event times. The length of the vector should be less than 200.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_pte.ntimes">pte.ntimes</code></td>
<td>
<p>In the mediation setting, if the argument <code>pte.times</code> is not specified
the argument <code>pte.ntimes</code> allows the user to only specify a number of
time points for which the function <code class="reqn">PTE(t)</code> has to be computed. This argument
is only to be used if <code>pte.times</code> is not specified. In that case
the default value for <code>pte.ntimes</code> is 10. The value of <code>pte.ntimes</code>
should be less than 200.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_pte.nmc">pte.nmc</code></td>
<td>
<p>An integer indicating how many Monte Carlo simulations are used
to integrate over the random effects in the computation of the function <code class="reqn">PTE(t)</code>.
in the mediation analysis setting. Default is 500.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_pte.boot">pte.boot</code></td>
<td>
<p>A logical value indicating if bootstrapped confidence bands needs to be computed for the
function <code class="reqn">PTE(t)</code> in the mediation analysis setting. Default is FALSE.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_pte.nboot">pte.nboot</code></td>
<td>
<p>An integer indicating how many bootstrapped replicates of <code class="reqn">PTE(t)</code> needs
to be computed to derive confidence bands for <code class="reqn">PTE(t)</code>. Default is 2000.</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_pte.boot.nmc">pte.boot.nmc</code></td>
<td>
<p>If <code>pte.boot</code> is TRUE, indicates how many Monte Carlo simulations are used
to integrate over the random effects in the bootstrapped functions <code class="reqn">PTE(t)</code>
in the mediation analysis setting. Default is 500</p>
</td></tr>
<tr><td><code id="jointSurroPenal_+3A_pte.integ.type">pte.integ.type</code></td>
<td>
<p>An integer indicating which type of integration over the distribution of
<code class="reqn">S</code> should be used in the computation of the function
<code class="reqn">PTE(t)</code>. If set to <code>1</code>, a simple trapezoidal rule is used with 300 integration points.
If set to <code>2</code> a Gauss-Laguerre quadrature is used with 30 knots. Default is <code>2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The estimated parameter are obtained using the robust Marquardt algorithm
(Marquardt, 1963) which is a combination between a Newton-Raphson algorithm
and a steepest descent algorithm. The iterations are stopped when the
difference between two consecutive log-likelihoods was small
(&lt;
10<sup>-3</sup> ), the estimated
coefficients were stable (consecutive
values (&lt; 10<sup>-3</sup> )), and the gradient
small enough (&lt; 10<sup>-3</sup> ), by default.
Cubic M-splines of order 4 are used for the hazard function, and I-splines (integrated M-splines) are
used for the cumulative hazard function.
</p>
<p>The inverse of the Hessian matrix is the variance estimator and to deal
with the positivity constraint of the variance component and the spline
coefficients, a squared transformation is used and the standard errors are
computed by the <code class="reqn">\Delta</code>-method (Knight &amp; Xekalaki, 2000). The smooth
parameter can be chosen by maximizing a likelihood cross validation
criterion (Joly and other, 1998).
</p>
<p>We proposed based on the joint surrogate model a new definition
of the Kendall's <code class="reqn">\tau</code>. Moreover, distinct numerical integration methods are available to approximate the
integrals in the marginal log-likelihood.
</p>
<p><b>Non-convergence case management procedure</b>
</p>
<p>Special attention must be given to initializing model parameters, the choice of the number of
spline knots, the smoothing parameters and the number of quadrature points to solve convergence
issues. We first initialized parameters using the user's desired strategy, as specified
by the option <code>true.init.val</code>. When numerical or convergence problems are encountered,
with <code>kappa.use</code> set to <code>4</code>, the model is fitted again using a combination of the following strategies:
vary the number of quadrature point (<code>nb.gh</code> to <code>nb.gh2</code> or <code>nb.gh2</code> to <code>nb.gh</code>)
in the event of the use of the Gaussian Hermite quadrature integration (see <code>int.method</code>);
divided or multiplied the smoothing parameters ( k<sub>1</sub>,
 k<sub>2</sub>) by 10 or 100 according to
their preceding values, or used parameter vectors obtained during the last iteration (with a
modification of the number of quadrature points and smoothing parameters). Using this strategy,
we usually obtained during simulation the rejection rate less than 3%. A sensitivity analysis
was conducted without this strategy, and similar results were obtained on the converged samples,
with about a 23% rejection rate.

</p>


<h3>Value</h3>

<p>This function return an object of class jointSurroPenal or jointSurroMed in the mediation analysis setting with elements:
</p>
<table role = "presentation">
<tr><td><code>EPS</code></td>
<td>
<p>A vector containing the obtained convergence thresholds with the Marquardt algorithm,
for the parameters, the log-likelihood and for the gradient;</p>
</td></tr>
<tr><td><code>b</code></td>
<td>

<p>A vector containing estimates for the splines parameter's;
the power's parameter <code class="reqn">\zeta</code> (if <code>indicator.zeta</code> is set to <code>1</code>),
the standard error of the shared individual-level frailty <code class="reqn">\omega</code><sub>ij</sub> (<code class="reqn">\theta</code>),elements of the
lower triangular matrix (L) from the Cholesky decomposition such that <code class="reqn">\Sigma</code> = LL<sup>T</sup>, with <code class="reqn">\Sigma</code>
the covariance of the random effects (v<sub>S<sub>i</sub></sub>,v<sub>T<sub>i</sub></sub>);
the coefficient <code class="reqn">\alpha</code> (if <code>indicator.alpha</code> is set to <code>1</code>); the satandard error
of the random effect <code>u</code><sub>i</sub>and the regression coefficients <code class="reqn">\beta</code><sub>S</sub>
and <code class="reqn">\beta</code><sub>T</sub>;
</p>
</td></tr>
<tr><td><code>varH</code></td>
<td>
<p>The variance matrix of all parameters in <code>b</code> (before positivity constraint transformation
for the variance of the measurement error, for which the delta method is used);</p>
</td></tr>
<tr><td><code>varHIH</code></td>
<td>
<p>The robust estimation of the variance matrix of all parameters in <code>b</code>;</p>
</td></tr>
<tr><td><code>loglikPenal</code></td>
<td>
<p>The complete marginal penalized log-likelihood;</p>
</td></tr>
<tr><td><code>LCV</code></td>
<td>
<p>the approximated likelihood cross-validation criterion in the semiparametric case (with <code>H</code>
minus the converged Hessian matrix, and <code>l(.)</code> the full log-likelihood).

<img src="../help/figures/lcv.png" width="50%" alt="lcv.png" />
</p>
</td></tr>
<tr><td><code>xS</code></td>
<td>
<p>vector of times for surrogate endpoint where both survipte.nmc.bootval and hazard function are estimated.
By default seq(0,max(time),length=99), where time is the vector of survival times;</p>
</td></tr>
<tr><td><code>lamS</code></td>
<td>
<p>array (dim = 3) of hazard estimates and confidence bands, for surrogate endpoint;</p>
</td></tr>
<tr><td><code>survS</code></td>
<td>
<p>array (dim = 3) of baseline survival estimates and confidence bands, for surrogate endpoint;</p>
</td></tr>
<tr><td><code>xT</code></td>
<td>
<p>vector of times for true endpoint where both survival and hazard function are estimated.
By default seq(0, max(time), length = 99), where time is the vector of survival times;</p>
</td></tr>
<tr><td><code>lamT</code></td>
<td>
<p>array (dim = 3) of hazard estimates and confidence bands, for true endpoint;</p>
</td></tr>
<tr><td><code>survT</code></td>
<td>
<p>array (dim = 3) of baseline survival estimates and confidence bands, for true endpoint;</p>
</td></tr>
<tr><td><code>n.iter</code></td>
<td>
<p>number of iterations needed to converge;</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Estimate for <code class="reqn">\theta</code>;</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>Estimate for <code class="reqn">\gamma</code>;</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Estimate for <code class="reqn">\alpha</code>;</p>
</td></tr>
<tr><td><code>zeta</code></td>
<td>
<p>Estimate for <code class="reqn">\zeta</code>;</p>
</td></tr>
<tr><td><code>sigma.s</code></td>
<td>
<p>Estimate for <code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>;</p>
</td></tr>
<tr><td><code>sigma.t</code></td>
<td>
<p>Estimate for <code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub>;</p>
</td></tr>
<tr><td><code>sigma.st</code></td>
<td>
<p>Estimate for  <code class="reqn">\sigma</code><sub>v<sub>ST</sub></sub>;</p>
</td></tr>
<tr><td><code>beta.s</code></td>
<td>
<p>Estimate for  <code class="reqn">\beta</code><sub>S</sub>;</p>
</td></tr>
<tr><td><code>beta.t</code></td>
<td>
<p>Estimate for  <code class="reqn">\beta</code><sub>T</sub>;</p>
</td></tr>
<tr><td><code>ui</code></td>
<td>
<p>A binary, that indicates if the heterogeneity between trial on the baseline risk
has been Considered (<code>1</code>), using the shared cluster specific frailties 
(<code>u</code><sub>i</sub>),
or not (<code>0</code>);</p>
</td></tr>
<tr><td><code>ktau</code></td>
<td>
<p>The Kendall's <code class="reqn">\tau</code> with the correspondant 95  <code class="reqn">\%</code> CI computed using the parametric bootstrap;</p>
</td></tr>
<tr><td><code>R2.boot</code></td>
<td>
<p>The 
<code>R</code><sup>2</sup><sub>trial</sub> with the correspondant 95 <code class="reqn">\%</code> CI computed using the parametric bootstrap;</p>
</td></tr>
<tr><td><code>Coefficients</code></td>
<td>
<p>The estimates with the corresponding standard errors and the 95 <code class="reqn">\%</code> CI</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>Positive smoothing parameters used for convergence. These values could be different to initial
values if <code>kappa.use</code> is set to <code>3</code> or <code>4</code>;</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The value used to rescale the survival times</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The dataset used in the model</p>
</td></tr>
<tr><td><code>varcov.Sigma</code></td>
<td>
<p>covariance matrix of 
the estimates of (<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>,<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub>,
<code class="reqn">\sigma</code><sub>v<sub>ST</sub></sub>)
obtained from the delta-method</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>list of all arguments used in the model</p>
</td></tr>
<tr><td><code>mediation</code></td>
<td>
<p>List returned in the case where the option <code>mediation</code> is set to <code>TRUE</code> which contains:
</p>

<ul>
<li><p> data.pte: A dataframe containing estimated values for the funtion <code class="reqn">PTE(t)</code> and the natural effects for differents time points
</p>
</li>
<li><p> g.knots: The vector of knots used in the spline basis for the function g.
</p>
</li>
<li><p> g.order: The order of the spline basis used to estimate the function g.
</p>
</li>
<li><p> g.coefficients: A vector containing the estimated coefficients associated with the splines in the estimation of the function g.
</p>
</li>
<li><p> data.g: A dataframe containing the values of the estimated function g computed at several time points and the associated 95
</p>
</li>
<li><p> pte.ci: A dataframe containing the 95
</p>
</li>
<li><p> TE.ci: A dataframe containing the 95
</p>
</li>
<li><p> NDE.ci: A dataframe containing the 95
</p>
</li>
<li><p> NIE.ci: A dataframe containing the 95
</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a>,
Quentin Le Coent <a href="mailto:quentin.le-coent@u-bordeaux.fr">quentin.le-coent@u-bordeaux.fr</a>  and
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>,
</p>


<h3>References</h3>

<p>Burzykowski, T., Molenberghs, G., Buyse, M., Geys, H., and Renard, D. (2001). Validation
of surrogate end points in multiple randomized clinical trials with failure time end points.
Journal of the Royal Statistical Society: Series C (Applied Statistics) 50, 405-422.
</p>
<p>Buyse, M., Molenberghs, G., Burzykowski, T., Renard, D., and Geys, H. (2000). The validation
of surrogate endpoints in meta-analyses of randomized experiments. Biostatistics 1, 49-67
</p>
<p>Sofeu, C. L., Emura, T., and Rondeau, V. (2019). One-step validation method for surrogate
endpoints using data from multiple randomized cancer clinical trials with failure-time endpoints.
Statistics in Medicine 38, 2928-2942.
</p>
<p>Le Coent, Q., Legrand, C., Rondeau, V. (2021). Time-to-event surrogate endpoint validation
using mediation and meta-analytic data. Article submitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurrSimul">jointSurrSimul</a></code>, <code><a href="#topic+summary.jointSurroPenal">summary.jointSurroPenal</a></code>, <code><a href="#topic+jointSurroPenalSimul">jointSurroPenalSimul</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Generation of data to use
data.sim &lt;- jointSurrSimul(n.obs=600, n.trial = 30,cens.adm=549.24,
         alpha = 1.5, theta = 3.5, gamma = 2.5, zeta = 1, sigma.s = 0.7,
         sigma.t = 0.7, cor = 0.8, betas = -1.25, betat = -1.25,
         full.data = 0, random.generator = 1, seed = 0, nb.reject.data = 0)


#Surrogacy evaluation based on generated data with a combination of Monte Carlo
#and classical Gaussian Hermite integration.*
# (Computation takes around 5 minutes)

joint.surro.sim.MCGH &lt;- jointSurroPenal(data = data.sim, int.method = 2,
                   nb.mc = 300, nb.gh = 20)

#Surrogacy evaluation based on generated data with a combination of Monte Carlo
# and Pseudo-adaptive Gaussian Hermite integration.
# (Computation takes around 4 minutes)

joint.surro.sim.MCPGH &lt;- jointSurroPenal(data = data.sim, int.method = 2,
                   nb.mc = 300, nb.gh = 20, adaptatif = 1)

# Results
summary(joint.surro.sim.MCGH)
summary(joint.surro.sim.MCPGH)

# Data from the advanced ovarian cancer randomized clinical trials.
# Joint surrogate model with \eqn{\zeta} fixed to 1, 8 nodes spline
# and the rescaled survival time.

data(dataOvarian)
# (Computation takes around 20 minutes)

joint.surro.ovar &lt;- jointSurroPenal(data = dataOvarian, n.knots = 8,
                init.kappa = c(2000,1000), indicator.alpha = 0, nb.mc = 200,
                scale = 1/365)
# results
summary(joint.surro.ovar)

print(joint.surro.ovar)


# Mediation analysis on the adjuvant chemotherapy
# dataset where the surrogate is a time-to-relapse and the final endpoint is death.
# 4 knots are used to estimate the two baseline hazard functions.
# The function g(s) is estimated using cubic b-splines with 1 interior
# knot ('g.nkots=1'). The function \eqn{PTE(t)} is computed at 100 time points
# using 10.000 Monte Carlo simulations for integration over the random effects.
# To reduce computation time in the provided example only one fifth of the
# the original dataset is used and the confidence bands for the function
# \eqn{PTE(t)} are not computed as well as the power parameters associated with
# the random effects. Full example is commented thereafter.

# We first need to change the variable "statusS" which in the dataset
# encodes the indicator of a disease free survival event to an indicator
# of a time to relapse event (i.e., resurgence of cancer or
# onset of a second cancer) that excludes death as a composite event.
# Thus, the patients whose variables "timeS" and "timeT" are equal
# and whose variable "statusS" is equal to 1 will have
# "statuS" be set to 0. We do this because composite endpoint may not
# be appropriate in the setting of mediation analysis.

data(gastadj)
gastadj$timeS&lt;-gastadj$timeS/365
gastadj$timeT&lt;-gastadj$timeT/365
#here changing "statusS" to corresponds to a time to relapse event
gastadj[gastadj$timeS==gastadj$timeT &amp; gastadj$statusS==1,c("statusS")]&lt;-0

# select 20% of the original dataset
set.seed(1)
n&lt;-nrow(gastadj)
subset&lt;-gastadj[sort(sample(1:nrow(gastadj),round(n*0.2),replace = FALSE)),]

# Mediation model ('mediation=TRUE'). Computation takes around 17 minutes
mod.gast&lt;-jointSurroPenal(subset,n.knots = 4,indicator.zeta = 0,
                         indicator.alpha = 0,mediation=TRUE,g.nknots=1,
                         pte.ntimes=30,pte.nmc=10000,pte.boot=FALSE)

summary(mod.gast)
plot(mod.gast)

# Example on the full dataset, including estimation of the power parameters
# mod.gast2&lt;-jointSurroPenal(gastadj,n.knots = 4,mediation=TRUE,g.nknots=1,
#                            pte.ntimes=30,pte.nmc=10000,pte.boot=TRUE,
#                            pte.nboot=2000,pte.boot.nmc=10000)

# results
# plot(mod.gast2)
# summary(mod.gast2)

## End(Not run)
</code></pre>

<hr>
<h2 id='jointSurroPenalSimul'>Simulation studies based on the one-step Joint surrogate models for the evaluation of a canditate
surrogate endpoint</h2><span id='topic+jointSurroPenalSimul'></span>

<h3>Description</h3>


<p>This function aims to allow simulation studies, based on the joint frailty surrogate model,
described in <a href="#topic+jointSurroPenal">jointSurroPenal</a>. Simulation can also be based on the joint frailty-copula
model described in <a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a>

</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointSurroPenalSimul(maxit=40, indicator.zeta = 1,
   indicator.alpha = 1, frail.base = 1, n.knots = 6, nb.dataset = 1,
   nbSubSimul=1000, ntrialSimul=30, LIMparam = 0.001,
   LIMlogl = 0.001, LIMderiv = 0.001, nb.mc = 300, nb.gh = 32,
   nb.gh2 = 20, adaptatif = 0, int.method = 2, nb.iterPGH = 5,
   nb.MC.kendall = 10000, nboot.kendall = 1000, true.init.val = 0,
   theta.init = 1, sigma.ss.init = 0.5, sigma.tt.init = 0.5,
   sigma.st.init = 0.48, gamma.init = 0.5, alpha.init = 1,
   zeta.init = 1, betas.init = 0.5, betat.init = 0.5,
   random.generator = 1, equi.subj.trial = 1, prop.subj.trial = NULL,
   equi.subj.trt = 1, prop.subj.trt = NULL,
   theta2 = 3.5, zeta = 1, gamma.ui = 2.5, alpha.ui = 1,
   betas = -1.25, betat = -1.25, lambdas = 1.8, nus = 0.0045,
   lambdat = 3, nut = 0.0025, prop.cens = 0, time.cens = 549, R2 = 0.81,
   sigma.s = 0.7, sigma.t = 0.7, kappa.use = 4, random = 0,
   random.nb.sim = 0, seed = 0, nb.reject.data = 0, init.kappa = NULL,
   ckappa = c(0,0), type.joint.estim = 1, type.joint.simul = 1,
   mbetast =NULL, mbetast.init = NULL, typecopula =1, theta.copula = 6,
   thetacopula.init = 3, filter.surr = c(1), filter.true = c(1),
   nb.decimal = 4, pfs = 0, print.times = TRUE, print.iter=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jointSurroPenalSimul_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations for the Marquardt algorithm.
Default is <code>40</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_indicator.zeta">indicator.zeta</code></td>
<td>
<p>A binary, indicates whether the power's parameter <code class="reqn">\zeta</code> should
be estimated (1) or not (0). It is required if <code>type.joint.estim = 1</code>.
If <code>0</code>, <code class="reqn">\zeta</code> will be set to <code>1</code> during estimation.
The default is <code>1</code>. This parameter can be seted to <code>0</code> in the event of identification issues.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_indicator.alpha">indicator.alpha</code></td>
<td>
<p>A binary, indicates whether the power's parameter <code class="reqn">\alpha</code> should
be estimated (1) or not (0). If <code>0</code>, <code class="reqn">\alpha</code> will be set to <code>1</code> during estimation.
The default is 1. This parameter can be seted to <code>0</code> in the event of identification issues.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_frail.base">frail.base</code></td>
<td>
<p>Considered the heterogeneity between trial on the baseline risk (<code>1</code>), using
the shared cluster specific frailties u<sub>i</sub> , or
not (<code>0</code>). The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_n.knots">n.knots</code></td>
<td>
<p>integer giving the number of knots to use. Value required in
the penalized likelihood estimation.  It corresponds to the (n.knots+2)
splines functions for the approximation of the hazard or the survival
functions.  We estimate I or M-splines of order 4. When the user set a
number of knots equals to k (n.knots=k) then the number of interior knots
is (k-2) and the number of splines is (k-2)+order.  Number of knots must be
between 4 and 20. (See <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details).</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_nb.dataset">nb.dataset</code></td>
<td>
<p>Number of dataset to analyze. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_nbsubsimul">nbSubSimul</code></td>
<td>
<p>Number of subjects.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_ntrialsimul">ntrialSimul</code></td>
<td>
<p>Number of trials.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_limparam">LIMparam</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
parameters, 10<sup>-3</sup> 
by default (See <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details).</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_limlogl">LIMlogl</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
log-likelihood, 10<sup>-3</sup> 
by default (See <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details).</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_limderiv">LIMderiv</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the gradient,
10<sup>-3</sup>  by default
(See <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details).</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_nb.mc">nb.mc</code></td>
<td>
<p>Number of samples considered in the Monte-Carlo integration. Required in the event
<code>int.method</code> is equals to <code>0</code>, <code>2</code> or <code>4</code>. A value between 100 and 300 most often gives
good results. However, beyond 300, the program takes a lot of time to estimate the parameters.
The default is <code>300</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_nb.gh">nb.gh</code></td>
<td>
<p>Number of nodes for the Gaussian-Hermite quadrature. It can
be chosen among 5, 7, 9, 12, 15, 20 and 32. The default is 32.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_nb.gh2">nb.gh2</code></td>
<td>
<p>Number of nodes for the Gauss-Hermite quadrature used to re-estimate the model,
in the event of non-convergence, defined as previously. The default is <code>20</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_adaptatif">adaptatif</code></td>
<td>
<p>A binary, indicates whether the pseudo adaptive Gaussian-Hermite quadrature
<code>(1)</code> or the classical Gaussian-Hermite quadrature <code>(0)</code> is used. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_int.method">int.method</code></td>
<td>
<p>A numeric, indicates the integration method: <code>0</code> for Monte carlo,
<code>1</code> for Gaussian-Hermite quadrature. If <code>type.joint.estim = 1</code> this parameter can be set to
<code>2</code> for a combination of both Gaussian-Hermite quadrature to
integrate over the individual-level random effects and Monte carlo to integrate over the trial-level
random effects, <code>4</code> for a combination of both Monte carlo to integrate over
the individual-level random effects and Gaussian-Hermite quadrature to integrate over the trial-level
random effects. If <code>type.joint.estim = 3</code>, value <code>3</code> indicates integration using Laplace
approximation . The default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_nb.iterpgh">nb.iterPGH</code></td>
<td>
<p>Number of iterations before the re-estimation of the posterior random effects,
in the event of the two-steps pseudo-adaptive Gaussian-hermite quadrature. If set to <code>0</code> there is no
re-estimation&quot;. The default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_nb.mc.kendall">nb.MC.kendall</code></td>
<td>
<p>Number of generated points used with the Monte-Carlo to estimate
integrals in the Kendall's <code class="reqn">\tau</code> formulation. Beter to use at least 4000 points for
stable results. Required if <code>type.joint.estim = 1</code>, the default is <code>10000</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_nboot.kendall">nboot.kendall</code></td>
<td>
<p>Number of samples considered in the parametric bootstrap to estimate the confidence
interval of the Kendall's <code class="reqn">\tau</code>, or <code>R</code>&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;trial&lt;/sub&gt;. The default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_true.init.val">true.init.val</code></td>
<td>
<p>Numerical value. Indicates if the real parameter values
<code>(1)</code>, or the given initial values to parameters <code>(0)</code> should be considered.
If set to <code>2</code>, <code class="reqn">\alpha</code> and <code class="reqn">\gamma</code> are initialised using two separed shared frailty model
(see <code><a href="#topic+frailtyPenal">frailtyPenal</a></code> for more details); <code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>, <code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub> and
<code class="reqn">\sigma</code><sub>v<sub>ST</sub></sub>
 are fixed using the default initial values given by the user; <code class="reqn">\zeta</code>,
<code class="reqn">\theta</code>, <code class="reqn">\beta</code><sub>S</sub> and <code class="reqn">\beta</code><sub>T</sub>
 are initialized using a classical joint
frailty model, considering individual level random effects. If the joint frailty model is
faced to convergence issues, <code class="reqn">\beta</code><sub>S</sub> and <code class="reqn">\beta</code><sub>T</sub>
 are initialized using
two shared frailty models.  In all others scenarios, if the simplified model does not converge,
default given parameters values are used. Initial values for spline's associated parameters
are fixed to <code>0.5</code>. The default for this argument is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_theta.init">theta.init</code></td>
<td>
<p>Initial values for <code class="reqn">\theta</code>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>, and <code>type.joint.estim = 1</code>. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_sigma.ss.init">sigma.ss.init</code></td>
<td>
<p>Initial values for 
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_sigma.tt.init">sigma.tt.init</code></td>
<td>
<p>Initial values for 
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_sigma.st.init">sigma.st.init</code></td>
<td>
<p>Initial values for 
<code class="reqn">\sigma</code><sub>v<sub>ST</sub></sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.48</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_gamma.init">gamma.init</code></td>
<td>
<p>Initial values for <code class="reqn">\gamma</code>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_alpha.init">alpha.init</code></td>
<td>
<p>Initial values for <code class="reqn">\alpha</code>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_zeta.init">zeta.init</code></td>
<td>
<p>Initial values for <code class="reqn">\zeta</code>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code> and <code>type.joint.estim = 1</code>. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_betas.init">betas.init</code></td>
<td>
<p>Initial values for  <code class="reqn">\beta</code><sub>S</sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_betat.init">betat.init</code></td>
<td>
<p>Initial values for  <code class="reqn">\beta</code><sub>T</sub>, required if <code>true.init.val</code>
is set to <code>0</code> or <code>2</code>. The default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_random.generator">random.generator</code></td>
<td>
<p>Random number generator used by the Fortran compiler,
<code>1</code> for the intrinsec subroutine <code>Random_number</code> and <code>2</code> for the
subroutine <code>uniran()</code>. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_equi.subj.trial">equi.subj.trial</code></td>
<td>
<p>A binary, that indicates if the same proportion of subjects per trial
should be considered in the procces of data generation (1) or not (0). In the event of
different trial sizes, fill in <code>prop.subj.trial</code> the proportions
of subjects to be considered per trial. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_prop.subj.trial">prop.subj.trial</code></td>
<td>
<p>Vector of the proportions of subjects to consider per trial.
Requires if the argument <code>equi.subj.trial</code> is different to <code>1</code>. The size of this vector is equal to the
number of trials.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_equi.subj.trt">equi.subj.trt</code></td>
<td>
<p>Indicates if the same proportion of treated subjects per trial should be
considered <code>(1)</code> or not <code>(0)</code>. If <code>0</code>, fill in <code>prop.subj.trt</code>
the proportions of treated subjects to be considered per trial. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_prop.subj.trt">prop.subj.trt</code></td>
<td>
<p>Vector of the proportions of treated subjects to consider per trial.
Requires if the argument <code>equi.subj.trt</code> is different to <code>0.5</code>. The size of this vector is equal to the
number of trials.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_theta2">theta2</code></td>
<td>
<p>True value for <code class="reqn">\theta</code>. Require if <code>type.joint.simul = 1</code>, the default is <code>3.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_zeta">zeta</code></td>
<td>
<p>True value for <code class="reqn">\zeta</code> in the event of simulation. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_gamma.ui">gamma.ui</code></td>
<td>
<p>True value for <code class="reqn">\gamma</code> in the event of simulation. The default is <code>2.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_alpha.ui">alpha.ui</code></td>
<td>
<p>True value for <code class="reqn">\alpha</code> in the event of simulation. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_betas">betas</code></td>
<td>
<p>True value for  <code class="reqn">\beta</code><sub>S</sub> in the event of simulation. The default is <code>-1.25</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_betat">betat</code></td>
<td>
<p>True value for  <code class="reqn">\beta</code><sub>T</sub> in the event of simulation. The default is <code>-1.25</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_lambdas">lambdas</code></td>
<td>
<p>Desired scale parameter for the <code>Weibull</code> distribution associated with the Surrogate
endpoint. The default is <code>1.8</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_nus">nus</code></td>
<td>
<p>Desired shape parameter for the <code>Weibull</code> distribution associated with the Surrogate
endpoint. The default is <code>0.0045</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_lambdat">lambdat</code></td>
<td>
<p>Desired scale parameter for the <code>Weibull</code> distribution associated with the True
endpoint.The default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_nut">nut</code></td>
<td>
<p>Desired shape parameter for the <code>Weibull</code> distribution associated with the True endpoint.
The default is <code>0.0025</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_prop.cens">prop.cens</code></td>
<td>
<p>A value between <code>0</code> and <code>1</code>, <code>1-prop.cens</code> is the minimum proportion of people who are randomly censored.
Represents the quantile to use for generating the random censorship time. In this case, the censorship
time follows a uniform distribution in <code>1</code> and <code>(prop.cens)ieme</code> percentile of the
generated death times. If this argument is set to <code>0</code>, the fix censorship is considered.
The default is <code>0</code>. Required if <code>type.joint.simul = 3</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_time.cens">time.cens</code></td>
<td>
<p>Censorship time. If argument <code>prop.cens</code> is set to <code>0</code>, it represents
the administrative censorship time, else it represents the fix censoring time. The default is <code>549</code>,
for about <code>40%</code> of fix censored subjects.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_r2">R2</code></td>
<td>
<p>Desired 
<code>R</code><sup>2</sup><sub>trial</sub>. The default is <code>0.81</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_sigma.s">sigma.s</code></td>
<td>
<p>True value for <code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>
The default is <code>0.7</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_sigma.t">sigma.t</code></td>
<td>
<p>True value for <code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub>. The default is <code>0.7</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_kappa.use">kappa.use</code></td>
<td>
<p>A numeric, that indicates how to manage the smoothing parameters  k<sub>1</sub>
and  k<sub>2</sub> in the event of convergence issues. If it is set
to <code>0</code>, the first smoothing parameters that allowed convergence on the first dataset is used
for all simulations. if it is set to <code>1</code>, a smoothing parameter is estimated by cross-validation
for each dataset generated. If it is set to <code>2</code>, the same process for chosing kappas as in the event
<code>1</code> is used, but in the event of convergence issue, the first smoothing parameters that allowed
convergence among the three previous that have worked is used. If it is set to <code>3</code>, the associated
smoothing parameters are successively divided by 10, in the event of convergence issues until 5 times.
If it is set to <code>4</code>, the management of the smoothing
parameters is as in the event <code>2</code>, preceded by the successive division described in the event <code>3</code> and
by the changing of the number of nodes for the Gauss-Hermite quadrature. The default is <code>4</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_random">random</code></td>
<td>
<p>A binary that says if we reset the random number generation with a different environment
at each call <code>(1)</code> or not <code>(0)</code>. If it is set to <code>1</code>, we use the computer clock
as seed. In the last case, it is not possible to reproduce the generated datasets.
The default is <code>0</code>. Required if <code>random.generator</code> is set to 1.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_random.nb.sim">random.nb.sim</code></td>
<td>
<p>If <code>random</code> is set to <code>1</code>, a binary that indicates the number
of generations that will be made, equal to <code>nb.dataset</code> in this case.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_seed">seed</code></td>
<td>
<p>The seed to use for data generation. Required if <code>random</code> is set to <code>0</code>.
The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_nb.reject.data">nb.reject.data</code></td>
<td>
<p>When the simulations have been split into several packets, this argument
indicates the number of generated datasets to reject before starting the simulations studies.
This prevents to reproduce the same datasets for all simulation packages. It must be set to
<code>0</code> if just one packet is considered, the default. Otherwise for each packet of simulation
run, this value must be updated.
e.g. If 10 packets are considered for a total of 100 datasets, one can assigned 0 for the first packet run,
10 for the second, 20 for the 3rd, ... , 90 for the 10th. If this argument is different to <code>0</code>,
the argument <code>nb.dataset</code> must be set to the number of dataset to consider in the packet.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_init.kappa">init.kappa</code></td>
<td>
<p>smoothing parameter used to penalized the log-likelihood. By default (init.kappa = NULL) the values used
are obtain by cross-validation.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_ckappa">ckappa</code></td>
<td>
<p>Vector of two constantes to add to the smoothing parameters. By default it is set to (0,0). this argument allows
to well manage the smoothing parameters in the event of convergence issues.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_type.joint.estim">type.joint.estim</code></td>
<td>
<p>Model to considered for the estimation. If this argument is set to <code>1</code>, the joint surrogate model
is used, the default (see <a href="#topic+jointSurroPenal">jointSurroPenal</a>). If set to <code>3</code>, parameters are estimated under the joint frailty-copula model
for surrogacy (see <a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a>).</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_type.joint.simul">type.joint.simul</code></td>
<td>
<p>Model to considered for data generation. If this argument is set to <code>1</code>, the joint surrogate model
is used, the default (see <a href="#topic+jointSurroPenal">jointSurroPenal</a>). If set to <code>3</code>, data are generated following the joint frailty-copula model
for surrogacy (see <a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a>).</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_mbetast">mbetast</code></td>
<td>
<p>Matrix or dataframe containing the true fixed traitment effects associated with the covariates. This matrix includes
two columns (first one for surrogate endpoint and second one for true endpoint) and the number of row corresponding
to the number of covariate. Require if <code>type.joint.simul = 3</code> with more than one covariate. The default
is NULL and assume only the treatment effect</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_mbetast.init">mbetast.init</code></td>
<td>
<p>Matrix or dataframe containing the initial values for the fixed effects associated with the covariates. This matrix include
two columns (first one for surrogate endpoint and second one for true endpoint) and the number of row corresponding
to the number of covariate. Require if <code>type.joint.simul = 3</code> with more than one covariate. The default
is NULL and assume only the treatment effect</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_typecopula">typecopula</code></td>
<td>
<p>The copula function used for estimation: 1 = clayton, 2 = Gumbel. Require if <code>type.joint.simul = 3</code>, the default is 1</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_theta.copula">theta.copula</code></td>
<td>
<p>The copula parameter. Require if <code>type.joint.simul = 3</code>. The default is <code>6</code>, for an individual-level
association (kendall's <code class="reqn">\tau</code>) of 0.75 in the event of Clayton copula</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_thetacopula.init">thetacopula.init</code></td>
<td>
<p>Initial value for the copula parameter. Require if <code>type.joint.estim = 3</code>, the default is 3</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_filter.surr">filter.surr</code></td>
<td>
<p>Vector of size the number of covariates, with the i-th element that indicates if the hazard for
surrogate is adjusted on the i-th covariate (code 1) or not (code 0). By default, only the treatment effect is
considered.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_filter.true">filter.true</code></td>
<td>
<p>Vector defines as <code>filter.surr</code>, for true endpoint. <code>filter.true</code> and <code>filter.surr</code>
should have the same size</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_nb.decimal">nb.decimal</code></td>
<td>
<p>Number of decimal required for results presentation.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_pfs">pfs</code></td>
<td>
<p>Is used to specified if the time to progression should be censored by the death time (0) or not (1).
The default is 0. In the event with pfs set to 1, death is included in the surrogate endpoint as in the definition of PFS or DFS.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_print.times">print.times</code></td>
<td>
<p>a logical parameter to print estimation time. Default
is TRUE.</p>
</td></tr>
<tr><td><code id="jointSurroPenalSimul_+3A_print.iter">print.iter</code></td>
<td>
<p>a logical parameter to print iteration process. Default
is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The estimated parameter are obtained using the robust Marquardt algorithm
(Marquardt, 1963) which is a combination between a Newton-Raphson algorithm
and a steepest descent algorithm. The iterations are stopped when the
difference between two consecutive log-likelihoods was small
(&lt;10<sup>-3</sup> ), the estimated coefficients were stable (consecutive
values (&lt;10<sup>-3</sup> ),
and the gradient small enough (&lt;10<sup>-3</sup> ), by default.
Cubic M-splines of order 4 are used for the hazard function, and I-splines (integrated M-splines) are
used for the cumulative hazard function.
</p>
<p>The inverse of the Hessian matrix is the variance estimator and to deal
with the positivity constraint of the variance component and the spline
coefficients, a squared transformation is used and the standard errors are
computed by the <code class="reqn">\Delta</code>-method (Knight &amp; Xekalaki, 2000). The smooth
parameter can be chosen by maximizing a likelihood cross validation
criterion (Joly and other, 1998).
</p>
<p>We proposed based on the joint surrogate model a new definition
of the Kendall's <code class="reqn">\tau</code>. By cons, for the joint frailty-copula model, we
based the individual-level association on a definition of <code class="reqn">\tau</code> clause to
that of the classical two-step approch (Burzykowski et al, 2001), but conditional
on the random effects. Moreover, distinct numerical integration methods are available to approximate the
integrals in the marginal log-likelihood.
</p>
<p><b>Non-convergence case management procedure</b>
</p>
<p>Special attention must be given to initializing model parameters, the choice of the number of
spline knots, the smoothing parameters and the number of quadrature points to solve convergence
issues. We first initialized parameters using the user's desired strategy, as specified
by the option <code>true.init.val</code>. When numerical or convergence problems are encountered,
with <code>kappa.use</code> set to <code>4</code>, the model is fitted again using a combination of the following strategies:
vary the number of quadrature point (<code>nb.gh</code> to <code>nb.gh2</code> or <code>nb.gh2</code> to <code>nb.gh</code>)
in the event of the use of the Gaussian Hermite quadrature integration (see <code>int.method</code>);
divided or multiplied the smoothing parameters ( k<sub>1</sub>,
 k<sub>2</sub>) by 10 or 100 according to
their preceding values, or used parameter vectors obtained during the last iteration (with a
modification of the number of quadrature points and smoothing parameters). Using this strategy,
we usually obtained during simulation the rejection rate less than 3%. A sensitivity analysis
was conducted without this strategy, and similar results were obtained on the converged samples,
with about a 23% rejection rate.

</p>


<h3>Value</h3>

<p>This function returns an object of class jointSurroPenalSimul with elements :
</p>
<table role = "presentation">
<tr><td><code>theta2</code></td>
<td>
<p>True value for <code class="reqn">\theta</code>, if <code>type.joint.estim = 1</code>;</p>
</td></tr>
<tr><td><code>theta.copula</code></td>
<td>
<p>Copula parameter, if <code>type.joint.estim = 3</code>;</p>
</td></tr>
<tr><td><code>zeta</code></td>
<td>
<p>true value for <code class="reqn">\zeta</code>, if <code>type.joint.estim = 1</code>;</p>
</td></tr>
<tr><td><code>gamma.ui</code></td>
<td>
<p>true value for <code class="reqn">\gamma</code>;</p>
</td></tr>
<tr><td><code>alpha.ui</code></td>
<td>
<p>true value for <code class="reqn">\alpha</code>;</p>
</td></tr>
<tr><td><code>sigma.s</code></td>
<td>
<p>true value for 
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>;</p>
</td></tr>
<tr><td><code>sigma.t</code></td>
<td>
<p>true value for 
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub>;</p>
</td></tr>
<tr><td><code>sigma.st</code></td>
<td>
<p>true value for 
<code class="reqn">\sigma</code><sub>v<sub>ST</sub></sub>;</p>
</td></tr>
<tr><td><code>betas</code></td>
<td>
<p>true value for  <code class="reqn">\beta</code><sub>S</sub>;</p>
</td></tr>
<tr><td><code>betat</code></td>
<td>
<p>true value for  <code class="reqn">\beta</code><sub>T</sub>;</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>true value for 
<code>R</code><sup>2</sup><sub>trial</sub>;</p>
</td></tr>
<tr><td><code>nb.subject</code></td>
<td>
<p>total number of subjects used;</p>
</td></tr>
<tr><td><code>nb.trials</code></td>
<td>
<p>total number of trials used;</p>
</td></tr>
<tr><td><code>nb.simul</code></td>
<td>
<p>number of simulated datasets;</p>
</td></tr>
<tr><td><code>nb.gh</code></td>
<td>
<p>number of nodes for the Gaussian-Hermite quadrature;</p>
</td></tr>
<tr><td><code>nb.gh2</code></td>
<td>
<p>number of nodes for the Gauss-Hermite quadrature used to re-estimate the model, in the event of non-convergence;</p>
</td></tr>
<tr><td><code>nb.mc</code></td>
<td>
<p>number of samples considered in the Monte-Carlo integration;</p>
</td></tr>
<tr><td><code>kappa.use</code></td>
<td>
<p>a numeric, that indicates how to manage the smoothing parameters
 k<sub>1</sub> and  k<sub>2</sub> in the event of convergence issues;</p>
</td></tr>
<tr><td><code>n.knots</code></td>
<td>
<p>number of knots used for splines;</p>
</td></tr>
<tr><td><code>int.method</code></td>
<td>
<p>integration method used;</p>
</td></tr>
<tr><td><code>n.iter</code></td>
<td>
<p>mean number of iterations needed to converge;</p>
</td></tr>
<tr><td><code>dataTkendall</code></td>
<td>
<p>a matrix with <code>nb.dataset</code> line(s) and three columns, of the estimates of Kendall's <code class="reqn">\tau</code>
and theirs confidence intervals (obtained using parametric bootstrap if <code>type.joint.estim = 1</code> or
Delta method if <code>type.joint.estim = 3</code>). All non-convergence cases  are represented by a line of 0;</p>
</td></tr>
<tr><td><code>dataR2boot</code></td>
<td>
<p>a matrix with <code>nb.dataset</code> line(s) and three columns, of the estimates of

<code>R</code><sup>2</sup><sub>trial</sub>
and theirs confidence intervals using the parametric bootstrap. All non-convergence cases are represented by a line of 0.</p>
</td></tr>
<tr><td><code>dataParamEstim</code></td>
<td>
<p>a dataframe including all estimates with the associated standard errors, for all simulation.
All non-convergence cases  are represented by a line of 0;</p>
</td></tr>
<tr><td><code>dataHessian</code></td>
<td>
<p>Dataframe of the variance-Covariance matrices  of the estimates for all simulations</p>
</td></tr>
<tr><td><code>dataHessianIH</code></td>
<td>
<p>Dataframe of the robust estimation of the variance matrices  of the estimates for all simulations</p>
</td></tr>
<tr><td><code>datab</code></td>
<td>
<p>Dataframe of the estimates for all simulations which rich convergence</p>
</td></tr>
<tr><td><code>type.joint</code></td>
<td>
<p>the estimation model; 1 for the joint surrogate and 3 for joint frailty-copula model</p>
</td></tr>
<tr><td><code>type.joint.simul</code></td>
<td>
<p>The model used for data generation; 1 for joint surrogate and 3 for joint frailty-copula</p>
</td></tr>
<tr><td><code>true.init.val</code></td>
<td>
<p>Indicates if the real parameter values have been used as initial values for the model <code>(1)</code>, or the given initial values <code>(0)</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a> and
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>
</p>


<h3>References</h3>

<p>Burzykowski, T., Molenberghs, G., Buyse, M., Geys, H., and Renard, D. (2001). Validation
of surrogate end points in multiple randomized clinical trials with failure time end points.
Journal of the Royal Statistical Society: Series C (Applied Statistics) 50, 405-422.
</p>
<p>Sofeu, C. L., Emura, T., and Rondeau, V. (2019). One-step validation method for surrogate
endpoints using data from multiple randomized cancer clinical trials with failure-time endpoints.
Statistics in Medicine 38, 2928-2942.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurroPenal">jointSurroPenal</a></code>, <code><a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a></code>, <code><a href="#topic+summary.jointSurroPenalSimul">summary.jointSurroPenalSimul</a></code>
, <code><a href="#topic+jointSurrSimul">jointSurrSimul</a></code>, <code><a href="#topic+jointSurrCopSimul">jointSurrCopSimul</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Surrogacy model evaluation performance study based on 10 generated data
# (Computation takes around 20 minutes using a processor including 40
# cores and a read only memory of 378 Go)
# To realize a simulation study on 100 samples or more (as required), use
# nb.dataset = 100

### joint frailty model
joint.simul &lt;- jointSurroPenalSimul(nb.dataset = 10, nbSubSimul= 600,
                   ntrialSimul = 30, LIMparam = 0.001, LIMlogl = 0.001,
                   LIMderiv = 0.001, nb.mc = 200, nb.gh = 20,
                   nb.gh2 = 32, true.init.val = 1, print.iter = FALSE, pfs = 0)

# results
summary(joint.simul, d = 3, R2boot = 1) # bootstrap
summary(joint.simul, d = 3, R2boot = 0) # Delta-method

### joint frailty copula model

joint.simul.cop.clay &lt;- jointSurroPenalSimul(nb.dataset = 10, nbSubSimul= 600,
                   ntrialSimul = 30, nb.mc = 1000, type.joint.estim = 3,
                   typecopula = 1, type.joint.simul = 3, theta.copula = 3,
                   time.cens = 349, true.init.val = 1, R2 = 0.81, maxit = 40,
                   print.iter = FALSE)

summary(joint.simul.cop.clay)


## End(Not run)

</code></pre>

<hr>
<h2 id='jointSurroTKendall'>Kendall's <code class="reqn">\tau</code> estimation using numerical integration methods</h2><span id='topic+jointSurroTKendall'></span>

<h3>Description</h3>

<p>This function estimate the Kendall's <code class="reqn">\tau</code> based on the joint surrogate model 
described in <a href="#topic+jointSurroPenal">jointSurroPenal</a> (Sofeu <em>et al.</em>, 2018), for the evaluation of 
a candidate surrogate endpoints, at the individual-level . We used the Monte-carlo and the gaussian Hermite 
quadrature methods for numerical integration. in the event of Gaussian Hermite quadrature, 
it is better to choose at least <code>20</code> quadature nodes for better results. 
The actual value of nodes used is the maximum between <code>20</code> and <code>nb.gh</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointSurroTKendall(object = NULL, theta, gamma, alpha = 1, zeta = 1, 
                   sigma.v = matrix(rep(0,4),2,2), int.method = 0, 
                   nb.MC.kendall = 10000, nb.gh = 32, 
                   random.generator = 1, random = 0, 
                   random.nb.sim = 0, seed = 0, ui = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jointSurroTKendall_+3A_object">object</code></td>
<td>
<p>An object inheriting from <code>jointSurroPenal</code> class. The default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="jointSurroTKendall_+3A_theta">theta</code></td>
<td>
<p>Variance of the individual-level random effect,  
<code class="reqn">\omega</code><sub>ij</sub>. 
Required if <code>object</code> is set to <code>NULL</code></p>
</td></tr>
<tr><td><code id="jointSurroTKendall_+3A_gamma">gamma</code></td>
<td>
<p>Variance of the trial-level random effect associated with the baseline risk, 
 <code>u</code><sub>i</sub>. 
Required if <code>object</code> is set to <code>NULL</code>. The default is <code>3.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurroTKendall_+3A_alpha">alpha</code></td>
<td>
<p>Power parameter associated with  
<code>u</code><sub>i</sub>. Required if <code>object</code> is set to <code>NULL</code>.
The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroTKendall_+3A_zeta">zeta</code></td>
<td>
<p>Power parameter associated with  
<code class="reqn">\omega</code><sub>ij</sub>. Required if <code>object</code> is set to <code>NULL</code> 
The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroTKendall_+3A_sigma.v">sigma.v</code></td>
<td>
<p>Covariance matrix  of the random effects treatment-by-trial interaction 
(v<sub>S<sub>i</sub></sub>,
v<sub>T<sub>i</sub></sub>)</p>
</td></tr>
<tr><td><code id="jointSurroTKendall_+3A_int.method">int.method</code></td>
<td>
<p>A numeric, indicates the integration method: <code>0</code> for Monte carlo and 
<code>1</code> for Gaussian-Hermite quadrature. The default is <code>0</code></p>
</td></tr>
<tr><td><code id="jointSurroTKendall_+3A_nb.mc.kendall">nb.MC.kendall</code></td>
<td>
<p>Number of generated points used with the Monte-Carlo to estimate
integrals in the Kendall's <code class="reqn">\tau</code> formulation. Beter to use at least 4000 points for
stable results. The default is <code>10000</code>.</p>
</td></tr>
<tr><td><code id="jointSurroTKendall_+3A_nb.gh">nb.gh</code></td>
<td>
<p>Number of nodes for the Gaussian-Hermite quadrature.  The default is <code>32</code>.</p>
</td></tr>
<tr><td><code id="jointSurroTKendall_+3A_random.generator">random.generator</code></td>
<td>
<p>Random number generator to use by the Fortran compiler, 
<code>1</code> for the intrinsec subroutine <code>Random_number</code> and <code>2</code> for the 
subroutine <code>uniran()</code>. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurroTKendall_+3A_random">random</code></td>
<td>
<p>A binary that says if we reset the random number generation with a different environment 
at each call <code>(1)</code> or not <code>(0)</code>. If it is set to <code>1</code>, we use the computer clock 
as a seed. In the last case, it is not possible to reproduce the generated datesets&quot;. 
The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurroTKendall_+3A_random.nb.sim">random.nb.sim</code></td>
<td>
<p>If <code>random</code> is set to <code>1</code>, a binary that indicates the number 
of generations that will be made.</p>
</td></tr>
<tr><td><code id="jointSurroTKendall_+3A_seed">seed</code></td>
<td>
<p>The seed to use for data (or samples) generation. required if <code>random</code> is set to <code>0</code>. 
The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurroTKendall_+3A_ui">ui</code></td>
<td>
<p>A binary, indicates whether one considered trial random effect associated with 
the baseline risk (<code>1</code>) or not (<code>0</code>). The default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function return the estimated Kendall's <code class="reqn">\tau</code>
</p>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a> and 
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>
</p>


<h3>References</h3>

<p>Sofeu C.L., Emura T. and Rondeau V. (2018). One-step validation method for surrogate 
endpoints in multiple randomized cancer clinical trials with failure-time endpoints. 
<code>Under review</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurrSimul">jointSurrSimul</a></code>, <code><a href="#topic+summary.jointSurroPenal">summary.jointSurroPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Ktau1 &lt;- jointSurroTKendall(theta = 3.5, gamma = 2.5, nb.gh = 32)
Ktau2 &lt;- jointSurroTKendall(theta = 1, gamma = 0.8, alpha = 1, zeta = 1, 
         nb.gh = 32)

###---Kendall's \eqn{\tau} from a joint surrogate model ---###

## Not run: 
data.sim &lt;-jointSurrSimul(n.obs=400, n.trial = 20,cens.adm=549, 
          alpha = 1.5, theta = 3.5, gamma = 2.5, zeta = 1, 
          sigma.s = 0.7, sigma.t = 0.7,cor = 0.8, betas = -1.25, 
          betat = -1.25, full.data = 0, random.generator = 1, 
          seed = 0, nb.reject.data = 0)
          

###---Estimation---###
joint.surrogate &lt;- jointSurroPenal(data = data.sim, nb.mc = 300, 
                   nb.gh = 20, indicator.alpha = 1, n.knots = 6)
                   
 Ktau3 &lt;- jointSurroTKendall(joint.surrogate)
 Ktau4 &lt;- jointSurroTKendall(joint.surrogate,nb.MC.kendall = 4000,
          seed = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='jointSurrSimul'>Generate survival times for two endpoints using the joint frailty surrogate model</h2><span id='topic+jointSurrSimul'></span>

<h3>Description</h3>

<p>Date are generated from the one-step joint surrogate model (see <code><a href="#topic+jointSurroPenal">jointSurroPenal</a></code> for more details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointSurrSimul(
  n.obs = 600,
  n.trial = 30,
  cens.adm = 549.24,
  alpha = 1.5,
  theta = 3.5,
  gamma = 2.5,
  zeta = 1,
  sigma.s = 0.7,
  sigma.t = 0.7,
  cor = 0.8,
  betas = -1.25,
  betat = -1.25,
  frailt.base = 1,
  lambda.S = 1.8,
  nu.S = 0.0045,
  lambda.T = 3,
  nu.T = 0.0025,
  ver = 1,
  typeOf = 1,
  equi.subj.trial = 1,
  equi.subj.trt = 1,
  prop.subj.trial = NULL,
  prop.subj.trt = NULL,
  full.data = 0,
  random.generator = 1,
  random = 0,
  random.nb.sim = 0,
  seed = 0,
  nb.reject.data = 0,
  pfs = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jointSurrSimul_+3A_n.obs">n.obs</code></td>
<td>
<p>Number of considered  subjects. The default is <code>600</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_n.trial">n.trial</code></td>
<td>
<p>Number of considered  trials. The default is <code>30</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_cens.adm">cens.adm</code></td>
<td>
<p>censorship time. The default is <code>549</code>, for about <code>40%</code> of censored subjects.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_alpha">alpha</code></td>
<td>
<p>Fixed value for <code class="reqn">\alpha</code>. The default is <code>1.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_theta">theta</code></td>
<td>
<p>Fixed value for <code class="reqn">\theta</code>. The default is <code>3.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_gamma">gamma</code></td>
<td>
<p>Fixed value for <code class="reqn">\gamma</code>. The default is <code>2.5</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_zeta">zeta</code></td>
<td>
<p>Fixed value for <code class="reqn">\zeta</code>. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_sigma.s">sigma.s</code></td>
<td>
<p>Fixed value for 
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>S</sub></sub>. 
The default is <code>0.7</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_sigma.t">sigma.t</code></td>
<td>
<p>Fixed value for 
<code class="reqn">\sigma</code><sup>2</sup><sub>v<sub>T</sub></sub>. 
The default is <code>0.7</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_cor">cor</code></td>
<td>
<p>Desired level of correlation between v<sub>S<sub>i</sub></sub> and v<sub>T<sub>i</sub></sub>. 

<code>R</code><sup>2</sup><sub>trial</sub> = cor <sup>2</sup>. 
The default is <code>0.8</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_betas">betas</code></td>
<td>
<p>Fixed value for  <code class="reqn">\beta</code><sub>S</sub>.
The default is <code>-1.25</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_betat">betat</code></td>
<td>
<p>Fixed value for  <code class="reqn">\beta</code><sub>T</sub>. 
The default is <code>-1.25</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_frailt.base">frailt.base</code></td>
<td>
<p>considered the heterogeneity on the baseline risk <code>(1)</code> or not <code>(0)</code>. 
The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_lambda.s">lambda.S</code></td>
<td>
<p>Desired scale parameter for the <code>Weibull</code> distribution associated with the Surrogate
endpoint. The default is 1.8.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_nu.s">nu.S</code></td>
<td>
<p>Desired shape parameter for the <code>Weibull</code> distribution associated with the Surrogate
endpoint. The default is 0.0045.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_lambda.t">lambda.T</code></td>
<td>
<p>Desired scale parameter for the <code>Weibull</code> distribution associated with the True endpoint.
The default is 3.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_nu.t">nu.T</code></td>
<td>
<p>Desired shape parameter for the <code>Weibull</code> distribution associated with the True endpoint.
The default is 0.0025.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_ver">ver</code></td>
<td>
<p>Number of covariates. For surrogte evaluation, we just considered one covatiate, the treatment arm</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_typeof">typeOf</code></td>
<td>
<p>Type of joint model used for data generation: 0 = classical joint model 
with a shared individual frailty effect (Rondeau, 2007), 1 = joint surrogate model with shared frailty 
effects  <code>u</code><sub>i</sub> and  
<code class="reqn">\omega</code><sub>ij</sub>, and two correlated random effects treatment-by-trial interaction 
(v<sub>S<sub>i</sub></sub>, v<sub>T<sub>i</sub></sub>) 
as described in Sofeu et al. (2018).</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_equi.subj.trial">equi.subj.trial</code></td>
<td>
<p>A binary variable that indicates if the same proportion of subjects should be included per trial (1) 
or not (0). If 0, the proportions of subject per trial are required in parameter <code>prop.subj.trial</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_equi.subj.trt">equi.subj.trt</code></td>
<td>
<p>A binary variable that indicates if the same proportion of subjects is randomized per trial (1) 
or not (0). If 0, the proportions of subject per trial are required in parameter <code>prop.subj.trt</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_prop.subj.trial">prop.subj.trial</code></td>
<td>
<p>The proportions of subjects per trial. Requires if <code>equi.subj.trial=0</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_prop.subj.trt">prop.subj.trt</code></td>
<td>
<p>The proportions of randomized subject per trial. Requires if <code>equi.subj.trt=0</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_full.data">full.data</code></td>
<td>
<p>Specified if you want the function to return the full dataset (1), including the random effects, 
or the restictive dataset (0) with <code>7</code> columns required for the function <code><a href="#topic+jointSurroPenal">jointSurroPenal</a></code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_random.generator">random.generator</code></td>
<td>
<p>Random number generator used by the Fortran compiler, 
<code>1</code> for the intrinsec subroutine <code>Random_number</code> and <code>2</code> for the 
subroutine <code>uniran()</code>. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_random">random</code></td>
<td>
<p>A binary that says if we reset the random number generation with a different environment 
at each call <code>(1)</code> or not <code>(0)</code>. If it is set to <code>1</code>, we use the computer clock 
as seed. In the last case, it is not possible to reproduce the generated datasets. 
The default is <code>0</code>. Required if <code>random.generator</code> is set to 1.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_random.nb.sim">random.nb.sim</code></td>
<td>
<p>required if <code>random.generator</code> is set to 1, and if <code>random</code> is set to 1.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_seed">seed</code></td>
<td>
<p>The seed to use for data (or samples) generation. Required if the argument <code>random.generator</code> is set to 1. 
Must be a positive value. If negative, the program do not account for seed. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_nb.reject.data">nb.reject.data</code></td>
<td>
<p>Number of generation to reject before the considered dataset. This parameter is required
when data generation is for simulation. With a fixed parameter and <code>random.generator</code> set to 1,
all ganerated data are the same. By varying this parameter, different datasets are obtained during data genarations. The default value is 0, 
in the event of one dataset.</p>
</td></tr>
<tr><td><code id="jointSurrSimul_+3A_pfs">pfs</code></td>
<td>
<p>Is used to specify if the time to progression should be censored by the death time (0) or not (1). 
The default is 0. In the event with pfs set to 1, death is included in the surrogate endpoint as in the definition of PFS or DFS.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We just considered in this generation, the Gaussian random effects. If the parameter <code>full.data</code> is set to 1,
this function  return a list containning severals parameters, including the generated random effects. 
the desired individual level correlation (Kendall's <code class="reqn">\tau</code>) depend on the values of 
<code class="reqn">\alpha</code>, <code class="reqn">\theta</code>, <code class="reqn">\gamma</code> and <code class="reqn">\zeta</code>.
</p>


<h3>Value</h3>

<p>This function return if the parameter <code>full.data</code> is set to 0, a <code><a href="base.html#topic+data.frame">data.frame</a></code> with columns :
</p>
<table role = "presentation">
<tr><td><code>patientID</code></td>
<td>
<p>A numeric, that represents the patient's identifier, must be unique;</p>
</td></tr>
<tr><td><code>trialID</code></td>
<td>
<p>A numeric, that represents the trial in which each patient was randomized;</p>
</td></tr>
<tr><td><code>trt</code></td>
<td>
<p>The treatment indicator for each patient, with 1 = treated, 0 = untreated;</p>
</td></tr>
<tr><td><code>timeS</code></td>
<td>
<p>The follow up time associated with the surrogate endpoint;</p>
</td></tr>
<tr><td><code>statusS</code></td>
<td>
<p>The event indicator associated with the surrogate endpoint. Normally 
0 = no event, 1 = event;</p>
</td></tr>
<tr><td><code>timeT</code></td>
<td>
<p>The follow up time associated with the true endpoint;</p>
</td></tr>
<tr><td><code>statusT</code></td>
<td>
<p>The event indicator associated with the true endpoint. Normally 
0 = no event, 1 = event;</p>
</td></tr>
</table>
<p>If the argument <code>full.data</code> is set to 1, additionnal colums corresponding to random effects 
 <code class="reqn">\omega</code><sub>ij</sub>, 
 <code>u</code><sub>i</sub>, v<sub>S<sub>i</sub></sub> and
v<sub>T<sub>i</sub></sub> are returned. Note that
 <code>u</code><sub>i</sub>, v<sub>S<sub>i</sub></sub> and
v<sub>T<sub>i</sub></sub> are returned if <code>typeOf</code> is set to <code>1</code>
</p>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a> and 
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>
</p>


<h3>References</h3>

<p>Rondeau V., Mathoulin-Pelissier S., Jacqmin-Gadda H., Brouste V. and Soubeyran P. (2007).
Joint frailty models for recurring events and death using maximum penalized likelihood 
estimation: application on cancer events. Biostatistics 8(4), 708-721.
</p>
<p>Sofeu, C. L., Emura, T., and Rondeau, V. (2019). One-step validation method for surrogate 
endpoints using data from multiple randomized cancer clinical trials with failure-time endpoints. 
Statistics in Medicine 38, 2928-2942.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurrSimul">jointSurrSimul</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data.sim &lt;- jointSurrSimul(n.obs=600, n.trial = 30,cens.adm=549.24, 
            alpha = 1.5, theta = 3.5, gamma = 2.5, sigma.s = 0.7, 
            zeta = 1, sigma.t = 0.7, cor = 0.8, betas = -1.25, 
            betat = -1.25, full.data = 0, random.generator = 1, 
            seed = 0, nb.reject.data = 0, pfs = 0)


</code></pre>

<hr>
<h2 id='longDat'>Longitudinal semicontinuous biomarker dataset (TPJM)</h2><span id='topic+longDat'></span>

<h3>Description</h3>

<p>This is a simulated dataset used to illustrate the two-part 
joint model included in the longiPenal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(longDat)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: 
</p>

<dl>
<dt>id</dt><dd><p>The identification number of a patient</p>
</dd>
<dt>timej</dt><dd><p>The measurement times of the biomarker</p>
</dd>
<dt>trtY</dt><dd><p>Treatment covariate</p>
</dd>
<dt>Y</dt><dd><p>Biomarker value</p>
</dd>
</dl>


<hr>
<h2 id='longiPenal'>Fit a Joint Model for Longitudinal Data and a Terminal Event</h2><span id='topic+longiPenal'></span>

<h3>Description</h3>


<p>Fit a joint model for longitudinal data and a terminal event
using a semiparametric penalized likelihood estimation or a parametric
estimation on the hazard function.
</p>
<p>The longitudinal outcomes y<sub>i</sub>(t<sub>ik</sub>)
(k=1,...,n<sub>i</sub>, i=1,...,N) for N subjects are described
by a linear mixed model and the risk of the terminal event is represented by
a proportional hazard risk model. The joint model is constructed assuming
that the processes are linked via a latent structure (Wulfsohn and Tsiatsis
1997):
</p>
<p><img src="../help/figures/longimodel.png" width="100%" alt="longimodel.png" />
</p>
<p>where <b><code class="reqn">X</code></b><sub>Li</sub>(t) and
<b><code class="reqn">X</code></b><sub>Ti</sub> are vectors of fixed effects covariates and
<b><code class="reqn">\beta</code></b><sub>L</sub> and <b><code class="reqn">\beta</code></b><sub>T</sub>
are the associated coefficients. Measurements errors
<code class="reqn">\epsilon</code><sub>i</sub>(t<sub>ik</sub>) are iid normally
distributed with mean 0 and variance
<code class="reqn">\sigma</code><sub>\epsilon</sub><sup>2</sup>. The random
effects <b>b</b><sub>i</sub> =
(b<sub>0i</sub>,...,b<sub>qi</sub>)<sup>T</sup>
<span>&#126;</span> <b><code class="reqn">N</code></b>(0,<b>B</b><sub>1</sub>) are
associated to covariates <b><code class="reqn">Z</code></b><sub>Li</sub>(t) and independent
from the measurement error. The relationship between the two processes is
explained via
h(<b>b</b><sub>i</sub>,<b><code class="reqn">\beta</code></b><sub>L</sub>,<b><code class="reqn">Z</code></b><sub>Li</sub>(t),<b><code class="reqn">X</code></b><sub>Li</sub>(t))
with coefficients <code class="reqn">\eta</code><sub>T</sub>. Two forms of the function
h(.) are available: the random effects <b>b</b><sub>i</sub>
and the current biomarker level
b<sub>i</sub>(t)=<b><code class="reqn">X</code><sub>Li</sub></b>(t<sub>ik</sub>)<sup>T</sup>
<b><code class="reqn">\beta</code></b><sub>L</sub> +<b> <code class="reqn">Z</code></b><sub>i</sub>(t<sub>ik</sub>)<sup>T</sup> <b>b</b><sub>i</sub>.
</p>
<p>We consider that the longitudinal outcome can be a subject to a
quantification limit, i.e. some observations, below a level of detection
s cannot be quantified (left-censoring).
</p>
<p>Alternatively, a two-part model is proposed to fit a semicontinuous biomarker.
The two-part model decomposes the biomarker's distribution into a binary
outcome (zero vs. positive values) and a continuous outcome (positive values). In the
conditional form, the continuous part is conditional on a positive value while in the
marginal form, the continuous part corresponds to the marginal mean of the biomarker.
A logistic mixed effects model fits the binary outcome and a linear or a lognormal mixed effects
model fits the continuous outcome. 
</p>
<p>A mediation analysis is possible to derive the proportion of the treatment effect on the survival
outcome due to the treatment effect on the longitudinal outcome. The proportion of treatment 
effect is derived as the ratio of the indirect effect over the total effect. This proportion is
defined on the survival scale and the indirect effect is taken as the difference of survivals at a given time
when the treatment is set to 1 for both the survival and longitudinal outcome and when the treatment
is only set to 1 for the survival endpoint and 0 for the longitudinal outcome. The total effect is the difference
of survivals when the treatment is set to 1 or 0 for both endpoints. 
</p>





<h3>Usage</h3>

<pre><code class='language-R'>longiPenal(formula, formula.LongitudinalData, data,  data.Longi,
          formula.Binary=FALSE, random,random.Binary=FALSE, fixed.Binary=FALSE, 
          GLMlog=FALSE, MTP=FALSE, id, intercept = TRUE,link="Random-effects",
          timevar=FALSE,left.censoring=FALSE,n.knots, kappa,maxit=350,
          hazard="Splines",mediation=FALSE,med.center=NULL,med.trt=NULL,init.B,
          init.Random, init.Eta, method.GH = "Standard",seed.MC=1, n.nodes,
          LIMparam=1e-3,LIMlogl=1e-3, LIMderiv=1e-3, print.times=TRUE,med.nmc=500,
          pte.times=NULL,pte.ntimes=NULL,pte.nmc=500,pte.boot=FALSE,pte.nboot=2000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="longiPenal_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a
<code class="reqn">\sim</code> operator, and the terms on the right. The response must be a
survival object as returned by the 'Surv' function like in survival
package. Interactions are possible using * or :.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_formula.longitudinaldata">formula.LongitudinalData</code></td>
<td>
<p>a formula object, only requires terms on the
right to indicate which variables are modelling the longitudinal outcome.
It must follow the standard form used for linear mixed-effects models.
Interactions are possible using * or :.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_data">data</code></td>
<td>
<p>a 'data.frame' with the variables used in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_data.longi">data.Longi</code></td>
<td>
<p>a 'data.frame' with the variables used in
<code>formula.LongitudinalData</code>.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_formula.binary">formula.Binary</code></td>
<td>
<p>a formula object, only requires terms on the
right to indicate which variables are modelling the binary part of the
two-part model fitting the longitudinal semicontinuous outcome.
It must follow the standard form used for linear mixed-effects models.
Interactions are possible using * or :.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_random">random</code></td>
<td>
<p>Names of variables for the random effects of the longitudinal
outcome. Maximum 3 random effects are possible at the moment. The random
intercept is chosen using <code>"1"</code>.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_random.binary">random.Binary</code></td>
<td>
<p>Names of variables for the random effects of the binary
part of the two-part model fitting the longitudinal semicontinuous outcome.
The random intercept is chosen using <code>"1"</code>.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_fixed.binary">fixed.Binary</code></td>
<td>
<p>Fix the value of the intercept in the binary part of a two-part model.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_glmlog">GLMlog</code></td>
<td>
<p>Logical value. Use a lognormal distribution for the biomarker
(instead of the default normal distribution).</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_mtp">MTP</code></td>
<td>
<p>Logical value. Marginal two-part joint model instead of
conditional two-part joint model (only with two-part models).</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_id">id</code></td>
<td>
<p>Name of the variable representing the individuals.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_intercept">intercept</code></td>
<td>
<p>Logical value. Is the fixed intercept of the biomarker
included in the mixed-effects model? The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_link">link</code></td>
<td>
<p>Type of link function for the dependence between the biomarker
and death: <code>"Random-effects"</code> for the association directly via the
random effects of the biomarker, <code>"Current-level"</code> for the association
via the true current level of the biomarker.  The option
<code>"Current-level"</code> can be chosen only if the biomarker random effects
are associated with the intercept and time (following this order).
<code>"Two-part"</code>, this structure is only applicable with conditional two-part models,
the effect of the current probability of positive value and the effect of
the expected value among positive values on the risk of event is evaluated
separately. The default is <code>"Random-effects"</code>.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_timevar">timevar</code></td>
<td>
<p>Indicates the time varying variables to take into account this
evolution over time in the link with the survival model (useful with
'Current-level' and 'Two-part' links)</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_left.censoring">left.censoring</code></td>
<td>
<p>Is the biomarker left-censored below a threshold
<code class="reqn">s</code>? The default is <code>FALSE</code>, ie. no left-censoring. In case of a
left-censored biomarker, this argument must be equal to the threshold
<code class="reqn">s</code>.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_n.knots">n.knots</code></td>
<td>
<p>Integer giving the number of knots to use. Value required in
the penalized likelihood estimation.  It corresponds to the (n.knots+2)
splines functions for the approximation of the hazard or the survival
functions.  We estimate I or M-splines of order 4. When the user set a
number of knots equals to k (n.knots=k) then the number of interior knots
is (k-2) and the number of splines is (k-2)+order.  Number of knots must be
between 4 and 20. (See Note in <code>frailtyPenal</code> function)</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_kappa">kappa</code></td>
<td>
<p>Positive smoothing parameter in the penalized likelihood
estimation.  The coefficient kappa of the integral of the squared second
derivative of hazard function in the fit (penalized log likelihood). To
obtain an initial value for <code>kappa</code>, a solution is to fit the
corresponding Cox model using cross validation (See <code>cross.validation</code>
in function <code>frailtyPenal</code>).  We advise the user to identify several
possible tuning parameters, note their defaults and look at the sensitivity
of the results to varying them.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for the Marquardt algorithm. The
default is 350.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_hazard">hazard</code></td>
<td>
<p>Type of hazard functions: <code>"Splines"</code> for semiparametric
hazard functions using equidistant intervals or <code>"Splines-per"</code> using
percentile with the penalized likelihood estimation, <code>"Weibull"</code> for
the parametric Weibull functions. The default is <code>"Splines"</code>.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_mediation">mediation</code></td>
<td>
<p>a logical value indicating if the mediation analysis method is used.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_med.center">med.center</code></td>
<td>
<p>For mediation analysis, a vector containing the center indicator for each subject
If no center then this argument should be <code>NULL</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_med.trt">med.trt</code></td>
<td>
<p>For mediation analysis, a vector containing the treatment indicator for each subject.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_init.b">init.B</code></td>
<td>
<p>Vector of initial values for regression coefficients. This
vector should be of the same size as the whole vector of covariates with
the first elements for the covariates related to the terminal event and
then for the covariates related to the biomarker (interactions in the end
of each component). Default is 0.5 for each.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_init.random">init.Random</code></td>
<td>
<p>Initial value for variance of the elements of the matrix
of the distribution of the random effects. Default is 0.5 for each element.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_init.eta">init.Eta</code></td>
<td>
<p>Initial values for regression coefficients for the link
function. Default is 0.5 for each.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_method.gh">method.GH</code></td>
<td>
<p>Method for the Gauss-Hermite quadrature: <code>"Standard"</code>
for the standard non-adaptive Gaussian quadrature, <code>"Pseudo-adaptive"</code>
for the pseudo-adaptive Gaussian quadrature, <code>"Monte-carlo"</code> for the
Monte-carlo method and <code>"HRMSYM"</code> for the
algorithm for the multivariate non-adaptive Gaussian quadrature (see
Details). The default is <code>"Standard"</code>.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_seed.mc">seed.MC</code></td>
<td>
<p>Monte-carlo integration points selection (1=fixed, 0=random)</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_n.nodes">n.nodes</code></td>
<td>
<p>Number of nodes for the Gauss-Hermite quadrature or the
Monte-carlo method. They can be chosen among 5, 7, 9, 12, 15, 20 and 32
for the GH quadrature and any number for the Monte-carlo method. The default is 9.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_limparam">LIMparam</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
parameters (see Details of <code>frailtyPenal</code> function), <code class="reqn">10^{-3}</code> by
default.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_limlogl">LIMlogl</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
log-likelihood (see Details of <code>frailtyPenal</code> function), <code class="reqn">10^{-3}</code>
by default.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_limderiv">LIMderiv</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
gradient (see Details of <code>frailtyPenal</code> function), <code class="reqn">10^{-3}</code> by
default.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_print.times">print.times</code></td>
<td>
<p>a logical parameter to print iteration process. The
default is TRUE.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_med.nmc">med.nmc</code></td>
<td>
<p>For mediation analysis, the number of Monte Carlo points used for computing the integral 
over the random effects in the likelihood computation. Default is 500.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_pte.times">pte.times</code></td>
<td>
<p>For mediation analysis, a vector of times for which the
funtion <code class="reqn">PTE(t)</code> is evaluated. Specified time points must be in the range of
the observed event times. The length of the vector should be less than 200.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_pte.ntimes">pte.ntimes</code></td>
<td>
<p>For mediation analysis, if the argument <code>pte.times</code> is not specified
the argument <code>pte.ntimes</code> allows the user to only specify a number of
time points for which the function <code class="reqn">PTE(t)</code> has to be computed. This argument
is only to be used if <code>pte.times</code> is not specified. In that case
the default value for <code>pte.ntimes</code> is 10. Should be less than 200.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_pte.nmc">pte.nmc</code></td>
<td>
<p>For mediation analysis, nn integer indicating how many Monte Carlo simulations are used
to integrate over the random effects in the computation of the function <code class="reqn">PTE(t)</code>. Should be less than
10000. Default is 500.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_pte.boot">pte.boot</code></td>
<td>
<p>For mediation analysis, a logical value indicating if bootstrapped confidence bands needs to be computed for the
function <code class="reqn">PTE(t)</code> in the mediation analysis setting. Default is FALSE.</p>
</td></tr>
<tr><td><code id="longiPenal_+3A_pte.nboot">pte.nboot</code></td>
<td>
<p>For mediation analysis, an integer indicating how many bootstrapped replicates of PTE(t) needs
to be computed to derive confidence bands for PTE(t). Should be less than 10000. Default is 2000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Typical usage for the joint model
</p>
<pre>longiPenal(Surv(time,event)~var1+var2, biomarker ~ var1+var2,
data, data.Longi, ...)</pre>
<p>The method of the Gauss-Hermite quadrature for approximations of the
multidimensional integrals, i.e. length of <code>random</code> is 2, can be chosen
among the standard, non-adaptive, pseudo-adaptive in which the quadrature
points are transformed using the information from the fitted mixed-effects
model for the biomarker (Rizopoulos 2012) or multivariate non-adaptive
procedure proposed by Genz et al. 1996 and implemented in FORTRAN subroutine
HRMSYM.  The choice of the method is important for estimations. The standard
non-adaptive Gauss-Hermite quadrature (<code>"Standard"</code>) with a specific
number of points gives accurate results but can be time consuming. The
non-adaptive procedure (<code>"HRMSYM"</code>) offers advantageous computational
time but in case of datasets in which some individuals have few repeated
observations (biomarker measures or recurrent events), this method may be
moderately unstable.  The pseudo-adaptive quadrature uses transformed
quadrature points to center and scale the integrand by utilizing estimates of
the random effects from an appropriate linear mixed-effects model. This
method enables using less quadrature points while preserving the estimation
accuracy and thus lead to a better computational time.The Monte-Carlo method
is also proposed for approximations of the multidimensional integrals.
</p>
<p>NOTE. Data frames <code>data</code> and <code>data.Longi</code> must be consistent. Names
and types of corresponding covariates must be the same, as well as the number
and identification of individuals. 
</p>


<h3>Value</h3>

<p>The following components are included in a 'longiPenal' object for each
model:
</p>
<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>The sequence of the corresponding estimation of the coefficients for
the hazard functions (parametric or semiparametric), the random effects
variances and the regression coefficients.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The code used for the
model.</p>
</td></tr> <tr><td><code>formula</code></td>
<td>
<p>The formula part of the code used for the terminal
event part of the model.</p>
</td></tr> <tr><td><code>formula.LongitudinalData</code></td>
<td>
<p>The formula part of
the code used for the longitudinal part of the model.</p>
</td></tr> <tr><td><code>formula.Binary</code></td>
<td>
<p>The
formula part of the code used for the binary part of the two-part model.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>The
regression coefficients (first for the terminal event and then for the
biomarker.</p>
</td></tr> <tr><td><code>groups</code></td>
<td>
<p>The number of groups used in the fit.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>The value of the smoothing parameter in the penalized likelihood
estimation corresponding to the baseline hazard function for the terminal
event.</p>
</td></tr> <tr><td><code>logLikPenal</code></td>
<td>
<p>The complete marginal penalized log-likelihood in
the semiparametric case.</p>
</td></tr> <tr><td><code>logLik</code></td>
<td>
<p>The marginal log-likelihood in the
parametric case.</p>
</td></tr> <tr><td><code>n.measurements</code></td>
<td>
<p>The number of biomarker observations
used in the fit.</p>
</td></tr> <tr><td><code>max_rep</code></td>
<td>
<p>The maximal number of repeated measurements
per individual.</p>
</td></tr> <tr><td><code>n.deaths</code></td>
<td>
<p>The number of events observed in the fit.</p>
</td></tr>
<tr><td><code>n.iter</code></td>
<td>
<p>The number of iterations needed to converge.</p>
</td></tr>
<tr><td><code>n.knots</code></td>
<td>
<p>The number of knots for estimating the baseline hazard
function in the penalized likelihood estimation.</p>
</td></tr> <tr><td><code>n.strat</code></td>
<td>
<p>The number
of stratum.</p>
</td></tr>
<tr><td><code>varH</code></td>
<td>
<p>The variance matrix of all parameters (before positivity
constraint transformation for the variance of the measurement error, for
which the delta method is used).</p>
</td></tr> <tr><td><code>varHIH</code></td>
<td>
<p>The robust estimation of the
variance matrix of all parameters.</p>
</td></tr>
<tr><td><code>xD</code></td>
<td>
<p>The vector of times where both survival and hazard function of the
terminal event are estimated. By default seq(0,max(time),length=99), where
time is the vector of survival times.</p>
</td></tr> <tr><td><code>lamD</code></td>
<td>
<p>The array (dim=3) of
baseline hazard estimates and confidence bands (terminal event).</p>
</td></tr>
<tr><td><code>survD</code></td>
<td>
<p>The array (dim=3) of baseline survival estimates and confidence
bands (terminal event).</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>The value of the median survival and its confidence bands.</p>
</td></tr>
<tr><td><code>typeof</code></td>
<td>
<p>The type of the baseline hazard
functions (0:&quot;Splines&quot;, &quot;2:Weibull&quot;).</p>
</td></tr> <tr><td><code>npar</code></td>
<td>
<p>The number of parameters.</p>
</td></tr>
<tr><td><code>nvar</code></td>
<td>
<p>The vector of number of explanatory variables for the terminal
event and biomarker.</p>
</td></tr> <tr><td><code>nvarEnd</code></td>
<td>
<p>The number of explanatory variables for
the terminal event.</p>
</td></tr> <tr><td><code>nvarY</code></td>
<td>
<p>The number of explanatory variables for the
biomarker.</p>
</td></tr> <tr><td><code>noVarEnd</code></td>
<td>
<p>The indicator of absence of the explanatory
variables for the terminal event.</p>
</td></tr> <tr><td><code>noVarY</code></td>
<td>
<p>The indicator of absence of
the explanatory variables for the biomarker.</p>
</td></tr> <tr><td><code>LCV</code></td>
<td>
<p>The approximated
likelihood cross-validation criterion in the semiparametric case (with H
minus the converged Hessian matrix, and l(.) the full
log-likelihood).</p>
<p style="text-align: center;"><code class="reqn">LCV=\frac{1}{n}(trace(H^{-1}_{pl}H) - l(.))</code>
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>The Akaike information Criterion for the parametric
case.</p>
<p style="text-align: center;"><code class="reqn">AIC=\frac{1}{n}(np - l(.))</code>
</p>
</td></tr> <tr><td><code>n.knots.temp</code></td>
<td>
<p>The initial value
for the number of knots.</p>
</td></tr> <tr><td><code>shape.weib</code></td>
<td>
<p>The shape parameter for the
Weibull hazard function.</p>
</td></tr> <tr><td><code>scale.weib</code></td>
<td>
<p>The scale parameter for the
Weibull hazard function.</p>
</td></tr> <tr><td><code>martingaledeath.res</code></td>
<td>
<p>The martingale residuals
for each individual.</p>
</td></tr> <tr><td><code>conditional.res</code></td>
<td>
<p>The conditional residuals for
the biomarker (subject-specific):
<code class="reqn">\bold{R}_i^{(m)}=\bold{y}_i-\bold{X}_{Li}^\top\widehat{\bold{\beta}}_L-\bold{Z}_i^\top\widehat{\bold{b}}_i</code>.</p>
</td></tr>
<tr><td><code>marginal.res</code></td>
<td>
<p>The marginal residuals for the biomarker (population
averaged):
<code class="reqn">\bold{R}_i^{(c)}=\bold{y}_i-\bold{X}_{Li}^\top\widehat{\bold{\beta}}_L</code>.</p>
</td></tr>
<tr><td><code>marginal_chol.res</code></td>
<td>
<p>The Cholesky marginal residuals for the biomarker:
<code class="reqn">\bold{R}_i^{(m)}=\widehat{\bold{U}_i^{(m)}}\bold{R}_i^{(m)}</code>, where
<code class="reqn">\widehat{\bold{U}_i^{(m)}}</code> is an upper-triangular matrix obtained by
the Cholesky decomposition of the variance matrix
<code class="reqn">\bold{V}_{\bold{R}_i^{(m)}}=\widehat{\bold{V}_i}-\bold{X}_{Li}(\sum_{i=1}^N\bold{X}_{Li}\widehat{\bold{V}_i}^{-1}\bold{X}_{Li})^{-1}\bold{X}_{Li}^\top</code>.</p>
</td></tr>
<tr><td><code>conditional_st.res</code></td>
<td>
<p>The standardized conditional residuals for the
biomarker.</p>
</td></tr> <tr><td><code>marginal_st.res</code></td>
<td>
<p>The standardized marginal residuals for
the biomarker.</p>
</td></tr> <tr><td><code>random.effects.pred</code></td>
<td>
<p> The empirical Bayes predictions
of the random effects (ie. using conditional posterior distributions).</p>
</td></tr>
<tr><td><code>pred.y.marg</code></td>
<td>
<p>The marginal predictions of the longitudinal outcome.</p>
</td></tr>
<tr><td><code>pred.y.cond</code></td>
<td>
<p>The conditional (given the random effects) predictions of
the longitudinal outcome.</p>
</td></tr> <tr><td><code>lineardeath.pred</code></td>
<td>
<p>The linear predictor for
the terminal part.</p>
</td></tr> <tr><td><code>global_chisq_d</code></td>
<td>
<p>The vector with values of each
multivariate Wald test for the terminal part.</p>
</td></tr> <tr><td><code>dof_chisq_d</code></td>
<td>
<p>The vector
with degrees of freedom for each multivariate Wald test for the terminal
part.</p>
</td></tr> <tr><td><code>global_chisq.test_d</code></td>
<td>
<p>The binary variable equals to 0 when no
multivariate Wald is given, 1 otherwise (for the terminal part).</p>
</td></tr>
<tr><td><code>p.global_chisq_d</code></td>
<td>
<p>The vector with the p_values for each global
multivariate Wald test for the terminal part.</p>
</td></tr> <tr><td><code>global_chisq</code></td>
<td>
<p>The vector
with values of each multivariate Wald test for the longitudinal part.</p>
</td></tr>
<tr><td><code>dof_chisq</code></td>
<td>
<p>The vector with degrees of freedom for each multivariate
Wald test for the longitudinal part.</p>
</td></tr> <tr><td><code>global_chisq.test</code></td>
<td>
<p>The binary
variable equals to 0 when no multivariate Wald is given, 1 otherwise (for the
longitudinal part).</p>
</td></tr> <tr><td><code>p.global_chisq</code></td>
<td>
<p>The vector with the p_values for
each global multivariate Wald test for the longitudinal part.</p>
</td></tr>
<tr><td><code>names.factordc</code></td>
<td>
<p>The names of the &quot;as.factor&quot; variables for the terminal
part.</p>
</td></tr> <tr><td><code>names.factor</code></td>
<td>
<p>The names of the &quot;as.factor&quot; variables for the
longitudinal part.</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>The logical value. Is the fixed intercept included in the
linear mixed-effects model?</p>
</td></tr> <tr><td><code>B1</code></td>
<td>
<p>The variance matrix of the random
effects for the longitudinal outcome.</p>
</td></tr> <tr><td><code>ResidualSE</code></td>
<td>
<p>The standard
deviation of the measurement error.</p>
</td></tr> <tr><td><code>eta</code></td>
<td>
<p>The regression coefficients
for the link function.</p>
</td></tr> <tr><td><code>ne_re</code></td>
<td>
<p>The number of random effects used in the
fit.</p>
</td></tr> <tr><td><code>names.re</code></td>
<td>
<p>The names of variables for the random effects.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>The name of the type of the link function.</p>
</td></tr>
<tr><td><code>eta_p.value</code></td>
<td>
<p>p-values of the Wald test for the estimated regression
coefficients for the link function.</p>
</td></tr> <tr><td><code>beta_p.value</code></td>
<td>
<p>p-values of the Wald
test for the estimated regression coefficients.</p>
</td></tr>
<tr><td><code>leftCensoring</code></td>
<td>
<p>The logical value. Is the longitudinal outcome
left-censored?</p>
</td></tr> <tr><td><code>leftCensoring.threshold</code></td>
<td>
<p>For the left-censored
biomarker, the value of the left-censoring threshold used for the fit.</p>
</td></tr>
<tr><td><code>prop.censored</code></td>
<td>
<p>The fraction of observations subjected to the
left-censoring.</p>
</td></tr>
<tr><td><code>methodGH</code></td>
<td>
<p>The method used for approximations of the
multidimensional integrals.</p>
</td></tr>
<tr><td><code>n.nodes</code></td>
<td>
<p>The number of integration points.</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Krol, A. Mauguen, Y. Mazroui, A. Laurent, S. Michiels and V. Rondeau
(2017). Tutorial in Joint Modeling and Prediction: A Statistical Software for
Correlated Longitudinal Outcomes, Recurrent Events and a Terminal Event.
<em>Journal of Statistical Software</em> <b>81</b>(3), 1-52.
</p>
<p>A. Krol, L. Ferrer, JP. Pignon, C. Proust-Lima, M. Ducreux, O. Bouche, S.
Michiels, V. Rondeau (2016). Joint Model for Left-Censored Longitudinal Data,
Recurrent Events and Terminal Event: Predictive Abilities of Tumor Burden for
Cancer Evolution with Application to the FFCD 2000-05 Trial.
<em>Biometrics</em> <b>72</b>(3) 907-16.
</p>
<p>D. Rizopoulos (2012). Fast fitting of joint models for longitudinal and event
time data using a pseudo-adaptive Gaussian quadrature rule.
<em>Computational Statistics and Data Analysis</em> <b>56</b>, 491-501.
</p>
<p>M.S. Wulfsohn, A.A. and Tsiatis, A. A. (1997). A joint model for survival and
longitudinal data measured with error. <em>Biometrics</em> <b>53</b>, 330-9.
</p>
<p>A. Genz and B. Keister (1996). Fully symmetric interpolatory rules for
multiple integrals over infinite regions with Gaussian weight. <em>Journal
of Computational and Applied Mathematics</em> <b>71</b>, 299-309.
</p>
<p>D. Rustand, L. Briollais, C. Tournigand and V. Rondeau (2020).
Two-part joint model for a longitudinal semicontinuous marker
and a terminal event with application to metastatic colorectal
cancer data. <em>Biostatistics</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.longiPenal">plot.longiPenal</a></code>,<code><a href="#topic+print.longiPenal">print.longiPenal</a></code>,<code><a href="#topic+summary.longiPenal">summary.longiPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

###--- Joint model for longitudinal data and a terminal event ---###

data(colorectal)
data(colorectalLongi)

# Survival data preparation - only terminal events
colorectalSurv &lt;- subset(colorectal, new.lesions == 0)

# Baseline hazard function approximated with splines
# Random effects as the link function

model.spli.RE &lt;- longiPenal(Surv(time1, state) ~ age + treatment + who.PS
+ prev.resection, tumor.size ~  year * treatment + age + who.PS ,
data=colorectalSurv,	data.Longi = colorectalLongi, random = c("1", "year"),
id = "id", link = "Random-effects", left.censoring = -3.33,
n.knots = 7, kappa = 2)

# Weibull baseline hazard function
# Current level of the biomarker as the link function

model.weib.CL &lt;- longiPenal(Surv(time1, state) ~ age + treatment + who.PS
+ prev.resection, tumor.size ~  year * treatment + age + who.PS , timevar="year",
data=colorectalSurv, data.Longi = colorectalLongi, random = c("1", "year"),
id = "id", link = "Current-level", left.censoring = -3.33, hazard = "Weibull")


###--- Two-part Joint model for semicontinuous
#      longitudinal data and a terminal event ---###

data(colorectal)
data(colorectalLongi)
colorectalSurv &lt;- subset(colorectal, new.lesions == 0)

# Box-cox back transformation (lambda=0.3) and apply logarithm (with a 1 unit shift)
colorectalLongi$Yo &lt;- (colorectalLongi$tumor.size*0.3+1)^(1/0.3)
colorectalLongi$Y &lt;- log(colorectalLongi$Y+1) # log transformation with shift=1

# Conditional two-part joint model - random-effects association structure (~15min)

CTPJM_re &lt;-longiPenal(Surv(time1, state)~age + treatment +
who.PS+ prev.resection, Y~year*treatment, formula.Binary=Y~year*treatment,
data = colorectalSurv, data.Longi = colorectalLongi, random = c("1"),
random.Binary=c("1"), id = "id", link ="Random-effects", left.censoring = F,
n.knots = 7, kappa = 2, hazard="Splines-per")

print(CTPJM_re)

# Conditional two-part joint model - current-level association structure (~15min)
# Simulated dataset (github.com/DenisRustand/TPJM_sim)
data(longDat)
data(survDat)
tte &lt;- frailtyPenal(Surv(deathTimes, d)~trt,n.knots=5,kappa=0, data=survDat,cross.validation = T)
kap &lt;- round(tte$kappa,2);kap # smoothing parameter
  CTPJM_cl &lt;- longiPenal(Surv(deathTimes, d)~trt, Y~timej*trtY,
  data=survDat, data.Longi = longDat,
  random = c("1","timej"), formula.Binary=Y~timej*trtY,
  random.Binary=c("1"), timevar="timej", id = "id",
  link = "Current-level", n.knots = 5, kappa = kap,
  hazard="Splines-per", method.GH="Monte-carlo",
  n.nodes=500)

  print(CTPJM_cl)


# Marginal two-part joint model - random-effects association structure (~10min)
longDat$Yex &lt;- exp(longDat$Y)-1
MTPJM_re &lt;- longiPenal(Surv(deathTimes, d)~trt, Yex~timej*trtY,
                  data=survDat, data.Longi = longDat,MTP=T,GLMlog = T,
                  random = c("1"), formula.Binary=Y~timej*trtY,
                  random.Binary=c("1"), timevar="timej", id = "id",
                  link = "Random-effects", n.knots = 5, kappa = kap,
                  hazard="Splines-per", method.GH="Monte-carlo",
                  n.nodes=500)

print(MTPJM_re)

# Marginal two-part joint model - current-level association structure (~45min)
 MTPJM_cl &lt;- longiPenal(Surv(deathTimes, d)~trt, Yex~timej*trtY,
                  data=survDat, data.Longi = longDat,MTP=T,GLMlog = T,
                  random = c("1","timej"), formula.Binary=Y~timej*trtY,
                  random.Binary=c("1"), timevar="timej", id = "id",
                  link = "Current-level", n.knots = 5, kappa = kap,
                  hazard="Splines-per", method.GH="Monte-carlo",
                  n.nodes=500)

print(MTPJM_cl)

###--- Mediation analysis  
#Takes ~ 10 minutes to run
data(colorectal)
data(colorectalLongi)
colorectalSurv &lt;- subset(colorectal, new.lesions == 0)

colorectalSurv$treatment&lt;-sapply(colorectalSurv$treatment,function(t) ifelse(t=="S",1,0))
colorectalLongi$treatment&lt;-sapply(colorectalLongi$treatment,function(t) ifelse(t=="S",1,0))

mod.col=longiPenal(Surv(time1, state) ~ age+treatment, 
  	       tumor.size ~ age+year*treatment,
           data=colorectalSurv,	data.Longi = colorectalLongi, random = c("1", "year"),
           id = "id", link = "Current-level",timevar="year",method.GH = "Pseudo-adaptive",
           mediation = TRUE,med.trt = colorectalSurv$treatment,
           med.center = NULL,med.nmc = 50,n.knots = 7, kappa = 2,
  	        pte.ntimes = 30,pte.boot = T,pte.nmc = 1000,pte.nboot = 1000)

print(mod.col)
plot(mod.col,plot.mediation='All')

## End(Not run)
</code></pre>

<hr>
<h2 id='loocv'>The trials leave-one-out crossvalidation for the one-step Joint surrogate model for evaluating a 
canditate surrogate endpoint.</h2><span id='topic+loocv'></span>

<h3>Description</h3>


<p>The trials leave-one-out crossvalidation for evaluating the joint surrogate model 

</p>


<h3>Usage</h3>

<pre><code class='language-R'>loocv(object, unusedtrial, var.used = "error.estim", alpha. = 0.05, 
dec = 3, print.times = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loocv_+3A_object">object</code></td>
<td>
<p>An object inheriting from <code>jointSurroPenal</code> class
(output from calling the function <code>jointSurroPenal</code> or <code>jointSurroCopPenal</code>).</p>
</td></tr>
<tr><td><code id="loocv_+3A_unusedtrial">unusedtrial</code></td>
<td>
<p>A list of trial not to be taken into account in the cross-validation.
This parameter is useful when after excluding some trials, the model is facing 
convergence problem.</p>
</td></tr>
<tr><td><code id="loocv_+3A_var.used">var.used</code></td>
<td>
<p>This argument takes two values. The first one is <code>"error.estim"</code>
and indicates if the prediction variance takes into account
the estimation errors from the estimates of the parameters. If estimates 
are supposed to be known or if the dataset includes a high number of trials with 
a high number of subject per trial, value <code>"No.error"</code> can be used. 
The default is <code>error.estim</code>.</p>
</td></tr>
<tr><td><code id="loocv_+3A_alpha.">alpha.</code></td>
<td>
<p>The confidence level for the prediction interval. The default is <code>0.05</code></p>
</td></tr>
<tr><td><code id="loocv_+3A_dec">dec</code></td>
<td>
<p>The desired number of digits after the decimal point for parameters
and confidence intervals. Default of 3 digits is used.</p>
</td></tr>
<tr><td><code id="loocv_+3A_print.times">print.times</code></td>
<td>
<p>a logical parameter to print estimation time. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of class <code>jointSurroPenalloocv</code> containing:
</p>
<table role = "presentation">
<tr><td><code>result</code></td>
<td>
<p>A dataframe 
including for each trial the number of included subjects, the observed 
treatment effect on the surrogate endpoint, the observed treatment effect on
the true endpoint and the predicted treatment effect on the 
true enpoint with the associated prediction intervals. If the observed treatment effect on the true 
endpoint is included into the prediction interval, the last columns contains &quot;*&quot;.</p>
</td></tr> 
<tr><td><code>ntrial</code></td>
<td>
<p>The number of trials in the meta-analysis</p>
</td></tr>
<tr><td><code>notconvtrial</code></td>
<td>
<p>The vector of trials that have not converged</p>
</td></tr>
<tr><td><code>pred.error</code></td>
<td>
<p>The prediction error, corresponding to the number of cases where the prediction interval does not included the observed treatment effect on T</p>
</td></tr>
<tr><td><code>different.models</code></td>
<td>
<p>The list of the <code>G</code> models obtained after excuded for the <code>i-th</code> trial</p>
</td></tr>
<tr><td><code>loocv.summary</code></td>
<td>
<p>A dataframe of the estimates for the <code>G</code> models; each raw including the results
without the subjects of the given trial</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a> and 
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>
</p>


<h3>References</h3>

<p>Burzykowski T, Buyse M (2006). &quot;Surrogate threshold effect: an alternative 
measure for meta-analytic surrogate endpoint validation.&quot; Pharmaceutical 
Statistics, 5(3), 173-186.ISSN 1539-1612.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurroPenal">jointSurroPenal</a>, <a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
# Generation of data to use 
 data.sim &lt;- jointSurrSimul(n.obs=300, n.trial = 10,cens.adm=549.24,
             alpha = 1.5, theta = 3.5, gamma = 2.5, zeta = 1, sigma.s = 0.7,
             sigma.t = 0.7, cor = 0.8, betas = -1.25, betat = -1.25,
             full.data = 0, random.generator = 1, seed = 0,
             nb.reject.data = 0)

###--- Joint surrogate model ---###
 
joint.surro.sim.MCGH &lt;- jointSurroPenal(data = data.sim, int.method = 2,
                        nb.mc = 300, nb.gh = 20, print.iter = F)

# Example of loocv taking into accountn ony trial 2 trials (1 and 3)
dloocv &lt;- loocv(joint.surro.sim.MCGH, unusedtrial = c(2,4:10))
dloocv$result
dloocv$loocv.summary

# In order to summarize all the estimated models during the loocv proccess:
dloocv$different.models


## End(Not run)


</code></pre>

<hr>
<h2 id='multivPenal'>Fit a multivariate frailty model for two types of recurrent events and a
terminal event.</h2><span id='topic+multivPenal'></span><span id='topic+transfo.table'></span><span id='topic+for'></span><span id='topic+multivariate'></span><span id='topic+frailty'></span><span id='topic+model'></span>

<h3>Description</h3>


<p>Fit a multivariate frailty model for two types of recurrent events with a
terminal event using a penalized likelihood estimation on the hazard
function or a parametric estimation. Right-censored data are allowed.
Left-truncated data and stratified analysis are not possible. Multivariate
frailty models allow studying, with a joint model, three survival dependent
processes for two types of recurrent events and a terminal event.
Multivariate joint frailty models are applicable in mainly two settings.
First, when focus is on the terminal event and we wish to account for the
effect of previous endogenous recurrent event. Second, when focus is on a
recurrent event and we wish to correct for informative censoring.
</p>
<p>The multivariate frailty model for two types of recurrent events with a
terminal event is (in the calendar or time-to-event timescale):
</p>
<p><img src="../help/figures/multivmodel1.png" width="100%" alt="multivmodel1.png" />
</p>
<p>where <code class="reqn">r</code><sub>0</sub><sup>l</sup>(t), (l&isin;{1,3}) and <code class="reqn">r</code><sub>0</sub>(t) are
respectively the recurrent and terminal event baseline hazard functions, and
<code class="reqn">\beta</code><sub>1</sub>,<code class="reqn">\beta</code><sub>2</sub>,<code class="reqn">\beta</code><sub>3</sub> the regression coefficient vectors associated
with <code class="reqn">Z</code><sub>i</sub>(t) the covariate vector. The covariates could be different
for the different event hazard functions and may be time-dependent. We
consider that death stops new occurrences of recurrent events of any type,
hence given <code class="reqn">t&gt;D</code>, <code class="reqn">dN</code><sup>R(l)*</sup>(t), (l&isin;{1,2}) takes the value 0.
Thus, the terminal and the two recurrent event processes are not independent
or even conditional upon frailties and covariates. We consider the hazard
functions of recurrent events among individuals still alive.  
components in the above multivariate frailty model are linked together by
two Gaussian and correlated random effects <code class="reqn">u</code><sub>i</sub>,<code class="reqn">v</code><sub>i</sub>: 
(<code class="reqn">u</code><sub>i</sub>,<code class="reqn">v</code><sub>i</sub>)<sup>T</sup> <span>&#126;</span> <b><code class="reqn">N</code></b>(0,<code class="reqn">\Sigma</code><sub>uv</sub>), with
</p>
<p><img src="../help/figures/multivmodel2.png" width="100%" alt="multivmodel2.png" />
</p>
<p>Dependencies between these three types of event are taken into account by
two correlated random effects and parameters <code class="reqn">\theta</code><sub>1</sub>,<code class="reqn">\theta</code><sub>2</sub> the
variance of the random effects and <code class="reqn">\alpha</code><sub>1</sub>,<code class="reqn">\alpha</code><sub>2</sub> the coefficients
for these random effects into the terminal event part. If <code class="reqn">\alpha</code><sub>1</sub> and
<code class="reqn">\theta</code><sub>1</sub> are both significantly different from 0, then the recurrent
events of type 1 and death are significantly associated (the sign of the
association is the sign of <code class="reqn">\alpha</code><sub>1</sub>). If <code class="reqn">\alpha</code><sub>2</sub> and
<code class="reqn">\theta</code><sub>2</sub> are both significantly different from 0, then the recurrent
events of type 2 and death are significantly associated (the sign of the
association is the sign of <code class="reqn">\alpha</code><sub>2</sub>). If <code class="reqn">\rho</code>, the correlation
between the two random effects, is significantly different from 0, then the
recurrent events of type 1 and the recurrent events of type 2 are
significantly associated (the sign of the association is the sign of
<code class="reqn">\rho</code>).



</p>


<h3>Usage</h3>

<pre><code class='language-R'>multivPenal(formula, formula.Event2, formula.terminalEvent, data, initialize
= TRUE, recurrentAG = FALSE, n.knots, kappa, maxit = 350, hazard =
"Splines", nb.int, print.times = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multivPenal_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response for the first recurrent
event on the left of a <code class="reqn">\sim</code> operator, and the terms on the right. The
response must be a survival object as returned by the 'Surv' function like
in survival package.  Interactions are possible using * or :.</p>
</td></tr>
<tr><td><code id="multivPenal_+3A_formula.event2">formula.Event2</code></td>
<td>
<p>a formula object, with the response for the second
recurrent event on the left of a <code class="reqn">\sim</code> operator, and the terms on the
right. The response must be a survival object as returned by the 'Surv'
function like in survival package.  Interactions are possible using * or :.</p>
</td></tr>
<tr><td><code id="multivPenal_+3A_formula.terminalevent">formula.terminalEvent</code></td>
<td>
<p>a formula object, with the response for the
terminal event on the left of a <code class="reqn">\sim</code> operator, and the terms on the
right. The response must be a survival object as returned by the 'Surv'
function like in survival package.</p>
</td></tr>
<tr><td><code id="multivPenal_+3A_data">data</code></td>
<td>
<p>a 'data.frame' with the variables used in 'formula',
'formula.Event2' and 'formula.terminalEvent'.</p>
</td></tr>
<tr><td><code id="multivPenal_+3A_initialize">initialize</code></td>
<td>
<p>Logical value to initialize regression coefficients and
baseline hazard functions parameters. When the estimation is semi-parametric
with splines, this initialization produces also values for smoothing
parameters (by cross validation). When initialization is requested, the
program first fit two shared frailty models (for the two types of recurrent
events) and a Cox proportional hazards model (for the terminal event).
Default is TRUE.</p>
</td></tr>
<tr><td><code id="multivPenal_+3A_recurrentag">recurrentAG</code></td>
<td>
<p>Logical value. Is Andersen-Gill model fitted? If so
indicates that recurrent event times with the counting process approach of
Andersen and Gill is used. This formulation can be used for dealing with
time-dependent covariates. The default is FALSE.</p>
</td></tr>
<tr><td><code id="multivPenal_+3A_n.knots">n.knots</code></td>
<td>
<p>integer vector of length 3 (for the three outcomes) giving
the number of knots to use. First is for the recurrent of type 1, second is
for the recurrent of type 2 and third is for the terminal event hazard
function. Value required in the penalized likelihood estimation. It
corresponds to the (n.knots+2) splines functions for the approximation of
the hazard or the survival functions. Number of knots must be between 4 and
20. (See Note)</p>
</td></tr>
<tr><td><code id="multivPenal_+3A_kappa">kappa</code></td>
<td>
<p>vector of length 3 (for the three outcomes) for positive
smoothing parameters in the penalized likelihood estimation. First is for
the recurrent of type 1, second is for the recurrent of type 2 and third is
for the terminal event hazard function. The coefficient kappa of the
integral of the squared second derivative of hazard function in the fit
(penalized log likelihood). Initial values for the kappas can be obtained
with the option &quot;initialize=TRUE&quot;. We advise the user to identify several
possible tuning parameters, note their defaults and look at the sensitivity
of the results to varying them. Value required.(See Note)</p>
</td></tr>
<tr><td><code id="multivPenal_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations for the Marquardt algorithm.
Default is 350.</p>
</td></tr>
<tr><td><code id="multivPenal_+3A_hazard">hazard</code></td>
<td>
<p>Type of hazard functions: &quot;Splines&quot; for semi-parametric hazard
functions with the penalized likelihood estimation, &quot;Piecewise-per&quot; for
piecewise constant hazard function using percentile, &quot;Piecewise-equi&quot; for
piecewise constant hazard function using equidistant intervals, &quot;Weibull&quot;
for parametric Weibull function. Default is &quot;Splines&quot;.</p>
</td></tr>
<tr><td><code id="multivPenal_+3A_nb.int">nb.int</code></td>
<td>
<p>An integer vector of length 3 (for the three outcomes). First
is the Number of intervals (between 1 and 20) for the recurrent of type 1
parametric hazard functions (&quot;Piecewise-per&quot;, &quot;Piecewise-equi&quot;). Second is
the Number of intervals (between 1 and 20) for the recurrent of type 2
parametric hazard functions (&quot;Piecewise-per&quot;, &quot;Piecewise-equi&quot;). Third is
Number of intervals (between 1 and 20) for the death parametric hazard
functions (&quot;Piecewise-per&quot;, &quot;Piecewise-equi&quot;)</p>
</td></tr>
<tr><td><code id="multivPenal_+3A_print.times">print.times</code></td>
<td>
<p>a logical parameter to print iteration process. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parameters estimates of a multivariate joint frailty model, more
generally a 'multivPenal' object. Methods defined for 'multivPenal' objects
are provided for print, plot and summary. The following components are
included in a 'multivPenal' object for multivariate Joint frailty models.
</p>
<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>sequence of the corresponding estimation of the splines
coefficients, the random effects variances, the coefficients of the
frailties and the regression coefficients.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The code used for
fitting the model.</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>the number of observations used in the fit.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>the number of subjects used in the fit.</p>
</td></tr> <tr><td><code>n.events</code></td>
<td>
<p>the
number of recurrent events of type 1 observed in the fit.</p>
</td></tr>
<tr><td><code>n.events2</code></td>
<td>
<p>the number of the recurrent events of type 2 observed in
the fit.</p>
</td></tr> <tr><td><code>n.deaths</code></td>
<td>
<p>the number of deaths observed in the fit.</p>
</td></tr>
<tr><td><code>loglikPenal</code></td>
<td>
<p>the complete marginal penalized log-likelihood in the
semi-parametric case.</p>
</td></tr> <tr><td><code>loglik</code></td>
<td>
<p>the marginal log-likelihood in the
parametric case.</p>
</td></tr> <tr><td><code>LCV</code></td>
<td>
<p>the approximated likelihood cross-validation
criterion in the semi parametric case (with H minus the converged Hessian
matrix, and l(.) the full
log-likelihood.</p>
<p style="text-align: center;"><code class="reqn">LCV=\frac{1}{n}(trace(H^{-1}_{pl}H) - l(.))</code>
</p>
<p>)</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike information Criterion for the parametric
case.</p>
<p style="text-align: center;"><code class="reqn">AIC=\frac{1}{n}(np - l(.))</code>
</p>
</td></tr> <tr><td><code>theta1</code></td>
<td>
<p>variance of the
frailty parameter for recurrences of type 1 <code class="reqn">(\bold{Var}(u_i))</code></p>
</td></tr>
<tr><td><code>theta2</code></td>
<td>
<p>variance of the frailty parameter for recurrences of type 2
<code class="reqn">(\bold{Var}(v_i))</code></p>
</td></tr> <tr><td><code>alpha1</code></td>
<td>
<p>the coefficient associated with the
frailty parameter <code class="reqn">u_i</code> in the terminal hazard function.</p>
</td></tr>
<tr><td><code>alpha2</code></td>
<td>
<p>the coefficient associated with the frailty parameter
<code class="reqn">v_i</code> in the terminal hazard function.</p>
</td></tr> <tr><td><code>rho</code></td>
<td>
<p>the correlation
coefficient between <code class="reqn">u_i</code> and <code class="reqn">v_i</code></p>
</td></tr> <tr><td><code>npar</code></td>
<td>
<p>number of
parameters.</p>
</td></tr> <tr><td><code>coef</code></td>
<td>
<p>the regression coefficients.</p>
</td></tr> <tr><td><code>nvar</code></td>
<td>
<p>A vector
with the number of covariates of each type of hazard function as
components.</p>
</td></tr> <tr><td><code>varH</code></td>
<td>
<p>the variance matrix of all parameters before
positivity constraint transformation (theta, the regression coefficients and
the spline coefficients). Then, the delta method is needed to obtain the
estimated variance parameters.</p>
</td></tr> <tr><td><code>varHIH</code></td>
<td>
<p>the robust estimation of the
variance matrix of all parameters (theta, the regression coefficients and
the spline coefficients).</p>
</td></tr> <tr><td><code>formula</code></td>
<td>
<p>the formula part of the code used
for the model for the recurrent event.</p>
</td></tr> <tr><td><code>formula.Event2</code></td>
<td>
<p>the formula
part of the code used for the model for the second recurrent event.</p>
</td></tr>
<tr><td><code>formula.terminalEvent</code></td>
<td>
<p>the formula part of the code used for the model
for the terminal event.</p>
</td></tr> <tr><td><code>x1</code></td>
<td>
<p>vector of times for hazard functions of
the recurrent events of type 1 are estimated. By default
seq(0,max(time),length=99), where time is the vector of survival times.</p>
</td></tr>
<tr><td><code>lam1</code></td>
<td>
<p>matrix of hazard estimates and confidence bands for recurrent
events of type 1.</p>
</td></tr> <tr><td><code>xSu1</code></td>
<td>
<p>vector of times for the survival function of
the recurrent event of type 1.</p>
</td></tr> <tr><td><code>surv1</code></td>
<td>
<p>matrix of baseline survival
estimates and confidence bands for recurrent events of type 1.</p>
</td></tr>
<tr><td><code>x2</code></td>
<td>
<p>vector of times for the recurrent event of type 2 (see x1 value).</p>
</td></tr>
<tr><td><code>lam2</code></td>
<td>
<p>the same value as lam1 for the recurrent event of type 2.</p>
</td></tr>
<tr><td><code>xSu2</code></td>
<td>
<p>vector of times for the survival function of the recurrent event
of type 2</p>
</td></tr> <tr><td><code>surv2</code></td>
<td>
<p>the same value as surv1 for the recurrent event of
type 2.</p>
</td></tr> <tr><td><code>xEnd</code></td>
<td>
<p>vector of times for the terminal event (see x1 value).</p>
</td></tr>
<tr><td><code>lamEnd</code></td>
<td>
<p>the same value as lam1 for the terminal event.</p>
</td></tr>
<tr><td><code>xSuEnd</code></td>
<td>
<p>vector of times for the survival function of the terminal
event</p>
</td></tr> <tr><td><code>survEnd</code></td>
<td>
<p>the same value as surv1 for the terminal event.</p>
</td></tr> 
<tr><td><code>median1</code></td>
<td>
<p>The value of the median survival and its confidence bands for the recurrent event of type 1.</p>
</td></tr>
<tr><td><code>median2</code></td>
<td>
<p>The value of the median survival and its confidence bands for the recurrent event of type 2.</p>
</td></tr>  
<tr><td><code>medianEnd</code></td>
<td>
<p>The value of the median survival and its confidence bands for the terminal event.</p>
</td></tr>
<tr><td><code>type.of.Piecewise</code></td>
<td>
<p>Type of Piecewise hazard functions (1:&quot;percentile&quot;,
0:&quot;equidistant&quot;).</p>
</td></tr> <tr><td><code>n.iter</code></td>
<td>
<p>number of iterations needed to converge.</p>
</td></tr>
<tr><td><code>type.of.hazard</code></td>
<td>
<p>Type of hazard functions (0:&quot;Splines&quot;, &quot;1:Piecewise&quot;,
&quot;2:Weibull&quot;).</p>
</td></tr> <tr><td><code>n.knots</code></td>
<td>
<p>a vector with number of knots for estimating
the baseline functions.</p>
</td></tr> <tr><td><code>kappa</code></td>
<td>
<p>a vector with the smoothing parameters
in the penalized likelihood estimation corresponding to each baseline
function as components.</p>
</td></tr> <tr><td><code>n.knots.temp</code></td>
<td>
<p>initial value for the number of
knots.</p>
</td></tr> <tr><td><code>zi</code></td>
<td>
<p>splines knots.</p>
</td></tr> <tr><td><code>time</code></td>
<td>
<p>knots for Piecewise hazard
function for the recurrent event of type 1.</p>
</td></tr> <tr><td><code>timedc</code></td>
<td>
<p>knots for
Piecewise hazard function for the terminal event.</p>
</td></tr> <tr><td><code>time2</code></td>
<td>
<p>knots for
Piecewise hazard function for the recurrent event of type 2.</p>
</td></tr>
<tr><td><code>noVar</code></td>
<td>
<p>indicator vector for recurrent, death and recurrent 2
explanatory variables.</p>
</td></tr> <tr><td><code>nvarRec</code></td>
<td>
<p>number of the recurrent of type 1
explanatory variables.</p>
</td></tr> <tr><td><code>nvarEnd</code></td>
<td>
<p>number of death explanatory
variables.</p>
</td></tr> <tr><td><code>nvarRec2</code></td>
<td>
<p>number of the recurrent of type 2 explanatory
variables.</p>
</td></tr> <tr><td><code>nbintervR</code></td>
<td>
<p>Number of intervals (between 1 and 20) for the
the recurrent of type 1 parametric hazard functions (&quot;Piecewise-per&quot;,
&quot;Piecewise-equi&quot;).</p>
</td></tr> <tr><td><code>nbintervDC</code></td>
<td>
<p>Number of intervals (between 1 and 20)
for the death parametric hazard functions (&quot;Piecewise-per&quot;,
&quot;Piecewise-equi&quot;).</p>
</td></tr> <tr><td><code>nbintervR2</code></td>
<td>
<p>Number of intervals (between 1 and 20)
for the the recurrent of type 2 parametric hazard functions
(&quot;Piecewise-per&quot;, &quot;Piecewise-equi&quot;).</p>
</td></tr> <tr><td><code>istop</code></td>
<td>
<p>Vector of the convergence
criteria.</p>
</td></tr> <tr><td><code>shape.weib</code></td>
<td>
<p>shape parameters for the Weibull hazard
function.</p>
</td></tr> <tr><td><code>scale.weib</code></td>
<td>
<p>scale parameters for the Weibull hazard
function.</p>
</td></tr>
<tr><td><code>martingale.res</code></td>
<td>
<p>martingale residuals for each cluster (recurrent of
type 1).</p>
</td></tr> <tr><td><code>martingale2.res</code></td>
<td>
<p>martingale residuals for each cluster
(recurrent of type 2).</p>
</td></tr> <tr><td><code>martingaledeath.res</code></td>
<td>
<p>martingale residuals for
each cluster (death).</p>
</td></tr> <tr><td><code>frailty.pred</code></td>
<td>
<p>empirical Bayes prediction of the
first frailty term.</p>
</td></tr> <tr><td><code>frailty2.pred</code></td>
<td>
<p>empirical Bayes prediction of the
second frailty term.</p>
</td></tr> <tr><td><code>frailty.var</code></td>
<td>
<p>variance of the empirical Bayes
prediction of the first frailty term.</p>
</td></tr> <tr><td><code>frailty2.var</code></td>
<td>
<p>variance of the
empirical Bayes prediction of the second frailty term.</p>
</td></tr>
<tr><td><code>frailty.corr</code></td>
<td>
<p>Correlation between the empirical Bayes prediction of
the two frailty.</p>
</td></tr> <tr><td><code>linear.pred</code></td>
<td>
<p>linear predictor: uses Beta'X + ui in
the multivariate frailty models.</p>
</td></tr> <tr><td><code>linear2.pred</code></td>
<td>
<p>linear predictor: uses
Beta'X + vi in the multivariate frailty models.</p>
</td></tr>
<tr><td><code>lineardeath.pred</code></td>
<td>
<p>linear predictor for the terminal part form the
multivariate frailty models: Beta'X + alpha1 ui + alpha2 vi</p>
</td></tr>
<tr><td><code>global_chisq</code></td>
<td>
<p>Recurrent event of type 1: a vector with the values of
each multivariate Wald test.</p>
</td></tr> <tr><td><code>dof_chisq</code></td>
<td>
<p>Recurrent event of type 1: a
vector with the degree of freedom for each multivariate Wald test.</p>
</td></tr>
<tr><td><code>global_chisq.test</code></td>
<td>
<p>Recurrent event of type 1: a binary variable equals
to 0 when no multivariate Wald is given, 1 otherwise.</p>
</td></tr>
<tr><td><code>p.global_chisq</code></td>
<td>
<p>Recurrent event of type 1: a vector with the p-values
for each global multivariate Wald test.</p>
</td></tr> <tr><td><code>names.factor</code></td>
<td>
<p>Recurrent event
of type 1: Names of the &quot;as.factor&quot; variables.</p>
</td></tr>
<tr><td><code>global_chisq2</code></td>
<td>
<p>Recurrent event of type 2: a vector with the values of
each multivariate Wald test.</p>
</td></tr> <tr><td><code>dof_chisq2</code></td>
<td>
<p>Recurrent event of type 2: a
vector with the degree of freedom for each multivariate Wald test.</p>
</td></tr>
<tr><td><code>global_chisq.test2</code></td>
<td>
<p>Recurrent event of type 2: a binary variable
equals to 0 when no multivariate Wald is given, 1 otherwise.</p>
</td></tr>
<tr><td><code>p.global_chisq2</code></td>
<td>
<p>Recurrent event of type 2: a vector with the p_values
for each global multivariate Wald test.</p>
</td></tr> <tr><td><code>names.factor2</code></td>
<td>
<p>Recurrent
event of type 2: Names of the &quot;as.factor&quot; variables.</p>
</td></tr>
<tr><td><code>global_chisq_d</code></td>
<td>
<p>Terminal event: a vector with the values of each
multivariate Wald test.</p>
</td></tr> <tr><td><code>dof_chisq_d</code></td>
<td>
<p>Terminal event: a vector with
the degree of freedom for each multivariate Wald test.</p>
</td></tr>
<tr><td><code>global_chisq.test_d</code></td>
<td>
<p>Terminal event: a binary variable equals to 0
when no multivariate Wald is given, 1 otherwise.</p>
</td></tr>
<tr><td><code>p.global_chisq_d</code></td>
<td>
<p>Terminal event: a vector with the p-values for each
global multivariate Wald test.</p>
</td></tr> <tr><td><code>names.factordc</code></td>
<td>
<p>Terminal event: Names
of the &quot;as.factor&quot; variables.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>&quot;kappa&quot; (kappa[1], kappa[2] and kappa[3]) and &quot;n.knots&quot; (n.knots[1],
n.knots[2] and n.knots[3]) are the arguments that the user has to change if
the fitted model does not converge.  &quot;n.knots&quot; takes integer values between
4 and 20. But with n.knots=20, the model will take a long time to converge.
So, usually, begin first with n.knots=7, and increase it step by step until
it converges. &quot;kappa&quot; only takes positive values. So, choose a value for
kappa (for instance 10000), and if it does not converge, multiply or divide
this value by 10 or 5 until it converges.  Moreover, it may be useful to
change the value of the initialize argument.
</p>


<h3>References</h3>

<p>Mazroui Y., Mathoulin-Pellissier S., MacGrogan G., Brouste V., Rondeau V.
(2013). Multivariate frailty models for two types of recurrent events with
an informative terminal event : Application to breast cancer data.
<em>Biometrical journal</em>, <b>55(6)</b>, 866-884.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+terminal">terminal</a></code>,<code><a href="#topic+event2">event2</a></code>,
<code><a href="#topic+print.multivPenal">print.multivPenal</a></code>,<code><a href="#topic+summary.multivPenal">summary.multivPenal</a></code>,<code><a href="#topic+plot.multivPenal">plot.multivPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



###--- Multivariate Frailty model ---###

data(dataMultiv)

# (computation takes around 60 minutes)
modMultiv.spli &lt;- multivPenal(Surv(TIMEGAP,INDICREC)~cluster(PATIENT)+v1+v2+
             event2(INDICMETA)+terminal(INDICDEATH),formula.Event2=~v1+v2+v3,
             formula.terminalEvent=~v1,data=dataMultiv,n.knots=c(8,8,8),
             kappa=c(1,1,1),initialize=FALSE)

print(modMultiv.spli)

modMultiv.weib &lt;- multivPenal(Surv(TIMEGAP,INDICREC)~cluster(PATIENT)+v1+v2+
             event2(INDICMETA)+terminal(INDICDEATH),formula.Event2=~v1+v2+v3,
             formula.terminalEvent=~v1,data=dataMultiv,hazard="Weibull")

print(modMultiv.weib)

modMultiv.cpm &lt;- multivPenal(Surv(TIMEGAP,INDICREC)~cluster(PATIENT)+v1+v2+
             event2(INDICMETA)+terminal(INDICDEATH),formula.Event2=~v1+v2+v3,
             formula.terminalEvent=~v1,data=dataMultiv,hazard="Piecewise-per",
             nb.int=c(6,6,6))

print(modMultiv.cpm)




</code></pre>

<hr>
<h2 id='num.id'>Identify individuals in Joint model for clustered data</h2><span id='topic+num.id'></span>

<h3>Description</h3>

<p>This is a special function used in addition to the <code>cluster()</code> function
in the context of survival joint models for clustered data. This function
identifies subject index. It is used on the right hand side of a
'frailtyPenal' formula. Using <code>num.id()</code> in a formula implies that a
joint frailty model for clustered data is fitted (Rondeau et al. 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.id(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="num.id_+3A_x">x</code></td>
<td>
<p>A character or numeric variable which is supposed to indicate the
variable identifying individuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>References</h3>

<p>V. Rondeau, J.P. Pignon, S. Michiels (2011). A joint model for
the dependence between clustered times to tumour progression and deaths: A
meta-analysis of chemotherapy in head and neck cancer. <em>Statistical
methods in medical research</em> <b>897</b>, 1-19.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



data(readmission)
#-- here is generated cluster (5 clusters)
readmission &lt;- transform(readmission,group=id%%5+1)

#-- exclusion all recurrent events --#
#--  to obtain framework of semi-competing risks --#
readmission2 &lt;- subset(readmission, (t.start == 0 &amp; event == 1) | event == 0)

joi.clus.gap &lt;- frailtyPenal(Surv(time,event)~cluster(group)+
num.id(id)+dukes+charlson+sex+chemo+terminal(death),
formula.terminalEvent=~dukes+charlson+sex+chemo,
data=readmission2,recurrentAG=FALSE, n.knots=8,
kappa=c(1.e+10,1.e+10) ,Alpha="None")




</code></pre>

<hr>
<h2 id='plot.additivePenal'>Plot Method for an Additive frailty model.</h2><span id='topic+plot.additivePenal'></span><span id='topic+lines.additivePenal'></span>

<h3>Description</h3>

<p>Plots estimated baseline survival and hazard functions (output from an object 
of class'additivePenal' object for additive frailty model ). 
Confidence bands are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'additivePenal'
plot(x, type.plot="Hazard", conf.bands=TRUE,
pos.legend="topright", cex.legend=0.7, main, color=2, median=TRUE, Xlab = "Time", Ylab =
"Hazard function", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.additivePenal_+3A_x">x</code></td>
<td>
<p>An object of a fitted additive frailty model (output from calling <code>additivePenal</code>).</p>
</td></tr>
<tr><td><code id="plot.additivePenal_+3A_type.plot">type.plot</code></td>
<td>
<p>a character string specifying the type of curve. Possible
value are &quot;Hazard&quot;, or &quot;Survival&quot;. The default is &quot;Hazard&quot;. Only the first
words are required, e.g &quot;Haz&quot;, &quot;Su&quot;</p>
</td></tr>
<tr><td><code id="plot.additivePenal_+3A_conf.bands">conf.bands</code></td>
<td>
<p>logical value. Determines whether confidence bands will be
plotted. The default is to do so.</p>
</td></tr>
<tr><td><code id="plot.additivePenal_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'</p>
</td></tr>
<tr><td><code id="plot.additivePenal_+3A_cex.legend">cex.legend</code></td>
<td>
<p>character expansion factor *relative* to current
'par(&quot;cex&quot;)'. Default is 0.7</p>
</td></tr>
<tr><td><code id="plot.additivePenal_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot.additivePenal_+3A_color">color</code></td>
<td>
<p>curve color (integer)</p>
</td></tr>
<tr><td><code id="plot.additivePenal_+3A_median">median</code></td>
<td>
<p>Logical value. Determines whether survival median will be plotted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.additivePenal_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time&quot;'</p>
</td></tr>
<tr><td><code id="plot.additivePenal_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;Hazard function&quot;'</p>
</td></tr>
<tr><td><code id="plot.additivePenal_+3A_...">...</code></td>
<td>
<p>Other graphical parameters like those in
<code><a href="#topic+plot.frailtyPenal">plot.frailtyPenal</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print a plot of the baseline survival or hazard functions with the
confidence bands or not (conf.bands argument)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+additivePenal">additivePenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



data(dataAdditive)

modAdd &lt;- additivePenal(Surv(t1,t2,event)~cluster(group)+var1+slope(var1),
correlation=TRUE,data=dataAdditive,n.knots=8,kappa=862,hazard="Splines")

#-- 'var1' is boolean as a treatment variable

plot(modAdd)




</code></pre>

<hr>
<h2 id='plot.Diffepoce'>Plot difference of EPOCE estimators between two joint frailty models.</h2><span id='topic+plot.Diffepoce'></span>

<h3>Description</h3>

<p>Plots values of the difference of two Cross-Validated Prognosis Observed
Loss (CVPOL) computed with two joint frailty models. Confidence intervals
are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Diffepoce'
plot(x, conf.bands=TRUE, Xlab = "Time", Ylab =
"EPOCE difference" , ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Diffepoce_+3A_x">x</code></td>
<td>
<p>An object inheriting from <code>Diffepoce</code> class.</p>
</td></tr>
<tr><td><code id="plot.Diffepoce_+3A_conf.bands">conf.bands</code></td>
<td>
<p>Logical value. Determines whether confidence intervals
will be plotted. The default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.Diffepoce_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time&quot;'</p>
</td></tr>
<tr><td><code id="plot.Diffepoce_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;EPOCE difference&quot;'</p>
</td></tr>
<tr><td><code id="plot.Diffepoce_+3A_...">...</code></td>
<td>
<p>Other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print one plot with one curve and its confidence interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Diffepoce">Diffepoce</a></code>
</p>

<hr>
<h2 id='plot.epoce'>Plot values of estimators of the Expected Prognostic Observed Cross-Entropy
(EPOCE).</h2><span id='topic+plot.epoce'></span>

<h3>Description</h3>

<p>Plots values of estimators MPOL and CVPOL for evaluating EPOCE. No
confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epoce'
plot(x, type, pos.legend="topright", cex.legend=0.7,
Xlab="Time",Ylab="Epoce", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.epoce_+3A_x">x</code></td>
<td>
<p>An object inheriting from <code>epoce</code> class</p>
</td></tr>
<tr><td><code id="plot.epoce_+3A_type">type</code></td>
<td>
<p>Type of estimator to plot. If new dataset was used only mpol can
be plotted (<code>"mpol"</code>), otherwise mpol and cvpol can be plotted
(<code>"mpol"</code> and <code>"cvpol"</code>, default is <code>"cvpol"</code>).</p>
</td></tr>
<tr><td><code id="plot.epoce_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'.</p>
</td></tr>
<tr><td><code id="plot.epoce_+3A_cex.legend">cex.legend</code></td>
<td>
<p>size of the legend. Default is 0.7.</p>
</td></tr>
<tr><td><code id="plot.epoce_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time&quot;'</p>
</td></tr>
<tr><td><code id="plot.epoce_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;Epoce&quot;'</p>
</td></tr>
<tr><td><code id="plot.epoce_+3A_...">...</code></td>
<td>
<p>Other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print a curve of the estimator of EPOCE using time points defined in
<code>epoce</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epoce">epoce</a></code>
</p>

<hr>
<h2 id='plot.frailtyPenal'>Plot Method for a Shared frailty model.</h2><span id='topic+plot.frailtyPenal'></span><span id='topic+lines.frailtyPenal'></span>

<h3>Description</h3>

<p>Plots estimated baseline survival and hazard functions from an object of
class 'frailtyPenal'. Confidence bands are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frailtyPenal'
plot(x, type.plot = "Hazard", conf.bands=TRUE,
pos.legend = "topright", cex.legend=0.7, main, color=2, median=TRUE, Xlab = "Time", Ylab
= "Hazard function", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.frailtyPenal_+3A_x">x</code></td>
<td>
<p>A shared frailty model, i.e. a <code>frailtyPenal</code> class object
(output from calling <code>frailtyPenal</code> function).</p>
</td></tr>
<tr><td><code id="plot.frailtyPenal_+3A_type.plot">type.plot</code></td>
<td>
<p>a character string specifying the type of curve. Possible
value are &quot;Hazard&quot;, or &quot;Survival&quot;. The default is &quot;Hazard&quot;. Only the first
letters are required, e.g &quot;Haz&quot;, &quot;Su&quot;</p>
</td></tr>
<tr><td><code id="plot.frailtyPenal_+3A_conf.bands">conf.bands</code></td>
<td>
<p>Logical value. Determines whether confidence bands will be
plotted.  The default is to do so.</p>
</td></tr>
<tr><td><code id="plot.frailtyPenal_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'</p>
</td></tr>
<tr><td><code id="plot.frailtyPenal_+3A_cex.legend">cex.legend</code></td>
<td>
<p>character expansion factor *relative* to current
'par(&quot;cex&quot;)'. Default is 0.7</p>
</td></tr>
<tr><td><code id="plot.frailtyPenal_+3A_main">main</code></td>
<td>
<p>title of plot</p>
</td></tr>
<tr><td><code id="plot.frailtyPenal_+3A_color">color</code></td>
<td>
<p>color of the curve (integer)</p>
</td></tr>
<tr><td><code id="plot.frailtyPenal_+3A_median">median</code></td>
<td>
<p>Logical value. Determines whether survival median will be plotted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.frailtyPenal_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time&quot;'</p>
</td></tr>
<tr><td><code id="plot.frailtyPenal_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;Hazard function&quot;'</p>
</td></tr>
<tr><td><code id="plot.frailtyPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print a plot of a shared frailty model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

data(readmission)

###--- Shared frailty model ---###

modSha &lt;- frailtyPenal(Surv(time,event)~as.factor(dukes)+cluster(id),
n.knots=10,kappa=10000,data=readmission,hazard="Splines")

plot(modSha,type="Survival",conf=FALSE)

###--- Cox proportional hazard model ---###

modCox &lt;- frailtyPenal(Surv(time,event)~as.factor(dukes),n.knots=10,
kappa=10000,data=readmission,hazard="Splines")

plot(modCox)

#-- no confidence bands
plot(modSha,conf.bands=FALSE)
plot(modCox,conf.bands=FALSE)


## End(Not run)


</code></pre>

<hr>
<h2 id='plot.jointNestedPenal'>Plot method for a joint nested frailty model.</h2><span id='topic+plot.jointNestedPenal'></span><span id='topic+lines.jointNestedPenal'></span>

<h3>Description</h3>

<p>Plots estimated baseline survival and hazard functions of a joint nested
frailty model (output from an object of class 'jointNestedPenal' for joint
nested frailty models) for each type of event (terminal or recurrent).
Confidence bands are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointNestedPenal'
plot(x, event = "Both", type.plot = "Hazard",
conf.bands = FALSE, pos.legend="topright", cex.legend = 0.7, ylim, main,
color = 2, median=TRUE, Xlab = "Time", Ylab = "Hazard function", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.jointNestedPenal_+3A_x">x</code></td>
<td>
<p>A joint nested model, i.e. an object of class
<code>jointNestedPenal</code> for joint nested frailty model (output from calling
<code>frailtyPenal</code> function).</p>
</td></tr>
<tr><td><code id="plot.jointNestedPenal_+3A_event">event</code></td>
<td>
<p>a character string specifying the type of curve. Possible value
are &quot;Terminal&quot;, &quot;Recurrent&quot;, or &quot;Both&quot;. The default is &quot;Both&quot;.</p>
</td></tr>
<tr><td><code id="plot.jointNestedPenal_+3A_type.plot">type.plot</code></td>
<td>
<p>a character string specifying the type of curve. Possible
value are &quot;Hazard&quot;, or &quot;Survival&quot;. The default is &quot;Hazard&quot;. Only the first
letters are required, e.g &quot;Haz&quot;, &quot;Su&quot;</p>
</td></tr>
<tr><td><code id="plot.jointNestedPenal_+3A_conf.bands">conf.bands</code></td>
<td>
<p>logical value. Determines whether confidence bands will be
plotted. The default is to do so.</p>
</td></tr>
<tr><td><code id="plot.jointNestedPenal_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'</p>
</td></tr>
<tr><td><code id="plot.jointNestedPenal_+3A_cex.legend">cex.legend</code></td>
<td>
<p>character expansion factor *relative* to current
'par(&quot;cex&quot;)'. Default is 0.7</p>
</td></tr>
<tr><td><code id="plot.jointNestedPenal_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits</p>
</td></tr>
<tr><td><code id="plot.jointNestedPenal_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot.jointNestedPenal_+3A_color">color</code></td>
<td>
<p>curve color (integer)</p>
</td></tr>
<tr><td><code id="plot.jointNestedPenal_+3A_median">median</code></td>
<td>
<p>Logical value. Determines whether survival median will be plotted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.jointNestedPenal_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time&quot;'</p>
</td></tr>
<tr><td><code id="plot.jointNestedPenal_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;Hazard function&quot;'</p>
</td></tr>
<tr><td><code id="plot.jointNestedPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print a plot of the baseline survival or hazard functions for each
type of event or both with the confidence bands or not (conf.bands argument)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

#-- here is generated cluster (30 clusters)
readmissionNested &lt;- transform(readmission,group=id%%30+1)

# Baseline hazard function approximated with splines with calendar-timescale

model.spli.AG &lt;- frailtyPenal(formula = Surv(t.start, t.stop, event) 
~ subcluster(id) + cluster(group) + dukes + terminal(death), 
formula.terminalEvent = ~dukes, data = readmissionNested, recurrentAG = TRUE,
 n.knots = 8, kappa = c(9.55e+9, 1.41e+12),initialize = TRUE)

# Plot the estimated baseline hazard function with the confidence intervals
plot(model.spli.AG)	

# Plot the estimated baseline hazard function with the confidence intervals
plot(model.spli.RE, type = "Survival")
	

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.jointPenal'>Plot Method for a Joint frailty model.</h2><span id='topic+plot.jointPenal'></span><span id='topic+lines.jointPenal'></span>

<h3>Description</h3>

<p>Plots estimated baseline survival and hazard functions of a joint frailty
model (output from an object of class 'JointPenal' for joint frailty models
) for each type of event (terminal or recurrent). Confidence bands are
allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointPenal'
plot(x, event = "Both", type.plot = "Hazard", conf.bands
= FALSE, pos.legend="topright", cex.legend = 0.7, ylim, main, color = 2, median=TRUE,
Xlab = "Time", Ylab = "Hazard function", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.jointPenal_+3A_x">x</code></td>
<td>
<p>A joint model, i.e. an object of class <code>frailtyPenal</code> for
Joint frailty model (output from calling <code>frailtyPenal</code> function).</p>
</td></tr>
<tr><td><code id="plot.jointPenal_+3A_event">event</code></td>
<td>
<p>a character string specifying the type of curve. Possible value
are &quot;Terminal&quot;, &quot;Recurrent&quot;, or &quot;Both&quot;. The default is &quot;Both&quot;.</p>
</td></tr>
<tr><td><code id="plot.jointPenal_+3A_type.plot">type.plot</code></td>
<td>
<p>a character string specifying the type of curve. Possible
value are &quot;Hazard&quot;, or &quot;Survival&quot;. The default is &quot;Hazard&quot;. Only the first
letters are required, e.g &quot;Haz&quot;, &quot;Su&quot;</p>
</td></tr>
<tr><td><code id="plot.jointPenal_+3A_conf.bands">conf.bands</code></td>
<td>
<p>logical value. Determines whether confidence bands will be
plotted. The default is to do so.</p>
</td></tr>
<tr><td><code id="plot.jointPenal_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'</p>
</td></tr>
<tr><td><code id="plot.jointPenal_+3A_cex.legend">cex.legend</code></td>
<td>
<p>character expansion factor *relative* to current
'par(&quot;cex&quot;)'. Default is 0.7</p>
</td></tr>
<tr><td><code id="plot.jointPenal_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits</p>
</td></tr>
<tr><td><code id="plot.jointPenal_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot.jointPenal_+3A_color">color</code></td>
<td>
<p>curve color (integer)</p>
</td></tr>
<tr><td><code id="plot.jointPenal_+3A_median">median</code></td>
<td>
<p>Logical value. Determines whether survival median will be plotted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.jointPenal_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time&quot;'</p>
</td></tr>
<tr><td><code id="plot.jointPenal_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;Hazard function&quot;'</p>
</td></tr>
<tr><td><code id="plot.jointPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print a plot of the baseline survival or hazard functions for each
type of event or both with the confidence bands or not (conf.bands argument)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

data(readmission)

#-- Gap-time
modJoint.gap &lt;- frailtyPenal(Surv(time,event)~cluster(id)+sex+dukes+
charlson+terminal(death),formula.terminalEvent=~sex+dukes+charlson,
data=readmission,n.knots=14,kappa=c(100,100))

#-- It takes around 1 minute to converge --#

plot(modJoint.gap,type.plot="Haz",event="recurrent",conf.bands=TRUE)
plot(modJoint.gap,type.plot="Haz",event="terminal",conf.bands=TRUE)
plot(modJoint.gap,type.plot="Haz",event="both",conf.bands=TRUE)

plot(modJoint.gap,type.plot="Su",event="recurrent",conf.bands=TRUE)
plot(modJoint.gap,type.plot="Su",event="terminal",conf.bands=TRUE)
plot(modJoint.gap,type.plot="Su",event="both",conf.bands=TRUE)



## End(Not run)


</code></pre>

<hr>
<h2 id='plot.jointRecCompet'>Plot Method for a joint competing risk model with one recurrent event and 
two terminal events.</h2><span id='topic+plot.jointRecCompet'></span>

<h3>Description</h3>

<p>Plots of estimated baseline survival and hazard functions of joint competing 
recurrent model (output from an object of class 'jointRecCompet') 
for each type of event (recurrent and the two terminal events). 
Confidence intervals are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointRecCompet'
plot(x, event = "All", type.plot = "Hazard",
conf.bands = FALSE, pos.legend = "topright", cex.legend = 0.7, ylim, main,
color1="red", color2="blue", colorEnd="green", median=TRUE, Xlab = "Time", 
Ylab = "Hazard function", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.jointRecCompet_+3A_x">x</code></td>
<td>
<p>A joint competing risk model, i.e. an object of class
<code>jointRecCompet</code> (output from calling <code>jointRecCompet</code> function).</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_event">event</code></td>
<td>
<p>a character string specifying the type of outcome. Possible
value are &quot;Recurrent&quot;, &quot;Terminal1&quot;,  &quot;Terminal2&quot;, or &quot;All&quot;. The default is
&quot;All&quot;.</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_type.plot">type.plot</code></td>
<td>
<p>a character string specifying the type of curve. Possible
value are &quot;Hazard&quot;, or &quot;Survival&quot;. The default is &quot;Hazard&quot;. Only the first
words are required, e.g &quot;Haz&quot;, &quot;Su&quot;</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_conf.bands">conf.bands</code></td>
<td>
<p>logical value. Determines whether confidence intervals
will be plotted. The default is to do so.</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_cex.legend">cex.legend</code></td>
<td>
<p>character expansion factor *relative* to current
'par(&quot;cex&quot;)'. Default is 0.7</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_color1">color1</code></td>
<td>
<p>curve color for recurrent event of type 1 (integer or color
name in quotation marks)</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_color2">color2</code></td>
<td>
<p>curve color for recurrent event of type 2 (integer or color
name in quotation marks)</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_colorend">colorEnd</code></td>
<td>
<p>curve color for terminal event (integer or color name in
quotation marks)</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_median">median</code></td>
<td>
<p>Logical value. Determines whether survival median will be plotted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time&quot;'</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;Hazard function&quot;'</p>
</td></tr>
<tr><td><code id="plot.jointRecCompet_+3A_...">...</code></td>
<td>
<p>Other graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print a plot of the baseline survival or hazard functions for each
type of event or both with the confidence intervals or not (conf.bands
argument)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointRecCompet">jointRecCompet</a></code>
</p>

<hr>
<h2 id='plot.jointSurroMed'>Plot Method for a joint surrogate mediation analysis model.</h2><span id='topic+plot.jointSurroMed'></span>

<h3>Description</h3>

<p>Plots the estimated functions associated with the mediation analysis, i.e.
<code class="reqn">g(s)</code>, <code class="reqn">PTE(t)</code>
as well as the natural direct, indirect and total effects.
An option to plot the confidence bands of the function <code class="reqn">g(s)</code> is available.
This option is also implemented for the confidence bands of the functions
<code class="reqn">PTE(t)</code> and of the natural effects if these confidence bands are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointSurroMed'
plot(x,plot.mediation="All",type.plot="Hazard",
conf.bands=TRUE,endpoint=2,
legend.pos = "topleft",...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.jointSurroMed_+3A_x">x</code></td>
<td>
<p>An object of class <code>jointSurroMed</code> from a joint surrogate model
with a mediation analysis
for longitudinal outcome and a terminal event, i.e., an
output from calling <code>jointSurroPenal</code> function with the option
'mediation' set to TRUE.</p>
</td></tr>
<tr><td><code id="plot.jointSurroMed_+3A_plot.mediation">plot.mediation</code></td>
<td>
<p>A character string specifying the desired plot.
Possible values are &quot;All&quot;, &quot;g&quot;,&quot;PTE&quot; or &quot;Effects&quot;. The default is
&quot;All&quot; which displays all three plots.</p>
</td></tr>
<tr><td><code id="plot.jointSurroMed_+3A_type.plot">type.plot</code></td>
<td>
<p>A character string specifying the type of curve
for the baseline hazards functions. Possible
value are &quot;Hazard&quot;, or &quot;Survival&quot;.</p>
</td></tr>
<tr><td><code id="plot.jointSurroMed_+3A_conf.bands">conf.bands</code></td>
<td>
<p>Logical value. Determines whether confidence bands should be
plotted. The default is to do so if the confidence bands are available.</p>
</td></tr>
<tr><td><code id="plot.jointSurroMed_+3A_endpoint">endpoint</code></td>
<td>
<p>An integer specifying for which endpoint should
the baseline curves be plotted. Possible values are 0
for the surrogate endpoint only and 1 for the final endpoint or 2 for both.
Default is 2.</p>
</td></tr>
<tr><td><code id="plot.jointSurroMed_+3A_legend.pos">legend.pos</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topleft&quot;'</p>
</td></tr>
<tr><td><code id="plot.jointSurroMed_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print one or several plots for the mediation analysis
of a joint surrogate model
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurroPenal">jointSurroPenal</a></code>
</p>

<hr>
<h2 id='plot.jointSurroPenal'>Plot Method for the one-step Joint surrogate model for the evaluation of a 
canditate surrogate endpoint.</h2><span id='topic+plot.jointSurroPenal'></span><span id='topic+lines.jointSurroPenal'></span>

<h3>Description</h3>

<p>Plots estimated baseline survival and hazard functions for the surrogate 
endpoint and the true endpoint from an object of class 'jointSurroPenal'. 
Confidence bands are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointSurroPenal'
plot(x, type.plot = "Hazard", conf.bands=TRUE,
pos.legend = "topright", cex.legend=0.7, main, Xlab = "Time", 
Ylab = "Baseline hazard function", median = TRUE, xmin = 0, xmax = NULL, 
ylim = c(0,1), endpoint = 2, scale = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.jointSurroPenal_+3A_x">x</code></td>
<td>
<p>An object inheriting from <code>jointSurroPenal</code> class
(output from calling the function <code>jointSurroPenal</code> ).</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_type.plot">type.plot</code></td>
<td>
<p>A character string specifying the type of curve. Possible
value are &quot;Hazard&quot;, or &quot;Survival&quot;. The default is &quot;Hazard&quot;. Only the first
letters are required, e.g &quot;Haz&quot;, &quot;Su&quot;.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_conf.bands">conf.bands</code></td>
<td>
<p>Logical value. Determines whether confidence bands will
be plotted.  The default is to do so.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;',
'&quot;bottom&quot;', '&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;',
'&quot;right&quot;' and '&quot;center&quot;'. The default is '&quot;topright&quot;'.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Character expansion factor *relative* to current
'par(&quot;cex&quot;)'. Default is 0.7.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_main">main</code></td>
<td>
<p>Title of plot.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time&quot;'.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;Baseline hazard function&quot;'.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_median">median</code></td>
<td>
<p>Logical value. Determines whether survival median will be plotted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_xmin">xmin</code></td>
<td>
<p>Minimum value for x-axis, the default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_xmax">xmax</code></td>
<td>
<p>Maximum value for x-axis, the default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_ylim">ylim</code></td>
<td>
<p>Range of y-axis. Default is from 0 to 1.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_endpoint">endpoint</code></td>
<td>
<p>A binary that indicates the endpoint to represent. <code>0</code> for
the surrogate endpoint, <code>1</code> for the true endpoint, and <code>2</code> for both
surrogate endpoint and true endpoint. The default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_scale">scale</code></td>
<td>
<p>A numeric that allows to rescale (by multiplication) the survival times. If no change is need the
argument is set to 1, the default value. eg: 1/365 aims to convert days to years .</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print a plot of the baseline survival or hazard functions for each
type of event or both with the confidence bands or not (conf.bands
argument)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurroPenal">jointSurroPenal</a>, <a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 


###--- Joint surrogate model ---###
###---evaluation of surrogate endpoints---###

data(dataOvarian)
joint.surro.ovar &lt;- jointSurroPenal(data = dataOvarian, n.knots = 8, 
                init.kappa = c(2000,1000), indicator.alpha = 0, 
                nb.mc = 200, scale = 1/365)

# Baseline Hazards fonctions for both the surrogate endpoint 
# and the true endpoint
plot(joint.surro.ovar,endpoint = 2,type.plot = "Haz", conf.bands = T)   

# Baseline survival fonctions for both the surrogate endpoint 
# and the true endpoint
plot(joint.surro.ovar,endpoint = 2,type.plot = "Su", conf.bands = T)  
             



## End(Not run)


</code></pre>

<hr>
<h2 id='plot.jointSurroPenalloocv'>Plot of trials leave-one-out crossvalidation Outputs from the one-step Joint surrogate model for evaluating a 
canditate surrogate endpoint.</h2><span id='topic+plot.jointSurroPenalloocv'></span>

<h3>Description</h3>


<p>Plot of trials leave-one-out crossvalidation Outputs for evaluating the joint surrogate model 

</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointSurroPenalloocv'
plot(x, unusedtrial = NULL, xleg = "bottomleft", 
yleg = NULL, main = NULL, xlab = "Trials", 
ylab = "Log Hazard ratio of the true endpoint", 
legend = c("Beta observed", "Beta predict"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.jointSurroPenalloocv_+3A_x">x</code></td>
<td>
<p>An object inherent from the <code>jointSurroPenalloocv</code> Class</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenalloocv_+3A_unusedtrial">unusedtrial</code></td>
<td>
<p>Vector of unconsidered trials, may be due to the fact that the 
predicted treatment effects on true endpoint have an outlier. In this case, 
one can drop from the data the trials with very hight absolute predicted value</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenalloocv_+3A_xleg">xleg</code></td>
<td>
<p>X-coordinate for the location of the legend.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenalloocv_+3A_yleg">yleg</code></td>
<td>
<p>Y-coordinate for the location of the legend, the default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot.jointSurroPenalloocv_+3A_main">main</code></td>
<td>
<p>An overall title for the plot: see <a href="graphics.html#topic+title">title</a>.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenalloocv_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis: see <a href="graphics.html#topic+title">title</a>.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenalloocv_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis: see <a href="graphics.html#topic+title">title</a>.</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenalloocv_+3A_legend">legend</code></td>
<td>
<p>A vector of characters string of length &gt;= 1 to appear in the legend</p>
</td></tr>
<tr><td><code id="plot.jointSurroPenalloocv_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function displays the boxplots corresponding to the number of trials in the 
dataset. Each boxplot includes 3 elements corresponding to the predicted treatment effect on true endpoint
with the prediction interval. The circles inside or outside the boxplot represent the observed
treatment effects on true endpoint. For each trial with convergence issues or outliers, the boxplot is replaced
by a dash. In this case, we display in the title of the figure a vector of these trials, if argument <code>main</code> 
is set to <code>NULL</code>. The function returns the list of unused trials.
</p>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a> and 
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>
</p>


<h3>References</h3>

<p>Burzykowski T, Buyse M (2006). &quot;Surrogate threshold effect: an alternative 
measure for meta-analytic surrogate endpoint validation.&quot; Pharmaceutical 
Statistics, 5(3), 173-186.ISSN 1539-1612.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loocv">loocv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
# Generation of data to use 
 data.sim &lt;- jointSurrSimul(n.obs=300, n.trial = 10,cens.adm=549.24,
             alpha = 1.5, theta = 3.5, gamma = 2.5, zeta = 1, sigma.s = 0.7,
             sigma.t = 0.7, cor = 0.8, betas = -1.25, betat = -1.25,
             full.data = 0, random.generator = 1, seed = 0,
             nb.reject.data = 0)

###--- Joint surrogate model ---###
 
joint.surro.sim.MCGH &lt;- jointSurroPenal(data = data.sim, int.method = 2,
                        nb.mc = 300, nb.gh = 20, print.iter = T)
        
# Example of loocv taking into accountn ony trial 2 trials (1 and 3)
dloocv &lt;- loocv(joint.surro.sim.MCGH, unusedtrial = c(2,4:10))

plot(x = dloocv, xleg = "topright", bty = "n")


## End(Not run)

</code></pre>

<hr>
<h2 id='plot.longiPenal'>Plot Method for a joint model for longitudinal data and a terminal event.</h2><span id='topic+plot.longiPenal'></span><span id='topic+lines.longiPenal'></span>

<h3>Description</h3>

<p>Plots estimated baseline survival and hazard functions for a terminal
outcome from an object of class 'longiPenal'. If available, plot the estimated
quantities related to a mediation analysis. Confidence bands are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'longiPenal'
plot(x, type.plot = "Hazard",plot.mediation="All", 
conf.bands=TRUE,pos.legend= "topright", cex.legend=0.7, main, color, 
median=TRUE, Xlab = "Time", Ylab = "Hazard function", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.longiPenal_+3A_x">x</code></td>
<td>
<p>A joint model for longitudinal outcome and a terminal event, i.e. a
<code>longiPenal</code> class object (output from calling <code>longiPenal</code>
function).</p>
</td></tr>
<tr><td><code id="plot.longiPenal_+3A_type.plot">type.plot</code></td>
<td>
<p>a character string specifying the type of curve for the
terminal event. Possible value are &quot;Hazard&quot;, or &quot;Survival&quot;. The default is
&quot;Hazard&quot;. Only the first words are required, e.g &quot;Haz&quot;, &quot;Su&quot;</p>
</td></tr>
<tr><td><code id="plot.longiPenal_+3A_plot.mediation">plot.mediation</code></td>
<td>
<p>A character string specifying the desired plot.
Possible values are &quot;All&quot;, &quot;PTE&quot; or &quot;Effects&quot;. The default is
&quot;All&quot; which displays both plots.</p>
</td></tr>
<tr><td><code id="plot.longiPenal_+3A_conf.bands">conf.bands</code></td>
<td>
<p>Logical value. Determines whether confidence bands will be
plotted.  The default is to do so.</p>
</td></tr>
<tr><td><code id="plot.longiPenal_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'</p>
</td></tr>
<tr><td><code id="plot.longiPenal_+3A_cex.legend">cex.legend</code></td>
<td>
<p>character expansion factor *relative* to current
'par(&quot;cex&quot;)'. Default is 0.7</p>
</td></tr>
<tr><td><code id="plot.longiPenal_+3A_main">main</code></td>
<td>
<p>title of plot</p>
</td></tr>
<tr><td><code id="plot.longiPenal_+3A_color">color</code></td>
<td>
<p>color of the curve (integer)</p>
</td></tr>
<tr><td><code id="plot.longiPenal_+3A_median">median</code></td>
<td>
<p>Logical value. Determines whether survival median will be plotted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.longiPenal_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time&quot;'</p>
</td></tr>
<tr><td><code id="plot.longiPenal_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;Hazard function&quot;'</p>
</td></tr>
<tr><td><code id="plot.longiPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print a plot for the terminal event of the joint model for a
longitudinal and survival data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+longiPenal">longiPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
###--- Joint model for longitudinal data and a terminal event ---###

data(colorectal)
data(colorectalLongi)

# Survival data preparation - only terminal events 
colorectalSurv &lt;- subset(colorectal, new.lesions == 0)

# Baseline hazard function approximated with splines
# Random effects as the link function

model.spli.RE &lt;- longiPenal(Surv(time1, state) ~ age + treatment + who.PS 
+ prev.resection, tumor.size ~  year * treatment + age + who.PS ,
colorectalSurv,	data.Longi = colorectalLongi, random = c("1", "year"),
id = "id", link = "Random-effects", left.censoring = -3.33, 
n.knots = 7, kappa = 2)
pdf(file = "/home/agareb1/etudiants/al10/newpack/test/plot_longi.pdf")

# Plot the estimated baseline hazard function with the confidence intervals
plot(model.spli.RE)	

# Plot the estimated baseline hazard function with the confidence intervals
plot(model.spli.RE, type = "Survival")	

## End(Not run)


</code></pre>

<hr>
<h2 id='plot.multivPenal'>Plot Method for a multivariate frailty model.</h2><span id='topic+plot.multivPenal'></span>

<h3>Description</h3>

<p>Plots of estimated baseline survival and hazard functions of a multivariate
frailty model (output from an object of class 'multivPenal' for multivariate
frailty models ) for each type of event (recurrent, terminal and second
recurrent). Confidence intervals are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multivPenal'
plot(x, event = "Both", type.plot = "Hazard",
conf.bands = FALSE, pos.legend = "topright", cex.legend = 0.7, ylim, main,
color1="red", color2="blue", colorEnd="green", median=TRUE, Xlab = "Time", 
Ylab = "Hazard function", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.multivPenal_+3A_x">x</code></td>
<td>
<p>A joint multivariate model, i.e. an object of class
<code>multivPenal</code> (output from calling <code>multivPenal</code> function).</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_event">event</code></td>
<td>
<p>a character string specifying the type of outcome. Possible
value are &quot;Terminal&quot;, &quot;Recurrent&quot;, &quot;Recurrent2&quot;, or &quot;Both&quot;. The default is
&quot;Both&quot;.</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_type.plot">type.plot</code></td>
<td>
<p>a character string specifying the type of curve. Possible
value are &quot;Hazard&quot;, or &quot;Survival&quot;. The default is &quot;Hazard&quot;. Only the first
words are required, e.g &quot;Haz&quot;, &quot;Su&quot;</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_conf.bands">conf.bands</code></td>
<td>
<p>logical value. Determines whether confidence intervals
will be plotted. The default is to do so.</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_cex.legend">cex.legend</code></td>
<td>
<p>character expansion factor *relative* to current
'par(&quot;cex&quot;)'. Default is 0.7</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_color1">color1</code></td>
<td>
<p>curve color for recurrent event of type 1 (integer or color
name in quotation marks)</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_color2">color2</code></td>
<td>
<p>curve color for recurrent event of type 2 (integer or color
name in quotation marks)</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_colorend">colorEnd</code></td>
<td>
<p>curve color for terminal event (integer or color name in
quotation marks)</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_median">median</code></td>
<td>
<p>Logical value. Determines whether survival median will be plotted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time&quot;'</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;Hazard function&quot;'</p>
</td></tr>
<tr><td><code id="plot.multivPenal_+3A_...">...</code></td>
<td>
<p>Other graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print a plot of the baseline survival or hazard functions for each
type of event or both with the confidence intervals or not (conf.bands
argument)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multivPenal">multivPenal</a></code>
</p>

<hr>
<h2 id='plot.nestedPenal'>Plot Method for a Nested frailty model.</h2><span id='topic+plot.nestedPenal'></span><span id='topic+lines.nestedPenal'></span>

<h3>Description</h3>

<p>Plots estimated baseline survival and hazard functions (output from an
object of class 'NestedPenal' for nested frailty models). 
Confidence bands are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nestedPenal'
plot(x, type.plot="Hazard", conf.bands=TRUE,
pos.legend="topright", cex.legend=0.7, main, color=2, median=TRUE, Xlab = "Time", Ylab =
"Hazard function", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.nestedPenal_+3A_x">x</code></td>
<td>
<p>A nested model, i.e. an object of class <code>frailtyPenal</code> for
Nested frailty models (output from calling <code>frailtyPenal</code> function).</p>
</td></tr>
<tr><td><code id="plot.nestedPenal_+3A_type.plot">type.plot</code></td>
<td>
<p>a character string specifying the type of curve. Possible
value are &quot;Hazard&quot;, or &quot;Survival&quot;. The default is &quot;Hazard&quot;. Only the first
words are required, e.g &quot;Haz&quot;, &quot;Su&quot;</p>
</td></tr>
<tr><td><code id="plot.nestedPenal_+3A_conf.bands">conf.bands</code></td>
<td>
<p>logical value. Determines whether confidence bands will be
plotted. The default is to do so.</p>
</td></tr>
<tr><td><code id="plot.nestedPenal_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'</p>
</td></tr>
<tr><td><code id="plot.nestedPenal_+3A_cex.legend">cex.legend</code></td>
<td>
<p>character expansion factor *relative* to current
'par(&quot;cex&quot;)'. Default is 0.7</p>
</td></tr>
<tr><td><code id="plot.nestedPenal_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot.nestedPenal_+3A_color">color</code></td>
<td>
<p>curve color (integer)</p>
</td></tr>
<tr><td><code id="plot.nestedPenal_+3A_median">median</code></td>
<td>
<p>Logical value. Determines whether survival median will be plotted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.nestedPenal_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time&quot;'</p>
</td></tr>
<tr><td><code id="plot.nestedPenal_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;Hazard function&quot;'</p>
</td></tr>
<tr><td><code id="plot.nestedPenal_+3A_...">...</code></td>
<td>
<p>Other graphical parameters like those in
<code><a href="#topic+plot.frailtyPenal">plot.frailtyPenal</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print a plot of the baseline survival or hazard functions with the
confidence bands or not (conf.bands argument)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

data(dataNested)
modNested &lt;- frailtyPenal(Surv(t1,t2,event)~cluster(group)+
subcluster(subgroup)+cov1+cov2,data=dataNested,n.knots=8,
kappa=50000,hazard="Splines")

plot(modNested,conf.bands=FALSE)


## End(Not run)


</code></pre>

<hr>
<h2 id='plot.predFrailty'>Plot predictions using a Cox or a shared frailty model.</h2><span id='topic+plot.predFrailty'></span>

<h3>Description</h3>

<p>Plots predicted probabilities of event. Confidence intervals are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predFrailty'
plot(x, conf.bands=FALSE, pos.legend="topright",
cex.legend=0.7, ylim=c(0,1), Xlab = "Time t", Ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.predFrailty_+3A_x">x</code></td>
<td>
<p>An object from the 'prediction' function, i.e. a <code>predFrailty</code>
class object.</p>
</td></tr>
<tr><td><code id="plot.predFrailty_+3A_conf.bands">conf.bands</code></td>
<td>
<p>Logical value. Determines whether confidence intervals
will be plotted. The default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.predFrailty_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'.</p>
</td></tr>
<tr><td><code id="plot.predFrailty_+3A_cex.legend">cex.legend</code></td>
<td>
<p>size of the legend. Default is 0.7.</p>
</td></tr>
<tr><td><code id="plot.predFrailty_+3A_ylim">ylim</code></td>
<td>
<p>range of y-axis. Default is from 0 to 1.</p>
</td></tr>
<tr><td><code id="plot.predFrailty_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time t&quot;'</p>
</td></tr>
<tr><td><code id="plot.predFrailty_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis.</p>
</td></tr>
<tr><td><code id="plot.predFrailty_+3A_...">...</code></td>
<td>
<p>Other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print one plot with as many curves as the number of profiles.
</p>

<hr>
<h2 id='plot.predJoint'>Plot predictions using a joint frailty model.</h2><span id='topic+plot.predJoint'></span>

<h3>Description</h3>

<p>Plots predicted probabilities of terminal event. Confidence intervals are
allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predJoint'
plot(x, conf.bands=FALSE,
relapses=TRUE,pos.legend="topright", cex.legend=0.7, ylim=c(0,1), Xlab =
"Time t", Ylab = "Prediction probability of event", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.predJoint_+3A_x">x</code></td>
<td>
<p>An object from the 'prediction' function, more generaly a
<code>predJoint</code> class object.</p>
</td></tr>
<tr><td><code id="plot.predJoint_+3A_conf.bands">conf.bands</code></td>
<td>
<p>Logical value. Determines whether confidence intervals
will be plotted. The default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.predJoint_+3A_relapses">relapses</code></td>
<td>
<p>Logical value. Determines whether observed recurrent events
will be plotted. The default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.predJoint_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'</p>
</td></tr>
<tr><td><code id="plot.predJoint_+3A_cex.legend">cex.legend</code></td>
<td>
<p>size of the legend. Default is 0.7</p>
</td></tr>
<tr><td><code id="plot.predJoint_+3A_ylim">ylim</code></td>
<td>
<p>range of y-axis. Default is from 0 to 1</p>
</td></tr>
<tr><td><code id="plot.predJoint_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time t&quot;'</p>
</td></tr>
<tr><td><code id="plot.predJoint_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;Prediction probability of event&quot;'</p>
</td></tr>
<tr><td><code id="plot.predJoint_+3A_...">...</code></td>
<td>
<p>Other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print as many plots as the number of subjects.
</p>

<hr>
<h2 id='plot.predLongi'>Plot predictions using a joint model for longitudinal data and a terminal
event or a trivariate joint model for longitudinal data, recurrent events
and a terminal event.</h2><span id='topic+plot.predLongi'></span>

<h3>Description</h3>

<p>Plots predicted probabilities of the event. Confidence intervals are
allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predLongi'
plot(x, conf.bands=FALSE, pos.legend="topright",
cex.legend=0.7, ylim=c(0,1), Xlab = "Time t", Ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.predLongi_+3A_x">x</code></td>
<td>
<p>An object inheriting from <code>predLongi</code>.</p>
</td></tr>
<tr><td><code id="plot.predLongi_+3A_conf.bands">conf.bands</code></td>
<td>
<p>Logical value. Determines whether confidence intervals
will be plotted. The default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.predLongi_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'.</p>
</td></tr>
<tr><td><code id="plot.predLongi_+3A_cex.legend">cex.legend</code></td>
<td>
<p>size of the legend. Default is 0.7.</p>
</td></tr>
<tr><td><code id="plot.predLongi_+3A_ylim">ylim</code></td>
<td>
<p>range of y-axis. Default is from 0 to 1.</p>
</td></tr>
<tr><td><code id="plot.predLongi_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time t&quot;'</p>
</td></tr>
<tr><td><code id="plot.predLongi_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis.</p>
</td></tr>
<tr><td><code id="plot.predLongi_+3A_...">...</code></td>
<td>
<p>Other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print one plot with as many curves as the number of profiles.
</p>

<hr>
<h2 id='plot.trivPenal'>Plot Method for a trivariate joint model for longitudinal data, recurrent
events and a terminal event.</h2><span id='topic+plot.trivPenal'></span><span id='topic+lines.trivPenal'></span>

<h3>Description</h3>

<p>Plots estimated baseline survival and hazard functions of a joint model
(output from an object of class 'trivPenal') for each type of event
(terminal or recurrent). Confidence bands are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trivPenal'
plot(x, event = "Both", type.plot = "Hazard", conf.bands =
FALSE, pos.legend="topright", cex.legend = 0.7, ylim, main, color = 2, median=TRUE, Xlab
= "Time", Ylab = "Hazard function", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.trivPenal_+3A_x">x</code></td>
<td>
<p>A joint model, an object of class <code>trivPenal</code>.</p>
</td></tr>
<tr><td><code id="plot.trivPenal_+3A_event">event</code></td>
<td>
<p>a character string specifying the type of curve. Possible value
are &quot;Terminal&quot;, &quot;Recurrent&quot;, or &quot;Both&quot;. The default is &quot;Both&quot;.</p>
</td></tr>
<tr><td><code id="plot.trivPenal_+3A_type.plot">type.plot</code></td>
<td>
<p>a character string specifying the type of curve. Possible
value are &quot;Hazard&quot;, or &quot;Survival&quot;. The default is &quot;Hazard&quot;. Only the first
words are required, e.g &quot;Haz&quot;, &quot;Su&quot;</p>
</td></tr>
<tr><td><code id="plot.trivPenal_+3A_conf.bands">conf.bands</code></td>
<td>
<p>logical value. Determines whether confidence bands will be
plotted. The default is to do so.</p>
</td></tr>
<tr><td><code id="plot.trivPenal_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'</p>
</td></tr>
<tr><td><code id="plot.trivPenal_+3A_cex.legend">cex.legend</code></td>
<td>
<p>character expansion factor *relative* to current
'par(&quot;cex&quot;)'. Default is 0.7</p>
</td></tr>
<tr><td><code id="plot.trivPenal_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits</p>
</td></tr>
<tr><td><code id="plot.trivPenal_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot.trivPenal_+3A_color">color</code></td>
<td>
<p>curve color (integer)</p>
</td></tr>
<tr><td><code id="plot.trivPenal_+3A_median">median</code></td>
<td>
<p>Logical value. Determines whether survival median will be plotted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.trivPenal_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time&quot;'</p>
</td></tr>
<tr><td><code id="plot.trivPenal_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;Hazard function&quot;'</p>
</td></tr>
<tr><td><code id="plot.trivPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print a plot of the baseline survival or hazard functions for each
type of event or both with the confidence bands or not (conf.bands argument)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trivPenal">trivPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
###--- Trivariate joint model for longitudinal data, ---###
###--- recurrent events and a terminal event ---###

data(colorectal)
data(colorectalLongi)

# Weibull baseline hazard function
# Random effects as the link function, Gap timescale
# (computation takes around 30 minutes)
model.weib.RE.gap &lt;-trivPenal(Surv(gap.time, new.lesions) ~ cluster(id)
+ age + treatment + who.PS + prev.resection + terminal(state),
formula.terminalEvent =~ age + treatment + who.PS + prev.resection, 
tumor.size ~ year * treatment + age + who.PS, data = colorectal,
data.Longi = colorectalLongi, random = c("1", "year"), id = "id", 
link = "Random-effects", left.censoring = -3.33, recurrentAG = FALSE,
hazard = "Weibull", method.GH="Pseudo-adaptive", n.nodes = 7)

plot(model.weib.RE.gap)
plot(model.weib.RE.gap, type = "survival")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.trivPenalNL'>Plot Method for a Non-Linear Trivariate Joint Model for Recurrent Events and
a Terminal Event with a Biomarker Described with an ODE.</h2><span id='topic+plot.trivPenalNL'></span><span id='topic+lines.trivPenalNL'></span>

<h3>Description</h3>

<p>Plots estimated baseline survival and hazard functions of a joint model
(output from an object of class 'trivPenalNL') for each type of event
(terminal or recurrent). Confidence bands are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trivPenalNL'
plot(x, event = "Both", type.plot = "Hazard", conf.bands
= FALSE, pos.legend="topright", cex.legend = 0.7, ylim, main, color = 2, median=TRUE,
Xlab = "Time", Ylab = "Hazard function", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.trivPenalNL_+3A_x">x</code></td>
<td>
<p>A joint model, an object of class <code>trivPenalNL</code>.</p>
</td></tr>
<tr><td><code id="plot.trivPenalNL_+3A_event">event</code></td>
<td>
<p>a character string specifying the type of curve. Possible value
are &quot;terminal&quot;, &quot;recurrent&quot;, or &quot;both&quot;. The default is &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="plot.trivPenalNL_+3A_type.plot">type.plot</code></td>
<td>
<p>a character string specifying the type of curve. Possible
value are &quot;Hazard&quot;, or &quot;survival&quot;. The default is &quot;hazard&quot;. Only the first
words are required, e.g &quot;haz&quot;, &quot;su&quot;</p>
</td></tr>
<tr><td><code id="plot.trivPenalNL_+3A_conf.bands">conf.bands</code></td>
<td>
<p>logical value. Determines whether confidence bands will be
plotted. The default is to do so.</p>
</td></tr>
<tr><td><code id="plot.trivPenalNL_+3A_pos.legend">pos.legend</code></td>
<td>
<p>The location of the legend can be specified by setting
this argument to a single keyword from the list '&quot;bottomright&quot;', '&quot;bottom&quot;',
'&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;', '&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and
'&quot;center&quot;'. The default is '&quot;topright&quot;'</p>
</td></tr>
<tr><td><code id="plot.trivPenalNL_+3A_cex.legend">cex.legend</code></td>
<td>
<p>character expansion factor *relative* to current
'par(&quot;cex&quot;)'. Default is 0.7</p>
</td></tr>
<tr><td><code id="plot.trivPenalNL_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits</p>
</td></tr>
<tr><td><code id="plot.trivPenalNL_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot.trivPenalNL_+3A_color">color</code></td>
<td>
<p>curve color (integer)</p>
</td></tr>
<tr><td><code id="plot.trivPenalNL_+3A_median">median</code></td>
<td>
<p>Logical value. Determines whether survival median will be plotted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.trivPenalNL_+3A_xlab">Xlab</code></td>
<td>
<p>Label of x-axis. Default is '&quot;Time&quot;'</p>
</td></tr>
<tr><td><code id="plot.trivPenalNL_+3A_ylab">Ylab</code></td>
<td>
<p>Label of y-axis. Default is '&quot;Hazard function&quot;'</p>
</td></tr>
<tr><td><code id="plot.trivPenalNL_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print a plot of the baseline survival or hazard functions for each
type of event or both with the confidence bands or not (conf.bands argument)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trivPenalNL">trivPenalNL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
###--- Trivariate joint model for longitudinal data, ---###
###--- recurrent events and a terminal event ---###

data(colorectal)
data(colorectalLongi)

# Weibull baseline hazard function
# Random effects as the link function, Gap timescale
# (computation takes around 30 minutes)
model.weib.RE.gap &lt;-trivPenal(Surv(gap.time, new.lesions) ~ cluster(id)
+ age + treatment + who.PS + prev.resection + terminal(state),
formula.terminalEvent =~ age + treatment + who.PS + prev.resection, 
tumor.size ~ year * treatment + age + who.PS, data = colorectal,
data.Longi = colorectalLongi, random = c("1", "year"), id = "id", 
link = "Random-effects", left.censoring = -3.33, recurrentAG = FALSE,
hazard = "Weibull", method.GH="Pseudo-adaptive", n.nodes = 7)

plot(model.weib.RE.gap)
plot(model.weib.RE.gap, type = "survival")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotTreatPredJointSurro'>Plot of the prediction of the treatment effect on the true endpoint and the STE</h2><span id='topic+plotTreatPredJointSurro'></span>

<h3>Description</h3>

<p>Plot the prediction of the treatment effect on the true endpoint based on the observed treatment effect
on the surrogate endpoint, with the prediction interval: results from the one-step Joint surrogate model  
for evaluating a canditate surrogate endpoint. The graphic also includes vertical lines that cut 
the x axis to the values of <a href="#topic+ste">ste</a>. A hatched rectagle/zone indicates the values of 
 <code class="reqn">\beta</code><sub>S</sub> that predict a non zeto 
 <code class="reqn">\beta</code><sub>T</sub>, according to the number of value 
for <code>STE</code> and the shape of the upper confidence limit for the prediction model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTreatPredJointSurro(
  object,
  from = -3,
  to = 2,
  type = "Coef",
  var.used = "error.estim",
  alpha. = 0.05,
  n = 1000,
  lty = 2,
  d = 3,
  colCI = "blue",
  xlab = "beta.S",
  ylab = "beta.T.predict",
  pred.int.use = "up",
  main = NULL,
  add.accept.area.betaS = TRUE,
  ybottom = -0.05,
  ytop = 0.05,
  density = 20,
  angle = 45,
  legend.show = TRUE,
  leg.x = NULL,
  leg.y = 2,
  legend = c("Prediction model", "95% prediction Interval", "Beta.S for nonzero beta.T",
    "STE"),
  leg.text.col = "black",
  leg.lty = c(1, 2, 4, NA),
  leg.pch = c(NA, NA, 7, 1),
  leg.bg = "white",
  leg.bty = "n",
  leg.cex = 0.85,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTreatPredJointSurro_+3A_object">object</code></td>
<td>
<p>An object inheriting from <code>jointSurroPenal</code> class
(output from calling the function <code>jointSurroPenal</code> ).</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_from">from</code></td>
<td>
<p>The range (with <code>to</code>) over which the function will be plotted. The default is 
<code>from -2 to 2</code></p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_to">to</code></td>
<td>
<p>The range (with <code>from</code>) over which the function will be plotted. The default is 
<code>from -2 to 2</code></p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_type">type</code></td>
<td>
<p>The type of graphic, <code>"Coef"</code> for the <code>log HR</code> or <code>"HR"</code> for hazard ratio.
If set to <code>HR</code>, the arguments <code>from</code> and <code>to</code> must take positive values.
The default is <code>"Coef"</code>.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_var.used">var.used</code></td>
<td>
<p>This argument can take two values. The first one is <code>"error.estim"</code>
and indicates if the prediction error take into account
the estimation error of the estimates of the parameters. If the estimates 
are supposed to be known or if the dataset includes a high number of trials with 
a high number of subject per trial, value <code>No.error</code> can be used. 
The default is <code>error.estim</code> (highly recommended).</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_alpha.">alpha.</code></td>
<td>
<p>The confidence level for the prediction interval. The default is <code>0.05</code></p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_n">n</code></td>
<td>
<p>An integer that indicates the number of values for  <code class="reqn">\beta</code><sub>S</sub>. The default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_lty">lty</code></td>
<td>
<p>The line type. Line types can either be specified as an integer 
(0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one 
of the character strings <code>"blank", "solid", "dashed", "dotted", "dotdash"</code>, <code>"longdash",
 or "twodash"</code>, where <code>"blank"</code> uses &quot;invisible lines&quot; (i.e., does not draw them). 
The default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_d">d</code></td>
<td>
<p>The desired number of digits after the decimal point for parameters
and confidence intervals. Default of 3 digits is used.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_colci">colCI</code></td>
<td>
<p>The color used to display the confidence interval.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_pred.int.use">pred.int.use</code></td>
<td>
<p>A character string that indicates the bound of the prediction interval 
to use to compute the STE. Possible values are <code>up</code> for the upper bound (the default)
or <code>lw</code> for the lower bound. <code>up</code> when we have a protective treatment effect and <code>lw</code> 
when we have a deleterious treatment effect.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_main">main</code></td>
<td>
<p>Title of the graphics</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_add.accept.area.betas">add.accept.area.betaS</code></td>
<td>
<p>A boolean that indicates if the plot should add acceptance area for 
 <code class="reqn">\beta</code><sub>S</sub>
that predict a nonzero  <code class="reqn">\beta</code><sub>T</sub>. The default is TRUE</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_ybottom">ybottom</code></td>
<td>
<p>A scalar for the left y bottom position of the rectangle on the x-axis associated with acceptable 
value for  <code class="reqn">\beta</code><sub>S</sub> to predict a 
non zero  <code class="reqn">\beta</code><sub>T</sub>. The default is <code>-0.05</code>.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_ytop">ytop</code></td>
<td>
<p>A scalar for the top right y position of the rectangle on the x-axis associated with acceptable 
value for  <code class="reqn">\beta</code><sub>S</sub> to predict a 
non zero  <code class="reqn">\beta</code><sub>T</sub>. The default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_density">density</code></td>
<td>
<p>The density of shading lines, in lines per inch.  The default 
value of 'NULL' means that no shading lines are drawn.  A 
zero value of 'density' means no shading lines whereas
negative values (and 'NA') suppress shading (and so allow color filling). The default is <code>20</code></p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_angle">angle</code></td>
<td>
<p>Angle (in degrees) of the shading lines. The default is <code>45</code></p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_legend.show">legend.show</code></td>
<td>
<p>A boolean that indicates if the legend should be displayed</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_leg.x">leg.x</code></td>
<td>
<p>The x co-ordinate to be used to position the legend.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_leg.y">leg.y</code></td>
<td>
<p>The y co-ordinate to be used to position the legend. The default is <code>4</code></p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_legend">legend</code></td>
<td>
<p>A character or expression vector of length &gt;= 1 to appear in the legend</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_leg.text.col">leg.text.col</code></td>
<td>
<p>The color used for the legend text. The default is <code>black</code>.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_leg.lty">leg.lty</code></td>
<td>
<p>The line type, width and color for the legend box (if bty = &quot;o&quot;).</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_leg.pch">leg.pch</code></td>
<td>
<p>= The plotting symbols appearing in the legend, as numeric vector or a 
vector of 1-character strings (see <a href="graphics.html#topic+points">points</a>). Unlike <code>points</code>, this can all be 
specified as a single multi-character string. Must be specified for symbol drawing.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_leg.bg">leg.bg</code></td>
<td>
<p>The background color for the legend box. (Note that this is only used if bty <code>!= "n"</code>.)</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_leg.bty">leg.bty</code></td>
<td>
<p>The type of box to be drawn around the legend. The allowed values are <code>"o"</code> 
(the default) and <code>"n"</code>.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_leg.cex">leg.cex</code></td>
<td>
<p>Character expansion factor relative to current par(<code>"cex"</code>). Used 
for text as defined in <a href="graphics.html#topic+legend">legend</a>.</p>
</td></tr>
<tr><td><code id="plotTreatPredJointSurro_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For a considered treatment effects on the surrogate enpoint, plot the
associated treatment effects on the true endpoint predicted from the joint surrogate model
with the prediction interval.
</p>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a> and 
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>
</p>


<h3>References</h3>

<p>Burzykowski T, Buyse M (2006). &quot;Surrogate threshold effect: an alternative 
measure for meta-analytic surrogate endpoint validation.&quot; Pharmaceutical 
Statistics, 5(3), 173-186.ISSN 1539-1612.
</p>
<p>Sofeu, C. L. and Rondeau, V. (2020). How to use frailtypack for validating failure-time surrogate 
endpoints using individual patient data from meta-analyses of randomized controlled trials. 
PLOS ONE; 15, 1-25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurroPenal">jointSurroPenal</a>, <a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a>, <a href="#topic+predict.jointSurroPenal">predict.jointSurroPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


###--- Joint surrogate model ---###
###---evaluation of surrogate endpoints---###

data(dataOvarian)
joint.surro.ovar &lt;- jointSurroPenal(data = dataOvarian, n.knots = 8, 
                init.kappa = c(2000,1000), indicator.alpha = 0, 
                nb.mc = 200, scale = 1/365)

## "HR"
plotTreatPredJointSurro(joint.surro.ovar, from = 0, to = 4, 
                type = "HR", lty = 2, leg.y = 13)
                
## or without acceptance area for betaS:
plotTreatPredJointSurro(joint.surro.ovar, from = 0, to = 4, 
                type = "HR", lty = 2, leg.y = 13, 
                add.accept.area.betaS = FALSE)
             
## "log HR"
plotTreatPredJointSurro(joint.surro.ovar, from = -2, to = 2, 
                type = "Coef", lty = 2, leg.y = 3.5)
                
### For a value of ste greater than 0 (HR &gt; 1), which induces deleterious
### treatment effet, argument "pred.int.use" can be set to "lw"  

plotTreatPredJointSurro(joint.surro.ovar, from = 0, to = 2, 
                type = "HR", lty = 2, leg.y = 4,
                pred.int.use = "lw")


## End(Not run)

</code></pre>

<hr>
<h2 id='predict.jointSurroPenal'>S3method predict for the one-step Joint surrogate models for the evaluation of a 
canditate surrogate endpoint.</h2><span id='topic+predict.jointSurroPenal'></span>

<h3>Description</h3>


<p>Predict the treatment effect on the true endpoint ( <code class="reqn">\beta</code><sub>T</sub>), based on the 
treatment effect observed on the surrogate endpoint ( <code class="reqn">\beta</code><sub>S</sub>).

</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointSurroPenal'
predict(object, datapred = NULL, betaS.obs = NULL, 
betaT.obs = NULL, ntrial0 = NULL, var.used = "error.estim", alpha. = 0.05, 
dec = 3, colCI = "red", from = -2, to = 2, type = "Coef", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.jointSurroPenal_+3A_object">object</code></td>
<td>
<p>An object inheriting from <code>jointSurroPenal</code> class
(output from calling the function <code>jointSurroPenal</code> or <code>jointSurroCopPenal</code>).</p>
</td></tr>
<tr><td><code id="predict.jointSurroPenal_+3A_datapred">datapred</code></td>
<td>
<p>Dataset to use for the prediction. If this argument is specified,
the data structure must be the same as the parameter <code>data</code> in the 
function <a href="#topic+jointSurroPenal">jointSurroPenal</a> or <a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a>. However, if observation on the true endpoint are
not available, columns timeT and <code>statusT</code> can be absent. In this case, the  <code class="reqn">\beta</code><sub>S</sub>
are calculated using Cox proportional hazards models.</p>
</td></tr>
<tr><td><code id="predict.jointSurroPenal_+3A_betas.obs">betaS.obs</code></td>
<td>
<p>Observed treatment effect on the surrogate endpoint, to use for the prediction of
the treatment effect on the true endpoint. If not null, this value is used for prediction instead of
<code>datapred</code>. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.jointSurroPenal_+3A_betat.obs">betaT.obs</code></td>
<td>
<p>Observed treatment effect on the true endpoint. Used to assess the prediction if not null.
The defaut is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.jointSurroPenal_+3A_ntrial0">ntrial0</code></td>
<td>
<p>Number of subjects include in the new trial. Required if <code>betaS.obs</code> is not null.
The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.jointSurroPenal_+3A_var.used">var.used</code></td>
<td>
<p>This argument can take two values. The first one is <code>"error.estim"</code>
and indicates if the prediction error take into account
the estimation error of the estimates of the parameters. If the estimates 
are supposed to be known or if the dataset includes a high number of trials with 
a high number of subject per trial, value <code>No.error</code> can be used. 
The default is <code>error.estim</code> (highly recommended).</p>
</td></tr>
<tr><td><code id="predict.jointSurroPenal_+3A_alpha.">alpha.</code></td>
<td>
<p>The confidence level for the prediction interval. The default is <code>0.05</code></p>
</td></tr>
<tr><td><code id="predict.jointSurroPenal_+3A_dec">dec</code></td>
<td>
<p>The desired number of digits after the decimal point for parameters
and confidence intervals. Default of 3 digits is used.</p>
</td></tr>
<tr><td><code id="predict.jointSurroPenal_+3A_colci">colCI</code></td>
<td>
<p>The color used to display the confidence interval.</p>
</td></tr>
<tr><td><code id="predict.jointSurroPenal_+3A_from">from</code></td>
<td>
<p>The range (with <code>to</code>) over which the function will be plotted. The default is 
<code>from -2 to 2</code></p>
</td></tr>
<tr><td><code id="predict.jointSurroPenal_+3A_to">to</code></td>
<td>
<p>The range (with <code>from</code>) over which the function will be plotted. The default is 
<code>from -2 to 2</code></p>
</td></tr>
<tr><td><code id="predict.jointSurroPenal_+3A_type">type</code></td>
<td>
<p>The type of graphic, <code>"Coef"</code> for the <code>log HR</code> or <code>"HR"</code> for hazard ratio.
If set to <code>HR</code>, the arguments <code>from</code> and <code>to</code> must take positive values.
The default is <code>"Coef"</code>.</p>
</td></tr>
<tr><td><code id="predict.jointSurroPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments. See the function (<a href="#topic+plotTreatPredJointSurro">plotTreatPredJointSurro</a>)</p>
</td></tr>
</table>


<h3>Details</h3>


<p>Prediction is based on the formulas described in (Burzikwosky <em>et al.</em>, 2006).
We do not consider the case in which the prediction take into account estimation error on 
the estimate of the treatment effect on the surrogate endpoint in the new trial.

</p>


<h3>Value</h3>

<p>Returns and display a dataframe including for each trial the number of included subjects 
(if available), the observed 
treatment effect on surrogate endpoint, the observed treatment effect on
true endpoint (if available) and the predicted treatment effect on 
true enpoint with the associated prediction intervals. If the observe treatment effect on true 
endpoint (if available) is included into the prediction interval, the last columns contains &quot;*&quot;.
This function also produces a plot of predicted treatment effects on the true endpoint
according to the given values of the treatment effects on the surrogate endpoint, with 
the prediction intervals.
</p>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a> and 
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>
</p>


<h3>References</h3>

<p>Burzykowski T, Buyse M (2006). &quot;Surrogate threshold effect: an alternative 
measure for meta-analytic surrogate endpoint validation.&quot; Pharmaceutical 
Statistics, 5(3), 173-186.ISSN 1539-1612.
</p>
<p>Sofeu, C. L. and Rondeau, V. (2020). How to use frailtypack for validating failure-time surrogate 
endpoints using individual patient data from meta-analyses of randomized controlled trials. 
PLOS ONE; 15, 1-25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurroPenal">jointSurroPenal</a>, <a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 


###--- Joint surrogate model ---###
###---evaluation of surrogate endpoints---###

data(dataOvarian)
joint.surro.ovar &lt;- jointSurroPenal(data = dataOvarian, n.knots = 8, 
                init.kappa = c(2000,1000), indicator.alpha = 0, 
                nb.mc = 200, scale = 1/365)

# prediction of the treatment effects on the true endpoint in each trial of 
# the dataOvarian dataset
predict(joint.surro.ovar)

# prediction of the treatment effect on the true endpoint from an observed 
# treatment effect on the surrogate endpoint in a given trial

# in log HR
predict(joint.surro.ovar, betaS.obs = -0.797, betaT.obs = -1.018)
predict(joint.surro.ovar, type = "Coef", betaS.obs = -1, leg.y = 0, leg.x = 0.3, to = 2.3)
predict(joint.surro.ovar, type = "Coef", leg.y = 3.5, add.accept.area.betaS = F, to = 2.3)

# in HR
predict(joint.surro.ovar, betaS.obs = exp(-0.797), betaT.obs = exp(-1.018))
predict(joint.surro.ovar, type = "HR", betaS.obs = log(0.65), leg.y = 5, to = 2.3)
predict(joint.surro.ovar, type = "HR", leg.y = 5, add.accept.area.betaS = F, to = 2.3)

## End(Not run)


</code></pre>

<hr>
<h2 id='prediction'>Prediction probabilities for Cox proportional hazard, Shared, Joint frailty
models, Joint models for longitudinal data and a terminal event and
Trivariate joint model for longitudinal data, recurrent events and a
terminal event (linear and non-linear).</h2><span id='topic+prediction'></span>

<h3>Description</h3>

 
<p><b>For Cox proportional hazard model</b>
</p>
<p>A predictive probability of event between t and horizon time t+w, with w the
window of prediction. 
</p>
<p><img src="../help/figures/prediction1.png" width="100%" alt="prediction1.png" />
</p>
<p><b>For Gamma Shared Frailty model for clustered (not recurrent) events</b>
</p>
<p>Two kinds of predictive probabilities can be calculated:
</p>
<p>- a conditional predictive probability of event between t and horizon time
t+w, i.e. given a specific group
</p>
<p><img src="../help/figures/prediction2.png" width="100%" alt="prediction2.png" />
</p>
<p>- a marginal predictive probability of event between t and horizon time t+w,
i.e. averaged over the population
</p>
<p><img src="../help/figures/prediction3.png" width="100%" alt="prediction3.png" />
</p>
<p><b>For Gaussian Shared Frailty model for clustered (not recurrent)
events</b>
</p>
<p>Two kinds of predictive probabilities can be calculated:
</p>
<p>- a conditional predictive probability of event between t and horizon time
t+w, i.e. given a specific group and given a specific Gaussian random effect
<code class="reqn">\eta</code>
</p>
<p><img src="../help/figures/prediction4.png" width="100%" alt="prediction4.png" />
</p>
<p>- a marginal predictive probability of event between t and horizon time t+w,
i.e. averaged over the population
</p>
<p><img src="../help/figures/prediction5.png" width="100%" alt="prediction5.png" />
</p>
<p><b>For Gamma Shared Frailty model for recurrent events</b>
</p>
<p>Two kinds of predictive probabilities can be calculated:
</p>
<p>- A marginal predictive probability of event between t and horizon time t+w,
i.e. averaged over the population.
</p>
<p><img src="../help/figures/prediction6.png" width="100%" alt="prediction6.png" />
</p>
<p>- a conditional predictive probability of event between t and horizon time
t+w, i.e. given a specific individual.
</p>
<p>This prediction method is the same as the conditional gamma prediction
method applied for clustered events (see formula <code class="reqn">P</code><sup>cond</sup> before).
</p>
<p><b>For Gaussian Shared Frailty model for recurrent events</b>
</p>
<p>Two kinds of predictive probabilities can be calculated:
</p>
<p>- A marginal predictive probability of event between t and horizon time t+w,
i.e. averaged over the population.
</p>
<p><img src="../help/figures/prediction7.png" width="100%" alt="prediction7.png" />
</p>
<p>- a conditional predictive probability of event between t and horizon time
t+w, i.e. given a specific individual.
</p>
<p>This prediction method is the same as the conditional Gaussian prediction
method applied for clustered events (see formula <code class="reqn">P</code><sup>cond</sup> before).
</p>
<p>It is possible to compute all these predictions in two ways on a scale of
times : - either you want a cumulative probability of developing the event
between t and t+w (with t fixed, but with a varying window of prediction w);
- either you want at a specific time the probability to develop the event in
the next w (ie, for a varying prediction time t, but for a fixed window of
prediction). See Details.
</p>
<p><b>For Joint Frailty model</b>
</p>
<p>Prediction for two types of event can be calculated : for a terminal event
or for a new recurrent event, knowing patient's characteristics.
</p>
<p><b> - Prediction of death knowing patients' characteristics : </b>
</p>
<p>It is to predict the probability of death in a specific time window given
the history of patient i before the time of prediction t. The history
H<sub>i</sub><sup>J,l</sup>, (l=1,2) is the information on covariates before time
t, but also the number of recurrences and the time of occurences. Three
types of marginal probabilities are computed:
</p>
<p>- a prediction of death between t and t+w given that the patient had exactly
J recurrences (H<sub>i</sub><sup>J,1</sup>) before t
</p>
<p><img src="../help/figures/prediction8.png" width="100%" alt="prediction8.png" />
</p>
<p>- a prediction of death between t and t+w given that the patient had at
least J recurrences (H<sub>i</sub><sup>J,2</sup>) before t
</p>
<p><img src="../help/figures/prediction9.png" width="100%" alt="prediction9.png" />
</p>
<p>- a prediction of death between t and t+w considering the recurrence history
only in the parameters estimation. It corresponds to the average probability
of death between t and t+w for a patient with these given characteristics.
</p>
<p><img src="../help/figures/prediction10.png" width="100%" alt="prediction10.png" />
</p>
<p><b> - Prediction of risk of a new recurrent event knowing patients'
characteristics : </b>
</p>
<p>It is to predict the probability of a new recurrent event in a specific time
window given the history of patient i before the time of prediction t. The
history H<sub>i</sub><sup>J</sup> is the information on covariates before time t, but also
the number of recurrences and the time of occurences. The marginal
probability computed is a prediction of a new recurrent event between t and
t+w given that the patient had exactly J recurrences (<code class="reqn">H</code><sub>i</sub><sup>J</sup>) before t:
</p>
<p><img src="../help/figures/prediction11.1.png" width="100%" alt="prediction11.1.png" />
<img src="../help/figures/prediction11.2.png" width="100%" alt="prediction11.2.png" />
</p>
<p>It is possible to compute all these predictions in two ways : - either you
want a cumulative probability of developing the event between t and t+w
(with t fixed, but with a varying window of prediction w); - either you want
at a specific time the probability to develop the event in the next w (ie,
for a varying prediction time t, but for a fixed window of prediction). See
Details.
</p>
<p>With Gaussian frailties (<code class="reqn">\eta</code>), the same expressions are used but with
u<sub>i</sub><sup>J</sup> replaced by <code class="reqn">exp</code>(J<code class="reqn">\eta</code><sub>i</sub>) and <code class="reqn">g(\eta)</code>
corresponds to the Gaussian distribution.
</p>
<p><b>For Joint Nested Frailty models</b>
</p>
<p>Prediction of the probability of developing a terminal event between t and
t+w for subject i who survived by time t based on the visiting and disease
histories of their own and other family members observed by time t.
</p>
<p>Let (Y<sub>fi</sub><sup>R</sup>(t)) be the history of subject i in family f,
before time t, which includes all the recurrent events and covariate
information. For disease history, let T<sub>fi</sub><sup>D</sup>(t) = min(T<sub>fi</sub>,t) be
the observed time to an event before t ; <code class="reqn">\delta</code><sub>fi</sub><sup>D</sup>(t) the disease
indicator by time t and X<sub>fi</sub><sup>D</sup>(t) the covariate information
observed up to time t. We define the family history of subject i in
family f by <img src="../help/figures/prediction12.png" width="100%" alt="prediction12.png" />
</p>
<p>which includes the visiting and disease history of all subjects except for
subject i in family f as well as their covariate information by
time t.
</p>
<p>The prediction probability can be written as :
</p>
<p><img src="../help/figures/prediction13.1.png" width="100%" alt="prediction13.1.png" />
<img src="../help/figures/prediction13.2.png" width="100%" alt="prediction13.2.png" />
</p>
<p><b>For Joint models for longitudinal data and a terminal event</b>
</p>
<p>The predicted probabilities are calculated in a specific time window given
the history of biomarker measurements before the time of prediction t
(&#x1B4;<sub>i</sub>(t)). The probabilities are conditional also on
covariates before time t and that the subject was at risk at t.  The
marginal predicted probability of the terminal event is
</p>
<p><img src="../help/figures/prediction14.png" width="100%" alt="prediction14.png" />
</p>
<p>These probabilities can be calculated in several time points with fixed time
of prediction t and varying window w or with fixed window w and varying time
of prediction t. See Details for an example of how to construct time
windows.
</p>
<p><b>For Trivariate joint models for longitudinal data, recurrent events
and a terminal event</b>
</p>
<p>The predicted probabilities are calculated in a specific time window given
the history of biomarker measurements &#x1B4;<sub>i</sub>(t) and recurrences
H<sub>i</sub><sup>J,1</sup> (complete history of recurrences with known J number
of observed events) before the time of prediction t. The probabilities are
conditional also on covariates before time t and that the subject was at
risk at t.  The marginal predicted probability of the terminal event is
</p>
<p><img src="../help/figures/prediction15.png" width="100%" alt="prediction15.png" />
</p>
<p>The biomarker history can be represented using a linear (<code>trivPenal</code>)
or non-linear mixed-effects model (<code>trivPenalNL</code>).
</p>
<p>These probabilities can be calculated in several time points with fixed time
of prediction t and varying window w or with fixed window w and varying time
of prediction t. See Details for an example of how to construct time
windows.
</p>




<h3>Usage</h3>

<pre><code class='language-R'>prediction(fit, data, data.Longi, t, window, event="Both", conditional =
FALSE, MC.sample=0, individual)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prediction_+3A_fit">fit</code></td>
<td>
<p>A frailtyPenal, jointPenal, longiPenal, trivPenal or trivPenalNL
object.</p>
</td></tr>
<tr><td><code id="prediction_+3A_data">data</code></td>
<td>
<p>Data frame for the prediction. See Details.</p>
</td></tr>
<tr><td><code id="prediction_+3A_data.longi">data.Longi</code></td>
<td>
<p>Data frame for the prediction used for joint models with
longitudinal data. See Details.</p>
</td></tr>
<tr><td><code id="prediction_+3A_t">t</code></td>
<td>
<p>Time or vector of times for prediction.</p>
</td></tr>
<tr><td><code id="prediction_+3A_window">window</code></td>
<td>
<p>Window or vector of windows for prediction.</p>
</td></tr>
<tr><td><code id="prediction_+3A_event">event</code></td>
<td>
<p>Only for joint and shared models. The type of event you want to
predict : &quot;Terminal&quot; for a terminal event, &quot;Recurrent&quot; for a recurrent event
or &quot;Both&quot;. Default value is &quot;Both&quot;. For joint nested model, only 'Terminal'
is allowed.  In a shared model, if you want to predict a new recurrent event
then the argument &quot;Recurrent&quot; should be use. If you want to predict a new
event from clustered data, do not use this option.</p>
</td></tr>
<tr><td><code id="prediction_+3A_conditional">conditional</code></td>
<td>
<p>Only for prediction method applied on shared models.
Provides distinction between the conditional and marginal prediction
methods. Default is FALSE.</p>
</td></tr>
<tr><td><code id="prediction_+3A_mc.sample">MC.sample</code></td>
<td>
<p>Number of samples used to calculate confidence bands with a
Monte-Carlo method (with a maximum of 1000 samples). If MC.sample=0 (default
value), no confidence intervals are calculated.</p>
</td></tr>
<tr><td><code id="prediction_+3A_individual">individual</code></td>
<td>
<p>Only for joint nested model. Vector of individuals (of the
same family) you want to make prediction.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>To compute predictions with a prediction time t fixed and a variable window:
</p>
<pre>prediction(fit, datapred, t=10, window=seq(1,10,by=1))</pre>
<p>Otherwise, you can have a variable prediction time and a fixed window.
</p>
<pre>prediction(fit, datapred, t=seq(10,20,by=1), window=5)</pre><p> Or fix
both prediction time t and window. </p>
<pre>prediction(fit, datapred,
t=10, window=5)</pre>
<p>The data frame building is an important step. It will contain profiles of
patient on which you want to do predictions. To make predictions on a Cox
proportional hazard or a shared frailty model, only covariates need to be
included. You have to distinguish between numerical and categorical
variables (factors). If we fit a shared frailty model with two covariates
sex (factor) and age (numeric), here is the associated data frame for three
profiles of prediction.
</p>
<pre> datapred &lt;- data.frame(sex=0,age=0) datapred$sex &lt;-
as.factor(datapred$sex) levels(datapred$sex)&lt;- c(1,2) datapred[1,] &lt;-
c(1,40) # man, 40 years old datapred[2,] &lt;- c(2,45) # woman, 45 years old
datapred[3,] &lt;- c(1,60) # man, 60 years old </pre>
<p><b>Time-dependent covariates:</b> In the context of time-dependent
covariate, the last previous value of the covariate is used before the time
t of prediction.
</p>
<p>It should be noted, that in a data frame for both marginal and conditional
prediction on a shared frailty model for clustered data, the group must be
specified. In the case of marginal predictions this can be any number as it
does not influence predictions. However, for conditional predictions, the
group must be also included in the data set used for the model fitting. The
conditional predictions apply the empirical Bayes estimate of the frailty
from the specified cluster.  Here, three individuals belong to group 5.
</p>
<pre> datapred &lt;- data.frame(group=0, sex=0,age=0) datapred$sex &lt;-
as.factor(datapred$sex) levels(datapred$sex)&lt;- c(1,2) datapred[1,] &lt;-
c(5,1,40) # man, 40 years old (cluster 5) datapred[2,] &lt;- c(5,2,45) # woman,
45 years old (cluster 5) datapred[3,] &lt;- c(5,1,60) # man, 60 years old
(cluster 5) </pre>
<p>To use the prediction function on joint frailty models and trivariate joint
models, the construction will be a little bit different. In these cases, the
prediction for the terminal event takes into account covariates but also
history of recurrent event times for a patient. You have to create a data
frame with the relapse times, the indicator of event, the cluster variable
and the covariates. Relapses occurring after the prediction time may be
included but will be ignored for the prediction. A joint model with
calendar-timescale need to be fitted with Surv(start,stop,event), relapse
times correspond to the &quot;stop&quot; variable and indicators of event correspond
to the &quot;event&quot; variable (if event=0, the relapse will not be taken into
account). For patients without relapses, all the values of &quot;event&quot; variable
should be set to 0. Finally, the same cluster variable name needs to be in
the joint model and in the data frame for predictions (&quot;id&quot; in the following
example). For instance, we observe relapses of a disease and fit a joint
model adjusted for two covariates sex (1:male 2:female) and chemo (treatment
by chemotherapy 1:no 2:yes). We describe 3 different profiles of prediction
all treated by chemotherapy: 1) a man with four relapses at 100, 200, 300
and 400 days, 2) a man with only one relapse at 1000 days, 3) a woman
without relapse.
</p>
<pre> datapred &lt;- data.frame(time=0,event=0,id=0,sex=0,chemo=0)
datapred$sex &lt;- as.factor(datapred$sex) levels(datapred$sex) &lt;- c(1,2)
datapred$chemo &lt;- as.factor(datapred$chemo) levels(datapred$chemo) &lt;- c(1,2)
datapred[1,] &lt;- c(100,1,1,1,2) # first relapse of the patient 1 datapred[2,]
&lt;- c(200,1,1,1,2) # second relapse of the patient 1 datapred[3,] &lt;-
c(300,1,1,1,2) # third relapse of the patient 1 datapred[4,] &lt;-
c(400,1,1,1,2) # fourth relapse of the patient 1 datapred[5,] &lt;-
c(1000,1,2,1,2) # one relapse at 1000 days for patient 2 datapred[6,] &lt;-
c(100,0,3,2,2) # patient 3 did not relapse </pre>
<p>The data can also be the dataset used to fit the joint model. In this case,
you will obtain as many prediction rows as patients.
</p>
<p>Finally, for the predictions using joint models for longitudinal data and a
terminal event and trivariate joint models, a data frame with the history of
the biomarker measurements must be provided. It must include data on
measurements (values and time points), cluster variable and covariates.
Measurements taken after the prediction time may be included but will be
ignored for the prediction. The same cluster variable name must be in the
data frame, in the data frame used for the joint model and in the data frame
with the recurrent event and terminal event times. For instance, we observe
two patients and each one had 5 tumor size measurements (patient 1 had an
increasing tumor size and patient 2, decreasing). The joint model used for
the predictions was adjusted on sex (1: male, 2: female), treatment (1:
sequential arm, 2: combined arm), WHO baseline performance status (1: 0
status, 2: 1 status, 3: 2 status) and previous resection of the primate
tumor (0: no, 1: yes). The data frame for the biomarker measurements can be:
</p>
<pre> datapredj_longi &lt;- data.frame(id = 0, year = 0, tumor.size =
0, treatment = 0, age = 0, who.PS = 0, prev.resection = 0)
datapredj_longi$treatment &lt;- as.factor(datapredj_longi$treatment)
levels(datapredj_longi$treatment) &lt;- 1:2 datapredj_longi$age &lt;-
as.factor(datapredj_longi$age) levels(datapredj_longi$age) &lt;- 1:3
datapredj_longi$who.PS &lt;- as.factor(datapredj_longi$who.PS)
levels(datapredj_longi$who.PS) &lt;- 1:3 datapredj_longi$prev.resection &lt;-
as.factor (datapredj_longi$prev.resection)
levels(datapredj_longi$prev.resection) &lt;- 1:2 # patient 1: increasing tumor
size datapredj_longi[1,] &lt;- c(1, 0,1.2 ,2,1,1,1) datapredj_longi[2,] &lt;-
c(1,0.3,1.4,2,1,1,1) datapredj_longi[3,] &lt;- c(1,0.6,1.9,2,1,1,1)
datapredj_longi[4,] &lt;- c(1,0.9,2.5,2,1,1,1) datapredj_longi[5,] &lt;-
c(1,1.5,3.9,2,1,1,1)

# patient 2: decreasing tumor size datapredj_longi[6,] &lt;- c(2, 0,1.2
,2,1,1,1) datapredj_longi[7,] &lt;- c(2,0.3,0.7,2,1,1,1) datapredj_longi[8,] &lt;-
c(2,0.5,0.3,2,1,1,1) datapredj_longi[9,] &lt;- c(2,0.7,0.1,2,1,1,1)
datapredj_longi[10,] &lt;- c(2,0.9,0.1,2,1,1,1) </pre>



<h3>Value</h3>

<p>The following components are included in a 'predFrailty' object obtained by
using prediction function for Cox proportional hazard and shared frailty
model.
</p>
<table role = "presentation">
<tr><td><code>npred</code></td>
<td>
<p>Number of individual predictions</p>
</td></tr> <tr><td><code>x.time</code></td>
<td>
<p>A vector of
prediction times of interest (used for plotting predictions): vector of
prediction times t if fixed window. Otherwise vector of prediction times
t+w</p>
</td></tr> <tr><td><code>window</code></td>
<td>
<p>Prediction window or vector of prediction windows</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>Predictions estimated for each profile</p>
</td></tr> <tr><td><code>icproba</code></td>
<td>
<p>Logical
value. Were confidence intervals estimated ?</p>
</td></tr> <tr><td><code>predLow</code></td>
<td>
<p>Lower limit of
Monte-Carlo confidence interval for each prediction</p>
</td></tr> <tr><td><code>predHigh</code></td>
<td>
<p>Upper
limit of Monte-Carlo confidence interval for each prediction</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of prediction probability (marginal or conditional)</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>For conditional probability, the list of group on which you
make predictions</p>
</td></tr>
</table>
<p>The following components are included in a 'predJoint' object obtained by
using prediction function for joint frailty model.
</p>
<table role = "presentation">
<tr><td><code>npred</code></td>
<td>
<p>Number of individual predictions</p>
</td></tr> <tr><td><code>x.time</code></td>
<td>
<p>A vector of
prediction times of interest (used for plotting predictions): vector of
prediction times t if fixed window. Otherwise vector of prediction times
t+w</p>
</td></tr> <tr><td><code>window</code></td>
<td>
<p>Prediction window or vector of prediction windows</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>Id of each patient</p>
</td></tr> <tr><td><code>pred1</code></td>
<td>
<p>Estimation of probability of
type 1: exactly j recurrences</p>
</td></tr> <tr><td><code>pred2</code></td>
<td>
<p>Estimation of probability of
type 2: at least j recurrences</p>
</td></tr> <tr><td><code>pred3</code></td>
<td>
<p>Estimation of probability of
type 3</p>
</td></tr> <tr><td><code>pred1_rec</code></td>
<td>
<p>Estimation of prediction of relapse</p>
</td></tr>
<tr><td><code>icproba</code></td>
<td>
<p>Logical value. Were confidence intervals estimated ?</p>
</td></tr>
<tr><td><code>predlow1</code></td>
<td>
<p>Lower limit of Monte-Carlo confidence interval for
probability of type 1</p>
</td></tr> <tr><td><code>predhigh1</code></td>
<td>
<p>Upper limit of Monte-Carlo
confidence interval for probability of type 1</p>
</td></tr> <tr><td><code>predlow2</code></td>
<td>
<p>Lower limit
of Monte-Carlo confidence interval for probability of type 2</p>
</td></tr>
<tr><td><code>predhigh2</code></td>
<td>
<p>Upper limit of Monte-Carlo confidence interval for
probability of type 2</p>
</td></tr> <tr><td><code>predlow3</code></td>
<td>
<p>Lower limit of Monte-Carlo confidence
interval for probability of type 3</p>
</td></tr> <tr><td><code>predhigh3</code></td>
<td>
<p>Upper limit of
Monte-Carlo confidence interval for probability of type 3</p>
</td></tr>
<tr><td><code>predhigh1_rec</code></td>
<td>
<p>Upper limit of Monte-Carlo confidence interval for
prediction of relapse</p>
</td></tr> <tr><td><code>predlow1_rec</code></td>
<td>
<p>Lower limit of Monte-Carlo
confidence interval for prediction of relapse</p>
</td></tr>
</table>
<p>The following components are included in a 'predLongi' object obtained by
using prediction function for joint models with longitudinal data.
</p>
<table role = "presentation">
<tr><td><code>npred</code></td>
<td>
<p>Number of individual predictions</p>
</td></tr> <tr><td><code>x.time</code></td>
<td>
<p>A vector of
prediction times of interest (used for plotting predictions): vector of
prediction times t if fixed window. Otherwise vector of prediction times
t+w</p>
</td></tr> <tr><td><code>window</code></td>
<td>
<p>Prediction window or vector of prediction windows</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>Id of each patient</p>
</td></tr> <tr><td><code>pred</code></td>
<td>
<p>Estimation of probability</p>
</td></tr>
<tr><td><code>icproba</code></td>
<td>
<p>Logical value. Were confidence intervals estimated?</p>
</td></tr>
<tr><td><code>predLow</code></td>
<td>
<p>Lower limit of Monte-Carlo confidence intervals</p>
</td></tr>
<tr><td><code>predHigh</code></td>
<td>
<p>Upper limit of Monte-Carlo confidence intervals</p>
</td></tr>
<tr><td><code>trivariate</code></td>
<td>
<p>Logical value. Are the prediction calculated from the
trivariate model?</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Krol, L. Ferrer, JP. Pignon, C. Proust-Lima, M. Ducreux, O.
Bouche, S. Michiels, V. Rondeau (2016). Joint Model for Left-Censored
Longitudinal Data, Recurrent Events and Terminal Event: Predictive Abilities
of Tumor Burden for Cancer Evolution with Application to the FFCD 2000-05
Trial. <em>Biometrics</em> <b>72</b>(3) 907-16.
</p>
<p>A. Mauguen, B. Rachet, S. Mathoulin-Pelissier, G. MacGrogan, A. Laurent, V.
Rondeau (2013). Dynamic prediction of risk of death using history of cancer
recurrences in joint frailty models. <em>Statistics in Medicine</em>,
<b>32(30)</b>, 5366-80.
</p>
<p>V. Rondeau, A. Laurent, A. Mauguen, P. Joly, C. Helmer (2015). Dynamic
prediction models for clustered and interval-censored outcomes:
investigating the intra-couple correlation in the risk of dementia.
<em>Statistical Methods in Medical Research</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

#####################################################
#### prediction on a COX or SHARED frailty model ####
#####################################################

data(readmission)
#-- here is a generated cluster (31 clusters of 13 subjects)
readmission &lt;- transform(readmission,group=id%%31+1)

#-- we compute predictions of death
#-- we extract last row of each subject for the time of death
readmission &lt;- aggregate(readmission,by=list(readmission$id),
                         FUN=function(x){x[length(x)]})[,-1]

##-- predictions on a Cox proportional hazard model --##
cox &lt;- frailtyPenal(Surv(t.stop,death)~sex+dukes,
n.knots=10,kappa=10000,data=readmission)

#-- construction of the data frame for predictions
datapred &lt;- data.frame(sex=0,dukes=0)
datapred$sex &lt;- as.factor(datapred$sex)
levels(datapred$sex)&lt;- c(1,2)
datapred$dukes &lt;- as.factor(datapred$dukes)
levels(datapred$dukes)&lt;- c(1,2,3)
datapred[1,] &lt;- c(1,2) # man, dukes 2
datapred[2,] &lt;- c(2,3) # woman, dukes 3

#-- prediction of death for two patients between 100 and 100+w,
#-- with w in (50,100,...,1900)
pred.cox &lt;- prediction(cox,datapred,t=100,window=seq(50,1900,50))
plot(pred.cox)

#-- prediction of death for two patients between t and t+400,
#-- with t in (100,150,...,1500)
pred.cox2 &lt;- prediction(cox,datapred,t=seq(100,1500,50),window=400)
plot(pred.cox2)

##-- predictions on a shared frailty model for clustered data --##
sha &lt;- frailtyPenal(Surv(t.stop,death)~cluster(group)+sex+dukes,
n.knots=10,kappa=10000,data=readmission)

#-- marginal prediction
# a group must be specified but it does not influence the results 
# in the marginal predictions setting
datapred$group[1:2] &lt;- 1
pred.sha.marg &lt;- prediction(sha,datapred,t=100,window=seq(50,1900,50))
plot(pred.sha.marg)

#-- conditional prediction, given a specific cluster (group=5)
datapred$group[1:2] &lt;- 5
pred.sha.cond &lt;- prediction(sha,datapred,t=100,window=seq(50,1900,50),
                            conditional = TRUE)
plot(pred.sha.cond)

##-- marginal prediction of a recurrent event, on a shared frailty model
data(readmission)

datapred &lt;- data.frame(t.stop=0,event=0,id=0,sex=0,dukes=0)
datapred$sex &lt;- as.factor(datapred$sex)
levels(datapred$sex)&lt;- c(1,2)
datapred$dukes &lt;- as.factor(datapred$dukes)
levels(datapred$dukes)&lt;- c(1,2,3)

datapred[1,] &lt;- c(100,1,1,1,2) #man, dukes 2, 3 recurrent events
datapred[2,] &lt;- c(200,1,1,1,2) 
datapred[3,] &lt;- c(300,1,1,1,2) 
datapred[4,] &lt;- c(350,0,2,1,2) #man, dukes 2  0 recurrent event

#-- Shared frailty model with gamma distribution
sha &lt;- frailtyPenal(Surv(t.stop,event)~cluster(id)+sex+dukes,n.knots=10,
kappa=10000,data=readmission)
pred.sha.rec.marg &lt;- prediction(sha,datapred,t=200,window=seq(50,1900,50),
event='Recurrent',MC.sample=100)

plot(pred.sha.rec.marg,conf.bands=TRUE)

##-- conditional prediction of a recurrent event, on a shared frailty model
pred.sha.rec.cond &lt;- prediction(sha,datapred,t=200,window=seq(50,1900,50),
event='Recurrent',conditional = TRUE,MC.sample=100)

plot(pred.sha.rec.cond,conf.bands=TRUE)
#####################################################
######## prediction on a JOINT frailty model ########
#####################################################

data(readmission)

##-- predictions of death on a joint model --##
joi &lt;- frailtyPenal(Surv(t.start,t.stop,event)~cluster(id)
+sex+dukes+terminal(death),formula.terminalEvent=~sex
+dukes,data=readmission,n.knots=10,kappa=c(100,100),recurrentAG=TRUE)

#-- construction of the data frame for predictions
datapredj &lt;- data.frame(t.stop=0,event=0,id=0,sex=0,dukes=0)
datapredj$sex &lt;- as.factor(datapredj$sex)
levels(datapredj$sex) &lt;- c(1,2)
datapredj$dukes &lt;- as.factor(datapredj$dukes)
levels(datapredj$dukes) &lt;- c(1,2,3)
datapredj[1,] &lt;- c(100,1,1,1,2)
datapredj[2,] &lt;- c(200,1,1,1,2)
datapredj[3,] &lt;- c(300,1,1,1,2)
datapredj[4,] &lt;- c(400,1,1,1,2)
datapredj[5,] &lt;- c(380,1,2,1,2)

#-- prediction of death between 100 and 100+500 given relapses
pred.joint0 &lt;- prediction(joi,datapredj,t=100,window=500,event = "Terminal")
print(pred.joint0)

#-- prediction of death between 100 and 100+w given relapses 
# (with confidence intervals)
pred.joint &lt;- prediction(joi,datapredj,t=100,window=seq(50,1500,50),
event = "Terminal",MC.sample=100)
plot(pred.joint,conf.bands=TRUE)
# each y-value of the plot corresponds to the prediction between [100,x]

#-- prediction of death between t and t+500 given relapses
pred.joint2 &lt;- prediction(joi,datapredj,t=seq(100,1000,50),
window=500,event = "Terminal")
plot(pred.joint2)
# each y-value of the plot corresponds to the prediction between [x,x+500], 
#or in the next 500

#-- prediction of relapse between 100 and 100+w given relapses 
# (with confidence intervals)
pred.joint &lt;- prediction(joi,datapredj,t=100,window=seq(50,1500,50),
event = "Recurrent",MC.sample=100)
plot(pred.joint,conf.bands=TRUE)
# each y-value of the plot corresponds to the prediction between [100,x]

#-- prediction of relapse and death between 100 and 100+w given relapses 
# (with confidence intervals)
pred.joint &lt;- prediction(joi,datapredj,t=100,window=seq(50,1500,50),
event = "Both",MC.sample=100)
plot(pred.joint,conf.bands=TRUE)
# each y-value of the plot corresponds to the prediction between [100,x]

#############################################################################
### prediction on a JOINT model for longitudinal data and a terminal event ####
#############################################################################


data(colorectal)
data(colorectalLongi)

# Survival data preparation - only terminal events 
colorectalSurv &lt;- subset(colorectal, new.lesions == 0)

#-- construction of the data-frame for predictions
#-- biomarker observations
datapredj_longi &lt;- data.frame(id = 0, year = 0, tumor.size = 0, treatment = 0,
 age = 0, who.PS = 0, prev.resection = 0)
datapredj_longi$treatment &lt;- as.factor(datapredj_longi$treatment)
levels(datapredj_longi$treatment) &lt;- 1:2
datapredj_longi$age &lt;- as.factor(datapredj_longi$age)
levels(datapredj_longi$age) &lt;- 1:3
datapredj_longi$who.PS &lt;- as.factor(datapredj_longi$who.PS)
levels(datapredj_longi$who.PS) &lt;- 1:3
datapredj_longi$prev.resection &lt;- as.factor(datapredj_longi$prev.resection)
levels(datapredj_longi$prev.resection) &lt;- 1:2

# patient 1: increasing tumor size
datapredj_longi[1,] &lt;- c(1, 0,1.2 ,2,1,1,1)
datapredj_longi[2,] &lt;- c(1,0.3,1.4,2,1,1,1)
datapredj_longi[3,] &lt;- c(1,0.6,1.9,2,1,1,1)
datapredj_longi[4,] &lt;- c(1,0.9,2.5,2,1,1,1)
datapredj_longi[5,] &lt;- c(1,1.5,3.9,2,1,1,1)

# patient 2: decreasing tumor size
datapredj_longi[6,] &lt;- c(2, 0,1.2 ,2,1,1,1)
datapredj_longi[7,] &lt;- c(2,0.3,0.7,2,1,1,1)
datapredj_longi[8,] &lt;- c(2,0.5,0.3,2,1,1,1)
datapredj_longi[9,] &lt;- c(2,0.7,0.1,2,1,1,1)
datapredj_longi[10,] &lt;- c(2,0.9,0.1,2,1,1,1)

#-- terminal event
datapredj &lt;- data.frame(id = 0, treatment = 0, age = 0, who.PS = 0,
prev.resection = 0)
datapredj$treatment &lt;- as.factor(datapredj$treatment)
levels(datapredj$treatment) &lt;- 1:2
datapredj$age &lt;- as.factor(datapredj$age)
levels(datapredj$age) &lt;- 1:3
datapredj$who.PS &lt;- as.factor(datapredj$who.PS)
datapredj$prev.resection &lt;- as.factor(datapredj$prev.resection)
levels(datapredj$prev.resection) &lt;- 1:2
levels(datapredj$who.PS) &lt;- 1:3
datapredj[1,] &lt;- c(1,2,1,1,1)
datapredj[2,] &lt;- c(2,2,1,1,1)

model.spli.CL &lt;- longiPenal(Surv(time1, state) ~ age + treatment + who.PS
+ prev.resection, tumor.size ~  year * treatment + age + who.PS , 
colorectalSurv, data.Longi = colorectalLongi, random = c("1", "year"),
id = "id", link = "Current-level", left.censoring = -3.33, n.knots = 6, 
kappa = 1)

#-- prediction of death between 1 year and 1+2 given history of the biomarker
pred.jointLongi0 &lt;- prediction(model.spli.CL, datapredj, datapredj_longi,
t = 1, window = 2)
print(pred.jointLongi0)

#-- prediction of death between 1 year and 1+w given history of the biomarker
pred.jointLongi &lt;- prediction(model.spli.CL, datapredj, datapredj_longi,
t = 1, window = seq(0.5, 2.5, 0.2), MC.sample = 100)
plot(pred.jointLongi, conf.bands = TRUE)
# each y-value of the plot corresponds to the prediction between [1,x]

#-- prediction of death between t and t+0.5 given history of the biomarker
pred.jointLongi2 &lt;- prediction(model.spli.CL, datapredj, datapredj_longi,
t = seq(1, 2.5, 0.5), window = 0.5, MC.sample = 100)
plot(pred.jointLongi2, conf.bands = TRUE)
# each y-value of the plot corresponds to the prediction between [x,x+0.5], 
#or in the next 0.5

#############################################################################
##### marginal prediction on a JOINT NESTED model for a terminal event ######
#############################################################################
#*--Warning! You can compute this prediction method with ONLY ONE family 
#*--by dataset of prediction. 
#*--Please make sure your data frame contains a column for individuals AND a 
#*--column for the reference number of the family chosen.

data(readmission)
readmissionNested &lt;- transform(readmission,group=id%%30+1)

#-- construction of the data frame for predictions : 
#-- family 5 was selected for the prediction

DataPred &lt;- readmissionNested[which(readmissionNested$group==5),]

#-- Fitting the model
modJointNested_Splines &lt;- 
frailtyPenal(formula = Surv(t.start, t.stop, event)~subcluster(id)+ 
cluster(group) + dukes + terminal(death),formula.terminalEvent
=~dukes, data = readmissionNested, recurrentAG = TRUE,n.knots = 8, 
kappa = c(9.55e+9, 1.41e+12), initialize = TRUE)

#-- Compute prediction over the individuals 274 and 4 of the family 5
predRead &lt;- prediction(modJointNested_Splines, data=DataPred,t=500,
window=seq(100,1500,200), conditional=FALSE, individual = c(274, 4))


#########################################################################
##### prediction on TRIVARIATE JOINT model (linear and non-linear) ######
#########################################################################

data(colorectal)
data(colorectalLongi)

#-- construction of the data frame for predictions
#-- history of recurrences and terminal event
datapredj &lt;- data.frame(time0 = 0, time1 = 0, new.lesions = 0, id = 0, 
treatment = 0, age = 0, who.PS = 0, prev.resection =0)
datapredj$treatment &lt;- as.factor(datapredj$treatment)
levels(datapredj$treatment) &lt;- 1:2
datapredj$age &lt;- as.factor(datapredj$age)
levels(datapredj$age) &lt;- 1:3
datapredj$who.PS &lt;- as.factor(datapredj$who.PS)
levels(datapredj$who.PS) &lt;- 1:3
datapredj$prev.resection &lt;- as.factor(datapredj$prev.resection)
levels(datapredj$prev.resection) &lt;- 1:2

datapredj[1,] &lt;- c(0,0.4,1,1,2,1,1,1)
datapredj[2,] &lt;- c(0.4,1.2,1,1,2,1,1,1)
datapredj[3,] &lt;- c(0,0.5,1,2,2,1,1,1)

# Linear trivariate joint model
# (computation takes around 40 minutes)
model.trivPenal &lt;-trivPenal(Surv(time0, time1, new.lesions) ~ cluster(id)
+ age + treatment + who.PS +  terminal(state),
formula.terminalEvent =~ age + treatment + who.PS + prev.resection, 
tumor.size ~ year * treatment + age + who.PS, data = colorectal, 
data.Longi = colorectalLongi, random = c("1", "year"), id = "id", 
link = "Random-effects", left.censoring = -3.33, recurrentAG = TRUE,
n.knots = 6, kappa=c(0.01, 2), method.GH="Pseudo-adaptive",
n.nodes=7, init.B = c(-0.07, -0.13, -0.16, -0.17, 0.42, #recurrent events covarates
-0.23, -0.1, -0.09, -0.12, 0.8, -0.23, #terminal event covariates
3.02, -0.30, 0.05, -0.63, -0.02, -0.29, 0.11, 0.74)) #biomarker covariates

#-- prediction of death between 1 year and 1+2
pred.jointTri0 &lt;- prediction(model.trivPenal, datapredj, 
datapredj_longi, t = 1, window = 2)
print(pred.jointTri0)

#-- prediction of death between 1 year and 1+w
pred.jointTri &lt;- prediction(model.trivPenal, datapredj, 
datapredj_longi, t = 1, window = seq(0.5, 2.5, 0.2), MC.sample = 100)
plot(pred.jointTri, conf.bands = TRUE)

#-- prediction of death between t and t+0.5
pred.jointTri2 &lt;- prediction(model.trivPenal, datapredj, 
datapredj_longi, t = seq(1, 2.5, 0.5), window = 0.5, MC.sample = 100)
plot(pred.jointTri2, conf.bands = TRUE)


###############################

# No information on dose - creation of a dummy variable 
colorectalLongi$dose &lt;- 1

# (computation can take around 40 minutes)
model.trivPenalNL &lt;- trivPenalNL(Surv(time0, time1, new.lesions) ~ cluster(id) + age + treatment
 + terminal(state), formula.terminalEvent =~ age + treatment, biomarker = "tumor.size",
 formula.KG ~ 1, formula.KD ~ treatment, dose = "dose", time.biomarker = "year", 
 data = colorectal, data.Longi =colorectalLongi, random = c("y0", "KG"), id = "id", 
 init.B = c(-0.22, -0.16, -0.35, -0.19, 0.04, -0.41, 0.23), init.Alpha = 1.86,
 init.Eta = c(0.5, 0.57, 0.5, 2.34), init.Biomarker = c(1.24, 0.81, 1.07, -1.53),
 recurrentAG = TRUE, n.knots = 5, kappa = c(0.01, 2), method.GH = "Pseudo-adaptive")

#-- prediction of death between 1 year and 1+2
pred.jointTriNL0 &lt;- prediction(model.trivPenalNL, datapredj, 
datapredj_longi, t = 1, window = 2)
print(pred.jointTriNL0)

#-- prediction of death between 1 year and 1+w 
pred.jointTriNL &lt;- prediction(model.trivPenalNL, datapredj, 
datapredj_longi, t = 1, window = seq(0.5, 2.5, 0.2), MC.sample = 100)
plot(pred.jointTriNL, conf.bands = TRUE)

#-- prediction of death between t and t+0.5
pred.jointTriNL2 &lt;- prediction(model.trivPenalNL, datapredj, 
datapredj_longi, t = seq(2, 3, 0.2), window = 0.5, MC.sample = 100)
plot(pred.jointTriNL2, conf.bands = TRUE)


## End(Not run)


</code></pre>

<hr>
<h2 id='print.additivePenal'>Print a Short Summary of parameter estimates of an additive frailty model</h2><span id='topic+print.additivePenal'></span>

<h3>Description</h3>

<p>Prints a short summary of the parameter estimates of an additive frailty
model or more generally of an 'additivePenal' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'additivePenal'
print(x, digits = max(options()$digits - 4, 6),
...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.additivePenal_+3A_x">x</code></td>
<td>
<p>the result of a call to the additivePenal function</p>
</td></tr>
<tr><td><code id="print.additivePenal_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.additivePenal_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print the parameter estimates of the survival or hazard functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+additivePenal">additivePenal</a></code>
</p>

<hr>
<h2 id='print.Cmeasures'>Print a short summary of results of Cmeasure function.</h2><span id='topic+print.Cmeasures'></span>

<h3>Description</h3>

<p>Print a short summary of results of the concordance measure estimated by the
Cmeasure function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cmeasures'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.Cmeasures_+3A_x">x</code></td>
<td>
<p>a Cmeasures object.</p>
</td></tr>
<tr><td><code id="print.Cmeasures_+3A_...">...</code></td>
<td>
<p>Other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print concordance measures estimated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Cmeasures">Cmeasures</a></code>
</p>

<hr>
<h2 id='print.frailtyDesign'>Print a short table of a 'frailtyDesign' result.</h2><span id='topic+print.frailtyDesign'></span>

<h3>Description</h3>

<p>Print a short table of a 'frailtyDesign' result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frailtyDesign'
print(x, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.frailtyDesign_+3A_x">x</code></td>
<td>
<p>an object of class 'frailtyDesign' (output from one of the
*.power or *.ssize functions).</p>
</td></tr>
<tr><td><code id="print.frailtyDesign_+3A_digits">digits</code></td>
<td>
<p>number of decimals to print for numeric fields. Default is 2.</p>
</td></tr>
<tr><td><code id="print.frailtyDesign_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyDesign">frailtyDesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>est.ex &lt;- SFM.power(
  Groups = 400, ni = 3, ni.type = "max", FUP = 6, Acc.Dur = 0.5, median.H0 = 1.5,
  beta.HA = log(0.7), theta = 0.5, cens.par = c(3, 10), cens.type = "Unif", data.type = "rec_event"
)

print(est.ex)

</code></pre>

<hr>
<h2 id='print.frailtyPenal'>Print a Short Summary of parameter estimates of a shared frailty model</h2><span id='topic+print.frailtyPenal'></span>

<h3>Description</h3>

<p>Prints a short summary of parameter estimates of a 'frailtyPenal' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frailtyPenal'
print(x, digits = max(options()$digits - 4, 6),
...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.frailtyPenal_+3A_x">x</code></td>
<td>
<p>the result of a call to the frailtyPenal function.</p>
</td></tr>
<tr><td><code id="print.frailtyPenal_+3A_digits">digits</code></td>
<td>
<p>number of digits to print.</p>
</td></tr>
<tr><td><code id="print.frailtyPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print the parameter estimates of the survival or hazard functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>

<hr>
<h2 id='print.jointNestedPenal'>Print a Short Summary of parameter estimates of a joint nested frailty model</h2><span id='topic+print.jointNestedPenal'></span>

<h3>Description</h3>

<p>Prints a short summary of parameter estimates of a joint nested frailty
model, or more generally an object of class 'jointNestedPenal' for joint
nested frailty models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointNestedPenal'
print(x, digits = max(options()$digits - 4,
6), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.jointNestedPenal_+3A_x">x</code></td>
<td>
<p>the result of a call to the jointNestedPenal function</p>
</td></tr>
<tr><td><code id="print.jointNestedPenal_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.jointNestedPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print, separately for each type of event (recurrent and terminal), the
parameter estimates of the survival or hazard functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>

<hr>
<h2 id='print.jointPenal'>Print a Short Summary of parameter estimates of a joint frailty model</h2><span id='topic+print.jointPenal'></span>

<h3>Description</h3>

<p>Prints a short summary of parameter estimates of a joint frailty model, or
more generally an object of class 'frailtyPenal' for joint frailty models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointPenal'
print(x, digits = max(options()$digits - 4, 6), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.jointPenal_+3A_x">x</code></td>
<td>
<p>the result of a call to the jointPenal function</p>
</td></tr>
<tr><td><code id="print.jointPenal_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.jointPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print, separately for each type of event (recurrent and terminal), the
parameter estimates of the survival or hazard functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>

<hr>
<h2 id='print.jointRecCompet'>Print a Short Summary of parameter estimates of a joint competing risks midel</h2><span id='topic+print.jointRecCompet'></span>

<h3>Description</h3>

<p>Prints a short summary of parameter estimates of a joint competing risks model
or more generally an object of class 'jointRecCompet'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointRecCompet'
print(x, digits = max(options()$digits - 4, 6),
...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.jointRecCompet_+3A_x">x</code></td>
<td>
<p>the result of a call to the jointRecCompet function</p>
</td></tr>
<tr><td><code id="print.jointRecCompet_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.jointRecCompet_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print, separately for each type of event (Recurrent, Terminal1 and
Terminal2), the parameter estimates of the survival or hazard functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointRecCompet">jointRecCompet</a></code>
</p>

<hr>
<h2 id='print.jointSurroPenal'>Summary of the random effects parameters, the fixed treatment 
effects, and the surrogacy evaluation criteria estimated from a joint surrogate model</h2><span id='topic+print.jointSurroPenal'></span>

<h3>Description</h3>

<p>This function returns the estimate of the coefficients and their standard error with p-values 
of the Wald test for the joint surrogate model, also hazard ratios (HR) and their 
confidence intervals for the fixed treatment effects, and finaly an estimate of the 
surrogacy evaluation criterian (Kendall's <code class="reqn">\tau</code> and 
<code>R</code><sup>2</sup><sub>trial</sub>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointSurroPenal'
print(x, d = 4, len = 3, nb.gh = 32, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.jointSurroPenal_+3A_x">x</code></td>
<td>
<p>An object inheriting from <code>jointSurroPenal</code> class.</p>
</td></tr>
<tr><td><code id="print.jointSurroPenal_+3A_d">d</code></td>
<td>
<p>The desired number of digits after the decimal point for parameters. 
The maximum of 4 digits is required for the estimates. Default of 3 digits is used.</p>
</td></tr>
<tr><td><code id="print.jointSurroPenal_+3A_len">len</code></td>
<td>
<p>The desired number of digits after the decimal point for p-value and convergence 
criteria. Default of 4 digits is used.</p>
</td></tr>
<tr><td><code id="print.jointSurroPenal_+3A_nb.gh">nb.gh</code></td>
<td>
<p>Number of nodes for the Gaussian-Hermite quadrature.  The default is <code>32</code>
<code>1</code> for Gaussian-Hermite quadrature.</p>
</td></tr>
<tr><td><code id="print.jointSurroPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the variances parameters of the random effects, it prints the estimate of
the coefficients with their standard error, Z-statistics and p-values
of the Wald test. For the fixed treatment effects, it also prints HR and its confidence
intervals for each covariate. For the surrogacy evaluation criteria, its prints the estimated 
Kendall's <code class="reqn">\tau</code> with its 95% Confidence interval obtained by the parametric bootstrap
or Delta-method, 
the estimated 
<code>R</code><sup>2</sup><sub>trial</sub>(R2trial) with standard error and the 95% Confidence interval 
obtained by Delta-method (Dowd <em>et al.</em>, 2014), 
<code>R</code><sup>2</sup><sub>trial</sub>(R2.boot) and its 95% 
Confidence interval obtained by the parametric bootstrap. 
We notice that, using bootstrap, 
the standard error of the point estimate is not available. We propose a classification of 
<code>R</code><sup>2</sup><sub>trial</sub> according to 
the suggestion of the Institute of Quality and Efficiency in Health Care 
(Prasad <em>et al.</em>, 2015). 
We also display the surrogate threshold effect (<code><a href="#topic+ste">ste</a></code>) with the associated hazard risk.
The rest of parameters concerns the convergence characteristics and 
included: the penalized marginal log-likelihood, the number of iterations, the LCV and the Convergence criteria.
</p>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a> and 
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>
</p>


<h3>References</h3>

<p>Dowd BE, Greene WH, Norton EC (2014). &quot;Computation of Standard Errors.&quot; Health Services
Research, 49(2), 731-750.
</p>
<p>Prasad V, Kim C, Burotto M, Vandross A (2015). &quot;The strength of association between
surrogate end points and survival in oncology: A systematic review of trial-level meta-
alyses.&quot; JAMA Internal Medicine, 175(8), 1389-1398.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurroPenal">jointSurroPenal</a>, <a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a>, <a href="#topic+jointSurroTKendall">jointSurroTKendall</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

###---Data generation---###
data.sim &lt;-jointSurrSimul(n.obs=400, n.trial = 20,cens.adm=549, 
          alpha = 1.5, theta = 3.5, gamma = 2.5, zeta = 1, 
          sigma.s = 0.7, sigma.t = 0.7, cor = 0.8, betas = -1.25, 
          betat = -1.25, full.data = 0, random.generator = 1, 
          seed = 0, nb.reject.data = 0)

###---Estimation---###
joint.surrogate &lt;- jointSurroPenal(data = data.sim, nb.mc = 300, 
                   nb.gh = 20, indicator.alpha = 1, n.knots = 6)
                            
print(joint.surrogate)

# or
joint.surrogate

## End(Not run)


</code></pre>

<hr>
<h2 id='print.longiPenal'>Print a Summary of parameter estimates of a joint model for longitudinal
data and a terminal event</h2><span id='topic+print.longiPenal'></span>

<h3>Description</h3>

<p>Prints a short summary of parameter estimates of a joint model for
longitudinal data and a terminal event, an object inheriting from class
'longiPenal'. If a mediation analysis was performed (option <code>mediation</code> set to
<code>TRUE</code> in <code><a href="#topic+longiPenal">longiPenal</a></code>) this function displays estimations of the related 
quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'longiPenal'
print(x, digits = max(options()$digits - 4, 6), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.longiPenal_+3A_x">x</code></td>
<td>
<p>an object inheriting from <code>longiPenal</code> class</p>
</td></tr>
<tr><td><code id="print.longiPenal_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.longiPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print, separately for each part of the model (longitudinal and terminal) the
parameter estimates and details on the estimation. Also print in a separate part the
results of the mediation analysis if one was performed
</p>


<h3>See Also</h3>

<p><code><a href="#topic+longiPenal">longiPenal</a></code>
</p>

<hr>
<h2 id='print.multivPenal'>Print a Short Summary of parameter estimates of a multivariate frailty model</h2><span id='topic+print.multivPenal'></span>

<h3>Description</h3>

<p>Prints a short summary of parameter estimates of a multivariate frailty
model, or more generally an object of class 'multivPenal'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multivPenal'
print(x, digits = max(options()$digits - 4, 6),
...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.multivPenal_+3A_x">x</code></td>
<td>
<p>the result of a call to the multivPenal function</p>
</td></tr>
<tr><td><code id="print.multivPenal_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.multivPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print, separately for each type of event (recurrent1, recurrent2 and
terminal), the parameter estimates of the survival or hazard functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multivPenal">multivPenal</a></code>
</p>

<hr>
<h2 id='print.nestedPenal'>Print a Short Summary of parameter estimates of a nested frailty model</h2><span id='topic+print.nestedPenal'></span>

<h3>Description</h3>

<p>Prints a short summary of parameter estimates of a nested frailty model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nestedPenal'
print(x, digits = max(options()$digits - 4, 6),
...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.nestedPenal_+3A_x">x</code></td>
<td>
<p>the result of a call to the frailtyPenal function for nested
frailty models</p>
</td></tr>
<tr><td><code id="print.nestedPenal_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.nestedPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>the number of observations used in the fit.</p>
</td></tr>
<tr><td><code>n.groups</code></td>
<td>
<p>the maximum number of groups used in the fit</p>
</td></tr>
<tr><td><code>n.events</code></td>
<td>
<p>the number of events observed in the fit</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>variance of the subcluster effect <code class="reqn">(Var(w_{ij}))</code></p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>variance of the cluster effect <code class="reqn">(Var(v_{i}))</code></p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>the coefficients of the linear predictor, which multiply the
columns of the model matrix.</p>
</td></tr> <tr><td><code>SE(H)</code></td>
<td>
<p>the standard error of the
estimates deduced from the variance matrix of theta and of the
coefficients.</p>
</td></tr> <tr><td><code>SE(HIH)</code></td>
<td>
<p>the standard error of the estimates deduced
from the robust estimation of the variance matrix of theta and of the
coefficients.</p>
</td></tr> <tr><td><code>p</code></td>
<td>
<p>p-value</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>

<hr>
<h2 id='print.prediction'>Print a short summary of results of prediction function.</h2><span id='topic+print.prediction'></span><span id='topic+print.predFrailty'></span><span id='topic+print.predJoint'></span><span id='topic+print.predLongi'></span>

<h3>Description</h3>

<p>Print a short summary of results of prediction function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predFrailty'
print(x, digits = 3, ...)
## S3 method for class 'predJoint'
print(x, digits = 3, ...) 
## S3 method for class 'predLongi'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.prediction_+3A_x">x</code></td>
<td>
<p>An object from the 'prediction' function, objects inheriting from
<code>predFrailty</code>, <code>predJoint</code> and <code>predLongi</code> classes.</p>
</td></tr>
<tr><td><code id="print.prediction_+3A_digits">digits</code></td>
<td>
<p>Number of digits to print</p>
</td></tr>
<tr><td><code id="print.prediction_+3A_...">...</code></td>
<td>
<p>Other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print the probabilities estimated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prediction">prediction</a></code>
</p>

<hr>
<h2 id='print.trivPenal'>Print a Summary of parameter estimates of a joint model for longitudinal
data, recurrent events and a terminal event</h2><span id='topic+print.trivPenal'></span>

<h3>Description</h3>

<p>Prints a short summary of parameter estimates of a joint model for
longitudinal data, recurrent events and a terminal event, an object
inheriting from class 'trivPenal'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trivPenal'
print(x, digits = max(options()$digits - 4, 6), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.trivPenal_+3A_x">x</code></td>
<td>
<p>an object inheriting from <code>trivPenal</code> class</p>
</td></tr>
<tr><td><code id="print.trivPenal_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.trivPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print, separately for each part of the model (longitudinal, recurrent and
terminal) the parameter estimates and details on the estimation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trivPenal">trivPenal</a></code>
</p>

<hr>
<h2 id='print.trivPenalNL'>Print a Summary of parameter estimates of a non-linear trivariate joint
model for longitudinal data, recurrent events and a terminal event</h2><span id='topic+print.trivPenalNL'></span>

<h3>Description</h3>

<p>Prints a short summary of parameter estimates of a non-linear trivariate
joint model for longitudinal data, recurrent events and a terminal event, an
object inheriting from class 'trivPenalNL'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trivPenalNL'
print(x, digits = max(options()$digits - 4, 6), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.trivPenalNL_+3A_x">x</code></td>
<td>
<p>an object inheriting from <code>trivPenaNLl</code> class</p>
</td></tr>
<tr><td><code id="print.trivPenalNL_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.trivPenalNL_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print, separately for each part of the model (biomarker growth, biomarker
decline, recurrent events and terminal event) the parameter estimates and
details on the estimation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trivPenalNL">trivPenalNL</a></code>
</p>

<hr>
<h2 id='readmission'>Rehospitalization colorectal cancer</h2><span id='topic+readmission'></span>

<h3>Description</h3>

<p>This contains rehospitalization times after surgery in patients diagnosed
with colorectal cancer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(readmission)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: </p>

<dl>
<dt>id</dt><dd><p>identification of each subject. Repeated for each recurrence</p>
</dd>
<dt>enum</dt><dd><p>which readmission</p>
</dd> <dt>t.start</dt><dd><p>start of interval (0 or
previous recurrence time)</p>
</dd> <dt>t.stop</dt><dd><p>recurrence or censoring time</p>
</dd>
<dt>time</dt><dd><p>interocurrence or censoring time</p>
</dd> <dt>event</dt><dd><p>rehospitalization
status. All event are 1 for each subject excepting last one that it is 0</p>
</dd>
<dt>chemo</dt><dd><p>Did patient receive chemotherapy? 1: No; 2:Yes</p>
</dd>
<dt>sex</dt><dd><p>gender: 1:Males 2:Females</p>
</dd> <dt>dukes</dt><dd><p>Dukes' tumoral stage:
1:A-B; 2:C 3:D</p>
</dd> <dt>charlson</dt><dd><p>Comorbidity Charlson's index. Time-dependent
covariate.  0: Index 0; 1: Index 1-2; 3: Index &gt;=3 </p>
</dd> <dt>death</dt><dd><p>death
indicator. 1:dead and 0:alive </p>
</dd> </dl>



<h3>Source</h3>

<p>Gonzalez, JR., Fernandez, E., Moreno, V., Ribes, J., Peris, M., Navarro, M.,
Cambray, M. and Borras, JM (2005). Sex differences in hospital readmission
among colorectal cancer patients. <em>Journal of Epidemiology and
Community Health</em>, <b>59</b>, 6, 506-511.
</p>

<hr>
<h2 id='reduce'>Delirium in critically ill ICU patients dataset: the REDUCE clinical trial</h2><span id='topic+reduce'></span>

<h3>Description</h3>

<p>This dataset contains an extract of 500 randomly selected patients from the randomized, 
double-blind, placebo-controlled REDUCE trial for critically ill patient admited to ICU. 
This trial investigated whether Haloperidol (1 or 2 mg) administered as a prophylactic improved 
28-day survival compared to placebo. Recurrent episodes of delirium are 
recorded and patients and patients can be censored by death or discharge from the ICU.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(reduce)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: 
</p>

<dl>
<dt>id</dt><dd><p>Identification number of a patient</p>
</dd> 
<dt>t.start</dt><dd><p>Start time of the interval (0 or time of last recurrence)</p>
</dd>
<dt>t.stop</dt><dd><p>Stop time of the interval, either delirium recurrence time or censoring time.</p>
</dd>
<dt>del</dt><dd><p>Delirium status</p>
</dd>
<dt>death</dt><dd><p>Death status</p>
</dd>
<dt>discharge</dt><dd><p>Discharge status</p>
</dd>
<dt>treatment</dt><dd><p>Treatment indicator, 
1 if patient was randomized to receive 2mg of Haloperidol, 
0 for control </p>
</dd>
</dl>



<h3>Source</h3>

<p>Van Den Boogaard, M., Slooter, A. J., Bruggemann, R. J., 
Schoonhoven, L., Beishuizen, A., Vermeijden, J. W., et al. (2018). 
Effect of haloperidol on survival among critically ill adults with a 
high risk of delirium: the REDUCE randomized clinical trial. <em>Jama</em>, <b>319(7)</b>, 680-690.
</p>

<hr>
<h2 id='runShiny'>Shiny application for modelisation and prediction of frailty models</h2><span id='topic+runShiny'></span>

<h3>Description</h3>

<p>This function loads the shiny package and runs the application for modelisation and prediction of several frailty models using package frailtypack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runShiny()
</code></pre>


<h3>Value</h3>

<p>No value returned.
</p>


<h3>References</h3>

<p>Rizopoulos D. (2016)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

runShiny()


## End(Not run)

</code></pre>

<hr>
<h2 id='simulatejointRecCompet'>Generating from a joint competing Joint frailty model with a recurrent event and two
terminal events.</h2><span id='topic+simulatejointRecCompet'></span>

<h3>Description</h3>

<p>Generates data under a joint frailty model for a single recurrent event
and two terminal events in a calendar-time format. Only a single covariate representing the treatment
is allowed. Event times are generated under Weibull distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulatejointRecCompet(n, censoring = 28, maxrecurrent = 50, 
           par0 = c(shapeR = 1.5, scaleR = 10, 
           shapeM = 1.75, scaleM = 16, 
           shapeD = 1.75, scaleD = 16, 
           sigma = 0.5, alphaM = 1, alphaD = 0, 
           betaR = -0.5, betaM = -0.5, betaD = 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulatejointRecCompet_+3A_n">n</code></td>
<td>
<p>Number of subjects. Default is 1500.</p>
</td></tr>
<tr><td><code id="simulatejointRecCompet_+3A_censoring">censoring</code></td>
<td>
<p>A number indicating a fixed right censoring time for all subjects 
(as an administrative censoring). If <code>NULL</code>, no censoring is applied. 
Default is 28.</p>
</td></tr>
<tr><td><code id="simulatejointRecCompet_+3A_maxrecurrent">maxrecurrent</code></td>
<td>
<p>Maximum number of recurrent events per subject.
If <code>NULL</code>, no upper bound is set for the number of of recurrent events
Default is 50.</p>
</td></tr>
<tr><td><code id="simulatejointRecCompet_+3A_par0">par0</code></td>
<td>
<p>A vector of arguments controlling the parameters of the generating model. 
</p>

<ul>
<li><p><code>shapeR</code>: <code>shape</code> parameter of the Weibull distribution for the recurrent event
</p>
</li>
<li><p><code>scaleR</code>: <code>scale</code> parameter of the Weibull distribution for the recurrent event 
</p>
</li>
<li><p><code>shapeT1</code>: <code>shape</code> parameter of the Weibull distribution for the first terminal event
</p>
</li>
<li><p><code>scaleT1</code>: <code>scale</code> parameter of the Weibull distribution for the first terminal event
</p>
</li>
<li><p><code>shapeT2</code>: <code>shape</code> parameter of the Weibull distribution for the second terminal event
</p>
</li>
<li><p><code>scaleT2</code>: <code>scale</code> parameter of the Weibull distribution for the second terminal event
</p>
</li>
<li><p><code>sigma</code>: Standard deviation of the frailty
</p>
</li>
<li><p><code>alphaT1</code>: Power parameter (link) of the frailty for the first terminal event
</p>
</li>
<li><p><code>alphaT2</code>: Power parameter (link) of the frailty for the second terminal event
</p>
</li>
<li><p><code>betaR</code>: Association parameter for the treatment effect on the recurrent event
</p>
</li>
<li><p><code>betaT1</code>: Association parameter for the treatment effect on the first terminal event
</p>
</li>
<li><p><code>betaT2</code>: Association parameter for the treatment effect on the second terminal event
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> object with the following columns:
</p>

<ul>
<li><p><code>id</code> Id number for each subject
</p>
</li>
<li><p><code>treatment</code> Binary treatment indicator 
</p>
</li>
<li><p><code>tstart</code> Start time of the observation period
</p>
</li>
<li><p><code>tstop</code> Stop time of the observation period
</p>
</li>
<li><p><code>recurrent</code> Censoring indicator for the recurrent event
</p>
</li>
<li><p><code>terminal1</code> Censoring indicator for the first terminal event
</p>
</li>
<li><p><code>terminal2</code> Censoring indicator for the second terminal event
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+jointRecCompet">jointRecCompet</a>
</p>

<hr>
<h2 id='slope'>Identify variable associated with the random slope</h2><span id='topic+slope'></span>

<h3>Description</h3>

<p>This is a special function used in the context of survival additive models.
It identifies the variable which is in interaction with the random slope
(<b><code class="reqn">v_i</code></b>). Generally, this variable is the treatment variable.
Using <code>interaction()</code> in a formula implies that an additive frailty
model is fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slope(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slope_+3A_x">x</code></td>
<td>
<p>A factor, a character or a numerical variable</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>The variable in interaction with the random slope</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is necessary to specify which variable is in interaction with the
random slope, even if only one explanatory variable is included in the
model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+additivePenal">additivePenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



data(dataAdditive)

##-- Additive with one covariate --##

modAdd1cov &lt;- additivePenal(Surv(t1,t2,event)~cluster(group)+var1+
slope(var1),data=dataAdditive,n.knots=8,kappa=10000,hazard="Splines")

##-- Additive with two covariates --##

set.seed(1234)
dataAdditive$var2 &lt;- rbinom(nrow(dataAdditive),1,0.5)

modAdd2cov &lt;- additivePenal(Surv(t1,t2,event)~cluster(group)+var1+
var2+slope(var1),data=dataAdditive,n.knots=8,kappa=10000,
hazard="Splines")

##-- Additive with 2 covariates and stratification --##

dataAdditive$var2 &lt;- rbinom(nrow(dataAdditive),1,0.5)

modAddstrat &lt;- additivePenal(Surv(t1,t2,event)~cluster(group)+
strata(var2)+var1+slope(var1),data=dataAdditive,n.knots=8,
kappa=c(10000,10000),hazard="Splines")




</code></pre>

<hr>
<h2 id='ste'>Surrogate threshold effect for the one-step Joint surrogate model for the evaluation of a 
canditate surrogate endpoint.</h2><span id='topic+ste'></span>

<h3>Description</h3>


<p>This function compute the surrogate threshold effect (STE) from the one-step joint frailty 
<code><a href="#topic+jointSurroPenal">model</a></code> or joint frailty-copula 
<code><a href="#topic+jointSurroCopPenal">model</a></code>. The STE is defined as the minimum treament effect 
on surrogate endpoint, necessary to predict a non-zero effect on 
true endpoint (Burzykowski <em>et al.</em>, 2006).

</p>


<h3>Usage</h3>

<pre><code class='language-R'>ste(object, var.used = "error.estim", alpha. = 0.05, 
    pred.int.use = "up")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ste_+3A_object">object</code></td>
<td>
<p>An object inheriting from <code>jointSurroPenal</code> class
(output from calling the <code>jointSurroPenal</code> or <code>jointSurroCopPenal</code> function ).</p>
</td></tr>
<tr><td><code id="ste_+3A_var.used">var.used</code></td>
<td>
<p>This argument takes two values. The first one is <code>"error.estim"</code>
and indicates if the prediction error takes into account
the estimation error of the estimates of the parameters. If the estimates 
are supposed to be known or if the dataset includes a high number of trials with 
a high number of subject per trial, value <code>No.error</code> can be used. 
The default is <code>error.estim</code>, which is highly recommended in practice.</p>
</td></tr>
<tr><td><code id="ste_+3A_alpha.">alpha.</code></td>
<td>
<p>The confidence level for the prediction interval. The default is <code>0.05</code></p>
</td></tr>
<tr><td><code id="ste_+3A_pred.int.use">pred.int.use</code></td>
<td>
<p>A character string that indicates the bound of the prediction interval 
to use to compute the STE. Possible values are <code>up</code> for the upper bound (the default)
or <code>lw</code> for the lower bound. <code>up</code> when we have a protective treatment effect and <code>lw</code> 
when we have a deleterious treatment effect (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

  
<p>The STE is obtained by solving the equation  
<code>l</code>(<code class="reqn">\alpha</code><sub>0</sub>) <code>= 0</code>
(resp.  
<code>u</code>(<code class="reqn">\alpha</code><sub>0</sub>) <code>= 0</code>), where 
 <code class="reqn">\alpha</code><sub>0</sub> represents
the corresponding STE, and  
<code>l</code>(<code class="reqn">\alpha</code><sub>0</sub>) (resp.  
<code>u</code>(<code class="reqn">\alpha</code><sub>0</sub>)) is the lower (resp. upper) bound of the prediction interval 
of the treatment effect on the true endpoint (<code class="reqn">\beta</code> + b<sub>0</sub>) . Thereby,
</p>

<p><img src="../help/figures/ste.png" width="60%" alt="ste.png" />
</p>
<p>where <img src="../help/figures/vartheta.png" width="3%" alt="vartheta.png" />
represents the set of estimates for the fixed-effects and the 
variance-covariance parameters of the random effects obtained from the joint surrogate 
<code><a href="#topic+jointSurroPenal">model</a></code> 
(Sofeu <em>et al.</em>, 2019). 
</p>
<p>If the previous equations gives two solutions, STE can be the 
minimum (resp. the maximum) value or both of them, according to the shape of the function. 
If the concavity of the function is turned upwards, STE is the first value and
the second value represents the maximum (res. the minimum) treament value observable 
on the surrogate that can predict a nonzero treatment effect on true endpoint. 
If the concavity of the function is turned down, both of the solutions
represent the STE and the interpretation is such that accepted values of the 
treatment effects on <code>S</code> predict a nonzero treatment effects on <code>T</code>
</p>
<p>Given that negative values of treatment effect indicate a reduction of the risk 
of failure and are considered beneficial, STE is recommended to be computed from 
the upper prediction
limit   
<code>u</code>(<code class="reqn">\alpha</code><sub>0</sub>).
</p>
<p>The details on the computation of STE are described in 
Burzykowski <em>et al.</em> (2006).

</p>


<h3>Value</h3>

<p>Returns and displays the STE.
</p>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a> and 
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>
</p>


<h3>References</h3>

<p>Burzykowski T, Buyse M (2006). &quot;Surrogate threshold effect: an alternative 
measure for meta-analytic surrogate endpoint validation.&quot; Pharmaceutical 
Statistics, 5(3), 173-186.ISSN 1539-1612.
</p>
<p>Sofeu, C. L., Emura, T., and Rondeau, V. (2019). One-step validation method for surrogate 
endpoints using data from multiple randomized cancer clinical trials with failure-time endpoints. 
Statistics in Medicine 38, 2928-2942. 
</p>
<p>Sofeu, C. L. and Rondeau, V. (2020). How to use frailtypack for validating failure-time surrogate 
endpoints using individual patient data from meta-analyses of randomized controlled trials. 
PLOS ONE; 15, 1-25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurroPenal">jointSurroPenal</a>, <a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a></code>, <code><a href="#topic+predict.jointSurroPenal">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>




###--- Joint surrogate model ---###
###---evaluation of surrogate endpoints---###

data(dataOvarian)
joint.surro.ovar &lt;- jointSurroPenal(data = dataOvarian, n.knots = 8, 
                init.kappa = c(2000,1000), indicator.alpha = 0, 
                nb.mc = 200, scale = 1/365)

# ======STE=====
# Assuming errors on the estimates
ste(joint.surro.ovar, var.used = "error.estim")
# Assuming no errors on the estimates
ste(joint.surro.ovar, var.used = "No.error", pred.int.use = "up")




</code></pre>

<hr>
<h2 id='subcluster'>Identify subclusters</h2><span id='topic+subcluster'></span>

<h3>Description</h3>

<p>This is a special function used in the context of survival nested or joint
nested models.  It identifies correlated groups of observations within other
groups defined by using 'cluster' function from 'survival' package, and is
used on the right hand side of 'frailtyPenal' formula for fitting a nested
or joint nested model.  Using <code>subcluster()</code> in a formula implies that
a nested or a joint nested frailty model is estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subcluster(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subcluster_+3A_x">x</code></td>
<td>
<p>A character, factor, or numeric variable which is supposed to
indicate the variable subgroup</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>A variable identified as a subcluster </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

data(dataNested)
modClu &lt;- frailtyPenal(Surv(t1,t2,event)~cluster(group)+
subcluster(subgroup)+cov1+cov2,data=dataNested,
n.knots=8,kappa=c(50000,50000),hazard="Splines")

print(modClu)

#-- here is generated cluster (30 clusters)
readmissionNested &lt;- transform(readmission,group=id%%30+1)

modJointNested_Splines &lt;- frailtyPenal(formula = Surv(t.start, t.stop, event)
	~ subcluster(id) + cluster(group) + dukes + 
	terminal(death), formula.terminalEvent = ~dukes, 
	data = readmissionNested, recurrentAG = TRUE, n.knots = 8, 
	kappa = c(9.55e+9, 1.41e+12), initialize = TRUE)


## End(Not run)


</code></pre>

<hr>
<h2 id='summary.additivePenal'>summary of parameter estimates of an additive frailty model</h2><span id='topic+summary.additivePenal'></span><span id='topic+print.summary.additivePenal'></span>

<h3>Description</h3>

<p>This function returns hazard ratios (HR) and its confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'additivePenal'
summary(object, level = 0.95, len = 6, d = 2,
lab="hr", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.additivePenal_+3A_object">object</code></td>
<td>
<p>output from a call to additivePenal.</p>
</td></tr>
<tr><td><code id="summary.additivePenal_+3A_level">level</code></td>
<td>
<p>significance level of confidence interval. Default is 95%.</p>
</td></tr>
<tr><td><code id="summary.additivePenal_+3A_len">len</code></td>
<td>
<p>the total field width. Default is 6.</p>
</td></tr>
<tr><td><code id="summary.additivePenal_+3A_d">d</code></td>
<td>
<p>the desired number of digits after the decimal point. Default of 6
digits is used.</p>
</td></tr>
<tr><td><code id="summary.additivePenal_+3A_lab">lab</code></td>
<td>
<p>label of printed results.</p>
</td></tr>
<tr><td><code id="summary.additivePenal_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints HR and its confidence intervals for each covariate.
Confidence level is allowed (level argument)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+additivePenal">additivePenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

data(dataAdditive)

modAdd &lt;- additivePenal(Surv(t1,t2,event)~cluster(group)+var1+slope(var1),
correlation=TRUE,data=dataAdditive,n.knots=8,kappa=862,hazard="Splines")

#- 'var1' is boolean as a treatment variable.

summary(modAdd)


## End(Not run)


</code></pre>

<hr>
<h2 id='summary.frailtyDesign'>Summarize a 'frailtyDesign' object.</h2><span id='topic+summary.frailtyDesign'></span>

<h3>Description</h3>

<p>Summarize a 'frailtyDesign' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frailtyDesign'
summary(object, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.frailtyDesign_+3A_object">object</code></td>
<td>
<p>an object of class 'frailtyDesign' (output from one of the
*.power or *.ssize functions).</p>
</td></tr>
<tr><td><code id="summary.frailtyDesign_+3A_digits">digits</code></td>
<td>
<p>number of decimals to print for numeric fields. Default is 2.</p>
</td></tr>
<tr><td><code id="summary.frailtyDesign_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyDesign">frailtyDesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>est.ex &lt;- SFM.power(
  Groups = 400, ni = 3, ni.type = "max", FUP = 6, Acc.Dur = 0.5, median.H0 = 1.5,
  beta.HA = log(0.7), theta = 0.5, cens.par = c(3, 10), cens.type = "Unif", data.type = "rec_event"
)

summary(est.ex)

</code></pre>

<hr>
<h2 id='summary.frailtyPenal'>summary of parameter estimates of a shared frailty model</h2><span id='topic+summary.frailtyPenal'></span><span id='topic+print.summary.frailtyPenal'></span>

<h3>Description</h3>

<p>This function returns hazard rations (HR) and its confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frailtyPenal'
summary(object, level = 0.95, len = 6, d = 2,
lab="hr", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.frailtyPenal_+3A_object">object</code></td>
<td>
<p>output from a call to frailtyPenal.</p>
</td></tr>
<tr><td><code id="summary.frailtyPenal_+3A_level">level</code></td>
<td>
<p>significance level of confidence interval. Default is 95%.</p>
</td></tr>
<tr><td><code id="summary.frailtyPenal_+3A_len">len</code></td>
<td>
<p>the total field width. Default is 6.</p>
</td></tr>
<tr><td><code id="summary.frailtyPenal_+3A_d">d</code></td>
<td>
<p>the desired number of digits after the decimal point. Default of 6
digits is used.</p>
</td></tr>
<tr><td><code id="summary.frailtyPenal_+3A_lab">lab</code></td>
<td>
<p>label of printed results.</p>
</td></tr>
<tr><td><code id="summary.frailtyPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints HR and its confidence intervals. Confidence level is allowed
(level argument).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

data(kidney)

##-- Shared frailty model --##

modSha &lt;- frailtyPenal(Surv(time,status)~age+sex+cluster(id),
n.knots=8,kappa=10000,data=kidney,hazard="Splines")

##-- Cox proportional hazard model --##

modCox &lt;- frailtyPenal(Surv(time,status)~age+sex,
n.knots=8,kappa=10000,data=kidney,hazard="Splines")

#-- confidence interval at 95% level (default)

summary(modSha)
summary(modCox)

#-- confidence interval at 99% level

summary(modSha,level=0.99)
summary(modCox,level=0.99)


## End(Not run)


</code></pre>

<hr>
<h2 id='summary.jointNestedPenal'>summary of parameter estimates of a joint nested frailty model</h2><span id='topic+summary.jointNestedPenal'></span><span id='topic+print.summary.jointNestedPenal'></span>

<h3>Description</h3>

<p>This function returns hazard rations (HR) and its confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointNestedPenal'
summary(object, level = 0.95, len = 6, d =
2, lab="hr", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.jointNestedPenal_+3A_object">object</code></td>
<td>
<p>output from a call to frailtyPenal for joint nested models</p>
</td></tr>
<tr><td><code id="summary.jointNestedPenal_+3A_level">level</code></td>
<td>
<p>significance level of confidence interval. Default is 95%.</p>
</td></tr>
<tr><td><code id="summary.jointNestedPenal_+3A_len">len</code></td>
<td>
<p>the total field width. Default is 6.</p>
</td></tr>
<tr><td><code id="summary.jointNestedPenal_+3A_d">d</code></td>
<td>
<p>the desired number of digits after the decimal point. Default of 6
digits is used.</p>
</td></tr>
<tr><td><code id="summary.jointNestedPenal_+3A_lab">lab</code></td>
<td>
<p>label of printed results.</p>
</td></tr>
<tr><td><code id="summary.jointNestedPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints HR and its confidence intervals for each covariate.
Confidence level is allowed (level argument).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

#-- here is generated cluster (30 clusters)
readmissionNested &lt;- transform(readmission,group=id%%30+1)

# Baseline hazard function approximated with splines with calendar-timescale

model.spli.AG &lt;- frailtyPenal(formula = Surv(t.start, t.stop, event)
 ~ subcluster(id) + cluster(group) + dukes + terminal(death), 
 formula.terminalEvent = ~dukes, data = readmissionNested, 
 recurrentAG = TRUE, n.knots = 8, kappa = c(9.55e+9, 1.41e+12),
 initialize = TRUE)

summary(model.spli.AG)


## End(Not run)

</code></pre>

<hr>
<h2 id='summary.jointPenal'>summary of parameter estimates of a joint frailty model</h2><span id='topic+summary.jointPenal'></span><span id='topic+print.summary.jointPenal'></span>

<h3>Description</h3>

<p>This function returns hazard rations (HR) and its confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointPenal'
summary(object, level = 0.95, len = 6, d = 2,
lab="hr", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.jointPenal_+3A_object">object</code></td>
<td>
<p>output from a call to frailtyPenal for joint models</p>
</td></tr>
<tr><td><code id="summary.jointPenal_+3A_level">level</code></td>
<td>
<p>significance level of confidence interval. Default is 95%.</p>
</td></tr>
<tr><td><code id="summary.jointPenal_+3A_len">len</code></td>
<td>
<p>the total field width. Default is 6.</p>
</td></tr>
<tr><td><code id="summary.jointPenal_+3A_d">d</code></td>
<td>
<p>the desired number of digits after the decimal point. Default of 6
digits is used.</p>
</td></tr>
<tr><td><code id="summary.jointPenal_+3A_lab">lab</code></td>
<td>
<p>label of printed results.</p>
</td></tr>
<tr><td><code id="summary.jointPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints HR and its confidence intervals for each covariate.
Confidence level is allowed (level argument).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

data(readmission)

#-- gap-time
modJoint.gap &lt;- frailtyPenal(Surv(time,event)~cluster(id)+sex+dukes+
charlson+terminal(death),formula.terminalEvent=~sex+dukes+charlson,
data=readmission,n.knots=14,kappa=c(9.55e+9,1.41e+12))

#-- calendar time
modJoint.calendar &lt;- frailtyPenal(Surv(t.start,t.stop,event)~cluster(id)+
sex+dukes+charlson+terminal(death),formula.terminalEvent=~sex+dukes+charlson,
data=readmission,n.knots=10,kappa=c(9.55e+9,1.41e+12),recurrentAG=TRUE)

#-- It takes around 1 minute to converge

summary(modJoint.gap)
summary(modJoint.calendar)


## End(Not run)


</code></pre>

<hr>
<h2 id='summary.jointRecCompet'>Summary method for a joint competing risks midel</h2><span id='topic+summary.jointRecCompet'></span>

<h3>Description</h3>

<p>Prints a short summary of parameter estimates of a joint competing risks model
or more generally an object of class 'jointRecCompet'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointRecCompet'
summary(object, digits = max(options()$digits - 4, 6),
...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.jointRecCompet_+3A_object">object</code></td>
<td>
<p>the result of a call to the jointRecCompet function</p>
</td></tr>
<tr><td><code id="summary.jointRecCompet_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="summary.jointRecCompet_+3A_...">...</code></td>
<td>
<p>other unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print, separately for each type of event (Recurrent, Terminal1 and
Terminal2), the parameter estimates of the survival or hazard functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointRecCompet">jointRecCompet</a></code>
</p>

<hr>
<h2 id='summary.jointSurroMed'>Short summary of the random effects parameters, the fixed treatment
effects, and the surrogacy evaluation criteria estimated from a joint surrogate mediation model</h2><span id='topic+summary.jointSurroMed'></span><span id='topic+print.summary.jointSurroMed'></span>

<h3>Description</h3>

<p>This function returns the estimate of the coefficients of the model, their standard error and the
associated p-values of the Wald test for the joint surrogate model, also hazard ratios (HR) and their
confidence intervals for the fixed treatment effects. It also displays summary of the surrogacy measure <code class="reqn">PTE(t)</code>
and of the natural direct, indirect and total effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointSurroMed'
summary(object,d=4,len=3,n=3,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.jointSurroMed_+3A_object">object</code></td>
<td>
<p>An object inheriting from <code>jointSurroMed</code> class.</p>
</td></tr>
<tr><td><code id="summary.jointSurroMed_+3A_d">d</code></td>
<td>
<p>The desired number of digits after the decimal point for parameters.
The maximum of 4 digits is required for the estimates. Default of 3 digits is used.</p>
</td></tr>
<tr><td><code id="summary.jointSurroMed_+3A_len">len</code></td>
<td>
<p>The desired number of digits after the decimal point for p-value and convergence
criteria. Default of 4 digits is used.</p>
</td></tr>
<tr><td><code id="summary.jointSurroMed_+3A_n">n</code></td>
<td>
<p>The number of time points to be used in the results of the differents function
related to the mediation analysis: <code class="reqn">g(s)</code>, <code class="reqn">PTE(t)</code> and the direct, indirect and total
effect. The provided value should be between 1 and 20. Default is 3.</p>
</td></tr>
<tr><td><code id="summary.jointSurroMed_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the variances parameters of the random effects, it prints the estimate of
the coefficients with their standard error, Z-statistics and p-values
of the Wald test. For the fixed treatment effects, it also prints HR and its confidence
intervals for each covariate.
For the surrogacy assessment, prints <code>n</code> value of the estimation function <code class="reqn">g(s)</code> and <code class="reqn">PTE(t)</code>.
Also prints the values of the estimated direct, indirect and total effects.
The remaining displayed information concern the convergence characteristics and
include the penalized marginal log-likelihood, the number of iterations, the LCV and the convergence criteria.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurroPenal">jointSurroPenal</a></code>
</p>

<hr>
<h2 id='summary.jointSurroPenal'>Short summary of the surrogacy evaluation criteria estimated from a joint surrogate model</h2><span id='topic+summary.jointSurroPenal'></span>

<h3>Description</h3>

<p>This function returns the estimate of the coefficient, the hazard ratios (HR) and their
confidence intervals for the fixed treatment effects. Also, an estimate of the
surrogacy evaluation criteria (Kendall's <code class="reqn">\tau</code>, 
<code>R</code><sup>2</sup><sub>trial</sub> and STE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointSurroPenal'
summary(object, d = 4, len = 3, nb.gh = 32, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.jointSurroPenal_+3A_object">object</code></td>
<td>
<p>An object inheriting from <code>jointSurroPenal</code> class.</p>
</td></tr>
<tr><td><code id="summary.jointSurroPenal_+3A_d">d</code></td>
<td>
<p>The desired number of digits after the decimal point for parameters.
The maximum of 4 digits is required for the estimates. Default of 3 digits is used.</p>
</td></tr>
<tr><td><code id="summary.jointSurroPenal_+3A_len">len</code></td>
<td>
<p>The desired number of digits after the decimal point for p-value and convergence
criteria. Default of 4 digits is used.</p>
</td></tr>
<tr><td><code id="summary.jointSurroPenal_+3A_nb.gh">nb.gh</code></td>
<td>
<p>Number of nodes for the Gaussian-Hermite quadrature.  The default is <code>32</code>
<code>1</code> for Gaussian-Hermite quadrature.</p>
</td></tr>
<tr><td><code id="summary.jointSurroPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the fixed treatment effects, it also prints HR and its confidence
intervals for each covariate. For the surrogacy evaluation criteria, its prints the estimated
Kendall's <code class="reqn">\tau</code> with its 95% Confidence interval obtained by the parametric bootstrap
or Delta-method,
the estimated 
<code>R</code><sup>2</sup><sub>trial</sub>(R2trial) with standard error and the 95% Confidence interval
obtained by Delta-method (Dowd <em>et al.</em>, 2014), 
<code>R</code><sup>2</sup><sub>trial</sub>(R2.boot) and its 95%
Confidence interval obtained by the parametric bootstrap.
We notice that, using bootstrap,
the standard error of the point estimate is not available. We propose a classification of 
<code>R</code><sup>2</sup><sub>trial</sub> according to
the suggestion of the Institute of Quality and Efficiency in Health Care
(Prasad <em>et al.</em>, 2015).
We also display the surrogate threshold effect (<code><a href="#topic+ste">ste</a></code>) with the associated hazard risk.
</p>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a> and
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>
</p>


<h3>References</h3>

<p>Dowd BE, Greene WH, Norton EC (2014). &quot;Computation of Standard Errors.&quot; Health Services
Research, 49(2), 731-750.
</p>
<p>Prasad V, Kim C, Burotto M, Vandross A (2015). &quot;The strength of association between
surrogate end points and survival in oncology: A systematic review of trial-level meta-
alyses.&quot; JAMA Internal Medicine, 175(8), 1389-1398.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurroPenal">jointSurroPenal</a>, <a href="#topic+jointSurroCopPenal">jointSurroCopPenal</a>, <a href="#topic+jointSurroTKendall">jointSurroTKendall</a>, <a href="#topic+print.jointSurroPenal">print.jointSurroPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

###---Data generation---###
data.sim &lt;-jointSurrSimul(n.obs=400, n.trial = 20,cens.adm=549,
          alpha = 1.5, theta = 3.5, gamma = 2.5, zeta = 1,
          sigma.s = 0.7, sigma.t = 0.7, cor = 0.8, betas = -1.25,
          betat = -1.25, full.data = 0, random.generator = 1,
          seed = 0, nb.reject.data = 0)

###---Estimation---###
joint.surrogate &lt;- jointSurroPenal(data = data.sim, nb.mc = 300,
                   nb.gh = 20, indicator.alpha = 1, n.knots = 6)

summary(joint.surrogate)

## End(Not run)


</code></pre>

<hr>
<h2 id='summary.jointSurroPenalSimul'>Short summary of the simulation studies based on a joint surrogate model</h2><span id='topic+summary.jointSurroPenalSimul'></span><span id='topic+print.summary.jointSurroPenalSimul'></span>

<h3>Description</h3>

<p>This function returns the true value, the mean of the estimates, 
the empirical standard error, the mean of the estimated standard errors 
(Mean SE), and the coverage probability for model parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jointSurroPenalSimul'
summary(object, d = 3, R2boot = 0, displayMSE = 0, printResult = 1, CP = 0,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.jointSurroPenalSimul_+3A_object">object</code></td>
<td>
<p>an object inheriting from <code>jointSurroPenalSimul</code> class.</p>
</td></tr>
<tr><td><code id="summary.jointSurroPenalSimul_+3A_d">d</code></td>
<td>
<p>The desired number of digits after the decimal point f. Default of 3</p>
</td></tr>
<tr><td><code id="summary.jointSurroPenalSimul_+3A_r2boot">R2boot</code></td>
<td>
<p>A binary that specifies whether the confidence interval of 
<code>R</code><sup>2</sup><sub>trial</sub> 
should be computed using parametric bootstrap (<code>1</code>) or Delta-method (<code>0</code>). 
The default is <code>0</code></p>
</td></tr>
<tr><td><code id="summary.jointSurroPenalSimul_+3A_displaymse">displayMSE</code></td>
<td>
<p>A binary that indicates if the results include bias and mean square errors (MSE), 
case 1, or the standard errors with the coverage percentage, case 0. By default this argument 
is set to 0. In the event of 1 the results just include the individual level and the trial level 
association measurements.</p>
</td></tr>
<tr><td><code id="summary.jointSurroPenalSimul_+3A_printresult">printResult</code></td>
<td>
<p>A binary that indicates if the summary of the results should be displayed <code>(1)</code>
or not <code>(0)</code>. If this argument is set to 0, resuls are just returned to the user</p>
</td></tr>
<tr><td><code id="summary.jointSurroPenalSimul_+3A_cp">CP</code></td>
<td>
<p>A binary that indicate in the event of <code>displayMSE = 1</code> if the percentage of coverage should be
display (1) or not (0). The default is 0</p>
</td></tr>
<tr><td><code id="summary.jointSurroPenalSimul_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For each parameter of the joint surrogate model , we print the true simulation value,  
the empirical standard error (empirical SE), the mean of the estimated standard errors 
(Mean SE), and the coverate probability (CP). 
For Kendall's <code class="reqn">\tau</code>, the 95% Confidence interval is obtained by 
parametric bootstrap (for joint frailty model) or Delta-method (for joint frailty-copula model). 
For 
<code>R</code><sup>2</sup><sub>trial</sub>(R2trial), the standard error is obtained
by Delta-method and the 95% Confidence interval could be obtained directly or by 
parametric bootstrap. We also display the total number of non convergence case with 
the associated percentage (R : n(%)), the mean number of iterations to reach convergence,
and other estimation and simulation parameters. We also return a dataframe of the simulations
results
.
</p>


<h3>Author(s)</h3>

<p>Casimir Ledoux Sofeu <a href="mailto:casimir.sofeu@u-bordeaux.fr">casimir.sofeu@u-bordeaux.fr</a>, <a href="mailto:scl.ledoux@gmail.com">scl.ledoux@gmail.com</a> and 
Virginie Rondeau <a href="mailto:virginie.rondeau@inserm.fr">virginie.rondeau@inserm.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSurroPenalSimul">jointSurroPenalSimul</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Studies simulation
## Not run: 
# (Computation takes around 45 minutes using a processor including 40
# cores and a read only memory of 378 Go)
joint.simul &lt;- jointSurroPenalSimul(nb.dataset = 10, nbSubSimul=600, 
                   ntrialSimul=30, LIMparam = 0.001, LIMlogl = 0.001, 
                   LIMderiv = 0.001, nb.mc = 200, nb.gh = 20, 
                   nb.gh2 = 32, true.init.val = 1, print.iter=F)

# results
summary(joint.simul, d = 3, R2boot = 1) # bootstrap
summary(joint.simul, d = 3, R2boot = 0) # Delta-method


## End(Not run)


</code></pre>

<hr>
<h2 id='summary.longiPenal'>Short summary of fixed covariates estimates of a joint model for
longitudinal data and a terminal event.</h2><span id='topic+summary.longiPenal'></span><span id='topic+print.summary.longiPenal'></span>

<h3>Description</h3>

<p>This function returns coefficients estimates and their standard error with
p-values of the Wald test for the longitudinal outcome and hazard ratios
(HR) and their confidence intervals for the terminal event.  If a mediation analysis 
was performed (option <code>mediation</code> set to <code>TRUE</code> in <code><a href="#topic+longiPenal">longiPenal</a></code>) 
this function displays estimations of the related quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'longiPenal'
summary(object, level = 0.95, len = 6, d = 2,
lab=c("coef","hr"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.longiPenal_+3A_object">object</code></td>
<td>
<p>an object inheriting from <code>longiPenal</code> class</p>
</td></tr>
<tr><td><code id="summary.longiPenal_+3A_level">level</code></td>
<td>
<p>significance level of confidence interval. Default is 95%.</p>
</td></tr>
<tr><td><code id="summary.longiPenal_+3A_len">len</code></td>
<td>
<p>the total field width for the terminal part. Default is 6.</p>
</td></tr>
<tr><td><code id="summary.longiPenal_+3A_d">d</code></td>
<td>
<p>the desired number of digits after the decimal point. Default of 6
digits is used.</p>
</td></tr>
<tr><td><code id="summary.longiPenal_+3A_lab">lab</code></td>
<td>
<p>labels of printed results for the longitudinal outcome and the
terminal event respectively.</p>
</td></tr>
<tr><td><code id="summary.longiPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the longitudinal outcome it prints the estimates of coefficients
of the fixed covariates with their standard error and p-values of the Wald
test. For the terminal event it prints HR and its confidence intervals for
each covariate. Confidence level is allowed (level argument).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+longiPenal">longiPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
###--- Joint model for longitudinal data and a terminal event ---###

data(colorectal)
data(colorectalLongi)

# Survival data preparation - only terminal events 
colorectalSurv &lt;- subset(colorectal, new.lesions == 0)

# Baseline hazard function approximated with splines
# Random effects as the link function

model.spli.RE &lt;- longiPenal(Surv(time1, state) ~ age + treatment + who.PS 
+ prev.resection, tumor.size ~  year * treatment + age + who.PS ,
colorectalSurv,	data.Longi = colorectalLongi, random = c("1", "year"),
id = "id", link = "Random-effects", left.censoring = -3.33, 
n.knots = 7, kappa = 2)

# Weibull baseline hazard function
# Current level of the biomarker as the link function

model.weib.CL &lt;- longiPenal(Surv(time1, state) ~ age + treatment + who.PS
+ prev.resection, tumor.size ~  year * treatment + age + who.PS , 
colorectalSurv, data.Longi = colorectalLongi, random = c("1", "year"),
id = "id", link = "Current-level", left.censoring = -3.33, hazard = "Weibull")
	
summary(model.spli.RE)
summary(model.weib.CL)

## End(Not run)


</code></pre>

<hr>
<h2 id='summary.multivPenal'>summary of parameter estimates of a multivariate frailty model.</h2><span id='topic+summary.multivPenal'></span>

<h3>Description</h3>

<p>This function returns hazard ratio (HR) and its confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multivPenal'
summary(object, level = 0.95, len = 6, d = 2, lab
= "hr", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.multivPenal_+3A_object">object</code></td>
<td>
<p>output from a call to multivPenal for joint multivariate
models</p>
</td></tr>
<tr><td><code id="summary.multivPenal_+3A_level">level</code></td>
<td>
<p>significance level of confidence interval. Default is 95%.</p>
</td></tr>
<tr><td><code id="summary.multivPenal_+3A_len">len</code></td>
<td>
<p>the total field width. Default is 6.</p>
</td></tr>
<tr><td><code id="summary.multivPenal_+3A_d">d</code></td>
<td>
<p>the desired number of digits after the decimal point. Default of 6
digits is used.</p>
</td></tr>
<tr><td><code id="summary.multivPenal_+3A_lab">lab</code></td>
<td>
<p>label of printed results.</p>
</td></tr>
<tr><td><code id="summary.multivPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints HR and its confidence intervals for each covariate.
Confidence level is allowed (level argument)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multivPenal">multivPenal</a></code>
</p>

<hr>
<h2 id='summary.nestedPenal'>summary of regression coefficient estimates of a nested frailty model</h2><span id='topic+summary.nestedPenal'></span><span id='topic+print.summary.nestedPenal'></span>

<h3>Description</h3>

<p>This function returns hazard rations (HR) and its confidence intervals for
each regression coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nestedPenal'
summary(object, level = 0.95, len = 6, d = 2,
lab="hr", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.nestedPenal_+3A_object">object</code></td>
<td>
<p>output from a call to nestedPenal.</p>
</td></tr>
<tr><td><code id="summary.nestedPenal_+3A_level">level</code></td>
<td>
<p>significance level of confidence interval. Default is 95%.</p>
</td></tr>
<tr><td><code id="summary.nestedPenal_+3A_len">len</code></td>
<td>
<p>the total field width. Default is 6.</p>
</td></tr>
<tr><td><code id="summary.nestedPenal_+3A_d">d</code></td>
<td>
<p>the desired number of digits after the decimal point. Default of 6
digits is used.</p>
</td></tr>
<tr><td><code id="summary.nestedPenal_+3A_lab">lab</code></td>
<td>
<p>label of printed results.</p>
</td></tr>
<tr><td><code id="summary.nestedPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints HR and its confidence intervals for each regression
coefficient. Confidence level is allowed (level argument).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

data(dataNested)

modNested &lt;- frailtyPenal(Surv(t1,t2,event)~cluster(group)+
subcluster(subgroup)+cov1+cov2,data=dataNested,
n.knots=8,kappa=c(50000,50000),hazard="Splines")

#- It takes 90 minutes to converge (depends on processor)

summary(modNested)


## End(Not run)


</code></pre>

<hr>
<h2 id='summary.trivPenal'>Short summary of fixed covariates estimates of a joint model for
longitudinal data, recurrent events and a terminal event</h2><span id='topic+summary.trivPenal'></span><span id='topic+print.summary.trivPenal'></span>

<h3>Description</h3>

<p>This function returns coefficients estimates and their standard error with
p-values of the Wald test for the longitudinal outcome and hazard ratios
(HR) and their confidence intervals for the terminal event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trivPenal'
summary(object, level = 0.95, len = 6, d = 2,
lab=c("coef","hr"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.trivPenal_+3A_object">object</code></td>
<td>
<p>an object inheriting from <code>trivPenal</code> class</p>
</td></tr>
<tr><td><code id="summary.trivPenal_+3A_level">level</code></td>
<td>
<p>significance level of confidence interval. Default is 95%.</p>
</td></tr>
<tr><td><code id="summary.trivPenal_+3A_len">len</code></td>
<td>
<p>the total field width for the terminal part. Default is 6.</p>
</td></tr>
<tr><td><code id="summary.trivPenal_+3A_d">d</code></td>
<td>
<p>the desired number of digits after the decimal point. Default of 6
digits is used.</p>
</td></tr>
<tr><td><code id="summary.trivPenal_+3A_lab">lab</code></td>
<td>
<p>labels of printed results for the longitudinal outcome and the
terminal event respectively.</p>
</td></tr>
<tr><td><code id="summary.trivPenal_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the longitudinal outcome it prints the estimates of coefficients
of the fixed covariates with their standard error and p-values of the Wald
test. For the terminal event it prints HR and its confidence intervals for
each covariate. Confidence level is allowed (level argument).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trivPenal">trivPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

###--- Trivariate joint model for longitudinal data, ---###
###--- recurrent events and a terminal event ---###

data(colorectal)
data(colorectalLongi)

# Weibull baseline hazard function
# Random effects as the link function, Gap timescale
# (computation takes around 30 minutes)
model.weib.RE.gap &lt;-trivPenal(Surv(gap.time, new.lesions) ~ cluster(id)
+ age + treatment + who.PS + prev.resection + terminal(state),
formula.terminalEvent =~ age + treatment + who.PS + prev.resection, 
tumor.size ~ year * treatment + age + who.PS, data = colorectal,
data.Longi = colorectalLongi, random = c("1", "year"), id = "id", 
link = "Random-effects", left.censoring = -3.33, recurrentAG = FALSE,
hazard = "Weibull", method.GH="Pseudo-adaptive", n.nodes = 7)

summary(model.weib.RE.gap)

## End(Not run)


</code></pre>

<hr>
<h2 id='summary.trivPenalNL'>Short summary of fixed covariates estimates of a non-linear trivariate joint
model for longitudinal data, recurrent events and a terminal event</h2><span id='topic+summary.trivPenalNL'></span><span id='topic+print.summary.trivPenalNL'></span>

<h3>Description</h3>

<p>This function returns coefficients estimates and their standard error with
p-values of the Wald test for the biomarker growth (KG) and decline (KD) and
hazard ratios and their confidence intervals for the terminal event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trivPenalNL'
summary(object, level = 0.95, len = 6, d = 2,
lab=c("coef","hr"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.trivPenalNL_+3A_object">object</code></td>
<td>
<p>an object inheriting from <code>trivPenal</code> class</p>
</td></tr>
<tr><td><code id="summary.trivPenalNL_+3A_level">level</code></td>
<td>
<p>significance level of confidence interval. Default is 95%.</p>
</td></tr>
<tr><td><code id="summary.trivPenalNL_+3A_len">len</code></td>
<td>
<p>the total field width for the terminal part. Default is 6.</p>
</td></tr>
<tr><td><code id="summary.trivPenalNL_+3A_d">d</code></td>
<td>
<p>the desired number of digits after the decimal point. Default of 6
digits is used.</p>
</td></tr>
<tr><td><code id="summary.trivPenalNL_+3A_lab">lab</code></td>
<td>
<p>labels of printed results for the longitudinal outcome and the
terminal event respectively.</p>
</td></tr>
<tr><td><code id="summary.trivPenalNL_+3A_...">...</code></td>
<td>
<p>other unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the longitudinal outcome it prints the estimates of coefficients
of the fixed covariates with their standard error and p-values of the Wald
test (separetely for the biomarker growth and decline).  For the terminal
event it prints HR and its confidence intervals for each covariate.
Confidence level is allowed (level argument).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trivPenalNL">trivPenalNL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

###--- Trivariate joint model for longitudinal data, ---###
###--- recurrent events and a terminal event ---###

data(colorectal)
data(colorectalLongi)

# Weibull baseline hazard function
# Random effects as the link function, Gap timescale
# (computation takes around 30 minutes)
model.weib.RE.gap &lt;-trivPenal(Surv(gap.time, new.lesions) ~ cluster(id)
+ age + treatment + who.PS + prev.resection + terminal(state),
formula.terminalEvent =~ age + treatment + who.PS + prev.resection, 
tumor.size ~ year * treatment + age + who.PS, data = colorectal,
data.Longi = colorectalLongi, random = c("1", "year"), id = "id", 
link = "Random-effects", left.censoring = -3.33, recurrentAG = FALSE,
hazard = "Weibull", method.GH="Pseudo-adaptive", n.nodes = 7)

summary(model.weib.RE.gap)

## End(Not run)


</code></pre>

<hr>
<h2 id='survDat'>Survival dataset (TPJM)</h2><span id='topic+survDat'></span>

<h3>Description</h3>

<p>This is a simulated dataset used to illustrate the two-part 
joint model included in the longiPenal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(survDat)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: 
</p>

<dl>
<dt>id</dt><dd><p>The identification number of a patient</p>
</dd>
<dt>deathTimes</dt><dd><p>The event times (death or censoring)</p>
</dd>
<dt>d</dt><dd><p>Censoring indicator</p>
</dd>
<dt>trt</dt><dd><p>Treatment covariate</p>
</dd>
</dl>


<hr>
<h2 id='SurvIC'>Create a survival object for interval censoring and possibly left truncated
data</h2><span id='topic+SurvIC'></span>

<h3>Description</h3>

<p>This is a function used in case of interval-censoring as a response variable
in a model formula only for Cox proportional hazard or shared frailty model.
Sometimes, an unobserved event might occur in a time interval [L,U].
RecurrentAG argument gets invalid with the use of SurvIC. Note that this
function used a Kronecker product which can suffer from computation issue
when the number of subjects in each cluster is high. Time dependent
variables are not allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurvIC(t0, lower, upper, event)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SurvIC_+3A_t0">t0</code></td>
<td>
<p>Truncation time for left truncated data only. To be ignored
otherwise.</p>
</td></tr>
<tr><td><code id="SurvIC_+3A_lower">lower</code></td>
<td>
<p>Starting time of the interval for interval-censored data. Time
of right-censoring instead.</p>
</td></tr>
<tr><td><code id="SurvIC_+3A_upper">upper</code></td>
<td>
<p>Ending time of the interval for interval-censored data. For
right-censored data, lower and upper time must be equal (for numerical
reason).</p>
</td></tr>
<tr><td><code id="SurvIC_+3A_event">event</code></td>
<td>
<p>Status indicator 0=right-censored, 1=interval-censored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typical usages are <code>SurvIC(lower,upper,event)</code> or
<code>SurvIC(t0,lower,upper,event)</code>
</p>


<h3>Value</h3>

<p>No return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



data(bcos)
bcos$event &lt;- ifelse(bcos$left!=bcos$right,1,0)

###---  Cox proportional hazard model with interval censoring ---###

cox.ic &lt;- frailtyPenal(SurvIC(left,right,event)~treatment,
data=bcos,n.knots=8,kappa=10000)

###---  Shared model with interval censoring ---###

bcos$group &lt;- c(rep(1:20,4),1:14)

sha.ic &lt;- frailtyPenal(SurvIC(left,right,event)~cluster(group)+
treatment,data=bcos,n.knots=8,kappa=10000)




</code></pre>

<hr>
<h2 id='survival'>Survival function</h2><span id='topic+survival'></span>

<h3>Description</h3>

<p>Let t be a continuous variable, we determine the value of the survival
function to t after run fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survival(t, ObjFrailty)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survival_+3A_t">t</code></td>
<td>
<p>time for survival function.</p>
</td></tr>
<tr><td><code id="survival_+3A_objfrailty">ObjFrailty</code></td>
<td>
<p>an object from the frailtypack fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return the value of survival function in t.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

#-- a fit Shared
data(readmission)

fit.shared &lt;- frailtyPenal(Surv(time,event)~dukes+cluster(id)+
strata(sex),n.knots=10,kappa=c(10000,10000),data=readmission)

#-- calling survival
survival(20,fit.shared)


## End(Not run)


</code></pre>

<hr>
<h2 id='terminal'>Identify terminal indicator</h2><span id='topic+terminal'></span>

<h3>Description</h3>

<p>This is a special function used in the context of recurrent event models
with terminal event (e.g., censoring variable related to recurrent events).
It contains the status indicator, normally 0=alive, 1=dead, and is used on
the right hand side of a formula of a 'frailtyPenal', 'longiPenal' and
'trivPenal' functions.  Using <code>terminal()</code> in a formula implies that a
joint frailty model for recurrent events and terminal events is fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terminal(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="terminal_+3A_x">x</code></td>
<td>
<p>A numeric variable but should be a Boolean which equals 1 if the
subject is dead and 0 if he is alive or censored, as a death indicator.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>a death indicator</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>

<hr>
<h2 id='timedep'>Identify time-varying effects</h2><span id='topic+timedep'></span>

<h3>Description</h3>


<p>This is a special function used in the context of Cox models and shared and
joint frailty models. It identifies time-varying effects of covariates in
the model. It is used in 'frailtyPenal' on the right hand side of formula or
of formula.terminalEvent.
</p>
<p>When considering time-varying effects in a survival model, regression
coefficients can be modeled with a linear combination of B-splines
<code class="reqn">B(t)</code> with coefficients <code class="reqn">\zeta</code> of order <code class="reqn">q</code> with <code class="reqn">m</code>
interior knots :
</p>
<p style="text-align: center;"><code class="reqn">\beta(t)=\sum_{j=-q+1}^m\zeta_jB_{j,q}(t)</code>
</p>

<p>You can notice that a linear combination of B-splines of order 1 without any
interior knots (0 interior knot) is the same as a model without time-varying
effect (or with constant effect over time).
</p>
<p>Statistical tests (likelihood ratio tests) can be done in order to know
whether the time-dependent coefficients are significantly different from
zero or to test whether a covariate has a time-dependent effect
significantly different from zero or not. These tests are correct only with
a parametric approach yet.
</p>
<p>- Proportional Hazard assumption ?
</p>
<p>Time-dependency of a covariate effect can be tested. We need to estimate
<code class="reqn">m+q</code> parameters <code class="reqn">\zeta_j</code> for <code class="reqn">j=-q+1,...,m</code> for a time-varying
coefficient. Only one (<code class="reqn">q=1</code>,<code class="reqn">m=0</code>) parameter is estimated for a
constant effect. A global test is done.
</p>
<p style="text-align: center;"><code class="reqn">H_0:\beta (t)=\beta</code>
</p>

<p>The corresponding LR statistic has a <code class="reqn">\chi^2</code> distribution of degree
<code class="reqn">m+q-1</code>.
</p>
<p>- Significant association ?
</p>
<p>We can also use a LR test to test whether a covariate has a significant
effect on the hazard function. The null hypothesis is :
</p>
<p style="text-align: center;"><code class="reqn">H_0:\beta (t)=0</code>
</p>

<p>For that we fit a model considering the covariate with a regression
coefficent modeled using B-splines and a model without the covariate. Hence,
the LR statistic has a <code class="reqn">\chi^2</code> distribution of degree <code class="reqn">m+q</code>.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>timedep(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timedep_+3A_x">x</code></td>
<td>
<p>A numerical or a factor variable that would have a time-varying
effect on the event</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>A variable identified with a time-varying effect</p>
</td></tr>
</table>


<h3>References</h3>

<p>Y. Mazroui, A. Mauguen, S. Mathoulin-Pelissier, G. MacGrogan, V.
Brouste, V. Rondeau (2013). Time-varying coefficients in a multivariate
frailty model: Application to breast cancer recurrences of several types and
death. To appear.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



data(readmission)

###--- Shared Frailty model with time-varying effect ---###

sha.time &lt;- frailtyPenal(Surv(time,event)~cluster(id)+dukes+charlson+
timedep(sex)+chemo,data=readmission,n.knots=8,kappa=1,
betaknots=3,betaorder=3)

#-- print results of the fit and the associated curves for the
#-- time-dependent effects
print(sha.time)

###--- Joint Frailty model with time-varying effect ---###

joi.time &lt;- frailtyPenal(Surv(time,event)~cluster(id)+timedep(sex)+
chemo+terminal(death),formula.terminalEvent=~timedep(sex)+chemo,
data=readmission,n.knots=8,kappa=c(1,1),betaknots=3,betaorder=3)

print(joi.time)




</code></pre>

<hr>
<h2 id='trivPenal'>Fit a Trivariate Joint Model for Longitudinal Data, Recurrent Events and a
Terminal Event</h2><span id='topic+trivPenal'></span>

<h3>Description</h3>


<p>Fit a trivariate joint model for longitudinal data, recurrent events and a
terminal event using a semiparametric penalized likelihood estimation or a
parametric estimation on the hazard functions.
</p>
<p>The longitudinal outcomes y<sub>i</sub>(t<sub>ik</sub>) (k=1,...,n<sub>i</sub>,
i=1,...,N) for N subjects are described by a linear mixed
model and the risks of the recurrent and terminal events are represented by
proportional hazard risk models. The joint model is constructed assuming
that the processes are linked via a latent structure (Krol et al. 2015):
</p>
<p><img src="../help/figures/trivmodel1.png" width="100%" alt="trivmodel1.png" />
</p>
<p>where <b><code class="reqn">X</code></b><sub>Li</sub>(t), <b><code class="reqn">X</code></b><sub>Rij</sub>(t) and
<b><code class="reqn">X</code></b><sub>Ti</sub>(t) are vectors of fixed effects covariates and
<b><code class="reqn">\beta</code></b><sub>L</sub>, <b><code class="reqn">\beta</code></b><sub>R</sub> and <b><code class="reqn">\beta</code></b><sub>T</sub> are the
associated coefficients. Measurements errors <code class="reqn">\epsilon</code><sub>i</sub>(t<sub>ik</sub>) are
iid normally distributed with mean 0 and variance <code class="reqn">\sigma</code><sub>\epsilon</sub><sup>2</sup>.
The random effects <b><code class="reqn">b</code></b><sub>i</sub> = (<code class="reqn">b</code><sub>0i</sub>,...,<code class="reqn">b</code><sub>qi</sub>)<sup>T</sup>
&#126; <b><code class="reqn">N</code></b>(0,<b><code class="reqn">B</code></b><sub>1</sub>) are associated to covariates <b><code class="reqn">Z</code></b><sub>i</sub>(t)
and independent from the measurement error. The relationship between the
biomarker and recurrent events is explained via
g(<b><code class="reqn">b</code></b><sub>i</sub>,<b><code class="reqn">\beta</code></b><sub>L</sub>,<b><code class="reqn">Z</code></b><sub>i</sub>(t),<b><code class="reqn">X</code></b><sub>Li</sub>(t)) with
coefficients <b><code class="reqn">\eta</code></b><sub>R</sub> and between the biomarker and terminal
event is explained via
h(<b><code class="reqn">b</code></b><sub>i</sub>,<b><code class="reqn">\beta</code></b><sub>L</sub>,<b><code class="reqn">Z</code></b><sub>i</sub>(t),<b><code class="reqn">X</code></b><sub>Li</sub>(t)) with
coefficients <b><code class="reqn">\eta</code></b><sub>T</sub>. Two forms of the functions g(.)
and h(.) are available: the random effects <code class="reqn">b</code><sub>i</sub> and
the current biomarker level <code class="reqn">m</code><sub>i</sub>(t)=<b><code class="reqn">X</code></b><sub>Li</sub>(t<sub>ik</sub>)<sup>T</sup><b><code class="reqn">\beta</code></b><sub>L</sub> + <b><code class="reqn">Z</code></b><sub>i</sub>(t<sub>ik</sub>)<sup>T</sup><b><code class="reqn">b</code></b><sub>i</sub>. The frailty term
v<sub>i</sub> is gaussian with mean 0 and variance <code class="reqn">\sigma</code><sub>v</sub>. Together with
<code class="reqn">b</code><sub>i</sub> constitutes the random effects of the model: 
</p>
<p><img src="../help/figures/trivmodel2.png" width="100%" alt="trivmodel2.png" />
</p>
<p>We consider that the longitudinal outcome can be a subject to a
quantification limit, i.e. some observations, below a level of detection
<code class="reqn">s</code> cannot be quantified (left-censoring).


</p>


<h3>Usage</h3>

<pre><code class='language-R'>trivPenal(formula, formula.terminalEvent, formula.LongitudinalData, data,
data.Longi, random, id, intercept = TRUE, link = "Random-effects",
left.censoring = FALSE, recurrentAG = FALSE, n.knots, kappa, maxit = 300,
hazard = "Splines", init.B, init.Random, init.Eta, init.Alpha, method.GH =
"Standard", n.nodes, LIMparam = 1e-3, LIMlogl = 1e-3, LIMderiv = 1e-3,
print.times = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trivPenal_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a
<code class="reqn">\sim</code> operator, and the terms on the right. The response must be a
survival object as returned by the 'Surv' function like in survival package.
Interactions are possible using * or :.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_formula.terminalevent">formula.terminalEvent</code></td>
<td>
<p>A formula object, only requires terms on the
right to indicate which variables are modelling the terminal event.
Interactions are possible using * or :.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_formula.longitudinaldata">formula.LongitudinalData</code></td>
<td>
<p>A formula object, only requires terms on the
right to indicate which variables are modelling the longitudinal outcome. It
must follow the standard form used for linear mixed-effects models.
Interactions are possible using * or :.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_data">data</code></td>
<td>
<p>A 'data.frame' with the variables used in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_data.longi">data.Longi</code></td>
<td>
<p>A 'data.frame' with the variables used in
<code>formula.LongitudinalData</code>.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_random">random</code></td>
<td>
<p>Names of variables for the random effects of the longitudinal
outcome. Maximum 3 random effects are possible at the moment. The random
intercept is chosen using <code>"1"</code>.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_id">id</code></td>
<td>
<p>Name of the variable representing the individuals.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_intercept">intercept</code></td>
<td>
<p>Logical value. Is the fixed intercept of the biomarker
included in the mixed-effects model? The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_link">link</code></td>
<td>
<p>Type of link functions for the dependence between the biomarker
and death and between the biomarker and the recurrent events:
<code>"Random-effects"</code> for the association directly via the random effects
of the biomarker, <code>"Current-level"</code> for the association via the true
current level of the biomarker. The option <code>"Current-level"</code> can be
chosen only if the biomarker random effects are associated with the
intercept and time (following this order). The default is
<code>"Random-effects"</code>.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_left.censoring">left.censoring</code></td>
<td>
<p>Is the biomarker left-censored below a threshold
<code class="reqn">s</code>? If there is no left-censoring, the argument must be equal to
<code>FALSE</code>, otherwise the value of the threshold must be given.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_recurrentag">recurrentAG</code></td>
<td>
<p>Logical value.  Is Andersen-Gill model fitted?  If so
indicates that recurrent event times with the counting process approach of
Andersen and Gill is used. This formulation can be used for dealing with
time-dependent covariates.  The default is FALSE.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_n.knots">n.knots</code></td>
<td>
<p>Integer giving the number of knots to use. Value required in
the penalized likelihood estimation.  It corresponds to the (n.knots+2)
splines functions for the approximation of the hazard or the survival
functions.  We estimate I or M-splines of order 4. When the user set a
number of knots equals to k (n.knots=k) then the number of interior knots is
(k-2) and the number of splines is (k-2)+order.  Number of knots must be
between 4 and 20. (See Note in <code>frailtyPenal</code> function)</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_kappa">kappa</code></td>
<td>
<p>Positive smoothing parameters in the penalized likelihood
estimation.  The coefficient kappa of the integral of the squared second
derivative of hazard function in the fit (penalized log likelihood). To
obtain an initial value for <code>kappa</code>, a solution is to fit the
corresponding Cox model using cross validation (See <code>cross.validation</code>
in function <code>frailtyPenal</code>).  We advise the user to identify several
possible tuning parameters, note their defaults and look at the sensitivity
of the results to varying them.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for the Marquardt algorithm.
Default is 300</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_hazard">hazard</code></td>
<td>
<p>Type of hazard functions: <code>"Splines"</code> for semiparametric
hazard functions using equidistant intervals or <code>"Splines-per"</code> using
percentile with the penalized likelihood estimation, <code>"Weibull"</code> for
the parametric Weibull functions. The default is <code>"Splines"</code>.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_init.b">init.B</code></td>
<td>
<p>Vector of initial values for regression coefficients. This
vector should be of the same size as the whole vector of covariates with the
first elements for the covariates related to the recurrent events, then to
the terminal event and then to the biomarker (interactions in the end of
each component). Default is 0.5 for each.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_init.random">init.Random</code></td>
<td>
<p>Initial value for variance of the elements of the matrix
of the distribution of the random effects.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_init.eta">init.Eta</code></td>
<td>
<p>Initial values for regression coefficients for the link
functions, first for the recurrent events (<code class="reqn">\bold{\eta}_R</code>) and for the
terminal event (<code class="reqn">\bold{\eta}_T</code>).</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_init.alpha">init.Alpha</code></td>
<td>
<p>Initial value for parameter alpha</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_method.gh">method.GH</code></td>
<td>
<p>Method for the Gauss-Hermite quadrature: <code>"Standard"</code>
for the standard non-adaptive Gaussian quadrature, <code>"Pseudo-adaptive"</code>
for the pseudo-adaptive Gaussian quadrature and <code>"HRMSYM"</code> for the
algorithm for the multivariate non-adaptive Gaussian quadrature (see
Details). The default is <code>"Standard"</code>.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_n.nodes">n.nodes</code></td>
<td>
<p>Number of nodes for the Gauss-Hermite quadrature. They can be
chosen amon 5, 7, 9, 12, 15, 20 and 32. The default is 9.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_limparam">LIMparam</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
parameters (see Details), <code class="reqn">10^{-3}</code> by default.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_limlogl">LIMlogl</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
log-likelihood (see Details), <code class="reqn">10^{-3}</code> by default.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_limderiv">LIMderiv</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
gradient (see Details), <code class="reqn">10^{-3}</code> by default.</p>
</td></tr>
<tr><td><code id="trivPenal_+3A_print.times">print.times</code></td>
<td>
<p>a logical parameter to print iteration process. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>Typical usage for the joint model
</p>
<pre>trivPenal(Surv(time,event)~cluster(id) + var1 + var2 +
terminal(death), formula.terminalEvent =~ var1 + var3, biomarker ~
var1+var2, data, data.Longi, ...)</pre>
<p>The method of the Gauss-Hermite quadrature for approximations of the
multidimensional integrals, i.e. length of <code>random</code> is 2, can be chosen
among the standard, non-adaptive, pseudo-adaptive in which the quadrature
points are transformed using the information from the fitted mixed-effects
model for the biomarker (Rizopoulos 2012) or multivariate non-adaptive
procedure proposed by Genz et al. 1996 and implemented in FORTRAN subroutine
HRMSYM.  The choice of the method is important for estimations. The standard
non-adaptive Gauss-Hermite quadrature (<code>"Standard"</code>) with a specific
number of points gives accurate results but can be time consuming. The
non-adaptive procedure (<code>"HRMSYM"</code>) offers advantageous computational
time but in case of datasets in which some individuals have few repeated
observations (biomarker measures or recurrent events), this method may be
moderately unstable.  The pseudo-adaptive quadrature uses transformed
quadrature points to center and scale the integrand by utilizing estimates
of the random effects from an appropriate linear mixed-effects model (this
transformation does not include the frailty in the trivariate model, for
which the standard method is used). This method enables using less
quadrature points while preserving the estimation accuracy and thus lead to
a better computational time.
</p>
<p>NOTE. Data frames <code>data</code> and <code>data.Longi</code> must be consistent.
Names and types of corresponding covariates must be the same, as well as the
number and identification of individuals.

</p>


<h3>Value</h3>

<p>The following components are included in a 'trivPenal' object for each
model:
</p>
<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>The sequence of the corresponding estimation of the coefficients
for the hazard functions (parametric or semiparametric), the random effects
variances and the regression coefficients.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The code used for
the model.</p>
</td></tr> <tr><td><code>formula</code></td>
<td>
<p>The formula part of the code used for the
recurrent event part of the model.</p>
</td></tr> <tr><td><code>formula.terminalEvent</code></td>
<td>
<p>The formula
part of the code used for the terminal event part of the model.</p>
</td></tr>
<tr><td><code>formula.LongitudinalData</code></td>
<td>
<p>The formula part of the code used for the
longitudinal part of the model.</p>
</td></tr> <tr><td><code>coef</code></td>
<td>
<p>The regression coefficients
(first for the recurrent events, then for the terminal event and then for
the biomarker.</p>
</td></tr> <tr><td><code>groups</code></td>
<td>
<p>The number of groups used in the fit.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>The values of the smoothing parameters in the penalized
likelihood estimation corresponding to the baseline hazard functions for the
recurrent and terminal events.</p>
</td></tr> <tr><td><code>logLikPenal</code></td>
<td>
<p>The complete marginal
penalized log-likelihood in the semiparametric case.</p>
</td></tr> <tr><td><code>logLik</code></td>
<td>
<p>The
marginal log-likelihood in the parametric case.</p>
</td></tr> <tr><td><code>n.measurements</code></td>
<td>
<p>The
number of biomarker observations used in the fit.</p>
</td></tr> <tr><td><code>max_rep</code></td>
<td>
<p>The
maximal number of repeated measurements per individual.</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>The number
of observations in 'data' (recurrent and terminal events) used in the fit.</p>
</td></tr>
<tr><td><code>n.events</code></td>
<td>
<p>The number of recurrent events observed in the fit.</p>
</td></tr>
<tr><td><code>n.deaths</code></td>
<td>
<p>The number of terminal events observed in the fit.</p>
</td></tr>
<tr><td><code>n.iter</code></td>
<td>
<p>The number of iterations needed to converge.</p>
</td></tr>
<tr><td><code>n.knots</code></td>
<td>
<p>The number of knots for estimating the baseline hazard
function in the penalized likelihood estimation.</p>
</td></tr> <tr><td><code>n.strat</code></td>
<td>
<p>The number
of stratum.</p>
</td></tr>
<tr><td><code>varH</code></td>
<td>
<p>The variance matrix of all parameters (before positivity
constraint transformation for the variance of the measurement error, for
which the delta method is used).</p>
</td></tr> <tr><td><code>varHIH</code></td>
<td>
<p>The robust estimation of the
variance matrix of all parameters.</p>
</td></tr>
<tr><td><code>xR</code></td>
<td>
<p>The vector of times where both survival and hazard function of the
recurrent events are estimated. By default seq(0,max(time),length=99), where
time is the vector of survival times.</p>
</td></tr> <tr><td><code>lamR</code></td>
<td>
<p>The array (dim=3) of
baseline hazard estimates and confidence bands (recurrent events).</p>
</td></tr>
<tr><td><code>survR</code></td>
<td>
<p>The array (dim=3) of baseline survival estimates and confidence
bands (recurrent events).</p>
</td></tr>
<tr><td><code>xD</code></td>
<td>
<p>The vector of times where both survival and hazard function of the
terminal event are estimated. By default seq(0,max(time),length=99), where
time is the vector of survival times.</p>
</td></tr> <tr><td><code>lamD</code></td>
<td>
<p>The array (dim=3) of
baseline hazard estimates and confidence bands.</p>
</td></tr> <tr><td><code>survD</code></td>
<td>
<p>The array
(dim=3) of baseline survival estimates and confidence bands.</p>
</td></tr> 
<tr><td><code>medianR</code></td>
<td>
<p>The value of the median survival and its confidence bands for the recurrent event.</p>
</td></tr>
<tr><td><code>medianD</code></td>
<td>
<p>The value of the median survival and its confidence bands for the terminal event.</p>
</td></tr>
<tr><td><code>typeof</code></td>
<td>
<p>The type of the baseline hazard function (0:&quot;Splines&quot;,
&quot;2:Weibull&quot;).</p>
</td></tr> <tr><td><code>npar</code></td>
<td>
<p>The number of parameters.</p>
</td></tr> <tr><td><code>nvar</code></td>
<td>
<p>The vector
of number of explanatory variables for the recurrent events, terminal event
and biomarker.</p>
</td></tr> <tr><td><code>nvarRec</code></td>
<td>
<p>The number of explanatory variables for the
recurrent events.</p>
</td></tr> <tr><td><code>nvarEnd</code></td>
<td>
<p>The number of explanatory variables for
the terminal event.</p>
</td></tr> <tr><td><code>nvarY</code></td>
<td>
<p>The number of explanatory variables for
the biomarker.</p>
</td></tr> <tr><td><code>noVarRec</code></td>
<td>
<p>The indicator of absence of the explanatory
variables for the recurrent events.</p>
</td></tr> <tr><td><code>noVarEnd</code></td>
<td>
<p>The indicator of
absence of the explanatory variables for the terminal event.</p>
</td></tr>
<tr><td><code>noVarY</code></td>
<td>
<p>The indicator of absence of the explanatory variables for the
biomarker.</p>
</td></tr> <tr><td><code>LCV</code></td>
<td>
<p>The approximated likelihood cross-validation
criterion in the semiparametric case (with H minus the converged Hessian
matrix, and l(.) the full
log-likelihood).</p>
<p style="text-align: center;"><code class="reqn">LCV=\frac{1}{n}(trace(H^{-1}_{pl}H) - l(.))</code>
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>The Akaike information Criterion for the parametric
case.</p>
<p style="text-align: center;"><code class="reqn">AIC=\frac{1}{n}(np - l(.))</code>
</p>
</td></tr> <tr><td><code>n.knots.temp</code></td>
<td>
<p>The initial
value for the number of knots.</p>
</td></tr> <tr><td><code>shape.weib</code></td>
<td>
<p>The shape parameter for
the Weibull hazard functions (the first element for the recurrences and the
second one for the terminal event).</p>
</td></tr> <tr><td><code>scale.weib</code></td>
<td>
<p>The scale parameter
for the Weibull hazard functions (the first element for the recurrences and
the second one for the terminal event).</p>
</td></tr> <tr><td><code>martingale.res</code></td>
<td>
<p>The
martingale residuals related to the recurrences for each individual.</p>
</td></tr>
<tr><td><code>martingaledeath.res</code></td>
<td>
<p>The martingale residuals related to the terminal
event for each individual.</p>
</td></tr> <tr><td><code>conditional.res</code></td>
<td>
<p>The conditional residuals
for the biomarker (subject-specific):
<code class="reqn">\bold{R}_i^{(m)}=\bold{y}_i-\bold{X}_{Li}^\top\widehat{\bold{\beta}}_L-\bold{Z}_i^\top\widehat{\bold{b}}_i</code>.</p>
</td></tr>
<tr><td><code>marginal.res</code></td>
<td>
<p>The marginal residuals for the biomarker (population
averaged):
<code class="reqn">\bold{R}_i^{(c)}=\bold{y}_i-\bold{X}_{Li}^\top\widehat{\bold{\beta}}_L</code>.</p>
</td></tr>
<tr><td><code>marginal_chol.res</code></td>
<td>
<p>The Cholesky marginal residuals for the biomarker:
<code class="reqn">\bold{R}_i^{(m)}=\widehat{\bold{U}_i^{(m)}}\bold{R}_i^{(m)}</code>, where
<code class="reqn">\widehat{\bold{U}_i^{(m)}}</code> is an upper-triangular matrix obtained by
the Cholesky decomposition of the variance matrix
<code class="reqn">\bold{V}_{\bold{R}_i^{(m)}}=\widehat{\bold{V}_i}-\bold{X}_{Li}(\sum_{i=1}^N\bold{X}_{Li}\widehat{\bold{V}_i}^{-1}\bold{X}_{Li})^{-1}\bold{X}_{Li}^\top</code>.</p>
</td></tr>
<tr><td><code>conditional_st.res</code></td>
<td>
<p>The standardized conditional residuals for the
biomarker.</p>
</td></tr> <tr><td><code>marginal_st.res</code></td>
<td>
<p>The standardized marginal residuals for
the biomarker.</p>
</td></tr> <tr><td><code>random.effects.pred</code></td>
<td>
<p> The empirical Bayes predictions
of the random effects (ie. using conditional posterior distributions).</p>
</td></tr>
<tr><td><code>frailty.pred</code></td>
<td>
<p>The empirical Bayes predictions of the frailty term (ie.
using conditional posterior distributions).</p>
</td></tr> <tr><td><code>pred.y.marg</code></td>
<td>
<p>The marginal
predictions of the longitudinal outcome.</p>
</td></tr> <tr><td><code>pred.y.cond</code></td>
<td>
<p>The conditional
(given the random effects) predictions of the longitudinal outcome.</p>
</td></tr>
<tr><td><code>linear.pred</code></td>
<td>
<p>The linear predictor for the recurrent events part.</p>
</td></tr>
<tr><td><code>lineardeath.pred</code></td>
<td>
<p>The linear predictor for the terminal event part.</p>
</td></tr>
<tr><td><code>global_chisqR</code></td>
<td>
<p>The vector with values of each multivariate Wald test
for the recurrent part.</p>
</td></tr> <tr><td><code>dof_chisqR</code></td>
<td>
<p>The vector with degrees of
freedom for each multivariate Wald test for the recurrent part.</p>
</td></tr>
<tr><td><code>global_chisq.testR</code></td>
<td>
<p>The binary variable equals to 0 when no
multivariate Wald is given, 1 otherwise (for the recurrent part).</p>
</td></tr>
<tr><td><code>p.global_chisqR</code></td>
<td>
<p>The vector with the p_values for each global
multivariate Wald test for the recurrent part.</p>
</td></tr>
<tr><td><code>global_chisqT</code></td>
<td>
<p>The vector with values of each multivariate Wald test
for the terminal part.</p>
</td></tr> <tr><td><code>dof_chisqT</code></td>
<td>
<p>The vector with degrees of freedom
for each multivariate Wald test for the terminal part.</p>
</td></tr>
<tr><td><code>global_chisq.testT</code></td>
<td>
<p>The binary variable equals to 0 when no
multivariate Wald is given, 1 otherwise (for the terminal part).</p>
</td></tr>
<tr><td><code>p.global_chisqT</code></td>
<td>
<p>The vector with the p_values for each global
multivariate Wald test for the terminal part.</p>
</td></tr>
<tr><td><code>global_chisqY</code></td>
<td>
<p>The vector with values of each multivariate Wald test
for the longitudinal part.</p>
</td></tr> <tr><td><code>dof_chisqY</code></td>
<td>
<p>The vector with degrees of
freedom for each multivariate Wald test for the longitudinal part.</p>
</td></tr>
<tr><td><code>global_chisq.testY</code></td>
<td>
<p>The binary variable equals to 0 when no
multivariate Wald is given, 1 otherwise (for the longitudinal part).</p>
</td></tr>
<tr><td><code>p.global_chisqY</code></td>
<td>
<p>The vector with the p_values for each global
multivariate Wald test for the longitudinal part.</p>
</td></tr>
<tr><td><code>names.factorR</code></td>
<td>
<p>The names of the &quot;as.factor&quot; variables for the
recurrent part.</p>
</td></tr> <tr><td><code>names.factorT</code></td>
<td>
<p>The names of the &quot;as.factor&quot; variables
for the terminal part.</p>
</td></tr> <tr><td><code>names.factorY</code></td>
<td>
<p>The names of the &quot;as.factor&quot;
variables for the longitudinal part.</p>
</td></tr>
<tr><td><code>AG</code></td>
<td>
<p>The logical value. Is Andersen-Gill model fitted? </p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>The logical value. Is the fixed intercept included in the
linear mixed-effects model?</p>
</td></tr> <tr><td><code>B1</code></td>
<td>
<p>The variance matrix of the random
effects for the longitudinal outcome.</p>
</td></tr> <tr><td><code>sigma2</code></td>
<td>
<p>The variance of the
frailty term (<code class="reqn">\sigma_v</code>).</p>
</td></tr> <tr><td><code>alpha</code></td>
<td>
<p>The coefficient <code class="reqn">\alpha</code>
associated with the frailty parameter in the terminal hazard function.</p>
</td></tr>
<tr><td><code>ResidualSE</code></td>
<td>
<p>The variance of the measurement error.</p>
</td></tr> <tr><td><code>etaR</code></td>
<td>
<p>The
regression coefficients for the link function <code class="reqn">g(\cdot)</code>.</p>
</td></tr>
<tr><td><code>etaT</code></td>
<td>
<p>The regression coefficients for the link function
<code class="reqn">h(\cdot)</code>.</p>
</td></tr> <tr><td><code>ne_re</code></td>
<td>
<p>The number of random effects b used in the
fit.</p>
</td></tr> <tr><td><code>names.re</code></td>
<td>
<p>The names of variables for the random effects
<code class="reqn">\bold{b}_i</code>.</p>
</td></tr> <tr><td><code>link</code></td>
<td>
<p>The name of the type of the link functions.</p>
</td></tr>
<tr><td><code>leftCensoring</code></td>
<td>
<p>The logical value. Is the longitudinal outcome
left-censored?</p>
</td></tr> <tr><td><code>leftCensoring.threshold</code></td>
<td>
<p>For the left-censored
biomarker, the value of the left-censoring threshold used for the fit.</p>
</td></tr>
<tr><td><code>prop.censored</code></td>
<td>
<p>The fraction of observations subjected to the
left-censoring.</p>
</td></tr>
<tr><td><code>methodGH</code></td>
<td>
<p>The Gaussian quadrature method used in the fit.</p>
</td></tr>
<tr><td><code>n.nodes</code></td>
<td>
<p>The number of nodes used for the Gaussian quadrature in the
fit.</p>
</td></tr>
<tr><td><code>alpha_p.value</code></td>
<td>
<p>p-value of the Wald test for the estimated coefficient
<code class="reqn">\alpha</code>.</p>
</td></tr> <tr><td><code>sigma2_p.value</code></td>
<td>
<p>p-value of the Wald test for the
estimated variance of the frailty term (<code class="reqn">\sigma_v</code>).</p>
</td></tr>
<tr><td><code>etaR_p.value</code></td>
<td>
<p>p-values of the Wald test for the estimated regression
coefficients for the link function <code class="reqn">g(\cdot)</code>.</p>
</td></tr>
<tr><td><code>etaT_p.value</code></td>
<td>
<p>p-values of the Wald test for the estimated regression
coefficients for the link function <code class="reqn">h(\cdot)</code>.</p>
</td></tr>
<tr><td><code>beta_p.value</code></td>
<td>
<p>p-values of the Wald test for the estimated regression
coefficients.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is recommended to initialize the parameter values using the results
from the reduced models (for example, <code>longiPenal</code> for the longitudinal
and terminal part and <code>frailtyPenal</code> for the recurrent part. See
example.
</p>


<h3>References</h3>

<p>A. Krol, A. Mauguen, Y. Mazroui, A. Laurent, S. Michiels and V. Rondeau
(2017). Tutorial in Joint Modeling and Prediction: A Statistical Software
for Correlated Longitudinal Outcomes, Recurrent Events and a Terminal Event.
<em>Journal of Statistical Software</em> <b>81</b>(3), 1-52.
</p>
<p>A. Krol, L. Ferrer, JP. Pignon, C. Proust-Lima, M. Ducreux, O. Bouche, S.
Michiels, V. Rondeau (2016). Joint Model for Left-Censored Longitudinal
Data, Recurrent Events and Terminal Event: Predictive Abilities of Tumor
Burden for Cancer Evolution with Application to the FFCD 2000-05 Trial.
<em>Biometrics</em> <b>72</b>(3) 907-16.
</p>
<p>D. Rizopoulos (2012). Fast fitting of joint models for longitudinal and
event time data using a pseudo-adaptive Gaussian quadrature rule.
<em>Computational Statistics and Data Analysis</em> <b>56</b>, 491-501.
</p>
<p>A. Genz and B. Keister (1996). Fully symmetric interpolatory rules for
multiple integrals over infinite regions with Gaussian weight. <em>Journal
of Computational and Applied Mathematics</em> <b>71</b>, 299-309.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.trivPenal">plot.trivPenal</a></code>,<code><a href="#topic+print.trivPenal">print.trivPenal</a></code>,<code><a href="#topic+summary.trivPenal">summary.trivPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

###--- Trivariate joint model for longitudinal data, ---###
###--- recurrent events and a terminal event ---###

data(colorectal)
data(colorectalLongi)

# Parameter initialisation for covariates - longitudinal and terminal part

# Survival data preparation - only terminal events 
colorectalSurv &lt;- subset(colorectal, new.lesions == 0)

initial.longi &lt;- longiPenal(Surv(time1, state) ~ age + treatment + who.PS 
+ prev.resection, tumor.size ~  year * treatment + age + who.PS ,
colorectalSurv,	data.Longi = colorectalLongi, random = c("1", "year"),
id = "id", link = "Random-effects", left.censoring = -3.33, 
n.knots = 6, kappa = 2, method.GH="Pseudo-adaptive",
 maxit=40, n.nodes=7)


# Parameter initialisation for covariates - recurrent part
initial.frailty &lt;- frailtyPenal(Surv(time0, time1, new.lesions) ~ cluster(id)
+ age + treatment + who.PS, data = colorectal,
recurrentAG = TRUE, RandDist = "LogN", n.knots = 6, kappa =2)


# Baseline hazard function approximated with splines
# Random effects as the link function, Calendar timescale
# (computation takes around 40 minutes)

model.spli.RE.cal &lt;-trivPenal(Surv(time0, time1, new.lesions) ~ cluster(id)
+ age + treatment + who.PS +  terminal(state),
formula.terminalEvent =~ age + treatment + who.PS + prev.resection, 
tumor.size ~ year * treatment + age + who.PS, data = colorectal, 
data.Longi = colorectalLongi, random = c("1", "year"), id = "id", 
link = "Random-effects", left.censoring = -3.33, recurrentAG = TRUE,
n.knots = 6, kappa=c(0.01, 2), method.GH="Standard", n.nodes = 7,
init.B = c(-0.07, -0.13, -0.16, -0.17, 0.42, #recurrent events covariates
-0.16, -0.14, -0.14, 0.08, 0.86, -0.24, #terminal event covariates
2.93, -0.28, -0.13, 0.17, -0.41, 0.23, 0.97, -0.61)) #biomarker covariates



# Weibull baseline hazard function
# Random effects as the link function, Gap timescale
# (computation takes around 30 minutes)
model.weib.RE.gap &lt;-trivPenal(Surv(gap.time, new.lesions) ~ cluster(id)
+ age + treatment + who.PS + prev.resection + terminal(state),
formula.terminalEvent =~ age + treatment + who.PS + prev.resection, 
tumor.size ~ year * treatment + age + who.PS, data = colorectal,
data.Longi = colorectalLongi, random = c("1", "year"), id = "id", 
link = "Random-effects", left.censoring = -3.33, recurrentAG = FALSE,
hazard = "Weibull", method.GH="Pseudo-adaptive",n.nodes=7)



## End(Not run)


</code></pre>

<hr>
<h2 id='trivPenalNL'>Fit a Non-Linear Trivariate Joint Model for Recurrent Events and a Terminal
Event with a Biomarker Described with an ODE Population Model</h2><span id='topic+trivPenalNL'></span>

<h3>Description</h3>


<p>Fit a non-linear trivariate joint model for a longitudinal biomarker,
recurrent events and a terminal event using a semiparametric penalized
likelihood estimation or a parametric estimation on the hazard functions.
</p>
<p>The values y<sub>i</sub>(t) (i=1,...,N) for N subjects represent
the individual evolution of the biomarker e.g. tumor size expressed as the
sum of the longest diameters (SLD) of target lesions. The dynamics of the
biomarker are described by an ordinary differential equation (ODE) that
includes the effect of the natural net growth and the treatment effect:
</p>
<p><img src="../help/figures/trivNLmodel1.png" width="100%" alt="trivNLmodel1.png" />
</p>
<p>The model includes the following parameters (using the interpretation of
tumor dynamics): exp(<code class="reqn">K</code><sub>G,0</sub>) the constant tumor growth rate,
exp(<code class="reqn">K</code><sub>D,0</sub>) the drug-induced tumor decline rate, <code class="reqn">\lambda</code>
resistance effect to drug (exponential tumor decay change with time),
exp(y<sub>0</sub>) the initial level of the biomarker and d<sub>i</sub> is the
treatment concentration (e.g dose). The random effects <b>b</b><sub>i</sub><sup>T</sup>
= (b<sub>y0,i</sub>,b<sub>G,i</sub>,b<sub>D,i</sub>,b<sub>\lambda,i</sub>)<sup>T</sup> are gaussian variables
with a diagonal covariance matrix <b>B</b><sub>i</sub>. In the trivariate model
we use the analytical solution of the equation with the population-based
approach of the non-linear mixed effects model. We can also assume a
transformation for the observations of the biomarker (one parameter Box-Cox
transformation) and we include a gaussian measurement error, for individual
i and observation k (k=1,...,n<sub>i</sub>),
<code class="reqn">\epsilon</code><sub>ik</sub> &#126; <b><code class="reqn">N</code></b>(0,<code class="reqn">\sigma</code><sub>\epsilon</sub><sup>2</sup>).
</p>
<p>The risks of the recurrent (r<sub>ij</sub>(.) the risk of the j<sup>th</sup>
event of the individual i) and terminal events (<code class="reqn">\lambda</code><sub>i</sub> the
risk of the event of the individual i) are represented by proportional
hazard risk models. The joint model is constructed assuming that the
processes are linked via a latent structure and includes the non-linear
mixed effects model for the longitudinal data:
</p>
<p><img src="../help/figures/trivNLmodel2.png" width="100%" alt="trivNLmodel2.png" />
</p>
<p>where <b><code class="reqn">X</code></b><sub>G,i</sub>(t), <b><code class="reqn">X</code></b><sub>D,i</sub>(t),
<b><code class="reqn">X</code></b><sub>R,ij</sub>(t) and <b><code class="reqn">X</code></b><sub>T,i</sub>(t) are vectors of possible
time-varying fixed effects covariates and <b><code class="reqn">\beta</code></b><sub>G</sub>,
<b><code class="reqn">\beta</code></b><sub>D</sub>, <b><code class="reqn">\beta</code></b><sub>R</sub> and <b><code class="reqn">\beta</code></b><sub>T</sub> are the
associated coefficients. The random effects <b>b</b><sub>i</sub> are independent
from the measurement error. The relationship between the biomarker and
recurrent events is explained via g(y<sub>i</sub>(t)) with coefficients
<b><code class="reqn">\eta</code></b><sub>R</sub> and between the biomarker and terminal event is
explained via h(y<sub>i</sub>(t)) with coefficients <b><code class="reqn">\eta</code></b><sub>T</sub>.
Currently, only one form of the functions g(.) and h(.)
is available: the random effects <b>b</b><sub>i</sub>. The frailty term
v<sub>i</sub> is gaussian with mean 0 and variance <code class="reqn">\sigma</code><sub>v</sub>. Together with
<b>b</b><sub>i</sub> constitutes the random effects of the model: 
</p>
<p><img src="../help/figures/trivNLmodel3.png" width="100%" alt="trivNLmodel3.png" />
</p>
<p>Any combination of the random effects <b>b</b><sub>i</sub>, e.g.
<b>b</b><sub>i</sub>=b<sub>y0,i</sub> or <b>b</b><sub>i</sub> =
{b<sub>G,i</sub>,b<sub>D,i</sub>,b<sub>\lambda,i</sub>} can be chosen for the model.
</p>
<p>We consider that the longitudinal outcome can be a subject to a
quantification limit, i.e. some observations, below a level of detection
s cannot be quantified (left-censoring).



</p>


<h3>Usage</h3>

<pre><code class='language-R'>trivPenalNL(formula, formula.terminalEvent, biomarker, formula.KG,
formula.KD, dose, time.biomarker, data, data.Longi, random, id, link =
"Random-effects", BoxCox = FALSE, left.censoring = FALSE, recurrentAG =
FALSE, n.knots, kappa, maxit = 300, hazard = "Splines", init.B, init.Random,
init.Eta, init.Alpha, init.Biomarker, method.GH = "Standard", init.GH =
FALSE, n.nodes, LIMparam = 1e-3, LIMlogl = 1e-3, LIMderiv = 1e-3,
print.times = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trivPenalNL_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a
<code class="reqn">\sim</code> operator, and the terms on the right. The response must be a
survival object as returned by the 'Surv' function like in survival package.
Interactions are possible using * or :.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_formula.terminalevent">formula.terminalEvent</code></td>
<td>
<p>A formula object, only requires terms on the
right to indicate which variables are modelling the terminal event.
Interactions are possible using * or :.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_biomarker">biomarker</code></td>
<td>
<p>Name of the variable representing the longitudinal
biomarker.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_formula.kg">formula.KG</code></td>
<td>
<p>A formula object, only requires terms on the right to
indicate which covariates related to the biomarker growth are included in
the longitudinal sub-model.  It must follow the standard form used for
linear mixed-effects models. Interactions are possible using * or :.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_formula.kd">formula.KD</code></td>
<td>
<p>A formula object, only requires terms on the right to
indicate which covariates related to the biomarker drug-induced decline are
included in the longitudinal sub-model.  It must follow the standard form
used for linear mixed-effects models. Interactions are possible using * or
:.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_dose">dose</code></td>
<td>
<p>Name of the variable representing the drug concentration
indicator.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_time.biomarker">time.biomarker</code></td>
<td>
<p>Name of the variable of times of biomarker
measurements.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_data">data</code></td>
<td>
<p>A 'data.frame' with the variables used in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_data.longi">data.Longi</code></td>
<td>
<p>A 'data.frame' with the variables used in
<code>formula.KG</code>, <code>formula.KD</code>, <code>biomarker</code>, <code>dose</code>,
<code>time.biomarker</code> and <code>id</code>.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_random">random</code></td>
<td>
<p>Names of parameters for which the random effects are included
in the mixed model. The names must be chosen among <code>"y0"</code>, <code>"KG"</code>,
<code>"KD"</code> and <code>"lambda"</code>. Any combination of the mentioned names is
allowed.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_id">id</code></td>
<td>
<p>Name of the variable representing the individuals.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_link">link</code></td>
<td>
<p>Type of link functions for the dependence between the biomarker
and death and between the biomarker and the recurrent events: only
<code>"Random-effects"</code> for the association directly via the random effects
of the biomarker is allowed for the moment (option for a future extension).</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_boxcox">BoxCox</code></td>
<td>
<p>Should the Box-Cox transformation be used for the longitudinal
biomarker? If there is no transformation, the argument must be equal to
<code>FALSE</code>, otherwise the of the transformation parameter must be given,
then the transformed values are <code class="reqn">y^*=(y^{\xi}-1)/\xi</code>, where <code class="reqn">\xi</code>
is the Box-Cox parameter.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_left.censoring">left.censoring</code></td>
<td>
<p>Is the biomarker left-censored below a threshold
<code class="reqn">s</code>? If there is no left-censoring, the argument must be equal to
<code>FALSE</code>, otherwise the value of the threshold must be given.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_recurrentag">recurrentAG</code></td>
<td>
<p>Logical value.  Is Andersen-Gill model fitted?  If so
indicates that recurrent event times with the counting process approach of
Andersen and Gill is used. This formulation can be used for dealing with
time-dependent covariates.  The default is FALSE.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_n.knots">n.knots</code></td>
<td>
<p>Integer giving the number of knots to use. Value required in
the penalized likelihood estimation.  It corresponds to the (n.knots+2)
splines functions for the approximation of the hazard or the survival
functions.  We estimate I or M-splines of order 4. When the user set a
number of knots equals to k (n.knots=k) then the number of interior knots is
(k-2) and the number of splines is (k-2)+order.  Number of knots must be
between 4 and 20. (See Note in <code>frailtyPenal</code> function)</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_kappa">kappa</code></td>
<td>
<p>Positive smoothing parameters in the penalized likelihood
estimation.  The coefficient kappa of the integral of the squared second
derivative of hazard function in the fit (penalized log likelihood). To
obtain an initial value for <code>kappa</code>, a solution is to fit the
corresponding Cox model using cross validation (See <code>cross.validation</code>
in function <code>frailtyPenal</code>).  We advise the user to identify several
possible tuning parameters, note their defaults and look at the sensitivity
of the results to varying them.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for the Marquardt algorithm.
Default is 300</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_hazard">hazard</code></td>
<td>
<p>Type of hazard functions: <code>"Splines"</code> for semiparametric
hazard functions using equidistant intervals or <code>"Splines-per"</code> using
percentile with the penalized likelihood estimation, <code>"Weibull"</code> for
the parametric Weibull functions. The default is <code>"Splines"</code>.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_init.b">init.B</code></td>
<td>
<p>Vector of initial values for regression coefficients. This
vector should be of the same size as the whole vector of covariates with the
first elements for the covariates related to the recurrent events, then to
the terminal event and then to the biomarker (interactions in the end of
each component). Default is 0.5 for each.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_init.random">init.Random</code></td>
<td>
<p>Initial value for variance of the elements of the matrix
of the distribution of the random effects.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_init.eta">init.Eta</code></td>
<td>
<p>Initial values for regression coefficients for the link
functions, first for the recurrent events (<code class="reqn">\bold{\eta}_R</code>) and for the
terminal event (<code class="reqn">\bold{\eta}_T</code>).</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_init.alpha">init.Alpha</code></td>
<td>
<p>Initial value for parameter alpha</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_init.biomarker">init.Biomarker</code></td>
<td>
<p>Initial values for biomarker parameters: <code class="reqn">y_0</code>,
<code class="reqn">K_{G,0}</code>, <code class="reqn">K_{D,0}</code> and <code class="reqn">\lambda</code> (using this order).</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_method.gh">method.GH</code></td>
<td>
<p>Method for the Gauss-Hermite quadrature: <code>"Standard"</code>
for the standard non-adaptive Gaussian quadrature and
<code>"Pseudo-adaptive"</code> for the pseudo-adaptive Gaussian quadrature (see
Details). The default is <code>"Standard"</code>.  When the option
<code>"Pseudo-adaptive"</code> is chosen, then a univariate model (non-linear
mixed model for the biomarker) is fitted in order to obtain the estimations
of the random effects <code class="reqn">\bold{b}_i</code>.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_init.gh">init.GH</code></td>
<td>
<p>Only when the opiton <code>"Pseudo-adaptive"</code> of the argument
<code>method.GH</code> is chosen. If <code>TRUE</code>, the estimations of the biomarker
parameters (<code class="reqn">y_0</code>, <code class="reqn">K_{G,0}</code>, <code class="reqn">K_{D,0}</code> and <code class="reqn">\lambda</code>),
<code class="reqn">\sigma_{\epsilon}</code>, <code class="reqn">\bold{\beta}_G</code> and <code class="reqn">\bold{\beta}_D</code> from
the univariate mixed model are used as the initial values of the parameters
related to the biomarker.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_n.nodes">n.nodes</code></td>
<td>
<p>Number of nodes for the Gauss-Hermite quadrature (from 5 to
32). The default is 9.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_limparam">LIMparam</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
parameters (see Details), <code class="reqn">10^{-3}</code> by default.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_limlogl">LIMlogl</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
log-likelihood (see Details), <code class="reqn">10^{-3}</code> by default.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_limderiv">LIMderiv</code></td>
<td>
<p>Convergence threshold of the Marquardt algorithm for the
gradient (see Details), <code class="reqn">10^{-3}</code> by default.</p>
</td></tr>
<tr><td><code id="trivPenalNL_+3A_print.times">print.times</code></td>
<td>
<p>a logical parameter to print iteration process. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>Typical usage for the joint model
</p>
<pre>trivPenalNL(Surv(time,event)~cluster(id) + var1 + var2 +
terminal(death), formula.terminalEvent =~ var1 + var3, biomarker =
"biomarker.name", dose = "dose.name", time.biomarker = "time", formula.KG ~
var1, formula.KD ~ var2, data, data.Longi, ...)</pre>
<p>The method of the Gauss-Hermite quadrature for approximations of the
multidimensional integrals, i.e. length of <code>random</code> more than 2, can be
chosen among the standard (non-adaptive) and pseudo-adaptive in which the
quadrature points are transformed using the information from the fitted
mixed-effects model for the biomarker (Rizopoulos 2012) or multivariate
non-adaptive procedure proposed by Genz et al. 1996 and implemented in
FORTRAN subroutine HRMSYM.  The choice of the method is important for
estimations. The standard non-adaptive Gauss-Hermite quadrature
(<code>"Standard"</code>) with a specific number of points gives accurate results
but can be time consuming.  The pseudo-adaptive quadrature uses transformed
quadrature points to center and scale the integrand by utilizing estimates
of the random effects from an appropriate non-linear mixed-effects model
(this transformation does not include the frailty in the trivariate model,
for which the standard method, with 20 quadrature points, is used). This
method enables using less quadrature points while preserving the estimation
accuracy and thus lead to a better computational time.
</p>
<p>NOTE. Data frames <code>data</code> and <code>data.Longi</code> must be consistent.
Names and types of corresponding covariates must be the same, as well as the
number and identification of individuals.

</p>


<h3>Value</h3>

<p>The following components are included in a 'trivPenalNL' object for each
model:
</p>
<table role = "presentation">
<tr><td><code>b</code></td>
<td>
<p>The sequence of the corresponding estimation of the coefficients
for the hazard functions (parametric or semiparametric), the random effects
variances and the regression coefficients.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The code used for
the model.</p>
</td></tr> <tr><td><code>formula</code></td>
<td>
<p>The formula part of the code used for the
recurrent event part of the model.</p>
</td></tr> <tr><td><code>formula.terminalEvent</code></td>
<td>
<p>The formula
part of the code used for the terminal event part of the model.</p>
</td></tr>
<tr><td><code>formula.KG</code></td>
<td>
<p>The formula part of the code used for the longitudinal
part of the model, for the biomarker growth dynamics.</p>
</td></tr> <tr><td><code>formula.KD</code></td>
<td>
<p>The
formula part of the code used for the longitudinal part of the model, for
the biomarker decline dynamics.</p>
</td></tr> <tr><td><code>coef</code></td>
<td>
<p>The regression coefficients
(first for the recurrent events, then for the terminal event, then for the
biomarker growth and then for the biomarker decline.</p>
</td></tr> <tr><td><code>groups</code></td>
<td>
<p>The
number of groups used in the fit.</p>
</td></tr> <tr><td><code>kappa</code></td>
<td>
<p>The values of the smoothing
parameters in the penalized likelihood estimation corresponding to the
baseline hazard functions for the recurrent and terminal events.</p>
</td></tr>
<tr><td><code>logLikPenal</code></td>
<td>
<p>The complete marginal penalized log-likelihood in the
semiparametric case.</p>
</td></tr> <tr><td><code>logLik</code></td>
<td>
<p>The marginal log-likelihood in the
parametric case.</p>
</td></tr> <tr><td><code>n.measurements</code></td>
<td>
<p>The number of biomarker observations
used in the fit.</p>
</td></tr> <tr><td><code>max_rep</code></td>
<td>
<p>The maximal number of repeated measurements
per individual.</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>The number of observations in 'data' (recurrent
and terminal events) used in the fit.</p>
</td></tr> <tr><td><code>n.events</code></td>
<td>
<p>The number of
recurrent events observed in the fit.</p>
</td></tr> <tr><td><code>n.deaths</code></td>
<td>
<p>The number of
terminal events observed in the fit.</p>
</td></tr> <tr><td><code>n.iter</code></td>
<td>
<p>The number of iterations
needed to converge.</p>
</td></tr> <tr><td><code>n.knots</code></td>
<td>
<p>The number of knots for estimating the
baseline hazard function in the penalized likelihood estimation.</p>
</td></tr>
<tr><td><code>n.strat</code></td>
<td>
<p>The number of stratum.</p>
</td></tr>
<tr><td><code>varH</code></td>
<td>
<p>The variance matrix of all parameters (before positivity
constraint transformation for the variance of the measurement error, for
which the delta method is used).</p>
</td></tr> <tr><td><code>varHIH</code></td>
<td>
<p>The robust estimation of the
variance matrix of all parameters.</p>
</td></tr>
<tr><td><code>xR</code></td>
<td>
<p>The vector of times where both survival and hazard function of the
recurrent events are estimated. By default seq(0,max(time),length=99), where
time is the vector of survival times.</p>
</td></tr> <tr><td><code>lamR</code></td>
<td>
<p>The array (dim=3) of
baseline hazard estimates and confidence bands (recurrent events).</p>
</td></tr>
<tr><td><code>survR</code></td>
<td>
<p>The array (dim=3) of baseline survival estimates and confidence
bands (recurrent events).</p>
</td></tr>
<tr><td><code>xD</code></td>
<td>
<p>The vector of times where both survival and hazard function of the
terminal event are estimated. By default seq(0,max(time),length=99), where
time is the vector of survival times.</p>
</td></tr> <tr><td><code>lamD</code></td>
<td>
<p>The array (dim=3) of
baseline hazard estimates and confidence bands.</p>
</td></tr> <tr><td><code>survD</code></td>
<td>
<p>The array
(dim=3) of baseline survival estimates and confidence bands.</p>
</td></tr>
<tr><td><code>medianR</code></td>
<td>
<p>The value of the median survival and its confidence bands for the recurrent event.</p>
</td></tr>
<tr><td><code>medianD</code></td>
<td>
<p>The value of the median survival and its confidence bands for the terminal event.</p>
</td></tr>
<tr><td><code>typeof</code></td>
<td>
<p>The type of the baseline hazard function (0:&quot;Splines&quot;,
&quot;2:Weibull&quot;).</p>
</td></tr> <tr><td><code>npar</code></td>
<td>
<p>The number of parameters.</p>
</td></tr> <tr><td><code>nvar</code></td>
<td>
<p>The vector
of number of explanatory variables for the recurrent events, terminal event,
biomarker growth and biomarker decline.</p>
</td></tr> <tr><td><code>nvarRec</code></td>
<td>
<p>The number of
explanatory variables for the recurrent events.</p>
</td></tr> <tr><td><code>nvarEnd</code></td>
<td>
<p>The number
of explanatory variables for the terminal event.</p>
</td></tr> <tr><td><code>nvarKG</code></td>
<td>
<p>The number
of explanatory variables for the biomarker growth.</p>
</td></tr> <tr><td><code>nvarKD</code></td>
<td>
<p>The number
of explanatory variables for the biomarker decline.</p>
</td></tr> <tr><td><code>noVarRec</code></td>
<td>
<p>The
indicator of absence of the explanatory variables for the recurrent events.</p>
</td></tr>
<tr><td><code>noVarEnd</code></td>
<td>
<p>The indicator of absence of the explanatory variables for
the terminal event.</p>
</td></tr> <tr><td><code>noVarKG</code></td>
<td>
<p>The indicator of absence of the
explanatory variables for the biomarker growth.</p>
</td></tr> <tr><td><code>noVarKD</code></td>
<td>
<p>The
indicator of absence of the explanatory variables for the biomarker
decline.</p>
</td></tr> <tr><td><code>LCV</code></td>
<td>
<p>The approximated likelihood cross-validation criterion
in the semiparametric case (with H minus the converged Hessian matrix, and
l(.) the full log-likelihood).</p>
<p style="text-align: center;"><code class="reqn">LCV=\frac{1}{n}(trace(H^{-1}_{pl}H) -
l(.))</code>
</p>
</td></tr> <tr><td><code>AIC</code></td>
<td>
<p>The Akaike information Criterion for the parametric
case.</p>
<p style="text-align: center;"><code class="reqn">AIC=\frac{1}{n}(np - l(.))</code>
</p>
</td></tr> <tr><td><code>n.knots.temp</code></td>
<td>
<p>The initial
value for the number of knots.</p>
</td></tr> <tr><td><code>shape.weib</code></td>
<td>
<p>The shape parameter for
the Weibull hazard functions (the first element for the recurrences and the
second one for the terminal event).</p>
</td></tr> <tr><td><code>scale.weib</code></td>
<td>
<p>The scale parameter
for the Weibull hazard functions (the first element for the recurrences and
the second one for the terminal event).</p>
</td></tr>
<tr><td><code>random.effects.pred</code></td>
<td>
<p> The empirical Bayes predictions of the random
effects (ie. using conditional posterior distributions).</p>
</td></tr>
<tr><td><code>global_chisq.testR</code></td>
<td>
<p>The binary variable equals to 0 when no
multivariate Wald is given, 1 otherwise (for the recurrent part).</p>
</td></tr>
<tr><td><code>global_chisq.testT</code></td>
<td>
<p>The binary variable equals to 0 when no
multivariate Wald is given, 1 otherwise (for the terminal part).</p>
</td></tr>
<tr><td><code>global_chisq.testKG</code></td>
<td>
<p>The binary variable equals to 0 when no
multivariate Wald is given, 1 otherwise (for the biomarker growth).</p>
</td></tr>
<tr><td><code>global_chisq.testKD</code></td>
<td>
<p>The binary variable equals to 0 when no
multivariate Wald is given, 1 otherwise (for the biomarker decline).</p>
</td></tr>
<tr><td><code>AG</code></td>
<td>
<p>The logical value. Is Andersen-Gill model fitted? </p>
</td></tr>
<tr><td><code>B1</code></td>
<td>
<p>The variance matrix of the random effects for the longitudinal
outcome.</p>
</td></tr> <tr><td><code>sigma2</code></td>
<td>
<p>The variance of the frailty term (<code class="reqn">\sigma_v</code>).</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The coefficient <code class="reqn">\alpha</code> associated with the frailty
parameter in the terminal hazard function.</p>
</td></tr> <tr><td><code>ResidualSE</code></td>
<td>
<p>The variance
of the measurement error.</p>
</td></tr> <tr><td><code>etaR</code></td>
<td>
<p>The regression coefficients for the
link function <code class="reqn">g(\cdot)</code>.</p>
</td></tr> <tr><td><code>etaT</code></td>
<td>
<p>The regression coefficients for
the link function <code class="reqn">h(\cdot)</code>.</p>
</td></tr> <tr><td><code>ne_re</code></td>
<td>
<p>The number of random effects
b used in the fit.</p>
</td></tr> <tr><td><code>names.re</code></td>
<td>
<p>The names of variables for the random
effects <code class="reqn">\bold{b}_i</code>.</p>
</td></tr> <tr><td><code>link</code></td>
<td>
<p>The name of the type of the link
functions.</p>
</td></tr>
<tr><td><code>leftCensoring</code></td>
<td>
<p>The logical value. Is the longitudinal outcome
left-censored?</p>
</td></tr> <tr><td><code>leftCensoring.threshold</code></td>
<td>
<p>For the left-censored
biomarker, the value of the left-censoring threshold used for the fit.</p>
</td></tr>
<tr><td><code>prop.censored</code></td>
<td>
<p>The fraction of observations subjected to the
left-censoring.</p>
</td></tr>
<tr><td><code>methodGH</code></td>
<td>
<p>The Gaussian quadrature method used in the fit.</p>
</td></tr>
<tr><td><code>n.nodes</code></td>
<td>
<p>The number of nodes used for the Gaussian quadrature in the
fit.</p>
</td></tr>
<tr><td><code>K_G0</code></td>
<td>
<p>Value of the estimate of the biomarker growth parameter.</p>
</td></tr>
<tr><td><code>K_D0</code></td>
<td>
<p>Value of the estimate of the biomarker decay parameter.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Value of the estimate of the biomarker resistance to drug.</p>
</td></tr>
<tr><td><code>y_0</code></td>
<td>
<p>Value of the estimate of the biomarker intial level.</p>
</td></tr>
<tr><td><code>biomarker</code></td>
<td>
<p>Name of the variable associated with the biomarker in the
data.</p>
</td></tr> <tr><td><code>time.biomarker</code></td>
<td>
<p>Name of the variable associated with the time
of measurements of the biomarker in the data.</p>
</td></tr> <tr><td><code>dose</code></td>
<td>
<p>Name of the
variable associated with the drug concentration in the data.</p>
</td></tr>
<tr><td><code>BoxCox</code></td>
<td>
<p>The logical value. Is the BoxCox transformation applied for
the biomarker?</p>
</td></tr> <tr><td><code>BoxCox_parameter</code></td>
<td>
<p>The value of the BoxCox
transformation parameter.</p>
</td></tr>
<tr><td><code>alpha_p.value</code></td>
<td>
<p>p-value of the Wald test for the estimated coefficient
<code class="reqn">\alpha</code>.</p>
</td></tr> <tr><td><code>sigma2_p.value</code></td>
<td>
<p>p-value of the Wald test for the
estimated variance of the frailty term (<code class="reqn">\sigma_v</code>).</p>
</td></tr>
<tr><td><code>etaR_p.value</code></td>
<td>
<p>p-values of the Wald test for the estimated regression
coefficients for the link function <code class="reqn">g(\cdot)</code>.</p>
</td></tr>
<tr><td><code>etaT_p.value</code></td>
<td>
<p>p-values of the Wald test for the estimated regression
coefficients for the link function <code class="reqn">h(\cdot)</code>.</p>
</td></tr>
<tr><td><code>y_0_p.value</code></td>
<td>
<p>p-value of the Wald test for the estimated biomarker
intial level.</p>
</td></tr> <tr><td><code>K_G0_p.value</code></td>
<td>
<p>p-value of the Wald test for the
estimated biomarker growth parameter.</p>
</td></tr> <tr><td><code>K_D0_p.value</code></td>
<td>
<p>p-value of the
Wald test for the estimated biomarker decay parameter.</p>
</td></tr>
<tr><td><code>lambda_p.value</code></td>
<td>
<p>p-value of the Wald test for the estimated biomarker
resistance to drug.</p>
</td></tr> <tr><td><code>beta_p.value</code></td>
<td>
<p>p-values of the Wald test for the
estimated regression coefficients.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is recommended to initialize the parameter values using the results
from a corresponding reduced model (<code>frailtyPenal</code> for the recurrent
and terminal part). See example.
</p>
<p>Estimations of models with more than three random effects can be very long.
</p>


<h3>References</h3>

<p>A. Krol, C. Tournigand, S. Michiels and V. RondeauS (2018).
Multivariate joint frailty model for the analysis of nonlinear tumor
kinetics and dynamic predictions of death. <em>Statistics in Medicine</em>.
</p>
<p>A. Krol, L. Ferrer, JP. Pignon, C. Proust-Lima, M. Ducreux, O. Bouche, S.
Michiels, V. Rondeau (2016). Joint Model for Left-Censored Longitudinal
Data, Recurrent Events and Terminal Event: Predictive Abilities of Tumor
Burden for Cancer Evolution with Application to the FFCD 2000-05 Trial.
<em>Biometrics</em> <b>72</b>(3) 907-16.
</p>
<p>D. Rizopoulos (2012). Fast fitting of joint models for longitudinal and
event time data using a pseudo-adaptive Gaussian quadrature rule.
<em>Computational Statistics and Data Analysis</em> <b>56</b>, 491-501.
</p>
<p>L. Claret, P. Girard, P.M. Hoff, E. Van Cutsem, K.P. Zuideveld, K. Jorga, J.
Fagerberg, R Bruno (2009). Model-based prediction of phase III overall
survival in colorectal cancer on the basis of phase II tumor dynamics.
<em>Journal of Clinical Oncology</em> <b>27</b>(25), 4103-8.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.trivPenalNL">plot.trivPenalNL</a></code>,<code><a href="#topic+print.trivPenalNL">print.trivPenalNL</a></code>,<code><a href="#topic+summary.trivPenalNL">summary.trivPenalNL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

###--- Non-linear trivariate joint model for longitudinal data, ---###
###--- recurrent events and a terminal event ---###

data(colorectal)
data(colorectalLongi)

# No information on dose - creation of a dummy variable 
colorectalLongi$dose &lt;- 1


# Parameters initialisation - estimation of a simplified model
# with two random effects (a frailty term and a random effect 
# related to biomarker growth (KG))
initial.model &lt;- trivPenalNL(Surv(time0, time1, new.lesions) ~ cluster(id)
 + age + treatment + terminal(state), formula.terminalEvent =~ age + treatment, 
 biomarker = "tumor.size", formula.KG ~ 1, formula.KD ~ treatment, dose = "dose",
 time.biomarker = "year", data = colorectal, data.Longi =colorectalLongi, 
 random = "KG", id = "id", recurrentAG = TRUE, n.knots = 5, kappa = c(0.01, 2),
 method.GH = "Pseudo-adaptive")


# Trivariate joint model with initial values for parameters
# (computation takes around 40 minutes)

model &lt;- trivPenalNL(Surv(time0, time1, new.lesions) ~ cluster(id) + age + treatment
 + terminal(state), formula.terminalEvent =~ age + treatment, biomarker = "tumor.size",
 formula.KG ~ 1, formula.KD ~ treatment, dose = "dose", time.biomarker = "year", 
 data = colorectal, data.Longi =colorectalLongi, random = c("y0", "KG"), id = "id", 
 init.B = c(-0.22, -0.16, -0.35, -0.19, 0.04, -0.41, 0.23), init.Alpha = 1.86,
 init.Eta = c(0.5, 0.57, 0.5, 2.34), init.Biomarker = c(1.24, 0.81, 1.07, -1.53),
 recurrentAG = TRUE, n.knots = 5, kappa = c(0.01, 2), method.GH = "Pseudo-adaptive")


## End(Not run)


</code></pre>

<hr>
<h2 id='wts'>Identify weights</h2><span id='topic+wts'></span>

<h3>Description</h3>

<p>This is a special function used in the context of the joint frailty models
for data from nested case-control studies. It specifies weights defined by
using 'wts' function, and is used of 'frailtyPenal' formula for fitting
joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wts(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wts_+3A_x">x</code></td>
<td>
<p>A numeric variable which is supposed to indicate the weights</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>A variable identified as weights</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyPenal">frailtyPenal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



data(dataNCC)
modJoint.ncc &lt;- frailtyPenal(Surv(t.start,t.stop,event)~cluster(id)+cov1
+cov2+terminal(death)+wts(ncc.wts), formula.terminalEvent=~cov1+cov2,
data=dataNCC,n.knots=8,kappa=c(1.6e+10, 5.0e+03),recurrentAG=TRUE, RandDist="LogN") 



print(modJoint.ncc)




</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
