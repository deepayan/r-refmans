<!DOCTYPE html><html lang="en"><head><title>Help for package BurStMisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BurStMisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Cfrag.list'><p> Write a Fragment of a C Program</p></a></li>
<li><a href='#corner'><p> Portion of an Array or Data Frame</p></a></li>
<li><a href='#genopt'><p> Genetic Optimization</p></a></li>
<li><a href='#genopt.control'><p> Control parameters for genopt</p></a></li>
<li><a href='#ntile'>
<p>Membership of ntile groups</p></a></li>
<li><a href='#permutation.test.discrete'><p> Random Permutation Test</p></a></li>
<li><a href='#plot.permtstBurSt'><p> Plot Distribution from a Permutation Test</p></a></li>
<li><a href='#scriptSearch'>
<p>Search R scripts for text</p></a></li>
<li><a href='#summary.genopt'>
<p>Summary of genopt object</p></a></li>
<li><a href='#writeExpectTest'>
<p>Text for a testthat test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Burns Statistics Miscellaneous</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Pat Burns</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pat Burns &lt;patrick@burns-stat.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Script search, corner, genetic optimization, permutation tests, write expect test.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>License:</td>
<td>Unlimited</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-08-13 11:05:49 UTC; pat</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-08-13 13:56:08</td>
</tr>
</table>
<hr>
<h2 id='Cfrag.list'> Write a Fragment of a C Program </h2><span id='topic+Cfrag.list'></span>

<h3>Description</h3>

<p>Writes either the C declaration of items in a list, or initializes them with
the contents of the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cfrag.list(x, file = NULL,  item.num = c(3, 10, 5),
	indent = c("\t", "\t\t"), declaration.only = FALSE,
	long = FALSE, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cfrag.list_+3A_x">x</code></td>
<td>

<p>required.
A list with names.
</p>
</td></tr>
<tr><td><code id="Cfrag.list_+3A_file">file</code></td>
<td>

<p>either <code>NULL</code> or a character string.
If <code>NULL</code> (or an empty string), then a vector of characters
is returned.
</p>
</td></tr>
<tr><td><code id="Cfrag.list_+3A_item.num">item.num</code></td>
<td>

<p>length three vector giving the number of items per line for doubles,
integers and characters.
</p>
</td></tr>
<tr><td><code id="Cfrag.list_+3A_indent">indent</code></td>
<td>

<p>length two vector giving the amount to indent declarations and the
items in the initialization.
</p>
</td></tr>
<tr><td><code id="Cfrag.list_+3A_declaration.only">declaration.only</code></td>
<td>

<p>logical flag.
If <code>TRUE</code>, then the variables are declared but not given
initial values.
</p>
</td></tr>
<tr><td><code id="Cfrag.list_+3A_long">long</code></td>
<td>

<p>logical flag.
If <code>TRUE</code>, then integers are declared to be &quot;long&quot;.
If <code>FALSE</code>, then integers are declared to be &quot;int&quot;.
</p>
</td></tr>
<tr><td><code id="Cfrag.list_+3A_append">append</code></td>
<td>

<p>logical flag.
If <code>TRUE</code>, then the file is appended to; otherwise it is
overwritten if it exists.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>file</code> is a non-empty character string, then the name of the file
that is written.
Otherwise, a character vector of the declarations &ndash; each element representing
a different line.
</p>


<h3>Side Effects </h3>

<p>if <code>file</code> is a non-empty character string, then the file is created,
overwritten or appended.
</p>


<h3>Details </h3>

<p>The type to declare is dependent on the storage mode of the component of
<code>x</code>.
You may need to coerce components to get them to be declared the correct type.
</p>


<h3>Note</h3>

<p>Rcpp now probably makes most uses of this function obsolete.
</p>


<h3>See Also</h3>

<p><code>.C</code>, <code>storage.mode</code>, <code>as.double</code>,
<code>as.integer</code>, <code>as.character</code>, <code>cat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test.list &lt;- list(adoub=as.double(rnorm(20)), anint=as.integer(92:109),
	achar=c("aaa", "bbbb", "ccccc"))

Cfrag.list(test.list, file="")

## Not run: 
Cfrag.list(test.list, file="test.c")

Cfrag.list(test.list[1], file="test.c", dec=TRUE)
Cfrag.list(test.list[-1], file="test.c", dec=FALSE, append=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='corner'> Portion of an Array or Data Frame </h2><span id='topic+corner'></span>

<h3>Description</h3>

<p>Returns an array (or data frame) of the same number of dimensions
as the input, but generally with smaller dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  corner(x, corner = "tlffff", n = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corner_+3A_x">x</code></td>
<td>
<p>an array (which includes matrices) or data frame. </p>
</td></tr>
<tr><td><code id="corner_+3A_corner">corner</code></td>
<td>
<p>a single character string which codes the particular
corner of the array that is desired.
The first character is either &quot;t&quot; (top) or &quot;b&quot; (bottom).
The second character is either &quot;l&quot; (left) or &quot;r&quot; (right).
Remaining characters should be either &quot;f&quot; (front) or &quot;b&quot; (back).
</p>
</td></tr>
<tr><td><code id="corner_+3A_n">n</code></td>
<td>
<p>a vector of positive integers which generally should have
length at least that of the <code>dim</code> of the array &ndash; it is
replicated if not.
This states (the maximum of) each of the dimensions of the result.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array similar to the input <code>x</code>, but with smaller dimensions in general.
</p>


<h3>See Also</h3>

 <p><code><a href="utils.html#topic+head">head</a></code>, <code><a href="utils.html#topic+tail">tail</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>  corner(freeny.x)
  corner(freeny.x, "br", c(2,3))

  # with three-dimensional arrays:
  corner(iris3)
  corner(array(1:1000, rep(10, 3)), "brf", 2:4)
</code></pre>

<hr>
<h2 id='genopt'> Genetic Optimization
</h2><span id='topic+genopt'></span>

<h3>Description</h3>

<p>Approximately minimizes the value of a function using a simple
heuristic optimizer that uses a combination of genetic and
simulated annealing optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  genopt(fun, population, lower = -Inf, upper = Inf,
         scale = dcontrol["eps"], add.args = NULL,
         control = genopt.control(...), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genopt_+3A_fun">fun</code></td>
<td>

<p>function that returns a numerical value.
</p>
</td></tr>
<tr><td><code id="genopt_+3A_population">population</code></td>
<td>

<p>a matrix or a list.
</p>
<p>If a matrix, then the rows correspond to the parameters and the
columns are different parameter vectors.
</p>
<p>If a list, then it should have a component named &quot;population&quot; and
optionally a component named &quot;objective&quot; &ndash; in particular, it can
be the result of a call to <code>genopt</code>.
If the &quot;objective&quot; component exists, then it is assumed to be the
function values of the population and the function will not be
evaluated on the members of the population.
</p>
</td></tr>
<tr><td><code id="genopt_+3A_lower">lower</code></td>
<td>

<p>vector giving the lower bound for parameter values.
This is replicated to be as long as the number of parameters.
</p>
</td></tr>
<tr><td><code id="genopt_+3A_upper">upper</code></td>
<td>

<p>vector giving the upper bound for parameter values.
This is replicated to be as long as the number of parameters.
</p>
</td></tr>
<tr><td><code id="genopt_+3A_scale">scale</code></td>
<td>

<p>vector of scales to use when doing local search with a solution.
This is replicated to be as long as the number of parameters.
</p>
</td></tr>
<tr><td><code id="genopt_+3A_add.args">add.args</code></td>
<td>

<p>list of additional arguments to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="genopt_+3A_control">control</code></td>
<td>

<p>an object like the output of <code>genopt.control</code> containing
control parameters for the optimization.
</p>
</td></tr>
<tr><td><code id="genopt_+3A_...">...</code></td>
<td>

<p>arguments for <code>genopt.control</code> if the <code>control</code> argument
is not given explicitly.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is a <code>summary</code> method for class <code>genopt</code> which
shows the call, a summary of the set of objectives found, and the
best solution (set of parameters).
</p>


<h3>Value</h3>

<p>a list of class <code>genopt</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>population</code></td>
<td>

<p>a matrix of the same size as the input population matrix, but generally
with different values in it.
</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>

<p>a vector with length equal to the number of columns of <code>population</code>
containing the function value for the corresponding parameter vector in
<code>population</code>.
</p>
</td></tr>
<tr><td><code>funevals</code></td>
<td>

<p>the number of function evaluations performed.
If <code>population</code> is given as a list that contains a &quot;funevals&quot;
component, then that number is added to the number of evaluations
done in the current call.
</p>
</td></tr>
<tr><td><code>random.seed</code></td>
<td>

<p>the random seed at the start of the call &ndash; given so that you can
reproduce the computations.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>an image of the call that created this object.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>The original version of this function appeared in &quot;S Poetry&quot;.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+genopt.control">genopt.control</a></code>, <code><a href="#topic+summary.genopt">summary.genopt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # two parameters, population size 5
  go1 &lt;- genopt(function(x, other) sum(x, other),
                population=matrix(rexp(10), nrow=2, ncol=5),
                lower=0, add.arg=list(other=3), trace=FALSE)
  summary(go1)

  go2 &lt;- genopt(function(x, other) sum(x, other), population=go1,
                lower=0, add.arg=list(other=3), trace=FALSE)

</code></pre>

<hr>
<h2 id='genopt.control'> Control parameters for genopt
</h2><span id='topic+genopt.control'></span>

<h3>Description</h3>

<p>Returns a list suitable as the <code>control</code> argument
of the <code>genopt</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  genopt.control(births = 100, random.n = 0, jitters.n = 3,
                 trace = TRUE, eps = 0.1, prob = 0.4, scale.min = 1e-12,
                 maxeval = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genopt.control_+3A_births">births</code></td>
<td>

<p>the number of times two parents are combined to create a
new solution.
</p>
</td></tr>
<tr><td><code id="genopt.control_+3A_random.n">random.n</code></td>
<td>

<p>the number of random solutions created (and evaluated)
before the genetic phase starts.
</p>
</td></tr>
<tr><td><code id="genopt.control_+3A_jitters.n">jitters.n</code></td>
<td>

<p>the number of times a newly successful solution is changed
(in the simulated annealing phase)
in an attempt to find a nearby better one.
</p>
</td></tr>
<tr><td><code id="genopt.control_+3A_trace">trace</code></td>
<td>

<p>logical value: should progress be printed?
</p>
</td></tr>
<tr><td><code id="genopt.control_+3A_eps">eps</code></td>
<td>

<p>the default value for the scale of the jittering in
simulated annealing.
</p>
</td></tr>
<tr><td><code id="genopt.control_+3A_prob">prob</code></td>
<td>

<p>in the selection of parameters between two parents, the probability
of each coming from the first parent.
</p>
</td></tr>
<tr><td><code id="genopt.control_+3A_scale.min">scale.min</code></td>
<td>

<p>the minimum value allowed in the <code>scale</code> argument of
<code>genopt</code>.
</p>
</td></tr>
<tr><td><code id="genopt.control_+3A_maxeval">maxeval</code></td>
<td>

<p>the maximum number of function evaluations allowed.
This takes previous function calls into account if <code>funevals</code>
is a component of the <code>population</code> argument of
<code>genopt</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components:
</p>
<table role = "presentation">
<tr><td><code>icontrol</code></td>
<td>

<p>vector of the control parameters that are logically integer
(or logical).
</p>
</td></tr>
<tr><td><code>dcontrol</code></td>
<td>

<p>vector of the control parameters that are logically real-valued.
</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+genopt">genopt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  goc1 &lt;- genopt.control(random.n=200, births=1000, trace=FALSE)

  go1 &lt;- genopt(function(x, other) sum(x, other),
                matrix(rexp(10), nrow=2, ncol=5), lower=0, add.arg=list(other=3),
                control=goc1)

  goc2 &lt;- genopt.control(random.n=0, births=1000, trace=FALSE)

  go2 &lt;- genopt(function(x, other) sum(x, other), go1,
                lower=0, add.arg=list(other=3), control=goc2)

</code></pre>

<hr>
<h2 id='ntile'>
Membership of ntile groups
</h2><span id='topic+ntile'></span>

<h3>Description</h3>

<p>Creates groups where the groups each have as close to the same number of members as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ntile(x, ngroups, na.rm = FALSE, result = "list",
    reverse = FALSE, checkBleed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ntile_+3A_x">x</code></td>
<td>

<p>a numeric vector.
</p>
</td></tr>
<tr><td><code id="ntile_+3A_ngroups">ngroups</code></td>
<td>

<p>a positive integer giving the number of groups to create.
</p>
</td></tr>
<tr><td><code id="ntile_+3A_na.rm">na.rm</code></td>
<td>

<p>logical value: if <code>TRUE</code>, then missing values are removed before
forming the groups.
</p>
</td></tr>
<tr><td><code id="ntile_+3A_result">result</code></td>
<td>

<p>a character string specifying the form of the resulting value.
This must be (an abbreviation of) one of: <code>"list"</code>, <code>"numeric"</code>,
<code>"factor"</code>
</p>
</td></tr>
<tr><td><code id="ntile_+3A_reverse">reverse</code></td>
<td>

<p>logical value: if <code>TRUE</code>, then the biggest values are in group 1.
</p>
</td></tr>
<tr><td><code id="ntile_+3A_checkbleed">checkBleed</code></td>
<td>

<p>logical value: if <code>TRUE</code>, then a warning is issued if the same
value appears in more than one group.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the form of the value depends on the <code>result</code> argument.
</p>
<p>The <code>"list"</code> result has the values of the input <code>x</code> grouped
into <code>ngroups</code> components.
</p>
<p>The <code>"numeric"</code> result is a vector of integers from 1
to <code>ngroups</code> indicating which group the corresponding element
of <code>x</code> is in.
</p>
<p>The <code>"factor"</code> result is an ordered factor version of the
<code>"numeric"</code> result.
</p>


<h3>Note</h3>

<p>A more primitive version of this function appeared in a blog post
called &quot;Miles of iles&quot; on the Portfolio Probe website.
A bit of comparison with the alternative functions in See Also may
be found there.
</p>


<h3>Author(s)</h3>

<p>Pat Burns
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>, <code><a href="Hmisc.html#topic+cut2">cut2</a></code>,
<code><a href="gtools.html#topic+quantcut">quantcut</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ntile(setNames(state.area, state.name), 10)

ntile(Loblolly$height, 5, result="factor", reverse=TRUE)

ntile(c(-10:10, rep(0, 7)), 4)
</code></pre>

<hr>
<h2 id='permutation.test.discrete'> Random Permutation Test</h2><span id='topic+permutation.test.discrete'></span><span id='topic+permutation.test.fun'></span><span id='topic+print.permtstBurSt'></span>

<h3>Description</h3>

<p>Performs a random permutation test on the relationship between 
two discrete variables, or by using a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutation.test.discrete(x, y = NULL, scores, alternative = "greater", 
	trials = 1000)
permutation.test.fun(x, y = NULL, fun = function(x, y) sum(x * y), 
	alternative = "greater", trials = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permutation.test.discrete_+3A_x">x</code></td>
<td>
 
<p>either a two-column matrix or data frame, or a vector.
When this has two columns, <code>y</code> should not be given.
</p>
</td></tr>
<tr><td><code id="permutation.test.discrete_+3A_y">y</code></td>
<td>
 
<p>either a zero-length object, or a vector the same length as <code>x</code>.
</p>
</td></tr>
<tr><td><code id="permutation.test.discrete_+3A_scores">scores</code></td>
<td>
 
<p>a numeric matrix providing the scores for each combination of
the unique values in <code>x</code> and <code>y</code>.
The dimnames need to consist of these unique values.
</p>
</td></tr>
<tr><td><code id="permutation.test.discrete_+3A_fun">fun</code></td>
<td>
 
<p>a function that takes two arguments and returns a single numeric value.
</p>
</td></tr>
<tr><td><code id="permutation.test.discrete_+3A_alternative">alternative</code></td>
<td>
 
<p>a character string that partially matches either <code>"greater"</code>
or <code>"less"</code>.
</p>
</td></tr>
<tr><td><code id="permutation.test.discrete_+3A_trials">trials</code></td>
<td>
 
<p>the number of random permutations to be performed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>permtstBurSt</code> which is a list with the
following components:
</p>
<table role = "presentation">
<tr><td><code>original.score</code></td>
<td>

<p>the score (or function value) produced by the original data.
</p>
</td></tr>
<tr><td><code>perm.scores</code></td>
<td>

<p>a vector of the scores (or function values) from the random permutations.
</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>

<p>a numeric vector that has the number of observations in the data, the
number of random permutations done, the number of permutations that
produced a score at least as extreme as the original, and the p-value
for the test.
</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>

<p>either <code>"greater"</code> or <code>"less"</code>.
</p>
</td></tr>
<tr><td><code>random.seed</code></td>
<td>

<p>the random seed at the start of the call.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>an image of the call that was used.
</p>
</td></tr>
</table>


<h3>Side effects </h3>

<p>The object <code>.Random.seed</code> is either created or updated.
</p>


<h3>Details </h3>

<p>There are <code>print</code> and <code>plot</code> methods for this class of object.
The print method merely describes the object and shows the p-value of the
test (rounded, by default, to 4 digits).
</p>
<p>A simple version of the p-value is the
number of random permutations that are at least as extreme as the original
divided by the total number of random permutations.
The value computed, which is more correct, has 1 added to both numerator 
and denominator.
In general the difference is of no consequence.  
However, there are cases where it does matter, for example when independent
p-values are combined.
</p>
<p>These functions are related to &quot;Permuting Super Bowl Theory&quot; which can
be found in the working papers section of <a href="http://www.burns-stat.com">http://www.burns-stat.com</a>.
The paper explains permutation tests via a discussion of the Super Bowl
indicator of the stock market.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+plot.permtstBurSt">plot.permtstBurSt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>winner &lt;- c('N', 'N', 'A', 'N', 'A', 'N')
market &lt;- c('+', '-', '-', '+', '+', '+')
smat &lt;- diag(2)
dimnames(smat) &lt;- list(c('N', 'A'), c('+', '-'))

pt1 &lt;- permutation.test.discrete(winner, market, smat)
print(pt1)
plot(pt1)

pt2 &lt;- permutation.test.fun(ToothGrowth[, -2], fun=cor)
print(pt2)
plot(pt2)


smat2 &lt;- matrix(c(-3, -.5, 3, -1, 1, 0, 0, 1, -1, 3, -.5, -3),
	3, 4, dimnames=list(c('Up', 'Neut', 'Down'), 
	c('Q1', 'Q2', 'Q3', 'Q4')))
my.results &lt;- data.frame(results=sample(c('Up', 'Neut', 'Down'),
       100, replace=TRUE), quartile=sample(
       c('Q1', 'Q2', 'Q3', 'Q4'), 100, replace=TRUE))
permutation.test.discrete(my.results[, c("results", "quartile")], 
	score=smat2)

</code></pre>

<hr>
<h2 id='plot.permtstBurSt'> Plot Distribution from a Permutation Test </h2><span id='topic+plot.permtstBurSt'></span>

<h3>Description</h3>

<p>Shows the distribution of the scores of the random permutations relative
to the score from the actual data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'permtstBurSt'
plot(x, col = c("black", "red"), width = 10, 
	uniqlim = 10, main = "", xlab = "Scores", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.permtstBurSt_+3A_x">x</code></td>
<td>
<p> an object of class <code>permtstBurSt</code>, which is likely
the result of:
</p>
<p><code>permutation.test.discrete</code> or <code>permutation.test.fun</code>.
</p>
</td></tr>
<tr><td><code id="plot.permtstBurSt_+3A_col">col</code></td>
<td>
<p> the colors to use in the plot &ndash; mainly for the bar-type
plot when there are only a few scores in the permutation distribution.
The first color is the one used for the insignificant part of the distribution,
the second color is for the significant part of the distribution.
The second color is used to identify the original score when a histogram 
is used.
</p>
</td></tr>
<tr><td><code id="plot.permtstBurSt_+3A_width">width</code></td>
<td>
<p> the width of the bars.
</p>
</td></tr>
<tr><td><code id="plot.permtstBurSt_+3A_uniqlim">uniqlim</code></td>
<td>
<p> the value that determines which type of plot to use.
If the number of unique values in the scores from the permutations
is bigger than <code>uniqlim</code>, then a histogram is drawn.
Otherwise, bars are drawn.
</p>
</td></tr>
<tr><td><code id="plot.permtstBurSt_+3A_main">main</code></td>
<td>
<p> character string giving the main title for the plot.
</p>
</td></tr>
<tr><td><code id="plot.permtstBurSt_+3A_xlab">xlab</code></td>
<td>
<p> character string giving the label for the x-axis.
</p>
</td></tr>
<tr><td><code id="plot.permtstBurSt_+3A_...">...</code></td>
<td>
<p> additional graphics parameters may be given.
</p>
</td></tr>
</table>


<h3>Side effects </h3>

<p>a plot is produced.
</p>


<h3>Details </h3>

<p>Two styles of plot are possible.
A histogram is more appropriate when there are more than a few
values in the permutation distribution.
When there are only a few distinct values, 
then a bar-type plot is more informative.
The <code>uniqlim</code> argument controls the definition of &quot;a few&quot;.
</p>
<p>These functions are related to &quot;Permuting Super Bowl Theory&quot; which can
be found in the working papers section of <a href="http://www.burns-stat.com">http://www.burns-stat.com</a>.
The paper explains permutation tests via a discussion of the Super Bowl
indicator of the stock market.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+permutation.test.discrete">permutation.test.discrete</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pt1 &lt;- permutation.test.discrete(winner, market, smat)
plot(pt1, col=c("blue", "gold"))

## End(Not run)
</code></pre>

<hr>
<h2 id='scriptSearch'>
Search R scripts for text
</h2><span id='topic+scriptSearch'></span>

<h3>Description</h3>

<p>Returns a list of text matches in the scripts in a directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scriptSearch(pattern, path = ".", subdirs = TRUE, suffix = "\\.[rR]$",
      commentsIncluded = FALSE, ..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scriptSearch_+3A_pattern">pattern</code></td>
<td>

<p>character string containing a regular expression
(this is the argument of the same name for <code><a href="base.html#topic+grep">grep</a></code>).
</p>
</td></tr>
<tr><td><code id="scriptSearch_+3A_path">path</code></td>
<td>

<p>a character string giving the (relative) path of the directory holding
the R scripts.
</p>
</td></tr>
<tr><td><code id="scriptSearch_+3A_subdirs">subdirs</code></td>
<td>

<p>logical value: if <code>TRUE</code>, then subdirectories of <code>path</code> are
also searched.
</p>
</td></tr>
<tr><td><code id="scriptSearch_+3A_suffix">suffix</code></td>
<td>

<p>a character string restricting the files to be searched.
</p>
</td></tr>
<tr><td><code id="scriptSearch_+3A_commentsincluded">commentsIncluded</code></td>
<td>

<p>logical value: if <code>FALSE</code>, then lines beginning with the hash
symbol are ignored.
</p>
</td></tr>
<tr><td><code id="scriptSearch_+3A_...">...</code></td>
<td>

<p>additional arguments to <code>grep</code> may be given &ndash; the most likely
possibilities are <code>ignore.case</code>, <code>perl</code> and <code>fixed</code>.
</p>
</td></tr>
<tr><td><code id="scriptSearch_+3A_verbose">verbose</code></td>
<td>

<p>logical value: if <code>TRUE</code>, then the names of the scripts being
searched are printed.  The full name of this argument needs to be given &ndash;
no abbreviation is allowed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code>suffix</code> argument restricts the search to R scripts.
An R script is considered to be a file that ends in dot-R, where the
&quot;R&quot; can be lowercase or uppercase.
</p>


<h3>Value</h3>

<p>a list: the names are equal to the file names containing matches,
and each component is a character vector of the whitespace-trimmed
lines in the file that match the pattern.
</p>


<h3>Limitations </h3>

<p>Using <code>commentsIncluded=FALSE</code> does not preclude a match being
declared when it is in a comment not starting the line.
</p>


<h3>Author(s)</h3>

<p>Pat Burns
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
scriptSearch("list.files")
scriptSearch("garch", "~/../burns-stat3/webpages/blog")

# search for an assignment
# ' *' means zero or more spaces
scriptSearch("specialObject *&lt;- ", "~/myScriptDirectory", subdirs=FALSE)

# search COBOL files
scriptSearch("blah", suffix="\\.cbl$")


## End(Not run)
</code></pre>

<hr>
<h2 id='summary.genopt'>
Summary of genopt object
</h2><span id='topic+summary.genopt'></span>

<h3>Description</h3>

<p>The call, best solution and summary of objectives in the final population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'genopt'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.genopt_+3A_object">object</code></td>
<td>

<p>the result of a call to <code>genopt</code>.
</p>
</td></tr>
<tr><td><code id="summary.genopt_+3A_...">...</code></td>
<td>

<p>currently unused.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>

<p>image of the call to <code>genopt</code>.
</p>
</td></tr>
<tr><td><code>summary.objectives</code></td>
<td>

<p>summary of the objectives of the solutions in the final population.
</p>
</td></tr>
<tr><td><code>best.solution</code></td>
<td>

<p>the vector of parameters with the best solution in the population.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+genopt">genopt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # two parameters, population size 5
  go1 &lt;- genopt(function(x, other) sum(x, other),
                population=matrix(rexp(10), nrow=2, ncol=5),
                lower=0, add.arg=list(other=3), trace=FALSE)
  summary(go1)
</code></pre>

<hr>
<h2 id='writeExpectTest'>
Text for a testthat test
</h2><span id='topic+writeExpectTest'></span>

<h3>Description</h3>

<p>Automatically writes the text of a <code>testthat::expect_equal</code> test of an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeExpectTest(expr, filename = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeExpectTest_+3A_expr">expr</code></td>
<td>

<p>an expression to be tested.
</p>
</td></tr>
<tr><td><code id="writeExpectTest_+3A_filename">filename</code></td>
<td>

<p>where should the results go to?
The empty string means that it goes to the console.
</p>
</td></tr>
<tr><td><code id="writeExpectTest_+3A_...">...</code></td>
<td>

<p>additional arguments to <code>cat</code> may be given to control the output.
The most likely choice is <code>append</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Side effects </h3>

<p>text is written to the console or to a file.
</p>


<h3>Note</h3>

<p>Some functions are hard to test, like <code><a href="#topic+scriptSearch">scriptSearch</a></code>.
It seems like this one would be too, but in fact it is self-testing.
If the test it writes doesn't pass in the same environment, then it
must have done something wrong.
</p>


<h3>See Also</h3>

<p><code><a href="testthat.html#topic+expect_equal">expect_equal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>writeExpectTest(head(1:10))
writeExpectTest(head(cars))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
