<!DOCTYPE html><html lang="en"><head><title>Help for package quadform</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<script type="text/javascript" src="mathjax-config.js"></script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quadform}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#quad.form'><p>Evaluate a quadratic form efficiently</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Efficient Evaluation of Quadratic Forms</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0-2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
 A range of quadratic forms are evaluated, using efficient methods.
 Unnecessary transposes are not performed.  Complex values are handled
 consistently.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/quadform">https://github.com/RobinHankin/quadform</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/quadform/issues">https://github.com/RobinHankin/quadform/issues</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-14 06:38:23 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-14 07:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='quad.form'>Evaluate a quadratic form efficiently</h2><span id='topic+quad.form'></span><span id='topic+quadform'></span><span id='topic+quad.form.inv'></span><span id='topic+quad.form.chol'></span><span id='topic+quad3.form'></span><span id='topic+quad3.form_ab'></span><span id='topic+quad3.form_bc'></span><span id='topic+quad3.form.inv'></span><span id='topic+quad.tform'></span><span id='topic+quad3.tform'></span><span id='topic+quad3.tform_ab'></span><span id='topic+quad3.tform_bc'></span><span id='topic+quad.tform.inv'></span><span id='topic+quad.diag'></span><span id='topic+quad.tdiag'></span><span id='topic+quad3.diag'></span><span id='topic+quad3.tdiag'></span><span id='topic+quad.trace'></span><span id='topic+quad.ttrace'></span><span id='topic+cprod'></span><span id='topic+tcprod'></span><span id='topic+ht'></span><span id='topic+cp'></span><span id='topic+tcp'></span><span id='topic+qf'></span><span id='topic+qfi'></span><span id='topic+q3'></span><span id='topic+q3i'></span><span id='topic+q3t'></span><span id='topic+qt'></span><span id='topic+qti'></span><span id='topic+qd'></span><span id='topic+qtd'></span><span id='topic+q3d'></span><span id='topic+q3td'></span><span id='topic+qtr'></span><span id='topic+qttr'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Given a square matrix \(M\) of size \(n\times n\), and a
matrix \(x\) of size \(n\times p\) (or a vector of length
\(n\)), evaluate various quadratic forms.
</p>
<p>The archetype is <code>quad.form(M,x)</code> for real or complex square
matrix <code>M</code> and vector or matrix <code>x</code>.  This evaluates
<code style="white-space: pre;">&#8288;Conj(t(x)) %*% M %*% x&#8288;</code> but using
<code>crossprod(crossprod(M,Conj(x)),x)</code> thus avoiding taking a
needless transpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quad.form(M, x)
quad.form.inv(M, x)
quad.form.chol(chol,x)
quad.tform(M, x)
quad3.form(M,left,right)
quad3.tform(M,left,right)
quad.tform.inv(M,x)
quad.diag(M,x)
quad.tdiag(M,x)
quad3.diag(M,left,right)
quad3.tdiag(M,left,right)
cprod(x,y)
tcprod(x,y)
ht(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quad.form_+3A_m">M</code></td>
<td>
<p>Square matrix of size \(n\times n\)</p>
</td></tr>
<tr><td><code id="quad.form_+3A_x">x</code>, <code id="quad.form_+3A_y">y</code></td>
<td>
<p>Matrix of size \(n\times p\), or vector of length \(n\)</p>
</td></tr>
<tr><td><code id="quad.form_+3A_chol">chol</code></td>
<td>
<p>Lower triangular Cholesky decomposition
of the quadratic form, see details</p>
</td></tr>
<tr><td><code id="quad.form_+3A_left">left</code>, <code id="quad.form_+3A_right">right</code></td>
<td>
<p>In function <code>quad3.form()</code>, matrices with
\(n\) rows and arbitrary number of columns</p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>ht(x)</code></td><td style="text-align: left;">\(\mathbf{x}^{*}=\overline{\mathbf{x}^{\scriptscriptstyle T}}\)
  </td><td style="text-align: left;"><code>Conj(t(x))</code></td><td style="text-align: left;"><code>ht(x)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>cprod(x,y)</code></td><td style="text-align: left;">\(\mathbf{x}^{*}\mathbf{y}\)
  </td><td style="text-align: left;"><code style="white-space: pre;">&#8288;ht(x) %*% y&#8288;</code></td><td style="text-align: left;"><code>cp()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>tcprod(x,y)</code></td><td style="text-align: left;">\(\mathbf{x}\mathbf{y}^{*}\)
  </td><td style="text-align: left;"><code style="white-space: pre;">&#8288;x %*% ht(y)&#8288;</code></td><td style="text-align: left;"><code>tcp()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quad.form(M,x)</code></td><td style="text-align: left;">\(\mathbf{x}^{*}M\mathbf{x}\)
  </td><td style="text-align: left;"><code style="white-space: pre;">&#8288;ht(x) %*% M %*% x&#8288;</code></td><td style="text-align: left;"><code>qf()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quad.form.inv(M,x)</code></td><td style="text-align: left;">\(\mathbf{x}^{*}M^{-1}\mathbf{x}\)
  </td><td style="text-align: left;"><code style="white-space: pre;">&#8288;ht(x) %*% solve(M) %*% x&#8288;</code></td><td style="text-align: left;"><code>qfi()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quad.tform(M,x)</code></td><td style="text-align: left;">\(\mathbf{x}M\mathbf{x}^{*}\)
  </td><td style="text-align: left;"><code style="white-space: pre;">&#8288;x %*% A %*% ht(x)&#8288;</code></td><td style="text-align: left;"><code>qt()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quad.tform.inv(M,x)</code></td><td style="text-align: left;">\(\mathbf{x}M^{-1}\mathbf{x}^{*}\)
  </td><td style="text-align: left;"><code style="white-space: pre;">&#8288;x %*% solve(M) %*% ht(x)&#8288;</code></td><td style="text-align: left;"><code>qti()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quad3.form(M,l,r)</code></td><td style="text-align: left;">\(\mathbf{l}^{*}M\mathbf{r}\)
  </td><td style="text-align: left;"><code style="white-space: pre;">&#8288;t(l) %*% M %*% r&#8288;</code></td><td style="text-align: left;"><code>q3()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quad3.form.inv(M,l,r)</code></td><td style="text-align: left;">\(\mathbf{l}^{*}M^{-1}\mathbf{r}\)
  </td><td style="text-align: left;"><code style="white-space: pre;">&#8288;t(l) %*% solve(M) %*% r&#8288;</code></td><td style="text-align: left;"><code>q3i()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quad3.tform(M,l,r)</code></td><td style="text-align: left;">\(\mathbf{l}M\mathbf{r}^{*}\)
  </td><td style="text-align: left;"><code style="white-space: pre;">&#8288;l %*% M %*% t(r)&#8288;</code></td><td style="text-align: left;"><code>q3t()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quad.diag(M,x)</code></td><td style="text-align: left;">\(\operatorname{diag}(\mathbf{x}^{*}M\mathbf{x})\)
  </td><td style="text-align: left;"><code style="white-space: pre;">&#8288;diag(quad.form(M,x))&#8288;</code></td><td style="text-align: left;"><code>qd()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quad.tdiag(M,x)</code></td><td style="text-align: left;">\(\operatorname{diag}(\mathbf{x}M\mathbf{x}^{*})\)
  </td><td style="text-align: left;"><code style="white-space: pre;">&#8288;diag(quad.tform(M,x))&#8288;</code></td><td style="text-align: left;"><code>qtd()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quad3.diag(M,l,r)</code></td><td style="text-align: left;">\(\operatorname{diag}(\mathbf{l}^{*}M\mathbf{r})\)
  </td><td style="text-align: left;"><code>diag(quad3.form(M,l,r))</code></td><td style="text-align: left;"><code>q3d()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quad3.tdiag(M,l,r)</code></td><td style="text-align: left;">\(\operatorname{diag}(\mathbf{l}M\mathbf{r}^{*})\)
  </td><td style="text-align: left;"><code>diag(quad3.tform(M,l,r))</code></td><td style="text-align: left;"><code>q3td()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quad.trace(M,x)</code></td><td style="text-align: left;">\(\operatorname{tr}(\mathbf{x}^{*}M\mathbf{x})\)
  </td><td style="text-align: left;"><code>tr(quad.form(M,x))</code></td><td style="text-align: left;"><code>qt()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quad.ttrace(M,x)</code></td><td style="text-align: left;">\(\operatorname{tr}(\mathbf{x}M\mathbf{x}^{*})\)
  </td><td style="text-align: left;"><code>tr(quad.tform(M,x))</code></td><td style="text-align: left;"><code>qtt()</code>
</td>
</tr>

</table>

<p><strong>In the above, \(\mathbf{x}^{*}\) denotes the
<em>complex conjugate</em> of the transpose, also known as the Hermitian
transpose</strong> (this only matters when considering complex numbers).
</p>
<p>These various functions generally avoid taking needless expensive
transposes in favour of using nested <code>crossprod()</code> and
<code>tcrossprod()</code> calls.  For example, the &ldquo;meat&rdquo; of
<code>quad.form()</code> is just <code>crossprod(crossprod(M,Conj(x)),x)</code>.
</p>
<p>Functions such as <code>quad.form.inv()</code> avoid taking a matrix
inverse.  The meat of <code>quad.form.inv()</code>, for example, is
<code>cprod(x, solve(M, x))</code>.  Many people have stated things like
&ldquo;Never invert a matrix unless absolutely necessary&rdquo;.  But I
have <em>never</em> seen a case where <code>quad.form.inv(M,x)</code> is
faster than <code>quad.form(solve(M),x)</code>.
</p>
<p>One motivation for the package is to return consistent results with
complex arguments.  Note, for example, that
<code>base::crossprod(x,y)</code> evaluates <code style="white-space: pre;">&#8288;t(x) %*% y&#8288;</code> and not, as
one would almost always want, <code style="white-space: pre;">&#8288;Conj(t(x)) %*% y&#8288;</code>.  Function
<code>cprod()</code>, unlike <code>crossprod()</code>, is consistent and returns
<code style="white-space: pre;">&#8288;Conj(t(x)) %*% y&#8288;</code> [or <code style="white-space: pre;">&#8288;ht(x) %*% y&#8288;</code>]; internally it is
essentially <code style="white-space: pre;">&#8288;crossprod(Conj(x), y)&#8288;</code>.
</p>
<p>Function <code>quad.form.chol()</code> interprets argument <code>chol</code> as
the lower triangular Cholesky decomposition of the quadratic form.
Remember that <code>M.lower %*% M.upper == M</code>, and <code>chol()</code>
returns the upper triangular matrix, so one needs to use the transpose
<code>t(chol(M))</code> in calls.  If the Cholesky decomposition of <code>M</code>
is available, then using <code>quad.form.chol()</code> and supplying
<code>chol(M)</code> should generally be faster (for large matrices) than
calling <code>quad.form()</code> and using <code>M</code> directly.  The time
saving is negligible for matrices smaller than about <i>50*50</i>, even if the overhead of computing the decomposition is
ignored.
</p>
<p>Functions <code>quad3.foo()</code> take three arguments: a matrix <code>M</code>
and two other vectors <code>l</code> and <code>r</code> [or <code>left</code> and
<code>right</code>].  For these functions, <code>M</code> is not necessarily
square although of course the matrices have to be compatible.
</p>
<p>Functions <code>quad3.form_ab()</code> and <code>quad3.form_bc()</code> are helper
functions not really intended for the end-user.  They return
mathematically identical results but differ in the bracketing order of
their operations: <code>quad3.form_ab(M,l,r)</code> returns
\(\left(\mathbf{l}^*M\right)\mathbf{r}\) and
<code>quad3.form_bc(M,l,r)</code> returns
\(\mathbf{l}^{*}\left(M\mathbf{r}\right)\).  The mnemonic
for their names is derived from the first multiplication when
calculating \((ab)c\) and \(a(bc)\).  Note that
<code>quad3.form_ab(M,l,r)</code> returns
<code style="white-space: pre;">&#8288;crossprod(crossprod(M,Conj(l)),r)&#8288;</code> rather than the
mathematically equivalent <code style="white-space: pre;">&#8288;cprod(cprod(M,l),r)&#8288;</code> on efficiency
grounds (only a single conjugate is taken).
</p>
<p>Function <code>quad3.form()</code> dispatches to either
<code>quad3.form_ab()</code> or <code>quad3.form_bc()</code> depending on the
dimensions of its argument as per the efficiency discussion at
<code>inst/quadform3test.Rmd</code>.  Similar considerations apply to
<code>quad3.tform()</code>, <code>quad3.tform_ab()</code>, and
<code>quad3.tform_bc()</code>.
</p>
<p>Terse forms [<code>qf()</code> for <code>quad.form()</code>, <code>qti()</code> for
<code>quad.tform.inv()</code>, etc] are provided for the perl
golfers among us.
</p>


<h3>Value</h3>

<p>Generally, return a (dropped) matrix, real or complex as appropriate
</p>


<h3>Note</h3>

<p>These functions are used extensively in the <a href="https://CRAN.R-project.org/package=emulator"><span class="pkg">emulator</span></a> and
<a href="https://CRAN.R-project.org/package=calibrator"><span class="pkg">calibrator</span></a> packages, primarily in the interests of elegant
code, but also speed.  For the problems I usually consider, the speedup
(of <code>quad.form(M,x)</code> over <code style="white-space: pre;">&#8288;t(x) %*% M %*% x&#8288;</code>, say) is
marginal at best.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>jj &lt;- matrix(rnorm(80),20,4)
M &lt;- crossprod(jj,jj)
M.lower &lt;- t(chol(M))
x &lt;- matrix(rnorm(8),4,2)

jj.1 &lt;- t(x) %*% M %*% x
jj.2 &lt;- quad.form(M,x)
jj.3 &lt;- quad.form.chol(M.lower, x)
print(jj.1)
print(jj.2)
print(jj.3)


## Make two Hermitian positive-definite matrices:
L &lt;- matrix(c(1,0.1i,-0.1i,1),2,2)
LL &lt;- diag(11)
LL[2,1] &lt;- -(LL[1,2] &lt;- 0.1i)

z &lt;- matrix(rnorm(22) + 1i*rnorm(22),2,11)

quad.diag(L,z)     # elements real because L is HPD
quad.tdiag(LL,z)   # ditto


## Now consider accuracy:
quad.form(solve(M),x) - quad.form.inv(M,x)  # should be zero
quad.form(M,x) - quad.tform(M,t(x))         # should be zero
quad.diag(M,x) - diag(quad.form(M,x))       # should be zero
diag(quad.form(L,z))   - quad.diag(L,z)     # should be zero
diag(quad.tform(LL,z)) - quad.tdiag(LL,z)   # should be zero
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
