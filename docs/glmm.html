<!DOCTYPE html><html><head><title>Help for package glmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {glmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bacteria'><p>Presence of Bacteria after Drug Treatments</p></a></li>
<li><a href='#bernoulli.glmm'><p>Functions for the Bernoulli family.</p></a></li>
<li><a href='#binomial.glmm'><p>Functions for the Binomial family.</p></a></li>
<li><a href='#Booth2'><p>A Logit-Normal GLMM Dataset</p></a></li>
<li><a href='#BoothHobert'><p>A Logit-Normal GLMM Dataset from Booth and Hobert</p></a></li>
<li><a href='#cbpp2'><p>Contagious Bovine Pleuropneumonia</p></a></li>
<li><a href='#coef.glmm'><p>Extract Model Coefficients</p></a></li>
<li><a href='#confint.glmm'><p>Calculates Asymptotic Confidence Intervals</p></a></li>
<li><a href='#glmm'><p>Fitting Generalized Linear Mixed Models using MCML</p></a></li>
<li><a href='#logLik.glmm'><p>Monte Carlo Log Likelihood</p></a></li>
<li><a href='#mcse'><p>Monte Carlo Standard Error</p></a></li>
<li><a href='#mcvcov'><p>Monte Carlo Variance Covariance Matrix</p></a></li>
<li><a href='#murder'><p>Number of Homicide Victims Known</p></a></li>
<li><a href='#poisson.glmm'><p>Functions for the Poisson family.</p></a></li>
<li><a href='#radish2'><p>Radish count data set</p></a></li>
<li><a href='#salamander'><p>Salamander mating data set from McCullagh and Nelder (1989)</p></a></li>
<li><a href='#se'><p>Standard Error</p></a></li>
<li><a href='#summary.glmm'><p>Summarizing GLMM Fits</p></a></li>
<li><a href='#varcomps'><p>Extract Model Variance Components</p></a></li>
<li><a href='#vcov.glmm'><p>Variance-Covariance Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Linear Mixed Models via Monte Carlo Likelihood
Approximation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christina Knudson &lt;drchristinaknudson@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Approximates the likelihood of a generalized linear mixed model using Monte Carlo likelihood approximation. Then maximizes the likelihood approximation to return maximum likelihood estimates, observed Fisher information, and other model information.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), trust, mvtnorm, Matrix, parallel, doParallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, foreach, itertools, utils</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-07 19:54:20 UTC; christina.knudson</td>
</tr>
<tr>
<td>Author:</td>
<td>Christina Knudson [aut, cre],
  Charles J. Geyer [ctb],
  Sydney Benson [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-09 20:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bacteria'>Presence of Bacteria after Drug Treatments</h2><span id='topic+bacteria'></span>

<h3>Description</h3>

<p>Tests of the presence of the bacteria H. influenzae in children with otitis media in the Northern Territory of Australia.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bacteria)</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt>y</dt><dd><p>Presence or absence: a factor with levels <code>n</code> and <code>y</code>.</p>
</dd>
<dt>ap</dt><dd><p>active/placebo: a factor with levels <code>a</code> and <code>p</code>.</p>
</dd>
<dt>hilo</dt><dd><p>hi/low compliance: a factor with levels <code>hi</code> and <code>lo</code>.</p>
</dd>
<dt>week</dt><dd><p>Numeric: week of test.</p>
</dd>
<dt>ID</dt><dd><p>Subject ID: a factor.</p>
</dd>
<dt>trt</dt><dd><p>A factor with levels <code>placebo</code>, <code>drug</code>, <code>drug+</code>, a re-coding of <code>ap</code> and <code>hilo</code>.</p>
</dd>
<dt>y2</dt><dd><p>y reformatted as 0/1 rather than n/y.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Dr. A. Leach tested the effects of a drug on 50 children with a history of otitis media in the Northern Territory of Australia. The children were randomized to the drug or the a placebo, and also to receive active encouragement to comply with taking the drug.
</p>
<p>The presence of H. influenzae was checked at weeks 0, 2, 4, 6 and 11: 30 of the checks were missing and are not included in this data frame.</p>


<h3>References</h3>

<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied Statistics with S</em>, Fourth edition.  Springer.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bacteria)
</code></pre>

<hr>
<h2 id='bernoulli.glmm'>Functions for the Bernoulli family. </h2><span id='topic+bernoulli.glmm'></span>

<h3>Description</h3>

<p>Given a scalar <code>eta</code>, this calculates the cumulant and two derivatives for the Bernoulli family. Also checks that the data are entered correctly.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bernoulli.glmm()
</code></pre>


<h3>Value</h3>

<table>
<tr><td><code>family.glmm</code></td>
<td>
<p>The family name, as a string.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>The link function (canonical link is required), as a string.</p>
</td></tr>
<tr><td><code>cum</code></td>
<td>
<p>The cumulant function.</p>
</td></tr>
<tr><td><code>cp</code></td>
<td>
<p>The first derivative of the cumulant function.</p>
</td></tr>
<tr><td><code>cpp</code></td>
<td>
<p>The second derivative of the cumulant function.</p>
</td></tr>
<tr><td><code>checkData</code></td>
<td>
<p>A function to check that all data are either 0 or 1.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is to be used by the <code><a href="#topic+glmm">glmm</a></code> command.</p>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmm">glmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta&lt;--3:3
bernoulli.glmm()$family.glmm
bernoulli.glmm()$cum(eta)
bernoulli.glmm()$cp(1)
bernoulli.glmm()$cpp(2)

</code></pre>

<hr>
<h2 id='binomial.glmm'>Functions for the Binomial family. </h2><span id='topic+binomial.glmm'></span>

<h3>Description</h3>

<p>Given a scalar <code>eta</code> and the number of trials, this calculates the cumulant and two derivatives for the Bernoulli family. Also checks that the data are entered correctly.</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomial.glmm()
</code></pre>


<h3>Value</h3>

<table>
<tr><td><code>family.glmm</code></td>
<td>
<p>The family name, as a string.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>The link function (canonical link is required), as a string.</p>
</td></tr>
<tr><td><code>cum</code></td>
<td>
<p>The cumulant function.</p>
</td></tr>
<tr><td><code>cp</code></td>
<td>
<p>The first derivative of the cumulant function.</p>
</td></tr>
<tr><td><code>cpp</code></td>
<td>
<p>The second derivative of the cumulant function.</p>
</td></tr>
<tr><td><code>checkData</code></td>
<td>
<p>A function to check that all data are nonnegative.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is to be used by the <code><a href="#topic+glmm">glmm</a></code> command.</p>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmm">glmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta&lt;--3:3
ntrials &lt;- 1
binomial.glmm()$family.glmm
binomial.glmm()$cum(eta, ntrials)
binomial.glmm()$cp(1, ntrials)
binomial.glmm()$cpp(2, ntrials)

</code></pre>

<hr>
<h2 id='Booth2'>A Logit-Normal GLMM Dataset</h2><span id='topic+Booth2'></span>

<h3>Description</h3>

<p>This data set contains simulated data from the paper of Booth and Hobert (referenced below) as well as another vector. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Booth2)</code></pre>


<h3>Format</h3>

<p>A data frame with 3 columns:
</p>

<dl>
<dt>y</dt><dd><p>Response vector.</p>
</dd>
<dt>x1</dt><dd><p>Fixed effect model matrix. The matrix has just one column vector.</p>
</dd>
<dt>z1</dt><dd><p>A categorical vector to be used for part of the random effect model matrix.</p>
</dd>
<dt>z2</dt><dd><p>A categorical vector to be used for part of the random effect model matrix.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The original data set was generated by Booth and Hobert using a single variance component, a single fixed effect, no intercept, and a logit link. This data set has the z2 vector added purely to illustrate an example with multiple variance components.</p>


<h3>References</h3>

<p>Booth, J. G. and Hobert, J. P. (1999)  Maximizing generalized linear mixed model likelihoods with an automated Monte Carlo EM algorithm. <em>Journal of the Royal Statistical Society, Series B</em>, <b>61</b>, 265&ndash;285. <a href="https://doi.org/10.1111/1467-9868.00176">doi:10.1111/1467-9868.00176</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Booth2)
</code></pre>

<hr>
<h2 id='BoothHobert'>A Logit-Normal GLMM Dataset from Booth and Hobert</h2><span id='topic+BoothHobert'></span>

<h3>Description</h3>

<p>This data set contains simulated data from the paper of Booth and Hobert referenced below. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BoothHobert)</code></pre>


<h3>Format</h3>

<p>A data frame with 3 columns:
</p>

<dl>
<dt>y</dt><dd><p>Response vector.</p>
</dd>
<dt>x1</dt><dd><p>Fixed effect model matrix. The matrix has just one column vector.</p>
</dd>
<dt>z1</dt><dd><p>Random effect model matrix. The matrix has just one column vector.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set was generated by Booth and Hobert using a single variance component, a single fixed effect, no intercept, and a logit link.</p>


<h3>References</h3>

<p>Booth, J. G. and Hobert, J. P. (1999)  Maximizing generalized linear mixed model likelihoods with an automated Monte Carlo EM algorithm. <em>Journal of the Royal Statistical Society, Series B</em>, <b>61</b>, 265&ndash;285. <a href="https://doi.org/10.1111/1467-9868.00176">doi:10.1111/1467-9868.00176</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BoothHobert)
</code></pre>

<hr>
<h2 id='cbpp2'>Contagious Bovine Pleuropneumonia</h2><span id='topic+cbpp2'></span>

<h3>Description</h3>

<p>This data set is a reformatted version of <code>cbpp</code> from the <code>lme4</code> package. Contagious bovine pleuropneumonia (CBPP) is a major disease of cattle in Africa, caused by a mycoplasma. This dataset describes the serological incidence of CBPP in zebu cattle during a follow-up survey implemented in 15 commercial herds located in the Boji district of Ethiopia. The goal of the survey was to study the within-herd spread of CBPP in newly infected herds. Blood samples were quarterly collected from all animals of these herds to determine their CBPP status. These data were used to compute the serological incidence of CBPP (new cases occurring during a given time period). Some data are missing (lost to follow-up). </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cbpp2)</code></pre>


<h3>Format</h3>

<p>A data frame with 3 columns:
</p>

<dl>
<dt>Y</dt><dd><p>Response vector. 1 if CBPP is observed, 0 otherwise.</p>
</dd>
<dt>period</dt><dd><p>A factor with levels 1 to 4.</p>
</dd>
<dt>herd</dt><dd><p>A factor identifying the herd (1 through 15).</p>
</dd>
</dl>



<h3>Details</h3>

<p>Serological status was determined using a competitive enzyme-linked immuno-sorbent assay (cELISA).</p>


<h3>References</h3>

<p>Lesnoff, M., Laval, G., Bonnet, P., Abdicho, S., Workalemahu, A., Kifle, D., Peyraud, A., Lancelot, R., Thiaucourt, F. (2004)  Within-herd spread of contagious bovine pleuropneumonia in Ethiopian highlands. <em>Preventive Veterinary Medicine</em>, <b>64</b>, 27&ndash;40. <a href="https://doi.org/10.1016/j.prevetmed.2004.03.005">doi:10.1016/j.prevetmed.2004.03.005</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cbpp2)
</code></pre>

<hr>
<h2 id='coef.glmm'>Extract Model Coefficients</h2><span id='topic+coef.glmm'></span>

<h3>Description</h3>

<p>A function that extracts the fixed effect coefficients returned from <code><a href="#topic+glmm">glmm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmm'
coef(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.glmm_+3A_object">object</code></td>
<td>
<p>An object of class <code>glmm</code> usually created using <code><a href="#topic+glmm">glmm</a></code>.</p>
</td></tr>
<tr><td><code id="coef.glmm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>A vector of coefficients (fixed effects only)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmm">glmm</a></code> for model fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(glmm)
set.seed(1234)
data(salamander)
m&lt;-1000
sal&lt;-glmm(Mate~0+Cross,random=list(~0+Female,~0+Male),varcomps.names=c("F","M"),
data=salamander,family.glmm=bernoulli.glmm,m=m,debug=TRUE,doPQL=FALSE)
coef(sal)

</code></pre>

<hr>
<h2 id='confint.glmm'>Calculates Asymptotic Confidence Intervals</h2><span id='topic+confint.glmm'></span>

<h3>Description</h3>

<p>A function that calculates asymptotic confidence intervals for one or more parameters in a model fitted by by <code><a href="#topic+glmm">glmm</a></code>. Confidence intervals can be calculated for fixed effect parameters and variance components using models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmm'
confint(object, parm, level, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.glmm_+3A_object">object</code></td>
<td>
<p>An object of class <code>glmm</code> usually created using <code><a href="#topic+glmm">glmm</a></code>.</p>
</td></tr>
<tr><td><code id="confint.glmm_+3A_parm">parm</code></td>
<td>
<p>A specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.glmm_+3A_level">level</code></td>
<td>
<p>The confidence level required.</p>
</td></tr>
<tr><td><code id="confint.glmm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower and upper confidence limits for each parameter. These will be labeled as (1-level)/2 and 1-(1-level)/2 in percent. By default, 2.5
</p>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmm">glmm</a></code> for model fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(glmm)
data(BoothHobert)
set.seed(123)
mod.mcml1&lt;-glmm(y~0+x1,list(y~0+z1),varcomps.names=c("z1"), data=BoothHobert,
family.glmm=bernoulli.glmm,m=1000,doPQL=TRUE)
confint(mod.mcml1)

</code></pre>

<hr>
<h2 id='glmm'>Fitting Generalized Linear Mixed Models using MCML</h2><span id='topic+glmm'></span>

<h3>Description</h3>

<p>This function fits generalized linear mixed models (GLMMs) by approximating the likelihood with ordinary Monte Carlo, then maximizing the approximated likelihood. </p>


<h3>Usage</h3>

<pre><code class='language-R'>glmm(fixed, random, varcomps.names, data, family.glmm, m, 
varcomps.equal, weights=NULL, doPQL = TRUE,debug=FALSE, p1=1/3,p2=1/3, p3=1/3,
rmax=1000,iterlim=1000, par.init, zeta=5, cluster=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmm_+3A_fixed">fixed</code></td>
<td>
<p>an object of class &quot;<code>formula</code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under  &quot;Details.&quot;</p>
</td></tr>
<tr><td><code id="glmm_+3A_random">random</code></td>
<td>
<p>an object of class &quot;<code>formula</code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under &quot;Details.&quot;</p>
</td></tr>
<tr><td><code id="glmm_+3A_varcomps.names">varcomps.names</code></td>
<td>
<p>The names of the distinct variance components in order of <code>varcomps.equal</code>.</p>
</td></tr>
<tr><td><code id="glmm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which <code>glmm</code> is called.</p>
</td></tr>
<tr><td><code id="glmm_+3A_family.glmm">family.glmm</code></td>
<td>
<p>The name of the family. Must be class <code>glmm.family</code>. Current options are <code><a href="#topic+bernoulli.glmm">bernoulli.glmm</a></code>, <code><a href="#topic+poisson.glmm">poisson.glmm</a></code>, and <code><a href="#topic+binomial.glmm">binomial.glmm</a></code>.</p>
</td></tr>
<tr><td><code id="glmm_+3A_m">m</code></td>
<td>
<p>The desired Monte Carlo sample size. See a note under &quot;Details.&quot;</p>
</td></tr>
<tr><td><code id="glmm_+3A_varcomps.equal">varcomps.equal</code></td>
<td>
<p>An optional vector with elements 1 through the number of distinct variance components. Denotes variance components are to be set equal by assigning them the same integer. The length of varcomps.equal must be equal to the length of the list of random effects formulas. If omitted, varcomps.equal assumes no variance component should be set equal.</p>
</td></tr>
<tr><td><code id="glmm_+3A_weights">weights</code></td>
<td>
<p>An optional vector with length equal to the length of the response vector. This argument makes the specified observations more or less informative for the model. See a note under &quot;Details.&quot;</p>
</td></tr>
<tr><td><code id="glmm_+3A_dopql">doPQL</code></td>
<td>
<p>logical. If <code>TRUE</code>, PQL estimates are used in the importance sampling distribution. If FALSE, the importance sampling distribution will use 0 for the fixed effects and 1 for the variance components. For advanced users, since <code>glmm</code> is generally more efficient when <code>doPQL=TRUE</code>.</p>
</td></tr>
<tr><td><code id="glmm_+3A_debug">debug</code></td>
<td>
<p>logical. If <code>TRUE</code>, extra output useful for testing will be provided. For advanced users.</p>
</td></tr>
<tr><td><code id="glmm_+3A_p1">p1</code></td>
<td>
<p>A probability for mixing the random effects generated from three distributions. <code>p1</code> is the proportion of random effects from the first distribution specified in &quot;Details.&quot; For advanced users.</p>
</td></tr>
<tr><td><code id="glmm_+3A_p2">p2</code></td>
<td>
<p>A probability for mixing the random effects generated from three distributions. <code>p2</code> is the proportion of random effects from the second distribution specified in &quot;Details.&quot; For advanced users.</p>
</td></tr>
<tr><td><code id="glmm_+3A_p3">p3</code></td>
<td>
<p>A probability for mixing the random effects generated from three distributions. <code>p3</code> is the proportion of random effects from the third distribution specified in &quot;Details.&quot; For advanced users.</p>
</td></tr>
<tr><td><code id="glmm_+3A_rmax">rmax</code></td>
<td>
<p>The maximum allowed trust region radius. This may be set very large. If set small, the algorithm traces a steepest ascent path. This is an argument for <code>trust</code>.</p>
</td></tr>
<tr><td><code id="glmm_+3A_iterlim">iterlim</code></td>
<td>
<p>A positive integer specifying the maximum number of trust iterations to be performed before the trust program is terminated. This is an argument for <code>trust</code>.</p>
</td></tr>
<tr><td><code id="glmm_+3A_par.init">par.init</code></td>
<td>
<p>An optional argument. A single vector that specifies the initial values of the fixed effects and variance components. The parameters should be inputted in the order that <code><a href="#topic+summary.glmm">summary.glmm</a></code> outputs them, with fixed effects followed by variance components. </p>
</td></tr>
<tr><td><code id="glmm_+3A_zeta">zeta</code></td>
<td>
<p>A scalar that specifies the degrees of freedom for the t-distribution from which random effects are generated.</p>
</td></tr>
<tr><td><code id="glmm_+3A_cluster">cluster</code></td>
<td>
<p>An optional argument. A cluster created by the user to enable computations to be done in parallel. See &quot;Details&quot; for more information on the default value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\beta</code> be a vector of fixed effects and let <code class="reqn">u</code> be a vector of random effects. Let <code class="reqn">X</code> and <code class="reqn">Z</code> be design matrices for the fixed and random effects, respectively. The random effects are assumed to be normally distributed with mean 0 and variance matrix <code class="reqn">D</code>, where <code class="reqn">D</code> is diagonal with entries from the unknown vector <code class="reqn">\nu</code>. Letting <code class="reqn">g</code> be the link function, <code class="reqn">g(\mu)=X \beta+ZU</code>. If the response type is Bernoulli or Binomial, then the logit function is the link; if the response type is Poisson, then the natural logarithm is the link function.
</p>
<p>Models for glmm are specified symbolically. A typical fixed effects model has the form <code>response ~ terms</code> where <code>response</code> is the (numeric) response vector and <code>terms</code> is a series of terms which specifies a linear predictor for response. A terms specification of the form <code>first + second</code> indicates all the terms in <code>first</code> together with all the terms in <code>second</code> with duplicates removed. 
</p>
<p>A specification of the form <code>first:second</code> indicates the set of terms obtained by taking the interactions of all terms in <code>first</code> with all terms in <code>second</code>. The specification <code>first*second</code> indicates the cross of <code>first</code> and <code>second</code>. This is the same as <code>first + second + first:second</code>.
</p>
<p>The terms in the formula will be re-ordered so that main effects come first, followed by the interactions, all second-order, all third-order and so on: to avoid this, pass a <code>terms</code> object as the formula. 
</p>
<p>If you choose <code>binomial.glmm</code> as the <code>family.glmm</code>, then your response should be a two-column matrix: the first column reports the number of successes and the second reports the number of failures.
</p>
<p>The random effects for glmm are also specified symbolically. The random effects model specification is typically a list. Each element of the <code>random</code> list has the form <code>response ~ 0 + term</code>. The 0 centers the random effects at 0. If you want your random effects to have a nonzero mean, then include that term in the fixed effects.  Each variance component must have its own formula in the list.
</p>
<p>To set some variance components equal to one another, use the <code>varcomps.equal</code> argument. The argument <code>varcomps.equal</code> should be a vector whose length is equal to the length of the random effects list. The vector should contain positive integers, and the first element of the <code>varcomps.equal</code> should be 1. To set variance components equal to one another, assign the same integer to the corresponding elements of <code>varcomps.equal</code>. For example, to set the first and second variance components equal to each other, the first two elements of <code>varcomps.equal</code> should be 1. If <code>varcomps.equal</code> is omitted, then the variance components are assumed to be distinct. 
</p>
<p>Each distinct variance component should have a name. The length of <code>varcomps.names</code> should be equal to the number of distinct variance components. If <code>varcomps.equal</code> is omitted, then the length of <code>varcomps.names</code> should be equal to the length of <code>random</code>.
</p>
<p>The package uses a relevance-weighted log density weighting scheme, similar to that described in Hu and Zidek (1997). This means that the <code>weights</code> argument functions in the following manner: a model built for a data set with three observations (obs. 1, obs. 2, obs. 3) and weighting scheme 1, 1, 2 gives the same results as the model built for a data set with four observations (obs. 1, obs. 2, obs. 3, obs. 3 - the last two observations are identical) and weighting scheme 1, 1, 1, 1.
</p>
<p>Monte Carlo likelihood approximation relies on an importance sampling distribution. Though infinitely many importance sampling distributions should yield the correct MCMLEs eventually, the importance sampling distribution used in this package was chosen to reduce the computation cost. When <code>doPQL</code> is <code>TRUE</code>, the importance sampling distribution relies on PQL estimates (as calculated in this package). When <code>doPQL</code> is <code>FALSE</code>, the random effect estimates in the distribution are taken to be 0, the fixed effect estimates are taken to be 0, and the variance component estimates are taken to be 1.
</p>
<p>This package's importance sampling distribution is a mixture of three distributions: a t centered at 0 with scale matrix determined by the PQL estimates of the variance components and with <code>zeta</code> degrees of freedom, a normal distribution centered at the PQL estimates of the random effects and with a variance matrix containing the PQL estimates of the variance components, and a normal distribution centered at the PQL estimates of the random effects and with a variance matrix based on the Hessian of the penalized log likelihood. The first component is included to guarantee the gradient of the MCLA has a central limit theorem. The second component is included to mirror our best guess of the distribution of the random effects. The third component is included so that the numerator and the denominator are similar when calculating the MCLA value.
</p>
<p>The Monte Carlo sample size <code>m</code> should be chosen as large as possible. You may want to run the model a couple times to begin to understand the variability inherent to Monte Carlo. There are no hard and fast rules for choosing <code>m</code>, and more research is needed on this area. For a general idea, I believe the <code>BoothHobert</code> model produces stable enough estimates at <code class="reqn">m=10^3</code> and the <code>salamander</code> model produces stable enough estimates at <code class="reqn">m=10^5</code>, as long as <code>doPQL</code> is <code>TRUE</code>.
</p>
<p>To decrease the computation time involved with larger Monte Carlo sample sizes, a parallel computing component has been added to this package. Generally, the larger the Monte Carlo sample size <code>m</code>, the greater the benefit of utilizing additional cores. By default, <code>glmm</code> will create a cluster that uses a single core. This forces all computations to be done sequentially rather than simultaneously. 
</p>
<p>To see the summary of the model, use summary().
</p>


<h3>Value</h3>

<p><code>glmm</code> returns an object of class <code>glmm</code> is a list containing at least the following components: 
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>A vector of the Monte Carlo maximum likelihood estimates (MCMLEs) for the fixed effects.</p>
</td></tr>
<tr><td><code>nu</code></td>
<td>
<p>A vector of the Monte Carlo maximum likelihood estimates for the variance components.</p>
</td></tr>
<tr><td><code>loglike.value</code></td>
<td>
<p>The Monte Carlo log likelihood evaluated at the MCMLEs <code>beta</code> and <code>nu</code>.</p>
</td></tr>
<tr><td><code>loglike.gradient</code></td>
<td>
<p>The Monte Carlo log likelihood gradient vector at the MCMLEs <code>beta</code> and <code>nu</code>.</p>
</td></tr>
<tr><td><code>loglike.hessian</code></td>
<td>
<p>The Monte Carlo log likelihood Hessian matrix at the MCMLEs <code>beta</code> and <code>nu</code>.</p>
</td></tr>
<tr><td><code>mod.mcml</code></td>
<td>
<p>A list containing the weighted (if applicable) fixed effect design matrix, the list of weighted (if applicable) random effect design matrices, the weighted (if applicable) response, and the number of trials (for the Binomial family).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call.</p>
</td></tr>
<tr><td><code>fixedcall</code></td>
<td>
<p>The fixed effects call.</p>
</td></tr>
<tr><td><code>randcall</code></td>
<td>
<p>The random effects call.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The unweighted design matrix for the fixed effects.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The unweighted response vector.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>The unweighted design matrix for the random effects.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>The weights vector.</p>
</td></tr>
<tr><td><code>family.glmm</code></td>
<td>
<p>The name of the family. Must be class <code>glmm.family</code>.</p>
</td></tr>
<tr><td><code>varcomps.names</code></td>
<td>
<p>The vector of names for the distinct variance components.</p>
</td></tr>
<tr><td><code>varcomps.equal</code></td>
<td>
<p>The vector denoting equal variance components.</p>
</td></tr>
<tr><td><code>umat</code></td>
<td>
<p>A matrix with <code>m</code> rows. Each row is a vector of random effects generated from the importance sampling distribution.</p>
</td></tr>
<tr><td><code>pvec</code></td>
<td>
<p>A vector containing <code>p1</code>, <code>p2</code>, and <code>p3</code>.</p>
</td></tr>
<tr><td><code>beta.pql</code></td>
<td>
<p>PQL estimate of <code class="reqn">\beta</code>, when <code>doPQL</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>nu.pql</code></td>
<td>
<p>PQL estimate of <code class="reqn">\nu</code>, when <code>doPQL</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>u.pql</code></td>
<td>
<p>PQL predictions of the random effects.</p>
</td></tr>
<tr><td><code>zeta</code></td>
<td>
<p>The number of degrees of freedom used in the t component of the importance sampling distribution.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>A cluster created by the user for use during the approximation of the log-likelihood value, gradient and hessian.</p>
</td></tr>
<tr><td><code>debug</code></td>
<td>
<p>If <code>TRUE</code> extra output useful for testing.</p>
</td></tr>
</table>
<p>The function <code><a href="base.html#topic+summary">summary</a></code> (i.e., <code><a href="#topic+summary.glmm">summary.glmm</a></code>) can
be used to obtain or print a summary of the results. The generic accessor function <code><a href="stats.html#topic+coef">coef</a></code> (i.e., <code><a href="#topic+coef.glmm">coef.glmm</a></code>) can be used to extract the coefficients.
</p>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>References</h3>

<p>Geyer, C. J. (1994)  On the convergence of Monte Carlo maximum likelihood calculations.  <em>Journal of the Royal Statistical Society, Series B</em>, <b>61</b>, 261&ndash;274.
<a href="https://doi.org/10.1111/j.2517-6161.1994.tb01976.x">doi:10.1111/j.2517-6161.1994.tb01976.x</a>.
</p>
<p>Geyer, C. J. and Thompson, E. (1992)  Constrained Monte Carlo maximum likelihood for dependent data.  <em>Journal of the Royal Statistical Society, Series B</em>, <b>54</b>, 657&ndash;699.
<a href="https://doi.org/10.1111/j.2517-6161.1992.tb01443.x">doi:10.1111/j.2517-6161.1992.tb01443.x</a>.
</p>
<p>Knudson, C. (2016). Monte Carlo likelihood approximation for generalized linear mixed models. PhD thesis, University of Minnesota.  <a href="http://hdl.handle.net/11299/178948">http://hdl.handle.net/11299/178948</a>
</p>
<p>Knudson, C., Benson, S., Geyer, J., Jones, G. (2021) Likelihood-based inference for generalized linear mixed models: Inference with the R package glmm. <em>Stat</em>, 10:e339. <a href="https://doi.org/10.1002/sta4.339">doi:10.1002/sta4.339</a>.
</p>
<p>Sung, Y. J. and Geyer, C. J. (2007)  Monte Carlo likelihood inference for missing data models.  <em>Annals of Statistics</em>, <b>35</b>, 990&ndash;1011.
<a href="https://doi.org/10.1214/009053606000001389">doi:10.1214/009053606000001389</a>.
</p>
<p>Hu, F. and Zidek, J. V. (2001) The relevance weighted likelihood with
applications. In: Ahmed, S. E. and Reid N. (eds).
<em>Empirical Bayes and Likelihood Inference</em>.
Lecture Notes in Statistics, <b>148</b>, 211&ndash;235. Springer, New York.
<a href="https://doi.org/10.1007/978-1-4613-0141-7_13">doi:10.1007/978-1-4613-0141-7_13</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#First, using the basic Booth and Hobert dataset
#to fit a glmm with a logistic link, one variance component,
#one fixed effect, and an intercept of 0. The Monte Carlo
#sample size is 100 to save time.
library(glmm)
data(BoothHobert)
set.seed(1234)
mod.mcml1 &lt;- glmm(y~0+x1, list(y~0+z1), varcomps.names=c("z1"), 
data=BoothHobert, family.glmm=bernoulli.glmm, m=100, doPQL=TRUE)
mod.mcml1$beta
mod.mcml1$nu
summary(mod.mcml1)
coef(mod.mcml1)

# This next example has crossed random effects but we assume
# all random effects have the same variance. The Monte Carlo
#sample size is 100 to save time.
#data(salamander)
#set.seed(1234)
#onenu &lt;- glmm(Mate~Cross, random=list(~0+Female,~0+Male), 
#varcomps.names=c("only"), varcomps.equal=c(1,1), data=salamander, 
#family.glmm=bernoulli.glmm, m=100, debug=TRUE, doPQL=TRUE)
#summary(onenu)

</code></pre>

<hr>
<h2 id='logLik.glmm'>Monte Carlo Log Likelihood</h2><span id='topic+logLik.glmm'></span>

<h3>Description</h3>

<p>A function that calculates the Monte Carlo log likelihood evaluated at the the Monte Carlo maximum likelihood estimates returned from <code><a href="#topic+glmm">glmm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmm'
logLik(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.glmm_+3A_object">object</code></td>
<td>
<p>An object of class <code>glmm</code> usually created using <code><a href="#topic+glmm">glmm</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.glmm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>logLik</code></td>
<td>
<p>The variance-covariance matrix for the parameter estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmm">glmm</a></code> for model fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(glmm)
data(BoothHobert)
set.seed(1234)
mod &lt;- glmm(y~0+x1, list(y~0+z1), varcomps.names=c("z1"), 
data=BoothHobert, family.glmm=bernoulli.glmm, m=100)
logLik(mod)
</code></pre>

<hr>
<h2 id='mcse'>Monte Carlo Standard Error</h2><span id='topic+mcse'></span>

<h3>Description</h3>

<p>A function that calculates the Monte Carlo standard error for the Monte Carlo maximum likelihood estimates returned from <code><a href="#topic+glmm">glmm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcse(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcse_+3A_object">object</code></td>
<td>
<p>An object of class <code>glmm</code> usually created using <code><a href="#topic+glmm">glmm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With maximum likelihood performed by Monte Carlo likelihood approximation, there are two sources of variability: there is variability from sample to sample and from Monte Carlo sample (of generated random effects) to Monte Carlo sample. The first source of variability (from sample to sample) is measured using standard error, which appears with the point estimates in the <code>summary</code> tables. The second source of variability is due to the Monte Carlo randomness, and this is measured by the Monte Carlo standard error. 
</p>
<p>A large Monte Carlo standard error indicates the Monte Carlo sample size <code>m</code> is too small.</p>


<h3>Value</h3>

<table>
<tr><td><code>mcse</code></td>
<td>
<p>The Monte Carlo standard errors for the Monte Carlo maximum likelihood estimates returned from <code><a href="#topic+glmm">glmm</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>References</h3>

<p>Geyer, C. J. (1994)  On the convergence of Monte Carlo maximum likelihood calculations.  <em>Journal of the Royal Statistical Society, Series B</em>, <b>61</b>, 261&ndash;274.
</p>
<p>Knudson, C. (2016)  Monte Carlo likelihood approximation for generalized linear mixed models. PhD thesis, University of Minnesota. <a href="http://hdl.handle.net/11299/178948">http://hdl.handle.net/11299/178948</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+glmm">glmm</a></code> for model fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(glmm)
data(BoothHobert)
set.seed(1234)
mod &lt;- glmm(y~0+x1, list(y~0+z1), varcomps.names=c("z1"), 
data=BoothHobert, family.glmm=bernoulli.glmm, m=100, doPQL=TRUE)
mcse(mod)

</code></pre>

<hr>
<h2 id='mcvcov'>Monte Carlo Variance Covariance Matrix</h2><span id='topic+mcvcov'></span>

<h3>Description</h3>

<p>A function that calculates the Monte Carlo variance covariance matrix for the Monte Carlo maximum likelihood estimates returned from <code><a href="#topic+glmm">glmm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcvcov(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcvcov_+3A_object">object</code></td>
<td>
<p>An object of class <code>glmm</code> usually created using <code><a href="#topic+glmm">glmm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With maximum likelihood performed by Monte Carlo likelihood approximation, there are two sources of variability: there is variability from sample to sample and from Monte Carlo sample (of generated random effects) to Monte Carlo sample. The first source of variability (from sample to sample) is measured using standard error, which appears with the point estimates in the <code>summary</code> tables. The second source of variability is due to the Monte Carlo randomness, and this is measured by the Monte Carlo standard error. 
</p>
<p>A large entry in Monte Carlo variance covariance matrix indicates the Monte Carlo sample size <code>m</code> is too small.
</p>
<p>The square root of the diagonal elements represents the Monte Carlo standard errors. The off-diagonal entries represent the Monte Carlo covariance.</p>


<h3>Value</h3>

<table>
<tr><td><code>mcvcov</code></td>
<td>
<p>The Monte Carlo variance covariance matrix for the Monte Carlo maximum likelihood estimates returned from <code><a href="#topic+glmm">glmm</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>References</h3>

<p>Geyer, C. J. (1994)  On the convergence of Monte Carlo maximum likelihood calculations.  <em>Journal of the Royal Statistical Society, Series B</em>,  <b>61</b>, 261&ndash;274.
<a href="https://doi.org/10.1111/j.2517-6161.1994.tb01976.x">doi:10.1111/j.2517-6161.1994.tb01976.x</a>.
</p>
<p>Knudson, C. (2016)  Monte Carlo likelihood approximation for generalized linear mixed models. PhD thesis, University of Minnesota.  <a href="http://hdl.handle.net/11299/178948">http://hdl.handle.net/11299/178948</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+glmm">glmm</a></code> for model fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(glmm)
data(BoothHobert)
set.seed(1234)
mod &lt;- glmm(y~0+x1, list(y~0+z1), varcomps.names=c("z1"), 
data=BoothHobert, family.glmm=bernoulli.glmm, m=100, doPQL=TRUE)

mcvcov(mod)


</code></pre>

<hr>
<h2 id='murder'>Number of Homicide Victims Known</h2><span id='topic+murder'></span>

<h3>Description</h3>

<p>Subjects responded to the question 'Within the past 12 months, how many people have you known personally that were victims of homicide?'</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(murder)</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt>y</dt><dd><p>The number of homicide victims known personally by the subject.</p>
</dd>
<dt>race</dt><dd><p>a factor with levels <code>black</code> and <code>white</code>.</p>
</dd>
<dt>black</dt><dd><p>a dummy variable to indicate whether the subject was black.</p>
</dd>
<dt>white</dt><dd><p>a dummy variable to indicate whether the subject was white.</p>
</dd>
</dl>



<h3>References</h3>

<p>Agresti, A. (2002)  <em>Categorical Data Analysis</em>, Second edition. Wiley.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(murder)
</code></pre>

<hr>
<h2 id='poisson.glmm'>Functions for the Poisson family.</h2><span id='topic+poisson.glmm'></span>

<h3>Description</h3>

<p>Given a scalar <code>eta</code>, this calculates the cumulant and two derivatives for the Poisson family. Also checks that the data are entered correctly.</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisson.glmm()</code></pre>


<h3>Value</h3>

<table>
<tr><td><code>family.glmm</code></td>
<td>
<p>The family name, as a string.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>The link function (canonical link is required).</p>
</td></tr>
<tr><td><code>cum</code></td>
<td>
<p>The cumulant function.</p>
</td></tr>
<tr><td><code>cp</code></td>
<td>
<p>The first derivative of the cumulant function.</p>
</td></tr>
<tr><td><code>cpp</code></td>
<td>
<p>The second derivative of the cumulant function.</p>
</td></tr>
<tr><td><code>checkData</code></td>
<td>
<p>A function to check that all data are nonnegative integers.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is to be used by the <code><a href="#topic+glmm">glmm</a></code> command.</p>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmm">glmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poisson.glmm()$family.glmm
poisson.glmm()$cum(2)
poisson.glmm()$cp(2)
poisson.glmm()$cpp(2)
</code></pre>

<hr>
<h2 id='radish2'>Radish count data set</h2><span id='topic+radish2'></span>

<h3>Description</h3>

<p>Data on life history traits for the invasive California wild
radish <em>Raphanus sativus</em>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(radish2)</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt>Site</dt><dd><p>Categorical. Experimental site where plant was grown. Two sites in this dataset.</p>
</dd>
<dt>Block</dt><dd><p>Categorical. Blocked nested within site.</p>
</dd>
<dt>Region</dt><dd><p>Categorical. Region from which individuals were obtained: northern, coastal California (N) or southern, inland California (S).</p>
</dd>
<dt>Pop</dt><dd><p>Categorical. Wild population nested within region.</p>
</dd>
<dt>varb</dt><dd><p>Categorical. Gives node of graphical model corresponding to each component of resp. This is useful for life history analysis (see aster package).</p>
</dd>
<dt>resp</dt><dd><p>Response vector.</p>
</dd>
<dt>id</dt><dd><p>Categorical. Indicates individual plants.</p>
</dd>
</dl>



<h3>References</h3>

<p>These data are a subset of data previously analyzed using fixed effect
aster methods (R function <code>aster</code>) in the following.
</p>
<p>Ridley, C. E. and Ellstrand, N. C. (2010).
Rapid evolution of morphology and adaptive life history in
the invasive California wild radish (<em>Raphanus sativus</em>) and
the implications for management.
<em>Evolutionary Applications</em>, <b>3</b>, 64&ndash;76.
</p>
<p>These data are a subset of data previously analyzed using random effect
aster methods (R function <code>reaster</code>) in the following.
</p>
<p>Geyer, C. J., Ridley, C. E., Latta, R. G., Etterson, J. R.,
and Shaw, R. G. (2013)
Local Adaptation and Genetic Effects on Fitness: Calculations
for Exponential Family Models with Random Effects.
<em>Annals of Applied Statistics</em>, <b>7</b>, 1778&ndash;1795.
<a href="https://doi.org/10.1214/13-AOAS653">doi:10.1214/13-AOAS653</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(radish2)</code></pre>

<hr>
<h2 id='salamander'>Salamander mating data set from McCullagh and Nelder (1989)</h2><span id='topic+salamander'></span>

<h3>Description</h3>

<p>This data set presents the outcome of an experiment  conducted at the University of Chicago in 1986 to study interbreeding between populations of mountain dusky salamanders (McCullagh and Nelder, 1989, Section 14.5).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(salamander)</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt>Mate</dt><dd><p>Whether the salamanders mated (1) or did not mate (0).</p>
</dd>
<dt>Cross</dt><dd><p>Cross between female and male type. A factor with four levels: <code>R/R</code>,<code>R/W</code>,<code>W/R</code>, and <code>W/W</code>. The type of the female salamander is listed first and the male is listed second. Rough Butt is represented by R and White Side is represented by W. For example, <code>Cross=W/R</code> indicates a White Side female was crossed with a Rough Butt male.</p>
</dd>
<dt>Male</dt><dd><p>Identification number of the male salamander. A factor.</p>
</dd>
<dt>Female</dt><dd><p>Identification number of the female salamander. A factor.</p>
</dd>
</dl>



<h3>References</h3>

<p>McCullagh P. and Nelder, J. A. (1989)  <em>Generalized Linear Models</em>.  Chapman and Hall/CRC.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(salamander)</code></pre>

<hr>
<h2 id='se'>Standard Error</h2><span id='topic+se'></span>

<h3>Description</h3>

<p>A function that calculates the standard error for the Monte Carlo maximum likelihood estimates returned from <code><a href="#topic+glmm">glmm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_+3A_object">object</code></td>
<td>
<p>An object of class <code>glmm</code> usually created using <code><a href="#topic+glmm">glmm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With maximum likelihood performed by Monte Carlo likelihood approximation, there are two sources of variability: there is variability from sample to sample and from Monte Carlo sample (of generated random effects) to Monte Carlo sample. The first source of variability (from sample to sample) is measured using standard error, which appears with the point estimates in the <code>summary</code> tables. The second source of variability is due to the Monte Carlo randomness, and this is measured by the Monte Carlo standard error. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>se</code></td>
<td>
<p>The standard errors for the Monte Carlo maximum likelihood estimates returned from <code><a href="#topic+glmm">glmm</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmm">glmm</a></code> for model fitting.
</p>
<p><code><a href="#topic+mcse">mcse</a></code> for calculating Monte Carlo standard error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(glmm)
data(BoothHobert)
set.seed(1234)
mod &lt;- glmm(y~0+x1, list(y~0+z1), varcomps.names=c("z1"), 
data=BoothHobert, family.glmm=bernoulli.glmm, m=100, doPQL=TRUE)

se(mod)


</code></pre>

<hr>
<h2 id='summary.glmm'>Summarizing GLMM Fits</h2><span id='topic+summary.glmm'></span><span id='topic+print.summary.glmm'></span>

<h3>Description</h3>

<p> &quot;summary&quot; method for class <code>glmm</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmm'
summary(object, ...)

## S3 method for class 'summary.glmm'
print(x, digits = max(3, getOption("digits") - 3),
      signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.glmm_+3A_object">object</code></td>
<td>
<p>an object of class <code>glmm</code>, usually, resulting from a
call to <code><a href="#topic+glmm">glmm</a></code>.</p>
</td></tr>
<tr><td><code id="summary.glmm_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.glmm</code>, usually, a result of a
call to <code>summary.glmm</code>.</p>
</td></tr>
<tr><td><code id="summary.glmm_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.glmm_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>, &ldquo;significance stars&rdquo;
are printed for each coefficient.</p>
</td></tr>
<tr><td><code id="summary.glmm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.glmm</code> computes and returns a list of summary statistics of the fitted generalized linear mixed model given in <code>object</code>, using the components (list elements) <code>"call"</code> and <code>"terms"</code> from its argument, plus
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a matrix for the fixed effects. The matrix has columns for the estimated coefficient, its standard error, t-statistic and corresponding (two-sided) p-value.</p>
</td></tr>
<tr><td><code>nucoefmat</code></td>
<td>
<p>a matrix with columns for the variance components. The matrix has columns for the estimated variance component, its standard error, t-statistic and corresponding (one-sided) p-value.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the design matrix for the fixed effects.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>the design matrix for the random effects.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector.</p>
</td></tr>
<tr><td><code>fixedcall</code></td>
<td>
<p>the call for the fixed effects.</p>
</td></tr>
<tr><td><code>randcall</code></td>
<td>
<p>the call for the random effects.</p>
</td></tr>
<tr><td><code>family.mcml</code></td>
<td>
<p>the family used to fit the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call to <code><a href="#topic+glmm">glmm</a></code>.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>the canonical link function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="#topic+glmm">glmm</a></code>, the generic <code><a href="base.html#topic+summary">summary</a></code>, and the function <code><a href="stats.html#topic+coef">coef</a></code>that extracts the fixed effect coefficients.
</p>

<hr>
<h2 id='varcomps'>Extract Model Variance Components</h2><span id='topic+varcomps'></span>

<h3>Description</h3>

<p>A function that extracts the variance components returned from <code><a href="#topic+glmm">glmm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varcomps(object,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcomps_+3A_object">object</code></td>
<td>
<p>An object of class <code>glmm</code> usually created using <code><a href="#topic+glmm">glmm</a></code>.</p>
</td></tr>
<tr><td><code id="varcomps_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>varcomps</code></td>
<td>
<p>A vector of variance component estimates </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmm">glmm</a></code> for model fitting.
<code><a href="#topic+coef.glmm">coef.glmm</a></code> for fixed effects coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(glmm)
data(BoothHobert)
set.seed(1234)
mod &lt;- glmm(y~0+x1, list(y~0+z1), varcomps.names=c("z1"), 
data=BoothHobert, family.glmm=bernoulli.glmm, m=100, doPQL=TRUE)

varcomps(mod)


</code></pre>

<hr>
<h2 id='vcov.glmm'>Variance-Covariance Matrix</h2><span id='topic+vcov.glmm'></span>

<h3>Description</h3>

<p>A function that calculates the variance-covariance matrix for the Monte Carlo maximum likelihood estimates returned from <code><a href="#topic+glmm">glmm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmm'
vcov(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.glmm_+3A_object">object</code></td>
<td>
<p>An object of class <code>glmm</code> usually created using <code><a href="#topic+glmm">glmm</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.glmm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>vcov</code></td>
<td>
<p>The variance-covariance matrix for the parameter estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christina Knudson</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmm">glmm</a></code> for model fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(glmm)
data(BoothHobert)
set.seed(1234)
mod &lt;- glmm(y~0+x1, list(y~0+z1), varcomps.names=c("z1"), 
data=BoothHobert, family.glmm=bernoulli.glmm, m=100, doPQL=TRUE)

vcov(mod)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
