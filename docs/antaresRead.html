<!DOCTYPE html><html lang="en"><head><title>Help for package antaresRead</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {antaresRead}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#antaresRead-package'><p>antaresRead: Import, Manipulate and Explore the Results of an 'Antares' Simulation</p></a></li>
<li><a href='#.transform_antares_version'><p>Convert the Antares number version</p></a></li>
<li><a href='#.writeIni'><p>Write ini file from list obtain by antaresRead::readIniFile and modify by user</p></a></li>
<li><a href='#API-methods'><p>API methods</p></a></li>
<li><a href='#as.antaresDataList'><p>Convert objects to antaresDataTable</p></a></li>
<li><a href='#as.antaresDataTable'><p>Convert objects to antaresDataTable</p></a></li>
<li><a href='#changeTimeStep'><p>Change the timestep of an output</p></a></li>
<li><a href='#copyToClipboard'><p>Copy data to the clipboard</p></a></li>
<li><a href='#extractDataList'><p>Format data PPSE-style</p></a></li>
<li><a href='#getAreas'><p>Select and exclude areas</p></a></li>
<li><a href='#getGeographicTrimming'><p>Read geographic trimming (filtering) options</p></a></li>
<li><a href='#getIdCols'><p>get Id columns</p></a></li>
<li><a href='#getLinks'><p>Retrieve links connected to a set of areas</p></a></li>
<li><a href='#hvdcModification'><p>hvdc straitement</p></a></li>
<li><a href='#mergeDigests'><p>Merge two digests</p></a></li>
<li><a href='#parAggregateMCall'><p>Creation of Mc_all new (only antares &gt; V6)</p></a></li>
<li><a href='#ponderateMcAggregation'><p>Mcyear aggregation weigthed by wd</p></a></li>
<li><a href='#read-ini'><p>Read configuration options from file or API</p></a></li>
<li><a href='#readAntares'><p>Read the data of an Antares simulation</p></a></li>
<li><a href='#readAntaresAreas'><p>Read output for a list of areas</p></a></li>
<li><a href='#readAntaresClusters'><p>Read output for a list of clusters</p></a></li>
<li><a href='#readAntaresSTClusters'><p>Read output for a list of short-term storage clusters</p></a></li>
<li><a href='#readBindingConstraints'><p>Read binding constraints</p></a></li>
<li><a href='#readClusterDesc'><p>Import clusters description</p></a></li>
<li><a href='#readDigestFile'><p>Read digest file</p></a></li>
<li><a href='#readInputRES'><p>Read Input RES time series</p></a></li>
<li><a href='#readInputThermal'><p>Read Input thermal time series</p></a></li>
<li><a href='#readInputTS'><p>Read Input time series</p></a></li>
<li><a href='#readLayout'><p>Read areas layout</p></a></li>
<li><a href='#readOptimCriteria'><p>Read Optimization Criteria</p></a></li>
<li><a href='#removeVirtualAreas'><p>Remove virtual areas</p></a></li>
<li><a href='#setHvdcAreas'><p>Set hvdc areas</p></a></li>
<li><a href='#setRam'><p>Specify RAM limit</p></a></li>
<li><a href='#setSimulationPath'><p>Set Path to an Antares simulation</p></a></li>
<li><a href='#setTimeoutAPI'><p>Change API Timeout</p></a></li>
<li><a href='#showAliases'><p>show aliases for variables</p></a></li>
<li><a href='#simOptions'><p>Extract simulation options</p></a></li>
<li><a href='#subset.antaresDataList'><p>Subset an antaresDataList</p></a></li>
<li><a href='#summary.bindingConstraints'><p>Display equation of binding constraint</p></a></li>
<li><a href='#viewAntares'><p>View the content of an antares output</p></a></li>
<li><a href='#writeDigest'><p>Write digest file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Import, Manipulate and Explore the Results of an 'Antares'
Simulation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.9.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Import, manipulate and explore results generated by 'Antares', a 
    powerful open source software developed by RTE (Réseau de Transport d’Électricité) to simulate and study electric power systems
    (more information about 'Antares' here : <a href="https://antares-simulator.org/">https://antares-simulator.org/</a>).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rte-antares-rpackage/antaresRead">https://github.com/rte-antares-rpackage/antaresRead</a>,
<a href="https://rte-antares-rpackage.github.io/antaresRead/">https://rte-antares-rpackage.github.io/antaresRead/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rte-antares-rpackage/antaresRead/issues">https://github.com/rte-antares-rpackage/antaresRead/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.9.6), bit64, lubridate (&ge; 1.7.1), plyr,
methods, stats, stringr, stringi, shiny, pbapply, doParallel,
jsonlite, httr, utils, memuse, purrr, lifecycle, assertthat</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, rmarkdown, foreach, parallel,
htmltools</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Infrastructure, DataImport</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-11 15:37:43 UTC; berthetcle</td>
</tr>
<tr>
<td>Author:</td>
<td>Tatiana Vargas [aut, cre],
  Jalal-Edine ZAWAM [aut],
  Frederic Breant [ctb],
  Francois Guillem [aut],
  Benoit Thieurmel [aut],
  Titouan Robert [aut],
  Victor Perrier [ctb],
  Etienne Sanchez [ctb],
  Assil Mansouri [ctb],
  Clement Berthet [ctb],
  Kamel Kemiha [ctb],
  Abdallah Mahoudi [ctb],
  Nicolas Boitard [ctb],
  RTE [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tatiana Vargas &lt;tatiana.vargas@rte-france.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-11 16:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='antaresRead-package'>antaresRead: Import, Manipulate and Explore the Results of an 'Antares' Simulation</h2><span id='topic+antaresRead'></span><span id='topic+antaresRead-package'></span>

<h3>Description</h3>

<p>Import, manipulate and explore results generated by 'Antares', a powerful open source software developed by RTE (Réseau de Transport d’Électricité) to simulate and study electric power systems (more information about 'Antares' here : <a href="https://antares-simulator.org/">https://antares-simulator.org/</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tatiana Vargas <a href="mailto:tatiana.vargas@rte-france.com">tatiana.vargas@rte-france.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jalal-Edine ZAWAM
</p>
</li>
<li><p> Francois Guillem
</p>
</li>
<li><p> Benoit Thieurmel
</p>
</li>
<li><p> Titouan Robert
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Frederic Breant [contributor]
</p>
</li>
<li><p> Victor Perrier [contributor]
</p>
</li>
<li><p> Etienne Sanchez [contributor]
</p>
</li>
<li><p> Assil Mansouri [contributor]
</p>
</li>
<li><p> Clement Berthet [contributor]
</p>
</li>
<li><p> Kamel Kemiha [contributor]
</p>
</li>
<li><p> Abdallah Mahoudi [contributor]
</p>
</li>
<li><p> Nicolas Boitard [contributor]
</p>
</li>
<li><p> RTE [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/rte-antares-rpackage/antaresRead">https://github.com/rte-antares-rpackage/antaresRead</a>
</p>
</li>
<li> <p><a href="https://rte-antares-rpackage.github.io/antaresRead/">https://rte-antares-rpackage.github.io/antaresRead/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rte-antares-rpackage/antaresRead/issues">https://github.com/rte-antares-rpackage/antaresRead/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.transform_antares_version'>Convert the Antares number version</h2><span id='topic+.transform_antares_version'></span>

<h3>Description</h3>

<p>From V9.0, system version is 9.0 (2 digit for minor) instead of 900
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.transform_antares_version(antares_version)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".transform_antares_version_+3A_antares_version">antares_version</code></td>
<td>
<p>&ldquo;numeric' Antares number version.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> value according to study version
</p>

<hr>
<h2 id='.writeIni'>Write ini file from list obtain by antaresRead::readIniFile and modify by user</h2><span id='topic+.writeIni'></span>

<h3>Description</h3>

<p>Write ini file from list obtain by antaresRead::readIniFile and modify by user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.writeIni(listData, pathIni, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".writeIni_+3A_listdata">listData</code></td>
<td>
<p><code>list</code>, modified list obtained by antaresRead::readIniFile.</p>
</td></tr>
<tr><td><code id=".writeIni_+3A_pathini">pathIni</code></td>
<td>
<p><code>Character</code>, Path to ini file.</p>
</td></tr>
<tr><td><code id=".writeIni_+3A_overwrite">overwrite</code></td>
<td>
<p>logical, should file be overwritten if already exist?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
pathIni &lt;- "D:/exemple_test/settings/generaldata.ini"
generalSetting &lt;- antaresRead::readIniFile(pathIni)
generalSetting$output$synthesis &lt;- FALSE
writeIni(generalSetting, pathIni)

## End(Not run)

</code></pre>

<hr>
<h2 id='API-methods'>API methods</h2><span id='topic+API-methods'></span><span id='topic+api_get'></span><span id='topic+api_post'></span><span id='topic+api_put'></span><span id='topic+api_delete'></span>

<h3>Description</h3>

<p>API methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>api_get(
  opts,
  endpoint,
  ...,
  default_endpoint = "v1/studies",
  parse_result = NULL,
  encoding = NULL
)

api_post(opts, endpoint, ..., default_endpoint = "v1/studies")

api_put(opts, endpoint, ..., default_endpoint = "v1/studies")

api_delete(opts, endpoint, ..., default_endpoint = "v1/studies")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="API-methods_+3A_opts">opts</code></td>
<td>
<p>Antares simulation options or a <code>list</code> with an <code style="white-space: pre;">&#8288;host = &#8288;</code> slot.</p>
</td></tr>
<tr><td><code id="API-methods_+3A_endpoint">endpoint</code></td>
<td>
<p>API endpoint to interrogate, it will be added after <code>default_endpoint</code>.
Can be a full URL (by wrapping ìn <code><a href="base.html#topic+I">I()</a></code>), in that case <code>default_endpoint</code> is ignored.</p>
</td></tr>
<tr><td><code id="API-methods_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to API method.</p>
</td></tr>
<tr><td><code id="API-methods_+3A_default_endpoint">default_endpoint</code></td>
<td>
<p>Default endpoint to use.</p>
</td></tr>
<tr><td><code id="API-methods_+3A_parse_result">parse_result</code></td>
<td>
<p><code>character</code> options for parameter <code>as</code> of function <code><a href="httr.html#topic+content">httr::content()</a></code></p>
</td></tr>
<tr><td><code id="API-methods_+3A_encoding">encoding</code></td>
<td>
<p>argument to pass as argument to the function <code><a href="httr.html#topic+content">httr::content()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Response from the API.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# List studies with local API
# default result content in R object (auto parsed)
api_get(opts = list(host = "http://0.0.0.0:8080"),
        endpoint = NULL, 
        parse_result = NULL)

# you can force parse options as text and encoding to UTF-8
api_get(opts = list(host = "http://0.0.0.0:8080"),
        endpoint = NULL, 
        parse_result = "text",
        encoding = "UTF-8")


## End(Not run)
</code></pre>

<hr>
<h2 id='as.antaresDataList'>Convert objects to antaresDataTable</h2><span id='topic+as.antaresDataList'></span><span id='topic+as.antaresDataList.antaresDataTable'></span><span id='topic+as.antaresDataList.data.frame'></span>

<h3>Description</h3>

<p>This function converts a list of tables or table into an
<code>antaresDataList</code> object.
</p>
<p>An <code>antaresDataList</code> is a list of tables of class<code>antaresDataTable</code>.
It also has attributes that store the time step, the type of data and the
simulation options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.antaresDataList(x, ...)

## S3 method for class 'antaresDataTable'
as.antaresDataList(x, name = NULL, ...)

## S3 method for class 'data.frame'
as.antaresDataList(
  x,
  synthesis,
  timeStep,
  type,
  opts = simOptions(),
  name = type,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.antaresDataList_+3A_x">x</code></td>
<td>
<p>Data.frame or data.table to convert to a an antaresDataTable.</p>
</td></tr>
<tr><td><code id="as.antaresDataList_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods.</p>
</td></tr>
<tr><td><code id="as.antaresDataList_+3A_name">name</code></td>
<td>
<p>name of the table in the final object. If <code>NULL</code>, the type of the data
is used.</p>
</td></tr>
<tr><td><code id="as.antaresDataList_+3A_synthesis">synthesis</code></td>
<td>
<p>Does the table contain synthetic results ?</p>
</td></tr>
<tr><td><code id="as.antaresDataList_+3A_timestep">timeStep</code></td>
<td>
<p>Time step of the data. One of &quot;hourly&quot;, &quot;daily&quot;, &quot;weekly&quot;, &quot;monthly&quot; or &quot;annual&quot;.</p>
</td></tr>
<tr><td><code id="as.antaresDataList_+3A_type">type</code></td>
<td>
<p>type of data: for instance &quot;areas&quot;, &quot;links&quot;, &quot;clusters&quot;, etc.</p>
</td></tr>
<tr><td><code id="as.antaresDataList_+3A_opts">opts</code></td>
<td>
<p>Simulation options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>antaresDataList</code> object.
</p>

<hr>
<h2 id='as.antaresDataTable'>Convert objects to antaresDataTable</h2><span id='topic+as.antaresDataTable'></span><span id='topic+as.antaresDataTable.data.frame'></span>

<h3>Description</h3>

<p>This function converts a <code>data.frame</code> or a <code>data.table</code> into an
<code>antaresDataTable</code> object.
</p>
<p>An <code>antaresDataTable</code> is simply a <code>data.table</code> with additional
attributes recording the time step, the type of data and the simulation
options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.antaresDataTable(x, ...)

## S3 method for class 'data.frame'
as.antaresDataTable(x, synthesis, timeStep, type, opts = simOptions(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.antaresDataTable_+3A_x">x</code></td>
<td>
<p>object to convert to a an <code>antaresDataList</code>.</p>
</td></tr>
<tr><td><code id="as.antaresDataTable_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods.</p>
</td></tr>
<tr><td><code id="as.antaresDataTable_+3A_synthesis">synthesis</code></td>
<td>
<p>Does the table contain synthetic results ?</p>
</td></tr>
<tr><td><code id="as.antaresDataTable_+3A_timestep">timeStep</code></td>
<td>
<p>Time step of the data. One of &quot;hourly&quot;, &quot;daily&quot;, &quot;weekly&quot;, &quot;monthly&quot; or &quot;annual&quot;.</p>
</td></tr>
<tr><td><code id="as.antaresDataTable_+3A_type">type</code></td>
<td>
<p>type of data: for instance &quot;areas&quot;, &quot;links&quot;, &quot;clusters&quot;, etc.</p>
</td></tr>
<tr><td><code id="as.antaresDataTable_+3A_opts">opts</code></td>
<td>
<p>Simulation options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>antaresDataTable</code> object.
</p>

<hr>
<h2 id='changeTimeStep'>Change the timestep of an output</h2><span id='topic+changeTimeStep'></span>

<h3>Description</h3>

<p>This function changes the timestep of a table or an <code>antaresData</code> object
and performs the required aggregation or desaggregation. We can specify
(des)aggregate functions by columns, see the param <code>fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>changeTimeStep(x, newTimeStep, oldTimeStep, fun = "sum", opts = simOptions())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="changeTimeStep_+3A_x">x</code></td>
<td>
<p>data.table with a column &quot;timeId&quot; or an object of class &quot;antaresDataList&quot;</p>
</td></tr>
<tr><td><code id="changeTimeStep_+3A_newtimestep">newTimeStep</code></td>
<td>
<p>Desired time step.The possible values are hourly, daily, weekly,
monthly and annual.</p>
</td></tr>
<tr><td><code id="changeTimeStep_+3A_oldtimestep">oldTimeStep</code></td>
<td>
<p>Current time step of the data. This argument is optional for an object of
class <code>antaresData</code> because the time step of the data is stored inside
the object</p>
</td></tr>
<tr><td><code id="changeTimeStep_+3A_fun">fun</code></td>
<td>
<p>Character vector with one element per column to (des)aggregate indicating
the function to use (&quot;sum&quot;, &quot;mean&quot;, &quot;min&quot; or &quot;max&quot;) for this column. It can
be a single element, in that case the same function is applied to every
columns.</p>
</td></tr>
<tr><td><code id="changeTimeStep_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a data.table or an object of class &quot;antaresDataList&quot; depending on the
class of <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setSimulationPath()

areasH &lt;- readAntares(select = "LOAD", synthesis = FALSE, mcYears = 1)
areasD &lt;- readAntares(select = "LOAD", synthesis = FALSE, mcYears = 1, timeStep ="daily")

areasDAgg &lt;- changeTimeStep(areasH, "daily", "hourly")

all.equal(areasDAgg$LOAD, areasD$LOAD)

# Use different aggregation functions
mydata &lt;- readAntares(select = c("LOAD", "MRG. PRICE"), timeStep = "monthly")
changeTimeStep(mydata, "annual", fun = c("sum", "mean"))

## End(Not run)

</code></pre>

<hr>
<h2 id='copyToClipboard'>Copy data to the clipboard</h2><span id='topic+copyToClipboard'></span><span id='topic+copyToClipboard.antaresDataList'></span>

<h3>Description</h3>

<p><code>copyToClipboard</code> is a utility function that copies data to the
clipboard. The data can then be copied in another program like excel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copyToClipboard(x, ...)

## S3 method for class 'antaresDataList'
copyToClipboard(x, what, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copyToClipboard_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="copyToClipboard_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="utils.html#topic+write.table">write.table</a></code></p>
</td></tr>
<tr><td><code id="copyToClipboard_+3A_what">what</code></td>
<td>
<p>character or numeric indicating which element to copy to clipboard (areas,
links, clusters or districts)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function does not return anything. It is only used to interact with the
clipboard
</p>


<h3>Note</h3>

<p>The function is useful only for small data objects: for a table,
only the 50000 rows are copied to clipboard. If the table to copy
is longer, either use filters to reduce the number of rows or write the
table in text file with <code><a href="utils.html#topic+write.table">write.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # This only works on Windows systems
## Not run: 
x &lt;- data.frame(a = sample(10), b = sample(10))

copyToClipboard(x)

# Try to open excel and use CTRL + V to copy the data in a spreadsheet.

## End(Not run)

</code></pre>

<hr>
<h2 id='extractDataList'>Format data PPSE-style</h2><span id='topic+extractDataList'></span>

<h3>Description</h3>

<p>This function converts an &quot;readAntares&quot; object in the data structure used
by PPSE : instead of having one table for areas, one for links and one for
clusters, the function creates a list with one element per area. Each element
is a data.table containing the data about the area and one column per cluster
of the area containing the production of this cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractDataList(x, areas = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractDataList_+3A_x">x</code></td>
<td>
<p>object of class &quot;antaresData&quot; or &quot;antaresTable&quot; created by the function
<code><a href="#topic+readAntares">readAntares</a></code></p>
</td></tr>
<tr><td><code id="extractDataList_+3A_areas">areas</code></td>
<td>
<p>character vector containing the name of areas to keep in the
final object. If <code>NULL</code>, all areas are kept in the final object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data.tables with one element per area. The list also
contains an element named &quot;areaList&quot; containing the name of areas in the
object and a table called &quot;infos&quot; that contains for each area the number
of variables of different type (values, details, link).
</p>

<hr>
<h2 id='getAreas'>Select and exclude areas</h2><span id='topic+getAreas'></span><span id='topic+getDistricts'></span>

<h3>Description</h3>

<p><code>getAreas</code> and <code>getDistricts</code> are utility functions that builds
list of areas or districts by using regular expressions to select and/or
exclude areas/districts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAreas(
  select = NULL,
  exclude = NULL,
  withClustersOnly = FALSE,
  regexpSelect = TRUE,
  regexpExclude = TRUE,
  opts = simOptions(),
  ignore.case = TRUE,
  districts = NULL
)

getDistricts(
  select = NULL,
  exclude = NULL,
  regexpSelect = TRUE,
  regexpExclude = TRUE,
  opts = simOptions(),
  ignore.case = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAreas_+3A_select">select</code></td>
<td>
<p>Character vector. If <code>regexpSelect</code> is TRUE, this vector is
interpreted as a list of regular expressions. Else it is interpreted as a
list of area names. If <code>NULL</code>, all areas are selected</p>
</td></tr>
<tr><td><code id="getAreas_+3A_exclude">exclude</code></td>
<td>
<p>Character vector. If <code>regexpExclude</code> is TRUE, this vector is
interpreted as a list of regular expressions and each area validating one
of them is excluded. Else it is interpreted as list of area names to
exclude. If <code>NULL</code>, not any area is excluded.</p>
</td></tr>
<tr><td><code id="getAreas_+3A_withclustersonly">withClustersOnly</code></td>
<td>
<p>Should the function return only nodes containing clusters ?</p>
</td></tr>
<tr><td><code id="getAreas_+3A_regexpselect">regexpSelect</code></td>
<td>
<p>Is <code>select</code> a list of regular expressions ?</p>
</td></tr>
<tr><td><code id="getAreas_+3A_regexpexclude">regexpExclude</code></td>
<td>
<p>Is <code>exclude</code> a list of regular expressions ?</p>
</td></tr>
<tr><td><code id="getAreas_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
<tr><td><code id="getAreas_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Should the case be ignored when evaluating the regular
expressions ?</p>
</td></tr>
<tr><td><code id="getAreas_+3A_districts">districts</code></td>
<td>
<p>Names of districts. If this argument is not null, only areas belonging
to the specified districts are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the name of the areas/districts satisfying the
rules defined by the parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getLinks">getLinks</a></code>
</p>

<hr>
<h2 id='getGeographicTrimming'>Read geographic trimming (filtering) options</h2><span id='topic+getGeographicTrimming'></span>

<h3>Description</h3>

<p>Read geographic trimming (filtering) options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGeographicTrimming(areas = NULL, links = TRUE, opts = simOptions())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getGeographicTrimming_+3A_areas">areas</code></td>
<td>
<p>Character. vector of areas</p>
</td></tr>
<tr><td><code id="getGeographicTrimming_+3A_links">links</code></td>
<td>
<p>Logical. if TRUE, return filtering options for all links starting from selected areas</p>
</td></tr>
<tr><td><code id="getGeographicTrimming_+3A_opts">opts</code></td>
<td>
<p>List. simulation options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of filtering options for areas and links
</p>

<hr>
<h2 id='getIdCols'>get Id columns</h2><span id='topic+getIdCols'></span>

<h3>Description</h3>

<p><code>getIdCols</code> return the id columns of an AntaresDataTable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIdCols(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getIdCols_+3A_x">x</code></td>
<td>
<p>an AntaresDataTable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the name of the id columns of an antaresDataTable
</p>

<hr>
<h2 id='getLinks'>Retrieve links connected to a set of areas</h2><span id='topic+getLinks'></span>

<h3>Description</h3>

<p>This function finds the names of the links connected to a set of areas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLinks(
  areas = NULL,
  exclude = NULL,
  opts = simOptions(),
  internalOnly = FALSE,
  namesOnly = TRUE,
  withDirection = FALSE,
  withTransmission = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLinks_+3A_areas">areas</code></td>
<td>
<p>Vector containing area names. It represents the set of areas we are interested
in. If <code>NULL</code>, all areas of the study are used.</p>
</td></tr>
<tr><td><code id="getLinks_+3A_exclude">exclude</code></td>
<td>
<p>Vector containing area names. If not <code>NULL</code>, all links connected to
one of these areas are omitted.</p>
</td></tr>
<tr><td><code id="getLinks_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
<tr><td><code id="getLinks_+3A_internalonly">internalOnly</code></td>
<td>
<p>If <code>TRUE</code>, only links that connect two areas from parameter <code>areas</code> are returned.
If not, the function also returns all the links that connect an area from the list with
an area outside the list.</p>
</td></tr>
<tr><td><code id="getLinks_+3A_namesonly">namesOnly</code></td>
<td>
<p>If <code>TRUE</code>, the function returns a vector with link names, else it
returns a table containing the name, the origin and the destination of each
selected link.</p>
</td></tr>
<tr><td><code id="getLinks_+3A_withdirection">withDirection</code></td>
<td>
<p>Used only if <code>namesOnly = FALSE</code>. If <code>FALSE</code>, then the function
returns a table with one line per link, containing the link name, the
origin and the destination of the link. If <code>TRUE</code>, then it returns a
table with columns <code>area</code>, <code>link</code>, <code>to</code> and <code>direction</code>
which is equal is equal to
1 if the link connects <code>area</code> to <code>to</code> and -1 if it connects
<code>to</code> to <code>area</code>.
The column <code>area</code> contains only areas that are compatible with parameters
<code>areas</code> and <code>exclude</code>. Note that the same link can appear twice
in the table with different directions.</p>
</td></tr>
<tr><td><code id="getLinks_+3A_withtransmission">withTransmission</code></td>
<td>
<p>Used only if <code>namesOnly = FALSE</code>. If <code>TRUE</code>, a column is added to indicate
type of transmission capacities for links.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>namesOnly = TRUE</code> the function returns a vector containing link names
</p>
<p>If <code>namesOnly = FALSE</code> and <code>withDirection = FALSE</code>, it returns a
<code>data.table</code> with <strong>exactly one line per link</strong> and with three columns:
</p>
<table role = "presentation">
<tr><td><code>link</code></td>
<td>
<p>Link name</p>
</td></tr>
<tr><td><code>from</code></td>
<td>
<p>First area connected to the link</p>
</td></tr>
<tr><td><code>to</code></td>
<td>
<p>Second area connected to the link</p>
</td></tr>
</table>
<p>If <code>namesOnly = FALSE</code> and <code>withDirection = TRUE</code>, it returns a
<code>data.table</code> with <strong>one or two lines per link</strong> and with four columns:
</p>
<table role = "presentation">
<tr><td><code>area</code></td>
<td>
<p>Area name</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>Link name</p>
</td></tr>
<tr><td><code>to</code></td>
<td>
<p>Area connected to <code>area</code> by <code>link</code></p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p>1 if the link connects <code>area</code> to <code>to</code> else -1</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Get all links of a study
getLinks()

# Get all links with their origins and destinations
getLinks(namesOnly = FALSE)

# Get all links connected to French areas (assuming their names contain "fr")
getLinks(getAreas("fr"))

# Same but with only links connecting two French areas
getLinks(getAreas("fr"), internalOnly = TRUE)

# Exclude links connecting real areas with pumped storage virtual areas
# (assuming their names contain "psp")
getLinks(getAreas("fr"), exclude = getAreas("psp"))


## End(Not run)

</code></pre>

<hr>
<h2 id='hvdcModification'>hvdc straitement</h2><span id='topic+hvdcModification'></span>

<h3>Description</h3>

<p>usage for hvdc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hvdcModification(data, removeHvdcAreas = TRUE, reafectLinks = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hvdcModification_+3A_data">data</code></td>
<td>
<p><code>antaresDataList</code> data to apply straitement</p>
</td></tr>
<tr><td><code id="hvdcModification_+3A_removehvdcareas">removeHvdcAreas</code></td>
<td>
<p><code>boolean</code> remove HVDC areas.</p>
</td></tr>
<tr><td><code id="hvdcModification_+3A_reafectlinks">reafectLinks</code></td>
<td>
<p><code>boolean</code> .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;antaresDataList&quot; is returned.
It is a list of data.tables, each element representing one type of element (areas, links, clusters)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data &lt;- readAntares(areas = 'all', links = 'all')
data &lt;- setHvdcAreas(data, "psp in")
data &lt;- hvdcModification(data)


## End(Not run)

</code></pre>

<hr>
<h2 id='mergeDigests'>Merge two digests</h2><span id='topic+mergeDigests'></span>

<h3>Description</h3>

<p>Merge two digests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeDigests(digest_new, digest_ori)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergeDigests_+3A_digest_new">digest_new</code></td>
<td>
<p>new digest with missing lines</p>
</td></tr>
<tr><td><code id="mergeDigests_+3A_digest_ori">digest_ori</code></td>
<td>
<p>original digest with all lines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated digest
list of 5 tables (begin, areas, middle, links lin., links quad.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readDigestFile">readDigestFile</a></code>
</p>

<hr>
<h2 id='parAggregateMCall'>Creation of Mc_all new (only antares &gt; V6)</h2><span id='topic+parAggregateMCall'></span><span id='topic+aggregateResult'></span>

<h3>Description</h3>

<p>Creation of Mc_all new (only antares &gt; V6)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parAggregateMCall(
  opts,
  nbcl = 8,
  verbose = 2,
  timestep = c("annual", "daily", "hourly", "monthly", "weekly"),
  writeOutput = TRUE,
  mcWeights = NULL,
  mcYears = NULL,
  filtering = FALSE,
  selected = NULL,
  legacy = FALSE
)

aggregateResult(
  opts,
  verbose = 2,
  timestep = c("annual", "daily", "hourly", "monthly", "weekly"),
  writeOutput = TRUE,
  mcWeights = NULL,
  mcYears = NULL,
  filtering = FALSE,
  selected = NULL,
  legacy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parAggregateMCall_+3A_opts">opts</code></td>
<td>
<p><code>list</code> of simulation parameters returned by the function <a href="#topic+setSimulationPath">setSimulationPath</a></p>
</td></tr>
<tr><td><code id="parAggregateMCall_+3A_nbcl">nbcl</code></td>
<td>
<p><code>numeric</code> Number of parralel process</p>
</td></tr>
<tr><td><code id="parAggregateMCall_+3A_verbose">verbose</code></td>
<td>
<p><code>numeric</code> show log in console. Defaut to 1
</p>

<ul>
<li><p> 0 : No log
</p>
</li>
<li><p> 1 : Short log
</p>
</li>
<li><p> 2 : Long log
</p>
</li></ul>
</td></tr>
<tr><td><code id="parAggregateMCall_+3A_timestep">timestep</code></td>
<td>
<p><code>character</code> antares timestep</p>
</td></tr>
<tr><td><code id="parAggregateMCall_+3A_writeoutput">writeOutput</code></td>
<td>
<p><code>boolean</code> write result or not.</p>
</td></tr>
<tr><td><code id="parAggregateMCall_+3A_mcweights">mcWeights</code></td>
<td>
<p><code>numeric</code> vector of weigth for mcYears.</p>
</td></tr>
<tr><td><code id="parAggregateMCall_+3A_mcyears">mcYears</code></td>
<td>
<p><code>numeric</code> mcYears to load.</p>
</td></tr>
<tr><td><code id="parAggregateMCall_+3A_filtering">filtering</code></td>
<td>
<p><code>boolean</code> filtering control</p>
</td></tr>
<tr><td><code id="parAggregateMCall_+3A_selected">selected</code></td>
<td>
<p><code>list</code> named list (pass to antaresRead) : list(areas = 'a', links = 'a - e')</p>
</td></tr>
<tr><td><code id="parAggregateMCall_+3A_legacy">legacy</code></td>
<td>
<p><code>boolean</code> run old version of the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object <code>list</code> of data.tables, each element representing one type
of element (areas, links, clusters)
</p>

<hr>
<h2 id='ponderateMcAggregation'>Mcyear aggregation weigthed by wd</h2><span id='topic+ponderateMcAggregation'></span>

<h3>Description</h3>

<p>Mcyear aggregation weigthed by wd
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ponderateMcAggregation(x, fun = weighted.mean, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ponderateMcAggregation_+3A_x">x</code></td>
<td>
<p><code>antaresData</code> data import with antaresRead</p>
</td></tr>
<tr><td><code id="ponderateMcAggregation_+3A_fun">fun</code></td>
<td>
<p><code>function</code> function to use</p>
</td></tr>
<tr><td><code id="ponderateMcAggregation_+3A_...">...</code></td>
<td>
<p><code>args</code> others args pass to fun</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;antaresDataTable&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  data &lt;- readAntares(areas = 'all', mcYears = 'all')
  ponderateMcAggregation(data, fun = weighted.mean, w = c(.1, .9))

  

## End(Not run)

</code></pre>

<hr>
<h2 id='read-ini'>Read configuration options from file or API</h2><span id='topic+read-ini'></span><span id='topic+readIni'></span><span id='topic+readIniFile'></span><span id='topic+readIniAPI'></span>

<h3>Description</h3>

<p>Read configuration options from file or API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readIni(pathIni, opts = antaresRead::simOptions(), default_ext = ".ini")

readIniFile(file, stringsAsFactors = FALSE)

readIniAPI(study_id, path, host, token = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read-ini_+3A_pathini">pathIni</code></td>
<td>
<p>Path to config/ini file to read.</p>
</td></tr>
<tr><td><code id="read-ini_+3A_opts">opts</code></td>
<td>
<p>List of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath()</a></code></p>
</td></tr>
<tr><td><code id="read-ini_+3A_default_ext">default_ext</code></td>
<td>
<p>Default extension used for config files.</p>
</td></tr>
<tr><td><code id="read-ini_+3A_file">file</code></td>
<td>
<p>File path.</p>
</td></tr>
<tr><td><code id="read-ini_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical: should character vectors be converted to factors?</p>
</td></tr>
<tr><td><code id="read-ini_+3A_study_id">study_id</code></td>
<td>
<p>Study's identifier.</p>
</td></tr>
<tr><td><code id="read-ini_+3A_path">path</code></td>
<td>
<p>Path of configuration object to read.</p>
</td></tr>
<tr><td><code id="read-ini_+3A_host">host</code></td>
<td>
<p>Host of AntaREST server API.</p>
</td></tr>
<tr><td><code id="read-ini_+3A_token">token</code></td>
<td>
<p>API personnal access token.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with an element for each section of the .ini file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(antaresRead)
library(antaresEditObject)

# With physical study:
setSimulationPath("../tests-studies/Study_V8.2/", simulation = "input")
readIni("settings/generaldata")

# With API
setSimulationPathAPI(
  host = "http://localhost:8080",
  study_id = "73427ae1-be83-44e0-b04f-d5127e53424c",
  token = NULL,
  simulation = "input"
)
readIni("settings/generaldata")


## End(Not run)
</code></pre>

<hr>
<h2 id='readAntares'>Read the data of an Antares simulation</h2><span id='topic+readAntares'></span>

<h3>Description</h3>

<p><img src="../help/figures/badge_api_ok.svg" alt='Antares API OK' />
</p>
<p><code>readAntares</code> is a swiss-army-knife function used to read almost every
possible time series of an antares Project at any desired time resolution
(hourly, daily, weekly, monthly or annual).
</p>
<p>It was first designed to read
output time series, but it can also read input time series. The input time
series are processed by the function to fit the query of the user (timeStep,
synthetic results or Monte-Carlo simulation, etc.). The few data that are not
read by <code>readAntares</code> can generally by read with other functions of the
package starting with &quot;read&quot; (<code><a href="#topic+readClusterDesc">readClusterDesc</a></code>,
<code><a href="#topic+readLayout">readLayout</a></code>, <code><a href="#topic+readBindingConstraints">readBindingConstraints</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readAntares(
  areas = NULL,
  links = NULL,
  clusters = NULL,
  districts = NULL,
  clustersRes = NULL,
  clustersST = NULL,
  bindingConstraints = FALSE,
  misc = FALSE,
  thermalAvailabilities = FALSE,
  hydroStorage = FALSE,
  hydroStorageMaxPower = FALSE,
  reserve = FALSE,
  linkCapacity = FALSE,
  mustRun = FALSE,
  thermalModulation = FALSE,
  select = NULL,
  mcYears = NULL,
  timeStep = c("hourly", "daily", "weekly", "monthly", "annual"),
  mcWeights = NULL,
  opts = simOptions(),
  parallel = FALSE,
  simplify = TRUE,
  showProgress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readAntares_+3A_areas">areas</code></td>
<td>
<p>Vector containing the names of the areas to import. If
<code>NULL</code> no area is imported. The special value <code>"all"</code> tells the
function to import all areas. By default, the value is &quot;all&quot; when no other argument is enter and &quot;NULL&quot; when other arguments are enter.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_links">links</code></td>
<td>
<p>Vector containing the name of links to import. If <code>NULL</code> no
area is imported. The special value <code>"all"</code> tells the function to
import all areas. Use function <code><a href="#topic+getLinks">getLinks</a></code> to import all links
connected to some areas.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_clusters">clusters</code></td>
<td>
<p>Vector containing the name of the areas for which you want to
import results at thermal cluster level. If <code>NULL</code> no cluster is imported. The
special value <code>"all"</code> tells the function to import thermal clusters from all
areas.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_districts">districts</code></td>
<td>
<p>Vector containing the names of the districts to import. If <code>NULL</code>,
no district is imported. The special value <code>"all"</code> tells the function to import all
districts.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_clustersres">clustersRes</code></td>
<td>
<p>Vector containing the name of the areas for which you want to
import results at renewable cluster level. If <code>NULL</code> no cluster is imported. The
special value <code>"all"</code> tells the function to import renewable clusters from all
areas.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_clustersst">clustersST</code></td>
<td>
<p>Vector containing the name of the areas for which you want to
import results at short-term cluster level. If <code>NULL</code> no cluster is imported. The
special value <code>"all"</code> tells the function to import short-term clusters from all
areas.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_bindingconstraints">bindingConstraints</code></td>
<td>
<p>Should binding constraints be imported (v8.4+)?</p>
</td></tr>
<tr><td><code id="readAntares_+3A_misc">misc</code></td>
<td>
<p>Vector containing the name of the areas for which you want to
import misc.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_thermalavailabilities">thermalAvailabilities</code></td>
<td>
<p>Should thermal availabilities of clusters be imported ? If TRUE, the column
&quot;thermalAvailability&quot; is added to the result and a new column &quot;availableUnits&quot;
containing the number of available units in a cluster is created.If synthesis is set to TRUE then
&quot;availableUnits&quot; contain the mean of avaible units on all MC Years.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_hydrostorage">hydroStorage</code></td>
<td>
<p>Should hydro storage be imported ?</p>
</td></tr>
<tr><td><code id="readAntares_+3A_hydrostoragemaxpower">hydroStorageMaxPower</code></td>
<td>
<p>Should hydro storage maximum power be imported ?</p>
</td></tr>
<tr><td><code id="readAntares_+3A_reserve">reserve</code></td>
<td>
<p>Should reserve be imported ?</p>
</td></tr>
<tr><td><code id="readAntares_+3A_linkcapacity">linkCapacity</code></td>
<td>
<p>Should link capacities be imported ?</p>
</td></tr>
<tr><td><code id="readAntares_+3A_mustrun">mustRun</code></td>
<td>
<p>Should must run productions be added to the result? If TRUE,
then four columns are added: <code>mustRun</code> contains the production of
clusters that are in complete must run mode; <code>mustRunPartial</code>
contains the partial must run production of clusters; <code>mustRunTotal</code>
is the sum of the two previous columns. Finally <code>thermalPmin</code> is
similar to mustRunTotal except it also takes into account the production
induced by the minimum stable power of the units of a cluster. More
precisely, for a given cluster and a given time step, it is equal to
<code>min(NODU x min.stable.power, mustRunTotal)</code>.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_thermalmodulation">thermalModulation</code></td>
<td>
<p>Should thermal modulation time series be imported ? If <code>TRUE</code>, the
columns &quot;marginalCostModulation&quot;, &quot;marketBidModulation&quot;, &quot;capacityModulation&quot;
and &quot;minGenModulation&quot; are added to the cluster data.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_select">select</code></td>
<td>
<p>Character vector containing the name of the columns to import. If this
argument is <code>NULL</code>, all variables are imported. Special names
<code>"allAreas"</code> and <code>"allLinks"</code> indicate to the function to import
all variables for areas or for links. Since version 1.0, values &quot;misc&quot;,
&quot;thermalAvailabilities&quot;, &quot;hydroStorage&quot;, &quot;hydroStorageMaxPower&quot;, &quot;reserve&quot;,
&quot;linkCapacity&quot;, &quot;mustRun&quot;, &quot;thermalModulation&quot; are also accepted and can
replace the corresponding arguments. The list of available variables can be
seen with the command <code>simOptions()$variables</code>.  Id variables like
<code>area</code>, <code>link</code> or <code>timeId</code> are automatically imported.
Note that <code>select</code> is <em>not</em> taken into account when importing cluster
data.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_mcyears">mcYears</code></td>
<td>
<p>Index of the Monte-Carlo years to import. If <code>NULL</code>, synthetic results
are read, else the specified Monte-Carlo simulations are imported. The
special value <code>all</code> tells the function to import all Monte-Carlo
simulations.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_timestep">timeStep</code></td>
<td>
<p>Resolution of the data to import: hourly (default), daily,
weekly, monthly or annual.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_mcweights">mcWeights</code></td>
<td>
<p>Vector of weights to apply to the specified mcYears. If not <code>NULL</code>, the vector must
be the same length as the vector provided in the <code>mcYear</code> parameter. The function
<code>readAntares</code> will then return the weighted synthetic results for the specified years,
with the specified weights.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
<tr><td><code id="readAntares_+3A_parallel">parallel</code></td>
<td>
<p>Should the importation be parallelized ? (See details)</p>
</td></tr>
<tr><td><code id="readAntares_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE and only one type of output is imported then a
data.table is returned. If FALSE, the result will always be a list of class
&quot;antaresData&quot;.</p>
</td></tr>
<tr><td><code id="readAntares_+3A_showprogress">showProgress</code></td>
<td>
<p>If TRUE the function displays information about the progress of the
importation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If parameters <code>areas</code>, <code>links</code>, <code>clusters</code> and <code>districts</code>
are all <code>NULL</code>, <code>readAntares</code> will read output for all areas.
By default the function reads synthetic results if they are available.
</p>
<p><code>readAntares</code> is able to read input time series, but when they are not
stored in output, these time series may have changed since a simulation has
been run. In such a case the function will remind you this danger with a
warning.
</p>
<p>When individual Monte-Carlo simulations are read, the function may crash
because of insufficient memory. In such a case, it is necessary to reduce
size of the output. Different strategies are available depending on your
objective:
</p>

<ul>
<li><p> Use a larger time step (parameter <code>timeStep</code>)
</p>
</li>
<li><p> Filter the elements to import (parameters <code>areas</code>,<code>links</code>,
<code>clusters</code> and <code>districts</code>)
</p>
</li>
<li><p> Select only a few columns (parameter <code>select</code>)
</p>
</li>
<li><p> read only a subset of Monte-Carlo simulations (parameter
<code>mcYears</code>). For instance one can import a random sample of
100 simulations with <code>mcYears = sample(simOptions()$mcYears, 100)</code>
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>simplify = TRUE</code> and only one type of output is imported
then the result is a data.table.
</p>
<p>Else an object of class &quot;antaresDataList&quot; is returned. It is a list of
data.tables, each element representing one type of element (areas, links,
clusters)
</p>


<h3>Parallelization</h3>

<p>If you import several elements of the same type (areas, links, clusters), you
can use parallelized importation to improve performance. Setting the
parameter <code>parallel = TRUE</code> is not enough to parallelize the
importation, you also have to install the package
<a href="https://CRAN.R-project.org/package=foreach">foreach</a>
and a package that provides a parallel backend (for instance the package
<a href="https://CRAN.R-project.org/package=doParallel">doParallel</a>).
</p>
<p>Before running the function with argument <code>parallel=TRUE</code>, you need to
register your parallel backend. For instance, if you use package &quot;doParallel&quot;
you need to use the function <code>registerDoParallel</code> once per
session.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setSimulationPath">setSimulationPath</a></code>, <code><a href="#topic+getAreas">getAreas</a></code>,
<code><a href="#topic+getLinks">getLinks</a></code>, <code><a href="#topic+getDistricts">getDistricts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Import areas and links separately

areas &lt;- readAntares() # equivalent to readAntares(areas="all")
links &lt;- readAntares(links="all")

# Import areas and links at same time

output &lt;- readAntares(areas = "all", links = "all")

# Add input time series to the object returned by the function
areas &lt;- readAntares(areas = "all", misc = TRUE, reserve = TRUE)

# Get all output for one area

myArea &lt;- sample(simOptions()$areaList, 1)
myArea

myAreaOutput &lt;- readAntares(area = myArea,
                            links = getLinks(myArea, regexpSelect=FALSE),
                            clusters = myArea)

# Or equivalently:
myAreaOutput &lt;- readAntaresAreas(myArea)

# Use parameter "select" to read only some columns.

areas &lt;- readAntares(select = c("LOAD", "OV. COST"))

# Aliases can be used to select frequent groups of columns. use showAliases()
# to view a list of available aliases

areas &lt;- readAntares(select="economy")


## End(Not run)
</code></pre>

<hr>
<h2 id='readAntaresAreas'>Read output for a list of areas</h2><span id='topic+readAntaresAreas'></span>

<h3>Description</h3>

<p>This a function is a wrapper for &quot;antaresData&quot; that reads all data for a
list of areas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readAntaresAreas(
  areas,
  links = TRUE,
  clusters = TRUE,
  clustersRes = TRUE,
  internalOnly = FALSE,
  opts = simOptions(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readAntaresAreas_+3A_areas">areas</code></td>
<td>
<p>Vector containing area names. It represents the set of areas we are interested
in. If <code>NULL</code>, all areas of the study are used.</p>
</td></tr>
<tr><td><code id="readAntaresAreas_+3A_links">links</code></td>
<td>
<p>should links connected to the areas be imported ?</p>
</td></tr>
<tr><td><code id="readAntaresAreas_+3A_clusters">clusters</code></td>
<td>
<p>should the thermal clusters of the areas be imported ?</p>
</td></tr>
<tr><td><code id="readAntaresAreas_+3A_clustersres">clustersRes</code></td>
<td>
<p>should the renewable clusters of the areas be imported ?</p>
</td></tr>
<tr><td><code id="readAntaresAreas_+3A_internalonly">internalOnly</code></td>
<td>
<p>If <code>TRUE</code>, only links that connect two areas from parameter <code>areas</code> are returned.
If not, the function also returns all the links that connect an area from the list with
an area outside the list.</p>
</td></tr>
<tr><td><code id="readAntaresAreas_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
<tr><td><code id="readAntaresAreas_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the function <code><a href="#topic+readAntares">readAntares</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>simplify = TRUE</code> and only one type of output is imported
then the result is a data.table.
</p>
<p>Else an object of class &quot;antaresData&quot; is returned. It is a list of
data.tables, each element representing one type of element (areas, links,
clusters)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
myarea &lt;- simOptions()$areaList[1]
data &lt;- readAntaresAreas(myarea)

# Equivalent but more concise than:
data2 &lt;- readAntares(myarea, links = getLinks(myarea), clusters = myarea)

all.equal(data, data2)

## End(Not run)

</code></pre>

<hr>
<h2 id='readAntaresClusters'>Read output for a list of clusters</h2><span id='topic+readAntaresClusters'></span>

<h3>Description</h3>

<p>Read output for a list of clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readAntaresClusters(
  clusters,
  selected = c("production", "NP Cost", "NODU", "profit"),
  timeStep = c("hourly", "daily", "weekly", "monthly", "annual"),
  opts = simOptions(),
  parallel = FALSE,
  showProgress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readAntaresClusters_+3A_clusters">clusters</code></td>
<td>
<p>vector of thermal clusters to be imported</p>
</td></tr>
<tr><td><code id="readAntaresClusters_+3A_selected">selected</code></td>
<td>
<p>vector of thematic trimming</p>
</td></tr>
<tr><td><code id="readAntaresClusters_+3A_timestep">timeStep</code></td>
<td>
<p>Resolution of the data to import: hourly (default), daily,
weekly, monthly or annual.</p>
</td></tr>
<tr><td><code id="readAntaresClusters_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
<tr><td><code id="readAntaresClusters_+3A_parallel">parallel</code></td>
<td>
<p>Should the importation be parallelized ? (See details)</p>
</td></tr>
<tr><td><code id="readAntaresClusters_+3A_showprogress">showProgress</code></td>
<td>
<p>If TRUE the function displays information about the progress of the
importation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table of results for thermal clusters
</p>

<hr>
<h2 id='readAntaresSTClusters'>Read output for a list of short-term storage clusters</h2><span id='topic+readAntaresSTClusters'></span>

<h3>Description</h3>

<p>Read output for a list of short-term storage clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readAntaresSTClusters(
  clustersST,
  selected = c("P.injection", "levels", "P.withdrawal"),
  timeStep = c("hourly", "daily", "weekly", "monthly", "annual"),
  opts = simOptions(),
  parallel = FALSE,
  showProgress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readAntaresSTClusters_+3A_clustersst">clustersST</code></td>
<td>
<p>vector of short-term storage clusters to be imported</p>
</td></tr>
<tr><td><code id="readAntaresSTClusters_+3A_selected">selected</code></td>
<td>
<p>vector of thematic trimming</p>
</td></tr>
<tr><td><code id="readAntaresSTClusters_+3A_timestep">timeStep</code></td>
<td>
<p>Resolution of the data to import: hourly (default), daily,
weekly, monthly or annual.</p>
</td></tr>
<tr><td><code id="readAntaresSTClusters_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
<tr><td><code id="readAntaresSTClusters_+3A_parallel">parallel</code></td>
<td>
<p>Should the importation be parallelized ? (See details)</p>
</td></tr>
<tr><td><code id="readAntaresSTClusters_+3A_showprogress">showProgress</code></td>
<td>
<p>If TRUE the function displays information about the progress of the
importation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table of results for short-term storage clusters
</p>

<hr>
<h2 id='readBindingConstraints'>Read binding constraints</h2><span id='topic+readBindingConstraints'></span>

<h3>Description</h3>

<p><img src="../help/figures/badge_api_ok.svg" alt='Antares API OK' />
<a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This function reads the binding constraints of an Antares project.
</p>
<p>Be aware that binding constraints are read in the input files of a study. So
they may have changed since a simulation has been run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readBindingConstraints(opts = simOptions())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readBindingConstraints_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bindingConstraints</code>. This object is also a named
list with 3 sections per read constraint.
</p>


<h3>Warning</h3>

<p>Since <code style="white-space: pre;">&#8288;release 2.7.0&#8288;</code> the structure of the returned object has evolved for
all versions of study Antares:
</p>

<ul>
<li><p> .ini parameters are in section <code>properties</code>
</p>
</li>
<li><p> Coeffcients links or thermal are in section <code>coefs</code>
</p>
</li>
<li><p> Values are already in section <code>values</code>
</p>
</li></ul>



<h3>Note</h3>

<p>For an study Antares <strong>version &gt;=8.7.0</strong>. Now contains <code>data.frame</code> with
one line per time step and <code class="reqn">p</code> colums according to &quot;scenarized RHS&quot;.
</p>
<p>For &quot;both&quot; case, you will find in section <code>values</code> two <code>data.frame</code> :
</p>

<ul>
<li><p> One <code>data.frame</code> for <code>less</code>
</p>
</li>
<li><p> One <code>data.frame</code> for <code>greater</code>
</p>
</li></ul>

<p>For an study Antares <strong>version &lt;8.7.0</strong>.
</p>
<p>Section <code>values</code> contains one line
per time step and three columns &quot;less&quot;, &quot;greater&quot; and &quot;equal&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setSimulationPath()

constraints &lt;- readBindingConstraints()

# read properties
constraints$properties

# read coefs
constraints$coefs

# read values
constraints$values
  # both case ( study Antares &gt;=8.7.0)
constraints$values$less
constraints$values$greater

# display equation (only for study Antares &lt;8.7.0)
summary(constraints)


## End(Not run)

</code></pre>

<hr>
<h2 id='readClusterDesc'>Import clusters description</h2><span id='topic+readClusterDesc'></span><span id='topic+readClusterResDesc'></span><span id='topic+readClusterSTDesc'></span>

<h3>Description</h3>

<p>This function reads in the input files of an antares study the
characteristics of each cluster.
</p>
<p>Be aware that clusters descriptions are read
in the input files so they may have changed since a simulation has been run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readClusterDesc(opts = simOptions(), dot_format = TRUE)

readClusterResDesc(opts = simOptions(), dot_format = TRUE)

readClusterSTDesc(opts = simOptions(), dot_format = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readClusterDesc_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
<tr><td><code id="readClusterDesc_+3A_dot_format">dot_format</code></td>
<td>
<p><code>logical</code> default TRUE to return <code>character</code> with &quot;valid&quot; format (see <code><a href="base.html#topic+make.names">make.names()</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with one line per cluster. The columns of the data.table may
change between different projects, but there will always be the following
columns:
</p>
<table role = "presentation">
<tr><td><code>area</code></td>
<td>
<p>Name of the area containing the cluster</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>Name of the cluster</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>Type of cluster (gaz, nuclear, etc.)</p>
</td></tr>
<tr><td><code>unitcount</code></td>
<td>
<p>number of production units</p>
</td></tr>
<tr><td><code>nominalcapacity</code></td>
<td>
<p>production capacity of each unit</p>
</td></tr>
</table>
<p>The other present columns depends on the version of antares and the options
that have been set: if an option is unset for all clusters, it will not
appear in the table.
</p>
<p>By default, the function reads the cluster description of the default antares
study. You can use the argument <code>opts</code> to specify another study.
</p>
<p><code>readClusterDesc</code> : read thermal clusters
</p>
<p><code>readClusterResDesc</code> : read renewable clusters (Antares &gt;= V8.1)
</p>
<p><code>readClusterSTDesc</code> : read st-storage clusters (Antares &gt;= V8.6)
</p>
<p>If you have no clusters properties, <code style="white-space: pre;">&#8288;Null data.table (0 rows and 0 cols)&#8288;</code> is returned.
</p>


<h3>Warning</h3>

<p>You have now two format output to display input properties.
Default is format uses by operating team, eg <code>min.down.time</code>.
Other format is according to antares simulator, eg <code>min-down-time</code>.
</p>
<p>All properties are returned with default values according to Antares Study version.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Default format with "dot separator"

# thermal
readClusterDesc()

# renewable
readClusterResDesc()

# st-storage
readClusterSTDesc()

# Antares Simulator format 

#' # thermal
readClusterDesc(dot_format = FALSE)

# renewable
readClusterResDesc(dot_format = FALSE)

# st-storage
readClusterSTDesc(dot_format = FALSE)


# By default, the function reads cluster descriptions for the default study,
# but it is possible to specify another study with parameter "opts"
sim1 &lt;- setSimulationPath()

#[... code that modifies the default antares study]

readClusterDesc(sim1)


## End(Not run)

</code></pre>

<hr>
<h2 id='readDigestFile'>Read digest file</h2><span id='topic+readDigestFile'></span>

<h3>Description</h3>

<p>Read digest file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDigestFile(opts, endpoint = "mc-all/grid/digest.txt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readDigestFile_+3A_opts">opts</code></td>
<td>
<p>simulation options</p>
</td></tr>
<tr><td><code id="readDigestFile_+3A_endpoint">endpoint</code></td>
<td>
<p>Suffix of path for digest file
Default is : &quot;mc-all/grid/digest.txt&quot; added to opts$simDataPath</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 5 tables (begin, areas, middle, links lin., links quad.)
</p>

<hr>
<h2 id='readInputRES'>Read Input RES time series</h2><span id='topic+readInputRES'></span>

<h3>Description</h3>

<p><code>readInputRes</code> is a function that reads renewable time series from an antares
project. But contrary to <code><a href="#topic+readAntares">readAntares</a></code>, it only reads time series
stored in the input folder, so it can work in &quot;input&quot; mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readInputRES(
  areas = "all",
  clusters,
  opts = simOptions(),
  timeStep = c("hourly", "daily", "weekly", "monthly", "annual"),
  simplify = TRUE,
  parallel = FALSE,
  showProgress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readInputRES_+3A_areas">areas</code></td>
<td>
<p>vector of RES areas names for which renewable time series must be read.</p>
</td></tr>
<tr><td><code id="readInputRES_+3A_clusters">clusters</code></td>
<td>
<p>vector of RES clusters names for which renewable time series must be read.</p>
</td></tr>
<tr><td><code id="readInputRES_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
<tr><td><code id="readInputRES_+3A_timestep">timeStep</code></td>
<td>
<p>Resolution of the data to import: hourly (default), daily,
weekly, monthly or annual.</p>
</td></tr>
<tr><td><code id="readInputRES_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE and only one type of output is imported then a
data.table is returned. If FALSE, the result will always be a list of class
&quot;antaresData&quot;.</p>
</td></tr>
<tr><td><code id="readInputRES_+3A_parallel">parallel</code></td>
<td>
<p>Should the importation be parallelized ? (See details)</p>
</td></tr>
<tr><td><code id="readInputRES_+3A_showprogress">showProgress</code></td>
<td>
<p>If TRUE the function displays information about the progress of the
importation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table with class &quot;antaresDataTable&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setSimulationPath">setSimulationPath</a></code>, <code><a href="#topic+readAntares">readAntares</a></code>,
<code><a href="#topic+getAreas">getAreas</a></code>, <code><a href="#topic+getLinks">getLinks</a></code>
</p>

<hr>
<h2 id='readInputThermal'>Read Input thermal time series</h2><span id='topic+readInputThermal'></span>

<h3>Description</h3>

<p><code>readInputThermal</code> is a function that reads thermal time series from an antares
project. But contrary to <code><a href="#topic+readAntares">readAntares</a></code>, it only reads time series
stored in the input folder, so it can work in &quot;input&quot; mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readInputThermal(
  areas = "all",
  clusters,
  thermalAvailabilities = TRUE,
  thermalModulation = FALSE,
  thermalData = FALSE,
  opts = simOptions(),
  timeStep = c("hourly", "daily", "weekly", "monthly", "annual"),
  simplify = TRUE,
  parallel = FALSE,
  showProgress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readInputThermal_+3A_areas">areas</code></td>
<td>
<p>vector of areas names for which thermal time series must be read.</p>
</td></tr>
<tr><td><code id="readInputThermal_+3A_clusters">clusters</code></td>
<td>
<p>vector of clusters names for which thermal time series must be read.</p>
</td></tr>
<tr><td><code id="readInputThermal_+3A_thermalavailabilities">thermalAvailabilities</code></td>
<td>
<p>if TRUE, return thermalAvailabilities data</p>
</td></tr>
<tr><td><code id="readInputThermal_+3A_thermalmodulation">thermalModulation</code></td>
<td>
<p>if TRUE, return thermalModulation data</p>
</td></tr>
<tr><td><code id="readInputThermal_+3A_thermaldata">thermalData</code></td>
<td>
<p>if TRUE, return thermalData from prepro</p>
</td></tr>
<tr><td><code id="readInputThermal_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
<tr><td><code id="readInputThermal_+3A_timestep">timeStep</code></td>
<td>
<p>Resolution of the data to import: hourly (default), daily,
weekly, monthly or annual.</p>
</td></tr>
<tr><td><code id="readInputThermal_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE and only one type of output is imported then a
data.table is returned. If FALSE, the result will always be a list of class
&quot;antaresData&quot;.</p>
</td></tr>
<tr><td><code id="readInputThermal_+3A_parallel">parallel</code></td>
<td>
<p>Should the importation be parallelized ? (See details)</p>
</td></tr>
<tr><td><code id="readInputThermal_+3A_showprogress">showProgress</code></td>
<td>
<p>If TRUE the function displays information about the progress of the
importation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If thermalModulation or thermalData is TRUE, an object of class &quot;antaresDataList&quot; is returned. It is a list of
data.tables for selected input
</p>
<p>Else the result is a data.table with class &quot;antaresDataTable&quot;.
</p>


<h3>Note</h3>

<p>the clusters parameter can also accept the special value &quot;all&quot;.
It indicates the function to read the desired time series for all clusters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setSimulationPath">setSimulationPath</a></code>, <code><a href="#topic+readAntares">readAntares</a></code>,
<code><a href="#topic+getAreas">getAreas</a></code>, <code><a href="#topic+getLinks">getLinks</a></code>
</p>

<hr>
<h2 id='readInputTS'>Read Input time series</h2><span id='topic+readInputTS'></span>

<h3>Description</h3>

<p><img src="../help/figures/badge_api_ok.svg" alt='Antares API OK' />
</p>
<p><code>readInputTS</code> is a function that reads time series from an antares
project. But contrary to <code><a href="#topic+readAntares">readAntares</a></code>, it only reads time series
stored in the input folder, so it can work in &quot;input&quot; mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readInputTS(
  load = NULL,
  thermalAvailabilities = NULL,
  ror = NULL,
  mingen = NULL,
  hydroStorage = NULL,
  hydroStorageMaxPower = NULL,
  wind = NULL,
  solar = NULL,
  misc = NULL,
  reserve = NULL,
  linkCapacity = NULL,
  resProduction = NULL,
  st_storage = NULL,
  opts = simOptions(),
  timeStep = c("hourly", "daily", "weekly", "monthly", "annual"),
  simplify = TRUE,
  parallel = FALSE,
  showProgress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readInputTS_+3A_load">load</code></td>
<td>
<p>vector of areas names for which load time series must be read.</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_thermalavailabilities">thermalAvailabilities</code></td>
<td>
<p>vector of areas names for which thermal availabilities of clusters must be read.</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_ror">ror</code></td>
<td>
<p>vector of areas names for which run of river time series must be read.</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_mingen">mingen</code></td>
<td>
<p>vector of areas names for which Hydro Pmin time series must be read.
(only for Antares version &gt;= 860)</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_hydrostorage">hydroStorage</code></td>
<td>
<p>vector of areas names for which hydrolic storage time series must be read.</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_hydrostoragemaxpower">hydroStorageMaxPower</code></td>
<td>
<p>vector of areas names for which hydrolic storage maximum power time series must be read.</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_wind">wind</code></td>
<td>
<p>vector of areas names for which wind time series must be read</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_solar">solar</code></td>
<td>
<p>vector of areas names for which solar time series must be read</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_misc">misc</code></td>
<td>
<p>vector of areas names for which misc time series must be read</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_reserve">reserve</code></td>
<td>
<p>vector of areas names for which reserve time series must be read</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_linkcapacity">linkCapacity</code></td>
<td>
<p>vector of links names for which links characteristics time series must be read</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_resproduction">resProduction</code></td>
<td>
<p>vector of areas names for which renewables clusters production time series must be read.</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_st_storage">st_storage</code></td>
<td>
<p>vector of areas names for which st-storage clusters production time series must be read.</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
<tr><td><code id="readInputTS_+3A_timestep">timeStep</code></td>
<td>
<p>Resolution of the data to import: hourly (default), daily,
weekly, monthly or annual.</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE and only one type of output is imported then a
data.table is returned. If FALSE, the result will always be a list of class
&quot;antaresData&quot;.</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_parallel">parallel</code></td>
<td>
<p>Should the importation be parallelized ? (See details)</p>
</td></tr>
<tr><td><code id="readInputTS_+3A_showprogress">showProgress</code></td>
<td>
<p>If TRUE the function displays information about the progress of the
importation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>simplify = TRUE</code> and only one type of input is imported
then the result is a data.table with class &quot;antaresDataTable&quot;.
</p>
<p>Else an object of class &quot;antaresDataList&quot; is returned. It is a list of
data.tables, each element representing one type of element (load, wind,
solar, etc.).
</p>


<h3>Note</h3>

<p>All parameters expecting a vector of areas or links names also accept the
special value &quot;all&quot;. It indicates the function to read the desired time
series for all areas or links.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setSimulationPath">setSimulationPath</a></code>, <code><a href="#topic+readAntares">readAntares</a></code>,
<code><a href="#topic+getAreas">getAreas</a></code>, <code><a href="#topic+getLinks">getLinks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Set an antares study in "input" mode. This is useful when one want to
# inspect input time series before running a simulation.
# Note that readAntares do not function in input mode, but readInputTS
# works with any mode.

setSimulationPath("path_to_the_study", "input")

# Read load time series
readInputTS(load = "all")

# Read hydrolic storage and maximum power in the same call:
readInputTS(hydroStorage = "all", hydroStorageMaxPower = "all")

# Use a different time step
myArea &lt;- readInputTS(load= "myArea", timeStep = "monthly")

# Quick plot to visualize the variability of the series
matplot(myArea[, - (1:2), with = FALSE], type = "l")

## End(Not run)

</code></pre>

<hr>
<h2 id='readLayout'>Read areas layout</h2><span id='topic+readLayout'></span>

<h3>Description</h3>

<p>This function reads in the input files of an antares study the current areas
layout, ie. the position of the areas It may be useful for plotting the
network.
</p>
<p>Be aware that the layout is read in the input files so they may have
changed since a simulation has been run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readLayout(opts = simOptions(), xyCompare = c("union", "intersect"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readLayout_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
<tr><td><code id="readLayout_+3A_xycompare">xyCompare</code></td>
<td>
<p>Use when passing multiple opts, can be &quot;union&quot; or &quot;intersect&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements:
</p>
<table role = "presentation">
<tr><td><code>areas:</code></td>
<td>
<p>A data.frame containing the name, the color and the coordinate
of each area</p>
</td></tr>
<tr><td><code>district:</code></td>
<td>
<p>A data.frame containing the name, the color and the coordinate
of each district</p>
</td></tr>
<tr><td><code>links:</code></td>
<td>
<p>A data.frame containing the name, the coordinates of the origin
and the destination of each link</p>
</td></tr>
</table>
<p>By default, <code>readLayout</code> reads the layout for the current default
antares study. It is possible to specify another study with the parameter
<code>opts</code>. And we can pass multiple studies using a <code>list</code> of opts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
readLayout()

# By default, the function reads layout for the default study,
# but it is possible to specify another study with parameter "opts"
sim1 &lt;- setSimulationPath()

#[... code that modifies the default antares study]

readLayout(sim1)


## End(Not run)

</code></pre>

<hr>
<h2 id='readOptimCriteria'>Read Optimization Criteria</h2><span id='topic+readOptimCriteria'></span>

<h3>Description</h3>

<p>This function can be used to read the value of the criteria optimized by ANTARES.
Notice that these values are only available in &quot;Xpansion&quot; mode or when option
&quot;Export mps&quot; is turned on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readOptimCriteria(opts = simOptions())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readOptimCriteria_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPath">setSimulationPath</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of class <code>antaresDataTable</code>. It contains the usual columns
<code>timeID</code>, <code>mcYear</code>, <code>time</code> and two columns &quot;criterion1&quot; and
&quot;criterion2&quot; containing the values of the criteria. Time step can be daily
or weekly depending on the optimization options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setSimulationPath()

optimCriteria &lt;- readOptimCriteria()

## End(Not run) 

</code></pre>

<hr>
<h2 id='removeVirtualAreas'>Remove virtual areas</h2><span id='topic+removeVirtualAreas'></span>

<h3>Description</h3>

<p>This function removes virtual areas from an <code>antaresDataList</code> object and
corrects the data for the real areas. The <code>antaresDataList</code> object
should contain area and link data to function correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeVirtualAreas(
  x,
  storageFlexibility = NULL,
  production = NULL,
  reassignCosts = FALSE,
  newCols = TRUE,
  rowBal = TRUE,
  prodVars = getAlias("rmVA_production"),
  costsVars = c("OV. COST", "OP. COST", "CO2 EMIS.", "NP COST"),
  costsOn = c("both", "storageFlexibility", "production")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeVirtualAreas_+3A_x">x</code></td>
<td>
<p>An object of class <code>antaresDataList</code> with at least components
<code>areas</code> and <code>links</code>.</p>
</td></tr>
<tr><td><code id="removeVirtualAreas_+3A_storageflexibility">storageFlexibility</code></td>
<td>
<p>A vector containing the names of the virtual
storage/flexibility areas. Can also be a named list. Names are columns
to add and elements the virtual areas to group.</p>
</td></tr>
<tr><td><code id="removeVirtualAreas_+3A_production">production</code></td>
<td>
<p>A vector containing the names of the virtual production
areas.</p>
</td></tr>
<tr><td><code id="removeVirtualAreas_+3A_reassigncosts">reassignCosts</code></td>
<td>
<p>If TRUE, the production costs of the virtual areas are
reallocated to the real areas they are connected to. If the virtual areas
are connected to a virtual hub, their costs are first reallocated to the
hub and then the costs of the hub are reallocated to the real areas.</p>
</td></tr>
<tr><td><code id="removeVirtualAreas_+3A_newcols">newCols</code></td>
<td>
<p>If <code>TRUE</code>, new columns containing the production of the virtual
areas are added. If FALSE their production is added to the production of
the real areas they are connected to.</p>
</td></tr>
<tr><td><code id="removeVirtualAreas_+3A_rowbal">rowBal</code></td>
<td>
<p>If <code>TRUE</code>, then BALANCE will be corrected by ROW. BAL:
BALANCE := BALANCE - &quot;ROW. BAL&quot;</p>
</td></tr>
<tr><td><code id="removeVirtualAreas_+3A_prodvars">prodVars</code></td>
<td>
<p>Virtual productions columns to add to real area.
Default to <code>getAlias("rmVA_production")</code></p>
</td></tr>
<tr><td><code id="removeVirtualAreas_+3A_costsvars">costsVars</code></td>
<td>
<p>If parameter <code>reassignCosts</code> is TRUE, affected columns.
Default to <code>OV. COST</code>, <code>OP. COST</code>, <code>CO2 EMIS.</code> and <code>NP COST</code></p>
</td></tr>
<tr><td><code id="removeVirtualAreas_+3A_costson">costsOn</code></td>
<td>
<p>If parameter <code>reassignCosts</code> is TRUE, then the costs of the
virtual areas are reassigned to the real areas they are connected to.
You can choose to reassigned production &amp; storageFlexibility virtuals areas
(&quot;both&quot;, default), or only &quot;production&quot; or &quot;storageFlexibility&quot; virtuals areas</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two types of virtual areas have been defined corresponding to different types
of modeling in Antares and different types of post-treatment to do:
</p>

<ul>
<li><p> Flexibility/storage areas are areas created to model
pumping unit or any other flexibility that behave as a storage. For those
virtual areas, the important results are flows on the links.
</p>
</li>
<li><p> Production areas are areas created to isolate some generation from
the &quot;real&quot; areas. They can be isolate for several reasons: to distinguish
time-series (for example wind onshore/offshore), to select some specific
unit to participate to day-ahead reserve, etc.
</p>
</li></ul>

<p><code>removeVirtualAreas</code> performs different corrections:
</p>

<ul>
<li><p> Correct the balance of the real areas (and districts) by removing the flows
to or from virtual areas.
</p>
</li>
<li><p> If parameter <code>reassignCosts</code> is TRUE, then the costs of the
virtual areas are reassigned to the real areas they are connected to. The
default affected columns are <code>OV. COST</code>, <code>OP. COST</code>, <code>CO2 EMIS.</code>
and <code>NP COST</code>. If a virtual area is connected to a single real area,
all its costs are attributed to the real area. If it is connected to
several real areas, then costs at a given time step are divided between
them proportionally to the flows between them and the virtual area.
An aggregation is done at the end to correct districts costs.
</p>
</li>
<li><p> For each storage/flexibility area, a column named like the area is
created. It contains the values of the flow between the virtual area and
the real areas. This column is interpreted as a production of
electricity: it is positive if the flow from the virtual area to the real
area is positive and negative otherwise. If parameter <code>newCols</code> is
<code>FALSE</code>, the values are added to the variable <code>PSP</code> and the
columns is removed.
An aggregation is done at the end to add virtual storage/flexibility to districts.
</p>
</li>
<li><p> If the parameter <code>production</code> is specified, then the non null
productions of the virtual areas are either added to the ones of the real
areas they are connected to if <code>newCols = FALSE</code> or put in new
columns if <code>newCols = TRUE</code>. In the second case the columns are
named <code>*_virtual</code> where &quot;<code>*</code>&quot; is a type of
production (wind, solar, nuclear, ...). Productions that are zero for
all virtual areas are omited.
If virtual production areas contains clusters then they will be move to the
real area.
An aggregation is done at the end to add virtual production to districts.
</p>
</li>
<li><p> Finally, virtual areas and the links connected to them are removed
from the data.
</p>
</li></ul>

<p>The functions makes a few assumptions about the network. If they are
violated it will not act correctly:
</p>

<ul>
<li><p> storage/flexibility
areas can be connected to other storage/flexibility areas (hubs), but at
least one of them is connected to a real area. That means that there is
no group of virtual areas disconnected from the real network. If such a
group exists, you can either remove them manually or simply not import
them.
</p>
</li>
<li><p> production areas are connected to one and only one real area. They
cannot be connected to virtual areas. But a real area may by connected to
several production areas.
</p>
</li></ul>



<h3>Value</h3>

<p>An <code>antaresDataList</code> object in which virtual areas have been removed and
data of the real has been corrected. See details for an explanation of the
corrections.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Assume we have a network with two virtual areas acting as pump storage and
# an area representing offshore production
#
#  offshore
#     |
# real area - psp in
#           \
#             psp out
#

data &lt;- readAntares(areas="all", links="all")

# Remove pump storage virtual areas

correctedData &lt;- removeVirtualAreas(
    x = data, 
    storageFlexibility = c("psp in", "psp out"),
    production = "offshore"
)
                                    
correctedData_list &lt;- removeVirtualAreas(
    x = data, 
    storageFlexibility = list(PSP = c("psp in", "psp out")),
    production = "offshore"
)
 
                                   
correctedData_details &lt;- removeVirtualAreas(
    x = data, 
    storageFlexibility = list(PSP_IN = "psp in", PSP_OUT =  "psp out"),
    production = "offshore"
)
                                    

## End(Not run)

</code></pre>

<hr>
<h2 id='setHvdcAreas'>Set hvdc areas</h2><span id='topic+setHvdcAreas'></span>

<h3>Description</h3>

<p>This function add hvdc attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setHvdcAreas(data, areas)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setHvdcAreas_+3A_data">data</code></td>
<td>
<p><code>antaresData</code> or <code>antaresDatalist</code> data.</p>
</td></tr>
<tr><td><code id="setHvdcAreas_+3A_areas">areas</code></td>
<td>
<p><code>character</code> hvdc areas list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;antaresDataList&quot; is returned.
It is a list of data.tables, each element representing one type of element (areas, links, clusters)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(antaresRead)
opts &lt;- setSimulationPath('mypath', 1)
myAreaOutput &lt;- readAntares(areas = "all", links = "all")
myAreaOutput &lt;- setHvdcAreas(myAreaOutput, "y_dsr")



## End(Not run)

</code></pre>

<hr>
<h2 id='setRam'>Specify RAM limit</h2><span id='topic+setRam'></span>

<h3>Description</h3>

<p>This function specify RAM limit (in Go) of the value returned by <a href="#topic+readAntares">readAntares</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setRam(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setRam_+3A_x">x</code></td>
<td>
<p><code>numeric</code> RAM limit in Go</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> (returned by <code><a href="base.html#topic+options">options()</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Set maximum ram to used to 50 Go
setRam(50)

## End(Not run)

</code></pre>

<hr>
<h2 id='setSimulationPath'>Set Path to an Antares simulation</h2><span id='topic+setSimulationPath'></span><span id='topic+setSimulationPathAPI'></span>

<h3>Description</h3>

<p>This function has to be used before the <code>read</code> functions. It sets the path to
the Antares simulation to work on and other useful options (list of areas,
links, areas with clusters, variables, etc.). On local disk with <code>setSimulationPath</code> or
on an AntaREST API with <code>setSimulationPathAPI</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSimulationPath(path, simulation = NULL)

setSimulationPathAPI(
  host,
  study_id,
  token,
  simulation = NULL,
  timeout = 60,
  httr_config = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setSimulationPath_+3A_path">path</code></td>
<td>
<p>(optional)
Path to the simulation. It can either be the path to a directory containing
an antares project or directly to the directory containing the output of a
simulation.  If missing, a window opens and lets the user choose the
directory of the simulation interactively. Can also choose .h5 file, if <code>rhdf5</code> is installed.</p>
</td></tr>
<tr><td><code id="setSimulationPath_+3A_simulation">simulation</code></td>
<td>
<p>(optional) Only used if &quot;path&quot; represents the path of a study and not of the
output of a simulation. It can be either the name of the simulation or a
number indicating which simulation to use. It is possible to use negative
values to select a simulation from the last one: for instance -1 will
select the most recent simulation, -2 will the penultimate one, etc. There
are two special values 0 and &quot;input&quot; that tells the function that the user
is not interested by the results of any simulation, but only by the inputs.
In such a case, the function <code><a href="#topic+readAntares">readAntares</a></code> is unavailable.</p>
</td></tr>
<tr><td><code id="setSimulationPath_+3A_host">host</code></td>
<td>
<p><code>character</code> host of AntaREST server API</p>
</td></tr>
<tr><td><code id="setSimulationPath_+3A_study_id">study_id</code></td>
<td>
<p><code>character</code> id of the target study on the API</p>
</td></tr>
<tr><td><code id="setSimulationPath_+3A_token">token</code></td>
<td>
<p><code>character</code> API personnal access token</p>
</td></tr>
<tr><td><code id="setSimulationPath_+3A_timeout">timeout</code></td>
<td>
<p><code>numeric</code> API timeout (seconds). Default to 60. See also <code><a href="#topic+setTimeoutAPI">setTimeoutAPI</a></code></p>
</td></tr>
<tr><td><code id="setSimulationPath_+3A_httr_config">httr_config</code></td>
<td>
<p>API httr configuration. See <code><a href="httr.html#topic+config">config</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation chosen with <code>setSimulationPath</code> or <code>setSimulationPathAPI</code> becomes the default
simulation for all functions of the package. This behavior is fine when
working on only one simulation, but it may become problematic when working
on multiple simulations at same time.
</p>
<p>In such case, you can store the object returned by the function in a variable
and pass this variable to the functions of the package (see examples).
</p>


<h3>Value</h3>

<p>A list containing various information about the simulation, in particular:
</p>
<table role = "presentation">
<tr><td><code>studyPath</code></td>
<td>
<p>path of the Antares study</p>
</td></tr>
<tr><td><code>simPath</code></td>
<td>
<p>path of the simulation</p>
</td></tr>
<tr><td><code>inputPath</code></td>
<td>
<p>path of the input folder of the study</p>
</td></tr>
<tr><td><code>studyName</code></td>
<td>
<p>Name of the study</p>
</td></tr>
<tr><td><code>simDataPath</code></td>
<td>
<p>path of the folder containing the data of the simulation</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>name of the simulation</p>
</td></tr>
<tr><td><code>mode</code></td>
<td>
<p>type of simulation: economy, adequacy, draft or input</p>
</td></tr>
<tr><td><code>synthesis</code></td>
<td>
<p>Are synthetic results available ?</p>
</td></tr>
<tr><td><code>yearByYear</code></td>
<td>
<p>Are the results for each Monte Carlo simulation available ?</p>
</td></tr>
<tr><td><code>scenarios</code></td>
<td>
<p>Are the Monte-Carlo scenarii stored in output ? This is
important to reconstruct some input time series that have been used in
each Monte-Carlo simulation.</p>
</td></tr>
<tr><td><code>mcYears</code></td>
<td>
<p>Vector containing the number of the exported Monte-Carlo scenarios</p>
</td></tr>
<tr><td><code>antaresVersion</code></td>
<td>
<p>Version of Antares used to run the simulation.</p>
</td></tr>
<tr><td><code>areaList</code></td>
<td>
<p>Vector of the available areas.</p>
</td></tr>
<tr><td><code>districtList</code></td>
<td>
<p>Vector of the available districts.</p>
</td></tr>
<tr><td><code>linkList</code></td>
<td>
<p>Vector of the available links.</p>
</td></tr>
<tr><td><code>areasWithClusters</code></td>
<td>
<p>Vector of areas containing clusters.</p>
</td></tr>
<tr><td><code>areasWithResClusters</code></td>
<td>
<p>Vector of areas containing clusters renewable.</p>
</td></tr>
<tr><td><code>areasWithSTClusters</code></td>
<td>
<p>Vector of areas containing clusters storage (&gt;=v8.6.0).</p>
</td></tr>
<tr><td><code>variables</code></td>
<td>
<p>Available variables for areas, districts and links.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Other parameters of the simulation.</p>
</td></tr>
<tr><td><code>binding</code></td>
<td>
<p>Table of time series dimensions for each group (&gt;=v8.7.0).</p>
</td></tr>
<tr><td><code>timeIdMin</code></td>
<td>

<p>Minimum time id of the simulation. It is generally equal to one but can
be higher if working on a subperiod.
</p>
</td></tr>
<tr><td><code>timeIdMax</code></td>
<td>
<p>maximum time id of the simulation.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>

<p>Date of the first day of the year in the simulation. This date corresponds
to timeId = 1.
</p>
</td></tr>
<tr><td><code>firstWeekday</code></td>
<td>
<p>First day of the week.</p>
</td></tr>
<tr><td><code>districtsDef</code></td>
<td>
<p>data.table containing the specification of the districts.</p>
</td></tr>
<tr><td><code>energyCosts</code></td>
<td>
<p>list containing the cost of spilled and unsupplied energy.</p>
</td></tr>
<tr><td><code>verbose</code></td>
<td>
<p><code>logical</code> default to FALSE, put to TRUE to manage diagnostic messages</p>
</td></tr>
<tr><td><code>sleep</code></td>
<td>
<p>timer for api commande execute</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+simOptions">simOptions</a></code>, <code><a href="#topic+readAntares">readAntares</a></code>, <code><a href="#topic+readLayout">readLayout</a></code>,
<code><a href="#topic+readClusterDesc">readClusterDesc</a></code>, <code><a href="#topic+readBindingConstraints">readBindingConstraints</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Select interactively a study. It only works on windows.

setSimulationPath()

# Specify path of the study. Note: if there are more than one simulation
# output in the study, the function will asks the user to interactively choose
# one simulation.

setSimulationPath("path_of_the_folder_of_the_study")

# Select the first simulation of a study

setSimulationPath("path_of_the_folder_of_the_study", 1)

# Select the last simulation of a study

setSimulationPath("path_of_the_folder_of_the_study", -1)

# Select a simulation by name

setSimulationPath("path_of_the_folder_of_the_study", "name of the simulation")

# Just need to read input data

setSimulationPath("path_of_the_folder_of_the_study", "input")
# or
setSimulationPath("path_of_the_folder_of_the_study", 0)

# Working with API
#--------------------------
setSimulationPathAPI(
    host = "http://antares_api_adress", 
    study_id = "study_id_on_api", 
    token = "token"
)

## Custom httr options ?

# global using httr package
require(httr)
set_config(verbose())
setSimulationPathAPI(
    host = "http://antares_api_adress", 
    study_id = "study_id_on_api", 
    token = "token"
)

reset_config()

# or in setSimulationPathAPI
setSimulationPathAPI(
    host = "http://antares_api_adress", 
    study_id = "study_id_on_api", 
    token = "token",
    httr_config = config(verbose = TRUE)
)

# disable ssl certificate checking ?
setSimulationPathAPI(
    host = "http://antares_api_adress", 
    study_id = "study_id_on_api", 
    token = "token",
    httr_config = config(ssl_verifypeer = FALSE)
)

# WORKING WITH MULTIPLE SIMULATIONS
#----------------------------------
# Let us assume ten simulations have been run and we want to collect the
# variable "LOAD" for each area. We can create a list containing options
# for each simulation and iterate through this list.

opts &lt;- lapply(1:10, function(i) {
   setSimulationPath("path_of_the_folder_of_the_study", i)
})

output &lt;- lapply(opts, function(o) {
  res &lt;- readAntares(areas = "all", select = "LOAD", timeStep = "monthly", opts = o)
  # Add a column "simulation" containing the name of the simulation
  res$simulation &lt;- o$name
  res
})

# Concatenate all the tables in one super table
output &lt;- rbindlist(output)

# Reshape output for easier comparisons: one line per timeId and one column
# per simulation
output &lt;- dcast(output, timeId + areaId ~ simulation, value.var = "LOAD")

output

# Quick visualization
matplot(output[area == area[1], !c("area", "timeId"), with = FALSE], 
        type = "l")

## End(Not run)

</code></pre>

<hr>
<h2 id='setTimeoutAPI'>Change API Timeout</h2><span id='topic+setTimeoutAPI'></span>

<h3>Description</h3>

<p>Change API Timeout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTimeoutAPI(opts, timeout)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setTimeoutAPI_+3A_opts">opts</code></td>
<td>
<p>list of simulation parameters returned by the function
<code><a href="#topic+setSimulationPathAPI">setSimulationPathAPI</a></code></p>
</td></tr>
<tr><td><code id="setTimeoutAPI_+3A_timeout">timeout</code></td>
<td>
<p><code>numeric</code> API timeout (seconds). Default to 60.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>simOptions</code>, list of options used to read the data contained in the last
simulation read by <code><a href="#topic+setTimeoutAPI">setTimeoutAPI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
opts &lt;- setTimeoutAPI(opts, timeout = 45)

## End(Not run)

</code></pre>

<hr>
<h2 id='showAliases'>show aliases for variables</h2><span id='topic+showAliases'></span><span id='topic+setAlias'></span><span id='topic+getAlias'></span>

<h3>Description</h3>

<p>Aliases are short names that can be used in the <code>select</code> parameter in
function <code><a href="#topic+readAntares">readAntares</a></code> to tell the function which columns and/or
type of data to import.
</p>
<p><code>setAlias</code> can be used to create a new alias. It can be especially
useful for package developers to help their users select the data required
by their packages.
</p>
<p><code>getAlias</code> return character vector containing columns and/or types of data
</p>
<p><code>showAliases</code> lists available aliases
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showAliases(names = NULL)

setAlias(name, desc, select)

getAlias(name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="showAliases_+3A_names">names</code></td>
<td>
<p>optional vector of alias names. If provided, the full list of
columns selected by these aliases is displayed. Else only the name and a
short description of all aliases is displayed.</p>
</td></tr>
<tr><td><code id="showAliases_+3A_name">name</code></td>
<td>
<p>Alias name</p>
</td></tr>
<tr><td><code id="showAliases_+3A_desc">desc</code></td>
<td>
<p>Short description indicating why the new alias is interesting</p>
</td></tr>
<tr><td><code id="showAliases_+3A_select">select</code></td>
<td>
<p>character vector containing columns and/or types of data to
import.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setAlias</code> is only used for its side effects. A data.frame with columns
'name', 'desc' and 'select'. <code>showAliases</code> invisibly returns a
data.frame with columns &quot;name&quot;, &quot;desc&quot; and &quot;select&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Display the short description of an alias
showAliases()

# Display the full description of an alias
showAliases("renewable")

getAlias("renewable")

## Not run: 
# Create a new alias that imports flows
setAlias("test", "short description", c("links", "FLOW LIN.")) 
showAliases()

## End(Not run)

</code></pre>

<hr>
<h2 id='simOptions'>Extract simulation options</h2><span id='topic+simOptions'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+readAntares">readAntares</a></code> stores in its output the options used
to read some data (path of the study, area list, link list, start date,
etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simOptions(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simOptions_+3A_x">x</code></td>
<td>
<p>object of class <code>antaresTable</code> or <code>antaresData</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simOptions</code> extracts these options from an object of class
<code>antaresTable</code> or <code>antaresOutput</code>. It can be useful when working on
multiple simulations, either to check how some object has been created or to
use it in some functions like <code><a href="#topic+getAreas">getAreas</a></code> or
<code><a href="#topic+getLinks">getLinks</a></code>
</p>
<p>If the parameter of the function is <code>NULL</code>, it returns the default
simulation options, that is the options set by <code><a href="#topic+setSimulationPath">setSimulationPath</a></code>
the last time it was run.
</p>


<h3>Value</h3>

<p>list of options used to read the data contained in an object or the last
simulation options read by <code><a href="#topic+setSimulationPath">setSimulationPath</a></code> if <code>x</code> is
<code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  setSimulationPath(study1)
  
  simOptions() # returns the options for study 1
  
  data &lt;- readAntares()
  
  # Choose a different study
  setSimulationPath(study2)
  
  simOptions() # returns the options for study 2
  
  getAreas() # returns the areas of the secund study
  getAreas(opts = simOptions(data)) # returns the areas of the first study
  

## End(Not run)

</code></pre>

<hr>
<h2 id='subset.antaresDataList'>Subset an antaresDataList</h2><span id='topic+subset.antaresDataList'></span>

<h3>Description</h3>

<p>Subset method for <code>antaresDataList</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'antaresDataList'
subset(x, y = NULL, areas = NULL, timeIds = NULL, mcYears = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.antaresDataList_+3A_x">x</code></td>
<td>
<p>Object of class <code>antaresDataList</code> created with
<code><a href="#topic+readAntares">readAntares</a></code>.</p>
</td></tr>
<tr><td><code id="subset.antaresDataList_+3A_y">y</code></td>
<td>
<p>A table containing at least one of the columns &quot;area&quot;, &quot;timeId&quot; or
&quot;mcYear&quot;. If it is not <code>NULL</code>, then only tuples <code>(area, timeId,
  mcYear)</code> present in this table are kept.</p>
</td></tr>
<tr><td><code id="subset.antaresDataList_+3A_areas">areas</code></td>
<td>
<p>Vector of area names to keep in the result. If <code>NULL</code>, all
areas are kept.</p>
</td></tr>
<tr><td><code id="subset.antaresDataList_+3A_timeids">timeIds</code></td>
<td>
<p>Vector of time ids to keep. If <code>NULL</code>, all time ids are
kept.</p>
</td></tr>
<tr><td><code id="subset.antaresDataList_+3A_mcyears">mcYears</code></td>
<td>
<p>Vector of monte-carlo years to keep. If <code>NULL</code>, all time
ids are kept.</p>
</td></tr>
<tr><td><code id="subset.antaresDataList_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filtered <code>antaresDataList</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#keep only the first year
mydata &lt;- readAntares(areas = "all", links = "all", mcYears = "all")
mySubset&lt;-subset(mydata, mcYears = 1)
  
#keep only the first year for areas a and b 
mydata &lt;- readAntares(areas = "all", links = "all", mcYears = "all")
mySubset&lt;-subset(mydata, mcYears = 1, areas=c("a", "b")) 

#' #keep only the first year for areas a and b and timeIds include in 5:16 
mydata &lt;- readAntares(areas = "all", links = "all", mcYears = "all")
mySubset&lt;-subset(mydata, mcYears = 1, areas=c("a", "b"), timeIds=5:16) 
  

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.bindingConstraints'>Display equation of binding constraint</h2><span id='topic+summary.bindingConstraints'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function cannot be used for a study <code style="white-space: pre;">&#8288;&gt;= 8.7.0&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bindingConstraints'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bindingConstraints_+3A_object">object</code></td>
<td>
<p>Object returned by readBindingConstraints</p>
</td></tr>
<tr><td><code id="summary.bindingConstraints_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with one line per constraint.
</p>

<hr>
<h2 id='viewAntares'>View the content of an antares output</h2><span id='topic+viewAntares'></span>

<h3>Description</h3>

<p>This function displays each element of an <code>antaresData</code> object in a
spreadsheet-like viewer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewAntares(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viewAntares_+3A_x">x</code></td>
<td>
<p>An object of class <code>antaresData</code>, generated by the function
<code><a href="#topic+readAntares">readAntares</a></code>.</p>
</td></tr>
<tr><td><code id="viewAntares_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setSimulationPath()

areas &lt;-readAntares()
viewAntares(areas)

output &lt;- studyAntares(areas="all", links = "all", clusters = "all")
viewAntares(output) # Opens three data viewers for each element of output

## End(Not run)

</code></pre>

<hr>
<h2 id='writeDigest'>Write digest file</h2><span id='topic+writeDigest'></span>

<h3>Description</h3>

<p>Write digest file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeDigest(digest, opts = simOptions())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeDigest_+3A_digest">digest</code></td>
<td>
<p>list of 5 elements similar to what is returned by <code><a href="#topic+readDigestFile">readDigestFile</a></code></p>
</td></tr>
<tr><td><code id="writeDigest_+3A_opts">opts</code></td>
<td>
<p>simulation options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated digest
list of 5 tables (begin, areas, middle, links lin., links quad.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readDigestFile">readDigestFile</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
