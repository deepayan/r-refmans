<!DOCTYPE html><html><head><title>Help for package nat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nat-package'><p>Analyse 3D biological image data especially neurons</p></a></li>
<li><a href='#[.neuronlistfh'><p>Extract from neuronlistfh object or its attached data.frame</p></a></li>
<li><a href='#*.dotprops'><p>Arithmetic for dotprops objects</p></a></li>
<li><a href='#*.neuron'><p>Arithmetic for neuron coordinates</p></a></li>
<li><a href='#*.neuronlist'><p>Arithmetic for neuron coordinates applied to neuronlists</p></a></li>
<li><a href='#affmat2cmtkparams'><p>Decompose homogeneous affine matrix to CMTK registration parameters</p></a></li>
<li><a href='#all.equal.dotprops'><p>all.equal method tailored to dotprops objects</p></a></li>
<li><a href='#all.equal.im3d'><p>Check equality on data and key attributes of im3d objects</p></a></li>
<li><a href='#all.equal.neuron'><p>Check equality on key fields of neuron object</p></a></li>
<li><a href='#amiratype'><p>Return the type of an amiramesh file on disk or a parsed header</p></a></li>
<li><a href='#as.data.frame.neuronlist'><p>Get or set the attached data.frame of a neuronlist</p></a></li>
<li><a href='#as.hxsurf'><p>Convert an object to a nat hxsurf object</p></a></li>
<li><a href='#as.im3d'><p>Convert a suitable object to an im3d object.</p></a></li>
<li><a href='#as.mesh3d'><p>Convert an object to an rgl mesh3d</p></a></li>
<li><a href='#as.neuronlist'><p>Make a list of neurons that can be used for coordinate plotting/analysis</p></a></li>
<li><a href='#as.neuronlist.neuronlistfh'><p>convert neuronlistfh to a regular (in memory) neuronlist</p></a></li>
<li><a href='#boundingbox'><p>Get the bounding box of an im3d volume or other compatible object</p></a></li>
<li><a href='#c.neuronlist'><p>Combine multiple neuronlists into a single list</p></a></li>
<li><a href='#Cell07PNs'><p>Cell07PNs: 40 Sample Projection Neurons from Jefferis, Potter et al 2007</p></a></li>
<li><a href='#clampmax'><p>Return function that finds maximum of its inputs within a clamping range</p></a></li>
<li><a href='#cmtk.bindir'><p>Return path to directory containing CMTK binaries</p></a></li>
<li><a href='#cmtk.call'><p>Utility function to create and run calls to CMTK commandline tools</p></a></li>
<li><a href='#cmtk.dof2mat'><p>Convert CMTK registration to homogeneous affine matrix with dof2mat</p></a></li>
<li><a href='#cmtk.extract_affine'><p>Extract affine registration from CMTK registration file or in-memory list</p></a></li>
<li><a href='#cmtk.mat2dof'><p>Use CMTK mat2dof to convert homogeneous affine matrix into CMTK registration</p></a></li>
<li><a href='#cmtk.reformatx'><p>Reformat an image with a CMTK registration using the reformatx tool</p></a></li>
<li><a href='#cmtk.statistics'><p>Calculate image statistics for a nrrd or other CMTK compatible file</p></a></li>
<li><a href='#cmtk.targetvolume'><p>Defines a target volume for a CMTK reformatx operation</p></a></li>
<li><a href='#cmtk.version'><p>Return cmtk version or test for presence of at least a specific version</p></a></li>
<li><a href='#cmtkparams2affmat'><p>Compose homogeneous affine matrix from CMTK registration parameters</p></a></li>
<li><a href='#cmtkreg'><p>Create and test cmtkreg objects that specify path to a CMTK registration</p></a></li>
<li><a href='#cmtkreglist'><p>Make in-memory CMTK registration list from affine matrix or CMTK parameters</p></a></li>
<li><a href='#coord2ind'><p>Find 1D indices into a 3D image given spatial coordinates</p></a></li>
<li><a href='#dotprops'><p>dotprops: Neurons as point clouds with tangent vectors (but no connectivity)</p></a></li>
<li><a href='#fileformats'><p>Set or return list of registered file formats that we can read</p></a></li>
<li><a href='#find.neuron'><p>Find neurons within a 3D selection box (usually drawn in rgl window)</p></a></li>
<li><a href='#find.soma'><p>Find neurons with soma inside 3D selection box (usually drawn in rgl window)</p></a></li>
<li><a href='#flip'><p>Flip an array, matrix or vector about an axis</p></a></li>
<li><a href='#graph.nodes'><p>Return root, end, or branchpoints of an igraph object</p></a></li>
<li><a href='#im3d'><p>Construct an im3d object representing 3D image data, densities etc</p></a></li>
<li><a href='#im3d-coords'><p>Interconvert pixel and physical coordinates</p></a></li>
<li><a href='#im3d-io'><p>Read/Write calibrated 3D blocks of image data</p></a></li>
<li><a href='#image.im3d'><p>Method to plot spatially calibrated image arrays</p></a></li>
<li><a href='#imexpand.grid'><p>Convert locations of im3d voxel grid into XYZ coordinates</p></a></li>
<li><a href='#imscalebar'><p>Make a scalebar to accompany an image.im3d plot</p></a></li>
<li><a href='#imslice'><p>Slice out a 3D subarray (or 2d matrix) from a 3D image array</p></a></li>
<li><a href='#ind2coord'><p>Find XYZ coords corresponding to 1D indices into a 3D image</p></a></li>
<li><a href='#intersect'><p>Find the intersection of two collections of objects</p></a></li>
<li><a href='#is.amiramesh'><p>Check if file is amiramesh format</p></a></li>
<li><a href='#is.fijitraces'><p>Check whether a file is in Fiji's simple neurite tracer format</p></a></li>
<li><a href='#is.im3d'><p>Test if an object is of class im3d</p></a></li>
<li><a href='#is.neuroml'><p>Check whether a file is in NeuroML format</p></a></li>
<li><a href='#is.neuronlist'><p>Test objects of neuronlist class to store multiple neurons</p></a></li>
<li><a href='#is.nrrd'><p>Check if a file is a NRRD file</p></a></li>
<li><a href='#is.swc'><p>Test if a file is an SWC format neuron</p></a></li>
<li><a href='#is.vaa3draw'><p>Check if a file is in the raw image format used by Hanchuan Peng's Vaa3D</p></a></li>
<li><a href='#kcs20'><p>List of 20 Kenyon Cells from Chiang et al 2011 converted to dotprops objects</p></a></li>
<li><a href='#mask'><p>Mask an object, typically to produce a copy with some values zeroed out</p></a></li>
<li><a href='#materials'><p>Extract or set the materials for an object</p></a></li>
<li><a href='#MBL.surf'><p>Surface object (hxsurf) for the left mushroom body in FCWB template space</p></a></li>
<li><a href='#mirror'><p>Mirror 3D object about a given axis, optionally using a warping registration</p></a></li>
<li><a href='#ndigest'><p>Calculated normalised digest value for an object</p></a></li>
<li><a href='#neuron'><p>neuron: class to represent traced neurons</p></a></li>
<li><a href='#neuronlist'><p>Create a neuronlist from zero or more neurons</p></a></li>
<li><a href='#neuronlist-dataframe-methods'><p>Methods for working with the dataframe attached to a neuronlist</p></a></li>
<li><a href='#neuronlistfh'><p>neuronlistfh - List of neurons loaded on demand from disk or remote website</p></a></li>
<li><a href='#ngraph'><p>ngraph: a graph to encode a neuron's connectivity</p></a></li>
<li><a href='#nlapply'><p>lapply and mapply for neuronlists (with optional parallelisation)</p></a></li>
<li><a href='#nlscan'><p>Scan through a set of neurons, individually plotting each one in 3D</p></a></li>
<li><a href='#nopen3d'><p>Open customised rgl window</p></a></li>
<li><a href='#normalise_swc'><p>Normalise an SWC format block of neuron morphology data</p></a></li>
<li><a href='#npop3d'><p>Remove plotted neurons or other 3D objects</p></a></li>
<li><a href='#nrrd.voxdims'><p>Return voxel dimensions (by default absolute voxel dimensions)</p></a></li>
<li><a href='#nvertices'><p>Find the number of vertices in an object (or each element of a neuronlist)</p></a></li>
<li><a href='#nview3d'><p>Set the 3D viewpoint of an RGL window using anatomical terms</p></a></li>
<li><a href='#origin'><p>Return the space origin of a 3D image object</p></a></li>
<li><a href='#pan3d'><p>Some useful extensions / changes to rgl defaults</p></a></li>
<li><a href='#plot.neuron'><p>Plot a 2D projection of a neuron</p></a></li>
<li><a href='#plot.neuronlist'><p>2D plots of the elements in a neuronlist, optionally using a subset</p>
expression</a></li>
<li><a href='#plot3d'><p>plot3d methods for different nat objects</p></a></li>
<li><a href='#plot3d.boundingbox'><p>Plot a bounding box in 3D</p></a></li>
<li><a href='#plot3d.cmtkreg'><p>Plot the domain of a CMTK registration</p></a></li>
<li><a href='#plot3d.dotprops'><p>3D plots of dotprops objects using rgl package</p></a></li>
<li><a href='#plot3d.hxsurf'><p>Plot amira surface objects in 3D using rgl</p></a></li>
<li><a href='#plot3d.neuron'><p>Plot neurons in 3D using rgl library</p></a></li>
<li><a href='#plot3d.neuronlist'><p>3D plots of the elements in a neuronlist, optionally using a subset</p>
expression</a></li>
<li><a href='#pointsinside'><p>Find which points of an object are inside a surface</p></a></li>
<li><a href='#potential_synapses'><p>Calculate number of potential synapses between two neurons</p></a></li>
<li><a href='#projection'><p>Make 2D (orthogonal) projection of 3D image data</p></a></li>
<li><a href='#prune'><p>prune an object by removing points near (or far) from a target object</p></a></li>
<li><a href='#prune_strahler'><p>Prune a neuron by removing segments with a given Strahler order</p></a></li>
<li><a href='#prune_vertices'><p>Prune selected vertices or edges from a neuron</p></a></li>
<li><a href='#read.amiramesh'><p>Read AmiraMesh data in binary or ascii format</p></a></li>
<li><a href='#read.cmtk'><p>Read CMTK TypedStream file to a list in memory</p></a></li>
<li><a href='#read.cmtkreg'><p>Read a CMTK format registration</p></a></li>
<li><a href='#read.hxsurf'><p>Read Amira surface (aka HxSurface or HyperSurface) files into hxsurf object</p></a></li>
<li><a href='#read.landmarks'><p>Generic functions to read/write landmarks in any supported format</p></a></li>
<li><a href='#read.morphml'><p>Return parsed XML or R list versions of a NeuroML file</p></a></li>
<li><a href='#read.neuron'><p>Read a single neuron from a file</p></a></li>
<li><a href='#read.neuron.fiji'><p>Read a neuron saved by Fiji's Simple Neurite Tracer Plugin</p></a></li>
<li><a href='#read.neuron.neuroml'><p>Read one or more neurons from a NeuroML v1 file</p></a></li>
<li><a href='#read.neuron.swc'><p>Read a neuron in swc file format</p></a></li>
<li><a href='#read.neuronlistfh'><p>Read a local, or remote, neuronlistfh object saved to a file.</p></a></li>
<li><a href='#read.neurons'><p>Read one or more neurons from file to a neuronlist in memory</p></a></li>
<li><a href='#read.nrrd'><p>Read nrrd file into an array in memory</p></a></li>
<li><a href='#read.vaa3draw'><p>Read Vaa3d format image data</p></a></li>
<li><a href='#reglist'><p>A simple wrapper class for multiple transformations</p></a></li>
<li><a href='#remotesync'><p>Synchronise a remote object</p></a></li>
<li><a href='#resample'><p>Resample an object with a new spacing</p></a></li>
<li><a href='#rootpoints'><p>Return the root or branch points of a neuron or graph</p></a></li>
<li><a href='#scale.neuron'><p>Scale and centre neuron 3D coordinates</p></a></li>
<li><a href='#seglengths'><p>Calculate length of all segments in neuron</p></a></li>
<li><a href='#seglist'><p>Make/convert neuron connectivity information into a seglist object</p></a></li>
<li><a href='#seglist2swc'><p>Recalculate Neurons's SWCData using SegList and point information</p></a></li>
<li><a href='#segmentgraph'><p>Return a simplified segment graph for a neuron</p></a></li>
<li><a href='#setdiff'><p>Find the (asymmetric) difference between two collections of objects</p></a></li>
<li><a href='#simplify_reglist'><p>Simplify a registration list</p></a></li>
<li><a href='#smooth_neuron'><p>Smooth the 3D coordinates of a neuron skeleton</p></a></li>
<li><a href='#spine'><p>Compute the longest path (aka spine or backbone) of a neuron</p></a></li>
<li><a href='#strahler_order'><p>Find the Strahler order of each point in a neuron</p></a></li>
<li><a href='#sub2ind'><p>Find 1D index given n-dimensional indices</p></a></li>
<li><a href='#subset'><p>Subset methods for different nat objects</p></a></li>
<li><a href='#subset.dotprops'><p>Subset points in dotprops object that match given conditions</p></a></li>
<li><a href='#subset.hxsurf'><p>Subset hxsurf object to specified regions</p></a></li>
<li><a href='#subset.neuron'><p>Subset neuron by keeping only vertices that match given conditions</p></a></li>
<li><a href='#subset.neuronlist'><p>Subset neuronlist returning either new neuronlist or names of chosen neurons</p></a></li>
<li><a href='#summary.neuronlist'><p>Summary statistics for neurons (e.g. cable length, number of nodes)</p></a></li>
<li><a href='#threshold'><p>Threshold an object, typically to produce a mask</p></a></li>
<li><a href='#union'><p>Find the union of two collections of objects</p></a></li>
<li><a href='#unmask'><p>Make im3d image array containing values at locations defined by a mask</p></a></li>
<li><a href='#voxdims'><p>Return voxel dimensions of an object</p></a></li>
<li><a href='#write.amiramesh'><p>Write a 3D data object to an amiramesh format file</p></a></li>
<li><a href='#write.cmtk'><p>Write a suitable list to a CMTK TypedStream file on disk</p></a></li>
<li><a href='#write.cmtkreg'><p>Write out CMTK registration list to folder</p></a></li>
<li><a href='#write.hxsurf'><p>Write Amira surface (aka HxSurface or HyperSurface) into .surf file.</p></a></li>
<li><a href='#write.neuron'><p>Write out a neuron in any of the file formats we know about</p></a></li>
<li><a href='#write.neuronlistfh'><p>Write out a neuronlistfh object to an RDS file</p></a></li>
<li><a href='#write.neurons'><p>Write neurons from a neuronlist object to individual files, or a zip archive</p></a></li>
<li><a href='#write.nrrd'><p>Write data and metadata to NRRD file or create a detached NRRD (nhdr) file.</p></a></li>
<li><a href='#write.vtk'><p>Write object to VTK file</p></a></li>
<li><a href='#xform'><p>Transform the 3D location of objects such as neurons</p></a></li>
<li><a href='#xformimage'><p>Transform image files using a registration or affine matrix</p></a></li>
<li><a href='#xformpoints'><p>Transform 3D points using a registration, affine matrix or function</p></a></li>
<li><a href='#xyzmatrix'><p>Get and assign coordinates for classes containing 3D vertex data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>NeuroAnatomy Toolbox for Analysis of 3D Image Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.24</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/natverse/nat">https://github.com/natverse/nat</a>, <a href="https://natverse.org/">https://natverse.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/natverse/nat/issues">https://github.com/natverse/nat/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>NeuroAnatomy Toolbox (nat) enables analysis and visualisation of 3D
    biological image data, especially traced neurons. Reads and writes 3D images
    in NRRD and 'Amira' AmiraMesh formats and reads surfaces in 'Amira' hxsurf
    format. Traced neurons can be imported from and written to SWC and 'Amira'
    LineSet and SkeletonGraph formats. These data can then be visualised in 3D
    via 'rgl', manipulated including applying calculated registrations, e.g.
    using the 'CMTK' registration suite, and analysed. There is also a simple
    representation for neurons that have been subjected to 3D skeletonisation
    but not formally traced; this allows morphological comparison between
    neurons including searches and clustering (via the 'nat.nblast' extension
    package).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1), rgl (&ge; 0.98.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>nabor, igraph (&ge; 1.3.0), methods, filehash (&ge; 2.3), digest,
nat.utils (&ge; 0.4.2), plyr, yaml</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rvcg (&ge; 0.17), testthat, httr, XML, knitr, rmarkdown,
markdown, MASS, alphashape3d, webshot2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>'alphashape3d.R' 'amiralandmarks-io.R' 'amiramesh-io.R'
'cmtk-reformat.R' 'cmtk.R' 'cmtk_geometry.R' 'cmtk_io.R'
'cmtkreg.R' 'coordinates.R' 'dist3D_Segment_to_Segment.R'
'neuron.R' 'dotprops.R' 'graph-nodes.R' 'hxsurf.R' 'im3d.R'
'nat-data.R' 'nat-package.R' 'ndigest.R' 'neuron-io-amira.R'
'neuron-io-fiji.R' 'neuron-io-neuroml.R' 'neuron-io.R'
'neuron-plot.R' 'neuronlist.R' 'neuronlist_interactive_3d.R'
'neuronlist_sets.R' 'neuronlistfh.R' 'ngraph.R' 'nrrd-io.R'
'pop3d.R' 'potential_synapses.R' 'reglist.R' 'seglist.R'
'summary.R' 'utils.R' 'vaa3draw-io.R' 'vtk-io.R' 'xform.R'
'xformimage.R' 'xformpoints.R' 'zzz.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 17:47:03 UTC; jefferis</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregory Jefferis <a href="https://orcid.org/0000-0002-0587-9355"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  James Manton <a href="https://orcid.org/0000-0001-9260-3156"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Dominik Krzeminski
    <a href="https://orcid.org/0000-0003-4568-0583"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregory Jefferis &lt;jefferis@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nat-package'>Analyse 3D biological image data especially neurons</h2><span id='topic+nat-package'></span><span id='topic+nat'></span>

<h3>Description</h3>

<p><b>nat</b> provides tools to read, analyse, plot, transform and convert
neuroanatomical data, especially representations of neurons.
</p>


<h3>Neuron Objects</h3>

<p>At present there are 2 main representations of
neuronal data:
</p>

<dl>
<dt><code><a href="#topic+neuron">neuron</a></code></dt><dd><p> objects contain one or more connected trees
that make up a neuron</p>
</dd>
<dt><code><a href="#topic+dotprops">dotprops</a></code></dt><dd><p> objects can contain one (or more) neurons
represented as points and tangent vectors in which the connectivity
information has been discarded</p>
</dd>
</dl>

<p>The <code>subset</code> function has both <code><a href="#topic+subset.neuron">subset.neuron</a></code> and
<code><a href="#topic+subset.dotprops">subset.dotprops</a></code> methods, which can be used to keep (or
reject) specified vertices within a neuron e.g. by spatial constraints.
<code><a href="#topic+subset.neuron">subset.neuron</a></code> will look after the tree structure of neurons
in these circumstances.
</p>
<p><code>neuron</code> objects containing connected trees can be converted to
<code><a href="#topic+ngraph">ngraph</a></code> objects, a lightweight wrapper around the
<code><a href="igraph.html#topic+igraph">igraph</a></code> library's <code><a href="igraph.html#topic+graph">graph</a></code> class that
preserves 3D coordinate information. This allows neurons to be manipulated
based on their graph structure, e.g. by finding all nodes upstream (closer
to the root) or downstream of a given node. The <code><a href="#topic+as.neuron">as.neuron</a></code>
function can convert <code>ngraph</code> objects back to <code>neuron</code>s or
selected vertex indices can be used to subset a neuron with
<code><a href="#topic+subset.neuron">subset.neuron</a></code>.
</p>


<h3>Collections of Neurons</h3>

<p>Neurons can be collected as
<code><a href="#topic+neuronlist">neuronlist</a></code> objects, which contain multiple
<code><a href="#topic+neuron">neuron</a></code> or <code>dotprops</code> objects along with an attached
dataframe of metadata. The metadata can be accessed and manipulated using
the <code>myneuronlist[i,j]</code> notation (see
<code><a href="#topic+neuronlist-dataframe-methods">neuronlist-dataframe-methods</a></code>).
</p>
<p>Neurons can be read in to a neuronlist using <code><a href="#topic+read.neurons">read.neurons</a></code> or
written out using <code><a href="#topic+write.neurons">write.neurons</a></code> with support for many of the
most common formats including swc.
</p>
<p>Metadata can be used to colour or subset the neurons during plotting (see
<code><a href="#topic+plot3d.neuronlist">plot3d.neuronlist</a></code> and <code><a href="#topic+subset.neuronlist">subset.neuronlist</a></code>).
Interactive 3D selection of neurons in a neuronlist is also possible using
<code><a href="#topic+find.neuron">find.neuron</a></code> (which makes use of rgl's <code><a href="rgl.html#topic+select3d">select3d</a></code>
function.
</p>
<p><code>neuronlist</code> objects also provide additional functionality to
streamline arithmetic (e.g. scaling all the points in all neurons see
<code><a href="#topic++2A.neuronlist">*.neuronlist</a></code>) and transformations (see <b>Transformations</b>
section below and <code><a href="#topic+xform">xform</a></code>). Arbitrary functions can be applied
to each individual neuron can be applied using the <code><a href="#topic+nlapply">nlapply</a></code>
function, which also provides options for progress bars and simple
parallelisation.
</p>


<h3>Transformations</h3>

<p><code><a href="#topic+neuron">neuron</a></code> or <code><a href="#topic+dotprops">dotprops</a></code>
objects can be transformed from e.g. sample to template brain space using
affine or non-rigid registrations, typically calculated with the open
source CMTK package available at
<a href="https://www.nitrc.org/projects/cmtk/">https://www.nitrc.org/projects/cmtk/</a>, see ?<a href="#topic+cmtk">cmtk</a> for
installation details. The function <code><a href="#topic+xform">xform</a></code> has methods to deal
with a variety of types of interest.
</p>


<h3>3D Image Data</h3>

<p>In addition to data types defined by unstructured
collections of 3D vertices such as <code><a href="#topic+neuron">neuron</a></code>,
<code><a href="#topic+dotprops">dotprops</a></code> and <code><a href="#topic+hxsurf">hxsurf</a></code> objects nat provides the
<code><a href="#topic+im3d">im3d</a></code> class to handle image/density data on a regular grid.
I/O is handled by <code><a href="#topic+read.im3d">read.im3d</a></code> and <code><a href="#topic+write.im3d">write.im3d</a></code>,
which are currently implemented for the amiramesh and nrrd file formats;
there is also read only access to the <a href="http://www.vaa3d.org/">vaa3d</a>
raw format.
</p>
<p>Spatial information can be queried with <code><a href="#topic+voxdims">voxdims</a></code>,
<code><a href="#topic+boundingbox">boundingbox</a></code> and <code><a href="#topic+ijkpos">ijkpos</a></code>, <code><a href="#topic+xyzpos">xyzpos</a></code>
methods. You can convert between voxel data and coordinate (vertex) -based
representations using the following functions:
</p>

<ul>
<li> <p><code><a href="#topic+as.im3d">as.im3d</a></code> The <code>as.im3d.matrix</code> method converts XYZ
coordinates to an <code>im3d</code> image volume
</p>
</li>
<li> <p><code><a href="#topic+ind2coord">ind2coord</a></code> Find XYZ coordinates of specified voxels of
an <code>im3d</code> image volume
</p>
</li>
<li> <p><code><a href="#topic+dotprops">dotprops</a></code> The <code>dotprops.im3d</code> method converts an
<code>im3d</code> object to a <code>dotprops</code> format neuron, i.e. a cloud of
unconnected segments.
</p>
</li></ul>



<h3>Surface Data</h3>

<p><b>nat</b> can read, write, transform and subset
surface (mesh) objects defined by Amira's HxSurface class. See
<code><a href="#topic+read.hxsurf">read.hxsurf</a></code> and links therein. In addition hxsurf objects can
be converted to the <code><a href="rgl.html#topic+mesh3d">mesh3d</a></code> format, which provides a link
to the <code><a href="rgl.html#topic+rgl">rgl</a></code> package and also to packages for
morphometrics and sophisticated mesh manipulation such as
<a href="https://cran.r-project.org/package=Morpho">Morpho</a> and
<a href="https://cran.r-project.org/package=Rvcg">Rvcg</a>.
</p>


<h3>rgl Package</h3>

<p><b>nat</b> uses the <b><code><a href="rgl.html#topic+rgl">rgl</a></code></b>
package extensively for 3D visualisation. rgl's core function is to provide
interactive visualisation (usually in an X11 window depending on OpenGL -
and therefore on a graphics card or OpenGL software emulator) but recently
significant functionality for static snapshots and embedding results in
reports such as web pages has been added. With this in mind, Duncan Murdoch
has added the <code><a href="rgl.html#topic+rgl.useNULL">rgl.useNULL</a></code> option. As of nat 1.8.0,
<code>options(rgl.useNULL=TRUE)</code> will be set before nat is loaded in
non-interactive R sessions. If you want to use nat in interactive
environments where X11 is not available, you may want to set
<code>options(rgl.useNULL=TRUE)</code> manually before loading nat.
</p>


<h3>File Formats</h3>

<p><b>nat</b> supports multiple input and output data
formats for the object classes. There is a registry-based mechanism which
allows support for reading or writing specific file formats (see
<code><a href="#topic+fileformats">fileformats</a></code>) to be plugged in to reasonably generic functions
such as <code><a href="#topic+read.neurons">read.neurons</a></code>. It is perfectly possible for other R
packages or end users to extend the supported list of file types by
registering new read/write or identification functions.
</p>


<h3>Package Options</h3>

<p>The following options can be set to specify default
behaviour.
</p>

<dl>
<dt><code>nat.cmtk.bindir</code></dt><dd><p> Location of CMTK binaries. See
<code><a href="#topic+cmtk.bindir">cmtk.bindir</a></code></p>
</dd>
<dt><code>nat.default.neuronlist</code></dt><dd><p> A character string naming a
neuronlist to use with the <code><a href="#topic+plot3d.character">plot3d.character</a></code> method</p>
</dd>
<dt><code>nat.progress</code></dt><dd><p> The default progress reporter to use with
<code><a href="#topic+nlapply">nlapply</a></code>. See <code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code> for
possible values. When unset is equivalent to special value <code>'auto'</code>.
To suppress altogether, use <code>nat.progress="none"</code>.</p>
</dd>
</dl>

<p>In addition there is one read-only option: </p>

<ul>
<li> <p><code>nat.cmtk.version</code> which is used to store the current cmtk
version when there are repeated calls to <code><a href="#topic+cmtk.version">cmtk.version</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+neuron">neuron</a></code>, <code><a href="#topic+dotprops">dotprops</a></code>,
<code><a href="#topic+neuronlist">neuronlist</a></code>, <code><a href="#topic+nlapply">nlapply</a></code>, <code><a href="#topic+plot3d">plot3d</a></code>,
<code><a href="#topic+xform">xform</a></code>, <code><a href="#topic+im3d">im3d</a></code>, <code><a href="#topic+read.hxsurf">read.hxsurf</a></code>,
<code><a href="rgl.html#topic+rgl">rgl</a></code> which is used for visualisation,
<code><a href="#topic+fileformats">fileformats</a></code>, <code><a href="#topic+read.neurons">read.neurons</a></code>, <code><a href="#topic+cmtk">cmtk</a></code>.
</p>

<hr>
<h2 id='+5B.neuronlistfh'>Extract from neuronlistfh object or its attached data.frame</h2><span id='topic++5B.neuronlistfh'></span>

<h3>Description</h3>

<p><code>[.neuronlistfh</code> extracts either a sublist from a 
neuronlistfh (converting it to a regular in memory list in the process) 
<em>or</em> its attached data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuronlistfh'
x[i, j, drop]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.neuronlistfh_+3A_x">x</code></td>
<td>
<p>A neuronlistfh object</p>
</td></tr>
<tr><td><code id="+2B5B.neuronlistfh_+3A_i">i</code>, <code id="+2B5B.neuronlistfh_+3A_j">j</code></td>
<td>
<p>elements to extract or replace. Numeric, logical  or character or,
for the [ get method, empty. See details and the help for 
<code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="+2B5B.neuronlistfh_+3A_drop">drop</code></td>
<td>
<p>logical.  If <code>TRUE</code> the result is coerced to the
lowest possible dimension.  The default is to drop if only one
column is left, but <b>not</b> to drop if only one row is left.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if i is a numeric or logical indexing vector, it will be 
converted internally to a vector of names by using the (sorted) names of 
the objects in x (i.e. names(x)[i])
</p>


<h3>Value</h3>

<p>A new in-memory <code>neuronlist</code> or when using two subscripts, a 
<code>data.frame</code> - see examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neuronlistfh">neuronlistfh</a></code>, <code><a href="#topic++5B.neuronlist">[.neuronlist</a></code>, 
<code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code>, <code><a href="base.html#topic++5B+3C-.data.frame">[&lt;-.data.frame</a></code>,
</p>
<p>Other neuronlistfh: 
<code><a href="#topic+neuronlistfh">neuronlistfh</a>()</code>,
<code><a href="#topic+read.neuronlistfh">read.neuronlistfh</a>()</code>,
<code><a href="#topic+remotesync">remotesync</a>()</code>,
<code><a href="#topic+write.neuronlistfh">write.neuronlistfh</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make a test neuronlistfh backed by a temporary folder on disk
tf=tempfile('kcs20fh')
kcs20fh&lt;-as.neuronlistfh(kcs20, dbdir=tf)

# get first neurons as an in memory neuronlist
class(kcs20fh[1:3])

# extract attached data.frame
str(kcs20fh[,])
# or part of the data.frame
str(kcs20fh[1:2,1:3])

# data.frame assignment (this one changes nothing)
kcs20fh[1:2,'gene_name'] &lt;- kcs20fh[1:2,'gene_name']

# clean up
unlink(tf, recursive=TRUE)

</code></pre>

<hr>
<h2 id='+2A.dotprops'>Arithmetic for dotprops objects</h2><span id='topic++2A.dotprops'></span><span id='topic++2B.dotprops'></span><span id='topic+-.dotprops'></span><span id='topic++2F.dotprops'></span>

<h3>Description</h3>

<p>Arithmetic for dotprops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dotprops'
x * y

## S3 method for class 'dotprops'
x + y

## S3 method for class 'dotprops'
x - y

## S3 method for class 'dotprops'
x / y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A.dotprops_+3A_x">x</code></td>
<td>
<p>A dotprops object</p>
</td></tr>
<tr><td><code id="+2B2A.dotprops_+3A_y">y</code></td>
<td>
<p>A scalar or 3-vector that will be applied to the dotprops object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new dotprops object
</p>

<hr>
<h2 id='+2A.neuron'>Arithmetic for neuron coordinates</h2><span id='topic++2A.neuron'></span><span id='topic++2B.neuron'></span><span id='topic+-.neuron'></span><span id='topic++2F.neuron'></span>

<h3>Description</h3>

<p>If x is a 1-vector or a 3-vector, multiply xyz only
If x is a 4-vector, multiply xyz and diameter by that
TODO Figure out how to document arithemtic functions in one go
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuron'
n * x

## S3 method for class 'neuron'
n + x

## S3 method for class 'neuron'
n - x

## S3 method for class 'neuron'
n / x
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A.neuron_+3A_n">n</code></td>
<td>
<p>a neuron</p>
</td></tr>
<tr><td><code id="+2B2A.neuron_+3A_x">x</code></td>
<td>
<p>(a numeric vector to multiply neuron coords in neuron)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified neuron
</p>


<h3>See Also</h3>

<p>neuron
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1&lt;-Cell07PNs[[1]]*2
n2&lt;-Cell07PNs[[1]]*c(2,2,2,1)
stopifnot(all.equal(n1,n2))
n3&lt;-Cell07PNs[[1]]*c(2,2,4)
</code></pre>

<hr>
<h2 id='+2A.neuronlist'>Arithmetic for neuron coordinates applied to neuronlists</h2><span id='topic++2A.neuronlist'></span><span id='topic++2B.neuronlist'></span><span id='topic+-.neuronlist'></span><span id='topic++2F.neuronlist'></span>

<h3>Description</h3>

<p>If x is one number or 3-vector, multiply coordinates by that
If x is a 4-vector, multiply xyz and diameter
TODO Figure out how to document arithemtic functions in one go
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuronlist'
x * y

## S3 method for class 'neuronlist'
x + y

## S3 method for class 'neuronlist'
x - y

## S3 method for class 'neuronlist'
x / y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A.neuronlist_+3A_x">x</code></td>
<td>
<p>a neuronlist</p>
</td></tr>
<tr><td><code id="+2B2A.neuronlist_+3A_y">y</code></td>
<td>
<p>(a numeric vector to multiply coords in neuronlist members)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified neuronlist
</p>


<h3>See Also</h3>

<p>Other neuronlist: 
<code><a href="#topic+is.neuronlist">is.neuronlist</a>()</code>,
<code><a href="#topic+neuronlist-dataframe-methods">neuronlist-dataframe-methods</a></code>,
<code><a href="#topic+neuronlistfh">neuronlistfh</a>()</code>,
<code><a href="#topic+neuronlist">neuronlist</a>()</code>,
<code><a href="#topic+nlapply">nlapply</a>()</code>,
<code><a href="#topic+read.neurons">read.neurons</a>()</code>,
<code><a href="#topic+write.neurons">write.neurons</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mn2&lt;-Cell07PNs[1:10]*2
</code></pre>

<hr>
<h2 id='affmat2cmtkparams'>Decompose homogeneous affine matrix to CMTK registration parameters</h2><span id='topic+affmat2cmtkparams'></span>

<h3>Description</h3>

<p>Decompose homogeneous affine matrix to CMTK registration parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affmat2cmtkparams(matrix, centre = c(0, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affmat2cmtkparams_+3A_matrix">matrix</code></td>
<td>
<p>4x4 homogeneous affine matrix</p>
</td></tr>
<tr><td><code id="affmat2cmtkparams_+3A_centre">centre</code></td>
<td>
<p>Rotation centre</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The version attribute of the resultant matrix marks this as
compliant with CMTK&gt;v2.4 (~ Dec 2013) when a bug in affine matrix
(de)composition was fixed.
</p>


<h3>Value</h3>

<p>5x3 matrix of CMTK registration parameters with a version attribute
</p>


<h3>See Also</h3>

<p>Other cmtk-geometry: 
<code><a href="#topic+cmtk.dof2mat">cmtk.dof2mat</a>()</code>,
<code><a href="#topic+cmtk.mat2dof">cmtk.mat2dof</a>()</code>,
<code><a href="#topic+cmtkparams2affmat">cmtkparams2affmat</a>()</code>
</p>

<hr>
<h2 id='all.equal.dotprops'>all.equal method tailored to dotprops objects</h2><span id='topic+all.equal.dotprops'></span>

<h3>Description</h3>

<p>all.equal method tailored to dotprops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dotprops'
all.equal(
  target,
  current,
  check.attributes = FALSE,
  absoluteVectors = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.dotprops_+3A_target">target</code>, <code id="all.equal.dotprops_+3A_current">current</code></td>
<td>
<p>dotprops objects to compare</p>
</td></tr>
<tr><td><code id="all.equal.dotprops_+3A_check.attributes">check.attributes</code></td>
<td>
<p>Whether to check attributes (false by default)</p>
</td></tr>
<tr><td><code id="all.equal.dotprops_+3A_absolutevectors">absoluteVectors</code></td>
<td>
<p>Whether to check only the absolute value of
eigenvectors for equality (default TRUE, see details)</p>
</td></tr>
<tr><td><code id="all.equal.dotprops_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to base <code>all.equal</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is required because the direction vectors are computed
using an eigenvector decomposition where the sign of the eigenvector is
essentially random and subject to small numerical instabilities. Therefore
it does not usually make sense to check the value of vect exactly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># equal using default 
kc1=kcs20[[1]]
kc1.recalc=dotprops(kc1)
# not equal due to differences in attributes and vectors
all.equal.default(kc1.recalc, kc1)
# still not equal because of tangent vector flipping
all.equal.default(kc1.recalc, kc1, check.attributes=FALSE)
# equal using appropriate method
stopifnot(isTRUE(all.equal(kc1.recalc, kc1)))
# NB identical when recalculated on same setup from same data
stopifnot(isTRUE(all.equal.default(kc1.recalc, dotprops(kc1))))
</code></pre>

<hr>
<h2 id='all.equal.im3d'>Check equality on data and key attributes of im3d objects</h2><span id='topic+all.equal.im3d'></span>

<h3>Description</h3>

<p>Check equality on data and key attributes of im3d objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'im3d'
all.equal(
  target,
  current,
  tolerance = 1e-06,
  attrsToCheck = c("BoundingBox"),
  attrsToCheckIfPresent = c("dim", "names", "dimnames", "x", "y", "z"),
  CheckSharedAttrsOnly = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.im3d_+3A_target">target</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="all.equal.im3d_+3A_current">current</code></td>
<td>
<p>other <span class="rlang"><b>R</b></span> object, to be compared with <code>target</code>.</p>
</td></tr>
<tr><td><code id="all.equal.im3d_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric <code class="reqn">\ge</code> 0.  Differences smaller than
<code>tolerance</code> are not reported.  The default value is close to
<code>1.5e-8</code>.</p>
</td></tr>
<tr><td><code id="all.equal.im3d_+3A_attrstocheck">attrsToCheck</code></td>
<td>
<p>Which attributes in im3d should always be checked</p>
</td></tr>
<tr><td><code id="all.equal.im3d_+3A_attrstocheckifpresent">attrsToCheckIfPresent</code></td>
<td>
<p>Which attributes in im3d should be checked if
present</p>
</td></tr>
<tr><td><code id="all.equal.im3d_+3A_checksharedattrsonly">CheckSharedAttrsOnly</code></td>
<td>
<p>Logical whether to check shared attributes only 
(default: FALSE)</p>
</td></tr>
<tr><td><code id="all.equal.im3d_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>all.equal</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+all.equal">all.equal</a></code>
</p>

<hr>
<h2 id='all.equal.neuron'>Check equality on key fields of neuron object</h2><span id='topic+all.equal.neuron'></span>

<h3>Description</h3>

<p>Check equality on key fields of neuron object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuron'
all.equal(
  target,
  current,
  tolerance = 1e-06,
  check.attributes = FALSE,
  fieldsToCheck = c("NumPoints", "StartPoint", "BranchPoints", "EndPoints", "NumSegs",
    "SegList", "d"),
  fieldsToCheckIfPresent = c("NeuronName", "nTrees", "SubTrees"),
  fieldsToExclude = character(),
  CheckSharedFieldsOnly = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.neuron_+3A_target">target</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="all.equal.neuron_+3A_current">current</code></td>
<td>
<p>other <span class="rlang"><b>R</b></span> object, to be compared with <code>target</code>.</p>
</td></tr>
<tr><td><code id="all.equal.neuron_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric <code class="reqn">\ge</code> 0.  Differences smaller than
<code>tolerance</code> are not reported.  The default value is close to
<code>1.5e-8</code>.</p>
</td></tr>
<tr><td><code id="all.equal.neuron_+3A_check.attributes">check.attributes</code></td>
<td>
<p>logical indicating if the
<code><a href="base.html#topic+attributes">attributes</a></code> of <code>target</code> and <code>current</code>
(other than the names) should be compared.</p>
</td></tr>
<tr><td><code id="all.equal.neuron_+3A_fieldstocheck">fieldsToCheck</code></td>
<td>
<p>Which fields in the neuron are always checked. The
special value of <code>NA</code> indicates that <b>all</b> fields in the neurons
will be compared.</p>
</td></tr>
<tr><td><code id="all.equal.neuron_+3A_fieldstocheckifpresent">fieldsToCheckIfPresent</code></td>
<td>
<p>These fields are only checked if they are 
present</p>
</td></tr>
<tr><td><code id="all.equal.neuron_+3A_fieldstoexclude">fieldsToExclude</code></td>
<td>
<p>Character vector of fields to exclude from check</p>
</td></tr>
<tr><td><code id="all.equal.neuron_+3A_checksharedfieldsonly">CheckSharedFieldsOnly</code></td>
<td>
<p>Logical whether to check shared fields only 
(default: FALSE)</p>
</td></tr>
<tr><td><code id="all.equal.neuron_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>all.equal</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+all.equal">all.equal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=Cell07PNs[[1]]
y=x
y$NeuronName='rhubarb'
# NOT TRUE
all.equal(x, y)
# TRUE
all.equal(x, y, fieldsToExclude='NeuronName')
</code></pre>

<hr>
<h2 id='amiratype'>Return the type of an amiramesh file on disk or a parsed header</h2><span id='topic+amiratype'></span>

<h3>Description</h3>

<p>Return the type of an amiramesh file on disk or a parsed header
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amiratype(x, bytes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amiratype_+3A_x">x</code></td>
<td>
<p>Path to files on disk or a single pre-parsed parameter list</p>
</td></tr>
<tr><td><code id="amiratype_+3A_bytes">bytes</code></td>
<td>
<p>A raw vector containing at least 11 bytes from the start of the
file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that when checking a file we first test if it is an amiramesh 
file (fast, especially when <code>bytes!=NULL</code>) before reading the header 
and determining content type (slow).
</p>


<h3>Value</h3>

<p>character vector (NA_character_ when file invalid)
</p>


<h3>See Also</h3>

<p>Other amira: 
<code><a href="#topic+is.amiramesh">is.amiramesh</a>()</code>,
<code><a href="#topic+read.amiramesh">read.amiramesh</a>()</code>,
<code><a href="#topic+read.hxsurf">read.hxsurf</a>()</code>,
<code><a href="#topic+write.hxsurf">write.hxsurf</a>()</code>
</p>

<hr>
<h2 id='as.data.frame.neuronlist'>Get or set the attached data.frame of a neuronlist</h2><span id='topic+as.data.frame.neuronlist'></span><span id='topic+data.frame+3C-'></span><span id='topic+data.frame+3C-.neuronlist'></span>

<h3>Description</h3>

<p>For <code>as.data.frame</code>, when there is no attached data.frame the result 
will be a data.frame with 0 columns but an appropriate number of rows, named by
the objects in the neuronlist.
</p>
<p><code>data.frame&lt;-</code> methods set the data frame attached to an 
object. At present this is only used for neuronlist objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuronlist'
as.data.frame(x, row.names = names(x), optional = FALSE, ...)

data.frame(x) &lt;- value

## S3 replacement method for class 'neuronlist'
data.frame(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.neuronlist_+3A_x">x</code></td>
<td>
<p>neuronlist to convert</p>
</td></tr>
<tr><td><code id="as.data.frame.neuronlist_+3A_row.names">row.names</code></td>
<td>
<p>row names (defaults to names of objects in neuronlist, which
is nearly always what you want.)</p>
</td></tr>
<tr><td><code id="as.data.frame.neuronlist_+3A_optional">optional</code></td>
<td>
<p>ignored in this method</p>
</td></tr>
<tr><td><code id="as.data.frame.neuronlist_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+data.frame">data.frame</a></code> (see 
examples)</p>
</td></tr>
<tr><td><code id="as.data.frame.neuronlist_+3A_value">value</code></td>
<td>
<p>The new data.frame to be attached to <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>as.data.frame.neuronlist</code>, a <code>data.frame</code> with
length(x) rows, named according to names(x) and containing the columns from
the attached data.frame, when present.
</p>
<p>for <code>data.frame&lt;-.neuronlist</code>, a neuronlist with the attached
data.frame.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code>, <code><a href="#topic+neuronlist">neuronlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(as.data.frame(kcs20))

# add additional variables
str(as.data.frame(kcs20, i=seq(kcs20), abc=LETTERS[seq(kcs20)]))
# stop character columns being turned into factors
newdf &lt;- as.data.frame(kcs20, i=seq(kcs20), abc=LETTERS[seq(kcs20)], 
  stringsAsFactors=FALSE)
str(newdf)
data.frame(kcs20)=newdf
</code></pre>

<hr>
<h2 id='as.hxsurf'>Convert an object to a nat hxsurf object</h2><span id='topic+as.hxsurf'></span><span id='topic+as.hxsurf.mesh3d'></span>

<h3>Description</h3>

<p>Convert an object to a nat hxsurf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.hxsurf(x, ...)

## S3 method for class 'mesh3d'
as.hxsurf(x, region = "Interior", col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.hxsurf_+3A_x">x</code></td>
<td>
<p>A surface object</p>
</td></tr>
<tr><td><code id="as.hxsurf_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="as.hxsurf_+3A_region">region</code></td>
<td>
<p>The default name for the surface region</p>
</td></tr>
<tr><td><code id="as.hxsurf_+3A_col">col</code></td>
<td>
<p>The surface colour (default value of NULL implies the colour
specified in mesh3d object or <code>grey</code> when the <code>mesh3d</code> object has
no colour.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hxsurf</code> objects are based on the format of Amira's surface 
objects (see <code><a href="#topic+read.hxsurf">read.hxsurf</a></code>). They have the ability to include 
multiple distinct regions. However, at the moment the only method that we 
provide converts <code>mesh3d</code> objects, which can only include one region.
</p>


<h3>Value</h3>

<p>A new surface object of class <code>hxsurf</code> (see 
<code><a href="#topic+read.hxsurf">read.hxsurf</a></code>) for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.mesh3d">as.mesh3d</a></code>
</p>
<p>Other hxsurf: 
<code><a href="#topic+as.mesh3d">as.mesh3d</a>()</code>,
<code><a href="#topic+materials">materials</a>()</code>,
<code><a href="#topic+plot3d.hxsurf">plot3d.hxsurf</a>()</code>,
<code><a href="#topic+read.hxsurf">read.hxsurf</a>()</code>,
<code><a href="#topic+subset.hxsurf">subset.hxsurf</a>()</code>,
<code><a href="#topic+write.hxsurf">write.hxsurf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tet=tetrahedron3d(col='red')
teth=as.hxsurf(tet)

plot3d(teth)

</code></pre>

<hr>
<h2 id='as.im3d'>Convert a suitable object to an im3d object.</h2><span id='topic+as.im3d'></span><span id='topic+as.im3d.im3d'></span><span id='topic+as.im3d.matrix'></span>

<h3>Description</h3>

<p>Convert a suitable object to an im3d object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.im3d(x, ...)

## S3 method for class 'im3d'
as.im3d(x, ...)

## S3 method for class 'matrix'
as.im3d(x, voxdims, origin = NULL, BoundingBox = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.im3d_+3A_x">x</code></td>
<td>
<p>Object to turn into an im3d</p>
</td></tr>
<tr><td><code id="as.im3d_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to methods.</p>
</td></tr>
<tr><td><code id="as.im3d_+3A_voxdims">voxdims</code></td>
<td>
<p>Numeric vector of length 3 <em>or</em> an <code>im3d</code> compatible
object (see details) completely specifying the required space.</p>
</td></tr>
<tr><td><code id="as.im3d_+3A_origin">origin</code></td>
<td>
<p>the location (or centre) of the first voxel</p>
</td></tr>
<tr><td><code id="as.im3d_+3A_boundingbox">BoundingBox</code></td>
<td>
<p>Physical extent of the image. See the details section of
<code><a href="#topic+boundingbox">boundingbox</a></code>'s help for the distinction between
<code>BoundingBox</code> and <code>bounds</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At present the only interesting method in <code>nat</code> is 
<code>as.im3d.matrix</code> which can be used to convert a matrix of 3D points 
into a 3D volume representation. <code><a href="#topic+ind2coord">ind2coord</a></code> can be used to do 
the reverse: convert a set of 3D coords to an <code>im3d</code> volume.
</p>
<p>Other than that, this is a largely a placeholder function with the 
expectation that other packages may wish to provide suitable methods.
</p>
<p><code>as.im3d.matrix</code> can accept any object that can be converted to
an im3d object in the <code>voxdims</code> argument This will completely specify 
the dims, voxdims, origin etc. Any value passed to those parameters will be
ignored. This can be useful for producing a new im3d to match a target 
image on disk or a <code>nat.templatebrains::templatebrain</code> object. See
examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+im3d">im3d</a></code>, <code><a href="#topic+ind2coord">ind2coord</a></code>
</p>
<p><code><a href="#topic+im3d">im3d</a></code>, <code><a href="#topic+as.im3d">as.im3d</a></code>
</p>
<p>Other im3d: 
<code><a href="#topic+boundingbox">boundingbox</a>()</code>,
<code><a href="#topic+im3d-coords">im3d-coords</a></code>,
<code><a href="#topic+im3d-io">im3d-io</a></code>,
<code><a href="#topic+im3d">im3d</a>()</code>,
<code><a href="#topic+imexpand.grid">imexpand.grid</a>()</code>,
<code><a href="#topic+imslice">imslice</a>()</code>,
<code><a href="#topic+is.im3d">is.im3d</a>()</code>,
<code><a href="#topic+mask">mask</a>()</code>,
<code><a href="#topic+origin">origin</a>()</code>,
<code><a href="#topic+projection">projection</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>,
<code><a href="#topic+voxdims">voxdims</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## convert a list of neurons into an image volume
im=as.im3d(xyzmatrix(kcs20), voxdims=c(1, 1, 1), 
  BoundingBox=c(250, 410, 0, 130, 0, 120))
## Not run: 
write.im3d(im, 'kc20volume.nrrd')

## use image dimensions of an image on disk
# nb note use of ReadData = FALSE so that we just fetch the dimensions of
# the target image
diskim=read.im3d("/path/to/my/image.nrrd", ReadData = FALSE)
im=as.im3d(xyzmatrix(kcs20), diskim)

## use image dimensions of JFRC2 template brain to define the image space
library(nat.flybrains)
im=as.im3d(xyzmatrix(kcs20), JFRC2)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.mesh3d'>Convert an object to an rgl mesh3d</h2><span id='topic+as.mesh3d'></span><span id='topic+as.mesh3d.ashape3d'></span><span id='topic+as.mesh3d.hxsurf'></span>

<h3>Description</h3>

<p><code>as.mesh3d.ashape3d</code> converts an 
<code>alphashape3d::ashape3d</code> object into a nat/rgl compatible
<code>mesh3d</code> surface
</p>
<p>Note that this provides a link to the Rvcg package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ashape3d'
as.mesh3d(x, tri_to_keep = 2L, ...)

## S3 method for class 'hxsurf'
as.mesh3d(x, Regions = NULL, material = NULL, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mesh3d_+3A_x">x</code></td>
<td>
<p>Object to convert to mesh3d</p>
</td></tr>
<tr><td><code id="as.mesh3d_+3A_tri_to_keep">tri_to_keep</code></td>
<td>
<p>Which alphashape triangles to keep (expert use only - see
<code>triang</code> entry in <b>Value</b> section of
<code><a href="alphashape3d.html#topic+ashape3d">ashape3d</a></code> docs for details.)</p>
</td></tr>
<tr><td><code id="as.mesh3d_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods</p>
</td></tr>
<tr><td><code id="as.mesh3d_+3A_regions">Regions</code></td>
<td>
<p>Character vector or regions to select from <code>hxsurf</code>
object</p>
</td></tr>
<tr><td><code id="as.mesh3d_+3A_material">material</code></td>
<td>
<p>rgl materials such as <code>color</code></p>
</td></tr>
<tr><td><code id="as.mesh3d_+3A_drop">drop</code></td>
<td>
<p>Whether to drop unused vertices (default TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <a href="https://en.wikipedia.org/wiki/Alpha_shape">alpha shape</a> is 
a generalisation of a convex hull enclosing a set of points. Unlike a 
convex hull, the resultant surface can be partly concave allowing the 
surface to more closely follow the set of points.
</p>
<p>In this implementation, the parameter alpha is a scale factor with units of
length that defines a spatial domain. When alpha is larger the alpha shape
approaches the convex hull; when alpha is smaller the alpha shape has a
greater number of faces / vertices i.e. it follows the points more closely.
</p>


<h3>Value</h3>

<p>a <code><a href="rgl.html#topic+mesh3d">mesh3d</a></code> object which can be plotted and
manipulated using <code><a href="rgl.html#topic+rgl">rgl</a></code> and <code>nat</code> packages.
</p>


<h3>See Also</h3>

<p><code><a href="alphashape3d.html#topic+ashape3d">ashape3d</a></code>, <code><a href="rgl.html#topic+mesh3d">mesh3d</a></code>
</p>
<p><code><a href="rgl.html#topic+as.mesh3d">as.mesh3d</a></code>, <code><a href="rgl.html#topic+tmesh3d">tmesh3d</a></code>,
<code><a href="#topic+as.hxsurf">as.hxsurf</a></code>, <code><a href="#topic+read.hxsurf">read.hxsurf</a></code>
</p>
<p>Other hxsurf: 
<code><a href="#topic+as.hxsurf">as.hxsurf</a>()</code>,
<code><a href="#topic+materials">materials</a>()</code>,
<code><a href="#topic+plot3d.hxsurf">plot3d.hxsurf</a>()</code>,
<code><a href="#topic+read.hxsurf">read.hxsurf</a>()</code>,
<code><a href="#topic+subset.hxsurf">subset.hxsurf</a>()</code>,
<code><a href="#topic+write.hxsurf">write.hxsurf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(alphashape3d)
kcs20.a=ashape3d(xyzmatrix(kcs20), alpha = 10)
plot(kcs20.a)

# convert to mesh3d
kcs20.mesh=as.mesh3d(kcs20.a)

# check that all points are inside mesh
all(pointsinside(kcs20, kcs20.mesh))
# and show that we can also use the alphashape directly
all(pointsinside(kcs20, kcs20.a))

clear3d()
wire3d(kcs20.mesh)
plot3d(kcs20, col=type, lwd=2)

</code></pre>

<hr>
<h2 id='as.neuronlist'>Make a list of neurons that can be used for coordinate plotting/analysis</h2><span id='topic+as.neuronlist'></span><span id='topic+as.neuronlist.default'></span>

<h3>Description</h3>

<p>Make a list of neurons that can be used for coordinate plotting/analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.neuronlist(l, ...)

## Default S3 method:
as.neuronlist(l, df = NULL, AddClassToNeurons = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.neuronlist_+3A_l">l</code></td>
<td>
<p>An existing list or a single neuron to start a list</p>
</td></tr>
<tr><td><code id="as.neuronlist_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="as.neuronlist_+3A_df">df</code></td>
<td>
<p>the data.frame to attach with additional metadata.</p>
</td></tr>
<tr><td><code id="as.neuronlist_+3A_addclasstoneurons">AddClassToNeurons</code></td>
<td>
<p>Whether to ensure neurons have class <code>neuron</code>
(see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>as.neuronlist</code> can cope with both <code>neurons</code> and
<code>dotprops</code> objects but <code>AddClassToNeurons</code> will only apply to 
things that look like neurons but don't have a class of <code>neuron</code>.
</p>
<p>See <code><a href="#topic+neuronlist">neuronlist</a></code> details for more information.
</p>


<h3>Value</h3>

<p>neuronlist with attr('df')
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.neuronlist">is.neuronlist</a></code>,<code><a href="#topic+is.neuron">is.neuron</a></code>,<code><a href="#topic+is.dotprops">is.dotprops</a></code>
</p>

<hr>
<h2 id='as.neuronlist.neuronlistfh'>convert neuronlistfh to a regular (in memory) neuronlist</h2><span id='topic+as.neuronlist.neuronlistfh'></span>

<h3>Description</h3>

<p>convert neuronlistfh to a regular (in memory) neuronlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuronlistfh'
as.neuronlist(l, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.neuronlist.neuronlistfh_+3A_l">l</code></td>
<td>
<p>An existing list or a single neuron to start a list</p>
</td></tr>
<tr><td><code id="as.neuronlist.neuronlistfh_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
</table>

<hr>
<h2 id='boundingbox'>Get the bounding box of an im3d volume or other compatible object</h2><span id='topic+boundingbox'></span><span id='topic+boundingbox.im3d'></span><span id='topic+boundingbox.character'></span><span id='topic+boundingbox.list'></span><span id='topic+boundingbox.neuron'></span><span id='topic+boundingbox.shape3d'></span><span id='topic+boundingbox.default'></span><span id='topic+boundingbox+3C-'></span>

<h3>Description</h3>

<p><code>boundingbox.list</code> is designed to be used on objects that
contain 3D point information and for which <code>xyzmatrix</code> is defined.
</p>
<p><code>boundingbox.shape3d</code> is designed to be used on objects 
that contain 3D point information and inherit from <code>rgl</code>'s 
<code>shape3d</code> class and for which <code>xyzmatrix</code> is defined. Presently
this applies to <code><a href="rgl.html#topic+mesh3d">mesh3d</a></code> objects.
</p>
<p>Set the bounding box of an im3d object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundingbox(x, ...)

## S3 method for class 'im3d'
boundingbox(x, dims = dim(x), ...)

## S3 method for class 'character'
boundingbox(x, ...)

## S3 method for class 'list'
boundingbox(x, na.rm = FALSE, ...)

## S3 method for class 'neuron'
boundingbox(x, na.rm = FALSE, ...)

## S3 method for class 'shape3d'
boundingbox(x, na.rm = FALSE, ...)

## Default S3 method:
boundingbox(x, dims, input = c("boundingbox", "bounds"), ...)

boundingbox(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundingbox_+3A_x">x</code></td>
<td>
<p>A vector or matrix specifying a bounding box, an <code>im3d</code> object,
any object with base class list for which <code><a href="#topic+xyzmatrix">xyzmatrix</a></code> can 
extract 3D points (e.g. neurons, surfaces etc), or, for 
<code>boundingbox.character</code>, a character vector specifying a file.</p>
</td></tr>
<tr><td><code id="boundingbox_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods</p>
</td></tr>
<tr><td><code id="boundingbox_+3A_dims">dims</code></td>
<td>
<p>The number of voxels in each dimension when x is a BoundingBox 
matrix.</p>
</td></tr>
<tr><td><code id="boundingbox_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether to ignore NA points (default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="boundingbox_+3A_input">input</code></td>
<td>
<p>Whether <code>x</code> defines the boundingbox or bounds of the image 
(see details).</p>
</td></tr>
<tr><td><code id="boundingbox_+3A_value">value</code></td>
<td>
<p>The object which will provide the new boundingbox information.
This can be be either an im3d object with a boundingbox or a vector or
matrix defined according to <code>boundingbox.default</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bounding box is defined as the position of the voxels at the two
opposite corners of the cuboid encompassing an image, <em>when each voxel
is assumed to have a single position (sometimes thought of as its centre) 
<strong>and no physical extent.</strong></em> When written as a vector it should look 
like: <code>c(x0,x1,y0,y1,z0,z1)</code>. When written as a matrix it should look 
like: <code>rbind(c(x0,y0,z0),c(x1,y1,z1))</code> where x0,y0,z0 is the position 
of the origin.
</p>
<p>Note that there are two competing definitions for the physical extent of an
image that are discussed e.g. 
<a href="https://teem.sourceforge.net/nrrd/format.html">https://teem.sourceforge.net/nrrd/format.html</a>. The definition that 
makes most sense depends largely on whether you think of a pixel as a 
little square with some defined area (and therefore a voxel as a cube with 
some defined volume) <em>or</em> you take the view that you can only define 
with certainty the grid points at which image data was acquired. The first 
view implies a physical extent which we call the  <code>bounds=dim(x) * 
  c(dx,dy,dz)</code>; the second is defined as <code>BoundingBox=dim(x)-1 * 
  c(dx,dy,dz)</code> and assumes that the extent of the image is defined by a 
cuboid including the sample points at the extreme corner of the grid. Amira
takes this second view and this is the one we favour given our background 
in microscopy. If you wish to convert a <code>bounds</code> type definition into 
an im3d BoundingBox, you should pass the argument <code>input='bounds'</code>.
</p>


<h3>Value</h3>

<p>a <code>matrix</code> with 2 rows and 3 columns with 
<code>class='boundingbox'</code> or <em>NULL</em> when missing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3d.boundingbox">plot3d.boundingbox</a></code>
</p>
<p>Other im3d: 
<code><a href="#topic+as.im3d">as.im3d</a>()</code>,
<code><a href="#topic+im3d-coords">im3d-coords</a></code>,
<code><a href="#topic+im3d-io">im3d-io</a></code>,
<code><a href="#topic+im3d">im3d</a>()</code>,
<code><a href="#topic+imexpand.grid">imexpand.grid</a>()</code>,
<code><a href="#topic+imslice">imslice</a>()</code>,
<code><a href="#topic+is.im3d">is.im3d</a>()</code>,
<code><a href="#topic+mask">mask</a>()</code>,
<code><a href="#topic+origin">origin</a>()</code>,
<code><a href="#topic+projection">projection</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>,
<code><a href="#topic+voxdims">voxdims</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boundingbox(c(x0=0,x1=10,y0=0,y1=20,z0=0,z1=30))
# bounding box for a neuron
boundingbox(Cell07PNs[[1]])
</code></pre>

<hr>
<h2 id='c.neuronlist'>Combine multiple neuronlists into a single list</h2><span id='topic+c.neuronlist'></span>

<h3>Description</h3>

<p>Combine multiple neuronlists into a single list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuronlist'
c(..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.neuronlist_+3A_...">...</code></td>
<td>
<p>neuronlists to combine</p>
</td></tr>
<tr><td><code id="c.neuronlist_+3A_recursive">recursive</code></td>
<td>
<p>Presently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="plyr.html#topic+rbind.fill">rbind.fill</a></code> to join any attached dataframes,
so missing values are replaced with NAs.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+c">c</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stopifnot(all.equal(kcs20[1:2],c(kcs20[1],kcs20[2])))
</code></pre>

<hr>
<h2 id='Cell07PNs'>Cell07PNs: 40 Sample Projection Neurons from Jefferis, Potter et al 2007</h2><span id='topic+Cell07PNs'></span>

<h3>Description</h3>

<p>These R lists (which have additional class neuronlist) contain 40 traced
olfactory projection neurons from Jefferis, Potter et al 2007 that have been
transformed onto the IS2 template brain (Cachero, Ostrovsky et al 2010).
</p>


<h3>References</h3>

<p>Jefferis G.S.X.E., Potter C.J., Chan A.M., Marin E.C., Rohlfing
T., Maurer C.R.J., and Luo L. (2007). Comprehensive maps of Drosophila
higher olfactory centers: spatially segregated fruit and pheromone
representation. Cell 128 (6), 1187&ndash;1203. <a href="https://doi.org/10.1016/j.cell.2007.01.040">doi:10.1016/j.cell.2007.01.040</a>
</p>
<p>Cachero S., Ostrovsky A.D., Yu J.Y., Dickson B.J., and Jefferis G.S.X.E.
(2010). Sexual dimorphism in the fly brain. Curr Biol 20 (18), 1589&ndash;601.
<a href="https://doi.org/10.1016/j.cub.2010.07.045">doi:10.1016/j.cub.2010.07.045</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+head.neuronlist">head.neuronlist</a></code>, <code><a href="#topic+with.neuronlist">with.neuronlist</a></code>
</p>
<p>Other nat-data: 
<code><a href="#topic+MBL.surf">MBL.surf</a></code>,
<code><a href="#topic+kcs20">kcs20</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(Cell07PNs)
table(with(Cell07PNs,Glomerulus))
</code></pre>

<hr>
<h2 id='clampmax'>Return function that finds maximum of its inputs within a clamping range</h2><span id='topic+clampmax'></span>

<h3>Description</h3>

<p>Return function that finds maximum of its inputs within a clamping range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clampmax(xmin, xmax, replace.infinite = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clampmax_+3A_xmin">xmin</code>, <code id="clampmax_+3A_xmax">xmax</code></td>
<td>
<p>clamping range. If xmax is missing xmin should be a vector
of length 2.</p>
</td></tr>
<tr><td><code id="clampmax_+3A_replace.infinite">replace.infinite</code></td>
<td>
<p>The value with which to replace non-finite values
<em>in the input vector</em>. When <code>replace.infinite=FALSE</code> no action is
taken. The default value of <code>NA</code> will result in e.g. <code>Inf</code> being
mapped to <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that by default infinite values in the input vector are
converted to <code>NA</code>s before the being compared with the clampmax range.
</p>


<h3>Value</h3>

<p>A function with signature <code>f(x, ..., na.rm)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
LHMask=read.im3d(system.file('tests/testthat/testdata/nrrd/LHMask.nrrd',package='nat'))
d=unmask(rnorm(sum(LHMask),mean=5,sd=5),LHMask)
op=par(mfrow=c(1,2))
rval=image(projection(d,projfun=max))
image(projection(d,projfun=clampmax(0,10)),zlim=rval$zlim)
par(op)

## End(Not run)
</code></pre>

<hr>
<h2 id='cmtk.bindir'>Return path to directory containing CMTK binaries</h2><span id='topic+cmtk.bindir'></span><span id='topic+cmtk'></span>

<h3>Description</h3>

<p>The <a href="https://www.nitrc.org/projects/cmtk">Computational
Morphometry Toolkit</a> (CMTK) is the default image registration toolkit
supported by nat. An external CMTK installation is required in order to
apply CMTK registrations. This function attempts to locate the full path to
the CMTK executable files and can query and set an option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtk.bindir(
  firstdir = getOption("nat.cmtk.bindir"),
  extradirs = c("~/bin", "/usr/local/lib/cmtk/bin", "/usr/local/bin", "/opt/local/bin",
    "/opt/local/lib/cmtk/bin/", "/Applications/IGSRegistrationTools/bin",
    "C:\\cygwin64\\usr\\local\\lib\\cmtk\\bin",
    "C:\\Program Files\\CMTK-3.3\\CMTK\\lib\\cmtk\\bin"),
  set = FALSE,
  check = FALSE,
  cmtktool = "gregxform"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmtk.bindir_+3A_firstdir">firstdir</code></td>
<td>
<p>Character vector specifying path containing CMTK binaries or
NA (see details). This defaults to options('nat.cmtk.bindir').</p>
</td></tr>
<tr><td><code id="cmtk.bindir_+3A_extradirs">extradirs</code></td>
<td>
<p>Where to look if CMTK is not in <code>firstdir</code> or the PATH</p>
</td></tr>
<tr><td><code id="cmtk.bindir_+3A_set">set</code></td>
<td>
<p>Whether to set options('nat.cmtk.bindir') with the found
directory. Also check/sets cygwin path on Windows (see Installation
section).</p>
</td></tr>
<tr><td><code id="cmtk.bindir_+3A_check">check</code></td>
<td>
<p>Whether to (re)check that a path that has been set appropriately
in options(nat.cmtk.bindir='/some/path') or now found in the PATH or
alternative directories. Will throw an error on failure.</p>
</td></tr>
<tr><td><code id="cmtk.bindir_+3A_cmtktool">cmtktool</code></td>
<td>
<p>Name of a specific cmtk tool which will be used to identify
the location of all cmtk binaries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Queries options('nat.cmtk.bindir') if <code>firstdir</code> is not
specified. If that does not contain the appropriate binaries, it will look
in the system PATH for the <code>cmtk</code> wrapper script installed by most
recent cmtk installations.
</p>
<p>Failing that, it will look for the cmtk tool specified by <code>cmtktool</code>,
first in the path and then a succession of plausible places until it finds
something. Setting <code>options(nat.cmtk.bindir=NA)</code> or passing
<code>firstdir=NA</code> will stop the function from trying to locate CMTK,
always returning NULL unless <code>check=TRUE</code>, in which case it will error
out.
</p>


<h3>Value</h3>

<p>Character vector giving path to CMTK binary directory or NULL when
this cannot be found.
</p>


<h3>Installation</h3>

<p>It is recommended to install released CMTK versions
available from the <a href="https://www.nitrc.org/projects/cmtk/">NITRC
website</a>. A bug in composition of affine transformations from CMTK
parameters in the CMTK versions &lt;2.4 series means that CMTK&gt;=3.0 is
strongly recommended. CMTK v3 registrations are not backwards compatible
with CMTK v2, but CMTKv3 can correctly interpret and convert registrations
from earlier versions.
</p>
<p>On Windows, when <code>set=TRUE</code>, cmtk.bindir will also check that the
cygwin bin directory is in the PATH. If it is not, then it is added for the
current R session. This should solve issues with missing cygwin dlls.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+options">options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>message(ifelse(is.null(d&lt;-cmtk.bindir()), "CMTK not found!",
               paste("CMTK is at:",d)))
## Not run: 
# set options('nat.cmtk.bindir') according to where cmtk was found
op=options(nat.cmtk.bindir=NULL)
cmtk.bindir(set=TRUE)
options(op)
## End(Not run)
</code></pre>

<hr>
<h2 id='cmtk.call'>Utility function to create and run calls to CMTK commandline tools</h2><span id='topic+cmtk.call'></span><span id='topic+cmtk.system2'></span>

<h3>Description</h3>

<p><code>cmtk.call</code> processes arguments into a form compatible with
CMTK command line tools.
</p>
<p><code>cmtk.system2</code> actually calls a cmtk tool using a call list
produced by <code>cmtk.call</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtk.call(
  tool,
  PROCESSED.ARGS = NULL,
  ...,
  FINAL.ARGS = NULL,
  RETURN.TYPE = c("string", "list")
)

cmtk.system2(cmtkcall, moreargs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmtk.call_+3A_tool">tool</code></td>
<td>
<p>Name of the CMTK tool</p>
</td></tr>
<tr><td><code id="cmtk.call_+3A_processed.args">PROCESSED.ARGS</code></td>
<td>
<p>Character vector of arguments that have already been 
processed by the callee. Placed immediately after cmtk tool.</p>
</td></tr>
<tr><td><code id="cmtk.call_+3A_...">...</code></td>
<td>
<p>Additional named arguments to be processed by (<code>cmtk.call</code>, 
see details) or passed to <code>system2</code> (<code>cmtk.system2</code>).</p>
</td></tr>
<tr><td><code id="cmtk.call_+3A_final.args">FINAL.ARGS</code></td>
<td>
<p>Character vector of arguments that have already been 
processed by the callee. Placed at the end of the call after optional 
arguments.</p>
</td></tr>
<tr><td><code id="cmtk.call_+3A_return.type">RETURN.TYPE</code></td>
<td>
<p>Sets return type to a character string or list (the latter
is suitable for use with <code><a href="base.html#topic+system2">system2</a></code>)</p>
</td></tr>
<tr><td><code id="cmtk.call_+3A_cmtkcall">cmtkcall</code></td>
<td>
<p>A list containing processed arguments prepared by 
<code>cmtk.call(RETURN.TYPE="list")</code></p>
</td></tr>
<tr><td><code id="cmtk.call_+3A_moreargs">moreargs</code></td>
<td>
<p>Additional arguments to add to the processed call</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cmtk.call</code> processes arguments in ... as follows:
</p>

<dl>
<dt>argument names</dt><dd><p> will be converted from <code>arg.name</code> to 
<code>--arg-name</code></p>
</dd>
<dt>logical vectors</dt><dd><p> (which must be of length 1) will be passed on as 
<code>--arg-name</code></p>
</dd>
<dt>character vectors</dt><dd><p> (which must be of length 1) will be passed on as 
<code>--arg-name arg</code> i.e. quoting is left up to callee.</p>
</dd>
<dt>numeric vectors</dt><dd><p> will be collapsed with commas if of length greater 
than 1 and then passed on unquoted e.g. <code>target.offset=c(1,2,3)</code> will 
result in <code>--target-offset 1,2,3</code></p>
</dd>
</dl>



<h3>Value</h3>

<p><em>Either</em> a string of the form <code>"&lt;tool&gt; &lt;PROCESSED.ARGS&gt; 
  &lt;...&gt; &lt;FINAL.ARGS&gt;"</code> <em>or</em> a list containing elements </p>

<ul>
<li><p> command A character vector of length 1 indicating the full path to 
the CMTK tool, shell quoted for protection.
</p>
</li>
<li><p> args A character vector of arguments of length 0 or greater.
</p>
</li></ul>

<p>See the help of <code><a href="base.html#topic+system2">system2</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmtk.bindir">cmtk.bindir</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cmtk.call("reformatx",'--outfile=out.nrrd', floating='floating.nrrd',
  mask=TRUE, target.offset=c(1,2,3), FINAL.ARGS=c('target.nrrd','reg.list'))
# get help for a cmtk tool
system(cmtk.call('reformatx', help=TRUE))

## End(Not run)
## Not run: 
cmtk.system2(cmtk.call('mat2dof', help=TRUE, RETURN.TYPE="list"))
# capture response into an R variable
helptext=cmtk.system2(cmtk.call('mat2dof', help=TRUE, RETURN.TYPE="list"),
  stdout=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cmtk.dof2mat'>Convert CMTK registration to homogeneous affine matrix with dof2mat</h2><span id='topic+cmtk.dof2mat'></span>

<h3>Description</h3>

<p>Convert CMTK registration to homogeneous affine matrix with dof2mat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtk.dof2mat(reg, Transpose = TRUE, version = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmtk.dof2mat_+3A_reg">reg</code></td>
<td>
<p>Path to input registration file or 5x3 matrix of CMTK parameters.</p>
</td></tr>
<tr><td><code id="cmtk.dof2mat_+3A_transpose">Transpose</code></td>
<td>
<p>ouput matrix so that form on disk matches R's convention.</p>
</td></tr>
<tr><td><code id="cmtk.dof2mat_+3A_version">version</code></td>
<td>
<p>Whether to return CMTK version string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transpose is true by default since this results in the orientation
of cmtk output files matching the orientation in R. Do not change this
unless you're sure you know what you're doing!
</p>


<h3>Value</h3>

<p>4x4 transformation matrix
</p>


<h3>See Also</h3>

<p>Other cmtk-commandline: 
<code><a href="#topic+cmtk.mat2dof">cmtk.mat2dof</a>()</code>
</p>
<p>Other cmtk-geometry: 
<code><a href="#topic+affmat2cmtkparams">affmat2cmtkparams</a>()</code>,
<code><a href="#topic+cmtk.mat2dof">cmtk.mat2dof</a>()</code>,
<code><a href="#topic+cmtkparams2affmat">cmtkparams2affmat</a>()</code>
</p>

<hr>
<h2 id='cmtk.extract_affine'>Extract affine registration from CMTK registration file or in-memory list</h2><span id='topic+cmtk.extract_affine'></span>

<h3>Description</h3>

<p>Extract affine registration from CMTK registration file or in-memory list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtk.extract_affine(r, outdir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmtk.extract_affine_+3A_r">r</code></td>
<td>
<p>A registration list or path to file on disk</p>
</td></tr>
<tr><td><code id="cmtk.extract_affine_+3A_outdir">outdir</code></td>
<td>
<p>Optional path to output file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>outdir</code> is missing a list containing the registration
paramers. Otherwise <code>NULL</code> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmtkreglist">cmtkreglist</a></code>
</p>
<p>Other cmtk-io: 
<code><a href="#topic+read.cmtkreg">read.cmtkreg</a>()</code>,
<code><a href="#topic+read.cmtk">read.cmtk</a>()</code>,
<code><a href="#topic+write.cmtkreg">write.cmtkreg</a>()</code>,
<code><a href="#topic+write.cmtk">write.cmtk</a>()</code>
</p>

<hr>
<h2 id='cmtk.mat2dof'>Use CMTK mat2dof to convert homogeneous affine matrix into CMTK registration</h2><span id='topic+cmtk.mat2dof'></span>

<h3>Description</h3>

<p>Use CMTK mat2dof to convert homogeneous affine matrix into CMTK registration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtk.mat2dof(m, f = NULL, centre = NULL, Transpose = TRUE, version = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmtk.mat2dof_+3A_m">m</code></td>
<td>
<p>Homogenous affine matrix (4x4) last row 0 0 0 1 etc</p>
</td></tr>
<tr><td><code id="cmtk.mat2dof_+3A_f">f</code></td>
<td>
<p>Output file (optional)</p>
</td></tr>
<tr><td><code id="cmtk.mat2dof_+3A_centre">centre</code></td>
<td>
<p>Centre for rotation (optional 3-vector)</p>
</td></tr>
<tr><td><code id="cmtk.mat2dof_+3A_transpose">Transpose</code></td>
<td>
<p>the input matrix so that it is read in as it appears on disk</p>
</td></tr>
<tr><td><code id="cmtk.mat2dof_+3A_version">version</code></td>
<td>
<p>When TRUE, function returns CMTK version number of mat2dof
tool</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no output file is supplied, 5x3 params matrix will be returned 
directly. Otherwise a logical will be returned indicating success or 
failure at writing to disk.
</p>
<p>Transpose is true by default since this results in an R matrix with 
the transpose in the fourth column being correctly interpreted by cmtk.
</p>


<h3>Value</h3>

<p>5x3 matrix of CMTK registration parameters or logical
</p>


<h3>See Also</h3>

<p>Other cmtk-commandline: 
<code><a href="#topic+cmtk.dof2mat">cmtk.dof2mat</a>()</code>
</p>
<p>Other cmtk-geometry: 
<code><a href="#topic+affmat2cmtkparams">affmat2cmtkparams</a>()</code>,
<code><a href="#topic+cmtk.dof2mat">cmtk.dof2mat</a>()</code>,
<code><a href="#topic+cmtkparams2affmat">cmtkparams2affmat</a>()</code>
</p>

<hr>
<h2 id='cmtk.reformatx'>Reformat an image with a CMTK registration using the reformatx tool</h2><span id='topic+cmtk.reformatx'></span>

<h3>Description</h3>

<p>Reformat an image with a CMTK registration using the reformatx tool
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtk.reformatx(
  floating,
  registrations,
  output,
  target,
  mask = FALSE,
  direction = NULL,
  interpolation = c("linear", "nn", "cubic", "pv", "sinc-cosine", "sinc-hamming"),
  dryrun = FALSE,
  Verbose = TRUE,
  MakeLock = TRUE,
  OverWrite = c("no", "update", "yes"),
  filesToIgnoreModTimes = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmtk.reformatx_+3A_floating">floating</code></td>
<td>
<p>The floating image to be reformatted</p>
</td></tr>
<tr><td><code id="cmtk.reformatx_+3A_registrations">registrations</code></td>
<td>
<p>One or more CMTK format registrations on disk</p>
</td></tr>
<tr><td><code id="cmtk.reformatx_+3A_output">output</code></td>
<td>
<p>The path to the output image (defaults to
<code>"&lt;targetstem&gt;_&lt;floatingstem&gt;.nrrd"</code>)</p>
</td></tr>
<tr><td><code id="cmtk.reformatx_+3A_target">target</code></td>
<td>
<p>A character vector specifying an image file on disk, an
<code>im3d</code> object (or an object that can be coerced to im3d) or a 6-or
9-vector defining a grid in the form Nx,Ny,Nz,dX,dY,dZ,[Ox,Oy,Oz].</p>
</td></tr>
<tr><td><code id="cmtk.reformatx_+3A_mask">mask</code></td>
<td>
<p>Whether to treat target as a binary mask (only reformatting 
positive voxels)</p>
</td></tr>
<tr><td><code id="cmtk.reformatx_+3A_direction">direction</code></td>
<td>
<p>Whether to transform image from sample space to reference
space (called <strong>forward</strong> by CMTK) or from reference to sample space
(called <strong>inverse</strong> by CMTK). Default (when <code>NULL</code> is forward).</p>
</td></tr>
<tr><td><code id="cmtk.reformatx_+3A_interpolation">interpolation</code></td>
<td>
<p>What interpolation scheme to use for output image 
(defaults to linear - see details)</p>
</td></tr>
<tr><td><code id="cmtk.reformatx_+3A_dryrun">dryrun</code></td>
<td>
<p>Just print command</p>
</td></tr>
<tr><td><code id="cmtk.reformatx_+3A_verbose">Verbose</code></td>
<td>
<p>Whether to show cmtk status messages and be verbose about file
update checks. Sets command line <code>--verbose</code> option.</p>
</td></tr>
<tr><td><code id="cmtk.reformatx_+3A_makelock">MakeLock</code></td>
<td>
<p>Whether to use a lock file to allow simple parallelisation 
(see <code>makelock</code>)</p>
</td></tr>
<tr><td><code id="cmtk.reformatx_+3A_overwrite">OverWrite</code></td>
<td>
<p>Whether to OverWrite an existing output file. One of 
c(&quot;no&quot;,&quot;update&quot;,&quot;yes&quot;). When OverWrite='update' 
<code><a href="nat.utils.html#topic+RunCmdForNewerInput">RunCmdForNewerInput</a></code> is used to determine if the output is 
older than any of the input files.</p>
</td></tr>
<tr><td><code id="cmtk.reformatx_+3A_filestoignoremodtimes">filesToIgnoreModTimes</code></td>
<td>
<p>Input files whose modification time should not 
be checked when determining if new output is required.</p>
</td></tr>
<tr><td><code id="cmtk.reformatx_+3A_...">...</code></td>
<td>
<p>additional arguments passed to CMTK <code>reformatx</code> after 
processing by <code><a href="#topic+cmtk.call">cmtk.call</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if you are reformatting a mask then you will need to 
change the interpolation to &quot;nn&quot;, since interpolating between e.g. mask 
levels 72 and 74 with 73 may have unintened consequences. Presently we have
no way of knowing whether an image should be treated as a mask, so the 
<code>interpolation</code> must be handled manually.
</p>


<h3>Value</h3>

<p>the path to the ouput image (whether or not it was re-created afresh)
or <code>NA_character_</code> if no output was possible.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmtk.bindir">cmtk.bindir</a>, <a href="#topic+cmtk.call">cmtk.call</a>, <a href="nat.utils.html#topic+makelock">makelock</a>, 
  <a href="nat.utils.html#topic+RunCmdForNewerInput">RunCmdForNewerInput</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cmtk.reformatx('myimage.nrrd', target='template.nrrd',
  registrations='template_myimage.list')

# get full listing of command line options  
system(cmtk.call('reformatx', help=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='cmtk.statistics'>Calculate image statistics for a nrrd or other CMTK compatible file</h2><span id='topic+cmtk.statistics'></span>

<h3>Description</h3>

<p>Calculate image statistics for a nrrd or other CMTK compatible file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtk.statistics(
  f,
  mask,
  imagetype = c("greyscale", "label"),
  masktype = c("label", "binary"),
  ...,
  Verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmtk.statistics_+3A_f">f</code></td>
<td>
<p>Path to image file (any CMTK compatible format)</p>
</td></tr>
<tr><td><code id="cmtk.statistics_+3A_mask">mask</code></td>
<td>
<p>Optional path to a mask file</p>
</td></tr>
<tr><td><code id="cmtk.statistics_+3A_imagetype">imagetype</code></td>
<td>
<p>Whether image should be treated as greyscale (default) or 
label field.</p>
</td></tr>
<tr><td><code id="cmtk.statistics_+3A_masktype">masktype</code></td>
<td>
<p>Whether mask should be treated as label field or binary mask 
(default label)</p>
</td></tr>
<tr><td><code id="cmtk.statistics_+3A_...">...</code></td>
<td>
<p>Additional arguments for ctmk's statistics tool processed by 
<code><a href="#topic+cmtk.call">cmtk.call</a></code>.</p>
</td></tr>
<tr><td><code id="cmtk.statistics_+3A_verbose">Verbose</code></td>
<td>
<p>Whether to show cmtk status messages and be verbose about file
update checks. Sets command line <code>--verbose</code> option.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When given a label mask, returns a dataframe with a row for each 
level of the label field.
</p>
<p>Note that the Entropy column (sometimes H, sometimes Entropy) will 
always be named Entropy in the returned dataframe.
</p>


<h3>Value</h3>

<p>data.frame describing results with the following columns when image
<code>f</code> is of <code>imagetype='greyscale'</code> (optionally with a mask):
</p>

<ul>
<li><p> MaskLevel (only present when using a mask) the integer value of the 
label field for this region
</p>
</li>
<li><p> min The minimum voxel value within the current region
</p>
</li>
<li><p> max The maximum voxel value within the current region
</p>
</li>
<li><p> mean The mean voxel value within the current region
</p>
</li>
<li><p> sdev The standard deviation of voxel values within the current region
</p>
</li>
<li><p> n The count of <b>all</b> voxel within the region (irrespective of 
their value)
</p>
</li>
<li><p> Entropy Information theoretic entropy of voxel value distribution 
within region
</p>
</li>
<li><p> sum Sum of voxel values within the region
</p>
</li></ul>

<p>When image <code>f</code> is of <code>imagetype='label'</code>, the following results
are returned:
</p>

<ul>
<li><p> level The integer value of the label field for this region
</p>
</li>
<li><p> count The number of voxels in this region
</p>
</li>
<li><p> surface The surface area of this region
</p>
</li>
<li><p> volume The volume of this region
</p>
</li>
<li><p> X,Y,Z 3D coordinates of the centroid of this region
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cmtk.statistics('someneuron.nrrd', mask='neuropilregionmask.nrrd')
cmtk.statistics('somelabelfield.nrrd', imagetype='label')

## End(Not run)
</code></pre>

<hr>
<h2 id='cmtk.targetvolume'>Defines a target volume for a CMTK reformatx operation</h2><span id='topic+cmtk.targetvolume'></span><span id='topic+cmtk.targetvolume.im3d'></span><span id='topic+cmtk.targetvolume.list'></span><span id='topic+cmtk.targetvolume.default'></span>

<h3>Description</h3>

<p><code>cmtk.targetvolume.list</code> is designed to cope with any 
user-defined class for which an as.im3d method exists. Presently the only
example in the nat.* ecosystem is
<code>nat.templatebrains::as.im3d.templatebrain</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtk.targetvolume(target, ...)

## S3 method for class 'im3d'
cmtk.targetvolume(target, ...)

## S3 method for class 'list'
cmtk.targetvolume(target, ...)

## Default S3 method:
cmtk.targetvolume(target, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmtk.targetvolume_+3A_target">target</code></td>
<td>
<p>A character vector specifying an image file on disk, an
<code>im3d</code> object (or an object that can be coerced to im3d) or a 6-or
9-vector defining a grid in the form Nx,Ny,Nz,dX,dY,dZ,[Ox,Oy,Oz].</p>
</td></tr>
<tr><td><code id="cmtk.targetvolume_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if the character vector specifies an amiramesh file, it will be 
converted to a bare <code>im3d</code> object and then to an appropriate 
'&ndash;target-grid' specification.
</p>


<h3>Value</h3>

<p>a character vector specifying the full cmtk reformatx '&ndash;target' or 
'&ndash;target-grid' argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# see https://github.com/jefferislab/nat.flybrains
library(nat.flybrains)
cmtk.targetvolume(FCWB)

## End(Not run)
</code></pre>

<hr>
<h2 id='cmtk.version'>Return cmtk version or test for presence of at least a specific version</h2><span id='topic+cmtk.version'></span>

<h3>Description</h3>

<p>Return cmtk version or test for presence of at least a specific version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtk.version(minimum = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmtk.version_+3A_minimum">minimum</code></td>
<td>
<p>If specified checks that the cmtk version</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NB this function has the side effect of setting an option 
nat.cmtk.version the first time that it is run in the current R session.
</p>


<h3>Value</h3>

<p>returns <code>numeric_version</code> representation of CMTK version or if 
minimum is not NULL, returns a logical indicating whether the installed 
version exceeds the current version. If CMTK is not installed returns NA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmtk.bindir">cmtk.bindir</a>, <a href="#topic+cmtk.dof2mat">cmtk.dof2mat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cmtk.version()
cmtk.version('3.2.2')

## End(Not run)
</code></pre>

<hr>
<h2 id='cmtkparams2affmat'>Compose homogeneous affine matrix from CMTK registration parameters</h2><span id='topic+cmtkparams2affmat'></span>

<h3>Description</h3>

<p>Compose homogeneous affine matrix from CMTK registration parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtkparams2affmat(
  params = NULL,
  tx = 0,
  ty = 0,
  tz = 0,
  rx = 0,
  ry = 0,
  rz = 0,
  sx = 1,
  sy = 1,
  sz = 1,
  shx = 0,
  shy = 0,
  shz = 0,
  cx = 0,
  cy = 0,
  cz = 0,
  legacy = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmtkparams2affmat_+3A_params">params</code></td>
<td>
<p>5x3 matrix of CMTK registration parameters or list of length 5.</p>
</td></tr>
<tr><td><code id="cmtkparams2affmat_+3A_tx">tx</code>, <code id="cmtkparams2affmat_+3A_ty">ty</code>, <code id="cmtkparams2affmat_+3A_tz">tz</code></td>
<td>
<p>Translation along x, y and z axes (default 0)</p>
</td></tr>
<tr><td><code id="cmtkparams2affmat_+3A_rx">rx</code>, <code id="cmtkparams2affmat_+3A_ry">ry</code>, <code id="cmtkparams2affmat_+3A_rz">rz</code></td>
<td>
<p>Rotation about x, y and z axes (in degrees, default 0)</p>
</td></tr>
<tr><td><code id="cmtkparams2affmat_+3A_sx">sx</code>, <code id="cmtkparams2affmat_+3A_sy">sy</code>, <code id="cmtkparams2affmat_+3A_sz">sz</code></td>
<td>
<p>Scale for x, y and z axes (default 1)</p>
</td></tr>
<tr><td><code id="cmtkparams2affmat_+3A_shx">shx</code>, <code id="cmtkparams2affmat_+3A_shy">shy</code>, <code id="cmtkparams2affmat_+3A_shz">shz</code></td>
<td>
<p>Shear for x,y,z axes (default 0)</p>
</td></tr>
<tr><td><code id="cmtkparams2affmat_+3A_cx">cx</code>, <code id="cmtkparams2affmat_+3A_cy">cy</code>, <code id="cmtkparams2affmat_+3A_cz">cz</code></td>
<td>
<p>Centre for rotation</p>
</td></tr>
<tr><td><code id="cmtkparams2affmat_+3A_legacy">legacy</code></td>
<td>
<p>Whether to assume that parameters are in the format used by 
CMTK &lt;=2.4.0 (default value NA implies FALSE, see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>legacy</code> parameter is not set explicitly, then it will 
be set to <code>TRUE</code> if params has a version attribute &lt;2.4 or FALSE 
otherwise.
</p>
<p>translation and centre components are assumed to be in physical 
coordinates.
</p>


<h3>Value</h3>

<p>4x4 homogeneous affine transformation matrix
</p>


<h3>See Also</h3>

<p>Other cmtk-geometry: 
<code><a href="#topic+affmat2cmtkparams">affmat2cmtkparams</a>()</code>,
<code><a href="#topic+cmtk.dof2mat">cmtk.dof2mat</a>()</code>,
<code><a href="#topic+cmtk.mat2dof">cmtk.mat2dof</a>()</code>
</p>

<hr>
<h2 id='cmtkreg'>Create and test cmtkreg objects that specify path to a CMTK registration</h2><span id='topic+cmtkreg'></span><span id='topic+as.cmtkreg'></span><span id='topic+as.cmtkreg.matrix'></span><span id='topic+as.cmtkreg.reglist'></span><span id='topic+as.cmtkreg.default'></span><span id='topic+is.cmtkreg'></span>

<h3>Description</h3>

<p><code>cmtkreg</code> creates an object of class <code>cmtkreg</code> that
describes one (or more) <a href="https://www.nitrc.org/projects/cmtk/">CMTK</a>
registrations. This is simply a character vector that also has class
cmtkreg.
</p>
<p><code>as.cmtkreg</code> converts objects to class <code>cmtkreg</code>,
minimally just by adding an approriate class attribute.
</p>
<p><code>is.cmtkreg</code> checks if an object is a cmtk registration
either by checking class (default), or inspecting file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtkreg(x, returnDir = TRUE)

as.cmtkreg(x, ...)

## S3 method for class 'matrix'
as.cmtkreg(x, ...)

## S3 method for class 'reglist'
as.cmtkreg(x, ...)

## Default S3 method:
as.cmtkreg(x, ...)

is.cmtkreg(x, filecheck = c("none", "exists", "magic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmtkreg_+3A_x">x</code></td>
<td>
<p>Path to a cmtk registration (either plain character vector or 
cmtkreg object)</p>
</td></tr>
<tr><td><code id="cmtkreg_+3A_returndir">returnDir</code></td>
<td>
<p>Whether to return the registration directory (default) or 
the actual file containing the registration</p>
</td></tr>
<tr><td><code id="cmtkreg_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods. Currently ignored.</p>
</td></tr>
<tr><td><code id="cmtkreg_+3A_filecheck">filecheck</code></td>
<td>
<p>Whether to check object class only (default: 'none') or find
amd check if registration file <strong>exists</strong> or check <strong>magic</strong> 
value in first line of file.</p>
</td></tr>
</table>

<hr>
<h2 id='cmtkreglist'>Make in-memory CMTK registration list from affine matrix or CMTK parameters</h2><span id='topic+cmtkreglist'></span>

<h3>Description</h3>

<p>Make in-memory CMTK registration list from affine matrix or CMTK parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtkreglist(x, centre = c(0, 0, 0), reference = "dummy", floating = "dummy")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmtkreglist_+3A_x">x</code></td>
<td>
<p>5x3 matrix of CMTK registration parameters OR 4x4 homogeneous affine
matrix</p>
</td></tr>
<tr><td><code id="cmtkreglist_+3A_centre">centre</code></td>
<td>
<p>Optional centre of rotation passed to <code>affmat2cmtkparams</code> 
when decomposing 4x4 affine matrix</p>
</td></tr>
<tr><td><code id="cmtkreglist_+3A_reference">reference</code>, <code id="cmtkreglist_+3A_floating">floating</code></td>
<td>
<p>Path to refererence and floating images.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this uses the modern CMTK notation of floating_study 
rather than model_study as used by IGSParamsToIGSRegistration (which 
results in an implicit inversion by CMTK tools).
</p>
<p>Note that the reference and floating fields have no impact on the 
transformation encoded in the resultant .list folder and can be overridden 
on the command line of CMTK tools.
</p>


<h3>Value</h3>

<p><code>list</code> of class <code>cmtkreg</code> containing registration
parameters suitable for <code><a href="#topic+write.cmtkreg">write.cmtkreg</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.cmtkreg">write.cmtkreg</a>, <a href="#topic+affmat2cmtkparams">affmat2cmtkparams</a>, <a href="#topic+cmtkreg">cmtkreg</a></code>
</p>

<hr>
<h2 id='coord2ind'>Find 1D indices into a 3D image given spatial coordinates</h2><span id='topic+coord2ind'></span><span id='topic+coord2ind.default'></span>

<h3>Description</h3>

<p>Find 1D indices into a 3D image given spatial coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord2ind(coords, ...)

## Default S3 method:
coord2ind(
  coords,
  imdims,
  voxdims = NULL,
  origin = NULL,
  aperm,
  Clamp = FALSE,
  CheckRanges = !Clamp,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord2ind_+3A_coords">coords</code></td>
<td>
<p>spatial coordinates of image voxels.</p>
</td></tr>
<tr><td><code id="coord2ind_+3A_...">...</code></td>
<td>
<p>extra arguments passed to methods.</p>
</td></tr>
<tr><td><code id="coord2ind_+3A_imdims">imdims</code></td>
<td>
<p>array dimensions of 3D image <em>OR</em> an object for which a 
<code><a href="#topic+as.im3d">as.im3d</a></code> object has been defined (see Details).</p>
</td></tr>
<tr><td><code id="coord2ind_+3A_voxdims">voxdims</code></td>
<td>
<p>vector of 3 voxels dimensions (width, height, depth).</p>
</td></tr>
<tr><td><code id="coord2ind_+3A_origin">origin</code></td>
<td>
<p>the origin of the 3D image.</p>
</td></tr>
<tr><td><code id="coord2ind_+3A_aperm">aperm</code></td>
<td>
<p>permutation order for axes.</p>
</td></tr>
<tr><td><code id="coord2ind_+3A_clamp">Clamp</code></td>
<td>
<p>???</p>
</td></tr>
<tr><td><code id="coord2ind_+3A_checkranges">CheckRanges</code></td>
<td>
<p>whether to check if coordinates are out of range.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coord2ind</code> is designed to cope with any user-defined class for
which an as.im3d method exists. Presently the only example in the nat.* 
ecosystem is <code>nat.templatebrains::as.im3d.templatebrain</code>. The 
existence of an <code>as.im3d</code> method implies that 
<code>voxdims</code>,<code>origin</code>, and <code>dim</code> functions can be called. This
is the necessary information required to convert i,j,k logical indices into
x,y,z spatial indices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ind2coord">ind2coord</a></code>, <code><a href="#topic+sub2ind">sub2ind</a></code>, <code><a href="#topic+ijkpos">ijkpos</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coord2ind(cbind(1,2,3), imdims = c(1024,512,218), 
  voxdims = c(0.622088, 0.622088, 0.622088), origin = c(0,0,0))
## Not run: 
## repeat but using a templatebrain object to specify the coordinate system
library(nat.flybrains)
coord2ind(cbind(1,2,3), JFRC2)

## End(Not run)
</code></pre>

<hr>
<h2 id='dotprops'>dotprops: Neurons as point clouds with tangent vectors (but no connectivity)</h2><span id='topic+dotprops'></span><span id='topic+is.dotprops'></span><span id='topic+as.dotprops'></span><span id='topic+dotprops.character'></span><span id='topic+dotprops.dotprops'></span><span id='topic+dotprops.im3d'></span><span id='topic+dotprops.neuronlist'></span><span id='topic+dotprops.neuron'></span><span id='topic+dotprops.default'></span>

<h3>Description</h3>

<p><code>dotprops</code> makes dotprops representation from raw 3D points
(extracting vertices from S3 objects that have them)
</p>
<p><code>dotprops.dotprops</code> will default to the original vale of 
<code>k</code> and copy over all attributes that are not set by
<code>dotprops.default</code>.
</p>
<p><code>dotprops.neuronlist</code> will run for every object in the 
neuronlist using <code><a href="#topic+nlapply">nlapply</a></code>. <code>...</code> arguments will be passed to 
<code>nlapply</code> in addition to the named argument <code>OmitFailures</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.dotprops(x)

as.dotprops(x, ...)

dotprops(x, ...)

## S3 method for class 'character'
dotprops(x, ...)

## S3 method for class 'dotprops'
dotprops(x, k = attr(x, "k"), ...)

## S3 method for class 'im3d'
dotprops(x, ...)

## S3 method for class 'neuronlist'
dotprops(x, ..., OmitFailures = NA)

## S3 method for class 'neuron'
dotprops(x, Labels = NULL, resample = NA, ...)

## Default S3 method:
dotprops(x, k = NULL, Labels = NULL, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dotprops_+3A_x">x</code></td>
<td>
<p>Object to be tested/converted</p>
</td></tr>
<tr><td><code id="dotprops_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="dotprops_+3A_k">k</code></td>
<td>
<p>Number of nearest neighbours to use for tangent vector calculation
(set to k=20 when passed NULL)</p>
</td></tr>
<tr><td><code id="dotprops_+3A_omitfailures">OmitFailures</code></td>
<td>
<p>Whether to omit neurons for which <code>FUN</code> gives an 
error. The default value (<code>NA</code>) will result in nlapply stopping with 
an error message the moment there is an eror. For other values, see 
details.</p>
</td></tr>
<tr><td><code id="dotprops_+3A_labels">Labels</code></td>
<td>
<p>Vector of labels for each point e.g. identifying axon vs
dendrite. The default value <code>NULL</code> will produce class-specific default
behaviour for different classes of input object, <code>TRUE</code> always uses
labels when an incoming object has them and <code>FALSE</code> never uses labels.</p>
</td></tr>
<tr><td><code id="dotprops_+3A_resample">resample</code></td>
<td>
<p>When finite, a new length to which all segmented edges will
be resampled. See <code><a href="#topic+resample.neuron">resample.neuron</a></code>.</p>
</td></tr>
<tr><td><code id="dotprops_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether to remove <code>NA</code> points (default FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>k</code> will default to 20 nearest neighbours when unset (i.e. when
it has default value of NA) unless <code>x</code> is a dotprops object (when the
original value of <code>k</code> is reused).
</p>


<h3>References</h3>

<p>The dotprops format is essentially identical to that developed
in:
</p>
<p>Masse N.Y., Cachero S., Ostrovsky A., and Jefferis G.S.X.E. (2012). A
mutual information approach to automate identification of neuronal clusters
in <em>Drosophila</em> brain images. Frontiers in Neuroinformatics 6 (00021).
<a href="https://doi.org/10.3389/fninf.2012.00021">doi:10.3389/fninf.2012.00021</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlapply">nlapply</a></code>
</p>

<hr>
<h2 id='fileformats'>Set or return list of registered file formats that we can read</h2><span id='topic+fileformats'></span><span id='topic+registerformat'></span><span id='topic+getformatreader'></span><span id='topic+getformatwriter'></span>

<h3>Description</h3>

<p><code>fileformats</code> returns format names, a format definition 
list or a table of information about the formats that match the given 
filter conditions.
</p>
<p><code>registerformat</code> registers a format in the io registry
</p>
<p><code>getformatreader</code> gets the function to read a file
</p>
<p><code>getformatwriter</code> gets the function to write a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fileformats(
  format = NULL,
  ext = NULL,
  read = NULL,
  write = NULL,
  class = NULL,
  rval = c("names", "info", "all")
)

registerformat(
  format = NULL,
  ext = format,
  read = NULL,
  write = NULL,
  magic = NULL,
  magiclen = NA_integer_,
  class = NULL
)

getformatreader(file, class = NULL)

getformatwriter(format = NULL, file = NULL, ext = NULL, class = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fileformats_+3A_format">format</code></td>
<td>
<p>Character vector naming the format</p>
</td></tr>
<tr><td><code id="fileformats_+3A_ext">ext</code></td>
<td>
<p>Character vector of file extensions (including periods)</p>
</td></tr>
<tr><td><code id="fileformats_+3A_read">read</code>, <code id="fileformats_+3A_write">write</code></td>
<td>
<p>Functions to read and write this format</p>
</td></tr>
<tr><td><code id="fileformats_+3A_class">class</code></td>
<td>
<p>The S3 class for the format (character vector e.g. 'neuron')</p>
</td></tr>
<tr><td><code id="fileformats_+3A_rval">rval</code></td>
<td>
<p>Character vector choosing what kind of return value 
<code>fileformats</code> will give.</p>
</td></tr>
<tr><td><code id="fileformats_+3A_magic">magic</code></td>
<td>
<p>Function to test whether a file is of this format</p>
</td></tr>
<tr><td><code id="fileformats_+3A_magiclen">magiclen</code></td>
<td>
<p>Optional integer specifying maximum number of bytes required 
from file header to determine file's type.</p>
</td></tr>
<tr><td><code id="fileformats_+3A_file">file</code></td>
<td>
<p>Path to a file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if a <code>format</code> argument is passed to <code>fileformats</code> it will
be matched with partial string matching and if a unique match exists that
will be returned.
</p>
<p><code>getformatreader</code> starts by reading a set number of bytes from 
the start off the current file and then checks using file extension and 
magic functions to see if it can identify the file. Presently formats are 
in a queue in alphabetical order, dispatching on the first match.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>fileformats</code> returns a character vector, matrix or list 
according to the value of rval.
</p>
</li>
<li> <p><code>getformatreader</code> returns a list. The reader can be accessed 
with <code>$read</code> and the format can be accessed by <code>$format</code>.
</p>
</li>
<li> <p><code>getformatwriter</code> returns a list. The writer can be accessed 
with <code>$write</code>.</p>
</li></ul>



<h3>getformatwriter output file</h3>

<p>If <code>getformatwriter</code> is passed a 
<code>file</code> argument, it will be processed based on the registered 
fileformats information and the <code>ext</code> argument to give a final output 
path in the <code>$file</code> element of the returned <code>list</code>.
</p>
<p>If <code>ext='.someext'</code> <code>getformatwriter</code> will use the specified 
extension to overwrite the default value returned by <code>fileformats</code>.
</p>
<p>If <code>ext=NULL</code>, the default, and <code>file='somefilename.someext'</code>
then <code>file</code> will be untouched and <code>ext</code> will be set to
<code>'someext'</code> (overriding the value returned by <code>fileformats</code>).
</p>
<p>If <code>file='somefile_without_extension'</code> then the suppplied or 
calculated extension will be appended to <code>file</code>.
</p>
<p>If <code>ext=NA</code> then the input <code>file</code> name will not be touched (even 
if it has no extension at all).
</p>
<p>Note that if <code>ext=NULL</code> or <code>ext=NA</code>, then only the specified 
format or, failing that, the <code>file</code> extension will be used to query 
the fileformats database for a match.
</p>
<p>See <code><a href="#topic+write.neuron">write.neuron</a></code> for code to make this discussion more 
concrete.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.neuron">write.neuron</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># information about the currently registered file formats
fileformats(rval='info')
## Not run: 
registerformat("swc",read=read.swc,write=read.swc,magic=is.swc,magiclen=10,
  class='neuron')

## End(Not run)
swc=tempfile(fileext = '.swc')
write.neuron(Cell07PNs[[1]], swc)
stopifnot(isTRUE(getformatreader(swc)$format=='swc'))
unlink(swc)
</code></pre>

<hr>
<h2 id='find.neuron'>Find neurons within a 3D selection box (usually drawn in rgl window)</h2><span id='topic+find.neuron'></span>

<h3>Description</h3>

<p>Find neurons within a 3D selection box (usually drawn in rgl window)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.neuron(
  sel3dfun = select3d(),
  indices = names(db),
  db = getOption("nat.default.neuronlist"),
  threshold = 0,
  invert = FALSE,
  rval = c("names", "data.frame", "neuronlist")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.neuron_+3A_sel3dfun">sel3dfun</code></td>
<td>
<p>A <code><a href="rgl.html#topic+select3d">select3d</a></code> style function to indicate if points
are within region</p>
</td></tr>
<tr><td><code id="find.neuron_+3A_indices">indices</code></td>
<td>
<p>Names of neurons to search (defaults to all neurons in list)</p>
</td></tr>
<tr><td><code id="find.neuron_+3A_db">db</code></td>
<td>
<p><code>neuronlist</code> to search. Can also be a character vector naming 
the neuronlist. Defaults to <code>options('nat.default.neuronlist')</code>.</p>
</td></tr>
<tr><td><code id="find.neuron_+3A_threshold">threshold</code></td>
<td>
<p>More than this many points must be present in region</p>
</td></tr>
<tr><td><code id="find.neuron_+3A_invert">invert</code></td>
<td>
<p>Whether to return neurons outside the selection box (default 
<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="find.neuron_+3A_rval">rval</code></td>
<td>
<p>What to return (character vector, default='names')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="#topic+subset.neuronlist">subset.neuronlist</a></code>, so can work on dotprops or 
neuron lists.
</p>


<h3>Value</h3>

<p>Character vector of names of selected neurons, neuronlist, or 
data.frame of attached metadata according to the value of <code>rval</code>.
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+select3d">select3d</a>, <a href="#topic+find.soma">find.soma</a>, <a href="#topic+subset.neuronlist">subset.neuronlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot3d(kcs20)
# draw a 3D selection e.g. around tip of vertical lobe when ready
find.neuron(db=kcs20)
# would return 9 neurons
# make a standalone selection function
vertical_lobe=select3d()
find.neuron(vertical_lobe, db=kcs20)
# use base::Negate function to invert the selection function 
# i.e. choose neurons that do not overlap the selection region
find.neuron(Negate(vertical_lobe), db=kcs20)

## End(Not run)
</code></pre>

<hr>
<h2 id='find.soma'>Find neurons with soma inside 3D selection box (usually drawn in rgl window)</h2><span id='topic+find.soma'></span>

<h3>Description</h3>

<p>Find neurons with soma inside 3D selection box (usually drawn in rgl window)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.soma(
  sel3dfun = select3d(),
  indices = names(db),
  db = getOption("nat.default.neuronlist"),
  invert = FALSE,
  rval = c("names", "neuronlist", "data.frame")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.soma_+3A_sel3dfun">sel3dfun</code></td>
<td>
<p>A <code><a href="rgl.html#topic+select3d">select3d</a></code> style function to indicate if points
are within region</p>
</td></tr>
<tr><td><code id="find.soma_+3A_indices">indices</code></td>
<td>
<p>Names of neurons to search (defaults to all neurons in list)</p>
</td></tr>
<tr><td><code id="find.soma_+3A_db">db</code></td>
<td>
<p><code>neuronlist</code> to search. Can also be a character vector naming 
the neuronlist. Defaults to <code>options('nat.default.neuronlist')</code>.</p>
</td></tr>
<tr><td><code id="find.soma_+3A_invert">invert</code></td>
<td>
<p>Whether to return neurons outside the selection box (default 
<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="find.soma_+3A_rval">rval</code></td>
<td>
<p>What to return (character vector, default='names')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can work on <code>neuronlist</code>s containing <code>neuron</code> objects 
<em>or</em> <code>neuronlist</code>s whose attached data.frame contains soma 
positions specified in columns called X,Y,Z  .
</p>


<h3>Value</h3>

<p>Character vector of names of selected neurons
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+select3d">select3d</a>, <a href="#topic+subset.neuronlist">subset.neuronlist</a>, <a href="#topic+find.neuron">find.neuron</a></code>
</p>

<hr>
<h2 id='flip'>Flip an array, matrix or vector about an axis</h2><span id='topic+flip'></span><span id='topic+flip.array'></span>

<h3>Description</h3>

<p>Flip an array, matrix or vector about an axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip(x, ...)

## S3 method for class 'array'
flip(x, flipdim = "X", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flip_+3A_x">x</code></td>
<td>
<p>Object to flip</p>
</td></tr>
<tr><td><code id="flip_+3A_...">...</code></td>
<td>
<p>Aditional arguments for methods</p>
</td></tr>
<tr><td><code id="flip_+3A_flipdim">flipdim</code></td>
<td>
<p>Character vector or 1-indexed integer indicating array 
dimension alogn which flip will occur. Characters X, Y, Z map onto 
dimensions 1, 2, 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that dimensions 1 and 2 for R matrices will be rows and 
columns, respectively, which does not map easily onto the intuition of a 2D
image matrix where the X axis would typically be thought of as running from
left to right on the page and the Y axis would run from top to bottom.
</p>

<hr>
<h2 id='graph.nodes'>Return root, end, or branchpoints of an igraph object</h2><span id='topic+graph.nodes'></span>

<h3>Description</h3>

<p>Return root, end, or branchpoints of an igraph object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.nodes(
  x,
  type = c("root", "end", "branch"),
  original.ids = "label",
  exclude.isolated = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.nodes_+3A_x">x</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="graph.nodes_+3A_type">type</code></td>
<td>
<p>one of root, end (which includes root) or branch</p>
</td></tr>
<tr><td><code id="graph.nodes_+3A_original.ids">original.ids</code></td>
<td>
<p>Use named attribute to return original vertex ids (when 
available). Set to FALSE when this is not desired.</p>
</td></tr>
<tr><td><code id="graph.nodes_+3A_exclude.isolated">exclude.isolated</code></td>
<td>
<p>Do not count isolated vertices as root points 
(default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the graph must be directed in order to return a root point
</p>

<hr>
<h2 id='im3d'>Construct an im3d object representing 3D image data, densities etc</h2><span id='topic+im3d'></span>

<h3>Description</h3>

<p><code>im3d</code> objects consist of a data array with attributes defining the
spatial positions at which the voxels are located. There should always be a
<code>BoundingBox</code> attribute which defines the physical extent of the volume
in the same manner as the Amira 3D visualisation and analysis software. This
corresponds to the <strong>node</strong> centers option in the
<a href="https://teem.sourceforge.net/nrrd/format.html">NRRD format</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>im3d(
  x = numeric(0),
  dims = NULL,
  voxdims = NULL,
  origin = NULL,
  BoundingBox = NULL,
  bounds = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="im3d_+3A_x">x</code></td>
<td>
<p>The object to turn into an im3d</p>
</td></tr>
<tr><td><code id="im3d_+3A_dims">dims</code></td>
<td>
<p>The dimensions of the image array either as an integer vector
<em>or</em> as an im3d object, whose attributes will provide defaults for
<code>dims, origin, BoundingBox, bounds</code> arguments. The default
(<code>dims=NULL</code>) will result in <code>dims</code> being set to <code>x</code> if
<code>x</code> is an <code>im3d</code> object or <code>dim(x)</code> otherwise.</p>
</td></tr>
<tr><td><code id="im3d_+3A_voxdims">voxdims</code></td>
<td>
<p>The voxel dimensions</p>
</td></tr>
<tr><td><code id="im3d_+3A_origin">origin</code></td>
<td>
<p>the location (or centre) of the first voxel</p>
</td></tr>
<tr><td><code id="im3d_+3A_boundingbox">BoundingBox</code></td>
<td>
<p>Physical extent of the image. See the details section of
<code><a href="#topic+boundingbox">boundingbox</a></code>'s help for the distinction between
<code>BoundingBox</code> and <code>bounds</code>.</p>
</td></tr>
<tr><td><code id="im3d_+3A_bounds">bounds</code></td>
<td>
<p>Physical extent of image</p>
</td></tr>
<tr><td><code id="im3d_+3A_...">...</code></td>
<td>
<p>Additional attributes such as units or materials</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We follow Amira's convention of setting the bounding box equal to
voxel dimension (rather than 0) for any dimension with only 1 voxel.
</p>


<h3>Value</h3>

<p>An array with additional class <code>im3d</code>
</p>


<h3>See Also</h3>

<p>Other im3d: 
<code><a href="#topic+as.im3d">as.im3d</a>()</code>,
<code><a href="#topic+boundingbox">boundingbox</a>()</code>,
<code><a href="#topic+im3d-coords">im3d-coords</a></code>,
<code><a href="#topic+im3d-io">im3d-io</a></code>,
<code><a href="#topic+imexpand.grid">imexpand.grid</a>()</code>,
<code><a href="#topic+imslice">imslice</a>()</code>,
<code><a href="#topic+is.im3d">is.im3d</a>()</code>,
<code><a href="#topic+mask">mask</a>()</code>,
<code><a href="#topic+origin">origin</a>()</code>,
<code><a href="#topic+projection">projection</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>,
<code><a href="#topic+voxdims">voxdims</a>()</code>
</p>

<hr>
<h2 id='im3d-coords'>Interconvert pixel and physical coordinates</h2><span id='topic+im3d-coords'></span><span id='topic+xyzpos'></span><span id='topic+ijkpos'></span>

<h3>Description</h3>

<p><code>xyzpos</code> converts pixel coordinates to physical coordinates
</p>
<p><code>ijkpos</code> converts physical coordinates to pixel coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyzpos(d, ijk)

ijkpos(d, xyz, roundToNearestPixel = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="im3d-coords_+3A_d">d</code></td>
<td>
<p>An <code>im3d</code> object defining a physical space</p>
</td></tr>
<tr><td><code id="im3d-coords_+3A_ijk">ijk</code></td>
<td>
<p>an Nx3 matrix of pixel coordinates (1-indexed)</p>
</td></tr>
<tr><td><code id="im3d-coords_+3A_xyz">xyz</code></td>
<td>
<p>Nx3 matrix of physical coordinates</p>
</td></tr>
<tr><td><code id="im3d-coords_+3A_roundtonearestpixel">roundToNearestPixel</code></td>
<td>
<p>Whether to round calculated pixel coordinates to
nearest integer value (i.e. nearest pixel). default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nx3 matrix of physica l or pixel coordinates
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ind2coord">ind2coord</a></code>
</p>
<p>Other im3d: 
<code><a href="#topic+as.im3d">as.im3d</a>()</code>,
<code><a href="#topic+boundingbox">boundingbox</a>()</code>,
<code><a href="#topic+im3d-io">im3d-io</a></code>,
<code><a href="#topic+im3d">im3d</a>()</code>,
<code><a href="#topic+imexpand.grid">imexpand.grid</a>()</code>,
<code><a href="#topic+imslice">imslice</a>()</code>,
<code><a href="#topic+is.im3d">is.im3d</a>()</code>,
<code><a href="#topic+mask">mask</a>()</code>,
<code><a href="#topic+origin">origin</a>()</code>,
<code><a href="#topic+projection">projection</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>,
<code><a href="#topic+voxdims">voxdims</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make an emty im3d
d=im3d(,dim=c(20,30,40),origin=c(10,20,30),voxdims=c(1,2,3))
# check round trip for origin
stopifnot(all.equal(ijkpos(d,xyzpos(d,c(1,1,1))), c(1,1,1)))
</code></pre>

<hr>
<h2 id='im3d-io'>Read/Write calibrated 3D blocks of image data</h2><span id='topic+im3d-io'></span><span id='topic+read.im3d'></span><span id='topic+write.im3d'></span>

<h3>Description</h3>

<p>Read/Write calibrated 3D blocks of image data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.im3d(
  file,
  ReadData = TRUE,
  SimplifyAttributes = FALSE,
  ReadByteAsRaw = FALSE,
  ...
)

write.im3d(x, file, format = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="im3d-io_+3A_file">file</code></td>
<td>
<p>Character vector describing a single file</p>
</td></tr>
<tr><td><code id="im3d-io_+3A_readdata">ReadData</code></td>
<td>
<p>Whether to read the data itself or return metadata only. 
Default: TRUE</p>
</td></tr>
<tr><td><code id="im3d-io_+3A_simplifyattributes">SimplifyAttributes</code></td>
<td>
<p>When <code>TRUE</code> leave only core im3d attributes.</p>
</td></tr>
<tr><td><code id="im3d-io_+3A_readbyteasraw">ReadByteAsRaw</code></td>
<td>
<p>Whether to read byte values as R <code><a href="base.html#topic+raw">raw</a></code> 
arrays. These occupy 1/4 memory but arithmetic is less convenient. 
(default: FALSE)</p>
</td></tr>
<tr><td><code id="im3d-io_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods</p>
</td></tr>
<tr><td><code id="im3d-io_+3A_x">x</code></td>
<td>
<p>The image data to write (an im3d, or capable of being interpreted as
such)</p>
</td></tr>
<tr><td><code id="im3d-io_+3A_format">format</code></td>
<td>
<p>Character vector specifying an image format (e.g. &quot;nrrd&quot;, 
&quot;amiramesh&quot;). Optional, since the format will normally be inferred from the
file extension. See <code><a href="#topic+getformatwriter">getformatwriter</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently only nrrd and amira formats are implemented. Furthermore 
implementing a registry to allow extension to arbitrary formats remains a 
TODO item.
</p>
<p>The core attributes of an im3d object are <code>BoundingBox, origin, x, y ,
  z</code> where <code>x, y, z</code> are the locations of samples in the x, y and z
image axes (which are assumed to be orthogonsl).
</p>


<h3>Value</h3>

<p>For <code>read.im3d</code> an objecting inheriting from base <code>array</code> 
and <code>im3d</code> classes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nrrd">read.nrrd</a>, <a href="#topic+read.amiramesh">read.amiramesh</a></code>
</p>
<p><code><a href="#topic+write.nrrd">write.nrrd</a></code>, <code><a href="#topic+getformatwriter">getformatwriter</a></code>
</p>
<p>Other im3d: 
<code><a href="#topic+as.im3d">as.im3d</a>()</code>,
<code><a href="#topic+boundingbox">boundingbox</a>()</code>,
<code><a href="#topic+im3d-coords">im3d-coords</a></code>,
<code><a href="#topic+im3d">im3d</a>()</code>,
<code><a href="#topic+imexpand.grid">imexpand.grid</a>()</code>,
<code><a href="#topic+imslice">imslice</a>()</code>,
<code><a href="#topic+is.im3d">is.im3d</a>()</code>,
<code><a href="#topic+mask">mask</a>()</code>,
<code><a href="#topic+origin">origin</a>()</code>,
<code><a href="#topic+projection">projection</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>,
<code><a href="#topic+voxdims">voxdims</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# read attributes of vaa3d raw file
read.im3d("L1DS1_crop_straight.raw", ReadData = F, chan=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='image.im3d'>Method to plot spatially calibrated image arrays</h2><span id='topic+image.im3d'></span>

<h3>Description</h3>

<p>Method to plot spatially calibrated image arrays
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'im3d'
image(
  x,
  xlim = NULL,
  ylim = NULL,
  zlim = NULL,
  plotdims = NULL,
  flipdims = "y",
  filled.contour = FALSE,
  asp = 1,
  axes = FALSE,
  xlab = NULL,
  ylab = NULL,
  nlevels = 20,
  levels = pretty(zlim, nlevels + 1),
  color.palette = colorRampPalette(c("navy", "cyan", "yellow", "red")),
  col = color.palette(length(levels) - 1),
  useRaster = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image.im3d_+3A_x">x</code></td>
<td>
<p>The im3d object containing the data to be plotted  (<code>NA</code>s are 
allowed).</p>
</td></tr>
<tr><td><code id="image.im3d_+3A_xlim">xlim</code>, <code id="image.im3d_+3A_ylim">ylim</code></td>
<td>
<p>ranges for the plotted <code>x</code> and <code>y</code> values, 
defaulting to the BoundingBox of x.</p>
</td></tr>
<tr><td><code id="image.im3d_+3A_zlim">zlim</code></td>
<td>
<p>the minimum and maximum <code>z</code> values for which colors should 
be plotted, defaulting to the range of the finite values of <code>z</code>. Each 
of the given colors will be used to color an equispaced interval of this 
range. The <em>midpoints</em> of the intervals cover the range, so that 
values just outside the range will be plotted.</p>
</td></tr>
<tr><td><code id="image.im3d_+3A_plotdims">plotdims</code></td>
<td>
<p>Which dimensions of 3D <code>im3d</code> object to plot (character 
vector). Defaults to <code>c('x','y')</code></p>
</td></tr>
<tr><td><code id="image.im3d_+3A_flipdims">flipdims</code></td>
<td>
<p>Which dimensions to flip (character vector). Defaults to 
flipping y.</p>
</td></tr>
<tr><td><code id="image.im3d_+3A_filled.contour">filled.contour</code></td>
<td>
<p>Whether to use a <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> plot 
instead of a regular <code><a href="Matrix.html#topic+image">image</a></code> plot.</p>
</td></tr>
<tr><td><code id="image.im3d_+3A_asp">asp</code></td>
<td>
<p>Whether to have a a square aspect ratio (logical, default: 
<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="image.im3d_+3A_axes">axes</code></td>
<td>
<p>Whether to plot axes (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="image.im3d_+3A_xlab">xlab</code>, <code id="image.im3d_+3A_ylab">ylab</code></td>
<td>
<p>each a character string giving the labels for the x and y 
axis.  Default to the &lsquo;call names&rsquo; of <code>x</code> or <code>y</code>, or to 
<code>""</code> if these were unspecified.</p>
</td></tr>
<tr><td><code id="image.im3d_+3A_nlevels">nlevels</code></td>
<td>
<p>The number of colour levels in z</p>
</td></tr>
<tr><td><code id="image.im3d_+3A_levels">levels</code></td>
<td>
<p>The levels at which to break z values</p>
</td></tr>
<tr><td><code id="image.im3d_+3A_color.palette">color.palette</code></td>
<td>
<p>The colour palette from which <code>col</code> will be 
selected.</p>
</td></tr>
<tr><td><code id="image.im3d_+3A_col">col</code></td>
<td>
<p>a list of colors such as that generated by <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>, 
<code><a href="grDevices.html#topic+heat.colors">heat.colors</a></code>, <code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code>, 
<code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code> or similar functions.</p>
</td></tr>
<tr><td><code id="image.im3d_+3A_useraster">useRaster</code></td>
<td>
<p>Whether to use <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code> to plot images as a
bitmap (much faster for large images). default <code>useRaster=NULL</code> checks
<code><a href="grDevices.html#topic+dev.capabilities">dev.capabilities</a></code> to see if raster images are supported.</p>
</td></tr>
<tr><td><code id="image.im3d_+3A_...">...</code></td>
<td>
<p>graphical parameters for <code><a href="graphics.html#topic+plot">plot</a></code> or 
<code><a href="graphics.html#topic+image">image</a></code> may also be passed as arguments to this 
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with elements:
</p>

<dl>
<dt>zlim</dt><dd><p> The z (intensity limits)</p>
</dd>
<dt>nlevels.actual</dt><dd><p> The actual number of plotted levels</p>
</dd>
<dt>nlevels.orig</dt><dd><p> The requested number of plotted levels</p>
</dd>
<dt>levels</dt><dd><p> The chosen levels</p>
</dd>
<dt>colors</dt><dd><p> A character vector of colours</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
LHMask=read.im3d(system.file('tests/testthat/testdata/nrrd/LHMask.nrrd',package='nat'))
image(imslice(LHMask,10), asp=TRUE)
# useRaster is appreciably quicker in most cases
image(imslice(LHMask,10), asp=TRUE, useRaster=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='imexpand.grid'>Convert locations of im3d voxel grid into XYZ coordinates</h2><span id='topic+imexpand.grid'></span>

<h3>Description</h3>

<p>Convert locations of im3d voxel grid into XYZ coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imexpand.grid(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imexpand.grid_+3A_d">d</code></td>
<td>
<p>An <code>im3d</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nx3 matrix of image coordinates
</p>


<h3>See Also</h3>

<p>expand.grid
</p>
<p>Other im3d: 
<code><a href="#topic+as.im3d">as.im3d</a>()</code>,
<code><a href="#topic+boundingbox">boundingbox</a>()</code>,
<code><a href="#topic+im3d-coords">im3d-coords</a></code>,
<code><a href="#topic+im3d-io">im3d-io</a></code>,
<code><a href="#topic+im3d">im3d</a>()</code>,
<code><a href="#topic+imslice">imslice</a>()</code>,
<code><a href="#topic+is.im3d">is.im3d</a>()</code>,
<code><a href="#topic+mask">mask</a>()</code>,
<code><a href="#topic+origin">origin</a>()</code>,
<code><a href="#topic+projection">projection</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>,
<code><a href="#topic+voxdims">voxdims</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d=im3d(,dim=c(2,3,2),origin=c(10,20,30),voxdims=c(1,2,3))
imexpand.grid(d)
</code></pre>

<hr>
<h2 id='imscalebar'>Make a scalebar to accompany an image.im3d plot</h2><span id='topic+imscalebar'></span>

<h3>Description</h3>

<p>Make a scalebar to accompany an image.im3d plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imscalebar(
  levels,
  col,
  nlevels = NULL,
  zlim = NULL,
  horizontal = TRUE,
  lab = "Density",
  mar = c(4, 2, 2, 2) + 0.1,
  border = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imscalebar_+3A_levels">levels</code></td>
<td>
<p>The levels at which z values were cut <strong>or</strong> a list 
returned by <code><a href="#topic+image.im3d">image.im3d</a></code></p>
</td></tr>
<tr><td><code id="imscalebar_+3A_col">col</code></td>
<td>
<p>The plotted colours for each level</p>
</td></tr>
<tr><td><code id="imscalebar_+3A_nlevels">nlevels</code></td>
<td>
<p>The number of colour levels (inferred from levels when 
<code>NULL</code>)</p>
</td></tr>
<tr><td><code id="imscalebar_+3A_zlim">zlim</code></td>
<td>
<p>The limits of the plotted z (intensity) values of the image</p>
</td></tr>
<tr><td><code id="imscalebar_+3A_horizontal">horizontal</code></td>
<td>
<p>Whether to make a horizontal or vertical scalebar (default:
TRUE)</p>
</td></tr>
<tr><td><code id="imscalebar_+3A_lab">lab</code></td>
<td>
<p>The (single) axis label for the scale bar (default: 
<code>Density</code>)</p>
</td></tr>
<tr><td><code id="imscalebar_+3A_mar">mar</code></td>
<td>
<p>The margins for ths plot</p>
</td></tr>
<tr><td><code id="imscalebar_+3A_border">border</code></td>
<td>
<p>Color for rectangle border (see <code><a href="graphics.html#topic+rect">rect</a></code>'s 
<code>border</code> argument for details).</p>
</td></tr>
<tr><td><code id="imscalebar_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>plot</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
LHMask=read.im3d(system.file('tests/testthat/testdata/nrrd/LHMask.nrrd',package='nat'))
op=par(no.readonly = TRUE)
layout(matrix(c(1, 2), ncol = 2L), widths = c(1, 0.2))
rval=image(imslice(LHMask,10), asp=TRUE)
imscalebar(rval)
par(op)

## End(Not run)
</code></pre>

<hr>
<h2 id='imslice'>Slice out a 3D subarray (or 2d matrix) from a 3D image array</h2><span id='topic+imslice'></span>

<h3>Description</h3>

<p>Slice out a 3D subarray (or 2d matrix) from a 3D image array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imslice(x, slice, slicedim = "z", drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imslice_+3A_x">x</code></td>
<td>
<p>An im3d objet</p>
</td></tr>
<tr><td><code id="imslice_+3A_slice">slice</code></td>
<td>
<p>Indices defining the slices to keep</p>
</td></tr>
<tr><td><code id="imslice_+3A_slicedim">slicedim</code></td>
<td>
<p>Character vector or integer defining axis from which slices 
will be removed.</p>
</td></tr>
<tr><td><code id="imslice_+3A_drop">drop</code></td>
<td>
<p>Whether singleton dimensions will be dropped (default: TRUE) 
conveting 3D array to 2d matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note the sample locations stored in the x,y,z attributes will be 
updated appropriately. FIXME: Should we also update bounding box?
</p>


<h3>See Also</h3>

<p>Other im3d: 
<code><a href="#topic+as.im3d">as.im3d</a>()</code>,
<code><a href="#topic+boundingbox">boundingbox</a>()</code>,
<code><a href="#topic+im3d-coords">im3d-coords</a></code>,
<code><a href="#topic+im3d-io">im3d-io</a></code>,
<code><a href="#topic+im3d">im3d</a>()</code>,
<code><a href="#topic+imexpand.grid">imexpand.grid</a>()</code>,
<code><a href="#topic+is.im3d">is.im3d</a>()</code>,
<code><a href="#topic+mask">mask</a>()</code>,
<code><a href="#topic+origin">origin</a>()</code>,
<code><a href="#topic+projection">projection</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>,
<code><a href="#topic+voxdims">voxdims</a>()</code>
</p>

<hr>
<h2 id='ind2coord'>Find XYZ coords corresponding to 1D indices into a 3D image</h2><span id='topic+ind2coord'></span><span id='topic+ind2coord.default'></span><span id='topic+ind2coord.array'></span><span id='topic+ind2coord.im3d'></span>

<h3>Description</h3>

<p>If you have an image-like object and you want to turn it into a 
matrix of 3D coords then you need <code>ind2coord</code>. For the reverse
operation we offer <code><a href="#topic+as.im3d.matrix">as.im3d.matrix</a></code> which allows you to turn a
matrix of 3D coordinates into an <code>im3d</code> image object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind2coord(inds, ...)

## Default S3 method:
ind2coord(inds, dims, voxdims, origin, ...)

## S3 method for class 'array'
ind2coord(inds, voxdims = NULL, origin = NULL, ...)

## S3 method for class 'im3d'
ind2coord(inds, voxdims = NULL, origin = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind2coord_+3A_inds">inds</code></td>
<td>
<p>indices into an image array (either 1D, for which <code>dims</code> 
must be present, or a logical array).</p>
</td></tr>
<tr><td><code id="ind2coord_+3A_...">...</code></td>
<td>
<p>extra arguments passed to methods.</p>
</td></tr>
<tr><td><code id="ind2coord_+3A_dims">dims</code></td>
<td>
<p>dimensions of 3D image array.</p>
</td></tr>
<tr><td><code id="ind2coord_+3A_voxdims">voxdims</code></td>
<td>
<p>vector of 3 voxel dimensions (width, height, depth).</p>
</td></tr>
<tr><td><code id="ind2coord_+3A_origin">origin</code></td>
<td>
<p>the origin.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+coord2ind">coord2ind</a></code>, <code><a href="#topic+sub2ind">sub2ind</a></code>, 
<code><a href="#topic+xyzpos">xyzpos</a></code>, <code><a href="#topic+as.im3d.matrix">as.im3d.matrix</a></code>
</p>

<hr>
<h2 id='intersect'>Find the intersection of two collections of objects</h2><span id='topic+intersect'></span><span id='topic+intersect.default'></span><span id='topic+intersect.neuronlist'></span>

<h3>Description</h3>

<p>Find the intersection of two collections of objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect(x, y, ...)

## Default S3 method:
intersect(x, y, ...)

## S3 method for class 'neuronlist'
intersect(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect_+3A_x">x</code></td>
<td>
<p>the first collection to consider.</p>
</td></tr>
<tr><td><code id="intersect_+3A_y">y</code></td>
<td>
<p>the second collection to consider.</p>
</td></tr>
<tr><td><code id="intersect_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that intersect.default calls base::intersect to ensure
consistent behaviour for regular vectors.
</p>


<h3>Value</h3>

<p>A collection of the same mode as <code>x</code> that contains all elements 
of <code>x</code> that are also present in <code>y</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+intersect">intersect</a></code>
</p>

<hr>
<h2 id='is.amiramesh'>Check if file is amiramesh format</h2><span id='topic+is.amiramesh'></span>

<h3>Description</h3>

<p>Check if file is amiramesh format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.amiramesh(f = NULL, bytes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.amiramesh_+3A_f">f</code></td>
<td>
<p>Path to one or more files to be tested <strong>or</strong> an array of raw 
bytes, for one file only.</p>
</td></tr>
<tr><td><code id="is.amiramesh_+3A_bytes">bytes</code></td>
<td>
<p>optional raw vector of at least 11 bytes from the start of a 
single file (used in preference to reading file <code>f</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tries to be as fast as possible by reading only first 11 bytes and 
checking if they equal to &quot;# AmiraMesh&quot; or (deprecated) &quot;# HyperMesh&quot;.
</p>


<h3>Value</h3>

<p>logical
</p>


<h3>See Also</h3>

<p>Other amira: 
<code><a href="#topic+amiratype">amiratype</a>()</code>,
<code><a href="#topic+read.amiramesh">read.amiramesh</a>()</code>,
<code><a href="#topic+read.hxsurf">read.hxsurf</a>()</code>,
<code><a href="#topic+write.hxsurf">write.hxsurf</a>()</code>
</p>

<hr>
<h2 id='is.fijitraces'>Check whether a file is in Fiji's simple neurite tracer format</h2><span id='topic+is.fijitraces'></span>

<h3>Description</h3>

<p>This will check a file on disk to see if it is in Fiji's simple neurite
tracer XML format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fijitraces(f, bytes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fijitraces_+3A_f">f</code></td>
<td>
<p>path to a file on disk</p>
</td></tr>
<tr><td><code id="is.fijitraces_+3A_bytes">bytes</code></td>
<td>
<p>optional raw vector of bytes used for prechecks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some prechecks (optionally taking place on a supplied raw vector of bytes)
should weed out nearly all true negatives and identify many true positives
without having to read/parse the file header.
</p>

<hr>
<h2 id='is.im3d'>Test if an object is of class im3d</h2><span id='topic+is.im3d'></span>

<h3>Description</h3>

<p>Test if an object is of class im3d
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.im3d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.im3d_+3A_x">x</code></td>
<td>
<p>Object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>See Also</h3>

<p>Other im3d: 
<code><a href="#topic+as.im3d">as.im3d</a>()</code>,
<code><a href="#topic+boundingbox">boundingbox</a>()</code>,
<code><a href="#topic+im3d-coords">im3d-coords</a></code>,
<code><a href="#topic+im3d-io">im3d-io</a></code>,
<code><a href="#topic+im3d">im3d</a>()</code>,
<code><a href="#topic+imexpand.grid">imexpand.grid</a>()</code>,
<code><a href="#topic+imslice">imslice</a>()</code>,
<code><a href="#topic+mask">mask</a>()</code>,
<code><a href="#topic+origin">origin</a>()</code>,
<code><a href="#topic+projection">projection</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>,
<code><a href="#topic+voxdims">voxdims</a>()</code>
</p>

<hr>
<h2 id='is.neuroml'>Check whether a file is in NeuroML format</h2><span id='topic+is.neuroml'></span>

<h3>Description</h3>

<p>This will check a file on disk to see if it is in NeuroML format. Some 
prechecks (optionally taking place on a supplied raw vector of bytes) should 
weed out nearly all true negatives and identify many true positives without
having to read/parse the file header.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.neuroml(f, bytes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.neuroml_+3A_f">f</code></td>
<td>
<p>path to a file on disk</p>
</td></tr>
<tr><td><code id="is.neuroml_+3A_bytes">bytes</code></td>
<td>
<p>optional raw vector of bytes used for prechecks</p>
</td></tr>
</table>

<hr>
<h2 id='is.neuronlist'>Test objects of neuronlist class to store multiple neurons</h2><span id='topic+is.neuronlist'></span>

<h3>Description</h3>

<p>Tests if object is a neuronlist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.neuronlist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.neuronlist_+3A_x">x</code></td>
<td>
<p>the object to test</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is.neuronlist</code> uses a relaxed definition to cope with older 
lists of neurons that do not have a class attribute of neuronlist.
</p>


<h3>Value</h3>

<p>A logical indicating whether the object is a neuronlist.
</p>


<h3>See Also</h3>

<p>Other neuronlist: 
<code><a href="#topic++2A.neuronlist">*.neuronlist</a>()</code>,
<code><a href="#topic+neuronlist-dataframe-methods">neuronlist-dataframe-methods</a></code>,
<code><a href="#topic+neuronlistfh">neuronlistfh</a>()</code>,
<code><a href="#topic+neuronlist">neuronlist</a>()</code>,
<code><a href="#topic+nlapply">nlapply</a>()</code>,
<code><a href="#topic+read.neurons">read.neurons</a>()</code>,
<code><a href="#topic+write.neurons">write.neurons</a>()</code>
</p>

<hr>
<h2 id='is.nrrd'>Check if a file is a NRRD file</h2><span id='topic+is.nrrd'></span>

<h3>Description</h3>

<p>Check if a file is a NRRD file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.nrrd(f = NULL, bytes = NULL, ReturnVersion = FALSE, TrustSuffix = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.nrrd_+3A_f">f</code></td>
<td>
<p>A character vector specifying the path or a raw vector with at least
8 bytes.</p>
</td></tr>
<tr><td><code id="is.nrrd_+3A_bytes">bytes</code></td>
<td>
<p>optional raw vector of at least 8 bytes from the start of a
single file (used in preference to reading file <code>f</code>).</p>
</td></tr>
<tr><td><code id="is.nrrd_+3A_returnversion">ReturnVersion</code></td>
<td>
<p>Whether to return the version of the nrrd format in 
which the file is encoded (1-5).</p>
</td></tr>
<tr><td><code id="is.nrrd_+3A_trustsuffix">TrustSuffix</code></td>
<td>
<p>Whether to trust that a file ending in .nrrd or .nhdr is a
NRRD</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that multiple files can be checked when a character vector of 
length &gt; 1 is provided, but only one file can be checked when a raw byte 
array is provided.
</p>

<hr>
<h2 id='is.swc'>Test if a file is an SWC format neuron</h2><span id='topic+is.swc'></span>

<h3>Description</h3>

<p>Test if a file is an SWC format neuron
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.swc(f, TrustSuffix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.swc_+3A_f">f</code></td>
<td>
<p>Path to one or more files</p>
</td></tr>
<tr><td><code id="is.swc_+3A_trustsuffix">TrustSuffix</code></td>
<td>
<p>Whether to trust that a file ending in .nrrd or .nhdr is a
NRRD</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this test is somewhat expensive compared with the other 
file tests since SWC files do not have a consistent magic value. It
therefore often has to read and parse the first few lines of the file in 
order to determine whether they are consistent with the SWC format.
</p>


<h3>Value</h3>

<p>logical value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.neuron">read.neuron</a></code>
</p>

<hr>
<h2 id='is.vaa3draw'>Check if a file is in the raw image format used by Hanchuan Peng's Vaa3D</h2><span id='topic+is.vaa3draw'></span>

<h3>Description</h3>

<p>See http://www.vaa3d.org/ 
https://github.com/Vaa3D/v3d_external/blob/master/imagej_io/v3draw_io_imagej/raw_reader.java
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.vaa3draw(f, bytes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.vaa3draw_+3A_f">f</code></td>
<td>
<p>A character vector specifying the path or a raw vector (see
<code>bytes</code>).</p>
</td></tr>
<tr><td><code id="is.vaa3draw_+3A_bytes">bytes</code></td>
<td>
<p>optional raw vector of at least 24 bytes from the start of a 
single file (used in preference to reading file <code>f</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that multiple files can be checked when a character vector of 
length &gt; 1 is provided, but only one file can be checked when a raw byte 
array is provided.
</p>

<hr>
<h2 id='kcs20'>List of 20 Kenyon Cells from Chiang et al 2011 converted to dotprops objects</h2><span id='topic+kcs20'></span>

<h3>Description</h3>

<p>This R list (which has additional class <code>neuronlist</code>) contains 20
skeletonized <em>Drosophila</em> Kenyon cells as <code>dotprops</code> objects.
Original data is due to Chiang et al. 2011, who have generously shared their
raw data <a href="https://doi.org/10.1016/j.cub.2010.11.056">doi:10.1016/j.cub.2010.11.056</a>. Image registration and further
processing was carried out by Greg Jefferis (see
<a href="https://doi.org/10.1016/j.neuron.2016.06.012">doi:10.1016/j.neuron.2016.06.012</a>).
</p>


<h3>References</h3>

<p>[1] Chiang A.S., Lin C.Y., Chuang C.C., Chang H.M., Hsieh C.H.,
Yeh C.W., Shih C.T., Wu J.J., Wang G.T., Chen Y.C., Wu C.C., Chen G.Y.,
Ching Y.T., Lee P.C., Lin C.Y., Lin H.H., Wu C.C., Hsu H.W., Huang Y.A.,
Chen J.Y., et al. (2011). Three-dimensional reconstruction of brain-wide
wiring networks in Drosophila at single-cell resolution. Curr Biol 21 (1),
1&ndash;11.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+head.neuronlist">head.neuronlist</a></code>, <code><a href="#topic+with.neuronlist">with.neuronlist</a></code>,
<code><a href="#topic+plot3d.neuronlist">plot3d.neuronlist</a></code>, <code><a href="#topic+plot3d.dotprops">plot3d.dotprops</a></code>,
<code><a href="#topic+dotprops">dotprops</a></code>
</p>
<p>Other nat-data: 
<code><a href="#topic+Cell07PNs">Cell07PNs</a></code>,
<code><a href="#topic+MBL.surf">MBL.surf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(kcs20)
table(with(kcs20, type))
nopen3d()
# see plot3d.neuronlist documentation for more details

plot3d(kcs20, col=type)

</code></pre>

<hr>
<h2 id='mask'>Mask an object, typically to produce a copy with some values zeroed out</h2><span id='topic+mask'></span><span id='topic+mask.im3d'></span>

<h3>Description</h3>

<p>Mask an object, typically to produce a copy with some values zeroed out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask(x, ...)

## S3 method for class 'im3d'
mask(x, mask, levels = NULL, rval = c("im3d", "values"), invert = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_+3A_x">x</code></td>
<td>
<p>Object to be masked</p>
</td></tr>
<tr><td><code id="mask_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="mask_+3A_mask">mask</code></td>
<td>
<p>An im3d object, an array or a vector with dimensions compatible 
with x.</p>
</td></tr>
<tr><td><code id="mask_+3A_levels">levels</code></td>
<td>
<p>Optional numeric vector of pixel values or character vector 
defining named <code><a href="#topic+materials">materials</a></code>.</p>
</td></tr>
<tr><td><code id="mask_+3A_rval">rval</code></td>
<td>
<p>Whether to return an im3d object based on <code>x</code> or just the 
values from <code>x</code> matching the mask.</p>
</td></tr>
<tr><td><code id="mask_+3A_invert">invert</code></td>
<td>
<p>Whether to invert the voxel selection (default <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>mask.im3d</code> passes ... arguments on to im3d
</p>


<h3>Value</h3>

<p>an oject with attributes matching <code>x</code> and elements with value 
<code>as.vector(TRUE, mode=mode)</code> i.e. <code>TRUE, 1, 0x01</code> and 
<code>as.vector(FALSE, mode=mode)</code> i.e. <code>FALSE, 0, 0x00</code> as 
appropriate.
</p>
<p>A copy of x with
</p>


<h3>See Also</h3>

<p>Other im3d: 
<code><a href="#topic+as.im3d">as.im3d</a>()</code>,
<code><a href="#topic+boundingbox">boundingbox</a>()</code>,
<code><a href="#topic+im3d-coords">im3d-coords</a></code>,
<code><a href="#topic+im3d-io">im3d-io</a></code>,
<code><a href="#topic+im3d">im3d</a>()</code>,
<code><a href="#topic+imexpand.grid">imexpand.grid</a>()</code>,
<code><a href="#topic+imslice">imslice</a>()</code>,
<code><a href="#topic+is.im3d">is.im3d</a>()</code>,
<code><a href="#topic+origin">origin</a>()</code>,
<code><a href="#topic+projection">projection</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>,
<code><a href="#topic+voxdims">voxdims</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=im3d(array(rnorm(1000),dim=c(10,10,10)), BoundingBox=c(20,200,100,200,200,300))
m=array(1:5,dim=c(10,10,10))
image(x[,,1])
image(mask(x, mask=m, levels=1)[,,1])
image(mask(x, mask=m, levels=1:2)[,,1])
</code></pre>

<hr>
<h2 id='materials'>Extract or set the materials for an object</h2><span id='topic+materials'></span><span id='topic+materials.default'></span><span id='topic+materials.character'></span><span id='topic+materials.hxsurf'></span>

<h3>Description</h3>

<p><code>materials.character</code> will read the materials from an im3d 
compatible image file on disk.
</p>
<p><code>materials.hxsurf</code> will extract the materials from an
hxsurf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>materials(x, ...)

## Default S3 method:
materials(x, ...)

## S3 method for class 'character'
materials(x, ...)

## S3 method for class 'hxsurf'
materials(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="materials_+3A_x">x</code></td>
<td>
<p>An object in memory or, for <code>materials.character</code>, an image on 
disk.</p>
</td></tr>
<tr><td><code id="materials_+3A_...">...</code></td>
<td>
<p>additional parameters passed to methods (presently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the id column will be the 1-indexed order that the
material appears in the <code>surf$Region</code> list for <code>hxsurf</code> objects
and the 0-indexed mask values for an image.
</p>
<p>Presently only amiramesh images are supported since they have a
standardised way of encoding labels, whereas nrrds would have to use
key-value pairs according to some ad hoc convention.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns <code>name, id, col</code>
</p>


<h3>See Also</h3>

<p>Other hxsurf: 
<code><a href="#topic+as.hxsurf">as.hxsurf</a>()</code>,
<code><a href="#topic+as.mesh3d">as.mesh3d</a>()</code>,
<code><a href="#topic+plot3d.hxsurf">plot3d.hxsurf</a>()</code>,
<code><a href="#topic+read.hxsurf">read.hxsurf</a>()</code>,
<code><a href="#topic+subset.hxsurf">subset.hxsurf</a>()</code>,
<code><a href="#topic+write.hxsurf">write.hxsurf</a>()</code>
</p>

<hr>
<h2 id='MBL.surf'>Surface object (hxsurf) for the left mushroom body in FCWB template space</h2><span id='topic+MBL.surf'></span>

<h3>Description</h3>

<p>This surface object is in the same space as the 20 Kenyon cells in
<code><a href="#topic+kcs20">kcs20</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hxsurf">hxsurf</a></code>
</p>
<p>Other nat-data: 
<code><a href="#topic+Cell07PNs">Cell07PNs</a></code>,
<code><a href="#topic+kcs20">kcs20</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot3d(kcs20)
plot3d(MBL.surf, alpha=0.3)


## Not run: 
## originally generated as follows
library(nat.flybrains)
MBL.surf=subset(FCWBNP.surf, "MB.*_L", drop = T)

## End(Not run)
</code></pre>

<hr>
<h2 id='mirror'>Mirror 3D object about a given axis, optionally using a warping registration</h2><span id='topic+mirror'></span><span id='topic+mirror.character'></span><span id='topic+mirror.default'></span><span id='topic+mirror.neuronlist'></span>

<h3>Description</h3>

<p>mirroring with a warping registration can be used to account 
e.g. for the asymmetry between brain hemispheres.
</p>
<p><code>mirror.character</code> handles images on disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirror(x, ...)

## S3 method for class 'character'
mirror(x, output, mirrorAxisSize = NULL, target = x, ...)

## Default S3 method:
mirror(
  x,
  mirrorAxisSize,
  mirrorAxis = c("X", "Y", "Z"),
  warpfile = NULL,
  transform = c("warp", "affine", "flip"),
  ...
)

## S3 method for class 'neuronlist'
mirror(x, subset = NULL, OmitFailures = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mirror_+3A_x">x</code></td>
<td>
<p>Object with 3D points (with named cols X,Y,Z) or path to image on
disk.</p>
</td></tr>
<tr><td><code id="mirror_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods or eventually to 
<code><a href="#topic+xform">xform</a></code></p>
</td></tr>
<tr><td><code id="mirror_+3A_output">output</code></td>
<td>
<p>Path to the output image</p>
</td></tr>
<tr><td><code id="mirror_+3A_mirroraxissize">mirrorAxisSize</code></td>
<td>
<p>A single number specifying the size of the axis to 
mirror or a 2 vector (<b>recommended</b>) or 2x3 matrix specifying the 
<code><a href="#topic+boundingbox">boundingbox</a></code> (see details).</p>
</td></tr>
<tr><td><code id="mirror_+3A_target">target</code></td>
<td>
<p>Path to the image defining the target grid (defaults to the
input image - hard to see when this would not be wanted).</p>
</td></tr>
<tr><td><code id="mirror_+3A_mirroraxis">mirrorAxis</code></td>
<td>
<p>Axis to mirror (default <code>"X"</code>). Can also be an integer
in range <code>1:3</code>.</p>
</td></tr>
<tr><td><code id="mirror_+3A_warpfile">warpfile</code></td>
<td>
<p>Optional registration or <code><a href="#topic+reglist">reglist</a></code> to be applied
<em>after</em> the simple mirroring.. It is called warpfile for historical
reasons, since it is normally the path to a CMTK registration that
specifies a non-rigid transformation to correct asymmetries in an image.</p>
</td></tr>
<tr><td><code id="mirror_+3A_transform">transform</code></td>
<td>
<p>whether to use warp (default) or affine component of 
registration, or simply flip about midplane of axis.</p>
</td></tr>
<tr><td><code id="mirror_+3A_subset">subset</code></td>
<td>
<p>For <code>mirror.neuronlist</code> indices
(character/logical/integer) that specify a subset of the members of
<code>x</code> to be transformed.</p>
</td></tr>
<tr><td><code id="mirror_+3A_omitfailures">OmitFailures</code></td>
<td>
<p>Whether to omit neurons for which <code>FUN</code> gives an 
error. The default value (<code>NA</code>) will result in nlapply stopping with 
an error message the moment there is an eror. For other values, see 
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mirrorAxisSize</code> argument can be specified in 3 ways for 
the x axis with extreme values, x0+x1: </p>

<ul>
<li><p> a single number equal to x0+x1
</p>
</li>
<li><p> a 2-vector c(x0, x1) (<b>recommended</b>)
</p>
</li>
<li><p> the <code><a href="#topic+boundingbox">boundingbox</a></code> for the 3D data to be mirrored: the 
relevant axis specified by <code>mirrorAxis</code> will be extracted.
</p>
</li></ul>

<p>This function is agnostic re node vs cell data, but for node data 
BoundingBox should be supplied while for cell, it should be bounds. See 
<code><a href="#topic+boundingbox">boundingbox</a></code> for details of BoundingBox vs bounds.
</p>
<p>See <code><a href="#topic+nlapply">nlapply</a></code> for details of the <code>subset</code> and 
<code>OmitFailures</code> arguments.
</p>


<h3>Value</h3>

<p>Object with transformed points
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xform">xform</a>, <a href="#topic+boundingbox">boundingbox</a></code>
</p>
<p><code><a href="#topic+nlapply">nlapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nopen3d()
x=Cell07PNs[[1]]
mx=mirror(x,168)

plot3d(x,col='red')
plot3d(mx,col='green')


# also works with dotprops objects
clear3d()
y=kcs20[[1]]
my=mirror(y,mirrorAxisSize=564.2532,transform='flip')

plot3d(y, col='red')
plot3d(my, col='green')


## Not run: 
## Example with an image
# note that we must specify an output image (obviously) but that as a
# convenience mirror calculates the mirrorAxisSize for us
mirror('myimage.nrrd', output='myimage-mirrored.nrrd', 
  warpfile='myimage_mirror.list')

# Simple flip along a different axis
mirror('myimage.nrrd', output='myimage-flipped.nrrd', mirrorAxis="Y", 
  transform='flip')

## End(Not run)
</code></pre>

<hr>
<h2 id='ndigest'>Calculated normalised digest value for an object</h2><span id='topic+ndigest'></span><span id='topic+ndigest.neuronlistfh'></span><span id='topic+ndigest.dotprops'></span><span id='topic+ndigest.neuron'></span>

<h3>Description</h3>

<p>The <em>normalised</em> digest should exclude any fields or 
attributes irrelevant to the core contents of the object (e.g. timestamps, 
absolute location of the input files on disk etc). In theory then, this
value should be constant for the same data regardless of the particular
machine on which the digest is being computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndigest(x, ...)

## S3 method for class 'neuronlistfh'
ndigest(x, ...)

## S3 method for class 'dotprops'
ndigest(x, absoluteVectors = TRUE, ...)

## S3 method for class 'neuron'
ndigest(
  x,
  fieldsToExclude = c("InputFileName", "CreatedAt", "NodeName", "InputFileStat",
    "InputFileMD5"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndigest_+3A_x">x</code></td>
<td>
<p>Object for which a normalised digest will be computed.</p>
</td></tr>
<tr><td><code id="ndigest_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods and then on to 
<code><a href="digest.html#topic+digest">digest</a></code></p>
</td></tr>
<tr><td><code id="ndigest_+3A_absolutevectors">absoluteVectors</code></td>
<td>
<p>Whether to check only the absolute value of
eigenvectors for equality (default TRUE, see details)</p>
</td></tr>
<tr><td><code id="ndigest_+3A_fieldstoexclude">fieldsToExclude</code></td>
<td>
<p>Character vector naming the neuron fields to exclude</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ndigest.neuronlistfh</code> only considers the <code>keyfilemap</code> and
<code>df</code> (metadata data.frame) when computing the hash value. See
<code><a href="#topic+neuronlistfh">neuronlistfh</a></code> for the significance of these two fields.
</p>
<p><code>ndigest.dotprops</code> ignores any <code>mtime</code> or <code>file</code>
attributes. It also converts tangent vectors to absolute values (when 
<code>absoluteVectors=TRUE</code>) because the direction vectors are computed 
using an eigenvector decomposition where the sign of the eigenvector is 
essentially random and subject to small numerical instabilities. Therefore 
it does not usually make sense to rely on the value of vect exactly.
</p>
<p><code>ndigest.neuron</code> ignores the following fields:
</p>

<ul>
<li><p> InputFileName
</p>
</li>
<li><p> CreatedAt
</p>
</li>
<li><p> NodeName
</p>
</li>
<li><p> InputFileStat
</p>
</li>
<li><p> InputFileMD5
</p>
</li></ul>



<h3>Value</h3>

<p>A character string containing the digest of the supplied object 
computed by <code><a href="digest.html#topic+digest">digest</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="digest.html#topic+digest">digest</a></code>
</p>
<p><code><a href="#topic+all.equal.dotprops">all.equal.dotprops</a></code>
</p>
<p><code><a href="#topic+all.equal.neuron">all.equal.neuron</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stopifnot(all.equal(ndigest(kcs20[[1]]), "4c045b0343938259cd9986494fc1c2b0"))
</code></pre>

<hr>
<h2 id='neuron'>neuron: class to represent traced neurons</h2><span id='topic+neuron'></span><span id='topic+is.neuron'></span><span id='topic+as.neuron'></span><span id='topic+as.neuron.data.frame'></span><span id='topic+as.neuron.ngraph'></span><span id='topic+as.neuron.igraph'></span><span id='topic+as.neuron.default'></span>

<h3>Description</h3>

<p><code>neuron</code> makes a neuron object from appropriate variables.
</p>
<p><code>is.neuron</code> will check if an object looks like a neuron.
</p>
<p><code>as.neuron</code> will convert a suitable object to a neuron
</p>
<p><code>as.neuron.data.frame</code> expects a block of SWC format data
</p>
<p><code>as.neuron.ngraph</code> converts a graph (typically an 
<code>ngraph</code> object) to a neuron
</p>
<p><code>as.neuron.igraph</code> will convert an <code>ngraph</code> compatible
<code><a href="igraph.html#topic+igraph">igraph</a></code> object into a <code>neuron</code>.
</p>
<p><code>as.neuron.default</code> will add class &quot;neuron&quot; to a neuron-like
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neuron(
  d,
  NumPoints = nrow(d),
  StartPoint,
  BranchPoints = integer(),
  EndPoints,
  SegList,
  SubTrees = NULL,
  InputFileName = NULL,
  NeuronName = NULL,
  ...,
  MD5 = TRUE
)

is.neuron(x, Strict = FALSE)

as.neuron(x, ...)

## S3 method for class 'data.frame'
as.neuron(x, ...)

## S3 method for class 'ngraph'
as.neuron(x, vertexData = NULL, origin = NULL, Verbose = FALSE, ...)

## S3 method for class 'igraph'
as.neuron(x, ...)

## Default S3 method:
as.neuron(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neuron_+3A_d">d</code></td>
<td>
<p>matrix of vertices and associated data in SWC format</p>
</td></tr>
<tr><td><code id="neuron_+3A_numpoints">NumPoints</code></td>
<td>
<p>Number of points in master subtree</p>
</td></tr>
<tr><td><code id="neuron_+3A_startpoint">StartPoint</code>, <code id="neuron_+3A_branchpoints">BranchPoints</code>, <code id="neuron_+3A_endpoints">EndPoints</code></td>
<td>
<p>Nodes of the neuron</p>
</td></tr>
<tr><td><code id="neuron_+3A_seglist">SegList</code></td>
<td>
<p>List where each element contains the vertex indices for a 
single segments of the neuron, starting at root.</p>
</td></tr>
<tr><td><code id="neuron_+3A_subtrees">SubTrees</code></td>
<td>
<p>List of SegLists where a neuron has multiple unconnected 
trees (e.g. because the soma is not part of the graph, or because the 
neuronal arbour has been cut.)</p>
</td></tr>
<tr><td><code id="neuron_+3A_inputfilename">InputFileName</code></td>
<td>
<p>Character vector with path to input file</p>
</td></tr>
<tr><td><code id="neuron_+3A_neuronname">NeuronName</code></td>
<td>
<p>Character vector containing name of neuron or a function 
with one argument (the full path) which returns the name. The default
(<code>NULL</code>) sets NeuronName to the file name without the file extension.</p>
</td></tr>
<tr><td><code id="neuron_+3A_...">...</code></td>
<td>
<p>Additional fields to be included in neuron. Note that if these 
include CreatedAt, NodeName, InputFileStat or InputFileMD5, they will 
override fields of that name that are calculated automatically.</p>
</td></tr>
<tr><td><code id="neuron_+3A_md5">MD5</code></td>
<td>
<p>Logical indicating whether to calculate MD5 hash of input</p>
</td></tr>
<tr><td><code id="neuron_+3A_x">x</code></td>
<td>
<p>A neuron or other object to test/convert</p>
</td></tr>
<tr><td><code id="neuron_+3A_strict">Strict</code></td>
<td>
<p>Whether to check class of neuron or use a more relaxed
definition based on object being a list with a SegList component.</p>
</td></tr>
<tr><td><code id="neuron_+3A_vertexdata">vertexData</code></td>
<td>
<p>A dataframe with SWC fields especially X,Y,Z,W,PointNo,
Parent.</p>
</td></tr>
<tr><td><code id="neuron_+3A_origin">origin</code></td>
<td>
<p>Root vertex, matched against labels (aka PointNo) when 
available (see details)</p>
</td></tr>
<tr><td><code id="neuron_+3A_verbose">Verbose</code></td>
<td>
<p>Whether to be verbose (default: FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>neuron objects consist of a list containing multiple fields describing the 3D
location and connectivity of points in a traced neuron. The critical fields 
of a neuron, n, are n$d which contains a dataframe in SWC format and 
n$SegList which contains a representation of the neuron's topology used for 
most internal calculations. For historical reasons, n$SegList is limited to a
<em>single fully-connected</em> tree. If the tree contains multiple unconnected
subtrees, then these are stored in n$SubTrees and nTrees will be &gt;1; the 
&quot;master&quot; subtree (typically the one with the most points) will then be stored
in n$SegList and n$NumPoints will refer to the number of points in that 
subtree, not the whole neuron.
</p>
<p>StartPoint, BranchPoints, EndPoints are indices matching the rows of 
the vertices in <code>d</code> <strong>not</strong> arbitrary point numbers typically 
encoded in <code>d$PointNo</code>.
</p>
<p>Columns will be ordered c('PointNo','Label','X','Y','Z','W','Parent')
</p>
<p>Uses a depth first search on the tree to reorder using the given 
origin.
</p>
<p>When the graph contains multiple subgraphs, only one will be chosen 
as the master tree and used to construct the SegList of the resultant 
neuron. However all subgraphs will be listed in the SubTrees element of the
neuron and nTrees will be set appropriately.
</p>
<p>When the graph vertices have a label attribute derived from PointNo,
the origin is assumed to be specified with respect to the vertex labels 
rather than the raw vertex ids.
</p>


<h3>Value</h3>

<p>A list with elements: 
(NumPoints,StartPoint,BranchPoints,EndPoints,nTrees,NumSegs,SegList, 
[SubTrees]) NB SubTrees will only be present when nTrees&gt;1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neuronlist">neuronlist</a></code>
</p>
<p><code><a href="igraph.html#topic+dfs">dfs</a>, <a href="#topic+as.seglist">as.seglist</a></code>
</p>
<p>Other neuron: 
<code><a href="#topic+ngraph">ngraph</a>()</code>,
<code><a href="#topic+plot.neuron">plot.neuron</a>()</code>,
<code><a href="#topic+potential_synapses">potential_synapses</a>()</code>,
<code><a href="#topic+prune">prune</a>()</code>,
<code><a href="#topic+resample">resample</a>()</code>,
<code><a href="#topic+rootpoints">rootpoints</a>()</code>,
<code><a href="#topic+spine">spine</a>()</code>,
<code><a href="#topic+subset.neuron">subset.neuron</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See help for functions listed in See Also for more detailed examples
## Basic properties
# a sample neuron 
n = Cell07PNs[[1]]
# inspect its internal structure
str(n)
# summary of 3D points
summary(xyzmatrix(n))
# identify 3d location of endpoints
xyzmatrix(n)[endpoints(n),]

## Other methods
# plot
plot(n)
# all methods for neuron objects
methods(class = 'neuron')

## Neurons as graphs 
# convert to graph and find longest paths by number of nodes
ng=as.ngraph(n)
hist(igraph::distances(ng))
# ... or in distances  microns
ngw=as.ngraph(n, weights=TRUE)
hist(igraph::distances(ngw))

# converting back and forth between neurons and graphs
g=as.ngraph(Cell07PNs[[1]])
gstem=igraph::induced_subgraph(g, 1:10)
# this is fine
plot(gstem)
plot(as.neuron(gstem))

# but if you had an undirected graph 
ug=igraph::as.undirected(gstem)
# you get a warning because there is no explicit origin for the graph
as.neuron(ug)

# If you need finer control of the conversion process 
gstem2=as.ngraph(ug, root = 10)
plot(gstem2)
plot(as.neuron(gstem2))
</code></pre>

<hr>
<h2 id='neuronlist'>Create a neuronlist from zero or more neurons</h2><span id='topic+neuronlist'></span>

<h3>Description</h3>

<p><code>neuronlist</code> objects consist of a list of neuron objects 
(usually of class <code><a href="#topic+neuron">neuron</a></code> or <code><a href="#topic+dotprops">dotprops</a></code>) along 
with an optional attached dataframe containing information about the 
neurons. <code>neuronlist</code> objects can be indexed using their name or the 
number of the neuron like a regular list. Both the <code>list</code> itself and 
the attached <code>data.frame</code> must have the same unique (row)names. If the
<code>[</code> operator is used to index the list, the attached dataframe will 
also be subsetted.
</p>
<p>It is perfectly acceptable not to pass any parameters, generating an empty 
neuronlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neuronlist(..., DATAFRAME = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neuronlist_+3A_...">...</code></td>
<td>
<p>objects to be turned into a list</p>
</td></tr>
<tr><td><code id="neuronlist_+3A_dataframe">DATAFRAME</code></td>
<td>
<p>an optional <code>data.frame</code> to attach to the neuronlist 
containing information about each neuron.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new neuronlist object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.data.frame.neuronlist">as.data.frame.neuronlist</a></code>, 
<code><a href="#topic+neuronlist-dataframe-methods">neuronlist-dataframe-methods</a></code>, <code><a href="#topic+neuron">neuron</a></code>, 
<code><a href="#topic+dotprops">dotprops</a></code>
</p>
<p>Other neuronlist: 
<code><a href="#topic++2A.neuronlist">*.neuronlist</a>()</code>,
<code><a href="#topic+is.neuronlist">is.neuronlist</a>()</code>,
<code><a href="#topic+neuronlist-dataframe-methods">neuronlist-dataframe-methods</a></code>,
<code><a href="#topic+neuronlistfh">neuronlistfh</a>()</code>,
<code><a href="#topic+nlapply">nlapply</a>()</code>,
<code><a href="#topic+read.neurons">read.neurons</a>()</code>,
<code><a href="#topic+write.neurons">write.neurons</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate an empty neuronlist
nl=neuronlist()
# slice an existing neuronlist with regular indexing
kcs5=kcs20[1:5]

# extract a single neuron from a neuronlist
n1=Cell07PNs[[1]]

# list all methods for neuronlist objects
methods(class='neuronlist')
</code></pre>

<hr>
<h2 id='neuronlist-dataframe-methods'>Methods for working with the dataframe attached to a neuronlist</h2><span id='topic+neuronlist-dataframe-methods'></span><span id='topic++5B.neuronlist'></span><span id='topic++5B+3C-.neuronlist'></span><span id='topic+droplevels.neuronlist'></span><span id='topic+droplevels'></span><span id='topic+with.neuronlist'></span><span id='topic+with'></span><span id='topic+head.neuronlist'></span><span id='topic+head'></span><span id='topic+tail.neuronlist'></span><span id='topic+tail'></span>

<h3>Description</h3>

<p><code>[.neuronlist</code> and <code>[&lt;-.neuronlist</code> behave like the 
corresponding base methods (<code>[.data.frame</code>, <code>[&lt;-.data.frame</code>) 
allowing extraction or replacement of parts of the data.frame attached to
the neuronlist.
</p>
<p><code>droplevels</code> Remove redundant factor levels in dataframe 
attached to neuronlist
</p>
<p><code>with</code> Evaluate expression in the context of dataframe
attached to a neuronlist
</p>
<p><code>head</code> Return the first part of data.frame attached to
neuronlist
</p>
<p><code>tail</code> Return the last part of data.frame attached to 
neuronlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuronlist'
x[i, j, drop]

## S3 replacement method for class 'neuronlist'
x[i, j] &lt;- value

## S3 method for class 'neuronlist'
droplevels(x, except = NULL, ...)

## S3 method for class 'neuronlist'
with(data, expr, ...)

## S3 method for class 'neuronlist'
head(x, ...)

## S3 method for class 'neuronlist'
tail(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neuronlist-dataframe-methods_+3A_x">x</code></td>
<td>
<p>A neuronlist object</p>
</td></tr>
<tr><td><code id="neuronlist-dataframe-methods_+3A_i">i</code>, <code id="neuronlist-dataframe-methods_+3A_j">j</code></td>
<td>
<p>elements to extract or replace. Numeric or character or, for [ 
only, empty. Numeric values are coerced to integer as if by 
<code>as.integer</code>. See <code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code> for details.</p>
</td></tr>
<tr><td><code id="neuronlist-dataframe-methods_+3A_drop">drop</code></td>
<td>
<p>logical.  If <code>TRUE</code> the result is coerced to the
lowest possible dimension.  The default is to drop if only one
column is left, but <b>not</b> to drop if only one row is left.</p>
</td></tr>
<tr><td><code id="neuronlist-dataframe-methods_+3A_value">value</code></td>
<td>
<p>A suitable replacement value: it will be repeated a whole
number of times if necessary and it may be coerced: see the
Coercion section.  If <code>NULL</code>, deletes the column if a single
column is selected.</p>
</td></tr>
<tr><td><code id="neuronlist-dataframe-methods_+3A_except">except</code></td>
<td>
<p>indices of columns from which <em>not</em> to drop levels</p>
</td></tr>
<tr><td><code id="neuronlist-dataframe-methods_+3A_...">...</code></td>
<td>
<p>Further arguments passed to default methods (and usually ignored)</p>
</td></tr>
<tr><td><code id="neuronlist-dataframe-methods_+3A_data">data</code></td>
<td>
<p>A neuronlist object</p>
</td></tr>
<tr><td><code id="neuronlist-dataframe-methods_+3A_expr">expr</code></td>
<td>
<p>The expression to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the attached dataframe with levels dropped (NB <strong>not</strong> the
neuronlist)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code>, @seealso <code><a href="base.html#topic++5B+3C-.data.frame">[&lt;-.data.frame</a></code>
</p>
<p><code><a href="#topic+droplevels">droplevels</a></code>
</p>
<p><code><a href="#topic+with">with</a></code>
</p>
<p><code><a href="#topic+head">head</a></code>
</p>
<p><code><a href="#topic+tail">tail</a></code>
</p>
<p>Other neuronlist: 
<code><a href="#topic++2A.neuronlist">*.neuronlist</a>()</code>,
<code><a href="#topic+is.neuronlist">is.neuronlist</a>()</code>,
<code><a href="#topic+neuronlistfh">neuronlistfh</a>()</code>,
<code><a href="#topic+neuronlist">neuronlist</a>()</code>,
<code><a href="#topic+nlapply">nlapply</a>()</code>,
<code><a href="#topic+read.neurons">read.neurons</a>()</code>,
<code><a href="#topic+write.neurons">write.neurons</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## treat kcs20 as data.frame
kcs20[1, ]
kcs20[1:3, ]
kcs20[, 1:4]
kcs20[, 'soma_side']
# alternative to as.data.frame(kcs20)
kcs20[, ]

## can also set columns
kcs13=kcs20[1:3]
kcs13[,'side']=as.character(kcs13[,'soma_side'])
head(kcs13)
# or parts of columns
kcs13[1,'soma_side']='R'
kcs13['FruMARCM-M001205_seg002','soma_side']='L'
# remove a column
kcs13[,'side']=NULL
all.equal(kcs13, kcs20[1:3])

# can even replace the whole data.frame like this
kcs13[,]=kcs13[,]
all.equal(kcs13, kcs20[1:3])

## get row/column names of attached data.frame 
# (unfortunately implementing ncol/nrow is challenging)
rownames(kcs20)
colnames(kcs20)
</code></pre>

<hr>
<h2 id='neuronlistfh'>neuronlistfh - List of neurons loaded on demand from disk or remote website</h2><span id='topic+neuronlistfh'></span><span id='topic+is.neuronlistfh'></span><span id='topic+as.neuronlistfh'></span><span id='topic+as.neuronlistfh.neuronlist'></span>

<h3>Description</h3>

<p><code>neuronlistfh</code> objects consist of a list of neuron objects 
along with an optional attached dataframe containing information about the 
neurons. In contrast to <code>neuronlist</code> objects the neurons are not 
present in memory but are instead dynamically loaded from disk as required.
<code>neuronlistfh</code> objects also inherit from <code>neuronlist</code> and 
therefore any appropriate methods e.g. <code>plot3d.neuronlist</code> can also be
used on <code>neuronlistfh</code> objects.
</p>
<p><code>neuronlistfh</code> constructs a neuronlistfh object from a 
<code>filehash</code>, <code>data.frame</code> and <code>keyfilemap</code>. End users will 
<strong>not</strong> typically use this function to make a <code>neuronlistfh</code>. 
They will usually read them using <code>read.neuronlistfh</code> and sometimes 
create them by using <code>as.neuronlistfh</code> on a <code>neuronlist</code> object.
</p>
<p><code>is.neuronlistfh</code> test if an object is a neuronlistfh
</p>
<p><code>as.neuronlistfh</code> generic function to convert an object to 
neuronlistfh
</p>
<p><code>as.neuronlistfh.neuronlist</code> converts a regular neuronlist 
to one backed by a filehash object with an on disk representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neuronlistfh(db, df, keyfilemap, hashmap = 1000L)

is.neuronlistfh(nl)

as.neuronlistfh(x, df, ...)

## S3 method for class 'neuronlist'
as.neuronlistfh(
  x,
  df = attr(x, "df"),
  dbdir = NULL,
  dbClass = c("RDS", "RDS2"),
  remote = NULL,
  WriteObjects = c("yes", "no", "missing"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neuronlistfh_+3A_db">db</code></td>
<td>
<p>a <code>filehash</code> object that manages an on disk database of neuron
objects. See Implementation details.</p>
</td></tr>
<tr><td><code id="neuronlistfh_+3A_df">df</code></td>
<td>
<p>Optional dataframe, where each row describes one neuron</p>
</td></tr>
<tr><td><code id="neuronlistfh_+3A_keyfilemap">keyfilemap</code></td>
<td>
<p>A named character vector in which the elements are 
filenames on disk (managed by the filehash object) and the names are the 
keys used in R to refer to the neuron objects. Note that the keyfilemap 
defines the order of objects in the neuronlist and will be used to reorder 
the dataframe if necessary.</p>
</td></tr>
<tr><td><code id="neuronlistfh_+3A_hashmap">hashmap</code></td>
<td>
<p>A logical indicating whether to add a hashed environment for 
rapid object lookup by name or an integer or an integer definining a 
threhsold number of objects when this will happen (see Implementation 
details).</p>
</td></tr>
<tr><td><code id="neuronlistfh_+3A_nl">nl</code></td>
<td>
<p>Object to test</p>
</td></tr>
<tr><td><code id="neuronlistfh_+3A_x">x</code></td>
<td>
<p>Object to convert</p>
</td></tr>
<tr><td><code id="neuronlistfh_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods, eventually passed to
<code>neuronlistfh()</code> constructor.</p>
</td></tr>
<tr><td><code id="neuronlistfh_+3A_dbdir">dbdir</code></td>
<td>
<p>The path to the underlying <code>filehash</code> database on disk. By
convention this should be a path whose final element is 'data'</p>
</td></tr>
<tr><td><code id="neuronlistfh_+3A_dbclass">dbClass</code></td>
<td>
<p>The <code>filehash</code> database class. Defaults to <code>RDS</code>.</p>
</td></tr>
<tr><td><code id="neuronlistfh_+3A_remote">remote</code></td>
<td>
<p>The url pointing to a remote repository containing files for 
each neuron.</p>
</td></tr>
<tr><td><code id="neuronlistfh_+3A_writeobjects">WriteObjects</code></td>
<td>
<p>Whether to write objects to disk. Missing implies that 
existing objects will not be overwritten. Default <code>"yes"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>neuronlistfh</code> object which is a character <code>vector</code> with 
classes <code>neuronlistfh, neuronlist</code> and attributes <code>db, df</code>. See 
Implementation details.
</p>


<h3>Implementation details</h3>

<p>neuronlistfh objects are a hybrid between 
regular <code>neuronlist</code> objects that organise data and metadata for 
collections of neurons and a backing <code>filehash</code> object. Instead of 
keeping objects in memory, they are <em>always</em> loaded from disk. 
Although this sounds like it might be slow, for nearly all practical 
purposes (e.g. plotting neurons) the time to read the neuron from disk is 
small compared with the time to plot the neuron; the OS will cache repeated
reads of the same file. The benefits in memory and startup time (&lt;1s vs 
100s for our 16,000 neuron database) are vital for collections of 1000s of 
neurons e.g. for dynamic report generation using knitr or for users with 
&lt;8Gb RAM or running 32 bit R.
</p>
<p>neuronlistfh objects include: </p>

<dl>
<dt>attr(&quot;keyfilemap&quot;)</dt><dd><p> A named character vector that determines the 
ordering of objects in the neuronlist and translates keys in R to filenames
on disk. For objects created by <code>as.neuronlistfh</code> the filenames will 
be the md5 hash of the object as calculated using <code>digest</code>. This 
design means that the same key can be used to refer to multiple distinct 
objects on disk. Objects are effecitvely versioned by their contents. So if
an updated neuronlistfh object is posted to a website and then fetched by a
user it will result in the automated download of any updated objects to 
which it refers.</p>
</dd>
<dt>attr(&quot;db&quot;)</dt><dd><p> The backing database - typically of class 
<code>filehashRDS</code>. This manages the loading of objects from disk.</p>
</dd>
<dt>attr(x,&quot;df&quot;)</dt><dd><p> The data.frame of metadata which can be used to select
and plot neurons. See <code><a href="#topic+neuronlist">neuronlist</a></code> for examples.</p>
</dd>
<dt>attr(x,&quot;hashmap&quot;)</dt><dd><p> (Optional) a hashed environment which can be used
for rapid lookup using key names (rather than numeric/logical indices). 
There is a space potential to pay for this redundant lookup method, but it 
is normally worth while given that the dataframe object is typically 
considerably larger. To give some numbers, the additional environment might
occupy ~ 1
time from 0.5 ms to 1us. Having located the object, on my machine it can 
take as little as 0.1ms to load from disk, so these savings are relevant.</p>
</dd>
</dl>

<p>Presently only backing objects which extend the <code>filehash</code> class are 
supported (although in theory other backing objects could be added). These 
include: </p>

<ul>
<li><p> filehash RDS
</p>
</li>
<li><p> filehash RDS2 (experimental)</p>
</li></ul>

<p>We have also implemented a simple remote access protocol (currently only 
for the <code>RDS</code> format). This allows a neuronlistfh object to be read 
from a url and downloaded to a local path. Subsequent attempts to access 
neurons stored in this list will result in automated download of the 
requested neuron to the local cache.
</p>
<p>An alternative backend, the experimental <code>RDS2</code> format is supported 
(available at <a href="https://github.com/jefferis/filehash">https://github.com/jefferis/filehash</a>). This is likely 
to be the most effective for large (5,000-500,000) collections of neurons, 
especially when using network filesystems (nfs, afp) which are typically 
very slow at listing large directories.
</p>
<p>Note that objects are stored in a filehash, which by definition does not 
have any ordering of its elements. However neuronlist objects (like lists) 
do have an ordering. Therefore the names of a neuronlistfh object are not 
necessarily the same as the result of calling <code>names()</code> on the 
underlying filehash object.
</p>


<h3>See Also</h3>

<p><code><a href="filehash.html#topic+filehash-class">filehash-class</a></code>
</p>
<p>Other neuronlistfh: 
<code><a href="#topic++5B.neuronlistfh">[.neuronlistfh</a>()</code>,
<code><a href="#topic+read.neuronlistfh">read.neuronlistfh</a>()</code>,
<code><a href="#topic+remotesync">remotesync</a>()</code>,
<code><a href="#topic+write.neuronlistfh">write.neuronlistfh</a>()</code>
</p>
<p>Other neuronlist: 
<code><a href="#topic++2A.neuronlist">*.neuronlist</a>()</code>,
<code><a href="#topic+is.neuronlist">is.neuronlist</a>()</code>,
<code><a href="#topic+neuronlist-dataframe-methods">neuronlist-dataframe-methods</a></code>,
<code><a href="#topic+neuronlist">neuronlist</a>()</code>,
<code><a href="#topic+nlapply">nlapply</a>()</code>,
<code><a href="#topic+read.neurons">read.neurons</a>()</code>,
<code><a href="#topic+write.neurons">write.neurons</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
kcnl=read.neuronlistfh('http://jefferislab.org/si/nblast/flycircuit/kcs20.rds',
'path/to/my/project/folder')
# this will automatically download the neurons from the web the first time
# it is run
plot3d(kcnl)

## End(Not run)
## Not run: 
# create neuronlistfh object backed by filehash with one file per neuron
# by convention we create a subfolder called data in which the objects live
kcs20fh=as.neuronlistfh(kcs20, dbdir='/path/to/my/kcdb/data')
plot3d(subset(kcs20fh,type=='gamma'))
# ... and, again by convention, save the neuronlisfh object next to filehash 
# backing database
write.neuronlistfh(kcs20fh, file='/path/to/my/kcdb/kcdb.rds')

# in a new session
read.neuronlistfh("/path/to/my/kcdb/kcdb.rds")
plot3d(subset(kcs20fh, type=='gamma'))

## End(Not run)
</code></pre>

<hr>
<h2 id='ngraph'>ngraph: a graph to encode a neuron's connectivity</h2><span id='topic+ngraph'></span><span id='topic+as.ngraph'></span><span id='topic+as.ngraph.data.frame'></span><span id='topic+as.ngraph.neuron'></span>

<h3>Description</h3>

<p>the <code>ngraph</code> class contains a (completely general) graph 
representation of a neuron's connectivity in an <code>igraph</code> object. It 
may additionally contain vertex label or position data. See details.
</p>
<p><code>ngraph()</code> creates an ngraph from edge and vertex information.
</p>
<p><code>as.ngraph</code> converts an object to an ngraph
</p>
<p><code>as.ngraph.dataframe</code> construct ngraph from a data.frame 
containing SWC format data
</p>
<p><code>as.ngraph.neuron</code> construct ngraph from a neuron
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngraph(
  el,
  vertexlabels,
  xyz = NULL,
  diam = NULL,
  directed = TRUE,
  weights = FALSE,
  vertex.attributes = NULL,
  graph.attributes = NULL
)

as.ngraph(x, ...)

## S3 method for class 'data.frame'
as.ngraph(x, directed = TRUE, ...)

## S3 method for class 'neuron'
as.ngraph(x, directed = TRUE, method = c("swc", "seglist"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngraph_+3A_el">el</code></td>
<td>
<p>A two columm matrix (start, end) defining edges. <code>start</code> means
closer to the root (soma) of the neuron.</p>
</td></tr>
<tr><td><code id="ngraph_+3A_vertexlabels">vertexlabels</code></td>
<td>
<p>Integer labels for graph - the edge list is specified 
using these labels.</p>
</td></tr>
<tr><td><code id="ngraph_+3A_xyz">xyz</code></td>
<td>
<p>3D coordinates of vertices (optional, Nx3 matrix, or Nx4 matrix 
when 4th column is assumed to be diameter)</p>
</td></tr>
<tr><td><code id="ngraph_+3A_diam">diam</code></td>
<td>
<p>Diameter of neuron at each vertex (optional)</p>
</td></tr>
<tr><td><code id="ngraph_+3A_directed">directed</code></td>
<td>
<p>Whether the resultant graph should be directed (default TRUE)</p>
</td></tr>
<tr><td><code id="ngraph_+3A_weights">weights</code></td>
<td>
<p>Logical value indicating whether edge weights defined by the 
3D distance between points should be added to graph (default <code>FALSE</code>) 
<em>or</em> a numeric vector of weights.</p>
</td></tr>
<tr><td><code id="ngraph_+3A_vertex.attributes">vertex.attributes</code>, <code id="ngraph_+3A_graph.attributes">graph.attributes</code></td>
<td>
<p>List of named attributes to be
added to the graph. The elements of <code>vertex.attributes</code> must be
vectors whose length is compatible with the number of elements in the
graph. See <code><a href="igraph.html#topic+set_vertex_attr">set_vertex_attr</a></code> for details.</p>
</td></tr>
<tr><td><code id="ngraph_+3A_x">x</code></td>
<td>
<p>Object to convert (see method descriptions)</p>
</td></tr>
<tr><td><code id="ngraph_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods</p>
</td></tr>
<tr><td><code id="ngraph_+3A_method">method</code></td>
<td>
<p>Whether to use the swc data (x$d) or the seglist to define 
neuronal connectivity to generate graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the <code>as.ngraph.neuron</code> method <em>always</em> keeps the
original vertex labels (a.k.a. PointNo) as read in from the original file.
</p>


<h3>Value</h3>

<p>an <code>igraph</code> object with additional class <code>ngraph</code>, having a
vertex for each entry in vertexlabels, each vertex having a <code>label</code> 
attribute. All vertices are included whether connected or not.
</p>


<h3>Connectivity</h3>

<p>We make the following assumptions about neurons coming
in
</p>

<ul>
<li><p> They have an integer vertex label that need not start from 1 and that
may have gaps
</p>
</li>
<li><p> The edge list which defines connectivity specifies edges using pairs 
of vertex labels, _not_ raw vertex ids.
</p>
</li></ul>

<p>We make no attempt to determine the root points at this stage.
</p>
<p>The raw vertex ids in the graph will be in the order of vertexlabels and 
can therefore be used to index a block of vertex coordinates. The 
vertexlabels will be stored using the vertex attribute <code>label</code>
</p>
<p>When the graph is directed (default) the edges will be from the root to the
other tips of the neuron.
</p>


<h3>Morphology</h3>

<p>The morphology of the neuron is encoded by the 
combination of connectivity information (i.e. the graph) and spatial data 
encoded as the 3D position and diameter of each vertex. Position 
information is stored as vertex attributes X, Y, and Z.
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+igraph">igraph</a></code>, <code><a href="igraph.html#topic+set_vertex_attr">set_vertex_attr</a></code>,
<code><a href="#topic+subset.neuron">subset.neuron</a></code> for example of graph-based manipulation of a
neuron.
</p>
<p>Other neuron: 
<code><a href="#topic+neuron">neuron</a>()</code>,
<code><a href="#topic+plot.neuron">plot.neuron</a>()</code>,
<code><a href="#topic+potential_synapses">potential_synapses</a>()</code>,
<code><a href="#topic+prune">prune</a>()</code>,
<code><a href="#topic+resample">resample</a>()</code>,
<code><a href="#topic+rootpoints">rootpoints</a>()</code>,
<code><a href="#topic+spine">spine</a>()</code>,
<code><a href="#topic+subset.neuron">subset.neuron</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g=as.ngraph(Cell07PNs[[1]])
library(igraph)
# check that vertex attributes of graph match X position
all.equal(V(g)$X, Cell07PNs[[1]]$d$X)
</code></pre>

<hr>
<h2 id='nlapply'>lapply and mapply for neuronlists (with optional parallelisation)</h2><span id='topic+nlapply'></span><span id='topic+nmapply'></span>

<h3>Description</h3>

<p>versions of lapply and mapply that look after the class and 
attached dataframe of neuronlist objects. <code>nlapply</code> can apply a 
function to only a <code>subset</code> of elements in the input neuronlist. 
Internally <code>nlapply</code> uses <code>plyr::llply</code> thereby enabling progress
bars and simple parallelisation (see plyr section and examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlapply(
  X,
  FUN,
  ...,
  subset = NULL,
  OmitFailures = NA,
  .progress = getOption("nat.progress", default = "auto")
)

nmapply(
  FUN,
  X,
  ...,
  MoreArgs = NULL,
  SIMPLIFY = FALSE,
  USE.NAMES = TRUE,
  subset = NULL,
  OmitFailures = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlapply_+3A_x">X</code></td>
<td>
<p>A neuronlist</p>
</td></tr>
<tr><td><code id="nlapply_+3A_fun">FUN</code></td>
<td>
<p>Function to be applied to each element of X</p>
</td></tr>
<tr><td><code id="nlapply_+3A_...">...</code></td>
<td>
<p>Additional arguments for FUN (see details)</p>
</td></tr>
<tr><td><code id="nlapply_+3A_subset">subset</code></td>
<td>
<p>Character, numeric or logical vector specifying on which subset
of <code>X</code> the function <code>FUN</code> should be applied. Elements outside the
subset are passed through unmodified.</p>
</td></tr>
<tr><td><code id="nlapply_+3A_omitfailures">OmitFailures</code></td>
<td>
<p>Whether to omit neurons for which <code>FUN</code> gives an 
error. The default value (<code>NA</code>) will result in nlapply stopping with 
an error message the moment there is an eror. For other values, see 
details.</p>
</td></tr>
<tr><td><code id="nlapply_+3A_.progress">.progress</code></td>
<td>
<p>Character vector specifying the type of progress bar (see 
<code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code> for options.) The default value of 
<code>"auto"</code> shows a progress bar in interactive use when there are &gt;=10 
elements in <code>X</code>. The default value can be overridden for the current 
session by setting the value of <code>options(nat.progressbar)</code> (see
examples).</p>
</td></tr>
<tr><td><code id="nlapply_+3A_moreargs">MoreArgs</code></td>
<td>
<p>a list of other arguments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="nlapply_+3A_simplify">SIMPLIFY</code></td>
<td>
<p>logical or character string; attempt to reduce the
result to a vector, matrix or higher dimensional array; see
the <code>simplify</code> argument of <code><a href="base.html#topic+sapply">sapply</a></code>.</p>
</td></tr>
<tr><td><code id="nlapply_+3A_use.names">USE.NAMES</code></td>
<td>
<p>logical; use the names of the first ... argument, or
if that is an unnamed character vector, use that vector as the names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>OmitFailures</code> is not <code>NA</code>, <code>FUN</code> will be 
wrapped in a call to <code>try</code> to ensure that failure for any single 
neuron does not abort the nlapply/nmapply call. When 
<code>OmitFailures=TRUE</code> the resultant neuronlist will be subsetted down to
return values for which <code>FUN</code> evaluated successfully. When 
<code>OmitFailures=FALSE</code>, &quot;try-error&quot; objects will be left in place. In 
either of the last 2 cases error messages will not be printed because the 
call is wrapped as <code>try(expr, silent=TRUE)</code>.
</p>


<h3>Value</h3>

<p>A neuronlist
</p>


<h3>plyr</h3>

<p>The arguments of most interest from plyr are:
</p>

<ul>
<li> <p><code>.inform</code> set to <code>TRUE</code> to give more informative error 
messages that should indicate which neurons are failing for a given applied
function.
</p>
</li>
<li> <p><code>.progress</code> set to <code>"text"</code> for a basic progress bar
</p>
</li>
<li> <p><code>.parallel</code> set to <code>TRUE</code> for parallelisation after 
registering a parallel backend (see below).
</p>
</li>
<li> <p><code>.paropts</code> Additional arguments for parallel computation. See 
<code><a href="plyr.html#topic+llply">llply</a></code> for details.
</p>
</li></ul>

<p>Before using parallel code within an R session you must register a suitable
parallel backend. The simplest example is the multicore option provided by 
the <code>doMC</code> package that is suitable for a spreading computational load
across multiple cores on a single machine. An example is provided below.
</p>
<p>Note that the progess bar and parallel options cannot be used at the same 
time. You may want to start a potentially long-running job with the 
progress bar option and then abort and re-run with <code>.parallel=TRUE</code> if
it looks likely to take a very long time.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+lapply">lapply</a></code>
</p>
<p><code><a href="base.html#topic+mapply">mapply</a></code>
</p>
<p>Other neuronlist: 
<code><a href="#topic++2A.neuronlist">*.neuronlist</a>()</code>,
<code><a href="#topic+is.neuronlist">is.neuronlist</a>()</code>,
<code><a href="#topic+neuronlist-dataframe-methods">neuronlist-dataframe-methods</a></code>,
<code><a href="#topic+neuronlistfh">neuronlistfh</a>()</code>,
<code><a href="#topic+neuronlist">neuronlist</a>()</code>,
<code><a href="#topic+read.neurons">read.neurons</a>()</code>,
<code><a href="#topic+write.neurons">write.neurons</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## nlapply example
kcs.reduced=nlapply(kcs20,function(x) subset(x,sample(nrow(x$points),50)))
open3d()
plot3d(kcs.reduced,col='red', lwd=2)
plot3d(kcs20,col='grey')
close3d()

## Not run: 
# example of using plyr's .inform argument for debugging error conditions
xx=nlapply(Cell07PNs, prune_strahler)
# oh dear there was an error, let's get some details about the neuron
# that caused the problem
xx=nlapply(Cell07PNs, prune_strahler, .inform=TRUE)

## End(Not run)

## Not run: 
## nlapply example with plyr
## dotprops.neuronlist uses nlapply under the hood
## the .progress and .parallel arguments are passed straight to 
system.time(d1&lt;-dotprops(kcs20,resample=1,k=5,.progress='text'))
## plyr+parallel
library(doMC)
# can also specify cores e.g. registerDoMC(cores=4)
registerDoMC()
system.time(d2&lt;-dotprops(kcs20,resample=1,k=5,.parallel=TRUE))
stopifnot(all.equal(d1,d2))

## End(Not run)

## nmapply example
# flip first neuron in X, second in Y and 3rd in Z
xyzflip=nmapply(mirror, kcs20[1:3], mirrorAxis = c("X","Y","Z"),
 mirrorAxisSize=c(400,20,30))

open3d()
plot3d(kcs20[1:3])
plot3d(xyzflip)
close3d()


## Not run: 
## Override default progress bar behaviour via options
sl=nlapply(Cell07PNs, FUN = seglengths)
options(nat.progress='none')
sl=nlapply(Cell07PNs, FUN = seglengths)
options(nat.progress=NULL)
sl=nlapply(Cell07PNs, FUN = seglengths)

## End(Not run)
</code></pre>

<hr>
<h2 id='nlscan'>Scan through a set of neurons, individually plotting each one in 3D</h2><span id='topic+nlscan'></span>

<h3>Description</h3>

<p>Can also choose to select specific neurons along the way and navigate 
forwards and backwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlscan(
  neurons,
  db = NULL,
  col = "red",
  Verbose = T,
  Wait = T,
  sleep = 0.1,
  extrafun = NULL,
  selected_file = NULL,
  selected_col = "green",
  yaml = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlscan_+3A_neurons">neurons</code></td>
<td>
<p>a <code>neuronlist</code> object or a character vector of names of 
neurons to plot from the neuronlist specified by <code>db</code>.</p>
</td></tr>
<tr><td><code id="nlscan_+3A_db">db</code></td>
<td>
<p>A neuronlist to use as the source of objects to plot. If
<code>NULL</code>, the default, will use the neuronlist specified by
options('nat.default.neuronlist')</p>
</td></tr>
<tr><td><code id="nlscan_+3A_col">col</code></td>
<td>
<p>the color with which to plot the neurons (default <code>'red'</code>).</p>
</td></tr>
<tr><td><code id="nlscan_+3A_verbose">Verbose</code></td>
<td>
<p>logical indicating that info about each selected neuron should
be printed (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="nlscan_+3A_wait">Wait</code></td>
<td>
<p>logical indicating that there should be a pause between each 
displayed neuron.</p>
</td></tr>
<tr><td><code id="nlscan_+3A_sleep">sleep</code></td>
<td>
<p>time to pause between each displayed neuron when 
<code>Wait=TRUE</code>.</p>
</td></tr>
<tr><td><code id="nlscan_+3A_extrafun">extrafun</code></td>
<td>
<p>an optional function called when each neuron is plotted, with
two arguments: the current neuron name and the current <code>selected</code> 
neurons.</p>
</td></tr>
<tr><td><code id="nlscan_+3A_selected_file">selected_file</code></td>
<td>
<p>an optional path to a <code>yaml</code> file that already 
contains a selection.</p>
</td></tr>
<tr><td><code id="nlscan_+3A_selected_col">selected_col</code></td>
<td>
<p>the color in which selected neurons (such as those 
specified in <code>selected_file</code>) should be plotted.</p>
</td></tr>
<tr><td><code id="nlscan_+3A_yaml">yaml</code></td>
<td>
<p>a logical indicating that selections should be saved to disk in 
(human-readable) <code>yaml</code> rather than (machine-readable) <code>rda</code> 
format.</p>
</td></tr>
<tr><td><code id="nlscan_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to <code><a href="#topic+plot3d">plot3d</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of names of any selected neurons, of length 0 if 
none selected.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3d.character">plot3d.character</a></code>, <code><a href="#topic+plot3d.neuronlist">plot3d.neuronlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# scan a neuronlist
nlscan(kcs20)

# using neuron names
nlscan(names(kcs20), db=kcs20)
# equivalently using a default neuron list
options(nat.default.neuronlist='kcs20')
nlscan(names(kcs20))

## End(Not run)
# scan without waiting
nlscan(kcs20[1:4], Wait=FALSE, sleep=0)
## Not run: 
# could select e.g. the gamma neurons with unbranched axons
gammas=nlscan(kcs20)
clear3d()
plot3d(kcs20[gammas])

# plot surface model of brain first
# nb depends on package only available on github
devtools::install_github(username = "jefferislab/nat.flybrains")
library(nat.flybrains)
plot3d(FCWB)
# could select e.g. the gamma neurons with unbranched axons
gammas=nlscan(kcs20)
clear3d()
plot3d(kcs20[gammas])

## End(Not run)
</code></pre>

<hr>
<h2 id='nopen3d'>Open customised rgl window</h2><span id='topic+nopen3d'></span>

<h3>Description</h3>

<p>Pan with right button (Ctrl+click), zoom with middle (Alt/Meta+click) button.
Defaults to a white background and orthogonal projection (FOV=0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nopen3d(bgcol = "white", FOV = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nopen3d_+3A_bgcol">bgcol</code></td>
<td>
<p>background colour</p>
</td></tr>
<tr><td><code id="nopen3d_+3A_fov">FOV</code></td>
<td>
<p>field of view</p>
</td></tr>
<tr><td><code id="nopen3d_+3A_...">...</code></td>
<td>
<p>additional options passed to open3d</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that sometimes (parts of) objects seem to disappear after panning and
zooming. See help for <code><a href="#topic+pan3d">pan3d</a></code>.
</p>


<h3>Value</h3>

<p>current rgl device
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+open3d">open3d</a>,<a href="#topic+pan3d">pan3d</a></code>
</p>

<hr>
<h2 id='normalise_swc'>Normalise an SWC format block of neuron morphology data</h2><span id='topic+normalise_swc'></span>

<h3>Description</h3>

<p>Normalise an SWC format block of neuron morphology data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise_swc(
  x,
  requiredColumns = c("PointNo", "Label", "X", "Y", "Z", "W", "Parent"),
  ifMissing = c("usedefaults", "warning", "stop"),
  includeExtraCols = TRUE,
  defaultValue = list(PointNo = seq.int(nrow(x)), Label = 2L, X = NA_real_, Y = NA_real_,
    Z = NA_real_, W = NA_real_, Parent = NA_integer_)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalise_swc_+3A_x">x</code></td>
<td>
<p>A data.frame containing neuron morphology data</p>
</td></tr>
<tr><td><code id="normalise_swc_+3A_requiredcolumns">requiredColumns</code></td>
<td>
<p>Character vector naming columns we should have</p>
</td></tr>
<tr><td><code id="normalise_swc_+3A_ifmissing">ifMissing</code></td>
<td>
<p>What to do if <code>x</code> is missing a required column</p>
</td></tr>
<tr><td><code id="normalise_swc_+3A_includeextracols">includeExtraCols</code></td>
<td>
<p>Whether to include any extra columns included in
<code>x</code></p>
</td></tr>
<tr><td><code id="normalise_swc_+3A_defaultvalue">defaultValue</code></td>
<td>
<p>A list containing default values to use for any missing
columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that row.names of the resultant data.frame will be set to NULL
so that they have completely standard values.
</p>


<h3>Value</h3>

<p>A data.frame containing the normalised block of SWC data with
standard columns in standard order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.neuron.data.frame">as.neuron.data.frame</a></code>, <code><a href="#topic+seglist2swc">seglist2swc</a></code>
</p>

<hr>
<h2 id='npop3d'>Remove plotted neurons or other 3D objects</h2><span id='topic+npop3d'></span>

<h3>Description</h3>

<p>The normal usage will not specify <code>x</code> in which case the last neurons
plotted by <code>plot3d.neuronlist</code> or any of its friends will be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npop3d(x, slow = FALSE, type = "shapes")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npop3d_+3A_x">x</code></td>
<td>
<p>rgl ids of objects to remove</p>
</td></tr>
<tr><td><code id="npop3d_+3A_slow">slow</code></td>
<td>
<p>Whether to remove neurons one by one (slowly) default: FALSE</p>
</td></tr>
<tr><td><code id="npop3d_+3A_type">type</code></td>
<td>
<p>Type of objects to remove see <code>pop3d</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+pop3d">pop3d</a></code>, <code><a href="#topic+plot3d.neuronlist">plot3d.neuronlist</a></code>
</p>

<hr>
<h2 id='nrrd.voxdims'>Return voxel dimensions (by default absolute voxel dimensions)</h2><span id='topic+nrrd.voxdims'></span>

<h3>Description</h3>

<p>Return voxel dimensions (by default absolute voxel dimensions)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrrd.voxdims(file, ReturnAbsoluteDims = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrrd.voxdims_+3A_file">file</code></td>
<td>
<p>path to nrrd/nhdr file or a list containing a nrrd header</p>
</td></tr>
<tr><td><code id="nrrd.voxdims_+3A_returnabsolutedims">ReturnAbsoluteDims</code></td>
<td>
<p>Defaults to returning absolute value of dims even 
if there are any negative space directions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NB Can handle off diagonal terms in space directions matrix, BUT 
assumes that space direction vectors are orthogonal.
</p>
<p>Will produce a warning if no valid dimensions can be found.
</p>


<h3>Value</h3>

<p>numeric vector of voxel dimensions (<code>NA_real_</code> when missing) of
length equal to the image dimension.
</p>


<h3>Author(s)</h3>

<p>jefferis
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nrrd.header">read.nrrd.header</a></code>
</p>

<hr>
<h2 id='nvertices'>Find the number of vertices in an object (or each element of a neuronlist)</h2><span id='topic+nvertices'></span><span id='topic+nvertices.default'></span><span id='topic+nvertices.neuronlist'></span><span id='topic+nvertices.igraph'></span>

<h3>Description</h3>

<p>Find the number of vertices in an object (or each element of a neuronlist)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nvertices(x, ...)

## Default S3 method:
nvertices(x, ...)

## S3 method for class 'neuronlist'
nvertices(x, ...)

## S3 method for class 'igraph'
nvertices(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nvertices_+3A_x">x</code></td>
<td>
<p>An object with 3d vertices (e.g. neuron, surface etc)</p>
</td></tr>
<tr><td><code id="nvertices_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer number of vertices (or a vector of length equal to a
neuronlist)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nvertices(Cell07PNs[[1]])
nvertices(kcs20)
</code></pre>

<hr>
<h2 id='nview3d'>Set the 3D viewpoint of an RGL window using anatomical terms</h2><span id='topic+nview3d'></span>

<h3>Description</h3>

<p>Set the 3D viewpoint of an RGL window using anatomical terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nview3d(
  viewpoint = c("frontal", "anterior", "dorsal", "ventral", "posterior", "left", "right",
    "oblique_right", "oblique_left"),
  FOV = 0,
  extramat = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nview3d_+3A_viewpoint">viewpoint</code></td>
<td>
<p>Character vector specifying viewpoint</p>
</td></tr>
<tr><td><code id="nview3d_+3A_fov">FOV</code></td>
<td>
<p>The Field of View (defaults to 0 =&gt; orthographic projection) (see
<code><a href="rgl.html#topic+par3d">par3d</a></code> for details).</p>
</td></tr>
<tr><td><code id="nview3d_+3A_extramat">extramat</code></td>
<td>
<p>An optional extra transformation matrix to be applied after
the one implied by the viewpoint argument.</p>
</td></tr>
<tr><td><code id="nview3d_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="rgl.html#topic+par3d">par3d</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+nopen3d">nopen3d</a></code>, <code><a href="rgl.html#topic+view3d">view3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot3d(kcs20, soma=TRUE)
nview3d('frontal')
nview3d('ant')
nview3d()
nview3d('posterior')
nview3d('oblique_right')
# a slightly oblique frontal view
nview3d('frontal', extramat=rotationMatrix(pi/10, 1, 1, 0))

</code></pre>

<hr>
<h2 id='origin'>Return the space origin of a 3D image object</h2><span id='topic+origin'></span>

<h3>Description</h3>

<p>Defined as the first coordinates (x,y,z) of the bounding box, 
which in turn matches the nrrd definition of the location of the &quot;centre&quot; 
of the first voxel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>origin(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="origin_+3A_x">x</code></td>
<td>
<p>Object for which origin should be returned. See 
<code><a href="#topic+boundingbox">boundingbox</a></code>.</p>
</td></tr>
<tr><td><code id="origin_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+boundingbox">boundingbox</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other im3d: 
<code><a href="#topic+as.im3d">as.im3d</a>()</code>,
<code><a href="#topic+boundingbox">boundingbox</a>()</code>,
<code><a href="#topic+im3d-coords">im3d-coords</a></code>,
<code><a href="#topic+im3d-io">im3d-io</a></code>,
<code><a href="#topic+im3d">im3d</a>()</code>,
<code><a href="#topic+imexpand.grid">imexpand.grid</a>()</code>,
<code><a href="#topic+imslice">imslice</a>()</code>,
<code><a href="#topic+is.im3d">is.im3d</a>()</code>,
<code><a href="#topic+mask">mask</a>()</code>,
<code><a href="#topic+projection">projection</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>,
<code><a href="#topic+voxdims">voxdims</a>()</code>
</p>

<hr>
<h2 id='pan3d'>Some useful extensions / changes to rgl defaults</h2><span id='topic+pan3d'></span>

<h3>Description</h3>

<p>Set up pan call back for current rgl device
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pan3d(button)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pan3d_+3A_button">button</code></td>
<td>
<p>Integer from 1 to 3 indicating mouse button</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Copied verbatim from ?rgl.setMouseCallbacks for rgl version 0.92.892 Mouse
button 2 is right and button 3 is middle (accessed by meta/alt key)
</p>
<p>Note that sometimes (parts of) objects seem to disappear after panning and 
zooming. The example in <code><a href="rgl.html#topic+rgl.setMouseCallbacks">rgl.setMouseCallbacks</a></code> from which this
is copied includes a note that &quot;this doesn't play well with rescaling&quot;
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+rgl.setMouseCallbacks">rgl.setMouseCallbacks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 open3d()
 pan3d(2)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.neuron'>Plot a 2D projection of a neuron</h2><span id='topic+plot.neuron'></span>

<h3>Description</h3>

<p>Plot a 2D projection of a neuron
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuron'
plot(
  x,
  WithLine = TRUE,
  WithNodes = TRUE,
  WithAllPoints = FALSE,
  WithText = FALSE,
  PlotSubTrees = TRUE,
  soma = FALSE,
  PlotAxes = c("XY", "YZ", "XZ", "ZY"),
  axes = TRUE,
  asp = 1,
  main = x$NeuronName,
  sub = NULL,
  xlim = NULL,
  ylim = NULL,
  AxisDirections = c(1, -1, 1),
  add = FALSE,
  col = NULL,
  PointAlpha = 1,
  tck = NA,
  lwd = par("lwd"),
  boundingbox = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.neuron_+3A_x">x</code></td>
<td>
<p>a neuron to plot.</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_withline">WithLine</code></td>
<td>
<p>whether to plot lines for all segments in neuron.</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_withnodes">WithNodes</code></td>
<td>
<p>whether points should only be drawn for nodes (branch/end 
points)</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_withallpoints">WithAllPoints</code></td>
<td>
<p>whether points should be drawn for all points in neuron.</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_withtext">WithText</code></td>
<td>
<p>whether to label plotted points with their id.</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_plotsubtrees">PlotSubTrees</code></td>
<td>
<p>Whether to plot all sub trees when the neuron is not 
fully connected.</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_soma">soma</code></td>
<td>
<p>Whether to plot a circle at neuron's origin representing the 
soma. Either a logical value or a numeric indicating the radius (default 
<code>FALSE</code>). When <code>soma=TRUE</code> the radius is hard coded to 2.</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_plotaxes">PlotAxes</code></td>
<td>
<p>the axes for the plot.</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_axes">axes</code></td>
<td>
<p>whether axes should be drawn.</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_asp">asp</code></td>
<td>
<p>the <code>y/x</code> aspect ratio, see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_main">main</code></td>
<td>
<p>the title for the plot</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_sub">sub</code></td>
<td>
<p>sub title for the plot</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_xlim">xlim</code></td>
<td>
<p>limits for the horizontal axis (see also boundingbox)</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_ylim">ylim</code></td>
<td>
<p>limits for the vertical axis (see also boundingbox)</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_axisdirections">AxisDirections</code></td>
<td>
<p>the directions for the axes. By default, R uses the 
bottom-left for the origin, whilst most graphics software uses the 
top-left. The default value of <code>c(1, -1, 1)</code> makes the produced plot 
consistent with the latter.</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_add">add</code></td>
<td>
<p>Whether the plot should be superimposed on one already present 
(default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_col">col</code></td>
<td>
<p>the color in which to draw the lines between nodes.</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_pointalpha">PointAlpha</code></td>
<td>
<p>the value of alpha to use in plotting the nodes.</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_tck">tck</code></td>
<td>
<p>length of tick mark as fraction of plotting region (negative 
number is outside graph, positive number is inside, 0 suppresses ticks, 1 
creates gridlines).</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_lwd">lwd</code></td>
<td>
<p>line width relative to the default (default=1).</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_boundingbox">boundingbox</code></td>
<td>
<p>A 2 x 3 matrix (ideally of class 
<code><a href="#topic+boundingbox">boundingbox</a></code>) that enables the plot axis limits to be set 
without worrying about axis selection or reversal (see details)</p>
</td></tr>
<tr><td><code id="plot.neuron_+3A_...">...</code></td>
<td>
<p>additional arguments passed to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions sets the axis ranges based on the chosen
<code>PlotAxes</code> and the range of the data in <code>x</code>. It is still possible
to use <code>PlotAxes</code> in combination with a <code>boundingbox</code>, for
example to set the range of a plot of a number of objects.
</p>
<p>nat assumes the default axis convention used in biological imaging, where
the origin of the y axis is the top rather than the bottom of the plot.
This is achieved by reversing the y axis of the 2D plot when the second
data axis is the Y axis of the 3D data. Other settings can be achieved by
modfiying the AxisDirections argument.
</p>


<h3>Value</h3>

<p>list of plotted points (invisibly)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3d.neuron">plot3d.neuron</a></code>
</p>
<p>Other neuron: 
<code><a href="#topic+neuron">neuron</a>()</code>,
<code><a href="#topic+ngraph">ngraph</a>()</code>,
<code><a href="#topic+potential_synapses">potential_synapses</a>()</code>,
<code><a href="#topic+prune">prune</a>()</code>,
<code><a href="#topic+resample">resample</a>()</code>,
<code><a href="#topic+rootpoints">rootpoints</a>()</code>,
<code><a href="#topic+spine">spine</a>()</code>,
<code><a href="#topic+subset.neuron">subset.neuron</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Draw first example neuron
plot(Cell07PNs[[1]])
# Overlay second example neuron
plot(Cell07PNs[[2]], add=TRUE)
# Clear the current plot and draw the third neuron from a different view
plot(Cell07PNs[[3]], PlotAxes="YZ")
# Just plot the end points for the fourth example neuron
plot(Cell07PNs[[4]], WithNodes=FALSE)
# Plot with soma (of default radius)
plot(Cell07PNs[[4]], WithNodes=FALSE, soma=TRUE)
# Plot with soma of defined radius
plot(Cell07PNs[[4]], WithNodes=FALSE, soma=1.25)
</code></pre>

<hr>
<h2 id='plot.neuronlist'>2D plots of the elements in a neuronlist, optionally using a subset 
expression</h2><span id='topic+plot.neuronlist'></span>

<h3>Description</h3>

<p>2D plots of the elements in a neuronlist, optionally using a subset 
expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuronlist'
plot(
  x,
  subset = NULL,
  col = NULL,
  colpal = rainbow,
  add = NULL,
  boundingbox = NULL,
  ...,
  SUBSTITUTE = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.neuronlist_+3A_x">x</code></td>
<td>
<p>a neuron list or, for <code>plot3d.character</code>, a character vector of
neuron names. The default neuronlist used by plot3d.character can be set by
using <code>options(nat.default.neuronlist='mylist')</code>. See 
?<code><a href="#topic+nat">nat</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.neuronlist_+3A_subset">subset</code></td>
<td>
<p>Expression evaluating to logical mask for neurons. See details.</p>
</td></tr>
<tr><td><code id="plot.neuronlist_+3A_col">col</code></td>
<td>
<p>An expression specifying a colour evaluated in the context of the 
dataframe attached to nl (after any subsetting). See details.</p>
</td></tr>
<tr><td><code id="plot.neuronlist_+3A_colpal">colpal</code></td>
<td>
<p>A vector of colours or a function that generates colours</p>
</td></tr>
<tr><td><code id="plot.neuronlist_+3A_add">add</code></td>
<td>
<p>Logical specifying whether to add data to an existing plot or make
a new one. The default value of <code>NULL</code> creates a new plot with the 
first neuron in the neuronlist and then adds the remaining neurons.</p>
</td></tr>
<tr><td><code id="plot.neuronlist_+3A_boundingbox">boundingbox</code></td>
<td>
<p>A 2 x 3 matrix (ideally of class 
<code><a href="#topic+boundingbox">boundingbox</a></code>) that enables the plot axis limits to be set 
without worrying about axis selection or reversal (see details)</p>
</td></tr>
<tr><td><code id="plot.neuronlist_+3A_...">...</code></td>
<td>
<p>options passed on to plot (such as colours, line width etc)</p>
</td></tr>
<tr><td><code id="plot.neuronlist_+3A_substitute">SUBSTITUTE</code></td>
<td>
<p>Whether to <code>substitute</code> the expressions passed as 
arguments <code>subset</code> and <code>col</code>. Default: <code>TRUE</code>. For expert 
use only, when calling from another function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The col and subset parameters are evaluated in the context of the 
dataframe attribute of the neuronlist. If col evaluates to a factor and 
colpal is a named vector then colours will be assigned by matching factor 
levels against the named elements of colpal. If there is one unnamed level,
this will be used as catch-all default value (see examples).
</p>
<p>If col evaluates to a factor and colpal is a function then it will be used
to generate colours with the same number of levels as are used in col.
</p>


<h3>Value</h3>

<p>list of values of <code>plot</code> with subsetted dataframe as attribute 
<code>'df'</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nat-package">nat-package</a>, <a href="#topic+plot3d.neuronlist">plot3d.neuronlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plot 4 cells
plot(Cell07PNs[1:4])
# modify some default plot arguments
plot(Cell07PNs[1:4], ylim=c(140,75), main='First 4 neurons')
# plot one class of neurons in red and all the others in grey
plot(Cell07PNs, col=Glomerulus, colpal=c(DA1='red', 'grey'), WithNodes=FALSE)
# subset operation
plot(Cell07PNs, subset=Glomerulus%in%c("DA1", "DP1m"), col=Glomerulus,
  ylim=c(140,75), WithNodes=FALSE)
</code></pre>

<hr>
<h2 id='plot3d'>plot3d methods for different nat objects</h2><span id='topic+plot3d'></span>

<h3>Description</h3>

<p>These methods enable nat objects including neuronlists and dotprops objects 
to be plotted in 3D. See the help for each individual method for details
along with the help for the generic in the rgl package.
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+plot3d">plot3d</a></code>, <code><a href="#topic+plot3d.boundingbox">plot3d.boundingbox</a></code>, 
<code><a href="#topic+plot3d.character">plot3d.character</a></code>, <code><a href="#topic+plot3d.cmtkreg">plot3d.cmtkreg</a></code>,
<code><a href="#topic+plot3d.dotprops">plot3d.dotprops</a></code>, <code><a href="#topic+plot3d.hxsurf">plot3d.hxsurf</a></code>,
<code><a href="#topic+plot3d.neuron">plot3d.neuron</a></code>, <code><a href="#topic+plot3d.neuronlist">plot3d.neuronlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># all known plot3d methods
methods("plot3d")

# up to date list of all plot3d nethods in this package
intersect(methods("plot3d"), ls(asNamespace("nat")))
</code></pre>

<hr>
<h2 id='plot3d.boundingbox'>Plot a bounding box in 3D</h2><span id='topic+plot3d.boundingbox'></span>

<h3>Description</h3>

<p>Plot a bounding box in 3D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boundingbox'
plot3d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.boundingbox_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+boundingbox">boundingbox</a></code> object to plot.</p>
</td></tr>
<tr><td><code id="plot3d.boundingbox_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code><a href="rgl.html#topic+segments3d">segments3d</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of RGL object IDs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boundingbox">boundingbox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># find the bounding box of all the neurons in a list
boundingbox(kcs20)
boundingbox(kcs20[1:3])

# plot those neurons
plot3d(kcs20)
# ... with their bounding box
plot3d(boundingbox(kcs20))

plot3d(kcs20)
# plot bounding box (in matching colours) for each neuron
# NB makes use of nlapply/neuronlist in slightly unsusual context - 
# plot3d.neuronlist can cope with lists containing anything with
# a valid plot3d method.
plot3d(nlapply(kcs20,boundingbox))


</code></pre>

<hr>
<h2 id='plot3d.cmtkreg'>Plot the domain of a CMTK registration</h2><span id='topic+plot3d.cmtkreg'></span>

<h3>Description</h3>

<p>Plot the domain of a CMTK registration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmtkreg'
plot3d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.cmtkreg_+3A_x">x</code></td>
<td>
<p>A cmtk registration (the path to the registration folder on disk) or
the resulting of reading one in with <code><a href="#topic+read.cmtkreg">read.cmtkreg</a></code>.</p>
</td></tr>
<tr><td><code id="plot3d.cmtkreg_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="rgl.html#topic+plot3d">plot3d</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cmtkreg">cmtkreg</a></code>, <code><a href="#topic+read.cmtkreg">read.cmtkreg</a></code>,
<code><a href="rgl.html#topic+plot3d">plot3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
testdatadir=system.file("tests/testthat/testdata/cmtk", package="nat")
regpath=file.path(testdatadir,'FCWB_JFRC2_01_warp_level-01.list/')
plot3d(cmtkreg(regpath))

# or read registration into memory if you want to work with it
reg=read.cmtkreg(regpath)
# nb calling plot3d.cmtkreg directly (rather than using the generic plot3d) 
# is considered bad style but read.cmtkreg returns a plain list 
# so method dispatch will fail
nat:::plot3d.cmtkreg(reg)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot3d.dotprops'>3D plots of dotprops objects using rgl package</h2><span id='topic+plot3d.dotprops'></span>

<h3>Description</h3>

<p>3D plots of dotprops objects using rgl package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dotprops'
plot3d(
  x,
  scalevecs = 1,
  alpharange = NULL,
  color = "black",
  PlotPoints = FALSE,
  PlotVectors = TRUE,
  UseAlpha = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.dotprops_+3A_x">x</code></td>
<td>
<p>A dotprops object</p>
</td></tr>
<tr><td><code id="plot3d.dotprops_+3A_scalevecs">scalevecs</code></td>
<td>
<p>Factor by which to scale unit vectors (numeric, default: 
1.0)</p>
</td></tr>
<tr><td><code id="plot3d.dotprops_+3A_alpharange">alpharange</code></td>
<td>
<p>Restrict plotting to points with <code>alpha</code> values in 
this range to plot (default: null =&gt; all points). See 
<code><a href="#topic+dotprops">dotprops</a></code> for definition of <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="plot3d.dotprops_+3A_color">color</code></td>
<td>
<p>Character or numeric vector specifying colours for 
points/vectors. See details.</p>
</td></tr>
<tr><td><code id="plot3d.dotprops_+3A_plotpoints">PlotPoints</code>, <code id="plot3d.dotprops_+3A_plotvectors">PlotVectors</code></td>
<td>
<p>Whether to plot points and/or tangent vectors 
(logical, default: tangent vectors only)</p>
</td></tr>
<tr><td><code id="plot3d.dotprops_+3A_usealpha">UseAlpha</code></td>
<td>
<p>Whether to scale tangent vector length by the value of 
<code>alpha</code></p>
</td></tr>
<tr><td><code id="plot3d.dotprops_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>points3d</code> and/or 
<code>segments3d</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tangent vectors are plotted by <code>segments3d</code> and centered on the
relevant point. Points are plotted by <code>points3d</code>.
</p>
<p><code>color</code> will be recycled by <code>points3d</code> and <code>segments3d</code>. 
However in the special case that <code>color</code> has length equal to the 
number of points in <code>x</code>, then it will be duplicated before being 
passed to <code>segments3d</code> so that the result is that each vector is 
coloured uniformly according to <code>color</code> (since segments3d expects 2
colours for each line segment, blending them if they are different).
</p>


<h3>Value</h3>

<p>invisible list of results of rgl plotting commands
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dotprops">dotprops</a>, <a href="rgl.html#topic+plot3d">plot3d</a>, <a href="rgl.html#topic+points3d">points3d</a>, 
  <a href="rgl.html#topic+segments3d">segments3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
open3d()
plot3d(kcs20[[1]])
clear3d()
plot3d(kcs20[[1]],col='red')
clear3d()
plot3d(kcs20[[1]],col='red',lwd=2)
plot3d(kcs20[[2]],col='green',lwd=2)

</code></pre>

<hr>
<h2 id='plot3d.hxsurf'>Plot amira surface objects in 3D using rgl</h2><span id='topic+plot3d.hxsurf'></span>

<h3>Description</h3>

<p>Plot amira surface objects in 3D using rgl
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hxsurf'
plot3d(x, materials = NULL, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.hxsurf_+3A_x">x</code></td>
<td>
<p>An hxsurf surface object</p>
</td></tr>
<tr><td><code id="plot3d.hxsurf_+3A_materials">materials</code></td>
<td>
<p>Character vector or <code><a href="base.html#topic+regex">regex</a></code> naming materials to
plot (defaults to all materials in x). See <code><a href="#topic+subset.hxsurf">subset.hxsurf</a></code>.</p>
</td></tr>
<tr><td><code id="plot3d.hxsurf_+3A_col">col</code></td>
<td>
<p>Character vector specifying colors for the materials, or a 
function that will be called with the number of materials to plot. When 
<code>NULL</code> (default) will use meterial colours defined in Amira (if 
available), or <code>rainbow</code> otherwise.</p>
</td></tr>
<tr><td><code id="plot3d.hxsurf_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+read.hxsurf">read.hxsurf</a></code>
</p>
<p>Other hxsurf: 
<code><a href="#topic+as.hxsurf">as.hxsurf</a>()</code>,
<code><a href="#topic+as.mesh3d">as.mesh3d</a>()</code>,
<code><a href="#topic+materials">materials</a>()</code>,
<code><a href="#topic+read.hxsurf">read.hxsurf</a>()</code>,
<code><a href="#topic+subset.hxsurf">subset.hxsurf</a>()</code>,
<code><a href="#topic+write.hxsurf">write.hxsurf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot3d(kcs20)
plot3d(MBL.surf)


# plot only vertical lobe
clear3d()
plot3d(MBL.surf, materials="VL", alpha=0.3)

# everything except vertical lobe
clear3d()
plot3d(MBL.surf, alpha=0.3, 
  materials=grep("VL", MBL.surf$RegionList, value = TRUE, invert = TRUE))

</code></pre>

<hr>
<h2 id='plot3d.neuron'>Plot neurons in 3D using rgl library</h2><span id='topic+plot3d.neuron'></span>

<h3>Description</h3>

<p>Plot neurons in 3D using rgl library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuron'
plot3d(
  x,
  WithLine = TRUE,
  NeuronNames = FALSE,
  WithNodes = TRUE,
  WithAllPoints = FALSE,
  WithText = FALSE,
  PlotSubTrees = TRUE,
  add = TRUE,
  col = NULL,
  soma = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.neuron_+3A_x">x</code></td>
<td>
<p>A neuron to plot</p>
</td></tr>
<tr><td><code id="plot3d.neuron_+3A_withline">WithLine</code></td>
<td>
<p>Whether to plot lines for all segments in neuron</p>
</td></tr>
<tr><td><code id="plot3d.neuron_+3A_neuronnames">NeuronNames</code></td>
<td>
<p>Logical indicating whether to label the neuron in the plot
using the NeuronName field <strong>or</strong> a character vector of names.</p>
</td></tr>
<tr><td><code id="plot3d.neuron_+3A_withnodes">WithNodes</code></td>
<td>
<p>Whether to plot dots for branch and end points</p>
</td></tr>
<tr><td><code id="plot3d.neuron_+3A_withallpoints">WithAllPoints</code></td>
<td>
<p>Whether to plot dots for all points in the neuron</p>
</td></tr>
<tr><td><code id="plot3d.neuron_+3A_withtext">WithText</code></td>
<td>
<p>Whether to label plotted points with their numeric id (see 
details)</p>
</td></tr>
<tr><td><code id="plot3d.neuron_+3A_plotsubtrees">PlotSubTrees</code></td>
<td>
<p>Whether to plot all sub trees when the neuron is not 
fully connected.</p>
</td></tr>
<tr><td><code id="plot3d.neuron_+3A_add">add</code></td>
<td>
<p>Whether to add the neuron to existing rgl plot rather than 
clearing the scene (default TRUE)</p>
</td></tr>
<tr><td><code id="plot3d.neuron_+3A_col">col</code></td>
<td>
<p>Colour specification (see rgl materials)</p>
</td></tr>
<tr><td><code id="plot3d.neuron_+3A_soma">soma</code></td>
<td>
<p>Whether to plot a sphere at neuron's origin representing the 
soma. Either a logical value or a numeric indicating the radius (default 
<code>FALSE</code>). When <code>soma=TRUE</code> the radius is hard coded to 2.</p>
</td></tr>
<tr><td><code id="plot3d.neuron_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to rgl::lines3d</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that when <code>WithText=TRUE</code>, the numeric identifiers plotted
are <em>raw indices</em> into the <code>x$d</code> array of the <code>neuron</code>,
<em>not</em> the values of the <code>PointNo</code> column.
</p>


<h3>Value</h3>

<p>list of rgl plotting ids (invisibly) separated into <code>lines</code>, 
<code>points</code>, <code>texts</code> according to plot element. See 
<code>rgl::<a href="rgl.html#topic+plot3d">plot3d</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3d.neuronlist">plot3d.neuronlist</a></code>, <code><a href="#topic+plot3d.dotprops">plot3d.dotprops</a></code>, 
<code>nat::<a href="#topic+plot3d">plot3d</a></code>, <code>rgl::<a href="rgl.html#topic+plot3d">plot3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new plot would have been opened if required
open3d()
plot3d(Cell07PNs[[1]],col='red')
plot3d(Cell07PNs[[2]],col='green')

# clear the current plot
clear3d()
plot3d(Cell07PNs[[2]],col='blue',add=FALSE)
# plot the number of all nodes
clear3d()
plot3d(Cell07PNs[[2]],col='red',WithText=TRUE,add=FALSE)
# include cell bodies
plot3d(Cell07PNs[3:4], col='red', soma=TRUE)
plot3d(Cell07PNs[5], col='red', soma=3)
close3d()

</code></pre>

<hr>
<h2 id='plot3d.neuronlist'>3D plots of the elements in a neuronlist, optionally using a subset 
expression</h2><span id='topic+plot3d.neuronlist'></span><span id='topic+plot3d.character'></span>

<h3>Description</h3>

<p><code>plot3d.character</code> is a convenience method intended for 
exploratory work on the command line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuronlist'
plot3d(
  x,
  subset = NULL,
  col = NULL,
  colpal = rainbow,
  skipRedraw = ifelse(interactive(), 200L, TRUE),
  WithNodes = FALSE,
  soma = FALSE,
  ...,
  SUBSTITUTE = TRUE
)

## S3 method for class 'character'
plot3d(x, db = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.neuronlist_+3A_x">x</code></td>
<td>
<p>a neuron list or, for <code>plot3d.character</code>, a character vector of
neuron names. The default neuronlist used by plot3d.character can be set by
using <code>options(nat.default.neuronlist='mylist')</code>. See 
?<code><a href="#topic+nat">nat</a></code> for details. <code><a href="#topic+nat-package">nat-package</a></code>.</p>
</td></tr>
<tr><td><code id="plot3d.neuronlist_+3A_subset">subset</code></td>
<td>
<p>Expression evaluating to logical mask for neurons. See details.</p>
</td></tr>
<tr><td><code id="plot3d.neuronlist_+3A_col">col</code></td>
<td>
<p>An expression specifying a colour evaluated in the context of the 
dataframe attached to nl (after any subsetting). See details.</p>
</td></tr>
<tr><td><code id="plot3d.neuronlist_+3A_colpal">colpal</code></td>
<td>
<p>A vector of colours or a function that generates colours</p>
</td></tr>
<tr><td><code id="plot3d.neuronlist_+3A_skipredraw">skipRedraw</code></td>
<td>
<p>When plotting more than this many (default 200) neurons 
skip redraw for individual neurons (this is much faster for large number of
neurons). Can also accept logical values TRUE (always skip) FALSE (never 
skip).</p>
</td></tr>
<tr><td><code id="plot3d.neuronlist_+3A_withnodes">WithNodes</code></td>
<td>
<p>Whether to plot points for end/branch points. Default: 
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot3d.neuronlist_+3A_soma">soma</code></td>
<td>
<p>Whether to plot a sphere at neuron's origin representing the 
soma. Either a logical value or a numeric indicating the radius (default 
<code>FALSE</code>). When <code>soma=TRUE</code> the radius is hard coded to 2.</p>
</td></tr>
<tr><td><code id="plot3d.neuronlist_+3A_...">...</code></td>
<td>
<p>options passed on to plot3d (such as colours, line width etc)</p>
</td></tr>
<tr><td><code id="plot3d.neuronlist_+3A_substitute">SUBSTITUTE</code></td>
<td>
<p>Whether to <code>substitute</code> the expressions passed as 
arguments <code>subset</code> and <code>col</code>. Default: <code>TRUE</code>. For expert 
use only, when calling from another function.</p>
</td></tr>
<tr><td><code id="plot3d.neuronlist_+3A_db">db</code></td>
<td>
<p>A neuronlist to use as the source of objects to plot. If
<code>NULL</code>, the default, will use the neuronlist specified by
options('nat.default.neuronlist')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The col and subset parameters are evaluated in the context of the 
dataframe attribute of the neuronlist. If col evaluates to a factor and 
colpal is a named vector then colours will be assigned by matching factor 
levels against the named elements of colpal. If there is one unnamed level,
this will be used as catch-all default value (see examples).
</p>
<p>If col evaluates to a factor and colpal is a function then it will be used 
to generate colours with the same number of levels as are used in col.
</p>
<p>WithNodes is <code>FALSE</code> by default when using <code>plot3d.neuronlist</code> 
but remains <code>TRUE</code> by default when plotting single neurons with 
<code><a href="#topic+plot3d.neuron">plot3d.neuron</a></code>. This is because the nodes quickly make plots 
with multiple neurons rather busy.
</p>
<p>When <code>soma</code> is <code>TRUE</code> or a vector of numeric values (recycled as 
appropriate), the values are used to plot cell bodies. For neurons the 
values are passed to <code>plot3d.neuron</code> for neurons. In contrast 
<code>dotprops</code> objects still need special handling. There must be columns 
called <code>X,Y,Z</code> in the data.frame attached to <code>x</code>, that are then 
used directly by code in <code>plot3d.neuronlist</code>.
</p>
<p>Whenever plot3d.neuronlist is called, it will add an entry to an 
environment <code>.plotted3d</code> in <code>nat</code> that stores the ids of all the 
plotted shapes (neurons, cell bodies) so that they can then be removed by a
call to <code>npop3d</code>.
</p>
<p>plot3d.character will check if options('nat.default.neuronlist') has
been set and then use x as an identifier to find a neuron in that 
neuronlist.
</p>


<h3>Value</h3>

<p>list of values of <code>plot3d</code> with subsetted dataframe as attribute
<code>'df'</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nat-package">nat-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
plot3d(kcs20,type=='gamma',col='green')

clear3d()
plot3d(kcs20,col=type)
plot3d(Cell07PNs,Glomerulus=="DA1",col='red')
plot3d(Cell07PNs,Glomerulus=="VA1d",col='green')
# Note use of default colour for non DA1 neurons
plot3d(Cell07PNs,col=Glomerulus, colpal=c(DA1='red', 'grey'))
# a subset expression
plot3d(Cell07PNs,Glomerulus%in%c("DA1",'VA1d'),
  col=c("red","green")[factor(Glomerulus)])
# the same but not specifying colours explicitly
plot3d(Cell07PNs,Glomerulus%in%c("DA1",'VA1d'),col=Glomerulus)

## Not run: 
## more complex colouring strategies for a larger neuron set
# see https://github.com/jefferis/frulhns for details
library(frulhns)
# notice the sexually dimorphic projection patterns for these neurons
plot3d(jkn,cluster=='aSP-f' &amp;shortGenotype=='JK1029', 
  col=sex,colpal=c(male='green',female='magenta'))

## colour neurons of a class by input resistance
jkn.aspg=subset(jkn, cluster=='aSP-g')
# NB this comes in as a factor
Ri=with(jkn.aspg,as.numeric(as.character(Ri..GOhm.)))
# the matlab jet palette
jet.colors&lt;-colorRampPalette(c('navy','cyan','yellow','red'))
plot3d(jkn.aspg,col=cut(Ri,20),colpal=jet.colors)

## End(Not run)
</code></pre>

<hr>
<h2 id='pointsinside'>Find which points of an object are inside a surface</h2><span id='topic+pointsinside'></span><span id='topic+pointsinside.default'></span>

<h3>Description</h3>

<p>Find which points of an object are inside a surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointsinside(x, surf, ...)

## Default S3 method:
pointsinside(x, surf, ..., rval = c("logical", "distance", "mesh3d"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointsinside_+3A_x">x</code></td>
<td>
<p>an object with 3D points.</p>
</td></tr>
<tr><td><code id="pointsinside_+3A_surf">surf</code></td>
<td>
<p>The reference surface - either a <code>mesh3d</code> object or any 
object that can be converted using <code>as.mesh3d</code> including <code>hxsurf</code>
and <code>ashape3d</code> objects.</p>
</td></tr>
<tr><td><code id="pointsinside_+3A_...">...</code></td>
<td>
<p>additional arguments for methods, eventually passed to as.mesh3d.</p>
</td></tr>
<tr><td><code id="pointsinside_+3A_rval">rval</code></td>
<td>
<p>what to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>hxsurf</code> surface objects will be converted to 
<code>mesh3d</code> before being passed to <code>Rvcg::vcgClostKD</code>, so if you are 
testing repeatedly against the same surface, it may make sense to 
pre-convert.
</p>
<p><code>pointsinside</code> depends on the face normals for each face pointing out 
of the object (see example). The face normals are defined by the order of 
the three vertices making up a triangular face. You can flip the face 
normal for a face by permuting the vertices (i.e. 1,2,3 -&gt; 1,3,2). If you 
find for a given surface that points are outside when you expect them to be
inside then the face normals are probably all the wrong way round. You can 
invert them yourself or use the <code>Morpho::invertFaces</code> function to fix 
this.
</p>
<p>If you find that some points but not all points are not behaving as you 
would expect, then it may be that some faces are not coherently oriented. 
The <code>Rvcg::<a href="Rvcg.html#topic+vcgClean">vcgClean</a></code> function can sometimes be used to 
correct the orientation of the faces. Fixing more problematic cases may be 
possible by generating a new surface using 
<code>alphashape3d::<a href="alphashape3d.html#topic+ashape3d">ashape3d</a></code> (see examples).
</p>


<h3>Value</h3>

<p>A vector of logical values or distances (positive inside, negative
outside) equal to the number of points in x or the <code>mesh3d</code> object
returned by <code>Rvcg::vcgClostKD</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# check if the vertices in these neurons are inside the mushroom body calyx
# surface object
inout=pointsinside(kcs20, surf=subset(MBL.surf, "MB_CA_L"))
table(inout)

# be a bit more lenient and include points less than 5 microns from surface
MBCAL=subset(MBL.surf, "MB_CA_L")
inout5=pointsinside(kcs20, surf=MBCAL, rval='distance') &gt; -5
table(inout5)

# show which points are in or out
# Hmm seems like there are a few red points in the vertical lobe
# that are well outside the calyx
points3d(xyzmatrix(kcs20), col=ifelse(inout5, 'red', 'black'))
plot3d(MBL.surf, alpha=.3)

# Let's try to make an alphashape for the mesh to clean it up
library(alphashape3d)
MBCAL.as=ashape3d(xyzmatrix(MBCAL), alpha = 10)
# Plotting the points, we can see that is much better behaved
points3d(xyzmatrix(kcs20), 
  col=ifelse(pointsinside(kcs20, MBCAL.as), 'red', 'black'))


## Not run: 
# Show the face normals for a surface
if(require('Morpho')) {
  # convert to a mesh3d object used by rgl and Morpho packge
  MBCAL.mesh=as.mesh3d(subset(MBL.surf, "MB_CA_L"))
  fn=facenormals(MBCAL.mesh)
  wire3d(MBCAL.mesh)
  # show that the normals point out of the object
  plotNormals(fn, long=5, col='red')
  
  # invert the faces of the mesh and show that normals point in
  MBCAL.inv=invertFaces(MBCAL.mesh)
  plotNormals(facenormals(MBCAL.inv), long=5, col='cyan')
}

## End(Not run)
</code></pre>

<hr>
<h2 id='potential_synapses'>Calculate number of potential synapses between two neurons</h2><span id='topic+potential_synapses'></span><span id='topic+potential_synapses.neuronlist'></span><span id='topic+potential_synapses.neuron'></span><span id='topic+potential_synapses.dotprops'></span>

<h3>Description</h3>

<p>This implements the method of Stepanyants and Chklovskii
</p>


<h3>Usage</h3>

<pre><code class='language-R'>potential_synapses(a, b, s, ...)

## S3 method for class 'neuronlist'
potential_synapses(a, b, s, ...)

## S3 method for class 'neuron'
potential_synapses(
  a,
  b,
  s,
  sigma = s,
  bounds,
  method = c("direct", "approx"),
  ...
)

## S3 method for class 'dotprops'
potential_synapses(
  a,
  b,
  s,
  sigma = s,
  seglength = 1,
  bounds = NULL,
  method = c("direct", "approx"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="potential_synapses_+3A_a">a</code>, <code id="potential_synapses_+3A_b">b</code></td>
<td>
<p>neurons or neuronlists</p>
</td></tr>
<tr><td><code id="potential_synapses_+3A_s">s</code></td>
<td>
<p>the approach distance to consider a potential synapse</p>
</td></tr>
<tr><td><code id="potential_synapses_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods (see details )</p>
</td></tr>
<tr><td><code id="potential_synapses_+3A_sigma">sigma</code></td>
<td>
<p>the smoothing parameter in the approximate method (see details)</p>
</td></tr>
<tr><td><code id="potential_synapses_+3A_bounds">bounds</code></td>
<td>
<p>Optional bounding box to restrict comparison</p>
</td></tr>
<tr><td><code id="potential_synapses_+3A_method">method</code></td>
<td>
<p>Whether to use the direct or approximate method (see details)</p>
</td></tr>
<tr><td><code id="potential_synapses_+3A_seglength">seglength</code></td>
<td>
<p>how long to consider each distance between points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>potential_synapses.neuronlist</code> uses
<code><a href="#topic+nlapply">nlapply</a></code> to process its first argument (<code>a</code>). This
enables progress bars, robustness to errors and simple parallel execution.
See the <code><a href="#topic+nlapply">nlapply</a></code> examples for further details of these
arguments in action.
</p>
<p>For this reason if you have two neuronlists of unequal sizes, it is
recommended to put the larger one in argument <code>a</code>.
</p>


<h3>References</h3>

<p>Neurogeometry and potential synaptic connectivity. Stepanyants A,
Chklovskii DB. Trends Neurosci. 2005 Jul;28(7):387-94.
<a href="https://doi.org/10.1016/j.tins.2005.05.006">doi:10.1016/j.tins.2005.05.006</a>
</p>


<h3>See Also</h3>

<p>Other neuron: 
<code><a href="#topic+neuron">neuron</a>()</code>,
<code><a href="#topic+ngraph">ngraph</a>()</code>,
<code><a href="#topic+plot.neuron">plot.neuron</a>()</code>,
<code><a href="#topic+prune">prune</a>()</code>,
<code><a href="#topic+resample">resample</a>()</code>,
<code><a href="#topic+rootpoints">rootpoints</a>()</code>,
<code><a href="#topic+spine">spine</a>()</code>,
<code><a href="#topic+subset.neuron">subset.neuron</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>potential_synapses(Cell07PNs[1], Cell07PNs[1:3], s=2)
## Not run: 
# if you have many neurons to calculate you should get a progress bar
potential_synapses(Cell07PNs[1:10], Cell07PNs[11:20], s=2)

# you can also use parallel execution, here over 7 cores
# doMC::registerDoMC(7)
potential_synapses(Cell07PNs[1:10], Cell07PNs[11:20], s=2, .parallel=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='projection'>Make 2D (orthogonal) projection of 3D image data</h2><span id='topic+projection'></span>

<h3>Description</h3>

<p>Make 2D (orthogonal) projection of 3D image data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projection(
  a,
  projdim = "z",
  projfun = c("integrate", "mean", "sum"),
  na.rm = T,
  mask = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projection_+3A_a">a</code></td>
<td>
<p>Array of image data (im3d format)</p>
</td></tr>
<tr><td><code id="projection_+3A_projdim">projdim</code></td>
<td>
<p>The image dimension down which to project</p>
</td></tr>
<tr><td><code id="projection_+3A_projfun">projfun</code></td>
<td>
<p>The function that collapses each vector of image data down to 
a single pixel. Can be a character vector naming a function or a function. 
See details.</p>
</td></tr>
<tr><td><code id="projection_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical indicating whether to ignore <code>NA</code> values in the 
image data when calculating function results. default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="projection_+3A_mask">mask</code></td>
<td>
<p>A mask with the same extent as the image.</p>
</td></tr>
<tr><td><code id="projection_+3A_...">...</code></td>
<td>
<p>Additional arguments for projfun</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>projfun</code> must have an argument <code>na.rm</code> like the
S3 Summary <code><a href="base.html#topic+groupGeneric">groupGeneric</a></code> functions such as <code>sum, min</code> 
etc.
</p>
<p>Note also that the BoundingBox of a 2d projection is not well-defined for
the axis along which the projection was made. Presently both the evaluation
location and the BoundingBox extremes are set to 0 after a projection is
made but FIXME this is not completely satisfactory. Perhaps defining this
to be NA or the midpoint of the orginal axis would be better justified.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+groupGeneric">groupGeneric</a></code>, <code><a href="#topic+clampmax">clampmax</a></code>
</p>
<p>Other im3d: 
<code><a href="#topic+as.im3d">as.im3d</a>()</code>,
<code><a href="#topic+boundingbox">boundingbox</a>()</code>,
<code><a href="#topic+im3d-coords">im3d-coords</a></code>,
<code><a href="#topic+im3d-io">im3d-io</a></code>,
<code><a href="#topic+im3d">im3d</a>()</code>,
<code><a href="#topic+imexpand.grid">imexpand.grid</a>()</code>,
<code><a href="#topic+imslice">imslice</a>()</code>,
<code><a href="#topic+is.im3d">is.im3d</a>()</code>,
<code><a href="#topic+mask">mask</a>()</code>,
<code><a href="#topic+origin">origin</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>,
<code><a href="#topic+voxdims">voxdims</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
LHMask=read.im3d(system.file('tests/testthat/testdata/nrrd/LHMask.nrrd',package='nat'))
d=unmask(rnorm(sum(LHMask),mean=5,sd=5),LHMask)
op=par(mfrow=c(1,2))
rval=image(projection(d,projfun=max))
image(projection(d,projfun=clampmax(0,10)),zlim=rval$zlim)
par(op)

## End(Not run)
## Not run: 
LHMask=read.im3d(system.file('tests/testthat/testdata/nrrd/LHMask.nrrd',package='nat'))
image(projection(LHMask),asp=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='prune'>prune an object by removing points near (or far) from a target object</h2><span id='topic+prune'></span><span id='topic+prune.neuron'></span><span id='topic+prune.dotprops'></span><span id='topic+prune.neuronlist'></span><span id='topic+prune.default'></span>

<h3>Description</h3>

<p>prune an object by removing points near (or far) from a target object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune(x, target, ...)

## S3 method for class 'neuron'
prune(x, target, ...)

## S3 method for class 'dotprops'
prune(x, target, ...)

## S3 method for class 'neuronlist'
prune(x, target, ...)

## Default S3 method:
prune(x, target, maxdist, keep = c("near", "far"), return.indices = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_+3A_x">x</code></td>
<td>
<p>The object to prune. (e.g. <code>dotprops</code> object, see details)</p>
</td></tr>
<tr><td><code id="prune_+3A_target">target</code></td>
<td>
<p>Another object with 3D points that will determine which points 
in x are kept.</p>
</td></tr>
<tr><td><code id="prune_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods (eventually passed to 
<code>prune.default</code>)</p>
</td></tr>
<tr><td><code id="prune_+3A_maxdist">maxdist</code></td>
<td>
<p>The threshold distance for keeping points</p>
</td></tr>
<tr><td><code id="prune_+3A_keep">keep</code></td>
<td>
<p>Whether to keep points in x that are near or far from the target</p>
</td></tr>
<tr><td><code id="prune_+3A_return.indices">return.indices</code></td>
<td>
<p>Whether to return the indices that pass the test rather
than the 3D object/points (default <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>prune.neuron</code> depends on a more basic function 
<code><a href="#topic+prune_vertices">prune_vertices</a></code> and is also related to
<code><a href="#topic+subset.neuron">subset.neuron</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prune_strahler">prune_strahler</a></code>, <code><a href="#topic+spine">spine</a></code>,
<code><a href="#topic+prune_vertices">prune_vertices</a></code>
</p>
<p><code><a href="#topic+subset.neuron">subset.neuron</a></code>
</p>
<p><code><a href="#topic+subset.dotprops">subset.dotprops</a></code>
</p>
<p>Other neuron: 
<code><a href="#topic+neuron">neuron</a>()</code>,
<code><a href="#topic+ngraph">ngraph</a>()</code>,
<code><a href="#topic+plot.neuron">plot.neuron</a>()</code>,
<code><a href="#topic+potential_synapses">potential_synapses</a>()</code>,
<code><a href="#topic+resample">resample</a>()</code>,
<code><a href="#topic+rootpoints">rootpoints</a>()</code>,
<code><a href="#topic+spine">spine</a>()</code>,
<code><a href="#topic+subset.neuron">subset.neuron</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## prune single neurons

plot3d(kcs20[[1]],col='blue')
plot3d(kcs20[[2]],col='red')

# prune neuron 2 down to points that are close to neuron 1
neuron2_close=prune(kcs20[[2]], target=kcs20[[1]], maxdist=10)

plot3d(neuron2_close, col='cyan', lwd=3)

neuron2_far=prune(kcs20[[2]], target=kcs20[[1]], maxdist=10, keep='far')

plot3d(neuron2_far, col='magenta', lwd=3)


## Prune a neuron with a neuronlist
pruned=prune(kcs20[[11]], kcs20[setdiff(1:20, 11)], maxdist=8)

plot3d(pruned, col='red', lwd=3)
plot3d(kcs20[[11]], col='green', lwd=3)
plot3d(kcs20,col='grey')

</code></pre>

<hr>
<h2 id='prune_strahler'>Prune a neuron by removing segments with a given Strahler order</h2><span id='topic+prune_strahler'></span>

<h3>Description</h3>

<p>Prune a neuron by removing segments with a given Strahler order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune_strahler(x, orderstoprune = 1:2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_strahler_+3A_x">x</code></td>
<td>
<p>A <code>neuron</code></p>
</td></tr>
<tr><td><code id="prune_strahler_+3A_orderstoprune">orderstoprune</code></td>
<td>
<p>Integer indices of which Strahler orders to prune - 
defaults to the lowest two orders (<code>1:2</code>)</p>
</td></tr>
<tr><td><code id="prune_strahler_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+as.neuron.data.frame">as.neuron.data.frame</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pruned <code>neuron</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+strahler_order">strahler_order</a></code>, <code><a href="#topic+spine">spine</a></code>, for finding the 
longest path in a neuron, <code><a href="#topic+prune">prune</a></code> for subsetting 
<code>dotprops</code> style neurons by spatial proximity, 
<code><a href="#topic+as.neuron.data.frame">as.neuron.data.frame</a></code>, which is used to generate the new
neuron.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=Cell07PNs[[1]]
pruned12=prune_strahler(x)
pruned1=prune_strahler(x, 1)
plot(x)
plot(pruned1, lwd=3, col='blue', add=TRUE)
plot(pruned12, lwd=3, col='red', add=TRUE)
</code></pre>

<hr>
<h2 id='prune_vertices'>Prune selected vertices or edges from a neuron</h2><span id='topic+prune_vertices'></span><span id='topic+prune_edges'></span>

<h3>Description</h3>

<p><code>prune_vertices</code> removes vertices from a neuron
</p>
<p><code>prune_edges</code> removes edges (and any unreferenced vertices)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune_vertices(x, verticestoprune, invert = FALSE, ...)

prune_edges(x, edges, invert = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_vertices_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+neuron">neuron</a></code> to prune. This can be any object that can be 
converted by <code><a href="#topic+as.ngraph">as.ngraph</a></code> &mdash; see details.</p>
</td></tr>
<tr><td><code id="prune_vertices_+3A_verticestoprune">verticestoprune</code></td>
<td>
<p>An integer vector describing which vertices to remove.</p>
</td></tr>
<tr><td><code id="prune_vertices_+3A_invert">invert</code></td>
<td>
<p>Whether to keep vertices rather than dropping them (default 
FALSE).</p>
</td></tr>
<tr><td><code id="prune_vertices_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+as.neuron.ngraph">as.neuron.ngraph</a></code></p>
</td></tr>
<tr><td><code id="prune_vertices_+3A_edges">edges</code></td>
<td>
<p>The edges to remove. One of i) an Nx2 matrix, each row
specifying a single edge defined by its <b>raw</b> edge id, ii) an integer
vector defining a <em>path</em> of raw vertex ids or iii) an <code>igraph.es</code>
edge sequence &mdash; see detaiuls and the <code>P</code> and <code>path</code> arguments
of <code>igraph::<a href="igraph.html#topic+E">E</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are relatively low-level functions and you will probably want 
to use <code><a href="#topic+subset.neuron">subset.neuron</a></code> or <code><a href="#topic+prune.neuron">prune.neuron</a></code> and 
friends in many cases.
</p>
<p>Note that <code>prune_vertices</code> and <code>prune_edges</code> both use <b>raw</b> 
vertex ids to specify the vertices/edges to be removed. If you want to use 
the id in the PointNo field, then you must translate yourself (see 
examples).
</p>
<p>Both <code>prune_vertices</code> and <code>prune_edges</code> first convert their input
<code>x</code> to the <code><a href="#topic+ngraph">ngraph</a></code> representation of the neuron befor 
removing points. The input <code>x</code> can therefore be in any form compatible
with <code><a href="#topic+as.ngraph">as.ngraph</a></code> including an existing <code>ngraph</code>. There is 
an additional requirement that the input must be compatible with 
<code><a href="#topic+xyzmatrix">xyzmatrix</a></code> if <code>invert=TRUE</code>.
</p>
<p>Note that the <code>edges</code> argument of <code>prune_edges</code> must specify a 
path traversing a set of vertices in a valid order. However if the input is
a matrix or vector the direction of each individual edge in this path is
ignored. So if your neuron has edges 2-&gt;1 2-&gt;3 3-&gt;4 then an edge sequence
1:3 would successfully delete 2 edges.
</p>


<h3>Value</h3>

<p>A pruned <code>neuron</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.neuron.ngraph">as.neuron.ngraph</a></code>, <code><a href="#topic+subset.neuron">subset.neuron</a></code>, 
<code><a href="#topic+prune.neuron">prune.neuron</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=prune_vertices(Cell07PNs[[1]], 1:25)
# original neuron
plot(Cell07PNs[[1]])
# with pruned neuron superimposed
plot(n, col='green', lwd=3, add=TRUE)

# use the PointNo field (= the original id from an SWC file)
n2=prune_vertices(n, match(26:30, n$d$PointNo))
y=prune_edges(Cell07PNs[[1]], edges=1:25)

# remove the spine of a neuron
spine_ids=spine(Cell07PNs[[1]], rval='ids')
pruned=prune_edges(Cell07PNs[[1]], spine_ids)

# NB this is subtly different from this, which removes vertices along the
# spine *even* if they are part of an edge that is outside the spine.
pruned2=prune_vertices(Cell07PNs[[1]], spine_ids)
</code></pre>

<hr>
<h2 id='read.amiramesh'>Read AmiraMesh data in binary or ascii format</h2><span id='topic+read.amiramesh'></span><span id='topic+read.amiramesh.header'></span>

<h3>Description</h3>

<p>Read AmiraMesh data in binary or ascii format
</p>
<p>Read the header of an amiramesh file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.amiramesh(
  file,
  sections = NULL,
  header = FALSE,
  simplify = TRUE,
  endian = NULL,
  ReadByteAsRaw = FALSE,
  Verbose = FALSE
)

read.amiramesh.header(file, Parse = TRUE, Verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.amiramesh_+3A_file">file</code></td>
<td>
<p>Name of file (or connection) to read</p>
</td></tr>
<tr><td><code id="read.amiramesh_+3A_sections">sections</code></td>
<td>
<p>character vector containing names of sections</p>
</td></tr>
<tr><td><code id="read.amiramesh_+3A_header">header</code></td>
<td>
<p>Whether to include the full unprocessesd text header as an 
attribute of the returned list.</p>
</td></tr>
<tr><td><code id="read.amiramesh_+3A_simplify">simplify</code></td>
<td>
<p>If there is only one datablock in file do not return wrapped 
in a list (default TRUE).</p>
</td></tr>
<tr><td><code id="read.amiramesh_+3A_endian">endian</code></td>
<td>
<p>Whether multibyte data types should be treated as big or little
endian. Default of NULL checks file or uses <code>.Platform$endian</code></p>
</td></tr>
<tr><td><code id="read.amiramesh_+3A_readbyteasraw">ReadByteAsRaw</code></td>
<td>
<p>Logical specifying whether to read 8 bit data as an R 
<code>raw</code> vector rather than <code>integer</code> vector (default: FALSE).</p>
</td></tr>
<tr><td><code id="read.amiramesh_+3A_verbose">Verbose</code></td>
<td>
<p>Print status messages</p>
</td></tr>
<tr><td><code id="read.amiramesh_+3A_parse">Parse</code></td>
<td>
<p>Logical indicating whether to parse header (default: TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>reading byte data as raw arrays requires 1/4 memory but complicates
arithmetic.
</p>
<p><code>read.amiramesh.header</code> will open a connection if file is a 
character vector and close it when finished reading.
</p>


<h3>Value</h3>

<p>list of named data chunks
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+readBin">readBin</a>, <a href="base.html#topic+.Platform">.Platform</a></code>
</p>
<p>Other amira: 
<code><a href="#topic+amiratype">amiratype</a>()</code>,
<code><a href="#topic+is.amiramesh">is.amiramesh</a>()</code>,
<code><a href="#topic+read.hxsurf">read.hxsurf</a>()</code>,
<code><a href="#topic+write.hxsurf">write.hxsurf</a>()</code>
</p>

<hr>
<h2 id='read.cmtk'>Read CMTK TypedStream file to a list in memory</h2><span id='topic+read.cmtk'></span>

<h3>Description</h3>

<p>This function is primarily of developer interest. End users will typically 
want to use more specialised functions for reading registrations and 
landmarks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.cmtk(con, CheckLabel = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.cmtk_+3A_con">con</code></td>
<td>
<p>Path to (optionally gzipped) file or (open) connection.</p>
</td></tr>
<tr><td><code id="read.cmtk_+3A_checklabel">CheckLabel</code></td>
<td>
<p>Check, fix and warn for invalid or duplicate labels 
(default TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the default format used by CMTK for registration, studylist,
landmarks and image files. Although this is largely a generic function, 
there is special handling of the coefficients and active members of the 
spline warp component of a CMTK nonrigid registrartion.
</p>
<p>Note that if an open connection is passed to read.cmtk the version 
number of the CMTK TypedStream will not be checked or recorded.
</p>


<h3>See Also</h3>

<p>Other cmtk-io: 
<code><a href="#topic+cmtk.extract_affine">cmtk.extract_affine</a>()</code>,
<code><a href="#topic+read.cmtkreg">read.cmtkreg</a>()</code>,
<code><a href="#topic+write.cmtkreg">write.cmtkreg</a>()</code>,
<code><a href="#topic+write.cmtk">write.cmtk</a>()</code>
</p>

<hr>
<h2 id='read.cmtkreg'>Read a CMTK format registration</h2><span id='topic+read.cmtkreg'></span>

<h3>Description</h3>

<p>Read a CMTK format registration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.cmtkreg(filename, ReturnRegistrationOnly = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.cmtkreg_+3A_filename">filename</code></td>
<td>
<p>Path to a CMTK registration file</p>
</td></tr>
<tr><td><code id="read.cmtkreg_+3A_returnregistrationonly">ReturnRegistrationOnly</code></td>
<td>
<p>When FALSE (default) will not attempt to 
extract the registration element from the registration file.</p>
</td></tr>
<tr><td><code id="read.cmtkreg_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to read.cmtk</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cmtk-io: 
<code><a href="#topic+cmtk.extract_affine">cmtk.extract_affine</a>()</code>,
<code><a href="#topic+read.cmtk">read.cmtk</a>()</code>,
<code><a href="#topic+write.cmtkreg">write.cmtkreg</a>()</code>,
<code><a href="#topic+write.cmtk">write.cmtk</a>()</code>
</p>

<hr>
<h2 id='read.hxsurf'>Read Amira surface (aka HxSurface or HyperSurface) files into hxsurf object</h2><span id='topic+read.hxsurf'></span><span id='topic+hxsurf'></span>

<h3>Description</h3>

<p>Read Amira surface (aka HxSurface or HyperSurface) files into hxsurf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.hxsurf(
  filename,
  RegionNames = NULL,
  RegionChoice = "both",
  FallbackRegionCol = "grey",
  Verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.hxsurf_+3A_filename">filename</code></td>
<td>
<p>Character vector defining path to file</p>
</td></tr>
<tr><td><code id="read.hxsurf_+3A_regionnames">RegionNames</code></td>
<td>
<p>Character vector specifying which regions should be read 
from file. Default value of <code>NULL</code> =&gt; all regions.</p>
</td></tr>
<tr><td><code id="read.hxsurf_+3A_regionchoice">RegionChoice</code></td>
<td>
<p>Whether the <em>Inner</em> or <em>Outer</em> material, or 
<em>both</em> (default), should define the material of the patch. See 
details.</p>
</td></tr>
<tr><td><code id="read.hxsurf_+3A_fallbackregioncol">FallbackRegionCol</code></td>
<td>
<p>Colour to set regions when no colour is defined</p>
</td></tr>
<tr><td><code id="read.hxsurf_+3A_verbose">Verbose</code></td>
<td>
<p>Print status messages during parsing when <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that when <code>RegionChoice="both"</code> or 
<code>RegionChoice=c("Inner", "Outer")</code> both polygons in inner and outer 
regions will be added to named regions. To understand the significance of 
this, consider two adjacent regions, A and B, with a shared surface. For 
the polygons in both A and B, Amira will have a patch with (say) 
InnerRegion A and OuterRegion B. This avoids duplication in the file. 
However, it might be convenient to add these polygons to both regions when 
we read them into R, so that regions A and B in our R object are both 
closed surfaces. To achieve this when <code>RegionChoice="both"</code>, 
<code>read.hxsurf</code> adds these polygons to region B (as well as region A) 
but swaps the order of the vertices defining the polygon to ensure that the
surface directionality is correct.
</p>
<p>As a rule of thumb, stick with <code>RegionChoice="both"</code>. If you get more 
regions than you wanted, then try switching to <code>RegionChoice="Inner"</code>
or <code>RegionChoice="Outer"</code>.
</p>


<h3>Value</h3>

<p>A list with S3 class hxsurf with elements </p>

<dl>
<dt>Vertices</dt><dd><p> A data.frame with columns <code>X, Y, Z, PointNo</code></p>
</dd>
<dt>Regions</dt><dd><p> A list with 3 column data.frames specifying triplets of 
vertices for each region (with reference to <code>PointNo</code> column in 
<code>Vertices</code> element)</p>
</dd>
<dt>RegionList</dt><dd><p> Character vector of region names (should match names of 
<code>Regions</code> element)</p>
</dd>
<dt>RegionColourList</dt><dd><p> Character vector specifying default colour to plot
each region in R's <code><a href="grDevices.html#topic+rgb">rgb</a></code> format</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+plot3d.hxsurf">plot3d.hxsurf</a>, <a href="grDevices.html#topic+rgb">rgb</a></code>
</p>
<p>Other amira: 
<code><a href="#topic+amiratype">amiratype</a>()</code>,
<code><a href="#topic+is.amiramesh">is.amiramesh</a>()</code>,
<code><a href="#topic+read.amiramesh">read.amiramesh</a>()</code>,
<code><a href="#topic+write.hxsurf">write.hxsurf</a>()</code>
</p>
<p>Other hxsurf: 
<code><a href="#topic+as.hxsurf">as.hxsurf</a>()</code>,
<code><a href="#topic+as.mesh3d">as.mesh3d</a>()</code>,
<code><a href="#topic+materials">materials</a>()</code>,
<code><a href="#topic+plot3d.hxsurf">plot3d.hxsurf</a>()</code>,
<code><a href="#topic+subset.hxsurf">subset.hxsurf</a>()</code>,
<code><a href="#topic+write.hxsurf">write.hxsurf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
read.hxsurf("my.surf", RegionChoice="both")

## End(Not run)
</code></pre>

<hr>
<h2 id='read.landmarks'>Generic functions to read/write landmarks in any supported format</h2><span id='topic+read.landmarks'></span><span id='topic+write.landmarks'></span>

<h3>Description</h3>

<p>Generic functions to read/write landmarks in any supported format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.landmarks(f, ...)

write.landmarks(
  x,
  file,
  format = "amiralandmarks",
  ext = NULL,
  Force = FALSE,
  MakeDir = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.landmarks_+3A_f">f</code></td>
<td>
<p>Path to a file (can also be a URL)</p>
</td></tr>
<tr><td><code id="read.landmarks_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to format specific functions</p>
</td></tr>
<tr><td><code id="read.landmarks_+3A_x">x</code></td>
<td>
<p>The landmarks object to write. Can also be a plain <code>matrix</code> or 
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="read.landmarks_+3A_file">file</code></td>
<td>
<p>The path to the output file. If this does not end in an extension
like <code>.landmarksAscii</code>, then one will be added based on the value of 
the <code>ext</code> argument.</p>
</td></tr>
<tr><td><code id="read.landmarks_+3A_format">format</code></td>
<td>
<p>Character vector specifying output format. Defaults to 
<code>"amiralandmarks"</code>. Partial matching is used (e.g. amira is
sufficient).</p>
</td></tr>
<tr><td><code id="read.landmarks_+3A_ext">ext</code></td>
<td>
<p>Optional character vector specifying a new or non-standard 
extension to use for output file, including the period (e.g. 
<code>ext='.am'</code>). When <code>ext=NULL</code>, the default, the default extension
for the selected <code>format</code> will be added if <code>f</code> does not have an 
extension. When <code>ext=NA</code>, the extension will not be modified and no 
extension will be appended if <code>f</code> does not have one.</p>
</td></tr>
<tr><td><code id="read.landmarks_+3A_force">Force</code></td>
<td>
<p>Whether to overwrite an existing file</p>
</td></tr>
<tr><td><code id="read.landmarks_+3A_makedir">MakeDir</code></td>
<td>
<p>Whether to create directory implied by <code>file</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Presently the supported formats are </p>

<ul>
<li><p> Amira
</p>
</li>
<li><p> CMTK
</p>
</li>
<li><p> Fiji (see <a href="https://imagej.net/plugins/name-landmarks-and-register">https://imagej.net/plugins/name-landmarks-and-register</a>) </p>
</li></ul>

<p>See examples section for how to produce a listing of all currently 
available formats with <code>fileformats</code>.
</p>


<h3>Value</h3>

<p>for <code>read.landmarks</code> a matrix or list of additional class 
landmarks, where the rownames specify the names of each landmark if 
available.
</p>
<p>For <code>write.landmarks</code> the path to the written file, invisibly.
</p>


<h3>Paired landmarks</h3>

<p>Only the amiralandmarks format supports the use of
paired landmarks
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fileformats">fileformats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Listing of supported fileformats for landmarks
fileformats(class = 'landmarks', rval = "info")

## round trip tests
m=matrix(rnorm(6), ncol=3)
rownames(m)=c("nose", "ear")
f=write.landmarks(m, file='knee', format='cmtk')
read.landmarks(f)

# write in amira format which does not support named landmarks
f2=write.landmarks(m, file='knee', format='amira')
read.landmarks(f2)

# clean up
unlink(c(f,f2))
</code></pre>

<hr>
<h2 id='read.morphml'>Return parsed XML or R list versions of a NeuroML file</h2><span id='topic+read.morphml'></span>

<h3>Description</h3>

<p><code>read.morphml</code> is designed to expose the full details of 
the morphology information in a NeuroML file either as a parsed XML 
structure processed by the <code>XML</code> package <em>or</em> as an extensively 
processed R list object. To obtain a <code><a href="#topic+neuron">neuron</a></code> object use 
<code>read.neuron.neuroml</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.morphml(f, ..., ReturnXML = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.morphml_+3A_f">f</code></td>
<td>
<p>Path to a file on disk or a remote URL (see 
<code><a href="XML.html#topic+xmlParse">xmlParse</a></code> for details).</p>
</td></tr>
<tr><td><code id="read.morphml_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="XML.html#topic+xmlParse">xmlParse</a></code></p>
</td></tr>
<tr><td><code id="read.morphml_+3A_returnxml">ReturnXML</code></td>
<td>
<p>Whether to return a parsed XML tree (when 
<code>ReturnXML=TRUE</code>) or a more extensively processed R list object when 
<code>ReturnXML=FALSE</code>, the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NeuroML files consist of an XML tree containing one more or more 
<b>cells</b>. Each <b>cell</b> contains a tree of <b>segments</b> defining 
the basic connectivity/position and an optional tree <b>cables</b> defining
attributes on groups of <b>segments</b> (e.g. a name, whether they are 
axon/dendrite/soma etc).
</p>
<p><code>read.morphml</code> will either provide the parsed XML tree which you can 
query using XPath statements or a more heavily processed version which 
provides as much information as possible from the segments and cables trees
in two R data.frames. The latter option will inevitably drop some 
information, but will probably be more convenient for most purposes.
</p>


<h3>Value</h3>

<p>Either an R list of S3 class containing one <code>morphml_cell</code> 
object for every cell in the NeuroML document or an object of class 
<code>XMLDocument</code> when <code>ReturnXML=TRUE</code>.
</p>


<h3>References</h3>

<p><a href="https://neuroml.org/">https://neuroml.org/</a>
</p>


<h3>See Also</h3>

<p><code>link[XML]{xmlParse}</code>, <code><a href="#topic+read.neuron.neuroml">read.neuron.neuroml</a></code>
</p>

<hr>
<h2 id='read.neuron'>Read a single neuron from a file</h2><span id='topic+read.neuron'></span>

<h3>Description</h3>

<p>Read a single neuron from a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.neuron(f, format = NULL, class = c("neuron", "ngraph"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.neuron_+3A_f">f</code></td>
<td>
<p>Path to file. This can be a URL, in which case the file is
downloaded to a temporary location before reading.</p>
</td></tr>
<tr><td><code id="read.neuron_+3A_format">format</code></td>
<td>
<p>The file format of the neuron. When <code>format=NULL</code>, the
default, <code>read.neuron</code> will infer the file format from the extension
or file header (aka magic) using the <code>fileformats</code> registry.</p>
</td></tr>
<tr><td><code id="read.neuron_+3A_class">class</code></td>
<td>
<p>The class of the returned object - presently either
<code>"neuron"</code> or <code>"ngraph"</code></p>
</td></tr>
<tr><td><code id="read.neuron_+3A_...">...</code></td>
<td>
<p>additional arguments passed to format-specific readers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will handle <code>neuron</code> and <code>dotprops</code> objects
saved in R .rds or .rda format by default. Additional file formats can be
registered using <code>fileformats</code>.
</p>
<p>At the moment the following formats are supported using file readers
already included with the nat package: </p>

<ul>
<li> <p><b>swc</b> See <code><a href="#topic+read.neuron.swc">read.neuron.swc</a></code>. SWC files can also
return an <code><a href="#topic+ngraph">ngraph</a></code> object containing the neuron structure in a
(permissive) general graph format that also contains the 3D positions for
each vertex.
</p>
</li>
<li> <p><b>neuroml</b> See <code><a href="#topic+read.neuron.neuroml">read.neuron.neuroml</a></code>
</p>
</li>
<li> <p><b>fijitraces</b> See <code><a href="#topic+read.neuron.fiji">read.neuron.fiji</a></code>. The file format
used by the <a href="https://imagej.net/plugins/snt/">SNT</a> plugin of
Fiji/ImageJ.
</p>
</li>
<li> <p><b>hxlineset,hxskel</b> Two distinct fileformats used by Amira.
<code>hxlineset</code> is the generic one, <code>hxskel</code> is used by the
hxskeletonize extension of Schmitt and Evers (see refs).
</p>
</li>
<li> <p><b>rda,rds</b> Native R cross-platform binary formats (see
<code><a href="base.html#topic+load">load</a>, <a href="base.html#topic+readRDS">readRDS</a></code>). Note that RDS only contains a single
unnamed neuron, whereas rda contains one or more named neurons.
</p>
</li></ul>



<h3>References</h3>

<p>Schmitt, S. and Evers, J. F. and Duch, C. and Scholz, M. and
Obermayer, K. (2004). New methods for the computer-assisted 3-D
reconstruction of neurons from confocal image stacks. Neuroimage 4,
1283&ndash;98. <a href="https://doi.org/10.1016/j.neuroimage.2004.06.047">doi:10.1016/j.neuroimage.2004.06.047</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.neuron">write.neuron</a></code>, <code><a href="#topic+read.neurons">read.neurons</a></code>,
<code><a href="#topic+fileformats">fileformats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# note that we override the default NeuronName field
n=read.neuron(system.file("tests/testthat/testdata","neuron","EBT7R.CNG.swc",package='nat'),
  NeuronName="EBT7R")
# use a function to set the NeuronName field
n3=read.neuron(system.file("tests/testthat/testdata","neuron","EBT7R.CNG.swc",package='nat'),
  NeuronName=function(x) sub("\\..*","",x))
# show the currently registered file formats that we can read
fileformats(class='neuron', read=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.neuron.fiji'>Read a neuron saved by Fiji's Simple Neurite Tracer Plugin</h2><span id='topic+read.neuron.fiji'></span>

<h3>Description</h3>

<p>Read a neuron saved by Fiji's Simple Neurite Tracer Plugin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.neuron.fiji(f, ..., simplify = TRUE, Verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.neuron.fiji_+3A_f">f</code></td>
<td>
<p>Path to a file</p>
</td></tr>
<tr><td><code id="read.neuron.fiji_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="XML.html#topic+xmlParse">xmlParse</a></code>.</p>
</td></tr>
<tr><td><code id="read.neuron.fiji_+3A_simplify">simplify</code></td>
<td>
<p>Whether to return a single neuron as a <code>neuron</code> object 
rather than a <code>neuronlist</code> of length 1.</p>
</td></tr>
<tr><td><code id="read.neuron.fiji_+3A_verbose">Verbose</code></td>
<td>
<p>Whether to print status messages during parsing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an XML based format so parsing it depends on installation of
the suggested XML package.
</p>


<h3>References</h3>

<p><a href="https://imagej.net/plugins/snt/">https://imagej.net/plugins/snt/</a> 
<a href="https://imagej.net/plugins/snt/extending">https://imagej.net/plugins/snt/extending</a>
</p>

<hr>
<h2 id='read.neuron.neuroml'>Read one or more neurons from a NeuroML v1 file</h2><span id='topic+read.neuron.neuroml'></span>

<h3>Description</h3>

<p>Read one or more neurons from a NeuroML v1 file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.neuron.neuroml(f, ..., AlwaysReturnNeuronList = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.neuron.neuroml_+3A_f">f</code></td>
<td>
<p>Path to a NeuroML format XML file</p>
</td></tr>
<tr><td><code id="read.neuron.neuroml_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to read.morphml (and on to 
<code><a href="XML.html#topic+xmlParse">xmlParse</a></code>)</p>
</td></tr>
<tr><td><code id="read.neuron.neuroml_+3A_alwaysreturnneuronlist">AlwaysReturnNeuronList</code></td>
<td>
<p>See <b>Value</b> section (default <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When the XML file contains only 1 cell <em>and</em> 
<code>AlwaysReturnNeuronList=FALSE</code>, a <code><a href="#topic+neuron">neuron</a></code> object, 
otherwise a <code><a href="#topic+neuronlist">neuronlist</a></code> containing one or more neurons.
</p>


<h3>References</h3>

<p><a href="https://neuroml.org/">https://neuroml.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.morphml">read.morphml</a></code>
</p>

<hr>
<h2 id='read.neuron.swc'>Read a neuron in swc file format</h2><span id='topic+read.neuron.swc'></span><span id='topic+read.ngraph.swc'></span>

<h3>Description</h3>

<p><code>read.neuron.swc</code> reads an SWC file on disk into a fully 
parsed <code><a href="#topic+neuron">neuron</a></code> representation.
</p>
<p><code>read.ngraph.swc</code> reads an SWC file on disk into the more 
generic (and forgiving) <code><a href="#topic+ngraph">ngraph</a></code> representation which provides
a bridge to the <code><a href="igraph.html#topic+igraph">igraph</a></code> library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.neuron.swc(f, ...)

read.ngraph.swc(f, weights = FALSE, directed = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.neuron.swc_+3A_f">f</code></td>
<td>
<p>path to file</p>
</td></tr>
<tr><td><code id="read.neuron.swc_+3A_...">...</code></td>
<td>
<p>Additional arguments. <code>read.neuron.swc</code> passes theseto 
<code><a href="#topic+as.neuron">as.neuron</a></code> and then on to <code><a href="#topic+neuron">neuron</a></code>. 
<code>read.neuron.swc</code> passes them to <code><a href="#topic+ngraph">ngraph</a></code>.</p>
</td></tr>
<tr><td><code id="read.neuron.swc_+3A_weights">weights</code></td>
<td>
<p>Logical value indicating whether edge weights defined by the 
3D distance between points should be added to graph (default <code>FALSE</code>) 
<em>or</em> a numeric vector of weights.</p>
</td></tr>
<tr><td><code id="read.neuron.swc_+3A_directed">directed</code></td>
<td>
<p>Whether the resultant graph should be directed (default TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions will accept SWC neurons with multiple trees and 
arbitrary point index order. However only <code>read.ngraph.swc</code> will
accept SWC files with cycles.
</p>
<p>These functions would normally be called from <code>read.neuron(s)</code> rather 
than used directly.
</p>


<h3>SWC Format</h3>

<p>According to 
<a href="http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html">http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html</a> SWC file format has a
radius not a diameter specification
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.swc">is.swc</a></code>
</p>

<hr>
<h2 id='read.neuronlistfh'>Read a local, or remote, neuronlistfh object saved to a file.</h2><span id='topic+read.neuronlistfh'></span>

<h3>Description</h3>

<p>Read a local, or remote, neuronlistfh object saved to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.neuronlistfh(file, localdir = NULL, update = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.neuronlistfh_+3A_file">file</code></td>
<td>
<p>The file path of the neuronlistfh object. Can be local, or remote
(via http or ftp).</p>
</td></tr>
<tr><td><code id="read.neuronlistfh_+3A_localdir">localdir</code></td>
<td>
<p>If the file is to be fetched from a remote location, this is 
the folder in which downloaded RDS file will be saved. The default value of
<code>NULL</code> will save to a folder in the current R sessions temporary
folder. See details.</p>
</td></tr>
<tr><td><code id="read.neuronlistfh_+3A_update">update</code></td>
<td>
<p>Whether to update local copy of neuronlistfh (default: FALSE, 
see details)</p>
</td></tr>
<tr><td><code id="read.neuronlistfh_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass to <code>download.file</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When reading a remote <code>neuronlistfh</code> object, it is downloaded 
and cached to <code>localdir</code>. If there is already a cached file at the 
appropriate location and <code>update=TRUE</code> then the md5sums are checked 
and the downloaded file will be copied on top of the original copy if they 
are different; if <code>udpate=FALSE</code>, the default, then no action will be 
taken. After downloading a remote <code>neuronlistfh</code> object, a check is 
made for the existence of the <code>data</code> directory that will be used to 
individual objects. If this does not exist it will be created.
</p>
<p>Note also that there is a <em>strict convention</em> for the layout of the 
files on disk. The neuronlistfh object will be saved in R's <code>RDS</code> 
format and will be placed next to a folder called <code>data</code> which will 
contain the data objects, also saved in RDS format. For example if 
<code>myneurons.rds</code> is downloaded to 
<code>localdir="\path\to\localdir"</code> the resultant file layout will be as
follows:
</p>

<ul>
<li> <p><code>\path\to\localdir\myneurons.rds</code>
</p>
</li>
<li> <p><code>\path\to\localdir\data\2f88e16c4f21bfcb290b2a8288c05bd0</code>
</p>
</li>
<li> <p><code>\path\to\localdir\data\5b58e040ee35f3bcc6023fb7836c842e</code>
</p>
</li>
<li> <p><code>\path\to\localdir\data\... etc</code>
</p>
</li></ul>

<p>Given this arrangment, the data directory should always be at a fixed 
location with respect to the saved neuronlistfh object and this is enforced
on download and the default behaviour on read and write. However it does 
remain possible (if not recommended) to site the neuronlistfh and filehash 
database directory in different relative locations; if the neuronlistfh 
object specified by file does not have a filehash database with a valid 
<code>dir</code> slot and there is no 'data' directory adjacent to the 
neuronlistfh object, an error will result.
</p>


<h3>See Also</h3>

<p>Other neuronlistfh: 
<code><a href="#topic++5B.neuronlistfh">[.neuronlistfh</a>()</code>,
<code><a href="#topic+neuronlistfh">neuronlistfh</a>()</code>,
<code><a href="#topic+remotesync">remotesync</a>()</code>,
<code><a href="#topic+write.neuronlistfh">write.neuronlistfh</a>()</code>
</p>

<hr>
<h2 id='read.neurons'>Read one or more neurons from file to a neuronlist in memory</h2><span id='topic+read.neurons'></span>

<h3>Description</h3>

<p>Read one or more neurons from file to a neuronlist in memory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.neurons(
  paths,
  pattern = NULL,
  neuronnames = basename,
  format = NULL,
  nl = NULL,
  df = NULL,
  OmitFailures = TRUE,
  SortOnUpdate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.neurons_+3A_paths">paths</code></td>
<td>
<p>Paths to neuron input files <em>or</em> a directory containing 
neurons <em>or</em> a <code><a href="#topic+neuronlistfh">neuronlistfh</a></code> object, <em>or</em> a zip 
archive containing multiple neurons.</p>
</td></tr>
<tr><td><code id="read.neurons_+3A_pattern">pattern</code></td>
<td>
<p>If paths is a directory, <code><a href="base.html#topic+regex">regex</a></code> that file 
names must match.</p>
</td></tr>
<tr><td><code id="read.neurons_+3A_neuronnames">neuronnames</code></td>
<td>
<p>Character vector or function that specifies neuron names. 
See details.</p>
</td></tr>
<tr><td><code id="read.neurons_+3A_format">format</code></td>
<td>
<p>File format for neuron (see <code><a href="#topic+read.neuron">read.neuron</a></code>)</p>
</td></tr>
<tr><td><code id="read.neurons_+3A_nl">nl</code></td>
<td>
<p>An existing neuronlist to be updated (see details)</p>
</td></tr>
<tr><td><code id="read.neurons_+3A_df">df</code></td>
<td>
<p>Optional data frame containing information about each neuron</p>
</td></tr>
<tr><td><code id="read.neurons_+3A_omitfailures">OmitFailures</code></td>
<td>
<p>Omit failures (when TRUE) or leave an NA value in the 
list</p>
</td></tr>
<tr><td><code id="read.neurons_+3A_sortonupdate">SortOnUpdate</code></td>
<td>
<p>When <code>nl!=NULL</code> the resultant neuronlist will be 
sorted so that neurons are ordered according to the value of the 
<code>paths</code> argument.</p>
</td></tr>
<tr><td><code id="read.neurons_+3A_...">...</code></td>
<td>
<p>Additional arguements to passed to read.neuron methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will cope with the same set of file formats offered by
<code>read.neuron</code>.
</p>
<p>If the <code>paths</code> argument specifies a (single) directory then all files 
in that directory will be read unless an optional regex pattern is also 
specified. Similarly, if <code>paths</code> specifies a zip archive, all neurons 
within the archive will be loaded.
</p>
<p><code>neuronnames</code> must specify a unique set of names that will be used as 
the names of the neurons in the resultant neuronlist. If <code>neuronnames</code>
is a a function then this will be applied to the path to each neuron. The 
default value is the function <code>basename</code> which results in each neuron 
being named for the input file from which it was read.
</p>
<p>The optional dataframe (<code>df</code>) detailing each neuron should have 
<code>rownames</code> that match the names of each neuron. It would also make 
sense if the same key was present in a column of the data frame. If the 
dataframe contains more rows than neurons, the superfluous rows are dropped
with a warning. If the dataframe is missing rows for some neurons an error 
is generated. If SortOnUpdate is TRUE then updating an existing neuronlist 
should result in a new neuronlist with ordering identical to reading all 
neurons from scratch.
</p>


<h3>Value</h3>

<p><code><a href="#topic+neuronlist">neuronlist</a></code> object containing the neurons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.neuron">read.neuron</a></code>, <code><a href="#topic+write.neurons">write.neurons</a></code>,
<code><a href="#topic+fileformats">fileformats</a></code>
</p>
<p>Other neuronlist: 
<code><a href="#topic++2A.neuronlist">*.neuronlist</a>()</code>,
<code><a href="#topic+is.neuronlist">is.neuronlist</a>()</code>,
<code><a href="#topic+neuronlist-dataframe-methods">neuronlist-dataframe-methods</a></code>,
<code><a href="#topic+neuronlistfh">neuronlistfh</a>()</code>,
<code><a href="#topic+neuronlist">neuronlist</a>()</code>,
<code><a href="#topic+nlapply">nlapply</a>()</code>,
<code><a href="#topic+write.neurons">write.neurons</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Read C. elegans neurons from OpenWorm github repository
vds=paste0("VD", 1:13)
vdurls=paste0("https://raw.githubusercontent.com/openworm/CElegansNeuroML/",
  "103d500e066125688aa7ac5eac7e9b2bb4490561/CElegans/generatedNeuroML/",vds,
  ".morph.xml")
vdnl=read.neurons(vdurls, neuronnames=vds)
plot3d(vdnl)

## The same, but this time add some metadata to neuronlist
# fetch table of worm neurons from wormbase
library(rvest)
nlurl="http://wormatlas.org/neurons/Individual%20Neurons/Neuronframeset.html"
wormneurons = html_table(html(nlurl), fill=TRUE)[[4]]
vddf=subset(wormneurons, Neuron%in%vds)
rownames(vddf)=vddf$Neuron
# attach metadata to neuronlist
vdnl=read.neurons(vdurls, neuronnames=vds, df=vddf)
# use metadata to plot a subset of neurons
clear3d()
plot3d(vdnl, grepl("P[1-6].app", Lineage))

## End(Not run)
</code></pre>

<hr>
<h2 id='read.nrrd'>Read nrrd file into an array in memory</h2><span id='topic+read.nrrd'></span><span id='topic+read.nrrd.header'></span>

<h3>Description</h3>

<p>Read nrrd file into an array in memory
</p>
<p>Read the (text) header of a NRRD format file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.nrrd(
  file,
  origin = NULL,
  ReadData = TRUE,
  AttachFullHeader = TRUE,
  Verbose = FALSE,
  ReadByteAsRaw = c("unsigned", "all", "none")
)

read.nrrd.header(file, Verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.nrrd_+3A_file">file</code></td>
<td>
<p>Path to a nrrd (or a connection for <code>read.nrrd.header</code>)</p>
</td></tr>
<tr><td><code id="read.nrrd_+3A_origin">origin</code></td>
<td>
<p>Add a user specified origin (x,y,z) to the returned object</p>
</td></tr>
<tr><td><code id="read.nrrd_+3A_readdata">ReadData</code></td>
<td>
<p>When FALSE just return attributes (i.e. the nrrd header)</p>
</td></tr>
<tr><td><code id="read.nrrd_+3A_attachfullheader">AttachFullHeader</code></td>
<td>
<p>Include the full nrrd header as an attribute of the 
returned object (default TRUE)</p>
</td></tr>
<tr><td><code id="read.nrrd_+3A_verbose">Verbose</code></td>
<td>
<p>Status messages while reading</p>
</td></tr>
<tr><td><code id="read.nrrd_+3A_readbyteasraw">ReadByteAsRaw</code></td>
<td>
<p>Either a character vector or a logical vector specifying
when R should read 8 bit data as an R <code>raw</code> vector rather than 
<code>integer</code> vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.nrrd</code> reads data into a raw array. If you wish to 
generate a <code><a href="#topic+im3d">im3d</a></code> object that includes spatial calibration (but
is limited to representing 3D data) then you should use
<code><a href="#topic+read.im3d">read.im3d</a></code>.
</p>
<p>ReadByteAsRaw=unsigned (the default) only reads unsigned byte data as a raw
array. This saves quite a bit of space and still allows data to be used for
logical indexing.
</p>


<h3>Value</h3>

<p>An <code>array</code> object, optionally with attributes from the nrrd 
header.
</p>
<p>A list with elements for the key nrrd header fields
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.nrrd">write.nrrd</a></code>, <code><a href="#topic+read.im3d">read.im3d</a></code>
</p>

<hr>
<h2 id='read.vaa3draw'>Read Vaa3d format image data</h2><span id='topic+read.vaa3draw'></span>

<h3>Description</h3>

<p>Read Vaa3d format image data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.vaa3draw(f, ReadData = TRUE, Verbose = FALSE, ReadByteAsRaw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.vaa3draw_+3A_f">f</code></td>
<td>
<p>Path to image to read</p>
</td></tr>
<tr><td><code id="read.vaa3draw_+3A_readdata">ReadData</code></td>
<td>
<p>Whether to read in data or just parse header</p>
</td></tr>
<tr><td><code id="read.vaa3draw_+3A_verbose">Verbose</code></td>
<td>
<p>Whether to print status messages</p>
</td></tr>
<tr><td><code id="read.vaa3draw_+3A_readbyteasraw">ReadByteAsRaw</code></td>
<td>
<p>Can reduce memory footprint by reading 8 bit data as a 
raw rather than 4 byte interegers.</p>
</td></tr>
</table>

<hr>
<h2 id='reglist'>A simple wrapper class for multiple transformations</h2><span id='topic+reglist'></span><span id='topic+invert_reglist'></span><span id='topic+c.reglist'></span>

<h3>Description</h3>

<p>A <code>reglist</code> is read as a set of transformations to be 
applied sequentially starting with the first element, then applying the 
second transformation to the result of the first and so on. Each individual
transformation is considered to map data from the sample (floating/moving) 
space to the reference (fixed/template) space.
</p>
<p>Each transformation may have an attribute <code>"swap"</code> indicating that the
natural direction of the transformation should be swapped (i.e. inverted). 
This can be done trivially in the case of affine transformations, 
expensively for others such as CMTK registrations (see 
<code><a href="#topic+cmtkreg">cmtkreg</a></code>) and not at all for others. Note that the term 'swap'
is used to avoid a direct equivalence with inversion - many registration 
tools use the term <em>inverse</em> for directions that one might naively 
think of as as the natural direction of the transformation (see 
<code><a href="#topic+xformpoints.cmtkreg">xformpoints.cmtkreg</a></code> for discussion).
</p>
<p><code>invert_reglist</code> inverts a reglist object
</p>
<p><code>c.reglist</code> combines multiple <code>reglist</code>s into a single
<code>reglist</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reglist(..., swap = NULL)

invert_reglist(x)

## S3 method for class 'reglist'
c(..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reglist_+3A_...">...</code></td>
<td>
<p>One or more transformations/reglists to combine</p>
</td></tr>
<tr><td><code id="reglist_+3A_swap">swap</code></td>
<td>
<p>A vector of the same length as <code>...</code> indicating whether the 
direction of each transformation should be swapped (i.e. mapping reference 
-&gt; sample).</p>
</td></tr>
<tr><td><code id="reglist_+3A_x">x</code></td>
<td>
<p>A reglist object to invert</p>
</td></tr>
<tr><td><code id="reglist_+3A_recursive">recursive</code></td>
<td>
<p>Presently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The swap argument is provided as a convenience, but an attribute
<code>'swap'</code> can also be set directly on each registration.
</p>


<h3>Inversion</h3>

<p><code>invert_reglist</code> takes a minimal approach to 
inversion. It reverses the order of the individual elements of the 
registration and tags each of them with a swap attribute (or changes the
value of the attribute if it already exists)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xform">xform</a></code>
</p>
<p><code><a href="base.html#topic+c">c</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>I=diag(4)
S=I
diag(S)=c(1, 2, 3, 1)
rl=reglist(S, I)
rli=invert_reglist(rl)

## We can check the inversion by simplifying
m=simplify_reglist(rl)[[1]]
mi=simplify_reglist(rli)[[1]]
# NB solve will invert a homogeneous affine matrix
all.equal(m, solve(mi))
I=diag(4)
S=I
diag(S)=c(1, 2, 3, 1)
rl=reglist(S, I)
rl2=c(rl, 'path/to/my/reg.list')
rl3=c(reglist('path/to/my/reg.list'), rl)
</code></pre>

<hr>
<h2 id='remotesync'>Synchronise a remote object</h2><span id='topic+remotesync'></span><span id='topic+remotesync.neuronlistfh'></span>

<h3>Description</h3>

<p>Synchronise a remote object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remotesync(
  x,
  remote = attr(x, "remote"),
  download.missing = TRUE,
  delete.extra = FALSE,
  ...
)

## S3 method for class 'neuronlistfh'
remotesync(
  x,
  remote = attr(x, "remote"),
  download.missing = FALSE,
  delete.extra = FALSE,
  indices = NULL,
  update.object = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remotesync_+3A_x">x</code></td>
<td>
<p>Object to synchronise with a remote URL</p>
</td></tr>
<tr><td><code id="remotesync_+3A_remote">remote</code></td>
<td>
<p>The remote URL to update from</p>
</td></tr>
<tr><td><code id="remotesync_+3A_download.missing">download.missing</code></td>
<td>
<p>Whether to download missing objects (default TRUE)</p>
</td></tr>
<tr><td><code id="remotesync_+3A_delete.extra">delete.extra</code></td>
<td>
<p>Whether to delete objects (default TRUE)</p>
</td></tr>
<tr><td><code id="remotesync_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="remotesync_+3A_indices">indices</code></td>
<td>
<p>Character vector naming neurons to update (default
<code>indices=NULL</code> implies all neurons).</p>
</td></tr>
<tr><td><code id="remotesync_+3A_update.object">update.object</code></td>
<td>
<p>Whether to update the <code>neuronlistfh</code> object itself 
on disk (default TRUE). Note that this assumes that the <code>neuronlistfh</code>
object has not been renamed after it was downloaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>neuronlistfh</code> object (invisibly)
</p>


<h3>See Also</h3>

<p>Other neuronlistfh: 
<code><a href="#topic++5B.neuronlistfh">[.neuronlistfh</a>()</code>,
<code><a href="#topic+neuronlistfh">neuronlistfh</a>()</code>,
<code><a href="#topic+read.neuronlistfh">read.neuronlistfh</a>()</code>,
<code><a href="#topic+write.neuronlistfh">write.neuronlistfh</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
kcs20=read.neuronlistfh('http://flybrain.mrc-lmb.cam.ac.uk/si/nblast/flycircuit/kcs20.rds')
# update object from the web
kcs20=remotesync(kcs20)
# download all neurons with significant innervation of the vertical lobe
mbvl_neurons=subset(kcs20, (MB_VL_R+MB_VL_L)&gt;200, rval='names')
kcs20=remotesync(kcs20, indices=mbvl_neurons, download.missing=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='resample'>Resample an object with a new spacing</h2><span id='topic+resample'></span><span id='topic+resample.neuron'></span>

<h3>Description</h3>

<p>Resample an object with a new spacing
</p>
<p>resample a neuron with a new spacing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(x, ...)

## S3 method for class 'neuron'
resample(x, stepsize, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p>An object to resample</p>
</td></tr>
<tr><td><code id="resample_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="resample_+3A_stepsize">stepsize</code></td>
<td>
<p>The new spacing along the tracing</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>resample.neuron</code> Floating point columns including X,Y,Z,W will
be interpolated using linear interpolation, while integer or factor columns
will be interpolated using constant interpolation. See <code><a href="stats.html#topic+approx">approx</a></code>
for details.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+approx">approx</a></code>, <code><a href="#topic+seglengths">seglengths</a></code>
</p>
<p>Other neuron: 
<code><a href="#topic+neuron">neuron</a>()</code>,
<code><a href="#topic+ngraph">ngraph</a>()</code>,
<code><a href="#topic+plot.neuron">plot.neuron</a>()</code>,
<code><a href="#topic+potential_synapses">potential_synapses</a>()</code>,
<code><a href="#topic+prune">prune</a>()</code>,
<code><a href="#topic+rootpoints">rootpoints</a>()</code>,
<code><a href="#topic+spine">spine</a>()</code>,
<code><a href="#topic+subset.neuron">subset.neuron</a>()</code>
</p>

<hr>
<h2 id='rootpoints'>Return the root or branch points of a neuron or graph</h2><span id='topic+rootpoints'></span><span id='topic+rootpoints.default'></span><span id='topic+rootpoints.neuron'></span><span id='topic+rootpoints.igraph'></span><span id='topic+branchpoints'></span><span id='topic+branchpoints.default'></span><span id='topic+branchpoints.neuron'></span><span id='topic+branchpoints.igraph'></span><span id='topic+endpoints'></span><span id='topic+endpoints.neuron'></span><span id='topic+endpoints.igraph'></span><span id='topic+endpoints.default'></span>

<h3>Description</h3>

<p>A neuron may have multiple subtrees and therefore multiple roots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rootpoints(x, ...)

## Default S3 method:
rootpoints(x, ...)

## S3 method for class 'neuron'
rootpoints(x, subtrees = 1, ...)

## S3 method for class 'igraph'
rootpoints(x, ...)

branchpoints(x, ...)

## Default S3 method:
branchpoints(x, ...)

## S3 method for class 'neuron'
branchpoints(x, subtrees = 1, ...)

## S3 method for class 'igraph'
branchpoints(x, ...)

endpoints(x, ...)

## S3 method for class 'neuron'
endpoints(x, subtrees = 1, ...)

## S3 method for class 'igraph'
endpoints(x, ...)

## Default S3 method:
endpoints(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rootpoints_+3A_x">x</code></td>
<td>
<p>Neuron or other object which might have roots</p>
</td></tr>
<tr><td><code id="rootpoints_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods</p>
</td></tr>
<tr><td><code id="rootpoints_+3A_subtrees">subtrees</code></td>
<td>
<p>Integer index of the fully connected subtree in 
<code>x$SubTrees</code>. Only applicable when a <code>neuron</code> consists of 
multiple unconnected subtrees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>branchpoints.neuron</code> returns a list if more than one subtree is
specified
</p>


<h3>Value</h3>

<p>Integer point number of root/branch point
</p>


<h3>See Also</h3>

<p>Other neuron: 
<code><a href="#topic+neuron">neuron</a>()</code>,
<code><a href="#topic+ngraph">ngraph</a>()</code>,
<code><a href="#topic+plot.neuron">plot.neuron</a>()</code>,
<code><a href="#topic+potential_synapses">potential_synapses</a>()</code>,
<code><a href="#topic+prune">prune</a>()</code>,
<code><a href="#topic+resample">resample</a>()</code>,
<code><a href="#topic+spine">spine</a>()</code>,
<code><a href="#topic+subset.neuron">subset.neuron</a>()</code>
</p>

<hr>
<h2 id='scale.neuron'>Scale and centre neuron 3D coordinates</h2><span id='topic+scale.neuron'></span><span id='topic+scale'></span><span id='topic+scale.dotprops'></span>

<h3>Description</h3>

<p>note that <code>scale.dotprops</code> recalculates the tangent vectors
after scaling the 3D coords. See <code><a href="#topic+dotprops">dotprops</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuron'
scale(x, center = TRUE, scale = TRUE)

## S3 method for class 'dotprops'
scale(x, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale.neuron_+3A_x">x</code></td>
<td>
<p>A neuron</p>
</td></tr>
<tr><td><code id="scale.neuron_+3A_center">center</code></td>
<td>
<p>3-vector to subtract from x,y,z coords</p>
</td></tr>
<tr><td><code id="scale.neuron_+3A_scale">scale</code></td>
<td>
<p>3-vector used to divide x,y,z coords</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>scale=TRUE</code>, the neuron will be rescaled to unit sd in each
axis. If <code>center=TRUE</code>, the neuron will be centred around the axis
means. See <code>base::<a href="base.html#topic+scale.default">scale.default</a></code> for additional details.
</p>


<h3>Value</h3>

<p>neuron with scaled coordinates
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale.default">scale.default</a></code>, <code><a href="#topic++2A.neuron">*.neuron</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1.scaledown=scale(Cell07PNs[[1]],scale=c(2,2,3))
n1.scaleup=scale(Cell07PNs[[1]],scale=1/c(2,2,3))
</code></pre>

<hr>
<h2 id='seglengths'>Calculate length of all segments in neuron</h2><span id='topic+seglengths'></span>

<h3>Description</h3>

<p>Calculate length of all segments in neuron
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seglengths(x, all = FALSE, flatten = TRUE, sumsegment = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seglengths_+3A_x">x</code></td>
<td>
<p>A neuron</p>
</td></tr>
<tr><td><code id="seglengths_+3A_all">all</code></td>
<td>
<p>Whether to calculate lengths for all segments when there are 
multiple subtrees (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="seglengths_+3A_flatten">flatten</code></td>
<td>
<p>Whether to flatten the lists of lists into a single list when 
<code>all=TRUE</code></p>
</td></tr>
<tr><td><code id="seglengths_+3A_sumsegment">sumsegment</code></td>
<td>
<p>Whether to return the length of each segment (when 
<code>sumsegment=TRUE</code>, the default) or a list of vectors of lengths of each
individual edge in the segment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A segment is an ubranched portion of neurite consisting of at least 
one vertex joined by edges.Only segments in x$SegList will be calculated 
unless <code>all=TRUE</code>. Segments containing only one point will have 0 
length.
</p>


<h3>Value</h3>

<p>A <code>vector</code> of lengths for each segment or when 
<code>sumsegment=FALSE</code> a <code>list</code> of vectors
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.seglist.neuron">as.seglist.neuron</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(seglengths(Cell07PNs[[1]]))
hist(unlist(seglengths(Cell07PNs[[1]], sumsegment = FALSE)),
  br=20, main='histogram of edge lengths', xlab='edge lengths /microns')
</code></pre>

<hr>
<h2 id='seglist'>Make/convert neuron connectivity information into a seglist object</h2><span id='topic+seglist'></span><span id='topic+as.seglist'></span><span id='topic+as.seglist.neuron'></span><span id='topic+as.seglist.igraph'></span>

<h3>Description</h3>

<p><code>seglist</code> makes a seglist object from a list of integer 
vectors of raw vertex ids. As a convenience if a vector of numeric ids are
passed these are assumed to specify a neuron with 1 segment.
</p>
<p><code>as.seglist.neuron</code> will extract the seglist from a neuron,
optionally extracting all subtrees (<code>all=TRUE</code>) and (in this case) 
flattening the list into a single hierarchy when <code>flatten=TRUE</code>.
n.b. when <code>all=TRUE</code> but <code>flatten=FALSE</code> the result will
<em>always</em> be a list of <code>seglist</code> objects (even if the neuron has
only one subtree i.e. is fully connected).
</p>
<p><code>as.seglist.igraph</code> will convert a fully connected acyclic 
ngraph or igraph object into a seglist consisting of exactly one subtree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seglist(...)

as.seglist(x, ...)

## S3 method for class 'neuron'
as.seglist(x, all = FALSE, flatten = FALSE, ...)

## S3 method for class 'igraph'
as.seglist(x, origin = NULL, Verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seglist_+3A_...">...</code></td>
<td>
<p>for <code>seglist</code> integer vectors to convert to a seglist</p>
</td></tr>
<tr><td><code id="seglist_+3A_x">x</code></td>
<td>
<p>object passed to be converted to seglist</p>
</td></tr>
<tr><td><code id="seglist_+3A_all">all</code></td>
<td>
<p>Whether to include segments from all subtrees</p>
</td></tr>
<tr><td><code id="seglist_+3A_flatten">flatten</code></td>
<td>
<p>When <code>all=TRUE</code> flatten the lists of lists into a 
one-level list.</p>
</td></tr>
<tr><td><code id="seglist_+3A_origin">origin</code></td>
<td>
<p>The origin of the tree (see details)</p>
</td></tr>
<tr><td><code id="seglist_+3A_verbose">Verbose</code></td>
<td>
<p>Whether to print progress updates to console (default FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="#topic+neuron">neuron</a></code> for further information about seglists.
</p>
<p>If the graph vertices have <code>vid</code> attributes, typically defining
the original vertex ids of a graph that was then decomposed into subgraphs,
then the origin is assumed to refer to one of these vids not a raw vertex 
id of the current graph. The returned seglist will also contain these 
original vertex ids.
</p>
<p>The head of the first segment in the seglist will be the origin.
</p>


<h3>Value</h3>

<p>A <code>list</code> with additional class <code>seglist</code>.
</p>
<p>a <code>list</code> with one entry for each unbranched segment.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neuron">neuron</a></code>
</p>
<p><code><a href="#topic+ngraph">ngraph</a>,<a href="igraph.html#topic+igraph">igraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sl=seglist(c(1:2),c(2:6))
</code></pre>

<hr>
<h2 id='seglist2swc'>Recalculate Neurons's SWCData using SegList and point information</h2><span id='topic+seglist2swc'></span>

<h3>Description</h3>

<p>Uses the SegList field (indices into point array) to recalculate point 
numbers and parent points for SWC data field (d).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seglist2swc(x, d, RecalculateParents = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seglist2swc_+3A_x">x</code></td>
<td>
<p>Neuron containing both the SegList and d fields or a plain seglist</p>
</td></tr>
<tr><td><code id="seglist2swc_+3A_d">d</code></td>
<td>
<p>SWC data block (only expected if x is a SegList)</p>
</td></tr>
<tr><td><code id="seglist2swc_+3A_recalculateparents">RecalculateParents</code></td>
<td>
<p>Whether to recalculate parent points (default T)</p>
</td></tr>
<tr><td><code id="seglist2swc_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+normalise_swc">normalise_swc</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If any columns are missing then they are set to default values by 
<code><a href="#topic+normalise_swc">normalise_swc</a></code>. In particular </p>

<ul>
<li><p> PointNo integer 1:npoints
</p>
</li>
<li><p> Label = 0 (unknown)
</p>
</li>
<li><p> W NA_real
</p>
</li></ul>

<p>Note that each numeric entry in the incoming SegList is a raw index into
the block of vertex data defined by <code>d</code>.
</p>


<h3>Value</h3>

<p>A neuron if x was a neuron otherwise dataframe of swc data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.neuron.data.frame">as.neuron.data.frame</a></code>, <code><a href="#topic+normalise_swc">normalise_swc</a></code>, <code><a href="#topic+neuron">neuron</a></code>
</p>

<hr>
<h2 id='segmentgraph'>Return a simplified segment graph for a neuron</h2><span id='topic+segmentgraph'></span>

<h3>Description</h3>

<p>Return a simplified segment graph for a neuron
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentgraph(
  x,
  weights = TRUE,
  segids = FALSE,
  exclude.isolated = FALSE,
  include.xyz = FALSE,
  reverse.edges = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentgraph_+3A_x">x</code></td>
<td>
<p>neuron</p>
</td></tr>
<tr><td><code id="segmentgraph_+3A_weights">weights</code></td>
<td>
<p>Whether to include the original segment lengths as edge
weights in the graph.</p>
</td></tr>
<tr><td><code id="segmentgraph_+3A_segids">segids</code></td>
<td>
<p>Whether to include the integer segment ids as an edge attribute
in the graph</p>
</td></tr>
<tr><td><code id="segmentgraph_+3A_exclude.isolated">exclude.isolated</code></td>
<td>
<p>Whether to eliminate isolated nodes</p>
</td></tr>
<tr><td><code id="segmentgraph_+3A_include.xyz">include.xyz</code></td>
<td>
<p>Whether to include 3D location as vertex attribute</p>
</td></tr>
<tr><td><code id="segmentgraph_+3A_reverse.edges">reverse.edges</code></td>
<td>
<p>Whether to reverse the direction of each edge in the 
output graph to point towards (rather than away from) the root (default 
<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resultant graph will contain all branch and endpoints of the 
original neuron. This will be constructed from the SegList field, or where 
present, the SubTrees field (containing multiple SegLists for each isolated
graph in the neuron). Each edge in the output graph will match one segment 
in the original SegList.
</p>


<h3>Value</h3>

<p><code>igraph</code> object containing only nodes of neuron keeping original
labels (<code>x$d$PointNo</code> =&gt; <code>V(g)$label</code>) and vertex indices 
(<code>1:nrow(x$d)</code> =&gt; <code>V(g)$vid)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sg=segmentgraph(Cell07PNs[[1]])
str(sg)
library(igraph)
plot(sg, edge.arrow.size=.4, vertex.size=10)
</code></pre>

<hr>
<h2 id='setdiff'>Find the (asymmetric) difference between two collections of objects</h2><span id='topic+setdiff'></span><span id='topic+setdiff.default'></span><span id='topic+setdiff.neuronlist'></span>

<h3>Description</h3>

<p>Find the (asymmetric) difference between two collections of objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setdiff(x, y, ...)

## Default S3 method:
setdiff(x, y, ...)

## S3 method for class 'neuronlist'
setdiff(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setdiff_+3A_x">x</code></td>
<td>
<p>the first collection to consider.</p>
</td></tr>
<tr><td><code id="setdiff_+3A_y">y</code></td>
<td>
<p>the second collection to consider.</p>
</td></tr>
<tr><td><code id="setdiff_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that setdiff.default calls base::setdiff to ensure consistent 
behaviour for regular vectors.
</p>
<p>As a convenience <code>setdiff.neuronlist</code> allows <code>y</code>, the second
collection, to be a character vector of names.
</p>


<h3>Value</h3>

<p>A collection of the same mode as <code>x</code> that contains all elements 
of <code>x</code> that are not present in <code>y</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+setdiff">setdiff</a></code>
</p>

<hr>
<h2 id='simplify_reglist'>Simplify a registration list</h2><span id='topic+simplify_reglist'></span>

<h3>Description</h3>

<p>Simplify a registration list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify_reglist(reg, as.cmtk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_reglist_+3A_reg">reg</code></td>
<td>
<p>A registration list (<code><a href="#topic+reglist">reglist</a></code>) containing one or more
transformations.</p>
</td></tr>
<tr><td><code id="simplify_reglist_+3A_as.cmtk">as.cmtk</code></td>
<td>
<p>Whether to convert to a vector of CMTK format registrations 
(see <code><a href="#topic+cmtkreg">cmtkreg</a></code>). The default value of <code>as.cmtk=NULL</code> 
converts all registrations to CMTK if any one registration is in CMTK 
format (thus enabling them to be applied by CMTK tools in a single call).
See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function </p>

<ul>
<li><p> inverts any affine matrices with attribute <code>"swap"</code>
</p>
</li>
<li><p> collapses multiple affine matrices into a single affine
</p>
</li>
<li><p> optionally converts all registrations to CMTK on disk registrations 
when possible.
</p>
</li></ul>

<p>Note that if any of the registrations are in CMTK format, the default 
behaviour is to try to convert all of the other registrations into CMTK 
format to enable them to be passed to CMTK in a single command. If 
<code>as.cmtk=TRUE</code> then there will be an error if this is not possible.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reglist">reglist</a></code>, <code><a href="#topic+xform">xform</a></code>, <code><a href="#topic+cmtkreg">cmtkreg</a></code>
</p>

<hr>
<h2 id='smooth_neuron'>Smooth the 3D coordinates of a neuron skeleton</h2><span id='topic+smooth_neuron'></span><span id='topic+smooth_segment_gauss'></span>

<h3>Description</h3>

<p><code>smooth_neuron</code> smooths a neuron.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_neuron(n, method = c("gauss", "spline"), ...)

smooth_segment_gauss(xyz, sigma, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_neuron_+3A_n">n</code></td>
<td>
<p>Neuron to smooth</p>
</td></tr>
<tr><td><code id="smooth_neuron_+3A_method">method</code></td>
<td>
<p>Smoothing method</p>
</td></tr>
<tr><td><code id="smooth_neuron_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to segment smoothing functions</p>
</td></tr>
<tr><td><code id="smooth_neuron_+3A_xyz">xyz</code></td>
<td>
<p>A block of 3D coordinates defining an unbranched segment</p>
</td></tr>
<tr><td><code id="smooth_neuron_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the Gaussian smoothing kernel (which
has the same spatial units as the object being smoothed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new neuron with smoothed 3d coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ns=smooth_neuron(Cell07PNs[[1]], sigma=2)
# plot in 2D zooming in on axon terminals 
plot(Cell07PNs[[1]], col='grey', xlim=c(260,290), ylim=c(115,90))
plot(ns, col='red', add=TRUE)

# 3D plot
plot3d(Cell07PNs[[1]], col='grey')
plot3d(ns, col='red')

</code></pre>

<hr>
<h2 id='spine'>Compute the longest path (aka spine or backbone) of a neuron</h2><span id='topic+spine'></span>

<h3>Description</h3>

<p>Compute the longest path (aka spine or backbone) of a neuron
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spine(
  n,
  UseStartPoint = FALSE,
  SpatialWeights = TRUE,
  invert = FALSE,
  rval = c("neuron", "length", "ids")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spine_+3A_n">n</code></td>
<td>
<p>the neuron to consider.</p>
</td></tr>
<tr><td><code id="spine_+3A_usestartpoint">UseStartPoint</code></td>
<td>
<p>Whether to use the StartPoint of the neuron (often the 
soma) as the starting point of the returned spine.</p>
</td></tr>
<tr><td><code id="spine_+3A_spatialweights">SpatialWeights</code></td>
<td>
<p>logical indicating whether spatial distances (default) 
should be used to weight segments instead of weighting each edge equally.</p>
</td></tr>
<tr><td><code id="spine_+3A_invert">invert</code></td>
<td>
<p>When <code>invert=TRUE</code> the spine is pruned away instead of 
being selected. This is only valid when <code>rval='neuron'</code> or
<code>rval='ids'</code>.</p>
</td></tr>
<tr><td><code id="spine_+3A_rval">rval</code></td>
<td>
<p>Character vector indicating the return type, one of 
<code>'neuron'</code>, <code>'length'</code> or <code>'ids'</code>. See <b>Value</b> section.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either </p>

<ul>
<li><p> a neuron object corresponding to the longest path <em>or</em>
</p>
</li>
<li><p> the length of the longest path (when <code>rval="length"</code>) <em>or</em>
</p>
</li>
<li><p> an integer vector of raw point indices (when <code>rval="ids"</code>).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="igraph.html#topic+diameter">diameter</a></code>,
<code><a href="igraph.html#topic+distances">distances</a></code>, <code><a href="#topic+prune_strahler">prune_strahler</a></code> for
removing lower order branches from a neuron, <code><a href="#topic+prune">prune</a></code> for
removing parts of a neuron by spatial criteria.
</p>
<p>Other neuron: 
<code><a href="#topic+neuron">neuron</a>()</code>,
<code><a href="#topic+ngraph">ngraph</a>()</code>,
<code><a href="#topic+plot.neuron">plot.neuron</a>()</code>,
<code><a href="#topic+potential_synapses">potential_synapses</a>()</code>,
<code><a href="#topic+prune">prune</a>()</code>,
<code><a href="#topic+resample">resample</a>()</code>,
<code><a href="#topic+rootpoints">rootpoints</a>()</code>,
<code><a href="#topic+subset.neuron">subset.neuron</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pn.spine=spine(Cell07PNs[[1]])

plot3d(Cell07PNs[[1]])
plot3d(pn.spine, lwd=4, col='black')

# just extract length
spine(Cell07PNs[[1]], rval='length')
# same result since StartPoint is included in longest path
spine(Cell07PNs[[1]], rval='length', UseStartPoint=TRUE)

# extract everything but the spine
antispine=spine(Cell07PNs[[1]], invert=TRUE)

plot3d(Cell07PNs[[1]])
plot3d(antispine, lwd=4, col='red')


</code></pre>

<hr>
<h2 id='strahler_order'>Find the Strahler order of each point in a neuron</h2><span id='topic+strahler_order'></span>

<h3>Description</h3>

<p>The Strahler order will be 1 for each tip segment and then 1 + 
the maximum of the Strahler order of each parent segment for internal 
segments. Branch points will have the Strahler order of the closest segment
to the root of which they are part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strahler_order(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strahler_order_+3A_x">x</code></td>
<td>
<p>A neuron</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is vital that the root of the neuron is valid since this 
determines the flow direction for calculation of the Strahler order. At 
present the function is not defined for neurons with multiple subtrees.
</p>
<p>Internally, this function uses <code><a href="#topic+segmentgraph">segmentgraph</a></code> to find a reduced
segmentgraph for the neuron.
</p>


<h3>Value</h3>

<p>A list containing </p>

<ul>
<li><p> points Vector of integer Strahler orders for each point in the neuron
</p>
</li>
<li><p> segments Vector of integer Strahler orders for each segment in the 
neuron </p>
</li></ul>



<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Strahler_number">https://en.wikipedia.org/wiki/Strahler_number</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prune_strahler">prune_strahler</a></code>, a <code><a href="#topic+segmentgraph">segmentgraph</a></code> (a form
of <code><a href="#topic+ngraph">ngraph</a></code>) representation is used to calculate the Strahler 
order.
</p>

<hr>
<h2 id='sub2ind'>Find 1D index given n-dimensional indices</h2><span id='topic+sub2ind'></span>

<h3>Description</h3>

<p>Emulates the MATLAB function <code>sub2ind</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub2ind(dims, indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub2ind_+3A_dims">dims</code></td>
<td>
<p>vector of dimensions of object to index into.</p>
</td></tr>
<tr><td><code id="sub2ind_+3A_indices">indices</code></td>
<td>
<p>vector of n-dimensional indices.</p>
</td></tr>
</table>

<hr>
<h2 id='subset'>Subset methods for different nat objects</h2><span id='topic+subset'></span>

<h3>Description</h3>

<p>These methods enable subsets of some nat objects including neurons and 
neuronlists to be obtained. See the help for each individual method for 
details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subset.neuron">subset.neuron</a></code>, <code><a href="#topic+subset.dotprops">subset.dotprops</a></code>,
<code><a href="#topic+subset.hxsurf">subset.hxsurf</a></code>, <code><a href="#topic+subset.neuronlist">subset.neuronlist</a></code>
</p>

<hr>
<h2 id='subset.dotprops'>Subset points in dotprops object that match given conditions</h2><span id='topic+subset.dotprops'></span>

<h3>Description</h3>

<p>Subset points in dotprops object that match given conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dotprops'
subset(x, subset, invert = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.dotprops_+3A_x">x</code></td>
<td>
<p>A dotprops object</p>
</td></tr>
<tr><td><code id="subset.dotprops_+3A_subset">subset</code></td>
<td>
<p>A subset of points defined by indices, an expression or a function (see Details)</p>
</td></tr>
<tr><td><code id="subset.dotprops_+3A_invert">invert</code></td>
<td>
<p>Whether to invert the subset criteria - a convenience when 
selecting by function or indices.</p>
</td></tr>
<tr><td><code id="subset.dotprops_+3A_...">...</code></td>
<td>
<p>Additional parameters (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>subset</code> defines either logical or numeric indices, in which
case these are simply applied to the matrices that define the <code>points</code>, <code>vect</code> fields of the <code>dotprops</code> object
etc OR a function (which is called with the 3D points array and returns T/F.
OR an expression 
vector).
</p>


<h3>Value</h3>

<p>subsetted dotprops object
</p>


<h3>See Also</h3>

<p><code>prune.dotprops</code>, <code>subset.neuron</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## subset using indices ...
dp=kcs20[[10]]
dp1=subset(dp, 1:50)

# ... or an expression
dp2=subset(dp, alpha&gt;0.7)
front=subset(dp, points[,'Z']&lt;40)
# use a helper function
between=function(x, lower, upper) x&gt;=lower &amp; x&lt;=upper
middle=middle=subset(dp, between(points[,'Z'], 40, 60))

# plot results in 3D

plot3d(front, col='red')
plot3d(middle, col='green')
plot3d(dp, col='blue')


## Not run: 

## subset using an selection function
s3d=select3d()
dp1=subset(dp, s3d(points))
# special case of previous version
dp2=subset(dp, s3d)
# keep the points that were removed from dp2
dp2.not=subset(dp, s3d, invert=TRUE)
# (another way of doing the same thing)
dp2.not=subset(dp, Negate(s3d))
stopifnot(all.equal(dp1, dp2))
dp2=subset(dp, alpha&gt;0.5 &amp; s3d(pointd))
dp3=subset(dp, 1:10)

## subset each dotprops object in a whole neuronlist
plot3d(kcs20)
s3d=select3d()
kcs20.partial = nlapply(kcs20, subset, s3d)
clear3d()
plot3d(kcs20.partial, col='red')
plot3d(kcs20, col='grey')

## End(Not run)
</code></pre>

<hr>
<h2 id='subset.hxsurf'>Subset hxsurf object to specified regions</h2><span id='topic+subset.hxsurf'></span>

<h3>Description</h3>

<p>Subset hxsurf object to specified regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hxsurf'
subset(x, subset = NULL, drop = TRUE, rval = c("hxsurf", "names"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.hxsurf_+3A_x">x</code></td>
<td>
<p>A dotprops object</p>
</td></tr>
<tr><td><code id="subset.hxsurf_+3A_subset">subset</code></td>
<td>
<p>Character vector specifying regions to keep. Interpreted as 
<code><a href="base.html#topic+regex">regex</a></code> if of length 1 and no fixed match.</p>
</td></tr>
<tr><td><code id="subset.hxsurf_+3A_drop">drop</code></td>
<td>
<p>Whether to drop unused vertices after subsetting (default:
<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="subset.hxsurf_+3A_rval">rval</code></td>
<td>
<p>Whether to return a new <code>hxsurf</code> object or just the names of
the matching regions</p>
</td></tr>
<tr><td><code id="subset.hxsurf_+3A_...">...</code></td>
<td>
<p>Additional parameters (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subsetted hxsurf object
</p>


<h3>See Also</h3>

<p>Other hxsurf: 
<code><a href="#topic+as.hxsurf">as.hxsurf</a>()</code>,
<code><a href="#topic+as.mesh3d">as.mesh3d</a>()</code>,
<code><a href="#topic+materials">materials</a>()</code>,
<code><a href="#topic+plot3d.hxsurf">plot3d.hxsurf</a>()</code>,
<code><a href="#topic+read.hxsurf">read.hxsurf</a>()</code>,
<code><a href="#topic+write.hxsurf">write.hxsurf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plot only vertical lobe
vertical_lobe=subset(MBL.surf, "VL")

plot3d(vertical_lobe, alpha=0.3)
plot3d(kcs20)

# there is also a shortcut for this
clear3d()
plot3d(MBL.surf, "VL", alpha=0.3)

</code></pre>

<hr>
<h2 id='subset.neuron'>Subset neuron by keeping only vertices that match given conditions</h2><span id='topic+subset.neuron'></span>

<h3>Description</h3>

<p>Subset neuron by keeping only vertices that match given conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuron'
subset(x, subset, invert = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.neuron_+3A_x">x</code></td>
<td>
<p>A neuron object</p>
</td></tr>
<tr><td><code id="subset.neuron_+3A_subset">subset</code></td>
<td>
<p>A subset of points defined by indices, an expression, or a 
function (see Details)</p>
</td></tr>
<tr><td><code id="subset.neuron_+3A_invert">invert</code></td>
<td>
<p>Whether to invert the subset criteria - a convenience when 
selecting by function or indices.</p>
</td></tr>
<tr><td><code id="subset.neuron_+3A_...">...</code></td>
<td>
<p>Additional parameters (passsed on to <code><a href="#topic+prune_vertices">prune_vertices</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>subset</code> defines which vertices of the neuron to keep and is 
one of </p>

<ul>
<li><p> logical or numeric indices, in which case these are simply used to 
index the vertices in the order of the data.frame <code>x$d</code>. Note that any
NA values are ignored.
</p>
</li>
<li><p> a function (which is called with the 3D points array and returns T/F 
vector)
</p>
</li>
<li><p> an expression evaluated in the context of the <code>x$d</code> data.frame 
containing the SWC specification of the points and connectivity of the 
neuron. This can therefore refer e.g. to the X,Y,Z location of vertices in 
the neuron.
</p>
</li></ul>



<h3>Value</h3>

<p>subsetted neuron
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prune.neuron">prune.neuron</a></code>, <code><a href="#topic+prune_vertices">prune_vertices</a></code>, 
<code><a href="#topic+subset.dotprops">subset.dotprops</a></code>
</p>
<p>Other neuron: 
<code><a href="#topic+neuron">neuron</a>()</code>,
<code><a href="#topic+ngraph">ngraph</a>()</code>,
<code><a href="#topic+plot.neuron">plot.neuron</a>()</code>,
<code><a href="#topic+potential_synapses">potential_synapses</a>()</code>,
<code><a href="#topic+prune">prune</a>()</code>,
<code><a href="#topic+resample">resample</a>()</code>,
<code><a href="#topic+rootpoints">rootpoints</a>()</code>,
<code><a href="#topic+spine">spine</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=Cell07PNs[[1]]
# keep vertices if their X location is &gt; 2000
n1=subset(n, X&gt;200)
# diameter of neurite &gt;1 
n2=subset(n, W&gt;1)
# first 50 nodes
n3=subset(n, 1:50)
# everything but first 50 nodes
n4=subset(n, 1:50, invert=TRUE)

## subset neuron by graph structure
# first plot neuron and show the point that we will use to divide the neuron
n=Cell07PNs[[1]]
plot(n)
# this neuron has a tag defining a point at which the neuron enters a brain
# region (AxonLHEP = Axon Lateral Horn Entry Point)
points(t(xyzmatrix(n)[n$AxonLHEP, 1:2]), pch=19, cex=2.5)

# now find the points downstream (distal) of that with respect to the root
ng=as.ngraph(n)
# use a depth first search
distal_points=igraph::dfs(ng, root=n$AxonLHEP, unreachable=FALSE,
  mode='out')$order
distal_tree=subset(n, distal_points)
plot(distal_tree, add=TRUE, col='red', lwd=2)

# Find proximal tree as well
# nb this does not include the AxonLHEP itself as defined here
proximal_points=setdiff(igraph::V(ng), distal_points)
proximal_tree=subset(n, proximal_points)
plot(proximal_tree, add=TRUE, col='blue', lwd=2)

## Not run: 
## subset using interactively defined spatial regions
plot3d(n)
# nb you can save this select3d object using save or saveRDS functions
# for future non-interactive use
s3d=select3d()
n4=subset(n, s3d(xyzmatrix(n)))
# special case of previous version
n5=subset(n, s3d)
stopifnot(all.equal(n4,n5))
# keep the points that were removed from n1
n4.not=subset(n,Negate(s3d))
# vertices with x position &gt; 100 and inside the selector function
n6=subset(n,X&gt;100 &amp; s3d(X,Y,Z))

## subset each neuron object in a whole neuronlist
n10=Cell07PNs[1:10]
plot3d(n10, lwd=0.5, col='grey')
n10.crop = nlapply(n10, subset, X&gt;250)
plot3d(n10.crop, col='red')

## subset a neuron using a surface
library(nat.flybrains)
# extract left lateral horn surface and convert to mesh3d 
lh=as.mesh3d(subset(IS2NP.surf, "LH_L"))
# subset neuron with this surface
x=subset(Cell07PNs[[1]], function(x) pointsinside(x, lh))
shade3d(lh, alpha=0.3)
plot3d(x, lwd=3, col='blue')
# Now find the parts of the neuron outside the surface
y=subset(Cell07PNs[[1]], function(x) Negate(pointsinside)(x, lh))
plot3d(y, col='red', lwd=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='subset.neuronlist'>Subset neuronlist returning either new neuronlist or names of chosen neurons</h2><span id='topic+subset.neuronlist'></span>

<h3>Description</h3>

<p>Subset neuronlist returning either new neuronlist or names of chosen neurons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuronlist'
subset(
  x,
  subset,
  filterfun,
  rval = c("neuronlist", "names", "data.frame"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.neuronlist_+3A_x">x</code></td>
<td>
<p>a neuronlist</p>
</td></tr>
<tr><td><code id="subset.neuronlist_+3A_subset">subset</code></td>
<td>
<p>An expression that can be evaluated in the context of the 
dataframe attached to the neuronlist. See details.</p>
</td></tr>
<tr><td><code id="subset.neuronlist_+3A_filterfun">filterfun</code></td>
<td>
<p>a function which can be applied to each neuron returning 
<code>TRUE</code> when that neuron should be included in the return list.</p>
</td></tr>
<tr><td><code id="subset.neuronlist_+3A_rval">rval</code></td>
<td>
<p>What to return (character vector, default='neuronlist')</p>
</td></tr>
<tr><td><code id="subset.neuronlist_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>filterfun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subset expression should evaluate to one of </p>

<ul>
<li><p> character vector of names
</p>
</li>
<li><p> logical vector
</p>
</li>
<li><p> vector of numeric indices
</p>
</li></ul>

<p>Any missing names are dropped with a warning. The <code>filterfun</code>
expression is wrapped in a try. Neurons returning an error will be dropped
with a warning.
</p>
<p>You may also be interested in <code><a href="#topic+find.neuron">find.neuron</a></code>, which enables 
objects in a neuronlist to be subsetted by a 3D selection box. In addition 
<code><a href="#topic+subset.neuron">subset.neuron</a></code>, <code><a href="#topic+subset.dotprops">subset.dotprops</a></code> methods exist: 
these are used to remove points from neurons (rather than to remove neurons
from neuronlists).
</p>


<h3>Value</h3>

<p>A <code>neuronlist</code>, character vector of names or the attached 
data.frame according to the value of <code>rval</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neuronlist">neuronlist</a>, <a href="#topic+find.neuron">find.neuron</a>, 
  <a href="base.html#topic+subset.data.frame">subset.data.frame</a>, <a href="#topic+subset.neuron">subset.neuron</a>, <a href="#topic+subset.dotprops">subset.dotprops</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>da1pns=subset(Cell07PNs,Glomerulus=='DA1')
with(da1pns,stopifnot(all(Glomerulus=='DA1')))
gammas=subset(kcs20,type=='gamma')
with(gammas,stopifnot(all(type=='gamma')))
# define a function that checks whether a neuron has points in a region in 
# space, specifically the tip of the mushroom body alpha' lobe
aptip&lt;-function(x) {xyz=xyzmatrix(x);any(xyz[,'X']&gt;350 &amp; xyz[,'Y']&lt;40)}
# this should identify the alpha'/beta' kenyon cells only
apbps=subset(kcs20,filterfun=aptip)
# look at which neurons are present in the subsetted neuronlist
head(apbps)
# combine global variables with dataframe columns
odds=rep(c(TRUE,FALSE),10)
stopifnot(all.equal(subset(kcs20,type=='gamma' &amp; odds),
            subset(kcs20,type=='gamma' &amp; rep(c(TRUE,FALSE),10))))
## Not run: 
# make a 3D selection function using interactive rgl::select3d() function
s3d=select3d()
# Apply a 3D search function to the first 100 neurons in the neuronlist dataset
subset(dps[1:100],filterfun=function(x) {sum(s3d(xyzmatrix(x)))&gt;0},
  rval='names')
# combine a search by metadata, neuropil location and 3D location
subset(dps, Gender=="M" &amp; rAL&gt;1000, function(x) sum(s3d(x))&gt;0, rval='name')
# The same but specifying indices directly, which can be considerably faster
# when neuronlist is huge and memory is in short supply
subset(dps, names(dps)[1:100],filterfun=function(x) {sum(s3d(xyzmatrix(x)))&gt;0},
  rval='names')

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.neuronlist'>Summary statistics for neurons (e.g. cable length, number of nodes)</h2><span id='topic+summary.neuronlist'></span><span id='topic+summary'></span><span id='topic+summary.neuron'></span><span id='topic+summary.dotprops'></span>

<h3>Description</h3>

<p><code>summary.neuronlist</code> computes tree statistics for all the 
neurons in a neuronlist object
</p>
<p><code>summary.neuron</code> computes statistics for individual neurons
</p>
<p><code>summary.dotprops</code> computes statistics for individual
neurons in dotprops format. Note the <code>veclength</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neuronlist'
summary(object, ..., include.attached.dataframe = FALSE)

## S3 method for class 'neuron'
summary(object, ...)

## S3 method for class 'dotprops'
summary(object, veclength = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.neuronlist_+3A_object">object</code></td>
<td>
<p>The neuron or neuronlist to summarise</p>
</td></tr>
<tr><td><code id="summary.neuronlist_+3A_...">...</code></td>
<td>
<p>For <code>summary.neuronlist</code> additional arguments passed on to 
summary methods for individual neurons</p>
</td></tr>
<tr><td><code id="summary.neuronlist_+3A_include.attached.dataframe">include.attached.dataframe</code></td>
<td>
<p>Whether to include the neuronlists attached
metadata in the returned data.frame.</p>
</td></tr>
<tr><td><code id="summary.neuronlist_+3A_veclength">veclength</code></td>
<td>
<p>The vector length to assume for each segment so that a cable
length estimate can be made.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> summarising the tree properties of the neuron 
with columns </p>

<ul>
<li><p> root
</p>
</li>
<li><p> nodes
</p>
</li>
<li><p> segments
</p>
</li>
<li><p> branchpoints
</p>
</li>
<li><p> endpoints
</p>
</li>
<li><p> cable.length
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+seglengths">seglengths</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># summary for a whole neuronlist
summary(Cell07PNs)
# including the attached data.frame with additional metadata
head(summary(Cell07PNs, include.attached.dataframe = FALSE))
# for a single regular format neuron
summary(Cell07PNs[[1]])
# for a single dotprops format neuron
summary(kcs20[[1]])
# specify a different estimate for the cable length associated with a single
# point in the neuron
summary(kcs20[[1]], veclength=1.2)
</code></pre>

<hr>
<h2 id='threshold'>Threshold an object, typically to produce a mask</h2><span id='topic+threshold'></span><span id='topic+threshold.im3d'></span>

<h3>Description</h3>

<p>Threshold an object, typically to produce a mask
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold(x, ...)

## S3 method for class 'im3d'
threshold(
  x,
  threshold = 0,
  mode = c("logical", "integer", "raw", "numeric"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshold_+3A_x">x</code></td>
<td>
<p>Object to be thresholded</p>
</td></tr>
<tr><td><code id="threshold_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="threshold_+3A_threshold">threshold</code></td>
<td>
<p>Either a numeric value that pixels must <strong>exceed</strong> in 
order to be included in the mask <em>or</em> a <code>logical</code> vector defining
foreground pixels.</p>
</td></tr>
<tr><td><code id="threshold_+3A_mode">mode</code></td>
<td>
<p>The storage mode of the resultant object (see 
<code><a href="base.html#topic+vector">vector</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>threshold.im3d</code> passes ... arguments on to im3d
</p>


<h3>Value</h3>

<p>an oject with attributes matching <code>x</code> and elements with value 
<code>as.vector(TRUE, mode=mode)</code> i.e. <code>TRUE, 1, 0x01</code> and 
<code>as.vector(FALSE, mode=mode)</code> i.e. <code>FALSE, 0, 0x00</code> as 
appropriate.
</p>


<h3>See Also</h3>

<p>Other im3d: 
<code><a href="#topic+as.im3d">as.im3d</a>()</code>,
<code><a href="#topic+boundingbox">boundingbox</a>()</code>,
<code><a href="#topic+im3d-coords">im3d-coords</a></code>,
<code><a href="#topic+im3d-io">im3d-io</a></code>,
<code><a href="#topic+im3d">im3d</a>()</code>,
<code><a href="#topic+imexpand.grid">imexpand.grid</a>()</code>,
<code><a href="#topic+imslice">imslice</a>()</code>,
<code><a href="#topic+is.im3d">is.im3d</a>()</code>,
<code><a href="#topic+mask">mask</a>()</code>,
<code><a href="#topic+origin">origin</a>()</code>,
<code><a href="#topic+projection">projection</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>,
<code><a href="#topic+voxdims">voxdims</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=im3d(rnorm(1000),dims=c(10,10,10), BoundingBox=c(20,200,100,200,200,300))
stopifnot(all.equal(threshold(x, 0), threshold(x, x&gt;0)))
</code></pre>

<hr>
<h2 id='union'>Find the union of two collections of objects</h2><span id='topic+union'></span><span id='topic+union.default'></span><span id='topic+union.neuronlist'></span>

<h3>Description</h3>

<p>Find the union of two collections of objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>union(x, y, ...)

## Default S3 method:
union(x, y, ...)

## S3 method for class 'neuronlist'
union(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="union_+3A_x">x</code></td>
<td>
<p>the first collection to consider.</p>
</td></tr>
<tr><td><code id="union_+3A_y">y</code></td>
<td>
<p>the second collection to consider.</p>
</td></tr>
<tr><td><code id="union_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that union.default calls base::union to ensure consistent 
behaviour for regular vectors.
</p>


<h3>Value</h3>

<p>A collection of the same mode as <code>x</code> that contains all unique
elements of <code>x</code> and <code>y</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+union">union</a></code>
</p>

<hr>
<h2 id='unmask'>Make im3d image array containing values at locations defined by a mask</h2><span id='topic+unmask'></span>

<h3>Description</h3>

<p>Make im3d image array containing values at locations defined by a mask
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmask(
  x,
  mask,
  default = NA,
  attributes. = attributes(mask),
  copyAttributes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmask_+3A_x">x</code></td>
<td>
<p>the data to place on a regular grid</p>
</td></tr>
<tr><td><code id="unmask_+3A_mask">mask</code></td>
<td>
<p>An <code>im3d</code> regular image array where non-zero voxels are the 
selected element.</p>
</td></tr>
<tr><td><code id="unmask_+3A_default">default</code></td>
<td>
<p>Value for regions outside the mask (default: NA)</p>
</td></tr>
<tr><td><code id="unmask_+3A_attributes.">attributes.</code></td>
<td>
<p>Attributes to set on new object. Defaults to attributes of
<code>mask</code></p>
</td></tr>
<tr><td><code id="unmask_+3A_copyattributes">copyAttributes</code></td>
<td>
<p>Whether to copy over attributes (including <code>dim</code>) 
from the mask to the returned object. default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values in x will be placed into a grid defined by the dimensions
of the <code>mask</code> in the order defined by the standard R linear 
subscripting of arrays (see e.g. <code><a href="base.html#topic+arrayInd">arrayInd</a></code>).
</p>


<h3>Value</h3>

<p>A new <code>im3d</code> object with attributes/dimensions defined by 
<code>mask</code> and values from <code>x</code>. If <code>copyAttributes</code> is 
<code>FALSE</code>, then it will have mode of <code>x</code> and length of <code>mask</code> 
but no other attributes.
</p>


<h3>See Also</h3>

<p>Other im3d: 
<code><a href="#topic+as.im3d">as.im3d</a>()</code>,
<code><a href="#topic+boundingbox">boundingbox</a>()</code>,
<code><a href="#topic+im3d-coords">im3d-coords</a></code>,
<code><a href="#topic+im3d-io">im3d-io</a></code>,
<code><a href="#topic+im3d">im3d</a>()</code>,
<code><a href="#topic+imexpand.grid">imexpand.grid</a>()</code>,
<code><a href="#topic+imslice">imslice</a>()</code>,
<code><a href="#topic+is.im3d">is.im3d</a>()</code>,
<code><a href="#topic+mask">mask</a>()</code>,
<code><a href="#topic+origin">origin</a>()</code>,
<code><a href="#topic+projection">projection</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+voxdims">voxdims</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# read in a mask
LHMask=read.im3d(system.file('tests/testthat/testdata/nrrd/LHMask.nrrd', package='nat'))
# pick out all the non zero values
inmask=LHMask[LHMask!=0]
# fill the non-zero elements of the mask with a vector that iterates over the
# values 0:9
stripes=unmask(seq(inmask)%%10, LHMask)
# make an image from one slice of that result array
image(imslice(stripes,11), asp=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='voxdims'>Return voxel dimensions of an object</h2><span id='topic+voxdims'></span><span id='topic+voxdims.im3d'></span><span id='topic+voxdims.character'></span><span id='topic+voxdims.default'></span>

<h3>Description</h3>

<p>This would properly be thought of as the voxel spacing when 
voxels are assumed not to have a physical extent (only a location).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voxdims(x, ...)

## S3 method for class 'im3d'
voxdims(x, ...)

## S3 method for class 'character'
voxdims(x, ...)

## Default S3 method:
voxdims(x, dims, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="voxdims_+3A_x">x</code></td>
<td>
<p>An <code>im3d</code> object with associated voxel dimensions, a path to  or a 2 x 3 
BoundingBox <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="voxdims_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods</p>
</td></tr>
<tr><td><code id="voxdims_+3A_dims">dims</code></td>
<td>
<p>The number of voxels in each dimension when x is a BoundingBox 
matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We follow Amira's convention of returning a voxel dimension equal to
the bounding box size (rather than 0) for any dimension with only 1 voxel.
</p>


<h3>Value</h3>

<p>A numeric vector of length 3, NA when missing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boundingbox">boundingbox</a></code>
</p>
<p>Other im3d: 
<code><a href="#topic+as.im3d">as.im3d</a>()</code>,
<code><a href="#topic+boundingbox">boundingbox</a>()</code>,
<code><a href="#topic+im3d-coords">im3d-coords</a></code>,
<code><a href="#topic+im3d-io">im3d-io</a></code>,
<code><a href="#topic+im3d">im3d</a>()</code>,
<code><a href="#topic+imexpand.grid">imexpand.grid</a>()</code>,
<code><a href="#topic+imslice">imslice</a>()</code>,
<code><a href="#topic+is.im3d">is.im3d</a>()</code>,
<code><a href="#topic+mask">mask</a>()</code>,
<code><a href="#topic+origin">origin</a>()</code>,
<code><a href="#topic+projection">projection</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>
</p>

<hr>
<h2 id='write.amiramesh'>Write a 3D data object to an amiramesh format file</h2><span id='topic+write.amiramesh'></span>

<h3>Description</h3>

<p>Write a 3D data object to an amiramesh format file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.amiramesh(
  x,
  file,
  enc = c("binary", "raw", "text", "hxzip"),
  dtype = c("float", "byte", "short", "ushort", "int", "double"),
  endian = .Platform$endian,
  WriteNrrdHeader = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.amiramesh_+3A_x">x</code></td>
<td>
<p>The image data to write (an im3d, or capable of being interpreted as
such)</p>
</td></tr>
<tr><td><code id="write.amiramesh_+3A_file">file</code></td>
<td>
<p>Character vector describing a single file</p>
</td></tr>
<tr><td><code id="write.amiramesh_+3A_enc">enc</code></td>
<td>
<p>Encoding of the data. NB &quot;raw&quot; and &quot;binary&quot; are synonyms.</p>
</td></tr>
<tr><td><code id="write.amiramesh_+3A_dtype">dtype</code></td>
<td>
<p>Data type to write to disk</p>
</td></tr>
<tr><td><code id="write.amiramesh_+3A_endian">endian</code></td>
<td>
<p>Endianness of data block. Defaults to current value of 
<code>.Platform$endian</code>.</p>
</td></tr>
<tr><td><code id="write.amiramesh_+3A_writenrrdheader">WriteNrrdHeader</code></td>
<td>
<p>Whether to write a separate detached nrrd header next 
to the amiramesh file allowing it to be opened by a NRRD reader. See 
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that only <code>'raw'</code> or <code>'text'</code> format data can
accommodate a detached NRRD format header since Amira's HxZip format is
subtly different from NRRD's gzip encoding. There is a full description 
of the deteached NRRD format in the help for <code><a href="#topic+write.nrrd">write.nrrd</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+.Platform">.Platform</a>, <a href="#topic+read.amiramesh">read.amiramesh</a>, <a href="#topic+write.nrrd">write.nrrd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d=array(rnorm(1000), c(10, 10, 10))
tf=tempfile(fileext='.am')
write.amiramesh(im3d(d, voxdims=c(0.5,0.5,1)), file=tf, WriteNrrdHeader=TRUE)
d2=read.nrrd(paste(tf, sep='', '.nhdr'))
all.equal(d, d2, tol=1e-6)
</code></pre>

<hr>
<h2 id='write.cmtk'>Write a suitable list to a CMTK TypedStream file on disk</h2><span id='topic+write.cmtk'></span>

<h3>Description</h3>

<p>This is probaly only of interest to developers. End users will 
probably wish to use more specific functions such as write.cmtkreg for
writing out registrations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.cmtk(l, con, gzip = FALSE, version = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.cmtk_+3A_l">l</code></td>
<td>
<p>Appropriately formatted list</p>
</td></tr>
<tr><td><code id="write.cmtk_+3A_con">con</code></td>
<td>
<p>A character string specifying a path or a connection</p>
</td></tr>
<tr><td><code id="write.cmtk_+3A_gzip">gzip</code></td>
<td>
<p>Whether to gzip output file (default FALSE)</p>
</td></tr>
<tr><td><code id="write.cmtk_+3A_version">version</code></td>
<td>
<p>TYPEDSTREAM version number, defaults to <code>"1.1"</code> if not 
specified in the version attribute of <code>l</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NB a version specified on the command line overrides one encoded as 
an attribute in the input list.
</p>


<h3>See Also</h3>

<p>Other cmtk-io: 
<code><a href="#topic+cmtk.extract_affine">cmtk.extract_affine</a>()</code>,
<code><a href="#topic+read.cmtkreg">read.cmtkreg</a>()</code>,
<code><a href="#topic+read.cmtk">read.cmtk</a>()</code>,
<code><a href="#topic+write.cmtkreg">write.cmtkreg</a>()</code>
</p>

<hr>
<h2 id='write.cmtkreg'>Write out CMTK registration list to folder</h2><span id='topic+write.cmtkreg'></span>

<h3>Description</h3>

<p>Write out CMTK registration list to folder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.cmtkreg(reglist, foldername, version = "2.4")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.cmtkreg_+3A_reglist">reglist</code></td>
<td>
<p>List specifying CMTK registration parameters</p>
</td></tr>
<tr><td><code id="write.cmtkreg_+3A_foldername">foldername</code></td>
<td>
<p>Path to registration folder (usually ending in .list)</p>
</td></tr>
<tr><td><code id="write.cmtkreg_+3A_version">version</code></td>
<td>
<p>CMTK version for registration (default 2.4). Will be converted
to character vector if not already.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that transformation in the forward direction (i.e. sample-&gt;ref)
e.g. as calculated from a set of landmarks where set 1 is the sample is
considered an inverse transformation by the IGS software. So in order to
use such a transformation as an initial affine with the registration
command the switch &ndash;initial-inverse must be used specifying the folder
name created by this function.
</p>
<p>CMTK v2.4 fixed a long-standing bug in affine (de)composition to
CMTK params. This resulted in a non-backwards compatible change marked by
writing the TYPEDSTREAM as version 2.4. The R code in this package
implements both the new and old compose/decompose functions, using the new
by default.
</p>


<h3>See Also</h3>

<p>Other cmtk-io: 
<code><a href="#topic+cmtk.extract_affine">cmtk.extract_affine</a>()</code>,
<code><a href="#topic+read.cmtkreg">read.cmtkreg</a>()</code>,
<code><a href="#topic+read.cmtk">read.cmtk</a>()</code>,
<code><a href="#topic+write.cmtk">write.cmtk</a>()</code>
</p>

<hr>
<h2 id='write.hxsurf'>Write Amira surface (aka HxSurface or HyperSurface) into .surf file.</h2><span id='topic+write.hxsurf'></span>

<h3>Description</h3>

<p>Write Amira surface (aka HxSurface or HyperSurface) into .surf file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.hxsurf(surf, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.hxsurf_+3A_surf">surf</code></td>
<td>
<p>hxsurf object to write to file.</p>
</td></tr>
<tr><td><code id="write.hxsurf_+3A_filename">filename</code></td>
<td>
<p>character vector defining path to file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> or integer status from <code><a href="base.html#topic+close">close</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3d.hxsurf">plot3d.hxsurf</a></code>,<code><a href="#topic+read.hxsurf">read.hxsurf</a></code>, <code><a href="grDevices.html#topic+rgb">rgb</a></code>
</p>
<p>Other amira: 
<code><a href="#topic+amiratype">amiratype</a>()</code>,
<code><a href="#topic+is.amiramesh">is.amiramesh</a>()</code>,
<code><a href="#topic+read.amiramesh">read.amiramesh</a>()</code>,
<code><a href="#topic+read.hxsurf">read.hxsurf</a>()</code>
</p>
<p>Other hxsurf: 
<code><a href="#topic+as.hxsurf">as.hxsurf</a>()</code>,
<code><a href="#topic+as.mesh3d">as.mesh3d</a>()</code>,
<code><a href="#topic+materials">materials</a>()</code>,
<code><a href="#topic+plot3d.hxsurf">plot3d.hxsurf</a>()</code>,
<code><a href="#topic+read.hxsurf">read.hxsurf</a>()</code>,
<code><a href="#topic+subset.hxsurf">subset.hxsurf</a>()</code>
</p>

<hr>
<h2 id='write.neuron'>Write out a neuron in any of the file formats we know about</h2><span id='topic+write.neuron'></span>

<h3>Description</h3>

<p>If file is not specified the neuron's InputFileName field will be checked 
(for a dotprops object it will be the <code>'file'</code> attribute). If this is 
missing there will be an error. If dir is specified it will be combined with 
basename(file). If file is specified but format is not, it will be inferred 
from file's extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.neuron(
  n,
  file = NULL,
  dir = NULL,
  format = NULL,
  ext = NULL,
  Force = FALSE,
  MakeDir = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.neuron_+3A_n">n</code></td>
<td>
<p>A neuron</p>
</td></tr>
<tr><td><code id="write.neuron_+3A_file">file</code></td>
<td>
<p>Path to output file</p>
</td></tr>
<tr><td><code id="write.neuron_+3A_dir">dir</code></td>
<td>
<p>Path to directory (this will replace dirname(file) if specified)</p>
</td></tr>
<tr><td><code id="write.neuron_+3A_format">format</code></td>
<td>
<p>Unique abbreviation of one of the registered file formats for 
neurons including 'swc', 'hxlineset', 'hxskel'</p>
</td></tr>
<tr><td><code id="write.neuron_+3A_ext">ext</code></td>
<td>
<p>Will replace the default extension for the filetype and should 
include the period eg <code>ext='.amiramesh'</code> or <code>ext='_reg.swc'</code>. The
special value of ext=NA will prevent the extension from being changed or 
added e.g. if the desired file name does not have an extension.</p>
</td></tr>
<tr><td><code id="write.neuron_+3A_force">Force</code></td>
<td>
<p>Whether to overwrite an existing file</p>
</td></tr>
<tr><td><code id="write.neuron_+3A_makedir">MakeDir</code></td>
<td>
<p>Whether to create directory implied by <code>file</code> argument.</p>
</td></tr>
<tr><td><code id="write.neuron_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to selected writer function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if <code>file</code> does not have an extension then the default
extension for the specified <code>format</code> will be appended. This behaviour 
can be suppressed by setting <code>ext=NA</code>.
</p>


<h3>Value</h3>

<p>return value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.neuron">write.neuron</a></code>, <code><a href="#topic+fileformats">fileformats</a></code>,
<code><a href="base.html#topic+saveRDS">saveRDS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># show the currently registered file formats that we can write
fileformats(class='neuron', write=TRUE)
## Not run: 
write.neuron(Cell07PNs[[1]], file='myneuron.swc')
# writes out "myneuron.swc" in SWC format
write.neuron(Cell07PNs[[1]], format = 'hxlineset', file='myneuron.amiramesh')
# writes out "myneuron.amiramesh" in Amira hxlineset format
write.neuron(Cell07PNs[[1]], format = 'hxlineset', file='myneuron')
# writes out "myneuron.am" in Amira hxlineset format

## End(Not run)
</code></pre>

<hr>
<h2 id='write.neuronlistfh'>Write out a neuronlistfh object to an RDS file</h2><span id='topic+write.neuronlistfh'></span>

<h3>Description</h3>

<p>Write out a neuronlistfh object to an RDS file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.neuronlistfh(x, file = attr(x, "file"), overwrite = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.neuronlistfh_+3A_x">x</code></td>
<td>
<p>The neuronlistfh object to write out</p>
</td></tr>
<tr><td><code id="write.neuronlistfh_+3A_file">file</code></td>
<td>
<p>Path where the file will be written (see details)</p>
</td></tr>
<tr><td><code id="write.neuronlistfh_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to overwrite an existing file</p>
</td></tr>
<tr><td><code id="write.neuronlistfh_+3A_...">...</code></td>
<td>
<p>Additional paramaters passed to <code>saveRDS</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function writes the main neuronlistfh object to disk, but makes
no attempt to touch/verify the associated object files.
</p>
<p>if <code>file</code> is not specified, then the function will first check if 
<code>x</code> has a <code>'file'</code> attribute. If that does not exist, then 
<code>attr(x,'db')@dir</code>, the backing <code>filehash</code> database directory, 
is inspected. The save path <code>file</code> will then be constructed by taking 
the directory one up from the database directory and using the name of the 
neuronlistfh object with the suffix '.rds'. e.g. write.neuronlistfh(kcs20) 
with db directory '/my/path/dps/data' will be saved as 
'/my/path/dps/kcs20.rds'
</p>
<p>Note that if x has a <code>'file'</code> attribute (set by 
<code>read.neuronlistfh</code>) then this will be removed before the file is 
saved (since the file attribute must be set on read to ensure that we know 
exactly which file on disk was the source of the object in memory).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+saveRDS">saveRDS</a></code>
</p>
<p>Other neuronlistfh: 
<code><a href="#topic++5B.neuronlistfh">[.neuronlistfh</a>()</code>,
<code><a href="#topic+neuronlistfh">neuronlistfh</a>()</code>,
<code><a href="#topic+read.neuronlistfh">read.neuronlistfh</a>()</code>,
<code><a href="#topic+remotesync">remotesync</a>()</code>
</p>

<hr>
<h2 id='write.neurons'>Write neurons from a neuronlist object to individual files, or a zip archive</h2><span id='topic+write.neurons'></span>

<h3>Description</h3>

<p>Write neurons from a neuronlist object to individual files, or a zip archive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.neurons(
  nl,
  dir,
  format = NULL,
  subdir = NULL,
  INDICES = names(nl),
  files = NULL,
  Force = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.neurons_+3A_nl">nl</code></td>
<td>
<p>neuronlist object</p>
</td></tr>
<tr><td><code id="write.neurons_+3A_dir">dir</code></td>
<td>
<p>directory to write neurons, or path to zip archive (see Details).</p>
</td></tr>
<tr><td><code id="write.neurons_+3A_format">format</code></td>
<td>
<p>Unique abbreviation of one of the registered file formats for 
neurons including 'swc', 'hxlineset', 'hxskel'</p>
</td></tr>
<tr><td><code id="write.neurons_+3A_subdir">subdir</code></td>
<td>
<p>String naming field in neuron that specifies a subdirectory OR 
expression to evaluate in the context of neuronlist's df attribute</p>
</td></tr>
<tr><td><code id="write.neurons_+3A_indices">INDICES</code></td>
<td>
<p>Character vector of the names of a subset of neurons in 
neuronlist to write.</p>
</td></tr>
<tr><td><code id="write.neurons_+3A_files">files</code></td>
<td>
<p>Character vector or expression specifying output filenames. See 
examples and <code><a href="#topic+write.neuron">write.neuron</a></code> for details.</p>
</td></tr>
<tr><td><code id="write.neurons_+3A_force">Force</code></td>
<td>
<p>Whether to overwrite an existing file</p>
</td></tr>
<tr><td><code id="write.neurons_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+write.neuron">write.neuron</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+write.neuron">write.neuron</a></code> for details of how to specify the 
file format/extension/name of the output files and how to establish what 
output file formats are available. A zip archive of files can be written by
specifying a value of <code>dir</code> that ends in <code>.zip</code>.
</p>


<h3>Value</h3>

<p>the path to the output file(s), absolute when this is a zip file.
</p>


<h3>Author(s)</h3>

<p>jefferis
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.neuron">write.neuron</a></code>, <code><a href="#topic+read.neurons">read.neurons</a></code>,
<code><a href="#topic+fileformats">fileformats</a></code>
</p>
<p>Other neuronlist: 
<code><a href="#topic++2A.neuronlist">*.neuronlist</a>()</code>,
<code><a href="#topic+is.neuronlist">is.neuronlist</a>()</code>,
<code><a href="#topic+neuronlist-dataframe-methods">neuronlist-dataframe-methods</a></code>,
<code><a href="#topic+neuronlistfh">neuronlistfh</a>()</code>,
<code><a href="#topic+neuronlist">neuronlist</a>()</code>,
<code><a href="#topic+nlapply">nlapply</a>()</code>,
<code><a href="#topic+read.neurons">read.neurons</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# write some neurons in swc format
write.neurons(Cell07PNs, dir="testwn", format='swc')
# write some neurons in Amira hxlineset format
write.neurons(Cell07PNs, dir="testwn", format='hxlineset')

# organise new files in directory hierarchy by glomerulus and Scored.By field
write.neurons(Cell07PNs,dir="testwn",
  subdir=file.path(Glomerulus,Scored.By),format='hxlineset')
# ensure that the neurons are named according to neuronlist names
write.neurons(Cell07PNs, dir="testwn", files=names(Cell07PNs),
  subdir=file.path(Glomerulus,Scored.By),format='hxlineset')
# only write a subset
write.neurons(subset(Cell07PNs, Scored.By="ACH"),dir="testwn2",
  subdir=Glomerulus,format='hxlineset')
# The same, but likely faster for big neuronlists
write.neurons(Cell07PNs, dir="testwn3",
  INDICES=subset(Cell07PNs,Scored.By="ACH",rval='names'),
  subdir=Glomerulus,format='hxlineset')
# set file name explicitly using a field in data.frame
write.neurons(subset(Cell07PNs, Scored.By="ACH"),dir="testwn4",
  subdir=Glomerulus, files=paste0(ID,'.am'), format='hxlineset')

## End(Not run)
</code></pre>

<hr>
<h2 id='write.nrrd'>Write data and metadata to NRRD file or create a detached NRRD (nhdr) file.</h2><span id='topic+write.nrrd'></span><span id='topic+write.nrrd.header'></span><span id='topic+write.nrrd.header.for.file'></span>

<h3>Description</h3>

<p><code>write.nrrd</code> writes an array, vector or im3d object to a 
NRRD file. When <code>x</code> is an <code>im3d</code> object, appropriate spatial 
calibration fields are added to the header.
</p>
<p><code>write.nrrd.header</code> writes a nrrd header file.
</p>
<p><code>write.nrrd.header.for.file</code> makes a detached NRRD
(<b>nhdr</b>) file that points at another image file on disk, making it
NRRD compatible. This can be a convenient way to make NRRD inputs for other
tools e.g. CMTK and also allows the same data block to pointed to by
different nhdr files with different spatial calibration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.nrrd(
  x,
  file,
  enc = c("gzip", "raw", "text"),
  dtype = c("float", "byte", "short", "ushort", "int", "double"),
  header = attr(x, "header"),
  endian = .Platform$endian,
  datafile = NULL
)

write.nrrd.header(header, file)

write.nrrd.header.for.file(infile, outfile = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.nrrd_+3A_x">x</code></td>
<td>
<p>Data to write as an <code>array</code>, <code>vector</code> or 
<code><a href="#topic+im3d">im3d</a></code> object.</p>
</td></tr>
<tr><td><code id="write.nrrd_+3A_file">file</code></td>
<td>
<p>Character string naming an output file (a detached nrrd header 
when <code>file</code> has extension 'nhdr').</p>
</td></tr>
<tr><td><code id="write.nrrd_+3A_enc">enc</code></td>
<td>
<p>One of three supported nrrd encodings (&quot;gzip&quot;, &quot;raw&quot;, &quot;text&quot;)</p>
</td></tr>
<tr><td><code id="write.nrrd_+3A_dtype">dtype</code></td>
<td>
<p>The data type to write. One of &quot;float&quot;,&quot;byte&quot;, &quot;short&quot;, 
&quot;ushort&quot;, &quot;int&quot;, &quot;double&quot;</p>
</td></tr>
<tr><td><code id="write.nrrd_+3A_header">header</code></td>
<td>
<p>List containing fields of nrrd header - see <em>Header</em> 
section.</p>
</td></tr>
<tr><td><code id="write.nrrd_+3A_endian">endian</code></td>
<td>
<p>One of &quot;big&quot; or &quot;little&quot;. Defaults to <code>.Platform$endian</code>.</p>
</td></tr>
<tr><td><code id="write.nrrd_+3A_datafile">datafile</code></td>
<td>
<p>Optional name of separate file into which data should be 
written (see details).</p>
</td></tr>
<tr><td><code id="write.nrrd_+3A_infile">infile</code>, <code id="write.nrrd_+3A_outfile">outfile</code></td>
<td>
<p>Path to input and output file for 
<code>write.nrrd.header.for.file</code>. If <code>outfile</code> is <code>NULL</code> (the
default) then it will be set to <code>&lt;infilestem.nhdr&gt;</code>.</p>
</td></tr>
</table>


<h3>Detached NRRDs</h3>

<p>NRRD files can be written in <em>detached</em> format 
(see <a href="https://teem.sourceforge.net/nrrd/format.html#detached">https://teem.sourceforge.net/nrrd/format.html#detached</a>) in which 
a text <b>nhdr</b> file is used to described the contents of a separate 
(usually binary) data file. This means that the nhdr file can be inspected 
and edited with a text editor, while the datablock can be in a completely 
raw format that can be opened even by programs that do not understand the 
NRRD format. Furthermore detached NRRD header files can be written to 
accompany non-NRRD image data so that it can be opened by nrrd readers.
</p>
<p>If <code>file</code> has extension <code>.nhdr</code> <em>or</em> <code>datafile</code> is 
non-NULL, then <code>write.nrrd</code> will write a separate datafile. If 
<code>datafile</code> is set, then it is interpeted as specifying a path relative
to the <b>nhdr</b> file. If <code>datafile</code> is not specified then default 
filenames will be chosen according to the encoding following the 
conventions of the teem library:
</p>

<ul>
<li><p> raw <code>'&lt;nhdrstem&gt;.raw'</code>
</p>
</li>
<li><p> gzip <code>'&lt;nhdrstem&gt;.raw.gz'</code>
</p>
</li>
<li><p> text <code>'&lt;nhdrstem&gt;.ascii'</code>
</p>
</li></ul>



<h3>Data file paths</h3>

<p>When a detached NRRD is written, the 
<code>datafile</code> can be specified either as <em>relative</em> or 
<em>absolute</em> path. Relative paths are strongly recommended - the best 
place is right next to the datafile. Relative paths are always specified 
with respect to the location of the <b>nhdr</b> file.
</p>
<p>The <code>datafile</code> argument is not processed by <code>write.nrrd</code> so it is
up to the caller to decide whether a relative or absolute path will be 
used.
</p>
<p>For <code>write.nrrd.header.for.file</code> if <code>outfile</code> is not specified 
then the nhdr file will be placed next to the original image stack and the 
<code>datafile</code> field will therefore just be <code>basename(infile)</code>. If 
outfile is specified explicitly, then <code>datafile</code> will be set to the 
full path in the <code>infile</code> argument. Therefore if you wish to specify 
<code>outfile</code>, you <em>must</em> set the current working directory (using 
<code>setwd</code>) to the location in which <code>outfile</code> will be written to 
ensure that the path to the datafile is correct. A future TODO would add 
the ability to convert an absolute datafile path to a relaive one (by
finding the common path between datafile and nhdr folders).
</p>


<h3>Header</h3>

<p>For <code>write.nrrd</code>, arguments <code>enc</code>, <code>dtype</code>, 
and <code>endian</code> along with the dimensions of the input (<code>x</code>) will 
override the corresponding NRRD header fields from any supplied 
<code>header</code> argument. See 
<a href="https://teem.sourceforge.net/nrrd/format.html">https://teem.sourceforge.net/nrrd/format.html</a> for details of the NRRD 
fields.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.nrrd">read.nrrd</a>, <a href="base.html#topic+.Platform">.Platform</a></code>
</p>

<hr>
<h2 id='write.vtk'>Write object to VTK file</h2><span id='topic+write.vtk'></span><span id='topic+write.vtk.neuron'></span>

<h3>Description</h3>

<p>Write object to VTK file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.vtk(x, file, ...)

## S3 method for class 'neuron'
write.vtk(
  x,
  file,
  datatype = c("float", "double"),
  title = file,
  WriteAllSubTrees = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.vtk_+3A_x">x</code></td>
<td>
<p>Object to write</p>
</td></tr>
<tr><td><code id="write.vtk_+3A_file">file</code></td>
<td>
<p>Path to output file</p>
</td></tr>
<tr><td><code id="write.vtk_+3A_...">...</code></td>
<td>
<p>Additional arguments to methods</p>
</td></tr>
<tr><td><code id="write.vtk_+3A_datatype">datatype</code></td>
<td>
<p>The VTK data type (one of float or double)</p>
</td></tr>
<tr><td><code id="write.vtk_+3A_title">title</code></td>
<td>
<p>Title of the .vtk file (defaults to file)</p>
</td></tr>
<tr><td><code id="write.vtk_+3A_writeallsubtrees">WriteAllSubTrees</code></td>
<td>
<p>Whether to write all subtrees in the neuron or just 
the main tree.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n=Cell07PNs[[1]]
write.vtk(n, paste0(n$NeuronName, ".vtk"))
write.neuron(n, paste0(n$NeuronName, ".vtk"))

## End(Not run)
</code></pre>

<hr>
<h2 id='xform'>Transform the 3D location of objects such as neurons</h2><span id='topic+xform'></span><span id='topic+xform.default'></span><span id='topic+xform.character'></span><span id='topic+xform.list'></span><span id='topic+xform.shape3d'></span><span id='topic+xform.neuron'></span><span id='topic+xform.data.frame'></span><span id='topic+xform.dotprops'></span><span id='topic+xform.neuronlist'></span>

<h3>Description</h3>

<p><code>xform</code> is designed to operate on a variety of data types, especially 
objects encapsulating neurons. <code>xform</code> depends on two specialised 
downstream functions <code><a href="#topic+xformpoints">xformpoints</a></code> and <code><a href="#topic+xformimage">xformimage</a></code>. 
These are user visible any contain some useful documentation, but should only
be required for expert use; in almost all circumstances, you should use only 
<code>xform</code>.
</p>
<p><code>xform.character</code> is designed to work with files on disk.
Presently it is restricted to images, although other datatypes may be
supported in future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xform(x, reg, ...)

## Default S3 method:
xform(x, reg, na.action = c("warn", "none", "drop", "error"), ...)

## S3 method for class 'character'
xform(x, reg, ...)

## S3 method for class 'list'
xform(x, reg, FallBackToAffine = TRUE, na.action = "error", ...)

## S3 method for class 'shape3d'
xform(x, reg, FallBackToAffine = TRUE, na.action = "error", ...)

## S3 method for class 'neuron'
xform(x, reg, FallBackToAffine = TRUE, na.action = "error", ...)

## S3 method for class 'data.frame'
xform(x, reg, subset = NULL, ...)

## S3 method for class 'dotprops'
xform(x, reg, FallBackToAffine = TRUE, ...)

## S3 method for class 'neuronlist'
xform(
  x,
  reg,
  subset = NULL,
  ...,
  OmitFailures = NA,
  VectoriseRegistrations = FALSE,
  TransformDFCoords = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xform_+3A_x">x</code></td>
<td>
<p>an object to transform</p>
</td></tr>
<tr><td><code id="xform_+3A_reg">reg</code></td>
<td>
<p>A registration defined by a matrix, a function, a <code>cmtkreg</code> 
object, or a character vector specifying a path to one or more 
registrations on disk (see Registrations section).</p>
</td></tr>
<tr><td><code id="xform_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods and eventually to 
<code><a href="#topic+xformpoints">xformpoints</a></code></p>
</td></tr>
<tr><td><code id="xform_+3A_na.action">na.action</code></td>
<td>
<p>How to handle NAs. NB drop may not work for some classes.</p>
</td></tr>
<tr><td><code id="xform_+3A_fallbacktoaffine">FallBackToAffine</code></td>
<td>
<p>Whether to use an affine transform when a cmtk
warping transformation fails.</p>
</td></tr>
<tr><td><code id="xform_+3A_subset">subset</code></td>
<td>
<p>For <code>xform.neuronlist</code> indices (character/logical/integer)
that specify a subset of the members of <code>x</code> to be transformed.</p>
</td></tr>
<tr><td><code id="xform_+3A_omitfailures">OmitFailures</code></td>
<td>
<p>Whether to omit neurons for which <code>FUN</code> gives an 
error. The default value (<code>NA</code>) will result in nlapply stopping with 
an error message the moment there is an eror. For other values, see 
details.</p>
</td></tr>
<tr><td><code id="xform_+3A_vectoriseregistrations">VectoriseRegistrations</code></td>
<td>
<p>When <code>FALSE</code>, the default, each element of
<code>reg</code> will be applied sequentially to each element of <code>x</code>. When 
<code>TRUE</code>, it is assumed that there is one element of <code>reg</code> for each
element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="xform_+3A_transformdfcoords">TransformDFCoords</code></td>
<td>
<p>If the metadata <code>data.frame</code> attached to 
<code>x</code> includes columns that look like x,y,z coordinates, transform those
as well.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are provided for some specialised S3 classes. Further 
methods can of course be constructed for user-defined S3 classes. However 
this will probably not be necessary if the <code>xyzmatrix</code> and 
<code>`xyzmatrix&lt;-`</code> generics are suitably overloaded <em>and</em> the S3 
object inherits from <code>list</code>.
</p>
<p>Note that given the behaviour of the <code>xyzmatrix</code> functions, the
<code>xform.data.frame</code> method will transform the x,y,z or X,Y,Z columns of
a data.frame if the data.frame has more than 3 columns, erroring out if no
such unique columns exist.
</p>
<p>TODO get this to work for matrices with more than 3 columns by
working on xyzmatrix definition.
</p>
<p>For the <code>xform.dotprops</code> method, dotprops tangent vectors will 
be recalculated from scratch after the points have been transformed (even 
though the tangent vectors could in theory be transformed more or less 
correctly). When there are multiple transformations, <code>xform</code> will take
care to carry out all transformations before recalculating the vectors.
</p>
<p>With <code>xform.neuronlist</code>, if you want to apply a different 
registration to each object in the neuronlist <code>x</code>, then you should use
<code>VectoriseRegistrations=TRUE</code>.
</p>
<p>When <code>x</code>'s attached data.frame contains columns called x,y,z or X,Y,Z 
then these are assumed to be coordinates and also transformed when 
<code>TransformDFCoords=TRUE</code> (the default). This provides a mechanism for 
transforming the soma positions of <code>neuronlist</code> objects containing 
<code>dotprops</code> objects (which do not otherwise store the soma position).
Note that if transformation fails, a warning will be issued and the points
will be replaced with <code>NA</code> values.
</p>


<h3>Registrations</h3>

<p>When <code>reg</code> is a character vector, xform's specialised downstream 
functions will check to see if it defines a path to one (or more) 
registrations on disk. These can be of two classes
</p>

<ul>
<li><p> CMTK registrations
</p>
</li>
<li> <p><code><a href="#topic+reglist">reglist</a></code> objects saved in R's <code>RDS</code> format (see 
<code><a href="base.html#topic+readRDS">readRDS</a></code>) which can contain any sequence of registrations 
supported by nat.
</p>
</li></ul>

<p>If the path does indeed point to a CMTK registration, this method will hand
off to <code>xformpoints.cmtkreg</code> or <code>xformimages.cmtkreg</code>. In this
case, the character vector may optionally have an attribute, 'swap', a
logical vector of the same length indicating whether the transformation
direction should be swapped. At the moment only CMTK registration files are
supported.
</p>
<p>If <code>reg</code> is a character vector of length &gt;=1 defining a sequence of 
registration files on disk they should proceed from sample to reference.
</p>
<p>Where <code>reg</code> is a function, it should have a signature like 
<code>myfun(x,), ...</code> where the <code>...</code> <strong>must</strong> be provided in 
order to swallow any arguments passed from higher level functions that are 
not relevant to this particular transformation function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xformpoints">xformpoints</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
kc1=kcs20[[1]]
kc1.default=xform(kc1,function(x,...) x)
stopifnot(isTRUE(all.equal(kc1,kc1.default)))
kc1.5=xform(kc1,function(x,...) x, k=5)
stopifnot(isTRUE(all.equal(kc1.5,kc1.default)))
kc1.20=xform(kc1,function(x,...) x, k=20)
stopifnot(!isTRUE(all.equal(kc1,kc1.20)))

# apply two registrations converting sample-&gt;IS2-&gt;JFRC2
reg_seq=c("IS2_sample.list", "JFRC2_IS2.list")
xform(kc1, reg_seq)
# apply two registrations, swapping the direction of the second one
# i.e. sample -&gt; IS2 -&gt; FCWB
reg_seq=structure(c("IS2_sample.list", "IS2_FCWB.list"), swap=c(FALSE, TRUE))
xform(kc1, reg_seq)

## End(Not run)
## Not run: 
# apply reg1 to Cell07PNs[[1]], reg2 to Cell07PNs[[2]] etc
regs=c(reg1, reg2, reg3)
nx=xform(Cell07PNs[1:3], reg=regs, VectoriseRegistrations=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='xformimage'>Transform image files using a registration or affine matrix</h2><span id='topic+xformimage'></span><span id='topic+xformimage.character'></span><span id='topic+xformimage.cmtkreg'></span><span id='topic+xformimage.reglist'></span><span id='topic+xformimage.default'></span>

<h3>Description</h3>

<p>You should almost always call <code><a href="#topic+xform">xform</a></code> rather
calling than<code>xformimage</code> directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xformimage(reg, image, ...)

## S3 method for class 'character'
xformimage(reg, image, ...)

## S3 method for class 'cmtkreg'
xformimage(
  reg,
  image,
  transformtype = c("warp", "affine"),
  direction = NULL,
  ...
)

## S3 method for class 'reglist'
xformimage(reg, image, ...)

## Default S3 method:
xformimage(reg, image, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xformimage_+3A_reg">reg</code></td>
<td>
<p>A registration defined by a matrix or a <code>cmtkreg</code> object, or
a character vector specifying a path to a CMTK registration on disk (see
details). If <code>reg</code> is a character vector of length &gt;1 defining a
sequence of registration files on disk they should proceed from sample to
reference.</p>
</td></tr>
<tr><td><code id="xformimage_+3A_image">image</code></td>
<td>
<p>Nx3 matrix of image</p>
</td></tr>
<tr><td><code id="xformimage_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods (and then eventually to
<code><a href="#topic+cmtk.reformatx">cmtk.reformatx</a></code>)</p>
</td></tr>
<tr><td><code id="xformimage_+3A_transformtype">transformtype</code></td>
<td>
<p>Which transformation to use when the CMTK file contains
both warp (default) and affine (TODO)</p>
</td></tr>
<tr><td><code id="xformimage_+3A_direction">direction</code></td>
<td>
<p>Whether to transform image from sample space to reference
space (called <strong>forward</strong> by CMTK) or from reference to sample space
(called <strong>inverse</strong> by CMTK). Default (when <code>NULL</code> is forward).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When passed a character vector, xformimage will check to see if it
defines a path containing CMTK registration erroring out if this is not the
case. If the path does indeed point to a CMTK registration, this method
will hand off to xformimage.cmtkreg. A future TODO would be to provide a
mechanism for extending this behaviour for other registration formats.
If a list of transformations is passed in, these transformations are passed
to the cmtk reformatx tool in the order received. Note that there is
presently no support for </p>

<ul>
<li><p> using the inverse of a registration
</p>
</li>
<li><p> specifying a mask
</p>
</li>
<li><p> passing additional arguments to reformatx
</p>
</li></ul>

<p>Note that the direction of CMTK registrations can be the source of
much confusion. This is because CMTK defines the <em>forward</em> direction
as the transform required to reformat an image in <em>sample</em> (floating)
space to an image in <em>template</em> space. Since this operation involves
filling a regular grid in template space by looking up the corresponding
positions in sample space, the transformation that is required is (somewhat
counterintuitively) the one that maps template to sample. However in
neuroanatomical work, one often has points in sample space that one would
like to transform into template space. Here one needs CMTK's <em>inverse</em>
transformation.
</p>
<p>A second source of confusion is that when there are multiple
transformations, CMTK's reformatx tool (wrapped by
<code><a href="#topic+cmtk.reformatx">cmtk.reformatx</a></code>) expects them to be listed:
</p>
<p><code>ref_intermediate.list intermediate_sample.list</code>
</p>
<p>where <code>ref_intermediate.list</code> is the CMTK registration obtained with
ref as target/reference and intermediate as sample/floating image.
</p>
<p>For consistency, all <code>xform.*</code> methods expect multiple registrations
to be listed from sample to reference and this order is then swapped when
they are passed on to <code>cmtk.reformatx</code>.
</p>
<p>whereas CMTK's streamxform tool (wrapped by <code><a href="#topic+xformpoints">xformpoints</a></code>)
expects them in the opposite order.
</p>


<h3>Value</h3>

<p>Character vector with path to xformed image.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmtk.reformatx">cmtk.reformatx</a></code>, <code><a href="#topic+xformpoints">xformpoints</a></code>,
<code><a href="#topic+xform">xform</a></code>
</p>

<hr>
<h2 id='xformpoints'>Transform 3D points using a registration, affine matrix or function</h2><span id='topic+xformpoints'></span><span id='topic+xformpoints.character'></span><span id='topic+xformpoints.cmtkreg'></span><span id='topic+xformpoints.reglist'></span><span id='topic+xformpoints.default'></span>

<h3>Description</h3>

<p>You should almost always call <code><a href="#topic+xform">xform</a></code> rather calling
than<code>xformpoints</code> directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xformpoints(reg, points, ...)

## S3 method for class 'character'
xformpoints(reg, points, ...)

## S3 method for class 'cmtkreg'
xformpoints(
  reg,
  points,
  transformtype = c("warp", "affine"),
  direction = NULL,
  FallBackToAffine = FALSE,
  ...
)

## S3 method for class 'reglist'
xformpoints(reg, points, ...)

## Default S3 method:
xformpoints(reg, points, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xformpoints_+3A_reg">reg</code></td>
<td>
<p>A registration defined by a matrix, a function, a
<code><a href="#topic+cmtkreg">cmtkreg</a></code> object, a <code><a href="#topic+reglist">reglist</a></code> object containing a
sequence of arbitrary registrations, or a character vector specifying
path(s) to registrations on disk (see details).</p>
</td></tr>
<tr><td><code id="xformpoints_+3A_points">points</code></td>
<td>
<p>Nx3 matrix of points</p>
</td></tr>
<tr><td><code id="xformpoints_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="xformpoints_+3A_transformtype">transformtype</code></td>
<td>
<p>Which transformation to use when the CMTK file contains
both warp (default) and affine</p>
</td></tr>
<tr><td><code id="xformpoints_+3A_direction">direction</code></td>
<td>
<p>Whether to transform points from sample space to reference
space (called <strong>inverse</strong> by CMTK) or from reference to sample space
(called <strong>forward</strong> by CMTK). Default (when <code>NULL</code> is inverse).</p>
</td></tr>
<tr><td><code id="xformpoints_+3A_fallbacktoaffine">FallBackToAffine</code></td>
<td>
<p>Whether to use the affine transformation for points
that fail to transform under a warping transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a list of transformations is passed in, these transformations are
performed in sequence order, such that <code>xformpoints(c(a,b,c), x) ==
xformpoints(c, (xformpoints(b, xformpoints(a, x))))</code>
</p>
<p>Note that the direction of CMTK registrations can be the source of
much confusion. This is because CMTK defines the <em>forward</em> direction
as the transform required to reformat an image in <em>sample</em> (floating)
space to an image in <em>template</em> space. Since this operation involves
filling a regular grid in template space by looking up the corresponding
positions in sample space, the transformation that is required is (somewhat
counterintuitively) the one that maps template to sample. However in
neuroanatomical work, one often has points in sample space that one would
like to transform into template space. Here one needs the <em>inverse</em>
transformation.
</p>

<hr>
<h2 id='xyzmatrix'>Get and assign coordinates for classes containing 3D vertex data</h2><span id='topic+xyzmatrix'></span><span id='topic+xyzmatrix.default'></span><span id='topic+xyzmatrix.neuron'></span><span id='topic+xyzmatrix.neuronlist'></span><span id='topic+xyzmatrix.dotprops'></span><span id='topic+xyzmatrix.hxsurf'></span><span id='topic+xyzmatrix.igraph'></span><span id='topic+xyzmatrix.mesh3d'></span><span id='topic+xyzmatrix+3C-'></span><span id='topic+xyzmatrix+3C-.neuron'></span><span id='topic+xyzmatrix+3C-.dotprops'></span><span id='topic+xyzmatrix+3C-.hxsurf'></span><span id='topic+xyzmatrix+3C-.igraph'></span><span id='topic+xyzmatrix+3C-.shape3d'></span><span id='topic+xyzmatrix+3C-.neuronlist'></span>

<h3>Description</h3>

<p><code>xyzmatrix</code> gets coordinates from objects containing 3D vertex data
</p>
<p><code>xyzmatrix&lt;-</code> assigns xyz elements of neuron or dotprops
object and can also handle matrix like objects with columns named X, Y, Z
or x, y, z.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyzmatrix(x, ...)

## Default S3 method:
xyzmatrix(x, y = NULL, z = NULL, ...)

## S3 method for class 'neuron'
xyzmatrix(x, ...)

## S3 method for class 'neuronlist'
xyzmatrix(x, ...)

## S3 method for class 'dotprops'
xyzmatrix(x, ...)

## S3 method for class 'hxsurf'
xyzmatrix(x, ...)

## S3 method for class 'igraph'
xyzmatrix(x, ...)

## S3 method for class 'mesh3d'
xyzmatrix(x, ...)

xyzmatrix(x) &lt;- value

## S3 replacement method for class 'neuron'
xyzmatrix(x) &lt;- value

## S3 replacement method for class 'dotprops'
xyzmatrix(x) &lt;- value

## S3 replacement method for class 'hxsurf'
xyzmatrix(x) &lt;- value

## S3 replacement method for class 'igraph'
xyzmatrix(x) &lt;- value

## S3 replacement method for class 'shape3d'
xyzmatrix(x) &lt;- value

## S3 replacement method for class 'neuronlist'
xyzmatrix(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyzmatrix_+3A_x">x</code></td>
<td>
<p>object containing 3D coordinates</p>
</td></tr>
<tr><td><code id="xyzmatrix_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="xyzmatrix_+3A_y">y</code>, <code id="xyzmatrix_+3A_z">z</code></td>
<td>
<p>separate y and z coordinates</p>
</td></tr>
<tr><td><code id="xyzmatrix_+3A_value">value</code></td>
<td>
<p>Nx3 matrix specifying new xyz coords</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>xyzmatrix</code> can extract or set 3D coordinates in a 
<code>matrix</code> or <code>data.frame</code> that <b>either</b> has exactly 3 columns
<b>or</b> has 3 columns named X,Y,Z or x,y,z.
</p>


<h3>Value</h3>

<p>For <code>xyzmatrix</code>: Nx3 matrix containing 3D coordinates
</p>
<p>For <code>xyzmatrix&lt;-</code>: Original object with modified coords
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xyzmatrix">xyzmatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see all available methods for different classes
methods('xyzmatrix')
# ... and for the assignment method
methods('xyzmatrix&lt;-')
n=Cell07PNs[[1]]
xyzmatrix(n)&lt;-xyzmatrix(n)
stopifnot(isTRUE(
  all.equal(xyzmatrix(n),xyzmatrix(Cell07PNs[[1]]))
))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
