<!DOCTYPE html><html><head><title>Help for package MRFcov</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MRFcov}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Bird.parasites'><p>Blood parasite occurrences in New Caledonian birds.</p></a></li>
<li><a href='#bootstrap_MRF'><p>Bootstrap observations to estimate MRF parameter coefficients</p></a></li>
<li><a href='#cv_MRF_diag'><p>MRF cross validation and assessment of predictive performance</p></a></li>
<li><a href='#MRFcov'><p>Markov Random Fields with covariates</p></a></li>
<li><a href='#MRFcov_spatial'><p>Spatially structured Markov Random Fields with covariates</p></a></li>
<li><a href='#plotMRF_hm'><p>Plot MRF interaction parameters as a heatmap</p></a></li>
<li><a href='#predict_MRF'><p>Predict training observations from fitted MRFcov models</p></a></li>
<li><a href='#predict_MRFnetworks'><p>Extract predicted network metrics for observations in a given dataset using</p>
equations from a fitted <code>MRFcov</code> object</a></li>
<li><a href='#prep_MRF_covariates'><p>Cross-multiply response and covariate variables</p></a></li>
<li><a href='#prep_MRF_covariates_spatial'><p>Cross-multiply response and covariate variables and build spatial splines</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Markov Random Fields with Additional Covariates</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.39</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-06 10:13:19 UTC</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nicholasjclark/MRFcov">https://github.com/nicholasjclark/MRFcov</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas J Clark &lt;nicholas.j.clark1214@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Approximate node interaction parameters of Markov Random Fields 
    graphical networks. Models can incorporate additional covariates, allowing users to estimate
    how interactions between nodes in the graph are predicted to change across
    covariate gradients. The general methods implemented in this package are described 
    in Clark et al. (2018) &lt;<a href="https://doi.org/10.1002%2Fecy.2221">doi:10.1002/ecy.2221</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.3), glmnet</td>
</tr>
<tr>
<td>Imports:</td>
<td>purrr, parallel, plyr, ggplot2, dplyr, caret, gridExtra,
magrittr, Matrix, stats, utils, reshape2, sfsmisc, igraph,
grDevices, pbapply, mgcv, MASS</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-06 06:53:59 UTC; Nick</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas J Clark [aut, cre],
  Konstans Wells [aut],
  Oscar Lindberg [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
</table>
<hr>
<h2 id='Bird.parasites'>Blood parasite occurrences in New Caledonian birds.</h2><span id='topic+Bird.parasites'></span>

<h3>Description</h3>

<p>A dataset containing binary occurrences of four blood parasite species
in New Caledonian birds. The first four variables represent the parasite occurrences
and the last variable is a scaled continuous covariate representing host relative
abundance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bird.parasites
</code></pre>


<h3>Format</h3>

<p>A data frame with 449 rows and 5 variables:
</p>

<dl>
<dt>Hzosteropis</dt><dd><p>binary occurrence of <em>Haemoproteus zosteropis</em></p>
</dd>
<dt>Hkillangoi</dt><dd><p>binary occurrence of <em>Haemoproteus killangoi</em></p>
</dd>
<dt>Plas</dt><dd><p>binary occurrence of <em>Plasmdodium</em> species</p>
</dd>
<dt>Microfilaria</dt><dd><p>binary occurrence of Microfilaria species</p>
</dd>
<dt>scale.prop.zos</dt><dd><p>scaled numeric variable representing relative abundance
of <em>Zosterops</em> host species</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.5061/dryad.pp6k4">doi:10.5061/dryad.pp6k4</a>
</p>


<h3>References</h3>

<p>Clark, N.J., Wells, K., Dimitrov, D. &amp; Clegg, S.M. (2016)
Co-infections and environmental conditions drive the distributions of blood
parasites in wild birds. Journal of Animal Ecology, 85, 1461-1470.
</p>

<hr>
<h2 id='bootstrap_MRF'>Bootstrap observations to estimate MRF parameter coefficients</h2><span id='topic+bootstrap_MRF'></span>

<h3>Description</h3>

<p>This function runs <code><a href="#topic+MRFcov">MRFcov</a></code> models multiple times to capture uncertainty
in parameter esimates. The dataset is shuffled and missing
values (if found) are imputed in each bootstrap iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_MRF(
  data,
  n_bootstraps,
  sample_seed,
  symmetrise,
  n_nodes,
  n_cores,
  n_covariates,
  family,
  sample_prop,
  spatial = FALSE,
  coords = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_MRF_+3A_data">data</code></td>
<td>
<p>Dataframe. The input data where the <code>n_nodes</code>
left-most variables are variables that are to be represented by nodes in the graph.
Note that <code>NA</code>'s are allowed for covariates. If present, these missing values
will be imputed from the distribution <code>rnorm(mean = 0, sd = 1)</code>, which assumes that
all covariates are scaled and centred (i.e. by using the function
<code><a href="base.html#topic+scale">scale</a></code> or similar)</p>
</td></tr>
<tr><td><code id="bootstrap_MRF_+3A_n_bootstraps">n_bootstraps</code></td>
<td>
<p>Positive integer. Represents the total number of bootstrap samples
to test. Default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_MRF_+3A_sample_seed">sample_seed</code></td>
<td>
<p>Numeric. Used as the seed value for generating bootstrap replicates, allowing
users to generate replicated datasets on different systems. Default is a random seed</p>
</td></tr>
<tr><td><code id="bootstrap_MRF_+3A_symmetrise">symmetrise</code></td>
<td>
<p>The method to use for symmetrising corresponding parameter estimates
(which are taken from separate regressions). Options are <code>min</code> (take the coefficient with the
smallest absolute value), <code>max</code> (take the coefficient with the largest absolute value)
or <code>mean</code> (take the mean of the two coefficients). Default is <code>mean</code></p>
</td></tr>
<tr><td><code id="bootstrap_MRF_+3A_n_nodes">n_nodes</code></td>
<td>
<p>Positive integer. The index of the last column in <code>data</code>
which is represented by a node in the final graph. Columns with index
greater than <code>n_nodes</code> are taken as covariates. Default is the number of
columns in <code>data</code>, corresponding to no additional covariates</p>
</td></tr>
<tr><td><code id="bootstrap_MRF_+3A_n_cores">n_cores</code></td>
<td>
<p>Integer. The number of cores to spread the job across using
<code><a href="parallel.html#topic+makePSOCKcluster">makePSOCKcluster</a></code>. Default is 1 (no parallelisation)</p>
</td></tr>
<tr><td><code id="bootstrap_MRF_+3A_n_covariates">n_covariates</code></td>
<td>
<p>Positive integer. The number of covariates in <code>data</code>,
before cross-multiplication. Default is <code>NCOL(data) - n_nodes</code></p>
</td></tr>
<tr><td><code id="bootstrap_MRF_+3A_family">family</code></td>
<td>
<p>The response type. Responses can be quantitative continuous (<code>family = "gaussian"</code>),
non-negative counts (<code>family = "poisson"</code>) or binomial 1s and 0s (<code>family = "binomial"</code>)</p>
</td></tr>
<tr><td><code id="bootstrap_MRF_+3A_sample_prop">sample_prop</code></td>
<td>
<p>Positive probability value indicating the proportion of rows to sample from
<code>data</code> in each bootstrap iteration. Default is no subsampling (<code>sample_prop == 1</code>)</p>
</td></tr>
<tr><td><code id="bootstrap_MRF_+3A_spatial">spatial</code></td>
<td>
<p>Logical. If <code>TRUE</code>, spatial MRF / CRF models are bootstrapped using
<code><a href="#topic+MRFcov_spatial">MRFcov_spatial</a></code>. Note, GPS coordinates must be supplied as <code>coords</code> for spatial
models to be run.
Smoothed spatial splines will be included in each node-wise regression as covariates.
This ensures resulting node interaction parameters are estimated after accounting for
possible spatial autocorrelation. Note that interpretation of spatial autocorrelation is difficult,
and so it is recommended to compare predictive capacities spatial and non-spatial CRFs through
the <code><a href="#topic+predict_MRF">predict_MRF</a></code> function</p>
</td></tr>
<tr><td><code id="bootstrap_MRF_+3A_coords">coords</code></td>
<td>
<p>A two-column <code>dataframe</code> (with <code>nrow(coords) == nrow(data)</code>)
representing the spatial coordinates of each observation in <code>data</code>. Ideally, these
coordinates will represent Latitude and Longitude GPS points for each observation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MRFcov</code> models are fit via cross-validation using
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>. For each model, the <code>data</code> is bootstrapped
by shuffling row observations and fitting models to a subset of observations
to account for uncertainty in parameter estimates.
Parameter estimates from the set of bootstrapped models are summarised
to present means and confidence intervals (as 95 percent quantiles).
</p>


<h3>Value</h3>

<p>A <code>list</code> containing:
</p>

<ul>
<li> <p><code>direct_coef_means</code>: <code>dataframe</code> containing mean coefficient values taken from all
bootstrapped models across the iterations
</p>
</li>
<li> <p><code>direct_coef_upper90</code> and <code>direct_coef_lower90</code>: <code>dataframe</code>s
containing coefficient 95 percent and 5 percent quantiles taken from all
bootstrapped models across the iterations
</p>
</li>
<li> <p><code>indirect_coef_mean</code>: <code>list</code> of symmetric matrices
(one matrix for each covariate) containing mean effects of covariates
on pairwise interactions
</p>
</li>
<li> <p><code>mean_key_coefs</code>: <code>list</code> of matrices of length <code>n_nodes</code>
containing mean covariate coefficient values and their relative importances
(using the formula <code>x^2 / sum (x^2)</code>
taken from all bootstrapped models across iterations. Only coefficients
with mean relative importances <code>&gt;0.01</code> are returned. Note, relative importance are only
useful if all covariates are on a similar scale.
</p>
</li>
<li> <p><code>mod_type</code>: A character stating the type of model that was fit
(used in other functions)
</p>
</li>
<li> <p><code>mod_family</code>: A character stating the family of model that was fit
(used in other functions)
</p>
</li>
<li> <p><code>poiss_sc_factors</code>: A vector of the square-root mean scaling factors
used to standardise <code>poisson</code> variables (only returned if <code>family = "poisson"</code>)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+MRFcov">MRFcov</a></code>, <code><a href="#topic+MRFcov_spatial">MRFcov_spatial</a></code>,
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Bird.parasites")

# Perform 2 quick bootstrap replicates using 70% of observations
bootedCRF &lt;- bootstrap_MRF(data = Bird.parasites,
                          n_nodes = 4,
                          family = 'binomial',
                          sample_prop = 0.7,
                          n_bootstraps = 2)


# Small example of using spatial coordinates for a spatial CRF
Latitude &lt;- sample(seq(120, 140, length.out = 100), nrow(Bird.parasites), TRUE)
Longitude &lt;- sample(seq(-19, -22, length.out = 100), nrow(Bird.parasites), TRUE)
coords &lt;- data.frame(Latitude = Latitude, Longitude = Longitude)
bootedSpatial &lt;- bootstrap_MRF(data = Bird.parasites, n_nodes = 4,
                             family = 'binomial',
                             spatial = TRUE,
                             coords = coords,
                             sample_prop = 0.5,
                             n_bootstraps = 2)
</code></pre>

<hr>
<h2 id='cv_MRF_diag'>MRF cross validation and assessment of predictive performance</h2><span id='topic+cv_MRF_diag'></span><span id='topic+cv_MRF_diag_rep'></span><span id='topic+cv_MRF_diag_rep_spatial'></span>

<h3>Description</h3>

<p><code>cv_MRF_diag</code> runs cross validation of <code><a href="#topic+MRFcov">MRFcov</a></code> models and tests predictive
performance.
</p>
<p><code>cv_MRF_diag_rep</code> fits a single node-optimised model
and test's this model's predictive performance across multiple test subsets of the <code>data</code>.
</p>
<p><code>cv_MRF_diag_rep_spatial</code> fits a single node-optimised spatial model
and test's this model's predictive performance across multiple test subsets of the <code>data</code>.
<br />
<br />
All <code>cv_MRF</code> functions assess model predictive performance and produce
either diagnostic plots or matrices of predictive metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_MRF_diag(
  data,
  symmetrise,
  n_nodes,
  n_cores,
  sample_seed,
  n_folds,
  n_fold_runs,
  n_covariates,
  compare_null,
  family,
  plot = TRUE,
  cached_model,
  cached_predictions,
  mod_labels = NULL
)

cv_MRF_diag_rep(
  data,
  symmetrise,
  n_nodes,
  n_cores,
  sample_seed,
  n_folds,
  n_fold_runs,
  n_covariates,
  compare_null,
  family,
  plot = TRUE
)

cv_MRF_diag_rep_spatial(
  data,
  coords,
  symmetrise,
  n_nodes,
  n_cores,
  sample_seed,
  n_folds,
  n_fold_runs,
  n_covariates,
  compare_null,
  family,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_MRF_diag_+3A_data">data</code></td>
<td>
<p>Dataframe. The input data where the <code>n_nodes</code>
left-most variables are variables that are to be represented by nodes in the graph.
Note that <code>NA</code>'s are allowed for covariates. If present, these missing values
will be imputed from the distribution <code>rnorm(mean = 0, sd = 1)</code>, which assumes that
all covariates are scaled and centred (i.e. by using the function
<code><a href="base.html#topic+scale">scale</a></code> or similar)</p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_symmetrise">symmetrise</code></td>
<td>
<p>The method to use for symmetrising corresponding parameter estimates
(which are taken from separate regressions). Options are <code>min</code> (take the coefficient with the
smallest absolute value), <code>max</code> (take the coefficient with the largest absolute value)
or <code>mean</code> (take the mean of the two coefficients). Default is <code>mean</code></p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_n_nodes">n_nodes</code></td>
<td>
<p>Positive integer. The index of the last column in <code>data</code>
which is represented by a node in the final graph. Columns with index
greater than n_nodes are taken as covariates. Default is the number of
columns in <code>data</code>, corresponding to no additional covariates</p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_n_cores">n_cores</code></td>
<td>
<p>Positive integer. The number of cores to spread the job across using
<code><a href="parallel.html#topic+makePSOCKcluster">makePSOCKcluster</a></code>. Default is 1 (no parallelisation)</p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_sample_seed">sample_seed</code></td>
<td>
<p>Numeric. This seed will be used as the basis
for dividing data into folds. Default is a random seed
between 1 and 100000</p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_n_folds">n_folds</code></td>
<td>
<p>Integer. The number of folds for cross-validation. Default is 10</p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_n_fold_runs">n_fold_runs</code></td>
<td>
<p>Integer. The number of total training runs to perform. During
each run, the data will be split into <code>n_folds</code> folds and the
observed data in each fold will be compared to their respective predictions.
Defaults to <code>n_folds</code></p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_n_covariates">n_covariates</code></td>
<td>
<p>Positive integer. The number of covariates in <code>data</code>, before cross-multiplication</p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_compare_null">compare_null</code></td>
<td>
<p>Logical. If <code>TRUE</code>, null models will also be run and plotted to
assess the influence of including covariates on model predictive performance.
Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_family">family</code></td>
<td>
<p>The response type. Responses can be quantitative continuous (<code>family = "gaussian"</code>),
non-negative counts (<code>family = "poisson"</code>) or binomial 1s and 0s (<code>family = "binomial"</code>).</p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code>ggplot2</code> objects are returned. If <code>FALSE</code>,
the prediction metrics are returned as a matrix. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_cached_model">cached_model</code></td>
<td>
<p>Used by function <code><a href="#topic+cv_MRF_diag_rep">cv_MRF_diag_rep</a></code> to store an optimised model and prevent
unneccessary replication of node-optimised model fitting</p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_cached_predictions">cached_predictions</code></td>
<td>
<p>Used by function <code><a href="#topic+cv_MRF_diag_rep">cv_MRF_diag_rep</a></code> to store predictions from
optimised models and prevent unneccessary replication</p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_mod_labels">mod_labels</code></td>
<td>
<p>Optional character string of labels for the two models being compared
(if <code>compare_null == TRUE</code>)</p>
</td></tr>
<tr><td><code id="cv_MRF_diag_+3A_coords">coords</code></td>
<td>
<p>A two-column <code>dataframe</code> (with <code>nrow(coords) == nrow(data)</code>)
representing the spatial coordinates of each observation in <code>data</code>. Ideally, these
coordinates will represent Latitude and Longitude GPS points for each observation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Node-optimised models are fitted using <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>,
and these models is used to predict <code>data</code> test subsets.
Test and training <code>data</code> subsets are created using <code><a href="caret.html#topic+createFolds">createFolds</a></code>.
<br />
<br />
To account for uncertainty in parameter estimates and in random fold generation, it is recommended
to perform cross-validation multiple times (by controlling the <code>n_fold_runs</code> argument) using
<code>cv_MRF_diag_rep</code> to supply a single cached model and that model's predictions.
This is useful for optimising a single model (using <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>) and testing
this model's predictive performance across many test subsets. Alternatively, one can run
<code>cv_MRF_diag</code> many times to fit different models in each iteration. This will be slower but
technically more sound
</p>


<h3>Value</h3>

<p>If <code>plot = TRUE</code>, a <code>ggplot2</code> object is returned. This will be
a plot containing boxplots of predictive metrics across test sets using the
optimised model (see <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code> for further details of <code>lambda1</code>
optimisation). If <code>plot = FALSE</code>, a matrix of prediction metrics is returned.
</p>


<h3>References</h3>

<p>Clark, NJ, Wells, K and Lindberg, O.
Unravelling changing interspecific interactions across environmental gradients
using Markov random fields. (2018). Ecology doi: 10.1002/ecy.2221
<a href="https://www.researchgate.net/publication/325184442_Unravelling_changing_interspecific_interactions_across_environmental_gradients_using_Markov_random_fields">Full text here</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MRFcov">MRFcov</a></code>,
<code><a href="#topic+predict_MRF">predict_MRF</a></code>,
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Bird.parasites")
# Generate boxplots of model predictive metrics
cv_MRF_diag(data = Bird.parasites, n_nodes = 4,
           n_cores = 1, family = 'binomial')

# Generate boxplots comparing the CRF to an MRF model (no covariates)
cv_MRF_diag(data = Bird.parasites, n_nodes = 4,
           n_cores = 1, family = 'binomial',
           compare_null = TRUE)

# Replicate 10-fold cross-validation 10 times
cv.preds &lt;- cv_MRF_diag_rep(data = Bird.parasites, n_nodes = 4,
                           n_cores = 1, family = 'binomial',
                           compare_null = TRUE,
                           plot = FALSE, n_fold_runs = 10)

# Plot model sensitivity and % true predictions
library(ggplot2)
gridExtra::grid.arrange(
 ggplot(data = cv.preds, aes(y = mean_sensitivity, x = model)) +
       geom_boxplot() + theme(axis.text.x = ggplot2::element_blank()) +
       labs(x = ''),
 ggplot(data = cv.preds, aes(y = mean_tot_pred, x = model)) +
       geom_boxplot(),
       ncol = 1,
 heights = c(1, 1))

# Create some sample Poisson data with strong correlations
cov &lt;- rnorm(500, 0.2)
cov2 &lt;- rnorm(500, 1)
sp.2 &lt;- rpois(500, lambda = exp(1.5 + (cov * 0.9)))
poiss.dat &lt;- data.frame(sp.1 = rpois(500, lambda = exp(0.5 + (cov * 0.3))),
                       sp.2 = sp.2,
                       sp.3 = rpois(500, lambda = exp(log(sp.2 + 1) + (cov * -0.5))),
                       cov = cov,
                       cov2 = cov2)

# A CRF should produce a better fit (lower deviance, lower MSE)
cvMRF.poiss &lt;- cv_MRF_diag(data = poiss.dat, n_nodes = 3,
                          n_folds = 10,
                          family = 'poisson',
                          compare_null = TRUE, plot = TRUE)


</code></pre>

<hr>
<h2 id='MRFcov'>Markov Random Fields with covariates</h2><span id='topic+MRFcov'></span>

<h3>Description</h3>

<p>This function is the workhorse of the <code>MRFcov</code> package, running
separate penalized regressions for each node to estimate parameters of
Markov Random Fields (MRF) graphs. Covariates can be included
(a class of models known as Conditional Random Fields; CRF), to estimate
how interactions between nodes vary across covariate magnitudes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRFcov(
  data,
  symmetrise,
  prep_covariates,
  n_nodes,
  n_cores,
  n_covariates,
  family,
  bootstrap = FALSE,
  progress_bar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MRFcov_+3A_data">data</code></td>
<td>
<p>A <code>dataframe</code>. The input data where the <code>n_nodes</code>
left-most variables are variables that are to be represented by nodes in the graph</p>
</td></tr>
<tr><td><code id="MRFcov_+3A_symmetrise">symmetrise</code></td>
<td>
<p>The method to use for symmetrising corresponding parameter estimates
(which are taken from separate regressions). Options are <code>min</code> (take the coefficient with the
smallest absolute value), <code>max</code> (take the coefficient with the largest absolute value)
or <code>mean</code> (take the mean of the two coefficients). Default is <code>mean</code></p>
</td></tr>
<tr><td><code id="MRFcov_+3A_prep_covariates">prep_covariates</code></td>
<td>
<p>Logical. If <code>TRUE</code>, covariate columns will be cross-multiplied
with nodes to prep the dataset for MRF models. Note this is only useful when additional
covariates are provided. Therefore, if <code>n_nodes &lt; NCOL(data)</code>,
default is <code>TRUE</code>. Otherwise, default is <code>FALSE</code>. See
<code><a href="#topic+prep_MRF_covariates">prep_MRF_covariates</a></code> for more information</p>
</td></tr>
<tr><td><code id="MRFcov_+3A_n_nodes">n_nodes</code></td>
<td>
<p>Positive integer. The index of the last column in <code>data</code>
which is represented by a node in the final graph. Columns with index
greater than n_nodes are taken as covariates. Default is the number of
columns in <code>data</code>, corresponding to no additional covariates</p>
</td></tr>
<tr><td><code id="MRFcov_+3A_n_cores">n_cores</code></td>
<td>
<p>Positive integer. The number of cores to spread the job across using
<code><a href="parallel.html#topic+makePSOCKcluster">makePSOCKcluster</a></code>. Default is 1 (no parallelisation)</p>
</td></tr>
<tr><td><code id="MRFcov_+3A_n_covariates">n_covariates</code></td>
<td>
<p>Positive integer. The number of covariates in <code>data</code>, before cross-multiplication.
Default is <code>NCOL(data) - n_nodes</code></p>
</td></tr>
<tr><td><code id="MRFcov_+3A_family">family</code></td>
<td>
<p>The response type. Responses can be quantitative continuous (<code>family = "gaussian"</code>),
non-negative counts (<code>family = "poisson"</code>) or binomial 1s and 0s (<code>family = "binomial"</code>).
If using (<code>family = "binomial"</code>), please note that if nodes occur in less than 5 percent
of observations this can make it generally difficult to
estimate occurrence probabilities (on the extreme end, this can result in intercept-only
models being fitted for the nodes in question). The function will issue a warning in this case.
If nodes occur in more than 95 percent of observations, this will return an error as the cross-validation
step will generally be unable to proceed. For <code>family = 'poisson'</code> models, all returned
coefficients are estimated on the identity scale AFTER using a nonparanormal transformation.
See <code>vignette("Gaussian_Poisson_CRFs")</code> for details of interpretation</p>
</td></tr>
<tr><td><code id="MRFcov_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Logical. Used by <code><a href="#topic+bootstrap_MRF">bootstrap_MRF</a></code> to reduce memory usage</p>
</td></tr>
<tr><td><code id="MRFcov_+3A_progress_bar">progress_bar</code></td>
<td>
<p>Logical. Progress bar in pbapply is used if <code>TRUE</code>, but this slows estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Separate penalized regressions are used to approximate
MRF parameters, where the regression for node <code>j</code> includes an
intercept and coefficients for the abundance (families <code>gaussian</code> or <code>poisson</code>)
or presence-absence (family <code>binomial</code>) of all other
nodes (<code>/j</code>) in <code>data</code>. If covariates are included, coefficients
are also estimated for the effect of the covariate on <code>j</code>, and for the
effects of the covariate on interactions between <code>j</code> and all other nodes
(<code>/j</code>). Note that interaction coefficients must be estimated between variables that
are on roughly the same scale, as the resulting parameter estimates are
unified into a Markov Random Field using the specified <code>symmetrise</code> function.
Counts for <code>poisson</code> variables, which are often not on the same scale,
will therefore be normalised with a nonparanormal transformation
<code>x = qnorm(rank(log2(x + 0.01)) / (length(x) + 1))</code>. These transformed counts
will be used in a <code>(family = "gaussian")</code>
model and their respective raw distribution parameters returned so that coefficients
can be back-transformed for interpretation (this back-transformation is
performed automatatically by other functions including <code><a href="#topic+predict_MRF">predict_MRF</a></code>
and <code><a href="#topic+cv_MRF_diag">cv_MRF_diag</a></code>). Gaussian variables are not automatically transformed, so
if they cover quite different ranges and scales, then it is recommended to scale them prior to fitting
models. For more information on this process, use
<code>vignette("Gaussian_Poisson_CRFs")</code>
<br />
<br />
Note that since the number of parameters to estimate in each node-wise regression
quickly increases with increasing numbers of nodes and covariates,
LASSO penalization is used to regularize
regressions. This is done by minimising the cross-validated
mean error for each node separately using <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>. In this way,
we maximise the log-likelihood of each node
separately before unifying the nodes into a graph.
</p>


<h3>Value</h3>

<p>A <code>list</code> containing:
</p>

<ul>
<li> <p><code>graph</code>: Estimated parameter <code>matrix</code> of pairwise interaction effects
</p>
</li>
<li> <p><code>intercepts</code>: Estimated parameter <code>vector</code> of node intercepts
</p>
</li>
<li> <p><code>indirect_coefs</code>: <code>list</code> containing matrices representing
indirect effects of each covariate on pairwise node interactions
</p>
</li>
<li> <p><code>direct_coefs</code>: <code>matrix</code> of direct effects of each parameter on
each outcome node. For <code>family = 'binomial'</code> models, all coefficients are
estimated on the logit scale.
</p>
</li>
<li> <p><code>param_names</code>: Character string of covariate parameter names
</p>
</li>
<li> <p><code>mod_type</code>: A character stating the type of model that was fit
(used in other functions)
</p>
</li>
<li> <p><code>mod_family</code>: A character stating the family of model that was fit
(used in other functions)
</p>
</li>
<li> <p><code>poiss_sc_factors</code>: A matrix of the estimated negative binomial or
poisson parameters for each raw  node variable (only returned if <code>family = "poisson"</code>).
These are needed for converting coefficients back to their original distribution, and are
used for prediction purposes only
</p>
</li></ul>



<h3>References</h3>

<p>Ising, E. (1925). Beitrag zur Theorie des Ferromagnetismus.
Zeitschrift f√ºr Physik A Hadrons and Nuclei, 31, 253-258.<br /><br />
Cheng, J., Levina, E., Wang, P. &amp; Zhu, J. (2014).
A sparse Ising model with covariates. (2012). Biometrics, 70, 943-953.<br /><br />
Clark, NJ, Wells, K and Lindberg, O.
Unravelling changing interspecific interactions across environmental gradients
using Markov random fields. (2018). Ecology doi: 10.1002/ecy.2221
<a href="https://www.researchgate.net/publication/325184442_Unravelling_changing_interspecific_interactions_across_environmental_gradients_using_Markov_random_fields">Full text here</a>.<br /><br />
Sutton C, McCallum A. An introduction to conditional random fields.
Foundations and Trends in Machine Learning 4, 267-373.
</p>


<h3>See Also</h3>

<p>Cheng et al. (2014), Sutton &amp; McCallum (2012) and Clark et al. (2018)
for overviews of Conditional Random Fields. See <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code> for
details of cross-validated optimization using LASSO penalty. Worked examples to showcase
this function can be found using <code>vignette("Bird_Parasite_CRF")</code> and
<code>vignette("Gaussian_Poisson_CRFs")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Bird.parasites")
CRFmod &lt;- MRFcov(data = Bird.parasites, n_nodes = 4, family = 'binomial')

</code></pre>

<hr>
<h2 id='MRFcov_spatial'>Spatially structured Markov Random Fields with covariates</h2><span id='topic+MRFcov_spatial'></span>

<h3>Description</h3>

<p>This function calls the <code><a href="#topic+MRFcov">MRFcov</a></code> function to fit
separate penalized regressions for each node and approximate parameters of
Markov Random Fields (MRF) graphs. Supplied GPS coordinates are used to
account for spatial autocorrelation via Gaussian Process spatial regression
splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRFcov_spatial(
  data,
  symmetrise,
  prep_covariates,
  n_nodes,
  n_cores,
  n_covariates,
  family,
  coords,
  prep_splines = TRUE,
  bootstrap = FALSE,
  progress_bar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MRFcov_spatial_+3A_data">data</code></td>
<td>
<p>A <code>dataframe</code>. The input data where the <code>n_nodes</code>
left-most variables are variables that are to be represented by nodes in the graph</p>
</td></tr>
<tr><td><code id="MRFcov_spatial_+3A_symmetrise">symmetrise</code></td>
<td>
<p>The method to use for symmetrising corresponding parameter estimates
(which are taken from separate regressions). Options are <code>min</code> (take the coefficient with the
smallest absolute value), <code>max</code> (take the coefficient with the largest absolute value)
or <code>mean</code> (take the mean of the two coefficients). Default is <code>mean</code></p>
</td></tr>
<tr><td><code id="MRFcov_spatial_+3A_prep_covariates">prep_covariates</code></td>
<td>
<p>Logical. If <code>TRUE</code>, covariate columns will be cross-multiplied
with nodes to prep the dataset for MRF models. Note this is only useful when additional
covariates are provided. Therefore, if <code>n_nodes &lt; NCOL(data)</code>,
default is <code>TRUE</code>. Otherwise, default is <code>FALSE</code>. See
<code><a href="#topic+prep_MRF_covariates">prep_MRF_covariates</a></code> for more information</p>
</td></tr>
<tr><td><code id="MRFcov_spatial_+3A_n_nodes">n_nodes</code></td>
<td>
<p>Positive integer. The index of the last column in <code>data</code>
which is represented by a node in the final graph. Columns with index
greater than n_nodes are taken as covariates. Default is the number of
columns in <code>data</code>, corresponding to no additional covariates</p>
</td></tr>
<tr><td><code id="MRFcov_spatial_+3A_n_cores">n_cores</code></td>
<td>
<p>Positive integer. The number of cores to spread the job across using
<code><a href="parallel.html#topic+makePSOCKcluster">makePSOCKcluster</a></code>. Default is 1 (no parallelisation)</p>
</td></tr>
<tr><td><code id="MRFcov_spatial_+3A_n_covariates">n_covariates</code></td>
<td>
<p>Positive integer. The number of covariates in <code>data</code>, before cross-multiplication.
Default is <code>NCOL(data) - n_nodes</code></p>
</td></tr>
<tr><td><code id="MRFcov_spatial_+3A_family">family</code></td>
<td>
<p>The response type. Responses can be quantitative continuous (<code>family = "gaussian"</code>),
non-negative counts (<code>family = "poisson"</code>) or binomial 1s and 0s (<code>family = "binomial"</code>).
If using (<code>family = "binomial"</code>), please note that if nodes occur in less than 5 percent
of observations this can make it generally difficult to
estimate occurrence probabilities (on the extreme end, this can result in intercept-only
models being fitted for the nodes in question). The function will issue a warning in this case.
If nodes occur in more than 95 percent of observations, this will return an error as the cross-validation
step will generally be unable to proceed. For <code>family = 'poisson'</code> models, all returned
coefficients are estimated on the identity scale AFTER using a nonparanormal transformation.
See <code>vignette("Gaussian_Poisson_CRFs")</code> for details of interpretation</p>
</td></tr>
<tr><td><code id="MRFcov_spatial_+3A_coords">coords</code></td>
<td>
<p>A two-column <code>dataframe</code> (with <code>nrow(coords) == nrow(data)</code>)
representing the spatial coordinates of each observation in <code>data</code>. Ideally, these
coordinates will represent Latitude and Longitude GPS points for each observation. The coordinates
are used to create smoothed Gaussian Process spatial regression splines via
<code><a href="mgcv.html#topic+smooth.construct2">smooth.construct2</a></code>.
Here, the basis dimension of the smoothed term
is chosen based on the number of unique GPS coordinates in <code>coords</code>.
If this number is less than <code>100</code>, then this number is used. If the number of
unique coordiantes is more than <code>100</code>, a value of <code>100</code> is used
(this parameter needs to be large in order to ensure enough degrees of freedom
for estimating 'wiggliness' of the smooth term; see
<code><a href="mgcv.html#topic+choose.k">choose.k</a></code> for details).
These splines will be included in each node-wise regression as additional penalized covariates.
This ensures that resulting node interaction parameters are estimated after accounting for
possible spatial autocorrelation. Note that interpretation of spatial autocorrelation is difficult,
and so it is recommended to compare predictive capacities spatial and non-spatial CRFs through
the <code><a href="#topic+predict_MRF">predict_MRF</a></code> function</p>
</td></tr>
<tr><td><code id="MRFcov_spatial_+3A_prep_splines">prep_splines</code></td>
<td>
<p>Logical. If spatial splines are already included in  <code>data</code>, set to
<code>FALSE</code>. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="MRFcov_spatial_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Logical. Used by <code><a href="#topic+bootstrap_MRF">bootstrap_MRF</a></code> to reduce memory usage</p>
</td></tr>
<tr><td><code id="MRFcov_spatial_+3A_progress_bar">progress_bar</code></td>
<td>
<p>Logical. Progress bar in pbapply is used if <code>TRUE</code>, but this slows estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of all elements contained in a returned <code><a href="#topic+MRFcov">MRFcov</a></code> object, with
the inclusion of a <code>dataframe</code> called <code>mrf_data</code>. This contains all prepped covariates
including the added spatial regression
splines, and should be used as <code>data</code> when generating predictions
via <code><a href="#topic+predict_MRF">predict_MRF</a></code> or <code><a href="#topic+predict_MRFnetworks">predict_MRFnetworks</a></code>
</p>


<h3>References</h3>

<p>Kammann, E. E. and M.P. Wand (2003) Geoadditive Models.
Applied Statistics 52(1):1-18.
</p>


<h3>See Also</h3>

<p>See <code><a href="mgcv.html#topic+smooth.construct2">smooth.construct2</a></code> and <code><a href="mgcv.html#topic+smooth.construct.gp.smooth.spec">smooth.construct.gp.smooth.spec</a></code>
for details of Gaussian process spatial regression splines. Worked examples to showcase
this function can be found using <code>vignette("Bird_Parasite_CRF")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Bird.parasites")
Latitude &lt;- sample(seq(120, 140, length.out = 100), nrow(Bird.parasites), TRUE)
Longitude &lt;- sample(seq(-19, -22, length.out = 100), nrow(Bird.parasites), TRUE)
coords &lt;- data.frame(Latitude = Latitude, Longitude = Longitude)
CRFmod_spatial &lt;- MRFcov_spatial(data = Bird.parasites, n_nodes = 4,
                                family = 'binomial', coords = coords)

</code></pre>

<hr>
<h2 id='plotMRF_hm'>Plot MRF interaction parameters as a heatmap</h2><span id='topic+plotMRF_hm'></span>

<h3>Description</h3>

<p>This function uses outputs from fitted <code><a href="#topic+MRFcov">MRFcov</a></code> and
<code><a href="#topic+bootstrap_MRF">bootstrap_MRF</a></code> models to plot a heatmap of node interaction coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMRF_hm(MRF_mod, node_names, main, plot_observed_vals, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMRF_hm_+3A_mrf_mod">MRF_mod</code></td>
<td>
<p>A fitted <code>MRFcov</code> or <code>bootstrap_MRF</code>
object</p>
</td></tr>
<tr><td><code id="plotMRF_hm_+3A_node_names">node_names</code></td>
<td>
<p>A character vector of species names for axis labels. Default
is to use rownames from the <code>MRFcov$graph</code> slot</p>
</td></tr>
<tr><td><code id="plotMRF_hm_+3A_main">main</code></td>
<td>
<p>An optional character title for the plot</p>
</td></tr>
<tr><td><code id="plotMRF_hm_+3A_plot_observed_vals">plot_observed_vals</code></td>
<td>
<p>Logical. If <code>TRUE</code> and the family of the fitted <code>MRFcov</code>
model is <code>'binomial'</code>,
then raw observed occurrence and co-occurrence values will be extracted from <code>data</code> and overlaid on
the resulting heatmap. Note, this option is not available for <code>bootstrap_MRF</code> models</p>
</td></tr>
<tr><td><code id="plotMRF_hm_+3A_data">data</code></td>
<td>
<p>Optional <code>dataframe</code> containing the input data where the left-most columns represent
binary occurrences of species that are represented by nodes in the graph. This call is only necessary
if users wish to overlay raw observed occurrence and co-occurrence values on the
heatmap of node interaction coefficients (only avaiable for <code>family = 'binomial'</code> models)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interaction parameters from <code>MRF_mod</code> are plotted as a heatmap, where
red colours indicate positive interactions and blue indicate negative interactions. If
<code>plot_observed_vals == TRUE</code>, raw observed values of single occurrences (on the diagonal)
and co-occurrences for each species in <code>data</code> are overlaid on the plot
(only avaiable for <code>family = 'binomial'</code> models). Note, this option is not
available for <code>bootstrap_MRF</code> models
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MRFcov">MRFcov</a></code> <code><a href="#topic+bootstrap_MRF">bootstrap_MRF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Bird.parasites")
CRFmod &lt;- MRFcov(data = Bird.parasites, n_nodes = 4, family = 'binomial')
plotMRF_hm(MRF_mod = CRFmod)
plotMRF_hm(MRF_mod = CRFmod, plot_observed_vals = TRUE, data = Bird.parasites)

#To plot as an igraph network instead, we can simply extract the adjacency matrix
net &lt;- igraph::graph.adjacency(CRFmod$graph, weighted = TRUE, mode = "undirected")
igraph::plot.igraph(net, layout = igraph::layout.circle,
                   edge.width = abs(igraph::E(net)$weight),
                   edge.color = ifelse(igraph::E(net)$weight &lt; 0, 'blue', 'red'))

</code></pre>

<hr>
<h2 id='predict_MRF'>Predict training observations from fitted MRFcov models</h2><span id='topic+predict_MRF'></span>

<h3>Description</h3>

<p>This function calculates linear predictors for node observations
using coefficients from an <code><a href="#topic+MRFcov">MRFcov</a></code> or <code><a href="#topic+MRFcov_spatial">MRFcov_spatial</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_MRF(
  data,
  MRF_mod,
  prep_covariates = TRUE,
  n_cores,
  progress_bar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_MRF_+3A_data">data</code></td>
<td>
<p>Dataframe. The input data to be predicted, where the <code>n_nodes</code>
left-most variables are are variables that are represented by nodes in the graph from
the <code>MRF_mod</code> model.
Colnames from this sample dataset must exactly match the colnames in the dataset that
was used to fit the <code>MRF_mod</code></p>
</td></tr>
<tr><td><code id="predict_MRF_+3A_mrf_mod">MRF_mod</code></td>
<td>
<p>A fitted <code><a href="#topic+MRFcov">MRFcov</a></code> or <code><a href="#topic+MRFcov_spatial">MRFcov_spatial</a></code> model object</p>
</td></tr>
<tr><td><code id="predict_MRF_+3A_prep_covariates">prep_covariates</code></td>
<td>
<p>Logical flag stating whether to prep the dataset
by cross-multiplication (<code>TRUE</code> by default; <code>FALSE</code> when used in other functions)</p>
</td></tr>
<tr><td><code id="predict_MRF_+3A_n_cores">n_cores</code></td>
<td>
<p>Positive integer stating the number of processing cores to split the job across.
Default is <code>1</code> (no parallelisation)</p>
</td></tr>
<tr><td><code id="predict_MRF_+3A_progress_bar">progress_bar</code></td>
<td>
<p>Logical. Progress bar in pbapply is used if <code>TRUE</code>, but this slows estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Observations for nodes in <code>data</code> are predicted using linear predictions
from <code>MRF_mod</code>. If <code>family = "binomial"</code>, a second element containing binary
predictions for nodes is returned. Note that predicting values for unobserved locations using a
spatial MRF is not currently supported
</p>


<h3>Value</h3>

<p>A <code>matrix</code> containing predictions for each observation in <code>data</code>. If
<code>family = "binomial"</code>, a second element containing binary
predictions for nodes is returned.
</p>


<h3>References</h3>

<p>Clark, NJ, Wells, K and Lindberg, O.
Unravelling changing interspecific interactions across environmental gradients
using Markov random fields. (2018). Ecology doi: 10.1002/ecy.2221
<a href="https://www.researchgate.net/publication/325184442_Unravelling_changing_interspecific_interactions_across_environmental_gradients_using_Markov_random_fields">Full text here</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MRFcov">MRFcov</a></code>, <code><a href="#topic+cv_MRF_diag">cv_MRF_diag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Bird.parasites")
# Fit a model to a subset of the data (training set)
CRFmod &lt;- MRFcov(data = Bird.parasites[1:300, ], n_nodes = 4, family = "binomial")

# If covariates are included, prep the dataset for gathering predictions
prepped_pred &lt;- prep_MRF_covariates(Bird.parasites[301:nrow(Bird.parasites), ], n_nodes = 4)

# Predict occurrences for the remaining subset (test set)
predictions &lt;- predict_MRF(data = prepped_pred, MRF_mod = CRFmod)

# Visualise predicted occurrences for nodes in the test set
predictions$Binary_predictions

# Predicting spatial MRFs requires the user to supply the spatially augmented dataset
data("Bird.parasites")
Latitude &lt;- sample(seq(120, 140, length.out = 100), nrow(Bird.parasites), TRUE)
Longitude &lt;- sample(seq(-19, -22, length.out = 100), nrow(Bird.parasites), TRUE)
coords &lt;- data.frame(Latitude = Latitude, Longitude = Longitude)
CRFmod_spatial &lt;- MRFcov_spatial(data = Bird.parasites, n_nodes = 4,
                                family = 'binomial', coords = coords)
predictions &lt;- predict_MRF(data = CRFmod_spatial$mrf_data,
                          prep_covariates  = FALSE,
                          MRF_mod = CRFmod_spatial)

</code></pre>

<hr>
<h2 id='predict_MRFnetworks'>Extract predicted network metrics for observations in a given dataset using
equations from a fitted <code>MRFcov</code> object</h2><span id='topic+predict_MRFnetworks'></span>

<h3>Description</h3>

<p>This function uses outputs from fitted <code><a href="#topic+MRFcov">MRFcov</a></code>
and <code><a href="#topic+bootstrap_MRF">bootstrap_MRF</a></code> models to
generate linear predictions for each observation in <code>data</code> and
calculate probabilistic network metrics from weighted adjacency matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_MRFnetworks(
  data,
  MRF_mod,
  cutoff,
  omit_zeros,
  metric,
  cached_predictions = NULL,
  prep_covariates,
  n_cores,
  progress_bar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_MRFnetworks_+3A_data">data</code></td>
<td>
<p>Dataframe. The sample data where the
left-most variables are variables that are represented by nodes in the graph.
Colnames from this sample dataset must exactly match the colnames in the dataset that
was used to fit the <code>MRF_mod</code></p>
</td></tr>
<tr><td><code id="predict_MRFnetworks_+3A_mrf_mod">MRF_mod</code></td>
<td>
<p>A fitted <code>MRFcov</code> or <code>bootstrap_MRF</code> object</p>
</td></tr>
<tr><td><code id="predict_MRFnetworks_+3A_cutoff">cutoff</code></td>
<td>
<p>Single numeric value specifying the linear prediction threshold. Species whose
linear prediction is below this level for a given observation in <code>data</code> will be
considered absent, meaning they cannot participate in community networks.
Default is <code>0.5</code> for <code>family == 'binomial'</code> or <code>0</code> for other families</p>
</td></tr>
<tr><td><code id="predict_MRFnetworks_+3A_omit_zeros">omit_zeros</code></td>
<td>
<p>Logical. If <code>TRUE</code>, each species will not be considered to
participate in community networks for observations in which that species was not observed
in <code>data</code>. If <code>FALSE</code>, the species is still considered to have possibly occurred, based
on the linear prediction for that observation. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="predict_MRFnetworks_+3A_metric">metric</code></td>
<td>
<p>The network metric to be calculated for each observation in <code>data</code>.
Recognised values are : <code>"degree"</code>, <code>"eigencentrality"</code>, or <code>"betweenness"</code>, or
leave blank to instead return a list of adjacency matrices</p>
</td></tr>
<tr><td><code id="predict_MRFnetworks_+3A_cached_predictions">cached_predictions</code></td>
<td>
<p>Use if providing stored predictions from <code><a href="#topic+predict_MRF">predict_MRF</a></code>
to prevent unneccessary replication. Default is to calculate predictions first and then
calculate network metrics</p>
</td></tr>
<tr><td><code id="predict_MRFnetworks_+3A_prep_covariates">prep_covariates</code></td>
<td>
<p>Logical flag stating whether to prep the dataset
by cross-multiplication (<code>TRUE</code> by default; use <code>FALSE</code> for predicting
networks from <code><a href="#topic+MRFcov_spatial">MRFcov_spatial</a></code> objects)</p>
</td></tr>
<tr><td><code id="predict_MRFnetworks_+3A_n_cores">n_cores</code></td>
<td>
<p>Positive integer stating the number of processing cores to split the job across.
Default is <code>1</code> (no parallelisation)</p>
</td></tr>
<tr><td><code id="predict_MRFnetworks_+3A_progress_bar">progress_bar</code></td>
<td>
<p>Logical. Progress bar in pbapply is used if <code>TRUE</code>, but this slows estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interaction parameters are predicted for each observation in <code>data</code>
and then converted into a weighted, undirected adjacency matrix
using <code><a href="igraph.html#topic+graph.adjacency">graph.adjacency</a></code>. Note that the network is probabilistic,
as node occurrences/abundances are predicted using fitted model equations from
<code>MRF_mod</code>. If a linear prediction for a given observation falls below the
user-specified <code>cutoff</code>, the node is considered absent from the community and cannot
participate in the network. After correcting for the linear predictions,
the specified network metric (degree centrality,
eigencentrality, or betweenness) for each observation in <code>data</code>
is then calculated and returned in a <code>matrix</code>. If <code>metric</code> is not
supplied, the weighted, undirected adjacency matrices are returned in a <code>list</code>
</p>


<h3>Value</h3>

<p>Either a <code>matrix</code> with <code>nrow = nrow(data)</code>,
containing each species' predicted network metric at each observation in <code>data</code>, or
a <code>list</code> with <code>length = nrow(data)</code> containing the weighted, undirected
adjacency matrix predicted at each observation in <code>data</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MRFcov">MRFcov</a></code>, <code><a href="#topic+bootstrap_MRF">bootstrap_MRF</a></code>, <code><a href="igraph.html#topic+degree">degree</a></code>,
<code><a href="igraph.html#topic+eigen_centrality">eigen_centrality</a></code>, <code><a href="igraph.html#topic+betweenness">betweenness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Bird.parasites")
CRFmod &lt;- MRFcov(data = Bird.parasites, n_nodes = 4,
                family = "binomial")
predict_MRFnetworks(data = Bird.parasites[1:200, ],
                   MRF_mod = CRFmod, metric = "degree",
                   cutoff = 0.25)


</code></pre>

<hr>
<h2 id='prep_MRF_covariates'>Cross-multiply response and covariate variables</h2><span id='topic+prep_MRF_covariates'></span>

<h3>Description</h3>

<p>This function performs the cross-multiplication necessary
for prepping datasets to be used in <code><a href="#topic+MRFcov">MRFcov</a></code> models. This
function is called by several of the functions within the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_MRF_covariates(data, n_nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_MRF_covariates_+3A_data">data</code></td>
<td>
<p>Dataframe. The input data where the <code>n_nodes</code>
left-most variables are outcome variables to be represented by nodes in the graph</p>
</td></tr>
<tr><td><code id="prep_MRF_covariates_+3A_n_nodes">n_nodes</code></td>
<td>
<p>Integer. The index of the last column in data
which is represented by a node in the final graph. Columns with index
greater than n_nodes are taken as covariates. Default is the number of
columns in data, corresponding to no additional covariates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Observations of nodes (species) in <code>data</code> are prepped for
<code>MRFcov</code> analysis by multiplication. This function is not designed to be called directly,
but is used by other functions in the package (namely <code><a href="#topic+MRFcov">MRFcov</a></code>,
<code><a href="#topic+MRFcov_spatial">MRFcov_spatial</a></code>,
<code><a href="#topic+cv_MRF_diag">cv_MRF_diag</a></code>, and
<code><a href="#topic+bootstrap_MRF">bootstrap_MRF</a></code>)
</p>


<h3>Value</h3>

<p>Dataframe of the prepped response and covariate variables necessary for
input in <code><a href="#topic+MRFcov">MRFcov</a></code> models
</p>

<hr>
<h2 id='prep_MRF_covariates_spatial'>Cross-multiply response and covariate variables and build spatial splines</h2><span id='topic+prep_MRF_covariates_spatial'></span>

<h3>Description</h3>

<p>This function performs the cross-multiplication necessary
for prepping datasets to be used in <code><a href="#topic+MRFcov_spatial">MRFcov_spatial</a></code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_MRF_covariates_spatial(data, n_nodes, coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_MRF_covariates_spatial_+3A_data">data</code></td>
<td>
<p>Dataframe. The input data where the <code>n_nodes</code>
left-most variables are outcome variables to be represented by nodes in the graph</p>
</td></tr>
<tr><td><code id="prep_MRF_covariates_spatial_+3A_n_nodes">n_nodes</code></td>
<td>
<p>Integer. The index of the last column in data
which is represented by a node in the final graph. Columns with index
greater than n_nodes are taken as covariates. Default is the number of
columns in data, corresponding to no additional covariates</p>
</td></tr>
<tr><td><code id="prep_MRF_covariates_spatial_+3A_coords">coords</code></td>
<td>
<p>A two-column <code>dataframe</code> (with <code>nrow(coords) == nrow(data)</code>)
representing the spatial coordinates of each observation in <code>data</code>. Ideally, these
coordinates will represent Latitude and Longitude GPS points for each observation. The coordinates
are used to create smoothed Gaussian Process spatial regression splines via
<code><a href="mgcv.html#topic+smooth.construct2">smooth.construct2</a></code>.
Here, the basis dimension of the smoothed term
is chosen based on the number of unique GPS coordinates in <code>coords</code>.
If this number is less than <code>100</code>, then this number is used. If the number of
unique coordiantes is more than <code>100</code>, a value of <code>100</code> is used
(this parameter needs to be large in order to ensure enough degrees of freedom
for estimating 'wiggliness' of the smooth term; see
<code><a href="mgcv.html#topic+choose.k">choose.k</a></code> for details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Observations of nodes (species) in <code>data</code> are prepped for
<code>MRFcov_spatial</code> analysis by multiplication. This function is useful if
users wish to prep the spatial splines beforehand and split the
data manually for out-of-sample cross-validation. To do so,
prep the splines here and set <code>prep_splines = FALSE</code> in <code>MRFcov_spatial</code>
</p>


<h3>Value</h3>

<p>Dataframe of the prepped response and covariate variables necessary for
input in <code><a href="#topic+MRFcov_spatial">MRFcov_spatial</a></code> models
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
