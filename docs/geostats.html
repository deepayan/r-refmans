<!DOCTYPE html><html><head><title>Help for package geostats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geostats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geostats'><p>library(geostats)</p></a></li>
<li><a href='#ACNK'><p>A-CN-K compositions</p></a></li>
<li><a href='#alr'><p>additive logratio transformation</p></a></li>
<li><a href='#boxcount'><p>box counting</p></a></li>
<li><a href='#Britain'><p>British coast</p></a></li>
<li><a href='#cantor'><p>Cantor set</p></a></li>
<li><a href='#catchments'><p>properties of 20 river catchments</p></a></li>
<li><a href='#circle.plot'><p>plot circular data</p></a></li>
<li><a href='#circle.points'><p>add points to a circular plot</p></a></li>
<li><a href='#clr'><p>centred logratio transformation</p></a></li>
<li><a href='#colourplot'><p>colour plot</p></a></li>
<li><a href='#Corsica'><p>rivers on Corsica</p></a></li>
<li><a href='#countQuakes'><p>count the number of earthquakes per year</p></a></li>
<li><a href='#declustered'><p>declustered earthquake data</p></a></li>
<li><a href='#DZ'><p>detrital zircon U-Pb data</p></a></li>
<li><a href='#earthquakes'><p>earthquake data</p></a></li>
<li><a href='#ellipse'><p>ellipse</p></a></li>
<li><a href='#exp'><p>exponential transformation</p></a></li>
<li><a href='#FAM'><p>A-F-M data</p></a></li>
<li><a href='#fault'><p>fault orientation data</p></a></li>
<li><a href='#Finland'><p>Finnish lake data</p></a></li>
<li><a href='#forams'><p>foram count data</p></a></li>
<li><a href='#fractaldim'><p>calculate the fractal dimension</p></a></li>
<li><a href='#fractures'><p>fractures</p></a></li>
<li><a href='#gutenberg'><p>create a Gutenberg-Richter plot</p></a></li>
<li><a href='#hills'><p>hills</p></a></li>
<li><a href='#koch'><p>Koch snowflake</p></a></li>
<li><a href='#kriging'><p>kriging</p></a></li>
<li><a href='#ksdist'><p>Kolmogorov-Smirnov distance matrix</p></a></li>
<li><a href='#logit'><p>logistic transformation</p></a></li>
<li><a href='#major'><p>composition of Namib dune sand</p></a></li>
<li><a href='#meanangle'><p>mean angle</p></a></li>
<li><a href='#meuse'><p>Meuse river data set</p></a></li>
<li><a href='#Mode'><p>get the mode of a dataset</p></a></li>
<li><a href='#palaeomag'><p>palaeomagnetic data</p></a></li>
<li><a href='#PCA2D'><p>Principal Component Analysis of 2D data</p></a></li>
<li><a href='#pebbles'><p>pebble orientations</p></a></li>
<li><a href='#pendulum'><p>3-magnet pendulum experiment</p></a></li>
<li><a href='#randy'><p>generate bivariate random data</p></a></li>
<li><a href='#Rbar'><p>calculate <code class="reqn">\bar{R}</code></p></a></li>
<li><a href='#Rbar2kappa'><p><code class="reqn">\bar{R}</code> to <code class="reqn">\kappa</code> conversion</p></a></li>
<li><a href='#rbsr'><p>Rb-Sr data</p></a></li>
<li><a href='#rwyxz'><p>Spurious correlation</p></a></li>
<li><a href='#semivariogram'><p>semivariogram</p></a></li>
<li><a href='#sierpinski'><p>Sierpinski carpet</p></a></li>
<li><a href='#sizefrequency'><p>calculate the size-frequency distribution of things</p></a></li>
<li><a href='#skew'><p>calculate the skewness of a dataset</p></a></li>
<li><a href='#stereonet'><p>stereonet</p></a></li>
<li><a href='#striations'><p>directions of glacial striations</p></a></li>
<li><a href='#ternary'><p>ternary diagrams</p></a></li>
<li><a href='#test'><p>composition of a further 147 oceanic basalts</p></a></li>
<li><a href='#training'><p>composition of 646 oceanic basalts</p></a></li>
<li><a href='#vonMises'><p>von Mises distribution</p></a></li>
<li><a href='#worldpop'><p>world population</p></a></li>
<li><a href='#xyz2xy'><p>get x,y plot coordinates of ternary data</p></a></li>
<li><a href='#york'><p>Linear regression of X,Y-variables with correlated errors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>An Introduction to Statistics for Geoscientists</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-02</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of datasets and simplified functions for an introductory (geo)statistics module at University College London. Provides functionality for compositional, directional and spatial data, including ternary diagrams, Wulff and Schmidt stereonets, and ordinary kriging interpolation. Implements logistic and (additive and centred) logratio transformations. Computes vector averages and concentration parameters for the von-Mises distribution. Includes a collection of natural and synthetic fractals, and a simulator for deterministic chaos using a magnetic pendulum example. The main purpose of these functions is pedagogical. Researchers can find more complete alternatives for these tools in other packages such as 'compositions', 'robCompositions', 'sp', 'gstat' and 'RFOC'. All the functions are written in plain R, with no compiled code and a minimal number of dependencies. Theoretical background and worked examples are available at <a href="https://tinyurl.com/UCLgeostats/">https://tinyurl.com/UCLgeostats/</a>.</td>
</tr>
<tr>
<td>Author:</td>
<td>Pieter Vermeesch [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pieter Vermeesch &lt;p.vermeesch@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pvermees/geostats/">https://github.com/pvermees/geostats/</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-02 21:46:30 UTC; pvermees</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-07 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='geostats'>library(geostats)</h2><span id='topic+geostats'></span><span id='topic+_PACKAGE'></span><span id='topic+geostats-package'></span>

<h3>Description</h3>

<p>A list of documented functions may be viewed by typing
<code>help(package='geostats')</code>.  Detailed instructions are
provided at <a href="https://github.com/pvermees/geostats/">https://github.com/pvermees/geostats/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Pieter Vermeesch <a href="mailto:p.vermeesch@ucl.ac.uk">p.vermeesch@ucl.ac.uk</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/pvermees/geostats/">https://github.com/pvermees/geostats/</a>
</p>
</li></ul>


<hr>
<h2 id='ACNK'>A-CN-K compositions</h2><span id='topic+ACNK'></span>

<h3>Description</h3>

<p>Synthetic A (Al<code class="reqn">_2</code>O<code class="reqn">_3</code>) &ndash; CN (CaO+Na<code class="reqn">_2</code>O) &ndash; K
(K<code class="reqn">_2</code>O) data table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ACNK,package='geostats')
ternary(ACNK,type='p',labels=c(expression('Al'[2]*'O'[3]),
                               expression('CaO+Na'[2]*'O'),
                               expression('K'[2]*'O')))
</code></pre>

<hr>
<h2 id='alr'>additive logratio transformation</h2><span id='topic+alr'></span>

<h3>Description</h3>

<p>Maps compositional data from an <code class="reqn">n</code>-dimensional
simplex to an (<code class="reqn">n-1</code>)-dimensional Euclidean space with
Aitchison's additive logratio transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alr(dat, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alr_+3A_dat">dat</code></td>
<td>
<p>an <code class="reqn">n</code> column data frame or matrix</p>
</td></tr>
<tr><td><code id="alr_+3A_inverse">inverse</code></td>
<td>
<p>if <code>TRUE</code>, applies the inverse alr
tranformation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>inverse=FALSE</code>, returns an <code class="reqn">(n-1) \times m</code>
matrix of logratios; otherwise returns an <code class="reqn">(n+1) \times m</code>
matrix of compositional data whose columns add up to 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyz &lt;- rbind(c(0.03,99.88,0.09),
             c(70.54,25.95,3.51),
             c(72.14,26.54,1.32))
colnames(xyz) &lt;- c('a','b','c')
rownames(xyz) &lt;- 1:3
uv &lt;- alr(xyz)
XYZ &lt;- alr(uv,inverse=TRUE)
xyz/XYZ
</code></pre>

<hr>
<h2 id='boxcount'>box counting</h2><span id='topic+boxcount'></span>

<h3>Description</h3>

<p>Count the number of boxes needed to cover all the 1s
in a matrix of 0s and 1s.
</p>
<p>Count the number of boxes needed to cover all the 1s
in a matrix of 0s and 1s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxcount(mat, size)

boxcount(mat, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxcount_+3A_mat">mat</code></td>
<td>
<p>a square square matrix of 0s and 1s, whose size should
be a power of 2.</p>
</td></tr>
<tr><td><code id="boxcount_+3A_size">size</code></td>
<td>
<p>the size (pixels per side) of the boxes, whose size
should be a power of 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer
</p>
<p>an integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sierpinski(n=5)
boxcount(mat=g,size=16)
g &lt;- sierpinski(n=5)
boxcount(mat=g,size=16)
</code></pre>

<hr>
<h2 id='Britain'>British coast</h2><span id='topic+Britain'></span>

<h3>Description</h3>

<p>A <code class="reqn">512 \times 512</code> pixel image of the British coastline.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Britain,package='geostats')
p &lt;- par(mfrow=c(1,2))
image(Britain)
fractaldim(Britain)
par(p)
</code></pre>

<hr>
<h2 id='cantor'>Cantor set</h2><span id='topic+cantor'></span>

<h3>Description</h3>

<p>Calculates or plots a Cantor set of fractal lines,
which is generated using a recursive algorithm that is built on
a line segment whose middle third is removed. Each level of
recursion replaces each black line by the same pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cantor(n = 5, plot = FALSE, add = FALSE, Y = 0, lty = 1, col = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cantor_+3A_n">n</code></td>
<td>
<p>an integer value controling the number of recursive
levels.</p>
</td></tr>
<tr><td><code id="cantor_+3A_plot">plot</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the Cantor set is plotted,
otherwise a list of breaks and counts is returned.</p>
</td></tr>
<tr><td><code id="cantor_+3A_add">add</code></td>
<td>
<p>logical (only used if <code>plot=TRUE</code>). If
<code>add=FALSE</code>, then a brand new figure is created; otherwise
the Cantor set is added to an existing plot.</p>
</td></tr>
<tr><td><code id="cantor_+3A_y">Y</code></td>
<td>
<p>y-value for the plot (only used if <code>plot=TRUE</code>).</p>
</td></tr>
<tr><td><code id="cantor_+3A_lty">lty</code></td>
<td>
<p>line type (see <code>pars()</code> for details)</p>
</td></tr>
<tr><td><code id="cantor_+3A_col">col</code></td>
<td>
<p>colour of the Cantor lines.</p>
</td></tr>
<tr><td><code id="cantor_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed on to <code>matplot</code> or
<code>matlines</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a square matrix with 0s and 1s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(c(0,1),y=c(0,1),type='n',bty='n',ann=FALSE,xaxt='n',yaxt='n',xpd=NA)
cantor(n=0,Y=1.00,plot=TRUE,add=TRUE)
cantor(n=1,Y=0.75,plot=TRUE,add=TRUE)
cantor(n=2,Y=0.50,plot=TRUE,add=TRUE)
cantor(n=3,Y=0.25,plot=TRUE,add=TRUE)
cantor(n=4,Y=0.00,plot=TRUE,add=TRUE)
</code></pre>

<hr>
<h2 id='catchments'>properties of 20 river catchments</h2><span id='topic+catchments'></span>

<h3>Description</h3>

<p>six different (three discrete, three continuous) measurements for
twenty fictitious river catchments, containing their dominant
lithology (categorical data), stratigraphic age (ordinal data),
number of springs (count data), the pH of the river water
(Cartesian quantity), its Ca/Mg ratio (Jeffreys quantity) and the
percentage covered by vegetation (proportion).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(catchments,package='geostats')
hist(catchments$pH)
</code></pre>

<hr>
<h2 id='circle.plot'>plot circular data</h2><span id='topic+circle.plot'></span>

<h3>Description</h3>

<p>Plots directional data as ticks on a circle, with
angles plotting in a clockwise direction from the top.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle.plot(a, degrees = FALSE, tl = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circle.plot_+3A_a">a</code></td>
<td>
<p>angle(s), scalar or vector</p>
</td></tr>
<tr><td><code id="circle.plot_+3A_degrees">degrees</code></td>
<td>
<p>logical. <code>TRUE</code> for degrees, <code>FALSE</code> for
radians</p>
</td></tr>
<tr><td><code id="circle.plot_+3A_tl">tl</code></td>
<td>
<p>tick length (value between 0 and 1)</p>
</td></tr>
<tr><td><code id="circle.plot_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed on to the generic
<code>matlines</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(striations,package='geostats')
circle.plot(striations,degrees=TRUE)
</code></pre>

<hr>
<h2 id='circle.points'>add points to a circular plot</h2><span id='topic+circle.points'></span>

<h3>Description</h3>

<p>Adds directional data as points on an existing circle
plot, with angles plotting in a clockwise direction from the
top.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle.points(a, degrees = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circle.points_+3A_a">a</code></td>
<td>
<p>angle(s), scalar or vector</p>
</td></tr>
<tr><td><code id="circle.points_+3A_degrees">degrees</code></td>
<td>
<p>logical. <code>TRUE</code> for degrees, <code>FALSE</code> for
radians</p>
</td></tr>
<tr><td><code id="circle.points_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed on to the generic
<code>points</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(striations,package='geostats')
circle.plot(striations,degrees=TRUE)
md &lt;- meanangle(striations,degrees=TRUE)
circle.points(md,pch=22,bg='black',degrees=TRUE)
</code></pre>

<hr>
<h2 id='clr'>centred logratio transformation</h2><span id='topic+clr'></span>

<h3>Description</h3>

<p>Maps compositional data from an n-dimensional simplex
to an n-dimensional Euclidean space with Aitchison's centred
logratio transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clr(dat, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clr_+3A_dat">dat</code></td>
<td>
<p>an <code>n x m</code> matrix</p>
</td></tr>
<tr><td><code id="clr_+3A_inverse">inverse</code></td>
<td>
<p>logical. If <code>TRUE</code>, applies the inverse clr
tranformation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>n x m</code> matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyz &lt;- rbind(c(0.03,99.88,0.09),
             c(70.54,25.95,3.51),
             c(72.14,26.54,1.32))
colnames(xyz) &lt;- c('a','b','c')
rownames(xyz) &lt;- 1:3
pc &lt;- prcomp(clr(xyz))
biplot(pc)
</code></pre>

<hr>
<h2 id='colourplot'>colour plot</h2><span id='topic+colourplot'></span>

<h3>Description</h3>

<p>Adds a colour bar to a scatter plot and/or filled
contour plot.  This function, which is based on base <code>R</code>'s
<code>filled.contour</code> function, is useful for visualising
kriging results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colourplot(
  x,
  y,
  z,
  X,
  Y,
  Z,
  nlevels = 20,
  colspec = hcl.colors,
  pch = 21,
  cex = 1,
  plot.title,
  plot.axes,
  key.title,
  key.axes,
  asp = NA,
  xaxs = "i",
  yaxs = "i",
  las = 1,
  axes = TRUE,
  frame.plot = axes,
  extra,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colourplot_+3A_x">x</code></td>
<td>
<p>numerical vector of <code class="reqn">n</code> equally spaced values to be
used in the contour plot.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_y">y</code></td>
<td>
<p>numerical vector of <code class="reqn">m</code> equally spaced values to be
used in the contour plot.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_z">z</code></td>
<td>
<p>an <code class="reqn">n \times m</code> matrix of numerical values to be used
in the contour plot.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_x">X</code></td>
<td>
<p>numerical vector of <code class="reqn">N</code> values to be used in the
scatter plot.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_y">Y</code></td>
<td>
<p>numerical vector of <code class="reqn">N</code> values to be used in the
scatter plot.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_z">Z</code></td>
<td>
<p>numerical vector of <code class="reqn">N</code> values to be used in the
scatter plot.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_nlevels">nlevels</code></td>
<td>
<p>number of levels to be used in the contour plot.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_colspec">colspec</code></td>
<td>
<p>colour specification (e.g., <code>rainbow</code>,
<code>grey.colors</code>, <code>heat.colors</code>, <code>topo.colors</code>).</p>
</td></tr>
<tr><td><code id="colourplot_+3A_pch">pch</code></td>
<td>
<p>plot character (<code>21</code> &ndash; <code>25</code>).</p>
</td></tr>
<tr><td><code id="colourplot_+3A_cex">cex</code></td>
<td>
<p>plot character magnification.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_plot.title">plot.title</code></td>
<td>
<p>statements that add titles to the main plot.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_plot.axes">plot.axes</code></td>
<td>
<p>statements that draw axes on the main plot. This
overrides the default axes.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_key.title">key.title</code></td>
<td>
<p>statements that add titles for the plot key.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_key.axes">key.axes</code></td>
<td>
<p>statements that draw axes on the plot key.  This
overrides the default axis.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_asp">asp</code></td>
<td>
<p>the y/x aspect ratio, see <code>plot.window</code>.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_xaxs">xaxs</code></td>
<td>
<p>the x axis style.  The default is to use internal
labelling.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_yaxs">yaxs</code></td>
<td>
<p>the y axis style.  The default is to use internal
labelling.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_las">las</code></td>
<td>
<p>the style of labelling to be used.  The default is to
use horizontal labelling.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_axes">axes</code></td>
<td>
<p>logicals indicating if axes should be drawn.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_frame.plot">frame.plot</code></td>
<td>
<p>logicals indicating if a box should be drawn, as
in <code>plot.default</code>.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_extra">extra</code></td>
<td>
<p>(optional) extra intructions to be carried out in the
main plot window, such as text annotations.</p>
</td></tr>
<tr><td><code id="colourplot_+3A_...">...</code></td>
<td>
<p>additional graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('meuse',package='geostats')
colourplot(X=meuse$x,Y=meuse$y,Z=log(meuse$zinc),
           plot.title=title(main='Meuse',xlab='Easting',ylab='Northing'),
           key.title=title(main='log(Zn)'))
</code></pre>

<hr>
<h2 id='Corsica'>rivers on Corsica</h2><span id='topic+Corsica'></span>

<h3>Description</h3>

<p>A <code class="reqn">512 \times 512</code> pixel image of the river network on Corsica.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Corsica,package='geostats')
p &lt;- par(mfrow=c(1,2))
image(Corsica)
fractaldim(Corsica)
par(p)
</code></pre>

<hr>
<h2 id='countQuakes'>count the number of earthquakes per year</h2><span id='topic+countQuakes'></span>

<h3>Description</h3>

<p>Counts the number of earthquakes per year that fall
within a certain time interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countQuakes(qdat, minmag, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countQuakes_+3A_qdat">qdat</code></td>
<td>
<p>a data frame containing columns named <code>mag</code> and
<code>year</code>.</p>
</td></tr>
<tr><td><code id="countQuakes_+3A_minmag">minmag</code></td>
<td>
<p>minimum magnitude</p>
</td></tr>
<tr><td><code id="countQuakes_+3A_from">from</code></td>
<td>
<p>first year</p>
</td></tr>
<tr><td><code id="countQuakes_+3A_to">to</code></td>
<td>
<p>last year</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table with the number of earthquakes per year
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(declustered,package='geostats')
quakesperyear &lt;- countQuakes(declustered,minmag=5.0,from=1917,to=2016)
table(quakesperyear)
</code></pre>

<hr>
<h2 id='declustered'>declustered earthquake data</h2><span id='topic+declustered'></span>

<h3>Description</h3>

<p>Dataset of 28267 earthquakes between 1769 and 2016, with
aftershocks and precursor events removed.
</p>


<h3>References</h3>

<p>Mueller, C.S., 2019. Earthquake catalogs for the USGS
national seismic hazard maps. Seismological Research Letters,
90(1), pp.251-261.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(declustered,package='geostats')
quakesperyear &lt;- countQuakes(declustered,minmag=5.0,from=1917,to=2016)
table(quakesperyear)
</code></pre>

<hr>
<h2 id='DZ'>detrital zircon U-Pb data</h2><span id='topic+DZ'></span>

<h3>Description</h3>

<p>Detrital zircon U-Pb data of 13 sand samples from China.
</p>


<h3>References</h3>

<p>Vermeesch, P. &ldquo;Multi-sample comparison of detrital age
distributions.&rdquo;  Chemical Geology 341 (2013): 140-146.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DZ,package='geostats')
qqplot(DZ[['Y']],DZ[['5']])
</code></pre>

<hr>
<h2 id='earthquakes'>earthquake data</h2><span id='topic+earthquakes'></span>

<h3>Description</h3>

<p>Dataset of 20000 earthquakes between 2017 and 2000, downloaded from
the USGS earthquake database
(<a href="https://earthquake.usgs.gov/earthquakes/search/">https://earthquake.usgs.gov/earthquakes/search/</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(earthquakes,package='geostats')
gutenberg(earthquakes$mag)
</code></pre>

<hr>
<h2 id='ellipse'>ellipse</h2><span id='topic+ellipse'></span>

<h3>Description</h3>

<p>Compute the x-y coordinates of an error ellipse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse(mean, cov, alpha = 0.05, n = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipse_+3A_mean">mean</code></td>
<td>
<p>two-element vector with the centre of the ellipse</p>
</td></tr>
<tr><td><code id="ellipse_+3A_cov">cov</code></td>
<td>
<p>the <code>2 x 2</code> covariance matrix of <code>x</code> and <code>y</code></p>
</td></tr>
<tr><td><code id="ellipse_+3A_alpha">alpha</code></td>
<td>
<p>confidence level of the ellipse</p>
</td></tr>
<tr><td><code id="ellipse_+3A_n">n</code></td>
<td>
<p>the number of points at which the ellipse is evaluated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a two-column matrix of plot coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rnorm(100,mean=100,sd=1)
Y &lt;- rnorm(100,mean=100,sd=1)
Z &lt;- rnorm(100,mean=100,sd=5)
dat &lt;- cbind(X/Z,Y/Z)
plot(dat)
ell &lt;- ellipse(mean=colMeans(dat),cov=cov(dat))
polygon(ell)
</code></pre>

<hr>
<h2 id='exp'>exponential transformation</h2><span id='topic+exp'></span><span id='topic+exp.density'></span>

<h3>Description</h3>

<p>Map a logged kernel density estimate from [<code class="reqn">-\infty,+\infty</code>]
to [<code class="reqn">0,\infty</code>] by taking exponents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'density'
exp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp_+3A_x">x</code></td>
<td>
<p>an object of class <code>density</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>density</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(catchments,package='geostats')
lc &lt;- log(catchments$CaMg)
ld &lt;- density(lc)
d &lt;- exp(ld)
plot(d)
</code></pre>

<hr>
<h2 id='FAM'>A-F-M data</h2><span id='topic+FAM'></span>

<h3>Description</h3>

<p>FeO - (Na<code class="reqn">_2</code>O + K<code class="reqn">_2</code>O) - MgO compositions of 630
calc-alkali basalts from the Cascade Mountains and 474 tholeiitic
basalts from Iceland. Arranged in F-A-M order instead of A-F-M for
consistency with the <code>ternary</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FAM,package='geostats')
ternary(FAM[,-1])
</code></pre>

<hr>
<h2 id='fault'>fault orientation data</h2><span id='topic+fault'></span>

<h3>Description</h3>

<p>Ten paired strike and dip measurements (in degrees), drawn from a
von Mises - Fisher distribution with mean vector
<code class="reqn">\mu=\{-1,-1,1\}/\sqrt{3}</code> and concentration parameter
<code class="reqn">\kappa=100</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fault,package='geostats')
stereonet(trd=fault$strike,plg=fault$dip,option=2,degrees=TRUE,show.grid=FALSE)
</code></pre>

<hr>
<h2 id='Finland'>Finnish lake data</h2><span id='topic+Finland'></span>

<h3>Description</h3>

<p>Table of 2327 Finnish lakes, extracted from a hydroLAKES database.
</p>


<h3>References</h3>

<p>Lehner, B., and Doll, P. (2004), Development and
validation of a global database of lakes, reservoirs and
wetlands, Journal of Hydrology, 296(1), 1-22, doi:
10.1016/j.jhydrol.2004.03.028.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Finland,package='geostats')
sf &lt;- sizefrequency(Finland$area)
size &lt;- sf[,'size']
freq &lt;- sf[,'frequency']
plot(size,freq,log='xy')
fit &lt;- lm(log(freq) ~ log(size))
lines(size,exp(predict(fit)))
</code></pre>

<hr>
<h2 id='forams'>foram count data</h2><span id='topic+forams'></span>

<h3>Description</h3>

<p>Planktic foraminifera counts in surface sediments in the Atlantic ocean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(forams,package='geostats')
abundant &lt;- forams[,c('quinqueloba','pachyderma','incompta',
                      'glutinata','bulloides')]
other &lt;- rowSums(forams[,c('uvula','scitula')])
dat &lt;- cbind(abundant,other)
chisq.test(dat)
</code></pre>

<hr>
<h2 id='fractaldim'>calculate the fractal dimension</h2><span id='topic+fractaldim'></span>

<h3>Description</h3>

<p>Performs box counting on a matrix of 0s and 1s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fractaldim(mat, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fractaldim_+3A_mat">mat</code></td>
<td>
<p>a square matrix of 0s and 1s. Size must be a power of 2.</p>
</td></tr>
<tr><td><code id="fractaldim_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>, plots the results on a log-log
scale.</p>
</td></tr>
<tr><td><code id="fractaldim_+3A_...">...</code></td>
<td>
<p>optional arguments to the generic <code>points</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>lm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sierpinski(n=5)
fractaldim(g)
</code></pre>

<hr>
<h2 id='fractures'>fractures</h2><span id='topic+fractures'></span>

<h3>Description</h3>

<p>A <code class="reqn">512 \times 512</code> pixel image of a fracture network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fractures,package='geostats')
p &lt;- par(mfrow=c(1,2))
image(fractures)
fractaldim(fractures)
par(p)
</code></pre>

<hr>
<h2 id='gutenberg'>create a Gutenberg-Richter plot</h2><span id='topic+gutenberg'></span>

<h3>Description</h3>

<p>Calculate a semi-log plot with earthquake magnitude on
the horizontal axis,and the cumulative number of earthquakes
exceeding any given magnitude on the vertical axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gutenberg(m, n = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gutenberg_+3A_m">m</code></td>
<td>
<p>a vector of earthquake magnitudes</p>
</td></tr>
<tr><td><code id="gutenberg_+3A_n">n</code></td>
<td>
<p>the number of magnitudes to evaluate</p>
</td></tr>
<tr><td><code id="gutenberg_+3A_...">...</code></td>
<td>
<p>optional arguments to the generic <code>points</code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the output of <code>lm</code> with earthquake magnitude as the
independent variable (<code>mag</code>) and the logarithm (base 10)
of the frequency as the dependent variable (<code>lfreq</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(declustered,package='geostats')
gutenberg(declustered$mag)
</code></pre>

<hr>
<h2 id='hills'>hills</h2><span id='topic+hills'></span>

<h3>Description</h3>

<p>150 X-Y-Z values for a synthetic landscape that consists of three
Gaussian mountains.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hills,package='geostats')
semivariogram(x=hills$X,y=hills$Y,z=hills$Z,model='gaussian')
</code></pre>

<hr>
<h2 id='koch'>Koch snowflake</h2><span id='topic+koch'></span>

<h3>Description</h3>

<p>Calculates or plots a Koch set of fractal lines, which
is generated using a recursive algorithm that is built on a
triangular hat shaped line segment. Each level of recursion
replaces each linear segment by the same pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>koch(n = 4, plot = TRUE, res = 512)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="koch_+3A_n">n</code></td>
<td>
<p>an integer value controling the number of recursive
levels.</p>
</td></tr>
<tr><td><code id="koch_+3A_plot">plot</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the Koch flake is plotted.</p>
</td></tr>
<tr><td><code id="koch_+3A_res">res</code></td>
<td>
<p>the number of pixels in each side of the output matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>res x res</code> matrix with 0s and 1s
</p>


<h3>Examples</h3>

<pre><code class='language-R'>koch()
</code></pre>

<hr>
<h2 id='kriging'>kriging</h2><span id='topic+kriging'></span>

<h3>Description</h3>

<p>Ordinary kriging interpolation of spatial
data. Implements a simple version of ordinary kriging that uses
all the data in a training set to predict the z-value of some
test data, using a semivariogram model generated by the
<code><a href="#topic+semivariogram">semivariogram</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kriging(x, y, z, xi, yi, svm, grid = FALSE, err = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kriging_+3A_x">x</code></td>
<td>
<p>numerical vector of training data</p>
</td></tr>
<tr><td><code id="kriging_+3A_y">y</code></td>
<td>
<p>numerical vector of the same length as <code>x</code></p>
</td></tr>
<tr><td><code id="kriging_+3A_z">z</code></td>
<td>
<p>numerical vector of the same length as <code>x</code></p>
</td></tr>
<tr><td><code id="kriging_+3A_xi">xi</code></td>
<td>
<p>scalar or vector with the <code>x</code>-coordinates of the
points at which the <code>z</code>-values are to be evaluated.</p>
</td></tr>
<tr><td><code id="kriging_+3A_yi">yi</code></td>
<td>
<p>scalar or vector with the <code>y</code>-coordinates of the
points at which the <code>z</code>-values are to be evaluated.</p>
</td></tr>
<tr><td><code id="kriging_+3A_svm">svm</code></td>
<td>
<p>output of the <code><a href="#topic+semivariogram">semivariogram</a></code> function, a
3-element vector with the sill, nugget and range of the
semivariogram fit.</p>
</td></tr>
<tr><td><code id="kriging_+3A_grid">grid</code></td>
<td>
<p>logical. If <code>TRUE</code>, evaluates the kriging
interpolator along a regular grid of values defined by
<code>xi</code> and <code>yi</code>.</p>
</td></tr>
<tr><td><code id="kriging_+3A_err">err</code></td>
<td>
<p>logical. If <code>TRUE</code>, returns the variance of the
kriging estimate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a vector (if <code>grid=FALSE</code>) or a matrix (if
<code>grid=TRUE</code>) of kriging interpolations. In the latter
case, values that are more than 10% out of the data range are
given <code>NA</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse,package='geostats')
x &lt;- meuse$x
y &lt;- meuse$y
z &lt;- log(meuse$cadmium)
svm &lt;- semivariogram(x=x,y=y,z=z)
kriging(x=x,y=y,z=z,xi=179850,yi=331650,svm=svm,grid=TRUE)
</code></pre>

<hr>
<h2 id='ksdist'>Kolmogorov-Smirnov distance matrix</h2><span id='topic+ksdist'></span>

<h3>Description</h3>

<p>Given a list of numerical vectors, fills a square
matrix with Kolmogorov-Smirnov statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ksdist(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ksdist_+3A_dat">dat</code></td>
<td>
<p>a list of numerical data vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>dist</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DZ,package='geostats')
d &lt;- ksdist(DZ)
mds &lt;- cmdscale(d)
plot(mds,type='n')
text(mds,labels=names(DZ))
</code></pre>

<hr>
<h2 id='logit'>logistic transformation</h2><span id='topic+logit'></span><span id='topic+logit.default'></span><span id='topic+logit.density'></span>

<h3>Description</h3>

<p>Maps numbers from [0,1] to [<code class="reqn">-\infty,+\infty</code>] and
back.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x, ...)

## Default S3 method:
logit(x, inverse = FALSE, ...)

## S3 method for class 'density'
logit(x, inverse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>a vector of real numbers (strictly positive if
<code>inverse=FALSE</code>) or an object of class <code>density</code>.</p>
</td></tr>
<tr><td><code id="logit_+3A_...">...</code></td>
<td>
<p>optional arguments to the <code>log</code> function.</p>
</td></tr>
<tr><td><code id="logit_+3A_inverse">inverse</code></td>
<td>
<p>logical. If <code>inverse=FALSE</code>, returns
<code class="reqn">\ln\!\left[\frac{x}{1-x}\right]</code>; otherwise returns
<code class="reqn">\frac{\exp[x]}{\exp[x]+1}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the same length of <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(catchments,package='geostats')
lp &lt;- logit(catchments$vegetation/100,inverse=FALSE)
ld &lt;- density(lp)
d &lt;- logit(ld,inverse=TRUE)
plot(d)
</code></pre>

<hr>
<h2 id='major'>composition of Namib dune sand</h2><span id='topic+major'></span>

<h3>Description</h3>

<p>Major element compositions of 16 Namib sand samples.
</p>


<h3>References</h3>

<p>Vermeesch, P. &amp; Garzanti, E. &ldquo;Making geological sense
of &lsquo;Big Data&rsquo; in sedimentary provenance analysis.&rdquo; Chemical
Geology 409 (2015): 20-27.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(major,package='geostats')
comp &lt;- clr(major)
pc &lt;- prcomp(comp)
biplot(pc)
</code></pre>

<hr>
<h2 id='meanangle'>mean angle</h2><span id='topic+meanangle'></span>

<h3>Description</h3>

<p>Computes the vector mean of a collection of circular
measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanangle(trd, plg = 0, option = 0, degrees = FALSE, orientation = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanangle_+3A_trd">trd</code></td>
<td>
<p>trend angle, in degrees, between 0 and 360 (if
<code>degrees=TRUE</code>) or between 0 and <code class="reqn">2\pi</code> (if
<code>degrees=FALSE</code>).</p>
</td></tr>
<tr><td><code id="meanangle_+3A_plg">plg</code></td>
<td>
<p>(optional) plunge angle, in degrees, between 0 and 90
(if <code>degrees=TRUE</code>) or between 0 and <code class="reqn">2\pi</code> (if
<code>degrees=FALSE</code>).</p>
</td></tr>
<tr><td><code id="meanangle_+3A_option">option</code></td>
<td>
<p>scalar. If <code>option=0</code>, then <code>plg</code> is
ignored and the measurements are considered to be circular; if
<code>option=1</code>, then <code>trd</code> is the azimuth and <code>plg</code>
is the dip; if <code>option=2</code>, then <code>trd</code> is the strike
and <code>plg</code> is the dip; if <code>option=3</code> then <code>trd</code>
is the longitude and <code>plg</code> is the latitude.</p>
</td></tr>
<tr><td><code id="meanangle_+3A_degrees">degrees</code></td>
<td>
<p><code>TRUE</code> for degrees, <code>FALSE</code> for radians</p>
</td></tr>
<tr><td><code id="meanangle_+3A_orientation">orientation</code></td>
<td>
<p>logical. If <code>TRUE</code>, estimates the mean
angle by eigen decomposition rather than by vector
summation. This is the right thing to do for orientation data
in which, for example, an angle of 45 degrees is equivalent to
an angle of 225 degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar of 2-element vector with the mean orientation,
either in radians (if <code>degrees=FALSE</code>), or in degrees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(striations,package='geostats')
meanangle(striations,degrees=TRUE)
</code></pre>

<hr>
<h2 id='meuse'>Meuse river data set</h2><span id='topic+meuse'></span>

<h3>Description</h3>

<p>This data set gives locations and topsoil heavy metal
concentrations, collected in a flood plain of the river Meuse, near
the village of Stein (NL). Heavy metal concentrations are from
composite samples of an area of approximately 15 m x 15 m. This
version of the <code>meuse</code> dataset is a trimmed down version of
the eponymous dataset from the <code>sp</code> dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse,package='geostats')
semivariogram(x=meuse$x,y=meuse$y,z=log(meuse$cadmium))
</code></pre>

<hr>
<h2 id='Mode'>get the mode of a dataset</h2><span id='topic+Mode'></span>

<h3>Description</h3>

<p>Computes the most frequently occuring value in a
sampling distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mode(x, categorical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mode_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="Mode_+3A_categorical">categorical</code></td>
<td>
<p>logical. If <code>TRUE</code>, returns the most
frequently occuring value for categorical variables. If
<code>FALSE</code>, returns the value corresponding to the maximimum
kernel density for continuous variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(catchments,package='geostats')
m1 &lt;- Mode(catchments$CaMg,categorical=TRUE)

m2 &lt;- 1:50
for (i in m2){
   m2[i] &lt;- Mode(rnorm(100),categorical=FALSE)
}
hist(m2)
</code></pre>

<hr>
<h2 id='palaeomag'>palaeomagnetic data</h2><span id='topic+palaeomag'></span>

<h3>Description</h3>

<p>Ten paired magnetic declination (azimuth) and inclination (dip)
measurements, drawn from a von Mises - Fisher distribution with
mean vector <code class="reqn">\mu=\{2,2,1\}/3</code> and concentration parameter
<code class="reqn">\kappa=200</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(palaeomag,package='geostats')
stereonet(trd=palaeomag$decl,plg=palaeomag$incl,degrees=TRUE,show.grid=FALSE)
</code></pre>

<hr>
<h2 id='PCA2D'>Principal Component Analysis of 2D data</h2><span id='topic+PCA2D'></span>

<h3>Description</h3>

<p>Produces a 4-panel summary plot for two dimensional
PCA for didactical purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCA2D(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCA2D_+3A_x">X</code></td>
<td>
<p>a matrix with two columns</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rbind(c(-1,7),c(3,2),c(4,3))
colnames(X) &lt;- c('a','b')
PCA2D(X)
</code></pre>

<hr>
<h2 id='pebbles'>pebble orientations</h2><span id='topic+pebbles'></span>

<h3>Description</h3>

<p>Orientations (in degrees) of 20 pebbles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pebbles,package='geostats')
circle.plot(pebbles,degrees=TRUE)
m &lt;- meanangle(pebbles,option=0,orientation=TRUE)
circle.points(m,degrees=TRUE,pch=22,bg='white')
</code></pre>

<hr>
<h2 id='pendulum'>3-magnet pendulum experiment</h2><span id='topic+pendulum'></span>

<h3>Description</h3>

<p>Simulates the 3-magnet pendulum experiment, starting
at a specified position with a given start velocity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pendulum(
  startpos = c(-2, 2),
  startvel = c(0, 0),
  src = rbind(c(0, 0), c(0.5, sqrt(0.75)), c(1, 0)),
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pendulum_+3A_startpos">startpos</code></td>
<td>
<p>2-element vecotor with the initial position</p>
</td></tr>
<tr><td><code id="pendulum_+3A_startvel">startvel</code></td>
<td>
<p>2-element vector with the initial velocity</p>
</td></tr>
<tr><td><code id="pendulum_+3A_src">src</code></td>
<td>
<p><code class="reqn">n \times 2</code> matrix with the positions of the magnets</p>
</td></tr>
<tr><td><code id="pendulum_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>, generates a plot with the
trajectory of the pendulum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the end position of the pendulum
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- par(mfrow=c(1,2))
pendulum(startpos=c(2.1,2))
pendulum(startpos=c(1.9,2))
par(p)
</code></pre>

<hr>
<h2 id='randy'>generate bivariate random data</h2><span id='topic+randy'></span>

<h3>Description</h3>

<p>Returns bivariate datasets from four synthetic
distributions that have the shape of a circle, arrow, square
and ellipse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randy(pop = 1, n = 250)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randy_+3A_pop">pop</code></td>
<td>
<p>an integer from 1 to 4 marking the population of choice:
1 = circle, 2 = arrow, 3 = solid square, 4 = ellipse.</p>
</td></tr>
<tr><td><code id="randy_+3A_n">n</code></td>
<td>
<p>the number of random draws to be drawn from population <code>pop</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>[2xn]</code> matrix of random numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- par(mfrow=c(1,4))
for (i in 1:4){
   plot(randy(pop=i))
}
par(p)
</code></pre>

<hr>
<h2 id='Rbar'>calculate <code class="reqn">\bar{R}</code></h2><span id='topic+Rbar'></span>

<h3>Description</h3>

<p>Given <code class="reqn">n</code> circular or spherical measurements, the
length of their normalised vector sum (<code class="reqn">\bar{R}</code>) serves as
a measure of directional concentration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rbar(trd, plg = 0, option = 0, degrees = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rbar_+3A_trd">trd</code></td>
<td>
<p>trend angle, in degrees, between 0 and 360 (if
<code>degrees=TRUE</code>) or between 0 and <code class="reqn">2\pi</code> (if
<code>degrees=FALSE</code>).</p>
</td></tr>
<tr><td><code id="Rbar_+3A_plg">plg</code></td>
<td>
<p>(optional) plunge angle, in degrees, between 0 and 90
(if <code>degrees=TRUE</code>) or between 0 and <code class="reqn">2\pi</code> (if
<code>degrees=FALSE</code>).</p>
</td></tr>
<tr><td><code id="Rbar_+3A_option">option</code></td>
<td>
<p>scalar. If <code>option=0</code>, then <code>plg</code> is
ignored and the measurements are considered to be circular; if
<code>option=1</code>, then <code>trd</code> is the azimuth and <code>plg</code>
is the dip; if <code>option=2</code>, then <code>trd</code> is the strike
and <code>plg</code> is the dip; if <code>option=3</code> then <code>trd</code>
is the longitude and <code>plg</code> is the latitude.</p>
</td></tr>
<tr><td><code id="Rbar_+3A_degrees">degrees</code></td>
<td>
<p><code>TRUE</code> for degrees, <code>FALSE</code> for radians</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a value between 0 and 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(striations,package='geostats')
Rbar(striations,degrees=TRUE)
</code></pre>

<hr>
<h2 id='Rbar2kappa'><code class="reqn">\bar{R}</code> to <code class="reqn">\kappa</code> conversion</h2><span id='topic+Rbar2kappa'></span>

<h3>Description</h3>

<p>Converts the empirical concentration parameter
<code class="reqn">\bar{R}</code> to the von-Mises concentration parameter
<code class="reqn">\kappa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rbar2kappa(R, p = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rbar2kappa_+3A_r">R</code></td>
<td>
<p>a scalar or vector of values between 0 and 1</p>
</td></tr>
<tr><td><code id="Rbar2kappa_+3A_p">p</code></td>
<td>
<p>the number of parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">\bar{R}</code> and <code class="reqn">\kappa</code> are two types of
concentration parameter that are commonly used in directional
data analysis.  <code class="reqn">\kappa</code> is one of the parameters of the
parametric von Mises distribution, which is difficult to
estimate from the data. <code class="reqn">\bar{R}</code> is easier to calculate
from data. <code>Rbar2kappa</code> converts <code class="reqn">\bar{R}</code> to
<code class="reqn">\bar{\kappa}</code> using the following approximate empirical
formula:
</p>
<p><code class="reqn">\kappa =
    \frac{\bar{R}(p+1-\bar{R}^2)}{1-\bar{R}^2}
</code>
</p>
<p>where <code class="reqn">p</code> marks the number of parameters in the data space (1
for circle, 2 for a sphere).
</p>


<h3>Value</h3>

<p>value(s) between 0 and <code class="reqn">+\infty</code>
</p>


<h3>References</h3>

<p>Banerjee, A., et al. &ldquo;Clustering on the unit
hypersphere using von Mises-Fisher distributions.&rdquo;  Journal of
Machine Learning Research 6.Sep (2005): 1345-1382.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(striations,package='geostats')
Rbar2kappa(Rbar(striations,degrees=TRUE))
</code></pre>

<hr>
<h2 id='rbsr'>Rb-Sr data</h2><span id='topic+rbsr'></span>

<h3>Description</h3>

<p>Synthetic dataset of 8 Rb-Sr analysis that form a 1Ga isochron.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rbsr,package='geostats')
plot(rbsr[,'RbSr'],rbsr[,'SrSr'])
fit &lt;- lm(SrSr ~ RbSr,data=rbsr)
abline(fit)
</code></pre>

<hr>
<h2 id='rwyxz'>Spurious correlation</h2><span id='topic+rwyxz'></span><span id='topic+ryxy'></span><span id='topic+rxzyz'></span>

<h3>Description</h3>

<p>Calculate the &lsquo;null correlation&rsquo; of ratios, using the
the spurious correlation formula of Pearson (1897).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwyxz(
  mw,
  mx,
  my,
  mz,
  sw,
  sx,
  sy,
  sz,
  rwx = 0,
  rwy = 0,
  rwz = 0,
  rxy = 0,
  rxz = 0,
  ryz = 0
)

ryxy(mx, my, sx, sy, rxy = 0)

rxzyz(mx, my, mz, sx, sy, sz, rxy = 0, rxz = 0, ryz = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwyxz_+3A_mw">mw</code></td>
<td>
<p>the mean of variable <code>w</code></p>
</td></tr>
<tr><td><code id="rwyxz_+3A_mx">mx</code></td>
<td>
<p>the mean of variable <code>x</code></p>
</td></tr>
<tr><td><code id="rwyxz_+3A_my">my</code></td>
<td>
<p>the mean of variable <code>y</code></p>
</td></tr>
<tr><td><code id="rwyxz_+3A_mz">mz</code></td>
<td>
<p>the mean of variable <code>z</code></p>
</td></tr>
<tr><td><code id="rwyxz_+3A_sw">sw</code></td>
<td>
<p>the standard deviation of variable <code>w</code></p>
</td></tr>
<tr><td><code id="rwyxz_+3A_sx">sx</code></td>
<td>
<p>the standard deviation of variable <code>x</code></p>
</td></tr>
<tr><td><code id="rwyxz_+3A_sy">sy</code></td>
<td>
<p>the standard deviation of variable <code>y</code></p>
</td></tr>
<tr><td><code id="rwyxz_+3A_sz">sz</code></td>
<td>
<p>the standard deviation of variable <code>z</code></p>
</td></tr>
<tr><td><code id="rwyxz_+3A_rwx">rwx</code></td>
<td>
<p>the correlation coefficient between <code>w</code> and
<code>x</code></p>
</td></tr>
<tr><td><code id="rwyxz_+3A_rwy">rwy</code></td>
<td>
<p>the correlation coefficient between <code>w</code> and
<code>y</code></p>
</td></tr>
<tr><td><code id="rwyxz_+3A_rwz">rwz</code></td>
<td>
<p>the correlation coefficient between <code>w</code> and
<code>z</code></p>
</td></tr>
<tr><td><code id="rwyxz_+3A_rxy">rxy</code></td>
<td>
<p>the correlation coefficient between <code>x</code> and
<code>y</code></p>
</td></tr>
<tr><td><code id="rwyxz_+3A_rxz">rxz</code></td>
<td>
<p>the correlation coefficient between <code>x</code> and
<code>z</code></p>
</td></tr>
<tr><td><code id="rwyxz_+3A_ryz">ryz</code></td>
<td>
<p>the correlation coefficient between <code>y</code> and
<code>z</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the null correlation coefficient
</p>


<h3>References</h3>

<p>Pearson, K. &ldquo;Mathematical contributions to the theory
of evolution. &ndash; on a form of spurious correlation which may
arise when indices are used in the measurement of organs.&rdquo;
Proceedings of the Royal Society of London 60.359-367 (1897):
489-498.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxzyz(mx=100,my=100,mz=100,sx=1,sy=1,sz=10)
</code></pre>

<hr>
<h2 id='semivariogram'>semivariogram</h2><span id='topic+semivariogram'></span>

<h3>Description</h3>

<p>Plots the semivariance of spatial data against
inter-sample distance, and fits a spherical equation to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semivariogram(
  x,
  y,
  z,
  bw = NULL,
  nb = 13,
  plot = TRUE,
  fit = TRUE,
  model = c("spherical", "exponential", "gaussian"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="semivariogram_+3A_x">x</code></td>
<td>
<p>numerical vector</p>
</td></tr>
<tr><td><code id="semivariogram_+3A_y">y</code></td>
<td>
<p>numerical vector of the same length as <code>x</code></p>
</td></tr>
<tr><td><code id="semivariogram_+3A_z">z</code></td>
<td>
<p>numerical vector of the same length as <code>x</code></p>
</td></tr>
<tr><td><code id="semivariogram_+3A_bw">bw</code></td>
<td>
<p>(optional) the bin width of the semivariance search
algorithm</p>
</td></tr>
<tr><td><code id="semivariogram_+3A_nb">nb</code></td>
<td>
<p>(optional) the maximum number of bins to evaluate</p>
</td></tr>
<tr><td><code id="semivariogram_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>FALSE</code>, suppresses the graphical
output</p>
</td></tr>
<tr><td><code id="semivariogram_+3A_fit">fit</code></td>
<td>
<p>logical. If <code>TRUE</code>, returns the sill, nugget and
range.</p>
</td></tr>
<tr><td><code id="semivariogram_+3A_model">model</code></td>
<td>
<p>the parametric model to fit to the empirical
semivariogram (only used if <code>fit=TRUE</code>).</p>
</td></tr>
<tr><td><code id="semivariogram_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed on to the generic
<code>plot</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with the estimated semivariances at
different distances for the data, and (if <code>fit=TRUE</code>), a
vector with the sill, nugget and range.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse,package='geostats')
semivariogram(x=meuse$x,y=meuse$y,z=log(meuse$cadmium))
</code></pre>

<hr>
<h2 id='sierpinski'>Sierpinski carpet</h2><span id='topic+sierpinski'></span>

<h3>Description</h3>

<p>Returns a matrix of 0s and 1s that form a Sierpinski
carpet. This is a two dimensional fractal, which is generated
using a recursive algorithm that is built on a grid of eight
black squares surrounding a white square. Each level of
recursion replaces each black square by the same pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sierpinski(n = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sierpinski_+3A_n">n</code></td>
<td>
<p>an integer value controling the number of recursive
levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a square matrix with 0s and 1s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sierpinski(n=5)
image(g,col=c('white','black'),axes=FALSE,asp=1)
</code></pre>

<hr>
<h2 id='sizefrequency'>calculate the size-frequency distribution of things</h2><span id='topic+sizefrequency'></span>

<h3>Description</h3>

<p>Count the number of items exceeding a certain size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizefrequency(dat, n = 10, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sizefrequency_+3A_dat">dat</code></td>
<td>
<p>a numerical vector</p>
</td></tr>
<tr><td><code id="sizefrequency_+3A_n">n</code></td>
<td>
<p>the number of sizes to evaluate</p>
</td></tr>
<tr><td><code id="sizefrequency_+3A_log">log</code></td>
<td>
<p>logical. If <code>TRUE</code>, uses a log spacing for the
sizes at which the frequencies are evaluated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with two columns <code>size</code> and
<code>frequency</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Finland,package='geostats')
sf &lt;- sizefrequency(Finland$area)
plot(frequency~size,data=sf,log='xy')
fit &lt;- lm(log(frequency) ~ log(size),data=sf)
lines(x=sf$size,y=exp(predict(fit)))
</code></pre>

<hr>
<h2 id='skew'>calculate the skewness of a dataset</h2><span id='topic+skew'></span>

<h3>Description</h3>

<p>Compute the third moment of a sampling distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skew(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skew_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(catchments,package='geostats')
skew(catchments$vegetation)
</code></pre>

<hr>
<h2 id='stereonet'>stereonet</h2><span id='topic+stereonet'></span>

<h3>Description</h3>

<p>Plots directional data on a Wulff or Schmidt
stereonet. The Wulff equal angle polar Lambert projection
preserves the shape of objects and is often used to visualise
structural data.  The Schmidt equal area polar Lambert
projection preserves the size of objects and is more popular in
mineralogy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stereonet(
  trd,
  plg,
  coneAngle = rep(10, length(trd)),
  option = 1,
  wulff = TRUE,
  add = FALSE,
  degrees = FALSE,
  show.grid = TRUE,
  grid.col = "grey50",
  tl = 0.05,
  type = "p",
  labels = 1:length(trd),
  pch = 21,
  bg = c("black", "white"),
  lty = c(1, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stereonet_+3A_trd">trd</code></td>
<td>
<p>trend angle, in degrees, between 0 and 360 (if
<code>degrees=TRUE</code>) or between 0 and <code class="reqn">2\pi</code> (if
<code>degrees=FALSE</code>).</p>
</td></tr>
<tr><td><code id="stereonet_+3A_plg">plg</code></td>
<td>
<p>plunge angle, in degrees, between 0 and 90 (if
<code>degrees=TRUE</code>) or between 0 and <code class="reqn">2\pi</code> (if
<code>degrees=FALSE</code>).</p>
</td></tr>
<tr><td><code id="stereonet_+3A_coneangle">coneAngle</code></td>
<td>
<p>if <code>option=4</code>, controls the radius of a small
circle around the pole with azimuth <code>trd</code> and dip
<code>plg</code>.</p>
</td></tr>
<tr><td><code id="stereonet_+3A_option">option</code></td>
<td>
<p>scalar. If <code>option=1</code> or <code>option=4</code>, then
<code>trd</code> is the azimuth and <code>plg</code> is the dip; if
<code>option=2</code>, then <code>trd</code> is the strike and <code>plg</code>
is the dip; if <code>option=3</code>, then <code>trd</code> is the
longitude and <code>plg</code> is the latitude.</p>
</td></tr>
<tr><td><code id="stereonet_+3A_wulff">wulff</code></td>
<td>
<p>logical. If <code>FALSE</code>, produces a Schmidt net.</p>
</td></tr>
<tr><td><code id="stereonet_+3A_add">add</code></td>
<td>
<p>logical. If <code>TRUE</code>, adds to an existing stereonet.</p>
</td></tr>
<tr><td><code id="stereonet_+3A_degrees">degrees</code></td>
<td>
<p>logical. If <code>FALSE</code>, assumes that
<code>azimuth</code> and <code>dip</code> are in radians.</p>
</td></tr>
<tr><td><code id="stereonet_+3A_show.grid">show.grid</code></td>
<td>
<p>logical. If <code>TRUE</code>, decorates the plot with a
grid of great and small circles.</p>
</td></tr>
<tr><td><code id="stereonet_+3A_grid.col">grid.col</code></td>
<td>
<p>colour of the grid.</p>
</td></tr>
<tr><td><code id="stereonet_+3A_tl">tl</code></td>
<td>
<p>tick length for the N, E, S, W markers (value between 0
and 1).  Set to 0 to omit the markers.</p>
</td></tr>
<tr><td><code id="stereonet_+3A_type">type</code></td>
<td>
<p>if <code>option=1</code> or <code>3</code>, coordinates can be
visualsed as points (<code>type='p'</code>), lines (<code>type='l'</code>)
or decorated with text labels (<code>type='t'</code>).</p>
</td></tr>
<tr><td><code id="stereonet_+3A_labels">labels</code></td>
<td>
<p>if <code>option=1</code> or <code>3</code> and <code>type='t'</code>,
specifies the text labels to be used to mark the measurements
on the stereonet.</p>
</td></tr>
<tr><td><code id="stereonet_+3A_pch">pch</code></td>
<td>
<p>plot character: see &lsquo;points&rsquo;.</p>
</td></tr>
<tr><td><code id="stereonet_+3A_bg">bg</code></td>
<td>
<p>background colours of the plot characters. Vector of two
colours, which are used to mark points that plot below and
above the projection plane of the stereonet, respectively. Only
relevant if <code>pch</code> falls in the range from 21:25.</p>
</td></tr>
<tr><td><code id="stereonet_+3A_lty">lty</code></td>
<td>
<p>line type. Vector of two numbers, which are used to plot
lines below and above the projection plane of the stereonet,
respectively.</p>
</td></tr>
<tr><td><code id="stereonet_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed on to the generic
<code>points</code> function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>based on a MATLAB script written by Nestor Cardozo.
</p>


<h3>References</h3>

<p>Allmendinger, R.W., Cardozo, N., and Fisher,
D.M. &ldquo;Structural geology algorithms: Vectors and
tensors&rdquo;. Cambridge University Press, 2011.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stereonet(trd=c(120,80),plg=c(10,30),degrees=TRUE,pch=16)
stereonet(trd=c(120,80),plg=c(10,30),degrees=TRUE,
          option=4,coneAngle=c(5,10),add=TRUE)
</code></pre>

<hr>
<h2 id='striations'>directions of glacial striations</h2><span id='topic+striations'></span>

<h3>Description</h3>

<p>Directions (in degrees) of 30 glacial striation measurements from
Madagascar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(striations,package='geostats')
circle.plot(striations,degrees=TRUE)
</code></pre>

<hr>
<h2 id='ternary'>ternary diagrams</h2><span id='topic+ternary'></span>

<h3>Description</h3>

<p>Plot points, lines or text on a ternary diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ternary(xyz = NULL, f = rep(1, 3), labels, add = FALSE, type = "p", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ternary_+3A_xyz">xyz</code></td>
<td>
<p>an <code>n x 3</code> matrix or data frame</p>
</td></tr>
<tr><td><code id="ternary_+3A_f">f</code></td>
<td>
<p>a three-element vector of multipliers for <code>xyz</code></p>
</td></tr>
<tr><td><code id="ternary_+3A_labels">labels</code></td>
<td>
<p>the text labels for the corners of the ternary
diagram</p>
</td></tr>
<tr><td><code id="ternary_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, adds information to an existing ternary
diagram</p>
</td></tr>
<tr><td><code id="ternary_+3A_type">type</code></td>
<td>
<p>one of <code>'n'</code> (empty plot), <code>'p'</code> (points),
<code>'l'</code> (lines) or <code>'t'</code> (text).</p>
</td></tr>
<tr><td><code id="ternary_+3A_...">...</code></td>
<td>
<p>optional arguments to the <code>points</code>, <code>lines</code> or
<code>text</code> functions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(ACNK,package='geostats')
ternary(ACNK,type='p',labels=c(expression('Al'[2]*'O'[3]),
                               expression('CaO+Na'[2]*'O'),
                               expression('K'[2]*'O')))
</code></pre>

<hr>
<h2 id='test'>composition of a further 147 oceanic basalts</h2><span id='topic+test'></span>

<h3>Description</h3>

<p>Major element compositions of 64 island arc basalts (IAB), 23 mid
oceanic ridge basalts (MORB) and 60 ocean island basalts
(OIB). This dataset can be used to test supervised learning
algorithms.
</p>


<h3>References</h3>

<p>Vermeesch, P. &ldquo;Tectonic discrimination diagrams
revisited.&rdquo;  Geochemistry, Geophysics, Geosystems 7.6 (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
data(training,package='geostats')
ld &lt;- lda(x=alr(training[,-1]),grouping=training[,1])
data(test,package='geostats')
pr &lt;- predict(ld,newdata=alr(test[,-1]))
table(test$affinity,pr$class)
</code></pre>

<hr>
<h2 id='training'>composition of 646 oceanic basalts</h2><span id='topic+training'></span>

<h3>Description</h3>

<p>Major element compositions of 227 island arc basalts (IAB), 221 mid
oceanic ridge basalts (MORB) and 198 ocean island basalts
(OIB). This dataset can be used to train supervised learning
algorithms.
</p>


<h3>References</h3>

<p>Vermeesch, P. &ldquo;Tectonic discrimination diagrams
revisited.&rdquo;  Geochemistry, Geophysics, Geosystems 7.6 (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
data(training,package='geostats')
ld &lt;- lda(x=alr(training[,-1]),grouping=training[,1])
pr &lt;- predict(ld)
table(training$affinity,pr$class)
</code></pre>

<hr>
<h2 id='vonMises'>von Mises distribution</h2><span id='topic+vonMises'></span>

<h3>Description</h3>

<p>Returns the probability density of a von Mises
distribution, which describes probability distributions on a
circle using the following density function:
</p>
<p><code class="reqn">\frac{\exp(\kappa\cos(x-\mu))}{2\pi I_0(\kappa)}</code>
</p>
<p>where <code class="reqn">I_0(\kappa)</code> is a zero order Bessel function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vonMises(a, mu = 0, kappa = 1, degrees = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vonMises_+3A_a">a</code></td>
<td>
<p>angle(s), scalar or vector</p>
</td></tr>
<tr><td><code id="vonMises_+3A_mu">mu</code></td>
<td>
<p>scalar containing the mean direction</p>
</td></tr>
<tr><td><code id="vonMises_+3A_kappa">kappa</code></td>
<td>
<p>scalar containing the concentration parameter</p>
</td></tr>
<tr><td><code id="vonMises_+3A_degrees">degrees</code></td>
<td>
<p><code>TRUE</code> for degrees, <code>FALSE</code> for radians</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar or vector of the same length as <code>angles</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(x=c(-1,1.2),y=c(-1,1.2),type='n',
     axes=FALSE,ann=FALSE,bty='n',asp=1)
a &lt;- seq(from=-pi,to=pi,length.out=200)
d &lt;- vonMises(a=a,mu=pi/4,kappa=5)
symbols(x=0,y=0,circles=1,add=TRUE,inches=FALSE,xpd=NA,fg='grey50')
lines(x=(1+d)*cos(a),y=(1+d)*sin(a),xpd=NA)
</code></pre>

<hr>
<h2 id='worldpop'>world population</h2><span id='topic+worldpop'></span>

<h3>Description</h3>

<p>The world population from 1750 until 2014.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(worldpop,package='geostats')
plot(worldpop)
</code></pre>

<hr>
<h2 id='xyz2xy'>get x,y plot coordinates of ternary data</h2><span id='topic+xyz2xy'></span>

<h3>Description</h3>

<p>Helper function to generate bivariate plot coordinates
for ternary data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyz2xy(xyz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyz2xy_+3A_xyz">xyz</code></td>
<td>
<p>an <code>n x 3</code> matrix or data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>n x 2</code> numerical matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyz &lt;- rbind(c(1,0,0),c(0,1,0),c(0,0,1),c(1,0,0))
xy &lt;- xyz2xy(xyz)
plot(xy,type='l',bty='n')
</code></pre>

<hr>
<h2 id='york'>Linear regression of X,Y-variables with correlated errors</h2><span id='topic+york'></span>

<h3>Description</h3>

<p>Implements the unified regression algorithm of York et al. (2004)
which, although based on least squares, yields results that are
consistent with maximum likelihood estimates of Titterington and
Halliday (1979).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>york(dat, alpha = 0.05, plot = TRUE, fill = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="york_+3A_dat">dat</code></td>
<td>
<p>a 4 or 5-column matrix with the X-values, the analytical
uncertainties of the X-values, the Y-values, the analytical
uncertainties of the Y-values, and (optionally) the correlation
coefficients of the X- and Y-values.</p>
</td></tr>
<tr><td><code id="york_+3A_alpha">alpha</code></td>
<td>
<p>cutoff value for confidence intervals.</p>
</td></tr>
<tr><td><code id="york_+3A_plot">plot</code></td>
<td>
<p>logical. If true, creates a scatter plot of the data
with the best fit line shown on it.</p>
</td></tr>
<tr><td><code id="york_+3A_fill">fill</code></td>
<td>
<p>the fill colour of the error ellipses. For additional
plot options, use the <code>IsoplotR</code> package.</p>
</td></tr>
<tr><td><code id="york_+3A_...">...</code></td>
<td>
<p>optional arguments for the scatter plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given n pairs of (approximately) collinear measurements <code class="reqn">X_i</code>
and <code class="reqn">Y_i</code> (for <code class="reqn">1 \leq i \leq n</code>), their uncertainties
<code class="reqn">s[X_i]</code> and <code class="reqn">s[Y_i]</code>, and their covariances
cov[<code class="reqn">X_i,Y_i</code>], the <code>york</code> function finds the best fitting
straight line using the least-squares algorithm of York et
al. (2004). This algorithm is modified from an earlier method
developed by York (1968) to be consistent with the maximum
likelihood approach of Titterington and Halliday (1979).
</p>


<h3>Value</h3>

<p>A two-element list of vectors containing:
</p>

<dl>
<dt>coef</dt><dd><p>the intercept and slope of the straight line fit</p>
</dd>
<dt>cov</dt><dd><p>the covariance matrix of the coefficients</p>
</dd>
</dl>



<h3>References</h3>

<p>Titterington, D.M. and Halliday, A.N., 1979. On the fitting of
parallel isochrons and the method of maximum likelihood. Chemical
Geology, 26(3), pp.183-195.
</p>
<p>York, Derek, et al., 2004. Unified equations for the slope,
intercept, and standard errors of the best straight line.  American
Journal of Physics 72.3, pp.367-375.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rbsr,package='geostats')
fit &lt;- york(rbsr)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
