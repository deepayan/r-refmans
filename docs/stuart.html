<!DOCTYPE html><html><head><title>Help for package stuart</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stuart}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.stuartFixedObjective'><p>Convert empirical to fixed objective.</p></a></li>
<li><a href='#bruteforce'><p>Subtest construction using a brute-force approach</p></a></li>
<li><a href='#combinations'><p>Compute the number of possible subtest combinations</p></a></li>
<li><a href='#crossvalidate'><p>Cross-Validate a Measurement Model</p></a></li>
<li><a href='#empiricalobjective'><p>Generate an empirical objective function for item selection.</p></a></li>
<li><a href='#extractobjective'><p>Extracting empirical objective functions for item selection</p></a></li>
<li><a href='#fairplayer'><p>MTMM fairplayer Intervention Data (2009)</p></a></li>
<li><a href='#fixedobjective'><p>Generate a fixed objective function for item selection.</p></a></li>
<li><a href='#gene'><p>Subtest construction using a simple genetic algorithm</p></a></li>
<li><a href='#heuristics'><p>Generating heuristics for the use in STUART subtest construction</p></a></li>
<li><a href='#holdout'><p>Data selection for holdout validation.</p></a></li>
<li><a href='#kfold'><p>k-Folds Crossvalidation</p></a></li>
<li><a href='#mmas'><p>Subtest construction using the Max-Min-Ant-System</p></a></li>
<li><a href='#objectivematrices'><p>Generate matrix-components for objective functions.</p></a></li>
<li><a href='#randomsamples'><p>Generating random samples of Subtests</p></a></li>
<li><a href='#sia'><p>Data from a German Meaning of Work Scale.</p></a></li>
<li><a href='#stuart-package'><p>STUART: Subtests Using Algorithmic Rummaging Techniques</p></a></li>
<li><a href='#sups'><p>Data from a scale for Supervisor Support</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Subtests Using Algorithmic Rummaging Techniques</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-05</td>
</tr>
<tr>
<td>Description:</td>
<td>Construct subtests from a pool of items by using ant-colony-optimization, genetic algorithms, brute force, or random sampling.
  Schultze (2017) &lt;<a href="https://doi.org/10.17169%2Frefubium-622">doi:10.17169/refubium-622</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, lavaan (&ge; 0.5.18), MplusAutomation (&ge; 0.7-2),
graphics, sn</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-05 20:42:28 UTC; martin</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Schultze [aut, cre],
  Johanna Schüller [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Schultze &lt;schultze@psych.uni-frankfurt.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-05 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.stuartFixedObjective'>Convert empirical to fixed objective.</h2><span id='topic+as.stuartFixedObjective'></span>

<h3>Description</h3>

<p>Convert an empirical objective to a fixed version to be used in item-selection. Sensible for extracting values from random selections and then using them in empirical but static objective functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.stuartFixedObjective(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.stuartFixedObjective_+3A_x">x</code></td>
<td>
<p>An object of class <code>stuartEmpiricalObjective</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>stuartFixedObjective</code>
</p>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empiricalobjective">empiricalobjective</a></code>, <code><a href="#topic+fixedobjective">fixedobjective</a></code>
</p>

<hr>
<h2 id='bruteforce'>Subtest construction using a brute-force approach</h2><span id='topic+bruteforce'></span>

<h3>Description</h3>

<p>Construct subtests from a given pool of items using a brute-force approach (i.e. by estimating all possible combinations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bruteforce(
  data,
  factor.structure,
  capacity = NULL,
  item.invariance = "congeneric",
  repeated.measures = NULL,
  long.invariance = "strict",
  mtmm = NULL,
  mtmm.invariance = "configural",
  grouping = NULL,
  group.invariance = "strict",
  comparisons = NULL,
  auxiliary = NULL,
  use.order = FALSE,
  software = "lavaan",
  cores = NULL,
  objective = NULL,
  ignore.errors = FALSE,
  analysis.options = NULL,
  suppress.model = FALSE,
  request.override = 10000,
  filename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bruteforce_+3A_data">data</code></td>
<td>
<p>A data.frame containing all relevant data.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_factor.structure">factor.structure</code></td>
<td>
<p>A list linking factors to items. The names of the list elements correspond to the factor names. Each list element must contain a character-vector of item names that are indicators of this factor.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_capacity">capacity</code></td>
<td>
<p>A list containing the number of items per subtest. This must be in the same order as the <code>factor.structure</code> provided. If a single number, it is applied to all subtests. If <code>NULL</code> all items are evenly distributed among the subtests.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_item.invariance">item.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>factor.structure</code> containing the desired invariance levels between items pertaining to the same subtest. Currently there are five options: 'congeneric', 'ess.equivalent', 'ess.parallel', 'equivalent', and 'parallel', the first being the default.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_repeated.measures">repeated.measures</code></td>
<td>
<p>A list linking factors that are repeated measures of each other. Repeated factors must be in one element of the list - other sets of factors in other elements of the list. When this is <code>NULL</code> (the default) a cross-sectional model is estimated.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_long.invariance">long.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>repeated.measures</code> containing the longitudinal invariance level of repeated items. Currently there are four options: 'configural', 'weak', 'strong', and 'strict'. Defaults to 'strict'. When <code>repeated.measures=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_mtmm">mtmm</code></td>
<td>
<p>A list linking factors that are measurements of the same construct with different methods. Measurements of the same construct must be in one element of the list - other sets of methods in other elements of the list. When this is <code>NULL</code> (the default) a single method model is estimated.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_mtmm.invariance">mtmm.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>mtmm</code> containing the invariance level of MTMM items. Currently there are five options: 'none', 'configural', 'weak', 'strong', and 'strict'. Defaults to 'configural'. With 'none' differing items are allowed for different methods. When <code>mtmm=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_grouping">grouping</code></td>
<td>
<p>The name of the grouping variable. The grouping variable must be part of <code>data</code> provided and must be a numeric variable.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_group.invariance">group.invariance</code></td>
<td>
<p>A single value describing the assumed invariance of items across groups. Currently there are four options: 'configural', 'weak', 'strong', and 'strict'. Defaults to 'strict'. When <code>grouping=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_comparisons">comparisons</code></td>
<td>
<p>A character vector containing any combination of 'item', 'long', 'mtmm', and 'group' indicating which invariance should be assessed via model comparisons. The order of the vector dictates the sequence in which model comparisons are performed. Defaults to <code>NULL</code> meaning that no model comparisons are performed.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_auxiliary">auxiliary</code></td>
<td>
<p>The names of auxiliary variables in <code>data</code>. These can be used in additional modeling steps that may be provided in <code>analysis.options$model</code>.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_use.order">use.order</code></td>
<td>
<p>A logical indicating whether or not to take the selection order of the items into account. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_software">software</code></td>
<td>
<p>The name of the estimation software. Can currently be 'lavaan' (the default), 'Mplus', or 'Mplus Demo'. Each option requires the software to be installed.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used in parallel processing. If <code>NULL</code> (the default) the result of <code><a href="parallel.html#topic+detectCores">detectCores</a></code> will be used. On Unix-y machines parallel processing is implemented via <code><a href="parallel.html#topic+mclapply">mclapply</a></code>, on Windows machines it is realized via <code><a href="parallel.html#topic+parLapply">parLapply</a></code>.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_objective">objective</code></td>
<td>
<p>A function that converts the results of model estimation into a pheromone. See <code><a href="#topic+mmas">mmas</a></code> for details.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_ignore.errors">ignore.errors</code></td>
<td>
<p>A logical indicating whether or not to ignore estimation problems (such as non positive-definite latent covariance matrices). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_analysis.options">analysis.options</code></td>
<td>
<p>A list additional arguments to be passed to the estimation software. The names of list elements must correspond to the arguments changed in the respective estimation software. E.g. <code>analysis.options$model</code> can contain additional modeling commands - such as regressions on auxiliary variables.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_suppress.model">suppress.model</code></td>
<td>
<p>A logical indicating whether to suppress the default model generation. If <code>TRUE</code> a model must be provided in <code>analysis.options$model</code>.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_request.override">request.override</code></td>
<td>
<p>The maximum number of combinations for which the estimation is performed immediately, without an additional override request.</p>
</td></tr>
<tr><td><code id="bruteforce_+3A_filename">filename</code></td>
<td>
<p>The stem of the filenames used to save inputs, outputs, and data files when <code>software='Mplus'</code>. This may include the file path. When <code>NULL</code> (the default) files will be saved to the temporary directory, which is deleted when the R session is ended.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pheromone function provided via <code>objective</code> is used to assess the quality of the solutions. These functions can contain any combination of the fit indices provided by the estimation software. When using Mplus these fit indices are 'rmsea', 'srmr', 'cfi', 'tli', 'chisq' (with 'df' and 'pvalue'), 'aic', 'bic', and 'abic'. With lavaan any fit index provided by <code><a href="lavaan.html#topic+inspect">inspect</a></code> can be used. Additionally 'crel' provides an aggregate of composite reliabilites, 'rel' provides a vector or a list of reliability coefficients for the latent variables, 'con' provides an aggregate consistency estimate for MTMM analyses, and 'lvcor' provides a list of the latent variable correlation matrices. For more detailed objective functions 'lambda', 'theta', 'psi', 'alpha', and 'nu' provide the model-implied matrices. Per default a pheromone function using 'crel', 'rmsea', and 'srmr' is used. Please be aware that the <code>objective</code> must be a function with the required fit indices as (correctly named) arguments.
</p>
<p>Using model comparisons via the <code>comparisons</code> argument compares the target model to a model with one less degree of assumed invariance (e.g. if your target model contains strong invariance, the comparison model contain weak invariance). Adding comparisons will change the preset for the objective function to include model differences. With comparisons, a custom objective function (the recommended approach) can also include all model fit indices with a preceding <code>delta.</code> to indicate the difference in this index between the two models. If more than one type of comparison is used, the argument of the objective function should end in the type of comparison requested (e.g. <code>delta.cfi.group</code> to use the difference in CFI between the model comparison of invariance across groups).
</p>


<h3>Value</h3>

<p>Returns an object of the class <code>stuartOutput</code> for which specific <code>summary</code> and <code>plot</code> methods are available. The results are a list.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The called function.</p>
</td></tr>
<tr><td><code>software</code></td>
<td>
<p>The software used to fit the CFA models.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A list of the ACO parameters used.</p>
</td></tr>
<tr><td><code>analysis.options</code></td>
<td>
<p>A list of the additional arguments passed to the estimation software.</p>
</td></tr>
<tr><td><code>timer</code></td>
<td>
<p>An object of the class <code>proc_time</code> which contains the time used for the analysis.</p>
</td></tr>
<tr><td><code>log</code></td>
<td>
<p>A <code>data.frame</code> containing the estimation history.</p>
</td></tr>
<tr><td><code>log_mat</code></td>
<td>
<p>A <code>list</code> of matrices (e.g. lvcor) relevant to the estimation history, if any.</p>
</td></tr>
<tr><td><code>solution</code></td>
<td>
<p><code>NULL</code></p>
</td></tr>
<tr><td><code>pheromones</code></td>
<td>
<p><code>NULL</code></p>
</td></tr>
<tr><td><code>subtests</code></td>
<td>
<p>A list containing the names of the selected items and their respective subtests.</p>
</td></tr>
<tr><td><code>final</code></td>
<td>
<p>The results of the estimation of the global-best solution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmas">mmas</a></code>, <code><a href="#topic+gene">gene</a></code>, <code><a href="#topic+randomsamples">randomsamples</a></code>, <code><a href="#topic+combinations">combinations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Bruteforce selection in a minimal example
# selecting 3 of 5 items
# requires lavaan
data(fairplayer)
fs &lt;- list(ra = names(fairplayer)[53:57])
sel &lt;- bruteforce(fairplayer, fs, 3,
  cores = 1)  # number of cores set to 1
summary(sel)  # Fit is perfect because of just-identified model

</code></pre>

<hr>
<h2 id='combinations'>Compute the number of possible subtest combinations</h2><span id='topic+combinations'></span>

<h3>Description</h3>

<p>Used to compute the number of possible subtest constellations prior to performing item selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combinations(
  data,
  factor.structure,
  capacity = NULL,
  repeated.measures = NULL,
  mtmm = NULL,
  use.order = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combinations_+3A_data">data</code></td>
<td>
<p>A data.frame containing all relevant data.</p>
</td></tr>
<tr><td><code id="combinations_+3A_factor.structure">factor.structure</code></td>
<td>
<p>A list linking factors to items. The names of the list elements correspond to the factor names. Each list element must contain a character-vector of item names that are indicators of this factor.</p>
</td></tr>
<tr><td><code id="combinations_+3A_capacity">capacity</code></td>
<td>
<p>A list containing the number of items per subtest. This must be in the same order as the <code>factor.structure</code> provided. If a single number, it is applied to all subtests. If <code>NULL</code> all items are evenly distributed among the subtests.</p>
</td></tr>
<tr><td><code id="combinations_+3A_repeated.measures">repeated.measures</code></td>
<td>
<p>A list linking factors that are repeated measures of each other. Repeated factors must be in one element of the list - other sets of factors in other elements of the list. When this is <code>NULL</code> (the default) a cross-sectional model is estimated.</p>
</td></tr>
<tr><td><code id="combinations_+3A_mtmm">mtmm</code></td>
<td>
<p>A list linking factors that are measurements of the same construct with different methods. Measurements of the same construct must be in one element of the list - other sets of methods in other elements of the list. When this is <code>NULL</code> (the default) a single method model is estimated.</p>
</td></tr>
<tr><td><code id="combinations_+3A_use.order">use.order</code></td>
<td>
<p>A logical indicating whether or not to take the selection order of the items into account. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="combinations_+3A_...">...</code></td>
<td>
<p>Other arguments normally provided to <code><a href="#topic+mmas">mmas</a></code>, which will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the number of possible subtest constellations.
</p>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bruteforce">bruteforce</a></code>, <code><a href="#topic+mmas">mmas</a></code>, <code><a href="#topic+gene">gene</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Determine number of combinations in a simple situation
data(fairplayer)
fs &lt;- list(si = names(fairplayer)[83:92])
combinations(fairplayer, fs, 4)

# Number of combinations with repeated measures
data(fairplayer)
fs &lt;- list(si1 = names(fairplayer)[83:92],
  si2 = names(fairplayer)[93:102],
  si3 = names(fairplayer)[103:112])
repe &lt;- list(si = c('si1', 'si2', 'si3'))
combinations(fairplayer, fs, 4, repeated.measures = repe)

</code></pre>

<hr>
<h2 id='crossvalidate'>Cross-Validate a Measurement Model</h2><span id='topic+crossvalidate'></span>

<h3>Description</h3>

<p>Cross-validate a measurement model obtained from STUART.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossvalidate(
  selection,
  old.data,
  new.data,
  max.invariance = "strict",
  filename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossvalidate_+3A_selection">selection</code></td>
<td>
<p>An object of class <code>stuartOutput</code>.</p>
</td></tr>
<tr><td><code id="crossvalidate_+3A_old.data">old.data</code></td>
<td>
<p>A <code>data.frame</code> of the calibration sample.</p>
</td></tr>
<tr><td><code id="crossvalidate_+3A_new.data">new.data</code></td>
<td>
<p>A <code>data.frame</code> of the validation sample.</p>
</td></tr>
<tr><td><code id="crossvalidate_+3A_max.invariance">max.invariance</code></td>
<td>
<p>The maximum measurement invariance level which will be tested. Currently there are four options: 'configural', 'weak', 'strong', and 'strict' (the default). All levels below <code>max.invariance</code> are also tested.</p>
</td></tr>
<tr><td><code id="crossvalidate_+3A_filename">filename</code></td>
<td>
<p>The stem of the filenames used to save inputs, outputs, and data files when <code>software='Mplus'</code>. This may include the file path. When <code>NULL</code> (the default) files will be saved to the temporary directory, which is deleted when the R session is ended.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the <code>data.frame</code> <code>comparison</code> and an object containing the model results of the four different invariance assumptions. 
</p>
<table>
<tr><td><code>comparison</code></td>
<td>
<p>A <code>data.frame</code> with 4 observations, each observation representing a level of measurement invariance. The number of columns depends on the arguments of the <code>objective</code> used in the original selection. In addition to those columns, three additional columns with the (corrected) Likelihood-Ratio-Tests are reported.</p>
</td></tr>
<tr><td><code>models</code></td>
<td>
<p>A list of the four model results either of class <code>lavaan</code> or <code>mplus.model</code>, depending on the <code>software</code>-setting of the original selection.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+holdout">holdout</a></code>, <code><a href="#topic+mmas">mmas</a></code>, <code><a href="#topic+bruteforce">bruteforce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Split data into two halves
data(fairplayer)
half1 &lt;- fairplayer[1:72,]
half2 &lt;- fairplayer[73:143,]

# Simple example from bruteforce
fs &lt;- list(ra = names(fairplayer)[53:57])
sel &lt;- bruteforce(half1, fs, 3,
  cores = 1)  # number of cores set to 1

# Validation
crossvalidate(sel, half1, half2)

# Using the 'holdout' function for data split
data(fairplayer)
split &lt;- holdout(fairplayer, seed = 55635)

# Simple example from bruteforce
fs &lt;- list(ra = names(fairplayer)[53:57])
sel &lt;- bruteforce(split, fs, 3,
  cores = 1)  # number of cores set to 1

# Validation
crossvalidate(sel, split)

</code></pre>

<hr>
<h2 id='empiricalobjective'>Generate an empirical objective function for item selection.</h2><span id='topic+empiricalobjective'></span>

<h3>Description</h3>

<p>Generate an empirical objective function from default or empirical values for use in an item selection using STUART.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empiricalobjective(
  criteria = c("rmsea", "srmr", "crel"),
  add = c("chisq", "df", "pvalue"),
  x = NULL,
  n = 50,
  side = NULL,
  skew = FALSE,
  scale = 1,
  matrices = NULL,
  fixed = NULL,
  comparisons = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empiricalobjective_+3A_criteria">criteria</code></td>
<td>
<p>A vector of names of criteria included in the objective function. Defaults to <code>c('rmsea', 'srmr', 'crel')</code>.</p>
</td></tr>
<tr><td><code id="empiricalobjective_+3A_add">add</code></td>
<td>
<p>A vector of names of criteria not used in the objective function, but added in order to be included in the log of solutions.</p>
</td></tr>
<tr><td><code id="empiricalobjective_+3A_x">x</code></td>
<td>
<p>Either a vector of values or an object of class <code>stuartOutput</code> from which to determine values in the objective function. If <code>NULL</code> (the default) values are generated from criteria-specific presets.</p>
</td></tr>
<tr><td><code id="empiricalobjective_+3A_n">n</code></td>
<td>
<p>Number of values to use in function determining. Defaults to 50, meaning if <code>side = 'top'</code> the 50 largest values are used to determine discrimination and difficulty parameters for each criterion.</p>
</td></tr>
<tr><td><code id="empiricalobjective_+3A_side">side</code></td>
<td>
<p>Which side good values are located at. <code>'top'</code> means large values are good (e.g. Reliability), <code>'bottom'</code> means small values are good (e.g. RMSEA), and <code>'middle'</code> means average values are good (e.g. factor correlations).</p>
</td></tr>
<tr><td><code id="empiricalobjective_+3A_skew">skew</code></td>
<td>
<p>Whether to account for skew in the distribution using the <code>psn()</code> function from the <code>sn</code>-Package. Defaults to <code>FALSE</code>, meaning a normal distribution is used.</p>
</td></tr>
<tr><td><code id="empiricalobjective_+3A_scale">scale</code></td>
<td>
<p>A numeric scale to use in weighting the objective component. Defaults to 1.</p>
</td></tr>
<tr><td><code id="empiricalobjective_+3A_matrices">matrices</code></td>
<td>
<p>An object of class <code>stuartObjectiveMatrices</code> to include matrices (e.g. latent correlations) into the objective function.</p>
</td></tr>
<tr><td><code id="empiricalobjective_+3A_fixed">fixed</code></td>
<td>
<p>An object of class <code>stuartFixedObjective</code> to include already previously defined fixed objectives.</p>
</td></tr>
<tr><td><code id="empiricalobjective_+3A_comparisons">comparisons</code></td>
<td>
<p>A vector of names of criteria included in the objective function which are related to model comparisons (e.g. when determining measurement invariance).</p>
</td></tr>
<tr><td><code id="empiricalobjective_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>stuartFixedObjective</code>
</p>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixedobjective">fixedobjective</a></code>, <code><a href="#topic+extractobjective">extractobjective</a></code>, <code><a href="#topic+objectivematrices">objectivematrices</a></code>
</p>

<hr>
<h2 id='extractobjective'>Extracting empirical objective functions for item selection</h2><span id='topic+extractobjective'></span>

<h3>Description</h3>

<p>This is a bare-bones initial version of this approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractobjective(
  x,
  n = 50,
  side = c("top", "bottom", "center"),
  skew = FALSE,
  scale = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractobjective_+3A_x">x</code></td>
<td>
<p>A vector of values for which to determine the objective function (e.g. RMSEA).</p>
</td></tr>
<tr><td><code id="extractobjective_+3A_n">n</code></td>
<td>
<p>Number of values to use in function determining. Defaults to 50.</p>
</td></tr>
<tr><td><code id="extractobjective_+3A_side">side</code></td>
<td>
<p>Which side good values are located at. <code>'top'</code> means large values are good (e.g. Reliability), <code>'bottom'</code> means small values are good (e.g. RMSEA), and <code>'middle'</code> means average values are good (e.g. factor correlations).</p>
</td></tr>
<tr><td><code id="extractobjective_+3A_skew">skew</code></td>
<td>
<p>Whether to account for skew in the distribution using the [sn::psn()] function. Defaults to <code>FALSE</code>, meaning a normal distribution is used.</p>
</td></tr>
<tr><td><code id="extractobjective_+3A_scale">scale</code></td>
<td>
<p>A numeric scale to use in weighting the objective component. Defaults to 1.</p>
</td></tr>
<tr><td><code id="extractobjective_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>stuartEmpiricalObjective</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empiricalobjective">empiricalobjective</a></code>, <code><a href="#topic+fixedobjective">fixedobjective</a></code>, <code><a href="#topic+objectivematrices">objectivematrices</a></code>
</p>

<hr>
<h2 id='fairplayer'>MTMM fairplayer Intervention Data (2009)</h2><span id='topic+fairplayer'></span>

<h3>Description</h3>

<p>Self- and teacher-reported empathy (8 item scale), relational aggression (5 item scale), and social intelligence (10 item scale) at three different occasions.
</p>


<h3>Format</h3>

<p>A data frame with 143 observations on 142 variables. The variable names consist of an initial letter indicating the source (s: self-report, t: teacher-report), two letters indicating the construct (EM: empathy, RA: relational aggression, SI: social intelligence), a number indicating the item number on the scale, and a &quot;t&quot; followed by a number indicating the measurement occasion.
</p>


<h3>Source</h3>

<p>Bull, H., Schultze, M., Scheithauer, H. (2009) School-based prevention of bullying and relational aggression: The fairplayer.manual. European Journal of Developmental Science, 3:313-317.
</p>
<p>Schultze, M. (2012). Evaluating What The Crowd Says. A longitudinal structural equation model for exchangeable and structurally different methods for evaluating interventions. Unpublished Diploma Thesis.
</p>

<hr>
<h2 id='fixedobjective'>Generate a fixed objective function for item selection.</h2><span id='topic+fixedobjective'></span>

<h3>Description</h3>

<p>Generate an objective function from default values for use in an item selection using STUART.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixedobjective(
  criteria = c("rmsea", "srmr", "crel"),
  add = c("chisq", "df", "pvalue"),
  side = NULL,
  scale = 1,
  matrices = NULL,
  fixed = NULL,
  comparisons = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixedobjective_+3A_criteria">criteria</code></td>
<td>
<p>A vector of names of criteria included in the objective function. Defaults to <code>c('rmsea', 'srmr', 'crel')</code>.</p>
</td></tr>
<tr><td><code id="fixedobjective_+3A_add">add</code></td>
<td>
<p>A vector of names of criteria not used in the objective function, but added in order to be included in the log of solutions.</p>
</td></tr>
<tr><td><code id="fixedobjective_+3A_side">side</code></td>
<td>
<p>Which side good values are located at. <code>'top'</code> means large values are good (e.g. Reliability), <code>'bottom'</code> means small values are good (e.g. RMSEA), and <code>'middle'</code> means average values are good (e.g. factor correlations).</p>
</td></tr>
<tr><td><code id="fixedobjective_+3A_scale">scale</code></td>
<td>
<p>A numeric scale to use in weighting the objective component. Defaults to 1.</p>
</td></tr>
<tr><td><code id="fixedobjective_+3A_matrices">matrices</code></td>
<td>
<p>An object of class <code>stuartObjectiveMatrices</code> to include matrices (e.g. latent correlations) into the objective function.</p>
</td></tr>
<tr><td><code id="fixedobjective_+3A_fixed">fixed</code></td>
<td>
<p>An object of class <code>stuartFixedObjective</code> to include already previously defined fixed objectives.</p>
</td></tr>
<tr><td><code id="fixedobjective_+3A_comparisons">comparisons</code></td>
<td>
<p>A vector of names of criteria included in the objective function which are related to model comparisons (e.g. when determining measurement invariance).</p>
</td></tr>
<tr><td><code id="fixedobjective_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>stuartFixedObjective</code>
</p>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empiricalobjective">empiricalobjective</a></code>, <code><a href="#topic+extractobjective">extractobjective</a></code>, <code><a href="#topic+objectivematrices">objectivematrices</a></code>
</p>

<hr>
<h2 id='gene'>Subtest construction using a simple genetic algorithm</h2><span id='topic+gene'></span>

<h3>Description</h3>

<p>Construct subtests from a given pool of items using a simple genetic algorithm. Allows for multiple constructs, occasions, and groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gene(
  data,
  factor.structure,
  capacity = NULL,
  item.weights = NULL,
  item.invariance = "congeneric",
  repeated.measures = NULL,
  long.invariance = "strict",
  mtmm = NULL,
  mtmm.invariance = "configural",
  grouping = NULL,
  group.invariance = "strict",
  comparisons = NULL,
  auxiliary = NULL,
  use.order = FALSE,
  software = "lavaan",
  cores = NULL,
  objective = NULL,
  ignore.errors = FALSE,
  burnin = 5,
  generations = 256,
  individuals = 64,
  selection = "tournament",
  selection.pressure = NULL,
  elitism = NULL,
  reproduction = 0.5,
  mutation = 0.05,
  mating.index = 0,
  mating.size = 0.25,
  mating.criterion = "similarity",
  immigration = 0,
  convergence.criterion = "geno.between",
  tolerance = NULL,
  reinit.n = 1,
  reinit.criterion = convergence.criterion,
  reinit.tolerance = NULL,
  reinit.prop = 0.75,
  schedule = "run",
  analysis.options = NULL,
  suppress.model = FALSE,
  seed = NULL,
  filename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gene_+3A_data">data</code></td>
<td>
<p>A data.frame containing all relevant data.</p>
</td></tr>
<tr><td><code id="gene_+3A_factor.structure">factor.structure</code></td>
<td>
<p>A list linking factors to items. The names of the list elements correspond to the factor names. Each list element must contain a character-vector of item names that are indicators of this factor.</p>
</td></tr>
<tr><td><code id="gene_+3A_capacity">capacity</code></td>
<td>
<p>A list containing the number of items per subtest. This must be in the same order as the <code>factor.structure</code> provided. If a single number, it is applied to all subtests. If <code>NULL</code> all items are evenly distributed among the subtests.</p>
</td></tr>
<tr><td><code id="gene_+3A_item.weights">item.weights</code></td>
<td>
<p>A placeholder. Currently all weights are assumed to be one.</p>
</td></tr>
<tr><td><code id="gene_+3A_item.invariance">item.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>factor.structure</code> containing the desired invariance levels between items pertaining to the same subtest. Currently there are five options: 'congeneric', 'ess.equivalent', 'ess.parallel', 'equivalent', and 'parallel', the first being the default.</p>
</td></tr>
<tr><td><code id="gene_+3A_repeated.measures">repeated.measures</code></td>
<td>
<p>A list linking factors that are repeated measures of each other. Repeated factors must be in one element of the list - other sets of factors in other elements of the list. When this is <code>NULL</code> (the default) a cross-sectional model is estimated.</p>
</td></tr>
<tr><td><code id="gene_+3A_long.invariance">long.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>repeated.measures</code> containing the longitudinal invariance level of repeated items. Currently there are four options: 'configural', 'weak', 'strong', and 'strict'. Defaults to 'strict'. When <code>repeated.measures=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="gene_+3A_mtmm">mtmm</code></td>
<td>
<p>A list linking factors that are measurements of the same construct with different methods. Measurements of the same construct must be in one element of the list - other sets of methods in other elements of the list. When this is <code>NULL</code> (the default) a single method model is estimated.</p>
</td></tr>
<tr><td><code id="gene_+3A_mtmm.invariance">mtmm.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>mtmm</code> containing the invariance level of MTMM items. Currently there are five options: 'none', 'configural', 'weak', 'strong', and 'strict'. Defaults to 'configural'. With 'none' differing items are allowed for different methods. When <code>mtmm=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="gene_+3A_grouping">grouping</code></td>
<td>
<p>The name of the grouping variable. The grouping variable must be part of <code>data</code> provided and must be a numeric variable.</p>
</td></tr>
<tr><td><code id="gene_+3A_group.invariance">group.invariance</code></td>
<td>
<p>A single value describing the assumed invariance of items across groups. Currently there are four options: 'configural', 'weak', 'strong', and 'strict'. Defaults to 'strict'. When <code>grouping=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="gene_+3A_comparisons">comparisons</code></td>
<td>
<p>A character vector containing any combination of 'item', 'long', 'mtmm', and 'group' indicating which invariance should be assessed via model comparisons. The order of the vector dictates the sequence in which model comparisons are performed. Defaults to <code>NULL</code> meaning that no model comparisons are performed.</p>
</td></tr>
<tr><td><code id="gene_+3A_auxiliary">auxiliary</code></td>
<td>
<p>The names of auxiliary variables in <code>data</code>. These can be used in additional modeling steps that may be provided in <code>analysis.options$model</code>.</p>
</td></tr>
<tr><td><code id="gene_+3A_use.order">use.order</code></td>
<td>
<p>A logical indicating whether or not to take the selection order of the items into account. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gene_+3A_software">software</code></td>
<td>
<p>The name of the estimation software. Can currently be 'lavaan' (the default) or 'Mplus'. Each option requires the software to be installed.</p>
</td></tr>
<tr><td><code id="gene_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used in parallel processing. If <code>NULL</code> (the default) the result of <code><a href="parallel.html#topic+detectCores">detectCores</a></code> will be used. On Unix-y machines parallel processing is implemented via <code><a href="parallel.html#topic+mclapply">mclapply</a></code>, on Windows machines it is realized via <code><a href="parallel.html#topic+parLapply">parLapply</a></code>.</p>
</td></tr>
<tr><td><code id="gene_+3A_objective">objective</code></td>
<td>
<p>A function that converts the results of model estimation into a pheromone. See 'details' for... details.</p>
</td></tr>
<tr><td><code id="gene_+3A_ignore.errors">ignore.errors</code></td>
<td>
<p>A logical indicating whether or not to ignore estimation problems (such as non positive-definite latent covariance matrices). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gene_+3A_burnin">burnin</code></td>
<td>
<p>Number of generations for which to use fixed objective function before switching to empirical objective. Ignored if <code>objective</code> is not of class <code>stuartEmpiricalObjetive</code>. Defaults to 5.</p>
</td></tr>
<tr><td><code id="gene_+3A_generations">generations</code></td>
<td>
<p>Maximum number of generations to run. Defaults to 256.</p>
</td></tr>
<tr><td><code id="gene_+3A_individuals">individuals</code></td>
<td>
<p>The number of individuals per generation. Defaults to 64.</p>
</td></tr>
<tr><td><code id="gene_+3A_selection">selection</code></td>
<td>
<p>The method used for selecting possible parents. Can be either <code>'proportional'</code> for fitness proportional random selection or <code>'tournament'</code> (the default) for a semi-deterministic selection.</p>
</td></tr>
<tr><td><code id="gene_+3A_selection.pressure">selection.pressure</code></td>
<td>
<p>The pressure exerted during the selection process, depending on the <code>selection</code>: if <code>selection = 'proportional'</code> the non-linearity coefficient of the pheromone when determining selection probability (the default is 1); if <code>selection = 'proportional'</code> the number of randomly selected individuals from which to choose the best (the default is 5).</p>
</td></tr>
<tr><td><code id="gene_+3A_elitism">elitism</code></td>
<td>
<p>The proportion of individuals from the last generation to carry over to the next generation. Defaults to 1/individuals, meaning that the best individual is retained into the next generation.</p>
</td></tr>
<tr><td><code id="gene_+3A_reproduction">reproduction</code></td>
<td>
<p>The proportion of individuals that are allowed to sire offspring. These individuals are selected using fitness proportionate selection. Defaults to .5.</p>
</td></tr>
<tr><td><code id="gene_+3A_mutation">mutation</code></td>
<td>
<p>The mutation probability. Defaults to .05. See 'details'.</p>
</td></tr>
<tr><td><code id="gene_+3A_mating.index">mating.index</code></td>
<td>
<p>The relative rank of the selected mate within the mating pool. A number bewteen 0 (the default) and 1. The meaning depends on the setting of <code>mating.criterion</code>. See 'details'.</p>
</td></tr>
<tr><td><code id="gene_+3A_mating.size">mating.size</code></td>
<td>
<p>The proportion of potential mates sampled from the pool of reproducers for each selected individual. Defaults to .25. See 'details'.</p>
</td></tr>
<tr><td><code id="gene_+3A_mating.criterion">mating.criterion</code></td>
<td>
<p>The criterion by which to select mates. Can be either 'similarity' (the default) or 'fitness'. See 'details'.</p>
</td></tr>
<tr><td><code id="gene_+3A_immigration">immigration</code></td>
<td>
<p>The proportion of individuals per generation that are randomly generated immigrants. Defaults to 0.</p>
</td></tr>
<tr><td><code id="gene_+3A_convergence.criterion">convergence.criterion</code></td>
<td>
<p>The criterion by which convergence is determined. Can be one of four criteria <code>'variance'</code>, <code>'median'</code>, <code>'geno.within'</code>, and <code>'geno.between'</code> (the default). See 'details'.</p>
</td></tr>
<tr><td><code id="gene_+3A_tolerance">tolerance</code></td>
<td>
<p>The tolerance for determining convergence. The default depends on the setting used for <code>convergence.criterion</code>. See 'details'.</p>
</td></tr>
<tr><td><code id="gene_+3A_reinit.n">reinit.n</code></td>
<td>
<p>The maximum number of reinitilizations to be performed. Defaults to 1. See 'details'.</p>
</td></tr>
<tr><td><code id="gene_+3A_reinit.criterion">reinit.criterion</code></td>
<td>
<p>The convergence criterion used to determine whether the population should be reinitialized. Can be one of four criteria <code>'variance'</code>, <code>'median'</code>, <code>'geno.within'</code>, and <code>'geno.between'</code>. Per default, the same criterion provided to <code>convergence.criterion</code> is used. See 'details'.</p>
</td></tr>
<tr><td><code id="gene_+3A_reinit.tolerance">reinit.tolerance</code></td>
<td>
<p>The tolerance for determining the necessity of reinitialization. The default depends on the setting used for <code>convergence.criterion</code>. See 'details'.</p>
</td></tr>
<tr><td><code id="gene_+3A_reinit.prop">reinit.prop</code></td>
<td>
<p>The proportion of the population to be discarded and replaced by random individuals when reinitializing. Defaults to .75. See 'details'.</p>
</td></tr>
<tr><td><code id="gene_+3A_schedule">schedule</code></td>
<td>
<p>The counter which the scheduling of parameters pertains to. Can be either 'run' (the default), for a continuous schedule, 'generation', for a schedule that is restarted every time the population is reinitialized.</p>
</td></tr>
<tr><td><code id="gene_+3A_analysis.options">analysis.options</code></td>
<td>
<p>A list additional arguments to be passed to the estimation software. The names of list elements must correspond to the arguments changed in the respective estimation software. E.g. <code>analysis.options$model</code> can contain additional modeling commands - such as regressions on auxiliary variables.</p>
</td></tr>
<tr><td><code id="gene_+3A_suppress.model">suppress.model</code></td>
<td>
<p>A logical indicating whether to suppress the default model generation. If <code>TRUE</code> a model must be provided in <code>analysis.options$model</code>.</p>
</td></tr>
<tr><td><code id="gene_+3A_seed">seed</code></td>
<td>
<p>A random seed for the generation of random samples. See <code><a href="base.html#topic+Random">Random</a></code> for more details.</p>
</td></tr>
<tr><td><code id="gene_+3A_filename">filename</code></td>
<td>
<p>The stem of the filenames used to save inputs, outputs, and data files when <code>software='Mplus'</code>. This may include the file path. When <code>NULL</code> (the default) files will be saved to the temporary directory, which is deleted when the R session is ended.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pheromone function provided via <code>objective</code> is used to assess the quality of the solutions. These functions can contain any combination of the fit indices provided by the estimation software. When using Mplus these fit indices are 'rmsea', 'srmr', 'cfi', 'tli', 'chisq' (with 'df' and 'pvalue'), 'aic', 'bic', and 'abic'. With lavaan any fit index provided by <code><a href="lavaan.html#topic+inspect">inspect</a></code> can be used. Additionally 'crel' provides an aggregate of composite reliabilites, 'rel' provides a vector or a list of reliability coefficients for the latent variables, 'con' provides an aggregate consistency estimate for MTMM analyses, and 'lvcor' provides a list of the latent variable correlation matrices. For more detailed objective functions 'lambda', 'theta', 'psi', and 'alpha' provide the model-implied matrices. Per default a pheromone function using 'crel', 'rmsea', and 'srmr' is used. Please be aware that the <code>objective</code> must be a function with the required fit indices as (correctly named) arguments.
</p>
<p>Using model comparisons via the <code>comparisons</code> argument compares the target model to a model with one less degree of assumed invariance (e.g. if your target model contains strong invariance, the comparison model contain weak invariance). Adding comparisons will change the preset for the objective function to include model differences. With comparisons, a custom objective function (the recommended approach) can also include all model fit indices with a preceding <code>delta.</code> to indicate the difference in this index between the two models. If more than one type of comparison is used, the argument of the objective function should end in the type of comparison requested (e.g. <code>delta.cfi.group</code> to use the difference in CFI between the model comparison of invariance across groups).
</p>
<p>The genetic algorithm implemented selects parents in a two-step procedure. First, either a tournament or a fitness proportionate selection is performed to select <code>inviduals</code> times <code>reproduction</code> viable parents. Then, the non-self-adaptive version of mating proposed by Galán, Mengshoel, and Pinter (2013) is used to perform mating. In contrast to the original article, the <code>mating.index</code> and <code>mating.size</code> are handled as proportions, not integers. Similarity-based mating is based on the Jaccard Similarity. Mutation is currently always handled as an exchange of the selection state between two items. This results in mutation selecting one item that was not selected prior to mutation and dropping one item selected prior to mutation. 
</p>
<p>Per default (<code>convergence.criterion = 'geno.between'</code>), convergence is checked by tracking the changes between selection probabilities over three subsequent generations. If the difference between these selections probabilities falls below <code>tolerance</code> (.01 by default) in three consecutive generations, the algorithm is deemed to have converged. To avoid false convergence in the early search, the lower of either 10% of the generations or 10 generations must be completed, before convergence is checked. When using reinitialization the default for <code>reinit.tolerance</code> is .05 to initiate a full reinitialization of the population.  An alternative convergence criterion is the variance of the global-best values on the objective function, as proposed by Bhandari, Murthy, and Pal (2012). For generalizability over different functions provided to <code>objective</code>, variances are scaled to the first global-best found. In this case the setting for <code>tolerance</code> pertains to the pure variance estimate and defaults to .0005 (or .005 when regarding the reinitialization process discussed below). Alternatively, the setting <code>'median'</code> checks for the relative difference between the objective function value of the generation-best and the median value of a generation (scaled by the former). Here, the default is .05 (or .10 when regarding the reinitialization process). The setting <code>'geno.within'</code> checks for the variability of genotypes in a generation, by determining the relative frequency, with which each item is selected. Convergence is reached if this relative frequency is either <code>tolerance</code> (.8, by default - or .7 for the reinitialization process) or 1 - <code>tolerance</code> for all items within a generation. 
</p>
<p>A reinitialization procedure can be used to avoid premature convergence. The behavior is controlled via the arguments starting in <code>reinit</code>. The argument <code>reinit.n</code> determines the maximum number of possible reinitializations. After each reinitialization, the generation counter is reset, allowing for the maximum number of generations before the search is aborted. The <code>reinit.criterion</code> and <code>reinit.tolerance</code> relate to convergence criteria outlined above. It is recommended to use a higher tolerance on reinitialization than on final convergence to avoid long periods of stagnant search. The <code>reinit.prop</code> determines the proportion of the population to be replaced by random individuals when reinitializing. Note that even when <code>reinit.prop = 1</code>, the number of individuals kept due to <code>elitism</code> is not discarded.
</p>


<h3>Value</h3>

<p>Returns an object of the class <code>stuartOutput</code> for which specific <code>summary</code> and <code>plot</code> methods are available. The results are a list.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The called function.</p>
</td></tr>
<tr><td><code>software</code></td>
<td>
<p>The software used to fit the CFA models.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A list of the parameters used.</p>
</td></tr>
<tr><td><code>analysis.options</code></td>
<td>
<p>A list of the additional arguments passed to the estimation software.</p>
</td></tr>
<tr><td><code>timer</code></td>
<td>
<p>An object of the class <code>proc_time</code> which contains the time used for the analysis.</p>
</td></tr>
<tr><td><code>log</code></td>
<td>
<p>A <code>data.frame</code> containing the optimization history.</p>
</td></tr>
<tr><td><code>log_mat</code></td>
<td>
<p>A <code>list</code> of matrices (e.g. lvcor) relevant to the estimation history, if any.</p>
</td></tr>
<tr><td><code>solution</code></td>
<td>
<p>A list of matrices with the choices made in the global-best solution.</p>
</td></tr>
<tr><td><code>pheromones</code></td>
<td>
<p>A list of matrices with the relative selection frequency of items in the final generation.</p>
</td></tr>
<tr><td><code>subtests</code></td>
<td>
<p>A list containing the names of the selected items and their respective subtests.</p>
</td></tr>
<tr><td><code>final</code></td>
<td>
<p>The results of the estimation of the global-best solution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>References</h3>

<p>Bhandari, D., Murthy, C.A., &amp; Pal, S.K. (2012). Variance as a Stopping Criterion for Genetic Algorithms with Elitist Model. Fundamenta Informaticae, 120, 145-164. doi:10.3233/FI-2012-754
</p>
<p>Galán, S.F., Mengshoel, O.J., &amp; Pinter,  R. (2013). A novel mating approach for genetic algorithms. Evolutionary Computation, 21(2), 197-229. doi:10.1162/EVCO_a_00067
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bruteforce">bruteforce</a></code>, <code><a href="#topic+mmas">mmas</a></code>, <code><a href="#topic+randomsamples">randomsamples</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Genetic selection in a simple situation
# requires lavaan
# number of cores set to 1 in all examples
data(fairplayer)
fs &lt;- list(si = names(fairplayer)[83:92])

# minimal example
sel &lt;- gene(fairplayer, fs, 4, 
  generations = 1, individuals = 10,  # minimal runtime, remove for application
  seed = 55635, cores = 1)
summary(sel)


# longitudinal example
data(fairplayer)
fs &lt;- list(si1 = names(fairplayer)[83:92],
  si2 = names(fairplayer)[93:102],
  si3 = names(fairplayer)[103:112])

repe &lt;- list(si = c('si1', 'si2', 'si3'))

# run to convergence
# switching to best-last mating and 50\% mating size
sel &lt;- gene(fairplayer, fs, 4, 
  repeated.measures = repe, long.invariance = 'strong',
  mating.criterion = 'fitness', mating.index = 0, 
  mating.size = .5,
  seed = 55635, cores = 1)

# forcing a run through all generations
# by disabling the convergence rule
sel &lt;- gene(fairplayer, fs, 4,
  repeated.measures = repe, long.invariance = 'strong',
  tolerance = 0, seed = 55635,
  cores = 1)


</code></pre>

<hr>
<h2 id='heuristics'>Generating heuristics for the use in STUART subtest construction</h2><span id='topic+heuristics'></span>

<h3>Description</h3>

<p>Creates uninformative heuristic matrices for the use in <code><a href="#topic+mmas">mmas</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heuristics(
  data,
  factor.structure,
  capacity = NULL,
  repeated.measures = NULL,
  mtmm = NULL,
  grouping = NULL,
  localization = "nodes",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heuristics_+3A_data">data</code></td>
<td>
<p>A data.frame containing all relevant data.</p>
</td></tr>
<tr><td><code id="heuristics_+3A_factor.structure">factor.structure</code></td>
<td>
<p>A list linking factors to items. The names of the list elements correspond to the factor names. Each list element must contain a character-vector of item names that are indicators of this factor.</p>
</td></tr>
<tr><td><code id="heuristics_+3A_capacity">capacity</code></td>
<td>
<p>A list containing the number of items per subtest. This must be in the same order as the <code>factor.structure</code> provided. If a single number, it is applied to all subtests. If <code>NULL</code> all items are evenly distributed among the subtests.</p>
</td></tr>
<tr><td><code id="heuristics_+3A_repeated.measures">repeated.measures</code></td>
<td>
<p>A list linking factors that are repeated measures of each other. Repeated factors must be in one element of the list - other sets of factors in other elements of the list. When this is <code>NULL</code> (the default) a cross-sectional model is estimated.</p>
</td></tr>
<tr><td><code id="heuristics_+3A_mtmm">mtmm</code></td>
<td>
<p>A list linking factors that are measurements of the same construct with different methods. Measurements of the same construct must be in one element of the list - other sets of methods in other elements of the list. When this is <code>NULL</code> (the default) a single method model is estimated.</p>
</td></tr>
<tr><td><code id="heuristics_+3A_grouping">grouping</code></td>
<td>
<p>The name of the grouping variable. The grouping variable must be part of <code>data</code> provided and must be a numeric variable.</p>
</td></tr>
<tr><td><code id="heuristics_+3A_localization">localization</code></td>
<td>
<p>Which parameterization to use when depositing pheromones. Can be either 'nodes' (the default) for depositing pheromones on selected nodes or 'arcs' for depositing on selection arcs.</p>
</td></tr>
<tr><td><code id="heuristics_+3A_...">...</code></td>
<td>
<p>Other arguments normally provided to <code><a href="#topic+mmas">mmas</a></code>, which will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a list of matrices which can be used as heuristics for all STUART constructions. This is mainly intended to write the structure of the heuristic matrices to an object, change components in line with theoretically derived heuristics and feed them back into <code><a href="#topic+mmas">mmas</a></code> via the <code>heuristics</code> argument. The generated heuristics will contain only 1s and 0s, making it no heuristic information. Selection probabilities can be altered by manipulating the contents of the object created by <code>heuristics</code>. Setting a value to 0 will result in prohibiting a certain choice to be made. Please note, that it will lead to unpredictable behavior if the diagonal elements of the matrices produced in the arcs parameterization are set to values other than 0.
</p>


<h3>Value</h3>

<p>Returns a list of the same length as the <code>factor.structure</code> argument provided.
</p>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmas">mmas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# heuristics for node localization
data(fairplayer)
fs &lt;- list(si = names(fairplayer)[83:92])

(heu &lt;- heuristics(fairplayer, fs, 4))

# Define anchor-item
heu$si[1] &lt;- 10000
heu

# heuristics for arc localization
data(fairplayer)
fs &lt;- list(si = names(fairplayer)[83:92])

(heu &lt;- heuristics(fairplayer, fs, 4, localization = 'arcs'))

# Define equal selection of odd and even items
heu$si[1:10,] &lt;- c(rep(c(0, 1), 5), rep(c(1, 0), 5))
heu

</code></pre>

<hr>
<h2 id='holdout'>Data selection for holdout validation.</h2><span id='topic+holdout'></span>

<h3>Description</h3>

<p>Split a <code>data.frame</code> into two subsets for holdout validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>holdout(data, prop = 0.5, grouping = NULL, seed = NULL, determined = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="holdout_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="holdout_+3A_prop">prop</code></td>
<td>
<p>A single value or vector of proportions of data in calibration sample. Defaults to .5, for an even split.</p>
</td></tr>
<tr><td><code id="holdout_+3A_grouping">grouping</code></td>
<td>
<p>Name of the grouping variable. Providing a grouping variable ensures that the provided proportion is selected within each group.</p>
</td></tr>
<tr><td><code id="holdout_+3A_seed">seed</code></td>
<td>
<p>A random seed. See <code><a href="base.html#topic+Random">Random</a></code> for more details.</p>
</td></tr>
<tr><td><code id="holdout_+3A_determined">determined</code></td>
<td>
<p>Name of a variable indicating the pre-determined assignment to the calibration or the validation sample. This variable must be a factor containing only <code>NA</code> (no determined assingment), <code>"calibrate"</code>, or <code>"validate"</code>. If no variable is provided (the default) all cases are assigned randomly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing two <code>data.frame</code>s, called calibrate and validate. The first corresponds to the calibration sample, the second to the validation sample.
</p>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossvalidate">crossvalidate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# seeded selection, 25% validation sample
data(fairplayer)
split &lt;- holdout(fairplayer, .75, seed = 55635)
lapply(split, nrow) # check size of samples

</code></pre>

<hr>
<h2 id='kfold'>k-Folds Crossvalidation</h2><span id='topic+kfold'></span>

<h3>Description</h3>

<p>k-Folds crossvalidation for item selection using any approach implemented in STUART.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfold(
  type,
  k = 5,
  max.invariance = "strict",
  seed = NULL,
  seeded.search = TRUE,
  ...,
  remove.details = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfold_+3A_type">type</code></td>
<td>
<p>A <code>character</code> calling the item-selection procedure. Can be one of &quot;mmas&quot; (see <code><a href="#topic+mmas">mmas</a></code>), &quot;gene&quot; (see <code><a href="#topic+gene">gene</a></code>), &quot;bruteforce&quot; (see <code><a href="#topic+bruteforce">bruteforce</a></code>), or randomsamples (see <code><a href="#topic+randomsamples">randomsamples</a></code>).</p>
</td></tr>
<tr><td><code id="kfold_+3A_k">k</code></td>
<td>
<p>The number of folds.</p>
</td></tr>
<tr><td><code id="kfold_+3A_max.invariance">max.invariance</code></td>
<td>
<p>The maximum measurement invariance level which will be tested. Currently there are four options: 'configural', 'weak', 'strong', and 'strict' (the default). All levels below <code>max.invariance</code> are also tested.</p>
</td></tr>
<tr><td><code id="kfold_+3A_seed">seed</code></td>
<td>
<p>The random seed.</p>
</td></tr>
<tr><td><code id="kfold_+3A_seeded.search">seeded.search</code></td>
<td>
<p>A <code>logical</code> indicating whether the <code>seed</code> should also be used for the search procedure (the default) or only for the sample splitting.</p>
</td></tr>
<tr><td><code id="kfold_+3A_...">...</code></td>
<td>
<p>Arguments passed to the item-selection procedure called with <code>type</code>.</p>
</td></tr>
<tr><td><code id="kfold_+3A_remove.details">remove.details</code></td>
<td>
<p>A <code>logical</code> indicating whether to remove detailed information such as models and copies of datasets. Reduces output size by approx. 90%. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function splits the provided data into k subsets using <code><a href="#topic+holdout">holdout</a></code> and runs the item-selection procedure requested via <code>type</code> on the training datasets. Validation is performed using <code><a href="#topic+crossvalidate">crossvalidate</a></code> to check for invariance of the measurement models between the training and validation data up to the invariance level provided via <code>max.invariance</code>. The final item selection is based on the highest value on the objective function in the multiple-group SEM imposing <code>max.invariance</code> between the training and validation data.
</p>


<h3>Value</h3>

<p>Returns an object of the class <code>stuartKfold</code> for which specific <code>summary</code> and <code>print</code> methods are available. The results are a list.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The called function.</p>
</td></tr>
<tr><td><code>subtests</code></td>
<td>
<p>A list containing the names of the selected items and their respective subtests.</p>
</td></tr>
<tr><td><code>solution</code></td>
<td>
<p>A list of matrices with the choices made in the global-best solution.</p>
</td></tr>
<tr><td><code>final</code></td>
<td>
<p>The results of the estimation of the solution leading to best objective value when cross-validated.</p>
</td></tr>
<tr><td><code>frequencies</code></td>
<td>
<p>A list of matrices showing the relative frequencies with which an item was selected across the k-folds.</p>
</td></tr>
<tr><td><code>full</code></td>
<td>
<p>A list of the results returned by the k runs of <code>type</code>.</p>
</td></tr>
<tr><td><code>crossvalidations</code></td>
<td>
<p>A list of data.frames showing the fit and model comparisons of all invariance levels up to <code>max.invariance</code> in each of the k folds.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A <code>data.frame</code>. The same as the original <code>data.frame</code> provided to <code>data</code> with the added variable <code>stuartKfold</code> indicating which fold an observation was assigned to.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+holdout">holdout</a></code> <code><a href="#topic+crossvalidate">crossvalidate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# k-Folding for a simple bruteforce selection
data(fairplayer)
fs &lt;- list(ra = names(fairplayer)[53:57])

sel &lt;- kfold('bruteforce', k = 2,
  data = fairplayer, factor.structure = fs, 
  capacity = 3, seed = 55635,
  cores = 1)
summary(sel)


### longitudinal example with mmas ----
data(fairplayer)
fs &lt;- list(si1 = names(fairplayer)[83:92],
  si2 = names(fairplayer)[93:102],
  si3 = names(fairplayer)[103:112])

repe &lt;- list(si = c('si1', 'si2', 'si3'))

sel_mmas &lt;- kfold('mmas', k = 3,
  data = fairplayer, factor.structure = fs,
  repeated.measures = repe, long.invariance = 'strong',
  capacity = 3, seed = 55635, pbest = .5,
  cores = 1)
summary(sel_mmas)



</code></pre>

<hr>
<h2 id='mmas'>Subtest construction using the Max-Min-Ant-System</h2><span id='topic+mmas'></span>

<h3>Description</h3>

<p>Construct subtests from a given pool of items using the classical Max-Min Ant-System (Stützle, 1998). Allows for multiple constructs, occasions, and groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmas(
  data,
  factor.structure,
  capacity = NULL,
  item.weights = NULL,
  item.invariance = "congeneric",
  repeated.measures = NULL,
  long.invariance = "strict",
  mtmm = NULL,
  mtmm.invariance = "configural",
  grouping = NULL,
  group.invariance = "strict",
  comparisons = NULL,
  auxiliary = NULL,
  use.order = FALSE,
  software = "lavaan",
  cores = NULL,
  objective = NULL,
  ignore.errors = FALSE,
  burnin = 5,
  ants = 16,
  colonies = 256,
  evaporation = 0.95,
  alpha = 1,
  beta = 1,
  pheromones = NULL,
  heuristics = NULL,
  deposit = "ib",
  localization = "nodes",
  pbest = 0.005,
  tolerance = 0.5,
  schedule = "run",
  analysis.options = NULL,
  suppress.model = FALSE,
  seed = NULL,
  filename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmas_+3A_data">data</code></td>
<td>
<p>A data.frame containing all relevant data.</p>
</td></tr>
<tr><td><code id="mmas_+3A_factor.structure">factor.structure</code></td>
<td>
<p>A list linking factors to items. The names of the list elements correspond to the factor names. Each list element must contain a character-vector of item names that are indicators of this factor.</p>
</td></tr>
<tr><td><code id="mmas_+3A_capacity">capacity</code></td>
<td>
<p>A list containing the number of items per subtest. This must be in the same order as the <code>factor.structure</code> provided. If a single number, it is applied to all subtests. If <code>NULL</code> all items are evenly distributed among the subtests.</p>
</td></tr>
<tr><td><code id="mmas_+3A_item.weights">item.weights</code></td>
<td>
<p>A placeholder. Currently all weights are assumed to be one.</p>
</td></tr>
<tr><td><code id="mmas_+3A_item.invariance">item.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>factor.structure</code> containing the desired invariance levels between items pertaining to the same subtest. Currently there are five options: 'congeneric', 'ess.equivalent', 'ess.parallel', 'equivalent', and 'parallel', the first being the default.</p>
</td></tr>
<tr><td><code id="mmas_+3A_repeated.measures">repeated.measures</code></td>
<td>
<p>A list linking factors that are repeated measures of each other. Repeated factors must be in one element of the list - other sets of factors in other elements of the list. When this is <code>NULL</code> (the default) a cross-sectional model is estimated.</p>
</td></tr>
<tr><td><code id="mmas_+3A_long.invariance">long.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>repeated.measures</code> containing the longitudinal invariance level of repeated items. Currently there are four options: 'configural', 'weak', 'strong', and 'strict'. Defaults to 'strict'. When <code>repeated.measures=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="mmas_+3A_mtmm">mtmm</code></td>
<td>
<p>A list linking factors that are measurements of the same construct with different methods. Measurements of the same construct must be in one element of the list - other sets of methods in other elements of the list. When this is <code>NULL</code> (the default) a single method model is estimated.</p>
</td></tr>
<tr><td><code id="mmas_+3A_mtmm.invariance">mtmm.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>mtmm</code> containing the invariance level of MTMM items. Currently there are five options: 'none', 'configural', 'weak', 'strong', and 'strict'. Defaults to 'configural'. With 'none' differing items are allowed for different methods. When <code>mtmm=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="mmas_+3A_grouping">grouping</code></td>
<td>
<p>The name of the grouping variable. The grouping variable must be part of <code>data</code> provided and must be a numeric variable.</p>
</td></tr>
<tr><td><code id="mmas_+3A_group.invariance">group.invariance</code></td>
<td>
<p>A single value describing the assumed invariance of items across groups. Currently there are four options: 'configural', 'weak', 'strong', and 'strict'. Defaults to 'strict'. When <code>grouping=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="mmas_+3A_comparisons">comparisons</code></td>
<td>
<p>A character vector containing any combination of 'item', 'long', 'mtmm', and 'group' indicating which invariance should be assessed via model comparisons. The order of the vector dictates the sequence in which model comparisons are performed. Defaults to <code>NULL</code> meaning that no model comparisons are performed.</p>
</td></tr>
<tr><td><code id="mmas_+3A_auxiliary">auxiliary</code></td>
<td>
<p>The names of auxiliary variables in <code>data</code>. These can be used in additional modeling steps that may be provided in <code>analysis.options$model</code>.</p>
</td></tr>
<tr><td><code id="mmas_+3A_use.order">use.order</code></td>
<td>
<p>A logical indicating whether or not to take the selection order of the items into account. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mmas_+3A_software">software</code></td>
<td>
<p>The name of the estimation software. Can currently be 'lavaan' (the default) or 'Mplus'. Each option requires the software to be installed.</p>
</td></tr>
<tr><td><code id="mmas_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used in parallel processing. If <code>NULL</code> (the default) the result of <code><a href="parallel.html#topic+detectCores">detectCores</a></code> will be used. On Unix-y machines parallel processing is implemented via <code><a href="parallel.html#topic+mclapply">mclapply</a></code>, on Windows machines it is realized via <code><a href="parallel.html#topic+parLapply">parLapply</a></code>.</p>
</td></tr>
<tr><td><code id="mmas_+3A_objective">objective</code></td>
<td>
<p>A function that converts the results of model estimation into a pheromone. See 'details' for... details.</p>
</td></tr>
<tr><td><code id="mmas_+3A_ignore.errors">ignore.errors</code></td>
<td>
<p>A logical indicating whether or not to ignore estimation problems (such as non positive-definite latent covariance matrices). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mmas_+3A_burnin">burnin</code></td>
<td>
<p>Number of colonies for which to use fixed objective function before switching to empirical objective. Ignored if <code>objective</code> is not of class <code>stuartEmpiricalObjetive</code>. Defaults to 5.</p>
</td></tr>
<tr><td><code id="mmas_+3A_ants">ants</code></td>
<td>
<p>The number of ants per colony to be estimated. Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td></tr>
<tr><td><code id="mmas_+3A_colonies">colonies</code></td>
<td>
<p>The maximum number of colonies estimated since finding the latest global-best solution before aborting the process. Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td></tr>
<tr><td><code id="mmas_+3A_evaporation">evaporation</code></td>
<td>
<p>The evaporation coefficient. Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td></tr>
<tr><td><code id="mmas_+3A_alpha">alpha</code></td>
<td>
<p>The nonlinearity coefficient of the pheromone-trail's contribution to determining selection probabilities. Defaults to 1 (linear). Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td></tr>
<tr><td><code id="mmas_+3A_beta">beta</code></td>
<td>
<p>The nonlinearity coefficient of the heuristics' contribution to determining selection probabilities. Defaults to 1 (linear). Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td></tr>
<tr><td><code id="mmas_+3A_pheromones">pheromones</code></td>
<td>
<p>A list of pheromones as created by <code><a href="#topic+mmas">mmas</a></code>. This can be used to continue previous runs of this function.</p>
</td></tr>
<tr><td><code id="mmas_+3A_heuristics">heuristics</code></td>
<td>
<p>An object of the class <code>stuartHeuristic</code> as provided by <code><a href="#topic+heuristics">heuristics</a></code> which contains heuristic information to be used in determining selection probabilities. If <code>NULL</code> (the default) selection probabilities are determined solely by the pheromones.</p>
</td></tr>
<tr><td><code id="mmas_+3A_deposit">deposit</code></td>
<td>
<p>Which deposit rule to use. Can be either 'ib' (the default) for an iteration-best deposit rule, or 'gb' for a global-best deposit rule.</p>
</td></tr>
<tr><td><code id="mmas_+3A_localization">localization</code></td>
<td>
<p>Which localization to use when depositing pheromones. Can be either 'nodes' (the default) for depositing pheromones on selected nodes or 'arcs' for depositing on selection arcs.</p>
</td></tr>
<tr><td><code id="mmas_+3A_pbest">pbest</code></td>
<td>
<p>The desired overall probability of constructing the global-best solution when the algorithm convergels.  Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td></tr>
<tr><td><code id="mmas_+3A_tolerance">tolerance</code></td>
<td>
<p>The tolerance of imprecision when comparing the pheromones to the upper and lower limits. Can either be a single value or an array with two columns for parameter scheduling. See 'details'.</p>
</td></tr>
<tr><td><code id="mmas_+3A_schedule">schedule</code></td>
<td>
<p>The counter which the scheduling of parameters pertains to. Can be either 'run' (the default), for a continuous schedule, 'colony', for a schedule that is restarted every time a new global best is found, or 'mixed' for a schedule that restarts its current phase every time a new global best is found. See 'details'.</p>
</td></tr>
<tr><td><code id="mmas_+3A_analysis.options">analysis.options</code></td>
<td>
<p>A list additional arguments to be passed to the estimation software. The names of list elements must correspond to the arguments changed in the respective estimation software. E.g. <code>analysis.options$model</code> can contain additional modeling commands - such as regressions on auxiliary variables.</p>
</td></tr>
<tr><td><code id="mmas_+3A_suppress.model">suppress.model</code></td>
<td>
<p>A logical indicating whether to suppress the default model generation. If <code>TRUE</code> a model must be provided in <code>analysis.options$model</code>.</p>
</td></tr>
<tr><td><code id="mmas_+3A_seed">seed</code></td>
<td>
<p>A random seed for the generation of random samples. See <code><a href="base.html#topic+Random">Random</a></code> for more details.</p>
</td></tr>
<tr><td><code id="mmas_+3A_filename">filename</code></td>
<td>
<p>The stem of the filenames used to save inputs, outputs, and data files when <code>software='Mplus'</code>. This may include the file path. When <code>NULL</code> (the default) files will be saved to the temporary directory, which is deleted when the R session is ended.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pheromone function provided via <code>objective</code> is used to assess the quality of the solutions. These functions can contain any combination of the fit indices provided by the estimation software. When using Mplus these fit indices are 'rmsea', 'srmr', 'cfi', 'tli', 'chisq' (with 'df' and 'pvalue'), 'aic', 'bic', and 'abic'. With lavaan any fit index provided by <code><a href="lavaan.html#topic+inspect">inspect</a></code> can be used. Additionally 'crel' provides an aggregate of composite reliabilites, 'rel' provides a vector or a list of reliability coefficients for the latent variables, 'con' provides an aggregate consistency estimate for MTMM analyses, and 'lvcor' provides a list of the latent variable correlation matrices. For more detailed objective functions 'lambda', 'theta', 'psi', 'alpha', and 'nu' provide the model-implied matrices. Per default a pheromone function using 'crel', 'rmsea', and 'srmr' is used. Please be aware that the <code>objective</code> must be a function with the required fit indices as (correctly named) arguments.
</p>
<p>Using model comparisons via the <code>comparisons</code> argument compares the target model to a model with one less degree of assumed invariance (e.g. if your target model contains strong invariance, the comparison model contain weak invariance). Adding comparisons will change the preset for the objective function to include model differences. With comparisons, a custom objective function (the recommended approach) can also include all model fit indices with a preceding <code>delta.</code> to indicate the difference in this index between the two models. If more than one type of comparison is used, the argument of the objective function should end in the type of comparison requested (e.g. <code>delta.cfi.group</code> to use the difference in CFI between the model comparison of invariance across groups).
</p>
<p>The scheduling of parameters is possible for the arguments <code>ants</code>, <code>colonies</code>, <code>evaporation</code>, <code>pbest</code>, <code>alpha</code>, <code>beta</code>, <code>tolerance</code>, and <code>deposit</code>. For all of these parameter scheduling is done when an array with two columns is provided. The first column of the array contains the timer, i.e. when to switch between parameter settings, the second column contains the values. The argument <code>schedule</code> can be used to select an absolute schedule (<code>schedule='run'</code>), a relative schedule which resets completely after a new global best is found (<code>schedule='colony'</code>), or a mixed version which resets the current phase of the schedule after a new global best is found (<code>schedule='mixed'</code>). When providing a parameter schedule for iterations 0, 3, and 10 using 'run' will result in a change after the third and the tenth iteration - irrespective of whether global best solutions were found. In contrast, using 'colony' will result in the first setting being used again once a new global best is found. This setting will then be used until iteration 3 (if no new best solution is found) before a switch occurs. If a new global best is found the setting will begin the sequence from the beginning. Using 'mixed' will result in the first setting being used until three consecutive iterations cannot produce a new global best. After this the second setting is used. If a new global best is found, the second setting is kept, but for the purpose of the schedule it is now iteration 3 again, meaning that the third setting will be used later than in a 'run' schedule.
</p>


<h3>Value</h3>

<p>Returns an object of the class <code>stuartOutput</code> for which specific <code>summary</code> and <code>plot</code> methods are available. The results are a list.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The called function.</p>
</td></tr>
<tr><td><code>software</code></td>
<td>
<p>The software used to fit the CFA models.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A list of the ACO parameters used.</p>
</td></tr>
<tr><td><code>analysis.options</code></td>
<td>
<p>A list of the additional arguments passed to the estimation software.</p>
</td></tr>
<tr><td><code>timer</code></td>
<td>
<p>An object of the class <code>proc_time</code> which contains the time used for the analysis.</p>
</td></tr>
<tr><td><code>log</code></td>
<td>
<p>A <code>data.frame</code> containing the optimization history.</p>
</td></tr>
<tr><td><code>log_mat</code></td>
<td>
<p>A <code>list</code> of matrices (e.g. lvcor) relevant to the estimation history, if any.</p>
</td></tr>
<tr><td><code>solution</code></td>
<td>
<p>A list of matrices with the choices made in the global-best solution.</p>
</td></tr>
<tr><td><code>pheromones</code></td>
<td>
<p>A list of matrices with the pheromones of each choice.</p>
</td></tr>
<tr><td><code>subtests</code></td>
<td>
<p>A list containing the names of the selected items and their respective subtests.</p>
</td></tr>
<tr><td><code>final</code></td>
<td>
<p>The results of the estimation of the global-best solution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>References</h3>

<p>Stützle, T. (1998). Local search algorithms for combinatorial problems: Analysis, improvements, and new applications. Unpublished doctoral dissertation. Darmstadt: Fachbereich Informatik, Universität Darmstadt.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bruteforce">bruteforce</a></code>, <code><a href="#topic+gene">gene</a></code>, <code><a href="#topic+randomsamples">randomsamples</a></code>, <code><a href="#topic+heuristics">heuristics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># MMAS in a simple situation
# requires lavaan
# number of cores set to 1 in all examples
data(fairplayer)
fs &lt;- list(si = names(fairplayer)[83:92])

# minimal example
sel &lt;- mmas(fairplayer, fs, 4, 
  colonies = 0, ants = 10,  # minimal runtime, remove for application
  seed = 55635, cores = 1)
summary(sel)


# longitudinal example
data(fairplayer)
fs &lt;- list(si1 = names(fairplayer)[83:92],
  si2 = names(fairplayer)[93:102],
  si3 = names(fairplayer)[103:112])

repe &lt;- list(si = c('si1', 'si2', 'si3'))

# change evaporation rate after 10 and 20 colonies
sel &lt;- mmas(fairplayer, fs, 4, 
  repeated.measures = repe, long.invariance = 'strong',
  evaporation = cbind(c(0, 10, 20), c(.95, .8, .5)),
  seed = 55635, cores = 1)


</code></pre>

<hr>
<h2 id='objectivematrices'>Generate matrix-components for objective functions.</h2><span id='topic+objectivematrices'></span>

<h3>Description</h3>

<p>Generate objects of the correct structure for use in custom objective functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectivematrices(
  data,
  factor.structure,
  capacity = NULL,
  matrices = c("lvcor"),
  n.random = 0,
  item.invariance = "congeneric",
  repeated.measures = NULL,
  long.invariance = "strict",
  mtmm = NULL,
  mtmm.invariance = "configural",
  grouping = NULL,
  group.invariance = "strict",
  comparisons = NULL,
  auxiliary = NULL,
  use.order = FALSE,
  software = "lavaan",
  cores = NULL,
  objective = NULL,
  ignore.errors = FALSE,
  analysis.options = NULL,
  suppress.model = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectivematrices_+3A_data">data</code></td>
<td>
<p>A data.frame containing all relevant data.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_factor.structure">factor.structure</code></td>
<td>
<p>A list linking factors to items. The names of the list elements correspond to the factor names. Each list element must contain a character-vector of item names that are indicators of this factor.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_capacity">capacity</code></td>
<td>
<p>A list containing the number of items per subtest. This must be in the same order as the <code>factor.structure</code> provided. If a single number, it is applied to all subtests. If <code>NULL</code> all items are evenly distributed among the subtests.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_matrices">matrices</code></td>
<td>
<p>Which matrix to extract. Can be one of <code>'lvcor'</code> (the default) for latent correlations, 'lambda', 'theta', 'psi', or 'alpha' for the model-implied matrices.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_n.random">n.random</code></td>
<td>
<p>The number of random draws to base values on. If 0 (the default) values are in the matrices are set to 0 and can be overwritten later. If any value larger than 0, the mean from <code>n.random</code> random solutions is used.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_item.invariance">item.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>factor.structure</code> containing the desired invariance levels between items pertaining to the same subtest. Currently there are five options: 'congeneric', 'ess.equivalent', 'ess.parallel', 'equivalent', and 'parallel', the first being the default.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_repeated.measures">repeated.measures</code></td>
<td>
<p>A list linking factors that are repeated measures of each other. Repeated factors must be in one element of the list - other sets of factors in other elements of the list. When this is <code>NULL</code> (the default) a cross-sectional model is estimated.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_long.invariance">long.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>repeated.measures</code> containing the longitudinal invariance level of repeated items. Currently there are four options: 'configural', 'weak', 'strong', and 'strict'. Defaults to 'strict'. When <code>repeated.measures=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_mtmm">mtmm</code></td>
<td>
<p>A list linking factors that are measurements of the same construct with different methods. Measurements of the same construct must be in one element of the list - other sets of methods in other elements of the list. When this is <code>NULL</code> (the default) a single method model is estimated.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_mtmm.invariance">mtmm.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>mtmm</code> containing the invariance level of MTMM items. Currently there are five options: 'none', 'configural', 'weak', 'strong', and 'strict'. Defaults to 'configural'. With 'none' differing items are allowed for different methods. When <code>mtmm=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_grouping">grouping</code></td>
<td>
<p>The name of the grouping variable. The grouping variable must be part of <code>data</code> provided and must be a numeric variable.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_group.invariance">group.invariance</code></td>
<td>
<p>A single value describing the assumed invariance of items across groups. Currently there are four options: 'configural', 'weak', 'strong', and 'strict'. Defaults to 'strict'. When <code>grouping=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_comparisons">comparisons</code></td>
<td>
<p>A character vector containing any combination of 'item', 'long', 'mtmm', and 'group' indicating which invariance should be assessed via model comparisons. The order of the vector dictates the sequence in which model comparisons are performed. Defaults to <code>NULL</code> meaning that no model comparisons are performed.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_auxiliary">auxiliary</code></td>
<td>
<p>The names of auxiliary variables in <code>data</code>. These can be used in additional modeling steps that may be provided in <code>analysis.options$model</code>.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_use.order">use.order</code></td>
<td>
<p>A logical indicating whether or not to take the selection order of the items into account. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_software">software</code></td>
<td>
<p>The name of the estimation software. Can currently be 'lavaan' (the default) or 'Mplus'. Each option requires the software to be installed.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used in parallel processing. If <code>NULL</code> (the default) the result of <code><a href="parallel.html#topic+detectCores">detectCores</a></code> will be used. On Unix-y machines parallel processing is implemented via <code><a href="parallel.html#topic+mclapply">mclapply</a></code>, on Windows machines it is realized via <code><a href="parallel.html#topic+parLapply">parLapply</a></code>.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_objective">objective</code></td>
<td>
<p>A function that converts the results of model estimation into a pheromone. See 'details' for... details.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_ignore.errors">ignore.errors</code></td>
<td>
<p>A logical indicating whether or not to ignore estimation problems (such as non positive-definite latent covariance matrices). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_analysis.options">analysis.options</code></td>
<td>
<p>A list additional arguments to be passed to the estimation software. The names of list elements must correspond to the arguments changed in the respective estimation software. E.g. <code>analysis.options$model</code> can contain additional modeling commands - such as regressions on auxiliary variables.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_suppress.model">suppress.model</code></td>
<td>
<p>A logical indicating whether to suppress the default model generation. If <code>TRUE</code> a model must be provided in <code>analysis.options$model</code>.</p>
</td></tr>
<tr><td><code id="objectivematrices_+3A_...">...</code></td>
<td>
<p>Additional arguments passed either to <code><a href="#topic+randomsamples">randomsamples</a></code> or to <code>lavaan</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>stuartFixedObjective</code>
</p>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empiricalobjective">empiricalobjective</a></code>, <code><a href="#topic+extractobjective">extractobjective</a></code>, <code><a href="#topic+objectivematrices">objectivematrices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Extract latent correlation matric
# requires lavaan
# number of cores set to 1 in all examples
data(sups)
fs &lt;- list(pro = names(sups)[2:13],
 fee = names(sups)[14:20])

mats &lt;- objectivematrices(sups, fs, 3,
  cores = 1)
mats

mats$lvcor$use[,] &lt;- FALSE
mats$lvcor$use[2, 1] &lt;- TRUE

mats$lvcor$use

</code></pre>

<hr>
<h2 id='randomsamples'>Generating random samples of Subtests</h2><span id='topic+randomsamples'></span>

<h3>Description</h3>

<p>Construct a defined number of random subtests from a given pool of items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomsamples(
  data,
  factor.structure,
  capacity = NULL,
  item.invariance = "congeneric",
  repeated.measures = NULL,
  long.invariance = "strict",
  mtmm = NULL,
  mtmm.invariance = "configural",
  grouping = NULL,
  group.invariance = "strict",
  comparisons = NULL,
  auxiliary = NULL,
  use.order = FALSE,
  software = "lavaan",
  cores = NULL,
  objective = NULL,
  ignore.errors = FALSE,
  analysis.options = NULL,
  suppress.model = FALSE,
  seed = NULL,
  request.override = 10000,
  filename = NULL,
  n = 1000,
  percentile = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomsamples_+3A_data">data</code></td>
<td>
<p>A data.frame containing all relevant data.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_factor.structure">factor.structure</code></td>
<td>
<p>A list linking factors to items. The names of the list elements correspond to the factor names. Each list element must contain a character-vector of item names that are indicators of this factor.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_capacity">capacity</code></td>
<td>
<p>A list containing the number of items per subtest. This must be in the same order as the <code>factor.structure</code> provided. If a single number, it is applied to all subtests. If <code>NULL</code> all items are evenly distributed among the subtests.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_item.invariance">item.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>factor.structure</code> containing the desired invariance levels between items pertaining to the same subtest. Currently there are five options: 'congeneric', 'ess.equivalent', 'ess.parallel', 'equivalent', and 'parallel', the first being the default.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_repeated.measures">repeated.measures</code></td>
<td>
<p>A list linking factors that are repeated measures of each other. Repeated factors must be in one element of the list - other sets of factors in other elements of the list. When this is <code>NULL</code> (the default) a cross-sectional model is estimated.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_long.invariance">long.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>repeated.measures</code> containing the longitudinal invariance level of repeated items. Currently there are four options: 'configural', 'weak', 'strong', and 'strict'. Defaults to 'strict'. When <code>repeated.measures=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_mtmm">mtmm</code></td>
<td>
<p>A list linking factors that are measurements of the same construct with different methods. Measurements of the same construct must be in one element of the list - other sets of methods in other elements of the list. When this is <code>NULL</code> (the default) a single method model is estimated.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_mtmm.invariance">mtmm.invariance</code></td>
<td>
<p>A character vector of length 1 or the same length as <code>mtmm</code> containing the invariance level of MTMM items. Currently there are five options: 'none', 'configural', 'weak', 'strong', and 'strict'. Defaults to 'configural'. With 'none' differing items are allowed for different methods. When <code>mtmm=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_grouping">grouping</code></td>
<td>
<p>The name of the grouping variable. The grouping variable must be part of <code>data</code> provided and must be a numeric variable.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_group.invariance">group.invariance</code></td>
<td>
<p>A single value describing the assumed invariance of items across groups. Currently there are four options: 'configural', 'weak', 'strong', and 'strict'. Defaults to 'strict'. When <code>grouping=NULL</code> this argument is ignored.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_comparisons">comparisons</code></td>
<td>
<p>A character vector containing any combination of 'item', 'long', 'mtmm', and 'group' indicating which invariance should be assessed via model comparisons. The order of the vector dictates the sequence in which model comparisons are performed. Defaults to <code>NULL</code> meaning that no model comparisons are performed.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_auxiliary">auxiliary</code></td>
<td>
<p>The names of auxiliary variables in <code>data</code>. These can be used in additional modeling steps that may be provided in <code>analysis.options$model</code>.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_use.order">use.order</code></td>
<td>
<p>A logical indicating whether or not to take the selection order of the items into account. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_software">software</code></td>
<td>
<p>The name of the estimation software. Can currently be 'lavaan' (the default), 'Mplus', or 'Mplus Demo'. Each option requires the software to be installed.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used in parallel processing. If <code>NULL</code> (the default) the result of <code><a href="parallel.html#topic+detectCores">detectCores</a></code> will be used. On Unix-y machines parallel processing is implemented via <code><a href="parallel.html#topic+mclapply">mclapply</a></code>, on Windows machines it is realized via <code><a href="parallel.html#topic+parLapply">parLapply</a></code>.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_objective">objective</code></td>
<td>
<p>A function that converts the results of model estimation into a pheromone. See <code><a href="#topic+mmas">mmas</a></code> for details.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_ignore.errors">ignore.errors</code></td>
<td>
<p>A logical indicating whether or not to ignore estimation problems (such as non positive-definite latent covariance matrices). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_analysis.options">analysis.options</code></td>
<td>
<p>A list additional arguments to be passed to the estimation software. The names of list elements must correspond to the arguments changed in the respective estimation software. E.g. <code>analysis.options$model</code> can contain additional modeling commands - such as regressions on auxiliary variables.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_suppress.model">suppress.model</code></td>
<td>
<p>A logical indicating whether to suppress the default model generation. If <code>TRUE</code> a model must be provided in <code>analysis.options$model</code>.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_seed">seed</code></td>
<td>
<p>A random seed for the generation of random samples. See <code><a href="base.html#topic+Random">Random</a></code> for more details.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_request.override">request.override</code></td>
<td>
<p>The maximum number of combinations for which the estimation is performed immediately, without an additional override request.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_filename">filename</code></td>
<td>
<p>The stem of the filenames used to save inputs, outputs, and data files when <code>software='Mplus'</code>. This may include the file path. When <code>NULL</code> (the default) files will be saved to the temporary directory, which is deleted when the R session is ended.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_n">n</code></td>
<td>
<p>The number of random samples to be drawn.</p>
</td></tr>
<tr><td><code id="randomsamples_+3A_percentile">percentile</code></td>
<td>
<p>The percentile of the final solution reported among the viable solutions. Defaults to 100 (the best solution found).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pheromone function provided via <code>objective</code> is used to assess the quality of the solutions. These functions can contain any combination of the fit indices provided by the estimation software. When using Mplus these fit indices are 'rmsea', 'srmr', 'cfi', 'tli', 'chisq' (with 'df' and 'pvalue'), 'aic', 'bic', and 'abic'. With lavaan any fit index provided by <code><a href="lavaan.html#topic+inspect">inspect</a></code> can be used. Additionally 'crel' provides an aggregate of composite reliabilites, 'rel' provides a vector or a list of reliability coefficients for the latent variables, 'con' provides an aggregate consistency estimate for MTMM analyses, and 'lvcor' provides a list of the latent variable correlation matrices. For more detailed objective functions 'lambda', 'theta', 'psi', 'alpha', and 'nu' provide the model-implied matrices. Per default a pheromone function using 'crel', 'rmsea', and 'srmr' is used. Please be aware that the <code>objective</code> must be a function with the required fit indices as (correctly named) arguments.
</p>
<p>Using model comparisons via the <code>comparisons</code> argument compares the target model to a model with one less degree of assumed invariance (e.g. if your target model contains strong invariance, the comparison model contain weak invariance). Adding comparisons will change the preset for the objective function to include model differences. With comparisons, a custom objective function (the recommended approach) can also include all model fit indices with a preceding <code>delta.</code> to indicate the difference in this index between the two models. If more than one type of comparison is used, the argument of the objective function should end in the type of comparison requested (e.g. <code>delta.cfi.group</code> to use the difference in CFI between the model comparison of invariance across groups).
</p>


<h3>Value</h3>

<p>Returns an object of the class <code>stuartOutput</code> for which specific <code>summary</code> and <code>plot</code> methods are available. The results are a list.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The called function.</p>
</td></tr>
<tr><td><code>software</code></td>
<td>
<p>The software used to fit the CFA models.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A list of the parameters used.</p>
</td></tr>
<tr><td><code>analysis.options</code></td>
<td>
<p>A list of the additional arguments passed to the estimation software.</p>
</td></tr>
<tr><td><code>timer</code></td>
<td>
<p>An object of the class <code>proc_time</code> which contains the time used for the analysis.</p>
</td></tr>
<tr><td><code>log</code></td>
<td>
<p>A <code>data.frame</code> containing the estimation history.</p>
</td></tr>
<tr><td><code>log_mat</code></td>
<td>
<p>A <code>list</code> of matrices (e.g. lvcor) relevant to the estimation history, if any.</p>
</td></tr>
<tr><td><code>solution</code></td>
<td>
<p><code>NULL</code></p>
</td></tr>
<tr><td><code>pheromones</code></td>
<td>
<p><code>NULL</code></p>
</td></tr>
<tr><td><code>subtests</code></td>
<td>
<p>A list containing the names of the selected items and their respective subtests.</p>
</td></tr>
<tr><td><code>final</code></td>
<td>
<p>The results of the estimation of the global-best solution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Schultze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bruteforce">bruteforce</a></code>, <code><a href="#topic+mmas">mmas</a></code>, <code><a href="#topic+gene">gene</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Random samples in a simple situation
# requires lavaan
# number of cores set to 1 in all examples
data(fairplayer)
fs &lt;- list(si = names(fairplayer)[83:92])

# 10 random solutions, report median solution
sel &lt;- randomsamples(fairplayer, fs, 4, 
  n = 10, percentile = 50,
  seed = 55635, cores = 1)
summary(sel)


</code></pre>

<hr>
<h2 id='sia'>Data from a German Meaning of Work Scale.</h2><span id='topic+sia'></span>

<h3>Description</h3>

<p>Self-reports from a scale construction study for a German Meaning of Work Scale (Feser et al., 2019) with three facets: Self-realization (17 items), belonging (9 items), justification (8 Items). The data additionally include assessments on the Work and Meaning Inventory (Steger et al., 2012), alienation from work (Fischer and Kohr, 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sia
</code></pre>


<h3>Format</h3>

<p>A data frame with 257 observations on 62 variables.
</p>


<h3>Details</h3>


<ul>
<li><p> lfdn. Participant ID.
</p>
</li>
<li><p> self1 - self17. 17 items of the self-realization facet.
</p>
</li>
<li><p> belong1 - belong9. 9 items of the belonging facet.
</p>
</li>
<li><p> just1 - just8. 8 items of the justification facet.
</p>
</li>
<li><p> wami1 - wami10. 10 items of the Work and Meaning Inventory.
</p>
</li>
<li><p> alien1 - alien10. 10 item of the alienation from work sacle.
</p>
</li>
<li><p> age. Age in years.
</p>
</li>
<li><p> sex. Gender with 1 = female, 2 = other, 3 = male.
</p>
</li>
<li><p> work. Type of employment 1 = employed, 2 = self-employed, 3 = temp-work, 4 = civil servant.
</p>
</li>
<li><p> wokrhours. Weekly work hours.
</p>
</li>
<li><p> tenure1. Years at the current place of employment.
</p>
</li>
<li><p> tenure2. Years of experience in current job.
</p>
</li>
<li><p> kldb2010. German Classification of Occupations (first code number).
</p>
</li></ul>



<h3>Source</h3>

<p>Feser, M., Lorenz, T., &amp; Mainz, E. (2019). Meaning of work: A culture based approach towards the construction of a German questionnaire. Poster presented at the 19th Congress of The European Association for Work &amp; Organizational Psychology. Turin, Italy.
</p>
<p>Fischer, A., &amp; Kohr, H. (2014). Entfremdung von der Arbeit. Zusammentstellung Sozialwissenschaftlicher Items Und Skalen, ZIS. https://doi.org/https://doi.org/10.6102/zis8
</p>
<p>Steger, M. F., Dik, B. J., &amp; Duffy, R. D. (2012). Measuring Meaningful Work. Journal of Career Assessment, 20(3), 322–337. https://doi.org/10.1177/1069072711436160
</p>

<hr>
<h2 id='stuart-package'>STUART: Subtests Using Algorithmic Rummaging Techniques</h2><span id='topic+stuart'></span><span id='topic+stuart-package'></span>

<h3>Description</h3>

<p>The STUART-Package automates the generation of subtests from
a given set of items within the confines of confirmatory factor analysis.
</p>


<h3>Functionality</h3>

<p>Using this package subtests can be generated in four different ways: using a pseudo-random approach rooted in Ant-Colony-Optimization via the <code><a href="#topic+mmas">mmas</a></code>-function, using a simple genetic algorithm via the <code><a href="#topic+gene">gene</a></code>-function, using a brute-force approach via the aptly named <code><a href="#topic+bruteforce">bruteforce</a></code>-function, or by random chance, using the <code><a href="#topic+randomsamples">randomsamples</a></code>-function.
</p>
<p>Addtionally, there are some convenience functions which are more or less useful. The <code><a href="#topic+combinations">combinations</a></code>-function can be used to determine the number of possible subtests to inform a decision on which selection approach to use. The <code><a href="#topic+crossvalidate">crossvalidate</a></code>-function can be used to evaluate the quality of a selection in a different (sub-)sample. To add to this functionality, the <code><a href="#topic+holdout">holdout</a></code>-function randomly splits the data into a calibration and a validation sample. The entire process can be applied to k samples with <code><a href="#topic+kfold">kfold</a></code>. The <code><a href="#topic+heuristics">heuristics</a></code>-function can be used to extract the formatting of heuristic matrices which can be provided to the <code><a href="#topic+mmas">mmas</a></code>-function.
</p>
<p>As of version 0.10.0 this package also includes some convenience functions for handling objective functions. These are mainly <code><a href="#topic+fixedobjective">fixedobjective</a></code> - to generate a fixed objective function containing any number of a variety of possible quality criteria - and <code><a href="#topic+empiricalobjective">empiricalobjective</a></code> - to generate an adaptive objective function based on the quality determined for previous solution on any such criteria. In addition <code><a href="#topic+objectivematrices">objectivematrices</a></code> provides functionality to extract matrices for situations in which, for example, latent correlations or regressions predicting distal outcomes are included into the selection procedure.
</p>
<p>The package also provides three datasets to try things out with: <code><a href="#topic+fairplayer">fairplayer</a></code>, <code><a href="#topic+sia">sia</a></code>, and <code><a href="#topic+sups">sups</a></code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin Schultze <a href="mailto:schultze@psych.uni-frankfurt.de">schultze@psych.uni-frankfurt.de</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Johanna Schüller [contributor]
</p>
</li></ul>


<hr>
<h2 id='sups'>Data from a scale for Supervisor Support</h2><span id='topic+sups'></span>

<h3>Description</h3>

<p>A scale for supervisor support with 19 items. The scale consists of two subscales: carreer promotion (items 1 through 12) and feedback and goal setting (items 13 through 19).
</p>


<h3>Format</h3>

<p>A data frame with 411 observations on 20 variables. The first variable indicates the person ID, the following 19 all stem from the scale for Supervisor Support
</p>


<h3>Source</h3>

<p>Janssen, A.B., Schultze, M., &amp; Grötsch, A. (2015). Following the ants: Development of short scales for proactive personality and supervisor support by Ant Colony Optimization. European Journal of Psychological Assessment.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
