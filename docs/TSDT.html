<!DOCTYPE html><html><head><title>Help for package TSDT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TSDT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25nin+25'><p>%nin%</p></a></li>
<li><a href='#binary_transform'><p>binary transform</p></a></li>
<li><a href='#bootstrap'><p>bootstrap</p></a></li>
<li><a href='#Bootstrap-class'><p>Bootstrap</p></a></li>
<li><a href='#BootstrapStatistic-class'><p>BootstrapStatistic</p></a></li>
<li><a href='#ctree_wrapper'><p>ctree_wrapper</p></a></li>
<li><a href='#CTree-class'><p>CTree</p></a></li>
<li><a href='#cutpoints'><p>Get distribution of cutpoints for subgroups.</p></a></li>
<li><a href='#diff_mean_deviance_residuals'><p>diff_mean_deviance_residuals</p></a></li>
<li><a href='#diff_quantile_response'><p>diff_quantile_response</p></a></li>
<li><a href='#diff_restricted_mean_survival_time'><p>diff_restricted_mean_survival_time</p></a></li>
<li><a href='#diff_survival_time_quantile'><p>diff_survival_time_quantile</p></a></li>
<li><a href='#distribution'><p>distribution</p></a></li>
<li><a href='#folds'><p>folds</p></a></li>
<li><a href='#function_parameter_names'><p>function_parameter_names</p></a></li>
<li><a href='#get_covariates'><p>get_covariates</p></a></li>
<li><a href='#get_cutpoints'><p>get_cutpoints</p></a></li>
<li><a href='#get_suggested_subgroup'><p>get_suggested_subgroup</p></a></li>
<li><a href='#get_trt'><p>get_trt</p></a></li>
<li><a href='#get_y'><p>get_y</p></a></li>
<li><a href='#hazard_ratio'><p>hazard_ratio</p></a></li>
<li><a href='#mean_deviance_residuals'><p>mean_deviance_residuals</p></a></li>
<li><a href='#mean_response'><p>mean_response</p></a></li>
<li><a href='#mob_wrapper'><p>mob_wrapper</p></a></li>
<li><a href='#MOB-class'><p>MOB</p></a></li>
<li><a href='#na2empty'><p>na2empty</p></a></li>
<li><a href='#parse_party'><p>parse_party</p></a></li>
<li><a href='#parse_rpart'><p>parse_rpart</p></a></li>
<li><a href='#partition'><p>partition</p></a></li>
<li><a href='#permutation'><p>permutation</p></a></li>
<li><a href='#quantile_response'><p>quantile_response</p></a></li>
<li><a href='#reset_factor_levels'><p>reset_factor_levels</p></a></li>
<li><a href='#rpart_nodes'><p>rpart_nodes</p></a></li>
<li><a href='#rpart_wrapper'><p>rpart_wrapper</p></a></li>
<li><a href='#subgroup'><p>subgroup</p></a></li>
<li><a href='#subsample'><p>subsample</p></a></li>
<li><a href='#Subsample-class'><p>Subsample</p></a></li>
<li><a href='#summary+2CTSDT-method'><p>Summary function for class TSDT.</p></a></li>
<li><a href='#survival_time_quantile'><p>survival_time_quantile</p></a></li>
<li><a href='#treatment_effect'><p>treatment_effect</p></a></li>
<li><a href='#TSDT'><p>Treatment-Specific Subgroup Detection Tool</p></a></li>
<li><a href='#TSDT_CutpointDistribution-class'><p>TSDT_CutpointDistribution</p></a></li>
<li><a href='#TSDT_Sample-class'><p>TSDT_Sample</p></a></li>
<li><a href='#TSDT-class'><p>TSDT</p></a></li>
<li><a href='#unfactor'><p>unfactor</p></a></li>
<li><a href='#unpack_args'><p>unpack_args</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Treatment-Specific Subgroup Detection Tool</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-06</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a method for identifying subgroups with superior response relative to the overall sample.</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, mlbench, hash, party, rpart, survival, survRM2,
stats, modeltools, utils, parallel</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/EliLillyCo/CRAN_TSDT">https://github.com/EliLillyCo/CRAN_TSDT</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/EliLillyCo/CRAN_TSDT/issues">https://github.com/EliLillyCo/CRAN_TSDT/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-06 21:49:12 UTC; c065288</td>
</tr>
<tr>
<td>Author:</td>
<td>Chakib Battioui [aut],
  Brian Denton [aut, cre],
  Lei Shen [ctb],
  Eli Lilly and Company [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brian Denton &lt;denton_brian_david@lilly.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-06 22:22:28 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25nin+25'>%nin%</h2><span id='topic++25nin+25'></span>

<h3>Description</h3>

<p>Negation of the built-in %in% operator. %nin% is
a short-hand for !( a %in% b ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %nin% b</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25nin+2B25_+3A_a">a</code></td>
<td>
<p>Any R object for which the binary operator %in% is
defined. This would include many built-in R primitives.</p>
</td></tr>
<tr><td><code id="+2B25nin+2B25_+3A_b">b</code></td>
<td>
<p>Any R object for which the binary operator %in% is
defined. This would include many built-in R primitives.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="base.html#topic++25in+25">%in%</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># 4 is not an element in {5,6,7}.
4 %nin% 5:7  # Evaluates to TRUE

# 4 is an element in {4,5,6,7}.
4 %nin% 4:7  # Evaluates to FALSE
</code></pre>

<hr>
<h2 id='binary_transform'>binary transform</h2><span id='topic+binary_transform'></span>

<h3>Description</h3>

<p>Converts any variable with two possible values to a 0,1 binary
variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary_transform(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_transform_+3A_x">x</code></td>
<td>
<p>A variable with two possible values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with values in 0,1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Convert a variable that takes values 'A' and 'B' to 0 and 1
x &lt;- sample( c('A','B'), size = 10, prob = c(0.5,0.5), replace = TRUE )
print(x);flush.console()
binary_transform( x )
</code></pre>

<hr>
<h2 id='bootstrap'>bootstrap</h2><span id='topic+bootstrap'></span>

<h3>Description</h3>

<p>Generate a vector of bootstrap samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(
  x,
  trt = NULL,
  trt_control = "Control",
  FUN = NULL,
  varname = NULL,
  varcol = NULL,
  arglist = NULL,
  n_samples = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_x">x</code></td>
<td>
<p>Source data to bootstrap.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_trt">trt</code></td>
<td>
<p>Treatment variable. (optional)</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_trt_control">trt_control</code></td>
<td>
<p>Value for treatment control arm. Default value is 'Control'.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_fun">FUN</code></td>
<td>
<p>Function to compute statistic for each bootstrap sample. (optional)</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_varname">varname</code></td>
<td>
<p>Name of variable in x on which to compute FUN. If x has only
one column varname is not needed. If x has more than one column then either
varname or varcol must be specified.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_varcol">varcol</code></td>
<td>
<p>Column index of x on which to compute FUN. If x has only one
column varcol is not needed. If x has more than one column then either varname
or varcol must be specified.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_arglist">arglist</code></td>
<td>
<p>List of additional arguments to pass to FUN.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of bootstrap samples to generate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each bootstrap sample will retain the in-bag and out-of-bag data.
Optionally, the user may specify a function to compute a statistic for each
in-bag and out-of-bag sample. This function may be a built-in R function
(e.g. mean, median, etc.) or a user-defined function (see Examples). If no
statistic function is provided bootstrap returns a vector of objects of class
<a href="#topic+Bootstrap-class">Bootstrap</a>. If a statistic function is provided bootstrap
returns a vector of objects of class <a href="#topic+BootstrapStatistic-class">BootstrapStatistic</a>,
which in addition to the in-bag and out-of-bag samples contains the name of
the statistic, variable on which the statistic is computed, and the numerical
result of the statistic for each in-bag and out-of-bag sample.
</p>


<h3>Value</h3>

<p>If FUN is NULL returns a vector of objects of class
<a href="#topic+Bootstrap-class">Bootstrap</a>. If FUN is non-NULL returns a vector of objects
of class <a href="#topic+BootstrapStatistic-class">BootstrapStatistic</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+Bootstrap-class">Bootstrap</a>, <a href="#topic+BootstrapStatistic-class">BootstrapStatistic</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate example data frame containing response and treatment
N &lt;- 20
x &lt;- data.frame( runif( N ) )
names( x ) &lt;- "response"
x$treatment &lt;- factor( sample( c("Control","Experimental"), size = N,
                       prob = c(0.8,0.2), replace = TRUE ) )

## Generate two bootstrap samples without regard to treatment
ex1 &lt;- bootstrap( x, n_samples = 2 )

## Generate two bootstrap samples stratified by treatment
ex2 &lt;- bootstrap( x, trt = x$treatment, trt_control = "Control", n_samples = 2 )

## For each bootstrap sample compute a statistic on the in-bag and out-of-bag data
ex3 &lt;- bootstrap( x, FUN = mean, varname = "response", n_samples = 2 )

## Specify a user-defined function that takes a numeric vector input and
## returns a numeric result
sort_and_rank &lt;- function( z, rank ){
  z &lt;- sort( z )
  return( z[rank] )
}

ex4 &lt;- bootstrap( x, FUN = sort_and_rank, arglist = list( rank = 1 ),
                  varname = "response", n_samples = 2 )
</code></pre>

<hr>
<h2 id='Bootstrap-class'>Bootstrap</h2><span id='topic+Bootstrap-class'></span>

<h3>Description</h3>

<p>Bootstrap is a container class for bootstrap samples.
</p>


<h3>Value</h3>

<p>Object of class Bootstrap
</p>


<h3>Slots</h3>


<dl>
<dt><code>inbag</code></dt><dd><p>In-bag bootstrap sample.</p>
</dd>
<dt><code>oob</code></dt><dd><p>Out-of-bag bootstrap sample.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+BootstrapStatistic-class">BootstrapStatistic</a>, <a href="#topic+bootstrap">bootstrap</a>
</p>

<hr>
<h2 id='BootstrapStatistic-class'>BootstrapStatistic</h2><span id='topic+BootstrapStatistic-class'></span>

<h3>Description</h3>

<p>BootstrapStatistic is a container class for bootstrap samples augmented with a computed statistic.
</p>


<h3>Value</h3>

<p>Object of class BootstrapStatistic
</p>


<h3>Slots</h3>


<dl>
<dt><code>statname</code></dt><dd><p>The name of a (possibly user-defined) statistic to compute on the bootstrap sample.</p>
</dd>
<dt><code>arglist</code></dt><dd><p>A list of arguments passed to the function referenced by statname.</p>
</dd>
<dt><code>variable</code></dt><dd><p>The name of the variable on which to compute statname.</p>
</dd>
<dt><code>inbag_stat</code></dt><dd><p>The value of statname for the in-bag bootstrapped sample.</p>
</dd>
<dt><code>oob_stat</code></dt><dd><p>The value of statname for the out-of-bag bootstrapped sample.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+Bootstrap-class">Bootstrap</a>, <a href="#topic+bootstrap">bootstrap</a>
</p>

<hr>
<h2 id='ctree_wrapper'>ctree_wrapper</h2><span id='topic+ctree_wrapper'></span>

<h3>Description</h3>

<p>A wrapper function to <a href="party.html#topic+ctree">ctree</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctree_wrapper(response, covariates = NULL, tree_builder_parameters = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctree_wrapper_+3A_response">response</code></td>
<td>
<p>Response variable to use in ctree model.</p>
</td></tr>
<tr><td><code id="ctree_wrapper_+3A_covariates">covariates</code></td>
<td>
<p>Covariates to use in ctree model.</p>
</td></tr>
<tr><td><code id="ctree_wrapper_+3A_tree_builder_parameters">tree_builder_parameters</code></td>
<td>
<p>A named list of parameters to pass to
<a href="party.html#topic+ctree">ctree</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+CTree-class">CTree</a>
</p>


<h3>See Also</h3>

<p><a href="party.html#topic+ctree">ctree</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace( "party", quietly = TRUE )
## From party::ctree() examples:
set.seed(290875)
airq &lt;- subset(airquality, !is.na(Ozone))

## Provide response and covariates to fit ctree
ex1 &lt;- ctree_wrapper( response = airq$Ozone,
                      covariates = subset( airq, select = -Ozone ) )

## Pass list of control parameters. Note that ctree takes a parameter called
## 'controls' (with an 's'), rather than 'control' as in rpart.
ex2 &lt;- ctree_wrapper( response = airq$Ozone,
                      covariates = subset( airq, select = -Ozone ),
                      tree_builder_parameters = list( controls =
                                             party::ctree_control( maxdepth = 2 ) ) )
</code></pre>

<hr>
<h2 id='CTree-class'>CTree</h2><span id='topic+CTree-class'></span>

<h3>Description</h3>

<p>CTree is a container class for trees created by <a href="party.html#topic+ctree">ctree</a>.
</p>


<h3>Value</h3>

<p>An object of class CTree
</p>


<h3>Slots</h3>


<dl>
<dt><code>tree</code></dt><dd><p>An object of class <a href="party.html#topic+BinaryTree-class">BinaryTree-class</a> produced by
<a href="party.html#topic+ctree">ctree</a>.</p>
</dd>
<dt><code>data</code></dt><dd><p>Training data.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>Control parameters</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="party.html#topic+ctree">ctree</a>, <a href="party.html#topic+BinaryTree-class">BinaryTree-class</a>
</p>

<hr>
<h2 id='cutpoints'>Get distribution of cutpoints for subgroups.</h2><span id='topic+cutpoints'></span>

<h3>Description</h3>

<p>Get distribution of cutpoints for subgroups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutpoints(object, subgroup = NULL, subsub = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutpoints_+3A_object">object</code></td>
<td>
<p>An object of class TSDT</p>
</td></tr>
<tr><td><code id="cutpoints_+3A_subgroup">subgroup</code></td>
<td>
<p>A string decscription of a subgroup (optional)</p>
</td></tr>
<tr><td><code id="cutpoints_+3A_subsub">subsub</code></td>
<td>
<p>A string description of a sub-subgroup (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the subgroup cutpoints.
</p>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>
</p>

<hr>
<h2 id='diff_mean_deviance_residuals'>diff_mean_deviance_residuals</h2><span id='topic+diff_mean_deviance_residuals'></span>

<h3>Description</h3>

<p>Computes the difference in the mean of deviance residuals
function across treatment groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_mean_deviance_residuals(data, scoring_function_parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_mean_deviance_residuals_+3A_data">data</code></td>
<td>
<p>data.frame containing response data</p>
</td></tr>
<tr><td><code id="diff_mean_deviance_residuals_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>named list of scoring function control parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The deviance residual is the observed number of
events at time t minus the expected number of events at time t. See
documentation for mean_deviance_residuals (linked below) for more details.
A smaller value for the deviance residual is preferred when the event under
study is an undesirable event &ndash; i.e. it is preferred to observe fewer events
than predicted by the survival model. A two-arm TSDT model computes the mean
deviance residual in the treatment arm minus the mean deviance residual in the
control arm. The treatment arm is superior to the control arm when the mean
deviance residual in the treatment arm is less than the mean deviance residual
in the control arm. Thus, the appropriate value for desirable_response is
desirable_response = 'decreasing'. If the event under study is a desirable
event the appropriate value for desirable_response is desirable_response =
'increasing'. It is assumed most survival models will model an undesirable
event, so the default value for desirable_response when the scoring_function
is diff_mean_deviance_residuals is desirable_response = 'decreasing'. Note
this differs from all other TSDT configurations, for which the default value
for desirable_response is desirable_response = 'increasing'.
</p>


<h3>Value</h3>

<p>Difference in mean deviance residuals across treatment arms.
</p>


<h3>See Also</h3>

<p><a href="#topic+mean_deviance_residuals">mean_deviance_residuals</a>, <a href="survival.html#topic+Surv">Surv</a>,
<a href="survival.html#topic+coxph">coxph</a>, <a href="survival.html#topic+survreg">survreg</a>,
<a href="survival.html#topic+residuals.coxph">residuals.coxph</a>,
<a href="survival.html#topic+residuals.survreg">residuals.survreg</a>,
<a href="#topic+TSDT">TSDT</a>
</p>

<hr>
<h2 id='diff_quantile_response'>diff_quantile_response</h2><span id='topic+diff_quantile_response'></span>

<h3>Description</h3>

<p>Return the difference across treatment arms of a specified
response quantile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_quantile_response(data, scoring_function_parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_quantile_response_+3A_data">data</code></td>
<td>
<p>data.frame containing response data</p>
</td></tr>
<tr><td><code id="diff_quantile_response_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>named list of scoring function control parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the difference across treatment arms of the
response quantile associated with a specified percentile. The default behavior
is to return the difference in medians.
</p>


<h3>Value</h3>

<p>A difference of response quantiles across treatment arms
</p>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>, <a href="#topic+quantile_response">quantile_response</a>, <a href="stats.html#topic+quantile">quantile</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate example data containing response and treatment
N &lt;- 100
y = runif( min = 0, max = 20, n = N )
df &lt;- as.data.frame( y )
names( df )  &lt;- "y"
df$trt &lt;- sample( c('Control','Experimental'), size = N, prob = c(0.4,0.6),
                  replace = TRUE )

## Default behavior is to return the median
diff_quantile_response( df )

# should match previous result from quantile_response
median( df$y[df$trt!='Control'] ) - median( df$y[df$trt=='Control'] )

## Get Q1 response
diff_quantile_response( df, scoring_function_parameters = list( percentile = 0.25 ) )

# should match previous result from quantile_response
quantile( df$y[df$trt!='Control'], 0.25 ) - quantile( df$y[df$trt=='Control'], 0.25 )

## Get max response
diff_quantile_response( df, scoring_function_parameters = list( percentile = 1 ) )

# should match previous result from quantile_response
max( df$y[df$trt!='Control'] ) -  max( df$y[df$trt=='Control'] )
</code></pre>

<hr>
<h2 id='diff_restricted_mean_survival_time'>diff_restricted_mean_survival_time</h2><span id='topic+diff_restricted_mean_survival_time'></span>

<h3>Description</h3>

<p>Computes the difference in restricted mean survival time across
treatment arms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_restricted_mean_survival_time(data, scoring_function_parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_restricted_mean_survival_time_+3A_data">data</code></td>
<td>
<p>data.frame containing response data</p>
</td></tr>
<tr><td><code id="diff_restricted_mean_survival_time_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>named list of scoring function control parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the restricted mean survival time for the treatment and
control arms and returns the difference.
</p>


<h3>Value</h3>

<p>Difference in restricted mean survival time across treatment arms.
</p>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>, <a href="survival.html#topic+Surv">Surv</a>, <a href="survRM2.html#topic+rmst2">rmst2</a>
</p>

<hr>
<h2 id='diff_survival_time_quantile'>diff_survival_time_quantile</h2><span id='topic+diff_survival_time_quantile'></span>

<h3>Description</h3>

<p>Computes the difference in the quantile of a survival function
across treatment groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_survival_time_quantile(data, scoring_function_parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_survival_time_quantile_+3A_data">data</code></td>
<td>
<p>data.frame containing response data</p>
</td></tr>
<tr><td><code id="diff_survival_time_quantile_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>named list of scoring function control parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the survival function quantile for the treatment and
control arms and returns the difference.
</p>


<h3>Value</h3>

<p>A difference in a survival time quantile across treatment arms.
</p>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>, <a href="#topic+survival_time_quantile">survival_time_quantile</a>, <a href="survival.html#topic+Surv">Surv</a>,
<a href="survival.html#topic+coxph">coxph</a>, <a href="survival.html#topic+survfit">survfit</a>, <a href="survival.html#topic+survreg">survreg</a>,
<a href="survival.html#topic+predict.coxph">predict.coxph</a>, <a href="survival.html#topic+predict.survreg">predict.survreg</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace( "survival", quiet = TRUE )
N &lt;- 200
df &lt;- data.frame( y = survival::Surv( runif( min = 0, max = 20, n = N ),
                            sample( c(0,1), size = N, prob = c(0.2,0.8), replace = TRUE ) ),
                  trt = sample( c('Control','Experimental'), size = N,
                                prob = c(0.4,0.6), replace = TRUE ) )

## Compute difference in median survival time between Experimental arm and
## Control arm.  It is not actually necessary to provide the value for the
## time_var, trt_var, trt_control, and percentile parameters because these
## values are all equal to their default values. The value are explicitly
## provided here simply for clarity.
ex1 &lt;- diff_survival_time_quantile( data = df,
                                    scoring_function_parameters = list( trt_var = "trt",
                                    trt_control = "Control",
                                    percentile = 0.50 ) )

## Compute difference in Q1 survival time. In this example the default value
## for all scoring function parameters are used except percentile, which here
## takes the value 0.25.
ex2 &lt;- diff_survival_time_quantile( data = df,
                                    scoring_function_parameters = list( percentile = 0.25 ) )
</code></pre>

<hr>
<h2 id='distribution'>distribution</h2><span id='topic+distribution'></span>

<h3>Description</h3>

<p>Returns the distribution of values used to compute TSDT summary
statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distribution(object, statistic, subgroup = NULL, subsub = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distribution_+3A_object">object</code></td>
<td>
<p>An object of class TSDT</p>
</td></tr>
<tr><td><code id="distribution_+3A_statistic">statistic</code></td>
<td>
<p>The desired statistic distribution</p>
</td></tr>
<tr><td><code id="distribution_+3A_subgroup">subgroup</code></td>
<td>
<p>The desired subgroup</p>
</td></tr>
<tr><td><code id="distribution_+3A_subsub">subsub</code></td>
<td>
<p>A subset of the subgroup</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the distribution of all values used to compute
summary statistics for superior subgroups identified by the TSDT algorithm.
The summary statistics returned for a TSDT object include the mean
subgroup size, mean response value, and median value of the scoring function.
These statistics reported seperately for in-bag and out-of-bag data sets, and
also stratified by treatment arm. This function can also provide the
distribution of all cutpoints for a numeric splitting variable in a subgroup
definition.
</p>


<h3>Value</h3>

<p>A vector containing the observed values for the specified subgroup
</p>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>, <a href="#topic+summary-methods">summary-methods</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
N &lt;- 200
continuous_response = runif( min = 0, max = 20, n = N )
trt &lt;- sample( c('Control','Experimental'), size = N, prob = c(0.4,0.6),
               replace = TRUE )
X1 &lt;- runif( N, min = 0, max = 1 )
X2 &lt;- runif( N, min = 0, max = 1 )
X3 &lt;- sample( c(0,1), size = N, prob = c(0.2,0.8), replace = TRUE )
X4 &lt;- sample( c('A','B','C'), size = N, prob = c(0.6,0.3,0.1), replace = TRUE )
covariates &lt;- data.frame( X1 )
covariates$X2 &lt;- X2
covariates$X3 &lt;- factor( X3 )
covariates$X4 &lt;- factor( X4 )

## Create a TSDT object
ex1 &lt;- TSDT( response = continuous_response,
            trt = trt, trt_control = 'Control',
            covariates = covariates[,1:4],
            inbag_score_margin = 0,
            desirable_response = "increasing",
            oob_score_margin = 0,
            min_subgroup_n_control = 5,
            min_subgroup_n_trt = 5,
            n_sample = 5 )

## Show summary statistics
summary( ex1 )

## Get the number of subjects in each superior in-bag subgroup
distribution( ex1, statistic = 'Inbag_Subgroup_Size' )

## Get the vector of subgroup sample sizes for a particular subgroup
distribution( ex1, statistic = 'Inbag_Subgroup_Size',
              subgroup = 'X1&lt;xxxxx &amp; X1&gt;=xxxxx' )

## Get the observed cutpoints for the numeric splitting variables in a subgroup
distribution( ex1, statistic = 'Cutpoints', subgroup = 'X1&lt;xxxxx &amp; X1&gt;=xxxxx' )

## If the subgroup definition has more than one numeric splitting variable you
## can retrieve the numeric cutpoints for the splitting variables individually
distribution( ex1, statistic = 'Cutpoints', subgroup = 'X1&lt;xxxxx &amp; X1&gt;=xxxxx',
              subsub = 'X1&lt;xxxxx' )
distribution( ex1, statistic = 'Cutpoints', subgroup = 'X1&lt;xxxxx &amp; X1&gt;=xxxxx',
              subsub = 'X1&gt;=xxxxx' )

## Valid statistic names come from the column names in the summary output. If
## you are uncertain what the possible statistic values could be, you can pass
## any arbitrary string as the statistic and an error message is returned
## listing valid statistic values.
## Not run: 
distribution( ex1, statistic = 'Invalid_Statistic' )

## End(Not run)
</code></pre>

<hr>
<h2 id='folds'>folds</h2><span id='topic+folds'></span>

<h3>Description</h3>

<p>Partition data into k folds for k-fold cross-validation. Adds a variable
fold_id to the data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>folds(x, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="folds_+3A_x">x</code></td>
<td>
<p>data.frame to partition into k folds for k-fold cross-validation.</p>
</td></tr>
<tr><td><code id="folds_+3A_k">k</code></td>
<td>
<p>Number of folds to use in cross-validation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of partitions of the vector x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random example data
N &lt;- 200
ID &lt;- 1:N
continuous_response = runif( min = 0, max = 20, n = N )
X1 &lt;- runif( N, min = 0, max = 1 )
X2 &lt;- runif( N, min = 0, max = 1 )
X3 &lt;- sample( c(0,1), size = N, prob = c(0.2,0.8), replace = TRUE )
X4 &lt;- sample( c('A','B','C'), size = N, prob = c(0.6,0.3,0.1), replace = TRUE )

df &lt;- data.frame( ID )
names( df ) &lt;- "ID"
df$response &lt;- continuous_response
df$X1 &lt;- X1
df$X2 &lt;- X2
df$X3 &lt;- factor( X3 )
df$X4 &lt;- factor( X4 )

## Partition data into 5 folds
ex1 &lt;- folds( df, k = 5 )

## Partition data into 10 folds
ex2 &lt;- folds( df, k = 10 )
</code></pre>

<hr>
<h2 id='function_parameter_names'>function_parameter_names</h2><span id='topic+function_parameter_names'></span>

<h3>Description</h3>

<p>Returns a character vector of the specified function's parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>function_parameter_names(FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="function_parameter_names_+3A_fun">FUN</code></td>
<td>
<p>The name of a function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of function parameter names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define a function
example_function &lt;- function( parm1, arg2, x, bool = FALSE ){
  cat( "This is an example function.\n" )
}

## Return the function parameter names
function_parameter_names( example_function )
</code></pre>

<hr>
<h2 id='get_covariates'>get_covariates</h2><span id='topic+get_covariates'></span>

<h3>Description</h3>

<p>Returns the covariate variables in the in-bag or out-of-bag data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_covariates(data, scoring_function_parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_covariates_+3A_data">data</code></td>
<td>
<p>A data.frame containing in-bag or out-of-bag data</p>
</td></tr>
<tr><td><code id="get_covariates_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>A list of named elements containing control
parameters and other data required by the scoring function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the user provides a covariate_vars parameter in the list of
scoring_function_parameters this function will return the variables specified
by that parameter. If the user specifies a covariate_cols parameter in the list of
scoring_function_parameters the function returns the columns in data indexed
by that parameter. Otherwise, NULL is returned.
</p>


<h3>Value</h3>

<p>A data.frame of covariates.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_y">get_y</a>, <a href="#topic+get_trt">get_trt</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an example data.frame
df &lt;- data.frame( y &lt;- 1:5 )
names( df ) &lt;- "y"
df$time &lt;- 10:14
df$time2 &lt;- 20:24
df$event &lt;- sample( c(0:1), size = 5, replace = TRUE )
df$trt &lt;- sample( c("Control","Treatment"), size = 5, replace = TRUE )
df$x1 &lt;- runif( n = 5 )
df$x2 &lt;- LETTERS[1:5]

## Select the covariate variables by name
get_covariates( df, scoring_function_parameters = list( covariate_vars = c("x1","x2") ) )

## Select the covariate variables by column index
get_covariates( df, scoring_function_parameters = list( covariate_cols = c(6:7) ) )
</code></pre>

<hr>
<h2 id='get_cutpoints'>get_cutpoints</h2><span id='topic+get_cutpoints'></span><span id='topic+get_cutpoints+2CTSDT_CutpointDistribution-method'></span><span id='topic+get_cutpoints+2CANY-method'></span><span id='topic+get_cutpoints+2CTSDT-method'></span>

<h3>Description</h3>

<p>Accessor method for cutpoints slot in TSDT objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cutpoints(.Object, subgroup, subsub = NULL)

## S4 method for signature 'TSDT_CutpointDistribution'
get_cutpoints(.Object, subgroup = character, subsub = NULL)

## S4 method for signature 'TSDT'
get_cutpoints(.Object, subgroup = character, subsub = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cutpoints_+3A_.object">.Object</code></td>
<td>
<p>A TSDT object.</p>
</td></tr>
<tr><td><code id="get_cutpoints_+3A_subgroup">subgroup</code></td>
<td>
<p>The anonymized subgroup.</p>
</td></tr>
<tr><td><code id="get_cutpoints_+3A_subsub">subsub</code></td>
<td>
<p>A particular component of the subgroup to retrieve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The summary results from TSDT provide a set of 'anonymized' subgroups
in a form similar to 'X1&lt;xxxxx'. The variable X1 may have been selected as a
splitting variable in several bootstrapped samples. The exact numerical
cutpoint for X1 could vary from one sample to the next. The get_cutpoints
method returns all the numerical cutpoints associated with this subgroup. If
the subgroup is a compound subgroup defined on more than one spliting variable
the user can specify the 'subsub' parameter to get the cutpoints associated
with a particular component of the subgroup.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
example( TSDT )
## You can access the cutpoints slot of a TSDT object directly
ex2@cutpoints

## You can also use the accessor method
get_cutpoints( ex2@cutpoints, subgroup = 'X1&lt;xxxxx' )

## Retrieving a compound subgroup defined on multiple splits
get_cutpoints( ex2, subgroup = 'X1&lt;xxxxx &amp; X1&gt;=xxxxx' )

## Retrieving a single component from the compound subgroup
get_cutpoints( ex2, subgroup = 'X1&lt;xxxxx &amp; X1&gt;=xxxxx', subsub = 'X1&gt;=xxxxx' )

## End(Not run)
</code></pre>

<hr>
<h2 id='get_suggested_subgroup'>get_suggested_subgroup</h2><span id='topic+get_suggested_subgroup'></span>

<h3>Description</h3>

<p>Get a string definition of the suggested subgroup definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_suggested_subgroup(anonymized_subgroup, suggested_cutoff, anon = "xxxxx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_suggested_subgroup_+3A_anonymized_subgroup">anonymized_subgroup</code></td>
<td>
<p>A string containing the the anonymized subgroup.</p>
</td></tr>
<tr><td><code id="get_suggested_subgroup_+3A_suggested_cutoff">suggested_cutoff</code></td>
<td>
<p>A string containing the suggested cutoff.</p>
</td></tr>
<tr><td><code id="get_suggested_subgroup_+3A_anon">anon</code></td>
<td>
<p>The anonymization string. By default this is 'xxxxx'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subgroups are reported in an anonymized fashion &ndash; e.g. a subgroup
defined on a variable X1 could be reported as X1&lt;xxxxx, 'xxxxx' is a string
used to represent an exact numeric cutoff. For each anonymized subgroup,
the distribution of exact numeric cutpoints is retained across all
bootrstrapped samples. TSDT then provides a suggested cutoff got each
anonymized subgroup. By default, this suggested cutoff is the median of the
observed cutpoints. Note that this anonymization applies only to numeric
splitting variables. Categorical splitting variables are not anonymized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
N &lt;- 200
continuous_response = runif( min = 0, max = 20, n = N )
trt &lt;- sample( c('Control','Experimental'), size = N, prob = c(0.4,0.6), replace = TRUE )
X1 &lt;- runif( N, min = 0, max = 1 )
X2 &lt;- runif( N, min = 0, max = 1 )
X3 &lt;- sample( c(0,1), size = N, prob = c(0.2,0.8), replace = TRUE )
X4 &lt;- sample( c('A','B','C'), size = N, prob = c(0.6,0.3,0.1), replace = TRUE )
covariates &lt;- data.frame( X1 )
covariates$X2 &lt;- X2
covariates$X3 &lt;- factor( X3 )
covariates$X4 &lt;- factor( X4 )

## Create a TSDT object
ex1 &lt;- TSDT( response = continuous_response,
             trt = trt, trt_control = 'Control',
             covariates = covariates[,1:4],
             inbag_score_margin = 0,
             desirable_response = "increasing",
             oob_score_margin = 0,
             min_subgroup_n_control = 10,
             min_subgroup_n_trt = 20,
             maxdepth = 2,
             rootcompete = 2 )

## Show summary statistics
summary( ex1 )

## Get the anonymized subgroup defined on X1
anonymized_subgroup &lt;- as.character( ex1@superior_subgroups$Subgroup[2] )

## Get the suggested cutoff for this subgroup
suggested_cutoff &lt;- as.character( ex1@superior_subgroups$Suggested_Cutoff[2] )

## Get the suggested subgroup
get_suggested_subgroup( anonymized_subgroup = anonymized_subgroup,
                        suggested_cutoff = suggested_cutoff )
</code></pre>

<hr>
<h2 id='get_trt'>get_trt</h2><span id='topic+get_trt'></span>

<h3>Description</h3>

<p>Returns the treatment variable in the in-bag or out-of-bag data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_trt(data, scoring_function_parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_trt_+3A_data">data</code></td>
<td>
<p>A data.frame containing in-bag or out-of-bag data</p>
</td></tr>
<tr><td><code id="get_trt_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>A list of named elements containing control
parameters and other data required by the scoring function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the user provides a trt_var parameter in the list of
scoring_function_parameters this function will return the variable specified
by that parameter. If the user specifies a trt_col parameter in the list of
scoring_function_parameters the function returns the column in data indexed
by that parameter. Lastly, if data contains a variable called 'trt' that
variable is returned. Otherwise, NULL is returned.
</p>


<h3>Value</h3>

<p>Treatment variable (if available) or NULL.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_y">get_y</a>, <a href="#topic+get_covariates">get_covariates</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an example data.frame
df &lt;- data.frame( y &lt;- 1:5 )
names( df ) &lt;- "y"
df$time &lt;- 10:14
df$time2 &lt;- 20:24
df$event &lt;- sample( c(0:1), size = 5, replace = TRUE )
df$trt &lt;- sample( c("Control","Treatment"), size = 5, replace = TRUE )
df$x1 &lt;- runif( n = 5 )
df$x2 &lt;- LETTERS[1:5]

## Select the trt variable by name
get_trt( df, scoring_function_parameters = list( trt_var = 'trt' ) )

## Select the trt variable by column index
get_trt( df, scoring_function_parameters = list( trt_col = 5 ) )

## The default behavior works for this example because the trt variable in df
## is actually called trt.
get_trt( df )

## If the user's data does not contain a variable called
## 'y' the default behavior will fail. In this case the user must explicitly
## identify the 'y' variable via one of the two previous methods.
names( df )[which(names(df) == "trt")] &lt;- "treatment" # rename the 'trt' variable to 'treatment'

get_trt( df )  # now default behavior fails (i.e. returns NULL)

get_trt( df, scoring_function_parameters = list( trt_var = 'treatment' ) ) # this works
</code></pre>

<hr>
<h2 id='get_y'>get_y</h2><span id='topic+get_y'></span>

<h3>Description</h3>

<p>Returns the response variable in the in-bag or out-of-bag data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_y(data, scoring_function_parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_y_+3A_data">data</code></td>
<td>
<p>A data.frame containing in-bag or out-of-bag data</p>
</td></tr>
<tr><td><code id="get_y_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>A list of named elements containing control
parameters and other data required by the scoring function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the user provides a y_var parameter in the list of
scoring_function_parameters this function will return the variable specified
by that parameter. If the user specifies a y_col parameter in the list of
scoring_function_parameters the function returns the column in data indexed
by that parameter. Lastly, if data contains a variable called 'y' that
variable is returned. Otherwise, NULL is returned.
</p>


<h3>Value</h3>

<p>Response variable (if present) or NULL.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_trt">get_trt</a>, <a href="#topic+get_covariates">get_covariates</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an example data.frame
df &lt;- data.frame( y &lt;- 1:5 )
names( df ) &lt;- "y"
df$time &lt;- 10:14
df$time2 &lt;- 20:24
df$event &lt;- sample( c(0:1), size = 5, replace = TRUE )
df$trt &lt;- sample( c("Control","Treatment"), size = 5, replace = TRUE )
df$x1 &lt;- runif( n = 5 )
df$x2 &lt;- LETTERS[1:5]

## Select the y variable by name
get_y( df, scoring_function_parameters = list( y_var = 'y' ) )

## Select the y variable by column index
get_y( df, scoring_function_parameters = list( y_col = 1 ) )

## The default behavior works for this example because the y variable in df
## is actually called y.
get_y( df )

## If the user's data does not contain a variable called
## 'y' the default behavior will fail. In this case the user must explicitly
## identify the 'y' variable via one of the two previous methods.
names( df )[which(names(df) == "y")] &lt;- "response" # rename the 'y' variable to 'response'

get_y( df )  # now default behavior fails (i.e. returns NULL)

get_y( df, scoring_function_parameters = list( y_var = 'response' ) ) # this works
</code></pre>

<hr>
<h2 id='hazard_ratio'>hazard_ratio</h2><span id='topic+hazard_ratio'></span>

<h3>Description</h3>

<p>Computes the hazard ratio across treatment arms using a CoxPH
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hazard_ratio(data, scoring_function_parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hazard_ratio_+3A_data">data</code></td>
<td>
<p>data.frame containing response data</p>
</td></tr>
<tr><td><code id="hazard_ratio_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>named list of scoring function control parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hazard ratio across treatment arms.
</p>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>, <a href="survival.html#topic+Surv">Surv</a>,  <a href="survival.html#topic+coxph">coxph</a>,
</p>

<hr>
<h2 id='mean_deviance_residuals'>mean_deviance_residuals</h2><span id='topic+mean_deviance_residuals'></span>

<h3>Description</h3>

<p>Computes the mean of the deviance residuals from a survival model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_deviance_residuals(data, scoring_function_parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_deviance_residuals_+3A_data">data</code></td>
<td>
<p>data.frame containing response data</p>
</td></tr>
<tr><td><code id="mean_deviance_residuals_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>named list of scoring function control parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the mean of the deviance residuals from a survival model.
The deviance residual at time t is computed as the observed number of events
at time t minus the expected number of events at time t (see Therneau, et. al.
linked below). The expected number of events is the number of events predicted
by the survival model. If the event under study is an undesirable event (as
would likely be the case in a clinical context), then a smaller value for the
deviance residual is desirable &ndash; i.e. it is desirable to observe fewer events
than expected from the survival model. In this case the appropriate value for
desirable_response in TSDT is desirable_response = 'decreasing'. If the event
under study is desirable then the appropriate value for desirable_response is
desirable_response = 'increasing'. It is assumed that most survival models are
modeling an undesirable event. Therefore, when the user specifies
mean_deviance_residual or diff_mean_deviance_residual, the default value for
desirable_repsonse is changed to 'decreasing', unless the user explicitly
provides desirable_response = 'increasing'. Note this differs from all other
TSDT configurations, for which the default value for desirable_response is
desirable_response = 'increasing'.
</p>


<h3>Value</h3>

<p>Mean of deviance residuals
</p>


<h3>References</h3>

<p>Therneau, T.M.,  Grambsch, P.M., and Fleming, T.R. (1990).  Martingale-based
residuals for survival models.  Biometrika, 77(1), 147-160.
doi:10.1093/biomet/77.1.147.
<a href="https://academic.oup.com/biomet/article/77/1/147/271076">https://academic.oup.com/biomet/article/77/1/147/271076</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>, <a href="survival.html#topic+Surv">Surv</a>, <a href="survival.html#topic+coxph">coxph</a>,
<a href="survival.html#topic+survfit">survfit</a>
</p>

<hr>
<h2 id='mean_response'>mean_response</h2><span id='topic+mean_response'></span>

<h3>Description</h3>

<p>Compute the mean response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_response(data, scoring_function_parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_response_+3A_data">data</code></td>
<td>
<p>data.frame containing response data</p>
</td></tr>
<tr><td><code id="mean_response_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>named list of scoring function control
parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will compute the mean of the response variable. If
a value for trt_arm is provided the mean in that treatment arm only will be
computed (and the trt variable must also be provided), otherwise the mean
for all data passed to the function will be computed.
</p>


<h3>Value</h3>

<p>The mean of the provided response variable.
</p>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>, <a href="#topic+treatment_effect">treatment_effect</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 50

data &lt;- data.frame( continuous_response = numeric(N),
                   trt = character(N) )

data$continuous_response &lt;- runif( min = 0, max = 20, n = N )
data$trt &lt;- sample( c('Control','Experimental'), size = N, prob = c(0.4,0.6), replace = TRUE )

## Compute mean response for all data
mean_response( data, scoring_function_parameters = list( y_var = 'continuous_response' ) )
mean( data$continuous_response ) # Function return value should match this value

## Compute mean response for Experimental treatment arm only
scoring_function_parameters &lt;- list( y_var = 'continuous_response', trt_arm = 'Experimental' )
mean_response( data, scoring_function_parameters = scoring_function_parameters )
# Function return value should match this value
mean( data$continuous_response[ data$trt == 'Experimental' ] )
</code></pre>

<hr>
<h2 id='mob_wrapper'>mob_wrapper</h2><span id='topic+mob_wrapper'></span>

<h3>Description</h3>

<p>Wrapper function for <a href="party.html#topic+mob">mob</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mob_wrapper(
  response,
  x = NULL,
  z = NULL,
  covariates = NULL,
  tree_builder_parameters = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mob_wrapper_+3A_response">response</code></td>
<td>
<p>Response variable to use in mob model.</p>
</td></tr>
<tr><td><code id="mob_wrapper_+3A_x">x</code></td>
<td>
<p>Covariates passed to model in mob. mob uses fits the formula
y ~ x1 + ... + xk | z1 + ... + zl where the variables before the | are passed
to the model and the variables after the | are used for partitioning. x
represents the x variables. See mob help page for more information.</p>
</td></tr>
<tr><td><code id="mob_wrapper_+3A_z">z</code></td>
<td>
<p>Covariates used to parition the mob model. mob uses fits the formula
y ~ x1 + ... + xk | z1 + ... + zl where the variables before the | are passed
to the model and the variables after the | are used for partitioning. z
represents the z variables. See mob help page for more information.</p>
</td></tr>
<tr><td><code id="mob_wrapper_+3A_covariates">covariates</code></td>
<td>
<p>An alias for z.</p>
</td></tr>
<tr><td><code id="mob_wrapper_+3A_tree_builder_parameters">tree_builder_parameters</code></td>
<td>
<p>A named list of parameters to pass to
<a href="party.html#topic+mob">mob</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+MOB-class">MOB</a>
</p>


<h3>See Also</h3>

<p><a href="party.html#topic+mob">mob</a>
</p>

<hr>
<h2 id='MOB-class'>MOB</h2><span id='topic+MOB-class'></span>

<h3>Description</h3>

<p>MOB is a container class for trees created by <a href="party.html#topic+mob">mob</a>.
</p>


<h3>Value</h3>

<p>An object of class MOB
</p>


<h3>Slots</h3>


<dl>
<dt><code>tree</code></dt><dd><p>An object of class <a href="party.html#topic+BinaryTree-class">BinaryTree-class</a> produced by
<a href="party.html#topic+mob">mob</a>.</p>
</dd>
<dt><code>data</code></dt><dd><p>Training data.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>Control parameters</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="party.html#topic+mob">mob</a>, <a href="party.html#topic+BinaryTree-class">BinaryTree-class</a>
</p>

<hr>
<h2 id='na2empty'>na2empty</h2><span id='topic+na2empty'></span>

<h3>Description</h3>

<p>Replace all instances of NA in character variable with empty
string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na2empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na2empty_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with NA values replaced with empty string.
</p>


<h3>See Also</h3>

<p><a href="#topic+unfactor">unfactor</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create character variable with missing values
ex1 &lt;- c( 'A', NA, 'B', NA, 'C', NA )
ex1

## Replace NAs with empty string
ex1 &lt;- na2empty( ex1 )
ex1
</code></pre>

<hr>
<h2 id='parse_party'>parse_party</h2><span id='topic+parse_party'></span>

<h3>Description</h3>

<p>Parse output from ctree() and mob() functions in party package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_party(tree, data = NULL, include_subgroups = FALSE, digits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_party_+3A_tree">tree</code></td>
<td>
<p>An object of class BinaryTree or mob resulting from a call to the
ctree() or mob() function.</p>
</td></tr>
<tr><td><code id="parse_party_+3A_data">data</code></td>
<td>
<p>data.frame containing covariates used to create tree.</p>
</td></tr>
<tr><td><code id="parse_party_+3A_include_subgroups">include_subgroups</code></td>
<td>
<p>A logical value indicating whether or not to include
a string representation of the subgroups in the results. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="parse_party_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Collects text output from party::ctree() or party::mob(), parses the
splits, and populates a data.frame with the relevant data.
</p>


<h3>Value</h3>

<p>A data.frame containing a parsed tree.
</p>


<h3>See Also</h3>

<p><a href="party.html#topic+ctree">ctree</a>, <a href="party.html#topic+mob">mob</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace( "party", quietly = TRUE )
requireNamespace( "modeltools", quietly = TRUE )
## From party::ctree() examples:
set.seed(290875)
## regression
airq &lt;- subset(airquality, !is.na(Ozone))
airct &lt;- party::ctree(Ozone ~ ., data = airq, 
               controls = party::ctree_control(maxsurrogate = 3))

## Parse the results into a new data.frame
ex1 &lt;- parse_party( airct )
ex1

## From party::mob() examples:
data("BostonHousing", package = "mlbench")
## and transform variables appropriately (for a linear regression)
BostonHousing$lstat &lt;- log(BostonHousing$lstat)
BostonHousing$rm &lt;- BostonHousing$rm^2
## as well as partitioning variables (for fluctuation testing)
BostonHousing$chas &lt;- factor( BostonHousing$chas, levels = 0:1, 
                              labels = c("no", "yes") )
BostonHousing$rad &lt;- factor(BostonHousing$rad, ordered = TRUE)

## partition the linear regression model medv ~ lstat + rm
## with respect to all remaining variables:
fmBH &lt;- party::mob( medv ~ lstat + rm | zn + indus + chas + nox + age + 
             dis + rad + tax + crim + b + ptratio,
             control = party::mob_control(minsplit = 40), data = BostonHousing, 
             model = modeltools::linearModel )

## Parse the results into a new data.frame
ex2 &lt;- parse_party( fmBH )
ex2
</code></pre>

<hr>
<h2 id='parse_rpart'>parse_rpart</h2><span id='topic+parse_rpart'></span>

<h3>Description</h3>

<p>Extract splits from an rpart.object returned from a call to
rpart().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_rpart(tree, include_subgroups = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_rpart_+3A_tree">tree</code></td>
<td>
<p>An rpart.object returned from call to rpart().</p>
</td></tr>
<tr><td><code id="parse_rpart_+3A_include_subgroups">include_subgroups</code></td>
<td>
<p>A logical value indicating whether or not to include
a string representation of the subgroups in the results. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes as its input an rpart.object returned from a
call to rpart.  It parses this rpart.object using rpart_nodes() and returns
the splits in the tree. The data returned include the NodeID of the node to
split, the NodeID of that node's parent, the NodeID of that nodes left child
and right child, the number of observations in that node, the variable
used in the split, the data type for the splitting variable, the logic
indicating which observations will go to the node's left child, the
value of the splitting variable at which the split ocurrs, the mean response
value of the node, and (optionally) the string representation of the node's
subgroup. A node's subgroup is defined by the sequence of splits from the
root to that node.
</p>


<h3>Value</h3>

<p>A data.frame containing a parsed tree.
</p>


<h3>See Also</h3>

<p><a href="#topic+rpart_nodes">rpart_nodes</a>, <a href="rpart.html#topic+rpart">rpart</a>, <a href="rpart.html#topic+rpart.object">rpart.object</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace( "rpart", quietly = TRUE )
## Generate example data containing response, treatment, and covariates
N &lt;- 50
continuous_response = runif( min = 0, max = 20, n = N )
trt &lt;- sample( c('Control','Experimental'), size = N, prob = c(0.4,0.6),
              replace = TRUE )
X1 &lt;- runif( N, min = 0, max = 1 )
X2 &lt;- runif( N, min = 0, max = 1 )
X3 &lt;- sample( c(0,1), size = N, prob = c(0.2,0.8), replace = TRUE )
X4 &lt;- sample( c('A','B','C'), size = N, prob = c(0.6,0.3,0.1), replace = TRUE )

## Fit an rpart model
fit &lt;- rpart::rpart( continuous_response ~ trt + X1 + X2 + X3 + X4,
                     control = rpart::rpart.control( maxdepth = 3L ) )
fit

## Parse the results into a new data.frame
ex1 &lt;- parse_rpart( fit, include_subgroups = TRUE )
ex1
</code></pre>

<hr>
<h2 id='partition'>partition</h2><span id='topic+partition'></span>

<h3>Description</h3>

<p>Partitions a vector x into n groups of roughly equal size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_+3A_x">x</code></td>
<td>
<p>Vector to partition.</p>
</td></tr>
<tr><td><code id="partition_+3A_n">n</code></td>
<td>
<p>Number of (roughly) equally-sized groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of partitions of the vector x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
partition( x, 3 )
</code></pre>

<hr>
<h2 id='permutation'>permutation</h2><span id='topic+permutation'></span>

<h3>Description</h3>

<p>Permute response, treatment, or response for one treatment arm only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutation(response = NULL, trt = NULL, permute_arm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permutation_+3A_response">response</code></td>
<td>
<p>Response (or other) variable(s) to be permuted. This can be a
data.frame of multiple variables (e.g. a data.frame of covariates or a
multivariate response).</p>
</td></tr>
<tr><td><code id="permutation_+3A_trt">trt</code></td>
<td>
<p>Treatment variable.</p>
</td></tr>
<tr><td><code id="permutation_+3A_permute_arm">permute_arm</code></td>
<td>
<p>reatment arm to permute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a response variable is provided and treatment is not provided 
the response variable is permuted.
</p>
<p>If a treatment variable is provided and response is not provided 
the treatment variable is permuted.
</p>
<p>If a response variable and treatment variable and permute are provided the
response variable is permuted only for the treatment arm indicated by
permute_arm.
</p>
<p>If a response variable and treatment variable are provided, but permute_arm
</p>


<h3>Value</h3>

<p>If permuting response or treatment, returns vector of permuted response
or treatment. If permuting response and treatment, returns a list of
permuted response and treatment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 20
x &lt;- data.frame( 1:N )
names( x ) &lt;- "response"
x$trt &lt;- factor( c( rep( "Experimental", 9 ), rep( "Control", N - 9 ) ) )
x$time &lt;- x$response
x$event &lt;- 0:1

## Permute treatment variable
ex1 &lt;- x[,c("response","trt")]
ex1$permuted_trt &lt;- permutation( trt = ex1$trt )

## Permute response variable
ex2 &lt;- x[,c("response","trt")]
ex2$permuted_response &lt;- permutation( response = ex2$response )

## Permute the response for treatment arm only
ex3 &lt;- x[,c("response","trt")]
permuted3 &lt;- permutation( response = ex3$response, trt = ex3$trt, permute_arm = "Experimental" )
names( permuted3 ) &lt;- paste( "permuted_", names(permuted3), sep = "" )
ex3 &lt;- cbind( ex3, permuted3 )

## Permute response and treatment together
ex4 &lt;- x[,c("response","trt")]
permutation_list4 &lt;- permutation( response = ex4$response, trt = ex4$trt )
ex4$permuted_response &lt;- permutation_list4$response
ex4$permuted_trt &lt;- permutation_list4$trt

## Permute a survival response for treatment arm only
ex5 &lt;- x[,c("time","event","trt")]
permuted5 &lt;- permutation( response = ex5[,c("time","event")], trt = ex5$trt,
                          permute_arm = "Experimental" )
names( permuted5 ) &lt;- paste( "permuted_", names(permuted5), sep = "" )
ex5 &lt;- cbind( ex5, permuted5 )

## Permute a survival outcome and treatment together
ex6 &lt;- x[,c("time","event","trt")]
permutation_list6 &lt;- permutation( response = ex6[,c("time","event")], trt = ex6$trt )
ex6$permuted_time &lt;- permutation_list6$response$time
ex6$permuted_event &lt;- permutation_list6$response$event
</code></pre>

<hr>
<h2 id='quantile_response'>quantile_response</h2><span id='topic+quantile_response'></span>

<h3>Description</h3>

<p>Return the specified quantile of the response distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_response(data, scoring_function_parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_response_+3A_data">data</code></td>
<td>
<p>data.frame containing response data</p>
</td></tr>
<tr><td><code id="quantile_response_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>named list of scoring function control
parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the response quantiles associated with a
specified percentile. The default behavior is to return the median &ndash; i.e.
50th-percentile.
</p>


<h3>Value</h3>

<p>A quantile of the response variable.
</p>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>, <a href="#topic+diff_quantile_response">diff_quantile_response</a>, <a href="stats.html#topic+quantile">quantile</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate example data containing response and treatment
N &lt;- 100
y = runif( min = 0, max = 20, n = N )
df &lt;- as.data.frame( y )
names( df )  &lt;- "y"
df$trt &lt;- sample( c('Control','Experimental'), size = N, prob = c(0.4,0.6),
                  replace = TRUE )

## Default behavior is to return the median
quantile_response( df )
median( df$y ) # should match previous result from quantile_response

## Get Q1 response
quantile_response( df, scoring_function_parameters = list( percentile = 0.25 ) )
quantile( df$y, 0.25 ) # should match previous result from quantile_response

## Get max response
quantile_response( df, scoring_function_parameters = list( percentile = 1 ) )
max( df$y ) # should match previous result from quantile_response
</code></pre>

<hr>
<h2 id='reset_factor_levels'>reset_factor_levels</h2><span id='topic+reset_factor_levels'></span>

<h3>Description</h3>

<p>Reset the list of levels associated with a factor variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_factor_levels(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reset_factor_levels_+3A_data">data</code></td>
<td>
<p>A data.frame containing factor variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After subsetting a factor variable some factor levels that were
previously present may be lost. This is particularly true for relatively rare
factor levels. This function resets the list of factor levels to include only
the levels currently present.
</p>


<h3>Value</h3>

<p>A data.frame with factor variable that now have reset levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex1 = as.factor( c( rep('A', 3), rep('B',3), rep('C',3) ) )

## The levels associated with the factor variable include the letters A, B, C
ex1  # Levels are A, B, C

## If the last three observations are dropped the value C no longer occurs
## in the data, but the list of associated factor levels still contains C.
## This mismatch between the data and the list of factor levels may cause
## problems, particularly for algorithms that iterate over the factor levels.

ex1 &lt;- ex1[1:6]
ex1 # Levels are still A, B, C, but the data contains only A and B

## If the factor levels are reset the data and list of levels will once again
## be consistent
ex1 &lt;- reset_factor_levels( ex1 )
ex1 # Levels now contain only A and B, which is consistent with data
</code></pre>

<hr>
<h2 id='rpart_nodes'>rpart_nodes</h2><span id='topic+rpart_nodes'></span>

<h3>Description</h3>

<p>Extract node information from an rpart.object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpart_nodes(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpart_nodes_+3A_tree">tree</code></td>
<td>
<p>An rpart.object returned from call to rpart().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Information about nodes and splits returned in an rpart.object
is contained in strings printed to the console. This function parses those
strings and populates a data.frame.
</p>


<h3>Value</h3>

<p>A data.frame containing the nodes of a parsed tree.
</p>


<h3>See Also</h3>

<p><a href="rpart.html#topic+rpart">rpart</a>, <a href="rpart.html#topic+rpart.object">rpart.object</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace( "rpart", quietly = TRUE )
## Generate example data containing response, treatment, and covariates
N &lt;- 50
continuous_response = runif( min = 0, max = 20, n = N )
binary_response &lt;- sample( c('A','B'), size = N, prob = c(0.5,0.5),
                           replace = TRUE )
trt &lt;- sample( c('Control','Experimental'), size = N, prob = c(0.4,0.6),
               replace = TRUE )
X1 &lt;- runif( N, min = 0, max = 1 )
X2 &lt;- runif( N, min = 0, max = 1 )
X3 &lt;- sample( c(0,1), size = N, prob = c(0.2,0.8), replace = TRUE )
X4 &lt;- sample( c('A','B','C'), size = N, prob = c(0.6,0.3,0.1), replace = TRUE )

## Fit an rpart model with continuous response (i.e. regression)
fit1 &lt;- rpart::rpart( continuous_response ~ trt + X1 + X2 + X3 + X4 )
fit1

## Parse the results into a new data.frame
ex1 &lt;- rpart_nodes( fit1 )
ex1

## Fit an rpart model with binary response (i.e. classification)
fit2 &lt;- rpart::rpart( binary_response ~ trt + X1 + X2 + X3 + X4 )
fit2
</code></pre>

<hr>
<h2 id='rpart_wrapper'>rpart_wrapper</h2><span id='topic+rpart_wrapper'></span>

<h3>Description</h3>

<p>A wrapper function to rpart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpart_wrapper(
  response,
  response_type = NULL,
  covariates = NULL,
  tree_builder_parameters = NULL,
  prune = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpart_wrapper_+3A_response">response</code></td>
<td>
<p>Response variable to use in rpart model.</p>
</td></tr>
<tr><td><code id="rpart_wrapper_+3A_response_type">response_type</code></td>
<td>
<p>Class of response variable.</p>
</td></tr>
<tr><td><code id="rpart_wrapper_+3A_covariates">covariates</code></td>
<td>
<p>Covariates to use in rpart model.</p>
</td></tr>
<tr><td><code id="rpart_wrapper_+3A_tree_builder_parameters">tree_builder_parameters</code></td>
<td>
<p>A named list of parameters to pass to rpart.
This includes all input parameters that rpart can take.</p>
</td></tr>
<tr><td><code id="rpart_wrapper_+3A_prune">prune</code></td>
<td>
<p>Logical variable indicating whether the tree shold be
pruned to the subtree with the smallest cross-validation error. Defaults to
FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a wrapper to rpart that provides a convenient
interface for specifying the response variable and covariates for the
rpart model. The user may indicate whether the tree should be pruned to
the size that yields the smallest cross-validation error. An rpart.object
is returned.
</p>


<h3>Value</h3>

<p>An object of class rpart.
</p>


<h3>See Also</h3>

<p><a href="rpart.html#topic+rpart">rpart</a>, <a href="rpart.html#topic+rpart.object">rpart.object</a>,
<a href="survival.html#topic+Surv">Surv</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate example data containing response, treatment, and covariates
N &lt;- 100
continuous_response = runif( min = 0, max = 20, n = N )
trt &lt;- sample( c('Control','Experimental'), size = N, prob = c(0.4,0.6), replace = TRUE )
X1 &lt;- runif( N, min = 0, max = 1 )
X2 &lt;- runif( N, min = 0, max = 1 )
X3 &lt;- sample( c(0,1), size = N, prob = c(0.2,0.8), replace = TRUE )
X4 &lt;- sample( c('A','B','C'), size = N, prob = c(0.6,0.3,0.1), replace = TRUE )
covariates &lt;- data.frame( trt )
names( covariates ) &lt;- "trt"
covariates$X1 &lt;- X1
covariates$X2 &lt;- X2
covariates$X3 &lt;- X3
covariates$X4 &lt;- X4
## Fit an rpart model
ex1 &lt;- rpart_wrapper( response = continuous_response, covariates = covariates )
ex1
</code></pre>

<hr>
<h2 id='subgroup'>subgroup</h2><span id='topic+subgroup'></span>

<h3>Description</h3>

<p>Subset a user-provided data.frame according to the subgroup
specified by a node in a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subgroup(splits, node, xdata, ydata = xdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subgroup_+3A_splits">splits</code></td>
<td>
<p>A data.frame of splits returned from a call to parse_rpart().</p>
</td></tr>
<tr><td><code id="subgroup_+3A_node">node</code></td>
<td>
<p>The NodeID of the node defining the desired split.</p>
</td></tr>
<tr><td><code id="subgroup_+3A_xdata">xdata</code></td>
<td>
<p>The data.frame of covariates to subset according to the subgroup
definition.</p>
</td></tr>
<tr><td><code id="subgroup_+3A_ydata">ydata</code></td>
<td>
<p>The associated vector of response values to subset according to
the subgroup definition. (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After the splits from an rpart.object are extracted by a call to
parse_rpart(), the extracted splits define a subgroup for each node. This
subgroup can be used to subset a user-provided data.frame. This function takes
as its input a data.frame of splits obtained from a call to parse_rpart(), a
NodeID indicating which node specifies the desired subgroup, a data.frame of
covariates to subset, and (optionally) the associated response data to subset.
If only xdata is specified by the user, the subset of xdata implied by the
subgroup will be returned. If xdata and ydata are provided by the user, the
subset of ydata will be returned (xdata is still required from the user
because the subsetting is computed on the covariate values even when the data
returned to the user are from ydata).
</p>


<h3>Value</h3>

<p>A data.frame containing the data consistent with the specified
subgroup.
</p>


<h3>See Also</h3>

<p><a href="#topic+parse_rpart">parse_rpart</a>, <a href="rpart.html#topic+rpart">rpart</a>, <a href="rpart.html#topic+rpart.object">rpart.object</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>requireNamespace( "rpart", quietly = TRUE )

## Generate example data containing response, treatment, and covariates
N &lt;- 20
continuous_response = runif( min = 0, max = 20, n = N )
trt &lt;- sample( c('Control','Experimental'), size = N, prob = c(0.4,0.6), replace = TRUE )
X1 &lt;- runif( N, min = 0, max = 1 )
X2 &lt;- runif( N, min = 0, max = 1 )
X3 &lt;- sample( c(0,1), size = N, prob = c(0.2,0.8), replace = TRUE )
X4 &lt;- sample( c('A','B','C'), size = N, prob = c(0.6,0.3,0.1), replace = TRUE )

covariates &lt;- data.frame( trt )
names( covariates ) &lt;- "trt"
covariates$X1 &lt;- X1
covariates$X2 &lt;- X2
covariates$X3 &lt;- X3
covariates$X4 &lt;- X4

## Fit an rpart model
fit &lt;- rpart::rpart( continuous_response ~ trt + X1 + X2 + X3 + X4 )

## Return parsed splits with subgroups
splits1 &lt;- parse_rpart( fit, include_subgroups = TRUE )
splits1

## Subset covariate data according to split for NodeID 3
ex1 &lt;- subgroup( splits = splits1, node = 3, xdata = covariates )
ex1

## Subset response data according to split for NodeID 3
ex2 &lt;- subgroup( splits = splits1, node = 3, xdata = covariates, ydata = continuous_response )
ex2
</code></pre>

<hr>
<h2 id='subsample'>subsample</h2><span id='topic+subsample'></span>

<h3>Description</h3>

<p>Generate a vector of subsamples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample(
  x,
  trt = NULL,
  trt_control = "Control",
  training_fraction = NULL,
  validation_fraction = NULL,
  test_fraction = NULL,
  n_samples = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsample_+3A_x">x</code></td>
<td>
<p>&lt;Source data to subsample.</p>
</td></tr>
<tr><td><code id="subsample_+3A_trt">trt</code></td>
<td>
<p>Treatment variable. (optional)</p>
</td></tr>
<tr><td><code id="subsample_+3A_trt_control">trt_control</code></td>
<td>
<p>Value for treatment control arm. Defaulte value is
'Control'.</p>
</td></tr>
<tr><td><code id="subsample_+3A_training_fraction">training_fraction</code></td>
<td>
<p>Fraction of source data to include in training
subsample.</p>
</td></tr>
<tr><td><code id="subsample_+3A_validation_fraction">validation_fraction</code></td>
<td>
<p>Fraction of source data to include in validation
subsample.</p>
</td></tr>
<tr><td><code id="subsample_+3A_test_fraction">test_fraction</code></td>
<td>
<p>Fraction of source data to include in test subsample.</p>
</td></tr>
<tr><td><code id="subsample_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of subsamples to generate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each subsample will contain training, validation, and test data in
proportions specified by the user. If a treatment variable is supplied the
ratio of treatments will be preserved as closely as possible.
</p>


<h3>Value</h3>

<p>Vector of objects of class Subsample.
</p>


<h3>See Also</h3>

<p><a href="#topic+Subsample-class">Subsample</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate example data frame containing response and treatment
N &lt;- 50
x &lt;- data.frame( runif( N ) )
names( x ) &lt;- "response"
x$treatment &lt;- factor( sample( c("Control","Experimental"), size = N,
                       prob = c(0.8,0.2), replace = TRUE ) )

## Generate two subsamples
ex1 &lt;- subsample( x,
                  training_fraction = 0.9,
                  test_fraction = 0.1,
                  n_samples = 2 )

## Generate two subsamples preserving treatment ratio
ex2 &lt;- subsample( x,
                  trt = x$treatment,
                  trt_control = "Control",
                  training_fraction = 0.7,
                  validation_fraction = 0.2,
                  test_fraction = 0.1,
                  n_samples = 2 )
</code></pre>

<hr>
<h2 id='Subsample-class'>Subsample</h2><span id='topic+Subsample-class'></span>

<h3>Description</h3>

<p>Subsmaple is a container class for subsamples.
</p>


<h3>Value</h3>

<p>Object of class
</p>


<h3>Slots</h3>


<dl>
<dt><code>training</code></dt><dd><p>Training data.</p>
</dd>
<dt><code>validation</code></dt><dd><p>Validation data.</p>
</dd>
<dt><code>test</code></dt><dd><p>Test data.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+subsample">subsample</a>
</p>

<hr>
<h2 id='summary+2CTSDT-method'>Summary function for class TSDT.</h2><span id='topic+summary+2CTSDT-method'></span>

<h3>Description</h3>

<p>Summary function for class TSDT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TSDT'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CTSDT-method_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+TSDT-class">TSDT</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the superior subgroups identified by TSDT.
</p>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>
</p>

<hr>
<h2 id='survival_time_quantile'>survival_time_quantile</h2><span id='topic+survival_time_quantile'></span>

<h3>Description</h3>

<p>Computes the quantile of a survival function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survival_time_quantile(data, scoring_function_parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survival_time_quantile_+3A_data">data</code></td>
<td>
<p>data.frame containing response data</p>
</td></tr>
<tr><td><code id="survival_time_quantile_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>named list of scoring function control parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the quantile of a survival function. The user specifies the
percentile associated with the desired quantile in
scoring_function_parameters. The default is percentile = 0.50, which returns
the median survival. A user may also specify a value for the trt_arm parameter
in scoring_function_parameters to compute the survival quantile for only one
arm.
</p>


<h3>Value</h3>

<p>A quantile of the response survival time.
</p>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>, <a href="#topic+diff_survival_time_quantile">diff_survival_time_quantile</a>,
<a href="survival.html#topic+Surv">Surv</a>, <a href="survival.html#topic+coxph">coxph</a>, <a href="survival.html#topic+survfit">survfit</a>,
<a href="survival.html#topic+survreg">survreg</a>, <a href="survival.html#topic+quantile.survfit">quantile.survfit</a>,
<a href="survival.html#topic+predict.coxph">predict.coxph</a>, <a href="survival.html#topic+predict.survreg">predict.survreg</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 200
time &lt;- runif( min = 0, max = 20, n = N )
event &lt;- sample( c(0,1), size = N, prob = c(0.2,0.8), replace = TRUE )
trt &lt;- sample( c('Control','Experimental'), size = N, prob = c(0.4,0.6), replace = TRUE )
df &lt;- data.frame( y = survival::Surv( time, event ), trt = trt )

## Compute median survival time in Experimental treatment arm.
ex1 &lt;- survival_time_quantile( data = df,
                               scoring_function_parameters = list( trt_var = "trt",
                               trt_arm = "Experimental",
                               percentile = 0.50 ) )

## Compute Q1 survival time for all data. It is necessary here to explicitly
## specify trt = NULL because a variable called trt exists in df. The default
## behavior is to use this variable as the treatment variable. To override
## the default behavior trt = NULL is included in scoring_function_parameters.
ex2 &lt;- survival_time_quantile( data = df,
                               scoring_function_parameters = list( trt = NULL, percentile = 0.25 ) )
</code></pre>

<hr>
<h2 id='treatment_effect'>treatment_effect</h2><span id='topic+treatment_effect'></span>

<h3>Description</h3>

<p>Compute treatment effect as mean( treatment response ) - mean( control response )
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treatment_effect(data, scoring_function_parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treatment_effect_+3A_data">data</code></td>
<td>
<p>data.frame containing response data</p>
</td></tr>
<tr><td><code id="treatment_effect_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>named list of scoring function control parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will compute the treatment for the response. The
treatment effect is computed as the difference in means between the non-control
treatment arm and the control treatment arm. The user must provide the
treatment variable as well as the control value.
</p>


<h3>Value</h3>

<p>The difference in mean response across treatment arms.
</p>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>, <a href="#topic+mean_response">mean_response</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100

df &lt;- data.frame( continuous_response = numeric(N),
                  trt = integer(N) )

df$continuous_response &lt;- runif( min = 0, max = 20, n = N )
df$trt &lt;- sample( c(0,1), size = N, prob = c(0.4,0.6), replace = TRUE )

# Compute the treatment effect
treatment_effect( df, list( y_var = 'continuous_response', trt_control = 0 ) )

# Function return value should match this value
mean( df$continuous_response[df$trt == 1] ) - mean( df$continuous_response[df$trt == 0] )
</code></pre>

<hr>
<h2 id='TSDT'>Treatment-Specific Subgroup Detection Tool</h2><span id='topic+TSDT'></span>

<h3>Description</h3>

<p>Implements a method for identifying subgroups with superior response relative
to the overall sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSDT(
  response = NULL,
  response_type = NULL,
  survival_model = "kaplan-meier",
  percentile = 0.5,
  tree_builder = "rpart",
  tree_builder_parameters = list(),
  covariates,
  trt = NULL,
  trt_control = 0,
  permute_method = NULL,
  permute_arm = NULL,
  n_samples = 1,
  desirable_response = NULL,
  sampling_method = "bootstrap",
  inbag_proportion = 0.5,
  scoring_function = NULL,
  scoring_function_parameters = list(),
  inbag_score_margin = 0,
  oob_score_margin = 0,
  eps = 1e-05,
  min_subgroup_n_control = NULL,
  min_subgroup_n_trt = NULL,
  min_subgroup_n_oob_control = NULL,
  min_subgroup_n_oob_trt = NULL,
  maxdepth = .Machine$integer.max,
  rootcompete = 0,
  competedepth = 1,
  strength_cutpoints = c(0.1, 0.2, 0.3),
  n_permutations = 0,
  n_cpu = 1,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSDT_+3A_response">response</code></td>
<td>
<p>Response variable.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_response_type">response_type</code></td>
<td>
<p>Data type of response. Must be one of binary, continuous,
survival. If none provided it will be inferred from the data type of response.
(optional)</p>
</td></tr>
<tr><td><code id="TSDT_+3A_survival_model">survival_model</code></td>
<td>
<p>The model to use for a survival response. Defaults to
kaplan-meier. Other possible values are: coxph, fleming-harrington, fh2,
weibull, exponential, gaussian, logistic, lognormal, and loglogistic.
(optional)</p>
</td></tr>
<tr><td><code id="TSDT_+3A_percentile">percentile</code></td>
<td>
<p>For a two-arm study this parameter specifies a test for
the difference in response percentile across the two treatment arms. For a
continuous response the default value for percentile is NULL. Instead, the
difference in mean response is computed by default for a continuous response.
If the user provides a values of percentile = 0.50 then the difference in
median response would be computed. For a survival outcome, the default value
for percentile is 0.50, which computes the difference in median survival.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_tree_builder">tree_builder</code></td>
<td>
<p>The algorithm to use for building the trees. Defaults to
rpart. Other possible values include ctree and mob (both from the party
package). (optional)</p>
</td></tr>
<tr><td><code id="TSDT_+3A_tree_builder_parameters">tree_builder_parameters</code></td>
<td>
<p>A named list of parameters to pass to the
tree-builder. The default tree-builder is rpart. In this case, the parameters
passed here would be rpart parameters. Examples might include parameters such
as control, cost, weights, na.action, etc. Consult the rpart documentation (or
the documentation of your selected tree-builder) for a complete list. (optional)</p>
</td></tr>
<tr><td><code id="TSDT_+3A_covariates">covariates</code></td>
<td>
<p>A data.frame containing the covariates.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_trt">trt</code></td>
<td>
<p>Treatment variable. Only needed if there are two treatment arms.
(optional)</p>
</td></tr>
<tr><td><code id="TSDT_+3A_trt_control">trt_control</code></td>
<td>
<p>Value for treatment control arm. This parameter is relevant
only for two-arm data. (defaults to 0)</p>
</td></tr>
<tr><td><code id="TSDT_+3A_permute_method">permute_method</code></td>
<td>
<p>Indicates whether only the response variable should be
permuted in the computation of the p-value, or the response and treatment
variable should be permuted together (preserving the treatment-response
correlation, but eliminating the correlation with the covariates), or the
response variable should be permuted within one treatment arm only. The
parameter values for these permutation schemes are (respectively) simple,
permute_response_and_treatment, and permute_response_one_arm. See permute_arm
to specify which treatment arm is to be permuted. The default permutation
scheme is response_one_arm. As noted in the documentation for the permute_arm
parameter is to permute the non-control arm. Taken together, this implies the
default permutation method for p-value computation is to permute the response
in the non-control arm only. For one-arm data only the response is permuted.
(optional)</p>
</td></tr>
<tr><td><code id="TSDT_+3A_permute_arm">permute_arm</code></td>
<td>
<p>Which treatment arm should be permuted? Defaults to the
experimental treatment arm &ndash; i.e. the treatment arm not matching the value
provided in trt_control. For one-arm data only the response is permuted.
(optional)</p>
</td></tr>
<tr><td><code id="TSDT_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of TSDT_Samples to draw.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_desirable_response">desirable_response</code></td>
<td>
<p>Direction of desirable response. Valid values are
'increasing' or 'decreasing'. The default value is 'increasing'. It is
important to note that although the parameter is called desirable_response, it
actually refers to the desirable direction of scoring function values. In most
cases there is a positive correlation bewteen the response and scoring
function values &ndash; i.e. as the response increases the scoring function also
increases. One instance for which this relationship between response and
scoring function may not hold is when mean_deviance_residuals or
diff_mean_deviance_residuals is used as the scoring function. See the help for
these scorings function for further details.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_sampling_method">sampling_method</code></td>
<td>
<p>Sampling method used to populate samples for TSDT
in-bag and out-of-bag data. Must be either bootstrap or subsample. Default
is bootstrap.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_inbag_proportion">inbag_proportion</code></td>
<td>
<p>The proportion of the data to use as the in-bag
subset when sampling_method is subsample.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_scoring_function">scoring_function</code></td>
<td>
<p>Scoring function to compute treatment effect. Links to
several possible scoring functions are provided in the See Also section below.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_scoring_function_parameters">scoring_function_parameters</code></td>
<td>
<p>Parameters passed to the scoring function.
As an example, the scoring function quantile_response takes a parameter
&quot;percentile&quot; which indicates the desired percentile of the response distribution.
Thus, if the median response is desired, this parameter could be set as follows:
scoring_function_parameters = list( percentile = 0.50 ). Most of the built-in
scoring functions have sensible defaults for the scoring function parameters
so it is not necessary to specify them explicitly in the call to TSDT. But this
parameter could be very useful for user-defined custom scoring functions.
(optional)</p>
</td></tr>
<tr><td><code id="TSDT_+3A_inbag_score_margin">inbag_score_margin</code></td>
<td>
<p>Required margin above overall mean for a subgroup to
be considered superior. If a subgroup mean must be 10% larger than the overall
subgroup mean to be superior then inbag_score_margin = 0.10. If
desirable_response = &quot;decreasing&quot; then inbag_score_margin should be negative
or zero.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_oob_score_margin">oob_score_margin</code></td>
<td>
<p>Similar to inbag_score_margin but for classifying
out-of-bag subgroups as superior.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_eps">eps</code></td>
<td>
<p>Tolerance value for floating-point precision. The default is 1E-5. (optional)</p>
</td></tr>
<tr><td><code id="TSDT_+3A_min_subgroup_n_control">min_subgroup_n_control</code></td>
<td>
<p>Minimum number of Control arm observations in an
in-bag subgroup. A value greater than or equal to one will be interpreted as
the required minimum number of observations. A value between zero and one
will be interpreted as a proportion of the in-bag Control observations. For a
bootstrapped in-bag sample the default for this parameter is 10
of Control observations in the overall sample. For an in-bag sample obtained
via subsampling the default value is the inbag_proportion times 10
number of Control observations in the overall sample.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_min_subgroup_n_trt">min_subgroup_n_trt</code></td>
<td>
<p>Minimum number of Experimental arm observations in
an in-bag subgroup. A value greater than or equal to one will be interpreted
as the required minimum number of observations. A value between zero and one
will be interpreted as a proportion of the in-bag Experimental observations.
For a bootstrapped in-bag sample the default for this parameter is 10
number of Experimental observations in the overall sample. For an in-bag
sample obtained via subsampling the default value is the inbag_proportion
times 10% of the number of Experimental observations in the overall sample.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_min_subgroup_n_oob_control">min_subgroup_n_oob_control</code></td>
<td>
<p>Minimum number of Control arm observations
in an out-of-bag subgroup. A value greater than or equal to one will be
interpreted as the required minimum number of observations. A value between
zero and one will be interpreted as a proportion of the out-of-bag Control
observations. For a bootstrapped out-of-bag sample the default for this
parameter is exp(-1)*10% of the number of Control observations in the overall
sample. For an out-of-bag sample obtained via subsampling the default value
is the inbag_proportion times (1-inbag_proportion)*10
Control observations in the overall sample.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_min_subgroup_n_oob_trt">min_subgroup_n_oob_trt</code></td>
<td>
<p>Minimum number of Experimental arm observations
in an out-of-bag subgroup. A value greater than or equal to one will be
interpreted as the required minimum number of observations. A value between
zero and one will be interpreted as a proportion of the out-of-bag
Experimental observations. For a bootstrapped out-of-bag sample the default
for this parameter is exp(-1)*10% of the number of Experimental observations
in the overall sample. For an out-of-bag sample obtained via subsampling the
default value is the inbag_proportion times (1-inbag_proportion)*10% of the
number of Experimental  observations in the overall sample.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_maxdepth">maxdepth</code></td>
<td>
<p>Maximum depth of trees.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_rootcompete">rootcompete</code></td>
<td>
<p>Number of competitor splits to retain for root node split.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_competedepth">competedepth</code></td>
<td>
<p>Depth of competitor split trees (defaults to 1)</p>
</td></tr>
<tr><td><code id="TSDT_+3A_strength_cutpoints">strength_cutpoints</code></td>
<td>
<p>Cutpoints for permuted p-values to classify a
subgroup as Strong, Moderate, Weak, or Not Confirmed. The default cutpoints are
0.10, 0.20, and 0.30 for Strong, Moderate, and Weak subgroups, respectively. (optional)</p>
</td></tr>
<tr><td><code id="TSDT_+3A_n_permutations">n_permutations</code></td>
<td>
<p>Number of permutations to compute for adjusted p-value.
Defaults to zero (no p-value computation). If p-values are desired, it is
recommended to use at least 500 permutations.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_n_cpu">n_cpu</code></td>
<td>
<p>Number of CPUs to use. Defaults to 1.</p>
</td></tr>
<tr><td><code id="TSDT_+3A_trace">trace</code></td>
<td>
<p>Report number of permutations computed as algorithm proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Treatment-Specific Subgroup Detection Tool (TSDT) creates several
bootstrapped samples from the input data. For each of these bootstrapped
samples the in-bag and out-of-bag data are retained. A tree is grown on the
in-bag data of each bootstrapped sample using the response variable and
supplied covariates. Each split in the tree defines a subgroup. The overall
mean response for the in-bag data is computed as well as the mean response
within each subgroup. Additionally, a scoring function is provided. Example
scoring functions might be mean response, difference in mean response between
treatment arms (i.e. treatment effect), or a quantile of the response (e.g.
median), or a difference in quantiles across treatment arms. Sensible
defaults are provided given the data type of the response and treatment
variables. The user can also specify a custom scoring function. The value of
the scoring function is computed for the overall in-bag data and each
subgroup. Subgroups with mean response larger than the overall in-bag mean
response and a mean scoring function value larger than the overall in-bag
scoring function value are identified as superior subgroups. This definition
of a superior subgroup assumes a larger value of the response variable is
desirable. If a smaller value of the response is desirable then subgroups
with mean response and mean scoring function smaller than the overall in-bag
mean are superior. The same computation of overall and subgroup mean
response and mean scoring function are done for the out-of-bag data. This is
repeated for all bootstrapped samples.  Measures of internal and external
consistency are then computed. Internal consistency is computed for each
subgroup that is identified as superior in one of the in-bag samples.
Internal consistency for each of these subgroups is the fraction of
bootstrapped samples where that subgroup is identified as superior in the
in-bag data. External consistency is also defined only for subgroups that
are identified as superior in at least one of the in-bag samples. For each
of these subgroups, external consistency is the number of bootstrapped
samples where the subgroup is defined as superior in the in-bag and
out-of-bag data divided by the number of bootstrapped samples where the
subgroup is identified as superior in the in-bag data. The internal and
external consistency results are returned for each subgroup that identified
as superior in the in-bag data of at least one bootstrapped sample. A score
for the overall strength of each subgroup is computed as the product of the
internal and external consistency. Optionally, a permutation-adjusted
p-value for the strength of each subgroup can be computed. Based on this
p-value subgroups are classified as strong, moderate, weak, or not
confirmed. A suggested cutoff for each subgroup is also provided. This is
helpful because two subgroups defined on the same continuous splitting
variable but with different cutpoints are considered equivalent. That is,
one subgroup X1&lt;0.6 and another X1&lt;0.7 would be considered equivalent and
listed in the results as X1&lt;xxxxx. (Note that X1&lt;0.6 and X1&gt;=0.7 would be
considered distinct subgroups and listed in the output as X1&lt;xxxxx and
X1&gt;=xxxxx, respectively.) So if a subgroup listed in the output as X1&lt;xxxxx
could actually represent many different numeric values for xxxxx it is
helpful to provide a final suggestion for the cutpoint. The algorithm
retains all the numeric values and uses the median as the suggested cutoff.
The user can also request the vector of numeric cutpoints and use any
function of their choosing to compute a suggested cutoff.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+TSDT-class">TSDT</a>
</p>


<h3>Author(s)</h3>

<p>Brian Denton <a href="mailto:denton_brian_david@lilly.com">denton_brian_david@lilly.com</a>,
Chakib Battioui <a href="mailto:battioui_chakib@lilly.com">battioui_chakib@lilly.com</a>,
Lei Shen <a href="mailto:shen_lei@lilly.com">shen_lei@lilly.com</a>
</p>


<h3>References</h3>

<p>Battioui, C., Shen, L., Ruberg, S., (2014). A Resampling-based Ensemble Tree Method to Identify Patient Subgroups with Enhanced Treatment Effect. JSM proceedings, 2014
</p>
<p>Shen, L., Battioui, C., Ding, Y., (2013). Chapter &quot;A Framework of Statistical methods for Identification of Subgroups with Differential Treatment Effects in Randomized Trials&quot; in the book &quot;Applied Statistics in Biomedicine and Clinical Trials Design&quot;
</p>


<h3>See Also</h3>

<p><a href="#topic+mean_response">mean_response</a>, <a href="#topic+quantile_response">quantile_response</a>,
<a href="#topic+diff_quantile_response">diff_quantile_response</a>, <a href="#topic+treatment_effect">treatment_effect</a>,
<a href="#topic+survival_time_quantile">survival_time_quantile</a>, <a href="#topic+diff_survival_time_quantile">diff_survival_time_quantile</a>,
<a href="#topic+mean_deviance_residuals">mean_deviance_residuals</a>, <a href="#topic+diff_mean_deviance_residuals">diff_mean_deviance_residuals</a>,
<a href="#topic+diff_restricted_mean_survival_time">diff_restricted_mean_survival_time</a>, <a href="#topic+TSDT-class">TSDT</a>,
<a href="rpart.html#topic+rpart">rpart</a>, <a href="party.html#topic+ctree">ctree</a>, <a href="party.html#topic+mob">mob</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create example data for constructing TSDT object
N &lt;- 200
continuous_response = runif( min = 0, max = 20, n = N )
trt &lt;- sample( c('Control','Experimental'), size = N, prob = c(0.4,0.6), replace = TRUE )
X1 &lt;- runif( N, min = 0, max = 1 )
X2 &lt;- runif( N, min = 0, max = 1 )
X3 &lt;- sample( c(0,1), size = N, prob = c(0.2,0.8), replace = TRUE )
X4 &lt;- sample( c('A','B','C'), size = N, prob = c(0.6,0.3,0.1), replace = TRUE )
covariates &lt;- data.frame( X1 )
covariates$X2 &lt;- X2
covariates$X3 &lt;- factor( X3 )
covariates$X4 &lt;- factor( X4 )


## In the following examples n_samples and n_permutations are set to small
## values so the examples complete quickly. The intent here is to provide
## a small functional example to demonstrate the structure of the output. In
## a real-world use of TSDT these values should be at least 100 and 500,
## respectively.

## Single-arm TSDT
ex1 &lt;- TSDT( response = continuous_response,
            covariates = covariates[,1:4],
            inbag_score_margin = 0,
            desirable_response = "increasing",
            n_samples = 5,       ## use value &gt;= 100 in real world application
            n_permutations = 5,  ## use value &gt;= 500 in real world application
            rootcompete = 1,
            maxdepth = 2 )

## Two-arm TSDT
ex2 &lt;- TSDT( response = continuous_response,
            trt = trt, trt_control = 'Control',
            covariates = covariates[,1:4],
            inbag_score_margin = 0,
            desirable_response = "increasing",
            oob_score_margin = 0,
            min_subgroup_n_control = 10,
            min_subgroup_n_trt = 20,
            maxdepth = 2,
            rootcompete = 1,
            n_samples = 5,      ## use value &gt;= 100 in real world application
            n_permutations = 5 ) ## use value &gt;= 500 in real world application
</code></pre>

<hr>
<h2 id='TSDT_CutpointDistribution-class'>TSDT_CutpointDistribution</h2><span id='topic+TSDT_CutpointDistribution-class'></span>

<h3>Description</h3>

<p>Implementation of TSDT_CutpointDistribution class. This class
continuous split variable. If the subgroup contains more than one split
variable a distribution of numeric cutpoints is collected for each continuous
split variable in the subgroup definition.
</p>


<h3>Value</h3>

<p>Object of class TSDT_CutpointDistribution
</p>


<h3>Slots</h3>


<dl>
<dt><code>Cutpoints</code></dt><dd><p>An object of class <a href="hash.html#topic+hash-class">hash-class</a></p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>, <a href="hash.html#topic+hash">hash</a>
</p>

<hr>
<h2 id='TSDT_Sample-class'>TSDT_Sample</h2><span id='topic+TSDT_Sample-class'></span>

<h3>Description</h3>

<p>TSDT_Sample is a container class containing the in-bag and
out-of-bag data from a subsampled or bootstrapped dataset. This container
class also contains a data.frame containing the parsed tree that is fit on the
in-bag data.
</p>


<h3>Value</h3>

<p>Object of class TSDT_Sample
</p>


<h3>Slots</h3>


<dl>
<dt><code>inbag</code></dt><dd><p>A data.frame containing in-bag data</p>
</dd>
<dt><code>oob</code></dt><dd><p>A data.frame containing out-of-bag data</p>
</dd>
<dt><code>subgroups</code></dt><dd><p>A data.frame containing a parsed tree</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>
</p>

<hr>
<h2 id='TSDT-class'>TSDT</h2><span id='topic+TSDT-class'></span>

<h3>Description</h3>

<p>TSDT is a container class for TSDT samples and metadata.
</p>


<h3>Value</h3>

<p>Object of class TSDT
</p>


<h3>Slots</h3>


<dl>
<dt><code>parameters</code></dt><dd><p>List of parameters used in construction of TSDT samples.</p>
</dd>
<dt><code>samples</code></dt><dd><p>Vector of <a href="#topic+TSDT_Sample-class">TSDT_Sample</a> objects.</p>
</dd>
<dt><code>superior_subgroups</code></dt><dd><p>data.frame containing summary statistics for superior
subgroups</p>
</dd>
<dt><code>cutpoints</code></dt><dd><p>An object of class  <a href="#topic+TSDT_CutpointDistribution-class">TSDT_CutpointDistribution</a>.</p>
</dd>
<dt><code>distributions</code></dt><dd><p>A list of distributions of TSDT statistics.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+TSDT">TSDT</a>, <a href="#topic+TSDT_Sample-class">TSDT_Sample</a>,
<a href="#topic+TSDT_CutpointDistribution-class">TSDT_CutpointDistribution</a>
</p>

<hr>
<h2 id='unfactor'>unfactor</h2><span id='topic+unfactor'></span>

<h3>Description</h3>

<p>Convert the factor columns of a data.frame to character or numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfactor(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfactor_+3A_data">data</code></td>
<td>
<p>A factor variable or a data.frame containing factor variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the levels of a factor variable in data represent numeric values
the variable will be converted to a numeric data type, otherwise it is
converted to a character data type.
</p>


<h3>Value</h3>

<p>A vector or data.frame no longer containing any factor variables.
</p>


<h3>See Also</h3>

<p><a href="#topic+na2empty">na2empty</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate example data.frame of factors with factor levels of numeric,
## character and mixed data types.
N &lt;- 20
ex1 &lt;- data.frame( factor( sample( c(0,1,NA), size = N, prob = c(0.4,0.3,0.3),
                           replace = TRUE ) )  )
names( ex1 ) &lt;- "num"
ex1$char &lt;- factor( sample( c("Control","Experimental", NA ), size = N,
                    prob = c(0.4,0.3,0.3), replace = TRUE ) )
ex1$mixed &lt;- factor( sample( c(10,'A',NA), size = N, prob = c(0.4,0.3,0.3),
                     replace = TRUE ) )

## Initially the data type of all variables in ex1 is factor
ex1
class( ex1$num )   #factor
class( ex1$char )  #factor
class( ex1$mixed ) #factor

## Now convert all factor variables to numeric or character
ex2 &lt;- unfactor( ex1 )
ex2

## The data types are now numeric or character
class( ex2$num )   # numeric
class( ex2$char )  # character
class( ex2$mixed ) # character

## The &lt;NA&gt; notation for missing factor values that have been converted to
## character can be changed to an empty string for easier reading by use of
## the function na2empty().
ex2$char &lt;- na2empty( ex2$char )
ex2$mixed &lt;- na2empty( ex2$mixed )
ex2
</code></pre>

<hr>
<h2 id='unpack_args'>unpack_args</h2><span id='topic+unpack_args'></span>

<h3>Description</h3>

<p>Assign the elements of a named list in current environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_args(args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_args_+3A_args">args</code></td>
<td>
<p>List of entities to be assigned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a list of named entities and assigns each element
of the list to its name in the calling environment.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+assign">assign</a>, <a href="base.html#topic+parent.frame">parent.frame</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a list of named elements
arglist &lt;- list( one = 1, two = 2, color = "blue" )

## The variables one, two, and color do not exist in the current environment
ls()

## Unpack the elements in arglist
unpack_args( arglist )

## Now the variables one, two, and color do exist in the current environment
ls()
one
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
