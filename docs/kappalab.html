<!DOCTYPE html><html><head><title>Help for package kappalab</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kappalab}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.capacity-methods'><p>Coercion method</p></a></li>
<li><a href='#as.card.capacity-methods'><p>Coercion method</p></a></li>
<li><a href='#as.card.game-methods'><p>Coercion method</p></a></li>
<li><a href='#as.card.set.func-methods'><p>Coercion method</p></a></li>
<li><a href='#as.game-methods'><p>Coercion method</p></a></li>
<li><a href='#as.Mobius.capacity-methods'><p>Coercion method</p></a></li>
<li><a href='#as.Mobius.card.set.func-methods'><p>Coercion method</p></a></li>
<li><a href='#as.Mobius.game-methods'><p>Coercion method</p></a></li>
<li><a href='#as.Mobius.set.func-methods'><p>Coercion method</p></a></li>
<li><a href='#as.set.func-methods'><p>Coercion method</p></a></li>
<li><a href='#capacity-class'><p>Class &quot;capacity&quot;</p></a></li>
<li><a href='#card.capacity-class'><p>Class &quot;card.capacity&quot;</p></a></li>
<li><a href='#card.game-class'><p>Class &quot;card.game&quot;</p></a></li>
<li><a href='#card.set.func'><p>Create objects representing cardinal set functions.</p></a></li>
<li><a href='#card.set.func-class'><p>Class &quot;card.set.func&quot;</p></a></li>
<li><a href='#Choquet.integral-methods'><p>Choquet integral</p></a></li>
<li><a href='#conjugate-methods'><p>The conjugate (or dual) transform</p></a></li>
<li><a href='#entropy-methods'><p>Normalized entropy of a capacity</p></a></li>
<li><a href='#entropy.capa.ident'><p>Unsupervised identification of a capacity from profiles</p></a></li>
<li><a href='#expect.Choquet.unif-methods'><p>Expectation and standard deviation of the Choquet integral in the</p>
uniform and normal cases</a></li>
<li><a href='#favor-methods'><p>Favor indices</p></a></li>
<li><a href='#game-class'><p>Class &quot;game&quot;</p></a></li>
<li><a href='#heuristic.ls.capa.ident'><p>Heuristic least squares capacity identification</p></a></li>
<li><a href='#interaction.indices-methods'><p>The Shapley interaction indices</p></a></li>
<li><a href='#is.cardinal-methods'><p>Test method</p></a></li>
<li><a href='#is.kadditive-methods'><p>Test method</p></a></li>
<li><a href='#is.monotone-methods'><p>Test method</p></a></li>
<li><a href='#is.normalized-methods'><p>Test method</p></a></li>
<li><a href='#k.truncate.Mobius-methods'><p>k-order truncation of the Möbius representation of a set function.</p></a></li>
<li><a href='#least.squares.capa.ident'><p>Least squares capacity identification</p></a></li>
<li><a href='#lin.prog.capa.ident'><p>Capacity identification based on linear programming</p></a></li>
<li><a href='#ls.ranking.capa.ident'><p>Least squares capacity identification in the framework of a ranking procedure</p></a></li>
<li><a href='#ls.sorting.capa.ident'><p>Least squares capacity identification in the framework of a sorting procedure</p></a></li>
<li><a href='#ls.sorting.treatment'><p>Least squares capacity identification in the framework of a</p>
sorting procedure: evaluation of the determined capacity</a></li>
<li><a href='#mini.dist.capa.ident'><p>Minimum distance capacity identification</p></a></li>
<li><a href='#mini.var.capa.ident'><p>Minimum variance capacity identification</p></a></li>
<li><a href='#Mobius-methods'><p>The Möbius transform</p></a></li>
<li><a href='#Mobius.capacity-class'><p>Class &quot;Mobius.capacity&quot;</p></a></li>
<li><a href='#Mobius.card.set.func'><p>Creates an object representing the Möbius transform of a cardinal set function.</p></a></li>
<li><a href='#Mobius.card.set.func-class'><p>Class &quot;Mobius.card.set.func&quot;</p></a></li>
<li><a href='#Mobius.game-class'><p>Class &quot;Mobius.game&quot;</p></a></li>
<li><a href='#Mobius.set.func'><p>Create objects representing the Möbius transform of a set function.</p></a></li>
<li><a href='#Mobius.set.func-class'><p>Class &quot;Mobius.set.func&quot;</p></a></li>
<li><a href='#normalize-methods'><p>Normalizes a capacity.</p></a></li>
<li><a href='#orness-methods'><p>Orness degree</p></a></li>
<li><a href='#pdf.Choquet.unif-methods'><p>Distribution of the Choquet integral for evaluations uniformly</p>
distributed on the unit hypercube</a></li>
<li><a href='#rnd-methods'><p>Rounding of set function coefficients</p></a></li>
<li><a href='#set.func'><p>Create objects of class &quot;set.func&quot;, &quot;game&quot;, or &quot;capacity&quot;.</p></a></li>
<li><a href='#set.func-class'><p>Class &quot;set.func&quot;</p></a></li>
<li><a href='#Shapley.value-methods'><p>The Shapley value</p></a></li>
<li><a href='#show-methods'><p>Methods for Function show in Package &lsquo;kappalab&rsquo;</p></a></li>
<li><a href='#Sipos.integral-methods'><p>Sipos integral</p></a></li>
<li><a href='#Sugeno.integral-methods'><p>Sugeno integral</p></a></li>
<li><a href='#summary-methods'><p>Summary method</p></a></li>
<li><a href='#summary.superclass.capacity-class'><p>Class &quot;summary.superclass.capacity&quot;</p></a></li>
<li><a href='#summary.superclass.set.func-class'><p>Class &quot;summary.superclass.set.func&quot;</p></a></li>
<li><a href='#superclass.capacity-class'><p>Class &quot;superclass.capacity&quot;</p></a></li>
<li><a href='#superclass.set.func-class'><p>Class &quot;superclass.set.func&quot;</p></a></li>
<li><a href='#to.data.frame-methods'><p>Puts a set function under the form of a data.frame</p></a></li>
<li><a href='#variance-methods'><p>Normalized variance of a capacity</p></a></li>
<li><a href='#veto-methods'><p>Veto indices</p></a></li>
<li><a href='#zeta-methods'><p>The zeta transform</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.4-12</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Non-Additive Measure and Integral Manipulation Functions</td>
</tr>
<tr>
<td>Author:</td>
<td>Michel Grabisch, Ivan Kojadinovic, Patrick Meyer.  </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ivan Kojadinovic &lt;ivan.kojadinovic@univ-pau.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>S4 tool box for capacity (or non-additive measure, fuzzy measure) and integral manipulation in a finite setting. It contains routines for handling various types of set functions such as games or capacities. It can be used to compute several non-additive integrals: the Choquet integral, the Sugeno integral, and the symmetric and asymmetric Choquet integrals. An analysis of capacities in terms of decision behavior can be performed through the computation of various indices such as the Shapley value, the interaction index, the orness degree, etc. The well-known Möbius transform, as well as other equivalent representations of set functions can also be computed. Kappalab further contains seven capacity identification routines: three least squares based approaches, a method based on linear programming, a maximum entropy like method based on variance minimization, a minimum distance approach and an unsupervised approach based on parametric entropies. The functions contained in Kappalab can for instance be used in the framework of multicriteria decision making or cooperative game theory.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.1.0), methods, lpSolve, quadprog, kernlab</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.cecill.info/licences/Licence_CeCILL_V2-en.txt">CeCILL version 2</a> | <a href="https://www.cecill.info/licences/Licence_CeCILL_V2.1-en.txt">CECILL-2.1</a> [expanded from: CeCILL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-07 19:25:48 UTC; ikojadin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-07 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.capacity-methods'>Coercion method</h2><span id='topic+as.capacity'></span><span id='topic+as.capacity-methods'></span><span id='topic+as.capacity+2Cset.func-method'></span><span id='topic+as.capacity+2Ccard.capacity-method'></span>

<h3>Description</h3>

<p>Creates <b>if possible</b> a new object of the desired class from the old object.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;set.func&quot; </dt><dd><p>Returns an object of class <code>capacity</code>.</p>
</dd>
<dt>object = &quot;card.capacity&quot; </dt><dd><p>Returns an object of class <code>capacity</code>.</p>
</dd>
</dl>

<hr>
<h2 id='as.card.capacity-methods'>Coercion method</h2><span id='topic+as.card.capacity'></span><span id='topic+as.card.capacity-methods'></span><span id='topic+as.card.capacity+2Ccard.set.func-method'></span><span id='topic+as.card.capacity+2Ccapacity-method'></span>

<h3>Description</h3>

<p>Creates <b>if possible</b> a new object of the desired class from the old object.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;card.set.func&quot; </dt><dd><p>Returns an object of class <code>card.capacity</code>.</p>
</dd>
<dt>object = &quot;capacity&quot; </dt><dd><p>Returns an object of class <code>card.capacity</code>.</p>
</dd>
</dl>

<hr>
<h2 id='as.card.game-methods'>Coercion method</h2><span id='topic+as.card.game'></span><span id='topic+as.card.game-methods'></span><span id='topic+as.card.game+2Ccard.set.func-method'></span><span id='topic+as.card.game+2Cgame-method'></span>

<h3>Description</h3>

<p>Creates <b>if possible</b> a new object of the desired class from the old object.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;card.set.func&quot; </dt><dd><p>Returns an object of class <code>card.game</code>.</p>
</dd>
<dt>object = &quot;game&quot; </dt><dd><p>Returns an object of class <code>card.game</code>.</p>
</dd>
</dl>

<hr>
<h2 id='as.card.set.func-methods'>Coercion method</h2><span id='topic+as.card.set.func'></span><span id='topic+as.card.set.func-methods'></span><span id='topic+as.card.set.func+2Cset.func-method'></span><span id='topic+as.card.set.func+2CMobius.set.func-method'></span><span id='topic+as.card.set.func+2CMobius.card.set.func-method'></span>

<h3>Description</h3>

<p>Creates <b>if possible</b> a new object of the desired class from the old object.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;set.func&quot; </dt><dd><p>Returns an object of class
<code>card.set.func</code>.</p>
</dd>
<dt>object = &quot;Mobius.set.func&quot; </dt><dd><p>Returns an object of class
<code>card.set.func</code>.</p>
</dd>
<dt>object = &quot;Mobius.card.set.func&quot; </dt><dd><p>Returns an object of class
<code>card.set.func</code>.</p>
</dd>
</dl>

<hr>
<h2 id='as.game-methods'>Coercion method</h2><span id='topic+as.game'></span><span id='topic+as.game-methods'></span><span id='topic+as.game+2Cset.func-method'></span><span id='topic+as.game+2Ccard.game-method'></span>

<h3>Description</h3>

<p>Creates <b>if possible</b> a new object of the desired class from the old object.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;set.func&quot; </dt><dd><p>Returns an object of class <code>game</code>.</p>
</dd>
<dt>object = &quot;card.game&quot; </dt><dd><p>Returns an object of class <code>game</code>.</p>
</dd>
</dl>

<hr>
<h2 id='as.Mobius.capacity-methods'>Coercion method</h2><span id='topic+as.Mobius.capacity'></span><span id='topic+as.Mobius.capacity-methods'></span><span id='topic+as.Mobius.capacity+2CMobius.set.func-method'></span>

<h3>Description</h3>

<p>Creates <b>if possible</b> a new object of the desired class from the old object.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.set.func&quot; </dt><dd><p>Returns an object of class <code>Mobius.capacity</code>.</p>
</dd>
</dl>

<hr>
<h2 id='as.Mobius.card.set.func-methods'>Coercion method</h2><span id='topic+as.Mobius.card.set.func'></span><span id='topic+as.Mobius.card.set.func-methods'></span><span id='topic+as.Mobius.card.set.func+2CMobius.set.func-method'></span><span id='topic+as.Mobius.card.set.func+2Cset.func-method'></span><span id='topic+as.Mobius.card.set.func+2Ccard.set.func-method'></span>

<h3>Description</h3>

<p>Creates <b>if possible</b> a new object of the desired class from the old object.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.set.func&quot; </dt><dd><p>Returns an object of class
<code>Mobius.card.set.func</code>.</p>
</dd>
<dt>object = &quot;set.func&quot; </dt><dd><p>Returns an object of class
<code>Mobius.card.set.func</code>.</p>
</dd>
<dt>object = &quot;card.set.func&quot; </dt><dd><p>Returns an object of class
<code>Mobius.card.set.func</code>.</p>
</dd>
</dl>

<hr>
<h2 id='as.Mobius.game-methods'>Coercion method</h2><span id='topic+as.Mobius.game'></span><span id='topic+as.Mobius.game-methods'></span><span id='topic+as.Mobius.game+2CMobius.set.func-method'></span>

<h3>Description</h3>

<p>Creates <b>if possible</b> a new object of the desired class from the old object.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.set.func&quot; </dt><dd><p>Returns an object of class <code>Mobius.game</code>.</p>
</dd>
</dl>

<hr>
<h2 id='as.Mobius.set.func-methods'>Coercion method</h2><span id='topic+as.Mobius.set.func'></span><span id='topic+as.Mobius.set.func-methods'></span><span id='topic+as.Mobius.set.func+2CMobius.card.set.func-method'></span><span id='topic+as.Mobius.set.func+2Cset.func-method'></span><span id='topic+as.Mobius.set.func+2Ccard.set.func-method'></span>

<h3>Description</h3>

<p>Creates <b>if possible</b> a new object of the desired class from the old object.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.card.set.func&quot; </dt><dd><p>Returns an object of class
<code>Mobius.set.func</code>.</p>
</dd>
<dt>object = &quot;set.func&quot; </dt><dd><p>Returns an object of class
<code>Mobius.set.func</code>.</p>
</dd>
<dt>object = &quot;card.set.func&quot; </dt><dd><p>Returns an object of class
<code>Mobius.set.func</code>.</p>
</dd>
</dl>

<hr>
<h2 id='as.set.func-methods'>Coercion method</h2><span id='topic+as.set.func'></span><span id='topic+as.set.func-methods'></span><span id='topic+as.set.func+2Ccard.set.func-method'></span><span id='topic+as.set.func+2CMobius.set.func-method'></span><span id='topic+as.set.func+2CMobius.card.set.func-method'></span>

<h3>Description</h3>

<p>Creates <b>if possible</b> a new object of the desired class from the old object.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;card.set.func&quot; </dt><dd><p>Returns an object of class
<code>set.func</code>.</p>
</dd>
<dt>object = &quot;Mobius.set.func&quot; </dt><dd><p>Returns an object of class
<code>set.func</code>.</p>
</dd>
<dt>object = &quot;Mobius.card.set.func&quot; </dt><dd><p>Returns an object of class <code>set.func</code>.</p>
</dd>
</dl>

<hr>
<h2 id='capacity-class'>Class &quot;capacity&quot;</h2><span id='topic+capacity-class'></span>

<h3>Description</h3>

<p>Class representing a capacity, i.e. a monotone set function
vanishing at the empty set (also called <em>fuzzy measure</em>, <em>non-additive measure</em>,
<em>monotone measure</em>).</p>


<h3>Objects from the Class</h3>

<p>Objects can be mainly created by calls
to the functions <code>capacity</code> and <code>entropy.capa.ident</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>n</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 equal to the
number of elements of the set on which the capacity is defined.</p>
</dd>
<dt><code>subsets</code>:</dt><dd><p>Object of class <code>numeric</code> of length
<code>2^n</code> containing the power set of the underlying set in
&quot;natural&quot; order. The subsets are coded as integers.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>numeric</code> of length
<code>2^n</code> containing the coefficients of the capacity in binary
order. We necessarily have <code>data[1] = 0</code> plus some additional monotonicity
constraints.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>game</code>, directly.
Class <code>superclass.capacity</code>, directly.
Class <code>set.func</code>, by class <code>game</code>.
Class <code>superclass.set.func</code>, by class <code>game</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>as.card.capacity</dt><dd><p><code>signature(object = "capacity")</code></p>
</dd>
<dt>conjugate</dt><dd><p><code>signature(object = "capacity")</code></p>
</dd>
<dt>entropy</dt><dd><p><code>signature(object = "capacity")</code></p>
</dd>
<dt>favor</dt><dd><p><code>signature(object = "capacity")</code></p>
</dd>
<dt>is.normalized</dt><dd><p><code>signature(object = "capacity")</code></p>
</dd>
<dt>normalize</dt><dd><p><code>signature(object = "capacity")</code></p>
</dd>
<dt>Mobius</dt><dd><p><code>signature(object = "capacity")</code></p>
</dd>
<dt>orness</dt><dd><p><code>signature(object = "capacity")</code></p>
</dd>
<dt>variance</dt><dd><p><code>signature(object = "capacity")</code></p>
</dd>
<dt>veto</dt><dd><p><code>signature(object = "capacity")</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+capacity">capacity</a></code>,
<br /> <code><a href="#topic+entropy.capa.ident">entropy.capa.ident</a></code>,
<br /> <code><a href="#topic+as.card.capacity-methods">as.card.capacity-methods</a></code>,
<br /> <code><a href="#topic+conjugate-methods">conjugate-methods</a></code>, 
<br /> <code><a href="#topic+entropy-methods">entropy-methods</a></code>,
<br /> <code><a href="#topic+favor-methods">favor-methods</a></code>, 
<br /> <code><a href="#topic+is.normalized-methods">is.normalized-methods</a></code>,
<br /> <code><a href="#topic+normalize-methods">normalize-methods</a></code>,
<br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>, 
<br /> <code><a href="#topic+orness-methods">orness-methods</a></code>,
<br /> <code><a href="#topic+variance-methods">variance-methods</a></code>, 
<br /> <code><a href="#topic+veto-methods">veto-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a capacity
mu &lt;- capacity(c(0:13,13,13)/13)

## the attributes of the object
mu@n
mu@data
mu@subsets

## a test
is.normalized(mu)
normalize(mu)

## a conversion that should not work
## as.card.capacity(mu)

## some transformations
conjugate(mu)
Mobius(mu)
## let us check ...
zeta(Mobius(mu))

## some summary indices
orness(mu)
veto(mu)
favor(mu)
variance(mu)
entropy(mu)
## the same
summary(mu)
</code></pre>

<hr>
<h2 id='card.capacity-class'>Class &quot;card.capacity&quot;</h2><span id='topic+card.capacity-class'></span>

<h3>Description</h3>

<p>Class representing a cardinal capacity, i.e. a capacity whose
values 
depend only on the cardinality of subsets (also called <em>symmetric capacity</em>).</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the functions <code>card.capacity</code>, <code>lower.capacity</code>, <code>upper.capacity</code>, <code>uniform.capacity</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>n</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 equal
to the number of elements of the set on which the cardinal game is defined.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>numeric</code> of length
<code>n+1</code> containing the coefficients of the cardinal capacity. We necessarily have
<code>data[1]=0</code> and <code>data[i+1]-data[i]&gt;0</code>.</p>
</dd> 
</dl>



<h3>Extends</h3>

<p>Class <code>card.game</code>, directly.
Class <code>superclass.capacity</code>, directly.
Class <code>card.set.func</code>, by class <code>card.game</code>.
Class <code>superclass.set.func</code>, by class <code>card.game</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>as.capacity</dt><dd><p><code>signature(object = "card.capacity")</code> </p>
</dd>
<dt>conjugate</dt><dd><p><code>signature(object = "card.capacity")</code> </p>
</dd>
<dt>entropy</dt><dd><p><code>signature(object = "card.capacity")</code> </p>
</dd>
<dt>favor</dt><dd><p><code>signature(object = "card.capacity")</code> </p>
</dd>
<dt>is.normalized</dt><dd><p><code>signature(object = "card.capacity")</code> </p>
</dd> 
<dt>normalize</dt><dd><p><code>signature(object = "card.capacity")</code> </p>
</dd>
<dt>orness</dt><dd><p><code>signature(object = "card.capacity")</code> </p>
</dd>
<dt>variance</dt><dd><p><code>signature(object = "card.capacity")</code> </p>
</dd>
<dt>veto</dt><dd><p><code>signature(object = "card.capacity")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>, <br /> <code><a href="#topic+card.capacity">card.capacity</a></code>,
<br /> <code><a href="#topic+as.capacity-methods">as.capacity-methods</a></code>, <br /> <code><a href="#topic+conjugate-methods">conjugate-methods</a></code>, 
<br /> <code><a href="#topic+entropy-methods">entropy-methods</a></code>, <br /> <code><a href="#topic+favor-methods">favor-methods</a></code>, 
<br /> <code><a href="#topic+is.normalized-methods">is.normalized-methods</a></code>, <br /> <code><a href="#topic+orness-methods">orness-methods</a></code>, 
<br /> <code><a href="#topic+variance-methods">variance-methods</a></code>, <br /> <code><a href="#topic+veto-methods">veto-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a capacity
mu &lt;- card.capacity(0:6/6)
## the same
mu &lt;- uniform.capacity(6)

# the attributes of the object
mu@n
mu@data

## a test
is.normalized(mu)
normalize(mu)

## a transformation
conjugate(mu)

## some summary indices
orness(mu)
veto(mu)
favor(mu)
variance(mu)
entropy(mu)
## the same
summary(mu)
</code></pre>

<hr>
<h2 id='card.game-class'>Class &quot;card.game&quot;</h2><span id='topic+card.game-class'></span>

<h3>Description</h3>

<p>Class representing a cardinal game, i.e. a game whose values depend
only on the cardinality of subsets.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the function <code>card.game</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>n</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 equal
to the number of elements of the set on which the cardinal game is defined.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>numeric</code> of length
<code>n+1</code> containing the coefficients of the cardinal game. We necessarily have
<code>data[1]=0</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>card.set.func</code>, directly.
Class <code>superclass.set.func</code>, by class <code>card.set.func</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>as.game</dt><dd><p><code>signature(object = "card.game")</code> </p>
</dd>
<dt>Choquet.integral</dt><dd><p><code>signature(object = "card.game", f = "numeric")</code> </p>
</dd>
<dt>Sipos.integral</dt><dd><p><code>signature(object = "card.game", f = "numeric")</code> </p>
</dd>
<dt>Sugeno.integral</dt><dd><p><code>signature(object = "card.game", f = "numeric")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+game-class">game-class</a></code>, <br /> <code><a href="#topic+card.game">card.game</a></code>,
<br /> <code><a href="#topic+as.game-methods">as.game-methods</a></code>, <br /> <code><a href="#topic+Choquet.integral-methods">Choquet.integral-methods</a></code>, 
<br /> <code><a href="#topic+Sipos.integral-methods">Sipos.integral-methods</a></code>, <br /> <code><a href="#topic+Sugeno.integral-methods">Sugeno.integral-methods</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a cardinal game (which is a capacity)
mu &lt;- card.game(c(0,rep(1,4)))

# the attributes of the object
mu@n
mu@data

## a conversion
as.game(mu)

## integral calculations 
f &lt;- c(0.2,0.3,0.1,0.7)
Choquet.integral(mu,f)
Sugeno.integral(mu,f)
f &lt;- c(0.2,-0.3,0.1,-0.7)
Sipos.integral(mu,f)
</code></pre>

<hr>
<h2 id='card.set.func'>Create objects representing cardinal set functions.</h2><span id='topic+card.set.func'></span><span id='topic+card.game'></span><span id='topic+card.capacity'></span><span id='topic+lower.capacity'></span><span id='topic+upper.capacity'></span><span id='topic+uniform.capacity'></span>

<h3>Description</h3>

<p>These functions create objects of class
<code>card.set.func</code>, <code>card.game</code>, or <code>card.capacity</code>
from an object of class <code>numeric</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>card.set.func(object)
card.game(object)
card.capacity(object)
lower.capacity(n)
upper.capacity(n)
uniform.capacity(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="card.set.func_+3A_object">object</code></td>
<td>
<p>An object of class <code>numeric</code> containing the
coefficients of the cardinal set function. The coefficient at
position <code>k</code> corresponds to the value of the cardinal set
function for subsets of size <code>k</code>.</p>
</td></tr>
<tr><td><code id="card.set.func_+3A_n">n</code></td>
<td>
<p>An object of class <code>numeric</code> of length 1 containing
the cardinal of the set on which the cardinal set function is
defined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return objects of class <code>card.set.func</code>, <code>card.game</code>, or <code>card.capacity</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+card.capacity-class">card.capacity-class</a></code>, 
<br /> <code><a href="#topic+card.game-class">card.game-class</a></code>,
<br /> <code><a href="#topic+card.set.func-class">card.set.func-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>card.set.func(4:-2)
card.game(c(0,-2:2))
card.capacity(0:5)
lower.capacity(3)
upper.capacity(4)
uniform.capacity(5)
</code></pre>

<hr>
<h2 id='card.set.func-class'>Class &quot;card.set.func&quot;</h2><span id='topic+card.set.func-class'></span>

<h3>Description</h3>

<p>Class representing a cardinal set function, i.e. whose values
depend only on the cardinality of subsets.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the function <code>card.set.func</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>n</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 equal
to the number of elements of the set on which the cardinal set
function is defined.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>numeric</code> of length
<code>n+1</code> containing the coefficients of the cardinal set function.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>superclass.set.func</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>as.card.game</dt><dd><p><code>signature(object = "card.set.func")</code></p>
</dd>
<dt>as.card.capacity</dt><dd><p><code>signature(object = "card.set.func")</code></p>
</dd>
<dt>as.set.func</dt><dd><p><code>signature(object = "card.set.func")</code> </p>
</dd>
<dt>as.Mobius.card.set.func</dt><dd><p><code>signature(object =
	"card.set.func")</code> </p>
</dd>
<dt>as.Mobius.set.func</dt><dd><p><code>signature(object = "card.set.func")</code></p>
</dd>
<dt>conjugate</dt><dd><p><code>signature(object = "card.set.func")</code></p>
</dd>
<dt>interaction.indices</dt><dd><p><code>signature(object =
	"card.set.func")</code></p>
</dd>
<dt>is.cardinal</dt><dd><p><code>signature(object = "card.set.func")</code></p>
</dd>
<dt>is.kadditive</dt><dd><p><code>signature(object = "card.set.func", k =
	"numeric")</code></p>
</dd>
<dt>is.monotone</dt><dd><p><code>signature(object = "card.set.func")</code></p>
</dd>
<dt>Mobius</dt><dd><p><code>signature(object = "card.set.func")</code></p>
</dd>
<dt>Shapley.value</dt><dd><p><code>signature(object = "card.set.func")</code></p>
</dd>
<dt>to.data.frame</dt><dd><p><code>signature(object = "card.set.func")</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+set.func-class">set.func-class</a></code>,
<br /> <code><a href="#topic+card.set.func">card.set.func</a></code>,
<br /> <code><a href="#topic+as.card.game-methods">as.card.game-methods</a></code>, 
<br /> <code><a href="#topic+as.card.capacity-methods">as.card.capacity-methods</a></code>,
<br /> <code><a href="#topic+as.set.func-methods">as.set.func-methods</a></code>,
<br /> <code><a href="#topic+as.Mobius.set.func-methods">as.Mobius.set.func-methods</a></code>,
<br /> <code><a href="#topic+as.Mobius.card.set.func-methods">as.Mobius.card.set.func-methods</a></code>,
<br /> <code><a href="#topic+conjugate-methods">conjugate-methods</a></code>, 
<br /> <code><a href="#topic+interaction.indices-methods">interaction.indices-methods</a></code>,
<br /> <code><a href="#topic+is.cardinal-methods">is.cardinal-methods</a></code>, 
<br /> <code><a href="#topic+is.kadditive-methods">is.kadditive-methods</a></code>,
<br /> <code><a href="#topic+is.monotone-methods">is.monotone-methods</a></code>, 
<br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>,
<br /> <code><a href="#topic+Shapley.value-methods">Shapley.value-methods</a></code>, 
<br /> <code><a href="#topic+to.data.frame-methods">to.data.frame-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a cardinal set function
mu &lt;- card.set.func(-3:2)

# the attributes of the object
mu@n
mu@data

## some conversions that cannot work
## Not run: as.card.game(mu)
## Not run: as.card.capacityfunc(mu)

## the following should work
as.set.func(mu)

## some tests
is.cardinal(mu)
is.kadditive(mu,2)
is.monotone(mu)

## some transformations
conjugate(mu)
Mobius(mu)
## let us check ...
zeta(Mobius(mu))

## summary 
Shapley.value(mu)
interaction.indices(mu)
# the same
summary(mu)

## save the set function to a file
d &lt;- to.data.frame(mu)
## Not run: write.table(d,"my.card.set.func.csv",sep="\t")

# finally, some other conversions that should work
mu &lt;- card.set.func(0:5)
as.card.game(mu)
as.card.capacity(mu)
</code></pre>

<hr>
<h2 id='Choquet.integral-methods'>Choquet integral</h2><span id='topic+Choquet.integral'></span><span id='topic+Choquet.integral-methods'></span><span id='topic+Choquet.integral+2CMobius.game+2Cnumeric-method'></span><span id='topic+Choquet.integral+2Ccard.game+2Cnumeric-method'></span><span id='topic+Choquet.integral+2Cgame+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Computes the Choquet integral of a discrete function with
respect to a game. The game can be given either under the form of an
object of class <code>game</code>, <code>card.game</code> or
<code>Mobius.game</code>. If the integrand is not positive, this function
computes what is known as the <em>asymmetric Choquet integral</em>.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.game&quot;, f = &quot;numeric&quot; </dt><dd><p>The Choquet integral of
<code>f</code> is computed from the Möbius transform of a game.</p>
</dd>
<dt>object = &quot;game&quot;, f = &quot;numeric&quot; </dt><dd><p>The Choquet integral of
<code>f</code> is computed from a game.</p>
</dd>
<dt>object = &quot;card.game&quot;, f = &quot;numeric&quot; </dt><dd><p>The Choquet integral of
<code>f</code> is computed from  a cardinal game.</p>
</dd>
</dl>


<h3>References</h3>

<p>G. Choquet (1953), <em>Theory of capacities</em>, Annales de l'Institut
Fourier 5, pages 131-295.
</p>
<p>D. Denneberg (2000), <em>Non-additive measure and integral, basic concepts and their
role for applications</em>, in: M. Grabisch, T. Murofushi, and M. Sugeno Eds, Fuzzy
Measures and Integrals: Theory and Applications, Physica-Verlag, pages 42-69.
</p>
<p>M. Grabisch, T. Murofushi, M. Sugeno Eds (2000), <em>Fuzzy Measures and
Integrals: Theory and Applications</em>, Physica-Verlag.
</p>
<p>M. Grabisch and Ch. Labreuche (2002), <em>The symmetric and asymmetric Choquet
integrals on finite spaces for decision making</em>, Statistical Papers 43, pages
37-52.
</p>
<p>M. Grabisch (2000), <em>A graphical interpretation of the Choquet integral</em>, IEEE
Transactions on Fuzzy Systems 8, pages 627-631.
</p>
<p>J.-L. Marichal (2000), <em>An axiomatic approach of the discrete Choquet integral as
a tool to aggregate interacting criteria</em>, IEEE Transactions on Fuzzy Systems
8:6, pages 800-807.
</p>
<p>Murofushi and M. Sugeno (1993), <em>Some quantities represented by the Choquet
integral</em>, Fuzzy Sets and Systems 56, pages 229-235.
</p>
<p>Murofushi and M. Sugeno (2000), <em>Fuzzy measures and fuzzy integrals</em>, in: M.
Grabisch, T. Murofushi, and M. Sugeno Eds, Fuzzy Measures and Integrals: Theory
and Applications, Physica-Verlag, pages 3-41.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+game-class">game-class</a></code>, <br /> <code><a href="#topic+Mobius.game-class">Mobius.game-class</a></code>,
<br /> <code><a href="#topic+card.game-class">card.game-class</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a normalized capacity
mu &lt;- capacity(c(0:13/13,1,1))

## and its Mobius transform
a &lt;- Mobius(mu)

## a discrete positive function f
f &lt;- c(0.1,0.9,0.3,0.8)

## the Choquet integral of f w.r.t mu
Choquet.integral(mu,f)
Choquet.integral(a,f)

## a similar example with a cardinal capacity
mu &lt;- uniform.capacity(4)
Choquet.integral(mu,f)
</code></pre>

<hr>
<h2 id='conjugate-methods'>The conjugate (or dual) transform</h2><span id='topic+conjugate'></span><span id='topic+conjugate-methods'></span><span id='topic+conjugate+2Ccapacity-method'></span><span id='topic+conjugate+2Ccard.capacity-method'></span><span id='topic+conjugate+2Ccard.set.func-method'></span><span id='topic+conjugate+2Cset.func-method'></span>

<h3>Description</h3>

<p>Computes the conjugate (also called the <em>dual</em>) of a set function. The
conjugate of the conjugate of a game gives the original game back.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;capacity&quot; </dt><dd><p>Returns an object of class <code>capacity</code>.</p>
</dd>
<dt>object = &quot;card.capacity&quot; </dt><dd><p>Returns an object of class <code>card.capacity</code>.</p>
</dd>
<dt>object = &quot;card.set.func&quot; </dt><dd><p>Returns an object of class <code>card.game</code>.</p>
</dd>
<dt>object = &quot;set.func&quot; </dt><dd><p>Returns an object of class <code>game</code>. </p>
</dd>
</dl>


<h3>References</h3>

<p>T. Murofushi and M. Sugeno (2000), <em>Fuzzy measures and fuzzy integrals</em>,
in: M. Grabisch, T. Murofushi, and M. Sugeno Eds, Fuzzy Measures and
Integrals: Theory and Applications, Physica-Verlag, pages 3-41.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>, 
<br /> <code><a href="#topic+card.capacity-class">card.capacity-class</a></code>, 
<br /> <code><a href="#topic+set.func-class">set.func-class</a></code>,
<br /> <code><a href="#topic+card.set.func-class">card.set.func-class</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a game
mu &lt;- game(c(0,-7:7))
mu

## its conjugate 
conjugate(mu)
## and mu again 
conjugate(conjugate(mu))

## a similar example with the upper capacity
mu &lt;- capacity(c(0,rep(1,15)))
mu
conjugate(mu)
conjugate(conjugate(mu))

## a similar example with an object of class card.capacity
mu &lt;- upper.capacity(6)
mu
conjugate(mu)
conjugate(conjugate(mu))

## the conjugate of a set function is a game
mu &lt;- set.func(-7:8)
mu
conjugate(mu)
mu &lt;- card.set.func(-2:5)
conjugate(mu)
</code></pre>

<hr>
<h2 id='entropy-methods'>Normalized entropy of a capacity</h2><span id='topic+entropy'></span><span id='topic+entropy-methods'></span><span id='topic+entropy+2CMobius.capacity-method'></span><span id='topic+entropy+2Ccapacity-method'></span><span id='topic+entropy+2Ccard.capacity-method'></span>

<h3>Description</h3>

<p>Computes the normalized entropy of a capacity. The capacity
can be given either under the form of an object of class
<code>capacity</code>, <code>card.capacity</code> or <code>Mobius.capacity</code>.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.capacity&quot; </dt><dd><p>The normalized entropy is computed
from the
Möbius transform of a capacity.</p>
</dd>
<dt>object = &quot;capacity&quot; </dt><dd><p>The normalized entropy is computed directly from a capacity.</p>
</dd>
<dt>object = &quot;card.capacity&quot; </dt><dd><p>The normalized entropy is computed from a cardinal capacity.</p>
</dd>
</dl>


<h3>References</h3>

<p>J-L. Marichal (2002), <em>Entropy of discrete Choquet capacities</em>, European
Journal of Operational Research, 3:137, 2002, pages 612-624.
</p>
<p>I. Kojadinovic, J-L. Marichal and M. Roubens (2005), <em>An axiomatic
approach to the definition of the entropy of a discrete Choquet
capacity</em>, Information Sciences 172, pages 131-153.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>, <br /> <code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+card.capacity-class">card.capacity-class</a></code>, <br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a capacity
mu &lt;- capacity(c(0,0,0:13))

## its Mobius transform
a &lt;- Mobius(mu)

## their normalized entropy
entropy(mu)
entropy(a)

## similar examples with card.capacity objects
mu &lt;- lower.capacity(4)
entropy(mu)
mu &lt;- uniform.capacity(4)
entropy(mu)
</code></pre>

<hr>
<h2 id='entropy.capa.ident'>Unsupervised identification of a capacity from profiles</h2><span id='topic+entropy.capa.ident'></span>

<h3>Description</h3>

<p>This function estimates a capacity using as argument a set
of data under the form: datum=(score on attribute 1, ..., score on attribute
n). The approach roughly consists in replacing the subjective notion
of <em>importance</em> of a subset of attributes by that of
<em>information content</em> of a subset of attributes, which is estimated
from the data by means of a parametric entropy measure. For
more details, see the references hereafter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy.capa.ident(d, entropy = "renyi", parameter = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy.capa.ident_+3A_d">d</code></td>
<td>
<p>An object of class <code>data.frame</code> containing the
discretized data. Each column of the <code>data.frame</code> must
be a <code>factor</code>. Each line corresponds to a datum.</p>
</td></tr>
<tr><td><code id="entropy.capa.ident_+3A_entropy">entropy</code></td>
<td>
<p>An object of class <code>character</code> containg the name
of the parametric entropy measure to be used for the estimation. The
allowed values are &quot;renyi&quot; and &quot;havrda.charvat&quot;.</p>
</td></tr>
<tr><td><code id="entropy.capa.ident_+3A_parameter">parameter</code></td>
<td>
<p>An object of class <code>numeric</code> containing he value
of the parameter of the choosen entropy. The parameter value must be
a positive real number. If equal to 1, the Shannon entropy is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>capacity</code>.</p>


<h3>References</h3>

<p>I. Kojadinovic (2004), <em>Estimation of the weights of interacting
criteria from the set of profiles by means of information-theoretic
functionals</em>, European Journal of Operational Research 155:3, pages 741-751.
</p>
<p>I. Kojadinovic (2005), <em>Unusupervised aggregation of commensurate
correlated attributes by means of the Choquet integral and entropy
functionals</em>, International Journal of Intelligent Systems, in press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>,
<br /> <code><a href="#topic+lin.prog.capa.ident">lin.prog.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.var.capa.ident">mini.var.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.dist.capa.ident">mini.dist.capa.ident</a></code>,
<br /> <code><a href="#topic+least.squares.capa.ident">least.squares.capa.ident</a></code>,
<br /> <code><a href="#topic+heuristic.ls.capa.ident">heuristic.ls.capa.ident</a></code>,
<br /> <code><a href="#topic+ls.sorting.capa.ident">ls.sorting.capa.ident</a></code>,
<br /> <code><a href="#topic+ls.ranking.capa.ident">ls.ranking.capa.ident</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a set of randomly generated data
## for instance, marks on a [0,20] scale
p &lt;- data.frame(matrix(runif(500,0,20),100,5))
names(p) &lt;- c("Stat","Prob","Alg","Cal","Eng")

## discretization
p[p &lt;= 5] &lt;- 1  
p[p &gt; 5 &amp; p &lt;= 10] &lt;- 2 
p[p &gt; 10 &amp; p &lt;= 15] &lt;- 3 
p[p &gt; 15] &lt;- 4

d &lt;- data.frame(factor(p[[1]]),
                factor(p[[2]]),
                factor(p[[3]]),
                factor(p[[4]]),
                factor(p[[5]]))

## associated unsupervised capacity
mu &lt;- entropy.capa.ident(d)
mu
</code></pre>

<hr>
<h2 id='expect.Choquet.unif-methods'>Expectation and standard deviation of the Choquet integral in the
uniform and normal cases</h2><span id='topic+expect.Choquet.unif'></span><span id='topic+sd.Choquet.unif'></span><span id='topic+expect.Choquet.unif-methods'></span><span id='topic+sd.Choquet.unif-methods'></span><span id='topic+expect.Choquet.unif+2Cgame-method'></span><span id='topic+sd.Choquet.unif+2Cgame-method'></span><span id='topic+expect.Choquet.norm'></span><span id='topic+sd.Choquet.norm'></span><span id='topic+expect.Choquet.norm-methods'></span><span id='topic+sd.Choquet.norm-methods'></span><span id='topic+expect.Choquet.norm+2Cgame-method'></span><span id='topic+sd.Choquet.norm+2Cgame-method'></span><span id='topic+expect.Choquet.norm+2CMobius.game-method'></span>

<h3>Description</h3>

<p>Methods for computing the expectation and standard
deviation of the Choquet integral in the standard uniform and standard
normal cases.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;game&quot;</dt><dd><p>Returns the expectation or the standard
deviation of the Choquet integral.</p>
</dd>
</dl>


<h3>References</h3>

<p>J-L. Marichal and I. Kojadinovic (2007), <em>The distribution of linear
combinations of lattice polynomials from the uniform distribution</em>,
submitted. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+game-class">game-class</a></code>, <code><a href="#topic+Mobius.game-class">Mobius.game-class</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## a capacity
mu &lt;- capacity(c(0,0.1,0.6,rep(0.9,4),1))

## the expectation and the standard deviation
## of the Choquet integral in the uniform case
expect.Choquet.unif(mu)
sd.Choquet.unif(mu)

## the same but empirically
m &lt;- 10000
ch &lt;- numeric(m)
for (i in 1:m) {
     f &lt;- runif(3) 
     ch[i] &lt;- Choquet.integral(mu,f)
}
mean(ch)
sd(ch)

## the expectation and the standard deviation
## of the Choquet integral in the normal case
expect.Choquet.norm(mu)
sd.Choquet.norm(mu)
expect.Choquet.norm(Mobius(mu))

## the same but empirically
for (i in 1:m) {
     f &lt;- rnorm(3) 
     ch[i] &lt;- Choquet.integral(mu,f)
}
mean(ch)
sd(ch)

</code></pre>

<hr>
<h2 id='favor-methods'>Favor indices</h2><span id='topic+favor'></span><span id='topic+favor-methods'></span><span id='topic+favor+2CMobius.capacity-method'></span><span id='topic+favor+2Ccapacity-method'></span><span id='topic+favor+2Ccard.capacity-method'></span>

<h3>Description</h3>

<p>Computes the favor indices of a Choquet integral from the
underlying <b>normalized</b> capacity. The capacity can be given either under the form
of an object of class <code>capacity</code>, <code>card.capacity</code> or
<code>Mobius.capacity</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.capacity&quot; </dt><dd><p>The favor indices are computed from
the Möbius transform of a capacity.</p>
</dd>
<dt>object = &quot;capacity&quot; </dt><dd><p>The favor indices are computed directly from a capacity.</p>
</dd>
<dt>object = &quot;card.capacity&quot; </dt><dd><p>The favor indices are computed from a cardinal capacity.</p>
</dd>
</dl>


<h3>References</h3>

<p>J.-L. Marichal (2000), <em>Behavioral analysis of aggregation in
multicriteria decision aid</em>, in: Preferences and Decisions under
Incomplete Knowledge, J. Fodor and B. De Baets and P. Perny Eds,
Physica-Verlag, pages 153-178.
</p>
<p>J.-L. Marichal (2004), <em>Tolerant or intolerant character of
interacting criteria in aggregation by the Choquet integral</em>,
European Journal of Operational Research 155:3, pages 771-791.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>, <br /> <code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+card.capacity-class">card.capacity-class</a></code>, <br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a capacity
mu &lt;- capacity(c(0:13,13,13))

## its Mobius transform
a &lt;- Mobius(mu)

## their favor indices
favor(mu)
favor(a)

## the same with a card.capacity object
mu &lt;- lower.capacity(4)
favor(mu)
</code></pre>

<hr>
<h2 id='game-class'>Class &quot;game&quot;</h2><span id='topic+game-class'></span>

<h3>Description</h3>

<p>Class representing a game, i.e. a set function vanishing at
the empty set (also called <em>non monotonic fuzzy measure</em>).</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the function <code>game</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>n</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 equal to the
number of elements of the set on which the game is defined.</p>
</dd>
<dt><code>subsets</code>:</dt><dd><p>Object of class <code>numeric</code> of length
<code>2^n</code> containing the power set of the underlying set in
&quot;natural&quot; order. The subsets are coded as integers.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>numeric</code> of length
<code>2^n</code> containing the coefficients of the game in binary
order.  We necessarily have <code>data[1] = 0</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>set.func</code>, directly.
Class <code>superclass.set.func</code>, by class <code>set.func</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>as.card.game</dt><dd><p><code>signature(object = "game")</code></p>
</dd>
<dt>Choquet.integral</dt><dd><p><code>signature(object = "game", f = "numeric")</code></p>
</dd>
<dt>Mobius</dt><dd><p><code>signature(object = "game")</code></p>
</dd>
<dt>Sipos.integral</dt><dd><p><code>signature(object = "game", f = "numeric")</code></p>
</dd>
<dt>Sugeno.integral</dt><dd><p><code>signature(object = "game", f =
	"numeric")</code></p>
</dd>
<dt>pdf.Choquet.unif</dt><dd><p><code>signature(object = "game", f = "numeric")</code></p>
</dd>
<dt>cdf.Choquet.unif</dt><dd><p><code>signature(object = "game", f = "numeric")</code></p>
</dd>
<dt>expect.Choquet.unif</dt><dd><p><code>signature(object = "game")</code></p>
</dd>
<dt>sd.Choquet.unif</dt><dd><p><code>signature(object = "game")</code></p>
</dd>
<dt>expect.Choquet.norm</dt><dd><p><code>signature(object = "game")</code></p>
</dd>
<dt>sd.Choquet.norm</dt><dd><p><code>signature(object = "game")</code></p>
</dd>
</dl>



<h3>See Also</h3>

	
<p><code><a href="#topic+game">game</a></code>,
<br /> <code><a href="#topic+as.card.game-methods">as.card.game-methods</a></code>,
<br /> <code><a href="#topic+Choquet.integral-methods">Choquet.integral-methods</a></code>, 
<br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>,
<br /> <code><a href="#topic+Sipos.integral-methods">Sipos.integral-methods</a></code>, 
<br /> <code><a href="#topic+Sugeno.integral-methods">Sugeno.integral-methods</a></code>,
<br /> <code><a href="#topic+pdf.Choquet.unif-methods">pdf.Choquet.unif-methods</a></code>, 
<br /> <code><a href="#topic+cdf.Choquet.unif-methods">cdf.Choquet.unif-methods</a></code>,
<br /> <code><a href="#topic+expect.Choquet.unif-methods">expect.Choquet.unif-methods</a></code>, 
<br /> <code><a href="#topic+sd.Choquet.unif-methods">sd.Choquet.unif-methods</a></code>,
<br /> <code><a href="#topic+expect.Choquet.norm-methods">expect.Choquet.norm-methods</a></code>, 
<br /> <code><a href="#topic+sd.Choquet.norm-methods">sd.Choquet.norm-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a game (which is a capacity)
mu &lt;- game(c(0,rep(1,15)))

## the attributes of the object
mu@n
mu@data
mu@subsets

## a conversion
as.card.game(mu)

## a transformation
Mobius(mu)
## let us check ...
zeta(Mobius(mu))

## integral calculations 
f &lt;- c(0.2,0.3,0.1,0.7)
Choquet.integral(mu,f)
Sugeno.integral(mu,f)
f &lt;- c(0.2,-0.3,0.1,-0.7)
Sipos.integral(mu,f)
</code></pre>

<hr>
<h2 id='heuristic.ls.capa.ident'>Heuristic least squares capacity identification</h2><span id='topic+heuristic.ls.capa.ident'></span>

<h3>Description</h3>

<p>Creates an object of class <code>capacity</code> or <code>game</code>
by means of the heuristic algorithm proposed by Grabisch (1995). More
precisely, given a set of data under the form:
datum=(score on criterion 1, ..., score on criterion
n, overall score), this function heuristically determines a capacity
that should be close to minimizing the sum of squared errors between overall scores
as given by the data and the output of the Choquet integral for those
data. See reference hereafter for more details.</p>


<h3>Usage</h3>

<pre><code class='language-R'>heuristic.ls.capa.ident(n, mu, C, g, Integral="Choquet", maxiter = 500,
                        alpha = 0.01, epsilon = 1e-6) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heuristic.ls.capa.ident_+3A_n">n</code></td>
<td>
<p>Object of class <code>numeric</code> containing the
number of elements of the set on which the object of class
<code>Mobius.capacity</code> is to be defined.</p>
</td></tr>
<tr><td><code id="heuristic.ls.capa.ident_+3A_mu">mu</code></td>
<td>
<p>Object of class <code>capacity</code> containing the initial capacity. It
should be initialized to the equidistributed capacity.</p>
</td></tr>
<tr><td><code id="heuristic.ls.capa.ident_+3A_c">C</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
<code>n</code>-column criteria matrix. Each line of this matrix
corresponds to a vector of the form: (score on criterion 1, ..., score on
criterion n).</p>
</td></tr>
<tr><td><code id="heuristic.ls.capa.ident_+3A_g">g</code></td>
<td>
<p>Object of class <code>numeric</code> containg the global
scores associated with the vectors given in the criteria matrix.</p>
</td></tr>
<tr><td><code id="heuristic.ls.capa.ident_+3A_integral">Integral</code></td>
<td>
<p>Object of class <code>character</code> indicating whether the
model is based on the asymmetric Choquet integral (<code>Integral =
      "Choquet"</code>) or the symmetric Choquet integral (<code>Integral =
      "Sipos"</code>).</p>
</td></tr>
<tr><td><code id="heuristic.ls.capa.ident_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations. </p>
</td></tr>
<tr><td><code id="heuristic.ls.capa.ident_+3A_alpha">alpha</code></td>
<td>
<p>Object of class <code>numeric</code> containing the coefficient of the
gradient (multiplicative coefficient of the partial derivative). Its value
lies in [0,1]. The higher the value, the larger the move of the capacity at
each iteration.</p>
</td></tr>
<tr><td><code id="heuristic.ls.capa.ident_+3A_epsilon">epsilon</code></td>
<td>
<p>Object of class <code>numeric</code> used for defining a stopping
criterion. Iterations are stopped if one of the following cases happen: 1)
itmax iterations have been performed 2) the error criterion is growing up 3)
normax &lt; epsilon, where normax is the maximum absolute normalized model error,
i.e., the maximum over all data of the quantity |e|/outmax, where e=desired
output - model output, and outmax is the highest value of the absolute value
of the model output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is explained in details in the reference hereafter.
</p>


<h3>Value</h3>

<p>The function returns a list structured as follows:
</p>
<table>
<tr><td><code>solution</code></td>
<td>
<p>Object of class <code>capacity</code> if the solution is
montone or of class <code>game</code> otherwise.</p>
</td></tr>
<tr><td><code>n.iter</code></td>
<td>
<p>Number of iterations taken by the algorithm.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Differences between the provided global evaluations
and those returned by the obtained model.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>Mean square error between the provided global evaluations
and those returned by the obtained model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>M. Grabisch (1995), <em>A new algorithm for identifying fuzzy measures and
its application to pattern recognition</em>, Int. Joint Conf. of the 4th
IEEE Int. Conf. on Fuzzy Systems and the 2nd Int. Fuzzy Engineering
Symposium, Yokohama, Japan, 145-150.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>,
<br /> <code><a href="#topic+least.squares.capa.ident">least.squares.capa.ident</a></code>,
<br /> <code><a href="#topic+lin.prog.capa.ident">lin.prog.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.var.capa.ident">mini.var.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.dist.capa.ident">mini.dist.capa.ident</a></code>,
<br /> <code><a href="#topic+ls.sorting.capa.ident">ls.sorting.capa.ident</a></code>,
<br /> <code><a href="#topic+ls.ranking.capa.ident">ls.ranking.capa.ident</a></code>,
<br /> <code><a href="#topic+entropy.capa.ident">entropy.capa.ident</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## number of criteria
n &lt;- 4

## the number of alternatives
n.a &lt;- 1000

## a randomly generated 5-criteria matrix
C &lt;- matrix(rnorm(n*n.a,10,2),n.a,n)

## the corresponding global scores
g &lt;- numeric(n.a)

## generate a random capacity
x &lt;- runif(2^n-1)
for (i in 2:(2^n-1))
    x[i] &lt;- x[i] + x[i-1]
mu &lt;- normalize(capacity(c(0,x)))
for (i in 1:n.a)
  g[i] &lt;- Choquet.integral(mu,C[i,])

## the initial capacity
## here the uniform capacity
mu.in &lt;- as.capacity(uniform.capacity(n))

## the solution 
hlsc &lt;- heuristic.ls.capa.ident(n,mu.in,C,g)
mu.sol &lt;- hlsc$solution

## the difference between mu and mu.sol
mu@data - mu.sol@data

hlsc
</code></pre>

<hr>
<h2 id='interaction.indices-methods'>The Shapley interaction indices</h2><span id='topic+interaction.indices'></span><span id='topic+interaction.indices-methods'></span><span id='topic+interaction.indices+2CMobius.set.func-method'></span><span id='topic+interaction.indices+2Ccard.set.func-method'></span><span id='topic+interaction.indices+2Cset.func-method'></span>

<h3>Description</h3>

<p>Computes the Shapley interaction index for pairs of elements with
respect to a set function. The set function can be given either under
the form of an object of class <code>set.func</code>, <code>card.set.func</code>
or <code>Mobius.set.func</code>
.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.set.func&quot; </dt><dd><p>The Shapley interaction indices are computed from the Möbius transform of a set function.</p>
</dd>
<dt>object = &quot;card.set.func&quot; </dt><dd><p>The Shapley interaction indices are computed from a cardinal set function.</p>
</dd>
<dt>object = &quot;set.func&quot; </dt><dd><p>The Shapley interaction indices are computed from a general set function.</p>
</dd>
</dl>


<h3>References</h3>

<p>G. Owen (1971/72), <em>Multilinear extensions of games</em>, Management Sci. 18, pages 64&ndash;79.
</p>
<p>T. Murofushi and S. Soneda (1993), <em>Techniques for reading fuzzy measures
(III): interaction index</em>, 9th Fuzzy System Symposium, pages 693&ndash;696, Saporo, Japan.
</p>
<p>M. Grabisch, J-L. Marichal and M. Roubens (2000), <em>Equivalent
representations of set functions</em>, Mathematics of Operations
Research 25(2), pages 157&ndash;178.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.set.func-class">Mobius.set.func-class</a></code>,
<br /> <code><a href="#topic+card.set.func-class">card.set.func-class</a></code>,
<br /> <code><a href="#topic+set.func-class">set.func-class</a></code>,
<br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a set function
mu &lt;- set.func(c(-7:6,6,6))

## the associated interaction indices
interaction.indices(mu)


## a similar example using a Mobius.set.func object
a &lt;- Mobius(mu)
interaction.indices(a)

## a similar example using a card.set.func object
mu &lt;- upper.capacity(6)
interaction.indices(mu)
</code></pre>

<hr>
<h2 id='is.cardinal-methods'>Test method</h2><span id='topic+is.cardinal'></span><span id='topic+is.cardinal-methods'></span><span id='topic+is.cardinal+2CMobius.set.func-method'></span><span id='topic+is.cardinal+2Ccard.set.func-method'></span><span id='topic+is.cardinal+2Cset.func-method'></span>

<h3>Description</h3>

<p>Tests whether a set function is cardinal, i.e., if its values
depend only on the cardinality of subsets. The set function
can be given either under the form of an object of class
<code>set.func</code>, <code>card.set.func</code> or <code>Mobius.set.func</code>.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.set.func&quot; </dt><dd><p>Returns an object of class <code>logical</code>.</p>
</dd>
<dt>object = &quot;card.set.func&quot; </dt><dd><p>Returns an object of class <code>logical</code>.</p>
</dd>
<dt>object = &quot;set.func&quot; </dt><dd><p>Returns an object of class <code>logical</code>.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>is.cardinal(set.func(-7:8))
is.cardinal(uniform.capacity(8))
is.cardinal(Mobius.game(0:10,4,2))
</code></pre>

<hr>
<h2 id='is.kadditive-methods'>Test method</h2><span id='topic+is.kadditive'></span><span id='topic+is.kadditive-methods'></span><span id='topic+is.kadditive+2CMobius.set.func+2Cnumeric-method'></span><span id='topic+is.kadditive+2Ccard.set.func+2Cnumeric-method'></span><span id='topic+is.kadditive+2Cset.func+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Tests whether a set function is <code>k</code>-additive, i.e., if its
Möbius function vanishes for subsets of more than k elements. The set
function can be given either under the form of an object of class
<code>set.func</code>, <code>card.set.func</code> or
<code>Mobius.set.func</code>. </p>


<h3>Details</h3>

<p>In order to test whether a coefficient is equal to zero, its
absolute value is compared with <code>epsilon</code> whose default
value is <code>1e-9</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.set.func&quot;, k = &quot;numeric&quot;, epsilon = &quot;numeric&quot;,
epsilon = &quot;numeric&quot; </dt><dd><p>Returns an object of class <code>logical</code>.</p>
</dd>
<dt>object = &quot;card.set.func&quot;, k = &quot;numeric&quot;, epsilon = &quot;numeric&quot; </dt><dd><p>Returns an object of class <code>logical</code>.</p>
</dd>
<dt>object = &quot;set.func&quot;, k = &quot;numeric&quot;, epsilon = &quot;numeric&quot; </dt><dd><p>Returns an object of class <code>logical</code>.</p>
</dd>
</dl>


<h3>References</h3>

<p>M. Grabisch (1997), <em>k-order additive discrete fuzzy measures and their
representation</em>, Fuzzy Sets and Systems 92(2), pages 167&ndash;189.
</p>
<p>M. Grabisch (2000), <em>The interaction and Möbius
representations of fuzzy measures on finites spaces, k-additive
measures: a survey</em>, in: Fuzzy Measures and Integrals: Theory and
Applications, M. Grabisch, T. Murofushi, and M. Sugeno Eds, Physica
Verlag, pages 70-93.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.set.func-class">Mobius.set.func-class</a></code>, 
<br /> <code><a href="#topic+card.set.func-class">card.set.func-class</a></code>, 
<br /> <code><a href="#topic+set.func-class">set.func-class</a></code>, 
<br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>, <br />
<br /> <code><a href="#topic+k.truncate.Mobius-methods">k.truncate.Mobius-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a set function
mu &lt;- set.func(c(0,1,1,1,2,2,2,3))
mu
is.kadditive(mu,2)
is.kadditive(mu,1)

## the Mobius representation of a set function, 2-additive by construction 
a &lt;- Mobius.set.func(c(0,1,2,1,3,1,2,1,2,3,1),4,2)
is.kadditive(a,2)
is.kadditive(a,1)
</code></pre>

<hr>
<h2 id='is.monotone-methods'>Test method</h2><span id='topic+is.monotone'></span><span id='topic+is.monotone-methods'></span><span id='topic+is.monotone+2CMobius.set.func-method'></span><span id='topic+is.monotone+2Ccard.set.func-method'></span><span id='topic+is.monotone+2Cset.func-method'></span>

<h3>Description</h3>

<p>Tests whether a set function is monotone with respect to set
inclusion. The set function
can be given either under the form of an object of class
<code>set.func</code>, <code>card.set.func</code> or <code>Mobius.set.func</code>.
</p>


<h3>Details</h3>

<p>For objects of class <code>set.func</code> or <code>card.set.func</code>, the
monotonicity constraints are considered to be satisfied
(cf. references hereafter) if the following inequalities are satisfied
</p>
<p style="text-align: center;"><code class="reqn">\mu(S \cup i) - \mu(S) \ge -epsilon</code>
</p>

<p>for all <code class="reqn">S</code> and all <code class="reqn">i</code>.
For objects of class <code>Mobius.set.func</code>, it is
required that a similar condition with respect to the Möbius
representation be satisfied (cf. references hereafter).
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.set.func&quot;, verbose = &quot;logical&quot;, epsilon =
&quot;numeric&quot; </dt><dd>
<p>Returns an object of class <code>logical</code>. If <code>verbose=TRUE</code>,
displays the violated monotonicity constraints, if any.</p>
</dd>
<dt>object = &quot;card.set.func&quot;, verbose = &quot;logical&quot;, epsilon =
&quot;numeric&quot; </dt><dd>
<p>Returns an object of class  <code>logical</code>. If
<code>verbose=TRUE</code>, displays the violated monotonicity
constraints, if any.</p>
</dd>
<dt>object = &quot;set.func&quot;, verbose = &quot;logical&quot;, epsilon = &quot;numeric&quot; </dt><dd>
<p>Returns an object of class <code>logical</code>. If <code>verbose=TRUE</code>,
displays the violated monotonicity constraints, if any.</p>
</dd>
</dl>


<h3>References</h3>

<p>A. Chateauneuf and J-Y. Jaffray (1989), <em>Some characterizations of
lower probabilities and other monotone capacities through the use of
Möbius inversion</em>, Mathematical Social Sciences 17:3, pages
263&ndash;283.
</p>
<p>M. Grabisch (2000), <em>The interaction and Möbius representations of fuzzy
measures on finites spaces, k-additive measures: a survey</em>, in:
Fuzzy Measures and Integrals: Theory and Applications, M. Grabisch,
T. Murofushi, and M. Sugeno Eds, Physica Verlag, pages 70-93.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.set.func-class">Mobius.set.func-class</a></code>, 
<br /> <code><a href="#topic+card.set.func-class">card.set.func-class</a></code>, 
<br /> <code><a href="#topic+set.func-class">set.func-class</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a monotone set function
mu &lt;- set.func(c(0,1,1,1,2,2,2,3))
mu
is.monotone(mu)

## the Mobius representation of a monotone set function
a &lt;- Mobius.set.func(c(0,1,2,1,3,1,2,1,2,3,1),4,2)
is.monotone(a)

## non-monotone examples
mu &lt;- set.func(c(0,-7:7))
is.monotone(mu,verbose=TRUE)
a &lt;- Mobius(mu)
is.monotone(a,verbose=TRUE)
</code></pre>

<hr>
<h2 id='is.normalized-methods'>Test method</h2><span id='topic+is.normalized'></span><span id='topic+is.normalized-methods'></span><span id='topic+is.normalized+2CMobius.capacity-method'></span><span id='topic+is.normalized+2Ccapacity-method'></span><span id='topic+is.normalized+2Ccard.capacity-method'></span>

<h3>Description</h3>

<p>Tests whether a capacity is normalized, i.e., if its value on the
universal set is 1. The capacity can be
given either under the form of an object of class <code>capacity</code>,
<code>card.capacity</code> or <code>Mobius.capacity</code>.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.capacity&quot; </dt><dd><p>Returns a <code>logical</code>.</p>
</dd>
<dt>object = &quot;capacity&quot; </dt><dd><p>Returns a <code>logical</code>.</p>
</dd>
<dt>object = &quot;card.capacity&quot; </dt><dd><p>Returns a <code>logical</code>.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>,
<br /> <code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+card.capacity-class">card.capacity-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a capacity
mu &lt;- capacity(0:15)
is.normalized(mu)
normalize(mu)

## its Mobius transform
a &lt;- Mobius(mu)
is.normalized(a)
normalize(a)

## a cardinal capacity
mu &lt;- uniform.capacity(7)
is.normalized(mu)
</code></pre>

<hr>
<h2 id='k.truncate.Mobius-methods'>k-order truncation of the Möbius representation of a set function.</h2><span id='topic+k.truncate.Mobius'></span><span id='topic+k.truncate.Mobius-methods'></span><span id='topic+k.truncate.Mobius+2Cset.func+2Cnumeric-method'></span><span id='topic+k.truncate.Mobius+2CMobius.set.func+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Truncates the Möbius representation of a set function by
considering that the values of subsets whose cardinal is superior to <code>k</code>
are zero. The result is at most <code>k</code>-additive. </p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;set.func&quot;, k = &quot;numeric&quot; </dt><dd><p>Returns an object of class <code>Mobius.set.func</code>. The Möbius representation of the set function is first computed and then <code>k</code>-truncated.</p>
</dd>
<dt>object = &quot;Mobius.set.func&quot;, k = &quot;numeric&quot; </dt><dd><p>Returns an object of class <code>Mobius.set.func</code>.</p>
</dd>
</dl>


<h3>References</h3>

<p>M. Grabisch (1997), <em>k-order additive discrete fuzzy measures and their
representation</em>, Fuzzy Sets and Systems 92(2), pages 167-189.
</p>
<p>M. Grabisch (2000), <em>The interaction and Möbius
representations of fuzzy measures on finites spaces, k-additive
measures: a survey</em>, in: Fuzzy Measures and Integrals: Theory and
Applications, M. Grabisch, T. Murofushi, and M. Sugeno Eds, Physica
Verlag, pages 70-93.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.set.func-class">Mobius.set.func-class</a></code>, 
<br /> <code><a href="#topic+set.func-class">set.func-class</a></code>, 
<br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a set function
mu &lt;- set.func(c(0,1,1,1,2,2,2,3))
mu

## 2-truncate it
k.truncate.Mobius(mu,2)
## 2-truncate it
k.truncate.Mobius(Mobius(mu),2)
</code></pre>

<hr>
<h2 id='least.squares.capa.ident'>Least squares capacity identification</h2><span id='topic+least.squares.capa.ident'></span>

<h3>Description</h3>

<p>Creates an object of class <code>Mobius.capacity</code> by means of an
approach grounded on least squares optimization. More precisely, given a set
of data under the form: datum=(score on criterion 1, ..., score on criterion
n, overall score), and possibly additional linear constraints expressing
preferences, importance of criteria, etc., this function determines, if it
exists, a capacity minimizing the sum of squared errors between overall scores
as given by the data and the output of the Choquet integral for those data,
and compatible with the additional linear constraints. The existence is
ensured if no additional constraint is given. The problem is solved using
quadratic programming.</p>


<h3>Usage</h3>

<pre><code class='language-R'>least.squares.capa.ident(n, k, C, g, Integral="Choquet",
A.Shapley.preorder = NULL, A.Shapley.interval = NULL,
A.interaction.preorder = NULL, A.interaction.interval = NULL,
A.inter.additive.partition = NULL,  sigf = 7, maxiter = 40,
epsilon = 1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="least.squares.capa.ident_+3A_n">n</code></td>
<td>
<p>Object of class <code>numeric</code> containing the
number of elements of the set on which the object of class
<code>Mobius.capacity</code> is to be defined.</p>
</td></tr>
<tr><td><code id="least.squares.capa.ident_+3A_k">k</code></td>
<td>
<p>Object of class <code>numeric</code> imposing that the solution is at
most a k-additive capacity (the Möbius transform of subsets whose cardinal is
superior to <code>k</code> vanishes).</p>
</td></tr>
<tr><td><code id="least.squares.capa.ident_+3A_c">C</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
<code>n</code>-column criteria matrix. Each line of this matrix
corresponds to a vector of the form: (score on criterion 1, ..., score on
criterion n).</p>
</td></tr>
<tr><td><code id="least.squares.capa.ident_+3A_g">g</code></td>
<td>
<p>Object of class <code>numeric</code> containg the global
scores associated with the vectors given in the criteria matrix.</p>
</td></tr>
<tr><td><code id="least.squares.capa.ident_+3A_integral">Integral</code></td>
<td>
<p>Object of class <code>character</code> indicating whether the
model is based on the asymmetric Choquet integral (<code>Integral =
      "Choquet"</code>) or the symmetric Choquet integral (<code>Integral =
      "Sipos"</code>).</p>
</td></tr>
<tr><td><code id="least.squares.capa.ident_+3A_a.shapley.preorder">A.Shapley.preorder</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the preorder of the criteria. Each line
of this 3-column matrix corresponds to one constraint of the type
&quot;the Shapley importance index of criterion <code>i</code> is greater than
the Shapley importance index of criterion <code>j</code> with preference threshold
<code>delta.S</code>&quot;. A line is structured as follows: the first element
encodes <code>i</code>, the second <code>j</code>, and the third element contains
the preference threshold <code>delta.S</code>.</p>
</td></tr>
<tr><td><code id="least.squares.capa.ident_+3A_a.shapley.interval">A.Shapley.interval</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the quantitative importance of the
criteria. Each line of this 3-column matrix corresponds to one
constraint of the type &quot;the Shapley importance index of criterion
<code>i</code> lies in the interval <code>[a,b]</code>&quot;. The interval
<code>[a,b]</code> has to be included in <code>[0,1]</code>. A line of the
matrix is structured as follows: the first element encodes <code>i</code>,
the second <code>a</code>, and the third <code>b</code>.</p>
</td></tr>
<tr><td><code id="least.squares.capa.ident_+3A_a.interaction.preorder">A.interaction.preorder</code></td>
<td>
<p>Object of class <code>matrix</code>
containing the constraints relative to the preorder of the pairs of
criteria in terms of the Shapley interaction index. Each line of this 5-column matrix
corresponds to one constraint of the type &quot;the Shapley interaction
index of the pair <code>ij</code> of criteria is greater than the Shapley interaction
index of the pair <code>kl</code> of criteria with preference threshold <code>delta.I</code>&quot;.
A line is structured as follows: the first two elements encode
<code>ij</code>, the second two <code>kl</code>, and the fifth element contains
the preference threshold <code>delta.I</code>.</p>
</td></tr>
<tr><td><code id="least.squares.capa.ident_+3A_a.interaction.interval">A.interaction.interval</code></td>
<td>
<p>Object of class <code>matrix</code>
containing the constraints relative to the type and the magnitude of
the Shapley interaction index for pairs of criteria. Each line of
this 4-column matrix corresponds to one constraint of the type
&quot;the Shapley interaction index of the pair <code>ij</code> of criteria
lies in the interval <code>[a,b]</code>&quot;. The interval <code>[a,b]</code> has to
be included in <code>[-1,1]</code>. A line is structured as follows: the first two elements encode
<code>ij</code>, the third element encodes <code>a</code>, and the fourth element
encodes <code>b</code>.</p>
</td></tr>
<tr><td><code id="least.squares.capa.ident_+3A_a.inter.additive.partition">A.inter.additive.partition</code></td>
<td>
<p>Object of class <code>numeric</code>
encoding a partition of the set of criteria imposing that there be
no interactions among criteria belonging to different classes 
of the partition. The partition is to be given under the form of a
vector of integers from <code>{1,...,n}</code> of length <code>n</code> such
that two criteria belonging to the same class are &quot;marked&quot; by the
same integer. For instance, the partition <code>{{1,3},{2,4},{5}}</code> can
be encoded as <code>c(1,2,1,2,3)</code>. See Fujimoto and Murofushi (2000)
for more details on the concept of mu-inter-additive partition.</p>
</td></tr>
<tr><td><code id="least.squares.capa.ident_+3A_sigf">sigf</code></td>
<td>
<p>Precision (default: 7 significant figures). Parameter to
be passed to the <code>ipop</code> function (quadratic programming)
of the <span class="pkg">kernlab</span> package.</p>
</td></tr>
<tr><td><code id="least.squares.capa.ident_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations. Parameter to
be passed to the <code>ipop</code> function (quadratic programming)
of the <span class="pkg">kernlab</span> package.</p>
</td></tr>
<tr><td><code id="least.squares.capa.ident_+3A_epsilon">epsilon</code></td>
<td>
<p>Object of class <code>numeric</code> containing the
threshold value for the monotonicity constraints, i.e. the
difference between the &quot;weights&quot; of two subsets whose cardinals
differ exactly by 1 must be greater than <code>epsilon</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quadratic program is solved using the <code>ipop</code> function of
the <span class="pkg">kernlab</span> package.
</p>


<h3>Value</h3>

<p>The function returns a list structured as follows:
</p>
<table>
<tr><td><code>solution</code></td>
<td>
<p>Object of class
<code>Mobius.capacity</code> containing the Möbius transform of the
<code>k</code>-additive solution, if any.</p>
</td></tr>
<tr><td><code>dual</code></td>
<td>
<p>The dual solution of the problem.</p>
</td></tr>
<tr><td><code>how</code></td>
<td>
<p>Character string describing the type of convergence.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Differences between the provided global evaluations
and those returned by the obtained model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>K. Fujimoto and T. Murofushi (2000) <em>Hierarchical decomposition of the
Choquet integral</em>, in: Fuzzy Measures and Integrals: Theory and
Applications, M. Grabisch, T. Murofushi, and M. Sugeno Eds, Physica
Verlag, pages 95-103.
</p>
<p>M. Grabisch, H.T. Nguyen and E.A. Walker (1995), <em>Fundamentals of
uncertainty calculi with applications to fuzzy inference</em>, Kluwer
Academic, Dordrecht.
</p>
<p>M. Grabisch and M. Roubens (2000), <em>Application of the Choquet Integral in
Multicriteria Decision Making</em>, in: Fuzzy Measures and Integrals: Theory and
Applications, M. Grabisch, T. Murofushi, and M. Sugeno Eds, Physica Verlag,
pages 415-434.
</p>
<p>P. Miranda and M. Grabisch (1999), <em>Optimization issues for fuzzy measures</em>,
International Journal of Fuzziness and Knowledge-based Systems 7:6, pages
545-560.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+heuristic.ls.capa.ident">heuristic.ls.capa.ident</a></code>,
<br /> <code><a href="#topic+lin.prog.capa.ident">lin.prog.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.var.capa.ident">mini.var.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.dist.capa.ident">mini.dist.capa.ident</a></code>,
<br /> <code><a href="#topic+ls.sorting.capa.ident">ls.sorting.capa.ident</a></code>,
<br /> <code><a href="#topic+entropy.capa.ident">entropy.capa.ident</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## the number of data
n.d &lt;- 20

## a randomly generated 5-criteria matrix
C &lt;- matrix(rnorm(5*n.d,10,2),n.d,5)


## the corresponding global scores
g &lt;- numeric(n.d)
mu &lt;- capacity(c(0:29,29,29)/29)
for (i in 1:n.d)
  g[i] &lt;- Choquet.integral(mu,C[i,])

## Not run: 
## the full solution 
lsc &lt;- least.squares.capa.ident(5,5,C,g)
a &lt;- lsc$solution
a
mu.sol &lt;- zeta(a)

## the difference between mu and mu.sol
mu@data - mu.sol@data

## the residuals
lsc$residuals

## the mean square error
mean(lsc$residuals^2)

## a 3-additive solution 
lsc &lt;- least.squares.capa.ident(5,3,C,g)
a &lt;- lsc$solution
mu.sol &lt;- zeta(a)
mu@data - mu.sol@data
lsc$residuals

## End(Not run)



## a similar example based on the Sipos integral

## a randomly generated 5-criteria matrix
C &lt;- matrix(rnorm(5*n.d,0,2),n.d,5)

## the corresponding global scores
g &lt;- numeric(n.d)
mu &lt;- capacity(c(0:29,29,29)/29)
for (i in 1:n.d)
  g[i] &lt;- Sipos.integral(mu,C[i,])

## Not run: 
## the full solution 
lsc &lt;- least.squares.capa.ident(5,5,C,g,Integral = "Sipos")
a &lt;- lsc$solution
mu.sol &lt;- zeta(a)
mu@data - mu.sol@data
lsc$residuals

## a 3-additive solution 
lsc &lt;- least.squares.capa.ident(5,3,C,g,Integral = "Sipos")
a &lt;- lsc$solution
mu.sol &lt;- zeta(a)
mu@data - mu.sol@data
lsc$residuals

## End(Not run)



## additional constraints

## a Shapley preorder constraint matrix
## Sh(1) - Sh(2) &gt;= -delta.S
## Sh(2) - Sh(1) &gt;= -delta.S
## Sh(3) - Sh(4) &gt;= -delta.S
## Sh(4) - Sh(3) &gt;= -delta.S
## i.e. criteria 1,2 and criteria 3,4
## should have the same global importances
delta.S &lt;- 0.01    
Asp &lt;- rbind(c(1,2,-delta.S),
             c(2,1,-delta.S),
             c(3,4,-delta.S),
             c(4,3,-delta.S)
            )

## a Shapley interval constraint matrix
## 0.3 &lt;= Sh(1) &lt;= 0.9 
Asi &lt;- rbind(c(1,0.3,0.9))


## an interaction preorder constraint matrix
## such that I(12) = I(45)
delta.I &lt;- 0.01
Aip &lt;- rbind(c(1,2,4,5,-delta.I),
             c(4,5,1,2,-delta.I))

## an interaction interval constraint matrix
## i.e. -0.20 &lt;= I(12) &lt;= -0.15 
delta.I &lt;- 0.01
Aii &lt;- rbind(c(1,2,-0.2,-0.15))

## an inter-additive partition constraint
## criteria 1,2,3 and criteria 4,5 are independent 
Aiap &lt;- c(1,1,1,2,2)





## a more constrained solution

lsc &lt;- least.squares.capa.ident(5,5,C,g,Integral = "Sipos",
                                 A.Shapley.preorder = Asp,
                                 A.Shapley.interval = Asi,
                                 A.interaction.preorder = Aip,
                                 A.interaction.interval = Aii,
                                 A.inter.additive.partition = Aiap,
                                 sigf = 5)

a &lt;- lsc$solution
mu.sol &lt;- zeta(a)
mu@data - mu.sol@data
lsc$residuals
summary(a)
</code></pre>

<hr>
<h2 id='lin.prog.capa.ident'>Capacity identification based on linear programming</h2><span id='topic+lin.prog.capa.ident'></span>

<h3>Description</h3>

<p>Creates an object of class <code>Mobius.capacity</code> using the
linear programming approach proposed by Marichal and Roubens (see
reference hereafter). Roughly speaking, this function determines, if it
exists, the capacity compatible with a set of linear constraints that
&quot;separates&quot; the most the provided alternatives. The problem is solved
using the <span class="pkg">lpSolve</span> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin.prog.capa.ident(n, k, A.Choquet.preorder = NULL,
A.Shapley.preorder = NULL, A.Shapley.interval = NULL,
A.interaction.preorder = NULL, A.interaction.interval = NULL,
A.inter.additive.partition = NULL, epsilon = 1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin.prog.capa.ident_+3A_n">n</code></td>
<td>
<p>Object of class <code>numeric</code> containing the
number of elements of the set on which the object of class
<code>Mobius.capacity</code> is to be defined.</p>
</td></tr>
<tr><td><code id="lin.prog.capa.ident_+3A_k">k</code></td>
<td>
<p>Object of class <code>numeric</code> imposing that the solution is at
most a k-additive capacity (the Möbius transform of subsets whose cardinal is
superior to <code>k</code> vanishes).</p>
</td></tr>
<tr><td><code id="lin.prog.capa.ident_+3A_a.choquet.preorder">A.Choquet.preorder</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the preorder of the alternatives. Each line
of the matrix corresponds to one constraint of the type &quot;alternative
<code>a</code> is preferred to alternative <code>b</code> with preference threshold
<code>delta.C</code>&quot;. A line is structured as follows: the first <code>n</code>
elements encode alternative <code>a</code>, the next <code>n</code> elements
encode alternative <code>b</code>, and the last element contains the
preference threshold <code>delta.C</code>.</p>
</td></tr>
<tr><td><code id="lin.prog.capa.ident_+3A_a.shapley.preorder">A.Shapley.preorder</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the preorder of the criteria. Each line
of this 3-column matrix corresponds to one constraint of the type
&quot;the Shapley importance index of criterion <code>i</code> is greater than
the Shapley importance index of criterion <code>j</code> with preference threshold
<code>delta.S</code>&quot;. A line is structured as follows: the first element
encodes <code>i</code>, the second <code>j</code>, and the third element contains
the preference threshold <code>delta.S</code>.</p>
</td></tr>
<tr><td><code id="lin.prog.capa.ident_+3A_a.shapley.interval">A.Shapley.interval</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the quantitative importance of the
criteria. Each line of this 3-column matrix corresponds to one
constraint of the type &quot;the Shapley importance index of criterion
<code>i</code> lies in the interval <code>[a,b]</code>&quot;. The interval
<code>[a,b]</code> has to be included in <code>[0,1]</code>. A line of the
matrix is structured as follows: the first element encodes <code>i</code>,
the second <code>a</code>, and the third <code>b</code>.</p>
</td></tr>
<tr><td><code id="lin.prog.capa.ident_+3A_a.interaction.preorder">A.interaction.preorder</code></td>
<td>
<p>Object of class <code>matrix</code>
containing the constraints relative to the preorder of the pairs of
criteria in terms of the Shapley interaction index. Each line of this 5-column matrix
corresponds to one constraint of the type &quot;the Shapley interaction
index of the pair <code>ij</code> of criteria is greater than the Shapley interaction
index of the pair <code>kl</code> of criteria with preference threshold <code>delta.I</code>&quot;.
A line is structured as follows: the first two elements encode
<code>ij</code>, the second two <code>kl</code>, and the fifth element contains
the preference threshold <code>delta.I</code>.</p>
</td></tr>
<tr><td><code id="lin.prog.capa.ident_+3A_a.interaction.interval">A.interaction.interval</code></td>
<td>
<p>Object of class <code>matrix</code>
containing the constraints relative to the type and the magnitude of
the Shapley interaction index for pairs of criteria. Each line of
this 4-column matrix corresponds to one constraint of the type
&quot;the Shapley interaction index of the pair <code>ij</code> of criteria
lies in the interval <code>[a,b]</code>&quot;. The interval <code>[a,b]</code> has to
be included in <code>[-1,1]</code>. A line is structured as follows: the first two elements encode
<code>ij</code>, the third element encodes <code>a</code>, and the fourth element
encodes <code>b</code>.</p>
</td></tr>
<tr><td><code id="lin.prog.capa.ident_+3A_a.inter.additive.partition">A.inter.additive.partition</code></td>
<td>
<p>Object of class <code>numeric</code>
encoding a partition of the set of criteria imposing that there be
no interactions among criteria belonging to different classes 
of the partition. The partition is to be given under the form of a
vector of integers from <code>{1,...,n}</code> of length <code>n</code> such
that two criteria belonging to the same class are &quot;marked&quot; by the
same integer. For instance, the partition <code>{{1,3},{2,4},{5}}</code> can
be encoded as <code>c(1,2,1,2,3)</code>. See Fujimoto and Murofushi (2000)
for more details on the concept of mu-inter-additive partition.</p>
</td></tr>
<tr><td><code id="lin.prog.capa.ident_+3A_epsilon">epsilon</code></td>
<td>
<p>Object of class <code>numeric</code> containing the
thresold value for the monotonicity constraints, i.e. the
difference between the &quot;weights&quot; of two subsets whose cardinals
differ exactly by 1 must be greater than <code>epsilon</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear program is solved using the <code>lp</code> function of
the <span class="pkg">lpSolve</span>.
</p>


<h3>Value</h3>

<p>The function returns a list structured as follows:
</p>
<table>
<tr><td><code>solution</code></td>
<td>
<p>Object of class <code>Mobius.capacity</code> containing the
Möbius transform of the <code>k</code>-additive solution, if any.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Value of the objective function.</p>
</td></tr>
<tr><td><code>lp.object</code></td>
<td>
<p>Object of class <code>lp.object</code> returned by <code>lpSolve</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>K. Fujimoto and T. Murofushi (2000) <em>Hierarchical decomposition of the
Choquet integral</em>, in: Fuzzy Measures and Integrals: Theory and
Applications, M. Grabisch, T. Murofushi, and M. Sugeno Eds, Physica
Verlag, pages 95-103.
</p>
<p>J-L. Marichal and M. Roubens (2000), <em>Determination of weights
of interacting criteria from a reference set</em>, European Journal of
Operational Research 124, pages 641-650.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+mini.var.capa.ident">mini.var.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.dist.capa.ident">mini.dist.capa.ident</a></code>,
<br /> <code><a href="#topic+least.squares.capa.ident">least.squares.capa.ident</a></code>,
<br /> <code><a href="#topic+heuristic.ls.capa.ident">heuristic.ls.capa.ident</a></code>,
<br /> <code><a href="#topic+ls.sorting.capa.ident">ls.sorting.capa.ident</a></code>,
<br /> <code><a href="#topic+entropy.capa.ident">entropy.capa.ident</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## some alternatives
a &lt;- c(18,11,18,11,11)
b &lt;- c(18,18,11,11,11)
c &lt;- c(11,11,18,18,11)
d &lt;- c(18,11,11,11,18)
e &lt;- c(11,11,18,11,18)
    
## preference threshold relative
## to the preorder of the alternatives
delta.C &lt;- 1

## corresponding Choquet preorder constraint matrix 
Acp &lt;- rbind(c(d,a,delta.C),
             c(a,e,delta.C),
             c(e,b,delta.C),
             c(b,c,delta.C)
            )

## a Shapley preorder constraint matrix
## Sh(1) - Sh(2) &gt;= -delta.S
## Sh(2) - Sh(1) &gt;= -delta.S
## Sh(3) - Sh(4) &gt;= -delta.S
## Sh(4) - Sh(3) &gt;= -delta.S
## i.e. criteria 1,2 and criteria 3,4
## should have the same global importances
delta.S &lt;- 0.01    
Asp &lt;- rbind(c(1,2,-delta.S),
             c(2,1,-delta.S),
             c(3,4,-delta.S),
             c(4,3,-delta.S)
            )

## a Shapley interval constraint matrix
## 0.3 &lt;= Sh(1) &lt;= 0.9 
Asi &lt;- rbind(c(1,0.3,0.9))


## an interaction preorder constraint matrix
## such that I(12) = I(34)
delta.I &lt;- 0.01
Aip &lt;- rbind(c(1,2,3,4,-delta.I),
             c(3,4,1,2,-delta.I))

## an interaction interval constraint matrix
## i.e. -0.20 &lt;= I(12) &lt;= -0.15 
Aii &lt;- rbind(c(1,2,-0.2,-0.15))


## Not run: 
## a LP 2-additive solution
lin.prog &lt;- lin.prog.capa.ident(5,2,A.Choquet.preorder = Acp)              
m &lt;- lin.prog$solution
m

## the resulting global evaluations
rbind(c(a,mean(a),Choquet.integral(m,a)),
      c(b,mean(b),Choquet.integral(m,b)),
      c(c,mean(c),Choquet.integral(m,c)),
      c(d,mean(d),Choquet.integral(m,d)),
      c(e,mean(e),Choquet.integral(m,e)))

## the Shapley value
Shapley.value(m)

## a LP 3-additive more constrained solution
lin.prog2 &lt;- lin.prog.capa.ident(5,3,
                                   A.Choquet.preorder = Acp,
                                   A.Shapley.preorder = Asp)
m &lt;- lin.prog2$solution
m
rbind(c(a,mean(a),Choquet.integral(m,a)),
      c(b,mean(b),Choquet.integral(m,b)),
      c(c,mean(c),Choquet.integral(m,c)),
      c(d,mean(d),Choquet.integral(m,d)),
      c(e,mean(e),Choquet.integral(m,e)))
Shapley.value(m)

## a LP 5-additive more constrained solution
lin.prog3 &lt;- lin.prog.capa.ident(5,5,
                                   A.Choquet.preorder = Acp,
                                   A.Shapley.preorder = Asp,
                                   A.Shapley.interval = Asi,
                                   A.interaction.preorder = Aip,
                                   A.interaction.interval = Aii)

m &lt;- lin.prog3$solution
m
rbind(c(a,mean(a),Choquet.integral(m,a)),
      c(b,mean(b),Choquet.integral(m,b)),
      c(c,mean(c),Choquet.integral(m,c)),
      c(d,mean(d),Choquet.integral(m,d)),
      c(e,mean(e),Choquet.integral(m,e)))
summary(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='ls.ranking.capa.ident'>Least squares capacity identification in the framework of a ranking procedure</h2><span id='topic+ls.ranking.capa.ident'></span>

<h3>Description</h3>

<p>Ranking alternatives means ordering them from the best to the worst alternative. The aim of the implemented method is to model a given ranking by means of a Choquet integral. The result of the function is an object of class <code>Mobius.capacity</code>. This function is an implementation of the TOMASO method (see Meyer and Roubens (2005)) in the particular ranking framework. The input data are given under the form of a set of alternatives and a partial weak order, each alternative being described according to a set of criteria. These well-known alternatives are called &quot;prototypes&quot;. They represent alternatives for which the decision maker has an a priori knowledge and for which he/she is able to build a ranking. If the provided ranking (partial weak order) of the prototypes cannot be described by a Choquet integral, an approximative solution, which minimizes the &quot;gap&quot; between the given ranking and the one derived from the Choquet integral, is proposed. The problem is solved by quadratic programming. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls.ranking.capa.ident(n, k, C, rk, d, A.Shapley.preorder = NULL,
A.Shapley.interval = NULL, A.interaction.preorder = NULL,
A.interaction.interval = NULL, A.inter.additive.partition = NULL,
sigf = 5, maxiter = 20, epsilon = 1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ls.ranking.capa.ident_+3A_n">n</code></td>
<td>
<p>Object of class <code>numeric</code> containing the
number of elements of the set on which the object of class
<code>Mobius.capacity</code> is to be defined (in short, the number of criteria).</p>
</td></tr>
<tr><td><code id="ls.ranking.capa.ident_+3A_k">k</code></td>
<td>
<p>Object of class <code>numeric</code> imposing that the solution is at
most a k-additive capacity (the Moebius transform of subsets whose cardinal is
superior to <code>k</code> vanishes).</p>
</td></tr>
<tr><td><code id="ls.ranking.capa.ident_+3A_c">C</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
<code>n</code>-column criteria matrix. Each line of this matrix
corresponds to a prototype.</p>
</td></tr>
<tr><td><code id="ls.ranking.capa.ident_+3A_rk">rk</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the preorder of the prototypes. Each line
of this 2-column matrix corresponds to one constraint of the type
&quot;the alternative <code>i</code> is prefered to the alternative <code>j</code>&quot;. A line is structured as follows: the first element
encodes <code>i</code>, the second <code>j</code>.</p>
</td></tr>
<tr><td><code id="ls.ranking.capa.ident_+3A_d">d</code></td>
<td>
<p>Object of class <code>numeric</code> containing the threshold value, i.e. the minimal &quot;distance&quot; between two neighbor alternatives in the given ranking (e.g. the difference in terms of the Choquet integral of the
a prototype with rank 3 and a prototype with rank 4 should be at least <code>d</code>).</p>
</td></tr>
<tr><td><code id="ls.ranking.capa.ident_+3A_a.shapley.preorder">A.Shapley.preorder</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the preorder of the criteria. Each line
of this 3-column matrix corresponds to one constraint of the type
&quot;the Shapley importance index of criterion <code>i</code> is greater than
the Shapley importance index of criterion <code>j</code> with preference threshold
<code>delta.S</code>&quot;. A line is structured as follows: the first element
encodes <code>i</code>, the second <code>j</code>, and the third element contains
the preference threshold <code>delta.S</code>.</p>
</td></tr>
<tr><td><code id="ls.ranking.capa.ident_+3A_a.shapley.interval">A.Shapley.interval</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the quantitative importance of the
criteria. Each line of this 3-column matrix corresponds to one
constraint of the type &quot;the Shapley importance index of criterion
<code>i</code> lies in the interval <code>[a,b]</code>&quot;. The interval
<code>[a,b]</code> has to be included in <code>[0,1]</code>. A line of the
matrix is structured as follows: the first element encodes <code>i</code>,
the second <code>a</code>, and the third <code>b</code>.</p>
</td></tr>
<tr><td><code id="ls.ranking.capa.ident_+3A_a.interaction.preorder">A.interaction.preorder</code></td>
<td>
<p>Object of class <code>matrix</code>
containing the constraints relative to the preorder of the pairs of
criteria in terms of the Shapley interaction index. Each line of this 5-column matrix
corresponds to one constraint of the type &quot;the Shapley interaction
index of the pair <code>ij</code> of criteria is greater than the Shapley interaction
index of the pair <code>kl</code> of criteria with preference threshold <code>delta.I</code>&quot;.
A line is structured as follows: the first two elements encode
<code>ij</code>, the second two <code>kl</code>, and the fifth element contains
the preference threshold <code>delta.I</code>.</p>
</td></tr>
<tr><td><code id="ls.ranking.capa.ident_+3A_a.interaction.interval">A.interaction.interval</code></td>
<td>
<p>Object of class <code>matrix</code>
containing the constraints relative to the type and the magnitude of
the Shapley interaction index for pairs of criteria. Each line of
this 4-column matrix corresponds to one constraint of the type
&quot;the Shapley interaction index of the pair <code>ij</code> of criteria
lies in the interval <code>[a,b]</code>&quot;. The interval <code>[a,b]</code> has to
be included in <code>[-1,1]</code>. A line is structured as follows: the first two elements encode
<code>ij</code>, the third element encodes <code>a</code>, and the fourth element
encodes <code>b</code>.</p>
</td></tr>
<tr><td><code id="ls.ranking.capa.ident_+3A_a.inter.additive.partition">A.inter.additive.partition</code></td>
<td>
<p>Object of class <code>numeric</code>
encoding a partition of the set of criteria imposing that there be
no interactions among criteria belonging to different classes 
of the partition. The partition is to be given under the form of a
vector of integers from <code>{1,...,n}</code> of length <code>n</code> such
that two criteria belonging to the same class are &quot;marked&quot; by the
same integer. For instance, the partition <code>{{1,3},{2,4},{5}}</code> can
be encoded as <code>c(1,2,1,2,3)</code>. See Fujimoto and Murofushi (2000)
for more details on the concept of mu-inter-additive partition.</p>
</td></tr>
<tr><td><code id="ls.ranking.capa.ident_+3A_sigf">sigf</code></td>
<td>
<p>Precision (default: 5 significant figures). Parameter to
be passed to the <code>ipop</code> function (quadratic programming)
of the <span class="pkg">kernlab</span> package.</p>
</td></tr>
<tr><td><code id="ls.ranking.capa.ident_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations. Parameter to
be passed to the <code>ipop</code> function (quadratic programming)
of the <span class="pkg">kernlab</span> package.</p>
</td></tr>
<tr><td><code id="ls.ranking.capa.ident_+3A_epsilon">epsilon</code></td>
<td>
<p>Object of class <code>numeric</code> containing the
threshold value for the monotonicity constraints, i.e. the
difference between the &quot;weights&quot; of two subsets whose cardinals
differ exactly by 1 must be greater than <code>epsilon</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quadratic program is solved using the <code>ipop</code> function of
the <span class="pkg">kernlab</span> package.
</p>


<h3>Value</h3>

<p>The function returns a list structured as follows:
</p>
<table>
<tr><td><code>solution</code></td>
<td>
<p>Object of class
<code>Mobius.capacity</code> containing the Moebius transform of the
<code>k</code>-additive solution.</p>
</td></tr>
<tr><td><code>glob.eval</code></td>
<td>
<p>The global evaluations satisfying the given ranking.</p>
</td></tr>
<tr><td><code>how</code></td>
<td>
<p>Information returned by <code>ipop</code> (cf. <span class="pkg">kernlab</span>) on
the convergence of the solver.</p>
</td></tr>
<tr><td><code>rk.C</code></td>
<td>
<p>The ranks of the prototypes</p>
</td></tr>
<tr><td><code>Choquet.C</code></td>
<td>
<p>The Choquet integral of the prototypes</p>
</td></tr>
</table>


<h3>References</h3>

<p>K. Fujimoto and T. Murofushi (2000) <em>Hierarchical decomposition of the
Choquet integral</em>, in: Fuzzy Measures and Integrals: Theory and
Applications, M. Grabisch, T. Murofushi, and M. Sugeno Eds, Physica
Verlag, pages 95-103.
</p>
<p>P. Meyer, M. Roubens (2005), <em>Choice, Ranking and Sorting in Fuzzy Multiple
Criteria Decision Aid</em>, in: J. Figueira, S. Greco, and M. Ehrgott,
Eds, Multiple Criteria Decision Analysis: State of the Art
Surveys, volume 78 of International Series in Operations Research and
Management Science, chapter 12, pages 471-506. Springer Science +
Business Media, Inc., New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+lin.prog.capa.ident">lin.prog.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.var.capa.ident">mini.var.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.dist.capa.ident">mini.dist.capa.ident</a></code>,
<br /> <code><a href="#topic+least.squares.capa.ident">least.squares.capa.ident</a></code>,
<br /> <code><a href="#topic+heuristic.ls.capa.ident">heuristic.ls.capa.ident</a></code>,
<br /> <code><a href="#topic+entropy.capa.ident">entropy.capa.ident</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
arthur &lt;- c(1, 1, 0.75, 0.25)
lancelot &lt;- c(0.75, 0.75, 0.75, 0.75)
yvain &lt;- c(1, 0.625, 0.5, 1)
perceval &lt;- c(0.25, 0.5, 0.75, 0.75)
erec &lt;- c(0.375, 1, 0.5 , 0.75)

P &lt;- rbind(arthur, lancelot, yvain, perceval, erec)

# lancelot &gt; erec; yvain &gt; erec, erec &gt; perceval, erec &gt; arthur
rk.proto &lt;- rbind(c("lancelot","erec"), c("yvain","erec"), c("erec","perceval"), c("erec","arthur"))

n&lt;-4
k&lt;-2
d&lt;-0.1

## search for a capacity which satisfies the constraints
lrc &lt;- ls.ranking.capa.ident(n ,k, P, rk.proto, d)

lrc

</code></pre>

<hr>
<h2 id='ls.sorting.capa.ident'>Least squares capacity identification in the framework of a sorting procedure</h2><span id='topic+ls.sorting.capa.ident'></span>

<h3>Description</h3>

<p>Sorting alternatives means assigning each alternative to a predefined
ordered class. The aim of the implemented method is to model a given classification (sorting)
of the alternatives by means of a Choquet integral. The result of the function
is an object of class <code>Mobius.capacity</code>. This function (in
combination with <code>ls.sorting.treatment</code>) is an implementation of
the TOMASO method; see Meyer and Roubens (2005). The input data are
given under the form of a set of alternatives and associated classes,
each alternative being described according to a set of criteria. These
well-known alternatives are called &quot;prototypes&quot;. They represent
alternatives for which the decision maker has an a priori knowledge
and that he/she is able to assign to one of the
ordered classes. If the provided classification of the prototypes cannot be
described by a Choquet integral, an approximative solution, which minimizes
the &quot;gap&quot; between the given classification and the one derived from
the Choquet integral, is proposed. The problem is solved by quadratic
programming. This function should be used in combination with
<code>ls.sorting.treatment</code> which allows to evaluate the model which
has been built and to assign other alternatives to the ordered classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls.sorting.capa.ident(n, k, C, cl, d, A.Shapley.preorder = NULL,
A.Shapley.interval = NULL, A.interaction.preorder = NULL,
A.interaction.interval = NULL, A.inter.additive.partition = NULL,
sigf = 5, maxiter = 20, epsilon = 1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ls.sorting.capa.ident_+3A_n">n</code></td>
<td>
<p>Object of class <code>numeric</code> containing the
number of elements of the set on which the object of class
<code>Mobius.capacity</code> is to be defined (in short, the number of criteria).</p>
</td></tr>
<tr><td><code id="ls.sorting.capa.ident_+3A_k">k</code></td>
<td>
<p>Object of class <code>numeric</code> imposing that the solution is at
most a k-additive capacity (the Möbius transform of subsets whose cardinal is
superior to <code>k</code> vanishes).</p>
</td></tr>
<tr><td><code id="ls.sorting.capa.ident_+3A_c">C</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
<code>n</code>-column criteria matrix. Each line of this matrix
corresponds to a prototype.</p>
</td></tr>
<tr><td><code id="ls.sorting.capa.ident_+3A_cl">cl</code></td>
<td>
<p>Object of class <code>numeric</code> containing the indexes of the
classes the alternatives are belonging to (the greater the class
index, the better the prototype is considered by the decision
maker). Each class index between min(cl) and max(cl) must be present.</p>
</td></tr>
<tr><td><code id="ls.sorting.capa.ident_+3A_d">d</code></td>
<td>
<p>Object of class <code>numeric</code> containing the threshold value
for the classes, i.e. the minimal &quot;distance&quot; between two neighbor
classes (e.g. the difference in terms of the Choquet integral of the
worst prototype of class 3 and the best prototype of
class 2 should be at least <code>d</code>).</p>
</td></tr>
<tr><td><code id="ls.sorting.capa.ident_+3A_a.shapley.preorder">A.Shapley.preorder</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the preorder of the criteria. Each line
of this 3-column matrix corresponds to one constraint of the type
&quot;the Shapley importance index of criterion <code>i</code> is greater than
the Shapley importance index of criterion <code>j</code> with preference threshold
<code>delta.S</code>&quot;. A line is structured as follows: the first element
encodes <code>i</code>, the second <code>j</code>, and the third element contains
the preference threshold <code>delta.S</code>.</p>
</td></tr>
<tr><td><code id="ls.sorting.capa.ident_+3A_a.shapley.interval">A.Shapley.interval</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the quantitative importance of the
criteria. Each line of this 3-column matrix corresponds to one
constraint of the type &quot;the Shapley importance index of criterion
<code>i</code> lies in the interval <code>[a,b]</code>&quot;. The interval
<code>[a,b]</code> has to be included in <code>[0,1]</code>. A line of the
matrix is structured as follows: the first element encodes <code>i</code>,
the second <code>a</code>, and the third <code>b</code>.</p>
</td></tr>
<tr><td><code id="ls.sorting.capa.ident_+3A_a.interaction.preorder">A.interaction.preorder</code></td>
<td>
<p>Object of class <code>matrix</code>
containing the constraints relative to the preorder of the pairs of
criteria in terms of the Shapley interaction index. Each line of this 5-column matrix
corresponds to one constraint of the type &quot;the Shapley interaction
index of the pair <code>ij</code> of criteria is greater than the Shapley interaction
index of the pair <code>kl</code> of criteria with preference threshold <code>delta.I</code>&quot;.
A line is structured as follows: the first two elements encode
<code>ij</code>, the second two <code>kl</code>, and the fifth element contains
the preference threshold <code>delta.I</code>.</p>
</td></tr>
<tr><td><code id="ls.sorting.capa.ident_+3A_a.interaction.interval">A.interaction.interval</code></td>
<td>
<p>Object of class <code>matrix</code>
containing the constraints relative to the type and the magnitude of
the Shapley interaction index for pairs of criteria. Each line of
this 4-column matrix corresponds to one constraint of the type
&quot;the Shapley interaction index of the pair <code>ij</code> of criteria
lies in the interval <code>[a,b]</code>&quot;. The interval <code>[a,b]</code> has to
be included in <code>[-1,1]</code>. A line is structured as follows: the first two elements encode
<code>ij</code>, the third element encodes <code>a</code>, and the fourth element
encodes <code>b</code>.</p>
</td></tr>
<tr><td><code id="ls.sorting.capa.ident_+3A_a.inter.additive.partition">A.inter.additive.partition</code></td>
<td>
<p>Object of class <code>numeric</code>
encoding a partition of the set of criteria imposing that there be
no interactions among criteria belonging to different classes 
of the partition. The partition is to be given under the form of a
vector of integers from <code>{1,...,n}</code> of length <code>n</code> such
that two criteria belonging to the same class are &quot;marked&quot; by the
same integer. For instance, the partition <code>{{1,3},{2,4},{5}}</code> can
be encoded as <code>c(1,2,1,2,3)</code>. See Fujimoto and Murofushi (2000)
for more details on the concept of mu-inter-additive partition.</p>
</td></tr>
<tr><td><code id="ls.sorting.capa.ident_+3A_sigf">sigf</code></td>
<td>
<p>Precision (default: 5 significant figures). Parameter to
be passed to the <code>ipop</code> function (quadratic programming)
of the <span class="pkg">kernlab</span> package.</p>
</td></tr>
<tr><td><code id="ls.sorting.capa.ident_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations. Parameter to
be passed to the <code>ipop</code> function (quadratic programming)
of the <span class="pkg">kernlab</span> package.</p>
</td></tr>
<tr><td><code id="ls.sorting.capa.ident_+3A_epsilon">epsilon</code></td>
<td>
<p>Object of class <code>numeric</code> containing the
threshold value for the monotonicity constraints, i.e. the
difference between the &quot;weights&quot; of two subsets whose cardinals
differ exactly by 1 must be greater than <code>epsilon</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quadratic program is solved using the <code>ipop</code> function of
the <span class="pkg">kernlab</span> package.
</p>


<h3>Value</h3>

<p>The function returns a list structured as follows:
</p>
<table>
<tr><td><code>solution</code></td>
<td>
<p>Object of class
<code>Mobius.capacity</code> containing the Möbius transform of the
<code>k</code>-additive solution.</p>
</td></tr>
<tr><td><code>glob.eval</code></td>
<td>
<p>The global evaluations satisfying the given classification.</p>
</td></tr>
<tr><td><code>how</code></td>
<td>
<p>Information returned by <code>ipop</code> (cf. <span class="pkg">kernlab</span>) on
the convergence of the solver.</p>
</td></tr>
</table>


<h3>References</h3>

<p>K. Fujimoto and T. Murofushi (2000) <em>Hierarchical decomposition of the
Choquet integral</em>, in: Fuzzy Measures and Integrals: Theory and
Applications, M. Grabisch, T. Murofushi, and M. Sugeno Eds, Physica
Verlag, pages 95-103.
</p>
<p>P. Meyer, M. Roubens (2005), <em>Choice, Ranking and Sorting in Fuzzy Multiple
Criteria Decision Aid</em>, in: J. Figueira, S. Greco, and M. Ehrgott,
Eds, Multiple Criteria Decision Analysis: State of the Art
Surveys, volume 78 of International Series in Operations Research and
Management Science, chapter 12, pages 471-506. Springer Science +
Business Media, Inc., New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+lin.prog.capa.ident">lin.prog.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.var.capa.ident">mini.var.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.dist.capa.ident">mini.dist.capa.ident</a></code>,
<br /> <code><a href="#topic+least.squares.capa.ident">least.squares.capa.ident</a></code>,
<br /> <code><a href="#topic+heuristic.ls.capa.ident">heuristic.ls.capa.ident</a></code>,
<br /> <code><a href="#topic+ls.sorting.treatment">ls.sorting.treatment</a></code>,
<br /> <code><a href="#topic+entropy.capa.ident">entropy.capa.ident</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate a random problem with 10 prototypes and 4 criteria
n.proto &lt;- 10 ## prototypes
n &lt;- 4  ## criteria
k &lt;- 4  
d &lt;- 0.1
	
## generating random data for the prototypes
C &lt;- matrix(runif(n.proto*n,0,1),n.proto,n)
cl &lt;- numeric(n.proto)

## the corresponding global evaluations
glob.eval &lt;- numeric(n.proto)
a &lt;- capacity(c(0:(2^n-3),(2^n-3),(2^n-3))/(2^n-3))
for (i in 1:n.proto)
  glob.eval[i] &lt;- Choquet.integral(a,C[i,])

## and the classes for the prototypes
cl[glob.eval &lt;= 0.33] &lt;- 1
cl[glob.eval &gt; 0.33 &amp; glob.eval &lt;= 0.66] &lt;-2
cl[glob.eval &gt; 0.66] &lt;- 3

cl

## Not run: 
# starting the calculations
# search for a capacity which satisfies the constraints
lsc &lt;- ls.sorting.capa.ident(n ,k, C, cl, d)

## output of the quadratic program (ipop, package kernlab)
lsc$how

## the capacity satisfying the constraints
lsc$solution
summary(lsc$solution)
## the global evaluations satisfying the constraints
lsc$glob.eval

## End(Not run)

## let us now add some constraints        

## a Shapley preorder constraint matrix
## Sh(1) &gt; Sh(2)
## Sh(3) &gt; Sh(4)
delta.S &lt;-0.01
Asp &lt;- rbind(c(1,2,delta.S), c(3,4,delta.S))

## a Shapley interval constraint matrix
## 0.1 &lt;= Sh(1) &lt;= 0.2 
Asi &lt;- rbind(c(1,0.1,0.2))
        
## an interaction preorder constraint matrix
## such that I(12) &gt; I(34)
delta.I &lt;- 0.01
Aip &lt;- rbind(c(1,2,3,4,delta.I))
        
## an interaction interval constraint matrix
## i.e. 0.2 &lt;= I(12) &lt;= 0.4 
## and 0 &lt; I(34) &lt;= 1
Aii &lt;- rbind(c(1,2,0.2,0.4), c(3,4,delta.I,1))
        
## an inter-additive partition constraint
## criteria 1,2 and criteria 3,4 are independent 
Aiap &lt;- c(1,1,2,2)


## starting the calculations
## search for a capacity which satisfies the constraints
lsc &lt;- ls.sorting.capa.ident(n ,k, C, cl, d,
                                  A.Shapley.preorder = Asp,
                                  A.Shapley.interval = Asi,
                                  A.interaction.preorder = Aip,
                                  A.interaction.interval = Aii,
                                  A.inter.additive.partition = Aiap)

## output of ipop
lsc$how
## the capacity satisfying the constraints
lsc$solution
summary(lsc$solution)
## the global evaluations satisfying the constraints
lsc$glob.eval

</code></pre>

<hr>
<h2 id='ls.sorting.treatment'>Least squares capacity identification in the framework of a
sorting procedure: evaluation of the determined capacity</h2><span id='topic+ls.sorting.treatment'></span>

<h3>Description</h3>

<p>This function assigns alternatives to classes and optionally compares
the obtained classification to a given one. The classes are
described by a set of prototypes (well-known alternatives for the
decision maker) and a   capacity (which can, for instance, be determined by
<code>ls.sorting.capa.ident</code>).   This function (in combination with
<code>ls.sorting.capa.ident</code>) is an
implementation of the TOMASO method; see Meyer and Roubens (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls.sorting.treatment(P, cl.proto, a, A, cl.orig.A = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ls.sorting.treatment_+3A_p">P</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
<code>n</code>-column criteria matrix. Each line of this matrix
corresponds to a prototype. A prototype is an alternative for which
the class is known beforehand.</p>
</td></tr>
<tr><td><code id="ls.sorting.treatment_+3A_cl.proto">cl.proto</code></td>
<td>
<p>Object of class <code>numeric</code> containing the indexes of the
classes the prototypes <code>P</code> are belonging to (the greater the class
index, the better the prototype is considered by the decision maker).</p>
</td></tr>
<tr><td><code id="ls.sorting.treatment_+3A_a">a</code></td>
<td>
<p>Object of class <code>Mobius.capacity</code> used to model the
classes determined by <code>P</code> by a Choquet integral.</p>
</td></tr>
<tr><td><code id="ls.sorting.treatment_+3A_a">A</code></td>
<td>
<p>Object of class <code>matrix</code> containing the <code>n</code>-column
criteria matrix representing the alternatives which have to be classified.</p>
</td></tr> 
<tr><td><code id="ls.sorting.treatment_+3A_cl.orig.a">cl.orig.A</code></td>
<td>
<p>Object of class <code>numeric</code>
containing the &quot;true&quot; classes of the alternatives of <code>A</code>. This
can be used for the evaluation of the quality of the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list structured as follows:
</p>
<table>
<tr><td><code>correct.A</code></td>
<td>
<p>Object of class <code>matrix</code> which contains the
different types of assignments of the elements of <code>A</code>. In
columns the alternatives. First line: correct assignment to a single class
(assignment of degree 0). Second line: correct ambiguous assignment to two
classes (assignment of degree 1), etc. Last line: bad assignment. In
case no <code>orig.class.A</code> is given, <code>correct.A</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>class.A</code></td>
<td>
<p>Object of class <code>matrix</code> which contains the
assignments of the elements of <code>A</code>. In columns, the
alternatives. First line, lower class. Second line, upper class. </p>
</td></tr>
<tr><td><code>eval.correct</code></td>
<td>
<p>Object of class <code>numeric</code> which contains the
ratio assignments over number of elements of <code>A</code>(for each type
of assignment; the first element is the ratio of correct
assignments). In
case no <code>orig.class.A</code> is given, <code>eval.correct</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>minmax.P</code></td>
<td>
<p>Object of class <code>matrix</code> which contains the min
and the max of each class, according to the prototypes. In columns,
the classes, first line: the minimum, second line: the maximum.</p>
</td></tr>
<tr><td><code>Choquet.A</code></td>
<td>
<p>Object of class <code>numeric</code> which contains the
Choquet integral of the evaluations of the alternatives of <code>A</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>P. Meyer, M. Roubens (2005), <em>Choice, Ranking and Sorting in Fuzzy Multiple
Criteria Decision Aid</em>, in: J. Figueira, S. Greco, and M. Ehrgott,
Eds, Multiple Criteria Decision Analysis: State of the Art
Surveys, volume 78 of International Series in Operations Research and
Management Science, chapter 12, pages 471-506. Springer Science +
Business Media, Inc., New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+mini.var.capa.ident">mini.var.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.dist.capa.ident">mini.dist.capa.ident</a></code>,
<br /> <code><a href="#topic+ls.sorting.capa.ident">ls.sorting.capa.ident</a></code>,
<br /> <code><a href="#topic+least.squares.capa.ident">least.squares.capa.ident</a></code>,
<br /> <code><a href="#topic+heuristic.ls.capa.ident">heuristic.ls.capa.ident</a></code>,
<br /> <code><a href="#topic+entropy.capa.ident">entropy.capa.ident</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate a random problem with 10 prototypes and 4 criteria
n.proto &lt;- 10 ## prototypes
n &lt;- 4  ## criteria
P &lt;- matrix(runif(n.proto*n,0,1),n.proto,n)

## the corresponding global scores, based on a randomly generated
## capacity a
glob.eval &lt;- numeric(n.proto)
a &lt;- capacity(c(0:(2^n-3),(2^n-3),(2^n-3))/(2^n-3))
for (i in 1:n.proto)
  glob.eval[i] &lt;- Choquet.integral(a,P[i,])

## based on these global scores, let us create a classification (3 classes)
cl.proto&lt;-numeric(n.proto)
cl.proto[glob.eval &lt;= 0.33] &lt;- 1
cl.proto[glob.eval &gt; 0.33 &amp; glob.eval&lt;=0.66] &lt;-2
cl.proto[glob.eval &gt; 0.66] &lt;- 3

## search for a capacity which satisfies the constraints
lsc &lt;- ls.sorting.capa.ident(n ,4, P, cl.proto, 0.1)

## output of the QP
lsc$how

## analyse the quality of the model (classify the prototypes by the
## model and compare both assignments)
lst &lt;- ls.sorting.treatment(P,cl.proto,lsc$solution,P,cl.proto)

## assignments of the prototypes
lst$class.A
## assignment types
lst$correct.A
## evaluation
lst$eval.correct

## generate a second set of random alternatives (A)
## their "correct" class is determined as beforehand with the
## randomly generated capacity a
## the goal is to see if we can reproduce this classification
## by the capacity learnt from the prototypes

## a randomly generated criteria matrix of 10 alternatives
A &lt;- matrix(runif(10*n,0,1),10,n)
cl.orig.A &lt;-numeric(10)
	
## the corresponding global scores
glob.eval.A &lt;- numeric(10)
for (i in 1:10)
  glob.eval.A[i] &lt;- Choquet.integral(a,A[i,])

## based on these global scores, let us determine a classification
cl.orig.A[glob.eval.A &lt;= 0.33] &lt;- 1
cl.orig.A[glob.eval.A&gt;0.33 &amp; glob.eval.A&lt;=0.66] &lt;-2
cl.orig.A[glob.eval.A &gt; 0.66] &lt;- 3

## let us now classify the alternatives of A according to the model
## built on P

lst &lt;- ls.sorting.treatment(P,cl.proto,lsc$solution,A,cl.orig.A)

## assignment of the alternatives of A
lst$class.A
## type of assignments
lst$correct.A
## evaluation
lst$eval.correct

## show the learnt capacity
## x11()
## barplot(Shapley.value(lsc$solution), main="Learnt capacity", sub="Shapley")
## summary of the learnt capacity
lsc$solution
summary(lsc$solution)

</code></pre>

<hr>
<h2 id='mini.dist.capa.ident'>Minimum distance capacity identification</h2><span id='topic+mini.dist.capa.ident'></span>

<h3>Description</h3>

<p>Creates an object of class <code>Mobius.capacity</code> using a
minimum distance principle. More precisely, this function determines,
if it exists, the closest capacity to a user-given game compatible
with a set of linear constraints. The distance can be chosen among
three quadratic distances (see help and references hereafter). The
problem is solved using strictly convex quadratic programming.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mini.dist.capa.ident(a, k, distance = "Choquet.coefficients",
A.Choquet.preorder = NULL, A.Shapley.preorder = NULL,
A.Shapley.interval = NULL, A.interaction.preorder = NULL,
A.interaction.interval = NULL, A.inter.additive.partition = NULL,
epsilon = 1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mini.dist.capa.ident_+3A_a">a</code></td>
<td>
<p>Object of class <code>Mobius.game</code> containing the
Möbius transform of the game to be approached.</p>
</td></tr>
<tr><td><code id="mini.dist.capa.ident_+3A_k">k</code></td>
<td>
<p>Object of class <code>numeric</code> imposing that the solution is at
most a k-additive capacity (the Möbius transform of subsets whose cardinal is
superior to <code>k</code> vanishes).</p>
</td></tr>
<tr><td><code id="mini.dist.capa.ident_+3A_distance">distance</code></td>
<td>
<p>Object of class <code>character</code> indicating which
quadratic distance is to be used in the objective function. The choice
<code>distance = "Choquet.coefficients"</code> will result in the
minimization of the average distance  between Choquet integral
coefficients, the choice <code>distance = "binary.alternatives"</code>
will result in the minimization of the average distance between binary
alternatives, and the choice <code>distance = "global.scores"</code> will
result in the minimization of the average distance between global scores.</p>
</td></tr>
<tr><td><code id="mini.dist.capa.ident_+3A_a.choquet.preorder">A.Choquet.preorder</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the preorder of the alternatives. Each line
of the matrix corresponds to one constraint of the type &quot;alternative
<code>a</code> is preferred to alternative <code>b</code> with preference threshold
<code>delta.C</code>&quot;. A line is structured as follows: the first <code>n</code>
elements encode alternative <code>a</code>, the next <code>n</code> elements
encode alternative <code>b</code>, and the last element contains the
preference threshold <code>delta.C</code>.</p>
</td></tr>
<tr><td><code id="mini.dist.capa.ident_+3A_a.shapley.preorder">A.Shapley.preorder</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the preorder of the criteria. Each line
of this 3-column matrix corresponds to one constraint of the type
&quot;the Shapley importance index of criterion <code>i</code> is greater than
the Shapley importance index of criterion <code>j</code> with preference threshold
<code>delta.S</code>&quot;. A line is structured as follows: the first element
encodes <code>i</code>, the second <code>j</code>, and the third element contains
the preference threshold <code>delta.S</code>.</p>
</td></tr>
<tr><td><code id="mini.dist.capa.ident_+3A_a.shapley.interval">A.Shapley.interval</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the quantitative importance of the
criteria. Each line of this 3-column matrix corresponds to one
constraint of the type &quot;the Shapley importance index of criterion
<code>i</code> lies in the interval <code>[a,b]</code>&quot;. The interval
<code>[a,b]</code> has to be included in <code>[0,1]</code>. A line of the
matrix is structured as follows: the first element encodes <code>i</code>,
the second <code>a</code>, and the third <code>b</code>.</p>
</td></tr>
<tr><td><code id="mini.dist.capa.ident_+3A_a.interaction.preorder">A.interaction.preorder</code></td>
<td>
<p>Object of class <code>matrix</code>
containing the constraints relative to the preorder of the pairs of
criteria in terms of the Shapley interaction index. Each line of this 5-column matrix
corresponds to one constraint of the type &quot;the Shapley interaction
index of the pair <code>ij</code> of criteria is greater than the Shapley interaction
index of the pair <code>kl</code> of criteria with preference threshold <code>delta.I</code>&quot;.
A line is structured as follows: the first two elements encode
<code>ij</code>, the second two <code>kl</code>, and the fifth element contains
the preference threshold <code>delta.I</code>.</p>
</td></tr>
<tr><td><code id="mini.dist.capa.ident_+3A_a.interaction.interval">A.interaction.interval</code></td>
<td>
<p>Object of class <code>matrix</code>
containing the constraints relative to the type and the magnitude of
the Shapley interaction index for pairs of criteria. Each line of
this 4-column matrix corresponds to one constraint of the type
&quot;the Shapley interaction index of the pair <code>ij</code> of criteria
lies in the interval <code>[a,b]</code>&quot;. The interval <code>[a,b]</code> has to
be included in <code>[-1,1]</code>. A line is structured as follows: the first two elements encode
<code>ij</code>, the third element encodes <code>a</code>, and the fourth element
encodes <code>b</code>.</p>
</td></tr>
<tr><td><code id="mini.dist.capa.ident_+3A_a.inter.additive.partition">A.inter.additive.partition</code></td>
<td>
<p>Object of class <code>numeric</code>
encoding a partition of the set of criteria imposing that there be
no interactions among criteria belonging to different classes 
of the partition. The partition is to be given under the form of a
vector of integers from <code>{1,...,n}</code> of length <code>n</code> such
that two criteria belonging to the same class are &quot;marked&quot; by the
same integer. For instance, the partition <code>{{1,3},{2,4},{5}}</code> can
be encoded as <code>c(1,2,1,2,3)</code>. See Fujimoto and Murofushi (2000)
for more details on the concept of mu-inter-additive partition.</p>
</td></tr>
<tr><td><code id="mini.dist.capa.ident_+3A_epsilon">epsilon</code></td>
<td>
<p>Object of class <code>numeric</code> containing the
thresold value for the monotonicity constraints, i.e. the
difference between the &quot;weights&quot; of two subsets whose cardinals
differ exactly by 1 must be greater than <code>epsilon</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quadratic program is solved using the <code>solve.QP</code> function of
the <span class="pkg">quadprog</span> package.
</p>


<h3>Value</h3>

<p>The function returns a list structured as follows:
</p>
<table>
<tr><td><code>solution</code></td>
<td>
<p>Object of class <code>Mobius.capacity</code> containing the
Möbius transform of the <code>k</code>-additive solution, if any.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Value of the objective function.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>Information returned by <code>solve.QP</code>.</p>
</td></tr>
<tr><td><code>iact</code></td>
<td>
<p>Information returned by <code>solve.QP</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>K. Fujimoto and T. Murofushi (2000) <em>Hierarchical decomposition of the
Choquet integral</em>, in: Fuzzy Measures and Integrals: Theory and
Applications, M. Grabisch, T. Murofushi, and M. Sugeno Eds, Physica
Verlag, pages 95-103.
</p>
<p>I. Kojadinovic (2006), <em>Quadratic objective functions for
capacity and bi-capacity identification and approximation</em>, A
Quarterly Journal of Operations Research (40R), in press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+lin.prog.capa.ident">lin.prog.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.var.capa.ident">mini.var.capa.ident</a></code>,
<br /> <code><a href="#topic+least.squares.capa.ident">least.squares.capa.ident</a></code>,
<br /> <code><a href="#topic+heuristic.ls.capa.ident">heuristic.ls.capa.ident</a></code>,
<br /> <code><a href="#topic+ls.sorting.capa.ident">ls.sorting.capa.ident</a></code>,
<br /> <code><a href="#topic+entropy.capa.ident">entropy.capa.ident</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## some alternatives
a &lt;- c(18,11,18,11,11)
b &lt;- c(18,18,11,11,11)
c &lt;- c(11,11,18,18,11)
d &lt;- c(18,11,11,11,18)
e &lt;- c(11,11,18,11,18)
    
## preference threshold relative
## to the preorder of the alternatives
delta.C &lt;- 1

## corresponding Choquet preorder constraint matrix 
Acp &lt;- rbind(c(d,a,delta.C),
             c(a,e,delta.C),
             c(e,b,delta.C),
             c(b,c,delta.C)
            )

## a Shapley preorder constraint matrix
## Sh(1) - Sh(2) &gt;= -delta.S
## Sh(2) - Sh(1) &gt;= -delta.S
## Sh(3) - Sh(4) &gt;= -delta.S
## Sh(4) - Sh(3) &gt;= -delta.S
## i.e. criteria 1,2 and criteria 3,4
## should have the same global importances
delta.S &lt;- 0.01    
Asp &lt;- rbind(c(1,2,-delta.S),
             c(2,1,-delta.S),
             c(3,4,-delta.S),
             c(4,3,-delta.S)
            )

## a Shapley interval constraint matrix
## 0.3 &lt;= Sh(1) &lt;= 0.9 
Asi &lt;- rbind(c(1,0.3,0.9))


## an interaction preorder constraint matrix
## such that I(12) = I(34)
delta.I &lt;- 0.01
Aip &lt;- rbind(c(1,2,3,4,-delta.I),
             c(3,4,1,2,-delta.I))

## an interaction interval constraint matrix
## i.e. -0.20 &lt;= I(12) &lt;= -0.15 
Aii &lt;- rbind(c(1,2,-0.2,-0.15))

## the capacity that we want to approach
x &lt;- runif(31)
for (i in 2:31)
    x[i] &lt;- x[i] + x[i-1]
mu &lt;- normalize(capacity(c(0,x)))
## and its Mobius transform
a.mu &lt;- Mobius(mu)

## some basic checks
## Not run: 
mini.dist.capa.ident(a.mu,5)
mini.dist.capa.ident(a.mu,5,"binary.alternatives")
mini.dist.capa.ident(a.mu,5,"global.scores")
mini.dist.capa.ident(a.mu,3)
mini.dist.capa.ident(a.mu,3,"binary.alternatives")
mini.dist.capa.ident(a.mu,3,"global.scores")

## End(Not run)

## a minimum distance 2-additive solution
min.dist &lt;- mini.dist.capa.ident(a.mu,2,"binary.alternatives",
                                 A.Choquet.preorder = Acp)              
m &lt;- min.dist$solution
m

## a minimum distance 3-additive more constrained solution
min.dist2 &lt;- mini.dist.capa.ident(a.mu,3,"global.scores",
                                   A.Choquet.preorder = Acp,
                                   A.Shapley.preorder = Asp)
m &lt;- min.dist2$solution
m
rbind(c(a,mean(a),Choquet.integral(m,a)),
      c(b,mean(b),Choquet.integral(m,b)),
      c(c,mean(c),Choquet.integral(m,c)),
      c(d,mean(d),Choquet.integral(m,d)),
      c(e,mean(e),Choquet.integral(m,e)))
Shapley.value(m)

## Not run: 
## a minimum distance 5-additive more constrained solution
min.dist3 &lt;- mini.dist.capa.ident(a.mu,5,
                                   A.Choquet.preorder = Acp,
                                   A.Shapley.preorder = Asp,
                                   A.Shapley.interval = Asi,
                                   A.interaction.preorder = Aip,
                                   A.interaction.interval = Aii)

m &lt;- min.dist3$solution
m
rbind(c(a,mean(a),Choquet.integral(m,a)),
      c(b,mean(b),Choquet.integral(m,b)),
      c(c,mean(c),Choquet.integral(m,c)),
      c(d,mean(d),Choquet.integral(m,d)),
      c(e,mean(e),Choquet.integral(m,e)))
summary(m)

## End(Not run)

</code></pre>

<hr>
<h2 id='mini.var.capa.ident'>Minimum variance capacity identification</h2><span id='topic+mini.var.capa.ident'></span>

<h3>Description</h3>

<p>Creates an object of class <code>Mobius.capacity</code> using a
maximum like quadratic entropy principle, which is equivalent to the minimization of the
variance. More precisely, this function determines, if it exists, the minimum
variance capacity compatible with a set of linear constraints. The
problem is solved using strictly convex quadratic programming.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mini.var.capa.ident(n, k, A.Choquet.preorder = NULL,
A.Shapley.preorder = NULL, A.Shapley.interval = NULL,
A.interaction.preorder = NULL, A.interaction.interval = NULL,
A.inter.additive.partition = NULL, epsilon = 1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mini.var.capa.ident_+3A_n">n</code></td>
<td>
<p>Object of class <code>numeric</code> containing the
number of elements of the set on which the object of class
<code>Mobius.capacity</code> is to be defined.</p>
</td></tr>
<tr><td><code id="mini.var.capa.ident_+3A_k">k</code></td>
<td>
<p>Object of class <code>numeric</code> imposing that the solution is at
most a k-additive capacity (the Möbius transform of subsets whose cardinal is
superior to <code>k</code> vanishes).</p>
</td></tr>
<tr><td><code id="mini.var.capa.ident_+3A_a.choquet.preorder">A.Choquet.preorder</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the preorder of the alternatives. Each line
of the matrix corresponds to one constraint of the type &quot;alternative
<code>a</code> is preferred to alternative <code>b</code> with preference threshold
<code>delta.C</code>&quot;. A line is structured as follows: the first <code>n</code>
elements encode alternative <code>a</code>, the next <code>n</code> elements
encode alternative <code>b</code>, and the last element contains the
preference threshold <code>delta.C</code>.</p>
</td></tr>
<tr><td><code id="mini.var.capa.ident_+3A_a.shapley.preorder">A.Shapley.preorder</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the preorder of the criteria. Each line
of this 3-column matrix corresponds to one constraint of the type
&quot;the Shapley importance index of criterion <code>i</code> is greater than
the Shapley importance index of criterion <code>j</code> with preference threshold
<code>delta.S</code>&quot;. A line is structured as follows: the first element
encodes <code>i</code>, the second <code>j</code>, and the third element contains
the preference threshold <code>delta.S</code>.</p>
</td></tr>
<tr><td><code id="mini.var.capa.ident_+3A_a.shapley.interval">A.Shapley.interval</code></td>
<td>
<p>Object of class <code>matrix</code> containing the
constraints relative to the quantitative importance of the
criteria. Each line of this 3-column matrix corresponds to one
constraint of the type &quot;the Shapley importance index of criterion
<code>i</code> lies in the interval <code>[a,b]</code>&quot;. The interval
<code>[a,b]</code> has to be included in <code>[0,1]</code>. A line of the
matrix is structured as follows: the first element encodes <code>i</code>,
the second <code>a</code>, and the third <code>b</code>.</p>
</td></tr>
<tr><td><code id="mini.var.capa.ident_+3A_a.interaction.preorder">A.interaction.preorder</code></td>
<td>
<p>Object of class <code>matrix</code>
containing the constraints relative to the preorder of the pairs of
criteria in terms of the Shapley interaction index. Each line of this 5-column matrix
corresponds to one constraint of the type &quot;the Shapley interaction
index of the pair <code>ij</code> of criteria is greater than the Shapley interaction
index of the pair <code>kl</code> of criteria with preference threshold <code>delta.I</code>&quot;.
A line is structured as follows: the first two elements encode
<code>ij</code>, the second two <code>kl</code>, and the fifth element contains
the preference threshold <code>delta.I</code>.</p>
</td></tr>
<tr><td><code id="mini.var.capa.ident_+3A_a.interaction.interval">A.interaction.interval</code></td>
<td>
<p>Object of class <code>matrix</code>
containing the constraints relative to the type and the magnitude of
the Shapley interaction index for pairs of criteria. Each line of
this 4-column matrix corresponds to one constraint of the type
&quot;the Shapley interaction index of the pair <code>ij</code> of criteria
lies in the interval <code>[a,b]</code>&quot;. The interval <code>[a,b]</code> has to
be included in <code>[-1,1]</code>. A line is structured as follows: the first two elements encode
<code>ij</code>, the third element encodes <code>a</code>, and the fourth element
encodes <code>b</code>.</p>
</td></tr>
<tr><td><code id="mini.var.capa.ident_+3A_a.inter.additive.partition">A.inter.additive.partition</code></td>
<td>
<p>Object of class <code>numeric</code>
encoding a partition of the set of criteria imposing that there be
no interactions among criteria belonging to different classes 
of the partition. The partition is to be given under the form of a
vector of integers from <code>{1,...,n}</code> of length <code>n</code> such
that two criteria belonging to the same class are &quot;marked&quot; by the
same integer. For instance, the partition <code>{{1,3},{2,4},{5}}</code> can
be encoded as <code>c(1,2,1,2,3)</code>. See Fujimoto and Murofushi (2000)
for more details on the concept of mu-inter-additive partition.</p>
</td></tr>
<tr><td><code id="mini.var.capa.ident_+3A_epsilon">epsilon</code></td>
<td>
<p>Object of class <code>numeric</code> containing the
thresold value for the monotonicity constraints, i.e. the
difference between the &quot;weights&quot; of two subsets whose cardinals
differ exactly by 1 must be greater than <code>epsilon</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quadratic program is solved using the <code>solve.QP</code> function of
the <span class="pkg">quadprog</span> package.
</p>


<h3>Value</h3>

<p>The function returns a list structured as follows:
</p>
<table>
<tr><td><code>solution</code></td>
<td>
<p>Object of class <code>Mobius.capacity</code> containing the
Möbius transform of the <code>k</code>-additive solution, if any.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Value of the objective function.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>Information returned by <code>solve.QP</code>.</p>
</td></tr>
<tr><td><code>iact</code></td>
<td>
<p>Information returned by <code>solve.QP</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>K. Fujimoto and T. Murofushi (2000) <em>Hierarchical decomposition of the
Choquet integral</em>, in: Fuzzy Measures and Integrals: Theory and
Applications, M. Grabisch, T. Murofushi, and M. Sugeno Eds, Physica
Verlag, pages 95-103.
</p>
<p>I. Kojadinovic (2005), <em>Minimum variance capacity
identification</em>, European Journal of Operational Research, in press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+lin.prog.capa.ident">lin.prog.capa.ident</a></code>,
<br /> <code><a href="#topic+mini.dist.capa.ident">mini.dist.capa.ident</a></code>,
<br /> <code><a href="#topic+least.squares.capa.ident">least.squares.capa.ident</a></code>,
<br /> <code><a href="#topic+heuristic.ls.capa.ident">heuristic.ls.capa.ident</a></code>,
<br /> <code><a href="#topic+ls.sorting.capa.ident">ls.sorting.capa.ident</a></code>,
<br /> <code><a href="#topic+entropy.capa.ident">entropy.capa.ident</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## some alternatives
a &lt;- c(18,11,18,11,11)
b &lt;- c(18,18,11,11,11)
c &lt;- c(11,11,18,18,11)
d &lt;- c(18,11,11,11,18)
e &lt;- c(11,11,18,11,18)
    
## preference threshold relative
## to the preorder of the alternatives
delta.C &lt;- 1

## corresponding Choquet preorder constraint matrix 
Acp &lt;- rbind(c(d,a,delta.C),
             c(a,e,delta.C),
             c(e,b,delta.C),
             c(b,c,delta.C)
            )

## a Shapley preorder constraint matrix
## Sh(1) - Sh(2) &gt;= -delta.S
## Sh(2) - Sh(1) &gt;= -delta.S
## Sh(3) - Sh(4) &gt;= -delta.S
## Sh(4) - Sh(3) &gt;= -delta.S
## i.e. criteria 1,2 and criteria 3,4
## should have the same global importances
delta.S &lt;- 0.01    
Asp &lt;- rbind(c(1,2,-delta.S),
             c(2,1,-delta.S),
             c(3,4,-delta.S),
             c(4,3,-delta.S)
            )

## a Shapley interval constraint matrix
## 0.3 &lt;= Sh(1) &lt;= 0.9 
Asi &lt;- rbind(c(1,0.3,0.9))


## an interaction preorder constraint matrix
## such that I(12) = I(34)
delta.I &lt;- 0.01
Aip &lt;- rbind(c(1,2,3,4,-delta.I),
             c(3,4,1,2,-delta.I))

## an interaction interval constraint matrix
## i.e. -0.20 &lt;= I(12) &lt;= -0.15 
Aii &lt;- rbind(c(1,2,-0.2,-0.15))


## a minimum variance 2-additive solution
min.var &lt;- mini.var.capa.ident(5,2,A.Choquet.preorder = Acp)              
m &lt;- min.var$solution
m

## the resulting global evaluations
rbind(c(a,mean(a),Choquet.integral(m,a)),
      c(b,mean(b),Choquet.integral(m,b)),
      c(c,mean(c),Choquet.integral(m,c)),
      c(d,mean(d),Choquet.integral(m,d)),
      c(e,mean(e),Choquet.integral(m,e)))

## the Shapley value
Shapley.value(m)

## a minimum variance 3-additive more constrained solution
min.var2 &lt;- mini.var.capa.ident(5,3,
                                   A.Choquet.preorder = Acp,
                                   A.Shapley.preorder = Asp)
m &lt;- min.var2$solution
m
rbind(c(a,mean(a),Choquet.integral(m,a)),
      c(b,mean(b),Choquet.integral(m,b)),
      c(c,mean(c),Choquet.integral(m,c)),
      c(d,mean(d),Choquet.integral(m,d)),
      c(e,mean(e),Choquet.integral(m,e)))
Shapley.value(m)

## a minimum variance 5-additive more constrained solution
min.var3 &lt;- mini.var.capa.ident(5,5,
                                   A.Choquet.preorder = Acp,
                                   A.Shapley.preorder = Asp,
                                   A.Shapley.interval = Asi,
                                   A.interaction.preorder = Aip,
                                   A.interaction.interval = Aii)

m &lt;- min.var3$solution
m
rbind(c(a,mean(a),Choquet.integral(m,a)),
      c(b,mean(b),Choquet.integral(m,b)),
      c(c,mean(c),Choquet.integral(m,c)),
      c(d,mean(d),Choquet.integral(m,d)),
      c(e,mean(e),Choquet.integral(m,e)))
summary(m)

</code></pre>

<hr>
<h2 id='Mobius-methods'>The Möbius transform</h2><span id='topic+Mobius'></span><span id='topic+Mobius-methods'></span><span id='topic+Mobius+2Ccapacity-method'></span><span id='topic+Mobius+2Ccard.set.func-method'></span><span id='topic+Mobius+2Cgame-method'></span><span id='topic+Mobius+2Cset.func-method'></span>

<h3>Description</h3>

<p>Computes the Möbius transform of a set function. The Möbius transform is the inverse of the zeta transform.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;capacity&quot; </dt><dd><p>Returns an object of class <code>Mobius.capacity</code>.</p>
</dd>
<dt>object = &quot;card.set.func&quot; </dt><dd><p>Returns an object of class <code>Mobius.card.set.func</code>.</p>
</dd>
<dt>object = &quot;game&quot; </dt><dd><p>Returns an object of class <code>Mobius.game</code>.</p>
</dd>
<dt>object = &quot;set.func&quot; </dt><dd><p>Returns an object of class <code>Mobius.set.func</code>.</p>
</dd>
</dl>


<h3>References</h3>

<p>G-C. Rota (1964), <em>On the foundations of combinatorial theory. I. Theory
of Möbius functions</em>, Z. Wahrscheinlichkeitstheorie und
Verw. Gebiete 2, pages 340-368.
</p>
<p>A. Chateauneuf and J-Y. Jaffray (1989), <em>Some characterizations of lower 
probabilities and other monotone capacities through the use of Möbius inversion</em>,
Mathematical Social Sciences 17, pages 263-283.
</p>
<p>M. Grabisch, J-L. Marichal and M. Roubens (2000), <em>Equivalent
representations of set functions</em>, Mathematics of Operations
Research 25:2, pages 157-178.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>, 
<br /> <code><a href="#topic+Mobius.card.set.func-class">Mobius.card.set.func-class</a></code>, 
<br /> <code><a href="#topic+Mobius.game-class">Mobius.game-class</a></code>,
<br /> <code><a href="#topic+Mobius.set.func-class">Mobius.set.func-class</a></code>,
<br /> <code><a href="#topic+capacity-class">capacity-class</a></code>, 
<br /> <code><a href="#topic+card.set.func-class">card.set.func-class</a></code>, 
<br /> <code><a href="#topic+game-class">game-class</a></code>,
<br /> <code><a href="#topic+set.func-class">set.func-class</a></code>, 
<br /> <code><a href="#topic+zeta-methods">zeta-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a capacity
mu &lt;- capacity(0:15)
mu

## its Mobius transform
a &lt;- Mobius(mu)
a

## its zeta transform
zeta(a)

## a similar example with a game object
mu &lt;- game(c(0,-2:12))
mu
Mobius(mu)
zeta(Mobius(mu))

## a similar example with a set.func object
mu &lt;- set.func(-7:8)
mu
Mobius(mu)
zeta(Mobius(mu))

## a similar example with a card.set.func object
mu &lt;- card.set.func(-3:4)
mu
Mobius(mu)
zeta(Mobius(mu))
</code></pre>

<hr>
<h2 id='Mobius.capacity-class'>Class &quot;Mobius.capacity&quot;</h2><span id='topic+Mobius.capacity-class'></span>

<h3>Description</h3>

<p>Class representing the Möbius transform of a capacity.</p>


<h3>Objects from the Class</h3>

<p>Objects can be mainly created by calls
to the functions <code>Mobius.capacity</code>,
<br /> <code>mini.var.capa.ident</code>,
<code>ls.sorting.capa.ident</code>,
and <code>least.squares.capa.ident</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>n</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 containing the
number of elements of the set on which the Möbius transform is
defined. </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 containg the order of
truncation of the Möbius transform: the value of subsets whose cardinal is
superior to k is put to zero.</p>
</dd>
<dt><code>subsets</code>:</dt><dd><p>Object of class <code>numeric</code> containing
the &quot;<code>k</code> power set&quot; of the underlying
set in &quot;natural&quot; order . The subsets are encoded as integers.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>numeric</code> of length
<code>choose(n,0) + ... + choose(n,k)</code> representing the
coefficients of a truncated Möbius transform of a capacity in &quot;natural&quot; order.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>Mobius.game</code>, directly.
Class <code>superclass.capacity</code>, directly. <br />
Class <code>Mobius.set.func</code>, by class <code>Mobius.game</code>.
Class <code>superclass.set.func</code>, by class <code>Mobius.game</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>entropy</dt><dd><p><code>signature(object = "Mobius.capacity")</code> </p>
</dd>
<dt>favor</dt><dd><p><code>signature(object = "Mobius.capacity")</code> </p>
</dd>
<dt>is.normalized</dt><dd><p><code>signature(object = "Mobius.capacity")</code> </p>
</dd>
<dt>normalize</dt><dd><p><code>signature(object = "Mobius.capacity")</code> </p>
</dd>
<dt>orness</dt><dd><p><code>signature(object = "Mobius.capacity")</code> </p>
</dd>
<dt>variance</dt><dd><p><code>signature(object = "Mobius.capacity")</code> </p>
</dd>
<dt>veto</dt><dd><p><code>signature(object = "Mobius.capacity")</code> </p>
</dd>
<dt>zeta</dt><dd><p><code>signature(object = "Mobius.capacity")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>,
<br /> <code><a href="#topic+entropy-methods">entropy-methods</a></code>,
<br /> <code><a href="#topic+favor-methods">favor-methods</a></code>, 
<br /> <code><a href="#topic+is.normalized-methods">is.normalized-methods</a></code>,
<br /> <code><a href="#topic+orness-methods">orness-methods</a></code>, 
<br /> <code><a href="#topic+variance-methods">variance-methods</a></code>,
<br /> <code><a href="#topic+veto-methods">veto-methods</a></code>,
<br /> <code><a href="#topic+zeta-methods">zeta-methods</a></code>,
<br /> <code><a href="#topic+mini.var.capa.ident">mini.var.capa.ident</a></code>,
<br /> <code><a href="#topic+least.squares.capa.ident">least.squares.capa.ident</a></code>,
<br /> <code><a href="#topic+ls.sorting.capa.ident">ls.sorting.capa.ident</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a capacity
mu &lt;- capacity(c(0,0,0:13))
## and its Mobius representation
a &lt;- Mobius(mu)
a

# the attributes of object a
a@n
a@k
a@data
a@subsets

## a test
is.normalized(a)
## normalize it
normalize(a)

## a transformation
zeta(a)
## Let us check ...
Mobius(zeta(a))

## some summary indices
orness(a)
veto(a)
favor(a)
variance(a)
entropy(a)
## the same
summary(a)
</code></pre>

<hr>
<h2 id='Mobius.card.set.func'>Creates an object representing the Möbius transform of a cardinal set function.</h2><span id='topic+Mobius.card.set.func'></span>

<h3>Description</h3>

<p>Creates objects of class <code>Mobius.card.set.func</code>: from
an object of class <code>numeric</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mobius.card.set.func(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mobius.card.set.func_+3A_object">object</code></td>
<td>
<p>An object of class <code>numeric</code> containing the
coefficients of the cardinal Möbius representation. The coefficient
at position <code>k</code> corresponds to the value of the cardinal
Möbius representation for subsets of size <code>k</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>Mobius.card.set.func</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.card.set.func-class">Mobius.card.set.func-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Mobius.card.set.func(4:-2)
</code></pre>

<hr>
<h2 id='Mobius.card.set.func-class'>Class &quot;Mobius.card.set.func&quot;</h2><span id='topic+Mobius.card.set.func-class'></span>

<h3>Description</h3>

<p>Class representing the Möbius transform of a cardinal
set function.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the function
<code>Mobius.card.set.func</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>n</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 equal
to the number of elements of the set on which the Möbius
representation of a cardinal set function is defined.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>numeric</code> of length
<code>n+1</code> containing the coefficients of the Möbius
representation of a cardinal set function.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>superclass.set.func</code>, directly.</p>


<h3>Methods</h3>


<dl>
<dt>as.Mobius.set.func</dt><dd><p><code>signature(object =
	"Mobius.card.set.func")</code></p>
</dd>
<dt>as.set.func</dt><dd><p><code>signature(object =
	"Mobius.card.set.func")</code></p>
</dd>
<dt>as.card.set.func</dt><dd><p><code>signature(object = "Mobius.card.set.func")</code></p>
</dd>
<dt>to.data.frame</dt><dd><p><code>signature(object = "Mobius.card.set.func")</code></p>
</dd>
<dt>zeta</dt><dd><p><code>signature(object = "Mobius.card.set.func")</code></p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+Mobius.set.func-class">Mobius.set.func-class</a></code>,
<br /> <code><a href="#topic+Mobius.card.set.func">Mobius.card.set.func</a></code>,
<br /> <code><a href="#topic+as.Mobius.set.func-methods">as.Mobius.set.func-methods</a></code>, 
<br /> <code><a href="#topic+as.card.set.func-methods">as.card.set.func-methods</a></code>,
<br /> <code><a href="#topic+as.set.func-methods">as.set.func-methods</a></code>,
<br /> <code><a href="#topic+zeta-methods">zeta-methods</a></code>, 
<br /> <code><a href="#topic+to.data.frame-methods">to.data.frame-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the Mobius representation of a cardinal set function
a &lt;- Mobius.card.set.func(-3:2)

# the attributes of the object
a@n
a@data

## some transformations
as.set.func(a)
zeta(a)
## let us check ...
Mobius(zeta(a))
</code></pre>

<hr>
<h2 id='Mobius.game-class'>Class &quot;Mobius.game&quot;</h2><span id='topic+Mobius.game-class'></span>

<h3>Description</h3>

<p>Class representing the Möbius transform of a game.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the function <code>Mobius.game</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>n</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 containing the
number of elements of the set on which the Möbius transform is
defined. </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 containg the order
of truncation of the Möbius transform: subsets whose cardinal is
superior to k are considered to be zero.</p>
</dd>
<dt><code>subsets</code>:</dt><dd><p>Object of class <code>numeric</code> containing
the &quot;<code>k</code> power set&quot; of the underlying
set in &quot;natural&quot; order . The subsets are encoded as integers.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>numeric</code> of length
<code>choose(n,0) + ... + choose(n,k)</code> representing the
coefficients of a truncated Möbius transform of a game in &quot;natural&quot; order.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>Mobius.set.func</code>, directly.
Class <code>superclass.set.func</code>, by class <code>Mobius.set.func</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>Choquet.integral</dt><dd><p><code>signature(object = "Mobius.game", f =
	"numeric")</code> </p>
</dd>
<dt>Sipos.integral</dt><dd><p><code>signature(object = "Mobius.game", f =
	"numeric")</code> </p>
</dd>
<dt>Sugeno.integral</dt><dd><p><code>signature(object = "Mobius.game", f =
	"numeric")</code> </p>
</dd>
<dt>zeta</dt><dd><p><code>signature(object = "Mobius.game")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+game-class">game-class</a></code>,
<br /> <code><a href="#topic+Mobius.game">Mobius.game</a></code>,
<br /> <code><a href="#topic+Choquet.integral-methods">Choquet.integral-methods</a></code>,
<br /> <code><a href="#topic+Sipos.integral-methods">Sipos.integral-methods</a></code>, 
<br /> <code><a href="#topic+Sugeno.integral-methods">Sugeno.integral-methods</a></code>,
<br /> <code><a href="#topic+zeta-methods">zeta-methods</a></code>,
<br /> <code><a href="#topic+expect.Choquet.norm-methods">expect.Choquet.norm-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a game (which is a capacity)
mu &lt;- game(c(0,rep(1,15)))
## and its Mobius representation
a &lt;- Mobius(mu)

# the attributes of object a
a@n
a@k
a@data
a@subsets

## a transformation
zeta(a)
## let us check ...
Mobius(zeta(a))

## integral calculations 
f &lt;- c(0.2,0.3,0.1,0.7)
Choquet.integral(a,f)
Sugeno.integral(a,f)
f &lt;- c(0.2,-0.3,0.1,-0.7)
Sipos.integral(a,f)
</code></pre>

<hr>
<h2 id='Mobius.set.func'>Create objects representing the Möbius transform of a set function.</h2><span id='topic+Mobius.set.func'></span><span id='topic+Mobius.game'></span><span id='topic+Mobius.capacity'></span><span id='topic+additive.capacity'></span>

<h3>Description</h3>

<p>These functions create objects of class
<code>Mobius.set.func</code>, <code>Mobius.game</code>, or <br />
<code>Mobius.capacity</code> from an object of class <code>numeric</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mobius.set.func(object, n, k)
Mobius.game(object, n, k)
Mobius.capacity(object, n, k)
additive.capacity(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mobius.set.func_+3A_n">n</code></td>
<td>
<p>An object of class <code>numeric</code> of length 1 equal to the
cardinal of the set on which the Möbius representation is defined.</p>
</td></tr>
<tr><td><code id="Mobius.set.func_+3A_k">k</code></td>
<td>
<p>An object of class <code>numeric</code> of length 1 equal to the
order of truncation of the Möbius representation. Coefficients whose
cardinal is superior to <code>k</code> are considered to be zero.</p>
</td></tr>
<tr><td><code id="Mobius.set.func_+3A_object">object</code></td>
<td>
<p>Object of class <code>numeric</code> of length
<code>choose(n,0) + ... + choose(n,k)</code> representing the
coefficients of the truncated Möbius transform in
&quot;natural&quot; order.</p>
</td></tr>
<tr><td><code id="Mobius.set.func_+3A_v">v</code></td>
<td>
<p>An object of class <code>numeric</code> containing the coefficients
of the capacity on singletons.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Return objects of class <code>Mobius.set.func</code>, <code>Mobius.game</code>, or <code>Mobius.capacity</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,  
<br /> <code><a href="#topic+Mobius.game-class">Mobius.game-class</a></code>,
<br /> <code><a href="#topic+Mobius.set.func-class">Mobius.set.func-class</a></code>,
<br /> <code><a href="#topic+k.truncate.Mobius-methods">k.truncate.Mobius-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Mobius.set.func(c(0,1,1,2,1,2,1,2,2,3,2),4,2)
Mobius.game(c(0,1,1,2,1,2,1,2,2,3,2),4,2)
Mobius.capacity(c(0,1,1,2,1,2,1,2,2,3,2),4,2)
additive.capacity(c(1,2,3,4))
</code></pre>

<hr>
<h2 id='Mobius.set.func-class'>Class &quot;Mobius.set.func&quot;</h2><span id='topic+Mobius.set.func-class'></span>

<h3>Description</h3>

<p>Class representing the Möbius transform of a set function.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the
function <code>Mobius.set.func</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>n</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 containing the
number of elements of the set on which the Möbius transform is
defined. </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 containg the order
of truncation of the Möbius transform: subsets whose cardinal is
superior to k are considered to be zero.</p>
</dd>
<dt><code>subsets</code>:</dt><dd><p>Object of class <code>numeric</code> containing
the &quot;<code>k</code> power set&quot; of the underlying
set in &quot;natural&quot; order . The subsets are encoded as integers.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>numeric</code> of length
<code>choose(n,0) + ... + choose(n,k)</code> representing the
coefficients of a truncated Möbius transform of a set function in &quot;natural&quot; order.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>superclass.set.func</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "Mobius.set.func")</code> </p>
</dd>
<dt>as.Mobius.card.set.func</dt><dd><p><code>signature(object =
	"Mobius.set.func")</code> </p>
</dd>
<dt>as.card.set.func</dt><dd><p><code>signature(object =
	"Mobius.set.func")</code> </p>
</dd>
<dt>as.set.func</dt><dd><p><code>signature(object = "Mobius.set.func")</code></p>
</dd>
<dt>as.Mobius.game</dt><dd><p><code>signature(object = "Mobius.set.func")</code></p>
</dd>
<dt>as.Mobius.capacity</dt><dd><p><code>signature(object = "Mobius.set.func")</code></p>
</dd>
<dt>interaction.indices</dt><dd><p><code>signature(object = "Mobius.set.func")</code></p>
</dd>
<dt>is.cardinal</dt><dd><p><code>signature(object = "Mobius.set.func")</code></p>
</dd>
<dt>is.kadditive</dt><dd><p><code>signature(object = "Mobius.set.func", k =
	"numeric")</code> </p>
</dd>
<dt>is.monotone</dt><dd><p><code>signature(object = "Mobius.set.func")</code></p>
</dd>
<dt>k.truncate.Mobius</dt><dd><p><code>signature(object = "Mobius.set.func",
	k = "numeric")</code></p>
</dd>
<dt>Shapley.value</dt><dd><p><code>signature(object = "Mobius.set.func")</code></p>
</dd>
<dt>to.data.frame</dt><dd><p><code>signature(object = "Mobius.set.func")</code></p>
</dd>
<dt>zeta</dt><dd><p><code>signature(object = "Mobius.set.func")</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+set.func-class">set.func-class</a></code>, 
<br /> <code><a href="#topic+Mobius.set.func">Mobius.set.func</a></code>,
<br /> <code><a href="#topic+as.Mobius.card.set.func-methods">as.Mobius.card.set.func-methods</a></code>,
<br /> <code><a href="#topic+as.card.set.func-methods">as.card.set.func-methods</a></code>,
<br /> <code><a href="#topic+as.set.func-methods">as.set.func-methods</a></code>,  
<br /> <code><a href="#topic+as.Mobius.game-methods">as.Mobius.game-methods</a></code>,
<br /> <code><a href="#topic+as.Mobius.capacity-methods">as.Mobius.capacity-methods</a></code>, 
<br /> <code><a href="#topic+interaction.indices-methods">interaction.indices-methods</a></code>, 
<br /> <code><a href="#topic+is.cardinal-methods">is.cardinal-methods</a></code>, 
<br /> <code><a href="#topic+is.kadditive-methods">is.kadditive-methods</a></code>,
<br /> <code><a href="#topic+is.monotone-methods">is.monotone-methods</a></code>, 
<br /> <code><a href="#topic+k.truncate.Mobius-methods">k.truncate.Mobius-methods</a></code>, 
<br /> <code><a href="#topic+Shapley.value-methods">Shapley.value-methods</a></code>, 
<br /> <code><a href="#topic+to.data.frame-methods">to.data.frame-methods</a></code>,
<br /> <code><a href="#topic+zeta-methods">zeta-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the Mobius transform of a set function directly
a &lt;- Mobius.set.func(1:16,4,4)

## the attributes of the object
a@n
a@k
a@data
a@subsets

## a set function
mu &lt;- set.func(7:-8)
## and its Mobius transform
a &lt;- Mobius(mu)

## some conversions that cannot work
## as.game(a)
## as.capacity(a)
## as.card.set.func(a)

## some tests
is.cardinal(a)
is.kadditive(a,2)
is.monotone(a)

## some transformations
zeta(a)
k.truncate.Mobius(a,2)

## summary 
Shapley.value(a)
interaction.indices(a)
# the same
summary(a)

## save the Mobius transform to a file
d &lt;- to.data.frame(a)
## Not run: write.table(d,"my.Mobius.set.func.csv",sep="\t")

# finally, some conversions that should work
mu &lt;- set.func(c(0,1,1,1,2,2,2,3))
a &lt;- Mobius(mu)
as.Mobius.game(a)
as.Mobius.capacity(a)
as.Mobius.card.set.func(a)
</code></pre>

<hr>
<h2 id='normalize-methods'>Normalizes a capacity.</h2><span id='topic+normalize'></span><span id='topic+normalize-methods'></span><span id='topic+normalize+2CMobius.capacity-method'></span><span id='topic+normalize+2Ccapacity-method'></span><span id='topic+normalize+2Ccard.capacity-method'></span>

<h3>Description</h3>

<p>Returns the normalized version of a capacity. The capacity
can be given either under the form of an object of class
<code>capacity</code>, <code>card.capacity</code> or <code>Mobius.capacity</code>. In
the case of objects of class <code>capacity</code> and <code>card.capacity</code>,
the normalization is performed by dividing each coefficient of the
capacity by the value of the capacity on the universe. In the case of
objects of class <code>Mobius.capacity</code>, the normalization is
performed by dividing each coefficient of the Möbius transform by the
sum of all the coefficients.  
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.capacity&quot; </dt><dd><p>Returns an object of class <code>Mobius.capacity</code>.</p>
</dd>
<dt>object = &quot;capacity&quot; </dt><dd><p>Returns an object of class <code>capacity</code>.</p>
</dd>
<dt>object = &quot;card.capacity&quot; </dt><dd><p>Returns an object of class <code>card.capacity</code>.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>,
<br /> <code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+card.capacity-class">card.capacity-class</a></code>,
<br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>,
<br /> <code><a href="#topic+is.normalized-methods">is.normalized-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a capacity
mu &lt;- capacity(0:15)

## normalize it
is.normalized(mu)
normalize(mu)

## a similar example with a Mobius.capacity object
a &lt;- Mobius(mu)
is.normalized(a)
normalize(a)
zeta(normalize(a))

## a similar example with a card.capacity object
mu &lt;- card.capacity(0:6)
is.normalized(mu)
normalize(mu)
Mobius(normalize(mu))

</code></pre>

<hr>
<h2 id='orness-methods'>Orness degree</h2><span id='topic+orness'></span><span id='topic+orness-methods'></span><span id='topic+orness+2CMobius.capacity-method'></span><span id='topic+orness+2Ccapacity-method'></span><span id='topic+orness+2Ccard.capacity-method'></span>

<h3>Description</h3>

<p>Computes the orness degree of a Choquet integral from the
underlying <b>normalized</b> capacity. The capacity can be given either under the form
of an object of class <code>capacity</code>, <code>card.capacity</code> or
<code>Mobius.capacity</code>.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.capacity&quot; </dt><dd><p>The orness degree is computed from the Möbius transform of a capacity.</p>
</dd>
<dt>object = &quot;capacity&quot; </dt><dd><p>The orness degree is computed directly from a capacity.</p>
</dd>
<dt>object = &quot;card.capacity&quot; </dt><dd><p>The orness degree is computed from a cardinal capacity.</p>
</dd>
</dl>


<h3>References</h3>

<p>J.-L. Marichal (2000), <em>Behavioral analysis of aggregation in
multicriteria decision aid</em>, in Preferences and Decisions under
Incomplete Knowledge, J. Fodor and B. De Baets and P. Perny Eds,
Physica-Verlag, pages 153-178, 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>,
<br /> <code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+card.capacity-class">card.capacity-class</a></code>,
<br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the upper capacity
mu &lt;- capacity(c(0,rep(1,15)))

## the Choquet integral w.r.t mu behaves like the maximum operator
f &lt;- c(0.1,0.1,0,0.9)
Choquet.integral(mu,f)

## its orness is 1
orness(mu)

## the same example with a Mobius.capacity object
a &lt;- Mobius(mu)
Choquet.integral(a,f)
orness(a)

## the same example with a card.capacity object
mu &lt;- upper.capacity(4)
Choquet.integral(mu,f)
orness(mu)
</code></pre>

<hr>
<h2 id='pdf.Choquet.unif-methods'>Distribution of the Choquet integral for evaluations uniformly
distributed on the unit hypercube</h2><span id='topic+pdf.Choquet.unif'></span><span id='topic+cdf.Choquet.unif'></span><span id='topic+pdf.Choquet.unif-methods'></span><span id='topic+cdf.Choquet.unif-methods'></span><span id='topic+pdf.Choquet.unif+2Cgame+2Cnumeric-method'></span><span id='topic+cdf.Choquet.unif+2Cgame+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Methods for computing the probability density and cumulative
distribution functions of the Choquet integral with respect to a game
for evaluations uniformly distributed on the unit hypercube.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;game&quot;, y = &quot;numeric&quot; </dt><dd><p>Returns the value of the
p.d.f. or the c.d.f. at <code>y</code>.</p>
</dd>
</dl>


<h3>References</h3>

<p>J-L. Marichal and I. Kojadinovic (2007), <em>The distribution of linear
combinations of lattice polynomials from the uniform distribution</em>,
submitted. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+game-class">game-class</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## a capacity
mu &lt;- capacity(c(0,0.1,0.6,rep(0.9,4),1))
## the cdf of the Choquet integral at 0.7
cdf.Choquet.unif(mu,0.7)

## the same but empirically
m &lt;- 10000
ch &lt;- numeric(m)
for (i in 1:m) {
     f &lt;- runif(3) 
     ch[i] &lt;- Choquet.integral(mu,f)
}
sum(ifelse(ch&lt;=0.7,1,0))/m
</code></pre>

<hr>
<h2 id='rnd-methods'>Rounding of set function coefficients</h2><span id='topic+rnd'></span><span id='topic+rnd-methods'></span><span id='topic+rnd+2Csuperclass.set.func-method'></span>

<h3>Description</h3>

<p>Rounds the coefficients of a set function to the specified
number of decimal places (default 0).
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;superclass.set.func&quot;, digits = &quot;numeric&quot; </dt><dd><p>Returns an object of the same class as
<code>x</code> whose <code>data</code> attribute is rounded.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>## a capacity
mu &lt;- capacity(0:15/15)
mu
rnd(mu,2)

## a similar example with a Mobius.capacity object
a &lt;- Mobius(mu)
a
rnd(a,1)

## a similar example with a card.capacity object
mu &lt;- uniform.capacity(6)
mu
rnd(mu)
</code></pre>

<hr>
<h2 id='set.func'>Create objects of class &quot;set.func&quot;, &quot;game&quot;, or &quot;capacity&quot;.</h2><span id='topic+set.func'></span><span id='topic+game'></span><span id='topic+capacity'></span>

<h3>Description</h3>

<p>These functions create objects of class <code>set.func</code>,
<code>game</code>, or <code>capacity</code> from objects of class <code>numeric</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.func(object)
game(object)
capacity(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.func_+3A_object">object</code></td>
<td>
<p>An object of class <code>numeric</code> containing the
coefficients of the set function in &quot;natural&quot; order. Its length has
to be a power of 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return objects of class <code>set.func</code>, <code>game</code>, or <code>capacity</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>, 
<br /> <code><a href="#topic+game-class">game-class</a></code>,
<br /> <code><a href="#topic+set.func-class">set.func-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.func(-12:3)
game(c(0,rep(-1,15)))
capacity(0:15)
</code></pre>

<hr>
<h2 id='set.func-class'>Class &quot;set.func&quot;</h2><span id='topic+set.func-class'></span>

<h3>Description</h3>

<p>Class representing a set function.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the function <code>set.func</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>n</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 equal to
the number of elements of the set on which the set function is defined.</p>
</dd>
<dt><code>subsets</code>:</dt><dd><p>Object of class <code>numeric</code> of length
<code>2^n</code> containing the power set of the underlying set in
&quot;natural&quot; order. The subsets are coded as integers.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>numeric</code> of length
<code>2^n</code> containing the coefficients of the set function in binary order.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>superclass.set.func</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "set.func")</code> </p>
</dd>
<dt>as.game</dt><dd><p><code>signature(object = "set.func")</code></p>
</dd>
<dt>as.capacity</dt><dd><p><code>signature(object = "set.func")</code></p>
</dd>
<dt>as.card.set.func</dt><dd><p><code>signature(object = "set.func")</code></p>
</dd>
<dt>as.Mobius.set.func</dt><dd><p><code>signature(object = "set.func")</code></p>
</dd>
<dt>as.Mobius.card.set.func</dt><dd><p><code>signature(object = "set.func")</code></p>
</dd>
<dt>conjugate</dt><dd><p><code>signature(object = "set.func")</code></p>
</dd>
<dt>interaction.indices</dt><dd><p><code>signature(object = "set.func")</code></p>
</dd>
<dt>is.cardinal</dt><dd><p><code>signature(object = "set.func")</code></p>
</dd>
<dt>is.kadditive</dt><dd><p><code>signature(object = "set.func", k = "numeric")</code></p>
</dd>
<dt>is.monotone</dt><dd><p><code>signature(object = "set.func")</code></p>
</dd>
<dt>k.truncate.Mobius</dt><dd><p><code>signature(object = "set.func", k =
	"numeric")</code></p>
</dd>
<dt>Mobius</dt><dd><p><code>signature(object = "set.func")</code></p>
</dd>
<dt>Shapley.value</dt><dd><p><code>signature(object = "set.func")</code></p>
</dd>
<dt>to.data.frame</dt><dd><p><code>signature(object = "set.func")</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+set.func">set.func</a></code>,
<br /> <code><a href="#topic+as.game-methods">as.game-methods</a></code>,	
<br /> <code><a href="#topic+as.capacity-methods">as.capacity-methods</a></code>,
<br /> <code><a href="#topic+as.card.set.func-methods">as.card.set.func-methods</a></code>, 
<br /> <code><a href="#topic+as.Mobius.set.func-methods">as.Mobius.set.func-methods</a></code>,
<br /> <code><a href="#topic+as.Mobius.card.set.func-methods">as.Mobius.card.set.func-methods</a></code>,
<br /> <code><a href="#topic+conjugate-methods">conjugate-methods</a></code>, 
<br /> <code><a href="#topic+interaction.indices-methods">interaction.indices-methods</a></code>,
<br /> <code><a href="#topic+is.cardinal-methods">is.cardinal-methods</a></code>, 
<br /> <code><a href="#topic+is.kadditive-methods">is.kadditive-methods</a></code>,
<br /> <code><a href="#topic+is.monotone-methods">is.monotone-methods</a></code>,
<br /> <code><a href="#topic+k.truncate.Mobius-methods">k.truncate.Mobius-methods</a></code>,
<br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>, 
<br /> <code><a href="#topic+Shapley.value-methods">Shapley.value-methods</a></code>,
<br /> <code><a href="#topic+to.data.frame-methods">to.data.frame-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a set function
mu &lt;- set.func(c(1:8,8:1)/8)

## the attributes of the object
mu@n
mu@data
mu@subsets

## some conversions that cannot work
## Not run: as.game(mu)
## Not run: as.capacity(mu)
## Not run: as.card.set.func(mu)

## some tests
is.cardinal(mu)
is.kadditive(mu,2)
is.monotone(mu)

## some transformations
conjugate(mu)
Mobius(mu)
k.truncate.Mobius(mu,2)

## summary 
Shapley.value(mu)
interaction.indices(mu)
# the same
summary(mu)

## save the set function to a file
d &lt;- to.data.frame(mu)
## Not run: write.table(d,"my.set.func.csv",sep="\t")

# finally, some conversions that should work
mu &lt;- set.func(c(0,1,1,1,2,2,2,3))
as.game(mu)
as.capacity(mu)
as.card.set.func(mu)
</code></pre>

<hr>
<h2 id='Shapley.value-methods'>The Shapley value</h2><span id='topic+Shapley.value'></span><span id='topic+Shapley.value-methods'></span><span id='topic+Shapley.value+2CMobius.set.func-method'></span><span id='topic+Shapley.value+2Ccard.set.func-method'></span><span id='topic+Shapley.value+2Cset.func-method'></span>

<h3>Description</h3>

<p>Computes the Shapley value (<code>n</code> indices) of a set
function. The set function can be given either under the form of an
object of class <code>set.func</code>, <code>card.set.func</code> or <code>Mobius.set.func</code>.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.set.func&quot; </dt><dd><p>The Shapley value is computed from the Möbius transform of a set function.</p>
</dd>
<dt>object = &quot;card.set.func&quot; </dt><dd><p>The Shapley value is computed from a cardinal set function.</p>
</dd>
<dt>object = &quot;set.func&quot; </dt><dd><p>The Shapley value is computed from a general set function.</p>
</dd>
</dl>


<h3>References</h3>

<p>L.S. Shapley (1953), <em>A value for <code>n</code>-person games</em>,
Contributions to the theory of games, vol. 2, Annals of Mathematics
Studies, no. 28, pages 307-317, Princeton University Press, Princeton,
N. J. .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mobius.set.func-class">Mobius.set.func-class</a></code>,
<br /> <code><a href="#topic+card.set.func-class">card.set.func-class</a></code>,
<br /> <code><a href="#topic+set.func-class">set.func-class</a></code>,
<br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a set function
mu &lt;- set.func(c(0:13/13,1,1))

## the Shapley value
Shapley.value(mu)

## the efficiency property should be satisfied
sum(Shapley.value(mu))

## a similar example using a Mobius.set.func object
a &lt;- Mobius(mu)
Shapley.value(a)

## a similar example using a card.set.func object
mu &lt;- upper.capacity(6)
Shapley.value(mu)
## the efficiency property should be satisfied
Shapley.value(mu)*6
</code></pre>

<hr>
<h2 id='show-methods'>Methods for Function show in Package &lsquo;kappalab&rsquo;</h2><span id='topic+show-methods'></span><span id='topic+show+2Csuperclass.set.func-method'></span><span id='topic+show+2Cset.func-method'></span><span id='topic+show+2CMobius.set.func-method'></span><span id='topic+show+2Csummary.superclass.set.func-method'></span><span id='topic+show+2Csummary.superclass.capacity-method'></span>

<h3>Description</h3>

<p>Displays the contents of an object.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;superclass.set.func&quot; </dt><dd><p>Generic <code>show</code> method for <code>superclass.set.func</code>.</p>
</dd>
<dt>object = &quot;set.func&quot; </dt><dd><p>Displays a <code>set.func</code> object.</p>
</dd>
<dt>object = &quot;Mobius.set.func&quot; </dt><dd><p>Displays a <code>Mobius.set.func</code> object.</p>
</dd>
<dt>object = &quot;summary.superclass.set.func&quot; </dt><dd><p>Displays a <code>summary.superclass.set.func</code> object.</p>
</dd>
<dt>object = &quot;summary.superclass.capacity&quot; </dt><dd><p>Displays a
<code>summary.superclass.capacity</code> object.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+superclass.set.func-class">superclass.set.func-class</a></code>,
<br /> <code><a href="#topic+set.func-class">set.func-class</a></code>,
<br /> <code><a href="#topic+Mobius.set.func-class">Mobius.set.func-class</a></code>,
<br /> <code><a href="#topic+summary.superclass.set.func-class">summary.superclass.set.func-class</a></code>,
<br /> <code><a href="#topic+summary.superclass.capacity-class">summary.superclass.capacity-class</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a set function
mu &lt;- set.func(0:15/15)
show(mu)
## the same
mu

## a Mobius transform
a &lt;- Mobius.set.func(0:10,4,2)
show(a)
a

## a cardinal capacity
mu &lt;- lower.capacity(5)
show(mu)
mu
</code></pre>

<hr>
<h2 id='Sipos.integral-methods'>Sipos integral</h2><span id='topic+Sipos.integral'></span><span id='topic+Sipos.integral-methods'></span><span id='topic+Sipos.integral+2CMobius.game+2Cnumeric-method'></span><span id='topic+Sipos.integral+2Ccard.game+2Cnumeric-method'></span><span id='topic+Sipos.integral+2Cgame+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Computes the Sipos integral (also called <em>symmetric Choquet
integral</em>) of a real-valued function with respect to a game. The game can be
given either under the form of an object of class <code>game</code>,
<code>card.game</code> or <code>Mobius.game</code>.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;game&quot;, f = &quot;numeric&quot; </dt><dd><p>The Sipos or symmetric Choquet integral of <code>f</code>
is computed from a game.</p>
</dd>
<dt>object = &quot;Mobius.game&quot;, f = &quot;numeric&quot; </dt><dd><p>The Sipos or symmetric Choquet integral of
<code>f</code> is computed from the Möbius transform of a game.</p>
</dd>
<dt>object = &quot;card.game&quot;, f = &quot;numeric&quot; </dt><dd><p>The Sipos or symmetric Choquet integral of
<code>f</code> is computed from a cardinal game.</p>
</dd>
</dl>


<h3>References</h3>

<p>M. Grabisch and Ch. Labreuche (2002), The symmetric and asymmetric Choquet
integrals on finite spaces for decision making, Statistical Papers 43, pages
37-52.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+game-class">game-class</a></code>,
<br /> <code><a href="#topic+Mobius.game-class">Mobius.game-class</a></code>,
<br /> <code><a href="#topic+card.game-class">card.game-class</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a normalized capacity
mu &lt;- capacity(c(0:13/13,1,1))

## and its Mobius transform
a &lt;- Mobius(mu)

## a discrete function f
f &lt;- c(0.1,-0.9,-0.3,0.8)

## the Sugeno integral of f w.r.t mu
Sipos.integral(mu,f)
Sipos.integral(a,f)

## a similar example with a cardinal capacity
mu &lt;- uniform.capacity(4)
Sipos.integral(mu,f)
</code></pre>

<hr>
<h2 id='Sugeno.integral-methods'>Sugeno integral</h2><span id='topic+Sugeno.integral'></span><span id='topic+Sugeno.integral-methods'></span><span id='topic+Sugeno.integral+2CMobius.game+2Cnumeric-method'></span><span id='topic+Sugeno.integral+2Ccard.game+2Cnumeric-method'></span><span id='topic+Sugeno.integral+2Cgame+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Computes the Sugeno integral of a <b>non negative</b> function with
respect to a game. Moreover, if the game is a capacity, the range of the function must be contained into
the range of the capacity. The game can be given either under the form of an
object of class <code>game</code>, <code>card.game</code> or <code>Mobius.game</code>.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.game&quot;, f = &quot;numeric&quot; </dt><dd><p>The Sugeno integral of
<code>f</code> is computed from the Möbius transform of a game.</p>
</dd>
<dt>object = &quot;game&quot;, f = &quot;numeric&quot; </dt><dd><p>The Sugeno integral of <code>f</code>
is computed from a game.</p>
</dd>
<dt>object = &quot;card.game&quot;, f = &quot;numeric&quot; </dt><dd><p>The Sugeno integral of
<code>f</code> is computed from a cardinal game.</p>
</dd>
</dl>


<h3>References</h3>

<p>M. Sugeno (1974), <em>Theory of fuzzy integrals and its applications</em>, Tokyo
Institute of Technology, Tokyo, Japan.
</p>
<p>J-L. Marichal (2000), <em>On Sugeno integral as an aggregation function</em>, Fuzzy Sets
and Systems 114, pages 347-365.
</p>
<p>J-L. Marichal (2001), <em>An axiomatic approach of the discrete Sugeno integral as a
tool to aggregate interacting criteria in a qualitative framework</em>, IEEE
Transactions on Fuzzy Systems 9:1, pages 164-172.
</p>
<p>T. Murofushi and M. Sugeno (2000), <em>Fuzzy measures and fuzzy integrals</em>,
in: M. Grabisch, T. Murofushi, and M. Sugeno Eds, Fuzzy Measures and
Integrals: Theory and Applications, Physica-Verlag, pages 3-41.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+game-class">game-class</a></code>,
<br /> <code><a href="#topic+Mobius.game-class">Mobius.game-class</a></code>,
<br /> <code><a href="#topic+card.game-class">card.game-class</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a normalized capacity
mu &lt;- capacity(c(0:13/13,1,1))

## and its Mobius transform
a &lt;- Mobius(mu)

## a discrete function f
f &lt;- c(0.1,0.9,0.3,0.8)

## the Sugeno integral of f w.r.t mu
Sugeno.integral(mu,f)
Sugeno.integral(a,f) 

## a similar example with a cardinal capacity
mu &lt;- uniform.capacity(4)
Sugeno.integral(mu,f)
</code></pre>

<hr>
<h2 id='summary-methods'>Summary method</h2><span id='topic+summary'></span><span id='topic+summary-methods'></span><span id='topic+summary+2Csuperclass.capacity-method'></span><span id='topic+summary+2Csuperclass.set.func-method'></span>

<h3>Description</h3>

<p>Computes indices that can be used to summarize a set function.</p>


<h3>Methods</h3>



<dl>
<dt>object = &quot;superclass.capacity&quot; </dt><dd><p>Returns an object of class <code>summary.superclass.capacity</code>.</p>
</dd>
<dt>object = &quot;superclass.set.func&quot; </dt><dd><p>Returns an object of class <code>summary.superclass.set.func</code>.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+summary.superclass.capacity-class">summary.superclass.capacity-class</a></code>, 
<br /> <code><a href="#topic+summary.superclass.set.func-class">summary.superclass.set.func-class</a></code>. 
</p>

<hr>
<h2 id='summary.superclass.capacity-class'>Class &quot;summary.superclass.capacity&quot;</h2><span id='topic+summary.superclass.capacity-class'></span>

<h3>Description</h3>

<p>Class containing most of the indices that can be used to summarize an object of class <code>superclass.capacity</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects are created by calls of the form <code>summary(...)</code> on objects of class <code>superclass.capacity</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>Shapley.value</code>:</dt><dd><p>Object of class <code>numeric</code> containing the Shapley value of a set function.</p>
</dd>
<dt><code>interaction.indices</code>:</dt><dd><p>Object of class <code>matrix</code> containing the Shapley interaction indices of a set function.</p>
</dd>
<dt><code>orness</code>:</dt><dd><p>Object of class <code>numeric</code> containg the orness degree of the Choquet integral corresponding to the underlying capacity.</p>
</dd>
<dt><code>veto</code>:</dt><dd><p>Object of class <code>numeric</code> containing the veto indices of the Choquet integral corresponding to the underlying capacity.</p>
</dd>
<dt><code>favor</code>:</dt><dd><p>Object of class <code>numeric</code> containing the favor indices of the Choquet integral corresponding to the underlying capacity.</p>
</dd>
<dt><code>variance</code>:</dt><dd><p>Object of class <code>numeric</code> containing the variance of the underlying capacity.</p>
</dd> 
<dt><code>entropy</code>:</dt><dd><p>Object of class <code>numeric</code> containing the variance of the underlying capacity.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "summary.superclass.capacity")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+superclass.capacity-class">superclass.capacity-class</a></code>, <br /> <code><a href="#topic+summary-methods">summary-methods</a></code>,
<br /> <code><a href="#topic+Shapley.value-methods">Shapley.value-methods</a></code>, <br /> <code><a href="#topic+interaction.indices-methods">interaction.indices-methods</a></code>, 
<br /> <code><a href="#topic+orness-methods">orness-methods</a></code>, <br /> <code><a href="#topic+veto-methods">veto-methods</a></code>,
<br /> <code><a href="#topic+favor-methods">favor-methods</a></code>, <br /> <code><a href="#topic+variance-methods">variance-methods</a></code>,
<br /> <code><a href="#topic+entropy-methods">entropy-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a capacity
mu &lt;- capacity(c(0:13,13,13)/13)
a &lt;- Mobius(mu)

## its summary
summary(mu)
summary(a)
</code></pre>

<hr>
<h2 id='summary.superclass.set.func-class'>Class &quot;summary.superclass.set.func&quot;</h2><span id='topic+summary.superclass.set.func-class'></span>

<h3>Description</h3>

<p>Class containing most of the indices that can be used to summarize an object of class <code>superclass.set.func</code> and not of class <code>superclass.capacity</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects are created by calls of the form <code>summary(...)</code> on objects of class <code>superclass.set.func</code> and not of class <code>superclass.capacity</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>Shapley.value</code>:</dt><dd><p>Object of class <code>numeric</code> containing the Shapley value of a set function.</p>
</dd>
<dt><code>interaction.indices</code>:</dt><dd><p>Object of class <code>matrix</code> containing the Shapley interaction indices of a set function.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "summary.superclass.set.func")</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+superclass.set.func-class">superclass.set.func-class</a></code>, <br /> <code><a href="#topic+superclass.capacity-class">superclass.capacity-class</a></code>,
<br /> <code><a href="#topic+summary-methods">summary-methods</a></code>,
<br /> <code><a href="#topic+show-methods">show-methods</a></code>, <br /> <code><a href="#topic+Shapley.value-methods">Shapley.value-methods</a></code>, 
<br /> <code><a href="#topic+interaction.indices-methods">interaction.indices-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a capacity
mu &lt;- set.func(c(0:13,13,13)/13)
a &lt;- Mobius(mu)

## its summary
summary(mu)
summary(a)
</code></pre>

<hr>
<h2 id='superclass.capacity-class'>Class &quot;superclass.capacity&quot;</h2><span id='topic+superclass.capacity-class'></span>

<h3>Description</h3>

<p>Virtual class, superclass of all <code>*.capacity</code> classes. Used to define a common <code>summary</code> method for <code>*.capacity</code> classes. Contains no slots.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>summary</dt><dd><p><code>signature(object = "superclass.capacity")</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+summary-methods">summary-methods</a></code>,
<br /> <code><a href="#topic+capacity-class">capacity-class</a></code>, <br /> <code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>, 
<br /> <code><a href="#topic+card.capacity-class">card.capacity-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## three capacities
mu1 &lt;- uniform.capacity(5)
mu2 &lt;- capacity(c(0,0,0:13))
a &lt;- Mobius(mu2)

## compute indices to summarize them
summary(mu1)
summary(mu2)
summary(a)
</code></pre>

<hr>
<h2 id='superclass.set.func-class'>Class &quot;superclass.set.func&quot;</h2><span id='topic+superclass.set.func-class'></span>

<h3>Description</h3>

<p>Virtual class, superclass of all <code>*.set.func</code> classes. Used to define common <code>show</code> and <code>summary</code> methods for <code>*.set.func</code> classes.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>n</code>:</dt><dd><p>Object of class <code>numeric</code> of length 1 equal
to the number of elements of the set on which the
set function is defined.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>numeric</code> containing the
coefficients of the set function.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "superclass.set.func")</code> </p>
</dd>
<dt>rnd</dt><dd><p><code>signature(x = "superclass.set.func", digits = "numeric")</code> </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "superclass.set.func")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+show-methods">show-methods</a></code>,
<br /> <code><a href="#topic+rnd-methods">rnd-methods</a></code>,
<br /> <code><a href="#topic+summary-methods">summary-methods</a></code>, 
<br /> <code><a href="#topic+set.func-class">set.func-class</a></code>,
<br /> <code><a href="#topic+Mobius.set.func-class">Mobius.set.func-class</a></code>, 
<br /> <code><a href="#topic+card.set.func-class">card.set.func-class</a></code>,
<br /> <code><a href="#topic+Mobius.card.set.func-class">Mobius.card.set.func-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## three set functions
mu1 &lt;- card.set.func(-2:4)
mu2 &lt;- set.func(c(-2,-2,-2:11/11))
mu3 &lt;- Mobius.set.func(c(-7:6,6,6),4,4)

## print mu1
show(mu1)
## the same
mu1
## the others
mu2
mu3

## round mu2
rnd(mu2,2)

## compute indices to summarize them
summary(mu1)
summary(mu2)
summary(mu3)
</code></pre>

<hr>
<h2 id='to.data.frame-methods'>Puts a set function under the form of a data.frame</h2><span id='topic+to.data.frame'></span><span id='topic+to.data.frame-methods'></span><span id='topic+to.data.frame+2CMobius.card.set.func-method'></span><span id='topic+to.data.frame+2CMobius.set.func-method'></span><span id='topic+to.data.frame+2Ccard.set.func-method'></span><span id='topic+to.data.frame+2Cset.func-method'></span>

<h3>Description</h3>

<p>Puts a set function under the form of a
<code>data.frame</code>. This function can be used to write a set function to a
file.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.card.set.func&quot; </dt><dd><p>Returns a <code>data.frame</code>.</p>
</dd>
<dt>object = &quot;Mobius.set.func&quot; </dt><dd><p>Returns a <code>data.frame</code>.</p>
</dd>
<dt>object = &quot;card.set.func&quot; </dt><dd><p>Returns a <code>data.frame</code>.</p>
</dd>
<dt>object = &quot;set.func&quot; </dt><dd><p>Returns a <code>data.frame</code>.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>## the Mobius representation of set function
a &lt;- Mobius.set.func(-1:-16,4,4)

## to data.frame
d &lt;- to.data.frame(a)
## Not run: write.table(d,"my.set.func.csv",sep="\t")
</code></pre>

<hr>
<h2 id='variance-methods'>Normalized variance of a capacity</h2><span id='topic+variance'></span><span id='topic+variance-methods'></span><span id='topic+variance+2CMobius.capacity-method'></span><span id='topic+variance+2Ccapacity-method'></span><span id='topic+variance+2Ccard.capacity-method'></span>

<h3>Description</h3>

<p>Computes the normalized variance of a capacity. The
capacity can be given either under the form of an object of class <code>capacity</code>, a <code>card.capacity</code> or <code>Mobius.capacity</code>.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.capacity&quot; </dt><dd><p>The normalized variance is computed from the Möbius transform of a capacity.</p>
</dd>
<dt>object = &quot;capacity&quot; </dt><dd><p>The normalized variance is computed directly from a capacity.</p>
</dd>
<dt>object = &quot;card.capacity&quot; </dt><dd><p>The normalized variance is computed from a cardinal capacity.</p>
</dd>
</dl>


<h3>References</h3>

<p>I. Kojadinovic (2005), <em>Minimum variance capacity
identification</em>, European Journal of Operational Research, in press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>, <br /> <code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+card.capacity-class">card.capacity-class</a></code>, <br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a capacity
mu &lt;- capacity(c(0,0,0,0:12)/12)

## its Mobius transform
a &lt;- Mobius(mu)

## their normalized variance
variance(mu)
variance(a)

## similar examples with card.capacity objects
mu &lt;- lower.capacity(4)
variance(mu)
mu &lt;- uniform.capacity(4)
variance(mu)
</code></pre>

<hr>
<h2 id='veto-methods'>Veto indices</h2><span id='topic+veto'></span><span id='topic+veto-methods'></span><span id='topic+veto+2CMobius.capacity-method'></span><span id='topic+veto+2Ccapacity-method'></span><span id='topic+veto+2Ccard.capacity-method'></span>

<h3>Description</h3>

<p>Computes the veto indices of a Choquet integral from the
underlying <b>normalized</b> capacity. The capacity can be given either under the form
of an object of class <code>capacity</code>, <code>card.capacity</code> or <code>Mobius.capacity</code>.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.capacity&quot; </dt><dd><p>The veto indices are computed from the Möbius transform of a capacity.</p>
</dd>
<dt>object = &quot;capacity&quot; </dt><dd><p>The veto indices are computed directly from a capacity.</p>
</dd>
<dt>object = &quot;card.capacity&quot; </dt><dd><p>The veto indices are computed from a cardinal capacity.</p>
</dd>
</dl>


<h3>References</h3>

<p>J.-L. Marichal (2000), <em>Behavioral analysis of aggregation in
multicriteria decision aid</em>, in: Preferences and Decisions under
Incomplete Knowledge, J. Fodor and B. De Baets and P. Perny Eds,
Physica-Verlag, pages 153-178.
</p>
<p>J.-L. Marichal (2004), <em>Tolerant or intolerant character of
interacting criteria in aggregation by the Choquet integral</em>,
European Journal of Operational Research 155:3, pages 771-791.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>, <br /> <code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>,
<br /> <code><a href="#topic+card.capacity-class">card.capacity-class</a></code>, <br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a capacity
mu &lt;- capacity(c(0:13,13,13)/13)

## its Mobius transform
a &lt;- Mobius(mu)

## their veto indices
veto(mu)
veto(a)

## the same with a card.capacity object
mu &lt;- lower.capacity(4)
veto(mu)
</code></pre>

<hr>
<h2 id='zeta-methods'>The zeta transform</h2><span id='topic+zeta'></span><span id='topic+zeta-methods'></span><span id='topic+zeta+2CMobius.capacity-method'></span><span id='topic+zeta+2CMobius.card.set.func-method'></span><span id='topic+zeta+2CMobius.game-method'></span><span id='topic+zeta+2CMobius.set.func-method'></span>

<h3>Description</h3>

<p>Computes the zeta transform of a set function given under
the form of its Möbius transform. The zeta transform is the inverse of
the Möbius transform.
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Mobius.capacity&quot; </dt><dd><p>Returns an object of class <code>capacity</code>.</p>
</dd>
<dt>object = &quot;Mobius.card.set.func&quot; </dt><dd><p>Returns an object of class <code>card.set.func</code>.</p>
</dd>
<dt>object = &quot;Mobius.game&quot; </dt><dd><p>Returns an object of class <code>game</code>.</p>
</dd>
<dt>object = &quot;Mobius.set.func&quot; </dt><dd><p>Returns an object of class <code>set.func</code>.</p>
</dd>
</dl>


<h3>References</h3>

<p>G-C. Rota (1964), <em>On the foundations of combinatorial theory. I. Theory
of Möbius functions</em>, Z. Wahrscheinlichkeitstheorie und
Verw. Gebiete 2, pages 340-368.
</p>
<p>A. Chateauneuf and J-Y. Jaffray (1989), <em>Some characterizations of lower 
probabilities and other monotone capacities through the use of Möbius inversion</em>,
Mathematical Social Sciences 17, pages 263-283.
</p>
<p>M. Grabisch, J-L. Marichal and M. Roubens (2000), <em>Equivalent
representations of set functions</em>, Mathematics of Operations
Research 25:2, pages 157-178.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity-class">capacity-class</a></code>, 
<br /> <code><a href="#topic+card.set.func-class">card.set.func-class</a></code>, 
<br /> <code><a href="#topic+game-class">game-class</a></code>,
<br /> <code><a href="#topic+set.func-class">set.func-class</a></code>,
<br /> <code><a href="#topic+Mobius.capacity-class">Mobius.capacity-class</a></code>, 
<br /> <code><a href="#topic+Mobius.card.set.func-class">Mobius.card.set.func-class</a></code>, 
<br /> <code><a href="#topic+Mobius.game-class">Mobius.game-class</a></code>,
<br /> <code><a href="#topic+Mobius.set.func-class">Mobius.set.func-class</a></code>, 
<br /> <code><a href="#topic+Mobius-methods">Mobius-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the Mobius transform of a capacity
a &lt;- Mobius.capacity(c(rep(0,15),1),4,4)
a

## its zeta transform
zeta(a)

## let us check
Mobius(zeta(a))

## a similar example with a Mobius.card.set.func object
mu &lt;- card.set.func(-3:4)
a &lt;- Mobius(mu)
zeta(a)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
