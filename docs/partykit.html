<!DOCTYPE html><html lang="en"><head><title>Help for package partykit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {partykit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cforest'><p>Conditional Random Forests</p></a></li>
<li><a href='#ctree'><p>Conditional Inference Trees</p></a></li>
<li><a href='#ctree_control'><p> Control for Conditional Inference Trees</p></a></li>
<li><a href='#extree_data'>
<p>Data Preprocessing for Extensible Trees.</p></a></li>
<li><a href='#extree_fit'>
<p>Fit Extensible Trees.</p></a></li>
<li><a href='#glmtree'><p>Generalized Linear Model Trees</p></a></li>
<li><a href='#HuntingSpiders'><p>Abundance of Hunting Spiders</p></a></li>
<li><a href='#lmtree'><p>Linear Model Trees</p></a></li>
<li><a href='#mob'><p>Model-based Recursive Partitioning</p></a></li>
<li><a href='#mob_control'><p>Control Parameters for Model-Based Partitioning</p></a></li>
<li><a href='#model_frame_rpart'><p> Model Frame Method for rpart</p></a></li>
<li><a href='#nodeapply'><p> Apply Functions Over Nodes</p></a></li>
<li><a href='#nodeids'><p> Extract Node Identifiers</p></a></li>
<li><a href='#panelfunctions'><p> Panel-Generators for Visualization of Party Trees</p></a></li>
<li><a href='#party'><p> Recursive Partytioning</p></a></li>
<li><a href='#party-coercion'><p>Coercion Functions</p></a></li>
<li><a href='#party-methods'><p> Methods for Party Objects</p></a></li>
<li><a href='#party-plot'><p> Visualization of Trees</p></a></li>
<li><a href='#party-predict'><p> Tree Predictions</p></a></li>
<li><a href='#partynode'><p> Inner and Terminal Nodes</p></a></li>
<li><a href='#partynode-methods'><p> Methods for Node Objects</p></a></li>
<li><a href='#partysplit'><p> Binary and Multiway Splits</p></a></li>
<li><a href='#prune.modelparty'><p>Post-Prune <code>modelparty</code> Objects</p></a></li>
<li><a href='#varimp'><p> Variable Importance</p></a></li>
<li><a href='#WeatherPlay'><p>Weather Conditions and Playing a Game</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Toolkit for Recursive Partytioning</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-02</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-23</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolkit with infrastructure for representing, summarizing, and
  visualizing tree-structured regression and classification models. This
  unified infrastructure can be used for reading/coercing tree models from
  different sources ('rpart', 'RWeka', 'PMML') yielding objects that share
  functionality for print()/plot()/predict() methods. Furthermore, new and improved
  reimplementations of conditional inference trees (ctree()) and model-based
  recursive partitioning (mob()) from the 'party' package are provided based
  on the new infrastructure. A description of this package was published
  by Hothorn and Zeileis (2015) <a href="https://jmlr.org/papers/v16/hothorn15a.html">https://jmlr.org/papers/v16/hothorn15a.html</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), graphics, grid, libcoin (&ge; 1.0-0), mvtnorm</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, stats, utils, survival, Formula (&ge; 1.2-1), inum
(&ge; 1.0-0), rpart (&ge; 4.1-11)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>XML, pmml, rJava, sandwich, strucchange, vcd, AER, mlbench,
TH.data (&ge; 1.0-3), coin (&ge; 1.1-0), RWeka (&ge; 0.4-19),
datasets, parallel, psychotools (&ge; 0.3-0), psychotree, party
(&ge; 1.3-0), randomForest</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://partykit.r-forge.r-project.org/partykit/">http://partykit.r-forge.r-project.org/partykit/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-02 15:26:36 UTC; hothorn</td>
</tr>
<tr>
<td>Author:</td>
<td>Torsten Hothorn <a href="https://orcid.org/0000-0001-8301-0471"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Heidi Seibold <a href="https://orcid.org/0000-0002-8960-9642"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Torsten Hothorn &lt;Torsten.Hothorn@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-02 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cforest'>Conditional Random Forests</h2><span id='topic+cforest'></span><span id='topic+gettree'></span><span id='topic+gettree.cforest'></span><span id='topic+predict.cforest'></span>

<h3>Description</h3>

<p>An implementation of the random forest and bagging ensemble algorithms
utilizing conditional inference trees as base learners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cforest(formula, data, weights, subset, offset, cluster, strata,
        na.action = na.pass,
	control = ctree_control(teststat = "quad", testtype = "Univ",
            mincriterion = 0, saveinfo = FALSE, ...),
        ytrafo = NULL, scores = NULL, ntree = 500L,
        perturb = list(replace = FALSE, fraction = 0.632),
        mtry = ceiling(sqrt(nvar)), applyfun = NULL, cores = NULL,
        trace = FALSE, ...)
## S3 method for class 'cforest'
predict(object, newdata = NULL,
        type = c("response", "prob", "weights", "node"),
        OOB = FALSE, FUN = NULL, simplify = TRUE, scale = TRUE, ...)
## S3 method for class 'cforest'
gettree(object, tree = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cforest_+3A_formula">formula</code></td>
<td>
<p> a symbolic description of the model to be fit. </p>
</td></tr>
<tr><td><code id="cforest_+3A_data">data</code></td>
<td>
<p> a data frame containing the variables in the model. </p>
</td></tr>
<tr><td><code id="cforest_+3A_subset">subset</code></td>
<td>
<p> an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="cforest_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting
process. Non-negative integer valued weights are
allowed as well as non-negative real weights.
Observations are sampled (with or without replacement)
according to probabilities <code>weights / sum(weights)</code>.
The fraction of observations to be sampled (without replacement)
is computed based on the sum of the weights if all weights
are integer-valued and based on the number of weights greater zero
else. Alternatively, <code>weights</code> can be a double matrix defining
case weights for all <code>ncol(weights)</code> trees in the forest directly.
This requires more storage but gives the user more control.</p>
</td></tr>
<tr><td><code id="cforest_+3A_offset">offset</code></td>
<td>
<p> an optional vector of offset values.</p>
</td></tr>
<tr><td><code id="cforest_+3A_cluster">cluster</code></td>
<td>
<p> an optional factor indicating independent clusters.
Highly experimental, use at your own risk.</p>
</td></tr>
<tr><td><code id="cforest_+3A_strata">strata</code></td>
<td>
<p> an optional factor for stratified sampling.</p>
</td></tr>
<tr><td><code id="cforest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain missing value.</p>
</td></tr>
<tr><td><code id="cforest_+3A_control">control</code></td>
<td>
<p>a list with control parameters, see
<code><a href="#topic+ctree_control">ctree_control</a></code>. The default values correspond to those
of the default values used by <code><a href="party.html#topic+cforest">cforest</a></code> from the
<code>party</code> package. <code>saveinfo = FALSE</code> leads to less
memory hungry representations of trees. Note that arguments
<code>mtry</code>, <code>cores</code> and <code>applyfun</code> in
<code><a href="#topic+ctree_control">ctree_control</a></code> are ignored for <code><a href="#topic+cforest">cforest</a></code>,
because they are already set.</p>
</td></tr>
<tr><td><code id="cforest_+3A_ytrafo">ytrafo</code></td>
<td>
<p>an optional named list of functions to be applied to the response
variable(s) before testing their association with the explanatory
variables. Note that this transformation is only
performed once for the root node and does not take weights into account
(which means, the forest bootstrap or subsetting is ignored,
which is almost certainly not a good idea).
Alternatively, <code>ytrafo</code> can be a function of <code>data</code> and
<code>weights</code>. In this case, the transformation is computed for
every node and the corresponding weights. This feature is experimental
and the user interface likely to change.</p>
</td></tr>
<tr><td><code id="cforest_+3A_scores">scores</code></td>
<td>
<p>an optional named list of scores to be attached to ordered
factors.</p>
</td></tr>
<tr><td><code id="cforest_+3A_ntree">ntree</code></td>
<td>

<p>Number of trees to grow for the forest.</p>
</td></tr>
<tr><td><code id="cforest_+3A_perturb">perturb</code></td>
<td>

<p>a list with arguments <code>replace</code> and <code>fraction</code> determining which type of
resampling with <code>replace = TRUE</code> referring to the n-out-of-n bootstrap and
<code>replace = FALSE</code> to sample splitting. 
<code>fraction</code> is the portion of observations to draw without
replacement. Honesty (experimental): If <code>fraction</code> has two elements, the
first fraction defines the portion of observations to be used for tree
induction, the second fraction defines the portion of observations used
for parameter estimation. The sum of both fractions can be smaller than
one but most not exceed one. Details can be found in Section 2.4 of 
Wager and Athey (2018).</p>
</td></tr>
<tr><td><code id="cforest_+3A_mtry">mtry</code></td>
<td>

<p>number of input variables randomly sampled as candidates
at each node for random forest like algorithms. Bagging, as special case
of a random forest without random input variable sampling, can
be performed by setting <code>mtry</code> either equal to <code>Inf</code> or
manually equal to the number of input variables.</p>
</td></tr>
<tr><td><code id="cforest_+3A_applyfun">applyfun</code></td>
<td>
<p>an optional <code><a href="base.html#topic+lapply">lapply</a></code>-style function with arguments
<code>function(X, FUN, ...)</code>. It is used for computing the variable selection criterion.
The default is to use the basic <code>lapply</code>
function unless the <code>cores</code> argument is specified (see below).</p>
</td></tr>
<tr><td><code id="cforest_+3A_cores">cores</code></td>
<td>
<p>numeric. If set to an integer the <code>applyfun</code> is set to
<code><a href="parallel.html#topic+mclapply">mclapply</a></code> with the desired number of <code>cores</code>.</p>
</td></tr>
<tr><td><code id="cforest_+3A_trace">trace</code></td>
<td>
<p>a logical indicating if a progress bar shall be printed while
the forest grows.</p>
</td></tr>
<tr><td><code id="cforest_+3A_object">object</code></td>
<td>

<p>An object as returned by <code>cforest</code></p>
</td></tr>
<tr><td><code id="cforest_+3A_newdata">newdata</code></td>
<td>

<p>An optional data frame containing test data.</p>
</td></tr>
<tr><td><code id="cforest_+3A_type">type</code></td>
<td>

<p>a character string denoting the type of predicted value
returned, ignored when argument <code>FUN</code> is given.  For
<code>"response"</code>, the mean of a numeric response, the predicted
class for a categorical response or the median survival time for a
censored response is returned.  For <code>"prob"</code> the matrix of
conditional class probabilities (<code>simplify = TRUE</code>) or a list
with the conditional class probabilities for each observation
(<code>simplify = FALSE</code>) is returned for a categorical response.
For numeric and censored responses, a list with the empirical
cumulative distribution functions and empirical survivor functions
(Kaplan-Meier estimate) is returned when <code>type = "prob"</code>.
<code>"weights"</code> returns an integer vector of prediction weights.
For <code>type = "where"</code>, a list of terminal node ids for each of the
trees in the forest ist returned.</p>
</td></tr>
<tr><td><code id="cforest_+3A_oob">OOB</code></td>
<td>

<p>a logical defining out-of-bag predictions (only if <code>newdata = NULL</code>).
If the forest was fitted with honesty, this option is ignored.</p>
</td></tr>
<tr><td><code id="cforest_+3A_fun">FUN</code></td>
<td>

<p>a function to compute summary statistics. Predictions for each node have to be
computed based on arguments <code>(y, w)</code> where <code>y</code> is the response and
<code>w</code> are case weights.</p>
</td></tr>
<tr><td><code id="cforest_+3A_simplify">simplify</code></td>
<td>

<p>a logical indicating whether the resulting list
of predictions should be converted to a suitable
vector or matrix (if possible).</p>
</td></tr>
<tr><td><code id="cforest_+3A_scale">scale</code></td>
<td>
<p>a logical indicating scaling of the nearest neighbor weights
by the sum of weights in the corresponding terminal node of
each tree. In the simple regression forest, predicting
the conditional mean by nearest neighbor weights will be
equivalent to (but slower!) the aggregation of means.</p>
</td></tr>
<tr><td><code id="cforest_+3A_tree">tree</code></td>
<td>
<p> an integer, the number of the tree to extract from the forest.</p>
</td></tr>
<tr><td><code id="cforest_+3A_...">...</code></td>
<td>
<p> additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation of the random forest (and bagging) algorithm differs
from the reference implementation in <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>
with respect to the base learners used and the aggregation scheme applied.
</p>
<p>Conditional inference trees, see <code><a href="#topic+ctree">ctree</a></code>, are fitted to each
of the <code>ntree</code> perturbed samples of the learning sample. Most of the hyper parameters in
<code><a href="#topic+ctree_control">ctree_control</a></code> regulate the construction of the conditional inference trees.
</p>
<p>Hyper parameters you might want to change are:
</p>
<p>1. The number of randomly preselected variables <code>mtry</code>, which is fixed
to the square root of the number of input variables.
</p>
<p>2. The number of trees <code>ntree</code>. Use more trees if you have more variables.
</p>
<p>3. The depth of the trees, regulated by <code>mincriterion</code>. Usually unstopped and unpruned
trees are used in random forests. To grow large trees, set <code>mincriterion</code> to a small value.
</p>
<p>The aggregation scheme works by averaging observation weights extracted
from each of the <code>ntree</code> trees and NOT by averaging predictions directly
as in <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>.
See Hothorn et al. (2004) and Meinshausen (2006) for a description.
</p>
<p>Predictions can be computed using <code><a href="stats.html#topic+predict">predict</a></code>. For observations
with zero weights, predictions are computed from the fitted tree
when <code>newdata = NULL</code>.
</p>
<p>Ensembles of conditional inference trees have not yet been extensively
tested, so this routine is meant for the expert user only and its current
state is rather experimental. However, there are some things available
in <code><a href="#topic+cforest">cforest</a></code> that can't be done with <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>,
for example fitting forests to censored response variables (see Hothorn et al., 2004, 2006a) or to
multivariate and ordered responses. Using the rich <code>partykit</code> infrastructure allows
additional functionality in <code>cforest</code>, such as parallel tree growing and probabilistic
forecasting (for example via quantile regression forests). Also plotting of single trees from
a forest is much easier now.
</p>
<p>Unlike <code><a href="party.html#topic+cforest">cforest</a></code>, <code>cforest</code> is entirely written in R which
makes customisation much easier at the price of longer computing times. However, trees
can be grown in parallel with this R only implemention which renders speed less of an issue.
Note that the default values are different from those used in package <code>party</code>, most
importantly the default for mtry is now data-dependent. <code>predict(, type = "node")</code> replaces
the <code><a href="party.html#topic+where">where</a></code> function and <code>predict(, type = "prob")</code> the
<code><a href="party.html#topic+treeresponse">treeresponse</a></code> function.
</p>
<p>Moreover, when predictors vary in their scale of measurement of number
of categories, variable selection and computation of variable importance is biased
in favor of variables with many potential cutpoints in <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>,
while in <code><a href="#topic+cforest">cforest</a></code> unbiased trees and an adequate resampling scheme
are used by default. See Hothorn et al. (2006b) and Strobl et al. (2007)
as well as Strobl et al. (2009).
</p>


<h3>Value</h3>

<p>An object of class <code>cforest</code>.
</p>


<h3>References</h3>

<p>Breiman L (2001).
Random Forests.
<em>Machine Learning</em>, <b>45</b>(1), 5&ndash;32.
</p>
<p>Hothorn T, Lausen B, Benner A, Radespiel-Troeger M (2004).
Bagging Survival Trees.
<em>Statistics in Medicine</em>, <b>23</b>(1), 77&ndash;91.
</p>
<p>Hothorn T, Buehlmann P, Dudoit S, Molinaro A, Van der Laan MJ (2006a).
Survival Ensembles.
<em>Biostatistics</em>, <b>7</b>(3), 355&ndash;373.
</p>
<p>Hothorn T, Hornik K, Zeileis A (2006b).
Unbiased Recursive Partitioning: A Conditional Inference Framework.
<em>Journal of Computational and Graphical Statistics</em>, <b>15</b>(3), 651&ndash;674.
</p>
<p>Hothorn T, Zeileis A (2015).
partykit: A Modular Toolkit for Recursive Partytioning in R.
<em>Journal of Machine Learning Research</em>, <b>16</b>, 3905&ndash;3909.
</p>
<p>Meinshausen N (2006).
Quantile Regression Forests.
<em>Journal of Machine Learning Research</em>, <b>7</b>, 983&ndash;999.
</p>
<p>Strobl C, Boulesteix AL, Zeileis A, Hothorn T (2007).
Bias in Random Forest Variable Importance Measures: Illustrations, Sources and a Solution.
<em>BMC Bioinformatics</em>, <b>8</b>, 25.
<a href="https://doi.org/10.1186/1471-2105-8-25">doi:10.1186/1471-2105-8-25</a>
</p>
<p>Strobl C, Malley J, Tutz G (2009).
An Introduction to Recursive Partitioning: Rationale, Application, and Characteristics of
Classification and Regression Trees, Bagging, and Random Forests.
<em>Psychological Methods</em>, <b>14</b>(4), 323&ndash;348.
</p>
<p>Stefan Wager &amp; Susan Athey (2018).
Estimation and Inference of Heterogeneous Treatment Effects using Random
Forests. <em>Journal of the American Statistical Association</em>,
<b>113</b>(523), 1228&ndash;1242. <a href="https://doi.org/10.1080/01621459.2017.1319839">doi:10.1080/01621459.2017.1319839</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## basic example: conditional inference forest for cars data
cf &lt;- cforest(dist ~ speed, data = cars)

## prediction of fitted mean and visualization
nd &lt;- data.frame(speed = 4:25)
nd$mean  &lt;- predict(cf, newdata = nd, type = "response")
plot(dist ~ speed, data = cars)
lines(mean ~ speed, data = nd)

## predict quantiles (aka quantile regression forest)
## Note that this works for integer-valued weight w
## Other weights require weighted quantiles, see for example
## Hmisc::wtd.quantile(
myquantile &lt;- function(y, w) quantile(rep(y, w), probs = c(0.1, 0.5, 0.9))
p &lt;- predict(cf, newdata = nd, type = "response", FUN = myquantile)
colnames(p) &lt;- c("lower", "median", "upper")
nd &lt;- cbind(nd, p)

## visualization with conditional (on speed) prediction intervals
plot(dist ~ speed, data = cars, type = "n")
with(nd, polygon(c(speed, rev(speed)), c(lower, rev(upper)),
  col = "lightgray", border = "transparent"))
points(dist ~ speed, data = cars)
lines(mean ~ speed, data = nd, lwd = 1.5)
lines(median ~ speed, data = nd, lty = 2, lwd = 1.5)
legend("topleft", c("mean", "median", "10% - 90% quantile"),
  lwd = c(1.5, 1.5, 10), lty = c(1, 2, 1),
  col = c("black", "black", "lightgray"), bty = "n")

## Not run: 

### honest (i.e., out-of-bag) cross-classification of
### true vs. predicted classes
data("mammoexp", package = "TH.data")
table(mammoexp$ME, predict(cforest(ME ~ ., data = mammoexp, ntree = 50),
                           OOB = TRUE, type = "response"))

### fit forest to censored response
if (require("TH.data") &amp;&amp; require("survival")) {

    data("GBSG2", package = "TH.data")
    bst &lt;- cforest(Surv(time, cens) ~ ., data = GBSG2, ntree = 50)

    ### estimate conditional Kaplan-Meier curves
    print(predict(bst, newdata = GBSG2[1:2,], OOB = TRUE, type = "prob"))

    print(gettree(bst))
}

## End(Not run)
</code></pre>

<hr>
<h2 id='ctree'>Conditional Inference Trees</h2><span id='topic+ctree'></span><span id='topic+sctest.constparty'></span>

<h3>Description</h3>

<p>Recursive partitioning for continuous, censored, ordered, nominal and
multivariate response variables in a conditional inference framework. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctree(formula, data, subset, weights, na.action = na.pass, offset, cluster, 
    control = ctree_control(...), ytrafo = NULL, 
    converged = NULL, scores = NULL, doFit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctree_+3A_formula">formula</code></td>
<td>
<p> a symbolic description of the model to be fit. </p>
</td></tr>
<tr><td><code id="ctree_+3A_data">data</code></td>
<td>
<p> a data frame containing the variables in the model. </p>
</td></tr>
<tr><td><code id="ctree_+3A_subset">subset</code></td>
<td>
<p> an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="ctree_+3A_weights">weights</code></td>
<td>
<p> an optional vector of weights to be used in the fitting
process. Only non-negative integer valued weights are
allowed.</p>
</td></tr>
<tr><td><code id="ctree_+3A_offset">offset</code></td>
<td>
<p> an optional vector of offset values.</p>
</td></tr>
<tr><td><code id="ctree_+3A_cluster">cluster</code></td>
<td>
<p> an optional factor indicating independent clusters. 
Highly experimental, use at your own risk.</p>
</td></tr>
<tr><td><code id="ctree_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain missing value.</p>
</td></tr>
<tr><td><code id="ctree_+3A_control">control</code></td>
<td>
<p>a list with control parameters, see
<code><a href="#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
<tr><td><code id="ctree_+3A_ytrafo">ytrafo</code></td>
<td>
<p>an optional named list of functions to be applied to the response 
variable(s) before testing their association with the explanatory 
variables. Note that this transformation is only
performed once for the root node and does not take weights into account.
Alternatively, <code>ytrafo</code> can be a function of <code>data</code> and
<code>weights</code>. In this case, the transformation is computed for
every node with corresponding weights. This feature is experimental
and the user interface likely to change.</p>
</td></tr>
<tr><td><code id="ctree_+3A_converged">converged</code></td>
<td>
<p>an optional function for checking user-defined criteria
before splits are implemented. This is not to be used and
very likely to change.</p>
</td></tr>
<tr><td><code id="ctree_+3A_scores">scores</code></td>
<td>
<p>an optional named list of scores to be attached to ordered
factors.</p>
</td></tr>
<tr><td><code id="ctree_+3A_dofit">doFit</code></td>
<td>
<p>a logical, if <code>FALSE</code>, the tree is not fitted.</p>
</td></tr>
<tr><td><code id="ctree_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>partykit::ctree</code> is a reimplementation of (most of)
<code>party::ctree</code> employing the new <code><a href="#topic+party">party</a></code> infrastructure
of the <span class="pkg">partykit</span> infrastructure. The vignette <code>vignette("ctree", package = "partykit")</code>
explains internals of the different implementations.
</p>
<p>Conditional inference trees estimate a regression relationship by binary recursive
partitioning in a conditional inference framework. Roughly, the algorithm
works as follows: 1) Test the global null hypothesis of independence between
any of the input variables and the response (which may be multivariate as well). 
Stop if this hypothesis cannot be rejected. Otherwise select the input
variable with strongest association to the response. This
association is measured by a p-value corresponding to a test for the
partial null hypothesis of a single input variable and the response.
2) Implement a binary split in the selected input variable. 
3) Recursively repeate steps 1) and 2). 
</p>
<p>The implementation utilizes a unified framework for conditional inference,
or permutation tests, developed by Strasser and Weber (1999). The stop
criterion in step 1) is either based on multiplicity adjusted p-values 
(<code>testtype = "Bonferroni"</code> in <code><a href="#topic+ctree_control">ctree_control</a></code>)
or on the univariate p-values (<code>testtype = "Univariate"</code>). In both cases, the
criterion is maximized, i.e., 1 - p-value is used. A split is implemented 
when the criterion exceeds the value given by <code>mincriterion</code> as
specified in <code><a href="#topic+ctree_control">ctree_control</a></code>. For example, when 
<code>mincriterion = 0.95</code>, the p-value must be smaller than
$0.05$ in order to split this node. This statistical approach ensures that
the right-sized tree is grown without additional (post-)pruning or cross-validation.
The level of <code>mincriterion</code> can either be specified to be appropriate
for the size of the data set (and <code>0.95</code> is typically appropriate for
small to moderately-sized data sets) or could potentially be treated like a
hyperparameter (see Section~3.4 in Hothorn, Hornik and Zeileis, 2006).
The selection of the input variable to split in
is based on the univariate p-values avoiding a variable selection bias
towards input variables with many possible cutpoints. The test statistics
in each of the nodes can be extracted with the <code>sctest</code> method.
(Note that the generic is in the <span class="pkg">strucchange</span> package so this either
needs to be loaded or <code>sctest.constparty</code> has to be called directly.)
In cases where splitting stops due to the sample size (e.g., <code>minsplit</code>
or <code>minbucket</code> etc.), the test results may be empty.
</p>
<p>Predictions can be computed using <code><a href="stats.html#topic+predict">predict</a></code>, which returns predicted means,
predicted classes or median predicted survival times and 
more information about the conditional
distribution of the response, i.e., class probabilities
or predicted Kaplan-Meier curves. For observations
with zero weights, predictions are computed from the fitted tree 
when <code>newdata = NULL</code>.
</p>
<p>By default, the scores for each ordinal factor <code>x</code> are
<code>1:length(x)</code>, this may be changed for variables in the formula 
using <code>scores = list(x = c(1, 5, 6))</code>, for example.
</p>
<p>For a general description of the methodology see Hothorn, Hornik and
Zeileis (2006) and Hothorn, Hornik, van de Wiel and Zeileis (2006).
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+party">party</a></code>.
</p>


<h3>References</h3>

 
<p>Hothorn T, Hornik K, Van de Wiel MA, Zeileis A (2006).
A Lego System for Conditional Inference.
<em>The American Statistician</em>, <b>60</b>(3), 257&ndash;263.
</p>
<p>Hothorn T, Hornik K, Zeileis A (2006).
Unbiased Recursive Partitioning: A Conditional Inference Framework.
<em>Journal of Computational and Graphical Statistics</em>, <b>15</b>(3), 651&ndash;674. 
</p>
<p>Hothorn T, Zeileis A (2015).
partykit: A Modular Toolkit for Recursive Partytioning in R.
<em>Journal of Machine Learning Research</em>, <b>16</b>, 3905&ndash;3909.
</p>
<p>Strasser H, Weber C (1999).
On the Asymptotic Theory of Permutation Statistics.
<em>Mathematical Methods of Statistics</em>, <b>8</b>, 220&ndash;250.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### regression
airq &lt;- subset(airquality, !is.na(Ozone))
airct &lt;- ctree(Ozone ~ ., data = airq)
airct
plot(airct)
mean((airq$Ozone - predict(airct))^2)

### classification
irisct &lt;- ctree(Species ~ .,data = iris)
irisct
plot(irisct)
table(predict(irisct), iris$Species)

### estimated class probabilities, a list
tr &lt;- predict(irisct, newdata = iris[1:10,], type = "prob")

### survival analysis
if (require("TH.data") &amp;&amp; require("survival") &amp;&amp; 
    require("coin") &amp;&amp; require("Formula")) {

  data("GBSG2", package = "TH.data")
  (GBSG2ct &lt;- ctree(Surv(time, cens) ~ ., data = GBSG2))
  predict(GBSG2ct, newdata = GBSG2[1:2,], type = "response")	  
  plot(GBSG2ct)

  ### with weight-dependent log-rank scores
  ### log-rank trafo for observations in this node only (= weights &gt; 0)
  h &lt;- function(y, x, start = NULL, weights, offset, estfun = TRUE, object = FALSE, ...) {
      if (is.null(weights)) weights &lt;- rep(1, NROW(y))
      s &lt;- logrank_trafo(y[weights &gt; 0,,drop = FALSE])
      r &lt;- rep(0, length(weights))
      r[weights &gt; 0] &lt;- s
      list(estfun = matrix(as.double(r), ncol = 1), converged = TRUE)
  }

  ### very much the same tree
  (ctree(Surv(time, cens) ~ ., data = GBSG2, ytrafo = h))
}

### multivariate responses
airct2 &lt;- ctree(Ozone + Temp ~ ., data = airq)
airct2
plot(airct2)
</code></pre>

<hr>
<h2 id='ctree_control'> Control for Conditional Inference Trees </h2><span id='topic+ctree_control'></span>

<h3>Description</h3>

<p>Various parameters that control aspects of the &lsquo;ctree&rsquo; fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctree_control(teststat = c("quadratic", "maximum"),
    splitstat = c("quadratic", "maximum"),
    splittest = FALSE,
    testtype = c("Bonferroni", "MonteCarlo", "Univariate", "Teststatistic"),
    pargs = GenzBretz(),
    nmax = c(yx = Inf, z = Inf), alpha = 0.05, mincriterion = 1 - alpha,
    logmincriterion = log(mincriterion), minsplit = 20L, minbucket = 7L,
    minprob = 0.01, stump = FALSE, maxvar = Inf, lookahead = FALSE, 
    MIA = FALSE, nresample = 9999L,
    tol = sqrt(.Machine$double.eps),maxsurrogate = 0L, numsurrogate = FALSE,
    mtry = Inf, maxdepth = Inf,
    multiway = FALSE, splittry = 2L, intersplit = FALSE, majority = FALSE,
    caseweights = TRUE, applyfun = NULL, cores = NULL, saveinfo = TRUE,
    update = NULL, splitflavour = c("ctree", "exhaustive"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctree_control_+3A_teststat">teststat</code></td>
<td>
<p> a character specifying the type of the test statistic
to be applied for variable selection. </p>
</td></tr>
<tr><td><code id="ctree_control_+3A_splitstat">splitstat</code></td>
<td>
<p> a character specifying the type of the test statistic
to be applied for splitpoint selection. Prior to
version 1.2-0, <code>maximum</code> was implemented only.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_splittest">splittest</code></td>
<td>
<p> a logical changing linear (the default <code>FALSE</code>) to
maximally selected statistics for
variable selection. Currently needs <code>testtype = "MonteCarlo"</code>.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_testtype">testtype</code></td>
<td>
<p> a character specifying how to compute the distribution of
the test statistic. The first three options refer to
p-values as criterion, <code>Teststatistic</code> uses the raw
statistic as criterion. <code>Bonferroni</code> and
<code>Univariate</code> relate to p-values from the asymptotic
distribution (adjusted or unadjusted).
Bonferroni-adjusted Monte-Carlo p-values are computed
when both <code>Bonferroni</code> and <code>MonteCarlo</code> are
given.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_pargs">pargs</code></td>
<td>
<p> control parameters for the computation of multivariate
normal probabilities, see <code><a href="mvtnorm.html#topic+GenzBretz">GenzBretz</a></code>.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_nmax">nmax</code></td>
<td>
<p> an integer of length two defining the number of bins each variable
(in the response <code>yx</code> and the partitioning variables
<code>z</code>)) and is divided into prior to tree building. The default <code>Inf</code>
does not apply any binning. Highly experimental, use at your own
risk.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_alpha">alpha</code></td>
<td>
<p> a double, the significance level for variable selection.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_mincriterion">mincriterion</code></td>
<td>
<p> the value of the test statistic or 1 - p-value that
must be exceeded in order to implement a split. </p>
</td></tr>
<tr><td><code id="ctree_control_+3A_logmincriterion">logmincriterion</code></td>
<td>
<p> the value of the test statistic or 1 - p-value that
must be exceeded in order to implement a split on
the log-scale. </p>
</td></tr>
<tr><td><code id="ctree_control_+3A_minsplit">minsplit</code></td>
<td>
<p> the minimum sum of weights in a node in order to be considered
for splitting. </p>
</td></tr>
<tr><td><code id="ctree_control_+3A_minbucket">minbucket</code></td>
<td>
<p> the minimum sum of weights in a terminal node. </p>
</td></tr>
<tr><td><code id="ctree_control_+3A_minprob">minprob</code></td>
<td>
<p> proportion of observations needed to establish a terminal node.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_stump">stump</code></td>
<td>
<p> a logical determining whether a stump (a tree with a maximum of three
nodes only) is to be computed. </p>
</td></tr>
<tr><td><code id="ctree_control_+3A_maxvar">maxvar</code></td>
<td>
<p> maximum number of variables the tree is allowed to split in.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_lookahead">lookahead</code></td>
<td>
<p> a logical determining whether a split is implemented only
after checking if tests in both daughter nodes can be performed.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_mia">MIA</code></td>
<td>
<p> a logical determining the treatment of <code>NA</code> as a category in split,
see Twala et al. (2008).</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_nresample">nresample</code></td>
<td>
<p> number of permutations for <code>testtype = "MonteCarlo"</code>.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_tol">tol</code></td>
<td>
<p>tolerance for zero variances.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_maxsurrogate">maxsurrogate</code></td>
<td>
<p> number of surrogate splits to evaluate.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_numsurrogate">numsurrogate</code></td>
<td>
<p> a logical for backward-compatibility with party. If
<code>TRUE</code>, only at least ordered variables are considered for surrogate splits.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_mtry">mtry</code></td>
<td>
<p> number of input variables randomly sampled as candidates
at each node for random forest like algorithms. The default
<code>mtry = Inf</code> means that no random selection takes place.
If <code><a href="#topic+ctree_control">ctree_control</a></code> is used in <code><a href="#topic+cforest">cforest</a></code>
this argument is ignored.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_maxdepth">maxdepth</code></td>
<td>
<p> maximum depth of the tree. The default <code>maxdepth = Inf</code>
means that no restrictions are applied to tree sizes.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_multiway">multiway</code></td>
<td>
<p> a logical indicating if multiway splits for all factor levels
are implemented for unordered factors.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_splittry">splittry</code></td>
<td>
<p> number of variables that are inspected for admissible splits
if the best split doesn't meet the sample size constraints.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_intersplit">intersplit</code></td>
<td>
<p> a logical indicating if splits in numeric variables
are simply <code>x &lt;= a</code> (the default) or interpolated
<code>x &lt;= (a + b) / 2</code>. The latter feature is experimental, see
Galili and Meilijson (2016).</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_majority">majority</code></td>
<td>
<p> if <code>FALSE</code> (the default), observations which can't be classified to a
daughter node because of missing information are randomly
assigned (following the node distribution). If <code>TRUE</code>,
they go with the majority (the default in the first
implementation <code><a href="party.html#topic+ctree">ctree</a></code>) in package
party.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_caseweights">caseweights</code></td>
<td>
<p> a logical interpreting <code>weights</code> as case weights.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_applyfun">applyfun</code></td>
<td>
<p>an optional <code><a href="base.html#topic+lapply">lapply</a></code>-style function with arguments
<code>function(X, FUN, ...)</code>. It is used for computing the variable selection criterion.
The default is to use the basic <code>lapply</code>
function unless the <code>cores</code> argument is specified (see below).
If <code><a href="#topic+ctree_control">ctree_control</a></code> is used in <code><a href="#topic+cforest">cforest</a></code>
this argument is ignored.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_cores">cores</code></td>
<td>
<p>numeric. If set to an integer the <code>applyfun</code> is set to
<code><a href="parallel.html#topic+mclapply">mclapply</a></code> with the desired number of <code>cores</code>.
If <code><a href="#topic+ctree_control">ctree_control</a></code> is used in <code><a href="#topic+cforest">cforest</a></code>
this argument is ignored.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_saveinfo">saveinfo</code></td>
<td>
<p>logical. Store information about variable selection
procedure in <code>info</code> slot of each <code>partynode</code>.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_update">update</code></td>
<td>
<p>logical. If <code>TRUE</code>, the data transformation is updated
in every node. The default always was and still is not to
update unless <code>ytrafo</code> is a function.</p>
</td></tr>
<tr><td><code id="ctree_control_+3A_splitflavour">splitflavour</code></td>
<td>
<p>use exhaustive search over splits instead of maximally
selected statistics (<code>ctree</code>). This feature may change.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>teststat</code>, <code>testtype</code> and <code>mincriterion</code>
determine how the global null hypothesis of independence between all input
variables and the response is tested (see <code><a href="#topic+ctree">ctree</a></code>).
The variable with most extreme p-value or test statistic is selected
for splitting. If this isn't possible due to sample size constraints
explained in the next paragraph, up to <code>splittry</code> other variables
are inspected for possible splits.
</p>
<p>A split is established when all of the following criteria are met:
1) the sum of the weights in the current node
is larger than <code>minsplit</code>, 2) a fraction of the sum of weights of more than
<code>minprob</code> will be contained in all daughter nodes, 3) the sum of
the weights in all daughter nodes exceeds <code>minbucket</code>, and 4)
the depth of the tree is smaller than <code>maxdepth</code>.
This avoids pathological splits deep down the tree.
When <code>stump = TRUE</code>, a tree with at most two terminal nodes is computed.
</p>
<p>The argument <code>mtry &gt; 0</code> means that a random forest like 'variable
selection', i.e., a random selection of <code>mtry</code> input variables, is
performed in each node.
</p>
<p>In each inner node, <code>maxsurrogate</code> surrogate splits are computed
(regardless of any missing values in the learning sample). Factors
in test samples whose levels were empty in the learning sample
are treated as missing when computing predictions (in contrast
to <code><a href="party.html#topic+ctree">ctree</a></code>. Note also the different behaviour of
<code>majority</code> in the two implementations.
</p>


<h3>Value</h3>

<p>A list.
</p>


<h3>References</h3>

<p>B. E. T. H. Twala, M. C. Jones, and D. J. Hand (2008),
Good Methods for Coping with Missing Data in Decision Trees,
<em>Pattern Recognition Letters</em>, <b>29</b>(7), 950&ndash;956.
</p>
<p>Tal Galili, Isaac Meilijson (2016), Splitting Matters: How
Monotone Transformation of Predictor Variables May Improve the
Predictions of Decision Tree Models, <a href="https://arxiv.org/abs/1611.04561">https://arxiv.org/abs/1611.04561</a>.
</p>

<hr>
<h2 id='extree_data'>
Data Preprocessing for Extensible Trees.
</h2><span id='topic+extree_data'></span>

<h3>Description</h3>

<p>A routine for preprocessing data before an extensible tree can be grown by
<code>extree_fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extree_data(formula, data, subset, na.action = na.pass, weights, offset, 
            cluster, strata, scores = NULL, yx = c("none", "matrix"),
            ytype = c("vector", "data.frame", "matrix"), 
            nmax = c(yx = Inf, z = Inf), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extree_data_+3A_formula">formula</code></td>
<td>
<p>a formula describing the model of the form <code>y1 + y2 + ... ~
x1 + x2 + ... | z1 + z2 + ...</code>.
</p>
</td></tr>
<tr><td><code id="extree_data_+3A_data">data</code></td>
<td>
<p>an optional data.frame containing the variables in the model.
</p>
</td></tr>
<tr><td><code id="extree_data_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.
</p>
</td></tr>
<tr><td><code id="extree_data_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the
data contain missing values.
</p>
</td></tr>
<tr><td><code id="extree_data_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights.
</p>
</td></tr>
<tr><td><code id="extree_data_+3A_offset">offset</code></td>
<td>
<p>an optional offset vector.
</p>
</td></tr>
<tr><td><code id="extree_data_+3A_cluster">cluster</code></td>
<td>
<p>an optional factor describing clusters. The interpretation
depends on the specific tree algorithm.
</p>
</td></tr>
<tr><td><code id="extree_data_+3A_strata">strata</code></td>
<td>
<p>an optional factor describing strata. The interpretation
depends on the specific tree algorithm.
</p>
</td></tr>
<tr><td><code id="extree_data_+3A_scores">scores</code></td>
<td>
<p>an optional named list of numeric scores to be assigned to
ordered factors in the <code>z</code> part of the formula.
</p>
</td></tr>
<tr><td><code id="extree_data_+3A_yx">yx</code></td>
<td>
<p>a character indicating if design matrices shall be computed. 
</p>
</td></tr>
<tr><td><code id="extree_data_+3A_ytype">ytype</code></td>
<td>
<p>a character indicating how response variables shall be
stored.
</p>
</td></tr>
<tr><td><code id="extree_data_+3A_nmax">nmax</code></td>
<td>
<p>a numeric vector of length two with the maximal number of
bins in the response and <code>x</code>-part (first element) and the <code>z</code>
part. Use <code>Inf</code> to switch-off binning.
</p>
</td></tr>
<tr><td><code id="extree_data_+3A_...">...</code></td>
<td>
<p>additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This internal functionality will be the basis of implementations of other
tree algorithms in future versions. Currently, only <code>ctree</code> relies on
this function.
</p>


<h3>Value</h3>

<p>An object of class <code>extree_data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data("iris")

  ed &lt;- extree_data(Species ~ Sepal.Width + Sepal.Length | Petal.Width + Petal.Length, 
                    data = iris, nmax = c("yx" = 25, "z" = 10), yx = "matrix")

  ### the model.frame
  mf &lt;- model.frame(ed)
  all.equal(mf, iris[, names(mf)])

  ### binned y ~ x part
  model.frame(ed, yxonly = TRUE)

  ### binned Petal.Width
  ed[[4, type = "index"]]

  ### response
  ed$yx$y

  ### model matrix 
  ed$yx$x

</code></pre>

<hr>
<h2 id='extree_fit'>
Fit Extensible Trees.
</h2><span id='topic+extree_fit'></span>

<h3>Description</h3>

<p>Basic infrastructure for fitting extensible trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extree_fit(data, trafo, converged, selectfun = ctrl$selectfun, splitfun = ctrl$splitfun, 
           svselectfun = ctrl$svselectfun, svsplitfun = ctrl$svsplitfun, partyvars, 
           subset, weights, ctrl, doFit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extree_fit_+3A_data">data</code></td>
<td>
<p>an object of class <code>extree_data</code>, see
<code><a href="#topic+extree_data">extree_data</a></code>.
</p>
</td></tr>
<tr><td><code id="extree_fit_+3A_trafo">trafo</code></td>
<td>
<p>a function with arguments <code>subset</code>, <code>weights</code>,
<code>info</code>, <code>estfun</code> and <code>object</code>.
</p>
</td></tr>
<tr><td><code id="extree_fit_+3A_converged">converged</code></td>
<td>
<p>a function with arguments <code>subset</code>, <code>weights</code>.
</p>
</td></tr>
<tr><td><code id="extree_fit_+3A_selectfun">selectfun</code></td>
<td>
<p>an optional function for selecting variables.
</p>
</td></tr>
<tr><td><code id="extree_fit_+3A_splitfun">splitfun</code></td>
<td>
<p>an optional function for selecting splits.
</p>
</td></tr>
<tr><td><code id="extree_fit_+3A_svselectfun">svselectfun</code></td>
<td>
<p>an optional function for selecting surrogate variables.
</p>
</td></tr>
<tr><td><code id="extree_fit_+3A_svsplitfun">svsplitfun</code></td>
<td>
<p>an optional function for selecting surrogate splits.
</p>
</td></tr>
<tr><td><code id="extree_fit_+3A_partyvars">partyvars</code></td>
<td>
<p>a numeric vector assigning a weight to each partitioning
variable (<code>z</code> in <code><a href="#topic+extree_data">extree_data</a></code>.
</p>
</td></tr>
<tr><td><code id="extree_fit_+3A_subset">subset</code></td>
<td>
<p>a sorted integer vector describing a subset.
</p>
</td></tr>
<tr><td><code id="extree_fit_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights.
</p>
</td></tr>
<tr><td><code id="extree_fit_+3A_ctrl">ctrl</code></td>
<td>
<p>control arguments.
</p>
</td></tr>
<tr><td><code id="extree_fit_+3A_dofit">doFit</code></td>
<td>
<p>a logical indicating if the tree shall be grown (<code>TRUE</code>)
or not <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This internal functionality will be the basis of implementations of other
tree algorithms in future versions. Currently, only <code>ctree</code> relies on
this function.
</p>


<h3>Value</h3>

<p>An object of class <code>partynode</code>.</p>

<hr>
<h2 id='glmtree'>Generalized Linear Model Trees</h2><span id='topic+glmtree'></span><span id='topic+plot.glmtree'></span><span id='topic+predict.glmtree'></span><span id='topic+print.glmtree'></span>

<h3>Description</h3>

<p>Model-based recursive partitioning based on generalized linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmtree(formula, data, subset, na.action, weights, offset, cluster,
  family = gaussian, epsilon = 1e-8, maxit = 25, method = "glm.fit", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmtree_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model (of type
<code>y ~ z1 + ... + zl</code> or <code>y ~ x1 + ... + xk | z1 + ... + zl</code>;
for details see below).</p>
</td></tr>
<tr><td><code id="glmtree_+3A_data">data</code>, <code id="glmtree_+3A_subset">subset</code>, <code id="glmtree_+3A_na.action">na.action</code></td>
<td>
<p>arguments controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="glmtree_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights. By default these are
treated as case weights but the default can be changed in
<code><a href="#topic+mob_control">mob_control</a></code>.</p>
</td></tr>
<tr><td><code id="glmtree_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the model <code>y ~ x1 + ... + xk</code> (i.e., only when
<code>x</code> variables are specified).</p>
</td></tr>
<tr><td><code id="glmtree_+3A_cluster">cluster</code></td>
<td>
<p>optional vector (typically numeric or factor) with a
cluster ID to be employed for clustered covariances in the parameter
stability tests.</p>
</td></tr>
<tr><td><code id="glmtree_+3A_family">family</code>, <code id="glmtree_+3A_method">method</code></td>
<td>
<p>specification of a family and fitting method for
<code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="glmtree_+3A_epsilon">epsilon</code>, <code id="glmtree_+3A_maxit">maxit</code></td>
<td>
<p>control parameters passed to
<code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="glmtree_+3A_...">...</code></td>
<td>
<p>optional control parameters passed to
<code><a href="#topic+mob_control">mob_control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convenience interface for fitting MOBs (model-based recursive partitions) via
the <code><a href="#topic+mob">mob</a></code> function. <code>glmtree</code> internally sets up a model
<code>fit</code> function for <code>mob</code>, using <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>.
Then <code>mob</code> is called using the negative log-likelihood as the objective
function.
</p>
<p>Compared to calling <code>mob</code> by hand, the implementation tries to avoid
unnecessary computations while growing the tree. Also, it provides a more
elaborate plotting function.
</p>


<h3>Value</h3>

<p>An object of class <code>glmtree</code> inheriting from <code><a href="#topic+modelparty">modelparty</a></code>.
The <code>info</code> element of the overall <code>party</code> and the individual
<code>node</code>s contain various informations about the models.
</p>


<h3>References</h3>

 
<p>Zeileis A, Hothorn T, Hornik K (2008).
Model-Based Recursive Partitioning.
<em>Journal of Computational and Graphical Statistics</em>, <b>17</b>(2), 492&ndash;514.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mob">mob</a></code>, <code><a href="#topic+mob_control">mob_control</a></code>, <code><a href="#topic+lmtree">lmtree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("mlbench")) {

## Pima Indians diabetes data
data("PimaIndiansDiabetes", package = "mlbench")

## recursive partitioning of a logistic regression model
pid_tree2 &lt;- glmtree(diabetes ~ glucose | pregnant +
  pressure + triceps + insulin + mass + pedigree + age,
  data = PimaIndiansDiabetes, family = binomial)

## printing whole tree or individual nodes
print(pid_tree2)
print(pid_tree2, node = 1)

## visualization
plot(pid_tree2)
plot(pid_tree2, tp_args = list(cdplot = TRUE))
plot(pid_tree2, terminal_panel = NULL)

## estimated parameters
coef(pid_tree2)
coef(pid_tree2, node = 5)
summary(pid_tree2, node = 5)

## deviance, log-likelihood and information criteria
deviance(pid_tree2)
logLik(pid_tree2)
AIC(pid_tree2)
BIC(pid_tree2)

## different types of predictions
pid &lt;- head(PimaIndiansDiabetes)
predict(pid_tree2, newdata = pid, type = "node")
predict(pid_tree2, newdata = pid, type = "response")
predict(pid_tree2, newdata = pid, type = "link")

}
</code></pre>

<hr>
<h2 id='HuntingSpiders'>Abundance of Hunting Spiders</h2><span id='topic+HuntingSpiders'></span>

<h3>Description</h3>

<p>Abundances for 12 species of hunting spiders along with
environmental predictors, all rated on a 0&ndash;9 scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HuntingSpiders")</code></pre>


<h3>Format</h3>

<p>A data frame containing 28 observations on 18 variables
(12 species abundances and 6 environmental predictors).
</p>

<dl>
<dt>arct.lute</dt><dd><p>numeric. Abundance of species <em>Arctosa lutetiana</em> (on a scale 0&ndash;9).</p>
</dd>
<dt>pard.lugu</dt><dd><p>numeric. Abundance of species <em>Pardosa lugubris</em> (on a scale 0&ndash;9).</p>
</dd>
<dt>zora.spin</dt><dd><p>numeric. Abundance of species <em>Zora spinimana</em> (on a scale 0&ndash;9).</p>
</dd>
<dt>pard.nigr</dt><dd><p>numeric. Abundance of species <em>Pardosa nigriceps</em> (on a scale 0&ndash;9).</p>
</dd>
<dt>pard.pull</dt><dd><p>numeric. Abundance of species <em>Pardosa pullata</em> (on a scale 0&ndash;9).</p>
</dd>
<dt>aulo.albi</dt><dd><p>numeric. Abundance of species <em>Aulonia albimana</em> (on a scale 0&ndash;9).</p>
</dd>
<dt>troc.terr</dt><dd><p>numeric. Abundance of species <em>Trochosa terricola</em> (on a scale 0&ndash;9).</p>
</dd>
<dt>alop.cune</dt><dd><p>numeric. Abundance of species <em>Alopecosa cuneata</em> (on a scale 0&ndash;9).</p>
</dd>
<dt>pard.mont</dt><dd><p>numeric. Abundance of species <em>Pardosa monticola</em> (on a scale 0&ndash;9).</p>
</dd>
<dt>alop.acce</dt><dd><p>numeric. Abundance of species <em>Alopecosa accentuata</em> (on a scale 0&ndash;9).</p>
</dd>
<dt>alop.fabr</dt><dd><p>numeric. Abundance of species <em>Alopecosa fabrilis</em> (on a scale 0&ndash;9).</p>
</dd>
<dt>arct.peri</dt><dd><p>numeric. Abundance of species <em>Arctosa perita</em> (on a scale 0&ndash;9).</p>
</dd>
<dt>water</dt><dd><p>numeric. Environmental predictor on a scale 0&ndash;9.</p>
</dd>
<dt>sand</dt><dd><p>numeric. Environmental predictor on a scale 0&ndash;9.</p>
</dd>
<dt>moss</dt><dd><p>numeric. Environmental predictor on a scale 0&ndash;9.</p>
</dd>
<dt>reft</dt><dd><p>numeric. Environmental predictor on a scale 0&ndash;9.</p>
</dd>
<dt>twigs</dt><dd><p>numeric. Environmental predictor on a scale 0&ndash;9.</p>
</dd>
<dt>herbs</dt><dd><p>numeric. Environmental predictor on a scale 0&ndash;9.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were originally analyzed by Van der Aart and Smeenk-Enserink (1975).
De'ath (2002) transformed all variables to the 0&ndash;9 scale and employed
multivariate regression trees.
</p>


<h3>Source</h3>

<p>Package <span class="pkg">mvpart</span> (currently archived, see
<a href="https://CRAN.R-project.org/package=mvpart">https://CRAN.R-project.org/package=mvpart</a>).
</p>


<h3>References</h3>

<p>Van der Aart PJM, Smeenk-Enserink N (1975).
Correlations between Distributions of Hunting Spiders (Lycosidae, Ctenidae)
and Environmental Characteristics in a Dune Area.
<em>Netherlands Journal of Zoology</em>, <b>25</b>, 1&ndash;45.
</p>
<p>De'ath G (2002).
Multivariate Regression Trees: A New Technique for Modelling Species-Environment Relationships.
<em>Ecology</em>, <b>83</b>(4), 1103&ndash;1117.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load data
data("HuntingSpiders", package = "partykit")

## fit multivariate tree for 12-dimensional species abundance
## (warnings by mvtnorm are suppressed)
suppressWarnings(sptree &lt;- ctree(arct.lute + pard.lugu + zora.spin + pard.nigr + pard.pull +
  aulo.albi + troc.terr + alop.cune + pard.mont + alop.acce + alop.fabr +
  arct.peri ~ herbs + reft + moss + sand + twigs + water, data = HuntingSpiders,
  teststat = "max", minsplit = 5))
plot(sptree, terminal_panel = node_barplot)
</code></pre>

<hr>
<h2 id='lmtree'>Linear Model Trees</h2><span id='topic+lmtree'></span><span id='topic+plot.lmtree'></span><span id='topic+predict.lmtree'></span><span id='topic+print.lmtree'></span>

<h3>Description</h3>

<p>Model-based recursive partitioning based on least squares
regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmtree(formula, data, subset, na.action, weights, offset, cluster, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmtree_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model (of type
<code>y ~ z1 + ... + zl</code> or <code>y ~ x1 + ... + xk | z1 + ... + zl</code>;
for details see below).</p>
</td></tr>
<tr><td><code id="lmtree_+3A_data">data</code>, <code id="lmtree_+3A_subset">subset</code>, <code id="lmtree_+3A_na.action">na.action</code></td>
<td>
<p>arguments controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="lmtree_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights. By default these are
treated as case weights but the default can be changed in
<code><a href="#topic+mob_control">mob_control</a></code>.</p>
</td></tr>
<tr><td><code id="lmtree_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the model <code>y ~ x1 + ... + xk</code> (i.e., only when
<code>x</code> variables are specified).</p>
</td></tr>
<tr><td><code id="lmtree_+3A_cluster">cluster</code></td>
<td>
<p>optional vector (typically numeric or factor) with a
cluster ID to be employed for clustered covariances in the parameter
stability tests.</p>
</td></tr>
<tr><td><code id="lmtree_+3A_...">...</code></td>
<td>
<p>optional control parameters passed to
<code><a href="#topic+mob_control">mob_control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convenience interface for fitting MOBs (model-based recursive partitions) via
the <code><a href="#topic+mob">mob</a></code> function. <code>lmtree</code> internally sets up a model
<code>fit</code> function for <code>mob</code>, using either <code><a href="stats.html#topic+lm.fit">lm.fit</a></code>
or <code><a href="stats.html#topic+lm.wfit">lm.wfit</a></code> (depending on whether weights are used or not).
Then <code>mob</code> is called using the residual sum of squares as the objective
function.
</p>
<p>Compared to calling <code>mob</code> by hand, the implementation tries to avoid
unnecessary computations while growing the tree. Also, it provides a more
elaborate plotting function.
</p>


<h3>Value</h3>

<p>An object of class <code>lmtree</code> inheriting from <code><a href="#topic+modelparty">modelparty</a></code>.
The <code>info</code> element of the overall <code>party</code> and the individual
<code>node</code>s contain various informations about the models.
</p>


<h3>References</h3>

 
<p>Zeileis A, Hothorn T, Hornik K (2008).
Model-Based Recursive Partitioning.
<em>Journal of Computational and Graphical Statistics</em>, <b>17</b>(2), 492&ndash;514.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mob">mob</a></code>, <code><a href="#topic+mob_control">mob_control</a></code>, <code><a href="#topic+glmtree">glmtree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("mlbench")) {

## Boston housing data
data("BostonHousing", package = "mlbench")
BostonHousing &lt;- transform(BostonHousing,
  chas = factor(chas, levels = 0:1, labels = c("no", "yes")),
  rad = factor(rad, ordered = TRUE))

## linear model tree
bh_tree &lt;- lmtree(medv ~ log(lstat) + I(rm^2) | zn +
  indus + chas + nox + age + dis + rad + tax + crim + b + ptratio,
  data = BostonHousing, minsize = 40)

## printing whole tree or individual nodes
print(bh_tree)
print(bh_tree, node = 7)

## plotting
plot(bh_tree)
plot(bh_tree, tp_args = list(which = "log(lstat)"))
plot(bh_tree, terminal_panel = NULL)

## estimated parameters
coef(bh_tree)
coef(bh_tree, node = 9)
summary(bh_tree, node = 9)

## various ways for computing the mean squared error (on the training data)
mean((BostonHousing$medv - fitted(bh_tree))^2)
mean(residuals(bh_tree)^2)
deviance(bh_tree)/sum(weights(bh_tree))
deviance(bh_tree)/nobs(bh_tree)

## log-likelihood and information criteria
logLik(bh_tree)
AIC(bh_tree)
BIC(bh_tree)
## (Note that this penalizes estimation of error variances, which
## were treated as nuisance parameters in the fitting process.)

## different types of predictions
bh &lt;- BostonHousing[c(1, 10, 50), ]
predict(bh_tree, newdata = bh, type = "node")
predict(bh_tree, newdata = bh, type = "response")
predict(bh_tree, newdata = bh, type = function(object) summary(object)$r.squared)

}


if(require("AER")) {

## Demand for economics journals data
data("Journals", package = "AER")
Journals &lt;- transform(Journals,
  age = 2000 - foundingyear,
  chars = charpp * pages)

## linear regression tree (OLS)
j_tree &lt;- lmtree(log(subs) ~ log(price/citations) | price + citations +
  age + chars + society, data = Journals, minsize = 10, verbose = TRUE)

## printing and plotting
j_tree
plot(j_tree)

## coefficients and summary
coef(j_tree, node = 1:3)
summary(j_tree, node = 1:3)

}


if(require("AER")) {

## Beauty and teaching ratings data
data("TeachingRatings", package = "AER")

## linear regression (WLS)
## null model
tr_null &lt;- lm(eval ~ 1, data = TeachingRatings, weights = students,
  subset = credits == "more")
## main effects
tr_lm &lt;- lm(eval ~ beauty + gender + minority + native + tenure + division,
  data = TeachingRatings, weights = students, subset = credits == "more")
## tree
tr_tree &lt;- lmtree(eval ~ beauty | minority + age + gender + division + native + tenure,
   data = TeachingRatings, weights = students, subset = credits == "more",
   caseweights = FALSE)

## visualization
plot(tr_tree)

## beauty slope coefficient
coef(tr_lm)[2]
coef(tr_tree)[, 2]

## R-squared
1 - deviance(tr_lm)/deviance(tr_null)
1 - deviance(tr_tree)/deviance(tr_null)
}

</code></pre>

<hr>
<h2 id='mob'>Model-based Recursive Partitioning</h2><span id='topic+mob'></span><span id='topic+modelparty'></span><span id='topic+coef.modelparty'></span><span id='topic+deviance.modelparty'></span><span id='topic+fitted.modelparty'></span><span id='topic+formula.modelparty'></span><span id='topic+getCall.modelparty'></span><span id='topic+logLik.modelparty'></span><span id='topic+model.frame.modelparty'></span><span id='topic+nobs.modelparty'></span><span id='topic+plot.modelparty'></span><span id='topic+predict.modelparty'></span><span id='topic+print.modelparty'></span><span id='topic+residuals.modelparty'></span><span id='topic+summary.modelparty'></span><span id='topic+weights.modelparty'></span><span id='topic+refit.modelparty'></span><span id='topic+sctest.modelparty'></span>

<h3>Description</h3>

<p>MOB is an algorithm for model-based recursive partitioning yielding
a tree with fitted models associated with each terminal node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mob(formula, data, subset, na.action, weights, offset, cluster,
  fit, control = mob_control(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mob_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model (of type
<code>y ~ z1 + ... + zl</code> or <code>y ~ x1 + ... + xk | z1 + ... + zl</code>;
for details see below).</p>
</td></tr>
<tr><td><code id="mob_+3A_data">data</code>, <code id="mob_+3A_subset">subset</code>, <code id="mob_+3A_na.action">na.action</code></td>
<td>
<p>arguments controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="mob_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights. By default these are
treated as case weights but the default can be changed in
<code><a href="#topic+mob_control">mob_control</a></code>.</p>
</td></tr>
<tr><td><code id="mob_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the model <code>y ~ x1 + ... + xk</code> (i.e., only when
<code>x</code> variables are specified).</p>
</td></tr>
<tr><td><code id="mob_+3A_cluster">cluster</code></td>
<td>
<p>optional vector (typically numeric or factor) with a
cluster ID to be passed on to the <code>fit</code> function and employed
for clustered covariances in the parameter stability tests.</p>
</td></tr>
<tr><td><code id="mob_+3A_fit">fit</code></td>
<td>
<p>function. A function for fitting the model within each node.
For details see below.</p>
</td></tr>
<tr><td><code id="mob_+3A_control">control</code></td>
<td>
<p>A list with control parameters as returned by
<code><a href="#topic+mob_control">mob_control</a></code>.</p>
</td></tr>
<tr><td><code id="mob_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>fit</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model-based partitioning fits a model tree using two groups of variables:
(1) The model variables which can be just a (set of) response(s) <code>y</code> or
additionally include regressors <code>x1</code>, ..., <code>xk</code>. These are used
for estimating the model parameters.
(2) Partitioning variables <code>z1</code>, ..., <code>zl</code>, which are used for
recursively partitioning the data. The two groups of variables are either specified
as <code>y ~ z1 + ... + zl</code> (when there are no regressors) or
<code>y ~ x1 + ... + xk | z1 + ... + zl</code> (when the model part contains regressors).
Both sets of variables may in principle be overlapping.
</p>
<p>To fit a tree model the following algorithm is used.
</p>

<ol>
<li> <p><code>fit</code> a model to the <code>y</code> or <code>y</code> and <code>x</code> variables
using the observations in the current node
</p>
</li>
<li><p> Assess the stability of the model parameters with respect to each
of the partitioning variables <code>z1</code>, ..., <code>zl</code>. If
there is some overall instability, choose the variable <code>z</code>
associated with the smallest <code class="reqn">p</code> value for partitioning, otherwise
stop.
</p>
</li>
<li><p> Search for the locally optimal split in <code>z</code> by minimizing the
objective function of the model. Typically, this will be
something like <code><a href="stats.html#topic+deviance">deviance</a></code> or the negative <code><a href="stats.html#topic+logLik">logLik</a></code>.
</p>
</li>
<li><p> Refit the <code>model</code> in both kid subsamples and repeat from step 2.
</p>
</li></ol>

<p>More details on the conceptual design of the algorithm can be found in 
Zeileis, Hothorn, Hornik (2008) and some illustrations are provided in
<code>vignette("MOB")</code>.
For specifying the <code>fit</code> function two approaches are possible:
</p>
<p>(1) It can be a function <code>fit(y, x = NULL, start = NULL, weights = NULL,
offset = NULL, ...)</code>. The arguments <code>y</code>, <code>x</code>, <code>weights</code>, <code>offset</code>
will be set to the corresponding elements in the current node of the tree.
Additionally, starting values will sometimes be supplied via <code>start</code>.
Of course, the <code>fit</code> function can choose to ignore any arguments that are
not applicable, e.g., if the are no regressors <code>x</code> in the model or if
starting values or not supported. The returned object needs to have a class
that has associated <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>, and
<code><a href="sandwich.html#topic+estfun">estfun</a></code> methods for extracting the estimated parameters,
the maximized log-likelihood, and the empirical estimating function (i.e.,
score or gradient contributions), respectively.
</p>
<p>(2) It can be a function <code>fit(y, x = NULL, start = NULL, weights = NULL,
offset = NULL, ..., estfun = FALSE, object = FALSE)</code>. The arguments have the
same meaning as above but the returned object needs to have a different structure.
It needs to be a list with elements <code>coefficients</code> (containing the estimated
parameters), <code>objfun</code> (containing the minimized objective function),
<code>estfun</code> (the empirical estimating functions), and <code>object</code> (the
fitted model object). The elements <code>estfun</code>, or <code>object</code> should be
<code>NULL</code> if the corresponding argument is set to <code>FALSE</code>.
</p>
<p>Internally, a function of type (2) is set up by <code>mob()</code> in case a function
of type (1) is supplied. However, to save computation time, a function of type
(2) may also be specified directly.
</p>
<p>For the fitted MOB tree, several standard methods are provided such as
<code>print</code>, <code>predict</code>, <code>residuals</code>, <code>logLik</code>, <code>deviance</code>,
<code>weights</code>, <code>coef</code> and <code>summary</code>. Some of these rely on reusing the
corresponding methods for the individual model objects in the terminal nodes.
Functions such as <code>coef</code>, <code>print</code>, <code>summary</code> also take a
<code>node</code> argument that can specify the node IDs to be queried.
Some examples are given below.
</p>
<p>More details can be found in <code>vignette("mob", package = "partykit")</code>.
An overview of the connections to other functions in the package is provided
by Hothorn and Zeileis (2015).
</p>


<h3>Value</h3>

<p>An object of class <code>modelparty</code> inheriting from <code><a href="#topic+party">party</a></code>.
The <code>info</code> element of the overall <code>party</code> and the individual
<code>node</code>s contain various informations about the models.
</p>


<h3>References</h3>

 
<p>Hothorn T, Zeileis A (2015).
partykit: A Modular Toolkit for Recursive Partytioning in R.
<em>Journal of Machine Learning Research</em>, <b>16</b>, 3905&ndash;3909.
</p>
<p>Zeileis A, Hothorn T, Hornik K (2008).
Model-Based Recursive Partitioning.
<em>Journal of Computational and Graphical Statistics</em>, <b>17</b>(2), 492&ndash;514.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mob_control">mob_control</a></code>, <code><a href="#topic+lmtree">lmtree</a></code>, <code><a href="#topic+glmtree">glmtree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("mlbench")) {

## Pima Indians diabetes data
data("PimaIndiansDiabetes", package = "mlbench")

## a simple basic fitting function (of type 1) for a logistic regression
logit &lt;- function(y, x, start = NULL, weights = NULL, offset = NULL, ...) {
  glm(y ~ 0 + x, family = binomial, start = start, ...)
}

## set up a logistic regression tree
pid_tree &lt;- mob(diabetes ~ glucose | pregnant + pressure + triceps + insulin +
  mass + pedigree + age, data = PimaIndiansDiabetes, fit = logit)
## see lmtree() and glmtree() for interfaces with more efficient fitting functions

## print tree
print(pid_tree)

## print information about (some) nodes
print(pid_tree, node = 3:4)

## visualization
plot(pid_tree)

## coefficients and summary
coef(pid_tree)
coef(pid_tree, node = 1)
summary(pid_tree, node = 1)

## average deviance computed in different ways
mean(residuals(pid_tree)^2)
deviance(pid_tree)/sum(weights(pid_tree))
deviance(pid_tree)/nobs(pid_tree)

## log-likelihood and information criteria
logLik(pid_tree)
AIC(pid_tree)
BIC(pid_tree)

## predicted nodes
predict(pid_tree, newdata = head(PimaIndiansDiabetes, 6), type = "node")
## other types of predictions are possible using lmtree()/glmtree()
}
</code></pre>

<hr>
<h2 id='mob_control'>Control Parameters for Model-Based Partitioning</h2><span id='topic+mob_control'></span>

<h3>Description</h3>

<p>Various parameters that control aspects the fitting algorithm
for recursively partitioned <code><a href="#topic+mob">mob</a></code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mob_control(alpha = 0.05, bonferroni = TRUE, minsize = NULL, maxdepth = Inf,
  mtry = Inf, trim = 0.1, breakties = FALSE, parm = NULL, dfsplit = TRUE, prune = NULL,
  restart = TRUE, verbose = FALSE, caseweights = TRUE, ytype = "vector", xtype = "matrix",
  terminal = "object", inner = terminal, model = TRUE, numsplit = "left",
  catsplit = "binary", vcov = "opg", ordinal = "chisq", nrep = 10000,
  minsplit = minsize, minbucket = minsize, applyfun = NULL, cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mob_control_+3A_alpha">alpha</code></td>
<td>
<p>numeric significance level. A node is splitted when
the (possibly Bonferroni-corrected) <code class="reqn">p</code> value for any parameter
stability test in that node falls below <code>alpha</code> (and the stopping
criteria <code>minsize</code> and <code>maxdepth</code> are not fulfilled).</p>
</td></tr>
<tr><td><code id="mob_control_+3A_bonferroni">bonferroni</code></td>
<td>
<p>logical. Should <code class="reqn">p</code> values be Bonferroni corrected?</p>
</td></tr>
<tr><td><code id="mob_control_+3A_minsize">minsize</code>, <code id="mob_control_+3A_minsplit">minsplit</code>, <code id="mob_control_+3A_minbucket">minbucket</code></td>
<td>
<p>integer. The minimum number of observations in a node.
If <code>NULL</code>, the default is to use 10 times the number of parameters
to be estimated (divided by the number of responses per observation
if that is greater than 1). <code>minsize</code> is the recommended name and
<code>minsplit</code>/<code>minbucket</code> are only included for backward compatibility with previous
versions of <code>mob</code> and compatibility with <code>ctree</code>, respectively.</p>
</td></tr>
<tr><td><code id="mob_control_+3A_maxdepth">maxdepth</code></td>
<td>
<p>integer. The maximum depth of the tree.</p>
</td></tr>
<tr><td><code id="mob_control_+3A_mtry">mtry</code></td>
<td>
<p>integer. The number of partitioning variables randomly sampled
as candidates in each node for forest-style algorithms. If <code>mtry</code>
is greater than the number of partitioning variables, no random selection
is performed. (Thus, by default all available partitioning variables are considered.)</p>
</td></tr>
<tr><td><code id="mob_control_+3A_trim">trim</code></td>
<td>
<p>numeric. This specifies the trimming in the parameter instability
test for the numerical variables. If smaller than 1, it is interpreted
as the fraction relative to the current node size.</p>
</td></tr>
<tr><td><code id="mob_control_+3A_breakties">breakties</code></td>
<td>
<p>logical. Should ties in numeric variables be broken
randomly for computing the associated parameter instability test?</p>
</td></tr>
<tr><td><code id="mob_control_+3A_parm">parm</code></td>
<td>
<p>numeric or character. Number or name of model parameters
included in the parameter instability tests (by default all parameters
are included).</p>
</td></tr>
<tr><td><code id="mob_control_+3A_dfsplit">dfsplit</code></td>
<td>
<p>logical or numeric. <code>as.integer(dfsplit)</code> is the degrees of freedom
per selected split employed when computing information criteria etc.</p>
</td></tr>
<tr><td><code id="mob_control_+3A_prune">prune</code></td>
<td>
<p>character, numeric, or function for specifying post-pruning rule.
If <code>prune</code> is <code>NULL</code> (the default), no post-pruning is performed.
For likelihood-based <code>mob()</code> trees, <code>prune</code> can be set to
<code>"AIC"</code> or <code>"BIC"</code> for post-pruning based on the corresponding
information criteria. More general rules (also in scenarios that are
not likelihood-based), can be specified by function arguments to
<code>prune</code>, for details see below.</p>
</td></tr>
<tr><td><code id="mob_control_+3A_restart">restart</code></td>
<td>
<p>logical. When determining the optimal split point in a numerical
variable: Should model estimation be restarted with <code>NULL</code> starting
values for each split? The default is <code>TRUE</code>. If <code>FALSE</code>, then
the parameter estimates from the previous split point are used as starting
values for the next split point (because in practice the difference are
often not huge). (Note that in that case a <code>for</code> loop is used
instead of the <code>applyfun</code> for fitting models across sample splits.)</p>
</td></tr>
<tr><td><code id="mob_control_+3A_verbose">verbose</code></td>
<td>
<p>logical. Should information about the fitting process
of <code><a href="#topic+mob">mob</a></code> (such as test statistics, <code class="reqn">p</code> values, selected
splitting variables and split points) be printed to the screen?</p>
</td></tr>
<tr><td><code id="mob_control_+3A_caseweights">caseweights</code></td>
<td>
<p>logical. Should weights be interpreted as case weights?
If <code>TRUE</code>, the number of observations is <code>sum(weights)</code>,
otherwise it is <code>sum(weights &gt; 0)</code>.</p>
</td></tr>
<tr><td><code id="mob_control_+3A_ytype">ytype</code>, <code id="mob_control_+3A_xtype">xtype</code></td>
<td>
<p>character. Specification of how <code>mob</code> should
preprocess <code>y</code> and <code>x</code> variables. Possible choice are:
<code>"vector"</code> (for <code>y</code> only), i.e., only one variable;
<code>"matrix"</code>, i.e., the model matrix of all variables;
<code>"data.frame"</code>, i.e., a data frame of all variables.</p>
</td></tr>
<tr><td><code id="mob_control_+3A_terminal">terminal</code>, <code id="mob_control_+3A_inner">inner</code></td>
<td>
<p>character. Specification of which additional
information (<code>"estfun"</code>, <code>"object"</code>, or both) should be
stored in each node. If <code>NULL</code>, no additional information is
stored.</p>
</td></tr>
<tr><td><code id="mob_control_+3A_model">model</code></td>
<td>
<p>logical. Should the full model frame be stored in the
resulting object?</p>
</td></tr>
<tr><td><code id="mob_control_+3A_numsplit">numsplit</code></td>
<td>
<p>character indicating how splits for numeric variables
should be justified. Because any splitpoint in the interval between
the last observation from the left child segment and the first observation
from the right child segment leads to the same observed split, two
options are available in <code>mob_control</code>:
Either, the split is <code>"left"</code>-justified (the default for
backward compatibility) or <code>"center"</code>-justified using the
midpoint of the possible interval.</p>
</td></tr>
<tr><td><code id="mob_control_+3A_catsplit">catsplit</code></td>
<td>
<p>character indicating how (unordered) categorical variables
should be splitted. By default the best <code>"binary"</code> split is
searched (by minimizing the objective function). Alternatively,
if set to <code>"multiway"</code>, the node is simply splitted into all
levels of the categorical variable.</p>
</td></tr>
<tr><td><code id="mob_control_+3A_vcov">vcov</code></td>
<td>
<p>character indicating which type of covariance matrix
estimator should be employed in the parameter instability tests.
The default is the outer product of gradients (<code>"opg"</code>).
Alternatively, <code>vcov = "info"</code> employs the information matrix
and <code>vcov = "sandwich"</code> the sandwich matrix (both of which are
only sensible for maximum likelihood estimation).</p>
</td></tr>
<tr><td><code id="mob_control_+3A_ordinal">ordinal</code></td>
<td>
<p>character indicating which type of parameter instability
test should be employed for ordinal partitioning variables (i.e.,
ordered factors). This can be <code>"chisq"</code>, <code>"max"</code>, or <code>"L2"</code>.
If <code>"chisq"</code> then the variable is treated as unordered and a
chi-squared test is performed. If <code>"L2"</code>, then a maxLM-type
test as for numeric variables is carried out but correcting for ties.
This requires simulation of p-values via <code><a href="strucchange.html#topic+catL2BB">catL2BB</a></code>
and requires some computation time. For <code>"max"</code> a weighted
double maximum test is used that computes p-values via
<code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>.</p>
</td></tr>
<tr><td><code id="mob_control_+3A_nrep">nrep</code></td>
<td>
<p>numeric. Number of replications in the simulation of
p-values for the ordinal <code>"L2"</code> statistic (if used).</p>
</td></tr>
<tr><td><code id="mob_control_+3A_applyfun">applyfun</code></td>
<td>
<p>an optional <code><a href="base.html#topic+lapply">lapply</a></code>-style function with arguments
<code>function(X, FUN, ...)</code>. It is used for refitting the model across
potential sample splits. The default is to use the basic <code>lapply</code>
function unless the <code>cores</code> argument is specified (see below).</p>
</td></tr>
<tr><td><code id="mob_control_+3A_cores">cores</code></td>
<td>
<p>numeric. If set to an integer the <code>applyfun</code> is set to
<code><a href="parallel.html#topic+mclapply">mclapply</a></code> with the desired number of <code>cores</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+mob">mob</a></code> for more details and references.
</p>
<p>For post-pruning, <code>prune</code> can be set to a <code>function(objfun, df, nobs)</code>
which either returns <code>TRUE</code> to signal that a current node can be pruned
or <code>FALSE</code>. All supplied arguments are of length two: <code>objfun</code> is the sum of objective
function values in the current node and its child nodes, respectively.
<code>df</code> is the degrees of freedom in the current node and its child nodes,
respectively. <code>nobs</code> is vector with the number of observations in the
current node and the total number of observations in the dataset, respectively.  
</p>
<p>If the objective function employed in the <code>mob()</code> call is the negative
log-likelihood, then a suitable function is set up on the fly by comparing  
<code>(2 * objfun + penalty * df)</code> in the current and the daughter nodes.
The penalty can then be set via a numeric or character value for <code>prune</code>:
AIC is used if <code>prune = "AIC"</code> or <code>prune = 2</code> and
BIC if <code>prune = "BIC"</code> or <code>prune = log(n)</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>mob_control</code> containing the control parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mob">mob</a></code></p>

<hr>
<h2 id='model_frame_rpart'> Model Frame Method for rpart </h2><span id='topic+model_frame_rpart'></span>

<h3>Description</h3>

<p>A model.frame method for rpart objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_frame_rpart(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_frame_rpart_+3A_formula">formula</code></td>
<td>
<p> an object of class <code><a href="rpart.html#topic+rpart">rpart</a></code>.</p>
</td></tr>
<tr><td><code id="model_frame_rpart_+3A_...">...</code></td>
<td>
<p> additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code><a href="stats.html#topic+model.frame">model.frame</a></code> method for <code><a href="rpart.html#topic+rpart">rpart</a></code> objects.
Because it is no longer possible to overwrite existing methods,
the function name is a little different here.
</p>


<h3>Value</h3>

<p>A model frame.
</p>

<hr>
<h2 id='nodeapply'> Apply Functions Over Nodes </h2><span id='topic+nodeapply'></span><span id='topic+nodeapply.party'></span><span id='topic+nodeapply.partynode'></span>

<h3>Description</h3>

<p>Returns a list of values obtained by applying a function to
<code>party</code> or <code>partynode</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodeapply(obj, ids = 1, FUN = NULL, ...)
## S3 method for class 'partynode'
nodeapply(obj, ids = 1, FUN = NULL, ...)
## S3 method for class 'party'
nodeapply(obj, ids = 1, FUN = NULL, by_node = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nodeapply_+3A_obj">obj</code></td>
<td>
<p> an object of class <code><a href="#topic+partynode">partynode</a></code> 
or <code><a href="#topic+party">party</a></code>.</p>
</td></tr>
<tr><td><code id="nodeapply_+3A_ids">ids</code></td>
<td>
<p> integer vector of node identifiers to apply over.</p>
</td></tr>
<tr><td><code id="nodeapply_+3A_fun">FUN</code></td>
<td>
<p> a function to be applied to nodes. By default, the 
node itself is returned.</p>
</td></tr>
<tr><td><code id="nodeapply_+3A_by_node">by_node</code></td>
<td>
<p> a logical indicating if <code>FUN</code> is applied
to subsets of <code><a href="#topic+party">party</a></code> objects or 
<code><a href="#topic+partynode">partynode</a></code> objects (default). </p>
</td></tr>
<tr><td><code id="nodeapply_+3A_...">...</code></td>
<td>
<p> additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>FUN</code> is applied to all nodes with node identifiers in
<code>ids</code> for a <code>partynode</code> object.
The method for <code>party</code> by default calls the <code>nodeapply</code>
method on it's <code>node</code> slot. If <code>by_node</code> is <code>FALSE</code>,
it is applied to a <code>party</code> object with root node <code>ids</code>.
</p>


<h3>Value</h3>

<p>A list of results of length <code>length(ids)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    ## a tree as flat list structure
    nodelist &lt;- list(
        # root node
        list(id = 1L, split = partysplit(varid = 4L, breaks = 1.9),
            kids = 2:3),
        # V4 &lt;= 1.9, terminal node
        list(id = 2L, info = "terminal A"),
        # V4 &gt; 1.9
        list(id = 3L, split = partysplit(varid = 5L, breaks = 1.7),
            kids = c(4L, 7L)),
        # V5 &lt;= 1.7
        list(id = 4L, split = partysplit(varid = 4L, breaks = 4.8),
            kids = 5:6),
        # V4 &lt;= 4.8, terminal node
        list(id = 5L, info = "terminal B"),
        # V4 &gt; 4.8, terminal node
        list(id = 6L, info = "terminal C"),
        # V5 &gt; 1.7, terminal node
        list(id = 7L, info = "terminal D")
    )

    ## convert to a recursive structure
    node &lt;- as.partynode(nodelist)

    ## return root node 
    nodeapply(node)

    ## return info slots of terminal nodes
    nodeapply(node, ids = nodeids(node, terminal = TRUE), 
        FUN = function(x) info_node(x))

    ## fit tree using rpart
    library("rpart")
    rp &lt;- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)

    ## coerce to `constparty'
    rpk &lt;- as.party(rp)

    ## extract nodeids
    nodeids(rpk)
    unlist(nodeapply(node_party(rpk), ids = nodeids(rpk), 
        FUN = id_node))
    unlist(nodeapply(rpk, ids = nodeids(rpk), FUN = id_node))

    ## but root nodes of party objects always have id = 1
    unlist(nodeapply(rpk, ids = nodeids(rpk), FUN = function(x) 
        id_node(node_party(x)), by_node = FALSE))
</code></pre>

<hr>
<h2 id='nodeids'> Extract Node Identifiers </h2><span id='topic+nodeids'></span><span id='topic+nodeids.party'></span><span id='topic+nodeids.partynode'></span><span id='topic+get_paths'></span>

<h3>Description</h3>

<p>Extract unique identifiers from inner and terminals
nodes of a <code>partynode</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodeids(obj, ...)
## S3 method for class 'partynode'
nodeids(obj, from = NULL, terminal = FALSE, ...)
## S3 method for class 'party'
nodeids(obj, from = NULL, terminal = FALSE, ...)
get_paths(obj, i)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nodeids_+3A_obj">obj</code></td>
<td>
<p> an object of class <code><a href="#topic+partynode">partynode</a></code> 
or <code><a href="#topic+party">party</a></code>.</p>
</td></tr>
<tr><td><code id="nodeids_+3A_from">from</code></td>
<td>
<p> an integer specifying node to start from.</p>
</td></tr>
<tr><td><code id="nodeids_+3A_terminal">terminal</code></td>
<td>
<p> logical specifying if only node identifiers 
of terminal nodes are returned. </p>
</td></tr>
<tr><td><code id="nodeids_+3A_i">i</code></td>
<td>
<p>a vector of node identifiers.</p>
</td></tr>
<tr><td><code id="nodeids_+3A_...">...</code></td>
<td>
<p> additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The identifiers of each node are extracted from <code>nodeids</code>.
<code>get_paths</code> returns the paths for extracting the corresponding
nodes using list subsets.
</p>


<h3>Value</h3>

<p>A vector of node identifiers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## a tree as flat list structure
  nodelist &lt;- list(
      # root node
      list(id = 1L, split = partysplit(varid = 4L, breaks = 1.9),
          kids = 2:3),
      # V4 &lt;= 1.9, terminal node
      list(id = 2L),
      # V4 &gt; 1.9
      list(id = 3L, split = partysplit(varid = 1L, breaks = 1.7),
          kids = c(4L, 7L)),
      # V1 &lt;= 1.7
      list(id = 4L, split = partysplit(varid = 4L, breaks = 4.8),
          kids = 5:6),
      # V4 &lt;= 4.8, terminal node
      list(id = 5L),
      # V4 &gt; 4.8, terminal node
      list(id = 6L),
      # V1 &gt; 1.7, terminal node
      list(id = 7L)
  )

  ## convert to a recursive structure
  node &lt;- as.partynode(nodelist)

  ## set up party object
  data("iris")
  tree &lt;- party(node, data = iris, 
      fitted = data.frame("(fitted)" = 
                          fitted_node(node, data = iris),
                          check.names = FALSE))
  tree
  
  ### ids of all nodes
  nodeids(tree)

  ### ids of all terminal nodes
  nodeids(tree, terminal = TRUE)

  ### ids of terminal nodes in subtree with root [3]
  nodeids(tree, from = 3, terminal = TRUE)

  ### get paths and extract all terminal nodes
  tr &lt;- unclass(node_party(tree))
  lapply(get_paths(tree, nodeids(tree, terminal = TRUE)), 
         function(path) tr[path])

</code></pre>

<hr>
<h2 id='panelfunctions'> Panel-Generators for Visualization of Party Trees </h2><span id='topic+panelfunctions'></span><span id='topic+node_inner'></span><span id='topic+node_terminal'></span><span id='topic+edge_simple'></span><span id='topic+node_barplot'></span><span id='topic+node_bivplot'></span><span id='topic+node_boxplot'></span><span id='topic+node_surv'></span><span id='topic+node_ecdf'></span><span id='topic+node_mvar'></span>

<h3>Description</h3>

<p>The plot method for <code>party</code> and <code>constparty</code> objects are rather
flexible and can be extended by panel functions. Some pre-defined
panel-generating functions of class <code>grapcon_generator</code>
for the most important cases are documented here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_inner(obj, id = TRUE, pval = TRUE, abbreviate = FALSE, fill = "white", 
  gp = gpar())

node_terminal(obj, digits = 3, abbreviate = FALSE,
  fill = c("lightgray", "white"), id = TRUE,
  just = c("center", "top"), top = 0.85,
  align = c("center", "left", "right"), gp = NULL, FUN = NULL,
  height = NULL, width = NULL)

edge_simple(obj, digits = 3, abbreviate = FALSE, justmin = Inf,
  just = c("alternate", "increasing", "decreasing", "equal"),
  fill = "white")

node_boxplot(obj, col = "black", fill = "lightgray", bg = "white", width = 0.5,
  yscale = NULL, ylines = 3, cex = 0.5, id = TRUE, mainlab = NULL, gp = gpar())

node_barplot(obj, col = "black", fill = NULL, bg = "white",
  beside = NULL, ymax = NULL, ylines = NULL, widths = 1, gap = NULL,
  reverse = NULL, rot = 0, just = c("center", "top"), id = TRUE,
  mainlab = NULL, text = c("none", "horizontal", "vertical"), gp = gpar())

node_surv(obj, col = "black", bg = "white", yscale = c(0, 1), ylines = 2,
  id = TRUE, mainlab = NULL, gp = gpar(), ...)

node_ecdf(obj, col = "black", bg = "white", ylines = 2,
  id = TRUE, mainlab = NULL, gp = gpar(), ...)

node_bivplot(mobobj, which = NULL, id = TRUE, pop = TRUE,
  pointcol = "black", pointcex = 0.5,
  boxcol = "black", boxwidth = 0.5, boxfill = "lightgray",
  bg = "white", fitmean = TRUE, linecol = "red",
  cdplot = FALSE, fivenum = TRUE, breaks = NULL,
  ylines = NULL, xlab = FALSE, ylab = FALSE, margins = rep(1.5, 4),
  mainlab = NULL, ...)

node_mvar(obj, which = NULL, id = TRUE, pop = TRUE, ylines = NULL,
  mainlab = NULL, varlab = TRUE, bg = "white", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panelfunctions_+3A_obj">obj</code></td>
<td>
<p> an object of class <code>party</code>.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_digits">digits</code></td>
<td>
<p> integer, used for formating numbers. </p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_abbreviate">abbreviate</code></td>
<td>
<p> logical indicating whether strings should be 
abbreviated. </p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_col">col</code>, <code id="panelfunctions_+3A_pointcol">pointcol</code>, <code id="panelfunctions_+3A_boxcol">boxcol</code>, <code id="panelfunctions_+3A_linecol">linecol</code></td>
<td>
<p> a color for points and lines. </p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_fill">fill</code>, <code id="panelfunctions_+3A_boxfill">boxfill</code>, <code id="panelfunctions_+3A_bg">bg</code></td>
<td>
<p> a color to filling rectangles and backgrounds. </p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_id">id</code></td>
<td>
<p> logical. Should node IDs be plotted?</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_pval">pval</code></td>
<td>
<p> logical. Should node p values be plotted (if they are
available)?</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_just">just</code></td>
<td>
<p>justification of terminal panel viewport (<code>node_terminal</code>),
or labels (<code>edge_simple</code>, <code>node_barplot</code>).</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_justmin">justmin</code></td>
<td>
<p>minimum average edge label length to employ justification
via <code>just</code> in <code>edge_panel</code>, otherwise <code>just = "equal"</code>
is used. Thus, by default <code>"equal"</code> justification is always used
but other justifications could be employed for finite <code>justmin</code>.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_top">top</code></td>
<td>
<p>in case of top justification, the npc coordinate at which the
viewport is justified.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_align">align</code></td>
<td>
<p>alignment of text within terminal panel viewport.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_ylines">ylines</code></td>
<td>
<p> number of lines for spaces in y-direction. </p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_widths">widths</code></td>
<td>
<p> widths in barplots. </p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_boxwidth">boxwidth</code></td>
<td>
<p> width in boxplots (called <code>width</code> in <code>node_boxplot</code>). </p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_gap">gap</code></td>
<td>
<p> gap between bars in a barplot (<code>node_barplot</code>). </p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_yscale">yscale</code></td>
<td>
<p> limits in y-direction</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_ymax">ymax</code></td>
<td>
<p> upper limit in y-direction</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_cex">cex</code>, <code id="panelfunctions_+3A_pointcex">pointcex</code></td>
<td>
<p>character extension of points in scatter plots.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_beside">beside</code></td>
<td>
<p> logical indicating if barplots should be side by side or stacked. </p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_reverse">reverse</code></td>
<td>
<p>logical indicating whether the order of levels should be reversed
for barplots. </p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_rot">rot</code></td>
<td>
<p> arguments passed to <code><a href="grid.html#topic+grid.text">grid.text</a></code> for the
x-axis labeling. </p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_gp">gp</code></td>
<td>
<p>graphical parameters.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_fun">FUN</code></td>
<td>
<p>function for formatting the <code>info</code>, passed to <code><a href="#topic+formatinfo_node">formatinfo_node</a></code>.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_height">height</code>, <code id="panelfunctions_+3A_width">width</code></td>
<td>
<p> numeric, number of lines/columns for printing text. </p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_mobobj">mobobj</code></td>
<td>
<p>an object of class <code>modelparty</code> as computed by <code><a href="#topic+mob">mob</a></code>.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_which">which</code></td>
<td>
<p>numeric or character. Optional selection of subset of regressor
variables. By default one panel for each regressor variable is drawn.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_pop">pop</code></td>
<td>
<p>logical. Should the viewports in the individual nodes be popped after
drawing?</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_fitmean">fitmean</code></td>
<td>
<p>logical. Should the fitted mean function be visualized?</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_cdplot">cdplot</code></td>
<td>
<p>logical. Should a CD plot (or a spineplot) be drawn when
the response variable is categorical?</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_fivenum">fivenum</code></td>
<td>
<p>logical. Should the five-number summary be used for splitting
the x-axis in spineplots?</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_breaks">breaks</code></td>
<td>
<p>numeric. Optional numeric vector with breaks for the x-axis in
splineplots.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_xlab">xlab</code>, <code id="panelfunctions_+3A_ylab">ylab</code></td>
<td>
<p>character. Optional annotation for x-axis and y-axis.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_margins">margins</code></td>
<td>
<p>numeric. Margins around drawing area in viewport.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_mainlab">mainlab</code></td>
<td>
<p>character or function. An optional title for the plot. Either
a character or a <code>function(id, nobs)</code>.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_varlab">varlab</code></td>
<td>
<p>logical. Should the individual variable labels be attached to
the <code>mainlab</code> for multivariate responses?</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_text">text</code></td>
<td>
<p>logical or character. Should percentage labels be drawn
for each bar? The default is <code>"none"</code> or equivalently <code>FALSE</code>.
Can be set to <code>TRUE</code> (or <code>"horizontal"</code>) or alternatively
<code>"vertical"</code>.</p>
</td></tr>
<tr><td><code id="panelfunctions_+3A_...">...</code></td>
<td>
<p> additional arguments passed to callies 
(for example to <code><a href="survival.html#topic+survfit">survfit</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot</code> methods for <code>party</code> and <code>constparty</code> objects provide an
extensible framework for the visualization of binary regression trees. The
user is allowed to specify panel functions for plotting terminal and inner
nodes as well as the corresponding edges. The panel functions to be used
should depend only on the node being visualized, however, for setting up
an appropriate panel function, information from the whole tree is typically
required. Hence, <span class="pkg">party</span> adopts the framework of <code>grapcon_generator</code>
(graphical appearance control) from the <span class="pkg">vcd</span> package (Meyer, Zeileis and
Hornik, 2005) and provides several panel-generating functions. For convenience,
the panel-generating functions <code>node_inner</code> and <code>edge_simple</code> 
return panel functions to draw inner nodes and left and right edges. 
For drawing terminal nodes, the functions returned by the other panel 
functions can be used. The panel generating function <code>node_terminal</code> 
is a terse text-based representation of terminal nodes.
</p>
<p>Graphical representations of terminal nodes are available and depend on
the kind of model and the measurement scale of the variables modeled.
</p>
<p>For univariate regressions (typically fitted by ),
<code>node_surv</code>
returns a functions that plots Kaplan-Meier curves in each 
terminal node; <code>node_barplot</code>, <code>node_boxplot</code>, <code>node_hist</code>, <code>node_ecdf</code> and
<code>node_density</code> can be used to plot bar plots, box plots, histograms, 
empirical cumulative distribution functions and 
estimated densities into the terminal nodes.
</p>
<p>For multivariate regressions (typically fitted by <code>mob</code>),
<code>node_bivplot</code> returns a panel function that creates bivariate plots
of the response against all regressors in the model. Depending on the scale
of the variables involved, scatter plots, box plots, spinograms (or CD plots)
and spine plots are created. For the latter two <code><a href="vcd.html#topic+spine">spine</a></code> and
<code><a href="vcd.html#topic+cd_plot">cd_plot</a></code> from the <span class="pkg">vcd</span> package are re-used.
</p>
<p>For multivariate responses in <code><a href="#topic+ctree">ctree</a></code>, the panel function <code>node_mvar</code>
generates one plot for each response.
</p>


<h3>References</h3>

<p>Meyer D, Zeileis A, Hornik K (2006).
The Strucplot Framework: Visualizing Multi-Way Contingency Tables with vcd.
<em>Journal of Statistical Software</em>, <b>17</b>(3), 1&ndash;48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a>
</p>

<hr>
<h2 id='party'> Recursive Partytioning </h2><span id='topic+party'></span><span id='topic+names.party'></span><span id='topic+names+3C-.party'></span><span id='topic+node_party'></span><span id='topic+is.constparty'></span><span id='topic+is.simpleparty'></span><span id='topic+data_party'></span><span id='topic+data_party.default'></span>

<h3>Description</h3>

<p>A class for representing decision trees and corresponding
accessor functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>party(node, data, fitted = NULL, terms = NULL, names = NULL, 
    info = NULL)
## S3 method for class 'party'
names(x)
## S3 replacement method for class 'party'
names(x) &lt;- value
data_party(party, id = 1L)
## Default S3 method:
data_party(party, id = 1L)
node_party(party)
is.constparty(party)
is.simpleparty(party)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="party_+3A_node">node</code></td>
<td>
<p> an object of class <code><a href="#topic+partynode">partynode</a></code>.</p>
</td></tr>
<tr><td><code id="party_+3A_data">data</code></td>
<td>
<p> a (potentially empty) <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="party_+3A_fitted">fitted</code></td>
<td>
<p> an optional <code><a href="base.html#topic+data.frame">data.frame</a></code> with <code>nrow(data)</code> 
rows (only if <code>nrow(data) != 0</code> and 
containing at least the fitted terminal node identifiers
as element <code>(fitted)</code>. In addition, weights
may be contained as element <code>(weights)</code> and 
responses as <code>(response)</code>.</p>
</td></tr>
<tr><td><code id="party_+3A_terms">terms</code></td>
<td>
<p> an optional <code><a href="stats.html#topic+terms">terms</a></code> object.  </p>
</td></tr>
<tr><td><code id="party_+3A_names">names</code></td>
<td>
<p> an optional vector of names to be assigned to each node of <code>node</code>. </p>
</td></tr>
<tr><td><code id="party_+3A_info">info</code></td>
<td>
<p> additional information. </p>
</td></tr>
<tr><td><code id="party_+3A_x">x</code></td>
<td>
<p> an object of class <code>party</code>.</p>
</td></tr>
<tr><td><code id="party_+3A_party">party</code></td>
<td>
<p> an object of class <code>party</code>.</p>
</td></tr>
<tr><td><code id="party_+3A_value">value</code></td>
<td>
<p>a character vector of up to the same length as <code>x</code>, or
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="party_+3A_id">id</code></td>
<td>
<p> a node identifier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>party</code> basically consist of a <code><a href="#topic+partynode">partynode</a></code>
object representing the tree structure in a recursive way and 
data. The <code>data</code> argument takes a <code>data.frame</code> which, however,
might have zero columns. Optionally, a <code>data.frame</code> with at least one
variable <code>(fitted)</code> containing the terminal node numbers of 
data used for fitting the tree may be specified along with a
<code><a href="stats.html#topic+terms">terms</a></code> object or any additional (currently unstructured)
information as <code>info</code>. Argument <code>names</code> defines names
for all nodes in <code>node</code>.
</p>
<p>Method <code>names</code> can be used to extract or alter names for nodes.
Function <code>node_party</code> returns the <code>node</code> element of a
<code>party</code> object. Further methods for <code>party</code> objects
are documented in <code><a href="#topic+party-methods">party-methods</a></code> and 
<code><a href="#topic+party-predict">party-predict</a></code>. Trees of various flavors can be coerced
to <code>party</code>, see <code><a href="#topic+party-coercion">party-coercion</a></code>.
</p>
<p>Two classes inherit from class <code>party</code> and impose additional
assumptions on the structure of this object:
Class <code>constparty</code> requires that the <code>fitted</code> slot
contains a partitioning of the learning sample as a factor <code>("fitted")</code>
and the response values of all observations in the learning sample
as <code>("response")</code>. This structure is most flexible and 
allows for graphical display of the response values in terminal
nodes as well as for computing predictions based on 
arbitrary summary statistics.
</p>
<p>Class <code>simpleparty</code> assumes that certain pre-computed information
about the distribution of the response variable is contained
in the <code>info</code> slot nodes. At the moment, no formal
class is used to describe this information.
</p>


<h3>Value</h3>

<p>The constructor returns an object of class <code>party</code>:
</p>
<table role = "presentation">
<tr><td><code>node</code></td>
<td>
<p> an object of class <code><a href="#topic+partynode">partynode</a></code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p> a (potentially empty) <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> an optional <code><a href="base.html#topic+data.frame">data.frame</a></code> with <code>nrow(data)</code> 
rows (only if <code>nrow(data) != 0</code> and 
containing at least the fitted terminal node identifiers
as element <code>(fitted)</code>. In addition, weights
may be contained as element <code>(weights)</code> and 
responses as <code>(response)</code>.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p> an optional <code><a href="stats.html#topic+terms">terms</a></code> object.  </p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p> an optional vector of names to be assigned to each node of <code>node</code>. </p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p> additional information. </p>
</td></tr>
</table>
<p><code>names</code> can be used to set and retrieve names of nodes and 
<code>node_party</code> returns an object of class <code><a href="#topic+partynode">partynode</a></code>.
<code>data_party</code> returns a data frame with observations contained in node
<code>id</code>.
</p>


<h3>References</h3>

 
<p>Hothorn T, Zeileis A (2015).
partykit: A Modular Toolkit for Recursive Partytioning in R.
<em>Journal of Machine Learning Research</em>, <b>16</b>, 3905&ndash;3909.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### data ###
## artificial WeatherPlay data
data("WeatherPlay", package = "partykit")
str(WeatherPlay)


### splits ###
## split in overcast, humidity, and windy
sp_o &lt;- partysplit(1L, index = 1:3)
sp_h &lt;- partysplit(3L, breaks = 75)
sp_w &lt;- partysplit(4L, index = 1:2)

## query labels
character_split(sp_o)


### nodes ###
## set up partynode structure
pn &lt;- partynode(1L, split = sp_o, kids = list(
  partynode(2L, split = sp_h, kids = list(
    partynode(3L, info = "yes"),
    partynode(4L, info = "no"))),
  partynode(5L, info = "yes"),
  partynode(6L, split = sp_w, kids = list(
    partynode(7L, info = "yes"),
    partynode(8L, info = "no")))))
pn


### tree ###
## party: associate recursive partynode structure with data
py &lt;- party(pn, WeatherPlay)
py
plot(py)


### variations ###
## tree stump
n1 &lt;- partynode(id = 1L, split = sp_o, kids = lapply(2L:4L, partynode))
print(n1, data = WeatherPlay)

## query fitted nodes and kids ids
fitted_node(n1, data = WeatherPlay)
kidids_node(n1, data = WeatherPlay)

## tree with full data sets
t1 &lt;- party(n1, data = WeatherPlay)

## tree with empty data set
party(n1, data = WeatherPlay[0, ])

## constant-fit tree
t2 &lt;- party(n1, 
  data = WeatherPlay,
  fitted = data.frame(
    "(fitted)" = fitted_node(n1, data = WeatherPlay),
    "(response)" = WeatherPlay$play,
    check.names = FALSE),
  terms = terms(play ~ ., data = WeatherPlay),
)
t2 &lt;- as.constparty(t2)
t2
plot(t2)
</code></pre>

<hr>
<h2 id='party-coercion'>Coercion Functions</h2><span id='topic+party-coercion'></span><span id='topic+as.party'></span><span id='topic+as.party.rpart'></span><span id='topic+as.party.Weka_tree'></span><span id='topic+as.party.XMLNode'></span><span id='topic+as.constparty'></span><span id='topic+as.simpleparty'></span><span id='topic+as.simpleparty.party'></span><span id='topic+as.simpleparty.simpleparty'></span><span id='topic+as.simpleparty.XMLNode'></span><span id='topic+as.simpleparty.constparty'></span><span id='topic+pmmlTreeModel'></span>

<h3>Description</h3>

<p>Functions coercing various objects to objects of class party.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.party(obj, ...)
## S3 method for class 'rpart'
as.party(obj, data = TRUE, ...)
## S3 method for class 'Weka_tree'
as.party(obj, data = TRUE, ...)
## S3 method for class 'XMLNode'
as.party(obj, ...)
pmmlTreeModel(file, ...)
as.constparty(obj, ...)
as.simpleparty(obj, ...)
## S3 method for class 'party'
as.simpleparty(obj, ...)
## S3 method for class 'simpleparty'
as.simpleparty(obj, ...)
## S3 method for class 'constparty'
as.simpleparty(obj, ...)
## S3 method for class 'XMLNode'
as.simpleparty(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="party-coercion_+3A_obj">obj</code></td>
<td>
<p> an object of class <code><a href="rpart.html#topic+rpart">rpart</a></code>,
<code><a href="RWeka.html#topic+Weka_classifier_trees">Weka_tree</a></code>, <code>XMLnode</code> or
objects inheriting from <code>party</code>.</p>
</td></tr>
<tr><td><code id="party-coercion_+3A_data">data</code></td>
<td>
<p>logical. Should the model frame associated with the fitted
<code>obj</code> be included in the <code>data</code> of the <code>party</code>?</p>
</td></tr>
<tr><td><code id="party-coercion_+3A_file">file</code></td>
<td>
<p> a file name of a XML file 
containing a PMML description of a tree.</p>
</td></tr>
<tr><td><code id="party-coercion_+3A_...">...</code></td>
<td>
<p> additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trees fitted using functions <code><a href="rpart.html#topic+rpart">rpart</a></code> or 
<code><a href="RWeka.html#topic+Weka_classifier_trees">J48</a></code> are coerced to <code><a href="#topic+party">party</a></code>
objects. By default, objects of class <code>constparty</code>
are returned.
</p>
<p>When information about the learning sample is available, 
<code><a href="#topic+party">party</a></code> objects can be coerced to objects of 
class <code>constparty</code> or <code>simpleparty</code> 
(see <code><a href="#topic+party">party</a></code> for details).
</p>


<h3>Value</h3>

<p>All methods return objects of class <code><a href="#topic+party">party</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## fit tree using rpart
library("rpart")
rp &lt;- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis)

## coerce to `constparty'
as.party(rp)
</code></pre>

<hr>
<h2 id='party-methods'> Methods for Party Objects </h2><span id='topic+party-methods'></span><span id='topic+length.party'></span><span id='topic+print.party'></span><span id='topic+print.simpleparty'></span><span id='topic+print.constparty'></span><span id='topic++5B.party'></span><span id='topic++5B+5B.party'></span><span id='topic+depth.party'></span><span id='topic+width.party'></span><span id='topic+getCall.party'></span><span id='topic+nodeprune'></span><span id='topic+nodeprune.party'></span>

<h3>Description</h3>

<p>Methods for computing on <code>party</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'party'
print(x, 
    terminal_panel = function(node)
      formatinfo_node(node, default = "*", prefix = ": "),
    tp_args = list(),
    inner_panel = function(node) "", ip_args = list(),
    header_panel = function(party) "",
    footer_panel = function(party) "",
    digits = getOption("digits") - 2, ...)
## S3 method for class 'simpleparty'
print(x, digits = getOption("digits") - 4,
    header = NULL, footer = TRUE, ...)
## S3 method for class 'constparty'
print(x, FUN = NULL, digits = getOption("digits") - 4,
    header = NULL, footer = TRUE, ...)
## S3 method for class 'party'
length(x)
## S3 method for class 'party'
x[i, ...]
## S3 method for class 'party'
x[[i, ...]]
## S3 method for class 'party'
depth(x, root = FALSE, ...)
## S3 method for class 'party'
width(x, ...)
## S3 method for class 'party'
nodeprune(x, ids, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="party-methods_+3A_x">x</code></td>
<td>
<p> an object of class <code><a href="#topic+party">party</a></code>.</p>
</td></tr>
<tr><td><code id="party-methods_+3A_i">i</code></td>
<td>
<p> an integer specifying the root of the subtree to extract.</p>
</td></tr>
<tr><td><code id="party-methods_+3A_terminal_panel">terminal_panel</code></td>
<td>
<p> a panel function for printing terminal nodes.</p>
</td></tr>
<tr><td><code id="party-methods_+3A_tp_args">tp_args</code></td>
<td>
<p> a list containing arguments to <code>terminal_panel</code>.</p>
</td></tr>
<tr><td><code id="party-methods_+3A_inner_panel">inner_panel</code></td>
<td>
<p> a panel function for printing inner nodes.</p>
</td></tr>
<tr><td><code id="party-methods_+3A_ip_args">ip_args</code></td>
<td>
<p> a list containing arguments to <code>inner_panel</code>.</p>
</td></tr>
<tr><td><code id="party-methods_+3A_header_panel">header_panel</code></td>
<td>
<p> a panel function for printing the header.</p>
</td></tr>
<tr><td><code id="party-methods_+3A_footer_panel">footer_panel</code></td>
<td>
<p> a panel function for printing the footer.</p>
</td></tr>
<tr><td><code id="party-methods_+3A_digits">digits</code></td>
<td>
<p> number of digits to be printed.</p>
</td></tr>
<tr><td><code id="party-methods_+3A_header">header</code></td>
<td>
<p> header to be printed.</p>
</td></tr>
<tr><td><code id="party-methods_+3A_footer">footer</code></td>
<td>
<p> footer to be printed.</p>
</td></tr>
<tr><td><code id="party-methods_+3A_fun">FUN</code></td>
<td>
<p> a function to be applied to nodes.</p>
</td></tr>
<tr><td><code id="party-methods_+3A_root">root</code></td>
<td>
<p> a logical. Should the root count be counted in <code>depth</code>? </p>
</td></tr>
<tr><td><code id="party-methods_+3A_ids">ids</code></td>
<td>
<p> a vector of node ids (or their names) to be pruned-off.</p>
</td></tr>
<tr><td><code id="party-methods_+3A_...">...</code></td>
<td>
<p> additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>length</code> gives the number of nodes in the tree (in contrast
to the <code>length</code> method for <code><a href="#topic+partynode">partynode</a></code> objects which
returns the number of kid nodes in the root),
<code>depth</code> the depth of the tree and <code>width</code> 
the number of terminal nodes. The subset methods extract subtrees
and the <code>print</code> method generates a textual representation
of the tree. <code>nodeprune</code> prunes-off nodes and makes sure that
the node ids of the resulting tree are in pre-order starting with root node id 1.
For <code>constparty</code> objects, the <code>fitted</code> slot is also changed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    ## a tree as flat list structure
    nodelist &lt;- list(
        # root node
        list(id = 1L, split = partysplit(varid = 4L, breaks = 1.9), 
            kids = 2:3),
        # V4 &lt;= 1.9, terminal node
        list(id = 2L),
        # V4 &gt; 1.9
        list(id = 3L, split = partysplit(varid = 5L, breaks = 1.7), 
            kids = c(4L, 7L)),
        # V5 &lt;= 1.7
        list(id = 4L, split = partysplit(varid = 4L, breaks = 4.8), 
            kids = 5:6),
        # V4 &lt;= 4.8, terminal node
        list(id = 5L),
        # V4 &gt; 4.8, terminal node
        list(id = 6L),
        # V5 &gt; 1.7, terminal node
        list(id = 7L)
    )

    ## convert to a recursive structure
    node &lt;- as.partynode(nodelist)

    ## set up party object
    data("iris")
    tree &lt;- party(node, data = iris, 
        fitted = data.frame("(fitted)" = 
            fitted_node(node, data = iris),
            check.names = FALSE))
    names(tree) &lt;- paste("Node", nodeids(tree), sep = " ")

    ## number of kids in root node
    length(tree)

    ## depth of tree
    depth(tree)

    ## number of terminal nodes
    width(tree)

    ## node number four
    tree["Node 4"]
    tree[["Node 4"]]

</code></pre>

<hr>
<h2 id='party-plot'> Visualization of Trees </h2><span id='topic+party-plot'></span><span id='topic+plot.party'></span><span id='topic+plot.constparty'></span><span id='topic+plot.simpleparty'></span>

<h3>Description</h3>

<p><code>plot</code> method for <code>party</code> objects with
extended facilities for plugging in panel functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'party'
plot(x, main = NULL,
    terminal_panel = node_terminal, tp_args = list(),
    inner_panel = node_inner, ip_args = list(),
    edge_panel = edge_simple, ep_args = list(),
    drop_terminal = FALSE, tnex = 1,
    newpage = TRUE, pop = TRUE, gp = gpar(),
    margins = NULL, ...)
## S3 method for class 'constparty'
plot(x, main = NULL,
    terminal_panel = NULL, tp_args = list(),
    inner_panel = node_inner, ip_args = list(),
    edge_panel = edge_simple, ep_args = list(),
    type = c("extended", "simple"), drop_terminal = NULL, 
    tnex = NULL, newpage = TRUE, pop = TRUE, gp = gpar(), 
    ...)
## S3 method for class 'simpleparty'
plot(x, digits = getOption("digits") - 4, tp_args = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="party-plot_+3A_x">x</code></td>
<td>
<p> an object of class <code>party</code> or <code>constparty</code>.</p>
</td></tr>
<tr><td><code id="party-plot_+3A_main">main</code></td>
<td>
<p> an optional title for the plot.</p>
</td></tr>
<tr><td><code id="party-plot_+3A_type">type</code></td>
<td>
<p> a character specifying the complexity of the plot:
<code>extended</code> tries to visualize the distribution of the
response variable in each terminal node whereas <code>simple</code> 
only gives some summary information.</p>
</td></tr>
<tr><td><code id="party-plot_+3A_terminal_panel">terminal_panel</code></td>
<td>
<p> an optional panel function of the form 
<code>function(node)</code> plotting the terminal nodes.
Alternatively, a panel generating function of class
<code>"grapcon_generator"</code> that is called with arguments
<code>x</code> and <code>tp_args</code> to set up a panel function.
By default, an appropriate panel function is chosen 
depending on the scale of the dependent variable.</p>
</td></tr>
<tr><td><code id="party-plot_+3A_tp_args">tp_args</code></td>
<td>
<p> a list of arguments passed to <code>terminal_panel</code> if this
is a <code>"grapcon_generator"</code> object.</p>
</td></tr>
<tr><td><code id="party-plot_+3A_inner_panel">inner_panel</code></td>
<td>
<p> an optional panel function of the form 
<code>function(node)</code> plotting the inner nodes.
Alternatively, a panel generating function of class
<code>"grapcon_generator"</code> that is called with arguments
<code>x</code> and <code>ip_args</code> to set up a panel function.</p>
</td></tr>
<tr><td><code id="party-plot_+3A_ip_args">ip_args</code></td>
<td>
<p> a list of arguments passed to <code>inner_panel</code> if this
is a <code>"grapcon_generator"</code> object.</p>
</td></tr>
<tr><td><code id="party-plot_+3A_edge_panel">edge_panel</code></td>
<td>
<p> an optional panel function of the form 
<code>function(split, ordered = FALSE, left = TRUE)</code>
plotting the edges.
Alternatively, a panel generating function of class
<code>"grapcon_generator"</code> that is called with arguments
<code>x</code> and <code>ip_args</code> to set up a panel function.</p>
</td></tr>		       
<tr><td><code id="party-plot_+3A_ep_args">ep_args</code></td>
<td>
<p> a list of arguments passed to <code>edge_panel</code> if this
is a <code>"grapcon_generator"</code> object.</p>
</td></tr>
<tr><td><code id="party-plot_+3A_drop_terminal">drop_terminal</code></td>
<td>
<p> a logical indicating whether all terminal nodes
should be plotted at the bottom.</p>
</td></tr>
<tr><td><code id="party-plot_+3A_tnex">tnex</code></td>
<td>
<p>a numeric value giving the terminal node extension in relation
to the inner nodes.</p>
</td></tr>
<tr><td><code id="party-plot_+3A_newpage">newpage</code></td>
<td>
<p> a logical indicating whether <code>grid.newpage()</code> should be called. </p>
</td></tr>
<tr><td><code id="party-plot_+3A_pop">pop</code></td>
<td>
<p> a logical whether the viewport tree should be popped before
return. </p>
</td></tr>
<tr><td><code id="party-plot_+3A_gp">gp</code></td>
<td>
<p>graphical parameters.</p>
</td></tr>
<tr><td><code id="party-plot_+3A_margins">margins</code></td>
<td>
<p>numeric vector of margin sizes.</p>
</td></tr>
<tr><td><code id="party-plot_+3A_digits">digits</code></td>
<td>
<p>number of digits to be printed.</p>
</td></tr>
<tr><td><code id="party-plot_+3A_...">...</code></td>
<td>
<p> additional arguments passed to callies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This <code>plot</code> method for <code>party</code> objects provides an
extensible framework for the visualization of binary regression trees. The
user is allowed to specify panel functions for plotting terminal and inner
nodes as well as the corresponding edges. Panel functions for plotting
inner nodes, edges and terminal nodes are available for the most important
cases and can serve as the basis for user-supplied extensions, see
<code><a href="#topic+node_inner">node_inner</a></code>.
</p>
<p>More details on the ideas and concepts of panel-generating functions and
<code>"grapcon_generator"</code> objects in general can be found in Meyer, Zeileis
and Hornik (2005).
</p>


<h3>References</h3>

<p>Meyer D, Zeileis A, Hornik K (2006).
The Strucplot Framework: Visualizing Multi-Way Contingency Tables with vcd.
<em>Journal of Statistical Software</em>, <b>17</b>(3), 1&ndash;48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+node_inner">node_inner</a></code>, <code><a href="#topic+node_terminal">node_terminal</a></code>, <code><a href="#topic+edge_simple">edge_simple</a></code>, 
<code><a href="#topic+node_barplot">node_barplot</a></code>, <code><a href="#topic+node_boxplot">node_boxplot</a></code>.</p>

<hr>
<h2 id='party-predict'> Tree Predictions </h2><span id='topic+party-predict'></span><span id='topic+predict.party'></span><span id='topic+predict_party'></span><span id='topic+predict_party.default'></span><span id='topic+predict_party.constparty'></span><span id='topic+predict_party.simpleparty'></span>

<h3>Description</h3>

<p>Compute predictions from <code>party</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'party'
predict(object, newdata = NULL, perm = NULL, ...)
predict_party(party, id, newdata = NULL, ...)
## Default S3 method:
predict_party(party, id, newdata = NULL, FUN = NULL, ...) 
## S3 method for class 'constparty'
predict_party(party, id, newdata = NULL,
    type = c("response", "prob", "quantile", "density", "node"),
    at = if (type == "quantile") c(0.1, 0.5, 0.9),
    FUN = NULL, simplify = TRUE, ...)
## S3 method for class 'simpleparty'
predict_party(party, id, newdata = NULL,
    type = c("response", "prob", "node"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="party-predict_+3A_object">object</code></td>
<td>
<p> objects of class <code><a href="#topic+party">party</a></code>. </p>
</td></tr>
<tr><td><code id="party-predict_+3A_newdata">newdata</code></td>
<td>
<p> an optional data frame in which to look for variables with
which to predict, if omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="party-predict_+3A_perm">perm</code></td>
<td>
<p>an optional character vector of variable names. Splits of
nodes with a primary split in any of these variables will
be permuted (after dealing with surrogates). Note that
surrogate split in the <code>perm</code> variables will no be permuted.</p>
</td></tr>
<tr><td><code id="party-predict_+3A_party">party</code></td>
<td>
<p> objects of class <code><a href="#topic+party">party</a></code>. </p>
</td></tr>
<tr><td><code id="party-predict_+3A_id">id</code></td>
<td>
<p> a vector of terminal node identifiers. </p>
</td></tr>
<tr><td><code id="party-predict_+3A_type">type</code></td>
<td>
<p> a character string denoting the type of predicted value
returned, ignored when argument <code>FUN</code> is given.  For
<code>"response"</code>, the mean of a numeric response, the predicted
class for a categorical response or the median survival time for a
censored response is returned.  For <code>"prob"</code> the matrix of
conditional class probabilities (<code>simplify = TRUE</code>) or a list
with the conditional class probabilities for each observation
(<code>simplify = FALSE</code>) is returned for a categorical response. 
For numeric and censored responses, a list with the empirical
cumulative distribution functions and empirical survivor functions
(Kaplan-Meier estimate) is returned when <code>type = "prob"</code>. 
<code>"node"</code> returns an integer vector of terminal node
identifiers.</p>
</td></tr>
<tr><td><code id="party-predict_+3A_fun">FUN</code></td>
<td>
<p> a function to extract (<code>default</code> method) or compute 
(<code>constparty</code> method) summary statistics. For the <code>default</code> method,
this is a function of a terminal node only, for the <code>constparty</code> method, 
predictions for each node have to be computed based on arguments <code>(y, w)</code>
where <code>y</code> is the response and <code>w</code> are case weights.</p>
</td></tr>
<tr><td><code id="party-predict_+3A_at">at</code></td>
<td>
<p> if the return value is a function (as the empirical cumulative distribution
function or the empirical quantile function), this function is evaluated
at values <code>at</code> and these numeric values are returned. If <code>at</code> is
<code>NULL</code>, the functions themselves are returned in a list.</p>
</td></tr>
<tr><td><code id="party-predict_+3A_simplify">simplify</code></td>
<td>
<p> a logical indicating whether the resulting list 
of predictions should be converted to a suitable
vector or matrix (if possible).</p>
</td></tr>
<tr><td><code id="party-predict_+3A_...">...</code></td>
<td>
<p> additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="stats.html#topic+predict">predict</a></code> method for <code><a href="#topic+party">party</a></code> objects
computes the identifiers of the predicted terminal nodes, either
for new data in <code>newdata</code> or for the learning samples
(only possible for objects of class <code>constparty</code>).
These identifiers are delegated to the corresponding
<code>predict_party</code> method which computes (via 
<code>FUN</code> for class <code>constparty</code>)
or extracts (class <code>simpleparty</code>) the actual predictions.
</p>


<h3>Value</h3>

<p>A list of predictions, possibly simplified to a numeric vector, 
numeric matrix or factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## fit tree using rpart
  library("rpart")
  rp &lt;- rpart(skips ~ Opening + Solder + Mask + PadType + Panel,
              data = solder, method = 'anova')

  ## coerce to `constparty'
  pr &lt;- as.party(rp)

  ## mean predictions
  predict(pr, newdata = solder[c(3, 541, 640),])

  ## ecdf
  predict(pr, newdata = solder[c(3, 541, 640),], type = "prob")

  ## terminal node identifiers
  predict(pr, newdata = solder[c(3, 541, 640),], type = "node")

  ## median predictions
  predict(pr, newdata = solder[c(3, 541, 640),], 
          FUN = function(y, w = 1) median(y))

</code></pre>

<hr>
<h2 id='partynode'> Inner and Terminal Nodes </h2><span id='topic+partynode'></span><span id='topic+kidids_node'></span><span id='topic+fitted_node'></span><span id='topic+id_node'></span><span id='topic+split_node'></span><span id='topic+surrogates_node'></span><span id='topic+kids_node'></span><span id='topic+info_node'></span><span id='topic+formatinfo_node'></span>

<h3>Description</h3>

<p>A class for representing inner and terminal 
nodes in trees and functions for data partitioning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partynode(id, split = NULL, kids = NULL, surrogates = NULL, 
    info = NULL)
kidids_node(node, data, vmatch = 1:ncol(data), 
    obs = NULL, perm = NULL)
fitted_node(node, data, vmatch = 1:ncol(data), 
    obs = 1:nrow(data), perm = NULL)
id_node(node)
split_node(node)
surrogates_node(node)
kids_node(node)
info_node(node)
formatinfo_node(node, FUN = NULL, default = "", prefix = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partynode_+3A_id">id</code></td>
<td>
<p> integer, a unique identifier for a node. </p>
</td></tr>
<tr><td><code id="partynode_+3A_split">split</code></td>
<td>
<p> an object of class <code><a href="#topic+partysplit">partysplit</a></code>. </p>
</td></tr>
<tr><td><code id="partynode_+3A_kids">kids</code></td>
<td>
<p> a list of <code>partynode</code> objects. </p>
</td></tr>
<tr><td><code id="partynode_+3A_surrogates">surrogates</code></td>
<td>
<p> a list of <code>partysplit</code> objects.</p>
</td></tr>
<tr><td><code id="partynode_+3A_info">info</code></td>
<td>
<p> additional information. </p>
</td></tr>
<tr><td><code id="partynode_+3A_node">node</code></td>
<td>
<p> an object of class <code>partynode</code>.</p>
</td></tr>
<tr><td><code id="partynode_+3A_data">data</code></td>
<td>
<p> a <code><a href="base.html#topic+list">list</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="partynode_+3A_vmatch">vmatch</code></td>
<td>
<p> a permutation of the variable numbers in <code>data</code>.</p>
</td></tr>
<tr><td><code id="partynode_+3A_obs">obs</code></td>
<td>
<p> a logical or integer vector indicating a subset of the
observations in <code>data</code>.</p>
</td></tr>
<tr><td><code id="partynode_+3A_perm">perm</code></td>
<td>
<p> a vector of integers specifying the variables
to be permuted prior before splitting (i.e., for
computing permutation variable importances). The
default <code>NULL</code> doesn't alter the data.</p>
</td></tr>
<tr><td><code id="partynode_+3A_fun">FUN</code></td>
<td>
<p> function for formatting the <code>info</code>, for default see below.</p>
</td></tr>
<tr><td><code id="partynode_+3A_default">default</code></td>
<td>
<p> a character used if the <code>info</code> in <code>node</code>
is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="partynode_+3A_prefix">prefix</code></td>
<td>
<p> an optional prefix to be added to the returned character. </p>
</td></tr>
<tr><td><code id="partynode_+3A_...">...</code></td>
<td>
<p> further arguments passed to
<code><a href="utils.html#topic+capture.output">capture.output</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A node represents both inner and terminal nodes in a tree structure. 
Each node has a unique identifier <code>id</code>. A node consisting only
of such an identifier (and possibly additional information
in <code>info</code>) is a terminal node.
</p>
<p>Inner nodes consist of a primary split 
(an object of class <code><a href="#topic+partysplit">partysplit</a></code>)
and at least two kids (daughter nodes). 
Kid nodes are objects of class <code>partynode</code>
itself, so the tree structure is defined recursively.
In addition, a list of <code>partysplit</code> objects 
offering surrogate splits can be supplied. Like
<code><a href="#topic+partysplit">partysplit</a></code> objects, <code>partynode</code>
objects aren't connected to the actual data.
</p>
<p>Function <code>kidids_node()</code> determines how
the observations in <code>data[obs,]</code> are partitioned
into the kid nodes and returns the number of the list element
in list <code>kids</code> each observations belongs to 
(and not it's identifier).
This is done by evaluating <code>split</code> (and possibly
all surrogate splits) on <code>data</code> using 
<code><a href="#topic+kidids_split">kidids_split</a></code>.
</p>
<p>Function <code>fitted_node()</code> performs all 
splits recursively and returns the identifier <code>id</code>
of the terminal node each observation in
<code>data[obs,]</code> belongs to. Arguments <code>vmatch</code>, 
<code>obs</code> and <code>perm</code> are passed to <code><a href="#topic+kidids_split">kidids_split</a></code>.
</p>
<p>Function <code>formatinfo_node()</code> extracts the the <code>info</code>
from <code>node</code> and formats it to a <code>character</code> vector using the following
strategy: If <code>is.null(info)</code>, the <code>default</code> is returned.  
Otherwise, <code>FUN</code> is applied for formatting. The default function uses
<code>as.character</code> for atomic objects and applies <code><a href="utils.html#topic+capture.output">capture.output</a></code>
to <code>print(info)</code> for other objects. Optionally, a <code>prefix</code> can be added
to the computed character string.
</p>
<p>All other functions are accessor functions for
extracting information from objects of class <code>partynode</code>.
</p>


<h3>Value</h3>

<p>The constructor <code>partynode()</code> returns an object of class <code>partynode</code>:
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>
<p> a unique integer identifier for a node. </p>
</td></tr>
<tr><td><code>split</code></td>
<td>
<p> an object of class <code><a href="#topic+partysplit">partysplit</a></code>. </p>
</td></tr>
<tr><td><code>kids</code></td>
<td>
<p> a list of <code>partynode</code> objects. </p>
</td></tr>
<tr><td><code>surrogates</code></td>
<td>
<p> a list of <code><a href="#topic+partysplit">partysplit</a></code> objects.</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p> additional information. </p>
</td></tr>
</table>
<p><code>kidids_split()</code> returns an integer vector describing
the partition of the observations into kid nodes by their position
in list <code>kids</code>.
</p>
<p><code>fitted_node()</code> returns the node identifiers (<code>id</code>) 
of the terminal nodes each observation belongs to.
</p>


<h3>References</h3>

 
<p>Hothorn T, Zeileis A (2015).
partykit: A Modular Toolkit for Recursive Partytioning in R.
<em>Journal of Machine Learning Research</em>, <b>16</b>, 3905&ndash;3909.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris", package = "datasets")

## a stump defined by a binary split in Sepal.Length
stump &lt;- partynode(id = 1L, 
    split = partysplit(which(names(iris) == "Sepal.Length"),
	breaks = 5),
    kids = lapply(2:3, partynode))

## textual representation
print(stump, data = iris)  

## list element number and node id of the two terminal nodes
table(kidids_node(stump, iris), 
    fitted_node(stump, data = iris))

## assign terminal nodes with probability 0.5
## to observations with missing `Sepal.Length'
iris_NA &lt;- iris
iris_NA[sample(1:nrow(iris), 50), "Sepal.Length"] &lt;- NA
table(fitted_node(stump, data = iris_NA, 
    obs = !complete.cases(iris_NA)))

## a stump defined by a primary split in `Sepal.Length'
## and a surrogate split in `Sepal.Width' which
## determines terminal nodes for observations with
## missing `Sepal.Length'
stump &lt;- partynode(id = 1L, 
    split = partysplit(which(names(iris) == "Sepal.Length"),
	breaks = 5),
    kids = lapply(2:3, partynode),
    surrogates = list(partysplit(
	which(names(iris) == "Sepal.Width"), breaks = 3)))
f &lt;- fitted_node(stump, data = iris_NA, 
    obs = !complete.cases(iris_NA))
tapply(iris_NA$Sepal.Width[!complete.cases(iris_NA)], f, range)

</code></pre>

<hr>
<h2 id='partynode-methods'> Methods for Node Objects</h2><span id='topic+partynode-methods'></span><span id='topic+is.partynode'></span><span id='topic+as.partynode'></span><span id='topic+as.partynode.partynode'></span><span id='topic+as.partynode.list'></span><span id='topic+as.list.partynode'></span><span id='topic+length.partynode'></span><span id='topic++5B.partynode'></span><span id='topic++5B+5B.partynode'></span><span id='topic+is.terminal'></span><span id='topic+is.terminal.partynode'></span><span id='topic+depth.partynode'></span><span id='topic+width'></span><span id='topic+width.partynode'></span><span id='topic+print.partynode'></span><span id='topic+nodeprune.partynode'></span>

<h3>Description</h3>

<p>Methods for computing on <code>partynode</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.partynode(x)
as.partynode(x, ...)
## S3 method for class 'partynode'
as.partynode(x, from = NULL, recursive = TRUE, ...)
## S3 method for class 'list'
as.partynode(x, ...)
## S3 method for class 'partynode'
as.list(x, ...)
## S3 method for class 'partynode'
length(x)
## S3 method for class 'partynode'
x[i, ...]
## S3 method for class 'partynode'
x[[i, ...]]
is.terminal(x, ...)
## S3 method for class 'partynode'
is.terminal(x, ...)
## S3 method for class 'partynode'
depth(x, root = FALSE, ...)
width(x, ...)
## S3 method for class 'partynode'
width(x, ...)
## S3 method for class 'partynode'
print(x, data = NULL, names = NULL,
    inner_panel = function(node) "", 
    terminal_panel = function(node) " *",
    prefix = "", first = TRUE, digits = getOption("digits") - 2, 
    ...)
## S3 method for class 'partynode'
nodeprune(x, ids, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partynode-methods_+3A_x">x</code></td>
<td>
<p> an object of class <code>partynode</code> or <code>list</code>.</p>
</td></tr>
<tr><td><code id="partynode-methods_+3A_from">from</code></td>
<td>
<p> an integer giving the identifier of the root node.</p>
</td></tr>
<tr><td><code id="partynode-methods_+3A_recursive">recursive</code></td>
<td>
<p> a logical, if <code>FALSE</code>, only the id of the root node
is checked against <code>from</code>. If 
<code>TRUE</code>, the ids of all nodes are checked.</p>
</td></tr>
<tr><td><code id="partynode-methods_+3A_i">i</code></td>
<td>
<p> an integer specifying the kid to extract.</p>
</td></tr>
<tr><td><code id="partynode-methods_+3A_root">root</code></td>
<td>
<p> a logical. Should the root count be counted in <code>depth</code>? </p>
</td></tr>
<tr><td><code id="partynode-methods_+3A_data">data</code></td>
<td>
<p> an optional <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="partynode-methods_+3A_names">names</code></td>
<td>
<p> a vector of names for nodes.</p>
</td></tr>
<tr><td><code id="partynode-methods_+3A_terminal_panel">terminal_panel</code></td>
<td>
<p> a panel function for printing terminal nodes.</p>
</td></tr>
<tr><td><code id="partynode-methods_+3A_inner_panel">inner_panel</code></td>
<td>
<p> a panel function for printing inner nodes.</p>
</td></tr>
<tr><td><code id="partynode-methods_+3A_prefix">prefix</code></td>
<td>
<p> lines start with this symbol.</p>
</td></tr>
<tr><td><code id="partynode-methods_+3A_first">first</code></td>
<td>
<p> a logical.</p>
</td></tr>
<tr><td><code id="partynode-methods_+3A_digits">digits</code></td>
<td>
<p> number of digits to be printed.</p>
</td></tr>
<tr><td><code id="partynode-methods_+3A_ids">ids</code></td>
<td>
<p> a vector of node ids to be pruned-off.</p>
</td></tr>
<tr><td><code id="partynode-methods_+3A_...">...</code></td>
<td>
<p> additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is.partynode</code> checks if the argument is a valid <code>partynode</code>
object. <code>is.terminal</code> is <code>TRUE</code> for terminal nodes
and <code>FALSE</code> for inner nodes. The subset methods
return the <code>partynode</code> object corresponding to the <code>i</code>th
kid.
</p>
<p>The <code>as.partynode</code> and <code>as.list</code> methods can be used
to convert flat list structures into recursive <code>partynode</code>
objects and vice versa. <code>as.partynode</code> applied to
<code>partynode</code> objects renumbers the recursive nodes
starting with root node identifier <code>from</code>.
</p>
<p><code>length</code> gives the number of kid nodes of the root node,
<code>depth</code> the depth of the tree and <code>width</code> 
the number of terminal nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a tree as flat list structure
nodelist &lt;- list(
  # root node
  list(id = 1L, split = partysplit(varid = 4L, breaks = 1.9), 
      kids = 2:3),
  # V4 &lt;= 1.9, terminal node
  list(id = 2L),
  # V4 &gt; 1.9
  list(id = 3L, split = partysplit(varid = 1L, breaks = 1.7), 
      kids = c(4L, 7L)),
  # V1 &lt;= 1.7
  list(id = 4L, split = partysplit(varid = 4L, breaks = 4.8), 
      kids = 5:6),
  # V4 &lt;= 4.8, terminal node
  list(id = 5L),
  # V4 &gt; 4.8, terminal node
  list(id = 6L),
  # V1 &gt; 1.7, terminal node
  list(id = 7L)
)

## convert to a recursive structure
node &lt;- as.partynode(nodelist)

## print raw recursive structure without data
print(node)

## print tree along with the associated iris data
data("iris", package = "datasets")
print(node, data = iris)

## print subtree
print(node[2], data = iris)

## print subtree, with root node number one
print(as.partynode(node[2], from = 1), data = iris)

## number of kids in root node
length(node)

## depth of tree
depth(node)

## number of terminal nodes
width(node)

## convert back to flat structure
as.list(node)
</code></pre>

<hr>
<h2 id='partysplit'> Binary and Multiway Splits </h2><span id='topic+partysplit'></span><span id='topic+kidids_split'></span><span id='topic+character_split'></span><span id='topic+varid_split'></span><span id='topic+breaks_split'></span><span id='topic+index_split'></span><span id='topic+right_split'></span><span id='topic+prob_split'></span><span id='topic+info_split'></span>

<h3>Description</h3>

<p>A class for representing multiway splits and functions 
for computing on splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partysplit(varid, breaks = NULL, index = NULL, right = TRUE, 
    prob = NULL, info = NULL)
kidids_split(split, data, vmatch = 1:length(data), obs = NULL)
character_split(split, data = NULL, 
    digits = getOption("digits") - 2)
varid_split(split)
breaks_split(split)
index_split(split)
right_split(split)
prob_split(split)
info_split(split)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partysplit_+3A_varid">varid</code></td>
<td>
<p> an integer specifying the variable to split in, i.e., 
a column number in <code>data</code>. </p>
</td></tr>
<tr><td><code id="partysplit_+3A_breaks">breaks</code></td>
<td>
<p> a numeric vector of split points. </p>
</td></tr>
<tr><td><code id="partysplit_+3A_index">index</code></td>
<td>
<p> an integer vector containing a contiguous sequence 
from one to the number of kid nodes. May contain <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="partysplit_+3A_right">right</code></td>
<td>
<p> a logical, indicating if the intervals defined by 
<code>breaks</code> should be closed on the
right (and open on the left) or vice versa.</p>
</td></tr>
<tr><td><code id="partysplit_+3A_prob">prob</code></td>
<td>
<p> a numeric vector representing a probability distribution 
over kid nodes. </p>
</td></tr>
<tr><td><code id="partysplit_+3A_info">info</code></td>
<td>
<p> additional information. </p>
</td></tr>
<tr><td><code id="partysplit_+3A_split">split</code></td>
<td>
<p> an object of class <code>partysplit</code>.</p>
</td></tr>
<tr><td><code id="partysplit_+3A_data">data</code></td>
<td>
<p> a <code><a href="base.html#topic+list">list</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="partysplit_+3A_vmatch">vmatch</code></td>
<td>
<p> a permutation of the variable numbers in <code>data</code>.</p>
</td></tr>
<tr><td><code id="partysplit_+3A_obs">obs</code></td>
<td>
<p> a logical or integer vector indicating a subset of the 
observations in <code>data</code>.</p>
</td></tr>
<tr><td><code id="partysplit_+3A_digits">digits</code></td>
<td>
<p> minimal number of significant digits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A split is basically a function that maps data, 
more specifically a partitioning variable,
to a set of integers indicating the kid nodes to send observations to. 
Objects of class <code>partysplit</code> describe such a function and can
be set-up via the <code>partysplit()</code> constructor.
The variables are available in a <code>list</code> or <code>data.frame</code> 
(here called <code>data</code>) and <code>varid</code> specifies the 
partitioning variable, i.e., the variable or list element to split in. 
The constructor <code>partysplit()</code> doesn't have access 
to the actual data, i.e., doesn't <em>estimate</em> splits.
</p>
<p><code>kidids_split(split, data)</code> actually partitions the data
<code>data[obs,varid_split(split)]</code> and assigns an integer (giving the
kid node number) to each observation. If <code>vmatch</code> is given,
the variable <code>vmatch[varid_split(split)]</code> is used.
</p>
<p><code>character_split()</code> returns a character representation
of its <code>split</code> argument. The remaining functions 
defined here are accessor functions for <code>partysplit</code> 
objects.
</p>
<p>The numeric vector <code>breaks</code> defines how the range of 
the partitioning variable (after coercing to a numeric via 
<code><a href="base.html#topic+as.numeric">as.numeric</a></code>) is divided into intervals 
(like in <code><a href="base.html#topic+cut">cut</a></code>) and may be 
<code>NULL</code>. These intervals are represented by the
numbers one to <code>length(breaks) + 1</code>.
</p>
<p><code>index</code> assigns these <code>length(breaks) + 1</code> 
intervals to one of at least two kid nodes. Thus, <code>index</code>
is a vector of integers where each element corresponds
to one element in a list <code>kids</code> containing <code><a href="#topic+partynode">partynode</a></code>
objects, see <code><a href="#topic+partynode">partynode</a></code> for details. The vector
<code>index</code> may contain <code>NA</code>s, in that case, the corresponding
values of the splitting variable are treated as missings (for
example factor levels that are not present in the learning sample).
Either <code>breaks</code> or <code>index</code> must be given.
When <code>breaks</code> is <code>NULL</code>, it is assumed that
the partitioning variable itself has storage mode <code>integer</code>
(e.g., is a <code><a href="base.html#topic+factor">factor</a></code>).
</p>
<p><code>prob</code> defines a probability distribution over
all kid nodes which is used for random splitting
when a deterministic split isn't possible (due to missing 
values, for example).
</p>
<p><code>info</code> takes arbitrary user-specified information.
</p>


<h3>Value</h3>

<p>The constructor <code>partysplit()</code> returns an object of class <code>partysplit</code>:
</p>
<table role = "presentation">
<tr><td><code>varid</code></td>
<td>
<p> an integer specifying the variable to split in, i.e., 
a column number in <code>data</code>, </p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p> a numeric vector of split points, </p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p> an integer vector containing a contiguous sequence 
from one to the number of kid nodes,</p>
</td></tr>
<tr><td><code>right</code></td>
<td>
<p> a logical, indicating if the intervals defined by 
<code>breaks</code> should be closed on the
right (and open on the left) or vice versa</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p> a numeric vector representing a probability distribution 
over kid nodes, </p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p> additional information. </p>
</td></tr>
</table>
<p><code>kidids_split()</code> returns an integer vector describing
the partition of the observations into kid nodes.
</p>
<p><code>character_split()</code> gives a character representation of the
split and the remaining functions return the corresponding slots
of <code>partysplit</code> objects.
</p>


<h3>References</h3>

 
<p>Hothorn T, Zeileis A (2015).
partykit: A Modular Toolkit for Recursive Partytioning in R.
<em>Journal of Machine Learning Research</em>, <b>16</b>, 3905&ndash;3909.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris", package = "datasets")

## binary split in numeric variable `Sepal.Length'
sl5 &lt;- partysplit(which(names(iris) == "Sepal.Length"),
    breaks = 5)
character_split(sl5, data = iris)
table(kidids_split(sl5, data = iris), iris$Sepal.Length &lt;= 5)

## multiway split in numeric variable `Sepal.Width', 
## higher values go to the first kid, smallest values 
## to the last kid
sw23 &lt;- partysplit(which(names(iris) == "Sepal.Width"),    
    breaks = c(3, 3.5), index = 3:1)	
character_split(sw23, data = iris)    
table(kidids_split(sw23, data = iris), 
    cut(iris$Sepal.Width, breaks = c(-Inf, 2, 3, Inf)))   

## binary split in factor `Species'
sp &lt;- partysplit(which(names(iris) == "Species"),
    index = c(1L, 1L, 2L))
character_split(sp, data = iris)
table(kidids_split(sp, data = iris), iris$Species)

## multiway split in factor `Species'
sp &lt;- partysplit(which(names(iris) == "Species"), index = 1:3)
character_split(sp, data = iris)
table(kidids_split(sp, data = iris), iris$Species)

## multiway split in numeric variable `Sepal.Width'
sp &lt;- partysplit(which(names(iris) == "Sepal.Width"), 
    breaks = quantile(iris$Sepal.Width))
character_split(sp, data = iris)

</code></pre>

<hr>
<h2 id='prune.modelparty'>Post-Prune <code>modelparty</code> Objects</h2><span id='topic+prune.modelparty'></span><span id='topic+prune.lmtree'></span>

<h3>Description</h3>

<p>Post-pruning of <code>modelparty</code> objects based on information
criteria like AIC, BIC, or related user-defined criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelparty'
prune(tree, type = "AIC", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prune.modelparty_+3A_tree">tree</code></td>
<td>
<p>object of class <code>modelparty</code>.</p>
</td></tr>
<tr><td><code id="prune.modelparty_+3A_type">type</code></td>
<td>
<p>pruning type. Can be <code>"AIC"</code>, <code>"BIC"</code> or a
user-defined function (details below).</p>
</td></tr>
<tr><td><code id="prune.modelparty_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code><a href="#topic+mob">mob</a></code>-based model trees, pre-pruning based on p-values
is used by default and often no post-pruning is necessary in such trees.
However, if pre-pruning is switched off (by using a large <code>alpha</code>)
or does is not sufficient (e.g., possibly in large samples) the <code>prune</code>
method can be used for subsequent post-pruning based on information criteria.
</p>
<p>The function <code>prune.modelparty</code> can be called directly but it is also
registered as a method for the generic <code><a href="rpart.html#topic+prune">prune</a></code> function
from the <span class="pkg">rpart</span> package. Thus, if <span class="pkg">rpart</span> is attached,
<code>prune(tree, type = "AIC", ...)</code> also works (see examples below).
</p>
<p>To customize the post-pruning strategy,
<code>type</code> can be set to a <code>function(objfun, df, nobs)</code>
which either returns <code>TRUE</code> to signal that a current node can be pruned
or <code>FALSE</code>. All supplied arguments are of length two: <code>objfun</code> is the sum of objective
function values in the current node and its child nodes, respectively.
<code>df</code> is the degrees of freedom in the current node and its child nodes,
respectively. <code>nobs</code> is vector with the number of observations in the
current node and the total number of observations in the dataset, respectively. 
</p>
<p>For <code>"AIC"</code> and <code>"BIC"</code> <code>type</code> is transformed so that AIC
or BIC are computed. However, this assumes that the <code>objfun</code> used in <code>tree</code>
is actually the negative log-likelihood. The degrees of freedom assumed for a split 
can be set via the <code>dfsplit</code> argument in <code><a href="#topic+mob_control">mob_control</a></code> when computing
the <code>tree</code> or manipulated later by changing the value of <code>tree$info$control$dfsplit</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>modelparty</code> where the associated tree is either the
same as the original or smaller.
</p>


<h3>See Also</h3>

<p><code><a href="rpart.html#topic+prune">prune</a></code>, <code><a href="#topic+lmtree">lmtree</a></code>, <code><a href="#topic+glmtree">glmtree</a></code>, <code><a href="#topic+mob">mob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(29)
n &lt;- 1000
d &lt;- data.frame(
  x = runif(n),
  z = runif(n),
  z_noise = factor(sample(1:3, size = n, replace = TRUE))
)
d$y &lt;- rnorm(n, mean = d$x * c(-1, 1)[(d$z &gt; 0.7) + 1], sd = 3)

## glm versus lm / logLik versus sum of squared residuals
fmla &lt;- y ~ x | z + z_noise
lm_big &lt;- lmtree(formula = fmla, data = d, maxdepth = 3, alpha = 1)
glm_big &lt;- glmtree(formula = fmla, data = d, maxdepth = 3, alpha = 1)

AIC(lm_big)
AIC(glm_big)

## load rpart for prune() generic
## (otherwise: use prune.modelparty directly)
if (require("rpart")) {

## pruning
lm_aic &lt;- prune(lm_big, type = "AIC")
lm_bic &lt;- prune(lm_big, type = "BIC")

width(lm_big)
width(lm_aic)
width(lm_bic)

glm_aic &lt;- prune(glm_big, type = "AIC")
glm_bic &lt;- prune(glm_big, type = "BIC")

width(glm_big)
width(glm_aic)
width(glm_bic)

}
</code></pre>

<hr>
<h2 id='varimp'> Variable Importance </h2><span id='topic+varimp'></span><span id='topic+varimp.constparty'></span><span id='topic+varimp.cforest'></span>

<h3>Description</h3>

<p>Standard and conditional variable importance for &lsquo;cforest&rsquo;, following the permutation
principle of the &lsquo;mean decrease in accuracy&rsquo; importance in &lsquo;randomForest&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'constparty'
varimp(object, nperm = 1L, 
       risk = c("loglik", "misclassification"), conditions = NULL,
       mincriterion = 0, ...)
## S3 method for class 'cforest'
varimp(object, nperm = 1L, 
       OOB = TRUE, risk = c("loglik", "misclassification"),
       conditional = FALSE, threshold = .2, applyfun = NULL, 
       cores = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varimp_+3A_object">object</code></td>
<td>
<p> an object as returned by <code>cforest</code>.</p>
</td></tr>
<tr><td><code id="varimp_+3A_mincriterion">mincriterion</code></td>
<td>
<p> the value of the test statistic or 1 - p-value that
must be exceeded in order to include a split in the 
computation of the importance. The default <code>mincriterion = 0</code>
guarantees that all splits are included.</p>
</td></tr>
<tr><td><code id="varimp_+3A_conditional">conditional</code></td>
<td>
<p> a logical determining whether unconditional or conditional 
computation of the importance is performed. </p>
</td></tr>
<tr><td><code id="varimp_+3A_threshold">threshold</code></td>
<td>
<p> the value of the test statistic or 1 - p-value of the association 
between the variable of interest and a covariate that must be 
exceeded inorder to include the covariate in the conditioning 
scheme for the variable of interest (only relevant if 
<code>conditional = TRUE</code>). </p>
</td></tr>
<tr><td><code id="varimp_+3A_nperm">nperm</code></td>
<td>
<p> the number of permutations performed.</p>
</td></tr>
<tr><td><code id="varimp_+3A_oob">OOB</code></td>
<td>
<p> a logical determining whether the importance is computed from the out-of-bag 
sample or the learning sample (not suggested).</p>
</td></tr>
<tr><td><code id="varimp_+3A_risk">risk</code></td>
<td>
<p> a character determining the risk to be evaluated.</p>
</td></tr>
<tr><td><code id="varimp_+3A_conditions">conditions</code></td>
<td>
<p> a list of conditions. </p>
</td></tr>
<tr><td><code id="varimp_+3A_applyfun">applyfun</code></td>
<td>
<p>an optional <code><a href="base.html#topic+lapply">lapply</a></code>-style function with arguments
<code>function(X, FUN, ...)</code>. It is used for computing the variable importances for each tree. 
The default is to use the basic <code>lapply</code>
function unless the <code>cores</code> argument is specified (see below).
Extra care is needed to ensure correct seeds are used in
the parallel runs (<code>RNGkind("L'Ecuyer-CMRG")</code> for
example).</p>
</td></tr>
<tr><td><code id="varimp_+3A_cores">cores</code></td>
<td>
<p>numeric. If set to an integer the <code>applyfun</code> is set to
<code><a href="parallel.html#topic+mclapply">mclapply</a></code> with the desired number of <code>cores</code>.</p>
</td></tr>
<tr><td><code id="varimp_+3A_...">...</code></td>
<td>
<p>additional arguments, not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NEEDS UPDATE
</p>
<p>Function <code>varimp</code> can be used to compute variable importance measures
similar to those computed by <code><a href="randomForest.html#topic+importance">importance</a></code>. Besides the
standard version, a conditional version is available, that adjusts for correlations between
predictor variables. 
</p>
<p>If <code>conditional = TRUE</code>, the importance of each variable is computed by permuting 
within a grid defined by the covariates that are associated  (with 1 - p-value 
greater than <code>threshold</code>) to the variable of interest.
The resulting variable importance score is conditional in the sense of beta coefficients in   
regression models, but represents the effect of a variable in both main effects and interactions.
See Strobl et al. (2008) for details.
</p>
<p>Note, however, that all random forest results are subject to random variation. Thus, before
interpreting the importance ranking, check whether the same ranking is achieved with a
different random seed &ndash; or otherwise increase the number of trees <code>ntree</code> in 
<code><a href="#topic+ctree_control">ctree_control</a></code>.
</p>
<p>Note that in the presence of missings in the predictor variables the procedure
described in Hapfelmeier et al. (2012) is performed.
</p>


<h3>Value</h3>

<p>A vector of &lsquo;mean decrease in accuracy&rsquo; importance scores.
</p>


<h3>References</h3>

 
<p>Leo Breiman (2001). Random Forests. <em>Machine Learning</em>, 45(1), 5&ndash;32.
</p>
<p>Alexander Hapfelmeier, Torsten Hothorn, Kurt Ulm, and Carolin Strobl (2014).
A New Variable Importance Measure for Random Forests with Missing Data.
<em>Statistics and Computing</em>, <b>24</b>(1), 21-34. 
<a href="https://doi.org/10.1007/s11222-012-9349-1">doi:10.1007/s11222-012-9349-1</a>
</p>
<p>Torsten Hothorn, Kurt Hornik, and Achim Zeileis (2006b). Unbiased
Recursive Partitioning: A Conditional Inference Framework.
<em>Journal of Computational and Graphical Statistics</em>, <b>15</b>(3),
651-674. <a href="https://doi.org/10.1198/106186006X133933">doi:10.1198/106186006X133933</a>
</p>
<p>Carolin Strobl, Anne-Laure Boulesteix, Thomas Kneib, Thomas Augustin, and Achim Zeileis (2008).
Conditional Variable Importance for Random Forests. <em>BMC Bioinformatics</em>, <b>9</b>, 307. 
<a href="https://doi.org/10.1186/1471-2105-8-25">doi:10.1186/1471-2105-8-25</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
   set.seed(290875)
   data("readingSkills", package = "party")
   readingSkills.cf &lt;- cforest(score ~ ., data = readingSkills, 
                               mtry = 2, ntree = 50)

   # standard importance
   varimp(readingSkills.cf)

   # conditional importance, may take a while...
   varimp(readingSkills.cf, conditional = TRUE)

</code></pre>

<hr>
<h2 id='WeatherPlay'>Weather Conditions and Playing a Game</h2><span id='topic+WeatherPlay'></span>

<h3>Description</h3>

<p>Artificial data set concerning the conditions suitable for
playing some unspecified game.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("WeatherPlay")</code></pre>


<h3>Format</h3>

<p>A data frame containing 14 observations on 5 variables.
</p>

<dl>
<dt>outlook</dt><dd><p>factor.</p>
</dd>
<dt>temperature</dt><dd><p>numeric.</p>
</dd>
<dt>humidity</dt><dd><p>numeric.</p>
</dd>
<dt>windy</dt><dd><p>factor.</p>
</dd>
<dt>play</dt><dd><p>factor.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Table 1.3 in Witten and Frank (2011).
</p>


<h3>References</h3>

<p>Witten IH, Frank E (2011).
<em>Data Mining: Practical Machine Learning Tools and Techniques</em>.
3rd Edition, Morgan Kaufmann, San Francisco. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+party">party</a></code>, <code><a href="#topic+partynode">partynode</a></code>, <code><a href="#topic+partysplit">partysplit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## load weather data
data("WeatherPlay", package = "partykit")
WeatherPlay

## construct simple tree
pn &lt;- partynode(1L,
  split = partysplit(1L, index = 1:3),
  kids = list(
    partynode(2L,
      split = partysplit(3L, breaks = 75),
      kids = list(
        partynode(3L, info = "yes"),
        partynode(4L, info = "no"))),
    partynode(5L, info = "yes"),
    partynode(6L,
      split = partysplit(4L, index = 1:2),
      kids = list(
        partynode(7L, info = "yes"),
        partynode(8L, info = "no")))))
pn

## couple with data
py &lt;- party(pn, WeatherPlay)

## print/plot/predict
print(py)
plot(py)
predict(py, newdata = WeatherPlay)

## customize printing
print(py,
  terminal_panel = function(node) paste(": play=", info_node(node), sep = ""))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
