<!DOCTYPE html><html><head><title>Help for package CDatanet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CDatanet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CDatanet-package'><p>The CDatanet package</p></a></li>
<li><a href='#cdnet'><p>Estimate Count Data Model with Social Interactions using NPL Method</p></a></li>
<li><a href='#homophili.data'><p>Convert data between directed network models and symmetric network models.</p></a></li>
<li><a href='#homophily.fe'><p>Estimate Network Formation Model with Degree Heterogeneity as Fixed Effects</p></a></li>
<li><a href='#homophily.re'><p>Estimate Network Formation Model with Degree Heterogeneity as Random Effects</p></a></li>
<li><a href='#sar'><p>Estimate SAR model</p></a></li>
<li><a href='#sart'><p>Estimate sart model</p></a></li>
<li><a href='#simcdnet'><p>Simulate data from Count Data Model with Social Interactions</p></a></li>
<li><a href='#simsar'><p>Simulate data from the linear-in-mean Model with Social Interactions</p></a></li>
<li><a href='#simsart'><p>Simulate data from the Tobit Model with Social Interactions</p></a></li>
<li><a href='#summary.cdnet'><p>Summarize Count Data Model with Social Interactions</p></a></li>
<li><a href='#summary.sar'><p>Summarize SAR Model</p></a></li>
<li><a href='#summary.sart'><p>Summarize sart Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modeling Count Data with Peer Effects</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Likelihood-based estimation and data generation from a class of models used to estimate peer effects on count data by controlling for the network endogeneity. This class includes count data models with social interactions (Houndetoungan 2023; &lt;<a href="https://doi.org/10.2139%2Fssrn.3721250">doi:10.2139/ssrn.3721250</a>&gt;), spatial tobit models (Xu and Lee 2015; &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2015.05.004">doi:10.1016/j.jeconom.2015.05.004</a>&gt;), and spatial linear-in-means models (Lee 2004; &lt;<a href="https://doi.org/10.1111%2Fj.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>&gt;).  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ahoundetoungan/CDatanet/issues">https://github.com/ahoundetoungan/CDatanet/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ahoundetoungan/CDatanet">https://github.com/ahoundetoungan/CDatanet</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), Formula, formula.tools, ddpcr, Matrix,
matrixcalc</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress, RcppDist, RcppNumerical,
RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, MASS, knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-09 11:46:31 UTC; haache</td>
</tr>
<tr>
<td>Author:</td>
<td>Aristide Houndetoungan [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aristide Houndetoungan &lt;ahoundetoungan@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-09 23:30:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='CDatanet-package'>The CDatanet package</h2><span id='topic+CDatanet'></span><span id='topic+CDatanet-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">CDatanet</span> package implements the count data model with social interactions and the dyadic linking model developed in Houndetoungan (2022).
It also simulates data from the count data model and implements the Spatial Autoregressive Tobit model (LeSage, 2000; Xu and Lee, 2015) for left censored data and the Spatial Autoregressive Model (Lee, 2004).
Network formation models, such as that studied by Yan et al. (2019), are also implemented.
To make the computations faster <span class="pkg">CDatanet</span> uses <code>C++</code> through the <span class="pkg">Rcpp</span> package (Eddelbuettel et al., 2011).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aristide Houndetoungan <a href="mailto:ahoundetoungan@gmail.com">ahoundetoungan@gmail.com</a>
</p>


<h3>References</h3>

<p>Eddelbuettel, D., &amp; Francois, R. (2011). <span class="pkg">Rcpp</span>: Seamless <span class="rlang"><b>R</b></span> and <code>C++</code> integration. <em>Journal of Statistical Software</em>, 40(8), 1-18, <a href="https://doi.org/10.18637/jss.v040.i08">doi:10.18637/jss.v040.i08</a>.
</p>
<p>Houndetoungan, E. A. (2022). Count Data Models with Social Interactions under Rational Expectations. Available at SSRN 3721250, <a href="https://doi.org/10.2139/ssrn.3721250">doi:10.2139/ssrn.3721250</a>.
</p>
<p>Lee, L. F. (2004). Asymptotic distributions of quasi-maximum likelihood estimators for spatial autoregressive models. <em>Econometrica</em>, 72(6), 1899-1925, <a href="https://doi.org/10.1111/j.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>.
</p>
<p>Xu, X., &amp; Lee, L. F. (2015). Maximum likelihood estimation of a spatial autoregressive Tobit model. <em>Journal of Econometrics</em>, 188(1), 264-280, <a href="https://doi.org/10.1016/j.jeconom.2015.05.004">doi:10.1016/j.jeconom.2015.05.004</a>.
</p>
<p>Yan, T., Jiang, B., Fienberg, S. E., &amp; Leng, C. (2019). Statistical inference in a directed network model with covariates. <em>Journal of the American Statistical Association</em>, 114(526), 857-868, <a href="https://doi.org/10.1080/01621459.2018.1448829">doi:10.1080/01621459.2018.1448829</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ahoundetoungan/CDatanet">https://github.com/ahoundetoungan/CDatanet</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ahoundetoungan/CDatanet/issues">https://github.com/ahoundetoungan/CDatanet/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cdnet'>Estimate Count Data Model with Social Interactions using NPL Method</h2><span id='topic+cdnet'></span>

<h3>Description</h3>

<p><code>cdnet</code> is used to estimate peer effects on counting data with rational expectations (see details). The model is presented in Houndetoungan (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdnet(
  formula,
  contextual,
  Glist,
  Rbar = NULL,
  estim.rho = FALSE,
  starting = list(theta = NULL, deltabar = NULL, delta = NULL, rho = NULL),
  yb0 = NULL,
  optimizer = "fastlbfgs",
  npl.ctr = list(),
  opt.ctr = list(),
  cov = TRUE,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdnet_+3A_formula">formula</code></td>
<td>
<p>an object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be as for example <code>y ~ x1 + x2 | x1 + x2</code>
where <code>y</code> is the endogenous vector, the listed variables before the pipe, <code>x1</code>, <code>x2</code> are the individual exogenous variables and
the listed variables after the pipe, <code>x1</code>, <code>x2</code> are the contextual observable variables. Other formulas may be
<code>y ~ x1 + x2</code> for the model without contextual effects, <code>y ~ -1 + x1 + x2 | x1 + x2</code> for the model
without intercept or <code> y ~ x1 + x2 | x2 + x3</code> to allow the contextual variable to be different from the individual variables.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_contextual">contextual</code></td>
<td>
<p>(optional) logical; if true, this means that all individual variables will be set as contextual variables. Set the
the <code>formula</code> as <code>y ~ x1 + x2</code> and <code>contextual</code> as <code>TRUE</code> is equivalent to set the formula as <code>y ~ x1 + x2 | x1 + x2</code>.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_glist">Glist</code></td>
<td>
<p>the adjacency matrix or list sub-adjacency matrix.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_rbar">Rbar</code></td>
<td>
<p>the value of Rbar. If not provided, it is automatically set at <code>quantile(y, 0.9)</code>.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_estim.rho">estim.rho</code></td>
<td>
<p>indicates if the parameter <code class="reqn">\rho</code> should be estimated or set to zero.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_starting">starting</code></td>
<td>
<p>(optional) starting value of <code class="reqn">\theta = (\lambda, \beta', \gamma')'</code>, <code class="reqn">\bar{\delta}</code>, <code class="reqn">\delta = (\delta_2, ..., \delta_{\bar{R}})</code>, and <code class="reqn">\rho</code>. The parameter <code class="reqn">\gamma</code> should be removed if the model
does not contain contextual effects (see details).</p>
</td></tr>
<tr><td><code id="cdnet_+3A_yb0">yb0</code></td>
<td>
<p>(optional) expectation of y.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_optimizer">optimizer</code></td>
<td>
<p>is either <code>fastlbfgs</code> (L-BFGS optimization method of the package <span class="pkg">RcppNumerical</span>), <code>nlm</code> (referring to the function <a href="stats.html#topic+nlm">nlm</a>), or <code>optim</code> (referring to the function <a href="stats.html#topic+optim">optim</a>).
Other arguments
of these functions such as, <code>control</code> and <code>method</code> can be defined through the argument <code>opt.ctr</code>.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_npl.ctr">npl.ctr</code></td>
<td>
<p>list of controls for the NPL method (see details).</p>
</td></tr>
<tr><td><code id="cdnet_+3A_opt.ctr">opt.ctr</code></td>
<td>
<p>list of arguments to be passed in <code>optim_lbfgs</code> of the package <span class="pkg">RcppNumerical</span>, <a href="stats.html#topic+nlm">nlm</a> or <a href="stats.html#topic+optim">optim</a> (the solver set in <code>optimizer</code>), such as <code>maxit</code>, <code>eps_f</code>, <code>eps_g</code>, <code>control</code>, <code>method</code>, ...</p>
</td></tr>
<tr><td><code id="cdnet_+3A_cov">cov</code></td>
<td>
<p>a Boolean indicating if the covariance should be computed.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>cdnet</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Model</h4>

<p>Following Houndetoungan (2022), the count data <code class="reqn">\mathbf{y}</code> is generated from a latent variable <code class="reqn">\mathbf{y}^*</code>.
The latent variable is given for all i as
</p>
<p style="text-align: center;"><code class="reqn">y_i^* = \lambda \mathbf{g}_i \mathbf{E}(\bar{\mathbf{y}}|\mathbf{X},\mathbf{G})  + \mathbf{x}_i'\beta + \mathbf{g}_i\mathbf{X}\gamma + \epsilon_i,</code>
</p>

<p>where <code class="reqn">\epsilon_i \sim N(0, 1)</code>.<br />
Then, <code class="reqn">y_i = r</code> iff <code class="reqn">a_r \leq y_i^* \leq a_{r+1}</code>, where
<code class="reqn">a_0 = -\inf</code>, <code class="reqn">a_1 = 0</code>, <code class="reqn">a_r = \sum_{k = 1}^r\delta_k</code>.
The parameter are subject to the constraints <code class="reqn">\delta_r \geq \lambda</code> if <code class="reqn">1 \leq r \leq \bar{R}</code>,  and
<code class="reqn">\delta_r = (r - \bar{R})^{\rho}\bar{\delta} + \lambda</code> if <code class="reqn">r \geq \bar{R} + 1</code>. The unknown parameters to be estimated are
<code class="reqn">\lambda</code>, <code class="reqn">\beta</code>, <code class="reqn">\gamma</code>, <code class="reqn">\delta_2</code>, ..., <code class="reqn">\delta_{\bar{R}}</code>, <code class="reqn">\bar{\delta}</code>, and <code class="reqn">\rho</code>.
</p>



<h4><code>npl.ctr</code></h4>

<p>The model parameters is estimated using the Nested Partial Likelihood (NPL) method. This approach
starts with a guess of <code class="reqn">\theta</code> and <code class="reqn">\bar{y}</code> and constructs iteratively a sequence
of <code class="reqn">\theta</code> and <code class="reqn">\bar{y}</code>. The solution converges when the <code class="reqn">L_1</code> distance
between two consecutive <code class="reqn">\theta</code> and <code class="reqn">\bar{y}</code> is less than a tolerance. <br />
The argument <code>npl.ctr</code> is an optional list which contain
</p>

<dl>
<dt>tol</dt><dd><p> the tolerance of the NPL algorithm (default 1e-4),</p>
</dd>
<dt>maxit</dt><dd><p> the maximal number of iterations allowed (default 500),</p>
</dd>
<dt>print</dt><dd><p> a boolean indicating if the estimate should be printed at each step.</p>
</dd>
<dt>S</dt><dd><p> the number of simulation performed use to compute integral in the covariance by important sampling.</p>
</dd>
</dl>




<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>info</code></td>
<td>
<p>list of general information about the model.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>NPL estimator.</p>
</td></tr>
<tr><td><code>yb</code></td>
<td>
<p>ybar (see details), expectation of y.</p>
</td></tr>
<tr><td><code>Gyb</code></td>
<td>
<p>average of the expectation of y among friends.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>list of covariance matrices.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>step-by-step output as returned by the optimizer.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Houndetoungan, E. A. (2022). Count Data Models with Social Interactions under Rational Expectations. Available at SSRN 3721250, <a href="https://doi.org/10.2139/ssrn.3721250">doi:10.2139/ssrn.3721250</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sart">sart</a></code>, <code><a href="#topic+sar">sar</a></code>, <code><a href="#topic+simcdnet">simcdnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
# Groups' size
nvec   &lt;- rep(100, 2)
M      &lt;- length(nvec)
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
beta   &lt;- c(1.5, 2.2, -0.9)
gamma  &lt;- c(1.5, -1.2)
delta  &lt;- c(1, 0.87, 0.75, 0.6)
delbar &lt;- 0.05
rho    &lt;- 0.5
theta  &lt;- c(lambda, beta, gamma)

# X
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network
Glist  &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm/rs
  Glist[[m]]   &lt;- Gm
}


# data
data    &lt;- data.frame(x1 = X[,1], x2 =  X[,2])

ytmp    &lt;- simcdnet(formula = ~ x1 + x2 | x1 + x2, Glist = Glist, theta = theta,
                    deltabar = delbar, delta = delta, rho = rho, data = data)

y       &lt;- ytmp$y

# plot histogram
hist(y, breaks = max(y))

data    &lt;- data.frame(yt = y, x1 = data$x1, x2 = data$x2)
rm(list = ls()[!(ls() %in% c("Glist", "data"))])

out   &lt;- cdnet(formula = yt ~ x1 + x2, contextual = TRUE, Glist = Glist, 
               data = data, Rbar = 5, estim.rho = TRUE, optimizer = "nlm")
summary(out)
</code></pre>

<hr>
<h2 id='homophili.data'>Convert data between directed network models and symmetric network models.</h2><span id='topic+homophili.data'></span>

<h3>Description</h3>

<p><code>homophili.data</code> is used to convert the matrix of explanatory variables between directed network models and symmetric network models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homophili.data(data, nvec, to = c("lower", "upper", "symmetric"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homophili.data_+3A_data">data</code></td>
<td>
<p>is the <code>matrix</code> or <code>data.frame</code> of the explanatory variables of the network formation model. This
corresponds to the <code>X</code> matrix in <code><a href="#topic+homophily.fe">homophily.fe</a></code> or in <code><a href="#topic+homophily.re">homophily.re</a></code>.</p>
</td></tr>
<tr><td><code id="homophili.data_+3A_nvec">nvec</code></td>
<td>
<p>is a vector of the number of individuals in the networks.</p>
</td></tr>
<tr><td><code id="homophili.data_+3A_to">to</code></td>
<td>
<p>indicates the direction of the conversion. For a matrix of explanatory variable <code>X</code> (<code>n*(n-1)</code> rows), one can
can select lower triangular entries (<code>to = "lower"</code>) or upper triangular entries (<code style="white-space: pre;">&#8288;to = "upper&#8288;</code>).
For a triangular <code>X</code> (<code>n*(n-1)/2</code> rows), one can convert to a full matrix of <code>n*(n-1)</code> rows by using symmetry (<code>to = "symmetric"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the transformed <code>data.frame</code>.
</p>

<hr>
<h2 id='homophily.fe'>Estimate Network Formation Model with Degree Heterogeneity as Fixed Effects</h2><span id='topic+homophily.fe'></span>

<h3>Description</h3>

<p><code>homophily.fe</code> implements a Logit estimator for network formation model with homophily. The model includes degree heterogeneity as fixed effects (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homophily.fe(
  network,
  formula,
  data,
  symmetry = FALSE,
  fe.way = 1,
  init = NULL,
  opt.ctr = list(maxit = 10000, eps_f = 1e-09, eps_g = 1e-09),
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homophily.fe_+3A_network">network</code></td>
<td>
<p>matrix or list of sub-matrix of social interactions containing 0 and 1, where links are represented by 1</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_formula">formula</code></td>
<td>
<p>an object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be as for example <code>~ x1 + x2</code>
where <code>x1</code>, <code>x2</code> are explanatory variable of links formation. If missing, the model is estimated with fixed effects only.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>homophily</code> is called.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_symmetry">symmetry</code></td>
<td>
<p>indicates whether the network model is symmetric (see details).</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_fe.way">fe.way</code></td>
<td>
<p>indicates whether it is a one-way or two-way fixed effect model. The expected value is 1 or 2 (see details).</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_init">init</code></td>
<td>
<p>(optional) either a list of starting values containing <code>beta</code>, an K-dimensional vector of the explanatory variables parameter,
<code>mu</code> an n-dimensional vector, and <code>nu</code> an n-dimensional vector,
where K is the number of explanatory variables and n is the number of individuals; or a vector of starting value for <code>c(beta, mu, nu)</code>.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_opt.ctr">opt.ctr</code></td>
<td>
<p>(optional) is a list of <code>maxit</code>, <code>eps_f</code>, and <code>eps_g</code>, which are control parameters used by the solver <code>optim_lbfgs</code>, of the package <span class="pkg">RcppNumerical</span>.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_print">print</code></td>
<td>
<p>Boolean indicating if the estimation progression should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">p_{ij}</code> be a probability for a link to go from the individual <code class="reqn">i</code> to the individual <code class="reqn">j</code>.
This probability is specified for two-way effect models (<code>fe.way = 2</code>) as
</p>
<p style="text-align: center;"><code class="reqn">p_{ij} = F(\mathbf{x}_{ij}'\beta + \mu_j + \nu_j)</code>
</p>

<p>where <code class="reqn">F</code> is the cumulative of the standard logistic distribution. Unobserved degree heterogeneity is captured by
<code class="reqn">\mu_i</code> and <code class="reqn">\nu_j</code>. The latter are treated as fixed effects (see <code><a href="#topic+homophily.re">homophily.re</a></code> for random effect models).
As shown by Yan et al. (2019), the estimator of
the parameter <code class="reqn">\beta</code> is biased. A bias correction is then necessary and is not implemented in this version. However
the estimator of <code class="reqn">\mu_i</code> and <code class="reqn">\nu_j</code> are consistent.<br />
For one-way fixed effect models (<code>fe.way = 1</code>), <code class="reqn">\nu_j = \mu_j</code>. For symmetric models, the network is not directed and the
fixed effects need to be one way.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>model.info</code></td>
<td>
<p>list of model information, such as the type of fixed effects, whether the model is symmetric,
number of observations, etc.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>maximizer of the log-likelihood.</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>maximized log-likelihood.</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>returned value of the optimization solver, which contains details of the optimization. The solver used is <code>optim_lbfgs</code> of the
package <span class="pkg">RcppNumerical</span>.</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>returned list of starting value.</p>
</td></tr>
<tr><td><code>loglike(init)</code></td>
<td>
<p>log-likelihood at the starting value.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Yan, T., Jiang, B., Fienberg, S. E., &amp; Leng, C. (2019). Statistical inference in a directed network model with covariates. <em>Journal of the American Statistical Association</em>, 114(526), 857-868, <a href="https://doi.org/10.1080/01621459.2018.1448829">doi:10.1080/01621459.2018.1448829</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+homophily.re">homophily.re</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
M            &lt;- 2 # Number of sub-groups
nvec         &lt;- round(runif(M, 20, 50))
beta         &lt;- c(.1, -.1)
Glist        &lt;- list()
dX           &lt;- matrix(0, 0, 2)
mu           &lt;- list()
nu           &lt;- list()
Emunu        &lt;- runif(M, -1.5, 0) #expectation of mu + nu
smu2         &lt;- 0.2
snu2         &lt;- 0.2
for (m in 1:M) {
  n          &lt;- nvec[m]
  mum        &lt;- rnorm(n, 0.7*Emunu[m], smu2)
  num        &lt;- rnorm(n, 0.3*Emunu[m], snu2)
  X1         &lt;- rnorm(n, 0, 1)
  X2         &lt;- rbinom(n, 1, 0.2)
  Z1         &lt;- matrix(0, n, n)  
  Z2         &lt;- matrix(0, n, n)
  
  for (i in 1:n) {
    for (j in 1:n) {
      Z1[i, j] &lt;- abs(X1[i] - X1[j])
      Z2[i, j] &lt;- 1*(X2[i] == X2[j])
    }
  }
  
  Gm           &lt;- 1*((Z1*beta[1] + Z2*beta[2] +
                       kronecker(mum, t(num), "+") + rlogis(n^2)) &gt; 0)
  diag(Gm)     &lt;- 0
  diag(Z1)     &lt;- NA
  diag(Z2)     &lt;- NA
  Z1           &lt;- Z1[!is.na(Z1)]
  Z2           &lt;- Z2[!is.na(Z2)]
  
  dX           &lt;- rbind(dX, cbind(Z1, Z2))
  Glist[[m]]   &lt;- Gm
  mu[[m]]      &lt;- mum
  nu[[m]]      &lt;- num
}

mu  &lt;- unlist(mu)
nu  &lt;- unlist(nu)

out   &lt;- homophily.fe(network =  Glist, formula = ~ -1 + dX, fe.way = 2)
muhat &lt;- out$estimate$mu
nuhat &lt;- out$estimate$nu
plot(mu, muhat)
plot(nu, nuhat)

</code></pre>

<hr>
<h2 id='homophily.re'>Estimate Network Formation Model with Degree Heterogeneity as Random Effects</h2><span id='topic+homophily.re'></span>

<h3>Description</h3>

<p><code>homophily.re</code> implements a Bayesian Probit estimator for network formation model with homophily. The model includes degree heterogeneity as random effects (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homophily.re(
  network,
  formula,
  data,
  symmetry = FALSE,
  group.fe = FALSE,
  re.way = 1,
  init = list(),
  iteration = 1000,
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homophily.re_+3A_network">network</code></td>
<td>
<p>matrix or list of sub-matrix of social interactions containing 0 and 1, where links are represented by 1.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_formula">formula</code></td>
<td>
<p>an object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be as for example <code>~ x1 + x2</code>
where <code>x1</code>, <code>x2</code> are explanatory variable of links formation.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>homophily</code> is called.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_symmetry">symmetry</code></td>
<td>
<p>indicates whether the network model is symmetric (see details).</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_group.fe">group.fe</code></td>
<td>
<p>indicates whether the model includes group fixed effects.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_re.way">re.way</code></td>
<td>
<p>indicates whether it is a one-way or two-way fixed effect model. The expected value is 1 or 2 (see details).</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_init">init</code></td>
<td>
<p>(optional) list of starting values containing <code>beta</code>, an K-dimensional vector of the explanatory variables parameter,
<code>mu</code> an n-dimensional vector, and <code>nu</code> an n-dimensional vector, <code>smu2</code> the variance of <code>mu</code>,
and <code>snu2</code> the variance of <code>nu</code>,
where K is the number of explanatory variables and n is the number of individuals.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_iteration">iteration</code></td>
<td>
<p>the number of iterations to be performed.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_print">print</code></td>
<td>
<p>boolean indicating if the estimation progression should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">p_{ij}</code> be a probability for a link to go from the individual <code class="reqn">i</code> to the individual <code class="reqn">j</code>.
This probability is specified for two-way effect models (<code>fe.way = 2</code>) as
</p>
<p style="text-align: center;"><code class="reqn">p_{ij} = F(\mathbf{x}_{ij}'\beta + \mu_j + \nu_j)</code>
</p>

<p>where <code class="reqn">F</code> is the cumulative of the standard normal distribution. Unobserved degree heterogeneity is captured by
<code class="reqn">\mu_i</code> and <code class="reqn">\nu_j</code>. The latter are treated as random effects (see <code><a href="#topic+homophily.fe">homophily.fe</a></code> for fixed effect models).<br />
For one-way random effect models (<code>fe.way = 1</code>), <code class="reqn">\nu_j = \mu_j</code>. For symmetric models, the network is not directed and the
random effects need to be one way.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>model.info</code></td>
<td>
<p>list of model information, such as the type of random effects, whether the model is symmetric,
number of observations, etc.</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>list of simulations from the posterior distribution.</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>returned list of starting values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+homophily.fe">homophily.fe</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
library(MASS)
M            &lt;- 4 # Number of sub-groups
nvec         &lt;- round(runif(M, 100, 500))
beta         &lt;- c(.1, -.1)
Glist        &lt;- list()
dX           &lt;- matrix(0, 0, 2)
mu           &lt;- list()
nu           &lt;- list()
cst          &lt;- runif(M, -1.5, 0)
smu2         &lt;- 0.2
snu2         &lt;- 0.2
rho          &lt;- 0.8
Smunu        &lt;- matrix(c(smu2, rho*sqrt(smu2*snu2), rho*sqrt(smu2*snu2), snu2), 2)
for (m in 1:M) {
  n          &lt;- nvec[m]
  tmp        &lt;- mvrnorm(n, c(0, 0), Smunu)
  mum        &lt;- tmp[,1] - mean(tmp[,1])
  num        &lt;- tmp[,2] - mean(tmp[,2])
  X1         &lt;- rnorm(n, 0, 1)
  X2         &lt;- rbinom(n, 1, 0.2)
  Z1         &lt;- matrix(0, n, n)  
  Z2         &lt;- matrix(0, n, n)
  
  for (i in 1:n) {
    for (j in 1:n) {
      Z1[i, j] &lt;- abs(X1[i] - X1[j])
      Z2[i, j] &lt;- 1*(X2[i] == X2[j])
    }
  }
  
  Gm           &lt;- 1*((cst[m] + Z1*beta[1] + Z2*beta[2] +
                       kronecker(mum, t(num), "+") + rnorm(n^2)) &gt; 0)
  diag(Gm)     &lt;- 0
  diag(Z1)     &lt;- NA
  diag(Z2)     &lt;- NA
  Z1           &lt;- Z1[!is.na(Z1)]
  Z2           &lt;- Z2[!is.na(Z2)]
  
  dX           &lt;- rbind(dX, cbind(Z1, Z2))
  Glist[[m]]   &lt;- Gm
  mu[[m]]      &lt;- mum
  nu[[m]]      &lt;- num
}

mu  &lt;- unlist(mu)
nu  &lt;- unlist(nu)

out   &lt;- homophily.re(network =  Glist, formula = ~ dX, group.fe = TRUE, 
                      re.way = 2, iteration = 1e3)

# plot simulations
plot(out$posterior$beta[,1], type = "l")
abline(h = cst[1], col = "red")
plot(out$posterior$beta[,2], type = "l")
abline(h = cst[2], col = "red")
plot(out$posterior$beta[,3], type = "l")
abline(h = cst[3], col = "red")
plot(out$posterior$beta[,4], type = "l")
abline(h = cst[4], col = "red")

plot(out$posterior$beta[,5], type = "l")
abline(h = beta[1], col = "red")
plot(out$posterior$beta[,6], type = "l")
abline(h = beta[2], col = "red")

plot(out$posterior$sigma2_mu, type = "l")
abline(h = smu2, col = "red")
plot(out$posterior$sigma2_nu, type = "l")
abline(h = snu2, col = "red")
plot(out$posterior$rho, type = "l")
abline(h = rho, col = "red")

i &lt;- 10
plot(out$posterior$mu[,i], type = "l")
abline(h = mu[i], col = "red")
plot(out$posterior$nu[,i], type = "l")
abline(h = nu[i], col = "red")

</code></pre>

<hr>
<h2 id='sar'>Estimate SAR model</h2><span id='topic+sar'></span>

<h3>Description</h3>

<p><code>sar</code> is used to estimate peer effects continuous variables (see details). The model is presented in Lee(2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar(
  formula,
  contextual,
  Glist,
  lambda0 = NULL,
  fixed.effects = FALSE,
  optimizer = "optim",
  opt.ctr = list(),
  print = TRUE,
  cov = TRUE,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sar_+3A_formula">formula</code></td>
<td>
<p>an object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be as for example <code>y ~ x1 + x2 | x1 + x2</code>
where <code>y</code> is the endogenous vector, the listed variables before the pipe, <code>x1</code>, <code>x2</code> are the individual exogenous variables and
the listed variables after the pipe, <code>x1</code>, <code>x2</code> are the contextual observable variables. Other formulas may be
<code>y ~ x1 + x2</code> for the model without contextual effects, <code>y ~ -1 + x1 + x2 | x1 + x2</code> for the model
without intercept or <code> y ~ x1 + x2 | x2 + x3</code> to allow the contextual variable to be different from the individual variables.</p>
</td></tr>
<tr><td><code id="sar_+3A_contextual">contextual</code></td>
<td>
<p>(optional) logical; if true, this means that all individual variables will be set as contextual variables. Set the
<code>formula</code> as <code>y ~ x1 + x2</code> and <code>contextual</code> as <code>TRUE</code> is equivalent to set the formula as <code>y ~ x1 + x2 | x1 + x2</code>.</p>
</td></tr>
<tr><td><code id="sar_+3A_glist">Glist</code></td>
<td>
<p>the adjacency matrix or list sub-adjacency matrix.</p>
</td></tr>
<tr><td><code id="sar_+3A_lambda0">lambda0</code></td>
<td>
<p>(optional) starting value of <code class="reqn">\lambda</code>. The parameter <code class="reqn">\gamma</code> should be removed if the model
does not contain contextual effects (see details).</p>
</td></tr>
<tr><td><code id="sar_+3A_fixed.effects">fixed.effects</code></td>
<td>
<p>logical; if true, group heterogeneity is included as fixed effects.</p>
</td></tr>
<tr><td><code id="sar_+3A_optimizer">optimizer</code></td>
<td>
<p>is either <code>nlm</code> (referring to the function <a href="stats.html#topic+nlm">nlm</a>) or <code>optim</code> (referring to the function <a href="stats.html#topic+optim">optim</a>).
Other arguments
of these functions such as, the control values and the method can be defined through the argument <code>opt.ctr</code>.</p>
</td></tr>
<tr><td><code id="sar_+3A_opt.ctr">opt.ctr</code></td>
<td>
<p>list of arguments of <a href="stats.html#topic+nlm">nlm</a> or <a href="stats.html#topic+optim">optim</a> (the one set in <code>optimizer</code>) such as control, method, ...</p>
</td></tr>
<tr><td><code id="sar_+3A_print">print</code></td>
<td>
<p>a Boolean indicating if the estimate should be printed at each step.</p>
</td></tr>
<tr><td><code id="sar_+3A_cov">cov</code></td>
<td>
<p>a Boolean indicating if the covariance should be computed.</p>
</td></tr>
<tr><td><code id="sar_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>mcmcARD</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Model</h4>

<p>The variable <code class="reqn">\mathbf{y}</code> is given for all i as
</p>
<p style="text-align: center;"><code class="reqn">y_i = \lambda \mathbf{g}_i y + \mathbf{x}_i'\beta + \mathbf{g}_i\mathbf{X}\gamma + \epsilon_i,</code>
</p>

<p>where <code class="reqn">\epsilon_i \sim N(0, \sigma^2)</code>.
</p>



<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>info</code></td>
<td>
<p>list of general information on the model.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Maximum Likelihood (ML) estimator.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>covariance matrix of the estimate.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>outputs as returned by the optimizer.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lee, L. F. (2004). Asymptotic distributions of quasi-maximum likelihood estimators for spatial autoregressive models. <em>Econometrica</em>, 72(6), 1899-1925, <a href="https://doi.org/10.1111/j.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sart">sart</a></code>, <code><a href="#topic+cdnet">cdnet</a></code>, <code><a href="#topic+simsar">simsar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Groups' size
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 1000))
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
beta   &lt;- c(2, -1.9, 0.8)
gamma  &lt;- c(1.5, -1.2)
sigma  &lt;- 1.5
theta  &lt;- c(lambda, beta, gamma, sigma)

# X
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network
Glist  &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm/rs
  Glist[[m]]   &lt;- Gm
}


# data
data    &lt;- data.frame(x1 = X[,1], x2 =  X[,2])

rm(list = ls()[!(ls() %in% c("Glist", "data", "theta"))])

ytmp    &lt;- simsar(formula = ~ x1 + x2 | x1 + x2, Glist = Glist,
                  theta = theta, data = data) 

y       &lt;- ytmp$y

# plot histogram
hist(y, breaks = max(y))

data    &lt;- data.frame(yt = y, x1 = data$x1, x2 = data$x2)
rm(list = ls()[!(ls() %in% c("Glist", "data"))])

out     &lt;- sar(formula = yt ~ x1 + x2, contextual = TRUE, 
                 Glist = Glist, optimizer = "optim", data = data)
summary(out)

</code></pre>

<hr>
<h2 id='sart'>Estimate sart model</h2><span id='topic+sart'></span>

<h3>Description</h3>

<p><code>sart</code> is used to estimate peer effects on censored data (see details). The model is presented in Xu and Lee(2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sart(
  formula,
  contextual,
  Glist,
  theta0 = NULL,
  yb0 = NULL,
  optimizer = "fastlbfgs",
  npl.ctr = list(),
  opt.ctr = list(),
  print = TRUE,
  cov = TRUE,
  RE = FALSE,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sart_+3A_formula">formula</code></td>
<td>
<p>an object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be as for example <code>y ~ x1 + x2 | x1 + x2</code>
where <code>y</code> is the endogenous vector, the listed variables before the pipe, <code>x1</code>, <code>x2</code> are the individual exogenous variables and
the listed variables after the pipe, <code>x1</code>, <code>x2</code> are the contextual observable variables. Other formulas may be
<code>y ~ x1 + x2</code> for the model without contextual effects, <code>y ~ -1 + x1 + x2 | x1 + x2</code> for the model
without intercept or <code> y ~ x1 + x2 | x2 + x3</code> to allow the contextual variable to be different from the individual variables.</p>
</td></tr>
<tr><td><code id="sart_+3A_contextual">contextual</code></td>
<td>
<p>(optional) logical; if true, this means that all individual variables will be set as contextual variables. Set the
<code>formula</code> as <code>y ~ x1 + x2</code> and <code>contextual</code> as <code>TRUE</code> is equivalent to set the formula as <code>y ~ x1 + x2 | x1 + x2</code>.</p>
</td></tr>
<tr><td><code id="sart_+3A_glist">Glist</code></td>
<td>
<p>the adjacency matrix or list sub-adjacency matrix.</p>
</td></tr>
<tr><td><code id="sart_+3A_theta0">theta0</code></td>
<td>
<p>(optional) starting value of <code class="reqn">\theta = (\lambda, \beta, \gamma, \sigma)</code>. The parameter <code class="reqn">\gamma</code> should be removed if the model
does not contain contextual effects (see details).</p>
</td></tr>
<tr><td><code id="sart_+3A_yb0">yb0</code></td>
<td>
<p>(optional) expectation of y.</p>
</td></tr>
<tr><td><code id="sart_+3A_optimizer">optimizer</code></td>
<td>
<p>is either <code>fastlbfgs</code> (L-BFGS optimization method of the package <span class="pkg">RcppNumerical</span>), <code>nlm</code> (referring to the function <a href="stats.html#topic+nlm">nlm</a>), or <code>optim</code> (referring to the function <a href="stats.html#topic+optim">optim</a>).
Other arguments
of these functions such as, <code>control</code> and <code>method</code> can be defined through the argument <code>opt.ctr</code>.</p>
</td></tr>
<tr><td><code id="sart_+3A_npl.ctr">npl.ctr</code></td>
<td>
<p>list of controls for the NPL method (see <code><a href="#topic+cdnet">cdnet</a></code>).</p>
</td></tr>
<tr><td><code id="sart_+3A_opt.ctr">opt.ctr</code></td>
<td>
<p>list of arguments to be passed in <code>optim_lbfgs</code> of the package <span class="pkg">RcppNumerical</span>, <a href="stats.html#topic+nlm">nlm</a> or <a href="stats.html#topic+optim">optim</a> (the solver set in <code>optimizer</code>), such as <code>maxit</code>, <code>eps_f</code>, <code>eps_g</code>, <code>control</code>, <code>method</code>, ...</p>
</td></tr>
<tr><td><code id="sart_+3A_print">print</code></td>
<td>
<p>a Boolean indicating if the estimate should be printed at each step.</p>
</td></tr>
<tr><td><code id="sart_+3A_cov">cov</code></td>
<td>
<p>a Boolean indicating if the covariance should be computed.</p>
</td></tr>
<tr><td><code id="sart_+3A_re">RE</code></td>
<td>
<p>a Boolean which indicates if the model if under rational expectation of not.</p>
</td></tr>
<tr><td><code id="sart_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>sart</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Model</h4>

<p>The left-censored variable <code class="reqn">\mathbf{y}</code> is generated from a latent variable <code class="reqn">\mathbf{y}^*</code>.
The latent variable is given for all i as
</p>
<p style="text-align: center;"><code class="reqn">y_i^* = \lambda \mathbf{g}_i y + \mathbf{x}_i'\beta + \mathbf{g}_i\mathbf{X}\gamma + \epsilon_i,</code>
</p>

<p>where <code class="reqn">\epsilon_i \sim N(0, \sigma^2)</code>.<br />
The count variable <code class="reqn">y_i</code> is then define that is <code class="reqn">y_i = 0</code> if
<code class="reqn">y_i^* \leq 0</code> and <code class="reqn">y_i = y_i^*</code> otherwise.
</p>



<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>info</code></td>
<td>
<p>list of general information on the model.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Maximum Likelihood (ML) estimator.</p>
</td></tr>
<tr><td><code>yb</code></td>
<td>
<p>ybar (see details), expectation of y.</p>
</td></tr>
<tr><td><code>Gyb</code></td>
<td>
<p>average of the expectation of y among friends.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>List of covariances.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>outputs as returned by the optimizer.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Xu, X., &amp; Lee, L. F. (2015). Maximum likelihood estimation of a spatial autoregressive Tobit model. <em>Journal of Econometrics</em>, 188(1), 264-280, <a href="https://doi.org/10.1016/j.jeconom.2015.05.004">doi:10.1016/j.jeconom.2015.05.004</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sar">sar</a></code>, <code><a href="#topic+cdnet">cdnet</a></code>, <code><a href="#topic+simsart">simsart</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Groups' size
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 1000))
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
beta   &lt;- c(2, -1.9, 0.8)
gamma  &lt;- c(1.5, -1.2)
sigma  &lt;- 1.5
theta  &lt;- c(lambda, beta, gamma, sigma)

# X
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network
Glist  &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm/rs
  Glist[[m]]   &lt;- Gm
}


# data
data    &lt;- data.frame(x1 = X[,1], x2 =  X[,2])

rm(list = ls()[!(ls() %in% c("Glist", "data", "theta"))])

ytmp    &lt;- simsart(formula = ~ x1 + x2 | x1 + x2, Glist = Glist,
                   theta = theta, data = data)

y       &lt;- ytmp$y

# plot histogram
hist(y)

opt.ctr &lt;- list(method  = "Nelder-Mead", 
                control = list(abstol = 1e-16, abstol = 1e-11, maxit = 5e3))
data    &lt;- data.frame(yt = y, x1 = data$x1, x2 = data$x2)
rm(list = ls()[!(ls() %in% c("Glist", "data"))])

out     &lt;- sart(formula = yt ~ x1 + x2, optimizer = "nlm",
                  contextual = TRUE, Glist = Glist, data = data)
summary(out)

</code></pre>

<hr>
<h2 id='simcdnet'>Simulate data from Count Data Model with Social Interactions</h2><span id='topic+simcdnet'></span>

<h3>Description</h3>

<p><code>simcdnet</code> is used simulate counting data with rational expectations (see details). The model is presented in Houndetoungan (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simcdnet(
  formula,
  contextual,
  Glist,
  theta,
  deltabar,
  delta = NULL,
  rho = 0,
  tol = 1e-10,
  maxit = 500,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simcdnet_+3A_formula">formula</code></td>
<td>
<p>an object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be as for example <code>y ~ x1 + x2 | x1 + x2</code>
where <code>y</code> is the endogenous vector, the listed variables before the pipe, <code>x1</code>, <code>x2</code> are the individual exogenous variables and
the listed variables after the pipe, <code>x1</code>, <code>x2</code> are the contextual observable variables. Other formulas may be
<code>y ~ x1 + x2</code> for the model without contextual effects, <code>y ~ -1 + x1 + x2 | x1 + x2</code> for the model
without intercept or <code>y ~ x1 + x2 | x2 + x3</code> to allow the contextual variable to be different from the individual variables.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_contextual">contextual</code></td>
<td>
<p>(optional) logical; if true, this means that all individual variables will be set as contextual variables. Set the
<code>formula</code> as <code>y ~ x1 + x2</code> and <code>contextual</code> as <code>TRUE</code> is equivalent to set the formula as <code>y ~ x1 + x2 | x1 + x2</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_glist">Glist</code></td>
<td>
<p>the adjacency matrix or list sub-adjacency matrix.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_theta">theta</code></td>
<td>
<p>the true value of the vector <code class="reqn">\theta = (\lambda, \beta', \gamma')'</code>. The parameter <code class="reqn">\gamma</code> should be removed if the model
does not contain contextual effects (see details).</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_deltabar">deltabar</code></td>
<td>
<p>the true value of <code class="reqn">\bar{\delta}</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_delta">delta</code></td>
<td>
<p>the true value of the vector <code class="reqn">\delta = (\delta_2, ..., \delta_{\bar{R}})</code>. If <code>NULL</code>, then <code class="reqn">\bar{R}</code> is set to one and <code>delta</code> is empty.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_rho">rho</code></td>
<td>
<p>the true value of <code class="reqn">\rho</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_tol">tol</code></td>
<td>
<p>the tolerance value used in the Fixed Point Iteration Method to compute the expectancy of <code>y</code>. The process stops if the <code class="reqn">L_1</code> distance
between two consecutive values of the expectancy of <code>y</code> is less than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_maxit">maxit</code></td>
<td>
<p>the maximal number of iterations in the Fixed Point Iteration Method.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>mcmcARD</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following Houndetoungan (2022), the count data <code class="reqn">\mathbf{y}</code> is generated from a latent variable <code class="reqn">\mathbf{y}^*</code>.
The latent variable is given for all i as
</p>
<p style="text-align: center;"><code class="reqn">y_i^* = \lambda \mathbf{g}_i \mathbf{E}(\bar{\mathbf{y}}|\mathbf{X},\mathbf{G})  + \mathbf{x}_i'\beta + \mathbf{g}_i\mathbf{X}\gamma + \epsilon_i,</code>
</p>

<p>where <code class="reqn">\epsilon_i \sim N(0, 1)</code>.<br />
Then, <code class="reqn">y_i = r</code> iff <code class="reqn">a_r \leq y_i^* \leq a_{r+1}</code>, where
<code class="reqn">a_0 = -\inf</code>, <code class="reqn">a_1 = 0</code>, <code class="reqn">a_r = \sum_{k = 1}^r\delta_k</code>.
The parameter are subject to the constraints <code class="reqn">\delta_r \geq \lambda</code> if <code class="reqn">1 \leq r \leq \bar{R}</code>,  and
<code class="reqn">\delta_r = (r - \bar{R})^{\rho}\bar{\delta} + \lambda</code> if <code class="reqn">r \geq \bar{R} + 1</code>.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>yst</code></td>
<td>
<p>ys (see details), the latent variable.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the observed count data.</p>
</td></tr>
<tr><td><code>yb</code></td>
<td>
<p>ybar (see details), the expectation of y.</p>
</td></tr>
<tr><td><code>Gyb</code></td>
<td>
<p>the average of the expectation of y among friends.</p>
</td></tr>
<tr><td><code>marg.effects</code></td>
<td>
<p>the marginal effects.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>the return value of rho.</p>
</td></tr>
<tr><td><code>Rmax</code></td>
<td>
<p>infinite sums in the marginal effects are approximated by sums up to Rmax.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>number of iterations performed by sub-network in the Fixed Point Iteration Method.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Houndetoungan, E. A. (2022). Count Data Models with Social Interactions under Rational Expectations. Available at SSRN 3721250, <a href="https://doi.org/10.2139/ssrn.3721250">doi:10.2139/ssrn.3721250</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cdnet">cdnet</a></code>, <code><a href="#topic+simsart">simsart</a></code>, <code><a href="#topic+simsar">simsar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Groups' size
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 1000))
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
beta   &lt;- c(1.5, 2.2, -0.9)
gamma  &lt;- c(1.5, -1.2)
delta  &lt;- c(1, 0.87, 0.75, 0.6)
delbar &lt;- 0.05
theta  &lt;- c(lambda, beta, gamma)

# X
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network
Glist  &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm/rs
  Glist[[m]]   &lt;- Gm
}


# data
data    &lt;- data.frame(x1 = X[,1], x2 =  X[,2])

rm(list = ls()[!(ls() %in% c("Glist", "data", "theta", "delta", "delbar"))])

ytmp    &lt;- simcdnet(formula = ~ x1 + x2 | x1 + x2, Glist = Glist, theta = theta, 
                    deltabar = delbar, delta = delta, rho = 0, data = data)

y       &lt;- ytmp$y

# plot histogram
hist(y, breaks = max(y))
</code></pre>

<hr>
<h2 id='simsar'>Simulate data from the linear-in-mean Model with Social Interactions</h2><span id='topic+simsar'></span>

<h3>Description</h3>

<p><code>simsar</code> is used to simulate continuous variables with social interactions (see details). The model is presented in Lee(2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simsar(formula, contextual, Glist, theta, RE = FALSE, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simsar_+3A_formula">formula</code></td>
<td>
<p>an object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be as for example <code>y ~ x1 + x2 | x1 + x2</code>
where <code>y</code> is the endogenous vector, the listed variables before the pipe, <code>x1</code>, <code>x2</code> are the individual exogenous variables and
the listed variables after the pipe, <code>x1</code>, <code>x2</code> are the contextual observable variables. Other formulas may be
<code>y ~ x1 + x2</code> for the model without contextual effects, <code>y ~ -1 + x1 + x2 | x1 + x2</code> for the model
without intercept or <code>y ~ x1 + x2 | x2 + x3</code> to allow the contextual variable to be different from the individual variables.</p>
</td></tr>
<tr><td><code id="simsar_+3A_contextual">contextual</code></td>
<td>
<p>(optional) logical; if true, this means that all individual variables will be set as contextual variables. Set the
<code>formula</code> as <code>y ~ x1 + x2</code> and <code>contextual</code> as <code>TRUE</code> is equivalent to set the formula as <code>y ~ x1 + x2 | x1 + x2</code>.</p>
</td></tr>
<tr><td><code id="simsar_+3A_glist">Glist</code></td>
<td>
<p>the adjacency matrix or list sub-adjacency matrix.</p>
</td></tr>
<tr><td><code id="simsar_+3A_theta">theta</code></td>
<td>
<p>the parameter value as <code class="reqn">\theta = (\lambda, \beta, \gamma, \sigma)</code>. The parameter <code class="reqn">\gamma</code> should be removed if the model
does not contain contextual effects (see details).</p>
</td></tr>
<tr><td><code id="simsar_+3A_re">RE</code></td>
<td>
<p>a Boolean which indicates if the model if under rational expectation of not.</p>
</td></tr>
<tr><td><code id="simsar_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>mcmcARD</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable <code class="reqn">\mathbf{y}</code> is given for all i as
</p>
<p style="text-align: center;"><code class="reqn">y_i = \lambda \mathbf{g}_i y + \mathbf{x}_i'\beta + \mathbf{g}_i\mathbf{X}\gamma + \epsilon_i,</code>
</p>

<p>where <code class="reqn">\epsilon_i \sim N(0, \sigma^2)</code>.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>the observed count data.</p>
</td></tr>
<tr><td><code>Gy</code></td>
<td>
<p>the average of y among friends.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lee, L. F. (2004). Asymptotic distributions of quasi-maximum likelihood estimators for spatial autoregressive models. <em>Econometrica</em>, 72(6), 1899-1925, <a href="https://doi.org/10.1111/j.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sar">sar</a></code>, <code><a href="#topic+simsart">simsart</a></code>, <code><a href="#topic+simcdnet">simcdnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Groups' size
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 1000))
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
beta   &lt;- c(2, -1.9, 0.8)
gamma  &lt;- c(1.5, -1.2)
sigma  &lt;- 1.5
theta  &lt;- c(lambda, beta, gamma, sigma)

# X
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network
Glist  &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm/rs
  Glist[[m]]   &lt;- Gm
}


# data
data    &lt;- data.frame(x1 = X[,1], x2 =  X[,2])

rm(list = ls()[!(ls() %in% c("Glist", "data", "theta"))])

ytmp    &lt;- simsar(formula = ~ x1 + x2 | x1 + x2, Glist = Glist,
                     theta = theta, data = data) 
y       &lt;- ytmp$y

# plot histogram
hist(y)

</code></pre>

<hr>
<h2 id='simsart'>Simulate data from the Tobit Model with Social Interactions</h2><span id='topic+simsart'></span>

<h3>Description</h3>

<p><code>simsart</code> is used to simulate censored data with social interactions (see details). The model is presented in Xu and Lee(2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simsart(
  formula,
  contextual,
  Glist,
  theta,
  tol = 1e-15,
  maxit = 500,
  RE = FALSE,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simsart_+3A_formula">formula</code></td>
<td>
<p>an object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be as for example <code>y ~ x1 + x2 | x1 + x2</code>
where <code>y</code> is the endogenous vector, the listed variables before the pipe, <code>x1</code>, <code>x2</code> are the individual exogenous variables and
the listed variables after the pipe, <code>x1</code>, <code>x2</code> are the contextual observable variables. Other formulas may be
<code>y ~ x1 + x2</code> for the model without contextual effects, <code>y ~ -1 + x1 + x2 | x1 + x2</code> for the model
without intercept or <code>y ~ x1 + x2 | x2 + x3</code> to allow the contextual variable to be different from the individual variables.</p>
</td></tr>
<tr><td><code id="simsart_+3A_contextual">contextual</code></td>
<td>
<p>(optional) logical; if true, this means that all individual variables will be set as contextual variables. Set the
<code>formula</code> as <code>y ~ x1 + x2</code> and <code>contextual</code> as <code>TRUE</code> is equivalent to set the formula as <code>y ~ x1 + x2 | x1 + x2</code>.</p>
</td></tr>
<tr><td><code id="simsart_+3A_glist">Glist</code></td>
<td>
<p>the adjacency matrix or list sub-adjacency matrix.</p>
</td></tr>
<tr><td><code id="simsart_+3A_theta">theta</code></td>
<td>
<p>the parameter value as <code class="reqn">\theta = (\lambda, \beta, \gamma, \sigma)</code>. The parameter <code class="reqn">\gamma</code> should be removed if the model
does not contain contextual effects (see details).</p>
</td></tr>
<tr><td><code id="simsart_+3A_tol">tol</code></td>
<td>
<p>the tolerance value used in the Fixed Point Iteration Method to compute <code>y</code>. The process stops if the <code class="reqn">L_1</code> distance
between two consecutive values of <code>y</code> is less than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="simsart_+3A_maxit">maxit</code></td>
<td>
<p>the maximal number of iterations in the Fixed Point Iteration Method.</p>
</td></tr>
<tr><td><code id="simsart_+3A_re">RE</code></td>
<td>
<p>a Boolean which indicates if the model if under rational expectation of not.</p>
</td></tr>
<tr><td><code id="simsart_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>mcmcARD</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The left-censored variable <code class="reqn">\mathbf{y}</code> is generated from a latent variable <code class="reqn">\mathbf{y}^*</code>.
The latent variable is given for all i as
</p>
<p style="text-align: center;"><code class="reqn">y_i^* = \lambda \mathbf{g}_i y + \mathbf{x}_i'\beta + \mathbf{g}_i\mathbf{X}\gamma + \epsilon_i,</code>
</p>

<p>where <code class="reqn">\epsilon_i \sim N(0, \sigma^2)</code>.<br />
The censored variable <code class="reqn">y_i</code> is then define that is <code class="reqn">y_i = 0</code> if
<code class="reqn">y_i^* \leq 0</code> and <code class="reqn">y_i = y_i^*</code> otherwise.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>yst</code></td>
<td>
<p>ys (see details), the latent variable.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the censored variable.</p>
</td></tr>
<tr><td><code>yb</code></td>
<td>
<p>expectation of y under rational expectation.</p>
</td></tr>
<tr><td><code>Gy</code></td>
<td>
<p>the average of y among friends.</p>
</td></tr>
<tr><td><code>Gyb</code></td>
<td>
<p>Average of expectation of y among friends under rational expectation.</p>
</td></tr>
<tr><td><code>marg.effects</code></td>
<td>
<p>the marginal effects.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>number of iterations performed by sub-network in the Fixed Point Iteration Method.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Xu, X., &amp; Lee, L. F. (2015). Maximum likelihood estimation of a spatial autoregressive Tobit model. <em>Journal of Econometrics</em>, 188(1), 264-280, <a href="https://doi.org/10.1016/j.jeconom.2015.05.004">doi:10.1016/j.jeconom.2015.05.004</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sart">sart</a></code>, <code><a href="#topic+simsar">simsar</a></code>, <code><a href="#topic+simcdnet">simcdnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Groups' size
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 1000))
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
beta   &lt;- c(2, -1.9, 0.8)
gamma  &lt;- c(1.5, -1.2)
sigma  &lt;- 1.5
theta  &lt;- c(lambda, beta, gamma, sigma)

# X
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network
Glist  &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm/rs
  Glist[[m]]   &lt;- Gm
}


# data
data    &lt;- data.frame(x1 = X[,1], x2 =  X[,2])

rm(list = ls()[!(ls() %in% c("Glist", "data", "theta"))])

ytmp    &lt;- simsart(formula = ~ x1 + x2 | x1 + x2, Glist = Glist,
                   theta = theta, data = data)

y       &lt;- ytmp$y

# plot histogram
hist(y)

</code></pre>

<hr>
<h2 id='summary.cdnet'>Summarize Count Data Model with Social Interactions</h2><span id='topic+summary.cdnet'></span><span id='topic+print.summary.cdnet'></span><span id='topic+print.cdnet'></span><span id='topic+summary.cdnets'></span><span id='topic+print.summary.cdnets'></span><span id='topic+print.cdnets'></span>

<h3>Description</h3>

<p>Summary and print methods for the class <code>cdnet</code> as returned by the function <a href="#topic+cdnet">cdnet</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cdnet'
summary(object, Glist, data, S = 1000L, ...)

## S3 method for class 'summary.cdnet'
print(x, ...)

## S3 method for class 'cdnet'
print(x, ...)

## S3 method for class 'cdnets'
summary(object, ...)

## S3 method for class 'summary.cdnets'
print(x, ...)

## S3 method for class 'cdnets'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cdnet_+3A_object">object</code></td>
<td>
<p>an object of class <code>cdnet</code>, output of the function <code><a href="#topic+cdnet">cdnet</a></code>.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_glist">Glist</code></td>
<td>
<p>adjacency matrix or list sub-adjacency matrix. This is not necessary if the covariance method was computed in <a href="#topic+cdnet">cdnet</a>.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_data">data</code></td>
<td>
<p>a <code>dataframe</code> containing the explanatory variables. This is not necessary if the covariance method was computed in <a href="#topic+cdnet">cdnet</a>.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_s">S</code></td>
<td>
<p>number of simulation to be used to compute integral in the covariance by important sampling.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.cdnet</code>, output of the function <code><a href="#topic+summary.cdnet">summary.cdnet</a></code>,
class <code>summary.cdnets</code>, list of outputs of the function <code><a href="#topic+summary.cdnet">summary.cdnet</a></code>
(when the model is estimated many times to control for the endogeneity)
or class <code>cdnet</code> of the function <code><a href="#topic+cdnet">cdnet</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same objects in <code>object</code>.
</p>

<hr>
<h2 id='summary.sar'>Summarize SAR Model</h2><span id='topic+summary.sar'></span><span id='topic+print.summary.sar'></span><span id='topic+print.sar'></span><span id='topic+summary.sars'></span><span id='topic+print.summary.sars'></span><span id='topic+print.sars'></span>

<h3>Description</h3>

<p>Summary and print methods for the class <code>sar</code> as returned by the function <a href="#topic+sar">sar</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sar'
summary(object, ...)

## S3 method for class 'summary.sar'
print(x, ...)

## S3 method for class 'sar'
print(x, ...)

## S3 method for class 'sars'
summary(object, ...)

## S3 method for class 'summary.sars'
print(x, ...)

## S3 method for class 'sars'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sar_+3A_object">object</code></td>
<td>
<p>an object of class <code>sar</code>, output of the function <code><a href="#topic+sar">sar</a></code>.</p>
</td></tr>
<tr><td><code id="summary.sar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.sar_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.sar</code>, output of the function <code><a href="#topic+summary.sar">summary.sar</a></code> or
class <code>sar</code>, output of the function <code><a href="#topic+sar">sar</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same objects in <code>object</code>.
</p>

<hr>
<h2 id='summary.sart'>Summarize sart Model</h2><span id='topic+summary.sart'></span><span id='topic+print.summary.sart'></span><span id='topic+print.sart'></span><span id='topic+summary.sarts'></span><span id='topic+print.summary.sarts'></span><span id='topic+print.sarts'></span>

<h3>Description</h3>

<p>Summary and print methods for the class <code>sart</code> as returned by the function <a href="#topic+sart">sart</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sart'
summary(object, Glist, data, ...)

## S3 method for class 'summary.sart'
print(x, ...)

## S3 method for class 'sart'
print(x, ...)

## S3 method for class 'sarts'
summary(object, ...)

## S3 method for class 'summary.sarts'
print(x, ...)

## S3 method for class 'sarts'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sart_+3A_object">object</code></td>
<td>
<p>an object of class <code>sart</code>, output of the function <code><a href="#topic+sart">sart</a></code>.</p>
</td></tr>
<tr><td><code id="summary.sart_+3A_glist">Glist</code></td>
<td>
<p>adjacency matrix or list sub-adjacency matrix. This is not necessary if the covariance method was computed in <a href="#topic+cdnet">cdnet</a>.</p>
</td></tr>
<tr><td><code id="summary.sart_+3A_data">data</code></td>
<td>
<p>dataframe containing the explanatory variables. This is not necessary if the covariance method was computed in <a href="#topic+cdnet">cdnet</a>.</p>
</td></tr>
<tr><td><code id="summary.sart_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.sart_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.sart</code>, output of the function <code><a href="#topic+summary.sart">summary.sart</a></code>
or class <code>sart</code>, output of the function <code><a href="#topic+sart">sart</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same objects in <code>object</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
