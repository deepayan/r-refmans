<!DOCTYPE html><html><head><title>Help for package CDatanet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CDatanet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CDatanet-package'><p>The CDatanet package</p></a></li>
<li><a href='#cdnet'><p>Estimating count data models with social interactions under rational expectations using the NPL method</p></a></li>
<li><a href='#homophili.data'><p>Converting data between directed network models and symmetric network models.</p></a></li>
<li><a href='#homophily.fe'><p>Estimating network formation models with degree heterogeneity: the fixed effect approach</p></a></li>
<li><a href='#homophily.re'><p>Estimating network formation models with degree heterogeneity: the Bayesian random effect approach</p></a></li>
<li><a href='#norm.network'><p>Creating objects for network models</p></a></li>
<li><a href='#peer.avg'><p>Computing peer averages</p></a></li>
<li><a href='#print.simcdEy'><p>Printing the average expected outcomes for count data models with social interactions</p></a></li>
<li><a href='#remove.ids'><p>Removing IDs with NA from Adjacency Matrices Optimally</p></a></li>
<li><a href='#sar'><p>Estimating linear-in-mean models with social interactions</p></a></li>
<li><a href='#sart'><p>Estimating Tobit models with social interactions</p></a></li>
<li><a href='#simcdEy'><p>Counterfactual analyses with count data models and social interactions</p></a></li>
<li><a href='#simcdnet'><p>Simulating count data models with social interactions under rational expectations</p></a></li>
<li><a href='#simnetwork'><p>Simulating network data</p></a></li>
<li><a href='#simsar'><p>Simulating data from linear-in-mean models with social interactions</p></a></li>
<li><a href='#simsart'><p>Simulating data from Tobit models with social interactions</p></a></li>
<li><a href='#summary.cdnet'><p>Summary for the estimation of count data models with social interactions under rational expectations</p></a></li>
<li><a href='#summary.sar'><p>Summary for the estimation of linear-in-mean models with social interactions</p></a></li>
<li><a href='#summary.sart'><p>Summary for the estimation of Tobit models with social interactions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Econometrics of Network Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulating and estimating peer effect models and network formation models. The class of peer effect models includes linear-in-means models (Lee, 2004; &lt;<a href="https://doi.org/10.1111%2Fj.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>&gt;), Tobit models (Xu and Lee, 2015; &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2015.05.004">doi:10.1016/j.jeconom.2015.05.004</a>&gt;), and discrete numerical data models (Houndetoungan, 2024; &lt;<a href="https://doi.org/10.2139%2Fssrn.3721250">doi:10.2139/ssrn.3721250</a>&gt;). The network formation models include pair-wise regressions with degree heterogeneity (Graham, 2017; &lt;<a href="https://doi.org/10.3982%2FECTA12679">doi:10.3982/ECTA12679</a>&gt;) and exponential random graph models (Mele, 2017; &lt;<a href="https://doi.org/10.3982%2FECTA10400">doi:10.3982/ECTA10400</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ahoundetoungan/CDatanet/issues">https://github.com/ahoundetoungan/CDatanet/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ahoundetoungan/CDatanet">https://github.com/ahoundetoungan/CDatanet</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), Formula, formula.tools, ddpcr, Matrix,
matrixcalc, foreach, doRNG, doParallel, parallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress, RcppDist, RcppNumerical,
RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, MASS, knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-14 14:25:55 UTC; aristide</td>
</tr>
<tr>
<td>Author:</td>
<td>Aristide Houndetoungan [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aristide Houndetoungan &lt;ahoundetoungan@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-14 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CDatanet-package'>The CDatanet package</h2><span id='topic+CDatanet'></span><span id='topic+CDatanet-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">CDatanet</span> package simulates and estimates peer effect models and network formation models. The class of peer effect models includes linear-in-means models (Lee, 2004; Lee et al., 2010),
Tobit models (Xu and Lee, 2015), and discrete numerical data models (Houndetoungan, 2024).
The network formation models include pair-wise regressions with degree heterogeneity (Graham, 2017; Yan et al., 2019) and exponential random graph models (Mele, 2017).
To make the computations faster <span class="pkg">CDatanet</span> uses <code>C++</code> through the <span class="pkg">Rcpp</span> package (Eddelbuettel et al., 2011).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aristide Houndetoungan <a href="mailto:ahoundetoungan@gmail.com">ahoundetoungan@gmail.com</a>
</p>


<h3>References</h3>

<p>Eddelbuettel, D., &amp; Francois, R. (2011). <span class="pkg">Rcpp</span>: Seamless <span class="rlang"><b>R</b></span> and <code>C++</code> integration. <em>Journal of Statistical Software</em>, 40(8), 1-18, <a href="https://doi.org/10.18637/jss.v040.i08">doi:10.18637/jss.v040.i08</a>.
</p>
<p>Houndetoungan, E. A. (2024). Count Data Models with Social Interactions under Rational Expectations. Available at SSRN 3721250, <a href="https://doi.org/10.2139/ssrn.3721250">doi:10.2139/ssrn.3721250</a>.
</p>
<p>Lee, L. F. (2004). Asymptotic distributions of quasi-maximum likelihood estimators for spatial autoregressive models. <em>Econometrica</em>, 72(6), 1899-1925, <a href="https://doi.org/10.1111/j.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>.
</p>
<p>Lee, L. F., Liu, X., &amp; Lin, X. (2010). Specification and estimation of social interaction models with network structures. The Econometrics Journal, 13(2), 145-176, <a href="https://doi.org/10.1111/j.1368-423X.2010.00310.x">doi:10.1111/j.1368-423X.2010.00310.x</a>
</p>
<p>Xu, X., &amp; Lee, L. F. (2015). Maximum likelihood estimation of a spatial autoregressive Tobit model. <em>Journal of Econometrics</em>, 188(1), 264-280, <a href="https://doi.org/10.1016/j.jeconom.2015.05.004">doi:10.1016/j.jeconom.2015.05.004</a>.
</p>
<p>Graham, B. S. (2017). An econometric model of network formation with degree heterogeneity. <em>Econometrica</em>, 85(4), 1033-1063, <a href="https://doi.org/10.3982/ECTA12679">doi:10.3982/ECTA12679</a>.
</p>
<p>Mele, A. (2017). A structural model of dense network formation. <em>Econometrica</em>, 85(3), 825-850, <a href="https://doi.org/10.3982/ECTA10400">doi:10.3982/ECTA10400</a>.
</p>
<p>Yan, T., Jiang, B., Fienberg, S. E., &amp; Leng, C. (2019). Statistical inference in a directed network model with covariates. <em>Journal of the American Statistical Association</em>, 114(526), 857-868, <a href="https://doi.org/10.1080/01621459.2018.1448829">doi:10.1080/01621459.2018.1448829</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ahoundetoungan/CDatanet">https://github.com/ahoundetoungan/CDatanet</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ahoundetoungan/CDatanet/issues">https://github.com/ahoundetoungan/CDatanet/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cdnet'>Estimating count data models with social interactions under rational expectations using the NPL method</h2><span id='topic+cdnet'></span>

<h3>Description</h3>

<p><code>cdnet</code> estimates count data models with social interactions under rational expectations using the NPL algorithm (see Houndetoungan, 2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdnet(
  formula,
  Glist,
  group,
  Rmax,
  Rbar,
  starting = list(lambda = NULL, Gamma = NULL, delta = NULL),
  Ey0 = NULL,
  ubslambda = 1L,
  optimizer = "fastlbfgs",
  npl.ctr = list(),
  opt.ctr = list(),
  cov = TRUE,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdnet_+3A_formula">formula</code></td>
<td>
<p>a class object <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. <code>formula</code> must be as, for example, <code>y ~ x1 + x2 + gx1 + gx2</code>
where <code>y</code> is the endogenous vector and <code>x1</code>, <code>x2</code>, <code>gx1</code> and <code>gx2</code> are control variables, which can include contextual variables, i.e. averages among the peers.
Peer averages can be computed using the function <code><a href="#topic+peer.avg">peer.avg</a></code>.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_glist">Glist</code></td>
<td>
<p>adjacency matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list of subnets with the <code>m</code>-th element being an <code class="reqn">n_s\times n_s</code>-adjacency matrix, where <code class="reqn">n_s</code> is the number of nodes in the <code>m</code>-th subnet.
For heterogeneous peer effects (<code>length(unique(group)) = h &gt; 1</code>), the <code>m</code>-th element must be a list of <code class="reqn">h^2</code> <code class="reqn">n_s\times n_s</code>-adjacency matrices corresponding to the different network specifications (see Houndetoungan, 2024).
For heterogeneous peer effects in the case of a single large network, <code>Glist</code> must be a one-item list. This item must be a list of <code class="reqn">h^2</code> network specifications.
The order in which the networks in are specified are important and must match <code>sort(unique(group))</code> (see examples).</p>
</td></tr>
<tr><td><code id="cdnet_+3A_group">group</code></td>
<td>
<p>the vector indicating the individual groups. The default assumes a common group. For 2 groups; that is, <code>length(unique(group)) = 2</code>, (e.g., <code>A</code> and <code>B</code>),
four types of peer effects are defined: peer effects of <code>A</code> on <code>A</code>, of <code>A</code> on <code>B</code>, of <code>B</code> on <code>A</code>, and of <code>B</code> on <code>B</code>.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_rmax">Rmax</code></td>
<td>
<p>an integer indicating the theoretical upper bound of <code>y</code>. (see the model specification in details).</p>
</td></tr>
<tr><td><code id="cdnet_+3A_rbar">Rbar</code></td>
<td>
<p>an <code class="reqn">L</code>-vector, where  <code class="reqn">L</code> is the number of groups. For large <code>Rmax</code> the cost function is assumed to be semi-parametric (i.e., nonparametric from 0 to <code class="reqn">\bar{R}</code> and quadratic beyond <code class="reqn">\bar{R}</code>).</p>
</td></tr>
<tr><td><code id="cdnet_+3A_starting">starting</code></td>
<td>
<p>(optional) a starting value for <code class="reqn">\theta = (\lambda, \Gamma', \delta')'</code>, where <code class="reqn">\lambda</code>, <code class="reqn">\Gamma</code>, and <code class="reqn">\delta</code> are the parameters to be estimated (see details).</p>
</td></tr>
<tr><td><code id="cdnet_+3A_ey0">Ey0</code></td>
<td>
<p>(optional) a starting value for <code class="reqn">E(y)</code>.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_ubslambda">ubslambda</code></td>
<td>
<p>a positive value indicating the upper bound of <code class="reqn">\sum_{s = 1}^S \lambda_s &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_optimizer">optimizer</code></td>
<td>
<p>is either <code>fastlbfgs</code> (L-BFGS optimization method of the package <span class="pkg">RcppNumerical</span>), <code>nlm</code> (referring to the function <a href="stats.html#topic+nlm">nlm</a>), or <code>optim</code> (referring to the function <a href="stats.html#topic+optim">optim</a>).
Arguments for these functions such as, <code>control</code> and <code>method</code> can be set via the argument <code>opt.ctr</code>.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_npl.ctr">npl.ctr</code></td>
<td>
<p>a list of controls for the NPL method (see details).</p>
</td></tr>
<tr><td><code id="cdnet_+3A_opt.ctr">opt.ctr</code></td>
<td>
<p>a list of arguments to be passed in <code>optim_lbfgs</code> of the package <span class="pkg">RcppNumerical</span>, <a href="stats.html#topic+nlm">nlm</a> or <a href="stats.html#topic+optim">optim</a> (the solver set in <code>optimizer</code>), such as <code>maxit</code>, <code>eps_f</code>, <code>eps_g</code>, <code>control</code>, <code>method</code>, etc.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_cov">cov</code></td>
<td>
<p>a Boolean indicating if the covariance should be computed.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>cdnet</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Model</h4>

<p>The count variable <code class="reqn">y_i</code> take the value <code class="reqn">r</code> with probability.
</p>
<p style="text-align: center;"><code class="reqn">P_{ir} = F(\sum_{s = 1}^S \lambda_s \bar{y}_i^{e,s}  + \mathbf{z}_i'\Gamma - a_{h(i),r}) - F(\sum_{s = 1}^S \lambda_s \bar{y}_i^{e,s}  + \mathbf{z}_i'\Gamma - a_{h(i),r + 1}).</code>
</p>

<p>In this equation, <code class="reqn">\mathbf{z}_i</code> is a vector of control variables; <code class="reqn">F</code> is the distribution function of the standard normal distribution;
<code class="reqn">\bar{y}_i^{e,s}</code> is the average of <code class="reqn">E(y)</code> among peers using the <code>s</code>-th network definition;
<code class="reqn">a_{h(i),r}</code> is the <code>r</code>-th cut-point in the cost group <code class="reqn">h(i)</code>. <br /><br />
The following identification conditions have been introduced: <code class="reqn">\sum_{s = 1}^S \lambda_s &gt; 0</code>, <code class="reqn">a_{h(i),0} = -\infty</code>, <code class="reqn">a_{h(i),1} = 0</code>, and
<code class="reqn">a_{h(i),r} = \infty</code> for any <code class="reqn">r \geq R_{\text{max}} + 1</code>. The last condition implies that <code class="reqn">P_{ir} = 0</code> for any <code class="reqn">r \geq R_{\text{max}} + 1</code>.
For any <code class="reqn">r \geq 1</code>, the distance between two cut-points is <code class="reqn">a_{h(i),r+1} - a_{h(i),r} =  \delta_{h(i),r} + \sum_{s = 1}^S \lambda_s</code>
As the number of cut-point can be large, a quadratic cost function is considered for <code class="reqn">r \geq \bar{R}_{h(i)}</code>, where <code class="reqn">\bar{R} = (\bar{R}_{1}, ..., \bar{R}_{L})</code>.
With the semi-parametric cost-function,
<code class="reqn">a_{h(i),r + 1} - a_{h(i),r}= \bar{\delta}_{h(i)} + \sum_{s = 1}^S \lambda_s</code>.  <br /><br />
The model parameters are: <code class="reqn">\lambda = (\lambda_1, ..., \lambda_S)'</code>, <code class="reqn">\Gamma</code>, and <code class="reqn">\delta = (\delta_1', ..., \delta_L')'</code>,
where <code class="reqn">\delta_l = (\delta_{l,2}, ..., \delta_{l,\bar{R}_l}, \bar{\delta}_l)'</code> for <code class="reqn">l = 1, ..., L</code>.
The number of single parameters in <code class="reqn">\delta_l</code> depends on  <code class="reqn">R_{\text{max}}</code> and <code class="reqn">\bar{R}_{l}</code>. The components <code class="reqn">\delta_{l,2}, ..., \delta_{l,\bar{R}_l}</code> or/and
<code class="reqn">\bar{\delta}_l</code> must be removed in certain cases.<br />
If <code class="reqn">R_{\text{max}} = \bar{R}_{l} \geq 2</code>, then <code class="reqn">\delta_l = (\delta_{l,2}, ..., \delta_{l,\bar{R}_l})'</code>.<br />
If <code class="reqn">R_{\text{max}} = \bar{R}_{l} = 1</code> (binary models), then <code class="reqn">\delta_l</code> must be empty.<br />
If <code class="reqn">R_{\text{max}} &gt; \bar{R}_{l} = 1</code>, then <code class="reqn">\delta_l = \bar{\delta}_l</code>.
</p>



<h4><code>npl.ctr</code></h4>

<p>The model parameters are estimated using the Nested Partial Likelihood (NPL) method. This approach
starts with a guess of <code class="reqn">\theta</code> and <code class="reqn">E(y)</code> and constructs iteratively a sequence
of <code class="reqn">\theta</code> and <code class="reqn">E(y)</code>. The solution converges when the <code class="reqn">\ell_1</code>-distance
between two consecutive <code class="reqn">\theta</code> and <code class="reqn">E(y)</code> is less than a tolerance. <br />
The argument <code>npl.ctr</code> must include
</p>

<dl>
<dt>tol</dt><dd><p>the tolerance of the NPL algorithm (default 1e-4),</p>
</dd>
<dt>maxit</dt><dd><p>the maximal number of iterations allowed (default 500),</p>
</dd>
<dt>print</dt><dd><p>a boolean indicating if the estimate should be printed at each step.</p>
</dd>
<dt>S</dt><dd><p>the number of simulations performed use to compute integral in the covariance by important sampling.</p>
</dd>
</dl>




<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>info</code></td>
<td>
<p>a list of general information about the model.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the NPL estimator.</p>
</td></tr>
<tr><td><code>Ey</code></td>
<td>
<p><code class="reqn">E(y)</code>, the expectation of y.</p>
</td></tr>
<tr><td><code>GEy</code></td>
<td>
<p>the average of <code class="reqn">E(y)</code> friends.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>a list including (if <code>cov == TRUE</code>) <code>parms</code> the covariance matrix and another list <code>var.comp</code>, which includes <code>Sigma</code>, as <code class="reqn">\Sigma</code>, and <code>Omega</code>, as <code class="reqn">\Omega</code>, matrices used for
compute the covariance matrix.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>step-by-step output as returned by the optimizer.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Houndetoungan, E. A. (2024). Count Data Models with Social Interactions under Rational Expectations. Available at SSRN 3721250, <a href="https://doi.org/10.2139/ssrn.3721250">doi:10.2139/ssrn.3721250</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sart">sart</a></code>, <code><a href="#topic+sar">sar</a></code>, <code><a href="#topic+simcdnet">simcdnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 200))
n      &lt;- sum(nvec)

# Adjacency matrix
A      &lt;- list()
for (m in 1:M) {
  nm           &lt;- nvec[m]
  Am           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30 #maximum number of friends
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Am[i, tmp] &lt;- 1
  }
  A[[m]]       &lt;- Am
}
Anorm  &lt;- norm.network(A) #Row-normalization

# X
X      &lt;- cbind(rnorm(n, 1, 3), rexp(n, 0.4))

# Two group:
group  &lt;- 1*(X[,1] &gt; 0.95)

# Networks
# length(group) = 2 and unique(sort(group)) = c(0, 1)
# The networks must be defined as to capture:
# peer effects of `0` on `0`, peer effects of `1` on `0`
# peer effects of `0` on `1`, and peer effects of `1` on `1`
G        &lt;- list()
cums     &lt;- c(0, cumsum(nvec))
for (m in 1:M) {
  tp     &lt;- group[(cums[m] + 1):(cums[m + 1])]
  Am     &lt;- A[[m]]
  G[[m]] &lt;- norm.network(list(Am * ((1 - tp) %*% t(1 - tp)),
                              Am * ((1 - tp) %*% t(tp)),
                              Am * (tp %*% t(1 - tp)),
                              Am * (tp %*% t(tp))))
}

# Parameters
lambda &lt;- c(0.2, 0.3, -0.15, 0.25) 
Gamma  &lt;- c(4.5, 2.2, -0.9, 1.5, -1.2)
delta  &lt;- rep(c(2.6, 1.47, 0.85, 0.7, 0.5), 2) 

# Data
data   &lt;- data.frame(X, peer.avg(Anorm, cbind(x1 = X[,1], x2 =  X[,2])))
colnames(data) = c("x1", "x2", "gx1", "gx2")

ytmp   &lt;- simcdnet(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, Rbar = rep(5, 2),
                   lambda = lambda, Gamma = Gamma, delta = delta, group = group,
                   data = data)
y      &lt;- ytmp$y
hist(y, breaks = max(y) + 1)
table(y)

# Estimation
est    &lt;- cdnet(formula = y ~ x1 + x2 + gx1 + gx2, Glist = G, Rbar = rep(5, 2), group = group,
                optimizer = "fastlbfgs", data = data,
                opt.ctr = list(maxit = 5e3, eps_f = 1e-11, eps_g = 1e-11))
summary(est)

</code></pre>

<hr>
<h2 id='homophili.data'>Converting data between directed network models and symmetric network models.</h2><span id='topic+homophili.data'></span>

<h3>Description</h3>

<p><code>homophili.data</code> converts the matrix of explanatory variables between directed network models and symmetric network models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homophili.data(data, nvec, to = c("lower", "upper", "symmetric"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homophili.data_+3A_data">data</code></td>
<td>
<p>is the <code>matrix</code> or <code>data.frame</code> of the explanatory variables of the network formation model. This
corresponds to the <code>X</code> matrix in <code><a href="#topic+homophily.fe">homophily.fe</a></code> or in <code><a href="#topic+homophily.re">homophily.re</a></code>.</p>
</td></tr>
<tr><td><code id="homophili.data_+3A_nvec">nvec</code></td>
<td>
<p>is a vector of the number of individuals in the networks.</p>
</td></tr>
<tr><td><code id="homophili.data_+3A_to">to</code></td>
<td>
<p>indicates the direction of the conversion. For a matrix of explanatory variable <code>X</code> (<code>n*(n-1)</code> rows), one can
can select lower triangular entries (<code>to = "lower"</code>) or upper triangular entries (<code style="white-space: pre;">&#8288;to = "upper&#8288;</code>).
For a triangular <code>X</code> (<code>n*(n-1)/2</code> rows), one can convert to a full matrix of <code>n*(n-1)</code> rows by using symmetry (<code>to = "symmetric"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the transformed <code>data.frame</code>.
</p>

<hr>
<h2 id='homophily.fe'>Estimating network formation models with degree heterogeneity: the fixed effect approach</h2><span id='topic+homophily.fe'></span>

<h3>Description</h3>

<p><code>homophily.fe</code> implements a Logit estimator for network formation model with homophily. The model includes degree heterogeneity using fixed effects (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homophily.fe(
  network,
  formula,
  data,
  symmetry = FALSE,
  fe.way = 1,
  init = NULL,
  opt.ctr = list(maxit = 10000, eps_f = 1e-09, eps_g = 1e-09),
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homophily.fe_+3A_network">network</code></td>
<td>
<p>matrix or list of sub-matrix of social interactions containing 0 and 1, where links are represented by 1</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_formula">formula</code></td>
<td>
<p>an object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be as for example <code>~ x1 + x2</code>
where <code>x1</code>, <code>x2</code> are explanatory variable of links formation. If missing, the model is estimated with fixed effects only.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>homophily</code> is called.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_symmetry">symmetry</code></td>
<td>
<p>indicates whether the network model is symmetric (see details).</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_fe.way">fe.way</code></td>
<td>
<p>indicates whether it is a one-way or two-way fixed effect model. The expected value is 1 or 2 (see details).</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_init">init</code></td>
<td>
<p>(optional) either a list of starting values containing <code>beta</code>, an K-dimensional vector of the explanatory variables parameter,
<code>mu</code> an n-dimensional vector, and <code>nu</code> an n-dimensional vector,
where K is the number of explanatory variables and n is the number of individuals; or a vector of starting value for <code>c(beta, mu, nu)</code>.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_opt.ctr">opt.ctr</code></td>
<td>
<p>(optional) is a list of <code>maxit</code>, <code>eps_f</code>, and <code>eps_g</code>, which are control parameters used by the solver <code>optim_lbfgs</code>, of the package <span class="pkg">RcppNumerical</span>.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_print">print</code></td>
<td>
<p>Boolean indicating if the estimation progression should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">p_{ij}</code> be a probability for a link to go from the individual <code class="reqn">i</code> to the individual <code class="reqn">j</code>.
This probability is specified for two-way effect models (<code>fe.way = 2</code>) as
</p>
<p style="text-align: center;"><code class="reqn">p_{ij} = F(\mathbf{x}_{ij}'\beta + \mu_j + \nu_j)</code>
</p>

<p>where <code class="reqn">F</code> is the cumulative of the standard logistic distribution. Unobserved degree heterogeneity is captured by
<code class="reqn">\mu_i</code> and <code class="reqn">\nu_j</code>. The latter are treated as fixed effects (see <code><a href="#topic+homophily.re">homophily.re</a></code> for random effect models).
As shown by Yan et al. (2019), the estimator of
the parameter <code class="reqn">\beta</code> is biased. A bias correction is then necessary and is not implemented in this version. However
the estimator of <code class="reqn">\mu_i</code> and <code class="reqn">\nu_j</code> are consistent.<br />
For one-way fixed effect models (<code>fe.way = 1</code>), <code class="reqn">\nu_j = \mu_j</code>. For symmetric models, the network is not directed and the
fixed effects need to be one way.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>model.info</code></td>
<td>
<p>list of model information, such as the type of fixed effects, whether the model is symmetric,
number of observations, etc.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>maximizer of the log-likelihood.</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>maximized log-likelihood.</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>returned value of the optimization solver, which contains details of the optimization. The solver used is <code>optim_lbfgs</code> of the
package <span class="pkg">RcppNumerical</span>.</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>returned list of starting value.</p>
</td></tr>
<tr><td><code>loglike(init)</code></td>
<td>
<p>log-likelihood at the starting value.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Yan, T., Jiang, B., Fienberg, S. E., &amp; Leng, C. (2019). Statistical inference in a directed network model with covariates. <em>Journal of the American Statistical Association</em>, 114(526), 857-868, <a href="https://doi.org/10.1080/01621459.2018.1448829">doi:10.1080/01621459.2018.1448829</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+homophily.re">homophily.re</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
M            &lt;- 2 # Number of sub-groups
nvec         &lt;- round(runif(M, 20, 50))
beta         &lt;- c(.1, -.1)
Glist        &lt;- list()
dX           &lt;- matrix(0, 0, 2)
mu           &lt;- list()
nu           &lt;- list()
Emunu        &lt;- runif(M, -1.5, 0) #expectation of mu + nu
smu2         &lt;- 0.2
snu2         &lt;- 0.2
for (m in 1:M) {
  n          &lt;- nvec[m]
  mum        &lt;- rnorm(n, 0.7*Emunu[m], smu2)
  num        &lt;- rnorm(n, 0.3*Emunu[m], snu2)
  X1         &lt;- rnorm(n, 0, 1)
  X2         &lt;- rbinom(n, 1, 0.2)
  Z1         &lt;- matrix(0, n, n)  
  Z2         &lt;- matrix(0, n, n)
  
  for (i in 1:n) {
    for (j in 1:n) {
      Z1[i, j] &lt;- abs(X1[i] - X1[j])
      Z2[i, j] &lt;- 1*(X2[i] == X2[j])
    }
  }
  
  Gm           &lt;- 1*((Z1*beta[1] + Z2*beta[2] +
                       kronecker(mum, t(num), "+") + rlogis(n^2)) &gt; 0)
  diag(Gm)     &lt;- 0
  diag(Z1)     &lt;- NA
  diag(Z2)     &lt;- NA
  Z1           &lt;- Z1[!is.na(Z1)]
  Z2           &lt;- Z2[!is.na(Z2)]
  
  dX           &lt;- rbind(dX, cbind(Z1, Z2))
  Glist[[m]]   &lt;- Gm
  mu[[m]]      &lt;- mum
  nu[[m]]      &lt;- num
}

mu  &lt;- unlist(mu)
nu  &lt;- unlist(nu)

out   &lt;- homophily.fe(network =  Glist, formula = ~ -1 + dX, fe.way = 2)
muhat &lt;- out$estimate$mu
nuhat &lt;- out$estimate$nu
plot(mu, muhat)
plot(nu, nuhat)

</code></pre>

<hr>
<h2 id='homophily.re'>Estimating network formation models with degree heterogeneity: the Bayesian random effect approach</h2><span id='topic+homophily.re'></span>

<h3>Description</h3>

<p><code>homophily.re</code> implements a Bayesian Probit estimator for network formation model with homophily. The model includes degree heterogeneity using random effects (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homophily.re(
  network,
  formula,
  data,
  symmetry = FALSE,
  group.fe = FALSE,
  re.way = 1,
  init = list(),
  iteration = 1000,
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homophily.re_+3A_network">network</code></td>
<td>
<p>matrix or list of sub-matrix of social interactions containing 0 and 1, where links are represented by 1.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_formula">formula</code></td>
<td>
<p>an object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be as for example <code>~ x1 + x2</code>
where <code>x1</code>, <code>x2</code> are explanatory variable of links formation.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>homophily</code> is called.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_symmetry">symmetry</code></td>
<td>
<p>indicates whether the network model is symmetric (see details).</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_group.fe">group.fe</code></td>
<td>
<p>indicates whether the model includes group fixed effects.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_re.way">re.way</code></td>
<td>
<p>indicates whether it is a one-way or two-way fixed effect model. The expected value is 1 or 2 (see details).</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_init">init</code></td>
<td>
<p>(optional) list of starting values containing <code>beta</code>, an K-dimensional vector of the explanatory variables parameter,
<code>mu</code> an n-dimensional vector, and <code>nu</code> an n-dimensional vector, <code>smu2</code> the variance of <code>mu</code>,
and <code>snu2</code> the variance of <code>nu</code>,
where K is the number of explanatory variables and n is the number of individuals.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_iteration">iteration</code></td>
<td>
<p>the number of iterations to be performed.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_print">print</code></td>
<td>
<p>boolean indicating if the estimation progression should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">p_{ij}</code> be a probability for a link to go from the individual <code class="reqn">i</code> to the individual <code class="reqn">j</code>.
This probability is specified for two-way effect models (<code>fe.way = 2</code>) as
</p>
<p style="text-align: center;"><code class="reqn">p_{ij} = F(\mathbf{x}_{ij}'\beta + \mu_j + \nu_j)</code>
</p>

<p>where <code class="reqn">F</code> is the cumulative of the standard normal distribution. Unobserved degree heterogeneity is captured by
<code class="reqn">\mu_i</code> and <code class="reqn">\nu_j</code>. The latter are treated as random effects (see <code><a href="#topic+homophily.fe">homophily.fe</a></code> for fixed effect models).<br />
For one-way random effect models (<code>fe.way = 1</code>), <code class="reqn">\nu_j = \mu_j</code>. For symmetric models, the network is not directed and the
random effects need to be one way.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>model.info</code></td>
<td>
<p>list of model information, such as the type of random effects, whether the model is symmetric,
number of observations, etc.</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>list of simulations from the posterior distribution.</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>returned list of starting values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+homophily.fe">homophily.fe</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
library(MASS)
M            &lt;- 4 # Number of sub-groups
nvec         &lt;- round(runif(M, 100, 500))
beta         &lt;- c(.1, -.1)
Glist        &lt;- list()
dX           &lt;- matrix(0, 0, 2)
mu           &lt;- list()
nu           &lt;- list()
cst          &lt;- runif(M, -1.5, 0)
smu2         &lt;- 0.2
snu2         &lt;- 0.2
rho          &lt;- 0.8
Smunu        &lt;- matrix(c(smu2, rho*sqrt(smu2*snu2), rho*sqrt(smu2*snu2), snu2), 2)
for (m in 1:M) {
  n          &lt;- nvec[m]
  tmp        &lt;- mvrnorm(n, c(0, 0), Smunu)
  mum        &lt;- tmp[,1] - mean(tmp[,1])
  num        &lt;- tmp[,2] - mean(tmp[,2])
  X1         &lt;- rnorm(n, 0, 1)
  X2         &lt;- rbinom(n, 1, 0.2)
  Z1         &lt;- matrix(0, n, n)  
  Z2         &lt;- matrix(0, n, n)
  
  for (i in 1:n) {
    for (j in 1:n) {
      Z1[i, j] &lt;- abs(X1[i] - X1[j])
      Z2[i, j] &lt;- 1*(X2[i] == X2[j])
    }
  }
  
  Gm           &lt;- 1*((cst[m] + Z1*beta[1] + Z2*beta[2] +
                       kronecker(mum, t(num), "+") + rnorm(n^2)) &gt; 0)
  diag(Gm)     &lt;- 0
  diag(Z1)     &lt;- NA
  diag(Z2)     &lt;- NA
  Z1           &lt;- Z1[!is.na(Z1)]
  Z2           &lt;- Z2[!is.na(Z2)]
  
  dX           &lt;- rbind(dX, cbind(Z1, Z2))
  Glist[[m]]   &lt;- Gm
  mu[[m]]      &lt;- mum
  nu[[m]]      &lt;- num
}

mu  &lt;- unlist(mu)
nu  &lt;- unlist(nu)

out   &lt;- homophily.re(network =  Glist, formula = ~ dX, group.fe = TRUE, 
                      re.way = 2, iteration = 1e3)

# plot simulations
plot(out$posterior$beta[,1], type = "l")
abline(h = cst[1], col = "red")
plot(out$posterior$beta[,2], type = "l")
abline(h = cst[2], col = "red")
plot(out$posterior$beta[,3], type = "l")
abline(h = cst[3], col = "red")
plot(out$posterior$beta[,4], type = "l")
abline(h = cst[4], col = "red")

plot(out$posterior$beta[,5], type = "l")
abline(h = beta[1], col = "red")
plot(out$posterior$beta[,6], type = "l")
abline(h = beta[2], col = "red")

plot(out$posterior$sigma2_mu, type = "l")
abline(h = smu2, col = "red")
plot(out$posterior$sigma2_nu, type = "l")
abline(h = snu2, col = "red")
plot(out$posterior$rho, type = "l")
abline(h = rho, col = "red")

i &lt;- 10
plot(out$posterior$mu[,i], type = "l")
abline(h = mu[i], col = "red")
plot(out$posterior$nu[,i], type = "l")
abline(h = nu[i], col = "red")

</code></pre>

<hr>
<h2 id='norm.network'>Creating objects for network models</h2><span id='topic+norm.network'></span><span id='topic+vec.to.mat'></span><span id='topic+mat.to.vec'></span>

<h3>Description</h3>

<p><code>vec.to.mat</code> creates a list of square matrices from a given vector.
The elements of the generated matrices are taken from the vector and placed column-wise (ie. the first column is filled up before filling the second column) and from the first matrix of the list to the last matrix of the list.
The diagonal of the generated matrices are zeros.
<code>mat.to.vec</code> creates a vector from a given list of square matrices .
The elements of the generated vector are taken from column-wise and from the first matrix of the list to the last matrix of the list, while dropping the diagonal entry.
<code>norm.network</code> row-normalizes matrices in a given list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm.network(W)

vec.to.mat(u, N, normalise = FALSE, byrow = FALSE)

mat.to.vec(W, ceiled = FALSE, byrow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm.network_+3A_w">W</code></td>
<td>
<p>matrix or list of matrices to convert.</p>
</td></tr>
<tr><td><code id="norm.network_+3A_u">u</code></td>
<td>
<p>numeric vector to convert.</p>
</td></tr>
<tr><td><code id="norm.network_+3A_n">N</code></td>
<td>
<p>vector of sub-network sizes  such that <code>length(u) == sum(N*(N - 1))</code>.</p>
</td></tr>
<tr><td><code id="norm.network_+3A_normalise">normalise</code></td>
<td>
<p>Boolean takes <code>TRUE</code> if the returned matrices should be row-normalized and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="norm.network_+3A_byrow">byrow</code></td>
<td>
<p>Boolean takes <code>TRUE</code> is entries in the matrices should be taken by row and <code>FALSE</code> if they should be taken by column.</p>
</td></tr>
<tr><td><code id="norm.network_+3A_ceiled">ceiled</code></td>
<td>
<p>Boolean takes <code>TRUE</code> if the given matrices should be ceiled before conversion and <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of size <code>sum(N*(N - 1))</code> or list of <code>length(N)</code> square matrices. The sizes of the matrices are <code style="white-space: pre;">&#8288;N[1], N[2], ...&#8288;</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simnetwork">simnetwork</a></code>, <code><a href="#topic+peer.avg">peer.avg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a list of adjacency matrices
## sub-network size
N &lt;- c(250, 370, 120)  
## rate of friendship
p &lt;- c(.2, .15, .18)   
## network data
u &lt;- unlist(lapply(1: 3, function(x) rbinom(N[x]*(N[x] - 1), 1, p[x])))
W &lt;- vec.to.mat(u, N)

# Convert G into a list of row-normalized matrices
G &lt;- norm.network(W)

# recover u
v &lt;- mat.to.vec(G, ceiled = TRUE)
all.equal(u, v)
</code></pre>

<hr>
<h2 id='peer.avg'>Computing peer averages</h2><span id='topic+peer.avg'></span>

<h3>Description</h3>

<p><code>peer.avg</code> computes peer average value using network data (as a list) and observable characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peer.avg(Glist, V, export.as.list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peer.avg_+3A_glist">Glist</code></td>
<td>
<p>the adjacency matrix or list sub-adjacency matrix.</p>
</td></tr>
<tr><td><code id="peer.avg_+3A_v">V</code></td>
<td>
<p>vector or matrix of observable characteristics.</p>
</td></tr>
<tr><td><code id="peer.avg_+3A_export.as.list">export.as.list</code></td>
<td>
<p>(optional) boolean to indicate if the output should be a list of matrices or a single matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix product <code>diag(Glist[[1]], Glist[[2]], ...) %*% V</code>, where <code>diag()</code> is the block diagonal operator.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simnetwork">simnetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a list of adjacency matrices
## sub-network size
N  &lt;- c(250, 370, 120)  
## rate of friendship
p  &lt;- c(.2, .15, .18)   
## network data
u  &lt;- unlist(lapply(1: 3, function(x) rbinom(N[x]*(N[x] - 1), 1, p[x])))
G  &lt;- vec.to.mat(u, N, normalise = TRUE)

# Generate a vector y
y  &lt;- rnorm(sum(N))

# Compute G%*%y
Gy &lt;- peer.avg(Glist = G, V = y)
</code></pre>

<hr>
<h2 id='print.simcdEy'>Printing the average expected outcomes for count data models with social interactions</h2><span id='topic+print.simcdEy'></span><span id='topic+summary.simcdEy'></span><span id='topic+print.summary.simcdEy'></span>

<h3>Description</h3>

<p>Summary and print methods for the class <code>simcdEy</code> as returned by the function <a href="#topic+simcdEy">simcdEy</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simcdEy'
print(x, ...)

## S3 method for class 'simcdEy'
summary(object, ...)

## S3 method for class 'summary.simcdEy'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.simcdEy_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.simcdEy</code>, output of the function <code><a href="#topic+summary.simcdEy">summary.simcdEy</a></code>
or class <code>simcdEy</code>, output of the function <code><a href="#topic+simcdEy">simcdEy</a></code>.</p>
</td></tr>
<tr><td><code id="print.simcdEy_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="print.simcdEy_+3A_object">object</code></td>
<td>
<p>an object of class <code>simcdEy</code>, output of the function <code><a href="#topic+simcdEy">simcdEy</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same objects in <code>object</code>.
</p>

<hr>
<h2 id='remove.ids'>Removing IDs with NA from Adjacency Matrices Optimally</h2><span id='topic+remove.ids'></span>

<h3>Description</h3>

<p><code>remove.ids</code> optimally removes identifiers with NA from adjacency matrices. Many combinations of rows and columns can be deleted
removing many rows and column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.ids(network, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.ids_+3A_network">network</code></td>
<td>
<p>is a list of adjacency matrices</p>
</td></tr>
<tr><td><code id="remove.ids_+3A_ncores">ncores</code></td>
<td>
<p>is the number of cores to be used to run the program in parallel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of adjacency matrices without missing values and a list of vectors of retained indeces
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(1:25, 5)
A[1, 1] &lt;- NA
A[4, 2] &lt;- NA
remove.ids(A)

B &lt;- matrix(1:100, 10)
B[1, 1] &lt;- NA
B[4, 2] &lt;- NA
B[2, 4] &lt;- NA
B[,8]   &lt;-NA
remove.ids(B)
</code></pre>

<hr>
<h2 id='sar'>Estimating linear-in-mean models with social interactions</h2><span id='topic+sar'></span>

<h3>Description</h3>

<p><code>sar</code> computes quasi-maximum likelihood estimators for linear-in-mean models with social interactions (see Lee, 2004 and Lee et al., 2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar(
  formula,
  Glist,
  lambda0 = NULL,
  fixed.effects = FALSE,
  optimizer = "optim",
  opt.ctr = list(),
  print = TRUE,
  cov = TRUE,
  cinfo = TRUE,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sar_+3A_formula">formula</code></td>
<td>
<p>a class object <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. <code>formula</code> must be as, for example, <code>y ~ x1 + x2 + gx1 + gx2</code>
where <code>y</code> is the endogenous vector and <code>x1</code>, <code>x2</code>, <code>gx1</code> and <code>gx2</code> are control variables, which can include contextual variables, i.e. averages among the peers.
Peer averages can be computed using the function <code><a href="#topic+peer.avg">peer.avg</a></code>.</p>
</td></tr>
<tr><td><code id="sar_+3A_glist">Glist</code></td>
<td>
<p>The network matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list of subnets with the <code>m</code>-th element being an <code>ns*ns</code> adjacency matrix, where <code>ns</code> is the number of nodes in the <code>m</code>-th subnet.</p>
</td></tr>
<tr><td><code id="sar_+3A_lambda0">lambda0</code></td>
<td>
<p>an optional starting value of <code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code id="sar_+3A_fixed.effects">fixed.effects</code></td>
<td>
<p>a Boolean indicating whether group heterogeneity must be included as fixed effects.</p>
</td></tr>
<tr><td><code id="sar_+3A_optimizer">optimizer</code></td>
<td>
<p>is either <code>nlm</code> (referring to the function <a href="stats.html#topic+nlm">nlm</a>) or <code>optim</code> (referring to the function <a href="stats.html#topic+optim">optim</a>).
Arguments for these functions such as, <code>control</code> and <code>method</code> can be set via the argument <code>opt.ctr</code>.</p>
</td></tr>
<tr><td><code id="sar_+3A_opt.ctr">opt.ctr</code></td>
<td>
<p>list of arguments of <a href="stats.html#topic+nlm">nlm</a> or <a href="stats.html#topic+optim">optim</a> (the one set in <code>optimizer</code>) such as <code>control</code>, <code>method</code>, etc.</p>
</td></tr>
<tr><td><code id="sar_+3A_print">print</code></td>
<td>
<p>a Boolean indicating if the estimate should be printed at each step.</p>
</td></tr>
<tr><td><code id="sar_+3A_cov">cov</code></td>
<td>
<p>a Boolean indicating if the covariance should be computed.</p>
</td></tr>
<tr><td><code id="sar_+3A_cinfo">cinfo</code></td>
<td>
<p>a Boolean indicating whether information is complete (<code>cinfo = TRUE</code>) or incomplete (<code>cinfo = FALSE</code>). In the case of incomplete information, the model is defined under rational expectations.</p>
</td></tr>
<tr><td><code id="sar_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>sar</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a complete information model, the outcome <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">y_i = \lambda \bar{y}_i + \mathbf{z}_i'\Gamma + \epsilon_i,</code>
</p>

<p>where <code class="reqn">\bar{y}_i</code> is the average of <code class="reqn">y</code> among peers,
<code class="reqn">\mathbf{z}_i</code> is a vector of control variables,
and <code class="reqn">\epsilon_i \sim N(0, \sigma^2)</code>.
In the case of incomplete information models with rational expectations, <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">y_i = \lambda E(\bar{y}_i) + \mathbf{z}_i'\Gamma + \epsilon_i.</code>
</p>



<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>info</code></td>
<td>
<p>list of general information on the model.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Maximum Likelihood (ML) estimator.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>covariance matrix of the estimate.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>outputs as returned by the optimizer.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lee, L. F. (2004). Asymptotic distributions of quasi-maximum likelihood estimators for spatial autoregressive models. <em>Econometrica</em>, 72(6), 1899-1925, <a href="https://doi.org/10.1111/j.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>.
</p>
<p>Lee, L. F., Liu, X., &amp; Lin, X. (2010). Specification and estimation of social interaction models with network structures. The Econometrics Journal, 13(2), 145-176, <a href="https://doi.org/10.1111/j.1368-423X.2010.00310.x">doi:10.1111/j.1368-423X.2010.00310.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sart">sart</a></code>, <code><a href="#topic+cdnet">cdnet</a></code>, <code><a href="#topic+simsar">simsar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Groups' size
set.seed(123)
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 1000))
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
Gamma  &lt;- c(2, -1.9, 0.8, 1.5, -1.2)
sigma  &lt;- 1.5
theta  &lt;- c(lambda, Gamma, sigma)

# X
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network
G      &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm/rs
  G[[m]]       &lt;- Gm
}

# data
data   &lt;- data.frame(X, peer.avg(G, cbind(x1 = X[,1], x2 =  X[,2])))
colnames(data) &lt;- c("x1", "x2", "gx1", "gx2")

ytmp    &lt;- simsar(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, 
                  theta = theta, data = data) 
data$y  &lt;- ytmp$y

out     &lt;- sar(formula = y ~ x1 + x2 + + gx1 + gx2, Glist = G, 
               optimizer = "optim", data = data)
summary(out)

</code></pre>

<hr>
<h2 id='sart'>Estimating Tobit models with social interactions</h2><span id='topic+sart'></span>

<h3>Description</h3>

<p><code>sart</code> estimates Tobit models with social interactions (Xu and Lee, 2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sart(
  formula,
  Glist,
  starting = NULL,
  Ey0 = NULL,
  optimizer = "fastlbfgs",
  npl.ctr = list(),
  opt.ctr = list(),
  cov = TRUE,
  cinfo = TRUE,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sart_+3A_formula">formula</code></td>
<td>
<p>a class object <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. <code>formula</code> must be as, for example, <code>y ~ x1 + x2 + gx1 + gx2</code>
where <code>y</code> is the endogenous vector and <code>x1</code>, <code>x2</code>, <code>gx1</code> and <code>gx2</code> are control variables, which can include contextual variables, i.e. averages among the peers.
Peer averages can be computed using the function <code><a href="#topic+peer.avg">peer.avg</a></code>.</p>
</td></tr>
<tr><td><code id="sart_+3A_glist">Glist</code></td>
<td>
<p>The network matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list of subnets with the <code>m</code>-th element being an <code>ns*ns</code> adjacency matrix, where <code>ns</code> is the number of nodes in the <code>m</code>-th subnet.</p>
</td></tr>
<tr><td><code id="sart_+3A_starting">starting</code></td>
<td>
<p>(optional) a starting value for <code class="reqn">\theta = (\lambda, \Gamma, \sigma)</code> (see the model specification in details).</p>
</td></tr>
<tr><td><code id="sart_+3A_ey0">Ey0</code></td>
<td>
<p>(optional) a starting value for <code class="reqn">E(y)</code>.</p>
</td></tr>
<tr><td><code id="sart_+3A_optimizer">optimizer</code></td>
<td>
<p>is either <code>fastlbfgs</code> (L-BFGS optimization method of the package <span class="pkg">RcppNumerical</span>), <code>nlm</code> (referring to the function <a href="stats.html#topic+nlm">nlm</a>), or <code>optim</code> (referring to the function <a href="stats.html#topic+optim">optim</a>).
Arguments for these functions such as, <code>control</code> and <code>method</code> can be set via the argument <code>opt.ctr</code>.</p>
</td></tr>
<tr><td><code id="sart_+3A_npl.ctr">npl.ctr</code></td>
<td>
<p>a list of controls for the NPL method (see details of the function <code><a href="#topic+cdnet">cdnet</a></code>).</p>
</td></tr>
<tr><td><code id="sart_+3A_opt.ctr">opt.ctr</code></td>
<td>
<p>a list of arguments to be passed in <code>optim_lbfgs</code> of the package <span class="pkg">RcppNumerical</span>, <a href="stats.html#topic+nlm">nlm</a> or <a href="stats.html#topic+optim">optim</a> (the solver set in <code>optimizer</code>), such as <code>maxit</code>, <code>eps_f</code>, <code>eps_g</code>, <code>control</code>, <code>method</code>, etc.</p>
</td></tr>
<tr><td><code id="sart_+3A_cov">cov</code></td>
<td>
<p>a Boolean indicating if the covariance must be computed.</p>
</td></tr>
<tr><td><code id="sart_+3A_cinfo">cinfo</code></td>
<td>
<p>a Boolean indicating whether information is complete (<code>cinfo = TRUE</code>) or incomplete (<code>cinfo = FALSE</code>). In the case of incomplete information, the model is defined under rational expectations.</p>
</td></tr>
<tr><td><code id="sart_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>sart</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a complete information model, the outcome <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\begin{cases}y_i^{\ast} = \lambda \bar{y}_i + \mathbf{z}_i'\Gamma + \epsilon_i, \\ y_i = \max(0, y_i^{\ast}),\end{cases}</code>
</p>

<p>where <code class="reqn">\bar{y}_i</code> is the average of <code class="reqn">y</code> among peers,
<code class="reqn">\mathbf{z}_i</code> is a vector of control variables,
and <code class="reqn">\epsilon_i \sim N(0, \sigma^2)</code>.
In the case of incomplete information modelswith rational expectations, <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\begin{cases}y_i^{\ast} = \lambda E(\bar{y}_i) + \mathbf{z}_i'\Gamma + \epsilon_i, \\ y_i = \max(0, y_i^{\ast}).\end{cases}</code>
</p>



<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>info</code></td>
<td>
<p>a list of general information on the model.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the Maximum Likelihood (ML) estimator.</p>
</td></tr>
<tr><td><code>Ey</code></td>
<td>
<p><code class="reqn">E(y)</code>, the expectation of y.</p>
</td></tr>
<tr><td><code>GEy</code></td>
<td>
<p>the average of <code class="reqn">E(y)</code> friends.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>a list including (if <code>cov == TRUE</code>) covariance matrices.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>outputs as returned by the optimizer.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Xu, X., &amp; Lee, L. F. (2015). Maximum likelihood estimation of a spatial autoregressive Tobit model. <em>Journal of Econometrics</em>, 188(1), 264-280, <a href="https://doi.org/10.1016/j.jeconom.2015.05.004">doi:10.1016/j.jeconom.2015.05.004</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sar">sar</a></code>, <code><a href="#topic+cdnet">cdnet</a></code>, <code><a href="#topic+simsart">simsart</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Groups' size
set.seed(123)
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 200))
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
Gamma  &lt;- c(2, -1.9, 0.8, 1.5, -1.2)
sigma  &lt;- 1.5
theta  &lt;- c(lambda, Gamma, sigma)

# X
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network
G      &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm/rs
  G[[m]]       &lt;- Gm
}

# Data
data   &lt;- data.frame(X, peer.avg(G, cbind(x1 = X[,1], x2 =  X[,2])))
colnames(data) &lt;- c("x1", "x2", "gx1", "gx2")

## Complete information game
ytmp    &lt;- simsart(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, theta = theta, 
                   data = data, cinfo = TRUE)
data$yc &lt;- ytmp$y

## Incomplete information game
ytmp    &lt;- simsart(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, theta = theta, 
                   data = data, cinfo = FALSE)
data$yi &lt;- ytmp$y

# Complete information estimation for yc
outc1   &lt;- sart(formula = yc ~ x1 + x2 + gx1 + gx2, optimizer = "nlm",
                Glist = G, data = data, cinfo = TRUE)
summary(outc1)

# Complete information estimation for yi
outc1   &lt;- sart(formula = yi ~ x1 + x2 + gx1 + gx2, optimizer = "nlm",
                Glist = G, data = data, cinfo = TRUE)
summary(outc1)

# Incomplete information estimation for yc
outi1   &lt;- sart(formula = yc ~ x1 + x2 + gx1 + gx2, optimizer = "nlm",
                Glist = G, data = data, cinfo = FALSE)
summary(outi1)

# Incomplete information estimation for yi
outi1   &lt;- sart(formula = yi ~ x1 + x2 + gx1 + gx2, optimizer = "nlm",
                Glist = G, data = data, cinfo = FALSE)
summary(outi1)

</code></pre>

<hr>
<h2 id='simcdEy'>Counterfactual analyses with count data models and social interactions</h2><span id='topic+simcdEy'></span>

<h3>Description</h3>

<p><code>simcdpar</code> computes the average expected outcomes for count data models with social interactions and standard errors using the Delta method.
This function can be used to examine the effects of changes in the network or in the control variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simcdEy(object, Glist, data, group, tol = 1e-10, maxit = 500, S = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simcdEy_+3A_object">object</code></td>
<td>
<p>an object of class <code>summary.cdnet</code>, output of the function <code><a href="#topic+summary.cdnet">summary.cdnet</a></code>
or class <code>cdnet</code>, output of the function <code><a href="#topic+cdnet">cdnet</a></code>.</p>
</td></tr>
<tr><td><code id="simcdEy_+3A_glist">Glist</code></td>
<td>
<p>adjacency matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list of subnets with the <code>m</code>-th element being an <code>ns*ns</code> adjacency matrix, where <code>ns</code> is the number of nodes in the <code>m</code>-th subnet.
For heterogenous peer effects (e.g., boy-boy, boy-girl friendship effects), the <code>m</code>-th element can be a list of many <code>ns*ns</code> adjacency matrices corresponding to the different network specifications (see Houndetoungan, 2024).
For heterogeneous peer effects in the case of a single large network, <code>Glist</code> must be a one-item list. This item must be a list of many specifications of large networks.</p>
</td></tr>
<tr><td><code id="simcdEy_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>summary.cdnet</code> is called.</p>
</td></tr>
<tr><td><code id="simcdEy_+3A_group">group</code></td>
<td>
<p>the vector indicating the individual groups (see function <code><a href="#topic+cdnet">cdnet</a></code>). If missing, the former group saved in <code>object</code> will be used.</p>
</td></tr>
<tr><td><code id="simcdEy_+3A_tol">tol</code></td>
<td>
<p>the tolerance value used in the Fixed Point Iteration Method to compute the expectancy of <code>y</code>. The process stops if the <code class="reqn">\ell_1</code>-distance
between two consecutive <code class="reqn">E(y)</code> is less than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="simcdEy_+3A_maxit">maxit</code></td>
<td>
<p>the maximal number of iterations in the Fixed Point Iteration Method.</p>
</td></tr>
<tr><td><code id="simcdEy_+3A_s">S</code></td>
<td>
<p>number of simulations to be used to compute integral in the covariance by important sampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>Ey</code></td>
<td>
<p><code class="reqn">E(y)</code>, the expectation of y.</p>
</td></tr>
<tr><td><code>GEy</code></td>
<td>
<p>the average of <code class="reqn">E(y)</code> friends.</p>
</td></tr>
<tr><td><code>aEy</code></td>
<td>
<p>the sampling mean of <code class="reqn">E(y)</code>.</p>
</td></tr>
<tr><td><code>se.aEy</code></td>
<td>
<p>the standard error of the sampling mean of <code class="reqn">E(y)</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+simcdnet">simcdnet</a></code>
</p>

<hr>
<h2 id='simcdnet'>Simulating count data models with social interactions under rational expectations</h2><span id='topic+simcdnet'></span>

<h3>Description</h3>

<p><code>simcdnet</code> simulate the count data model with social interactions under rational expectations developed by Houndetoungan (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simcdnet(
  formula,
  group,
  Glist,
  parms,
  lambda,
  Gamma,
  delta,
  Rmax,
  Rbar,
  tol = 1e-10,
  maxit = 500,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simcdnet_+3A_formula">formula</code></td>
<td>
<p>a class object <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. <code>formula</code> must be as, for example, <code>y ~ x1 + x2 + gx1 + gx2</code>
where <code>y</code> is the endogenous vector and <code>x1</code>, <code>x2</code>, <code>gx1</code> and <code>gx2</code> are control variables, which can include contextual variables, i.e. averages among the peers.
Peer averages can be computed using the function <code><a href="#topic+peer.avg">peer.avg</a></code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_group">group</code></td>
<td>
<p>the vector indicating the individual groups. The default assumes a common group. For 2 groups; that is, <code>length(unique(group)) = 2</code>, (e.g., <code>A</code> and <code>B</code>),
four types of peer effects are defined: peer effects of <code>A</code> on <code>A</code>, of <code>A</code> on <code>B</code>, of <code>B</code> on <code>A</code>, and of <code>B</code> on <code>B</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_glist">Glist</code></td>
<td>
<p>adjacency matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list of subnets with the <code>m</code>-th element being an <code class="reqn">n_s\times n_s</code>-adjacency matrix, where <code class="reqn">n_s</code> is the number of nodes in the <code>m</code>-th subnet.
For heterogeneous peer effects (<code>length(unique(group)) = h &gt; 1</code>), the <code>m</code>-th element must be a list of <code class="reqn">h^2</code> <code class="reqn">n_s\times n_s</code>-adjacency matrices corresponding to the different network specifications (see Houndetoungan, 2024).
For heterogeneous peer effects in the case of a single large network, <code>Glist</code> must be a one-item list. This item must be a list of <code class="reqn">h^2</code> network specifications.
The order in which the networks in are specified are important and must match <code>sort(unique(group))</code> (see examples).</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_parms">parms</code></td>
<td>
<p>a vector defining the true value of <code class="reqn">\theta = (\lambda', \Gamma', \delta')'</code> (see the model specification in details).
Each parameter <code class="reqn">\lambda</code>, <code class="reqn">\Gamma</code>, or <code class="reqn">\delta</code> can also be given separately to the arguments <code>lambda</code>, <code>Gamma</code>, or <code>delta</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_lambda">lambda</code></td>
<td>
<p>the true value of the vector <code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_gamma">Gamma</code></td>
<td>
<p>the true value of the vector <code class="reqn">\Gamma</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_delta">delta</code></td>
<td>
<p>the true value of the vector <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_rmax">Rmax</code></td>
<td>
<p>an integer indicating the theoretical upper bound of <code>y</code>. (see the model specification in details).</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_rbar">Rbar</code></td>
<td>
<p>an <code class="reqn">L</code>-vector, where  <code class="reqn">L</code> is the number of groups. For large <code>Rmax</code> the cost function is assumed to be semi-parametric (i.e., nonparametric from 0 to <code class="reqn">\bar{R}</code> and quadratic beyond <code class="reqn">\bar{R}</code>).
The <code>l</code>-th element of <code>Rbar</code> indicates <code class="reqn">\bar{R}</code> for the <code>l</code>-th value of <code>sort(unique(group))</code> (see the model specification in details).</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_tol">tol</code></td>
<td>
<p>the tolerance value used in the Fixed Point Iteration Method to compute the expectancy of <code>y</code>. The process stops if the <code class="reqn">\ell_1</code>-distance
between two consecutive <code class="reqn">E(y)</code> is less than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_maxit">maxit</code></td>
<td>
<p>the maximal number of iterations in the Fixed Point Iteration Method.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>simcdnet</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The count variable <code class="reqn">y_i</code> take the value <code class="reqn">r</code> with probability.
</p>
<p style="text-align: center;"><code class="reqn">P_{ir} = F(\sum_{s = 1}^S \lambda_s \bar{y}_i^{e,s}  + \mathbf{z}_i'\Gamma - a_{h(i),r}) - F(\sum_{s = 1}^S \lambda_s \bar{y}_i^{e,s}  + \mathbf{z}_i'\Gamma - a_{h(i),r + 1}).</code>
</p>

<p>In this equation, <code class="reqn">\mathbf{z}_i</code> is a vector of control variables; <code class="reqn">F</code> is the distribution function of the standard normal distribution;
<code class="reqn">\bar{y}_i^{e,s}</code> is the average of <code class="reqn">E(y)</code> among peers using the <code>s</code>-th network definition;
<code class="reqn">a_{h(i),r}</code> is the <code>r</code>-th cut-point in the cost group <code class="reqn">h(i)</code>. <br /><br />
The following identification conditions have been introduced: <code class="reqn">\sum_{s = 1}^S \lambda_s &gt; 0</code>, <code class="reqn">a_{h(i),0} = -\infty</code>, <code class="reqn">a_{h(i),1} = 0</code>, and
<code class="reqn">a_{h(i),r} = \infty</code> for any <code class="reqn">r \geq R_{\text{max}} + 1</code>. The last condition implies that <code class="reqn">P_{ir} = 0</code> for any <code class="reqn">r \geq R_{\text{max}} + 1</code>.
For any <code class="reqn">r \geq 1</code>, the distance between two cut-points is <code class="reqn">a_{h(i),r+1} - a_{h(i),r} =  \delta_{h(i),r} + \sum_{s = 1}^S \lambda_s</code>
As the number of cut-point can be large, a quadratic cost function is considered for <code class="reqn">r \geq \bar{R}_{h(i)}</code>, where <code class="reqn">\bar{R} = (\bar{R}_{1}, ..., \bar{R}_{L})</code>.
With the semi-parametric cost-function,
<code class="reqn">a_{h(i),r + 1} - a_{h(i),r}= \bar{\delta}_{h(i)} + \sum_{s = 1}^S \lambda_s</code>.  <br /><br />
The model parameters are: <code class="reqn">\lambda = (\lambda_1, ..., \lambda_S)'</code>, <code class="reqn">\Gamma</code>, and <code class="reqn">\delta = (\delta_1', ..., \delta_L')'</code>,
where <code class="reqn">\delta_l = (\delta_{l,2}, ..., \delta_{l,\bar{R}_l}, \bar{\delta}_l)'</code> for <code class="reqn">l = 1, ..., L</code>.
The number of single parameters in <code class="reqn">\delta_l</code> depends on  <code class="reqn">R_{\text{max}}</code> and <code class="reqn">\bar{R}_{l}</code>. The components <code class="reqn">\delta_{l,2}, ..., \delta_{l,\bar{R}_l}</code> or/and
<code class="reqn">\bar{\delta}_l</code> must be removed in certain cases.<br />
If <code class="reqn">R_{\text{max}} = \bar{R}_{l} \geq 2</code>, then <code class="reqn">\delta_l = (\delta_{l,2}, ..., \delta_{l,\bar{R}_l})'</code>.<br />
If <code class="reqn">R_{\text{max}} = \bar{R}_{l} = 1</code> (binary models), then <code class="reqn">\delta_l</code> must be empty.<br />
If <code class="reqn">R_{\text{max}} &gt; \bar{R}_{l} = 1</code>, then <code class="reqn">\delta_l = \bar{\delta}_l</code>.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>yst</code></td>
<td>
<p><code class="reqn">y^{\ast}</code>, the latent variable.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the observed count variable.</p>
</td></tr>
<tr><td><code>Ey</code></td>
<td>
<p><code class="reqn">E(y)</code>, the expectation of y.</p>
</td></tr>
<tr><td><code>GEy</code></td>
<td>
<p>the average of <code class="reqn">E(y)</code> friends.</p>
</td></tr>
<tr><td><code>meff</code></td>
<td>
<p>a list includinh average and individual marginal effects.</p>
</td></tr>
<tr><td><code>Rmax</code></td>
<td>
<p>infinite sums in the marginal effects are approximated by sums up to Rmax.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>number of iterations performed by sub-network in the Fixed Point Iteration Method.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Houndetoungan, E. A. (2024). Count Data Models with Social Interactions under Rational Expectations. Available at SSRN 3721250, <a href="https://doi.org/10.2139/ssrn.3721250">doi:10.2139/ssrn.3721250</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cdnet">cdnet</a></code>, <code><a href="#topic+simsart">simsart</a></code>, <code><a href="#topic+simsar">simsar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 200))
n      &lt;- sum(nvec)

# Adjacency matrix
A      &lt;- list()
for (m in 1:M) {
  nm           &lt;- nvec[m]
  Am           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30 #maximum number of friends
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Am[i, tmp] &lt;- 1
  }
  A[[m]]       &lt;- Am
}
Anorm  &lt;- norm.network(A) #Row-normalization

# X
X      &lt;- cbind(rnorm(n, 1, 3), rexp(n, 0.4))

# Two group:
group  &lt;- 1*(X[,1] &gt; 0.95)

# Networks
# length(group) = 2 and unique(sort(group)) = c(0, 1)
# The networks must be defined as to capture:
# peer effects of `0` on `0`, peer effects of `1` on `0`
# peer effects of `0` on `1`, and peer effects of `1` on `1`
G        &lt;- list()
cums     &lt;- c(0, cumsum(nvec))
for (m in 1:M) {
  tp     &lt;- group[(cums[m] + 1):(cums[m + 1])]
  Am     &lt;- A[[m]]
  G[[m]] &lt;- norm.network(list(Am * ((1 - tp) %*% t(1 - tp)),
                              Am * ((1 - tp) %*% t(tp)),
                              Am * (tp %*% t(1 - tp)),
                              Am * (tp %*% t(tp))))
}

# Parameters
lambda &lt;- c(0.2, 0.3, -0.15, 0.25) 
Gamma  &lt;- c(4.5, 2.2, -0.9, 1.5, -1.2)
delta  &lt;- rep(c(2.6, 1.47, 0.85, 0.7, 0.5), 2) 

# Data
data   &lt;- data.frame(X, peer.avg(Anorm, cbind(x1 = X[,1], x2 =  X[,2])))
colnames(data) = c("x1", "x2", "gx1", "gx2")

ytmp   &lt;- simcdnet(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, Rbar = rep(5, 2),
                   lambda = lambda, Gamma = Gamma, delta = delta, group = group,
                   data = data)
y      &lt;- ytmp$y
hist(y, breaks = max(y) + 1)
table(y)
</code></pre>

<hr>
<h2 id='simnetwork'>Simulating network data</h2><span id='topic+simnetwork'></span>

<h3>Description</h3>

<p><code>simnetwork</code> simulates adjacency matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simnetwork(dnetwork, normalise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simnetwork_+3A_dnetwork">dnetwork</code></td>
<td>
<p>is a list of sub-network matrices, where the (i, j)-th position of the m-th matrix is the probability that i be connected to j, with i and j individuals from the m-th network.</p>
</td></tr>
<tr><td><code id="simnetwork_+3A_normalise">normalise</code></td>
<td>
<p>boolean takes <code>TRUE</code> if the returned matrices should be row-normalized and <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of (row-normalized) adjacency matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a list of adjacency matrices
## sub-network size
N         &lt;- c(250, 370, 120)  
## distribution
dnetwork  &lt;- lapply(N, function(x) matrix(runif(x^2), x))
## network
G         &lt;- simnetwork(dnetwork)
</code></pre>

<hr>
<h2 id='simsar'>Simulating data from linear-in-mean models with social interactions</h2><span id='topic+simsar'></span>

<h3>Description</h3>

<p><code>simsar</code> simulates continuous variables with social interactions (see Lee, 2004 and Lee et al., 2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simsar(formula, Glist, theta, cinfo = TRUE, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simsar_+3A_formula">formula</code></td>
<td>
<p>a class object <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. <code>formula</code> must be as, for example, <code>y ~ x1 + x2 + gx1 + gx2</code>
where <code>y</code> is the endogenous vector and <code>x1</code>, <code>x2</code>, <code>gx1</code> and <code>gx2</code> are control variables, which can include contextual variables, i.e. averages among the peers.
Peer averages can be computed using the function <code><a href="#topic+peer.avg">peer.avg</a></code>.</p>
</td></tr>
<tr><td><code id="simsar_+3A_glist">Glist</code></td>
<td>
<p>The network matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list of subnets with the <code>m</code>-th element being an <code>ns*ns</code> adjacency matrix, where <code>ns</code> is the number of nodes in the <code>m</code>-th subnet.</p>
</td></tr>
<tr><td><code id="simsar_+3A_theta">theta</code></td>
<td>
<p>a vector defining the true value of <code class="reqn">\theta = (\lambda, \Gamma, \sigma)</code> (see the model specification in details).</p>
</td></tr>
<tr><td><code id="simsar_+3A_cinfo">cinfo</code></td>
<td>
<p>a Boolean indicating whether information is complete (<code>cinfo = TRUE</code>) or incomplete (<code>cinfo = FALSE</code>). In the case of incomplete information, the model is defined under rational expectations.</p>
</td></tr>
<tr><td><code id="simsar_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>simsar</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a complete information model, the outcome <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">y_i = \lambda \bar{y}_i + \mathbf{z}_i'\Gamma + \epsilon_i,</code>
</p>

<p>where <code class="reqn">\bar{y}_i</code> is the average of <code class="reqn">y</code> among peers,
<code class="reqn">\mathbf{z}_i</code> is a vector of control variables,
and <code class="reqn">\epsilon_i \sim N(0, \sigma^2)</code>.
In the case of incomplete information models with rational expectations, <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">y_i = \lambda E(\bar{y}_i) + \mathbf{z}_i'\Gamma + \epsilon_i.</code>
</p>



<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>the observed count data.</p>
</td></tr>
<tr><td><code>Gy</code></td>
<td>
<p>the average of y among friends.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lee, L. F. (2004). Asymptotic distributions of quasi-maximum likelihood estimators for spatial autoregressive models. <em>Econometrica</em>, 72(6), 1899-1925, <a href="https://doi.org/10.1111/j.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>.
</p>
<p>Lee, L. F., Liu, X., &amp; Lin, X. (2010). Specification and estimation of social interaction models with network structures. The Econometrics Journal, 13(2), 145-176, <a href="https://doi.org/10.1111/j.1368-423X.2010.00310.x">doi:10.1111/j.1368-423X.2010.00310.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sar">sar</a></code>, <code><a href="#topic+simsart">simsart</a></code>, <code><a href="#topic+simcdnet">simcdnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Groups' size
set.seed(123)
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 1000))
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
Gamma  &lt;- c(2, -1.9, 0.8, 1.5, -1.2)
sigma  &lt;- 1.5
theta  &lt;- c(lambda, Gamma, sigma)

# X
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network
G      &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm/rs
  G[[m]]       &lt;- Gm
}

# data
data   &lt;- data.frame(X, peer.avg(G, cbind(x1 = X[,1], x2 =  X[,2])))
colnames(data) &lt;- c("x1", "x2", "gx1", "gx2")

ytmp    &lt;- simsar(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, 
                  theta = theta, data = data) 
y       &lt;- ytmp$y

</code></pre>

<hr>
<h2 id='simsart'>Simulating data from Tobit models with social interactions</h2><span id='topic+simsart'></span>

<h3>Description</h3>

<p><code>simsart</code> simulates censored data with social interactions (see Xu and Lee, 2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simsart(formula, Glist, theta, tol = 1e-15, maxit = 500, cinfo = TRUE, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simsart_+3A_formula">formula</code></td>
<td>
<p>a class object <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. <code>formula</code> must be as, for example, <code>y ~ x1 + x2 + gx1 + gx2</code>
where <code>y</code> is the endogenous vector and <code>x1</code>, <code>x2</code>, <code>gx1</code> and <code>gx2</code> are control variables, which can include contextual variables, i.e. averages among the peers.
Peer averages can be computed using the function <code><a href="#topic+peer.avg">peer.avg</a></code>.</p>
</td></tr>
<tr><td><code id="simsart_+3A_glist">Glist</code></td>
<td>
<p>The network matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list of subnets with the <code>m</code>-th element being an <code>ns*ns</code> adjacency matrix, where <code>ns</code> is the number of nodes in the <code>m</code>-th subnet.</p>
</td></tr>
<tr><td><code id="simsart_+3A_theta">theta</code></td>
<td>
<p>a vector defining the true value of <code class="reqn">\theta = (\lambda, \Gamma, \sigma)</code> (see the model specification in details).</p>
</td></tr>
<tr><td><code id="simsart_+3A_tol">tol</code></td>
<td>
<p>the tolerance value used in the fixed point iteration method to compute <code>y</code>. The process stops if the <code class="reqn">\ell_1</code>-distance
between two consecutive values of <code>y</code> is less than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="simsart_+3A_maxit">maxit</code></td>
<td>
<p>the maximal number of iterations in the fixed point iteration method.</p>
</td></tr>
<tr><td><code id="simsart_+3A_cinfo">cinfo</code></td>
<td>
<p>a Boolean indicating whether information is complete (<code>cinfo = TRUE</code>) or incomplete (<code>cinfo = FALSE</code>). In the case of incomplete information, the model is defined under rational expectations.</p>
</td></tr>
<tr><td><code id="simsart_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>simsart</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a complete information model, the outcome <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\begin{cases}y_i^{\ast} = \lambda \bar{y}_i + \mathbf{z}_i'\Gamma + \epsilon_i, \\ y_i = \max(0, y_i^{\ast}),\end{cases}</code>
</p>

<p>where <code class="reqn">\bar{y}_i</code> is the average of <code class="reqn">y</code> among peers,
<code class="reqn">\mathbf{z}_i</code> is a vector of control variables,
and <code class="reqn">\epsilon_i \sim N(0, \sigma^2)</code>.
In the case of incomplete information modelswith rational expectations, <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\begin{cases}y_i^{\ast} = \lambda E(\bar{y}_i) + \mathbf{z}_i'\Gamma + \epsilon_i, \\ y_i = \max(0, y_i^{\ast}).\end{cases}</code>
</p>



<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>yst</code></td>
<td>
<p><code class="reqn">y^{\ast}</code>, the latent variable.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the observed censored variable.</p>
</td></tr>
<tr><td><code>Ey</code></td>
<td>
<p><code class="reqn">E(y)</code>, the expectation of y.</p>
</td></tr>
<tr><td><code>Gy</code></td>
<td>
<p>the average of y among friends.</p>
</td></tr>
<tr><td><code>GEy</code></td>
<td>
<p>the average of <code class="reqn">E(y)</code> friends.</p>
</td></tr>
<tr><td><code>meff</code></td>
<td>
<p>a list includinh average and individual marginal effects.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>number of iterations performed by sub-network in the Fixed Point Iteration Method.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Xu, X., &amp; Lee, L. F. (2015). Maximum likelihood estimation of a spatial autoregressive Tobit model. <em>Journal of Econometrics</em>, 188(1), 264-280, <a href="https://doi.org/10.1016/j.jeconom.2015.05.004">doi:10.1016/j.jeconom.2015.05.004</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sart">sart</a></code>, <code><a href="#topic+simsar">simsar</a></code>, <code><a href="#topic+simcdnet">simcdnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Groups' size
set.seed(123)
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 200))
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
Gamma  &lt;- c(2, -1.9, 0.8, 1.5, -1.2)
sigma  &lt;- 1.5
theta  &lt;- c(lambda, Gamma, sigma)

# X
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network
G      &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm/rs
  G[[m]]       &lt;- Gm
}

# Data
data   &lt;- data.frame(X, peer.avg(G, cbind(x1 = X[,1], x2 =  X[,2])))
colnames(data) &lt;- c("x1", "x2", "gx1", "gx2")

## Complete information game
ytmp    &lt;- simsart(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, theta = theta, 
                   data = data, cinfo = TRUE)
data$yc &lt;- ytmp$y

## Incomplete information game
ytmp    &lt;- simsart(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, theta = theta, 
                   data = data, cinfo = FALSE)
data$yi &lt;- ytmp$y
</code></pre>

<hr>
<h2 id='summary.cdnet'>Summary for the estimation of count data models with social interactions under rational expectations</h2><span id='topic+summary.cdnet'></span><span id='topic+print.summary.cdnet'></span><span id='topic+print.cdnet'></span>

<h3>Description</h3>

<p>Summary and print methods for the class <code>cdnet</code> as returned by the function <a href="#topic+cdnet">cdnet</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cdnet'
summary(object, Glist, data, S = 1000L, ...)

## S3 method for class 'summary.cdnet'
print(x, ...)

## S3 method for class 'cdnet'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cdnet_+3A_object">object</code></td>
<td>
<p>an object of class <code>cdnet</code>, output of the function <code><a href="#topic+cdnet">cdnet</a></code>.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_glist">Glist</code></td>
<td>
<p>adjacency matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list of subnets with the <code>m</code>-th element being an <code>ns*ns</code> adjacency matrix, where <code>ns</code> is the number of nodes in the <code>m</code>-th subnet.
For heterogenous peer effects (e.g., boy-boy, boy-girl friendship effects), the <code>m</code>-th element can be a list of many <code>ns*ns</code> adjacency matrices corresponding to the different network specifications (see Houndetoungan, 2024).
For heterogeneous peer effects in the case of a single large network, <code>Glist</code> must be a one-item list. This item must be a list of many specifications of large networks.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>summary.cdnet</code> is called.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_s">S</code></td>
<td>
<p>number of simulations to be used to compute integral in the covariance by important sampling.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.cdnet</code>, output of the function <code><a href="#topic+summary.cdnet">summary.cdnet</a></code>
or class <code>cdnet</code>, output of the function <code><a href="#topic+cdnet">cdnet</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same objects in <code>object</code>.
</p>

<hr>
<h2 id='summary.sar'>Summary for the estimation of linear-in-mean models with social interactions</h2><span id='topic+summary.sar'></span><span id='topic+print.summary.sar'></span><span id='topic+print.sar'></span>

<h3>Description</h3>

<p>Summary and print methods for the class <code>sar</code> as returned by the function <a href="#topic+sar">sar</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sar'
summary(object, ...)

## S3 method for class 'summary.sar'
print(x, ...)

## S3 method for class 'sar'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sar_+3A_object">object</code></td>
<td>
<p>an object of class <code>sar</code>, output of the function <code><a href="#topic+sar">sar</a></code>.</p>
</td></tr>
<tr><td><code id="summary.sar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.sar_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.sar</code>, output of the function <code><a href="#topic+summary.sar">summary.sar</a></code> or
class <code>sar</code>, output of the function <code><a href="#topic+sar">sar</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same objects in <code>object</code>.
</p>

<hr>
<h2 id='summary.sart'>Summary for the estimation of Tobit models with social interactions</h2><span id='topic+summary.sart'></span><span id='topic+print.summary.sart'></span><span id='topic+print.sart'></span>

<h3>Description</h3>

<p>Summary and print methods for the class <code>sart</code> as returned by the function <a href="#topic+sart">sart</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sart'
summary(object, Glist, data, ...)

## S3 method for class 'summary.sart'
print(x, ...)

## S3 method for class 'sart'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sart_+3A_object">object</code></td>
<td>
<p>an object of class <code>sart</code>, output of the function <code><a href="#topic+sart">sart</a></code>.</p>
</td></tr>
<tr><td><code id="summary.sart_+3A_glist">Glist</code></td>
<td>
<p>adjacency matrix or list sub-adjacency matrix. This is not necessary if the covariance method was computed in <a href="#topic+cdnet">cdnet</a>.</p>
</td></tr>
<tr><td><code id="summary.sart_+3A_data">data</code></td>
<td>
<p>dataframe containing the explanatory variables. This is not necessary if the covariance method was computed in <a href="#topic+cdnet">cdnet</a>.</p>
</td></tr>
<tr><td><code id="summary.sart_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.sart_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.sart</code>, output of the function <code><a href="#topic+summary.sart">summary.sart</a></code>
or class <code>sart</code>, output of the function <code><a href="#topic+sart">sart</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same objects in <code>object</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
