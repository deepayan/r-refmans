<!DOCTYPE html><html lang="en-US"><head><title>Help for package CDatanet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CDatanet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CDatanet-package'><p>The CDatanet Package</p></a></li>
<li><a href='#cdnet'><p>Estimating Count Data Models with Social Interactions under Rational Expectations Using the NPL Method</p></a></li>
<li><a href='#homophili.data'><p>Converting Data between Directed Network Models and Symmetric Network Models.</p></a></li>
<li><a href='#homophily.fe'><p>Estimating Network Formation Models with Degree Heterogeneity: the Fixed Effect Approach</p></a></li>
<li><a href='#homophily.re'><p>Estimating Network Formation Models with Degree Heterogeneity: the Bayesian Random Effect Approach</p></a></li>
<li><a href='#norm.network'><p>Creating Objects for Network Models</p></a></li>
<li><a href='#peer.avg'><p>Computing Peer Averages</p></a></li>
<li><a href='#print.simcdEy'><p>Printing the Average Expected Outcomes for Count Data Models with Social Interactions</p></a></li>
<li><a href='#remove.ids'><p>Removing Identifiers with NA from Adjacency Matrices Optimally</p></a></li>
<li><a href='#sar'><p>Estimating Linear-in-mean Models with Social Interactions</p></a></li>
<li><a href='#sart'><p>Estimating Tobit Models with Social Interactions</p></a></li>
<li><a href='#simcdEy'><p>Counterfactual Analyses with Count Data Models and Social Interactions</p></a></li>
<li><a href='#simcdnet'><p>Simulating Count Data Models with Social Interactions Under Rational Expectations</p></a></li>
<li><a href='#simnetwork'><p>Simulating Network Data</p></a></li>
<li><a href='#simsar'><p>Simulating Data from Linear-in-Mean Models with Social Interactions</p></a></li>
<li><a href='#simsart'><p>Simulating Data from Tobit Models with Social Interactions</p></a></li>
<li><a href='#summary.cdnet'><p>Summary for the Estimation of Count Data Models with Social Interactions under Rational Expectations</p></a></li>
<li><a href='#summary.sar'><p>Summary for the Estimation of Linear-in-mean Models with Social Interactions</p></a></li>
<li><a href='#summary.sart'><p>Summary for the Estimation of Tobit Models with Social Interactions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Econometrics of Network Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-10</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulating and estimating peer effect models and network formation models. The class of peer effect models includes linear-in-means models (Lee, 2004; &lt;<a href="https://doi.org/10.1111%2Fj.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>&gt;), Tobit models (Xu and Lee, 2015; &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2015.05.004">doi:10.1016/j.jeconom.2015.05.004</a>&gt;), and discrete numerical data models (Houndetoungan, 2024; &lt;<a href="https://doi.org/10.2139%2Fssrn.3721250">doi:10.2139/ssrn.3721250</a>&gt;). The network formation models include pair-wise regressions with degree heterogeneity (Graham, 2017; &lt;<a href="https://doi.org/10.3982%2FECTA12679">doi:10.3982/ECTA12679</a>&gt;) and exponential random graph models (Mele, 2017; &lt;<a href="https://doi.org/10.3982%2FECTA10400">doi:10.3982/ECTA10400</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ahoundetoungan/CDatanet/issues">https://github.com/ahoundetoungan/CDatanet/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ahoundetoungan/CDatanet">https://github.com/ahoundetoungan/CDatanet</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), Formula, formula.tools, ddpcr, Matrix,
matrixcalc, foreach, doRNG, doParallel, parallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress, RcppDist, RcppNumerical,
RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, MASS, knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-02 01:01:19 UTC; haache</td>
</tr>
<tr>
<td>Author:</td>
<td>Aristide Houndetoungan [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aristide Houndetoungan &lt;ahoundetoungan@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-07 15:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='CDatanet-package'>The CDatanet Package</h2><span id='topic+CDatanet'></span><span id='topic+CDatanet-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">CDatanet</span> package simulates and estimates peer effect models and network formation models. The peer effect models include linear-in-means models (Lee, 2004; Lee et al., 2010),
Tobit models (Xu and Lee, 2015), and discrete numerical data models (Houndetoungan, 2024).
The network formation models include pairwise regressions with degree heterogeneity (Graham, 2017; Yan et al., 2019) and exponential random graph models (Mele, 2017).
To enhance computation speed, <span class="pkg">CDatanet</span> uses <code>C++</code> via the <span class="pkg">Rcpp</span> package (Eddelbuettel et al., 2011).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aristide Houndetoungan <a href="mailto:ahoundetoungan@gmail.com">ahoundetoungan@gmail.com</a>
</p>


<h3>References</h3>

<p>Eddelbuettel, D., &amp; Francois, R. (2011). <span class="pkg">Rcpp</span>: Seamless <span class="rlang"><b>R</b></span> and <code>C++</code> integration. <em>Journal of Statistical Software</em>, 40(8), 1-18, <a href="https://doi.org/10.18637/jss.v040.i08">doi:10.18637/jss.v040.i08</a>.
</p>
<p>Houndetoungan, E. A. (2024). Count Data Models with Heterogeneous Peer Effects. Available at SSRN 3721250, <a href="https://doi.org/10.2139/ssrn.3721250">doi:10.2139/ssrn.3721250</a>.
</p>
<p>Lee, L. F. (2004). Asymptotic distributions of quasi-maximum likelihood estimators for spatial autoregressive models. <em>Econometrica</em>, 72(6), 1899-1925, <a href="https://doi.org/10.1111/j.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>.
</p>
<p>Lee, L. F., Liu, X., &amp; Lin, X. (2010). Specification and estimation of social interaction models with network structures. The Econometrics Journal, 13(2), 145-176, <a href="https://doi.org/10.1111/j.1368-423X.2010.00310.x">doi:10.1111/j.1368-423X.2010.00310.x</a>
</p>
<p>Xu, X., &amp; Lee, L. F. (2015). Maximum likelihood estimation of a spatial autoregressive Tobit model. <em>Journal of Econometrics</em>, 188(1), 264-280, <a href="https://doi.org/10.1016/j.jeconom.2015.05.004">doi:10.1016/j.jeconom.2015.05.004</a>.
</p>
<p>Graham, B. S. (2017). An econometric model of network formation with degree heterogeneity. <em>Econometrica</em>, 85(4), 1033-1063, <a href="https://doi.org/10.3982/ECTA12679">doi:10.3982/ECTA12679</a>.
</p>
<p>Mele, A. (2017). A structural model of dense network formation. <em>Econometrica</em>, 85(3), 825-850, <a href="https://doi.org/10.3982/ECTA10400">doi:10.3982/ECTA10400</a>.
</p>
<p>Yan, T., Jiang, B., Fienberg, S. E., &amp; Leng, C. (2019). Statistical inference in a directed network model with covariates. <em>Journal of the American Statistical Association</em>, 114(526), 857-868, <a href="https://doi.org/10.1080/01621459.2018.1448829">doi:10.1080/01621459.2018.1448829</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ahoundetoungan/CDatanet">https://github.com/ahoundetoungan/CDatanet</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ahoundetoungan/CDatanet/issues">https://github.com/ahoundetoungan/CDatanet/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cdnet'>Estimating Count Data Models with Social Interactions under Rational Expectations Using the NPL Method</h2><span id='topic+cdnet'></span>

<h3>Description</h3>

<p><code>cdnet</code> estimates count data models with social interactions under rational expectations using the NPL algorithm (see Houndetoungan, 2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdnet(
  formula,
  Glist,
  group,
  Rmax,
  Rbar,
  starting = list(lambda = NULL, Gamma = NULL, delta = NULL),
  Ey0 = NULL,
  ubslambda = 1L,
  optimizer = "fastlbfgs",
  npl.ctr = list(),
  opt.ctr = list(),
  cov = TRUE,
  data
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdnet_+3A_formula">formula</code></td>
<td>
<p>a class object <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> must be, for example, <code>y ~ x1 + x2 + gx1 + gx2</code>, where <code>y</code> is the endogenous vector, and <code>x1</code>, <code>x2</code>, <code>gx1</code>, and <code>gx2</code> are control variables, which may include contextual variables (i.e., averages among the peers). Peer averages can be computed using the function <code><a href="#topic+peer.avg">peer.avg</a></code>.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_glist">Glist</code></td>
<td>
<p>adjacency matrix. For networks consisting of multiple subnets (e.g., schools), <code>Glist</code> can be a list of subnets, with the <code>m</code>-th element being an <code class="reqn">n_m \times n_m</code> adjacency matrix, where <code class="reqn">n_m</code> is the number of nodes in the <code>m</code>-th subnet. For heterogeneous peer effects (i.e., when <code>length(unique(group)) = h &gt; 1</code>), the <code>m</code>-th element must be a list of <code class="reqn">h^2</code> <code class="reqn">n_m \times n_m</code> adjacency matrices corresponding to the different network specifications (see Houndetoungan, 2024, Section 2.1). For heterogeneous peer effects in the case of a single large network (a single school), <code>Glist</code> must be a one-item list (since there is one school). This item must be a list of <code class="reqn">h^2</code> network specifications. The order in which the networks are specified is important and must match the order of the groups in <code>sort(unique(group))</code> (see argument <code>group</code> and examples).</p>
</td></tr>
<tr><td><code id="cdnet_+3A_group">group</code></td>
<td>
<p>a vector indicating the individual groups. The default assumes a common group. For two groups, i.e., <code>length(unique(group)) = 2</code> (e.g., <code>A</code> and <code>B</code>), four types of peer effects are defined: peer effects of <code>A</code> on <code>A</code>, of <code>A</code> on <code>B</code>, of <code>B</code> on <code>A</code>, and of <code>B</code> on <code>B</code>. In this case, in the argument <code>Glist</code>, the networks must be defined in this order: <code>AA</code>, <code>AB</code>, <code>BA</code>, <code>BB</code>.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_rmax">Rmax</code></td>
<td>
<p>an integer indicating the theoretical upper bound of <code>y</code> (see model specification in detail).</p>
</td></tr>
<tr><td><code id="cdnet_+3A_rbar">Rbar</code></td>
<td>
<p>an <code class="reqn">L</code>-vector, where <code class="reqn">L</code> is the number of groups. For large <code>Rmax</code>, the cost function is assumed to be semi-parametric (i.e., nonparametric from 0 to <code class="reqn">\bar{R}</code> and quadratic beyond <code class="reqn">\bar{R}</code>).</p>
</td></tr>
<tr><td><code id="cdnet_+3A_starting">starting</code></td>
<td>
<p>(optional) a starting value for <code class="reqn">\theta = (\lambda, \Gamma', \delta')</code>, where <code class="reqn">\lambda</code>, <code class="reqn">\Gamma</code>, and <code class="reqn">\delta</code> are the parameters to be estimated (see details).</p>
</td></tr>
<tr><td><code id="cdnet_+3A_ey0">Ey0</code></td>
<td>
<p>(optional) a starting value for <code class="reqn">E(y)</code>.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_ubslambda">ubslambda</code></td>
<td>
<p>a positive value indicating the upper bound of <code class="reqn">\sum_{s = 1}^S \lambda_s &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_optimizer">optimizer</code></td>
<td>
<p>specifies the optimization method, which can be one of: <code>fastlbfgs</code> (L-BFGS optimization method from the <span class="pkg">RcppNumerical</span> package), <code>nlm</code> (from the function <a href="stats.html#topic+nlm">nlm</a>), or <code>optim</code> (from the function <a href="stats.html#topic+optim">optim</a>). Arguments for these functions, such as <code>control</code> and <code>method</code>, can be set via the argument <code>opt.ctr</code>.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_npl.ctr">npl.ctr</code></td>
<td>
<p>a list of controls for the NPL method (see details).</p>
</td></tr>
<tr><td><code id="cdnet_+3A_opt.ctr">opt.ctr</code></td>
<td>
<p>a list of arguments to be passed to <code>optim_lbfgs</code> from the <span class="pkg">RcppNumerical</span> package, or to <a href="stats.html#topic+nlm">nlm</a> or <a href="stats.html#topic+optim">optim</a> (the solver specified in <code>optimizer</code>), such as <code>maxit</code>, <code>eps_f</code>, <code>eps_g</code>, <code>control</code>, <code>method</code>, etc.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_cov">cov</code></td>
<td>
<p>a Boolean indicating whether the covariance should be computed.</p>
</td></tr>
<tr><td><code id="cdnet_+3A_data">data</code></td>
<td>
<p>an optional data frame, list, or environment (or an object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>cdnet</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Model</h4>

<p>The count variable <code class="reqn">y_i</code> takes the value <code class="reqn">r</code> with probability.
</p>
<p style="text-align: center;"><code class="reqn">P_{ir} = F(\sum_{s = 1}^S \lambda_s \bar{y}_i^{e,s}  + \mathbf{z}_i'\Gamma - a_{h(i),r}) - F(\sum_{s = 1}^S \lambda_s \bar{y}_i^{e,s}  + \mathbf{z}_i'\Gamma - a_{h(i),r + 1}).</code>
</p>

<p>In this equation, <code class="reqn">\mathbf{z}_i</code> is a vector of control variables; <code class="reqn">F</code> is the distribution function of the standard normal distribution;
<code class="reqn">\bar{y}_i^{e,s}</code> is the average of <code class="reqn">E(y)</code> among peers using the <code>s</code>-th network definition;
<code class="reqn">a_{h(i),r}</code> is the <code>r</code>-th cut-point in the cost group <code class="reqn">h(i)</code>. <br /><br />
The following identification conditions have been introduced: <code class="reqn">\sum_{s = 1}^S \lambda_s &gt; 0</code>, <code class="reqn">a_{h(i),0} = -\infty</code>, <code class="reqn">a_{h(i),1} = 0</code>, and
<code class="reqn">a_{h(i),r} = \infty</code> for any <code class="reqn">r \geq R_{\text{max}} + 1</code>. The last condition implies that <code class="reqn">P_{ir} = 0</code> for any <code class="reqn">r \geq R_{\text{max}} + 1</code>.
For any <code class="reqn">r \geq 1</code>, the distance between two cut-points is <code class="reqn">a_{h(i),r+1} - a_{h(i),r} =  \delta_{h(i),r} + \sum_{s = 1}^S \lambda_s</code>.
As the number of cut-points can be large, a quadratic cost function is considered for <code class="reqn">r \geq \bar{R}_{h(i)}</code>, where <code class="reqn">\bar{R} = (\bar{R}_{1}, ..., \bar{R}_{L})</code>.
With the semi-parametric cost function,
<code class="reqn">a_{h(i),r + 1} - a_{h(i),r} = \bar{\delta}_{h(i)} + \sum_{s = 1}^S \lambda_s</code>.  <br /><br />
The model parameters are: <code class="reqn">\lambda = (\lambda_1, ..., \lambda_S)'</code>, <code class="reqn">\Gamma</code>, and <code class="reqn">\delta = (\delta_1', ..., \delta_L')'</code>,
where <code class="reqn">\delta_l = (\delta_{l,2}, ..., \delta_{l,\bar{R}_l}, \bar{\delta}_l)'</code> for <code class="reqn">l = 1, ..., L</code>.
The number of single parameters in <code class="reqn">\delta_l</code> depends on  <code class="reqn">R_{\text{max}}</code> and <code class="reqn">\bar{R}_l</code>. The components <code class="reqn">\delta_{l,2}, ..., \delta_{l,\bar{R}_l}</code> or/and
<code class="reqn">\bar{\delta}_l</code> must be removed in certain cases.<br />
If <code class="reqn">R_{\text{max}} = \bar{R}_l \geq 2</code>, then <code class="reqn">\delta_l = (\delta_{l,2}, ..., \delta_{l,\bar{R}_l})'</code>.<br />
If <code class="reqn">R_{\text{max}} = \bar{R}_l = 1</code> (binary models), then <code class="reqn">\delta_l</code> must be empty.<br />
If <code class="reqn">R_{\text{max}} &gt; \bar{R}_l = 1</code>, then <code class="reqn">\delta_l = \bar{\delta}_l</code>.
</p>



<h4><code>npl.ctr</code></h4>

<p>The model parameters are estimated using the Nested Partial Likelihood (NPL) method. This approach
begins with an initial guess for <code class="reqn">\theta</code> and <code class="reqn">E(y)</code> and iteratively refines them.
The solution converges when the <code class="reqn">\ell_1</code>-distance between two consecutive estimates of
<code class="reqn">\theta</code> and <code class="reqn">E(y)</code> is smaller than a specified tolerance.
</p>
<p>The argument <code>npl.ctr</code> must include the following parameters:
</p>

<dl>
<dt>tol</dt><dd><p>the tolerance level for the NPL algorithm (default is 1e-4).</p>
</dd>
<dt>maxit</dt><dd><p>the maximum number of iterations allowed (default is 500).</p>
</dd>
<dt>print</dt><dd><p>a boolean value indicating whether the estimates should be printed at each step.</p>
</dd>
<dt>S</dt><dd><p>the number of simulations performed to compute the integral in the covariance using importance sampling.</p>
</dd>
</dl>




<h3>Value</h3>

<p>A list consisting of:
</p>
<table role = "presentation">
<tr><td><code>info</code></td>
<td>
<p>a list containing general information about the model.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the NPL estimator.</p>
</td></tr>
<tr><td><code>Ey</code></td>
<td>
<p><code class="reqn">E(y)</code>, the expectation of <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code>GEy</code></td>
<td>
<p>the average of <code class="reqn">E(y)</code> across peers.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>a list that includes (if <code>cov == TRUE</code>): <code>parms</code>, the covariance matrix, and another list, <code>var.comp</code>, which contains <code>Sigma</code> (<code class="reqn">\Sigma</code>) and <code>Omega</code> (<code class="reqn">\Omega</code>), the matrices used to compute the covariance matrix.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>step-by-step output returned by the optimizer.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Houndetoungan, A. (2024). Count Data Models with Heterogeneous Peer Effects. Available at SSRN 3721250, <a href="https://doi.org/10.2139/ssrn.3721250">doi:10.2139/ssrn.3721250</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sart">sart</a></code>, <code><a href="#topic+sar">sar</a></code>, <code><a href="#topic+simcdnet">simcdnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 200))
n      &lt;- sum(nvec)

# Adjacency matrix
A      &lt;- list()
for (m in 1:M) {
  nm           &lt;- nvec[m]
  Am           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30 #maximum number of friends
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Am[i, tmp] &lt;- 1
  }
  A[[m]]       &lt;- Am
}
Anorm  &lt;- norm.network(A) #Row-normalization

# X
X      &lt;- cbind(rnorm(n, 1, 3), rexp(n, 0.4))

# Two group:
group  &lt;- 1*(X[,1] &gt; 0.95)

# Networks
# length(group) = 2 and unique(sort(group)) = c(0, 1)
# The networks must be defined as to capture:
# peer effects of `0` on `0`, peer effects of `1` on `0`
# peer effects of `0` on `1`, and peer effects of `1` on `1`
G        &lt;- list()
cums     &lt;- c(0, cumsum(nvec))
for (m in 1:M) {
  tp     &lt;- group[(cums[m] + 1):(cums[m + 1])]
  Am     &lt;- A[[m]]
  G[[m]] &lt;- norm.network(list(Am * ((1 - tp) %*% t(1 - tp)),
                              Am * ((1 - tp) %*% t(tp)),
                              Am * (tp %*% t(1 - tp)),
                              Am * (tp %*% t(tp))))
}

# Parameters
lambda &lt;- c(0.2, 0.3, -0.15, 0.25) 
Gamma  &lt;- c(4.5, 2.2, -0.9, 1.5, -1.2)
delta  &lt;- rep(c(2.6, 1.47, 0.85, 0.7, 0.5), 2) 

# Data
data   &lt;- data.frame(X, peer.avg(Anorm, cbind(x1 = X[,1], x2 =  X[,2])))
colnames(data) = c("x1", "x2", "gx1", "gx2")

ytmp   &lt;- simcdnet(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, Rbar = rep(5, 2),
                   lambda = lambda, Gamma = Gamma, delta = delta, group = group,
                   data = data)
y      &lt;- ytmp$y
hist(y, breaks = max(y) + 1)
table(y)

# Estimation
est    &lt;- cdnet(formula = y ~ x1 + x2 + gx1 + gx2, Glist = G, Rbar = rep(5, 2), group = group,
                optimizer = "fastlbfgs", data = data,
                opt.ctr = list(maxit = 5e3, eps_f = 1e-11, eps_g = 1e-11))
summary(est)

</code></pre>

<hr>
<h2 id='homophili.data'>Converting Data between Directed Network Models and Symmetric Network Models.</h2><span id='topic+homophili.data'></span>

<h3>Description</h3>

<p><code>homophili.data</code> converts the matrix of explanatory variables between directed network models and symmetric network models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homophili.data(data, nvec, to = c("lower", "upper", "symmetric"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="homophili.data_+3A_data">data</code></td>
<td>
<p>A <code>matrix</code> or <code>data.frame</code> of the explanatory variables of the network formation model. This
corresponds to the <code>X</code> matrix in <code><a href="#topic+homophily.fe">homophily.fe</a></code> or <code><a href="#topic+homophily.re">homophily.re</a></code>.</p>
</td></tr>
<tr><td><code id="homophili.data_+3A_nvec">nvec</code></td>
<td>
<p>A vector of the number of individuals in the networks.</p>
</td></tr>
<tr><td><code id="homophili.data_+3A_to">to</code></td>
<td>
<p>Indicates the direction of the conversion. For a matrix of explanatory variables <code>X</code> (<code>n*(n-1)</code> rows), one can
select lower triangular entries (<code>to = "lower"</code>) or upper triangular entries (<code>to = "upper"</code>).
For a triangular <code>X</code> (<code>n*(n-1)/2</code> rows), one can convert to a full matrix of <code>n*(n-1)</code> rows by using symmetry (<code>to = "symmetric"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformed <code>data.frame</code>.
</p>

<hr>
<h2 id='homophily.fe'>Estimating Network Formation Models with Degree Heterogeneity: the Fixed Effect Approach</h2><span id='topic+homophily.fe'></span>

<h3>Description</h3>

<p><code>homophily.fe</code> implements a Logit estimator for a network formation model with homophily. The model includes degree heterogeneity using fixed effects (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homophily.fe(
  network,
  formula,
  data,
  symmetry = FALSE,
  fe.way = 1,
  init = NULL,
  method = c("L-BFGS", "Block-NRaphson", "Mix"),
  ctr = list(maxit.opt = 10000, maxit.nr = 50, eps_f = 1e-09, eps_g = 1e-09, tol = 1e-04),
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="homophily.fe_+3A_network">network</code></td>
<td>
<p>A matrix or list of sub-matrices of social interactions containing 0 and 1, where links are represented by 1.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_formula">formula</code></td>
<td>
<p>An object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be, for example, <code>~ x1 + x2</code>,
where <code>x1</code> and <code>x2</code> are explanatory variables for link formation. If missing, the model is estimated with fixed effects only.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_data">data</code></td>
<td>
<p>An optional data frame, list, or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>homophily</code> is called.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_symmetry">symmetry</code></td>
<td>
<p>Indicates whether the network model is symmetric (see details).</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_fe.way">fe.way</code></td>
<td>
<p>Indicates whether it is a one-way or two-way fixed effect model. The expected value is 1 or 2 (see details).</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_init">init</code></td>
<td>
<p>(optional) Either a list of starting values containing <code>beta</code>, a K-dimensional vector of the explanatory variables' parameters,
<code>mu</code>, an n-dimensional vector, and <code>nu</code>, an n-dimensional vector, where K is the number of explanatory variables and n is the number of individuals;
or a vector of starting values for <code>c(beta, mu, nu)</code>.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_method">method</code></td>
<td>
<p>A character string specifying the optimization method. Expected values are <code>"L-BFGS"</code>, <code>"Block-NRaphson"</code>, or <code>"Mix"</code>.
<code>"Block-NRaphson"</code> refers to the <code>Newton-Raphson</code> method applied to each subnetwork, and <code>"Mix"</code> combines the <code>Newton-Raphson</code> method for <code>beta</code> with the <code>L-BFGS</code> method for the fixed effects.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_ctr">ctr</code></td>
<td>
<p>(optional) A list containing control parameters for the solver. For the <code>optim_lbfgs</code> method from the <span class="pkg">RcppNumerical</span> package,
the list should include <code>maxit.opt</code> (corresponding to <code>maxit</code> for the <code>L-BFGS</code> method), <code>eps_f</code>, and <code>eps_g</code>. For the <code>Block-NRaphson</code> method,
the list should include <code>maxit.nr</code> (corresponding to <code>maxit</code> for the <code>Newton-Raphson</code> method) and <code>tol</code>.</p>
</td></tr>
<tr><td><code id="homophily.fe_+3A_print">print</code></td>
<td>
<p>A boolean indicating if the estimation progression should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">p_{ij}</code> be the probability for a link to go from individual <code class="reqn">i</code> to individual <code class="reqn">j</code>.
This probability is specified for two-way effect models (<code>fe.way = 2</code>) as
</p>
<p style="text-align: center;"><code class="reqn">p_{ij} = F(\mathbf{x}_{ij}'\beta + \mu_i + \nu_j),</code>
</p>

<p>where <code class="reqn">F</code> is the cumulative distribution function of the standard logistic distribution. Unobserved degree heterogeneity is captured by
<code class="reqn">\mu_i</code> and <code class="reqn">\nu_j</code>. These are treated as fixed effects (see <code><a href="#topic+homophily.re">homophily.re</a></code> for random effect models).
As shown by Yan et al. (2019), the estimator of the parameter <code class="reqn">\beta</code> is biased. A bias correction is necessary but not implemented in this version. However,
the estimators of <code class="reqn">\mu_i</code> and <code class="reqn">\nu_j</code> are consistent.<br />
</p>
<p>For one-way fixed effect models (<code>fe.way = 1</code>), <code class="reqn">\nu_j = \mu_j</code>. For symmetric models, the network is not directed, and the fixed effects need to be one-way.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table role = "presentation">
<tr><td><code>model.info</code></td>
<td>
<p>A list of model information, such as the type of fixed effects, whether the model is symmetric,
the number of observations, etc.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The maximizer of the log-likelihood.</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>The maximized log-likelihood.</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>The returned value from the optimization solver, which contains details of the optimization. The solver used is <code>optim_lbfgs</code> from the
<span class="pkg">RcppNumerical</span> package.</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>The returned list of starting values.</p>
</td></tr>
<tr><td><code>loglike.init</code></td>
<td>
<p>The log-likelihood at the starting values.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Yan, T., Jiang, B., Fienberg, S. E., &amp; Leng, C. (2019). Statistical inference in a directed network model with covariates. <em>Journal of the American Statistical Association</em>, 114(526), 857-868, <a href="https://doi.org/10.1080/01621459.2018.1448829">doi:10.1080/01621459.2018.1448829</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+homophily.re">homophily.re</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
M            &lt;- 2 # Number of sub-groups
nvec         &lt;- round(runif(M, 20, 50))
beta         &lt;- c(.1, -.1)
Glist        &lt;- list()
dX           &lt;- matrix(0, 0, 2)
mu           &lt;- list()
nu           &lt;- list()
Emunu        &lt;- runif(M, -1.5, 0) # Expectation of mu + nu
smu2         &lt;- 0.2
snu2         &lt;- 0.2
for (m in 1:M) {
  n          &lt;- nvec[m]
  mum        &lt;- rnorm(n, 0.7*Emunu[m], smu2)
  num        &lt;- rnorm(n, 0.3*Emunu[m], snu2)
  X1         &lt;- rnorm(n, 0, 1)
  X2         &lt;- rbinom(n, 1, 0.2)
  Z1         &lt;- matrix(0, n, n)  
  Z2         &lt;- matrix(0, n, n)
  
  for (i in 1:n) {
    for (j in 1:n) {
      Z1[i, j] &lt;- abs(X1[i] - X1[j])
      Z2[i, j] &lt;- 1*(X2[i] == X2[j])
    }
  }
  
  Gm           &lt;- 1*((Z1*beta[1] + Z2*beta[2] +
                       kronecker(mum, t(num), "+") + rlogis(n^2)) &gt; 0)
  diag(Gm)     &lt;- 0
  diag(Z1)     &lt;- NA
  diag(Z2)     &lt;- NA
  Z1           &lt;- Z1[!is.na(Z1)]
  Z2           &lt;- Z2[!is.na(Z2)]
  
  dX           &lt;- rbind(dX, cbind(Z1, Z2))
  Glist[[m]]   &lt;- Gm
  mu[[m]]      &lt;- mum
  nu[[m]]      &lt;- num
}

mu  &lt;- unlist(mu)
nu  &lt;- unlist(nu)

out   &lt;- homophily.fe(network =  Glist, formula = ~ -1 + dX, fe.way = 2)
muhat &lt;- out$estimate$mu
nuhat &lt;- out$estimate$nu
plot(mu, muhat)
plot(nu, nuhat)

</code></pre>

<hr>
<h2 id='homophily.re'>Estimating Network Formation Models with Degree Heterogeneity: the Bayesian Random Effect Approach</h2><span id='topic+homophily.re'></span>

<h3>Description</h3>

<p><code>homophily.re</code> implements a Bayesian Probit estimator for network formation model with homophily. The model includes degree heterogeneity using random effects (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homophily.re(
  network,
  formula,
  data,
  symmetry = FALSE,
  group.fe = FALSE,
  re.way = 1,
  init = list(),
  iteration = 1000,
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="homophily.re_+3A_network">network</code></td>
<td>
<p>matrix or list of sub-matrix of social interactions containing 0 and 1, where links are represented by 1.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_formula">formula</code></td>
<td>
<p>an object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be as for example <code>~ x1 + x2</code>
where <code>x1</code>, <code>x2</code> are explanatory variables for links formation.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_data">data</code></td>
<td>
<p>an optional data frame, list, or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>homophily</code> is called.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_symmetry">symmetry</code></td>
<td>
<p>indicates whether the network model is symmetric (see details).</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_group.fe">group.fe</code></td>
<td>
<p>indicates whether the model includes group fixed effects.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_re.way">re.way</code></td>
<td>
<p>indicates whether it is a one-way or two-way random effect model. The expected value is 1 or 2 (see details).</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_init">init</code></td>
<td>
<p>(optional) list of starting values containing <code>beta</code>, a K-dimensional vector of the explanatory variables parameter,
<code>mu</code>, an n-dimensional vector, and <code>nu</code>, an n-dimensional vector, <code>smu2</code> the variance of <code>mu</code>,
and <code>snu2</code> the variance of <code>nu</code>, where K is the number of explanatory variables and n is the number of individuals.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_iteration">iteration</code></td>
<td>
<p>the number of iterations to be performed.</p>
</td></tr>
<tr><td><code id="homophily.re_+3A_print">print</code></td>
<td>
<p>boolean indicating if the estimation progression should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">p_{ij}</code> be a probability for a link to go from the individual <code class="reqn">i</code> to the individual <code class="reqn">j</code>.
This probability is specified for two-way effect models (<code>re.way = 2</code>) as
</p>
<p style="text-align: center;"><code class="reqn">p_{ij} = F(\mathbf{x}_{ij}'\beta + \mu_i + \nu_j),</code>
</p>

<p>where <code class="reqn">F</code> is the cumulative of the standard normal distribution. Unobserved degree heterogeneity is captured by
<code class="reqn">\mu_i</code> and <code class="reqn">\nu_j</code>. The latter are treated as random effects (see <code><a href="#topic+homophily.fe">homophily.fe</a></code> for fixed effect models).<br />
For one-way random effect models (<code>re.way = 1</code>), <code class="reqn">\nu_j = \mu_j</code>. For symmetric models, the network is not directed and the
random effects need to be one way.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table role = "presentation">
<tr><td><code>model.info</code></td>
<td>
<p>list of model information, such as the type of random effects, whether the model is symmetric,
number of observations, etc.</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>list of simulations from the posterior distribution.</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>returned list of starting values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+homophily.fe">homophily.fe</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
library(MASS)
M            &lt;- 4 # Number of sub-groups
nvec         &lt;- round(runif(M, 100, 500))
beta         &lt;- c(.1, -.1)
Glist        &lt;- list()
dX           &lt;- matrix(0, 0, 2)
mu           &lt;- list()
nu           &lt;- list()
cst          &lt;- runif(M, -1.5, 0)
smu2         &lt;- 0.2
snu2         &lt;- 0.2
rho          &lt;- 0.8
Smunu        &lt;- matrix(c(smu2, rho*sqrt(smu2*snu2), rho*sqrt(smu2*snu2), snu2), 2)
for (m in 1:M) {
  n          &lt;- nvec[m]
  tmp        &lt;- mvrnorm(n, c(0, 0), Smunu)
  mum        &lt;- tmp[,1] - mean(tmp[,1])
  num        &lt;- tmp[,2] - mean(tmp[,2])
  X1         &lt;- rnorm(n, 0, 1)
  X2         &lt;- rbinom(n, 1, 0.2)
  Z1         &lt;- matrix(0, n, n)  
  Z2         &lt;- matrix(0, n, n)
  
  for (i in 1:n) {
    for (j in 1:n) {
      Z1[i, j] &lt;- abs(X1[i] - X1[j])
      Z2[i, j] &lt;- 1*(X2[i] == X2[j])
    }
  }
  
  Gm           &lt;- 1*((cst[m] + Z1*beta[1] + Z2*beta[2] +
                       kronecker(mum, t(num), "+") + rnorm(n^2)) &gt; 0)
  diag(Gm)     &lt;- 0
  diag(Z1)     &lt;- NA
  diag(Z2)     &lt;- NA
  Z1           &lt;- Z1[!is.na(Z1)]
  Z2           &lt;- Z2[!is.na(Z2)]
  
  dX           &lt;- rbind(dX, cbind(Z1, Z2))
  Glist[[m]]   &lt;- Gm
  mu[[m]]      &lt;- mum
  nu[[m]]      &lt;- num
}

mu  &lt;- unlist(mu)
nu  &lt;- unlist(nu)

out   &lt;- homophily.re(network =  Glist, formula = ~ dX, group.fe = TRUE, 
                      re.way = 2, iteration = 1e3)

# plot simulations
plot(out$posterior$beta[,1], type = "l")
abline(h = cst[1], col = "red")
plot(out$posterior$beta[,2], type = "l")
abline(h = cst[2], col = "red")
plot(out$posterior$beta[,3], type = "l")
abline(h = cst[3], col = "red")
plot(out$posterior$beta[,4], type = "l")
abline(h = cst[4], col = "red")

plot(out$posterior$beta[,5], type = "l")
abline(h = beta[1], col = "red")
plot(out$posterior$beta[,6], type = "l")
abline(h = beta[2], col = "red")

plot(out$posterior$sigma2_mu, type = "l")
abline(h = smu2, col = "red")
plot(out$posterior$sigma2_nu, type = "l")
abline(h = snu2, col = "red")
plot(out$posterior$rho, type = "l")
abline(h = rho, col = "red")

i &lt;- 10
plot(out$posterior$mu[,i], type = "l")
abline(h = mu[i], col = "red")
plot(out$posterior$nu[,i], type = "l")
abline(h = nu[i], col = "red")

</code></pre>

<hr>
<h2 id='norm.network'>Creating Objects for Network Models</h2><span id='topic+norm.network'></span><span id='topic+vec.to.mat'></span><span id='topic+mat.to.vec'></span>

<h3>Description</h3>

<p>The <code>vec.to.mat</code> function creates a list of square matrices from a given vector.
Elements of the generated matrices are taken from the vector and placed column-wise or row-wise, progressing from the first matrix in the list to the last.
The diagonals of the generated matrices are set to zeros.<br />
The <code>mat.to.vec</code> function creates a vector from a given list of square matrices.
Elements of the generated vector are taken column-wise or row-wise, starting from the first matrix in the list to the last, excluding diagonal entries.<br />
The <code>norm.network</code> function row-normalizes matrices in a given list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm.network(W)

vec.to.mat(u, N, normalise = FALSE, byrow = FALSE)

mat.to.vec(W, ceiled = FALSE, byrow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm.network_+3A_w">W</code></td>
<td>
<p>A matrix or list of matrices to convert.</p>
</td></tr>
<tr><td><code id="norm.network_+3A_u">u</code></td>
<td>
<p>A numeric vector to convert.</p>
</td></tr>
<tr><td><code id="norm.network_+3A_n">N</code></td>
<td>
<p>A vector of sub-network sizes such that <code>length(u) == sum(N * (N - 1))</code>.</p>
</td></tr>
<tr><td><code id="norm.network_+3A_normalise">normalise</code></td>
<td>
<p>A boolean indicating whether the returned matrices should be row-normalized (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="norm.network_+3A_byrow">byrow</code></td>
<td>
<p>A boolean indicating whether entries in the matrices should be taken by row (<code>TRUE</code>) or by column (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="norm.network_+3A_ceiled">ceiled</code></td>
<td>
<p>A boolean indicating whether the given matrices should be ceiled before conversion (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>sum(N * (N - 1))</code> or a list of <code>length(N)</code> square matrices, with matrix sizes determined by <code style="white-space: pre;">&#8288;N[1], N[2], ...&#8288;</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simnetwork">simnetwork</a></code>, <code><a href="#topic+peer.avg">peer.avg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a list of adjacency matrices
## Sub-network sizes
N &lt;- c(250, 370, 120)  
## Rate of friendship
p &lt;- c(0.2, 0.15, 0.18)   
## Network data
u &lt;- unlist(lapply(1:3, function(x) rbinom(N[x] * (N[x] - 1), 1, p[x])))
W &lt;- vec.to.mat(u, N)

# Convert W into a list of row-normalized matrices
G &lt;- norm.network(W)

# Recover u
v &lt;- mat.to.vec(G, ceiled = TRUE)
all.equal(u, v)
</code></pre>

<hr>
<h2 id='peer.avg'>Computing Peer Averages</h2><span id='topic+peer.avg'></span>

<h3>Description</h3>

<p>The <code>peer.avg</code> function computes peer average values using network data (provided as a list of adjacency matrices) and observable characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peer.avg(Glist, V, export.as.list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peer.avg_+3A_glist">Glist</code></td>
<td>
<p>An adjacency matrix or a list of sub-adjacency matrices representing the network structure.</p>
</td></tr>
<tr><td><code id="peer.avg_+3A_v">V</code></td>
<td>
<p>A vector or matrix of observable characteristics.</p>
</td></tr>
<tr><td><code id="peer.avg_+3A_export.as.list">export.as.list</code></td>
<td>
<p>(optional) A boolean indicating whether the output should be a list of matrices (<code>TRUE</code>) or a single matrix (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix product <code>diag(Glist[[1]], Glist[[2]], ...) %*% V</code>, where <code>diag()</code> represents the block diagonal operator.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simnetwork">simnetwork</a></code>, <code><a href="#topic+vec.to.mat">vec.to.mat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a list of adjacency matrices
## Sub-network sizes
N &lt;- c(250, 370, 120)  
## Rate of friendship
p &lt;- c(0.2, 0.15, 0.18)   
## Network data
u &lt;- unlist(lapply(1:3, function(x) rbinom(N[x] * (N[x] - 1), 1, p[x])))
G &lt;- vec.to.mat(u, N, normalise = TRUE)

# Generate a vector y
y &lt;- rnorm(sum(N))

# Compute G %*% y
Gy &lt;- peer.avg(Glist = G, V = y)
</code></pre>

<hr>
<h2 id='print.simcdEy'>Printing the Average Expected Outcomes for Count Data Models with Social Interactions</h2><span id='topic+print.simcdEy'></span><span id='topic+summary.simcdEy'></span><span id='topic+print.summary.simcdEy'></span>

<h3>Description</h3>

<p>Summary and print methods for the class <code>simcdEy</code> as returned by the function <a href="#topic+simcdEy">simcdEy</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simcdEy'
print(x, ...)

## S3 method for class 'simcdEy'
summary(object, ...)

## S3 method for class 'summary.simcdEy'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.simcdEy_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.simcdEy</code>, output of the function <code><a href="#topic+summary.simcdEy">summary.simcdEy</a></code> or class <code>simcdEy</code>, output of the function <code><a href="#topic+simcdEy">simcdEy</a></code>.</p>
</td></tr>
<tr><td><code id="print.simcdEy_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="print.simcdEy_+3A_object">object</code></td>
<td>
<p>an object of class <code>simcdEy</code>, output of the function <code><a href="#topic+simcdEy">simcdEy</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same objects in <code>object</code>.
</p>

<hr>
<h2 id='remove.ids'>Removing Identifiers with NA from Adjacency Matrices Optimally</h2><span id='topic+remove.ids'></span>

<h3>Description</h3>

<p>The <code>remove.ids</code> function removes identifiers with missing values (NA) from adjacency matrices in an optimal way.
Multiple combinations of rows and columns can be deleted to eliminate NAs, but this function ensures that the smallest
number of rows and columns are removed to retain as much data as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.ids(network, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove.ids_+3A_network">network</code></td>
<td>
<p>A list of adjacency matrices to process.</p>
</td></tr>
<tr><td><code id="remove.ids_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to use for parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>network</dt><dd><p>A list of adjacency matrices without missing values.</p>
</dd>
<dt>id</dt><dd><p>A list of vectors indicating the indices of retained rows and columns for each matrix.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Small adjacency matrix
A &lt;- matrix(1:25, 5)
A[1, 1] &lt;- NA
A[4, 2] &lt;- NA
remove.ids(A)

# Example 2: Larger adjacency matrix with multiple NAs
B &lt;- matrix(1:100, 10)
B[1, 1] &lt;- NA
B[4, 2] &lt;- NA
B[2, 4] &lt;- NA
B[, 8] &lt;- NA
remove.ids(B)
</code></pre>

<hr>
<h2 id='sar'>Estimating Linear-in-mean Models with Social Interactions</h2><span id='topic+sar'></span>

<h3>Description</h3>

<p><code>sar</code> computes quasi-maximum likelihood estimators for linear-in-mean models with social interactions (see Lee, 2004 and Lee et al., 2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar(
  formula,
  Glist,
  lambda0 = NULL,
  fixed.effects = FALSE,
  optimizer = "optim",
  opt.ctr = list(),
  print = TRUE,
  cov = TRUE,
  cinfo = TRUE,
  data
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sar_+3A_formula">formula</code></td>
<td>
<p>a class object <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. <code>formula</code> must be as, for example, <code>y ~ x1 + x2 + gx1 + gx2</code>
where <code>y</code> is the endogenous vector and <code>x1</code>, <code>x2</code>, <code>gx1</code> and <code>gx2</code> are control variables, which can include contextual variables, i.e. averages among the peers.
Peer averages can be computed using the function <code><a href="#topic+peer.avg">peer.avg</a></code>.</p>
</td></tr>
<tr><td><code id="sar_+3A_glist">Glist</code></td>
<td>
<p>The network matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list of subnets with the <code>m</code>-th element being an <code>ns*ns</code> adjacency matrix, where <code>ns</code> is the number of nodes in the <code>m</code>-th subnet.</p>
</td></tr>
<tr><td><code id="sar_+3A_lambda0">lambda0</code></td>
<td>
<p>an optional starting value of <code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code id="sar_+3A_fixed.effects">fixed.effects</code></td>
<td>
<p>a Boolean indicating whether group heterogeneity must be included as fixed effects.</p>
</td></tr>
<tr><td><code id="sar_+3A_optimizer">optimizer</code></td>
<td>
<p>is either <code>nlm</code> (referring to the function <a href="stats.html#topic+nlm">nlm</a>) or <code>optim</code> (referring to the function <a href="stats.html#topic+optim">optim</a>).
Arguments for these functions such as, <code>control</code> and <code>method</code> can be set via the argument <code>opt.ctr</code>.</p>
</td></tr>
<tr><td><code id="sar_+3A_opt.ctr">opt.ctr</code></td>
<td>
<p>list of arguments of <a href="stats.html#topic+nlm">nlm</a> or <a href="stats.html#topic+optim">optim</a> (the one set in <code>optimizer</code>) such as <code>control</code>, <code>method</code>, etc.</p>
</td></tr>
<tr><td><code id="sar_+3A_print">print</code></td>
<td>
<p>a Boolean indicating if the estimate should be printed at each step.</p>
</td></tr>
<tr><td><code id="sar_+3A_cov">cov</code></td>
<td>
<p>a Boolean indicating if the covariance should be computed.</p>
</td></tr>
<tr><td><code id="sar_+3A_cinfo">cinfo</code></td>
<td>
<p>a Boolean indicating whether information is complete (<code>cinfo = TRUE</code>) or incomplete (<code>cinfo = FALSE</code>). In the case of incomplete information, the model is defined under rational expectations.</p>
</td></tr>
<tr><td><code id="sar_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>sar</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the complete information model, the outcome <code class="reqn">y_i</code> for individual <code class="reqn">i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">y_i = \lambda \bar{y}_i + \mathbf{z}_i'\Gamma + \epsilon_i,</code>
</p>

<p>where <code class="reqn">\bar{y}_i</code> represents the average outcome <code class="reqn">y</code> among individual <code class="reqn">i</code>'s peers,
<code class="reqn">\mathbf{z}_i</code> is a vector of control variables, and <code class="reqn">\epsilon_i \sim N(0, \sigma^2)</code> is the error term.
In the case of incomplete information models with rational expectations, the outcome <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">y_i = \lambda E(\bar{y}_i) + \mathbf{z}_i'\Gamma + \epsilon_i,</code>
</p>

<p>where <code class="reqn">E(\bar{y}_i)</code> is the expected average outcome of <code class="reqn">i</code>'s peers, as perceived by individual <code class="reqn">i</code>.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table role = "presentation">
<tr><td><code>info</code></td>
<td>
<p>list of general information on the model.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Maximum Likelihood (ML) estimator.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>covariance matrix of the estimate.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>outputs as returned by the optimizer.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lee, L. F. (2004). Asymptotic distributions of quasi-maximum likelihood estimators for spatial autoregressive models. <em>Econometrica</em>, 72(6), 1899-1925, <a href="https://doi.org/10.1111/j.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>.
</p>
<p>Lee, L. F., Liu, X., &amp; Lin, X. (2010). Specification and estimation of social interaction models with network structures. The Econometrics Journal, 13(2), 145-176, <a href="https://doi.org/10.1111/j.1368-423X.2010.00310.x">doi:10.1111/j.1368-423X.2010.00310.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sart">sart</a></code>, <code><a href="#topic+cdnet">cdnet</a></code>, <code><a href="#topic+simsar">simsar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Groups' size
set.seed(123)
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 1000))
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
Gamma  &lt;- c(2, -1.9, 0.8, 1.5, -1.2)
sigma  &lt;- 1.5
theta  &lt;- c(lambda, Gamma, sigma)

# X
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network
G      &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm/rs
  G[[m]]       &lt;- Gm
}

# data
data   &lt;- data.frame(X, peer.avg(G, cbind(x1 = X[,1], x2 =  X[,2])))
colnames(data) &lt;- c("x1", "x2", "gx1", "gx2")

ytmp    &lt;- simsar(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, 
                  theta = theta, data = data) 
data$y  &lt;- ytmp$y

out     &lt;- sar(formula = y ~ x1 + x2 + gx1 + gx2, Glist = G, 
               optimizer = "optim", data = data)
summary(out)

</code></pre>

<hr>
<h2 id='sart'>Estimating Tobit Models with Social Interactions</h2><span id='topic+sart'></span>

<h3>Description</h3>

<p><code>sart</code> estimates Tobit models with social interactions based on the framework of Xu and Lee (2015).
The method allows for modeling both complete and incomplete information scenarios in networks, incorporating rational expectations in the latter case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sart(
  formula,
  Glist,
  starting = NULL,
  Ey0 = NULL,
  optimizer = "fastlbfgs",
  npl.ctr = list(),
  opt.ctr = list(),
  cov = TRUE,
  cinfo = TRUE,
  data
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sart_+3A_formula">formula</code></td>
<td>
<p>An object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The formula must follow the structure,
e.g., <code>y ~ x1 + x2 + gx1 + gx2</code>, where <code>y</code> is the endogenous variable, and <code>x1</code>, <code>x2</code>, <code>gx1</code>, and <code>gx2</code> are control variables.
Control variables may include contextual variables, such as peer averages, which can be computed using <code><a href="#topic+peer.avg">peer.avg</a></code>.</p>
</td></tr>
<tr><td><code id="sart_+3A_glist">Glist</code></td>
<td>
<p>The network matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list, where the <code>m</code>-th element is
an <code>ns*ns</code> adjacency matrix representing the <code>m</code>-th subnet, with <code>ns</code> being the number of nodes in that subnet.</p>
</td></tr>
<tr><td><code id="sart_+3A_starting">starting</code></td>
<td>
<p>(Optional) A vector of starting values for <code class="reqn">\theta = (\lambda, \Gamma, \sigma)</code>, where:
</p>

<ul>
<li> <p><code class="reqn">\lambda</code> is the peer effect coefficient,
</p>
</li>
<li> <p><code class="reqn">\Gamma</code> is the vector of control variable coefficients,
</p>
</li>
<li> <p><code class="reqn">\sigma</code> is the standard deviation of the error term.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sart_+3A_ey0">Ey0</code></td>
<td>
<p>(Optional) A starting value for <code class="reqn">E(y)</code>.</p>
</td></tr>
<tr><td><code id="sart_+3A_optimizer">optimizer</code></td>
<td>
<p>The optimization method to be used. Choices are:
</p>

<ul>
<li> <p><code>"fastlbfgs"</code>: L-BFGS optimization method from the <span class="pkg">RcppNumerical</span> package,
</p>
</li>
<li> <p><code>"nlm"</code>: Refers to the <a href="stats.html#topic+nlm">nlm</a> function,
</p>
</li>
<li> <p><code>"optim"</code>: Refers to the <a href="stats.html#topic+optim">optim</a> function.
</p>
</li></ul>

<p>Additional arguments for these functions, such as <code>control</code> and <code>method</code>, can be specified through the <code>opt.ctr</code> argument.</p>
</td></tr>
<tr><td><code id="sart_+3A_npl.ctr">npl.ctr</code></td>
<td>
<p>A list of controls for the NPL (Nested Pseudo-Likelihood) method (refer to the details in <code><a href="#topic+cdnet">cdnet</a></code>).</p>
</td></tr>
<tr><td><code id="sart_+3A_opt.ctr">opt.ctr</code></td>
<td>
<p>A list of arguments to be passed to the chosen solver (<code>fastlbfgs</code>, <a href="stats.html#topic+nlm">nlm</a>, or <a href="stats.html#topic+optim">optim</a>),
such as <code>maxit</code>, <code>eps_f</code>, <code>eps_g</code>, <code>control</code>, <code>method</code>, etc.</p>
</td></tr>
<tr><td><code id="sart_+3A_cov">cov</code></td>
<td>
<p>A Boolean indicating whether to compute the covariance matrix (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="sart_+3A_cinfo">cinfo</code></td>
<td>
<p>A Boolean indicating whether the information structure is complete (<code>TRUE</code>) or incomplete (<code>FALSE</code>).
Under incomplete information, the model is defined with rational expectations.</p>
</td></tr>
<tr><td><code id="sart_+3A_data">data</code></td>
<td>
<p>An optional data frame, list, or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a>) containing the variables
in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>sart</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a complete information model, the outcome <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\begin{cases}
y_i^{\ast} = \lambda \bar{y}_i + \mathbf{z}_i'\Gamma + \epsilon_i, \\ 
y_i = \max(0, y_i^{\ast}),
\end{cases}</code>
</p>

<p>where <code class="reqn">\bar{y}_i</code> is the average of <code class="reqn">y</code> among peers,
<code class="reqn">\mathbf{z}_i</code> is a vector of control variables,
and <code class="reqn">\epsilon_i \sim N(0, \sigma^2)</code>. <br />
</p>
<p>In the case of incomplete information models with rational expectations, <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\begin{cases}
y_i^{\ast} = \lambda E(\bar{y}_i) + \mathbf{z}_i'\Gamma + \epsilon_i, \\ 
y_i = \max(0, y_i^{\ast}).
\end{cases}</code>
</p>



<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt><code>info</code></dt><dd><p>General information about the model.</p>
</dd>
<dt><code>estimate</code></dt><dd><p>The Maximum Likelihood (ML) estimates of the parameters.</p>
</dd>
<dt><code>Ey</code></dt><dd><p><code class="reqn">E(y)</code>, the expected values of the endogenous variable.</p>
</dd>
<dt><code>GEy</code></dt><dd><p>The average of <code class="reqn">E(y)</code> among peers.</p>
</dd>
<dt><code>cov</code></dt><dd><p>A list including covariance matrices (if <code>cov = TRUE</code>).</p>
</dd>
<dt><code>details</code></dt><dd><p>Additional outputs returned by the optimizer.</p>
</dd>
</dl>



<h3>References</h3>

<p>Xu, X., &amp; Lee, L. F. (2015). Maximum likelihood estimation of a spatial autoregressive Tobit model. <em>Journal of Econometrics</em>, 188(1), 264-280, <a href="https://doi.org/10.1016/j.jeconom.2015.05.004">doi:10.1016/j.jeconom.2015.05.004</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sar">sar</a></code>, <code><a href="#topic+cdnet">cdnet</a></code>, <code><a href="#topic+simsart">simsart</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Group sizes
set.seed(123)
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 200))
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
Gamma  &lt;- c(2, -1.9, 0.8, 1.5, -1.2)
sigma  &lt;- 1.5
theta  &lt;- c(lambda, Gamma, sigma)

# Covariates (X)
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network creation
G      &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm / rs
  G[[m]]       &lt;- Gm
}

# Data creation
data   &lt;- data.frame(X, peer.avg(G, cbind(x1 = X[, 1], x2 = X[, 2])))
colnames(data) &lt;- c("x1", "x2", "gx1", "gx2")

## Complete information game
ytmp    &lt;- simsart(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, theta = theta, 
                   data = data, cinfo = TRUE)
data$yc &lt;- ytmp$y

## Incomplete information game
ytmp    &lt;- simsart(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, theta = theta, 
                   data = data, cinfo = FALSE)
data$yi &lt;- ytmp$y

# Complete information estimation for yc
outc1   &lt;- sart(formula = yc ~ x1 + x2 + gx1 + gx2, optimizer = "nlm",
                Glist = G, data = data, cinfo = TRUE)
summary(outc1)

# Complete information estimation for yi
outc1   &lt;- sart(formula = yi ~ x1 + x2 + gx1 + gx2, optimizer = "nlm",
                Glist = G, data = data, cinfo = TRUE)
summary(outc1)

# Incomplete information estimation for yc
outi1   &lt;- sart(formula = yc ~ x1 + x2 + gx1 + gx2, optimizer = "nlm",
                Glist = G, data = data, cinfo = FALSE)
summary(outi1)

# Incomplete information estimation for yi
outi1   &lt;- sart(formula = yi ~ x1 + x2 + gx1 + gx2, optimizer = "nlm",
                Glist = G, data = data, cinfo = FALSE)
summary(outi1)

</code></pre>

<hr>
<h2 id='simcdEy'>Counterfactual Analyses with Count Data Models and Social Interactions</h2><span id='topic+simcdEy'></span>

<h3>Description</h3>

<p><code>simcdpar</code> computes the average expected outcomes for count data models with social interactions and standard errors using the Delta method.
This function can be used to examine the effects of changes in the network or in the control variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simcdEy(object, Glist, data, group, tol = 1e-10, maxit = 500, S = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simcdEy_+3A_object">object</code></td>
<td>
<p>an object of class <code>summary.cdnet</code>, output of the function <code><a href="#topic+summary.cdnet">summary.cdnet</a></code> or class <code>cdnet</code>, output of the function <code><a href="#topic+cdnet">cdnet</a></code>.</p>
</td></tr>
<tr><td><code id="simcdEy_+3A_glist">Glist</code></td>
<td>
<p>adjacency matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list of subnets with the <code>m</code>-th element being an <code>ns*ns</code> adjacency matrix, where <code>ns</code> is the number of nodes in the <code>m</code>-th subnet.
For heterogeneous peer effects (e.g., boy-boy, boy-girl friendship effects), the <code>m</code>-th element can be a list of many <code>ns*ns</code> adjacency matrices corresponding to the different network specifications (see Houndetoungan, 2024).
For heterogeneous peer effects in the case of a single large network, <code>Glist</code> must be a one-item list. This item must be a list of many specifications of large networks.</p>
</td></tr>
<tr><td><code id="simcdEy_+3A_data">data</code></td>
<td>
<p>an optional data frame, list, or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>summary.cdnet</code> is called.</p>
</td></tr>
<tr><td><code id="simcdEy_+3A_group">group</code></td>
<td>
<p>the vector indicating the individual groups (see function <code><a href="#topic+cdnet">cdnet</a></code>). If missing, the former group saved in <code>object</code> will be used.</p>
</td></tr>
<tr><td><code id="simcdEy_+3A_tol">tol</code></td>
<td>
<p>the tolerance value used in the Fixed Point Iteration Method to compute the expectancy of <code>y</code>. The process stops if the <code class="reqn">\ell_1</code>-distance between two consecutive <code class="reqn">E(y)</code> is less than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="simcdEy_+3A_maxit">maxit</code></td>
<td>
<p>the maximal number of iterations in the Fixed Point Iteration Method.</p>
</td></tr>
<tr><td><code id="simcdEy_+3A_s">S</code></td>
<td>
<p>number of simulations to be used to compute integral in the covariance by important sampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table role = "presentation">
<tr><td><code>Ey</code></td>
<td>
<p><code class="reqn">E(y)</code>, the expectation of y.</p>
</td></tr>
<tr><td><code>GEy</code></td>
<td>
<p>the average of <code class="reqn">E(y)</code> friends.</p>
</td></tr>
<tr><td><code>aEy</code></td>
<td>
<p>the sampling mean of <code class="reqn">E(y)</code>.</p>
</td></tr>
<tr><td><code>se.aEy</code></td>
<td>
<p>the standard error of the sampling mean of <code class="reqn">E(y)</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+simcdnet">simcdnet</a></code>
</p>

<hr>
<h2 id='simcdnet'>Simulating Count Data Models with Social Interactions Under Rational Expectations</h2><span id='topic+simcdnet'></span>

<h3>Description</h3>

<p><code>simcdnet</code> simulates the count data model with social interactions under rational expectations developed by Houndetoungan (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simcdnet(
  formula,
  group,
  Glist,
  parms,
  lambda,
  Gamma,
  delta,
  Rmax,
  Rbar,
  tol = 1e-10,
  maxit = 500,
  data
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simcdnet_+3A_formula">formula</code></td>
<td>
<p>A class object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. <code>formula</code> should be specified, for example, as <code>y ~ x1 + x2 + gx1 + gx2</code>, where <code>y</code> is the endogenous vector and <code>x1</code>, <code>x2</code>, <code>gx1</code>, and <code>gx2</code> are control variables. These control variables can include contextual variables, such as averages among the peers. Peer averages can be computed using the function <code><a href="#topic+peer.avg">peer.avg</a></code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_group">group</code></td>
<td>
<p>A vector indicating the individual groups. By default, this assumes a common group. If there are 2 groups (i.e., <code>length(unique(group)) = 2</code>, such as <code>A</code> and <code>B</code>), four types of peer effects are defined:
peer effects of <code>A</code> on <code>A</code>, <code>A</code> on <code>B</code>, <code>B</code> on <code>A</code>, and <code>B</code> on <code>B</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_glist">Glist</code></td>
<td>
<p>An adjacency matrix or list of adjacency matrices. For networks consisting of multiple subnets (e.g., schools), <code>Glist</code> can be a list of subnet matrices, where the <code class="reqn">m</code>-th element is an <code class="reqn">n_m \times n_m</code> adjacency matrix, with <code class="reqn">n_m</code> representing the number of nodes in the <code class="reqn">m</code>-th subnet.
For heterogeneous peer effects (<code>length(unique(group)) = h &gt; 1</code>), the <code class="reqn">m</code>-th element should be a list of <code class="reqn">h^2</code> <code class="reqn">n_m \times n_m</code> adjacency matrices corresponding to different network specifications (see Houndetoungan, 2024).
For heterogeneous peer effects in a single large network, <code>Glist</code> should be a one-item list, where the item is a list of <code class="reqn">h^2</code> network specifications. The order of these networks is important and must match <code>sort(unique(group))</code> (see examples).</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_parms">parms</code></td>
<td>
<p>A vector defining the true values of <code class="reqn">\theta = (\lambda', \Gamma', \delta')'</code> (see model specification in the details section). Each parameter <code class="reqn">\lambda</code>, <code class="reqn">\Gamma</code>, or <code class="reqn">\delta</code> can also be provided separately to the arguments <code>lambda</code>, <code>Gamma</code>, or <code>delta</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_lambda">lambda</code></td>
<td>
<p>The true value of the vector <code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_gamma">Gamma</code></td>
<td>
<p>The true value of the vector <code class="reqn">\Gamma</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_delta">delta</code></td>
<td>
<p>The true value of the vector <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_rmax">Rmax</code></td>
<td>
<p>An integer indicating the theoretical upper bound of <code>y</code> (see model specification in detail).</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_rbar">Rbar</code></td>
<td>
<p>An <code class="reqn">L</code>-vector, where <code class="reqn">L</code> is the number of groups. For large <code>Rmax</code>, the cost function is assumed to be semi-parametric (i.e., nonparametric from 0 to <code class="reqn">\bar{R}</code> and quadratic beyond <code class="reqn">\bar{R}</code>). The <code class="reqn">l</code>-th element of <code>Rbar</code> indicates <code class="reqn">\bar{R}</code> for the <code class="reqn">l</code>-th value of <code>sort(unique(group))</code> (see model specification in detail).</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_tol">tol</code></td>
<td>
<p>The tolerance value used in the Fixed Point Iteration Method to compute the expectancy of <code>y</code>. The process stops if the <code class="reqn">\ell_1</code>-distance between two consecutive <code class="reqn">E(y)</code> is less than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations in the Fixed Point Iteration Method.</p>
</td></tr>
<tr><td><code id="simcdnet_+3A_data">data</code></td>
<td>
<p>An optional data frame, list, or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>simcdnet</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The count variable <code class="reqn">y_i</code> takes the value <code class="reqn">r</code> with probability.
</p>
<p style="text-align: center;"><code class="reqn">P_{ir} = F(\sum_{s = 1}^S \lambda_s \bar{y}_i^{e,s}  + \mathbf{z}_i'\Gamma - a_{h(i),r}) - F(\sum_{s = 1}^S \lambda_s \bar{y}_i^{e,s}  + \mathbf{z}_i'\Gamma - a_{h(i),r + 1}).</code>
</p>

<p>In this equation, <code class="reqn">\mathbf{z}_i</code> is a vector of control variables; <code class="reqn">F</code> is the distribution function of the standard normal distribution;
<code class="reqn">\bar{y}_i^{e,s}</code> is the average of <code class="reqn">E(y)</code> among peers using the <code>s</code>-th network definition;
<code class="reqn">a_{h(i),r}</code> is the <code>r</code>-th cut-point in the cost group <code class="reqn">h(i)</code>. <br /><br />
The following identification conditions have been introduced: <code class="reqn">\sum_{s = 1}^S \lambda_s &gt; 0</code>, <code class="reqn">a_{h(i),0} = -\infty</code>, <code class="reqn">a_{h(i),1} = 0</code>, and
<code class="reqn">a_{h(i),r} = \infty</code> for any <code class="reqn">r \geq R_{\text{max}} + 1</code>. The last condition implies that <code class="reqn">P_{ir} = 0</code> for any <code class="reqn">r \geq R_{\text{max}} + 1</code>.
For any <code class="reqn">r \geq 1</code>, the distance between two cut-points is <code class="reqn">a_{h(i),r+1} - a_{h(i),r} =  \delta_{h(i),r} + \sum_{s = 1}^S \lambda_s</code>.
As the number of cut-points can be large, a quadratic cost function is considered for <code class="reqn">r \geq \bar{R}_{h(i)}</code>, where <code class="reqn">\bar{R} = (\bar{R}_{1}, ..., \bar{R}_{L})</code>.
With the semi-parametric cost function,
<code class="reqn">a_{h(i),r + 1} - a_{h(i),r} = \bar{\delta}_{h(i)} + \sum_{s = 1}^S \lambda_s</code>.  <br /><br />
The model parameters are: <code class="reqn">\lambda = (\lambda_1, ..., \lambda_S)'</code>, <code class="reqn">\Gamma</code>, and <code class="reqn">\delta = (\delta_1', ..., \delta_L')'</code>,
where <code class="reqn">\delta_l = (\delta_{l,2}, ..., \delta_{l,\bar{R}_l}, \bar{\delta}_l)'</code> for <code class="reqn">l = 1, ..., L</code>.
The number of single parameters in <code class="reqn">\delta_l</code> depends on  <code class="reqn">R_{\text{max}}</code> and <code class="reqn">\bar{R}_l</code>. The components <code class="reqn">\delta_{l,2}, ..., \delta_{l,\bar{R}_l}</code> or/and
<code class="reqn">\bar{\delta}_l</code> must be removed in certain cases.<br />
If <code class="reqn">R_{\text{max}} = \bar{R}_l \geq 2</code>, then <code class="reqn">\delta_l = (\delta_{l,2}, ..., \delta_{l,\bar{R}_l})'</code>.<br />
If <code class="reqn">R_{\text{max}} = \bar{R}_l = 1</code> (binary models), then <code class="reqn">\delta_l</code> must be empty.<br />
If <code class="reqn">R_{\text{max}} &gt; \bar{R}_l = 1</code>, then <code class="reqn">\delta_l = \bar{\delta}_l</code>.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table role = "presentation">
<tr><td><code>yst</code></td>
<td>
<p><code class="reqn">y^{\ast}</code>, the latent variable.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the observed count variable.</p>
</td></tr>
<tr><td><code>Ey</code></td>
<td>
<p><code class="reqn">E(y)</code>, the expectation of y.</p>
</td></tr>
<tr><td><code>GEy</code></td>
<td>
<p>the average of <code class="reqn">E(y)</code> among peers.</p>
</td></tr>
<tr><td><code>meff</code></td>
<td>
<p>a list including average and individual marginal effects.</p>
</td></tr>
<tr><td><code>Rmax</code></td>
<td>
<p>infinite sums in the marginal effects are approximated by sums up to Rmax.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>number of iterations performed by sub-network in the Fixed Point Iteration Method.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Houndetoungan, A. (2024). Count Data Models with Heterogeneous Peer Effects. Available at SSRN 3721250, <a href="https://doi.org/10.2139/ssrn.3721250">doi:10.2139/ssrn.3721250</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cdnet">cdnet</a></code>, <code><a href="#topic+simsart">simsart</a></code>, <code><a href="#topic+simsar">simsar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 200)) # Random group sizes
n      &lt;- sum(nvec) # Total number of individuals

# Adjacency matrix for each group
A      &lt;- list()
for (m in 1:M) {
  nm           &lt;- nvec[m] # Size of group m
  Am           &lt;- matrix(0, nm, nm) # Empty adjacency matrix
  max_d        &lt;- 30 # Maximum number of friends
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1)) # Sample friends
    Am[i, tmp] &lt;- 1 # Set friendship links
  }
  A[[m]]       &lt;- Am # Add to the list
}
Anorm  &lt;- norm.network(A) # Row-normalization of the adjacency matrices

# Covariates (X)
X      &lt;- cbind(rnorm(n, 1, 3), rexp(n, 0.4)) # Random covariates

# Two groups based on first covariate
group  &lt;- 1 * (X[,1] &gt; 0.95) # Assign to groups based on x1

# Networks: Define peer effects based on group membership
# The networks should capture:
# - Peer effects of `0` on `0`
# - Peer effects of `1` on `0`
# - Peer effects of `0` on `1`
# - Peer effects of `1` on `1`
G        &lt;- list()
cums     &lt;- c(0, cumsum(nvec)) # Cumulative indices for groups
for (m in 1:M) {
  tp     &lt;- group[(cums[m] + 1):(cums[m + 1])] # Group membership for group m
  Am     &lt;- A[[m]] # Adjacency matrix for group m
  # Define networks based on peer effects
  G[[m]] &lt;- norm.network(list(Am * ((1 - tp) %*% t(1 - tp)),
                              Am * ((1 - tp) %*% t(tp)),
                              Am * (tp %*% t(1 - tp)),
                              Am * (tp %*% t(tp))))
}

# Parameters for the model
lambda &lt;- c(0.2, 0.3, -0.15, 0.25) 
Gamma  &lt;- c(4.5, 2.2, -0.9, 1.5, -1.2)
delta  &lt;- rep(c(2.6, 1.47, 0.85, 0.7, 0.5), 2) # Repeated values for delta

# Prepare data for the model
data   &lt;- data.frame(X, peer.avg(Anorm, cbind(x1 = X[,1], x2 = X[,2]))) 
colnames(data) = c("x1", "x2", "gx1", "gx2") # Set column names

# Simulate outcomes using the `simcdnet` function
ytmp   &lt;- simcdnet(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, Rbar = rep(5, 2),
                   lambda = lambda, Gamma = Gamma, delta = delta, group = group,
                   data = data)
y      &lt;- ytmp$y

# Plot histogram of the simulated outcomes
hist(y, breaks = max(y) + 1)

# Display frequency table of the simulated outcomes
table(y)

</code></pre>

<hr>
<h2 id='simnetwork'>Simulating Network Data</h2><span id='topic+simnetwork'></span>

<h3>Description</h3>

<p><code>simnetwork</code> generates adjacency matrices based on specified probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simnetwork(dnetwork, normalise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simnetwork_+3A_dnetwork">dnetwork</code></td>
<td>
<p>A list of sub-network matrices, where the (i, j)-th position of the m-th matrix represents the probability that individual <code>i</code> is connected to individual <code>j</code> in the m-th network.</p>
</td></tr>
<tr><td><code id="simnetwork_+3A_normalise">normalise</code></td>
<td>
<p>A boolean indicating whether the returned matrices should be row-normalized (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of (row-normalized) adjacency matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a list of adjacency matrices
## Sub-network sizes
N         &lt;- c(250, 370, 120)  
## Probability distributions
dnetwork  &lt;- lapply(N, function(x) matrix(runif(x^2), x))
## Generate networks
G         &lt;- simnetwork(dnetwork)
</code></pre>

<hr>
<h2 id='simsar'>Simulating Data from Linear-in-Mean Models with Social Interactions</h2><span id='topic+simsar'></span>

<h3>Description</h3>

<p><code>simsar</code> simulates continuous variables under linear-in-mean models with social interactions, following the specifications described
in Lee (2004) and Lee et al. (2010). The model incorporates peer interactions, where the value of an individual’s outcome depends
not only on their own characteristics but also on the average characteristics of their peers in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simsar(formula, Glist, theta, cinfo = TRUE, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simsar_+3A_formula">formula</code></td>
<td>
<p>A symbolic description of the model, passed as a class object of type <a href="stats.html#topic+formula">formula</a>.
The formula must specify the endogenous variable and control variables, for example:
<code>y ~ x1 + x2 + gx1 + gx2</code>, where <code>y</code> is the endogenous vector,
and <code>x1</code>, <code>x2</code>, <code>gx1</code>, and <code>gx2</code> are the control variables, which may include contextual variables (peer averages).
Peer averages can be computed using the function <code><a href="#topic+peer.avg">peer.avg</a></code>.</p>
</td></tr>
<tr><td><code id="simsar_+3A_glist">Glist</code></td>
<td>
<p>A list of network adjacency matrices representing multiple subnets. The <code>m</code>-th element in the list should be an
<code>ns * ns</code> matrix, where <code>ns</code> is the number of nodes in the <code>m</code>-th subnet.</p>
</td></tr>
<tr><td><code id="simsar_+3A_theta">theta</code></td>
<td>
<p>A numeric vector defining the true values of the model parameters <code class="reqn">\theta = (\lambda, \Gamma, \sigma)</code>.
These parameters are used to define the model specification in the details section.</p>
</td></tr>
<tr><td><code id="simsar_+3A_cinfo">cinfo</code></td>
<td>
<p>A Boolean flag indicating whether the information is complete (<code>cinfo = TRUE</code>) or incomplete (<code>cinfo = FALSE</code>).
If information is incomplete, the model operates under rational expectations.</p>
</td></tr>
<tr><td><code id="simsar_+3A_data">data</code></td>
<td>
<p>An optional data frame, list, or environment (or an object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame)
containing the variables in the model. If not provided, the variables are taken from the environment of the function call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the complete information model, the outcome <code class="reqn">y_i</code> for individual <code class="reqn">i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">y_i = \lambda \bar{y}_i + \mathbf{z}_i'\Gamma + \epsilon_i,</code>
</p>

<p>where <code class="reqn">\bar{y}_i</code> represents the average outcome <code class="reqn">y</code> among individual <code class="reqn">i</code>'s peers,
<code class="reqn">\mathbf{z}_i</code> is a vector of control variables, and <code class="reqn">\epsilon_i \sim N(0, \sigma^2)</code> is the error term.
In the case of incomplete information models with rational expectations, the outcome <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">y_i = \lambda E(\bar{y}_i) + \mathbf{z}_i'\Gamma + \epsilon_i,</code>
</p>

<p>where <code class="reqn">E(\bar{y}_i)</code> is the expected average outcome of <code class="reqn">i</code>'s peers, as perceived by individual <code class="reqn">i</code>.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>the observed count data.</p>
</td></tr>
<tr><td><code>Gy</code></td>
<td>
<p>the average of y among friends.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lee, L. F. (2004). Asymptotic distributions of quasi-maximum likelihood estimators for spatial autoregressive models. <em>Econometrica</em>, 72(6), 1899-1925, <a href="https://doi.org/10.1111/j.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>.
</p>
<p>Lee, L. F., Liu, X., &amp; Lin, X. (2010). Specification and estimation of social interaction models with network structures. The Econometrics Journal, 13(2), 145-176, <a href="https://doi.org/10.1111/j.1368-423X.2010.00310.x">doi:10.1111/j.1368-423X.2010.00310.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sar">sar</a></code>, <code><a href="#topic+simsart">simsart</a></code>, <code><a href="#topic+simcdnet">simcdnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Groups' size
set.seed(123)
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 1000))
n      &lt;- sum(nvec)

# Parameters
lambda &lt;- 0.4
Gamma  &lt;- c(2, -1.9, 0.8, 1.5, -1.2)
sigma  &lt;- 1.5
theta  &lt;- c(lambda, Gamma, sigma)

# X
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Network
G      &lt;- list()

for (m in 1:M) {
  nm           &lt;- nvec[m]
  Gm           &lt;- matrix(0, nm, nm)
  max_d        &lt;- 30
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1))
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm); rs[rs == 0] &lt;- 1
  Gm           &lt;- Gm/rs
  G[[m]]       &lt;- Gm
}

# data
data   &lt;- data.frame(X, peer.avg(G, cbind(x1 = X[,1], x2 =  X[,2])))
colnames(data) &lt;- c("x1", "x2", "gx1", "gx2")

ytmp    &lt;- simsar(formula = ~ x1 + x2 + gx1 + gx2, Glist = G, 
                  theta = theta, data = data) 
y       &lt;- ytmp$y

</code></pre>

<hr>
<h2 id='simsart'>Simulating Data from Tobit Models with Social Interactions</h2><span id='topic+simsart'></span>

<h3>Description</h3>

<p><code>simsart</code> simulates censored data with social interactions (see Xu and Lee, 2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simsart(formula, Glist, theta, tol = 1e-15, maxit = 500, cinfo = TRUE, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simsart_+3A_formula">formula</code></td>
<td>
<p>a class object <code><a href="stats.html#topic+formula">formula</a></code>: a symbolic description of the model.
<code>formula</code> must be, for example, <code>y ~ x1 + x2 + gx1 + gx2</code>, where <code>y</code> is the endogenous vector,
and <code>x1</code>, <code>x2</code>, <code>gx1</code>, and <code>gx2</code> are control variables. These can include contextual variables,
i.e., averages among the peers. Peer averages can be computed using the function <code><a href="#topic+peer.avg">peer.avg</a></code>.</p>
</td></tr>
<tr><td><code id="simsart_+3A_glist">Glist</code></td>
<td>
<p>The network matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list
of subnets with the <code>m</code>-th element being an <code>ns*ns</code> adjacency matrix, where <code>ns</code> is the number of nodes
in the <code>m</code>-th subnet.</p>
</td></tr>
<tr><td><code id="simsart_+3A_theta">theta</code></td>
<td>
<p>a vector defining the true value of <code class="reqn">\theta = (\lambda, \Gamma, \sigma)</code> (see the model specification in the details).</p>
</td></tr>
<tr><td><code id="simsart_+3A_tol">tol</code></td>
<td>
<p>the tolerance value used in the fixed-point iteration method to compute <code>y</code>. The process stops
if the <code class="reqn">\ell_1</code>-distance between two consecutive values of <code>y</code> is less than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="simsart_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations in the fixed-point iteration method.</p>
</td></tr>
<tr><td><code id="simsart_+3A_cinfo">cinfo</code></td>
<td>
<p>a Boolean indicating whether information is complete (<code>cinfo = TRUE</code>) or incomplete (<code>cinfo = FALSE</code>).
In the case of incomplete information, the model is defined under rational expectations.</p>
</td></tr>
<tr><td><code id="simsart_+3A_data">data</code></td>
<td>
<p>an optional data frame, list, or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken
from <code>environment(formula)</code>, typically the environment from which <code>simsart</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a complete information model, the outcome <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\begin{cases}
y_i^{\ast} = \lambda \bar{y}_i + \mathbf{z}_i'\Gamma + \epsilon_i, \\ 
y_i = \max(0, y_i^{\ast}),
\end{cases}</code>
</p>

<p>where <code class="reqn">\bar{y}_i</code> is the average of <code class="reqn">y</code> among peers,
<code class="reqn">\mathbf{z}_i</code> is a vector of control variables,
and <code class="reqn">\epsilon_i \sim N(0, \sigma^2)</code>. <br />
</p>
<p>In the case of incomplete information models with rational expectations, <code class="reqn">y_i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\begin{cases}
y_i^{\ast} = \lambda E(\bar{y}_i) + \mathbf{z}_i'\Gamma + \epsilon_i, \\ 
y_i = \max(0, y_i^{\ast}).
\end{cases}</code>
</p>



<h3>Value</h3>

<p>A list consisting of:
</p>

<dl>
<dt>yst</dt><dd><p><code class="reqn">y^{\ast}</code>, the latent variable.</p>
</dd>
<dt>y</dt><dd><p>The observed censored variable.</p>
</dd>
<dt>Ey</dt><dd><p><code class="reqn">E(y)</code>, the expected value of <code class="reqn">y</code>.</p>
</dd>
<dt>Gy</dt><dd><p>The average of <code class="reqn">y</code> among peers.</p>
</dd>
<dt>GEy</dt><dd><p>The average of <code class="reqn">E(y)</code> among peers.</p>
</dd>
<dt>meff</dt><dd><p>A list including average and individual marginal effects.</p>
</dd>
<dt>iteration</dt><dd><p>The number of iterations performed per sub-network in the fixed-point iteration method.</p>
</dd>
</dl>



<h3>References</h3>

<p>Xu, X., &amp; Lee, L. F. (2015). Maximum likelihood estimation of a spatial autoregressive Tobit model. <em>Journal of Econometrics</em>, 188(1), 264-280, <a href="https://doi.org/10.1016/j.jeconom.2015.05.004">doi:10.1016/j.jeconom.2015.05.004</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sart">sart</a></code>, <code><a href="#topic+simsar">simsar</a></code>, <code><a href="#topic+simcdnet">simcdnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define group sizes
set.seed(123)
M      &lt;- 5 # Number of sub-groups
nvec   &lt;- round(runif(M, 100, 200)) # Number of nodes per sub-group
n      &lt;- sum(nvec) # Total number of nodes

# Define parameters
lambda &lt;- 0.4
Gamma  &lt;- c(2, -1.9, 0.8, 1.5, -1.2)
sigma  &lt;- 1.5
theta  &lt;- c(lambda, Gamma, sigma)

# Generate covariates (X)
X      &lt;- cbind(rnorm(n, 1, 1), rexp(n, 0.4))

# Construct network adjacency matrices
G      &lt;- list()
for (m in 1:M) {
  nm           &lt;- nvec[m] # Nodes in sub-group m
  Gm           &lt;- matrix(0, nm, nm) # Initialize adjacency matrix
  max_d        &lt;- 30 # Maximum degree
  for (i in 1:nm) {
    tmp        &lt;- sample((1:nm)[-i], sample(0:max_d, 1)) # Random connections
    Gm[i, tmp] &lt;- 1
  }
  rs           &lt;- rowSums(Gm) # Normalize rows
  rs[rs == 0]  &lt;- 1
  Gm           &lt;- Gm / rs
  G[[m]]       &lt;- Gm
}

# Prepare data
data   &lt;- data.frame(X, peer.avg(G, cbind(x1 = X[, 1], x2 = X[, 2])))
colnames(data) &lt;- c("x1", "x2", "gx1", "gx2") # Add column names

# Complete information game simulation
ytmp    &lt;- simsart(formula = ~ x1 + x2 + gx1 + gx2, 
                   Glist = G, theta = theta, 
                   data = data, cinfo = TRUE)
data$yc &lt;- ytmp$y # Add simulated outcome to the dataset

# Incomplete information game simulation
ytmp    &lt;- simsart(formula = ~ x1 + x2 + gx1 + gx2, 
                   Glist = G, theta = theta, 
                   data = data, cinfo = FALSE)
data$yi &lt;- ytmp$y # Add simulated outcome to the dataset

</code></pre>

<hr>
<h2 id='summary.cdnet'>Summary for the Estimation of Count Data Models with Social Interactions under Rational Expectations</h2><span id='topic+summary.cdnet'></span><span id='topic+print.summary.cdnet'></span><span id='topic+print.cdnet'></span>

<h3>Description</h3>

<p>Summary and print methods for the class <code>cdnet</code> as returned by the function <a href="#topic+cdnet">cdnet</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cdnet'
summary(object, Glist, data, S = 1000L, ...)

## S3 method for class 'summary.cdnet'
print(x, ...)

## S3 method for class 'cdnet'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cdnet_+3A_object">object</code></td>
<td>
<p>an object of class <code>cdnet</code>, output of the function <code><a href="#topic+cdnet">cdnet</a></code>.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_glist">Glist</code></td>
<td>
<p>adjacency matrix. For networks consisting of multiple subnets, <code>Glist</code> can be a list of subnets with the <code>m</code>-th element being an <code>ns*ns</code> adjacency matrix, where <code>ns</code> is the number of nodes in the <code>m</code>-th subnet.
For heterogeneous peer effects (e.g., boy-boy, boy-girl friendship effects), the <code>m</code>-th element can be a list of many <code>ns*ns</code> adjacency matrices corresponding to the different network specifications (see Houndetoungan, 2024).
For heterogeneous peer effects in the case of a single large network, <code>Glist</code> must be a one-item list. This item must be a list of many specifications of large networks.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_data">data</code></td>
<td>
<p>an optional data frame, list, or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables in the model. If not found in data, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>summary.cdnet</code> is called.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_s">S</code></td>
<td>
<p>number of simulations to be used to compute integral in the covariance by important sampling.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.cdnet_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.cdnet</code>, output of the function <code><a href="#topic+summary.cdnet">summary.cdnet</a></code> or class <code>cdnet</code>, output of the function <code><a href="#topic+cdnet">cdnet</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same objects in <code>object</code>.
</p>

<hr>
<h2 id='summary.sar'>Summary for the Estimation of Linear-in-mean Models with Social Interactions</h2><span id='topic+summary.sar'></span><span id='topic+print.summary.sar'></span><span id='topic+print.sar'></span>

<h3>Description</h3>

<p>Summary and print methods for the class <code>sar</code> as returned by the function <code><a href="#topic+sar">sar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sar'
summary(object, ...)

## S3 method for class 'summary.sar'
print(x, ...)

## S3 method for class 'sar'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.sar_+3A_object">object</code></td>
<td>
<p>an object of class <code>sar</code>, output of the function <code><a href="#topic+sar">sar</a></code>.</p>
</td></tr>
<tr><td><code id="summary.sar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.sar_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.sar</code>, output of the function <code><a href="#topic+summary.sar">summary.sar</a></code> or
class <code>sar</code>, output of the function <code><a href="#topic+sar">sar</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same objects in <code>object</code>.
</p>

<hr>
<h2 id='summary.sart'>Summary for the Estimation of Tobit Models with Social Interactions</h2><span id='topic+summary.sart'></span><span id='topic+print.summary.sart'></span><span id='topic+print.sart'></span>

<h3>Description</h3>

<p>Summary and print methods for the class <code>sart</code> as returned by the function <a href="#topic+sart">sart</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sart'
summary(object, Glist, data, ...)

## S3 method for class 'summary.sart'
print(x, ...)

## S3 method for class 'sart'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.sart_+3A_object">object</code></td>
<td>
<p>an object of class <code>sart</code>, output of the function <code><a href="#topic+sart">sart</a></code>.</p>
</td></tr>
<tr><td><code id="summary.sart_+3A_glist">Glist</code></td>
<td>
<p>adjacency matrix or list sub-adjacency matrix. This is not necessary if the covariance method was computed in <a href="#topic+cdnet">cdnet</a>.</p>
</td></tr>
<tr><td><code id="summary.sart_+3A_data">data</code></td>
<td>
<p>dataframe containing the explanatory variables. This is not necessary if the covariance method was computed in <a href="#topic+cdnet">cdnet</a>.</p>
</td></tr>
<tr><td><code id="summary.sart_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.sart_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.sart</code>, output of the function <code><a href="#topic+summary.sart">summary.sart</a></code>
or class <code>sart</code>, output of the function <code><a href="#topic+sart">sart</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same objects in <code>object</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
