<!DOCTYPE html><html><head><title>Help for package ncdf4</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ncdf4}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nc_close'><p>Close a netCDF File</p></a></li>
<li><a href='#nc_create'><p>Create a netCDF File</p></a></li>
<li><a href='#nc_enddef'><p>Takes a netCDF file out of define mode</p></a></li>
<li><a href='#nc_open'><p>Open a netCDF File</p></a></li>
<li><a href='#nc_redef'><p>Puts a netCDF file back into define mode</p></a></li>
<li><a href='#nc_sync'><p>Synchronize (flush to disk) a netCDF File</p></a></li>
<li><a href='#nc_version'><p>Report version of ncdf4 library</p></a></li>
<li><a href='#ncatt_get'><p>Get attribute from netCDF file</p></a></li>
<li><a href='#ncatt_put'><p>Put an attribute into a netCDF file</p></a></li>
<li><a href='#ncdf4-internal'><p>Internal ncdf4 functions</p></a></li>
<li><a href='#ncdf4-package'><p>Read, write, and create netCDF files (including version 4 format)</p></a></li>
<li><a href='#ncdim_def'><p>Define a netCDF Dimension</p></a></li>
<li><a href='#ncvar_add'><p>Add New netCDF Variable to Existing File</p></a></li>
<li><a href='#ncvar_change_missval'><p>Change the Missing Value For a netCDF Variable</p></a></li>
<li><a href='#ncvar_def'><p>Define a netCDF Variable</p></a></li>
<li><a href='#ncvar_get'><p>Read data from a netCDF file</p></a></li>
<li><a href='#ncvar_put'><p>Write data to a netCDF file</p></a></li>
<li><a href='#ncvar_rename'><p>Rename an Existing Variable in a netCDF File</p></a></li>
<li><a href='#print.ncdf4'><p>Print Information About a netCDF File</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.22</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Interface to Unidata netCDF (Version 4 or Earlier) Format Data
Files</td>
</tr>
<tr>
<td>Author:</td>
<td>David Pierce &lt;dpierce@ucsd.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Pierce &lt;dpierce@ucsd.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a high-level R interface to data files written using Unidata's netCDF library (version 4 or earlier), which are binary data files that are portable across platforms and include metadata information in addition to the data sets.  Using this package, netCDF files (either version 4 or "classic" version 3) can be opened and data sets read in easily.  It is also easy to create new netCDF dimensions, variables, and files, in either version 3 or 4 format, and manipulate existing netCDF files.  This package replaces the former ncdf package, which only worked with netcdf version 3 files.  For various reasons the names of the functions have had to be changed from the names in the ncdf package.  The old ncdf package is still available at the URL given below, if you need to have backward compatibility.  It should be possible to have both the ncdf and ncdf4 packages installed simultaneously without a problem.  However, the ncdf package does not provide an interface for netcdf version 4 files.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>netcdf library version 4.1 or later</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cirrus.ucsd.edu/~pierce/ncdf/">https://cirrus.ucsd.edu/~pierce/ncdf/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-28 19:05:38 UTC; pierce</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 20:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nc_close'>Close a netCDF File</h2><span id='topic+nc_close'></span>

<h3>Description</h3>

<p>Closes an open netCDF file, which flushes any unwritten data to disk.
Always close a netCDF file when you are done with it!
You are risking data loss otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> nc_close( nc )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nc_close_+3A_nc">nc</code></td>
<td>
<p>An object of class <code>ncdf4</code> (as returned by either function
<code><a href="#topic+nc_open">nc_open</a></code> or function <code><a href="#topic+nc_create">nc_create</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data written to a netCDF file is cached in memory, for better performance.
This data is only written out to disk when the file is closed.  Therefore, always
remember to close a netCDF file when done with it.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+nc_sync">nc_sync</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: nc &lt;- nc_open("salinity.nc")
## Not run: data &lt;- ncvar_get( nc )	# Read the "only" var in the file
## Not run: nc_close(nc)
</code></pre>

<hr>
<h2 id='nc_create'>Create a netCDF File</h2><span id='topic+nc_create'></span>

<h3>Description</h3>

<p>Creates a new netCDF file on disk, given the variables the new file is to contain. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> nc_create( filename, vars, force_v4=FALSE, verbose=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nc_create_+3A_filename">filename</code></td>
<td>
<p>Name of the  netCDF file to be created.</p>
</td></tr>
<tr><td><code id="nc_create_+3A_vars">vars</code></td>
<td>
<p>Either an object of class <code>ncvar4</code> describing the variable to be created, or a vector (or list) of such objects to be created.</p>
</td></tr>
<tr><td><code id="nc_create_+3A_force_v4">force_v4</code></td>
<td>
<p>If TRUE, then the created output file will always be in netcdf-4 format (which
supports more features, but
cannot be read by version 3 of the netcdf library).  If FALSE, then the file is created
in netcdf version 3 format UNLESS the user has requested features that require version 4.
Deafult is FALSE.</p>
</td></tr>
<tr><td><code id="nc_create_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, then information is printed while the file is being created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine creates a new netCDF file on disk.  The routine must be called with the variables
that will be created in the file.
Keep in mind that the new file may not actually be written to disk until 
<code><a href="#topic+nc_close">nc_close</a></code> is called.  Always call
<code><a href="#topic+nc_close">nc_close</a></code> when you are done with your file, or
before exiting R!
</p>


<h3>Value</h3>

<p>An object of class <code>ncdf4</code>, which has the fields described in <code><a href="#topic+nc_open">nc_open</a></code>.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+ncdim_def">ncdim_def</a></code>, <code><a href="#topic+ncvar_def">ncvar_def</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Define an integer dimension 
dimState &lt;- ncdim_def( "StateNo", "count", 1:50 )

# Make an integer variable.  Note that an integer variable can have
# a double precision dimension, or vice versa; there is no fixed
# relationship between the precision of the dimension and that of the
# associated variable.  We just make an integer variable here for
# illustration purposes.
varPop &lt;- ncvar_def("Pop", "count", dimState, -1, 
		longname="Population", prec="integer")

# Create a netCDF file with this variable
ncnew &lt;- nc_create( "states_population.nc", varPop )

# Write some values to this variable on disk.
popAlabama &lt;- 4447100
ncvar_put( ncnew, varPop, popAlabama, start=1, count=1 )

nc_close(ncnew)

# Clean up example
file.remove( "states_population.nc" )

## End(Not run)
</code></pre>

<hr>
<h2 id='nc_enddef'>Takes a netCDF file out of define mode</h2><span id='topic+nc_enddef'></span>

<h3>Description</h3>

<p>Changes a netCDF that is currently in define mode back into data mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> nc_enddef( nc )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nc_enddef_+3A_nc">nc</code></td>
<td>
<p>An object of class <code>ncdf4</code> (as returned by either 
function <code><a href="#topic+nc_open">nc_open</a></code>
or function <code><a href="#topic+nc_create">nc_create</a></code>, indicating what file to operate upon.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: typical users will never need to use this function.
</p>
<p>NetCDF files can be in &quot;define mode&quot;, at which time dimensions and variables can be
defined, or new attributes added to a file, or in &quot;data mode&quot;, at which time data
can be read from the file.
This call puts a file that is currently in define mode back into data mode.
The ncdf4 package manages this process transparently, so normally, an end user
will not need to call this explicitly.
</p>


<h3>Note</h3>

<p>The typical user will never need this call, nor will ever have to worry about
&quot;define mode&quot; or &quot;data mode&quot;.  THIS CALL IS PROVIDED FOR ADVANCED USERS ONLY!
If the user goes through this package's standard functional interface,
the file will always automatically be set to whatever mode it needs to be in
without the user having to do anything.
For example, the call to write an attribute (<code><a href="#topic+ncatt_put">ncatt_put</a></code>)
handles this automatically.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+nc_redef">nc_redef</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function is for advanced useage only, and will never
# be needed by the typical users R code.
</code></pre>

<hr>
<h2 id='nc_open'>Open a netCDF File</h2><span id='topic+nc_open'></span>

<h3>Description</h3>

<p>Opens an existing netCDF file for reading (or, optionally, writing).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> nc_open( filename, write=FALSE, readunlim=TRUE, verbose=FALSE, 
 	auto_GMT=TRUE, suppress_dimvals=FALSE, return_on_error=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nc_open_+3A_filename">filename</code></td>
<td>
<p>Name of the existing netCDF file to be opened.</p>
</td></tr>
<tr><td><code id="nc_open_+3A_write">write</code></td>
<td>
<p>If FALSE (default), then the file is opened read-only.  If TRUE, then writing to the file is allowed.</p>
</td></tr>
<tr><td><code id="nc_open_+3A_readunlim">readunlim</code></td>
<td>
<p>When invoked, this function reads in the values of all dimensions from 
the associated variables.  This can be slow for a large file with a long unlimited 
dimension.  If set to FALSE, the values for the unlimited dimension are not 
automatically read in (they can be read in later, manually, using <code>ncvar_get()</code>).</p>
</td></tr>
<tr><td><code id="nc_open_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, then messages are printed out during execution of this function.</p>
</td></tr>
<tr><td><code id="nc_open_+3A_auto_gmt">auto_GMT</code></td>
<td>
<p>If TRUE, then GMT files are automatically detected. Does not yet do anything.</p>
</td></tr>
<tr><td><code id="nc_open_+3A_suppress_dimvals">suppress_dimvals</code></td>
<td>
<p>If TRUE, then NO dimensional values are automatically read in from the file. (Use
this if there are so many dimensional values that a out-of-memory error is generated).</p>
</td></tr>
<tr><td><code id="nc_open_+3A_return_on_error">return_on_error</code></td>
<td>
<p>If TRUE, then nc_open always returns, and returned list 
element $error will be TRUE if an error was encountered and FALSE if no error was encountered. 
If return_on_error is FALSE (the default), nc_open halts with an error message if an error is encountered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine opens an existing netCDF file for reading (or, if write=TRUE, for writing).
To create a new netCDF file, use <code><a href="#topic+nc_create">nc_create</a></code> instead.
</p>
<p>In addition to simply opening the file, information about the file and its contents
is read in and stored in the returned object, which is of class <code>ncdf4</code>.
This class has the following user-accessible fields, all of which are read-only: 1) filename,
which is a character string holding the name of the file; 2) ndims, which is an
integer holding the number of dimensions in the file; 3) nvars, which is an integer
holding the number of the variables in the file that are NOT coordinate variables
(aka dimensional variables); 4) natts, which is an integer holding the number of
global attributes; 5) unlimdimid, which is an integer holding the dimension id of
the unlimited dimension, or -1 if there is none; 6) dim, which is a list of
objects of class <code>ncdim4</code>; 7) var, which is a list of objects of class
<code>ncvar4</code>; 8) writable, which is TRUE or FALSE, depending on whether the file
was opened with write=TRUE or write=FALSE.
</p>
<p>The concept behind the R interface to a netCDF file is that the <code>ncdf4</code> object
returned by this function, as well as the list of <code>ncdim4</code> objects contained
in the ncdf object's &quot;dim&quot; list and the <code>ncvar4</code> objects contained in the
ncdf object's &quot;var&quot; list, completely describe the netCDF file. I.e., they hold
the entire contents of the file's metadata.  Therefore, there are no R interfaces
to the explicit netCDF query functions, such as &quot;nc_inq_nvars&quot; or &quot;nc_inq_natts&quot;.
The upshot is, look in the ncdf4 object or its children to get information about
the netCDF file.  (Note: the <code>ncdim4</code> object is described in the help
file for <code><a href="#topic+ncdim_def">ncdim_def</a></code>; the <code>ncvar4</code> object is described
in the help file for <code><a href="#topic+ncvar_def">ncvar_def</a></code>).
</p>
<p>Missing values: R uses &quot;NA&quot; as a missing value. Netcdf files have various 
standards for indicating a missing value. The most common is that a variable
will have an attribute named &quot;_FillValue&quot; indicating the value that should
be interpreted as a missing value. (For example, the _FillValue attribute might
have the value of 1.e30, indicating that any data in the netcdf file with
a value of 1.e30 should be interpreted as a missing value.) 
If the &quot;_FillValue&quot; attribute is found, then the ncdf4
package transparently maps all the netcdf file's missing values to NA's; this
is the most common case.
The attribute &quot;missing_value&quot; is also recognized if there is no &quot;_FillValue&quot;
attribute. 
</p>
<p>Some netcdf files specify both a &quot;_FillValue&quot; and a &quot;missing_value&quot; attribute
for a variable. If these two
attributes have the same value, then everything is fine. If they have different
values, I consider this a malformed netcdf file and I suggest you contact
the person who made your netcdf file to fix it. In this event you can
set the &quot;raw_datavals&quot; flag in the ncvar_get() call and handle the 
conflicting missing values however you want. 
</p>
<p>If the netcdf file does not have a missing value, then the ncdf4
package assigns a default missing value of 1.e30 to the netcdcf file so that R NA's,
which are always possible in the R environment, can be sensibly handled
in the netcdf file. On rare occasions this can cause problems with non-compliant
or incorrect netcdf files that implicitly use some particular value,
for example 9.96921e+36, to indicate a missing value but without 
setting a proper _FillValue attribute. The best way to fix such netcdf files is to explicitly
put in the correct _FillValue attribute using an <code><a href="#topic+ncatt_put">ncatt_put</a></code> call.
</p>


<h3>Value</h3>

<p>An object of class <code>ncdf4</code> that has the fields described above.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+ncdim_def">ncdim_def</a></code>, <code><a href="#topic+ncvar_def">ncvar_def</a></code>, <code><a href="#topic+ncatt_put">ncatt_put</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Define an integer dimension 
dimState &lt;- ncdim_def( "StateNo", "count", 1:50 )

# Make an integer variable.  Note that an integer variable can have
# a double precision dimension, or vice versa; there is no fixed
# relationship between the precision of the dimension and that of the
# associated variable.  We just make an integer variable here for
# illustration purposes.
varPop &lt;- ncvar_def("Pop", "count", dimState, -1, 
	longname="Population", prec="integer")

# Create a netCDF file with this variable
ncnew &lt;- nc_create( "states_population.nc", varPop )

# Write some values to this variable on disk.
popAlabama &lt;- 4447100
ncvar_put( ncnew, varPop, popAlabama, start=1, count=1 )

# Add source info metadata to file
ncatt_put( ncnew, 0, "source", "Census 2000 from census bureau web site")

nc_close(ncnew)

# Now open the file and read its data
ncold &lt;- nc_open("states_population.nc")
data &lt;- ncvar_get(ncold)
print("here is the data in the file:")
print(data)
nc_close( ncold )

# Clean up example
file.remove( "states_population.nc" )

## End(Not run)
</code></pre>

<hr>
<h2 id='nc_redef'>Puts a netCDF file back into define mode</h2><span id='topic+nc_redef'></span>

<h3>Description</h3>

<p>Puts a netCDF that is not currently in define mode back into define mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> nc_redef( nc )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nc_redef_+3A_nc">nc</code></td>
<td>
<p>An object of class <code>ncdf4</code> (as returned by either 
function <code><a href="#topic+nc_open">nc_open</a></code>(..., write=TRUE)
or function <code><a href="#topic+nc_create">nc_create</a></code>, indicating what file to operate on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically, users will never need this function.
</p>
<p>NetCDF files can be in &quot;define mode&quot;, at which time dimensions and variables can be
defined, or new attributes added to a file, or in &quot;data mode&quot;, at which time data
can be read from the file.
This call puts a file that is currently in data mode back into define mode.
This functionality is handled transparently by the ncdf4 library, so users
will never need to call this unless they are doing advanced manipulations
of netcdf files.
</p>


<h3>Note</h3>

<p>The typical user will never need this call, nor will ever have to worry about
&quot;define mode&quot; or &quot;data mode&quot;.  THIS CALL IS PROVIDED FOR ADVANCED USERS ONLY!
If the user goes through this package's standard functional interface,
the file will always automatically be set to whatever mode it needs to be in
without the user having to do anything.
For example, the call to write an attribute (<code><a href="#topic+ncatt_put">ncatt_put</a></code>)
handles this automatically.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+nc_enddef">nc_enddef</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function is for advanced useage only, and will never
# be needed by the typical users R code.
</code></pre>

<hr>
<h2 id='nc_sync'>Synchronize (flush to disk) a netCDF File</h2><span id='topic+nc_sync'></span>

<h3>Description</h3>

<p>Flushes any pending operations on a netCDF file to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> nc_sync( nc )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nc_sync_+3A_nc">nc</code></td>
<td>
<p>An object of class <code>ncdf4</code> that is opened for writing (as returned by either 
function <code><a href="#topic+nc_open">nc_open</a></code><code>(..., write=TRUE)</code>
or function <code><a href="#topic+nc_create">nc_create</a></code>, indicating what file is being written to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data in a netCDF file is cached in memory, for better performance.
An example of when this might be bad is if a long-running job writes one
timestep of the output file at a time; if the job crashes near the end, 
the results of many timesteps might be lost.  In such an event, the user
can manually force any cached data to be written to disk using this call.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The time you would use the sync.ncdf function is when you have an unlimited
# dimension and are writing to the file timestep-by-timestep. Make a netCDF file 
# that has an unlimited dimension for illustration.
nx &lt;- 5
ny &lt;- 8
dimx &lt;- ncdim_def( "X", "meters", 1:nx )
dimy &lt;- ncdim_def( "Y", "meters", 1:ny )
dimt &lt;- ncdim_def( "Time", "days since 1900-01-01", 0, unlim=TRUE )

vartemp &lt;- ncvar_def( "Temperature", "degC", list(dimx,dimy,dimt), 1.e30 )
nc  &lt;- nc_create( "temperature.nc", vartemp )

nt &lt;- 10  # Imagine this is actually some very large number of timesteps
for( i in 1:nt ) {
	# Long, slow computation to get the data ... for illustration, we just
	# use the following:
	data &lt;- runif(nx*ny)

	# Write the data to this timestep
	ncvar_put( nc, vartemp, data, start=c(1,1,i), count=c(nx,ny,1) )

	# Write the time value for this timestep as well
	timeval &lt;- i*10
	ncvar_put( nc, dimt, timeval, start=i, count=1 )

	# Flush this timestep's data to the file so we dont lose it
	# if there is a crash or other problem
	nc_sync( nc )
	}

# Always remember to close the file when done!!
nc_close(nc)

# Clean up example
file.remove( "temperature.nc" )

## End(Not run)
</code></pre>

<hr>
<h2 id='nc_version'>Report version of ncdf4 library</h2><span id='topic+nc_version'></span>

<h3>Description</h3>

<p>Returns a string that is the version number of the ncdf4 package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> nc_version()
</code></pre>


<h3>Details</h3>

<p>Note that the returned value it is a string, not a floating point number.
</p>


<h3>Value</h3>

<p>A string (not float) that is the version number of the ncdf4 package.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>

<hr>
<h2 id='ncatt_get'>Get attribute from netCDF file</h2><span id='topic+ncatt_get'></span>

<h3>Description</h3>

<p>Reads an attribute from a netCDF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ncatt_get( nc, varid, attname=NA, verbose=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncatt_get_+3A_nc">nc</code></td>
<td>
<p>An object of class <code>ncdf4</code> (as returned from <code><a href="#topic+nc_open">nc_open</a></code>),
indicating what file to read from.</p>
</td></tr>
<tr><td><code id="ncatt_get_+3A_varid">varid</code></td>
<td>
<p>The variable whose attribute is to be read.  Can be a
character string with the variable's name or an object of class <code>ncvar4</code>.
As a special case, if varid==0, then a global (file) 
attribute will be read rather than a particular variable's attribute.
In netcdf version 4 files, attributes can be stored in a group without
an associated variable (as if they were global attributes for the group
instead of for the file). In this case, set varid to a string holding the fully qualified
group name using forward slashes for subgroups. For example, &quot;group1/metadata&quot;.</p>
</td></tr>
<tr><td><code id="ncatt_get_+3A_attname">attname</code></td>
<td>
<p>Name of the attribute to read; if not specified, a list
containg ALL attributes of the selected variable or file is returned.</p>
</td></tr>
<tr><td><code id="ncatt_get_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, then debugging information is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gets an attribute from a netCDF variable (or a global attribute
from a netCDF file, if the passed argument &quot;varid&quot; is zero).
Multiple attributes are returned in a vector.
</p>


<h3>Value</h3>

<p>If an attribute name is supplied (i.e., argument
attname is given), this returns 
a list with two components, &quot;hasatt&quot; and &quot;value&quot;.
&quot;hasatt&quot; is TRUE if the named attribute was found, and FALSE otherwise.
&quot;value&quot; is the (possibly vector) value of the attribute.
If the on-disk type of the attribute is short or integer, then an integer
value is returned.  If the on-disk type is float or double, than a 
double value is returned.  If the on-disk type is character, than a
character string is returned.
</p>
<p>If no attribute name is supplied, then this returns a list containing
ALL the attributes for the specified variable
along with their associated values.  For example,
if attlist is the list returned by this call, then names(attlist) shows
all the attributes defined for the variable, and attlist[[N]] is the
value of the N'th attribute.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+ncatt_put">ncatt_put</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Make a simple netCDF file
filename &lt;- "atttest_types.nc"
dim &lt;- ncdim_def( "X", "inches", 1:12 )
var &lt;- ncvar_def( "Data", "unitless", dim, -1 ) 
ncnew &lt;- nc_create( filename, var )

# Define some attributes of various types
attvaldbl &lt;- 3.1415926536
ncatt_put( ncnew, var, "testatt_dbl", attvaldbl, prec="double" )
attvalfloat &lt;- c(1.0,4.0,9.0,16.0)
ncatt_put( ncnew, var, "testatt_float", attvalfloat )
# varid=0 means it is a global attribute
ncatt_put( ncnew, 0, "globalatt_int", 32000, prec="int" ) 
ncatt_put( ncnew, 0, "globalatt_short", 7, prec="short" )
ncatt_put( ncnew, 0, "description", 
	"this is a test file with attributes of various types")
nc_close(ncnew)

# Now illustrate the use of the ncatt_get function by reading them back in
doitfor &lt;- function( nc, var, attname ) {
	av &lt;- ncatt_get( nc, var, attname )
	if( av$hasatt ) {
		print(paste("File",nc$filename,", var",var,"DOES have attribute",
				attname))
		print(paste("Storage mode:",storage.mode(av$value)))
		print("Attribute value:")
		print(av$value)
	} else {
		print(paste("File",nc$filename,", var",var,"does NOT have",
			"attribute", attname))
		}
}
	
nc &lt;- nc_open( filename )
var &lt;- "Data"
doitfor( nc, var, "testatt_dbl" )
doitfor( nc, var, "testatt_float" )
doitfor( nc, var, "testatt_wacko" )
doitfor( nc, 0,   "globalatt_int" )
doitfor( nc, 0,   "globalatt_short" )
doitfor( nc, 0,   "description" )
nc_close( nc )

# Clean up after our test
file.remove( filename )


## End(Not run)
</code></pre>

<hr>
<h2 id='ncatt_put'>Put an attribute into a netCDF file</h2><span id='topic+ncatt_put'></span>

<h3>Description</h3>

<p>Writes an attribute to a netCDF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ncatt_put( nc, varid, attname, attval, prec=NA, verbose=FALSE, 
 	definemode=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncatt_put_+3A_nc">nc</code></td>
<td>
<p>An object of class <code>ncdf4</code> (as returned from <code><a href="#topic+nc_open">nc_open</a></code>),
indicating what file to write to.</p>
</td></tr>
<tr><td><code id="ncatt_put_+3A_varid">varid</code></td>
<td>
<p>The variable whose attribute is to be written.  Can be a
character string with the variable's name, an object of class <code>ncvar4</code>,
or an id contained in the &quot;id&quot; field of a <code>ncvar</code> object. As a
special case, if varid==0, then a global attribute is written
instead of a variable's attribute.</p>
</td></tr>
<tr><td><code id="ncatt_put_+3A_attname">attname</code></td>
<td>
<p>Name of the attribute to write.</p>
</td></tr>
<tr><td><code id="ncatt_put_+3A_attval">attval</code></td>
<td>
<p>Attribute to write.</p>
</td></tr>
<tr><td><code id="ncatt_put_+3A_prec">prec</code></td>
<td>
<p>Precision to write the attribute.  If not specified, the written precision is the same as the variable whose attribute this is.  This can be overridden by specifying this argument with a value of &quot;short&quot;, &quot;float&quot;, &quot;double&quot;, or &quot;text&quot;.</p>
</td></tr>
<tr><td><code id="ncatt_put_+3A_verbose">verbose</code></td>
<td>
<p>Can be set to TRUE if additional information is desired while the attribute is being created.</p>
</td></tr>
<tr><td><code id="ncatt_put_+3A_definemode">definemode</code></td>
<td>
<p>If FALSE (the default), it is assumed that the file is NOT already in define mode.  Since the file must be in define mode for this call to work, the file will be put in define mode, the attribute defined, and then the file taken out of define mode.  If this argument is set to TRUE, it is assumed the file is already in define mode, and the file is also left in define mode.  If you don't know what any of this means, just leave
this at the default value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function write an attribute to a netCDF variable (or a global attribute
to a netCDF file, if the passed argument &quot;varid&quot; is zero).
The type of the written variable can be controlled by the &quot;prec&quot; argument, if
the default behavior (the precision follows that of the associated variable) is
not wanted.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+ncatt_get">ncatt_get</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Make a simple netCDF file
filename &lt;- "atttest_types.nc"
dim &lt;- ncdim_def( "X", "inches", 1:12 )
var &lt;- ncvar_def( "Data", "unitless", dim, -1 ) 
ncnew &lt;- nc_create( filename, var )

# Define some attributes of various types
attvaldbl &lt;- 3.1415926536
ncatt_put( ncnew, var, "testatt_dbl", attvaldbl, prec="double" )
attvalfloat &lt;- c(1.0,4.0,9.0,16.0)
ncatt_put( ncnew, var, "testatt_float", attvalfloat )
# varid=0 means it is a global attribute
ncatt_put( ncnew, 0, "globalatt_int", 32000, prec="int" ) 
ncatt_put( ncnew, 0, "globalatt_short", 7, prec="short" )
ncatt_put( ncnew, 0, "description", 
	"this is a test file with attributes of various types")
nc_close(ncnew)

# Clean up our test
file.remove( filename )

## End(Not run)
</code></pre>

<hr>
<h2 id='ncdf4-internal'>Internal ncdf4 functions</h2><span id='topic+ncdim_create'></span><span id='topic+ncdim_same'></span><span id='topic+default_missval_ncdf4'></span><span id='topic+ncvar_name'></span><span id='topic+vobjtovarid4'></span><span id='topic+ncvar_inq'></span><span id='topic+ncdim_inq'></span><span id='topic+nc_unlimdim'></span><span id='topic+ncvar_size'></span><span id='topic+ncvar_ndims'></span><span id='topic+ncdim_id'></span><span id='topic+ncvar_id'></span><span id='topic+ncvar_id_to_missing_value'></span><span id='topic+ncvar_name'></span><span id='topic+ncvar_type'></span><span id='topic+blankstring_ncdf4'></span><span id='topic+nslashes_ncdf4'></span><span id='topic+ncvar_type_to_string'></span><span id='topic+ncvar_inq_deflate'></span><span id='topic+ncvar_inq_chunking'></span><span id='topic+ncvar_get_inner'></span><span id='topic+ncvar_def_deflate'></span><span id='topic+ncvar_def_chunking'></span><span id='topic+ncdf4_format'></span><span id='topic+ncdf4_make_id'></span><span id='topic+ncatt_put_inner'></span><span id='topic+ncatt_get_n'></span><span id='topic+ncatt_get_inner'></span><span id='topic+nc_parse_group_structure'></span><span id='topic+nc_make_group_inner'></span><span id='topic+nc_grpname'></span><span id='topic+nc_grpids'></span><span id='topic+nc_groups_below'></span><span id='topic+nc_get_grp_info'></span><span id='topic+nc4_loop'></span><span id='topic+nc4_basename'></span>

<h3>Description</h3>

<p>Internal ncdf functions.
</p>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='ncdf4-package'>Read, write, and create netCDF files (including version 4 format)</h2><span id='topic+ncdf4-package'></span>

<h3>Description</h3>

<p>Read from or write to existing netCDF format files, or create new ones.
</p>


<h3>Details</h3>

<p>More information on this package, including detailed installation instructions,
can be found at http://dwpierce.com/software.
</p>
<p>The netCDF data file format from Unidata is a platform-independent, binary
file that also contains metadata describing the contents and format of the data
in the file.  Version 4 of the netcdf library stores data in HDF5 format files;
earlier versions stored data in a custom format.
The R package ncdf4 can read either format.
</p>
<p>NetCDF files contain one or more variables, which are usually
structured as regular N-dimensional arrays.  For example, you might
have a variable named &quot;Temperature&quot; that is a function of longitude,
latitude, and height. NetCDF files also contain dimensions, which 
describe the extent of the variables' arrays.  In our Temperature example,
the dimensions are &quot;longitude&quot;, &quot;latitude&quot;, and &quot;height&quot;. Data can be read from
or written to variables in arbitrary hyperslabs (for example, you can 
read or write all the Temperature values at a given height, or at a given
latitude).  
</p>
<p>The R package 'ncdf4' allows
reading from, writing to, and creation of netCDF files, either netCDF version
3 or (optionally) netCDF version 4.  If you choose to create version 4
output files, be aware that older netcdf software might only be
able to read version 3 files.
</p>
<p>Note that both the
netCDF library and the HDF5 library must already be installed on your machine for 
this R interface to the library to work.
</p>
<p>If you are new to netCDF files, they can be a little overwhelming,
so here is a brief sketch of what documentation you need to read next.  
</p>
<p>If you want to READ data 
from an already-existing netCDF file, first call <code><a href="#topic+nc_open">nc_open</a></code> 
to open the file, then call <code><a href="#topic+ncvar_get">ncvar_get</a></code> to read the data
from a variable in the file.  
</p>
<p>If you want to WRITE data to a new netCDF file, the procedure is
to first define the dimensions your data array has, then define the
variable, then create the file.  So, first call
<code><a href="#topic+ncdim_def">ncdim_def</a></code> to define the dimensions that your data
exists along (for example, latitude, longitude, and time). Then call
<code><a href="#topic+ncvar_def">ncvar_def</a></code> to define a variable 
that uses those dimensions, and will hold your data.
Then call <code><a href="#topic+nc_create">nc_create</a></code>
to create the netCDF file.
Finally, call <code><a href="#topic+ncvar_put">ncvar_put</a></code>
to write your data to the newly created netCDF file, 
and <code><a href="#topic+nc_close">nc_close</a></code> when you are done.
</p>
<p>Not all features of netcdf-4 are supported yet.
This version supports compression, chunking, groups, vlen strings, and multiple
unlimited dimensions.
User-defined types and vlen data arrays (variable-length arrays) are not supported yet.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+print.ncdf4">print.ncdf4</a></code>,
<code><a href="#topic+nc_open">nc_open</a></code>,
<code><a href="#topic+nc_close">nc_close</a></code>, 
<code><a href="#topic+nc_create">nc_create</a></code>,
<code><a href="#topic+ncdim_def">ncdim_def</a></code>,
<code><a href="#topic+ncvar_def">ncvar_def</a></code>,
<code><a href="#topic+ncvar_get">ncvar_get</a></code>,
<code><a href="#topic+ncvar_put">ncvar_put</a></code>,
<code><a href="#topic+ncvar_change_missval">ncvar_change_missval</a></code>,
<code><a href="#topic+ncatt_get">ncatt_get</a></code>,
<code><a href="#topic+ncatt_put">ncatt_put</a></code>, 
<code><a href="#topic+nc_sync">nc_sync</a></code>,
<code><a href="#topic+nc_redef">nc_redef</a></code>.
</p>

<hr>
<h2 id='ncdim_def'>Define a netCDF Dimension</h2><span id='topic+ncdim_def'></span>

<h3>Description</h3>

<p>Defines a netCDF dimension.  This dimension initially only exists in memory.
The dimension is later added to a netCDF variable using a call to <code>ncvar_def()</code>, 
and written to disk using <code>nc_create()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ncdim_def( name, units, vals, unlim=FALSE, 
 	create_dimvar=TRUE, calendar=NA, longname=name )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncdim_def_+3A_name">name</code></td>
<td>
<p>Name of the dimension to be created (character string).
The dimension name can 
optionally have forward slashes in it, in which case the dimension will be defined 
in the indicated group. For example, a dimension
named <code>model3/run1/Longitude</code> will define a group named <code>model3</code>, with a
subgroup named <code>run1</code>, which will hold a dimension named <code>Longitude</code>. Using
groups forces a netcdf version 4 file to be written. Note that older software might not
be able to read netcdf version 4 files.</p>
</td></tr>
<tr><td><code id="ncdim_def_+3A_units">units</code></td>
<td>
<p>The dimension's units (character string).</p>
</td></tr>
<tr><td><code id="ncdim_def_+3A_vals">vals</code></td>
<td>
<p>The dimension's values (vector of numeric type). If integers are passed, the associated dimensional variable will be integer type; otherwise, it will be double precision.</p>
</td></tr>
<tr><td><code id="ncdim_def_+3A_unlim">unlim</code></td>
<td>
<p>If TRUE, this dimension is unlimited.  Unlimited dimensions are convenient for storing, for example, data that extends over time; 
the time dimension can be made unlimited, and extended as needed.  Or, an unlimited dimension could be the number of stations, and extended
as more stations come on-line.  Note that in netCDF version 4, multiple dimensions can be unlimited.  In netCDF version 3, there could
only be one unlimited dimension, typically the time dimension.</p>
</td></tr>
<tr><td><code id="ncdim_def_+3A_create_dimvar">create_dimvar</code></td>
<td>
<p>If TRUE, a dimensional variable (aka coordinate variable) will be created for this dimension. Note: if this is set to FALSE, then 'units' must be an empty string.  It is good practice to always leave this as TRUE.</p>
</td></tr>
<tr><td><code id="ncdim_def_+3A_calendar">calendar</code></td>
<td>
<p>If set, the specified string will be added as an attribute named &quot;calendar&quot; to the dimension variable.  Used almost exclusively with unlimited time dimensions.  Useful values include &quot;standard&quot; (or &quot;gregorian&quot;), &quot;noleap&quot; (or &quot;365_day&quot;), and &quot;360_day&quot;). </p>
</td></tr>
<tr><td><code id="ncdim_def_+3A_longname">longname</code></td>
<td>
<p>If set, AND create_dimvar is TRUE, 
then the created dimvar will have a long_name attribute with this value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine creates a netCDF dimension in memory.  The created dimension can then
later be passed to the routine <code>ncvar_def()</code> when defining a variable.
</p>
<p>Note that this interface to the netCDF library by default includes that more than the
minimum required by the netCDF standard.  I.e., the netCDF standard allows
dimensions with no units or values.  This call encourages creating dimensions
that have units and values,
as it is useful to ensure that all dimensions have units and
values, and considerably easier to include them in this call than it is
to add them later.  The units and values are implemented through &quot;dimensional
variables,&quot; which are variables with the same name as the dimension.  By default, these
dimensional variables are created automatically &ndash; there is no need for the
user to create them explicitly.  Dimensional variables are standard practice
in netCDF files.  To suppress the creation of the dimensional variable for
the dimension, set passed parameter create_dimvar to FALSE.  As a
check, if create_dimvar is FALSE, you must ALSO pass an empty string (&rdquo;) as the unit, and the values
must be simple integers from 1 to the length of the dimension (e.g., 1:10 to
make a dimension of length 10).
This empahsizes that without a dimensional variable, a netCDF file cannot
store a dimension's units or values.
</p>
<p>The dimensional variable is usually created as a double precision floating
point.  The other possibility is to pass integer values (using <code>as.integer</code>,
for example), in which case the dimensional variable with be integer.
</p>
<p>The return value of this function is an object of class <code>ncdim4</code>, which
describes the newly created dimension.
The <code>ncdim</code> object is used for more than just creating a new 
dimension, however.
When opening an existing file, function <code><a href="#topic+nc_open">nc_open</a></code> returns a 
<code>ncdf4</code> class object, which itself has a list of <code>ncdim</code> objects
that describe all the dimensions in that existing file.
</p>
<p>The <code>ncdim</code> object has the following fields, which are all read only:
1) name, which is a character string containing the name of the dimension;
2) units, which is a character string containing the units for the dimension,
if there are any (technically speaking, this is the &quot;units&quot; attribute of the
associated coordinate variable); 3) vals, which is a vector containing the
dimension's values (i.e., the values of the associated coordinate variable,
or, if there is none, an integer sequence from 1 to the length of the dimension);
3) len, which is the length of this dimension; 4) unlim, which is a boolean
indicating whether or not this is an unlimited dimension; 5) (optional) calendar,
which is set if and only if the on-disk dimvar had an attribute named
&quot;calendar&quot; (in which case, it is set to the value of that attribute).
</p>


<h3>Value</h3>

<p>An object of class <code>ncdim4</code> that can later be passed to 
<code>ncvar_def()</code>.
</p>


<h3>Note</h3>

<p>It is good practice, but not necessary, to pass the dimension's values 
to this routine when the dimension is created.  It is also possible to 
write them later with a call to 'ncvar_put', using as the dimension
name as the 'varid' in the call.  This is useful when creating large variables
with long unlimited dimensions; it can take a long time to write out the
unlimited dimension's values.  In this case, it can be more efficient to
step through the file, writing one timestep at a time, and write that 
timestep's dimensional value at the same time.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+ncvar_def">ncvar_def</a></code>, <code><a href="#topic+nc_create">nc_create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Define some straightforward dimensions
x &lt;- ncdim_def( "Lon", "degreesE", 0.5:359.5)
y &lt;- ncdim_def( "Lat", "degreesN", as.double(-89:89))
t &lt;- ncdim_def( "Time", "days since 1900-01-01", 1:10, unlim=TRUE)

# Make a variable with those dimensions.  Note order: time is LAST
salinity &lt;- ncvar_def("Salinity",    "ppt",  list(x,y,t), 1.e30 )

# Create a netCDF file with this variable
ncnew &lt;- nc_create( "salinity.nc", salinity )

nc_close(ncnew)

# Now, illustrate some manipulations of the ncdim object.
filename &lt;- "salinity.nc"
nc &lt;- nc_open( filename )
print(paste("File",filename,"contains",nc$ndims,"dimensions"))
for( i in 1:nc$ndims ) {
	print(paste("Here is information about dimension number",i,":"))
	d &lt;- nc$dim[[i]]
	print(paste("    Name  :",d$name))
	print(paste("    Units :",d$units))
	print(paste("    Length:",d$len))
	print("    Values:")
	print(d$vals)
	print(paste("    Unlimited:",d$unlim))
	}
nc_close( nc )

# Clean up example
file.remove( filename )

## End(Not run)
</code></pre>

<hr>
<h2 id='ncvar_add'>Add New netCDF Variable to Existing File</h2><span id='topic+ncvar_add'></span>

<h3>Description</h3>

<p>Special purpose routine for adding a new variable to a netCDF file
that already exists on disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ncvar_add( nc, v, verbose=FALSE, indefine=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncvar_add_+3A_nc">nc</code></td>
<td>
<p>The already-existing netCDF file we want to add a new variable to. This must
be a value of class &quot;ncdf4&quot; returned by a call to <code><a href="#topic+nc_open">nc_open</a></code><code>(...,write=TRUE).</code></p>
</td></tr>
<tr><td><code id="ncvar_add_+3A_v">v</code></td>
<td>
<p>The variable to be added to the file.  This must be 
a value of class &quot;ncvar4&quot; returned by a call to <code><a href="#topic+ncvar_def">ncvar_def</a></code>.</p>
</td></tr>
<tr><td><code id="ncvar_add_+3A_verbose">verbose</code></td>
<td>
<p>If true, prints diagnostic messages.</p>
</td></tr>
<tr><td><code id="ncvar_add_+3A_indefine">indefine</code></td>
<td>
<p>If true, the file is assumed to already be in define mode.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two cases in which you might want to add a variable to a netCDF
file.  The first, and most common way, is when you are creating a 
new netCDF file.
Usually when you create a netCDF file, you specify what variables you want
the file to contain.
This is the method
most users will use to make netCDF files.  To do this, do NOT use this
routine; instead, pass a list of the variables you wish to have created in the output
file to routine <code><a href="#topic+nc_create">nc_create</a></code>.
</p>
<p>The second, less common, case is when you already have an existing netCDF
file on disk and wish to add a new variable to it.  In that case, use
this routine.  First define the variable you want to add to the existing
file using routine <code><a href="#topic+ncvar_def">ncvar_def</a></code>; then add it to the already-existing
and opened (for writing) netCDF file using this routine.  (This routine
automatically creates any additional dimensions that are needed in the
output file to handle the new variable.)
</p>
<p>NOTE that the return value of this routine should replace the old netCDF
file handle that you were using.  This newly returned value reflects the
modifications to the file that were accomplished by calling this routine.
</p>


<h3>Value</h3>

<p>A handle to the netCDF file that describes the newly modified file.
This is an object of type 'ncdf', the same as returned by <code><a href="#topic+nc_open">nc_open</a></code>
or <code><a href="#topic+nc_create">nc_create</a></code>.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+ncdim_def">ncdim_def</a></code>, <code><a href="#topic+nc_create">nc_create</a></code>, 
<code><a href="#topic+ncvar_def">ncvar_def</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#===========================================================================
# PART 1.  MAKE A TEST NETCDF FILE THAT WE WILL ADD A VARIABLE TO IN PART 2.
#===========================================================================

#----------------
# Make dimensions
#----------------
xvals &lt;- 1:360
yvals &lt;- -90:90

nx &lt;- length(xvals)
ny &lt;- length(yvals)

xdim &lt;- ncdim_def( 'Lon', 'degreesE', xvals )
ydim &lt;- ncdim_def( 'Lat', 'degreesE', yvals )
tdim &lt;- ncdim_def( 'Time', 'days since 1900-01-01', 0, unlim=TRUE )

#---------
# Make var
#---------
mv &lt;- 1.e30     # missing value
var_temp &lt;- ncvar_def( 'Temperature', 'K', list(xdim,ydim,tdim), mv )

#---------------------
# Make new output file
#---------------------
output_fname &lt;- 'test_real3d.nc'
ncid_new &lt;- nc_create( output_fname, list(var_temp))

#-------------------------------
# Put some test data in the file
#-------------------------------
data_temp &lt;- array(0.,dim=c(nx,ny,1))
for( j in 1:ny )
for( i in 1:nx )
        data_temp[i,j,1] &lt;- sin(i/10)*sin(j/10)

ncvar_put( ncid_new, var_temp, data_temp, start=c(1,1,1), count=c(nx,ny,1))

#--------------------------
# Close our new output file
#--------------------------
nc_close( ncid_new )

#===========================================================================
# PART 2.  ADD A NEW VARIABLE TO THE FILE
#===========================================================================

#---------------------------------------------------
# Open the existing file we're going to add a var to
#---------------------------------------------------
ncid_old &lt;- nc_open( output_fname, write=TRUE )

#------------------------------------------------------------------
# Make a NEW variable to put into the file.  Have this new variable
# use the same dimensions already in the file
#------------------------------------------------------------------
xdim2 &lt;- ncid_old$dim[['Lon']]
ydim2 &lt;- ncid_old$dim[['Lat']]
tdim2 &lt;- ncid_old$dim[['Time']]
mv2 &lt;- 1.e30
var_q &lt;- ncvar_def( 'Humidity', 'g/kg', list(xdim2,ydim2,tdim2), mv2 )

ncid_old &lt;- ncvar_add( ncid_old, var_q )	# NOTE this returns a modified netcdf file handle 

#-------------------------------------------------------------------
# Make a DIFFERENT new var that will be added to the file.  This var
# uses a dim that does NOT already exist in the file.
#-------------------------------------------------------------------
zdim   &lt;- ncdim_def( 'Level', 'hPa', seq(1000,100,by=-100))
var_cf &lt;- ncvar_def( 'CloudFraction', 'percent', list(xdim2,ydim2,zdim,tdim2), mv2 )

ncid_old &lt;- ncvar_add( ncid_old, var_cf )

print(ncid_old)

nc_close( ncid_old )

# Clean up our example
file.remove( output_fname )

## End(Not run)
</code></pre>

<hr>
<h2 id='ncvar_change_missval'>Change the Missing Value For a netCDF Variable</h2><span id='topic+ncvar_change_missval'></span>

<h3>Description</h3>

<p>Changes the missing_value attribute for a netCDF variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ncvar_change_missval( nc, varid, missval ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncvar_change_missval_+3A_nc">nc</code></td>
<td>
<p>An object of class <code>ncdf4</code>, as returned by <code><a href="#topic+nc_open">nc_open</a></code><code>(...,write=TRUE)</code> 
or <code><a href="#topic+nc_create">nc_create</a></code>.</p>
</td></tr>
<tr><td><code id="ncvar_change_missval_+3A_varid">varid</code></td>
<td>
<p>Either the name of the variable or an <code>ncvar</code> object indicating 
whose missing value will be changed.</p>
</td></tr>
<tr><td><code id="ncvar_change_missval_+3A_missval">missval</code></td>
<td>
<p>The missing value to change to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: this specialty function is only used to change a variable's missing value
after it has already been defined,
which is rare.  The proper way to set
a variable's missing value in the first place is by setting the missing value argument to
routine <code><a href="#topic+ncvar_def">ncvar_def</a></code> appropriately.
</p>
<p>Missing values are special values in netCDF files whose value is to be taken
as indicating the data is &quot;missing&quot;.
This is a convention, and is indicated by the netCDF variable having an
attribute named &quot;missing_value&quot; that holds this number.
This function sets the &quot;missing_value&quot; attribute for a variable.
</p>
<p>R uses a similar concept to indicate missing values, the &quot;NA&quot; value.
When the ncdf library reads in data set from a pre-existing file, all data values
that equal that variable's missing value attribute appear to the R code
as being &quot;NA&quot; values.
When the R code writes values to a netCDF variable, any &quot;NA&quot; values are
set to that variable's missing value before being written out.
This makes the mapping between netCDF's &quot;missing_value&quot; attribute and
R's &quot;NA&quot; values transparent to the user.
</p>
<p>For this to work, though, the user still has to specify a missing value
for a variable.  Usually this is specified when the variable is created,
as a required argument to <code><a href="#topic+ncvar_def">ncvar_def</a></code>.
However, sometimes it is useful to add (or change) a missing value for variable
that already exists in a disk file.  This function enables that.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+ncvar_def">ncvar_def</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Make an example netCDF file with a given missing value.  We will
# then change the missing value in the file using ncvar_change_missval

origMissVal &lt;- -1.
dimX   &lt;- ncdim_def( "X", "meters", 1:7 )
varAlt &lt;- ncvar_def( "Altitude", "km", dimX, origMissVal )
ncnew  &lt;- nc_create( "transect.nc", varAlt )
data &lt;- c(10.,2.,NA,1.,7.,NA,8.)
ncvar_put( ncnew, varAlt, data )
nc_close(ncnew)

# At this point, the actual data values in the netCDF
# file will be: 10 2 -1 1 7 -1 8
# because the "NA" values were filled with the missing
# value, -1.  Also, the missing_value attribute of variable
# "varAlt" will be equal to -1.

# Now change the missing value to something else.  Remember
# we have to open the file as writable to be able to change
# the missing value on disk!

newMissVal &lt;- 999.9
nc &lt;- nc_open( "transect.nc", write=TRUE )
varname &lt;- "Altitude"
data &lt;- ncvar_get( nc, varname )  # data now has: 10., 2., NA, 1., 7., NA, 8.
print(data)
ncvar_change_missval( nc, varname, newMissVal )
ncvar_put( nc, varname, data )
nc_close(nc)

# Now, the actual data values in the netCDF file will be:
# 10 2 999.9 1 7 999.9 8
# and the variables "missing_value" attributre will be 999.9

# **NOTE** that we had to explicitly read in the data and write
# it out again in order for the on-disk missing values in the
# data array to change!  The on-disk missing_value attribute for
# the variable is set automatically by this function, but it is 
# up to you whether or not you want to read in all the existing
# data and change the values to the new missing value.

# Clean up our example
file.remove( "transect.nc" )

## End(Not run)
</code></pre>

<hr>
<h2 id='ncvar_def'>Define a netCDF Variable</h2><span id='topic+ncvar_def'></span>

<h3>Description</h3>

<p>Defines a netCDF variable.  This variable initially only exists in memory.
It is later written to disk using <code>nc_create()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ncvar_def( name, units, dim, missval=NULL, longname=name, prec="float", 
 shuffle=FALSE, compression=NA, chunksizes=NA, verbose=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncvar_def_+3A_name">name</code></td>
<td>
<p>Name of the variable to be created (character string).  
The name can 
optionally have forward slashes in it, in which case the variable will be defined 
in the indicated group. For example, a variable
named <code>model3/run1/Temperature</code> will define a group named <code>model3</code>, with a
subgroup named <code>run1</code>, which will hold a variable named <code>Temperature</code>. Using
groups forces a netcdf version 4 file to be written. Note that older software might not
be able to read netcdf version 4 files.</p>
</td></tr>
<tr><td><code id="ncvar_def_+3A_units">units</code></td>
<td>
<p>The variable's units (character string). Or, pass a zero length string (&rdquo;) to have no units attribute.</p>
</td></tr>
<tr><td><code id="ncvar_def_+3A_dim">dim</code></td>
<td>
<p>The variable's dimension(s) (one or a list of &quot;ncdim4&quot; class objects, as returned by <code>ncdim_def</code>).  To create a variable with NO dimensions, pass an empty list (&quot;list()&quot;). </p>
</td></tr>
<tr><td><code id="ncvar_def_+3A_missval">missval</code></td>
<td>
<p>The variable's missing value. If NO missing value is desired, pass a NULL, or omit this argument entirely. If a NaN missing value is desired, pass an NA.</p>
</td></tr>
<tr><td><code id="ncvar_def_+3A_longname">longname</code></td>
<td>
<p>Optional longer name for the variable, which is assigned to the variable's &quot;long_name&quot; attribute. For example, a variable named &quot;TS&quot; might have the longname &quot;Surface Temperature&quot;</p>
</td></tr>
<tr><td><code id="ncvar_def_+3A_prec">prec</code></td>
<td>
<p>Precision of the created variable.  Valid options: 'short' 'integer' 'float' 'double' 'char' 'byte'. See the special note below for how to create a character variable (strings).</p>
</td></tr>
<tr><td><code id="ncvar_def_+3A_shuffle">shuffle</code></td>
<td>
<p>Turns on (if TRUE) or off (if FALSE, the default) the shuffle filter.  According to 
netcdf docs, turning the shuffle filter on can improve compression for integer variables.
Turning the shuffle filter on forces the created file to be in netcdf version 4 format,
which will not be compatible with older software that only reads netcdf version 3 files.</p>
</td></tr>
<tr><td><code id="ncvar_def_+3A_compression">compression</code></td>
<td>
<p>If set to an integer between 1 (least compression) and 9 (most compression), this
enables compression for the variable as it is written to the file.
Turning compression on forces the created file to be in netcdf version 4 format,
which will not be compatible with older software that only reads netcdf version 3 files.</p>
</td></tr>
<tr><td><code id="ncvar_def_+3A_chunksizes">chunksizes</code></td>
<td>
<p>If set, this must be a vector of integers with a length equal to the number
of dimensions in the variable. When data from this variable is written to the file, it
will be buffered in blocks as indicated by the chunksize. The order of dimensions
in this vector is the standard R ordering of XYZT. In some instances, setting a 
chunksize that reflects how the variable's data will be read or written can greatly
reduce read or write times. See the netcdf documentation for more detail on how to set this
parameter. Enabling this feature forces the created file to be in netcdf version 4 format,
which will not be compatible with older software that only reads netcdf version 3 files.</p>
</td></tr>
<tr><td><code id="ncvar_def_+3A_verbose">verbose</code></td>
<td>
<p>Print debugging information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine creates a netCDF variable in memory.  The variable can then
be passed to the routine <code>nc_create</code> when writing a file to disk.
</p>
<p>Note that this interface to the netCDF library includes more than the
minimum required by the netCDF standard.  I.e., the netCDF standard allows
variables with no units or missing values.  This call requires units and 
a missing value,
as it is useful to ensure that all variables have units and
missing values, and considerably easier to include them in this call than it is
to add them later.  The units and missing value are implemented through attributes
to the variable, named &quot;units&quot; and &quot;missing_value&quot;, respectively.
This is standard practice in netCDF files.
</p>
<p>After a variable is defined with this call, and created on disk using
<code><a href="#topic+nc_create">nc_create</a></code>, then data values for the variable can be written
to disk using <code><a href="#topic+ncvar_put">ncvar_put</a></code>.
</p>
<p>This function returns a <code>ncvar</code> object, which describes the newly-created
variable.  However, the <code>ncvar</code> object is used for more than just
creating new variables.  The function <code><a href="#topic+nc_open">nc_open</a></code> returns a <code>ncdf4</code>
class object that itself contains a list of <code>ncvar4</code> objects that describe
the variables in an existing, on-disk netCDF file.  (Note that coordinate
variables are NOT included in this list.  Attributes of the coordinate variables
are kept in the <code>ncdim4</code> class object instead.)
</p>
<p>The <code>ncvar4</code> class object has the following fields, which are all read-only:
1) name, which is a character string containing the name of the variable;
2) units, which is a character string containing the contents of the
variable's &quot;units&quot; attribute; 3) missval, which contains the contents of the
variable's &quot;missing_value&quot; attribute; 4) longname, which is the 
contents of the variable's &quot;long_name&quot; attribute, or defaults to the name
of the variable if there is no &quot;long_name&quot; attribute; 5) ndims, which is the
number of dimensions this variable has; 6) dim, which is a list of objects of
class &quot;ncdim4&quot; (see <code><a href="#topic+ncdim_def">ncdim_def</a></code>), and describe this
variable's dimensions; 7) unlim, which is TRUE if this variable has an unlimited
dimension and FALSE otherwise; 8) varsize, which is a convenience array
that gives the shape of the variable (in XYZT ordering).
</p>
<p>Note that the missval attribute does not need to be used much in R, because
R's special value NA is fully supported.  I.e., when data is read in from an
existing file, any values equal to the &quot;missing&quot; value are set to NA.  When
data is written out, any NAs are set equal to the missing value.  If not
explicitly set by the user, a default value of 1.e30 is used for the missing
value.
</p>
<p>CHARACTER VARIABLES: Character-type variables (i.e., strings) are supported using the
original netcdf library approach, which is used because it is backwards compatible with
the older version 3 of the netcdf library. This approach uses fixed-size
strings, which should be declared to be the maximum length of the string
that will be stored. If the maximum string size is N, then an auxiliary
dimension is first defined, with values
running from 1 to N. For example, if N=12 and we call the new
auxiliary dimension &quot;nchar&quot;, then the code could look like this:
dimnchar &lt;- ncdim_def(&quot;nchar&quot;, &quot;&quot;, 1:12, create_dimvar=FALSE ). The
character type variable is then defined with the first dimension being
this new auxiliary variable: varcolors &lt;- ncvar_def(&quot;colors&quot;, &quot;&quot;, list(dimnchar, dimcolorno),
prec=&quot;char&quot; ). See the manual page for <code><a href="#topic+ncvar_put">ncvar_put</a></code> for a worked example.
</p>


<h3>Value</h3>

<p>An object of class <code>ncvar4</code> that can later be passed to 
<code>nc_create()</code>.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+ncdim_def">ncdim_def</a></code>, <code><a href="#topic+nc_create">nc_create</a></code>, 
<code><a href="#topic+ncvar_put">ncvar_put</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Define an integer dimension 
dimState &lt;- ncdim_def( "StateNo", "count", 1:50 )

# Make an integer variable.  Note that an integer variable can have
# a double precision dimension, or vice versa; there is no fixed
# relationship between the precision of the dimension and that of the
# associated variable.  We just make an integer variable here for
# illustration purposes.
varPop &lt;- ncvar_def("Pop", "count", dimState, -1, 
		longname="Population", prec="integer")

# Create a netCDF file with this variable
ncnew &lt;- nc_create( "states_population.nc", varPop )

# Write some values to this variable on disk.
popAlabama &lt;- 4447100
ncvar_put( ncnew, varPop, popAlabama, start=1, count=1 )

# Add source info metadata to file
ncatt_put( ncnew, 0, "source", "Census 2000 from census bureau web site")

nc_close(ncnew)

# Now illustrate some manipulations of the var.ncdf object
filename &lt;- "states_population.nc"
nc &lt;- nc_open(filename)
print(paste("File",nc$filename,"contains",nc$nvars,"variables"))
for( i in 1:nc$nvars ) {
	v &lt;- nc$var[[i]]
	print(paste("Here is information on variable number",i))
	print(paste("   Name: ",v$name))
	print(paste("   Units:",v$units))
	print(paste("   Missing value:",v$missval))
	print(paste("   # dimensions :",v$ndims))
	print(paste("   Variable size:",v$varsize))
	}

# Illustrate creating variables of various types.  You will find
# that the type of the missing_value attribute automatically follows
# the type of the variable.
dimt &lt;- ncdim_def( "Time", "days", 1:3 ) 
missval &lt;- -1
varShort &lt;- ncvar_def( "varShort", "meters", dimt, missval, prec="short")
varInt   &lt;- ncvar_def( "varInt",   "meters", dimt, missval, prec="integer")
varFloat &lt;- ncvar_def( "varFloat", "meters", dimt, missval, prec="single")
varDouble&lt;- ncvar_def( "varDouble","meters", dimt, missval, prec="double")
nctypes &lt;- nc_create("vartypes.nc", list(varShort,varInt,varFloat,varDouble) )
nc_close(nctypes)

# Clean up example
file.remove( filename )
file.remove( "vartypes.nc" )

## End(Not run)
</code></pre>

<hr>
<h2 id='ncvar_get'>Read data from a netCDF file</h2><span id='topic+ncvar_get'></span>

<h3>Description</h3>

<p>Reads data from an existing netCDF file.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ncvar_get(nc, varid=NA, start=NA, count=NA, verbose=FALSE,
 signedbyte=TRUE, collapse_degen=TRUE, raw_datavals=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncvar_get_+3A_nc">nc</code></td>
<td>
<p>An object of class <code>ncdf4</code> (as returned by either 
function <code><a href="#topic+nc_open">nc_open</a></code>
or function <code><a href="#topic+nc_create">nc_create</a></code>), indicating what file to read from.</p>
</td></tr>
<tr><td><code id="ncvar_get_+3A_varid">varid</code></td>
<td>
<p>What variable to read the data from.  Can be a string with the name
of the variable or an object of class <code>ncvar4</code>
If left unspecified, the function will determine if there
is only one variable in the file and, if so, read from that.  If left unspecified
and there are multiple variables in the file, an error is generated.
This argument can also, optionally, specify the name of a dimension (usually the
unlimited dimension) in order to read values from a coordinate variable.
Note this is not usual practice, because the <code>ncdim</code> object already
contains all the dimension's values in the field named &quot;vals&quot;.  However, it can
sometimes be faster to turn off this automatic reading of the unlimited dimension's
values by using <code>nc_open(filename, readunlim=FALSE)</code>, then read the
dimension values in later with this function.</p>
</td></tr>
<tr><td><code id="ncvar_get_+3A_start">start</code></td>
<td>
<p>A vector of indices indicating where to start reading the passed values
(beginning at 1).  
The length of this vector must equal the number of dimensions the variable has.
Order is X-Y-Z-T (i.e., the time dimension is last).  If not specified, reading 
starts at the beginning of the file (1,1,1,...).</p>
</td></tr>
<tr><td><code id="ncvar_get_+3A_count">count</code></td>
<td>
<p>A vector of integers indicating the count of values to read
along each dimension (order is X-Y-Z-T).  
The length of this vector must equal the number of dimensions the variable has.
If not specified and the variable does
NOT have an unlimited dimension, the entire variable is read.  
As a special case, the value
&quot;-1&quot; indicates that all entries along that dimension should be read.</p>
</td></tr>
<tr><td><code id="ncvar_get_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, then progress information is printed.</p>
</td></tr>
<tr><td><code id="ncvar_get_+3A_signedbyte">signedbyte</code></td>
<td>
<p>If TRUE (default), then on-disk byte variables are interpreted
as signed.  This is in accord with the netCDF standard.  If FALSE, then
on-disk byte variables are interpreted as unsigned.</p>
</td></tr>
<tr><td><code id="ncvar_get_+3A_collapse_degen">collapse_degen</code></td>
<td>
<p>If TRUE (the default), then degenerate (length==1) dimensions
in the returned array are removed.</p>
</td></tr>
<tr><td><code id="ncvar_get_+3A_raw_datavals">raw_datavals</code></td>
<td>
<p>If TRUE, then the actual raw data values from the
file are returned with no conversion to NA (if equal to the missing value/fill value) or
scale/offset applied. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine reads data values from a variable in an existing netCDF file.  The file
must already have been opened with a call to <code><a href="#topic+nc_open">nc_open</a></code>.
</p>
<p>Returned values will be in ordinary R double precision if the netCDF 
variable type is float or double.
Returned values will be in R's integer storage mode if the netCDF 
variable type is short or int.
Returned values will be of character type if the netCDF variable is 
of character type.
</p>
<p>Values of &quot;NA&quot; are supported; values in the data file that match the
variable's missing value attribute are automatically converted to &quot;NA&quot; before
being returned to the user.
See <code><a href="#topic+ncvar_change_missval">ncvar_change_missval</a></code> for more information.
</p>
<p>Data in a netCDF file is conceived as being a multi-dimensional array.
The number and length of dimensions is determined when the variable is
created.  The 'start' and 'count' indices that this routine takes indicate
where the writing starts along each dimension, and the count of values
along each dimension to write.  Note that the special count value &quot;-1&quot;
means &quot;all the values along that dimension&quot;.
</p>
<p>If the variable in the netCDF file has a scale and/or offset attribute defined, 
the returned data are automatically and silently scaled and/or offset as requested.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+ncvar_put">ncvar_put</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Start with the simplest example.  If the file only has one variable in it,
# you can read the data as easily as this:
#
nc &lt;- nc_open("salinity.nc")
# NOTE how not specifying varid reads the "only" var in the file
data &lt;- ncvar_get( nc )	
nc_close(nc)

# In this next example we read values from file "writevals.nc", which is created by
# the R code in the example section for function "ncvar_put".  We open the
# file with readunlim=FALSE for potentially faster access, and to illustrate
# (below) how to read in the unlimited dimension values.
#
nc &lt;- nc_open( "writevals.nc", readunlim=FALSE )

print(paste("The file has",nc$nvars,"variables"))

# This illustrates how to read all the data from a variable
v1 &lt;- nc$var[[1]]
data1 &lt;- ncvar_get( nc, v1 )	# by default, reads ALL the data
print(paste("Data for var ",v1$name,":",sep=""))
print(data1)

# This shows how the shape of the read data is preserved
v2 &lt;- nc$var[[2]]
data2 &lt;- ncvar_get( nc, v2 )
print(paste("Var 2 has name",v2$name,"and is of shape",dim(data2),
	". Here are the values:"))
print(data2)

# This illustrates how to read data one timestep at a time.  In this
# example we will elaborately show how to deal with a variable whose
# shape is completely unknown (i.e., how many dimensions, and what their
# sizes are).  We will also, for illustration of a common case, show how
# to read in the values of the time dimension at each timestep.
v3      &lt;- nc$var[[3]]
varsize &lt;- v3$varsize
ndims   &lt;- v3$ndims
nt      &lt;- varsize[ndims]  # Remember timelike dim is always the LAST dimension!
for( i in 1:nt ) {
	# Initialize start and count to read one timestep of the variable.
	start &lt;- rep(1,ndims)	# begin with start=(1,1,1,...,1)
	start[ndims] &lt;- i	# change to start=(1,1,1,...,i) to read timestep i
	count &lt;- varsize	# begin w/count=(nx,ny,nz,...,nt), reads entire var
	count[ndims] &lt;- 1	# change to count=(nx,ny,nz,...,1) to read 1 tstep
	data3 &lt;- ncvar_get( nc, v3, start=start, count=count )

	# Now read in the value of the timelike dimension
	timeval &lt;- ncvar_get( nc, v3$dim[[ndims]]$name, start=i, count=1 )

	print(paste("Data for variable",v3$name,"at timestep",i,
		" (time value=",timeval,v3$dim[[ndims]]$units,"):"))
	print(data3)
	}

nc_close(nc)

## End(Not run)
</code></pre>

<hr>
<h2 id='ncvar_put'>Write data to a netCDF file</h2><span id='topic+ncvar_put'></span>

<h3>Description</h3>

<p>Writes data to an existing netCDF file.  The variable to be written to
must already exist on disk (i.e., you must call either
<code><a href="#topic+nc_create">nc_create</a></code> or <code><a href="#topic+nc_open">nc_open</a></code>
before calling this function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ncvar_put( nc, varid, vals, start=NA, count=NA, verbose=FALSE, na_replace="fast" ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncvar_put_+3A_nc">nc</code></td>
<td>
<p>An object of class <code>ncdf4</code> (as returned by either function
<code><a href="#topic+nc_open">nc_open</a></code>
or <code><a href="#topic+nc_create">nc_create</a></code>), indicating what file to write to.</p>
</td></tr>
<tr><td><code id="ncvar_put_+3A_varid">varid</code></td>
<td>
<p>What variable to write the data to.  Can be a string with the name
of the variable or an object of class <code>ncvar4</code>, as
returned by <code><a href="#topic+ncvar_def">ncvar_def</a></code> or  <code><a href="#topic+nc_open">nc_open</a></code>.</p>
</td></tr>
<tr><td><code id="ncvar_put_+3A_vals">vals</code></td>
<td>
<p>The values to be written.</p>
</td></tr>
<tr><td><code id="ncvar_put_+3A_start">start</code></td>
<td>
<p>A vector of indices indicating where to start writing the passed values
(starting at 1).  
The length of this vector must equal the number of dimensions the variable has.
Order is X-Y-Z-T (i.e., the time dimension is last).  If not specified, writing 
starts at the beginning of the file (1,1,1,...).</p>
</td></tr>
<tr><td><code id="ncvar_put_+3A_count">count</code></td>
<td>
<p>A vector of integers indicating the count of values to write
along each dimension (order is X-Y-Z-T).  
The length of this vector must equal the number of dimensions the variable has.
If not specified and the variable does
NOT have an unlimited dimension, the entire variable is written.  If the variable
has an unlimited dimension, this argument must be specified.  As a special case, the value
&quot;-1&quot; indicates that all entries along that dimension should be written.</p>
</td></tr>
<tr><td><code id="ncvar_put_+3A_verbose">verbose</code></td>
<td>
<p>If true, prints information while executing.</p>
</td></tr>
<tr><td><code id="ncvar_put_+3A_na_replace">na_replace</code></td>
<td>
<p>This is either the string &quot;fast&quot; or the string &quot;safe&quot;. When
the 'vals' array is written out, NA's have to be replaced by the missing
value specified when the variable was created. If na_replace is &quot;fast&quot;, then
this is done in-place without copying the 'vals' data array. This results
in the passed 'vals' array being modified such that NA's are replaced with 
the missing value. This is fast but not standard in R and may be unexpected.
If na_replace is &quot;safe&quot; then the vals array is copied before the NA replacement,
so that the vals array is not modified. This is more expected and standard R,
but can be slow and might cause memory issues if a very large 'vals' array 
is passed in. Default value is &quot;fast&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine writes data values to a variable in a netCDF file.  The file
should have either been created with <code><a href="#topic+nc_create">nc_create</a></code>, or 
opened with <code><a href="#topic+nc_open">nc_open</a></code> called with parameter <code>write=TRUE</code>.
</p>
<p>Note that the data type (i.e., precision) of the values written to the file is determined when the
variable is created; in particular, it does not matter what type you pass
to this function to be written.  In other words, if the variable was created
with type 'integer', passing double precision values to this routine will 
still result in integer values being written to disk.
</p>
<p>Values of &quot;NA&quot; are supported; they are converted to the netCDF variable's
missing value attribute before being written.  See <code><a href="#topic+ncvar_change_missval">ncvar_change_missval</a></code>
for more information.
</p>
<p>Data in a netCDF file is conceived as being a multi-dimensional array.
The number and length of dimensions is determined when the variable is
created.  The 'start' and 'count' indices that this routine takes indicate
where the writing starts along each dimension, and the count of values
along each dimension to write.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+ncdim_def">ncdim_def</a></code>, 
<code><a href="#topic+nc_create">nc_create</a></code>, 
<code><a href="#topic+nc_open">nc_open</a></code>, 
<code><a href="#topic+ncvar_get">ncvar_get</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#--------------------------------
# Make a few dimensions we can use
#--------------------------------
nx &lt;- 3
ny &lt;- 4
nt &lt;- 5
xvals &lt;- (1:nx)*100.
dimX &lt;- ncdim_def( "X", "meters", xvals )
dimY &lt;- ncdim_def( "Y", "meters", (1:ny)*100. )
dimT &lt;- ncdim_def( "Time", "seconds", (1:nt)/100., unlim=TRUE )

#-------------------------------------------------------------------
# Make varables of various dimensionality, for illustration purposes
#-------------------------------------------------------------------
mv &lt;- 1.e30		# missing value to use
var1d &lt;- ncvar_def( "var1d", "units", dimX, mv )
var2d &lt;- ncvar_def( "var2d", "units", list(dimX,dimY), mv )
var3d &lt;- ncvar_def( "var3d", "units", list(dimX,dimY,dimT), mv )

#---------------------
# Create the test file
#---------------------
nc &lt;- nc_create( "writevals.nc", list(var1d,var2d,var3d) )

#----------------------------
# Write some data to the file
#----------------------------
data1d &lt;- runif(nx)
ncvar_put( nc, var1d, data1d )	# no start or count: write all values
ncvar_put( nc, var1d, 27.5, start=3, count=1 ) # Write a value to the third slot

data2d &lt;- runif(nx*ny)
ncvar_put( nc, var2d, data2d )	# no start or count: write all values

#--------------------------------
# Write a 1-d slice to the 2d var
#--------------------------------
ncvar_put( nc, var2d, data1d, start=c(1,2), count=c(nx,1) )	

#--------------------------------------------------------------
# Note how "-1" in the count means "the whole dimension length", 
# which equals nx in this case
#--------------------------------------------------------------
ncvar_put( nc, var2d, data1d, start=c(1,3), count=c(-1,1) )	

#-------------------------------------------------------------------------------
# The 3-d variable has an unlimited dimension.  We will loop over the timesteps,
# writing one 2-d slice per timestep.
#-------------------------------------------------------------------------------
for( i in 1:nt) 
	ncvar_put( nc, var3d, data2d, start=c(1,1,i), count=c(-1,-1,1) )

nc_close(nc)

#----------------------------------------------------------------------
# Illustrate creating a character type variable
#----------------------------------------------------------------------
cnames   &lt;- c("red", "orange", "green", "yellow", "puce", "colorwithverylongname" )
nstrings &lt;- length(cnames)

#--------------------------------------------------------------
# Make dimensions. Setting "dimnchar" to have a length of 12
# means that the maximum color name
# length can be 12.  Longer names will be truncated to this.
# We don't need dimvars for this example.
#--------------------------------------------------------------
dimnchar   &lt;- ncdim_def("nchar",   "", 1:12, create_dimvar=FALSE )
dimcolorno &lt;- ncdim_def("colorno", "", 1:nstrings, create_dimvar=FALSE )

#------------------------------------------------------------------------
# NOTE in the following call that units is set to the empty string (""),
# which suppresses creation of a units attribute, and the missing value
# is entirely omitted, which suppresses creation of the missing value att
#------------------------------------------------------------------------
varcolors  &lt;- ncvar_def("colors", "", list(dimnchar, dimcolorno), " ",
			prec="char" )

ncid &lt;- nc_create( "colornames.nc", list(varcolors) )

ncvar_put( ncid, "colors", cnames, verbose=TRUE )

nc_close( ncid )

#---------
# Clean up
#---------
file.remove( "colornames.nc" )
file.remove( "writevals.nc" )

## End(Not run)
</code></pre>

<hr>
<h2 id='ncvar_rename'>Rename an Existing Variable in a netCDF File</h2><span id='topic+ncvar_rename'></span>

<h3>Description</h3>

<p>Renames an existing variable that currently is part of a netCDF file
that is on disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ncvar_rename( nc, old_varname, new_varname, verbose=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncvar_rename_+3A_nc">nc</code></td>
<td>
<p>The already-existing netCDF file that we want to manipulate. This must
be a value of class &quot;ncdf4&quot; returned by a call to <code><a href="#topic+nc_open">nc_open</a></code><code>(...,write=TRUE).</code></p>
</td></tr>
<tr><td><code id="ncvar_rename_+3A_old_varname">old_varname</code></td>
<td>
<p>The variable in the file that is to be renamed.
This can be a string with the name of the variable to be renamed,
or a value of class &quot;ncvar4&quot; returned by a call to <code>ncvar_def()</code>.</p>
</td></tr>
<tr><td><code id="ncvar_rename_+3A_new_varname">new_varname</code></td>
<td>
<p>A string containing the new name of the variable.</p>
</td></tr>
<tr><td><code id="ncvar_rename_+3A_verbose">verbose</code></td>
<td>
<p>If true, run verbosely.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This call allows you to rename a variable that already exists in a netCDF 
file.
</p>
<p>NOTE that the return value of this routine should replace the old netCDF
file handle that you were using.  This newly returned value reflects the
modifications to the file that were accomplished by calling this routine.
</p>


<h3>Value</h3>

<p>The updated value of nc that contains the new name.
This needs to replace the old value of nc in the code.
I..e, <code>ncid &lt;- ncvar_rename( ncid, ... )</code>.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+ncdim_def">ncdim_def</a></code>, <code><a href="#topic+nc_create">nc_create</a></code>, 
<code><a href="#topic+ncvar_def">ncvar_def</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#===================================================================
# PART 1.  MAKE A TEST NETCDF FILE THAT WE WILL MANIPULATE IN PART 2
#===================================================================

#----------------
# Make dimensions
#----------------
xvals &lt;- 1:360
yvals &lt;- -90:90

nx &lt;- length(xvals)
ny &lt;- length(yvals)

xdim &lt;- ncdim_def( 'Lon', 'degreesE', xvals )
ydim &lt;- ncdim_def( 'Lat', 'degreesE', yvals )
tdim &lt;- ncdim_def( 'Time', 'days since 1900-01-01', 0, unlim=TRUE )

#---------
# Make var
#---------
mv &lt;- 1.e30     # missing value
var_temp &lt;- ncvar_def( 'Temperature', 'K', list(xdim,ydim,tdim), mv )

#---------------------
# Make new output file
#---------------------
output_fname &lt;- 'test_real3d.nc'
ncid_new &lt;- nc_create( output_fname, list(var_temp))

#-------------------------------
# Put some test data in the file
#-------------------------------
data_temp &lt;- array(0.,dim=c(nx,ny,1))
for( j in 1:ny )
for( i in 1:nx )
        data_temp[i,j,1] &lt;- sin(i/10)*sin(j/10)

ncvar_put( ncid_new, var_temp, data_temp, start=c(1,1,1), count=c(nx,ny,1))

#--------------------------
# Close our new output file
#--------------------------
nc_close( ncid_new )

#===========================================================================
# PART 2.  RENAME A NEW VARIABLE TO THE FILE
#===========================================================================

#-------------------------------------------------
# Open the existing file we're going to manipulate
#-------------------------------------------------
ncid_old &lt;- nc_open( output_fname, write=TRUE )

old_varname &lt;- 'Temperature'
new_varname &lt;- 'T'

ncid_old &lt;- ncvar_rename( ncid_old, old_varname, new_varname )

print(ncid_old)

nc_close( ncid_old )

# Clean up our example
file.remove( output_fname )

## End(Not run)
</code></pre>

<hr>
<h2 id='print.ncdf4'>Print Information About a netCDF File</h2><span id='topic+print.ncdf4'></span>

<h3>Description</h3>

<p>Prints information about a netCDF file, including the variables and dimensions
it contains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ncdf4'
print( x, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ncdf4_+3A_x">x</code></td>
<td>
<p>An object of class &quot;ncdf4&quot;.</p>
</td></tr>
<tr><td><code id="print.ncdf4_+3A_...">...</code></td>
<td>
<p>Extra arguments are passed to the generic print function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NetCDF files contain variables, which themselves have dimensions.  
This routine prints out useful information about a netCDF file's
variables and dimensions.  It is overloaded on the regular print
function, so if &quot;nc&quot; is an object of class &quot;ncdf4&quot;, then just
calling <code>print(nc)</code> will suffice.  Objects of class
&quot;ncdf4&quot; are returned from <code><a href="#topic+nc_open">nc_open</a></code> and <code><a href="#topic+nc_create">nc_create</a></code>.
</p>


<h3>Author(s)</h3>

<p>David W. Pierce <a href="mailto:dpierce@ucsd.edu">dpierce@ucsd.edu</a></p>


<h3>References</h3>

<p>http://dwpierce.com/software
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+ncvar_def">ncvar_def</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a netCDF file, print information about it
nc &lt;- nc_open( "salinity.nc" )
print(nc)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
