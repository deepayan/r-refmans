<!DOCTYPE html><html><head><title>Help for package freqdom.fda</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {freqdom.fda}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#freqdom.fda-package'><p>Functional time series: dynamic FPCA</p></a></li>
<li><a href='#fts.cov.structure'><p>Estimate autocovariance and cross-covariances operators</p></a></li>
<li><a href='#fts.dpca'><p>Compute Functional Dynamic Principal Components and dynamic Karhunen Loeve extepansion</p></a></li>
<li><a href='#fts.dpca.filters'><p>Functional dynamic PCA filters</p></a></li>
<li><a href='#fts.dpca.KLexpansion'><p>Dynamic KL expansion</p></a></li>
<li><a href='#fts.dpca.scores'><p>Functional dynamic principal component scores</p></a></li>
<li><a href='#fts.dpca.var'><p>Proportion of variance explained by dynamic principal components</p></a></li>
<li><a href='#fts.freqdom'><p>Creates an object of class  <code>fts.freqdom</code>.</p></a></li>
<li><a href='#fts.plot.covariance'><p>Contour plot for the kernels of cross-covariance operators.</p></a></li>
<li><a href='#fts.plot.filters'><p>Plot kernels</p></a></li>
<li><a href='#fts.plot.operators'><p>Contour plot of operator kernels.</p></a></li>
<li><a href='#fts.rar'><p>Simulate functional autoregressive processes</p></a></li>
<li><a href='#fts.rma'><p>Simulate functional moving average processes</p></a></li>
<li><a href='#fts.spectral.density'><p>Functional spectral and cross-spectral density operator</p></a></li>
<li><a href='#fts.timedom'><p>Object of class <code>fts.timedom</code></p></a></li>
<li><a href='#fts.timedom.trunc'><p>Truncate functional timedom object</p></a></li>
<li><a href='#is.fts.freqdom'><p>Checks if an object belongs to the class fts.freqdom</p></a></li>
<li><a href='#is.fts.timedom'><p>Checks if an object belongs to the class fts.timedom</p></a></li>
<li><a href='#pm10'><p>PM10 dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functional Time Series: Dynamic Functional Principal Components</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Hormann S., Kidzinski L.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kidzinski L. &lt;lukasz.kidzinski@stanford.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of functional dynamic principle components analysis. Related graphic tools and frequency domain methods.
  These methods directly use multivariate dynamic principal components implementation,
  following the guidelines from Hormann, Kidzinski and Hallin (2016), Dynamic Functional Principal Component &lt;<a href="https://doi.org/10.1111%2Frssb.12076">doi:10.1111/rssb.12076</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0), mvtnorm, stats, graphics, base, fda, freqdom</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, MARSS</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-18 16:26:56 UTC; kidzik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-19 00:04:34 UTC</td>
</tr>
</table>
<hr>
<h2 id='freqdom.fda-package'>Functional time series: dynamic FPCA</h2><span id='topic+freqdom.fda-package'></span><span id='topic+_PACKAGE'></span><span id='topic+fda.ts'></span>

<h3>Description</h3>

<p>Implementation of dynamic functional principle component analysis (FDPCA),
simulation of functional AR and functional MA processes and frequency domain tools for funcional data.
The package is a wrapper for functionality of the multivariate package <span class="pkg">freqdom</span>
for applying frequency domain on objects from <span class="pkg">fda</span>.
Compared to <span class="pkg">freqdom</span> some new visualization methods are added &ndash;
adequate only if data has functional structure.
</p>


<h3>Details</h3>

<p><span class="pkg">fda.ts</span> package allows you to analyse functional time series objects
in both time and frequency domain. The main feature is dynamic functional principal component analysis.
This method allows to transform a stationary functional time series into a vector process with
mutually uncorrelated component processes.
</p>
<p>There are two key differnces between classical PCA and dynamic PCA:
</p>

<ul>
<li><p> Component processes returned by the dynamic procedure are mutually uncorrelated,
</p>
</li>
<li><p> The mapping maximizes the long run variance of compoments, which, in case of stationary functional time series, means
that the process reconstructed from and <code class="reqn">d &gt; 0</code> first dynamic principal components
better approximates the original functional time series process than the first <code class="reqn">d</code> classic principal components.
</p>
</li></ul>

<p>For functional data one can conveniently visualize properties of the
filters, covariances or the spectral density operator.
</p>
<p>For details we refer to the literature below and to help pages of functions <code><a href="#topic+fts.dpca">fts.dpca</a></code>
for estimating the components, <code><a href="#topic+fts.dpca.scores">fts.dpca.scores</a></code> for estimating scores and
<code><a href="#topic+fts.dpca.KLexpansion">fts.dpca.KLexpansion</a></code> for retrieving the signal from components.
</p>
<p>The package <span class="pkg">fda.ts</span> require the package <span class="pkg">freqdom</span> provides the analogue multivariate toolset.
</p>


<h3>References</h3>

<p>Hormann Siegfried, Kidzinski Lukasz and Hallin Marc.
<em>Dynamic functional principal components.</em> Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 77.2 (2015): 319-348.
</p>
<p>Hormann Siegfried, Kidzinski Lukasz and Kokoszka Piotr.
<em>Estimation in functional lagged regression.</em>
Journal of Time Series Analysis 36.4 (2015): 541-561.
</p>
<p>Hormann Siegfried and Kidzinski Lukasz.
<em>A note on estimation in Hilbertian linear models.</em>
Scandinavian journal of statistics 42.1 (2015): 43-62.
</p>

<hr>
<h2 id='fts.cov.structure'>Estimate autocovariance and cross-covariances operators</h2><span id='topic+fts.cov.structure'></span>

<h3>Description</h3>

<p>This function is used to estimate a collection of cross-covariances operators of two stationary functional series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.cov.structure(X, Y = X, lags = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.cov.structure_+3A_x">X</code></td>
<td>
<p>an object of class <code><a href="fda.html#topic+fd">fd</a></code> containing <code class="reqn">T</code> functional observations.</p>
</td></tr>
<tr><td><code id="fts.cov.structure_+3A_y">Y</code></td>
<td>
<p>an object of class <code><a href="fda.html#topic+fd">fd</a></code> containing <code class="reqn">T</code> functional observations.</p>
</td></tr>
<tr><td><code id="fts.cov.structure_+3A_lags">lags</code></td>
<td>
<p>an integer-valued vector <code class="reqn">(\ell_1,\ldots, \ell_K)</code> containing the lags for which covariances are calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X_1(u),\ldots, X_T(u)</code> and <code class="reqn">Y_1(u),\ldots, Y_T(u)</code> be two samples of functional data. This function determines empirical lagged covariances between the series <code class="reqn">(X_t(u))</code> and <code class="reqn">(Y_t(u))</code>. More precisely it determines
</p>
<p style="text-align: center;"><code class="reqn">
  (\widehat{c}^{XY}_h(u,v)\colon h\in lags ),
</code>
</p>

<p>where <code class="reqn">\widehat{c}^{XY}_h(u,v)</code> is the empirical version of the covariance kernel <code class="reqn">\mathrm{Cov}(X_h(u),Y_0(v))</code>.
For a sample of size <code class="reqn">T</code> we set <code class="reqn">\hat\mu^X(u)=\frac{1}{T}\sum_{t=1}^T X_t(u)</code> and
<code class="reqn">\hat\mu^Y(v)=\frac{1}{T}\sum_{t=1}^T Y_t(v)</code>. Now for <code class="reqn">h \geq 0</code>
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{T}\sum_{t=1}^{T-h} (X_{t+h}(u)-\hat\mu^X(u))(Y_t(v)-\hat\mu^Y(v))</code>
</p>

<p>and for <code class="reqn">h &lt; 0</code>
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{T}\sum_{t=|h|+1}^{T} (X_{t+h}(u)-\hat\mu^X(u))(Y_t(v)-\hat\mu^Y(v)).</code>
</p>

<p>Since <code class="reqn">X_t(u)=\boldsymbol{b}_1^\prime(u)\mathbf{x}_t</code> and <code class="reqn">Y_t(u)=\mathbf{y}_t^\prime \boldsymbol{b}_2(u)</code> we can write
</p>
<p style="text-align: center;"><code class="reqn">
  \widehat{c}^{XY}_h(u,v)=\boldsymbol{b}_1^\prime(u)\widehat{C}^{\mathbf{xy}}\boldsymbol{b}_2(v),
</code>
</p>

<p>where <code class="reqn">\widehat{C}^{\mathbf{xy}}</code> is defined as for the function &ldquo;cov.structure&rdquo; for series of coefficient vectors
<code class="reqn">(\mathbf{x}_t\colon 1\leq t\leq T)</code> and <code class="reqn">(\mathbf{y}_t\colon 1\leq t\leq T)</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+fts.timedom">fts.timedom</a></code>. The list contains the following components:
</p>

<ul>
<li> <p><code>operators</code> <code class="reqn">\quad</code> an array. Element <code>[,,k]</code> contains the covariance matrix of the coefficient vectors of the two time series related to lag <code class="reqn">\ell_k</code>.
</p>
</li>
<li> <p><code>lags</code> <code class="reqn">\quad</code> the lags vector from the arguments.
</p>
</li>
<li> <p><code>basisX</code> <code class="reqn">\quad</code> <code>X$basis</code>, an object of class <code>basis.fd</code> (see <code><a href="fda.html#topic+create.basis">create.basis</a></code>)
</p>
</li>
<li> <p><code>basisY</code> <code class="reqn">\quad</code> <code>Y$basis</code>, an object of class <code>basis.fd</code> (see <code><a href="fda.html#topic+create.basis">create.basis</a></code>)
</p>
</li></ul>



<h3>See Also</h3>

<p>The multivariate equivalent in the <code>freqdom</code> package: <code><a href="freqdom.html#topic+cov.structure">cov.structure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate an autoregressive process
fts = fts.rar(d=3)

# Get covariance at lag 0
fts.cov.structure(fts, lags = 0)

# Get covariance at lag 10
fts.cov.structure(fts, lags = 10)

# Get entire covariance structure between -20 and 20
fts.cov.structure(fts, lags = -20:20)

# Compute covariance with another process
fts0 = fts + fts.rma(d=3)
fts.cov.structure(fts, fts0, lags = -2:2)
</code></pre>

<hr>
<h2 id='fts.dpca'>Compute Functional Dynamic Principal Components and dynamic Karhunen Loeve extepansion</h2><span id='topic+fts.dpca'></span>

<h3>Description</h3>

<p>Functional dynamic principal component analysis (FDPCA) decomposes functional time series to a vector time series with
uncorrelated components. Compared to classical functional principal components, FDPCA decomposition outputs components which
are uncorrelated in time, allowing simpler modeling of the processes and maximizing long run variance of the projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.dpca(X, q = 30, freq = (-1000:1000/1000) * pi, Ndpc = X$basis$nbasis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.dpca_+3A_x">X</code></td>
<td>
<p>a functional time series as a <code>fd</code> object from <code>fda</code> package.</p>
</td></tr>
<tr><td><code id="fts.dpca_+3A_q">q</code></td>
<td>
<p>window size for the kernel estimator, i.e. a positive integer.</p>
</td></tr>
<tr><td><code id="fts.dpca_+3A_freq">freq</code></td>
<td>
<p>a vector containing frequencies in <code class="reqn">[-\pi, \pi]</code> on which the spectral density should be evaluated.</p>
</td></tr>
<tr><td><code id="fts.dpca_+3A_ndpc">Ndpc</code></td>
<td>
<p>is the number of principal component filters to compute as in <code><a href="#topic+fts.dpca.filters">fts.dpca.filters</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This convenient function applies the FDPCA methodology and returns filters (<code><a href="#topic+fts.dpca.filters">fts.dpca.filters</a></code>), scores
(<code><a href="#topic+fts.dpca.scores">fts.dpca.scores</a></code>), the spectral density (<code><a href="#topic+fts.spectral.density">fts.spectral.density</a></code>), variances (<code><a href="#topic+fts.dpca.var">fts.dpca.var</a></code>) and
Karhunen-Leove expansion (<code><a href="#topic+fts.dpca.KLexpansion">fts.dpca.KLexpansion</a></code>).
</p>
<p>See the example for understanding usage, and help pages for details on individual functions.
</p>


<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li> <p><code>scores</code> <code class="reqn">\quad</code> DPCA scores (<code><a href="#topic+fts.dpca.scores">fts.dpca.scores</a></code>)
</p>
</li>
<li> <p><code>filters</code> <code class="reqn">\quad</code>  DPCA filters (<code><a href="#topic+fts.dpca.filters">fts.dpca.filters</a></code>)
</p>
</li>
<li> <p><code>spec.density</code> <code class="reqn">\quad</code>  spectral density of <code>X</code> (<code><a href="#topic+fts.spectral.density">fts.spectral.density</a></code>)
</p>
</li>
<li> <p><code>var</code> <code class="reqn">\quad</code> amount of variance explained by dynamic principal components (<code><a href="#topic+fts.dpca.var">fts.dpca.var</a></code>)
</p>
</li>
<li> <p><code>Xhat</code> <code class="reqn">\quad</code>  Karhunen-Loeve expansion using <code>Ndpc</code> dynamic principal components (<code><a href="#topic+fts.dpca.KLexpansion">fts.dpca.KLexpansion</a></code>)
</p>
</li></ul>



<h3>References</h3>

<p>Hormann, S., Kidzinski, L., and Hallin, M.
<em>Dynamic functional principal components.</em> Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 77.2 (2015): 319-348.
</p>
<p>Brillinger, D.
<em>Time Series</em> (2001), SIAM, San Francisco.
</p>
<p>Shumway, R., and Stoffer, D.
<em>Time series analysis and its applications: with R examples</em> (2010), Springer Science &amp; Business Media
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example PM10 data from Graz, Austria
data(pm10) # loads functional time series pm10 to the environment
X = center.fd(pm10)

# Compute functional dynamic principal components with only one component
res.dpca = fts.dpca(X, Ndpc = 1, freq=(-25:25/25)*pi) # leave default freq for higher precision
plot(res.dpca$Xhat)
fts.plot.filters(res.dpca$filters)

# Compute functional PCA with only one component
res.pca = prcomp(t(X$coefs), center = TRUE)
res.pca$x[,-1] = 0

# Compute empirical variance explained
var.dpca = (1 - sum( (res.dpca$Xhat$coefs - X$coefs)**2 ) / sum(X$coefs**2))*100
var.pca = (1 - sum( (res.pca$x %*% t(res.pca$rotation) - t(X$coefs) )**2 ) / sum(X$coefs**2))*100

cat("Variance explained by PCA (empirical):\t\t",var.pca,"%\n")
cat("Variance explained by PCA (theoretical):\t",
   (1 - (res.pca$sdev[1] / sum(res.pca$sdev)))*100,"%\n")
cat("Variance explained by DPCA (empirical):\t\t",var.dpca,"%\n")
cat("Variance explained by DPCA (theoretical):\t",(res.dpca$var[1])*100,"%\n")

# Plot filters
fts.plot.filters(res.dpca$filters)

# Plot spectral density (note that in case of these data it's concentrated around 0)
fts.plot.operators(res.dpca$spec.density,freq = c(-2,-3:3/30 * pi,2))

# Plot covariance of X
fts.plot.covariance(X)

# Compare values of the first PC scores with the first DPC scores 
plot(res.pca$x[,1],t='l',xlab = "Time",ylab="Score", lwd = 2.5)
lines(res.dpca$scores[,1], col=2, lwd = 2.5)
legend(0,4,c("first PC score","first DPC score"), # puts text in the legend
       lty=c(1,1),lwd=c(2.5,2.5), col=1:2)
</code></pre>

<hr>
<h2 id='fts.dpca.filters'>Functional dynamic PCA filters</h2><span id='topic+fts.dpca.filters'></span>

<h3>Description</h3>

<p>From a given spectral density operator the dynamic principal component filter sequences are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.dpca.filters(F, Ndpc = F$basisX$nbasis, q = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.dpca.filters_+3A_f">F</code></td>
<td>
<p>spectral density operator, provided as an object of class <code>fts.freqdom</code>.</p>
</td></tr>
<tr><td><code id="fts.dpca.filters_+3A_ndpc">Ndpc</code></td>
<td>
<p>an integer <code class="reqn">\in\{1,\ldots, d\}</code> with <code class="reqn">d=</code><code>F$basisX$nbasis</code>. It is the number of dynamic principal components to be computed. By default it is set equal to <code class="reqn">d</code>.</p>
</td></tr>
<tr><td><code id="fts.dpca.filters_+3A_q">q</code></td>
<td>
<p>a non-negative integer. DPCA filter coefficients at lags <code class="reqn">|h|\leq</code> q will be computed. By default <code>q=30</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dynamic principal components are linear filters <code class="reqn">(\phi_{\ell k}(u)\colon k\in \mathbf{Z})</code>, <code class="reqn">1\leq\ell\leq d</code>.
They are defined as the Fourier coefficients of the dynamic eigenvector <code class="reqn">\varphi_\ell(\omega)(u)</code> of a spectral density
kernel <code class="reqn">f_\omega(u,v)</code>, i.e. <code class="reqn">\int_0^1 f_\omega(u,v)\varphi_\ell(\omega)(v)dv=\lambda_\ell(\omega)\varphi_\ell(\omega)(u)</code>
and
</p>
<p style="text-align: center;"><code class="reqn">
  \phi_{\ell k}(u):=\frac{1}{2\pi}\int_{-\pi}^\pi \varphi_\ell(\omega)(u) \exp(-ik\omega) d\omega.
</code>
</p>

<p>The index <code class="reqn">\ell</code> is referring to the <code class="reqn">\ell</code>-th largest dynamic eigenvalue <code class="reqn">\lambda_\ell(\omega)</code>. For a given spectral
density operator (provided as on object of class <code>fts.freqdom</code>) the function <code>fts.dpca.filters</code> computes
<code class="reqn">\phi_{\ell k}(u)</code> for <code class="reqn">|k|\leq</code> q. Filters will be computed for <code class="reqn">1\leq \ell\leq \code{Ndpc}</code>.
</p>
<p>For more details we refer to  Hormann et al. (2015).
</p>


<h3>Value</h3>

<p>An object of class <code>fts.timedom</code>.  The list has the following components:
</p>

<ul>
<li> <p><code>operators</code> <code class="reqn">\quad</code> an array. Each matrix in this array has dimension <code class="reqn">\code{Ndpc}\times d</code> and is assigned to a certain lag.
For a given lag <code class="reqn">k</code>, the rows of the matrix correspond to the coefficient vector of the filter functions.
</p>
</li>
<li> <p><code>lags</code> <code class="reqn">\quad</code> a vector with the lags of the filter coefficients.
</p>
</li>
<li> <p><code>basisX</code> <code class="reqn">\quad</code> <code>F$basis</code>, hence an object of class <code>basis.fd</code> (see <code><a href="fda.html#topic+create.basis">create.basis</a></code>).
</p>
</li>
<li> <p><code>correspondence</code> <code class="reqn">\quad</code> the correspondence matrix: all scalar products between basis functions.
</p>
</li></ul>



<h3>References</h3>

<p>Hormann, S., Kidzinski, L., and Hallin, M.
<em>Dynamic functional principal components.</em> Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 77.2 (2015): 319-348.
</p>
<p>Brillinger, D.
<em>Time Series</em> (2001), SIAM, San Francisco.
</p>
<p>Shumway, R.H., and Stoffer, D.S.
<em>Time Series Analysis and Its Applications</em> (2006), Springer, New York.
</p>


<h3>See Also</h3>

<p>The multivariate equivalent in the <code>freqdom</code> package: <code><a href="freqdom.html#topic+dpca.filters">dpca.filters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pm10)
X = center.fd(pm10)

# Compute the spectral density operator with Bartlett weights
SD = fts.spectral.density(X, freq = (-50:50/50) * pi, q = 2, weight="Bartlett")
filters = fts.dpca.filters(SD, 2, q = 10)

# Plot filters 1 and 2
fts.plot.filters(filters, 2, one.plot = TRUE)

# Recompute with a different estimate of the spectral density (largerg q)
SD = fts.spectral.density(X, freq = (-50:50/50) * pi, q = 5, weight="Bartlett")
filters = fts.dpca.filters(SD, 2, q = 10)

# Plot filters 1 and 2
fts.plot.filters(filters, 2, one.plot = TRUE)
</code></pre>

<hr>
<h2 id='fts.dpca.KLexpansion'>Dynamic KL expansion</h2><span id='topic+fts.dpca.KLexpansion'></span>

<h3>Description</h3>

<p>Computes the dynamic KL expansion up to a given order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.dpca.KLexpansion(X, dpcs = fts.dpca.filters(fts.spectral.density(X)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.dpca.KLexpansion_+3A_x">X</code></td>
<td>
<p>a functional time series given as an object of class <code><a href="fda.html#topic+fd">fd</a></code>.</p>
</td></tr>
<tr><td><code id="fts.dpca.KLexpansion_+3A_dpcs">dpcs</code></td>
<td>
<p>an object of class <code>fts.timedom</code>, representing the dpca filters
obtained from the sample <code>X</code>. If <code>dpsc = NULL</code>, then <code>dpcs = fts.dpca.filter(fts.spectral.density(X))</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the <code class="reqn">L</code>-order dynamic functional principal components expansion, defined by
</p>
<p style="text-align: center;"><code class="reqn">
  \hat{X}_{t}^L(u):=\sum_{\ell=1}^L\sum_{k\in\mathbf{Z}}  Y_{\ell,t+k} \phi_{\ell k}(u),\quad 1\leq L\leq d,
</code>
</p>

<p>where <code class="reqn">\phi_{\ell k}(v)</code> and <code class="reqn">d</code> are explained in  <code>fts.dpca.filters</code> and <code class="reqn">Y_{\ell k}</code> are the dynamic functional PC scores as in <code>fts.dpca.scores</code>. For the sample version the sum extends over the range of lags for which the <code class="reqn">\phi_{\ell k}</code> are defined.
</p>
<p>For more details we refer to Hormann et al. (2015).
</p>


<h3>Value</h3>

<p>An object of class <code><a href="fda.html#topic+fd">fd</a></code>.
</p>


<h3>References</h3>

<p>Hormann, S., Kidzinski, L., and Hallin, M.
<em>Dynamic functional principal components.</em> Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 77.2 (2015): 319-348.
</p>


<h3>See Also</h3>

<p>The multivariate equivalent in the <code>freqdom</code> package: <code><a href="freqdom.html#topic+dpca.KLexpansion">dpca.KLexpansion</a></code>
</p>

<hr>
<h2 id='fts.dpca.scores'>Functional dynamic principal component scores</h2><span id='topic+fts.dpca.scores'></span>

<h3>Description</h3>

<p>Computes the dynamic principal component scores of a functional time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.dpca.scores(X, dpcs = fts.dpca.filters(spectral.density(X)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.dpca.scores_+3A_x">X</code></td>
<td>
<p>a functional time series given as an object of class <code><a href="fda.html#topic+fd">fd</a></code>.</p>
</td></tr>
<tr><td><code id="fts.dpca.scores_+3A_dpcs">dpcs</code></td>
<td>
<p>an object of class <code>fts.timedom</code>, representing the dpca filters
obtained from the sample <code>X</code>. If <code>dpsc = NULL</code>, then
<code>dpcs = fts.dpca.filter(fts.spectral.density(X))</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">\ell</code>-th dynamic principal components score sequence is defined by
</p>
<p style="text-align: center;"><code class="reqn">
  Y_{\ell t}:=\sum_{k\in\mathbf{Z}} \int_0^1 \phi_{\ell k}(v) X_{t-k}(v)dv,\quad 1\leq \ell\leq d,
</code>
</p>

<p>where <code class="reqn">\phi_{\ell k}(v)</code> and <code class="reqn">d</code> are explained in <code><a href="#topic+fts.dpca.filters">fts.dpca.filters</a></code>. (The integral is not necessarily restricted to the interval <code class="reqn">[0,1]</code>, this depends on the data.) For the sample version the sum extends over the range of lags for which the <code class="reqn">\phi_{\ell k}</code> are defined.
</p>
<p>For more details we refer to  Hormann et al. (2015).
</p>


<h3>Value</h3>

<p>A <code class="reqn">(T\times \code{Ndpc})</code>-matix with <code>Ndpc = dim(dpcs$operators)[1]</code>. The <code class="reqn">\ell</code>-th column contains the <code class="reqn">\ell</code>-th dynamic principal component score sequence.
</p>


<h3>References</h3>

<p>Hormann, S., Kidzinski, L., and Hallin, M.
<em>Dynamic functional principal components.</em> Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 77.2 (2015): 319-348.
</p>


<h3>See Also</h3>

<p>The multivariate equivalent in the <code>freqdom</code> package: <code><a href="freqdom.html#topic+dpca.scores">dpca.scores</a></code>
</p>

<hr>
<h2 id='fts.dpca.var'>Proportion of variance explained by dynamic principal components</h2><span id='topic+fts.dpca.var'></span>

<h3>Description</h3>

<p>Computes the proportion and cumulative proportion of variance explained by dynamic principal components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.dpca.var(F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.dpca.var_+3A_f">F</code></td>
<td>
<p>spectral density operator, provided as an object of class <code><a href="#topic+fts.freqdom">fts.freqdom</a></code>. To guarantee accuracy of
numerical integration it is important that <code>F$freq</code> is a dense grid of frequencies in <code class="reqn">[-\pi,\pi]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a spectral density operator <code class="reqn">\mathcal{F}_\omega</code> and let <code class="reqn">\lambda_\ell(\omega)</code> by the <code class="reqn">\ell</code>-th dynamic
eigenvalue. The proportion of variance described by the <code class="reqn">\ell</code>-th dynamic principal component is given as
<code class="reqn">v_\ell:=\int_{-\pi}^\pi \lambda_\ell(\omega)d\omega/\int_{-\pi}^\pi \mathrm{tr}(\mathcal{F}_\omega)d\omega</code>.
This function numerically computes the vectors <code class="reqn">(v_\ell)</code>.
</p>
<p>For more details we refer to Hormann et al. (2015).
</p>


<h3>Value</h3>

<p>A vector containing the <code class="reqn">v_\ell</code>.
</p>


<h3>References</h3>

<p>Hormann, S., Kidzinski, L., and Hallin, M.
<em>Dynamic functional principal components.</em> Journal of the Royal
Statistical Society: Series B (Statistical Methodology) 77.2 (2015): 319-348.
</p>


<h3>See Also</h3>

<p>The multivariate equivalent in the <code>freqdom</code> package: <code><a href="freqdom.html#topic+dpca.var">dpca.var</a></code>
</p>

<hr>
<h2 id='fts.freqdom'>Creates an object of class  <code>fts.freqdom</code>.</h2><span id='topic+fts.freqdom'></span>

<h3>Description</h3>

<p>Creates an object of class  <code>fts.freqdom</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.freqdom(F, basisX, basisY = basisX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.freqdom_+3A_f">F</code></td>
<td>
<p>an object of class freqdom.</p>
</td></tr>
<tr><td><code id="fts.freqdom_+3A_basisx">basisX</code></td>
<td>
<p>an object of class <code>basis.fd</code> (see <code><a href="fda.html#topic+create.basis">create.basis</a></code>)</p>
</td></tr>
<tr><td><code id="fts.freqdom_+3A_basisy">basisY</code></td>
<td>
<p>an object of class <code>basis.fd</code> (see <code><a href="fda.html#topic+create.basis">create.basis</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This class is used to describe a frequency domain operator (for example a spectral
density operator) on selected frequencies. Formally we consider an object of class
<code>freqdom</code> and add some basis functions. Depending on the context, we
have different interpretations for the new object.
</p>
<p>(I) In order to define an operator which maps between two functions spaces, the we
interpret <code>F$operators</code> as coefficients in the basis function expansion of
the kernel of some finite rank operators </p>
<p style="text-align: center;"><code class="reqn">\mathcal{F}_k:\mathrm{span}(\code{basisY})+\mathrm{i}\, \mathrm{span}(\code{basisY})\to\mathrm{span}(\code{basisX})+\mathrm{i}\, \mathrm{span}(\code{basisX}).</code>
</p>
<p> The kernels are <code class="reqn">f_k(u,v)=\boldsymbol{b}_1^\prime(u)\, F_k\, \boldsymbol{b}_2(v)</code>, where <code class="reqn">\boldsymbol{b_1}(u)=(b_{11}(u),\ldots, b_{1d_1}(u))^\prime</code> and <code class="reqn">\boldsymbol{b_2}(u)=(b_{21}(u),\ldots, b_{2d_1}(u))^\prime</code> are the basis functions provided by the arguments  basisX and basisY, respectively. Moreover, we consider frequencies <code class="reqn">\{\omega_1,\ldots, \omega_K\}\subset[-\pi,\pi]</code>. The object this function creates corresponds to the mapping <code class="reqn">\omega_k \mapsto f_k(u,v)</code>.
</p>
<p>(II) We may ignore basisX, and represent the linear mapping
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{F}_k:\mathrm{span}(\code{basisY})+\mathrm{i}\, \mathrm{span}(\code{basisY})\to C^{d_1},</code>
</p>

<p>by considering <code class="reqn">f_k(v):=F_k\,\boldsymbol{b}_2(v)</code> and <code class="reqn">\mathcal{F}_k(x)=\int f_k(v)x(v)dv</code>.
</p>
<p>(III) We may ignore basisY, and represent the linear mapping
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{F}_k: C^{d_1}\to\mathrm{span}(\code{basisX})+\mathrm{i}\, \mathrm{span}(\code{basisX}),</code>
</p>

<p>by considering <code class="reqn">f_k(u):=\boldsymbol{b}_1^\prime(u)F_k</code> and <code class="reqn">\mathcal{F}_k(y)=f_k(u)y</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class  <code>fts.freqdom</code>. An object of class
<code>fts.freqdom</code> is a list containing the following components:
</p>

<ul>
<li> <p><code>operators</code> <code class="reqn">\quad</code> returns the array <code>F$operators</code>.
</p>
</li>
<li> <p><code>basisX</code> <code class="reqn">\quad</code> returns <code>basisX</code> as given in the argument.
</p>
</li>
<li> <p><code>basisY</code> <code class="reqn">\quad</code> returns <code>basisY</code> as given in the argument.
</p>
</li>
<li> <p><code>freq</code> <code class="reqn">\quad</code> returns the vector <code>F$freq</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>The multivariate equivalent in the <code>freqdom</code> package: <code><a href="freqdom.html#topic+freqdom">freqdom</a></code>
</p>

<hr>
<h2 id='fts.plot.covariance'>Contour plot for the kernels of cross-covariance operators.</h2><span id='topic+fts.plot.covariance'></span>

<h3>Description</h3>

<p>Contour plot for the kernels of cross-covariance operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.plot.covariance(X, Y = X, cor = FALSE, res = 200, lags = 0:3, nlevels = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.plot.covariance_+3A_x">X</code></td>
<td>
<p>an object of class <code><a href="fda.html#topic+fd">fd</a></code> representing a functional data sample.</p>
</td></tr>
<tr><td><code id="fts.plot.covariance_+3A_y">Y</code></td>
<td>
<p>an object of class<code><a href="fda.html#topic+fd">fd</a></code> representing a functional data sample.</p>
</td></tr>
<tr><td><code id="fts.plot.covariance_+3A_cor">cor</code></td>
<td>
<p>if <code>FALSE</code> covariance kernels are plotted, if <code>TRUE</code> correlation kernel will be plotted.</p>
</td></tr>
<tr><td><code id="fts.plot.covariance_+3A_res">res</code></td>
<td>
<p>number of discretization points to evaluate functional data.</p>
</td></tr>
<tr><td><code id="fts.plot.covariance_+3A_lags">lags</code></td>
<td>
<p>lags to plot, dafauts <code>0:3</code></p>
</td></tr>
<tr><td><code id="fts.plot.covariance_+3A_nlevels">nlevels</code></td>
<td>
<p>number of color levels for the contour plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fts = fts.rar(100)

# Plot covariance operators of the time series curves
# We chose resolution equal 150 for better precision 
fts.plot.covariance(fts, lags=0:2, res = 150) 

# Plot correlation operators of the time series curves
fts.plot.covariance(fts, lags=0:2, cor = TRUE, res = 50)

# Make the grid of levels more dense
fts.plot.covariance(fts, lags=0:1, nlevels = 100)
</code></pre>

<hr>
<h2 id='fts.plot.filters'>Plot kernels</h2><span id='topic+fts.plot.filters'></span>

<h3>Description</h3>

<p>Plot kernels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.plot.filters(A, Ndpc = 1, lags = -3:3, one.plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.plot.filters_+3A_a">A</code></td>
<td>
<p>a functional filter sequence given as object of class <code><a href="#topic+fts.timedom">fts.timedom</a></code>.</p>
</td></tr>
<tr><td><code id="fts.plot.filters_+3A_ndpc">Ndpc</code></td>
<td>
<p>if Ndpc = k the first k filter sequences are plotted.</p>
</td></tr>
<tr><td><code id="fts.plot.filters_+3A_lags">lags</code></td>
<td>
<p>number of lags to plot.</p>
</td></tr>
<tr><td><code id="fts.plot.filters_+3A_one.plot">one.plot</code></td>
<td>
<p>if TRUE then functional filters corresponding belonging to the respective scores will all be plotted in the same graph.</p>
</td></tr>
<tr><td><code id="fts.plot.filters_+3A_...">...</code></td>
<td>
<p>arguments <code>col, lwd, lty</code> passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Load example PM10 data from Graz, Austria
data(pm10) # loads functional time series pm10 to the environment
X = center.fd(pm10)

# Compute functional dynamic principal components with only one component
res.dpca = fts.dpca(X, Ndpc = 1, freq=(-25:25/25)*pi) # leave default freq for higher precision

# Plot Functional Dynamic Principal Component Filters
fts.plot.filters(res.dpca$filters)
</code></pre>

<hr>
<h2 id='fts.plot.operators'>Contour plot of operator kernels.</h2><span id='topic+fts.plot.operators'></span>

<h3>Description</h3>

<p>Contour plot of operator kernels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.plot.operators(A, res = 200, lags = 0, freq = 0, axis = "Re", nlevels = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.plot.operators_+3A_a">A</code></td>
<td>
<p>an object of class <code>fts.timedom</code> or <code><a href="#topic+fts.freqdom">fts.freqdom</a></code>.</p>
</td></tr>
<tr><td><code id="fts.plot.operators_+3A_res">res</code></td>
<td>
<p>number of discretization points to evaluate functional data.</p>
</td></tr>
<tr><td><code id="fts.plot.operators_+3A_lags">lags</code></td>
<td>
<p>a vector of integers. For objects of class <code><a href="#topic+fts.timedom">fts.timedom</a></code>
the lags of the operators we want to plot.</p>
</td></tr>
<tr><td><code id="fts.plot.operators_+3A_freq">freq</code></td>
<td>
<p>a vector of frequencies in <code class="reqn">[-\pi,\pi]</code>. For an object of class
<code>fts.freqdom</code> the frequencies at which we want to plot the operator. If the
chosen frequencies are not contained in <code>A$freq</code>, the closest frequencies will be used.</p>
</td></tr>
<tr><td><code id="fts.plot.operators_+3A_axis">axis</code></td>
<td>
<p>if <code>"Re"</code> we plot the real part, if <code>"Im"</code> we plot the imaginary part of a complex-valued operator.</p>
</td></tr>
<tr><td><code id="fts.plot.operators_+3A_nlevels">nlevels</code></td>
<td>
<p>number of color levels for the contour plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Load example PM10 data from Graz, Austria
data(pm10) # loads functional time series pm10 to the environment
X = center.fd(pm10)

# Compute functional dynamic principal components with only one component
res.dpca = fts.dpca(X, Ndpc = 1, freq=(-25:25/25)*pi) # leave default freq for higher precision

# Plot the spectral density operator at frequencies -2, -3:3/30 * pi and 2
fts.plot.operators(res.dpca$spec.density,freq = c(-2,-3:3/30 * pi,2))
</code></pre>

<hr>
<h2 id='fts.rar'>Simulate functional autoregressive processes</h2><span id='topic+fts.rar'></span>

<h3>Description</h3>

<p>Generates functional autoregressive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.rar(
  n = 100,
  d = 11,
  Psi = NULL,
  op.norms = NULL,
  burnin = 20,
  noise = "mnorm",
  sigma = diag(d:1)/d,
  df = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.rar_+3A_n">n</code></td>
<td>
<p>number of observations to generate.</p>
</td></tr>
<tr><td><code id="fts.rar_+3A_d">d</code></td>
<td>
<p>dimension of the underlying multivariate VAR model.</p>
</td></tr>
<tr><td><code id="fts.rar_+3A_psi">Psi</code></td>
<td>
<p>an array of <code class="reqn">p\geq 1</code> coefficient matrices (need to be square matrices).
<code>Psi[,,k]</code> is the k-th coefficient matrix. If Psi is provided then <code>d=dim(Psi)[1]</code>. If no value is set then we generate a
functional autoregressive process of order 1. Then, <code>Psi[,,1]</code> is proportional to <code class="reqn">\exp(-|i-j|\colon 1\leq i, j\leq d)</code>
and such that Hilbert-Schmidt norm of the corresponding <code>lag-1</code> AR operator is 1/2.</p>
</td></tr>
<tr><td><code id="fts.rar_+3A_op.norms">op.norms</code></td>
<td>
<p>a vector with non-negative scalar entries to which the <code>Psi</code> are supposed to be scaled. The length of the
vector must equal to the order of the model.</p>
</td></tr>
<tr><td><code id="fts.rar_+3A_burnin">burnin</code></td>
<td>
<p>an integer <code class="reqn">\geq 0</code>. It specifies a number of initial  observations to be trashed to achieve stationarity.</p>
</td></tr>
<tr><td><code id="fts.rar_+3A_noise">noise</code></td>
<td>
<p><code>"mnorm"</code> for normal noise or <code>"t"</code> for student t noise. If
not specified <code>"mvnorm"</code> is chosen.</p>
</td></tr>
<tr><td><code id="fts.rar_+3A_sigma">sigma</code></td>
<td>
<p>covariance  or scale matrix of the coefficients corresponding to
functional innovations. The default value is <code>diag(d:1)/d</code>.</p>
</td></tr>
<tr><td><code id="fts.rar_+3A_df">df</code></td>
<td>
<p>degrees of freqdom if <code>noise = "mt"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose is to simulate a functional autoregressive process of the form
</p>
<p style="text-align: center;"><code class="reqn">
  X_t(u)=\sum_{k=1}^p \int_0^1\Psi_k(u,v) X_{t-k}(v)dv+\varepsilon_t(u),\quad 1\leq t\leq n.
</code>
</p>

<p>Here we assume that the observations lie in a finite dimensional subspace of the function space spanned by
Fourier basis functions <code class="reqn">\boldsymbol{b}^\prime(u)=(b_1(u),\ldots, b_d(u))</code>. That is <code class="reqn">X_t(u)=\boldsymbol{b}^\prime(u)\boldsymbol{X}_t</code>, <code class="reqn">\varepsilon_t(u)=\boldsymbol{b}^\prime(u)\boldsymbol{\varepsilon}_t</code> and <code class="reqn">\Psi_k(u,v)=\boldsymbol{b}^\prime(u)\boldsymbol{\Psi}_k \boldsymbol{b}(v)</code>. Then it follows that
</p>
<p style="text-align: center;"><code class="reqn">
  \boldsymbol{X}_t=\boldsymbol{\Psi}_1\boldsymbol{X}_{t-1}+\cdots+ \boldsymbol{\Psi}_p\boldsymbol{X}_{t-p}+\boldsymbol{\varepsilon}_t.
</code>
</p>

<p>Hence the dynamic of the functional time series is described by a VAR(<code class="reqn">p</code>) process.
</p>
<p>In this mathematical model the law of <code class="reqn">\boldsymbol{\varepsilon}_t</code> is determined by <code>noise</code>.
The matrices <code>Psi[,,k]</code> correspond to <code class="reqn">\boldsymbol{\Psi}_k</code>. If <code>op.norms</code> is provided, then the coefficient
matrices will be rescaled, such that the Hilbert-Schmidt norms of <code class="reqn">\boldsymbol{\Psi}_k</code> correspond to the vector.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="fda.html#topic+fd">fd</a></code>.
</p>


<h3>See Also</h3>

<p>The multivariate equivalent in the <code>freqdom</code> package: <code><a href="freqdom.html#topic+rar">rar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a FAR process without burnin (starting from 0)
fts = fts.rar(n = 5, d = 5, burnin = 0)
plot(fts)

# Generate a FAR process with burnin 50 (starting from observations
# already resambling the final distribution)
fts = fts.rar(n = 5, d = 5, burnin = 50)
plot(fts)

# Generate observations with very strong dependance
fts = fts.rar(n = 100, d = 5, burnin = 50, op.norms = 0.999)
plot(fts)
</code></pre>

<hr>
<h2 id='fts.rma'>Simulate functional moving average processes</h2><span id='topic+fts.rma'></span>

<h3>Description</h3>

<p>Generate a functional moving average process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.rma(
  n = 100,
  d = 11,
  Psi = NULL,
  op.norms = NULL,
  noise = "mnorm",
  sigma = diag(d:1)/d,
  df = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.rma_+3A_n">n</code></td>
<td>
<p>number of observations to generate.</p>
</td></tr>
<tr><td><code id="fts.rma_+3A_d">d</code></td>
<td>
<p>dimension of the underlying multivariate VAR model.</p>
</td></tr>
<tr><td><code id="fts.rma_+3A_psi">Psi</code></td>
<td>
<p>an array of <code class="reqn">p\geq 1</code> coefficient matrices (need to be square matrices). <code>Psi[,,k]</code> is the k-th coefficient
matrix. If <code>Psi</code> is provided then <code>d=dim(Psi)[1]</code>. If no value is set then we generate a functional autoregressive
process of order 1. Then, <code>Psi[,,1]</code> is proportional to <code class="reqn">\exp(-|i-j|\colon 1\leq i, j\leq d)</code> and such that
Hilbert-Schmidt norm of the corresponding lag-1 MA operator is 1/2.</p>
</td></tr>
<tr><td><code id="fts.rma_+3A_op.norms">op.norms</code></td>
<td>
<p>a vector with non-negative scalar entries to which the <code>Psi</code> are supposed to be scaled.
The length of the vector must equal to the order of the model.</p>
</td></tr>
<tr><td><code id="fts.rma_+3A_noise">noise</code></td>
<td>
<p><code>"mnorm"</code> for normal noise or <code>"mt"</code> for student t noise. If
not specified <code>"mvnorm"</code> is chosen.</p>
</td></tr>
<tr><td><code id="fts.rma_+3A_sigma">sigma</code></td>
<td>
<p>covariance  or scale matrix of the coefficients corresponding to functional innovations. The default value
is <code>diag(d:1)/d</code>.</p>
</td></tr>
<tr><td><code id="fts.rma_+3A_df">df</code></td>
<td>
<p>degrees of freqdom if <code>noise = "mt"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose is to simulate a functional autoregressive process of the form
</p>
<p style="text-align: center;"><code class="reqn">
X_t(u)=\sum_{k=1}^p \int_0^1\Psi_k(u,v) X_{t-k}(v)dv+\varepsilon_t(u),\quad 1\leq t\leq n.
</code>
</p>

<p>Here we assume that the observations lie in a finite dimensional subspace of the function space spanned by
Fourier basis functions <code class="reqn">\boldsymbol{b}^\prime(u)=(b_1(u),\ldots, b_d(u))</code>. That is <code class="reqn">X_t(u)=\boldsymbol{b}^\prime(u)\boldsymbol{X}_t</code>, <code class="reqn">\varepsilon_t(u)=\boldsymbol{b}^\prime(u)\boldsymbol{\varepsilon}_t</code> and <code class="reqn">\Psi_k(u,v)=\boldsymbol{b}^\prime(u)\boldsymbol{\Psi}_k \boldsymbol{b}(v)</code>. Then it follows that
</p>
<p style="text-align: center;"><code class="reqn">
\boldsymbol{X}_t=\boldsymbol{\Psi}_1\boldsymbol{X}_{t-1}+\cdots+ \boldsymbol{\Psi}_p\boldsymbol{X}_{t-p}+\boldsymbol{\varepsilon}_t.
</code>
</p>

<p>Hence the dynamic of the functional time series is described by a VAR(<code class="reqn">p</code>) process.
</p>
<p>In this mathematical model the law of <code class="reqn">\boldsymbol{\varepsilon}_t</code> is determined by <code>noise</code>. The matrices <code>Psi[,,k]</code>
correspond to <code class="reqn">\boldsymbol{\Psi}_k</code>. If <code>op.norms</code> is provided, then the coefficient matrices will be rescaled, such that
the Hilbert-Schmidt norms of <code class="reqn">\boldsymbol{\Psi}_k</code> correspond to the vector.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="fda.html#topic+fd">fd</a></code>.
</p>


<h3>See Also</h3>

<p>The multivariate equivalent in the <code>freqdom</code> package: <code><a href="freqdom.html#topic+rma">rma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a FMA process without burnin (starting from 0)
fts = fts.rma(n = 5, d = 5)
plot(fts)

# Generate observations with very strong dependance
fts = fts.rma(n = 100, d = 5, op.norms = 0.999)
plot(fts)

# Generate observations with very strong dependance and noise
# from the multivariate t distribution
fts = fts.rma(n = 100, d = 5, op.norms = 0.999, noise = "mt")
plot(fts)
</code></pre>

<hr>
<h2 id='fts.spectral.density'>Functional spectral and cross-spectral density operator</h2><span id='topic+fts.spectral.density'></span>

<h3>Description</h3>

<p>Estimates the spectral density operator and cross spectral density operator of functional time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.spectral.density(
  X,
  Y = X,
  freq = (-1000:1000/1000) * pi,
  q = ceiling((dim(X$coefs)[2])^{     0.33 }),
  weights = "Bartlett"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.spectral.density_+3A_x">X</code></td>
<td>
<p>an object of class <code><a href="fda.html#topic+fd">fd</a></code> containing <code class="reqn">T</code> functional observations.</p>
</td></tr>
<tr><td><code id="fts.spectral.density_+3A_y">Y</code></td>
<td>
<p>an object of class <code><a href="fda.html#topic+fd">fd</a></code> containing <code class="reqn">T</code> functional observations.</p>
</td></tr>
<tr><td><code id="fts.spectral.density_+3A_freq">freq</code></td>
<td>
<p>a vector containing frequencies in <code class="reqn">[-\pi, \pi]</code> on which the spectral density should be evaluated.
By default <code>freq=(-1000:1000/1000)*pi</code>.</p>
</td></tr>
<tr><td><code id="fts.spectral.density_+3A_q">q</code></td>
<td>
<p>window size for the kernel estimator, i.e. a positive integer. By default we choose <code>q = max(1, floor((dim(X$coefs)[2])^{0.33}))</code>.</p>
</td></tr>
<tr><td><code id="fts.spectral.density_+3A_weights">weights</code></td>
<td>
<p>kernel used in the spectral smoothing. For possible choices see
<code><a href="freqdom.html#topic+spectral.density">spectral.density</a></code> in package <code>freqdom</code>. By default the Bartlett kernel is chosen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X_1(u),\ldots, X_T(u)</code> and <code class="reqn">Y_1(u),\ldots, Y_T(u)</code> be two samples of functional data. The cross-spectral density kernel between the two time series <code class="reqn">(X_t(u))</code> and <code class="reqn">(Y_t(u))</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">  
  f^{XY}_\omega(u,v)=\sum_{h\in\mathbf{Z}} \mathrm{Cov}(X_h(u),Y_0(v)) e^{-ih\omega}.
</code>
</p>

<p>The function <code><a href="#topic+fts.spectral.density">fts.spectral.density</a></code> determines the empirical
cross-spectral density kernel between the two time series. The estimator is of the
form
</p>
<p style="text-align: center;"><code class="reqn">
  \widehat{f}^{XY}_\omega(u,v)=\sum_{|h|\leq q} w(|k|/q)\widehat{c}^{XY}_h(u,v)e^{-ih\omega},
</code>
</p>

<p>with <code class="reqn">\widehat{c}^{XY}_h(u,v)</code> defined in <code><a href="#topic+fts.cov.structure">fts.cov.structure</a></code>.
The other paremeters are as in <code><a href="freqdom.html#topic+cov.structure">cov.structure</a></code>.
</p>
<p>Since <code class="reqn">X_t(u)=\boldsymbol{b}_1^\prime(u)\mathbf{x}_t</code> and <code class="reqn">Y_t(u)=\mathbf{y}_t^\prime \boldsymbol{b}_2(u)</code> we can write
</p>
<p style="text-align: center;"><code class="reqn">
  \widehat{f}^{XY}_\omega(u,v)=\boldsymbol{b}_1^\prime(u)\widehat{\mathcal{F}}^{\mathbf{xy}}(\omega)\boldsymbol{b}_2(v),
</code>
</p>

<p>where <code class="reqn">\widehat{\mathcal{F}}^{\mathbf{xy}}(\omega)</code> is defined as for the function <code><a href="freqdom.html#topic+spectral.density">spectral.density</a></code> for series of coefficient vectors
<code class="reqn">(\mathbf{x}_t\colon 1\leq t\leq T)</code> and <code class="reqn">(\mathbf{y}_t\colon 1\leq t\leq T)</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>fts.timedom</code>. The list is containing the following components:
</p>

<ul>
<li> <p><code>operators</code> <code class="reqn">\quad</code> an array. Element <code>[,,k]</code> in the coefficient matrix of the spectral density matrix evaluated at the <code class="reqn">k</code>-th frequency listed in <code>freq</code>.
</p>
</li>
<li> <p><code>lags</code> <code class="reqn">\quad</code> returns the lags vector from the arguments.
</p>
</li>
<li> <p><code>basisX</code> <code class="reqn">\quad</code> returns <code>X$basis</code>, an object of class <code>basis.fd</code> (see <code><a href="fda.html#topic+create.basis">create.basis</a></code>).
</p>
</li>
<li> <p><code>basisY</code> <code class="reqn">\quad</code> returns <code>Y$basis</code>, an object of class <code>basis.fd</code> (see <code><a href="fda.html#topic+create.basis">create.basis</a></code>)
</p>
</li></ul>



<h3>See Also</h3>

<p>The multivariate equivalent in the <code>freqdom</code> package: <code><a href="freqdom.html#topic+spectral.density">spectral.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pm10)
X = center.fd(pm10)

# Compute the spectral density operator with Bartlett weights
SD = fts.spectral.density(X, freq = (-50:50/50) * pi, q = 2, weight="Bartlett")
fts.plot.operators(SD, freq = -2:2)

# Compute the spectral density operator with Tukey weights
SD = fts.spectral.density(X, freq = (-50:50/50) * pi, q = 2, weight="Tukey")
fts.plot.operators(SD, freq = -2:2)
# Note relatively small difference between the two plots

# Now, compute the spectral density operator with Tukey weights and larger q
SD = fts.spectral.density(X, freq = (-50:50/50) * pi, q = 5, weight="Tukey")
fts.plot.operators(SD, freq = -2:2)
</code></pre>

<hr>
<h2 id='fts.timedom'>Object of class <code>fts.timedom</code></h2><span id='topic+fts.timedom'></span>

<h3>Description</h3>

<p>Creates an object of class <code>fts.timedom</code>. This object corresponds to a sequence of linear operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.timedom(A, basisX, basisY = basisX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fts.timedom_+3A_a">A</code></td>
<td>
<p>an object of class timedom.</p>
</td></tr>
<tr><td><code id="fts.timedom_+3A_basisx">basisX</code></td>
<td>
<p>an object of class <code>basis.fd</code> (see <code><a href="fda.html#topic+create.basis">create.basis</a></code>)</p>
</td></tr>
<tr><td><code id="fts.timedom_+3A_basisy">basisY</code></td>
<td>
<p>an object of class <code>basis.fd</code> (see <code><a href="fda.html#topic+create.basis">create.basis</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This class is used to describe a functional linear filter, i.e. a sequence of linear operators, each of which corresponds to a certain lag.
Formally we consider an object of class <code>timedom</code> and add some basis functions. Depending on the context, we have different interpretations for the new object.
</p>
<p>(I) In order to define operators which maps between two functions spaces, the we
interpret <code>A$operators</code> as coefficients in the basis function expansion of the
kernel of some finite rank operators </p>
<p style="text-align: center;"><code class="reqn">\mathcal{A}_k:\mathrm{span}(\code{basisY})\to\mathrm{span}(\code{basisX}).</code>
</p>
<p> The kernels are <code class="reqn">a_k(u,v)=\boldsymbol{b}_1^\prime(u)\, A_k\, \boldsymbol{b}_2(v)</code>, where <code class="reqn">\boldsymbol{b_1}(u)=(b_{11}(u),\ldots, b_{1d_1}(u))^\prime</code> and <code class="reqn">\boldsymbol{b_2}(u)=(b_{21}(u),\ldots, b_{2d_1}(u))^\prime</code> are the basis functions provided by the arguments  basisX and basisY, respectively. Moreover, we consider lags <code class="reqn">\ell_1&lt;\ell_2&lt;\cdots&lt;\ell_K</code>. The object this function creates corresponds to the mapping <code class="reqn">\ell_k \mapsto a_k(u,v)</code>.
</p>
<p>(II) We may ignore basisX, and represent the linear mapping
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{A}_k:\mathrm{span}(\code{basisY})\to R^{d_1},</code>
</p>

<p>by considering <code class="reqn">a_k(v):=A_k\,\boldsymbol{b}_2(v)</code> and <code class="reqn">\mathcal{A}_k(x)=\int a_k(v)x(v)dv</code>.
</p>
<p>(III) We may ignore basisY, and represent the linear mapping
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{A}_k: R^{d_1}\to\mathrm{span}(\code{basisX}),</code>
</p>

<p>by considering <code class="reqn">a_k(u):=\boldsymbol{b}_1^\prime(u)A_k</code> and <code class="reqn">\mathcal{A}_k(y)=a_k(u)y</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class  <code>fts.freqdom</code>. An object of class  <code>fts.freqdom</code> is a list containing the following components:
</p>

<ul>
<li> <p><code>operators</code> <code class="reqn">\quad</code> returns the array <code>A$operators</code>.
</p>
</li>
<li> <p><code>basisX</code> <code class="reqn">\quad</code> returns basisX as given in the argument.
</p>
</li>
<li> <p><code>basisY</code> <code class="reqn">\quad</code> returns basisY as given in the argument.
</p>
</li>
<li> <p><code>lags</code> <code class="reqn">\quad</code> returns <code>A$lags</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>The multivariate equivalent in the <code>freqdom</code> package: <code><a href="freqdom.html#topic+timedom">timedom</a></code>
</p>

<hr>
<h2 id='fts.timedom.trunc'>Truncate functional timedom object</h2><span id='topic+fts.timedom.trunc'></span>

<h3>Description</h3>

<p>Truncate functional timedom object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fts.timedom.trunc(A, lags)
</code></pre>

<hr>
<h2 id='is.fts.freqdom'>Checks if an object belongs to the class fts.freqdom</h2><span id='topic+is.fts.freqdom'></span>

<h3>Description</h3>

<p>Checks if an object belongs to the class <code><a href="#topic+fts.freqdom">fts.freqdom</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fts.freqdom(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fts.freqdom_+3A_x">X</code></td>
<td>
<p>some object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>X</code> is of type <code><a href="#topic+fts.freqdom">fts.freqdom</a></code>, <code>FALSE</code> otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fts.freqdom">fts.freqdom</a></code>, <code><a href="#topic+fts.timedom">fts.timedom</a></code>, <code><a href="#topic+is.fts.timedom">is.fts.timedom</a></code>
</p>

<hr>
<h2 id='is.fts.timedom'>Checks if an object belongs to the class fts.timedom</h2><span id='topic+is.fts.timedom'></span>

<h3>Description</h3>

<p>Checks if an object belongs to the class <code><a href="#topic+fts.timedom">fts.timedom</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fts.timedom(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fts.timedom_+3A_x">X</code></td>
<td>
<p>some object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>X</code> is of type <code><a href="#topic+fts.timedom">fts.timedom</a></code>, <code>FALSE</code> otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fts.freqdom">fts.freqdom</a></code>, <code><a href="#topic+fts.timedom">fts.timedom</a></code>, <code><a href="#topic+is.fts.freqdom">is.fts.freqdom</a></code>
</p>

<hr>
<h2 id='pm10'>PM10 dataset</h2><span id='topic+pm10'></span>

<h3>Description</h3>

<p>Concentration of partical matter of diameter 10 micrometers or smaller (<code>PM10</code>)
is one of the most widely adopted measurements for assesment of ambient air quality.
In this dataset, we provide <code class="reqn">175</code> measurement of daily temporal distribution of <code>PM10</code>
in Graz, Austria, collected between December 2004 and June 2005.
</p>
<p>For the purpose of this R package, raw data of 48 observations per day, was transformed
to functional objects in Fourier basis using <span class="pkg">fda</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm10
</code></pre>


<h3>Format</h3>

<p><code class="reqn">175</code> daily distribution functions in the <code>fd</code> format
from the <span class="pkg">fda</span> package
</p>


<h3>Source</h3>

<p>Styrian Government, FA 17C Technical Environmental Protection and Safety, Air Quality Control Section,
</p>


<h3>References</h3>

<p>Hormann, Siegfried, Brigitte Pfeiler, and Ernst Stadlober.
<em>Analysis and prediction of particulate matter PM10 for the winter season in Graz.</em>
Austrian Journal of Statistics 34.4 (2005): 307-326.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pm10)
summary(pm10)
plot(pm10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
