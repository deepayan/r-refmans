<!DOCTYPE html><html><head><title>Help for package MCMCglmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MCMCglmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MCMCglmm-package'><p>Multivariate Generalised Linear Mixed Models</p></a></li>
<li><a href='#at.level'><p>Incidence Matrix of Levels within a Factor</p></a></li>
<li><a href='#at.set'><p>Incidence Matrix of Combined Levels within a Factor</p></a></li>
<li><a href='#BTdata'><p>Blue Tit Data for a Quantitative Genetic Experiment</p></a></li>
<li><a href='#BTped'><p>Blue Tit Pedigree</p></a></li>
<li><a href='#buildV'><p>Forms expected (co)variances for GLMMs fitted with MCMCglmm</p></a></li>
<li><a href='#commutation'><p>Commutation Matrix</p></a></li>
<li><a href='#dcmvnorm'><p>Density of a (conditional) multivariate normal variate</p></a></li>
<li><a href='#Ddivergence'><p>d-divergence</p></a></li>
<li><a href='#Dexpressions'><p>List of unevaluated expressions for (mixed) partial derivatives of</p>
fitness with respect to linear predictors.</a></li>
<li><a href='#Dtensor'><p>Tensor of (mixed) partial derivatives</p></a></li>
<li><a href='#evalDtensor'><p>Evaluates a list of (mixed) partial derivatives</p></a></li>
<li><a href='#gelman.prior'><p>Prior Covariance Matrix for Fixed Effects.</p></a></li>
<li><a href='#inverseA'><p>Inverse Relatedness Matrix and Phylogenetic Covariance Matrix</p></a></li>
<li><a href='#knorm'><p>(Mixed) Central Moments of a Multivariate Normal Distribution</p></a></li>
<li><a href='#KPPM'><p>Kronecker Product Permutation Matrix</p></a></li>
<li><a href='#krzanowski.test'><p>Krzanowski's Comparison of Subspaces</p></a></li>
<li><a href='#kunif'><p>Central Moments of a Uniform Distribution</p></a></li>
<li><a href='#list2bdiag'><p>Forms the direct sum from a list of matrices</p></a></li>
<li><a href='#MCMCglmm'><p>Multivariate Generalised Linear Mixed Models</p></a></li>
<li><a href='#me'><p>Design Matrix for Measurement Error Model</p></a></li>
<li><a href='#mult.memb'><p>Design Matrices for Multiple Membership Models</p></a></li>
<li><a href='#path'><p>Design Matrix for Path Analyses</p></a></li>
<li><a href='#pkk'><p>Probability that all multinomial categories have a non-zero count.</p></a></li>
<li><a href='#PlodiaPO'><p>Phenoloxidase measures on caterpillars of the Indian meal moth.</p></a></li>
<li><a href='#PlodiaR'><p>Resistance of Indian meal moth caterpillars to the granulosis virus</p>
PiGV.</a></li>
<li><a href='#PlodiaRB'><p>Resistance (as a binary trait) of Indian meal moth caterpillars to the</p>
granulosis virus PiGV.</a></li>
<li><a href='#plot.MCMCglmm'><p>Plots MCMC chains from MCMCglmm using plot.mcmc</p></a></li>
<li><a href='#plotsubspace'><p>Plots covariance matrices</p></a></li>
<li><a href='#posterior.ante'><p>Posterior distribution of ante-dependence parameters</p></a></li>
<li><a href='#posterior.cor'><p>Transforms posterior distribution of covariances into correlations</p></a></li>
<li><a href='#posterior.evals'><p>Posterior distribution of eigenvalues</p></a></li>
<li><a href='#posterior.inverse'><p>Posterior distribution of matrix inverse</p></a></li>
<li><a href='#posterior.mode'><p>Estimates the marginal parameter modes using kernel density estimation</p></a></li>
<li><a href='#predict.MCMCglmm'><p>Predict method for GLMMs fitted with MCMCglmm</p></a></li>
<li><a href='#prunePed'><p>Pedigree pruning</p></a></li>
<li><a href='#Ptensor'><p>Tensor of Sample (Mixed) Central Moments</p></a></li>
<li><a href='#rbv'><p>Random Generation of MVN Breeding Values and Phylogenetic Effects</p></a></li>
<li><a href='#residuals.MCMCglmm'><p>Residuals form a GLMM fitted with MCMCglmm</p></a></li>
<li><a href='#rIW'><p>Random Generation from the Conditional Inverse Wishart Distribution</p></a></li>
<li><a href='#rtcmvnorm'><p>Random Generation from a Truncated Conditional Normal Distribution</p></a></li>
<li><a href='#rtnorm'><p>Random Generation from a Truncated Normal Distribution</p></a></li>
<li><a href='#simulate.MCMCglmm'><p>Simulate method for GLMMs fitted with MCMCglmm</p></a></li>
<li><a href='#sir'><p>Design Matrix for Simultaneous and Recursive Relationships between Responses</p></a></li>
<li><a href='#sm2asreml'><p>Converts sparseMatrix to asreml's giv format</p></a></li>
<li><a href='#spl'><p>Orthogonal Spline Design Matrix</p></a></li>
<li><a href='#SShorns'><p>Horn type and genders of Soay Sheep</p></a></li>
<li><a href='#summary.MCMCglmm'><p>Summarising GLMM Fits from MCMCglmm</p></a></li>
<li><a href='#Tri2M'><p>Lower/Upper Triangle Elements of a Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.35</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-30</td>
</tr>
<tr>
<td>Title:</td>
<td>MCMC Generalised Linear Mixed Models</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, coda, ape</td>
</tr>
<tr>
<td>Imports:</td>
<td>corpcor, tensorA, cubature, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, combinat, mvtnorm, orthopolynom, MCMCpack, bayesm, msm</td>
</tr>
<tr>
<td>Author:</td>
<td>Jarrod Hadfield</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jarrod Hadfield &lt;j.hadfield@ed.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits Multivariate Generalised Linear Mixed Models (and related models) using Markov chain Monte Carlo techniques (Hadfield 2010 J. Stat. Soft.). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-30 12:34:30 UTC; jhadfiel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-30 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='MCMCglmm-package'>Multivariate Generalised Linear Mixed Models</h2><span id='topic+MCMCglmm-package'></span>

<h3>Description</h3>

<p>MCMCglmm is a package for fitting Generalised Linear Mixed Models using Markov 
chain Monte Carlo techniques (Hadfield 2009). Most commonly used distributions like the normal 
and the Poisson are supported together with some useful but less popular ones 
like the zero-inflated Poisson and the multinomial. Missing values and left, 
right and interval censoring are accommodated for all traits. The package also 
supports multi-trait models where the multiple responses can follow different 
types of distribution.  The package allows various residual and random-effect 
variance structures to be specified including heterogeneous variances, 
unstructured covariance matrices and random regression (e.g. random slope 
models).  Three special types of variance structure that can be specified are 
those associated with pedigrees (animal models), phylogenies (the comparative 
method) and measurement error (meta-analysis).
</p>
<p>The package makes heavy use of results in Sorensen &amp; Gianola (2002) and Davis 
(2006) which taken together result in what is hopefully a fast and efficient 
routine. Most small to medium sized problems should take seconds to a few 
minutes, but large problems (&gt; 20,000 records) are possible.  My interest is in 
evolutionary biology so there are also several functions for applying Rice's 
(2004) tensor analysis to real data and functions for visualising and comparing 
matrices.
</p>
<p>Please read the tutorial <code>vignette("Tutorial", "MCMCglmm")</code> or the course notes
<code>vignette("CourseNotes", "MCMCglmm")</code> 
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>References</h3>

<p>Hadfield, J.D. (2009) MCMC methods for Multi-response Generalised 
Linear Mixed Models: The MCMCglmm R Package, <em>submitted</em>
</p>
<p>Sorensen, D. &amp; Gianola, D. (2002) Likelihood, Bayesian and MCMC Methods in Quantitative 
Genetics, Springer
</p>
<p>Davis, T.A. (2006) Direct Methods for Sparse Linear Systems, SIAM
</p>
<p>Rice (2004) Evolutionary Theory: Mathematical and Conceptual Foundations, Sinauer
</p>

<hr>
<h2 id='at.level'>Incidence Matrix of Levels within a Factor</h2><span id='topic+at.level'></span>

<h3>Description</h3>

<p>Incidence matrix of levels within a factor</p>


<h3>Usage</h3>

<pre><code class='language-R'>at.level(x, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="at.level_+3A_x">x</code></td>
<td>
<p>factor</p>
</td></tr>
<tr><td><code id="at.level_+3A_level">level</code></td>
<td>
<p>factor level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>incidence matrix for level in x
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+at.set">at.set</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fac&lt;-gl(3,10,30, labels=letters[1:3])
x&lt;-rnorm(30)
model.matrix(~at.level(fac,"b"):x)
</code></pre>

<hr>
<h2 id='at.set'>Incidence Matrix of Combined Levels within a Factor</h2><span id='topic+at.set'></span>

<h3>Description</h3>

<p>Incidence Matrix of Combined Levels within a Factor</p>


<h3>Usage</h3>

<pre><code class='language-R'>at.set(x, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="at.set_+3A_x">x</code></td>
<td>
<p>factor</p>
</td></tr>
<tr><td><code id="at.set_+3A_level">level</code></td>
<td>
<p>set of factor levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>incidence matrix for the set <code>level</code> in x
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+at.level">at.level</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fac&lt;-gl(3,10,30, labels=letters[1:3])
x&lt;-rnorm(30)
model.matrix(~at.set(fac,2:3):x)
</code></pre>

<hr>
<h2 id='BTdata'>Blue Tit Data for a Quantitative Genetic Experiment</h2><span id='topic+BTdata'></span>

<h3>Description</h3>

<p>Blue Tit (<em>Cyanistes caeruleus</em>) Data for a Quantitative Genetic Experiment</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BTdata)</code></pre>


<h3>Format</h3>

<p>a data frame with 828 rows and 7 columns, with variables tarsus length (<code>tarsus</code>) and colour (<code>back</code>) measured on 828 individuals (<code>animal</code>). The mother of each is also recorded (<code>dam</code>) together with the foster nest (<code>fosternest</code>) in which the chicks were reared. The date on which the first egg in each nest hatched (<code>hatchdate</code>) is recorded together with the sex (<code>sex</code>) of the individuals.</p>


<h3>References</h3>

<p>Hadfield, J.D. et. al. 2007 Journal of Evolutionary Biology 20 549-557
</p>


<h3>See Also</h3>

<p><a href="#topic+BTped">BTped</a></p>

<hr>
<h2 id='BTped'>Blue Tit Pedigree</h2><span id='topic+BTped'></span>

<h3>Description</h3>

<p>Blue Tit (<em>Cyanistes caeruleus</em>) Pedigree</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BTped)</code></pre>


<h3>Format</h3>

<p>a data frame with 1040 rows and 3 columns, with individual identifier (<code>animal</code>) mother identifier (<code>dam</code>) and father identifier (<code>sire</code>). The first 212 rows are the parents of the 828 offspring from 106 full-sibling families. Parents are assumed to be unrelated to each other and have NA's in the <code>dam</code> and <code>sire</code> column. 
</p>


<h3>References</h3>

<p>Hadfield, J.D. et. al. 2007 Journal of Evolutionary Biology 20 549-557
</p>


<h3>See Also</h3>

<p><a href="#topic+BTped">BTped</a></p>

<hr>
<h2 id='buildV'>Forms expected (co)variances for GLMMs fitted with MCMCglmm</h2><span id='topic+buildV'></span>

<h3>Description</h3>

<p>Forms the expected covariance structure of link-scale observations for GLMMs fitted with MCMCglmm</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildV(object, marginal=object$Random$formula, diag=TRUE, it=NULL, posterior="mean", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildV_+3A_object">object</code></td>
<td>
<p>an object of class <code>"MCMCglmm"</code></p>
</td></tr>
<tr><td><code id="buildV_+3A_marginal">marginal</code></td>
<td>
<p>formula defining random effects to be maginalised</p>
</td></tr>
<tr><td><code id="buildV_+3A_diag">diag</code></td>
<td>
<p>logical; if <code>TRUE</code> the covariances betwween observations are not calculated</p>
</td></tr>
<tr><td><code id="buildV_+3A_it">it</code></td>
<td>
<p>integer; optional, MCMC iteration on which covariance structure should be based</p>
</td></tr>
<tr><td><code id="buildV_+3A_posterior">posterior</code></td>
<td>
<p>character; if <code>it</code> is  <code>NULL</code> should the covariance structure be based on the marginal posterior means (<code>'mean'</code>) of the VCV parameters, or the  posterior modes (<code>'mode'</code>), or a random draw from the posterior with replacement (<code>'distribution'</code>).  If <code>posterior=="all"</code> the posterior distribution of observation variances is returned</p>
</td></tr>
<tr><td><code id="buildV_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>diag=TRUE</code> an n by n covariance matrix. If <code>diag=FALSE</code> and  <code>posterior!="all"</code> an 1 by n matrix of variances. If <code>posterior=="all"</code> an nit by n matrix of variances (where nit is the number of saved MCMC iterations).</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCglmm">MCMCglmm</a></code></p>

<hr>
<h2 id='commutation'>Commutation Matrix</h2><span id='topic+commutation'></span>

<h3>Description</h3>

<p>Forms an mn x mn commutation matrix which transforms <code class="reqn">vec({\bf A})</code> into <code class="reqn">vec({\bf A}^{'})</code>, where <code class="reqn">{\bf A}</code> is an m x n matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commutation(m, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commutation_+3A_m">m</code></td>
<td>
<p>integer; number of rows of A</p>
</td></tr>
<tr><td><code id="commutation_+3A_n">n</code></td>
<td>
<p>integer; number of columns of A</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Commutation Matrix
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>References</h3>

<p>Magnus, J. R. &amp; Neudecker, H. (1979) Annals of Statistics 7 (2) 381-394</p>


<h3>Examples</h3>

<pre><code class='language-R'>commutation(2,2)
</code></pre>

<hr>
<h2 id='dcmvnorm'>Density of a (conditional) multivariate normal variate</h2><span id='topic+dcmvnorm'></span>

<h3>Description</h3>

<p>Density of a (conditional) multivariate normal variate</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcmvnorm(x, mean = 0, V = 1, keep=1, cond=(1:length(x))[-keep], log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcmvnorm_+3A_x">x</code></td>
<td>
<p>vector of observations</p>
</td></tr>
<tr><td><code id="dcmvnorm_+3A_mean">mean</code></td>
<td>
<p>vector of means</p>
</td></tr>
<tr><td><code id="dcmvnorm_+3A_v">V</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="dcmvnorm_+3A_keep">keep</code></td>
<td>
<p>vector of integers: observations for which density is required</p>
</td></tr>
<tr><td><code id="dcmvnorm_+3A_cond">cond</code></td>
<td>
<p>vector of integers: observations to condition on</p>
</td></tr>
<tr><td><code id="dcmvnorm_+3A_log">log</code></td>
<td>
<p>if TRUE, density p is given as log(p)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric 
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>V1&lt;-cbind(c(1,0.5), c(0.5,1))
dcmvnorm(c(0,2), c(0,0), V=V1, keep=1, cond=2)
# density of x[1]=0 conditional on x[2]=2 given 
# x ~ MVN(c(0,0), V1) 

dcmvnorm(c(0,2), c(0,0), V=V1, keep=1, cond=NULL)
# density of x[1]=0 marginal to x[2] 
dnorm(0,0,1)
# same as univariate density 

V2&lt;-diag(2)
dcmvnorm(c(0,2), c(0,0), V=V2, keep=1, cond=2)
# density of x[1]=0 conditional on x[2]=2 given 
# x ~ MVN(c(0,0), V2) 
dnorm(0,0,1)
# same as univariate density because V2 is diagonal
</code></pre>

<hr>
<h2 id='Ddivergence'>d-divergence</h2><span id='topic+Ddivergence'></span>

<h3>Description</h3>

<p>Calculates Ovaskainen's (2008) d-divergence between 2 zero-mean multivariate normal distributions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ddivergence(CA=NULL, CB=NULL, n=10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ddivergence_+3A_ca">CA</code></td>
<td>
<p>Matrix A</p>
</td></tr>
<tr><td><code id="Ddivergence_+3A_cb">CB</code></td>
<td>
<p>Matrix B</p>
</td></tr>
<tr><td><code id="Ddivergence_+3A_n">n</code></td>
<td>
<p>number of Monte Carlo samples for approximating the integral</p>
</td></tr>
</table>


<h3>Value</h3>

<p>d-divergence
</p>


<h3>Note</h3>

<p>In versions of MCMCglmm &lt;2.26 Ovaskainen's (2008) d-divergence was incorrectly calculated.
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>References</h3>

<p>Ovaskainen, O.  et. al. (2008) Proc. Roy. Soc - B (275) 1635 593-750</p>


<h3>Examples</h3>

<pre><code class='language-R'>CA&lt;-rIW(diag(2),10, n=1)
CB&lt;-rIW(diag(2),10, n=1)
Ddivergence(CA, CB)
</code></pre>

<hr>
<h2 id='Dexpressions'>List of unevaluated expressions for (mixed) partial derivatives of 
fitness with respect to linear predictors.</h2><span id='topic+Dexpressions'></span>

<h3>Description</h3>

<p>Unevaluated expressions for (mixed) partial derivatives of fitness with 
respect to linear predictors for survival and fecundity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Dexpressions
</code></pre>


<h3>Value</h3>

<table>
<tr><td><code>PW.d0W</code></td>
<td>
<p>Fitness (W) function for the Poisson-Weibull (PW) model.</p>
</td></tr>
<tr><td><code>PW.d1Wds</code></td>
<td>
<p>First Partial derivative of fitness (d1W) with respect to 
survival (d1s) linear predictor for the Poisson-Weibull (PW) model.</p>
</td></tr>
<tr><td><code>PW.d1Wdf</code></td>
<td>
<p>First Partial derivative of fitness (d1W) with respect to 
fecundity (d1f) linear redictor for the Poisson-Weibull (PW) model.</p>
</td></tr> 
<tr><td><code>PW.d3Wd2sd1f</code></td>
<td>
<p>Mixed third partial derivative of fitness (d3W) with 2nd 
derivative of survival linear predictor (d2s) and first derivative of fecundity 
linear predictor (d1f) from the Poisson-Weibull (PW) model.</p>
</td></tr>   
<tr><td><code>PW.d3Wdsd2f</code></td>
<td>
<p>and so on ...</p>
</td></tr>
<tr><td><code>PW.d2Wd2f</code></td>
<td>
</td></tr>
<tr><td><code>PW.d2Wd2s</code></td>
<td>
</td></tr>
<tr><td><code>PW.d3Wd3s</code></td>
<td>
</td></tr>
<tr><td><code>PW.d3Wd3f</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Dtensor">Dtensor</a></code></p>

<hr>
<h2 id='Dtensor'>Tensor of (mixed) partial derivatives</h2><span id='topic+Dtensor'></span>

<h3>Description</h3>

<p>Forms tensor of (mixed) partial derivatives</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dtensor(expr, name=NULL, mu = NULL, m=1, evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dtensor_+3A_expr">expr</code></td>
<td>
<p>'expression'</p>
</td></tr>
<tr><td><code id="Dtensor_+3A_name">name</code></td>
<td>
<p>character vector, giving the variable names with respect to which 
derivatives will be computed. If NULL all variables in the expression will be 
used</p>
</td></tr>
<tr><td><code id="Dtensor_+3A_mu">mu</code></td>
<td>
<p>optional: numeric vector, at which the derivatives are evaluated</p>
</td></tr>
<tr><td><code id="Dtensor_+3A_m">m</code></td>
<td>
<p>order of derivative</p>
</td></tr>
<tr><td><code id="Dtensor_+3A_evaluate">evaluate</code></td>
<td>
<p>logical; if <code>TRUE</code> the derivatives are evaluated at 
<code>mu</code>, if <code>FALSE</code> the derivatives are left unevaluated</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Dtensor</code></td>
<td>
<p>(list) of unevaluated expression(s) if <code>evaluate=FALSE</code> or 
a tensor if <code>evaluate=TRUE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jarrod Hadfield j.hadfield@ed.ac.uk</p>


<h3>References</h3>

<p>Rice, S.H. (2004) Evolutionary Theory: Mathematical and Conceptual 
Foundations. Sinauer (MA) USA.</p>


<h3>See Also</h3>

<p><code><a href="#topic+evalDtensor">evalDtensor</a></code>, <code><a href="#topic+Dexpressions">Dexpressions</a></code>, <code><a href="stats.html#topic+D">D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f&lt;-expression(beta_1 + time * beta_2 + u)
Dtensor(f,eval=FALSE)
</code></pre>

<hr>
<h2 id='evalDtensor'>Evaluates a list of (mixed) partial derivatives</h2><span id='topic+evalDtensor'></span>

<h3>Description</h3>

<p>Evaluates a list of (mixed) partial derivatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalDtensor(x, mu, m=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalDtensor_+3A_x">x</code></td>
<td>
<p>unevaluated (list) of expression(s)</p>
</td></tr>
<tr><td><code id="evalDtensor_+3A_mu">mu</code></td>
<td>
<p>values at which the derivatives are evaluated: names need to match 
terms in x</p>
</td></tr>
<tr><td><code id="evalDtensor_+3A_m">m</code></td>
<td>
<p>order of derivative</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tensor 
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Dtensor">Dtensor</a></code>, <code><a href="stats.html#topic+D">D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f&lt;-expression(beta_1 + time*beta_2+u)
Df&lt;-Dtensor(f, eval=FALSE, m=2)
evalDtensor(Df, mu=data.frame(beta_1=0.5, beta_2=1, time=3, u=2.3))
Dtensor(f, mu=c(1,3,1,2.3), m=2)
</code></pre>

<hr>
<h2 id='gelman.prior'>Prior Covariance Matrix for Fixed Effects.</h2><span id='topic+gelman.prior'></span>

<h3>Description</h3>

<p>Prior Covariance Matrix for Fixed Effects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gelman.prior(formula, data, scale=1, intercept=scale, singular.ok=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gelman.prior_+3A_formula">formula</code></td>
<td>
<p><code><a href="stats.html#topic+formula">formula</a></code> for the fixed effects.</p>
</td></tr>
<tr><td><code id="gelman.prior_+3A_data">data</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="gelman.prior_+3A_intercept">intercept</code></td>
<td>
<p>prior standard deviation for the intercept</p>
</td></tr>
<tr><td><code id="gelman.prior_+3A_scale">scale</code></td>
<td>
<p>prior standard deviation for regression parameters</p>
</td></tr>
<tr><td><code id="gelman.prior_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical: if <code>FALSE</code> linear dependencies in the fixed effects are removed. if <code>TRUE</code> they are left in an estimated, although all information comes form the prior</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gelman et al. (2008) suggest that the input variables of a categorical regression are standardised and that the associated regression parameters are assumed independent in the prior.  Gelman et al. (2008) recommend a scaled t-distribution with a single degree of freedom (scaled Cauchy) and a scale of 10 for the intercept and 2.5 for the regression parameters. If the degree of freedom is infinity (i.e. a normal distribution) then a prior covariance matrix <code>B$V</code> can be defined for the regression parameters without input standardisation that corresponds to a diagonal prior <code class="reqn">{\bf D}</code> for the regression parameters had the inputs been standardised.  The diagonal elements of <code class="reqn">{\bf D}</code> are set to <code>scale^2</code> except the first which is set to <code>intercept^2</code>.  With logistic regression <code class="reqn">D=\pi^{2}/3+\sigma^{2}</code> gives a prior that is approximately flat on the probability scale, where <code class="reqn">\sigma^{2}</code> is the total variance due to the random effects. For probit regression it is <code class="reqn">D=1+\sigma^{2}</code>.
</p>


<h3>Value</h3>

<p>prior covariance matrix
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>References</h3>

<p>Gelman, A. et al. (2008) The Annals of Appled Statistics 2 4  1360-1383
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat&lt;-data.frame(y=c(0,0,1,1), x=gl(2,2))
# data with complete separation

#####################
# probit regression #
#####################

prior1&lt;-list(
  B=list(mu=c(0,0), V=gelman.prior(~x, data=dat, scale=sqrt(1+1))), 
  R=list(V=1,fix=1))

m1&lt;-MCMCglmm(y~x, prior=prior1, data=dat, family="ordinal", verbose=FALSE)

c2&lt;-1
p1&lt;-pnorm(m1$Sol[,1]/sqrt(1+c2)) # marginal probability when x=1

#######################
# logistic regression #
#######################

prior2&lt;-list(B=list(mu=c(0,0), V=gelman.prior(~x, data=dat, scale=sqrt(pi^2/3+1))),
             R=list(V=1,fix=1))

m2&lt;-MCMCglmm(y~x, prior=prior2, data=dat, family="categorical", verbose=FALSE)

c2 &lt;- (16 * sqrt(3)/(15 * pi))^2
p2&lt;-plogis(m2$Sol[,1]/sqrt(1+c2)) # marginal probability when x=1

plot(mcmc.list(p1,p2))


</code></pre>

<hr>
<h2 id='inverseA'>Inverse Relatedness Matrix and Phylogenetic Covariance Matrix</h2><span id='topic+inverseA'></span>

<h3>Description</h3>

<p>Henderson (1976) and Meuwissen and Luo (1992) algorithm for inverting 
relatedness matrices, and Hadfield and Nakagawa (2010) algorithm for inverting 
phylogenetic covariance matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  inverseA(pedigree=NULL, nodes="ALL", scale=TRUE, reduced=FALSE,
     tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverseA_+3A_pedigree">pedigree</code></td>
<td>
<p>ordered pedigree with 3 columns: id, dam and sire, or a 
<code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="inverseA_+3A_nodes">nodes</code></td>
<td>
<p><code>"ALL"</code> calculates the inverse for all individuals/nodes. 
For phylogenies <code>"TIPS"</code> calculates the inverse for the species tips only, 
and for pedigrees a vector of id's can be passed which inverts the relatedness 
matrix for that subset.</p>
</td></tr>
<tr><td><code id="inverseA_+3A_scale">scale</code></td>
<td>
<p>logical: should a phylogeny (needs to be ultrametric) be scaled 
to unit length (distance from root to tip)?</p>
</td></tr>
<tr><td><code id="inverseA_+3A_reduced">reduced</code></td>
<td>
<p>logical: should childless nodes be dropped from the inverse and the pedigree/phylogeny representation be reduced?</p>
</td></tr>
<tr><td><code id="inverseA_+3A_tol">tol</code></td>
<td>
<p>numeric: differences in branch length smaller than this are ignored when assessing whether a tree is ultrametric.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Ainv</code></td>
<td>
<p>inverse as <code>sparseMatrix</code></p>
</td></tr>
<tr><td><code>inbreeding</code></td>
<td>
<p>inbreeding coefficients/branch lengths</p>
</td></tr>
<tr><td><code>pedigree</code></td>
<td>
<p>pedigree/pedigree representation of phylogeny</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>References</h3>

<p>Henderson, C.R. (1976) Biometrics 32 (1) 69:83
</p>
<p>Quaas, R. L. and Pollak, E. J. (1980) Journal of Animal Science 51:1277-1287.
</p>
<p>Meuwissen, T.H.E and Luo, Z. (1992) Genetic Selection Evolution 24 (4) 305:313
</p>
<p>Hadfield, J.D. and Nakagawa, S. (2010)  Journal of Evolutionary Biology 23 494-508
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.families)
Ainv&lt;-inverseA(bird.families)
</code></pre>

<hr>
<h2 id='knorm'>(Mixed) Central Moments of a Multivariate Normal Distribution</h2><span id='topic+knorm'></span>

<h3>Description</h3>

<p>Forms a tensor of (mixed) central moments of a multivariate normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knorm(V, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knorm_+3A_v">V</code></td>
<td>
<p>(co)variance matrix</p>
</td></tr>
<tr><td><code id="knorm_+3A_k">k</code></td>
<td>
<p>kth central moment, must be even</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tensor
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>References</h3>

<p>Schott, J.R.(2003) Journal of Multivariate Analysis 87 (1) 177-190</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnorm">dnorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>V&lt;-diag(2)
knorm(V,2)
knorm(V,4)
</code></pre>

<hr>
<h2 id='KPPM'>Kronecker Product Permutation Matrix</h2><span id='topic+KPPM'></span>

<h3>Description</h3>

<p>Forms an mk x mk Kronecker Product Permutation Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KPPM(m, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KPPM_+3A_m">m</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="KPPM_+3A_k">k</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>References</h3>

<p>Schott, J.R.(2003) Journal of Multivariate Analysis 87 (1) 177-190</p>


<h3>Examples</h3>

<pre><code class='language-R'>KPPM(2,3)
</code></pre>

<hr>
<h2 id='krzanowski.test'>Krzanowski's Comparison of Subspaces</h2><span id='topic+krzanowski.test'></span>

<h3>Description</h3>

<p>Calculates statistics of Krzanowski's comparison of subspaces.</p>


<h3>Usage</h3>

<pre><code class='language-R'>krzanowski.test(CA, CB, vecsA, vecsB, corr = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krzanowski.test_+3A_ca">CA</code></td>
<td>
<p>Matrix A</p>
</td></tr>
<tr><td><code id="krzanowski.test_+3A_cb">CB</code></td>
<td>
<p>Matrix B</p>
</td></tr>
<tr><td><code id="krzanowski.test_+3A_vecsa">vecsA</code></td>
<td>
<p>Vector of integers indexing the eigenvectors determining the 
subspace of A</p>
</td></tr>
<tr><td><code id="krzanowski.test_+3A_vecsb">vecsB</code></td>
<td>
<p>Vector of integers indexing the eigenvectors determining the 
subspace of B</p>
</td></tr>
<tr><td><code id="krzanowski.test_+3A_corr">corr</code></td>
<td>
<p>logical; if <code>TRUE</code> the variances of A and B are standardised</p>
</td></tr>
<tr><td><code id="krzanowski.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>sumofS</code></td>
<td>
<p>metric for overall similarity with 0 indicting no similarity and 
a value of <code>length(vecsA)</code> for identical subspaces</p>
</td></tr>
<tr><td><code>angles</code></td>
<td>
<p>angle in degrees between each best matched pair of vectors</p>
</td></tr>
<tr><td><code>bisector</code></td>
<td>
<p>vector that lies between each best matched pair of vectors</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>References</h3>

<p>Krzanowski, W.J. (2000) Principles of Multivariate Analysis. OUP</p>


<h3>Examples</h3>

<pre><code class='language-R'>CA&lt;-rIW(diag(5),10, n=1)
CB&lt;-rIW(diag(5),10, n=1)
krzanowski.test(CA, CB, vecsA=1:2, vecsB=1:2)
krzanowski.test(CA, CA, vecsA=1:2, vecsB=1:2)
</code></pre>

<hr>
<h2 id='kunif'>Central Moments of a Uniform Distribution</h2><span id='topic+kunif'></span>

<h3>Description</h3>

<p>Returns the central moments of a uniform distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kunif(min, max, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kunif_+3A_min">min</code>, <code id="kunif_+3A_max">max</code></td>
<td>
<p>lower and upper limits of the distribution.  Must be finite.</p>
</td></tr>
<tr><td><code id="kunif_+3A_k">k</code></td>
<td>
<p>k central moment, must be even</p>
</td></tr>
</table>


<h3>Value</h3>

<p>kth central moment
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dunif">dunif</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>kunif(-1,1,4)
y&lt;-runif(1000,-1,1)
mean((y-mean(y))^4)
</code></pre>

<hr>
<h2 id='list2bdiag'>Forms the direct sum from a list of matrices</h2><span id='topic+list2bdiag'></span>

<h3>Description</h3>

<p>Forms a block-diagonal matrix from a list of matrices</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2bdiag(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2bdiag_+3A_x">x</code></td>
<td>
<p>list of square matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>M&lt;-list(rIW(diag(3), 10), rIW(diag(2), 10))
list2bdiag(M)
</code></pre>

<hr>
<h2 id='MCMCglmm'>Multivariate Generalised Linear Mixed Models</h2><span id='topic+MCMCglmm'></span>

<h3>Description</h3>

<p>Markov chain Monte Carlo Sampler for Multivariate Generalised Linear Mixed 
Models with special emphasis on correlated random effects arising from pedigrees 
and phylogenies (Hadfield 2010). Please read the course notes: <code>vignette("CourseNotes", 
"MCMCglmm")</code> or the overview <code>vignette("Overview", "MCMCglmm")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCglmm(fixed, random=NULL, rcov=~units, family="gaussian", mev=NULL, 
    data,start=NULL, prior=NULL, tune=NULL, pedigree=NULL, nodes="ALL",
    scale=TRUE, nitt=13000, thin=10, burnin=3000, pr=FALSE,
    pl=FALSE, verbose=TRUE, DIC=TRUE, singular.ok=FALSE, saveX=TRUE,
    saveZ=TRUE, saveXL=TRUE, slice=FALSE, ginverse=NULL, trunc=FALSE, 
    theta_scale=NULL, saveWS=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCglmm_+3A_fixed">fixed</code></td>
<td>
<p><code><a href="stats.html#topic+formula">formula</a></code> for the fixed effects, multiple responses 
are passed as a matrix using cbind</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_random">random</code></td>
<td>
<p><code><a href="stats.html#topic+formula">formula</a></code> for the random effects. Multiple random terms can be passed using the <code>+</code> operator, and in the most general case each random term has the form <code>variance.function(formula):linking.function(random.terms)</code>. Currently, the only <code>variance.functions</code> available are <code>idv</code>, <code>idh</code>, <code>us</code>, <code>cor[]</code> and <code>ante[]</code>. <code>idv</code> fits a constant variance across all components in <code>formula</code>. Both <code>idh</code> and <code>us</code> fit different variances across each component in <code>formula</code>, but <code>us</code> will also fit the covariances. <code>corg</code> fixes the variances along the diagonal to one and <code>corgh</code> fixes the variances along the diagonal to those specified in the prior.  <code>cors</code> allows correlation submatrices. 
<code>ante[]</code> fits ante-dependence structures of different order (e.g ante1, ante2), and the number can be prefixed by a <code>c</code> to hold all regression coefficients of the same order equal. The number can also be suffixed by a <code>v</code> to hold all innovation variances equal (e.g <code>antec2v</code> has 3 parameters).  The <code>formula</code> can contain both factors and numeric terms (i.e. random regression) although it should be noted that the intercept term is suppressed.  The (co)variances are the (co)variances of the <code>random.terms</code> effects.  Currently, the only <code>linking.functions</code> available are <code>mm</code> and <code>str</code>. <code>mm</code> fits a multimembership model where multiple random terms are separated by the <code>+</code> operator. <code>str</code> allows covariances to exist between multiple random terms that are also separated by the <code>+</code> operator. In both cases the levels of all multiple random terms have to be the same.  For simpler models the <code>variance.function(formula)</code> and <code>linking.function(random.terms)</code> can be omitted and the model syntax has the simpler form <code>~random1+random2+...</code>.  There are two reserved variables: <code>units</code> which index rows of the response variable and <code>trait</code> which index columns of the response variable</p>
</td></tr> 
<tr><td><code id="MCMCglmm_+3A_rcov">rcov</code></td>
<td>
<p><code><a href="stats.html#topic+formula">formula</a></code> for residual covariance structure. This has to be set up so that each data point is associated with a unique residual. For example a multi-response model might have the R-structure defined by <code>~us(trait):units</code></p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_family">family</code></td>
<td>
<p>optional character vector of trait distributions. Currently, 
<code>"gaussian"</code>, <code>"poisson"</code>,  <code>"categorical"</code>,  
<code>"multinomial"</code>,  <code>"ordinal"</code>, <code>"threshold"</code>, <code>"exponential"</code>, <code>"geometric"</code>, <code>"cengaussian"</code>,  
<code>"cenpoisson"</code>,  <code>"cenexponential"</code>,  <code>"zipoisson"</code>, <code>"zapoisson"</code>, <code>"ztpoisson"</code>, <code>"hupoisson"</code>, <code>"zibinomial"</code>, <code>"threshold"</code>, <code>"nzbinom"</code> , <code>"ncst"</code>, <code>"msst"</code> , <code>"hubinomial"</code>, <code>"ztmb"</code> and <code>"ztmultinomial"</code> are supported, where the prefix <code>"cen"</code> means censored, the prefix <code>"zi"</code> means zero inflated, the prefix <code>"za"</code> means zero altered, the prefix <code>"zt"</code> means zero truncated and the prefix <code>"hu"</code> means hurdle. If <code>NULL</code>, <code>data</code> needs to contain a 
<code>family</code> column.</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_mev">mev</code></td>
<td>
<p>optional vector of measurement error variances for each data point 
for random effect meta-analysis.</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_data">data</code></td>
<td>
<p><code>data.frame</code></p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_start">start</code></td>
<td>
<p>optional list having 5 possible elements: 
<code>R</code> (R-structure) <code>G</code> (G-structure) and <code>liab</code> (latent variables or liabilities) should contain the starting values where <code>G</code> itself is also a list with as many elements as random effect components. The element <code>QUASI</code> should be logical: if <code>TRUE</code> starting latent variables are obtained heuristically, if <code>FALSE</code> then they are sampled from a Z-distribution. The element <code>r</code> should be be between -1 and 1 and determines the correlation between the starting latent variables and the ordered latent variables (ordered by the response variable): the default is 0.8.</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_prior">prior</code></td>
<td>
<p>optional list of prior specifications having 4 possible elements: 
<code>R</code> (R-structure) <code>G</code> (G-structure), <code>B</code> (fixed effects) and <code>S</code> (theta_scale parameter). <code>B</code> and <code>S</code> are lists containing the expected value (<code>mu</code>) and a 
(co)variance matrix (<code>V</code>) representing the strength of belief: the defaults are <code>B$mu</code>=<code>S$mu</code>=0 and <code>B$V</code>=<code>S$V</code>=I*1e+10, where where I is an identity matrix of appropriate dimension.  The priors for the variance structures (<code>R</code> and <code>G</code>) are lists with the expected (co)variances (<code>V</code>) and degree of belief parameter (<code>nu</code>) for the inverse-Wishart, and also the mean vector (<code>alpha.mu</code>) and covariance matrix (<code>alpha.V</code>) for the redundant working parameters. The defaults are <code>nu</code>=0, <code>V</code>=1, <code>alpha.mu</code>=0, and <code>alpha.V</code>=0. When <code>alpha.V</code> is non-zero, parameter expanded algorithms are used.</p>
</td></tr> 
<tr><td><code id="MCMCglmm_+3A_tune">tune</code></td>
<td>
<p>optional list with elements <code>mh_V</code> and/or <code>mh_weights</code> <code>mh_V</code> should be a list with as many elements as there are R-structure terms with each element being the (co)variance matrix defining the proposal distribution for the associated latent variables. If NULL an adaptive algorithm is used which ceases to adapt once the burn-in phase has finished. <code>mh_weights</code> should be equal to the number of latent variables and acts as a scaling factor for the proposal standard deviations.</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_pedigree">pedigree</code></td>
<td>
<p>ordered pedigree with 3 columns id, dam and sire or a 
<code>phylo</code> object. This argument is retained for back compatibility - see ginverse argument for a more general formulation.</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_nodes">nodes</code></td>
<td>
<p>pedigree/phylogeny nodes to be estimated. The default, 
<code>"ALL"</code> estimates effects for all individuals in a pedigree or nodes in a 
phylogeny (including ancestral nodes). For phylogenies <code>"TIPS"</code> estimates 
effects for the tips only, and for pedigrees a vector of ids can be passed to 
<code>nodes</code> specifying the subset of individuals for which animal effects are 
estimated.  Note that all analyses are equivalent if omitted nodes have missing 
data but by absorbing these nodes the chain max mix better. However, the 
algorithm may be less numerically stable and may iterate slower, especially for 
large phylogenies.</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_scale">scale</code></td>
<td>
<p>logical: should the phylogeny (needs to be ultrametric) be scaled 
to unit length (distance from root to tip)?</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_nitt">nitt</code></td>
<td>
<p>number of MCMC iterations</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_thin">thin</code></td>
<td>
<p>thinning interval</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_burnin">burnin</code></td>
<td>
<p>burnin</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_pr">pr</code></td>
<td>
<p>logical: should the posterior distribution of random effects be 
saved?</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_pl">pl</code></td>
<td>
<p>logical: should the posterior distribution of latent variables be 
saved?</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_verbose">verbose</code></td>
<td>
<p>logical: if <code>TRUE</code> MH diagnostics are printed to screen</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_dic">DIC</code></td>
<td>
<p>logical: if <code>TRUE</code> deviance and deviance information criterion are calculated</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical: if <code>FALSE</code> linear dependencies in the fixed effects are removed. if <code>TRUE</code> they are left in an estimated, although all information comes form the prior</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_savex">saveX</code></td>
<td>
<p>logical: save fixed effect design matrix</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_savez">saveZ</code></td>
<td>
<p>logical: save random effect design matrix</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_savexl">saveXL</code></td>
<td>
<p>logical: save structural parameter design matrix</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_slice">slice</code></td>
<td>
<p>logical: should slice sampling be used? Only applicable for binary traits with independent residuals</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_ginverse">ginverse</code></td>
<td>
<p>a list of sparse inverse matrices (<code class="reqn">{\bf A^{-1}}</code>) that are proportional to the covariance structure of the random effects. The names of the matrices should correspond to columns in <code>data</code> that are associated with the random term. All levels of the random term should appear as rownames for the matrices.</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_trunc">trunc</code></td>
<td>
<p>logical: should latent variables in binary models be truncated to prevent under/overflow (+/-20 for categorical/multinomial models and +/-7 for threshold/probit models)? </p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_theta_scale">theta_scale</code></td>
<td>
<p>optional list of 4 possible elements specifying a set of location effects (fixed or random) that are to be scaled by the parameter <code>theta_scale</code> for the subset of observations which have level <code>level</code> in factor <code>factor</code>: <code>factor</code>, <code>level</code>, <code>fixed</code> (position of fixed terms to be scaled) and <code>random</code> (position of random effect components).</p>
</td></tr>
<tr><td><code id="MCMCglmm_+3A_savews">saveWS</code></td>
<td>
<p>logical: save design matrix for scaled effects.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Sol</code></td>
<td>
<p>Posterior Distribution of MME solutions, including fixed effects</p>
</td></tr>
<tr><td><code>VCV</code></td>
<td>
<p>Posterior Distribution of (co)variance matrices</p>
</td></tr>
<tr><td><code>CP</code></td>
<td>
<p>Posterior Distribution of cut-points from an ordinal model</p>
</td></tr>
<tr><td><code>Liab</code></td>
<td>
<p>Posterior Distribution of latent variables</p>
</td></tr>
<tr><td><code>Fixed</code></td>
<td>
<p>list: fixed formula and number of fixed effects</p>
</td></tr>
<tr><td><code>Random</code></td>
<td>
<p>list: random formula, dimensions of each covariance matrix, number of levels per covariance matrix, and term in random formula to which each covariance belongs</p>
</td></tr>
<tr><td><code>Residual</code></td>
<td>
<p>list: residual formula, dimensions of each covariance matrix, number of levels per covariance matrix, and term in residual formula to which each covariance belongs</p>
</td></tr>
<tr><td><code>Deviance</code></td>
<td>
<p>deviance -2*log(p(y|...))</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>deviance information criterion</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>sparse fixed effect design matrix</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>sparse random effect design matrix</p>
</td></tr>
<tr><td><code>XL</code></td>
<td>
<p>sparse structural parameter design matrix</p>
</td></tr>
<tr><td><code>error.term</code></td>
<td>
<p>residual term for each datum</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>distribution of each datum</p>
</td></tr>
<tr><td><code>Tune</code></td>
<td>
<p>(co)variance matrix of the proposal distribution for the latent variables</p>
</td></tr>
<tr><td><code>meta</code></td>
<td>
<p>logical; was <code>mev</code> passed?</p>
</td></tr>
<tr><td><code>Wscale</code></td>
<td>
<p>sparse design matrix for scaled terms.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>References</h3>

<p>General analyses: Hadfield, J.D. (2010) Journal of Statistical Software 33 2 1-22
</p>
<p>Phylogenetic analyses: Hadfield, J.D. &amp; Nakagawa, S. (2010) Journal of Evolutionary Biology 23 494-508
</p>
<p>Background Sorensen, D. &amp; Gianola, D. (2002) Springer
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+mcmc">mcmc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1: univariate Gaussian model with standard random effect
 
data(PlodiaPO)  
model1&lt;-MCMCglmm(PO~1, random=~FSfamily, data=PlodiaPO, verbose=FALSE,
 nitt=1300, burnin=300, thin=1)
summary(model1)

# Example 2: univariate Gaussian model with phylogenetically correlated
# random effect

data(bird.families) 

phylo.effect&lt;-rbv(bird.families, 1, nodes="TIPS") 
phenotype&lt;-phylo.effect+rnorm(dim(phylo.effect)[1], 0, 1)  

# simulate phylogenetic and residual effects with unit variance

test.data&lt;-data.frame(phenotype=phenotype, taxon=row.names(phenotype))

Ainv&lt;-inverseA(bird.families)$Ainv

# inverse matrix of shared phyloegnetic history

prior&lt;-list(R=list(V=1, nu=0.002), G=list(G1=list(V=1, nu=0.002)))

model2&lt;-MCMCglmm(phenotype~1, random=~taxon, ginverse=list(taxon=Ainv),
 data=test.data, prior=prior, verbose=FALSE, nitt=1300, burnin=300, thin=1)

plot(model2$VCV)

</code></pre>

<hr>
<h2 id='me'>Design Matrix for Measurement Error Model</h2><span id='topic+me'></span>

<h3>Description</h3>

<p>Sets up design matrix for measurement error models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>me(formula, error=NULL, group=NULL, type="classical")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="me_+3A_formula">formula</code></td>
<td>
<p><code><a href="stats.html#topic+formula">formula</a></code> for the fixed effects.</p>
</td></tr>
<tr><td><code id="me_+3A_error">error</code></td>
<td>
<p>character; name of column in <code><a href="base.html#topic+data.frame">data.frame</a></code> in which standard error (<code>type="classical"</code> or <code>type="berkson"</code>) or miscalssification error  (<code>type="dclassical"</code>) is stored.</p>
</td></tr>
<tr><td><code id="me_+3A_group">group</code></td>
<td>
<p>name of column in <code><a href="base.html#topic+data.frame">data.frame</a></code> in which groups are stored. Rows of the design matrix with the same <code>group</code> level are assumed to pertain to the same obsevation of the covariate that is measured with error.</p>
</td></tr>
<tr><td><code id="me_+3A_type">type</code></td>
<td>
<p>character; one of <code>type="classical"</code>, <code>type="berkson"</code>, <code>type="dclassical"</code> or <code>type="dberkson"</code> (see details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>design matrix, with a prior distribution attribute 
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>

<hr>
<h2 id='mult.memb'>Design Matrices for Multiple Membership Models</h2><span id='topic+mult.memb'></span>

<h3>Description</h3>

<p>Forms design matrices for multiple membership models</p>


<h3>Usage</h3>

<pre><code class='language-R'>mult.memb(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mult.memb_+3A_formula">formula</code></td>
<td>
<p>formula</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently <code>mult.memb</code> can only usefully be used inside an <code>idv</code> variance function. The formula usually contains serveral factors that have the same factor levels.
</p>


<h3>Value</h3>

<p>design matrix
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>fac1&lt;-factor(sample(letters[1:3], 5, TRUE), levels=letters[1:3])
fac2&lt;-factor(sample(letters[1:3], 5, TRUE), levels=letters[1:3])
cbind(fac1, fac2)
mult.memb(~fac1+fac2)
</code></pre>

<hr>
<h2 id='path'>Design Matrix for Path Analyses</h2><span id='topic+path'></span>

<h3>Description</h3>

<p>Forms design matrix for path analyses that involve paths within residual blocks</p>


<h3>Usage</h3>

<pre><code class='language-R'>path(cause=NULL, effect=NULL, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_+3A_cause">cause</code></td>
<td>
<p>integer; index of predictor &lsquo;trait&rsquo; within residual block</p>
</td></tr>
<tr><td><code id="path_+3A_effect">effect</code></td>
<td>
<p>integer; index of response &lsquo;trait&rsquo; within residual block </p>
</td></tr>
<tr><td><code id="path_+3A_k">k</code></td>
<td>
<p>integer; dimension of residual block </p>
</td></tr>
</table>


<h3>Value</h3>

<p>design matrix 
</p>


<h3>Note</h3>

<p>For more general path anlaytic models see <a href="#topic+sir">sir</a> which allows paths to exist between responses that are not in the same residual block. However, <code>sir</code> does not handle non-Gaussian or missing responses. Note that path models involving non-Gaussian data are defined on the link scale which may not always be appropriate.
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><a href="#topic+sir">sir</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>path(1, 2,2)
</code></pre>

<hr>
<h2 id='pkk'>Probability that all multinomial categories have a non-zero count.</h2><span id='topic+pkk'></span>

<h3>Description</h3>

<p>Calculates the probability that all categories in a multinomial have a non-zero count.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkk(prob, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkk_+3A_prob">prob</code></td>
<td>
<p>numeric non-negative vector of length K, specifying the probability for the K classes; is internally normalized to sum 1. Infinite and missing values are not allowed.</p>
</td></tr>
<tr><td><code id="pkk_+3A_size">size</code></td>
<td>
<p>integer, say N, specifying the total number of objects that are put into K boxes in the typical multinomial experiment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>probability that there is at least one object in each of the K boxes
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>p&lt;-runif(4)
pkk(p, 10)
</code></pre>

<hr>
<h2 id='PlodiaPO'>Phenoloxidase measures on caterpillars of the Indian meal moth.</h2><span id='topic+PlodiaPO'></span>

<h3>Description</h3>

<p>Phenoloxidase measures on caterpillars of the Indian meal moth 
(<em>Plodia interpunctella</em>).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PlodiaPO)</code></pre>


<h3>Format</h3>

<p>a data frame with 511 rows and 3 columns, with variables indicating 
full-sib family (<code>FSfamily</code>), phenoloxidase measures (<code>PO</code>), and plate 
(<code>plate</code>). PO has undergone a Box-Cox power transformation of 0.141</p>


<h3>Source</h3>

<p>Tidbury H &amp; Boots M (2007) University of Sheffield</p>


<h3>See Also</h3>

<p><a href="#topic+PlodiaR">PlodiaR</a>, <a href="#topic+PlodiaRB">PlodiaRB</a></p>

<hr>
<h2 id='PlodiaR'>Resistance of Indian meal moth caterpillars to the granulosis virus 
PiGV.</h2><span id='topic+PlodiaR'></span>

<h3>Description</h3>

<p>Resistance of Indian meal moth (<em>Plodia interpunctella</em>) 
caterpillars to the granulosis virus PiGV.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PlodiaR)</code></pre>


<h3>Format</h3>

<p>a data frame with 50 rows and 5 columns, with variables indicating full-
sib family (<code>FSfamly</code>), date of egg laying (<code>date_laid</code>) and assaying 
(<code>date_Ass</code>), and the number of individuals from the family that were 
experimentally infected with the virus <code>Infected</code> and the number of those 
that pupated <code>Pupated</code>. These full-sib family identifiers also relate to 
the full-sib family identifiers in PlodiaPO</p>


<h3>Source</h3>

<p>Tidbury H &amp; Boots M (2007) University of Sheffield</p>


<h3>See Also</h3>

<p><a href="#topic+PlodiaRB">PlodiaRB</a>, <a href="#topic+PlodiaPO">PlodiaPO</a></p>

<hr>
<h2 id='PlodiaRB'>Resistance (as a binary trait) of Indian meal moth caterpillars to the 
granulosis virus PiGV.</h2><span id='topic+PlodiaRB'></span>

<h3>Description</h3>

<p>Resistance (as a binary trait) of Indian meal moth (<em>Plodia 
interpunctella</em>) caterpillars to the granulosis virus PiGV.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PlodiaRB)</code></pre>


<h3>Format</h3>

<p>a data frame with 784 rows and 4 columns, with variables indicating full-
sib family (<code>FSfamly</code>), date of egg laying (<code>date_laid</code>) and assaying 
(<code>date_Ass</code>), and a binary variable indicating whether an individual was 
resistant (<code>Pupated</code>) to an experimental infection of the virus. These data 
are identical to those in the data.frame <code>PlodiaR</code> except each family-level 
binomial variable has been expanded into a binary variable for each individual.</p>


<h3>Source</h3>

<p>Tidbury H &amp; Boots M (2007) University of Sheffield</p>


<h3>See Also</h3>

<p><a href="#topic+PlodiaR">PlodiaR</a>, <a href="#topic+PlodiaPO">PlodiaPO</a></p>

<hr>
<h2 id='plot.MCMCglmm'>Plots MCMC chains from MCMCglmm using plot.mcmc</h2><span id='topic+plot.MCMCglmm'></span>

<h3>Description</h3>

<p><code>plot</code> method for class <code>"MCMCglmm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCMCglmm'
plot(x, random=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.MCMCglmm_+3A_x">x</code></td>
<td>
<p>an object of class <code>"MCMCglmm"</code></p>
</td></tr>
<tr><td><code id="plot.MCMCglmm_+3A_random">random</code></td>
<td>
<p>logical; should saved random effects be plotted</p>
</td></tr>
<tr><td><code id="plot.MCMCglmm_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code>plot.mcmc</code>, <code><a href="#topic+MCMCglmm">MCMCglmm</a></code></p>

<hr>
<h2 id='plotsubspace'>Plots covariance matrices</h2><span id='topic+plotsubspace'></span>

<h3>Description</h3>

<p>Represents covariance matrices as 3-d ellipsoids using the <code>rgl</code> package. 
Covariance matrices of dimension greater than 3 are plotted on the subspace 
defined by the first three eigenvectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  plotsubspace(CA, CB=NULL, corr = FALSE, shadeCA = TRUE, 
      shadeCB = TRUE, axes.lab = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotsubspace_+3A_ca">CA</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="plotsubspace_+3A_cb">CB</code></td>
<td>
<p>Optional second matrix</p>
</td></tr>
<tr><td><code id="plotsubspace_+3A_corr">corr</code></td>
<td>
<p>If <code>TRUE</code> the covariance matrices are transformed into 
correlation matrices</p>
</td></tr>
<tr><td><code id="plotsubspace_+3A_shadeca">shadeCA</code></td>
<td>
<p>If <code>TRUE</code> the ellipsoid is solid, if <code>FALSE</code> the 
ellipsoid is wireframe</p>
</td></tr>
<tr><td><code id="plotsubspace_+3A_shadecb">shadeCB</code></td>
<td>
<p>If <code>TRUE</code> the ellipsoid is solid, if <code>FALSE</code> the 
ellipsoid is wireframe</p>
</td></tr>
<tr><td><code id="plotsubspace_+3A_axes.lab">axes.lab</code></td>
<td>
<p>If <code>TRUE</code> the axes are labelled with the eigenvectors</p>
</td></tr>
<tr><td><code id="plotsubspace_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix CA is always red, and the matrix CB if given is always blue. The 
subspace is defined by the first three eigenvectors of CA, and the percentage of 
variance for each matrix along these three dimensions is given in the plot 
title. 
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a> with code taken from the <code>rgl</code> package</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+rgl">rgl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> if(requireNamespace("rgl")!=FALSE){
   G1&lt;-rIW(diag(4),10)
   G2&lt;-G1*1.2
 #  plotsubspace(G1, G2, shadeCB=FALSE)
 # commented out because of problems with rgl 
 } 
</code></pre>

<hr>
<h2 id='posterior.ante'>Posterior distribution of ante-dependence parameters</h2><span id='topic+posterior.ante'></span>

<h3>Description</h3>

<p>Posterior distribution of ante-dependence parameters</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior.ante(x,k=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior.ante_+3A_x">x</code></td>
<td>
<p>mcmc object of (co)variances stacked column-wise</p>
</td></tr>
<tr><td><code id="posterior.ante_+3A_k">k</code></td>
<td>
<p>order of the ante-dependence structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>posterior ante-dependence parameters (innovation variances followed by regression ceofficients)
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior.cor">posterior.cor</a></code>, <code><a href="#topic+posterior.evals">posterior.evals</a></code>, <code><a href="#topic+posterior.inverse">posterior.inverse</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>v&lt;-rIW(diag(2),10, n=1000)
plot(posterior.ante(mcmc(v),1))
</code></pre>

<hr>
<h2 id='posterior.cor'>Transforms posterior distribution of covariances into correlations</h2><span id='topic+posterior.cor'></span>

<h3>Description</h3>

<p>Transforms posterior distribution of covariances into correlations</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior.cor(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior.cor_+3A_x">x</code></td>
<td>
<p>mcmc object of (co)variances stacked column-wise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>posterior correlation matrices
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior.evals">posterior.evals</a></code>, <code><a href="#topic+posterior.inverse">posterior.inverse</a></code>, <code><a href="#topic+posterior.ante">posterior.ante</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>v&lt;-rIW(diag(2),3, n=1000)
hist(posterior.cor(mcmc(v))[,2])
</code></pre>

<hr>
<h2 id='posterior.evals'>Posterior distribution of eigenvalues</h2><span id='topic+posterior.evals'></span>

<h3>Description</h3>

<p>Posterior distribution of eigenvalues</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior.evals(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior.evals_+3A_x">x</code></td>
<td>
<p>mcmc object of (co)variances stacked column-wise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>posterior eigenvalues
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior.cor">posterior.cor</a></code>, <code><a href="#topic+posterior.inverse">posterior.inverse</a></code>, <code><a href="#topic+posterior.ante">posterior.ante</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>v&lt;-rIW(diag(2),3, n=1000)
hist(posterior.evals(mcmc(v))[,2])
</code></pre>

<hr>
<h2 id='posterior.inverse'>Posterior distribution of matrix inverse</h2><span id='topic+posterior.inverse'></span>

<h3>Description</h3>

<p>Posterior distribution of matrix inverse</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior.inverse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior.inverse_+3A_x">x</code></td>
<td>
<p>mcmc object of (co)variances stacked column-wise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>posterior of inverse (co)variance matrices
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior.cor">posterior.cor</a></code>, <code><a href="#topic+posterior.evals">posterior.evals</a></code>, <code><a href="#topic+posterior.ante">posterior.ante</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>v&lt;-rIW(diag(2),3, n=1000)
plot(posterior.inverse(mcmc(v)))
</code></pre>

<hr>
<h2 id='posterior.mode'>Estimates the marginal parameter modes using kernel density estimation</h2><span id='topic+posterior.mode'></span>

<h3>Description</h3>

<p>Estimates the marginal parameter modes using kernel density estimation</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior.mode(x, adjust=0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior.mode_+3A_x">x</code></td>
<td>
<p>mcmc object</p>
</td></tr>
<tr><td><code id="posterior.mode_+3A_adjust">adjust</code></td>
<td>
<p>numeric, passed to <code><a href="stats.html#topic+density">density</a></code> to adjust the bandwidth of the kernal density</p>
</td></tr>
<tr><td><code id="posterior.mode_+3A_...">...</code></td>
<td>
<p>other arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modes of the kernel density estimates
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>v&lt;-rIW(as.matrix(1),10, n=1000)
hist(v)
abline(v=posterior.mode(mcmc(v)), col="red")
</code></pre>

<hr>
<h2 id='predict.MCMCglmm'>Predict method for GLMMs fitted with MCMCglmm</h2><span id='topic+predict.MCMCglmm'></span>

<h3>Description</h3>

<p>Predicted values for GLMMs fitted with MCMCglmm</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCMCglmm'
predict(object, newdata=NULL, marginal=object$Random$formula,
        type="response", interval="none", level=0.95, it=NULL, 
        posterior="all", verbose=FALSE, approx="numerical", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.MCMCglmm_+3A_object">object</code></td>
<td>
<p>an object of class <code>"MCMCglmm"</code></p>
</td></tr>
<tr><td><code id="predict.MCMCglmm_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with which to predict</p>
</td></tr>
<tr><td><code id="predict.MCMCglmm_+3A_marginal">marginal</code></td>
<td>
<p>formula defining random effects to be maginalised</p>
</td></tr>
<tr><td><code id="predict.MCMCglmm_+3A_type">type</code></td>
<td>
<p>character; either &quot;terms&quot; (link scale) or &quot;response&quot; (data scale)</p>
</td></tr>
<tr><td><code id="predict.MCMCglmm_+3A_interval">interval</code></td>
<td>
<p>character; either &quot;none&quot;, &quot;confidence&quot; or &quot;prediction&quot;</p>
</td></tr>
<tr><td><code id="predict.MCMCglmm_+3A_level">level</code></td>
<td>
<p>A numeric scalar in the interval (0,1) giving the target probability content of the intervals.</p>
</td></tr>
<tr><td><code id="predict.MCMCglmm_+3A_it">it</code></td>
<td>
<p>integer; optional, MCMC iteration on which predictions should be based</p>
</td></tr>
<tr><td><code id="predict.MCMCglmm_+3A_posterior">posterior</code></td>
<td>
<p>character; should marginal posterior predictions be calculated (&quot;all&quot;), or should they be made conditional on the marginal posterior means (&quot;mean&quot;) of the parameters, the posterior modes (&quot;mode&quot;), or a random draw from the posterior (&quot;distribution&quot;).</p>
</td></tr>
<tr><td><code id="predict.MCMCglmm_+3A_verbose">verbose</code></td>
<td>
<p>logical;  if <code>TRUE</code>, warnings are issued with newdata when the original model has fixed effects that do not appear in newdata and/or newdata has random effects not present in the original model.</p>
</td></tr>
<tr><td><code id="predict.MCMCglmm_+3A_approx">approx</code></td>
<td>
<p>character; for distributions for which the mean cannot be calculated analytically what approximation should be used: numerical integration (<code>numerical</code>; slow), second order Taylor expansion (<code>taylor2</code>) and for logistic models approximations presented in Diggle (2004) (<code>diggle</code>) and McCulloch and Searle (2001) (<code>mcculloch</code>)</p>
</td></tr>
<tr><td><code id="predict.MCMCglmm_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Expectation and credible interval</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>References</h3>

<p>Diggle P, et al. (2004). Analysis of Longitudinal Data. 2nd Edition. Oxford University Press.
</p>
<p>McCulloch CE and Searle SR (2001). Generalized, Linear and Mixed Models. John Wiley &amp; Sons, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCglmm">MCMCglmm</a></code></p>

<hr>
<h2 id='prunePed'>Pedigree pruning</h2><span id='topic+prunePed'></span>

<h3>Description</h3>

<p>Creates a subset of a pedigree by retaining the ancestors of a specified subset 
of individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prunePed(pedigree, keep, make.base=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prunePed_+3A_pedigree">pedigree</code></td>
<td>
<p>pedigree with id in column 1 dam in column 2 and sire in 
column 3</p>
</td></tr>
<tr><td><code id="prunePed_+3A_keep">keep</code></td>
<td>
<p>individuals in pedigree for which the ancestors should be 
retained</p>
</td></tr>
<tr><td><code id="prunePed_+3A_make.base">make.base</code></td>
<td>
<p>logical: should ancestors that do not provide additional information be discarded?</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>subsetted pedigree
</p>


<h3>Note</h3>

<p>If the individuals in <code>keep</code> are the only phenotyped individuals for some analysis then some non-phenotyped individuals can often be discarded if they are not responsible for pedigree links between phenotyped individuals.  In the simplest case (<code>make.base=FALSE</code>) all ancestors of phenotyped individuals will be retained, although further pruning may be possible using <code>make.base=TRUE</code>. In this case all pedigree links that do not connect phenotyped individuals are discarded resulting in some individuals becoming part of the base population. In terms of variance component and fixed effect estimation pruning the pedigree should have no impact on the target posterior distribution, although convergence and mixing may be better because there is less missing data. 
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a> + Michael Morrissey</p>

<hr>
<h2 id='Ptensor'>Tensor of Sample (Mixed) Central Moments</h2><span id='topic+Ptensor'></span>

<h3>Description</h3>

<p>Forms a tensor of sample (mixed) central moments</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ptensor(x, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ptensor_+3A_x">x</code></td>
<td>
<p>matrix; traits in columns samples in rows</p>
</td></tr>
<tr><td><code id="Ptensor_+3A_k">k</code></td>
<td>
<p>kth central moment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tensor
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-1000
y&lt;-matrix(rnorm(n), n/2, 2)
Ptensor(y,2)
cov(y)*((n-1)/n)
</code></pre>

<hr>
<h2 id='rbv'>Random Generation of MVN Breeding Values and Phylogenetic Effects</h2><span id='topic+rbv'></span>

<h3>Description</h3>

<p>Random Generation of MVN Breeding Values and Phylogenetic Effects</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbv(pedigree, G, nodes="ALL", scale=TRUE, ggroups=NULL, gmeans=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbv_+3A_pedigree">pedigree</code></td>
<td>
<p>ordered pedigree with 3 columns id, dam and sire or a 
<code>phylo</code> object.</p>
</td></tr>
<tr><td><code id="rbv_+3A_g">G</code></td>
<td>
<p>(co)variance matrix</p>
</td></tr>
<tr><td><code id="rbv_+3A_nodes">nodes</code></td>
<td>
<p>effects for pedigree/phylogeny nodes to be returned. The default, 
<code>nodes="ALL"</code> returns effects for all individuals in a pedigree or nodes in 
a phylogeny (including ancestral nodes). For phylogenies <code>nodes="TIPS"</code> 
returns effects for the tips only, and for pedigrees a vector of ids can be 
passed to <code>nodes</code> specifying the subset of individuals for which animal 
effects are returned.</p>
</td></tr>
<tr><td><code id="rbv_+3A_scale">scale</code></td>
<td>
<p>logical: should a phylogeny (needs to be ultrametric) be scaled to 
unit length (distance from root to tip)?</p>
</td></tr>
<tr><td><code id="rbv_+3A_ggroups">ggroups</code></td>
<td>
<p>optional; vector of genetic groups</p>
</td></tr>
<tr><td><code id="rbv_+3A_gmeans">gmeans</code></td>
<td>
<p>matrix of mean breeding value for genetic groups (rows) by traits (columns)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of breeding values/phylogenetic effects
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.families)
bv&lt;-rbv(bird.families, diag(2))
</code></pre>

<hr>
<h2 id='residuals.MCMCglmm'>Residuals form a GLMM fitted with MCMCglmm</h2><span id='topic+residuals.MCMCglmm'></span>

<h3>Description</h3>

<p><code>residuals</code> method for class <code>"MCMCglmm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCMCglmm'
residuals(object, type = c("deviance", "pearson", "working",
                                "response", "partial"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.MCMCglmm_+3A_object">object</code></td>
<td>
<p>an object of class <code>"MCMCglmm"</code></p>
</td></tr>
<tr><td><code id="residuals.MCMCglmm_+3A_type">type</code></td>
<td>
<p> the type of residuals which should be returned. The alternatives are: <code>"deviance"</code> (default), <code>"pearson"</code>,<code>"working"</code>, <code>"response"</code>, and <code>"partial"</code>.</p>
</td></tr>
<tr><td><code id="residuals.MCMCglmm_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of residuals
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="#topic+MCMCglmm">MCMCglmm</a></code></p>

<hr>
<h2 id='rIW'>Random Generation from the Conditional Inverse Wishart Distribution</h2><span id='topic+rIW'></span>

<h3>Description</h3>

<p>Samples from the inverse Wishart distribution, with the possibility 
of conditioning on a diagonal submatrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>rIW(V, nu, fix=NULL, n=1, CM=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rIW_+3A_v">V</code></td>
<td>
<p>Expected (co)varaince matrix as <code>nu</code> tends to infinity</p>
</td></tr>
<tr><td><code id="rIW_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="rIW_+3A_fix">fix</code></td>
<td>
<p>optional integer indexing the partition to be conditioned on</p>
</td></tr>
<tr><td><code id="rIW_+3A_n">n</code></td>
<td>
<p>integer: number of samples to be drawn</p>
</td></tr>
<tr><td><code id="rIW_+3A_cm">CM</code></td>
<td>
<p>matrix: optional matrix to condition on. If not given, and <code>fix!=NULL</code>,  V_22 is conditioned on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">{\bf W^{-1}}</code> is a draw from the inverse Wishart,  <code>fix</code> indexes the diagonal element of <code class="reqn">{\bf W^{-1}}</code>  which partitions <code class="reqn">{\bf W^{-1}}</code> into 4 submatrices. <code>fix</code> indexes the upper left corner of the lower 
diagonal matrix and it is this matrix that is conditioned on.
</p>
<p>For example partioning <code class="reqn">{\bf W^{-1}}</code> such that 
</p>
<p style="text-align: center;"><code class="reqn">
{\bf W^{-1}} = \left[
             \begin{array}{cc}
		      {\bf W^{-1}}_{11}&amp;{\bf W^{-1}}_{12}\\
			   {\bf W^{-1}}_{21}&amp;{\bf W^{-1}}_{22}\\
             \end{array}
		   \right]
  </code>
</p>


<p>fix indexes the upper left corner of <code class="reqn">{\bf W^{-1}}_{22}</code>. If <code>CM!=NULL</code> then <code class="reqn">{\bf W^{-1}}_{22}</code> is fixed at <code>CM</code>, otherwise <code class="reqn">{\bf W^{-1}}_{22}</code> is fixed at  <code class="reqn">\texttt{V}_{22}</code>. For example, if <code>dim(V)</code>=4 and <code>fix=2</code> then <code class="reqn">{\bf W^{-1}}_{11}</code> is a 1X1 matrix and <code class="reqn">{\bf W^{-1}}_{22}</code>  is a 3X3 matrix.
</p>


<h3>Value</h3>

<p>if <code>n</code> = 1 a matrix equal in dimension to <code>V</code>, if <code>n</code>&gt;1 a 
matrix of dimension <code>n</code> x <code>length(V)</code>
</p>


<h3>Note</h3>

<p>In versions of MCMCglmm &gt;1.10 the arguments to <code>rIW</code> have changed so that they are more intuitive in the context of <code><a href="#topic+MCMCglmm">MCMCglmm</a></code>.  Following the notation of Wikipedia (<a href="https://en.wikipedia.org/wiki/Inverse-Wishart_distribution">https://en.wikipedia.org/wiki/Inverse-Wishart_distribution</a>) the inverse scale matrix <code class="reqn">{\bm \Psi}=(\texttt{V*nu})</code>. In earlier versions of MCMCglmm (&lt;1.11) <code class="reqn">{\bm \Psi} = \texttt{V}^{-1}</code>. Although the old parameterisation is consistent with the <code><a href="MCMCpack.html#topic+riwish">riwish</a></code> function in MCMCpack and the <code><a href="bayesm.html#topic+rwishart">rwishart</a></code> function in bayesm it is inconsistent with the prior definition for <code><a href="#topic+MCMCglmm">MCMCglmm</a></code>.  The following pieces of code are sampling from the same distributions: 
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="MCMCpack.html#topic+riwish">riwish</a>(nu, nu*V)</code> </td><td style="text-align: left;"> from MCMCpack</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="bayesm.html#topic+rwishart">rwishart</a>(nu, solve(nu*V))$IW</code> </td><td style="text-align: left;"> from bayesm</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rIW(nu, solve(nu*V))</code> </td><td style="text-align: left;"> from MCMCglmm &lt;1.11</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rIW(V, nu)</code> </td><td style="text-align: left;"> from MCMCglmm &gt;=1.11</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>References</h3>

<p>Korsgaard, I.R. et. al. 1999 Genetics Selection Evolution 31 (2) 
177:181</p>


<h3>See Also</h3>

<p><code><a href="bayesm.html#topic+rwishart">rwishart</a></code>, <code><a href="MCMCpack.html#topic+rwish">rwish</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>nu&lt;-10
V&lt;-diag(4)
rIW(V, nu, fix=2)
</code></pre>

<hr>
<h2 id='rtcmvnorm'>Random Generation from a Truncated Conditional Normal Distribution</h2><span id='topic+rtcmvnorm'></span>

<h3>Description</h3>

<p>Samples from the Truncated Conditional Normal Distribution</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtcmvnorm(n = 1, mean = 0, V = 1, x=0, keep=1, lower = -Inf, upper = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtcmvnorm_+3A_n">n</code></td>
<td>
<p>integer: number of samples to be drawn</p>
</td></tr>
<tr><td><code id="rtcmvnorm_+3A_mean">mean</code></td>
<td>
<p>vector of means</p>
</td></tr>
<tr><td><code id="rtcmvnorm_+3A_v">V</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="rtcmvnorm_+3A_x">x</code></td>
<td>
<p>vector of observations to condition on</p>
</td></tr>
<tr><td><code id="rtcmvnorm_+3A_keep">keep</code></td>
<td>
<p>element of x to be sampled</p>
</td></tr>
<tr><td><code id="rtcmvnorm_+3A_lower">lower</code></td>
<td>
<p>left truncation point</p>
</td></tr>
<tr><td><code id="rtcmvnorm_+3A_upper">upper</code></td>
<td>
<p>right truncation point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector 
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow=c(2,1))
V1&lt;-cbind(c(1,0.5), c(0.5,1))
x1&lt;-rtcmvnorm(10000, c(0,0), V=V1, c(0,2), keep=1, lower=-1, upper=1)
x2&lt;-rtnorm(10000, 0, 1, lower=-1, upper=1)
plot(density(x1), main="Correlated conditioning observation")
lines(density(x2), col="red")
# denisties of conditional (black) and unconditional (red) distribution
# when the two variables are correlated (r=0.5) 

V2&lt;-diag(2)
x3&lt;-rtcmvnorm(10000, c(0,0), V=V2, c(0,2), keep=1, lower=-1, upper=1)
x4&lt;-rtnorm(10000, 0, 1, lower=-1, upper=1)
plot(density(x3), main="Uncorrelated conditioning observation")
lines(density(x4), col="red")
# denisties of conditional (black) and unconditional (red) distribution
# when the two variables are uncorrelated (r=0) 

</code></pre>

<hr>
<h2 id='rtnorm'>Random Generation from a Truncated Normal Distribution</h2><span id='topic+rtnorm'></span>

<h3>Description</h3>

<p>Samples from the Truncated Normal Distribution</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtnorm(n = 1, mean = 0, sd = 1, lower = -Inf, upper = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtnorm_+3A_n">n</code></td>
<td>
<p>integer: number of samples to be drawn</p>
</td></tr>
<tr><td><code id="rtnorm_+3A_mean">mean</code></td>
<td>
<p>vector of means</p>
</td></tr>
<tr><td><code id="rtnorm_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations</p>
</td></tr>
<tr><td><code id="rtnorm_+3A_lower">lower</code></td>
<td>
<p>left truncation point</p>
</td></tr>
<tr><td><code id="rtnorm_+3A_upper">upper</code></td>
<td>
<p>right truncation point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector 
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>References</h3>

<p>Robert, C.P. (1995) Statistics &amp; Computing 5 121-125</p>


<h3>See Also</h3>

<p><code><a href="msm.html#topic+rtnorm">rtnorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>hist(rtnorm(100, lower=-1, upper=1))
</code></pre>

<hr>
<h2 id='simulate.MCMCglmm'>Simulate method for GLMMs fitted with MCMCglmm</h2><span id='topic+simulate.MCMCglmm'></span>

<h3>Description</h3>

<p>Simulated response vectors for GLMMs fitted with MCMCglmm</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCMCglmm'
simulate(object, nsim = 1, seed = NULL, newdata=NULL, marginal = object$Random$formula, 
          type = "response", it=NULL, posterior = "all", verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.MCMCglmm_+3A_object">object</code></td>
<td>
<p>an object of class <code>"MCMCglmm"</code></p>
</td></tr>
<tr><td><code id="simulate.MCMCglmm_+3A_nsim">nsim</code></td>
<td>
<p>number of response vectors to simulate.  Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="simulate.MCMCglmm_+3A_seed">seed</code></td>
<td>
<p>Either <code>NULL</code> or an integer that will be used in a call to <code>set.seed</code> before simulating the response vectors.  The default, <code>NULL</code> will not change the random generator state.</p>
</td></tr>
<tr><td><code id="simulate.MCMCglmm_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame for which to simulate new observations</p>
</td></tr>
<tr><td><code id="simulate.MCMCglmm_+3A_marginal">marginal</code></td>
<td>
<p>formula defining random effects to be maginalised</p>
</td></tr>
<tr><td><code id="simulate.MCMCglmm_+3A_type">type</code></td>
<td>
<p>character; either &quot;terms&quot; (link scale) or &quot;response&quot; (data scale)</p>
</td></tr>
<tr><td><code id="simulate.MCMCglmm_+3A_it">it</code></td>
<td>
<p>integer; optional, MCMC iteration on which predictions should be based</p>
</td></tr>
<tr><td><code id="simulate.MCMCglmm_+3A_posterior">posterior</code></td>
<td>
<p>character; if <code>it</code> is  <code>NULL</code> should the response vector be simulated using the marginal posterior means (&quot;mean&quot;) of the parameters, or the  posterior modes (&quot;mode&quot;), random draws from the posterior with replacement (&quot;distribution&quot;) or  without replacement (&quot;all&quot;)</p>
</td></tr>
<tr><td><code id="simulate.MCMCglmm_+3A_verbose">verbose</code></td>
<td>
<p>logical;  if <code>TRUE</code>, warnings are issued with newdata when the original model has fixed effects that do not appear in newdata and/or newdata has random effects not present in the original model.</p>
</td></tr>
<tr><td><code id="simulate.MCMCglmm_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (with nsim columns) of simulated response vectors</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCglmm">MCMCglmm</a></code></p>

<hr>
<h2 id='sir'>Design Matrix for Simultaneous and Recursive Relationships between Responses</h2><span id='topic+sir'></span>

<h3>Description</h3>

<p>Forms design matrix for simultaneous and recursive relationships between responses</p>


<h3>Usage</h3>

<pre><code class='language-R'>sir(formula1=NULL, formula2=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sir_+3A_formula1">formula1</code></td>
<td>
<p>formula</p>
</td></tr>
<tr><td><code id="sir_+3A_formula2">formula2</code></td>
<td>
<p>formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>design matrix 
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>fac1&lt;-factor(sample(letters[1:3], 5, TRUE), levels=letters[1:3])
fac2&lt;-factor(sample(letters[1:3], 5, TRUE), levels=letters[1:3])
cbind(fac1, fac2)
sir(~fac1, ~fac2)

</code></pre>

<hr>
<h2 id='sm2asreml'>Converts sparseMatrix to asreml's giv format</h2><span id='topic+sm2asreml'></span>

<h3>Description</h3>

<p>Converts sparseMatrix to asreml's giv format: row-ordered, upper triangle 
sparse matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm2asreml(A=NULL, rownames=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sm2asreml_+3A_a">A</code></td>
<td>
<p>sparseMatrix</p>
</td></tr>
<tr><td><code id="sm2asreml_+3A_rownames">rownames</code></td>
<td>
<p>rownames of A</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame: if <code>A</code> was formed from a pedigree equivalent to giv format 
returned by <code>asreml.Ainverse</code>
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p>inverseA</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bird.families)
A&lt;-inverseA(bird.families)
Aasreml&lt;-sm2asreml(A$Ainv, A$node.names)
</code></pre>

<hr>
<h2 id='spl'>Orthogonal Spline Design Matrix</h2><span id='topic+spl'></span>

<h3>Description</h3>

<p>Orthogonal Spline Design Matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>spl(x,  k=10, knots=NULL, type="LRTP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spl_+3A_x">x</code></td>
<td>
<p>a numeric covariate</p>
</td></tr>
<tr><td><code id="spl_+3A_k">k</code></td>
<td>
<p>integer, defines knot points at the 1:k/(k+1) quantiles of x</p>
</td></tr>
<tr><td><code id="spl_+3A_knots">knots</code></td>
<td>
<p>vector of knot points</p>
</td></tr>
<tr><td><code id="spl_+3A_type">type</code></td>
<td>
<p>type of spline - currently only low-rank thin-plate (&quot;LRTP&quot;) are implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Design matrix post-multiplied by the inverse square root of the penalty matrix 
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x&lt;-rnorm(100)
y&lt;-x^2+cos(x)-x+0.2*x^3+rnorm(100)
plot(y~x)
lines((x^2+cos(x)-x+0.2*x^3)[order(x)]~sort(x))

dat&lt;-data.frame(y=y, x=x)

m1&lt;-MCMCglmm(y~x, random=~idv(spl(x)), data=dat, pr=TRUE, verbose=FALSE) # penalised smoother
m2&lt;-MCMCglmm(y~x+spl(x),data=dat,  verbose=FALSE)                        # non-penalised

pred1&lt;-(cbind(m1$X,m1$Z)%*%colMeans(m1$Sol))@x
pred2&lt;-(cbind(m2$X)%*%colMeans(m2$Sol))@x

lines(pred1[order(x)]~sort(x), col="red")
lines(pred2[order(x)]~sort(x), col="green")

m1$DIC-mean(m1$Deviance)  # effective number of parameters &lt; 13
m2$DIC-mean(m2$Deviance)  # effective number of parameters ~ 13

## End(Not run)
</code></pre>

<hr>
<h2 id='SShorns'>Horn type and genders of Soay Sheep</h2><span id='topic+SShorns'></span>

<h3>Description</h3>

<p>Horn type and genders of Soay Sheep <em>Ovis aires</em></p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SShorns)</code></pre>


<h3>Format</h3>

<p>a data frame with 666 rows and 3 columns, with individual idenitifier (<code>id</code>), horn type (<code>horn</code>) and gender (<code>sex</code>).</p>


<h3>References</h3>

<p>Clutton-Brock T., Pemberton, J. Eds. 2004 Soay Sheep: Dynamics and Selection in an Island Population
</p>

<hr>
<h2 id='summary.MCMCglmm'>Summarising GLMM Fits from MCMCglmm</h2><span id='topic+summary.MCMCglmm'></span><span id='topic+print.summary.MCMCglmm'></span><span id='topic+print.MCMCglmm'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"MCMCglmm"</code>. The returned object is suitable for printing with the <code>print.summary.MCMCglmm</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCMCglmm'
summary(object, random=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.MCMCglmm_+3A_object">object</code></td>
<td>
<p>an object of class <code>"MCMCglmm"</code></p>
</td></tr>
<tr><td><code id="summary.MCMCglmm_+3A_random">random</code></td>
<td>
<p>logical: should the random effects be summarised</p>
</td></tr>
<tr><td><code id="summary.MCMCglmm_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>DIC</code></td>
<td>
<p>Deviance Information Criterion</p>
</td></tr>  
<tr><td><code>fixed.formula</code></td>
<td>
<p>model formula for the fixed terms</p>
</td></tr>
<tr><td><code>random.formula</code></td>
<td>
<p>model formula for the random terms</p>
</td></tr>
<tr><td><code>residual.formula</code></td>
<td>
<p>model formula for the residual terms</p>
</td></tr>
<tr><td><code>solutions</code></td>
<td>
<p>posterior mean, 95% HPD interval, MCMC p-values and effective sample size of fixed (and random) effects</p>
</td></tr>
<tr><td><code>Gcovariances</code></td>
<td>
<p>posterior mean, 95% HPD interval and effective sample size of random effect (co)variance components</p>
</td></tr>
<tr><td><code>Gterms</code></td>
<td>
<p>indexes random effect (co)variances by the component terms defined in the random formula</p>
</td></tr>
<tr><td><code>Rcovariances</code></td>
<td>
<p>posterior mean, 95% HPD interval and effective sample size of residual (co)variance components</p>
</td></tr>
<tr><td><code>Rterms</code></td>
<td>
<p>indexes residuals (co)variances by the component terms defined in the rcov formula</p>
</td></tr>
<tr><td><code>csats</code></td>
<td>
<p>chain length, burn-in and thinning interval</p>
</td></tr>
<tr><td><code>cutpoints</code></td>
<td>
<p>posterior mean, 95% HPD interval and effective sample size of cut-points from an ordinal model</p>
</td></tr>
<tr><td><code>theta_scale</code></td>
<td>
<p>posterior mean, 95% HPD interval, MCMC p-values and effective sample size of scaling parameter in theta_scale models.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+MCMCglmm">MCMCglmm</a></code></p>

<hr>
<h2 id='Tri2M'>Lower/Upper Triangle Elements of a Matrix</h2><span id='topic+Tri2M'></span>

<h3>Description</h3>

<p>Lower/Upper triangle elements of a matrix or forms a matrix from a vector of 
lower/upper triangle elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tri2M(x, lower.tri = TRUE, reverse = TRUE, diag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tri2M_+3A_x">x</code></td>
<td>
<p>Matrix or vector</p>
</td></tr>
<tr><td><code id="Tri2M_+3A_lower.tri">lower.tri</code></td>
<td>
<p>If <code>x</code> is a matrix then the lower triangle (<code>TRUE</code>) 
or upper triangle <code>FALSE</code> elements (including diagonal elements) are 
returned. If <code>x</code> is a vector a matrix is formed under the assumption that 
<code>x</code> are the lower triangle (<code>TRUE</code>) or upper triangle (<code>FALSE</code>) 
elements.</p>
</td></tr>
<tr><td><code id="Tri2M_+3A_reverse">reverse</code></td>
<td>
<p>logical: if<code>TRUE</code> a symmetric matrix is formed, if 
<code>FALSE</code> the remaining triangle is left as zeros.</p>
</td></tr>
<tr><td><code id="Tri2M_+3A_diag">diag</code></td>
<td>
<p>logical: if<code>TRUE</code> diagonal elements are included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric or matrix
</p>


<h3>Author(s)</h3>

<p>Jarrod Hadfield <a href="mailto:j.hadfield@ed.ac.uk">j.hadfield@ed.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>M&lt;-rIW(diag(3), 10)
x&lt;-Tri2M(M)
x
Tri2M(x, reverse=TRUE)
Tri2M(x, reverse=FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
