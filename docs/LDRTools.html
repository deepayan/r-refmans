<!DOCTYPE html><html><head><title>Help for package LDRTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LDRTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AOP'>
<p>Function to Average Orthogonal Projection Matrices</p></a></li>
<li><a href='#B2P'>
<p>Function to Compute an Orthogonal Projection Matrix Based on an Arbitrary Matrix</p></a></li>
<li><a href='#LDRTools-package'>
<p>Tools for Linear Dimension Reduction</p></a></li>
<li><a href='#O2P'>
<p>Function to Compute an Orthogonal Projection Matrix Based on a Matrix with Orthonormal Columns</p></a></li>
<li><a href='#Pdist'>
<p>Function to Compute the Distances Between Orthogonal Projection Matrices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Linear Dimension Reduction</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Eero Liski [aut],
  Klaus Nordhausen <a href="https://orcid.org/0000-0002-3758-8501"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Hannu Oja <a href="https://orcid.org/0000-0002-4945-5976"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Anne Ruiz-Gazen <a href="https://orcid.org/0000-0001-8970-8061"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dr</td>
</tr>
<tr>
<td>Description:</td>
<td>Linear dimension reduction subspaces can be uniquely defined using orthogonal projection matrices. This package provides tools to compute distances between such subspaces and to compute the average subspace. For details see Liski, E.Nordhausen K., Oja H., Ruiz-Gazen A. (2016) Combining Linear Dimension Reduction Subspaces &lt;<a href="https://doi.org/10.1007%2F978-81-322-3643-6_7">doi:10.1007/978-81-322-3643-6_7</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-17 18:30:57 UTC; admin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-17 23:12:34 UTC</td>
</tr>
</table>
<hr>
<h2 id='AOP'>
Function to Average Orthogonal Projection Matrices
</h2><span id='topic+AOP'></span>

<h3>Description</h3>

<p>The function computes the average of orthogonal projection matrices and estimates the average rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AOP(x, weights = "constant")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AOP_+3A_x">x</code></td>
<td>
<p>List of orthogonal projection matrices, can have different ranks.</p>
</td></tr>
<tr><td><code id="AOP_+3A_weights">weights</code></td>
<td>
<p>The weight function used for the individual ranks. Possible inputs are <code>constant</code>, <code>inverse</code> and <code>sq.inverse</code> (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AOP maximizes the function <code class="reqn">D(P)= w(k)tr(\bar P_wP)- \frac 12 w^2(k)k</code>, 
where <code class="reqn">\bar P_w=\frac 1m \sum_{i=1}^m w(k_i) P_i</code>
is a regular average of weighted orthogonal projection matrices, <code class="reqn">m</code> is the number of orthogonal projection matrices averaged, 
<code class="reqn">w(k)</code>is the weight function and <code class="reqn">k</code> is the rank of <code class="reqn">P</code>.
The possible weights are defined as <code>constant</code>: <code class="reqn">w(k)=1</code>, <code>inverse</code>: <code class="reqn">w(k)=1/k</code> and 
<code>sq.inverse</code>: <code class="reqn">w(k)=1/\sqrt k</code>. The <code>constant</code> weight corresponds to the so called Crone &amp; Crosby distance. Orthogonal 
projection matrices of zero rank are also possible inputs for the function. In such a case, the function prints a warning giving the number of orthogonal 
projection matrices with zero rank.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>P</code></td>
<td>
<p>The estimated average orthogonal projection matrix.</p>
</td></tr>
<tr><td><code>O</code></td>
<td>
<p>An orthogonal matrix on which P is based upon.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The rank of the average orthogonal projection matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eero Liski and Klaus Nordhausen
</p>


<h3>References</h3>

<p><cite>Crone, L. J., and Crosby, D. S. (1995), Statistical Applications of a Metric on Subspaces to Satellite Meteorology, Technometrics 37, 324-328. </cite>
</p>
<p><cite>Liski E., Nordhausen K., Oja H., and Ruiz-Gazen A. (2016), Combining Linear Dimension Reduction Subspaces. In: Agostinelli C., Basu A., Filzmoser P., Mukherjee D. (eds) Recent Advances in Robust Statistics: Theory and Applications. <a href="https://doi.org/10.1007/978-81-322-3643-6_7">doi:10.1007/978-81-322-3643-6_7</a>.</cite> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pdist">Pdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Ex.1
##
library(dr)
# Australian athletes data with 202 observations
data(ais)
# 10 explanatory variables
X &lt;- as.matrix(ais[,c(2:3,5:12)])
colnames(X) &lt;- names(ais[,c(2:3,5:12)])
p &lt;- dim(X)[2]
# Response variable lean body mass (LBM)
y &lt;- ais$LBM
# Significance level 
alpha &lt;- 0.05


# SIR
s0.sir &lt;- dr(y ~ X, method="sir")
# Estimate of k 
k.sir &lt;- sum(dr.test(s0.sir, numdir=4)[,3] &lt; alpha)
# List of transformation matrices corresponding to 
# k.sir and fixed k=1, respectively
B.sir.list &lt;- list(B1=s0.sir$evectors[,1:k.sir], B2=s0.sir$evectors[,1:1])
# List of orthogonal projectors corresponding to 
# k.sir, fixed k=1 and fixed k=0, respectively
P.sir.list &lt;- list(P1=O2P(B.sir.list$B1), P2=O2P(B.sir.list$B2), 
P3=diag(0,p))


# SAVE
s0.save &lt;- dr(y ~ X, method="save")
# Estimate of k 
k.save &lt;- sum(dr.test(s0.save, numdir=4)[,3] &lt; alpha)
# List of transformation matrices corresponding to 
# k.save and fixed k=1, respectively
B.save.list &lt;- list(B1=s0.save$evectors[,1:k.save], 
B2=s0.save$evectors[,1:1])
# List of orthogonal projectors corresponding to 
# k.save, fixed k=1 and fixed k=0, respectively
P.save.list &lt;- list(P1=O2P(B.save.list$B1), P2=O2P(B.save.list$B2), 
P3=diag(0,p))


# DR k-estimates
dr.k &lt;- c(k.sir, k.save)
names(dr.k) &lt;- c("SIR","SAVE")
dr.k


# List of individually estimated projectors
proj.list.a &lt;- list(P.sir.list$P1, P.save.list$P1)
# List of fixed projectors
proj.list.b &lt;- list(P.sir.list$P2, P.save.list$P2)
# List of zero projectors
proj.list.c &lt;- list(P.sir.list$P3, P.save.list$P3)
# List of zero-rank SIR-projector and 
# other individually estimated projectors
proj.list.d &lt;- list(P.sir.list$P3, P.save.list$P1)


# AOP (constant) object corresponding to the first projector list
AOP.const.a &lt;- AOP(proj.list.a, weights="constant")

# AOP (inverse) objects corresponding to three projector lists
AOP.inv.a &lt;- AOP(proj.list.a, weights="inverse")
AOP.inv.b &lt;- AOP(proj.list.b, weights="inverse")
AOP.inv.c &lt;- AOP(proj.list.c, weights="inverse")

# AOP (sq.inverse) objects corresponding to three projector lists
AOP.sqinv.a &lt;- AOP(proj.list.a, weights="sq.inverse")
AOP.sqinv.c &lt;- AOP(proj.list.c, weights="sq.inverse")
AOP.sqinv.d &lt;- AOP(proj.list.d, weights="sq.inverse")


# k-estimates of the AOP's
AOP.a &lt;- c(AOP.const.a$k, AOP.inv.a$k, AOP.sqinv.a$k)
names(AOP.a) &lt;- c("const","inv","sqinv")
AOP.a

AOP.c &lt;- AOP.inv.c$k
names(AOP.c) &lt;- c("inv")
AOP.c

AOP.d &lt;- AOP.sqinv.d$k
names(AOP.d) &lt;- c("sqinv")
AOP.d


# Scatter plots between the response and the transformed data 
# corresponding to the different AOP transformation matrices

# AOP.inverse
newdata.inv.AOPa &lt;- cbind(y,X %*% AOP.inv.a$O)
pairs(newdata.inv.AOPa)

newdata.inv.AOPb &lt;- cbind(y,X %*% AOP.inv.b$O)
pairs(newdata.inv.AOPb)


# AOP.sq.inverse
newdata.sqinv.AOPc &lt;- cbind(y,X %*% AOP.sqinv.c$O)
pairs(newdata.sqinv.AOPc)

newdata.sqinv.AOPd &lt;- cbind(y,X %*% AOP.sqinv.d$O)
pairs(newdata.sqinv.AOPd)






###################################
## Ex.2
##
a &lt;- c(1,1,rep(0,8))
A &lt;- diag(a)
B &lt;- diag(0,10)
B[3,1] &lt;- 1
P.A &lt;- O2P(A[,1:2])
P.B &lt;- O2P(B[,1])
zero.mat &lt;- diag(0,10)
# True projector, k=3
P.C &lt;- P.A + P.B

# Average P.A and P.B
proj.list &lt;- list(P.A, P.B)
AOP.const &lt;- AOP(proj.list, weights="constant")
AOP.inv &lt;- AOP(proj.list, weights="inverse")
AOP.sqinv &lt;- AOP(proj.list, weights="sq.inverse")
k.list &lt;- c(AOP.const$k, AOP.inv$k, AOP.sqinv$k)
names(k.list) &lt;- c("const","inv","sqinv")
k.list

# Average P.A, P.B and three zero rank matrices
proj.list &lt;- list(P.A, P.B, zero.mat, zero.mat, zero.mat)
AOP.const &lt;- AOP(proj.list, weights="constant")
AOP.inv &lt;- AOP(proj.list, weights="inverse")
AOP.sqinv &lt;- AOP(proj.list, weights="sq.inverse")
k.list &lt;- c(AOP.const$k, AOP.inv$k, AOP.sqinv$k)
names(k.list) &lt;- c("const","inv","sqinv")
k.list

</code></pre>

<hr>
<h2 id='B2P'>
Function to Compute an Orthogonal Projection Matrix Based on an Arbitrary Matrix
</h2><span id='topic+B2P'></span>

<h3>Description</h3>

<p>Function to compute an orthogonal projection matrix based on an arbitrary matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B2P(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B2P_+3A_x">x</code></td>
<td>
<p>A matrix with p rows and k columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The orthogonal projection matrix <code class="reqn">P</code> corresponding to matrix <code class="reqn">x</code> is defined as <code class="reqn">P=x(x^{T}x)^{-1}x^{T}</code>.
</p>


<h3>Value</h3>

<p>The resulting orthogonal projection matrix. </p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+O2P">O2P</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
X &lt;- matrix(rnorm(30),ncol=3)
P &lt;- B2P(X)
</code></pre>

<hr>
<h2 id='LDRTools-package'>
Tools for Linear Dimension Reduction
</h2><span id='topic+LDRTools-package'></span><span id='topic+LDRTools'></span>

<h3>Description</h3>

<p>Linear dimension reduction subspaces can be uniquely defined using orthogonal projection matrices. This package provides tools to compute distances between such subspaces and to compute the average subspace. For details see Liski, E.Nordhausen K., Oja H., Ruiz-Gazen A. (2016) Combining Linear Dimension Reduction Subspaces &lt;doi:10.1007/978-81-322-3643-6_7&gt;.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> LDRTools</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Tools for Linear Dimension Reduction</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.2-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-09-17</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> 
    c(person("Eero", "Liski", 
             role = "aut"),
      person("Klaus", "Nordhausen", 
             email = "klausnordhausenR@gmail.com",
             role = c("aut", "cre"),
             comment = c(ORCID = "0000-0002-3758-8501")),
      person("Hannu", "Oja", 
             role = c("aut"),
             comment = c(ORCID = "0000-0002-4945-5976")),
      person("Anne", "Ruiz-Gazen", 
             role = "aut", 
             comment = c(ORCID = "0000-0001-8970-8061")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> 
    Eero Liski [aut],
    Klaus Nordhausen [aut, cre] (&lt;https://orcid.org/0000-0002-3758-8501&gt;),
    Hannu Oja [aut] (&lt;https://orcid.org/0000-0002-4945-5976&gt;),
    Anne Ruiz-Gazen [aut] (&lt;https://orcid.org/0000-0001-8970-8061&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.2.2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> dr</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Linear dimension reduction subspaces can be uniquely defined using orthogonal projection matrices. This package provides tools to compute distances between such subspaces and to compute the average subspace. For details see Liski, E.Nordhausen K., Oja H., Ruiz-Gazen A. (2016) Combining Linear Dimension Reduction Subspaces &lt;doi:10.1007/978-81-322-3643-6_7&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
AOP                     Function to Average Orthogonal Projection
                        Matrices
B2P                     Function to Compute an Orthogonal Projection
                        Matrix Based on an Arbitrary Matrix
LDRTools-package        Tools for Linear Dimension Reduction
O2P                     Function to Compute an Orthogonal Projection
                        Matrix Based on a Matrix with Orthonormal
                        Columns
Pdist                   Function to Compute the Distances Between
                        Orthogonal Projection Matrices
</pre>


<h3>Author(s)</h3>


<p>    Eero Liski [aut],
    Klaus Nordhausen [aut, cre] (&lt;https://orcid.org/0000-0002-3758-8501&gt;),
    Hannu Oja [aut] (&lt;https://orcid.org/0000-0002-4945-5976&gt;),
    Anne Ruiz-Gazen [aut] (&lt;https://orcid.org/0000-0001-8970-8061&gt;)
</p>
<p>Maintainer: Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Liski E., Nordhausen K., Oja H., and Ruiz-Gazen A. (2016), Combining Linear Dimension Reduction Subspaces. In: Agostinelli C., Basu A., Filzmoser P., Mukherjee D. (eds) Recent Advances in Robust Statistics: Theory and Applications. <a href="https://doi.org/10.1007/978-81-322-3643-6_7">doi:10.1007/978-81-322-3643-6_7</a>.</cite>  
</p>

<hr>
<h2 id='O2P'>
Function to Compute an Orthogonal Projection Matrix Based on a Matrix with Orthonormal Columns
</h2><span id='topic+O2P'></span>

<h3>Description</h3>

<p>Function to compute an orthogonal projection matrix based on a matrix with orthonormal columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>O2P(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="O2P_+3A_x">x</code></td>
<td>
<p>a matrix with k orthonormal columns of length p.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The orthogonal projection matrix <code class="reqn">P</code> corresponding to matrix <code class="reqn">x</code> is defined as <code class="reqn">P=xx^{T}</code>.
</p>


<h3>Value</h3>

<p>The resulting orthogonal projection matrix. </p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B2P">B2P</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- tcrossprod(matrix(rnorm(100),ncol=10))
# Orthogonal projector based on the first three eigenvectors of X
P &lt;- O2P(eigen(X)$vectors[,1:3])
</code></pre>

<hr>
<h2 id='Pdist'>
Function to Compute the Distances Between Orthogonal Projection Matrices
</h2><span id='topic+Pdist'></span>

<h3>Description</h3>

<p>The function computes distances between orthogonal projection matrices that might have different ranks. Different weight functions for the ranks are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pdist(x, weights = "constant")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pdist_+3A_x">x</code></td>
<td>
<p>List of othogonal projection matrices (can have different ranks).</p>
</td></tr>
<tr><td><code id="Pdist_+3A_weights">weights</code></td>
<td>
<p>The weight function used for the individual ranks. Possible inputs are <code>constant</code>, <code>inverse</code> and <code>sq.inverse</code> (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A weighted distance between subspaces  <code class="reqn">P_1</code> and <code class="reqn">P_2</code> with ranks <code class="reqn">k_1</code> and <code class="reqn">k_2</code> is given by 
<code class="reqn">D_{w}^2(P_1,P_2)=\frac{1}{2} ||w(k_1)P_1-w(k_2)P_2||^2</code>, 
where <code class="reqn">w</code> denotes the weight function. 
The possible weights are defined as <code>constant</code>: 
<code class="reqn">w(k)=1</code>, <code>inverse</code>: <code class="reqn">w(k)=1/k</code> and <code>sq.inverse</code>: <code class="reqn">w(k)=1/\sqrt k</code>. The <code>constant</code> weight corresponds to the so called Crone &amp; Crosby distance. Orthogonal projection matrices of zero rank 
are also possible inputs for the function. 
</p>


<h3>Value</h3>

<p>an object of class <code>dist</code> having the attributes:
</p>
<table>
<tr><td><code>Size</code></td>
<td>
<p>number of orthogonal projection matrices.</p>
</td></tr>
<tr><td><code>Labels</code></td>
<td>
<p>names of orthogonal projection matrices if available.</p>
</td></tr>
<tr><td><code>Diag</code></td>
<td>
<p>FALSE.</p>
</td></tr>
<tr><td><code>Upper</code></td>
<td>
<p>FALSE.</p>
</td></tr>
<tr><td><code>methods</code></td>
<td>
<p>The name of the weights used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eero Liski and Klaus Nordhausen
</p>


<h3>References</h3>

<p><cite>Crone, L. J., and Crosby, D. S. (1995), Statistical Applications of a Metric on Subspaces to Satellite Meteorology, Technometrics 37, 324-328. </cite>
</p>
<p><cite>Liski E., Nordhausen K., Oja H., and Ruiz-Gazen A. (2016), Combining Linear Dimension Reduction Subspaces. In: Agostinelli C., Basu A., Filzmoser P., Mukherjee D. (eds) Recent Advances in Robust Statistics: Theory and Applications. <a href="https://doi.org/10.1007/978-81-322-3643-6_7">doi:10.1007/978-81-322-3643-6_7</a>.</cite>  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AOP">AOP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ex.1
X.1 &lt;- tcrossprod(matrix(rnorm(16),ncol=4))
X.2 &lt;- tcrossprod(matrix(rnorm(16),ncol=4))
X.3 &lt;- tcrossprod(matrix(rnorm(16),ncol=4))
U1 &lt;- eigen(X.1)$vectors
U2 &lt;- eigen(X.2)$vectors
U3 &lt;- eigen(X.3)$vectors

PRO &lt;- list(P1=O2P(U1),P2=O2P(U2),P3=O2P(U3))

DIST.MAT&lt;-Pdist(PRO)
str(DIST.MAT)
as.matrix(DIST.MAT)
print(DIST.MAT, diag=TRUE)
print(DIST.MAT, diag=TRUE, upper=TRUE)

PRO2 &lt;- list(O2P(U1),O2P(U2),O2P(U3))
Pdist(PRO2, weights="inverse")

#############################
# Ex.2
a &lt;- c(1,1,rep(0,8))
A &lt;- diag(a)
b &lt;- c(1,1,1,1,rep(0,6))
B &lt;- diag(b)
P.A &lt;- O2P(A[,1:2])
P.B &lt;- O2P(B[,1:4])

proj.list &lt;- list(P.A,P.B)
Pdist(proj.list, weights="constant")
Pdist(proj.list, weights="inverse")
Pdist(proj.list, weights="sq.inverse")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
