<!DOCTYPE html><html lang="en"><head><title>Help for package bmstdr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bmstdr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#argo_floats_atlantic_2003'><p>Temperature and salinity data from Argo floats in the North Atlantic Ocean at</p>
three layers of depth: surface (less than 50 meters),  mid-layer (between 475-525 meters)
and deep (975 to 1025 meters) during 2003.</a></li>
<li><a href='#Bcartime'><p>Bayesian regression model fitting for areal and areal spatio-temporal data.</p>
Calculates parameter estimates, validation statistics, and
estimated values of several Bayesian model choice criteria.</a></li>
<li><a href='#BCauchy'><p>Cauchy prior simulation example.</p></a></li>
<li><a href='#Bmchoice'><p>Model choice criteria calculation for univariate</p>
normal model for both known and unknown sigma^2</a></li>
<li><a href='#Bmoving_sptime'><p>Model fitting and validation for spatio-temporal data from moving sensors in time.</p></a></li>
<li><a href='#bmstdr_variogram'><p>Calculates and plots the variogram cloud and an estimated variogram.</p></a></li>
<li><a href='#Bnormal'><p>N(theta, sigma2):  Using different methods.</p></a></li>
<li><a href='#Bspatial'><p>Bayesian regression model fitting for point referenced spatial data.</p>
Calculates parameter estimates, validation statistics, and
estimated values of several Bayesian model choice criteria.</a></li>
<li><a href='#Bsptime'><p>Bayesian regression model fitting for point referenced spatio-temporal data.</p>
Calculates parameter estimates, validation statistics, and
estimated values of several Bayesian model choice criteria.</a></li>
<li><a href='#calculate_dic'><p>Calculate DIC function.</p>
Has two arguments: (1) log full likelihood at thetahat and (2) vector of log-likelihood at the theta samples
Calculate the DIC criteria values</a></li>
<li><a href='#calculate_validation_statistics'><p>Calculates the four validation statistics: RMSE, MAE, CRPS and coverage</p>
given the observed values and MCMC iterates.</a></li>
<li><a href='#calculate_waic'><p>Calculate WAIC  function.</p>
Has the sole argument component wise likelihood at thetahat samples.
v must be a matrix
Calculate the WAIC criteria values</a></li>
<li><a href='#coef.bmstdr'><p>Prints and returns the estimates of the coefficients</p></a></li>
<li><a href='#colpalette'><p>The color palette used to draw maps to illustrate the package</p>
bmstdr, see  Sahu (2022)
It has the values in order: dodgerblue4, dodgerblue2, firebrick2,
firebrick4 and purple.</a></li>
<li><a href='#engdeaths'><p>Number of weekly Covid-19 deaths and cases in the 313 local</p>
Local Authority Districts, Counties  and Unitary Authorities (LADCUA) in
England during the 20 peaks in the first peak from March 13 to July 31, 2020.</a></li>
<li><a href='#engtotals'><p>Total number of weekly Covid-19 deaths and cases in the 313 local</p>
Local Authority Districts, Counties  and Unitary Authorities (LADCUA) in
England during the first peak from March 13 to July 31, 2020.</a></li>
<li><a href='#fig11.13.plot'><p>Draws a time series (ribbon) plot by combining fitted and predicted values</p></a></li>
<li><a href='#fitted.bmstdr'><p>Extract fitted values from bmstdr objects.</p></a></li>
<li><a href='#fnc.delete.map.XYZ'><p>This function is used to delete values outside the state of New York</p></a></li>
<li><a href='#get_parameter_estimates'><p>Obtains parameter estimates from MCMC samples</p></a></li>
<li><a href='#get_validation_summaries'><p>Obtains suitable validation summary statistics from MCMC samples</p>
obtained for  validation.</a></li>
<li><a href='#getvalidrows'><p>Returns a vector of row numbers for validation.</p></a></li>
<li><a href='#gridnyspatial'><p>Values of three covariates for 100 grid locations in New York</p>
averaged over the 62 days during the months of July and August, 2006.</a></li>
<li><a href='#gridnysptime'><p>Values of three covariates for 100 grid locations in New York for</p>
the 62 days during the months of July and August, 2006.</a></li>
<li><a href='#hitandfalsealarm'><p>Calculate the hit and false alarm rates</p></a></li>
<li><a href='#is.bmstdr'><p>Is it a bmstdr model fitted object?</p></a></li>
<li><a href='#materncov'><p>Banerjee, Carlin and Gelfand (2015) Mat'ern covariance function</p></a></li>
<li><a href='#maternfun'><p>Banerjee et al Mat'ern covariance function</p></a></li>
<li><a href='#nyspatial'><p>Average ozone concentration values and three covariates from 28 sites in New York.</p></a></li>
<li><a href='#nysptime'><p>Daily 8-hour maximum ozone concentration values and three covariates from 28 sites in New York for</p>
the 62 days during the months of July and August, 2006.</a></li>
<li><a href='#obs_v_pred_plot'><p>Observed against predicted plot</p></a></li>
<li><a href='#phichoice_sp'><p>Grid search method for choosing phi</p>
Calculates the validation statistics using the spatial model with a given range of values of
the decay parameter phi.</a></li>
<li><a href='#phichoicep'><p>Calculates the validation statistics using the spatial model with a given range of values of</p>
the decay parameter phi.</a></li>
<li><a href='#plot.bmstdr'><p>Plot method for  bmstdr objects.</p></a></li>
<li><a href='#print.bmstdr'><p>Provides basic information regarding the fitted model.</p></a></li>
<li><a href='#residuals.bmstdr'><p>Extract residuals from a bmstdr  fitted object.</p></a></li>
<li><a href='#summary.bmstdr'><p>Provides basic summaries of model fitting.</p></a></li>
<li><a href='#terms.bmstdr'><p>Prints the terms</p></a></li>
<li><a href='#Weng'><p>A 313 by 313 proximity matrix for the 313 LADCUAS in England. Each entry is either 0 or 1</p>
and is 1 if the corresponding row and column LADCUAs share a common boundary.</a></li>
<li><a href='#ydata'><p>Average air pollution values from 28 sites in New York.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Modeling of Spatio-Temporal Data with R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.9</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.sujitsahu.com">https://www.sujitsahu.com</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Fits, validates and compares a number of Bayesian models for
    spatial and space time point referenced and areal unit data. Model fitting
    is done using several packages: 'rstan', 'INLA', 'spBayes', 'spTimer',
    'spTDyn', 'CARBayes' and 'CARBayesST'. Model comparison is performed using
    the DIC and WAIC,  and K-fold cross-validation where the user is free
    to select their own subset of data rows for validation. Sahu (2022)
    &lt;<a href="https://doi.org/10.1201%2F9780429318443">doi:10.1201/9780429318443</a>&gt; describes the methods in detail.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, spTimer, ggplot2, rstan, rstantools, spBayes,
CARBayes, CARBayesST, spTDyn, MCMCpack, Rdpack, mnormt,
inlabru, ggpubr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), Rcpp (&ge; 0.12.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>INLA (&ge; 22.5.7), coda, extraDistr, maps, xtable, MASS, loo,
cowplot, ggrepel, sf, knitr, rmarkdown, testthat, ggspatial,
interp, tidyr, RColorBrewer, magick, markdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
rstan (&ge; 2.18.1), StanHeaders (&ge; 2.18.0), RcppParallel</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/stable">https://inla.r-inla-download.org/R/stable</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sujit-sahu/bmstdr/issues">https://github.com/sujit-sahu/bmstdr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-16 09:40:18 UTC; sks</td>
</tr>
<tr>
<td>Author:</td>
<td>Sujit K. Sahu <a href="https://orcid.org/0000-0003-2315-3598"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Duncan P. Lee [aut],
  K. Shuvo Bakar [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sujit K. Sahu &lt;S.K.Sahu@soton.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-18 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='argo_floats_atlantic_2003'>Temperature and salinity data from Argo floats in the North Atlantic Ocean at 
three layers of depth: surface (less than 50 meters),  mid-layer (between 475-525 meters) 
and deep (975 to 1025 meters) during 2003.</h2><span id='topic+argo_floats_atlantic_2003'></span>

<h3>Description</h3>

<p>Temperature and salinity data from Argo floats in the North Atlantic Ocean at 
three layers of depth: surface (less than 50 meters),  mid-layer (between 475-525 meters) 
and deep (975 to 1025 meters) during 2003.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argo_floats_atlantic_2003
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 6978 rows and 11 columns.
</p>


<h3>Source</h3>

<p>Sahu and Challenor (2008)
@format A data frame with 6978 rows and 11 columns:
</p>

<dl>
<dt>lon</dt><dd><p>Longitude of the argo float</p>
</dd>
<dt>lat</dt><dd><p>Latitude of the argo float</p>
</dd>
<dt>time</dt><dd><p>Cumulative day of the year in 2003</p>
</dd>
<dt>day</dt><dd><p>Day within each month in 2003</p>
</dd>
<dt>month</dt><dd><p>Month in 2003</p>
</dd>
<dt>temp</dt><dd><p>Temperature recorded by the Argo float in degree Celsius</p>
</dd>
<dt>sali</dt><dd><p>Salinity in practical salinity units</p>
</dd>
<dt>xlon</dt><dd><p>Centered and scaled values of longitude at each depth</p>
</dd>
<dt>xlat</dt><dd><p>Centered and scaled values of latitude at each depth</p>
</dd>
<dt>xinter</dt><dd><p>Centered and scaled values of longitude times latitude at each depth</p>
</dd>
</dl>



<h3>References</h3>

<p>Sahu SK, Challenor P (2008).
&ldquo;A space-time model for joint modeling of ocean temperature and salinity levels as measured by Argo floats.&rdquo;
<em>Environmetrics</em>, <b>19</b>, 509-528.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> head(argo_floats_atlantic_2003)
 # Data for the surface layer 
 surface &lt;- argo_floats_atlantic_2003[argo_floats_atlantic_2003$depth==1, ] 
 # Data for the mid-layer 
 midlayer &lt;- argo_floats_atlantic_2003[argo_floats_atlantic_2003$depth==2, ] 
 # Data at the deep ocean 
 deep &lt;- argo_floats_atlantic_2003[argo_floats_atlantic_2003$depth==3, ]  
</code></pre>

<hr>
<h2 id='Bcartime'>Bayesian regression model fitting for areal and areal spatio-temporal data. 
Calculates parameter estimates, validation statistics, and 
estimated values of several Bayesian model choice criteria.</h2><span id='topic+Bcartime'></span>

<h3>Description</h3>

<p>Bayesian regression model fitting for areal and areal spatio-temporal data. 
Calculates parameter estimates, validation statistics, and 
estimated values of several Bayesian model choice criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bcartime(
  formula,
  data,
  family,
  link = NULL,
  trials = NULL,
  offsetcol = NULL,
  formula.omega = NULL,
  scol = NULL,
  tcol = NULL,
  package = "CARBayes",
  model = "glm",
  AR = 1,
  W = NULL,
  adj.graph = NULL,
  residtype = "response",
  interaction = TRUE,
  Z = NULL,
  W.binary = NULL,
  changepoint = NULL,
  knots = NULL,
  validrows = NULL,
  prior.mean.delta = NULL,
  prior.mean.beta = NULL,
  prior.var.beta = NULL,
  prior.mean.gamma = NULL,
  prior.var.gamma = NULL,
  prior.sigma2 = NULL,
  prior.tau2 = c(2, 1),
  prior.delta = NULL,
  prior.var.delta = NULL,
  prior.lambda = NULL,
  prior.nu2 = c(2, 1),
  epsilon = 0,
  G = NULL,
  ind.area = NULL,
  trends = NULL,
  rho.T = NULL,
  rho.S = NULL,
  rho = NULL,
  rho.slo = NULL,
  rho.int = NULL,
  MALA = FALSE,
  N = 2000,
  burn.in = 1000,
  thin = 10,
  rseed = 44,
  Nchains = 4,
  verbose = TRUE,
  plotit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bcartime_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;formula&quot; (or one that can be coerced to that class):
a symbolic description of the regression model to be fitted.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_data">data</code></td>
<td>
<p>The data frame for which the model formula is to be fitted.
The data frame should be in long format having one row for each location and  time
combination. The data frame must be ordered by time within each site, and should
optionally have a column, named s.index,  providing the site indices.
Thus the data,  with n sites and T times within each site, should be
organized in the order: (s1, t1), (s1, t2), ... (s1, T), ... (sn, t1), ... (sn, T). 
The data frame should also contain two columns giving the coordinates of the
locations for spatio temporal model fitting.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_family">family</code></td>
<td>
<p>One of either &quot;gaussian&quot;, &quot;binomial&quot;,&quot;poisson&quot; or &quot;zip&quot;, 
which respectively specify a Gaussian, binomial likelihood model with the 
logistic link function, a Poisson likelihood model with a log link function, 
or a zero-inflated Poisson model with a log link function.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_link">link</code></td>
<td>
<p>The link function to use for INLA based model fitting. This is 
ignored for the CARBayes and   CARBayesST models.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_trials">trials</code></td>
<td>
<p>Only used if family=&quot;binomial&quot;. 
Either the name (character) or number of the column in 
the supplied data frame containing the total number of trials 
The program will try to access data[, trials] to get 
the binomial denominators.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_offsetcol">offsetcol</code></td>
<td>
<p>Only used in INLA based modeling. The column name or number 
in the data frame that should be used as the offset.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_formula.omega">formula.omega</code></td>
<td>

<p>A one-sided formula object with no response variable (left side of the &quot;~&quot;) 
needed, specifying the covariates in the logistic regression model for 
modelling the probability of an observation being a structural zero. Each 
covariate (or an offset) needs to be a vector of length K*1. Only required for 
zero-inflated Poisson models.
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_scol">scol</code></td>
<td>
<p>Either the name (character) or number of the column in the supplied data frame 
identifying the spatial units. The program will try to access data[, scol] 
to identify the spatial units. If this is omitted, no spatial modeling will be performed.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_tcol">tcol</code></td>
<td>
<p>Like the <code>scol</code> argument for the time identifier. 
Either the name (character) or number of the column in the supplied data frame 
identifying the  time indices. The program will try to access data[, tcol] 
to identify the time points. If this is omitted, no temporal modeling will be performed.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_package">package</code></td>
<td>
<p>Which package is to be used in model fitting? Currently available 
packages are:
</p>
  
<ul>
<li><p> &quot;inla&quot;: INLA model fitting for areal data.
See Gómez-Rubio (2020).
</p>
</li>
<li><p> &quot;CARBayes&quot;: All possible models in this package can be fitted. 
See Lee (2021).
</p>
</li>
<li><p> &quot;CARBayesST&quot;: All possible models in this package can be fitted.
See Lee et al. (2018).
Further details and more examples are provided in Chapters 10 and 11 of the book 
Sahu (2022).
</p>
</li></ul>
</td></tr>
<tr><td><code id="Bcartime_+3A_model">model</code></td>
<td>
<p>The specific spatio temporal model to be fitted. 
If the package is &quot;INLA&quot; then the model argument should be a vector with two elements 
giving the spatial model as the first component. The alternatives for the 
spatial model are: &quot;bym&quot;, &quot;bym2&quot;, &quot;besag&quot;, &quot;besag2&quot;, &quot;besagproper&quot;, &quot;besagproper2&quot;, &quot;iid&quot; 
and &quot;none&quot;. The temporal model as the second second component can  be one of 
&quot;iid&quot;, &quot;rw1&quot;,  &quot;rw2&quot;, ar1&quot; or &quot;none&quot;. 
In case the model component is &quot;none&quot; then no spatial/temporal random effects 
will be fitted. No temporal random effects will be fitted in case <code>model</code> is
supplied as a  scalar, i.e. not a vector of two values.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_ar">AR</code></td>
<td>

<p>The order of the autoregressive time series process that must be either 1 or 2. 
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_w">W</code></td>
<td>
<p>A non-negative K by K neighborhood matrix (where K is the number of spatial units). 
Typically a binary specification is used, where the jkth element equals one if areas (j, k) 
are spatially close (e.g. share a common border) and is zero otherwise. 
The matrix can be non-binary, but each row must contain at least one non-zero entry.
This argument may not need to be specified if <code>adj.graph</code> is specified instead.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_adj.graph">adj.graph</code></td>
<td>
<p>Adjacency graph which may be specified instead of the adjacency matrix 
matrix. This argument is used if  <code>W</code> has not been supplied. The argument 
<code>W</code> is used in case both <code>W</code> and <code>adj.graph</code> are supplied.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_residtype">residtype</code></td>
<td>
<p>Residual type, either &quot;response&quot; or &quot;pearson&quot;,
in GLM fitting with the packages CARBayes and CARBayesST.
Default is &quot;response&quot; type observed minus fitted. The other option &quot;pearson&quot; is for 
Pearson residuals in GLM. For INLA based model fitting only the default response 
residuals are calculated.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_interaction">interaction</code></td>
<td>
<p>TRUE or FALSE indicating whether the spatio-temporal interaction 
random effects should be included. Defaults to TRUE unless family=&quot;gaussian&quot; in which 
case interactions are not allowed.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_z">Z</code></td>
<td>

<p>A list, where each element is a K by K matrix of non-negative dissimilarity metrics.
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_w.binary">W.binary</code></td>
<td>

<p>Logical, should the estimated neighbourhood matrix have only binary (0,1) values.
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_changepoint">changepoint</code></td>
<td>

<p>A scalar indicating the position of the change point should one of the change point 
trend functions be included in the trends vector, i.e. if &quot;CP&quot; or &quot;CT&quot; is specified.
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_knots">knots</code></td>
<td>

<p>A scalar indicating the number of knots to use should one of the monotonic cubic 
splines trend functions be included in the trends vector, i.e. if &quot;MD&quot; or &quot;MI&quot; is 
specified.
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_validrows">validrows</code></td>
<td>
<p>A vector providing the rows of the data frame which 
should be used for validation. 
The default NULL value instructs that validation will not be performed.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_prior.mean.delta">prior.mean.delta</code></td>
<td>
<p>A vector of prior means for the regression parameters delta 
(Gaussian priors are assumed) for the zero probability logistic regression 
component of the model. Defaults to a vector of zeros.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_prior.mean.beta">prior.mean.beta</code></td>
<td>

<p>A vector of prior means for the regression parameters beta (Gaussian priors are 
assumed). Defaults to a vector of zeros.
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_prior.var.beta">prior.var.beta</code></td>
<td>

<p>A vector of prior variances for the regression parameters beta (Gaussian priors 
are assumed). Defaults to a vector with values 100,000.
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_prior.mean.gamma">prior.mean.gamma</code></td>
<td>

<p>A vector of prior means for the temporal trend parameters (Gaussian priors are 
assumed). Defaults to a vector of zeros.
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_prior.var.gamma">prior.var.gamma</code></td>
<td>

<p>A vector of prior variances for the temporal trend parameters (Gaussian priors 
are assumed). Defaults to a vector with values 100,000.
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_prior.sigma2">prior.sigma2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale)
prior for sigma2. Defaults to c(1, 0.01).  
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_prior.tau2">prior.tau2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale) 
prior for tau2. Defaults to c(1, 0.01).  
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_prior.delta">prior.delta</code></td>
<td>

<p>The prior maximum for the cluster smoothing parameter delta. Defaults to 10.  
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_prior.var.delta">prior.var.delta</code></td>
<td>
<p>A vector of prior variances for the regression parameters 
delta (Gaussian priors are assumed) for the zero probability logistic 
regression component of the model. Defaults to a vector with values 100000.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_prior.lambda">prior.lambda</code></td>
<td>

<p>A vector of prior samples sizes for the Dirichlet prior controlling the 
probabilities that each trend function is chosen. The vector should be the same 
length as the trends vector and defaults to a vector of ones.
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_prior.nu2">prior.nu2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale) 
prior for nu2. Defaults to c(1, 0.01) and only used if family=&quot;Gaussian&quot;.   
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_epsilon">epsilon</code></td>
<td>
<p>Diagonal ridge parameter to add to the random effects prior precision matrix, 
only required when rho = 1, and the prior precision is improper. Defaults to 0. Only used for adaptive 
model fitting in CARBayesST.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_g">G</code></td>
<td>
<p>The maximum number of distinct intercept terms (groups) to allow in the localised model.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_ind.area">ind.area</code></td>
<td>

<p>A vector of integers the same length as the number of data points (individuals) 
giving which spatial unit (nunmbered from 1 to K to align with the rows of
the W matrix) each individual belongs to.
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_trends">trends</code></td>
<td>

<p>A vector containing the temporal trend functions to include in the model, which 
include: constant (&quot;Constant&quot;&quot;); linear decreasing (&quot;LD&quot;); linear increasing 
(&quot;LI&quot;); Known change point, where the trend can increase towards the change point 
before subsequently decreasing (&quot;CP&quot;); or decrease towards the change point before 
subsequently increasing (&quot;CT&quot;); and monotonic cubic splines which are decreasing 
(&quot;MD&quot;) or increasing (&quot;MI&quot;). At least two trends have to be selected, with the 
constant trend always included. To avoid identifiability problems only one of &quot;LI&quot; 
or &quot;MI&quot; can be included at a given time (similarily for &quot;LD&quot; and &quot;MD&quot;).
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_rho.t">rho.T</code></td>
<td>
<p>The value in the interval [0, 1] that the temporal dependence parameter 
rho.T is fixed at if it should not be estimated. If this argument is NULL 
then rho.T is estimated in the model.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_rho.s">rho.S</code></td>
<td>
<p>The value in the interval [0, 1] that the spatial dependence parameter rho.S is 
fixed at if it should not be estimated. If this argument is NULL then rho.S is 
estimated in the model.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_rho">rho</code></td>
<td>
<p>The value in the interval [0, 1] that the spatial dependence parameter rho 
is fixed at if it should not be estimated. If this argument is NULL 
then rho is estimated in the model. Setting rho=1, reduces the random effects 
prior to the intrinsic CAR model but does require epsilon&gt;0.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_rho.slo">rho.slo</code></td>
<td>
<p>The value in the interval [0, 1] that the spatial dependence parameter 
for the slope of the linear time trend, rho.slo, is fixed at if it should not be estimated. 
If this argument is NULL then rho.slo is estimated in the model.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_rho.int">rho.int</code></td>
<td>
<p>The value in the interval [0, 1] that the spatial dependence parameter for 
the intercept of the linear time trend, rho.int, is fixed at if it should not 
be estimated. If this argument is NULL then rho.int is estimated in the model.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_mala">MALA</code></td>
<td>
<p>Logical, should the function use Metropolis adjusted Langevin algorithm (MALA) 
updates (TRUE) or simple random walk (FALSE, default) updates for the 
regression parameters and random effects.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_n">N</code></td>
<td>
<p>MCMC sample size.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_burn.in">burn.in</code></td>
<td>
<p>How many initial iterations to discard. 
Only relevant for MCMC based model fitting, i.e., when package is spBayes or Stan.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_thin">thin</code></td>
<td>
<p>The level of thinning to apply to the MCMC samples to reduce 
their temporal autocorrelation. Defaults to 1 (no thinning).</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_rseed">rseed</code></td>
<td>
<p>Random number seed that controls the starting point for the random number stream.
A set value is required to help reproduce the results.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_nchains">Nchains</code></td>
<td>

<p>The number of parallel Markov chains to be used in the Metropolis coupled Markov 
chain Monte Carlo (MCMCMC) simulations. Defaults to 4.
</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar value: whether to print various estimates and statistics.</p>
</td></tr>
<tr><td><code id="Bcartime_+3A_plotit">plotit</code></td>
<td>
<p>Logical scalar value: whether to plot the predictions against the observed values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> params -   A table of parameter estimates  
</p>
</li>
<li><p> fit -   The fitted model object.    
</p>
</li>
<li><p> fitteds -   A vector of fitted values.    
</p>
</li>
<li><p> mchoice -   Calculated model choice statistics if those have been 
requested by the input argument <code>mchoice=T</code>. Not all model fits will contain 
all the model choice statistics.  
</p>
</li>
<li><p> residuals -   A vector of residual values.   
</p>
</li>
<li><p> stats -   The four validation statistics: rmse, mae, crps and coverage. 
This is present only if model validation has been performed.  
</p>
</li>
<li><p> yobs_preds -   A data frame containing the validation rows of the model 
fitting data  frame. The last five columns of this data frame contains 
the validation prediction summaries: mean, sd, median, and 95% prediction interval. 
This is present only if model validation has been performed.  
</p>
</li>
<li><p> valpreds -   A matrix containing the MCMC samples of the validation predictions. 
The dimension of this matrix is the number of validations times the number of retained 
MCMC samples. This is present only if model validation has been performed. 
</p>
</li>
<li><p> validationplots - Present only if validation has been performed. 
Contains three validation plots with or without segment and 
an ordinary plot.  See <code><a href="#topic+obs_v_pred_plot">obs_v_pred_plot</a></code> for more.   
</p>
</li>
<li><p> sn -   The number of areal units used in fitting.   
</p>
</li>
<li><p> tn -  The number of time points used in fitting.  
</p>
</li>
<li><p> formula - The input formula for the regression part of the model.   
</p>
</li>
<li><p> scale.transform -   It is there for compatibility with <code>Bsptime</code> output.    
</p>
</li>
<li><p> package -   The name of the package used for model fitting.   
</p>
</li>
<li><p> model -   The name of the fitted model.    
</p>
</li>
<li><p> call -   The command used to call the model fitting function.   
</p>
</li>
<li><p> computation.time -   Computation time required to run the model fitting.   
</p>
</li></ul>



<h3>References</h3>

<p>Gómez-Rubio V (2020).
<em>Bayesian inference with INLA</em>.
Boca Raton:Chapman and Hall/CRC,.<br /><br /> Lee D (2021).
&ldquo;CARBayes version 5.2.3: An R Package for Spatial Areal Unit Modelling with Conditional Autoregressive Priors.&rdquo;
University of Glasgow.
<a href="https://cran.r-project.org/package=CARBayes">https://cran.r-project.org/package=CARBayes</a>.<br /><br /> Lee D, Rushworth A, Napier G (2018).
&ldquo;Spatio-Temporal Areal Unit Modeling in R with Conditional Autoregressive Priors Using the CARBayesST Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>84</b>(9), 10.18637/jss.v084.i09.<br /><br /> Sahu SK (2022).
<em>Bayesian Modeling of Spatio Temporal Data with R</em>, 1st edition.
Chapman and Hall, Boca Raton.
<a href="https://doi.org/10.1201/9780429318443">https://doi.org/10.1201/9780429318443</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Set the validation row numbers 
vs &lt;- sample(nrow(engtotals), 5)
# Total number of iterations 
N &lt;- 60
# Number of burn in iterations 
burn.in &lt;- 10
# Number of thinning iterations
thin &lt;- 1

# Set the model formula for binomial distribution based modeling 
f1 &lt;- noofhighweeks ~ jsa + log10(houseprice) + log(popdensity) + sqrt(no2)
## Independent error logistic regression
M1 &lt;- Bcartime(formula = f1, data = engtotals, family = "binomial",
    trials = "nweek", N = N, burn.in = burn.in, thin = thin,
    verbose = TRUE)
summary(M1)
# Leroux model
M1.leroux &lt;- Bcartime(formula = f1, data = engtotals, scol = "spaceid",
    model = "leroux", W = Weng, family = "binomial", trials = "nweek",
    N = N, burn.in = burn.in, thin = thin)
summary(M1.leroux)
# BYM model
M1.bym &lt;- Bcartime(formula = f1, data = engtotals, scol = "spaceid",
    model = "bym", W = Weng, family = "binomial", trials = "nweek",
    N = N, burn.in = burn.in, thin = thin, verbose = FALSE)
summary(M1.bym)

# Validation for the Leroux model
M1.leroux.v &lt;- Bcartime(formula = f1, data = engtotals, scol = "spaceid",
    model = "leroux", W = Weng, family = "binomial", trials = "nweek",
    validrows = vs, N = N, burn.in = burn.in, thin = thin, verbose = FALSE)
summary(M1.leroux.v)


## Poisson Distribution based models ####################################
# Model formula
f2 &lt;- covid ~ offset(logEdeaths) + jsa + log10(houseprice) + log(popdensity) +
    sqrt(no2)

# Independent error Poisson regression
M2 &lt;- Bcartime(formula = f2, data = engtotals, family = "poisson", N = N,
    burn.in = burn.in, thin = thin, verbose = FALSE)
summary(M2)
## Poisson regression with Leroux Model
M2.leroux &lt;- Bcartime(formula = f2, data = engtotals, scol = "spaceid",
    model = "leroux", family = "poisson", W = Weng, N = N, burn.in = burn.in,
    thin = thin, verbose = FALSE)
summary(M2.leroux)
# Poisson regression with BYM Model
M2.bym &lt;- Bcartime(formula = f2, data = engtotals, scol = "spaceid",
    model = "bym", family = "poisson", W = Weng, N = N, burn.in = burn.in,
    thin = thin)
summary(M2.bym)


## Gaussian distribution based models  ###############
f3 &lt;- sqrt(no2) ~ jsa + log10(houseprice) + log(popdensity)

# Independent error model 
M3 &lt;- Bcartime(formula = f3, data = engtotals, family = "gaussian", N = N,
    burn.in = burn.in, thin = thin, verbose = FALSE)
summary(M3)
# Leroux model 
M3.leroux &lt;- Bcartime(formula = f3, data = engtotals, scol = "spaceid",
    model = "leroux", family = "gaussian", W = Weng, N = N, burn.in = burn.in,
    thin = thin, verbose = FALSE)
summary(M3.leroux)

## Validation
M3.leroux.v &lt;- Bcartime(formula = f3, data = engtotals, scol = "spaceid",
    model = "leroux", family = "gaussian", W = Weng, N = N, burn.in = burn.in,
    thin = thin, validrows = vs, verbose = FALSE)
summary(M3.leroux.v)



## Spatio-temporal modeling ##################################################
head(engdeaths)
dim(engdeaths)
colnames(engdeaths)
vs &lt;- sample(nrow(engdeaths), 5)


## Binomial distribution
engdeaths$nweek &lt;- rep(1, nrow(engdeaths))
f1 &lt;- highdeathsmr ~ jsa + log10(houseprice) + log(popdensity)

M1st_linear &lt;- Bcartime(formula = f1, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", trials = "nweek", W = Weng, model = "linear",
    family = "binomial", package = "CARBayesST", N = N, burn.in = burn.in,
    thin = thin, verbose = TRUE)
summary(M1st_linear)
M1st_sepspat &lt;- Bcartime(formula = f1, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", trials = "nweek", W = Weng, model = "sepspatial",
    family = "binomial", package = "CARBayesST", N = N, burn.in = burn.in,
    thin = thin, verbose = FALSE)
summary(M1st_sepspat)
M1st_ar &lt;- Bcartime(formula = f1, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", trials = "nweek", W = Weng, model = "ar", AR = 1,
    family = "binomial", package = "CARBayesST", N = N, burn.in = burn.in,
    thin = thin, verbose = FALSE)
summary(M1st_ar)
# Model validation
M1st_ar.v &lt;- Bcartime(formula = f1, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", trials = "nweek", W = Weng, model = "ar", AR = 1,
    family = "binomial", package = "CARBayesST", N = N, burn.in = burn.in,
    thin = thin, validrows = vs, verbose = FALSE)
summary(M1st_ar.v)


## Spatio temporal Poisson models###################################
colnames(engdeaths)
f2 &lt;- covid ~ offset(logEdeaths) + jsa + log10(houseprice) + log(popdensity) +
    n0

M2st_linear &lt;- Bcartime(formula = f2, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", W = Weng, model = "linear", family = "poisson",
    package = "CARBayesST", N = N, burn.in = burn.in, thin = thin,
    verbose = FALSE)
summary(M2st_linear)
M2st_anova &lt;- Bcartime(formula = f2, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", W = Weng, model = "anova", family = "poisson",
    package = "CARBayesST", N = N, burn.in = burn.in, thin = thin,
    verbose = FALSE)
summary(M2st_anova)
M2st_anova_nointer &lt;- Bcartime(formula = f2, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", W = Weng, model = "anova", interaction = FALSE,
    family = "poisson", package = "CARBayesST", N = N, burn.in = burn.in,
    thin = thin, verbose = FALSE)
summary(M2st_anova_nointer)
M2st_sepspat &lt;- Bcartime(formula = f2, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", W = Weng, model = "sepspatial", family = "poisson",
    package = "CARBayesST", N = N, burn.in = burn.in, thin = thin,
    verbose = FALSE)
summary(M2st_sepspat)
M2st_ar &lt;- Bcartime(formula = f2, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", W = Weng, model = "ar", AR = 1, family = "poisson",
    package = "CARBayesST", N = N, burn.in = burn.in, thin = thin,
    verbose = FALSE)
summary(M2st_ar)
M2st_ar.v &lt;- Bcartime(formula = f2, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", W = Weng, model = "ar", family = "poisson",
    package = "CARBayesST", N = N, burn.in = burn.in, thin = thin,
    validrows = vs, verbose = FALSE)
M2st_anova.v &lt;- Bcartime(formula = f2, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", W = Weng, model = "anova", family = "poisson",
    package = "CARBayesST", N = N, burn.in = burn.in, thin = thin,
    validrows = vs, verbose = FALSE)
summary(M2st_ar.v)
summary(M2st_anova.v)


## Spatio-temporal Normal models ###############################
colnames(engdeaths)
f3 &lt;- sqrt(no2) ~ jsa + log10(houseprice) + log(popdensity)

M3st_linear &lt;- Bcartime(formula = f3, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", W = Weng, model = "linear", family = "gaussian",
    package = "CARBayesST", N = N, burn.in = burn.in, thin = thin,
    verbose = FALSE)
summary(M3st_linear)
M3st_anova &lt;- Bcartime(formula = f3, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", W = Weng, model = "anova", family = "gaussian",
    package = "CARBayesST", N = N, burn.in = burn.in, thin = thin,
    verbose = FALSE)
summary(M3st_anova)
M3st_anova_nointer &lt;- Bcartime(formula = f3, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", W = Weng, model = "anova", interaction = FALSE,
    family = "gaussian", package = "CARBayesST", N = N, burn.in = burn.in,
    thin = thin, verbose = FALSE)
summary(M3st_anova_nointer)
M3st_ar &lt;- Bcartime(formula = f3, data = engdeaths, scol = "spaceid",
    tcol = "Weeknumber", W = Weng, model = "ar", AR = 2, family = "gaussian",
    package = "CARBayesST", N = N, burn.in = burn.in, thin = thin,
    verbose = FALSE)
summary(M3st_ar)

# Execute the following examples if INLA is available
if (require(INLA)) {
    N &lt;- 55
    burn.in &lt;- 5
    thin &lt;- 1
    vs &lt;- sample(nrow(engtotals), 5)
    

    # Spatial Binomial GLM

    f1 &lt;- noofhighweeks ~ jsa + log10(houseprice) + log(popdensity) +  sqrt(no2)

     M1.inla.bym &lt;- Bcartime(data = engtotals, formula = f1,
        W = Weng, scol = "spaceid", model = c("bym"), package = "inla",
        family = "binomial", link="logit",  trials = "nweek", N = N, burn.in = burn.in,
        thin = thin)
     summary(M1.inla.bym)



    ## Spatial only Poisson

    f2inla &lt;- covid ~ jsa + log10(houseprice) + log(popdensity) +
        sqrt(no2)

    M2.inla.bym &lt;- Bcartime(data = engtotals, formula = f2inla,
        W = Weng, scol = "spaceid", offsetcol = "logEdeaths",
        model = c("bym"), package = "inla", link = "log",
        family = "poisson", N = N, burn.in = burn.in, thin = thin)
    summary(M2.inla.bym)



    ## Normal models

    f3 &lt;- sqrt(no2) ~ jsa + log10(houseprice) + log(popdensity)

    ## Fit BYM with iid random effect
    M3.inla.bym &lt;- Bcartime(data = engtotals, formula = f3,
        W = Weng, scol = "spaceid", model = c("bym"), package = "inla",
        family = "gaussian", N = N, burn.in = burn.in, thin = thin)
    summary(M3.inla.bym)

    # validation
    M3.inla.bym.v &lt;- Bcartime(data = engtotals, formula = f3,
        W = Weng, scol = "spaceid", model = c("bym"), package = "inla",
        family = "gaussian",  validrows = vs, N = N, burn.in = burn.in,
        thin = thin)

    summary(M3.inla.bym.v)


    ###### Spatio-temporal INLA models

   
    f1 &lt;- highdeathsmr ~ jsa + log10(houseprice) + log(popdensity)
    nweek &lt;- rep(1, nrow(engdeaths))
    engdeaths$nweek &lt;- rep(1, nrow(engdeaths))

    ## INLA Binomial
  
    model &lt;- c("bym", "ar1")
    M1st_inla.bym &lt;- Bcartime(data = engdeaths, formula = f1,
        W = Weng, scol = "spaceid", tcol = "Weeknumber",
        model = model, trials = "nweek", family = "binomial", link="logit", 
        package = "inla", N = N, burn.in = burn.in, thin = thin)
    summary(M1st_inla.bym)

    M1st_inla_v &lt;- Bcartime(data = engdeaths, formula = f1,
        W = Weng, scol = "spaceid", tcol = "Weeknumber",
        offsetcol = "logEdeaths", model = model, trials = "nweek",
        family = "binomial",  link="logit", package = "inla", validrow = vs,
        N = N, burn.in = burn.in, thin = thin)
    summary(M1st_inla_v)


    model &lt;- c("bym", "none")
    M1st_inla.bym.none &lt;- Bcartime(data = engdeaths, formula = f1,
        W = Weng, scol = "spaceid", tcol = "Weeknumber",
        model = model, trials = "nweek", family = "binomial", link="logit", 
        package = "inla", N = N, burn.in = burn.in, thin = thin)
    summary(M1st_inla.bym.none)


    model &lt;- c("bym")
    M1st_inla.bym.none &lt;- Bcartime(data = engdeaths, formula = f1,
        W = Weng, scol = "spaceid", tcol = "Weeknumber",
        model = model, trials = "nweek", family = "binomial", link="logit", 
        package = "inla", N = N, burn.in = burn.in, thin = thin)
    summary(M1st_inla.bym.none)


    ## Poisson models
    f2inla &lt;- covid ~ jsa + log10(houseprice) + log(popdensity) +
        n0 + n1 + n2 + n3

    model &lt;- c("bym", "ar1")
    M2stinla &lt;- Bcartime(data = engdeaths, formula = f2inla,
        W = Weng, scol = "spaceid", tcol = "Weeknumber",
        offsetcol = "logEdeaths", model = model, link = "log",
        family = "poisson", package = "inla", N = N, burn.in = burn.in,
        thin = thin)

    summary(M2stinla)

    M2stinla.v &lt;- Bcartime(data = engdeaths, formula = f2inla,
        W = Weng, scol = "spaceid", tcol = "Weeknumber",
        offsetcol = "logEdeaths", model = model, link = "log",
        family = "poisson", package = "inla", validrows = vs,
        N = N, burn.in = burn.in, thin = thin)

    summary(M2stinla.v)

    ## Normal models

    f3 &lt;- sqrt(no2) ~ jsa + log10(houseprice) + log(popdensity)

    model &lt;- c("bym", "iid")
    M3inla.bym.iid &lt;- Bcartime(data = engdeaths, formula = f3,
        W = Weng, scol = "spaceid", tcol = "Weeknumber",
        model = model, family = "gaussian", package = "inla",
        validrows = vs, N = N, burn.in = burn.in, thin = thin)
    summary(M3inla.bym.iid)

    model &lt;- c("bym", "ar1")
    M3inla.bym.ar1 &lt;- Bcartime(data = engdeaths, formula = f3,
        W = Weng, scol = "spaceid", tcol = "Weeknumber",
        model = model, family = "gaussian", package = "inla",
        validrows = vs, N = N, burn.in = burn.in, thin = thin)
    summary(M3inla.bym.ar1)

}


</code></pre>

<hr>
<h2 id='BCauchy'>Cauchy prior simulation example.</h2><span id='topic+BCauchy'></span>

<h3>Description</h3>

<p>Cauchy prior simulation example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BCauchy(
  method = "exact",
  true.theta = 1,
  n = 25,
  N = 10000,
  rseed = 44,
  tuning.sd = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BCauchy_+3A_method">method</code></td>
<td>
<p>Which method or package to use. Possibilities are: 
</p>
  
<ul>
<li><p> &quot;exact&quot;: Use exact numerical integration.  
</p>
</li>
<li><p> &quot;importance&quot;: Use importance sampling with the prior distribution as 
the importance sampling distribution.
</p>
</li>
<li><p> &quot;rejection&quot;: Use rejection sampling with the prior distribution as 
the importance sampling distribution.
</p>
</li>
<li><p> &quot;independence&quot;: Use the Metropolis-Hastings independence sampler with 
the prior distribution as the proposal distribution.
</p>
</li>
<li><p> &quot;randomwalk&quot;: Use the Metropolis-Hastings random-walk sampler with 
normal distribution with mean 0 and variance (tuning.sd)^2 as the 
increment distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="BCauchy_+3A_true.theta">true.theta</code></td>
<td>
<p>True value of theta with a default value of 5.</p>
</td></tr>
<tr><td><code id="BCauchy_+3A_n">n</code></td>
<td>
<p>Data sample size; defaults to 100.</p>
</td></tr>
<tr><td><code id="BCauchy_+3A_n">N</code></td>
<td>
<p>is the number of Monte Carlo samples.</p>
</td></tr>
<tr><td><code id="BCauchy_+3A_rseed">rseed</code></td>
<td>
<p>is the random number seed for drawing data samples.</p>
</td></tr>
<tr><td><code id="BCauchy_+3A_tuning.sd">tuning.sd</code></td>
<td>
<p>is the standard deviation of the proposal increment distribution for the random walk sampler.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimated posterior mean, ybar (the data mean)
and the values of the numerator and the denominator integrals
The routine simulates n observations from N(theta, 1). 
Mean of the simulated data values are returned as ybar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
BCauchy(true.theta = 1, n=25) 
BCauchy(true.theta = 5, n=100) 
BCauchy(method="importance", true.theta = 1, n=25) 
BCauchy(method="importance", true.theta = 1, n=25, N=20000) 
BCauchy(method="rejection", true.theta = 1, n=25) 
BCauchy(method="independence", true.theta = 1, n=25) 
BCauchy(method="randomwalk", true.theta = 1, n=25, tuning.sd =1) 

</code></pre>

<hr>
<h2 id='Bmchoice'>Model choice criteria calculation for univariate 
normal model for both known and unknown sigma^2</h2><span id='topic+Bmchoice'></span>

<h3>Description</h3>

<p>Model choice criteria calculation for univariate 
normal model for both known and unknown sigma^2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bmchoice(
  case = "Exact.sigma2.known",
  y = ydata,
  mu0 = mean(y),
  sigma2 = 22,
  kprior = 1,
  prior.M = 1,
  prior.sigma2 = c(2, 1),
  N = 10000,
  rseed = 44
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bmchoice_+3A_case">case</code></td>
<td>
<p>One of the three cases: 
</p>
  
<ul>
<li><p> &quot;Exact.sigma2.known&quot;: Use exact theoretical calculation.  
</p>
</li>
<li><p> &quot;MC.sigma2.known&quot;: Use Monte Carlo methods for drawing samples from the 
posterior assuming known sigma2.  
</p>
</li>
<li><p> &quot;MC.sigma2.unknown&quot;: Use the Gibbs sampler to generate samples 
from the joint posterior distribution of theta and sigma^2.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Bmchoice_+3A_y">y</code></td>
<td>
<p>A vector of data values. Default is 28 ydata values from the package bmstdr</p>
</td></tr>
<tr><td><code id="Bmchoice_+3A_mu0">mu0</code></td>
<td>
<p>The value of the prior mean if kprior=0. Default is the data mean.</p>
</td></tr>
<tr><td><code id="Bmchoice_+3A_sigma2">sigma2</code></td>
<td>
<p>Value of the known data variance; defaults to sample variance of the data. This is ignored 
in the third case when sigma2 is assumed to be unknown.</p>
</td></tr>
<tr><td><code id="Bmchoice_+3A_kprior">kprior</code></td>
<td>
<p>A scalar providing how many data standard deviation the prior
mean is from the data mean. Default value is 0.</p>
</td></tr>
<tr><td><code id="Bmchoice_+3A_prior.m">prior.M</code></td>
<td>
<p>Prior sample size, defaults to 10^(-4).</p>
</td></tr>
<tr><td><code id="Bmchoice_+3A_prior.sigma2">prior.sigma2</code></td>
<td>
<p>Shape and scale parameter value for the gamma prior on 1/sigma^2, the precision.</p>
</td></tr>
<tr><td><code id="Bmchoice_+3A_n">N</code></td>
<td>
<p>The number of samples to generate.</p>
</td></tr>
<tr><td><code id="Bmchoice_+3A_rseed">rseed</code></td>
<td>
<p>The random number seed. Defaults to 44 to reproduce the results
in the book  Sahu (2022).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the exact values of pdic, dic, pdicalt, dicalt,
pwaic1, waic1, pwaic2, waic2, gof, penalty and pmcc.
Also prints out the posterior mean and variance.
@references
Sahu SK (2022).
<em>Bayesian Modeling of Spatio Temporal Data with R</em>, 1st edition.
Chapman and Hall, Boca Raton.
<a href="https://doi.org/10.1201/9780429318443">https://doi.org/10.1201/9780429318443</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Bmchoice()
b1 &lt;- Bmchoice(case="Exact.sigma2.known")
b2 &lt;- Bmchoice(case="MC.sigma2.known")
d1 &lt;- Bmchoice(case="MC.sigma2.unknown")
d2 &lt;- Bmchoice(y=rt(100, df=8),  kprior=1, prior.M=1)

</code></pre>

<hr>
<h2 id='Bmoving_sptime'>Model fitting and validation for spatio-temporal data from moving sensors in time.</h2><span id='topic+Bmoving_sptime'></span>

<h3>Description</h3>

<p>Model fitting and validation for spatio-temporal data from moving sensors in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bmoving_sptime(
  formula,
  data,
  coordtype,
  coords,
  prior.sigma2 = c(2, 1),
  prior.tau2 = c(2, 1),
  prior.phi = NULL,
  prior.phi.param = NULL,
  scale.transform = "NONE",
  ad.delta = 0.8,
  t.depth = 12,
  s.size = 0.01,
  N = 2500,
  burn.in = 1000,
  no.chains = 1,
  validrows = 10,
  predspace = FALSE,
  newdata = NULL,
  mchoice = TRUE,
  plotit = FALSE,
  rseed = 44,
  verbose = TRUE,
  knots.coords = NULL,
  g_size = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bmoving_sptime_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;formula&quot; (or one that can be coerced to that class):
a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_data">data</code></td>
<td>
<p>The data frame for which the model formula is to be fitted.
The data frame should be in long format having one row for each location and  time
combination. The data frame must be ordered by time within each site, and should
optionally have a column, named s.index,  providing the site indices.
Thus the data,  with n sites and T times within each site, should be
organized in the order: (s1, t1), (s1, t2), ... (s1, T), ... (sn, t1), ... (sn, T). 
The data frame should also contain two columns giving the coordinates of the
locations for spatio temporal model fitting.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_coordtype">coordtype</code></td>
<td>
<p>Type of coordinates: utm, lonlat or plain with utm 
(supplied in meters) as the default. Distance will be calculated in units of kilometer
if this argument is either utm or lonlat. Euclidean distance will be calculated 
if this is given as the third type plain.  If  distance in meter is to be calculated 
then coordtype should be passed on as plain although the coords are supplied in UTM.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_coords">coords</code></td>
<td>
<p>A vector of size 2 giving the column numbers of the data 
frame which contain the coordinates of the data locations.  
Here the supplied data frame must contain a column named 'time' which 
should indicate the time index of the data row. The values in the column 'time' 
should be positive integers starting from 1.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_prior.sigma2">prior.sigma2</code></td>
<td>
<p>Shape and scale parameter value for the gamma prior on 1/sigma^2, the precision.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_prior.tau2">prior.tau2</code></td>
<td>
<p>Shape and scale parameter value for the gamma prior on tau^2, the nugget effect.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_prior.phi">prior.phi</code></td>
<td>
<p>Specifies the prior distribution for <code class="reqn">\phi</code> only when 
package is one of Stan, spTimer or spTDyn.  Distribution options 
uniform specified by &quot;Unif&quot; and gamma specified by &quot;Gamm&quot; have been implemented in 
both Stan and spTimer. Additionally a half-Cauchy prior distribution specified as &quot;Cauchy&quot;
has been implemented in Stan. In the case of spTimer the uniform distribution is discrete 
while in the case of Stan the uniform distribution is continuous. In the case of 
spTimer the option &quot;FIXED&quot; can be used to keep the value fixed. In that case the fixed value 
can be given by by a scalar value as the argument <code>prior.phi.param</code> below or it can be left 
unspecified in which case the  fixed value of <code class="reqn">\phi</code> is chosen as 3/maximum distance between the 
data locations.  The  &quot;FIXED&quot; option is not available for the Stan package.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_prior.phi.param">prior.phi.param</code></td>
<td>
<p>Lower and upper limits of the uniform prior distribution for
phi the spatial decay parameter. For the default uniform distribution the values correspond
to an effective range that is between 1% and 100% of the maximum distance
between the data locations. For the Gamma distribution the default values are 2 and 1
and for the Cauchy distribution the default values are 0, 1 which specifies
a half-Cauchy distribution in <code class="reqn">(0, \infty)</code>.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_scale.transform">scale.transform</code></td>
<td>
<p>Transformation of the response variable. It can take three values: SQRT, LOG or NONE.
Default value is &quot;NONE&quot;.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_ad.delta">ad.delta</code></td>
<td>
<p>Adaptive delta controlling the behavior of Stan during fitting.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_t.depth">t.depth</code></td>
<td>
<p>Maximum allowed tree depth in the fitting process of Stan.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_s.size">s.size</code></td>
<td>
<p>step size in the fitting process of Stan.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_n">N</code></td>
<td>
<p>MCMC sample size.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_burn.in">burn.in</code></td>
<td>
<p>How many initial iterations to discard. 
Only relevant for MCMC based model fitting, i.e., when package is spBayes or Stan.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_no.chains">no.chains</code></td>
<td>
<p>Number of parallel chains to run in Stan.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_validrows">validrows</code></td>
<td>
<p>Either a number of randomly selected data rows to validate
or a vector giving the row numbers of the data set for validation.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_predspace">predspace</code></td>
<td>
<p>A 0-1 flag indicating whether spatial predictions are to be made.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_newdata">newdata</code></td>
<td>
<p>A new data frame with the same column structure as the model fitting data set.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_mchoice">mchoice</code></td>
<td>
<p>Logical scalar value: whether model choice statistics should be calculated.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_plotit">plotit</code></td>
<td>
<p>Logical scalar value: whether to plot the predictions against the observed values.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_rseed">rseed</code></td>
<td>
<p>Random number seed that controls the starting point for the random number stream.
A set value is required to help reproduce the results.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar value: whether to print various estimates and statistics.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_knots.coords">knots.coords</code></td>
<td>
<p>Only relevant for GPP models fitted by either spTimer or spTDyn. 
Optional two column matrix of UTM-X and UTM-Y coordinates of the knots in kilometers.
It is preferable to specify the g_size parameter instead.</p>
</td></tr>
<tr><td><code id="Bmoving_sptime_+3A_g_size">g_size</code></td>
<td>
<p>Only relevant for GPP models fitted by either spTimer or spTDyn. 
The grid size c(m, n) for the knots for the GPP model. A square grid is assumed 
if this is passed on as a scalar. This does not need to be given if knots.coords is given instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> params - A table of parameter estimates 
</p>
</li>
<li><p> fit  -   The fitted model object. 
</p>
</li>
<li><p> datatostan - A list containing all the information sent to the 
rstan package. 
</p>
</li>
<li><p> prior.phi.param  -    This contains the values of 
the hyperparameters of the prior distribution for the spatial 
decay parameter <code class="reqn">phi</code>.   
</p>
</li>
<li><p> prior.phi  -    This contains the name of  of the prior 
distribution for the spatial decay parameter <code class="reqn">phi</code>.  
</p>
</li>
<li><p> validationplots - Present only if validation has been performed. 
Contains three validation plots with or without segment and 
an ordinary plot.  See <code><a href="#topic+obs_v_pred_plot">obs_v_pred_plot</a></code> for more. 
</p>
</li>
<li><p> fitteds  -   A vector of fitted values.   
</p>
</li>
<li><p> residuals   -   A vector of residual values.  
</p>
</li>
<li><p> package   -   The name of the package used for model fitting.  
This is  always stan for this function. 
</p>
</li>
<li><p> model   -   The name of the fitted model.   
</p>
</li>
<li><p> call  -   The command used to call the model fitting function.  
</p>
</li>
<li><p> formula   -   The input formula for the regression part of 
the model.  
</p>
</li>
<li><p> scale.transform  -   The transformation adopted by the 
input argument with the same name.  
</p>
</li>
<li><p> sn   -   The number of data locations used in fitting.  
</p>
</li>
<li><p> tn   -   The number of time points used in fitting for each location.  
</p>
</li>
<li><p> computation.time  -   Computation time required 
to run the model fitting.     
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+Bsptime">Bsptime</a></code> for spatio-temporal  model fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
deep &lt;- argo_floats_atlantic_2003[argo_floats_atlantic_2003$depth==3, ]
deep$x2inter &lt;- deep$xinter*deep$xinter
deep$month &lt;- factor(deep$month)
deep$lat2 &lt;- (deep$lat)^2
deep$sin1 &lt;- round(sin(deep$time*2*pi/365), 4)
deep$cos1 &lt;- round(cos(deep$time*2*pi/365), 4)
deep$sin2 &lt;- round(sin(deep$time*4*pi/365), 4)
deep$cos2 &lt;- round(cos(deep$time*4*pi/365), 4)
deep[, c( "xlat2", "xsin1", "xcos1", "xsin2", "xcos2")] &lt;- 
scale(deep[,c("lat2", "sin1", "cos1", "sin2", "cos2")])
f2 &lt;- temp ~ xlon + xlat + xlat2+ xinter + x2inter 
M2 &lt;- Bmoving_sptime(formula=f2, data = deep, coordtype="lonlat", 
coords = 1:2, N=11, burn.in=6, validrows =NULL, mchoice = FALSE)
summary(M2)
plot(M2)
names(M2)
# Testing for smaller data sets with different data pattern  
d2 &lt;- deep[1:25, ]
d2$time &lt;- 1:25 
# Now there is no missing times 
M1 &lt;- Bmoving_sptime(formula=f2, data = d2, coordtype="lonlat", coords = 1:2, 
N=11, burn.in=6,  mchoice = FALSE) 
summary(M1)
d2[26, ] &lt;- d2[25, ]
# With multiple observation at the same location and time 
M1 &lt;- Bmoving_sptime(formula=f2, data = d2, coordtype="lonlat", coords = 1:2, 
N=11, burn.in=6,  mchoice = FALSE) 
summary(M1)
d2[27, ] &lt;- d2[24, ]
d2[27, 3] &lt;- 25
# With previous location re-sampled 
M1 &lt;- Bmoving_sptime(formula=f2, data = d2, coordtype="lonlat", coords = 1:2, 
N=11, burn.in=6,  mchoice = FALSE) 
summary(M1)

</code></pre>

<hr>
<h2 id='bmstdr_variogram'>Calculates and plots the variogram cloud and an estimated variogram.</h2><span id='topic+bmstdr_variogram'></span>

<h3>Description</h3>

<p>Calculates and plots the variogram cloud and an estimated variogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmstdr_variogram(
  formula = yo3 ~ utmx + utmy,
  coordtype = "utm",
  data = nyspatial,
  nbins = 30
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bmstdr_variogram_+3A_formula">formula</code></td>
<td>
<p>Its a formula argument for the response and the coordinates.</p>
</td></tr>
<tr><td><code id="bmstdr_variogram_+3A_coordtype">coordtype</code></td>
<td>
<p>Type of coordinates: utm, lonlat or plain with utm 
(supplied in meters) as the default. Distance will be calculated in units of kilometer
if this argument is either utm or lonlat. Euclidean distance will be calculated 
if this is given as the third type plain.  If  distance in meter is to be calculated 
then coordtype should be passed on as plain although the coords are supplied in UTM.</p>
</td></tr>
<tr><td><code id="bmstdr_variogram_+3A_data">data</code></td>
<td>
<p>A data frame containing the response and the co-ordinates</p>
</td></tr>
<tr><td><code id="bmstdr_variogram_+3A_nbins">nbins</code></td>
<td>
<p>Number of bins for the variogram. Default is 30.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> cloud - A data frame containing the variogram cloud. 
This contains pairs of all the data locations, distance 
between the locations and the variogram value for the pair. 
</p>
</li>
<li><p> variogram  A data frame containing the variogram values in 
each bin.   
</p>
</li>
<li><p> cloudplot A ggplot2 object of the plot of the  variogram cloud. 
</p>
</li>
<li><p> variogramplot A ggplot2 object of the plot of the  binned variogram
values. 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- bmstdr_variogram(data=nyspatial, formula = yo3~utmx + utmy, 
coordtype="utm", nb=50)
names(a)
if (require(ggpubr)) ggarrange(a$cloudplot, a$variogramplot, nrow=1, ncol=2)
</code></pre>

<hr>
<h2 id='Bnormal'>N(theta, sigma2):  Using different methods.</h2><span id='topic+Bnormal'></span>

<h3>Description</h3>

<p>N(theta, sigma2):  Using different methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bnormal(
  package = "exact",
  y = ydata,
  mu0 = mean(y),
  kprior = 0,
  prior.M = 1e-04,
  prior.sigma2 = c(0, 0),
  N = 2000,
  burn.in = 1000,
  rseed = 44
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bnormal_+3A_package">package</code></td>
<td>
<p>Which package (or method) to use. Possibilities are: 
</p>
  
<ul>
<li><p> &quot;exact&quot;: Use exact theoretical calculation.  
</p>
</li>
<li><p> &quot;RGibbs&quot;: Use Gibbs sampler using R code.  
</p>
</li>
<li><p> &quot;stan&quot;: Use HMC by implementing in Stan.
</p>
</li>
<li><p> &quot;inla&quot;: Use the INLA package.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Bnormal_+3A_y">y</code></td>
<td>
<p>A vector of data values. Default is 28 ydata values from the package bmstdr</p>
</td></tr>
<tr><td><code id="Bnormal_+3A_mu0">mu0</code></td>
<td>
<p>The value of the prior mean if kprior=0. Default is the data mean.</p>
</td></tr>
<tr><td><code id="Bnormal_+3A_kprior">kprior</code></td>
<td>
<p>A scalar providing how many data standard deviation the prior
mean is from the data mean. Default value is 0.</p>
</td></tr>
<tr><td><code id="Bnormal_+3A_prior.m">prior.M</code></td>
<td>
<p>Prior sample size, defaults to 10^(-4).#'</p>
</td></tr>
<tr><td><code id="Bnormal_+3A_prior.sigma2">prior.sigma2</code></td>
<td>
<p>Shape and scale parameter value for the gamma prior on 1/sigma^2, the precision.</p>
</td></tr>
<tr><td><code id="Bnormal_+3A_n">N</code></td>
<td>
<p>is the number of Gibbs sampling iterations</p>
</td></tr>
<tr><td><code id="Bnormal_+3A_burn.in">burn.in</code></td>
<td>
<p>is the number of initial iterations to discard before 
making inference.</p>
</td></tr>
<tr><td><code id="Bnormal_+3A_rseed">rseed</code></td>
<td>
<p>is the random number seed defaults to 44.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the exact posterior means and variances of theta and sigma2
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the posterior mean and variance  using `exact' methods - no sampling 
# or approximation  
Bnormal(kprior = 1, prior.M = 1, prior.sigma2 = c(2, 1))
# Use default non-informative prior
Bnormal(mu0 = 0) 
# Start creating table
y &lt;-  ydata
mu0 &lt;-  mean(y)
kprior &lt;-  1
prior.M  &lt;-  1
prior.sigma2 &lt;- c(2, 1)
N  &lt;-  10000
eresults &lt;- Bnormal(package = "exact", y = y, mu0 = mu0, kprior = kprior,
    prior.M = prior.M, prior.sigma2 = prior.sigma2)
eresults 
# Run Gibbs sampling
samps &lt;- Bnormal(package = "RGibbs", y = y, mu0 = mu0, kprior = kprior,
    prior.M = prior.M, prior.sigma2 = prior.sigma2, N = N)
gres &lt;- list(mean_theta = mean(samps[, 1]), var_theta = var(samps[, 1]),
    mean_sigma2 = mean(samps[, 2]), var_sigma2 = var(samps[, 2]))
glow &lt;- list(theta_low = quantile(samps[, 1], probs = 0.025), var_theta = NA,
    sigma2_low = quantile(samps[, 2], probs = 0.025), var_sigma2 = NA)
gupp &lt;- list(theta_low = quantile(samps[, 1], probs = 0.975), var_theta = NA,
    sigma2_low = quantile(samps[, 2], probs = 0.975), var_sigma2 = NA)
a &lt;- rbind(unlist(eresults), unlist(gres), unlist(glow), unlist(gupp))
cvsamp &lt;- sqrt(samps[, 2])/samps[, 1]
cv &lt;- c(NA, mean(cvsamp), quantile(cvsamp, probs = c(0.025, 0.975)))
u &lt;- data.frame(a, cv)
rownames(u) &lt;- c("Exact", "Estimate", "2.5%", "97.5%")
print(u)
# End create table 
##
# Compute using the model fitted by Stan 
u &lt;- Bnormal(package = "stan", kprior = 1, prior.M = 1, prior.sigma = c(2, 1),
    N = 2000, burn.in = 1000)
print(u)
###
# Compute using INLA 
if (require(INLA)) {
    u &lt;- Bnormal(package = "inla", kprior = 1, prior.M = 1, prior.sigma = c(2,
        1), N = 1000)
    print(u)
}
</code></pre>

<hr>
<h2 id='Bspatial'>Bayesian regression model fitting for point referenced spatial data. 
Calculates parameter estimates, validation statistics, and 
estimated values of several Bayesian model choice criteria.</h2><span id='topic+Bspatial'></span>

<h3>Description</h3>

<p>Bayesian regression model fitting for point referenced spatial data. 
Calculates parameter estimates, validation statistics, and 
estimated values of several Bayesian model choice criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bspatial(
  formula,
  data,
  package = "none",
  model = "lm",
  coordtype = NULL,
  coords = NULL,
  validrows = NULL,
  scale.transform = "NONE",
  prior.beta0 = 0,
  prior.M = 1e-04,
  prior.sigma2 = c(2, 1),
  prior.tau2 = c(2, 0.1),
  phi = NULL,
  prior.phi.param = NULL,
  prior.range = c(1, 0.5),
  prior.sigma = c(1, 0.005),
  offset = c(10, 140),
  max.edge = c(50, 1000),
  cov.model = "exponential",
  N = 5000,
  burn.in = 1000,
  rseed = 44,
  n.report = 500,
  no.chains = 1,
  ad.delta = 0.99,
  s.size = 0.01,
  t.depth = 15,
  verbose = TRUE,
  plotit = TRUE,
  mchoice = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bspatial_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;formula&quot; (or one that can be coerced to that class):
a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_data">data</code></td>
<td>
<p>The data frame for which the model formula is to be fitted. 
If a spatial model is to be fitted then the data frame should contain 
two columns containing the locations of the coordinates. See the <code>coords</code> argument below.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_package">package</code></td>
<td>
<p>Which package is to be used in model fitting? Currently available 
packages are:
</p>
  
<ul>
<li><p> &quot;spBayes&quot;: The model implemented is the marginal model with 
nugget effect using the <code>spLM</code> function.  
</p>
</li>
<li><p> &quot;stan&quot;: The model implemented is the full spatial random effect model 
with nugget effect where the decay parameter has been assumed to be fixed. 
</p>
</li>
<li><p> &quot;inla&quot;: The model fitted is the spatial random effect model with the 
nugget effect.
</p>
</li>
<li><p> &quot;none&quot;:  In this case case, the argument  <code>model</code> must be 
specified either as &quot;lm&quot; or &quot;spat&quot;. See below.
</p>
</li></ul>

<p>Further details and more examples are provided in Chapter 6 of the book 
Sahu (2022).</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_model">model</code></td>
<td>
<p>Only used when the package has been chosen to be &quot;none&quot;. 
It can take one of two values: either &quot;lm&quot; or &quot;spat&quot;. The &quot;lm&quot; option is for an independent error 
regression model while the &quot;spat&quot; option fits a  spatial model without any nugget effect.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_coordtype">coordtype</code></td>
<td>
<p>Type of coordinates: utm, lonlat or plain with utm 
(supplied in meters) as the default. Distance will be calculated in units of kilometer
if this argument is either utm or lonlat. Euclidean distance will be calculated 
if this is given as the third type plain.  If  distance in meter is to be calculated 
then coordtype should be passed on as plain although the coords are supplied in UTM.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_coords">coords</code></td>
<td>
<p>A vector of size two identifying the two column numbers 
of the data frame to take as coordinates. 
Or this can be given as a  matrix of number of sites by 2 providing the coordinates of all the
data locations.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_validrows">validrows</code></td>
<td>
<p>A vector of site indices which should be used for validation. 
This function does not allow some sites to be used for both fitting and validation.
The remaining observations will be used for model fitting. The default NULL value instructs that
validation will not be performed.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_scale.transform">scale.transform</code></td>
<td>
<p>Transformation of the response variable. It can take three values: SQRT, LOG or NONE.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_prior.beta0">prior.beta0</code></td>
<td>
<p>A scalar value or a vector providing the prior mean for beta parameters.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_prior.m">prior.M</code></td>
<td>
<p>Prior precision value (or matrix) for beta.  Defaults to a diagonal 
matrix with diagonal values 10^(-4).</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_prior.sigma2">prior.sigma2</code></td>
<td>
<p>Shape and scale parameter value for the gamma prior on 1/sigma^2, the precision.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_prior.tau2">prior.tau2</code></td>
<td>
<p>Shape and scale parameter value for the gamma prior on tau^2, the nugget effect.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_phi">phi</code></td>
<td>
<p>The spatial decay parameter for the exponential covariance function. Only 
used if the package is  Stan or the model is a spatial model &quot;spat&quot; without nugget effect when the 
<code>package</code> is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_prior.phi.param">prior.phi.param</code></td>
<td>
<p>Lower and upper limits of the uniform prior distribution for
<code class="reqn">\phi</code>,  the spatial decay parameter when the package is <code>spBayes</code>. 
If this is not specified the default values are chosen so that the effective range is
uniformly distributed between 25% and 100% of the maximum distance between data locations.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_prior.range">prior.range</code></td>
<td>
<p>A length 2 vector, with (range0, Prange) specifying 
that <code class="reqn">P(\rho &lt; \rho_0)=p_{\rho}</code>, where <code class="reqn">\rho</code> is the spatial range of 
the random field. If Prange is NA, then range0 is used as a fixed range value. 
If this parameter is unspecified then range0=0.90 * maximum distance 
and Prange =0.95. If instead a single value is specified then the range is set at the single value.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_prior.sigma">prior.sigma</code></td>
<td>
<p>A length 2 vector, with (sigma0, Psigma) specifying 
that <code class="reqn">P(\sigma &gt; \sigma_0)=p_{\sigma}</code>, where <code class="reqn">\sigma</code> is the marginal 
standard deviation of the field. If Psigma is NA, then sigma0 is used as a fixed range value.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_offset">offset</code></td>
<td>
<p>Only used in INLA based modeling.  Offset parameter. See documentation for <code>inla.mesh.2d</code>.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_max.edge">max.edge</code></td>
<td>
<p>Only used in INLA based modeling. See documentation for <code>inla.mesh.2d</code>.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_cov.model">cov.model</code></td>
<td>
<p>Only relevant for the spBayes package.  Default is the exponential model. 
See the documentation for <code>spLM</code> in the package spBayes.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_n">N</code></td>
<td>
<p>MCMC sample size. Default value 5000.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_burn.in">burn.in</code></td>
<td>
<p>How many initial iterations to discard. Default value 1000. 
Only relevant for MCMC based model fitting, i.e., when package is spBayes or Stan.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_rseed">rseed</code></td>
<td>
<p>Random number seed that controls the starting point for the random number stream.
A set value is required to help reproduce the results.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_n.report">n.report</code></td>
<td>
<p>How many times to report in MCMC progress. This is used only when the package is spBayes.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_no.chains">no.chains</code></td>
<td>
<p>Number of parallel chains to run in Stan.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_ad.delta">ad.delta</code></td>
<td>
<p>Adaptive delta controlling the behavior of Stan during fitting.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_s.size">s.size</code></td>
<td>
<p>step size in the fitting process of Stan.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_t.depth">t.depth</code></td>
<td>
<p>Maximum allowed tree depth in the fitting process of Stan.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar value: whether to print various estimates and statistics.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_plotit">plotit</code></td>
<td>
<p>Logical scalar value: whether to plot the predictions against the observed values.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_mchoice">mchoice</code></td>
<td>
<p>Logical scalar value: whether model choice statistics should be calculated.</p>
</td></tr>
<tr><td><code id="Bspatial_+3A_...">...</code></td>
<td>
<p>Any additional arguments that may be passed on to the fitting package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> params -  A table of parameter estimates 
</p>
</li>
<li><p>  fit -  The fitted model object. This is present only if a named 
package, e.g.   <code>spBayes</code>  has been used. 
</p>
</li>
<li><p>  max.d -  Maximum distance between data locations. 
This is in unit of kilometers unless the <code>coordtype</code> argument 
is set as <code>plain</code>.     
</p>
</li>
<li><p>  fitteds -  A vector of fitted values.   
</p>
</li>
<li><p>  mchoice -  Calculated model choice statistics if those have been 
requested by the input argument <code>mchoice=TRUE</code>. Not all model fits will contain 
all the model choice statistics. 
</p>
</li>
<li><p>  stats -  The four validation statistics: rmse, mae, crps and coverage. 
This is present only if model validation has been performed. 
</p>
</li>
<li><p>  yobs_preds -  A data frame containing the validation rows of the model 
fitting data  frame. The last five columns of this data frame contains 
the validation prediction summaries: mean, sd, median, and 95% prediction interval. 
This is present only if model validation has been performed. 
</p>
</li>
<li><p>  valpreds -  A matrix containing the MCMC samples of the validation predictions. 
The dimension of this matrix is the number of validations times the number of retained 
MCMC samples. This is present only if model validation has been performed.  
</p>
</li>
<li><p> validationplots - Present only if validation has been performed. 
Contains three validation plots with or without segment and 
an ordinary plot.  See <code><a href="#topic+obs_v_pred_plot">obs_v_pred_plot</a></code> for more. 
</p>
</li>
<li><p>  residuals -  A vector of residual values.  
</p>
</li>
<li><p>  sn -  The number of data locations used in fitting.
</p>
</li>
<li><p>  tn  Defaults to 1. Used for plotting purposes. 
</p>
</li>
<li><p>  phi -  If present this contains the fixed value of 
the spatial decay parameter <code class="reqn">phi</code> used to fit the model. 
</p>
</li>
<li><p>  prior.phi.param -   If present this contains the values of the hyperparameters 
of the prior distribution for the spatial decay parameter <code class="reqn">phi</code>.  
</p>
</li>
<li><p>  prior.range -   Present only if the <code>INLA</code> package has been used 
in model fitting.  This contains the values of the hyperparameters 
of the prior distribution for the range.  
</p>
</li>
<li><p>  logliks -   A list containing the log-likelihood values used in calculation 
of the model choice statistics if those have been requested in the first place. 
</p>
</li>
<li><p>  formula -  The input formula for the regression part of the model.  
</p>
</li>
<li><p>  scale.transform -  The transformation adopted by the input argument with the 
same name.  
</p>
</li>
<li><p>  package -  The name of the package used for model fitting.  
</p>
</li>
<li><p>  model -  The name of the fitted model.   
</p>
</li>
<li><p>  call -  The command used to call the model fitting function.  
</p>
</li>
<li><p>  computation.time -  Computation time required to run the model fitting.  
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+Bsptime">Bsptime</a></code> for Bayesian spatio-temporal model fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 10
burn.in &lt;- 5
n.report &lt;- 2
a &lt;- Bspatial(formula = mpg ~ wt, data = mtcars, package = "none", model = "lm",
    N = N)
summary(a)
plot(a)
print(a)
b &lt;- Bspatial(formula = mpg ~ disp + wt + qsec + drat, data = mtcars,
    validrows = c(8, 11, 12, 14, 18, 21, 24, 28), N = N)
#' print(b)
summary(b)
## Illustration with the nyspatial data set
head(nyspatial)
## Linear regression model fitting
M1 &lt;- Bspatial(formula = yo3 ~ xmaxtemp + xwdsp + xrh, data = nyspatial,
    mchoice = TRUE, N = N)
print(M1)
plot(M1)
a &lt;- residuals(M1)
summary(M1)
## Spatial model fitting
M2 &lt;- Bspatial(model = "spat", formula = yo3 ~ xmaxtemp + xwdsp +
    xrh, data = nyspatial, coordtype = "utm", coords = 4:5, phi = 0.4,
    mchoice = TRUE, N = N)
names(M2)
print(M2)
plot(M2)
a &lt;- residuals(M2)
summary(M2)
## Fit model 2 on the square root scale
M2root &lt;- Bspatial(model = "spat", formula = yo3 ~ xmaxtemp + xwdsp + xrh,
    data = nyspatial, coordtype = "utm", coords = 4:5, scale.transform = "SQRT")
summary(M2root)
## Spatial model fitting using spBayes
M3 &lt;- Bspatial(package = "spBayes", formula = yo3 ~ xmaxtemp + xwdsp + xrh,
    data = nyspatial, coordtype = "utm", coords = 4:5, prior.phi = c(0.005,
        2), mchoice = TRUE, N = N, burn.in = burn.in, n.report = n.report)
summary(M3)

# Spatial model fitting using stan (with a small number of iterations)
M4 &lt;- Bspatial(package = "stan", formula = yo3 ~ xmaxtemp + xwdsp + xrh,
    data = nyspatial, coordtype = "utm", coords = 4:5, phi = 0.4, N = N,
    burn.in = burn.in, mchoice = TRUE)
summary(M4)


## K fold cross-validation for M2 only
set.seed(44)
x &lt;- runif(n = 28)
u &lt;- order(x)
# Here are the four folds
s1 &lt;- u[1:7]
s2 &lt;- u[8:14]
s3 &lt;- u[15:21]
s4 &lt;- u[22:28]
summary((1:28) - sort(c(s1, s2, s3, s4)))  ## check
v1 &lt;- Bspatial(model = "spat", formula = yo3 ~ xmaxtemp + xwdsp + xrh,
    data = nyspatial, coordtype = "utm", coords = 4:5, validrows = s1,
    phi = 0.4, N = N)
v2 &lt;- Bspatial(model = "spat", formula = yo3 ~ xmaxtemp + xwdsp + xrh,
    data = nyspatial, coordtype = "utm", coords = 4:5, validrows = s2,
    phi = 0.4, N = N)
v3 &lt;- Bspatial(model = "spat", formula = yo3 ~ xmaxtemp + xwdsp + xrh,
    data = nyspatial, coordtype = "utm", coords = 4:5, validrows = s3,
    phi = 0.4, N = N)
v4 &lt;- Bspatial(model = "spat", formula = yo3 ~ xmaxtemp + xwdsp + xrh,
    data = nyspatial, coordtype = "utm", coords = 4:5, validrows = s4,
    phi = 0.4, N = N)
M2.val.table &lt;- cbind(unlist(v1$stats), unlist(v2$stats), unlist(v3$stats),
    unlist(v4$stats))
dimnames(M2.val.table)[[2]] &lt;- paste("Fold", 1:4, sep = "")
round(M2.val.table, 3)

## Model validation
s &lt;- c(1, 5, 10)
M1.v &lt;- Bspatial(model = "lm", formula = yo3 ~ xmaxtemp + xwdsp + xrh,
    data = nyspatial, coordtype = "utm", coords = 4:5, validrows = s, N = N,
    burn.in = burn.in)
M2.v &lt;- Bspatial(model = "spat", formula = yo3 ~ xmaxtemp + xwdsp + xrh,
    data = nyspatial, coordtype = "utm", coords = 4:5, validrows = s, phi = 0.4,
    N = N, burn.in = burn.in)
M3.v &lt;- Bspatial(package = "spBayes", formula = yo3 ~ xmaxtemp + xwdsp +
    xrh, data = nyspatial, coordtype = "utm", coords = 4:5, validrows = s,
    prior.phi = c(0.005, 2), n.report = 2, N = N, burn.in = burn.in)
# Collect all the results
Mall.table &lt;- cbind(unlist(M1.v$stats), unlist(M2.v$stats), unlist(M3.v$stats))
colnames(Mall.table) &lt;- paste("M", c(1:3), sep = "")
round(Mall.table, 3)


if (require(INLA) &amp; require(inlabru)) {
    N &lt;- 10
    burn.in &lt;- 5
    # Spatial model fitting using INLA
    M5 &lt;- Bspatial(package = "inla", formula = yo3 ~ xmaxtemp + xwdsp + xrh,
        data = nyspatial, coordtype = "utm", coords = 4:5, mchoice = TRUE,
        N = N, burn.in = burn.in)
    summary(M5)
}

</code></pre>

<hr>
<h2 id='Bsptime'>Bayesian regression model fitting for point referenced spatio-temporal data. 
Calculates parameter estimates, validation statistics, and 
estimated values of several Bayesian model choice criteria.</h2><span id='topic+Bsptime'></span>

<h3>Description</h3>

<p>Bayesian regression model fitting for point referenced spatio-temporal data. 
Calculates parameter estimates, validation statistics, and 
estimated values of several Bayesian model choice criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bsptime(
  formula,
  data,
  package = "none",
  model = "GP",
  coordtype = NULL,
  coords = NULL,
  validrows = NULL,
  scale.transform = "NONE",
  prior.beta0 = 0,
  prior.M = 1e-04,
  prior.sigma2 = c(2, 1),
  prior.tau2 = c(2, 0.1),
  prior.sigma.eta = c(2, 0.001),
  phi.s = NULL,
  phi.t = NULL,
  prior.phi = "Gamm",
  prior.phi.param = NULL,
  phi.tuning = NULL,
  phi.npoints = NULL,
  prior.range = c(1, 0.5),
  prior.sigma = c(1, 0.005),
  offset = c(10, 140),
  max.edge = c(50, 1000),
  rhotp = 0,
  time.data = NULL,
  truncation.para = list(at = 0, lambda = 2),
  newcoords = NULL,
  newdata = NULL,
  annual.aggrn = "NONE",
  cov.model = "exponential",
  g_size = NULL,
  knots.coords = NULL,
  tol.dist = 0.005,
  N = 2000,
  burn.in = 1000,
  rseed = 44,
  n.report = 2,
  no.chains = 1,
  ad.delta = 0.8,
  t.depth = 15,
  s.size = 0.01,
  verbose = FALSE,
  plotit = TRUE,
  mchoice = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bsptime_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;formula&quot; (or one that can be coerced to that class):
a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_data">data</code></td>
<td>
<p>The data frame for which the model formula is to be fitted.
The data frame should be in long format having one row for each location and  time
combination. The data frame must be ordered by time within each site, and should
optionally have a column, named s.index,  providing the site indices.
Thus the data,  with n sites and T times within each site, should be
organized in the order: (s1, t1), (s1, t2), ... (s1, T), ... (sn, t1), ... (sn, T). 
The data frame should also contain two columns giving the coordinates of the
locations for spatio temporal model fitting.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_package">package</code></td>
<td>
<p>Which package is to be used in model fitting? Currently available 
packages are:
</p>
  
<ul>
<li><p> &quot;spBayes&quot;: The model implemented is the dynamic spatio-temporal 
model fitted using the <code>spDynLM</code> function in the <code>spBayes</code> 
package.  
</p>
</li>
<li><p> &quot;stan&quot;: The model implemented is the marginal independent GP model.
</p>
</li>
<li><p> &quot;inla&quot; The only model implemented is the AR model.
</p>
</li>
<li><p> &quot;spTimer&quot;: All possible models in this package can be fitted.
</p>
</li>
<li><p> &quot;sptDyn&quot;: All possible models in this package can be fitted.
</p>
</li>
<li><p> &quot;none&quot;.: In this case case, the argument  <code>model</code> must be 
specified either as &quot;lm&quot; or &quot;separable&quot;. See below.
</p>
</li></ul>

<p>Further details and more examples are provided in Chapters 7-9 of the book 
Sahu (2022).</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_model">model</code></td>
<td>
<p>The model to be fitted. This argument is passed to the fitting package. 
In case the package is none, then it can be either &quot;lm&quot; or &quot;separable&quot;. 
The &quot;lm&quot; option is for an independent error regression model 
while the other option fits a separable model without any nugget effect.
The separable model fitting method cannot handle missing data. All missing data points
in the response variable will be replaced by the grand mean of the available observations.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_coordtype">coordtype</code></td>
<td>
<p>Type of coordinates: utm, lonlat or plain with utm 
(supplied in meters) as the default. Distance will be calculated in units of kilometer
if this argument is either utm or lonlat. Euclidean distance will be calculated 
if this is given as the third type plain.  If  distance in meter is to be calculated 
then coordtype should be passed on as plain although the coords are supplied in UTM.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_coords">coords</code></td>
<td>
<p>A vector of size two identifying the two column numbers 
of the data frame to take as coordinates. 
Or this can be given as a  matrix of number of sites by 2 providing the coordinates of all the
data locations.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_validrows">validrows</code></td>
<td>
<p>A vector of row numbers of the supplied data frame 
which should be used for validation. When the model is &quot;separable&quot; this argument 
must include all the time points for the sites to be validated.  Otherwise, the 
user is allowed to select the row numbers of the data frame validation as they wish. 
The default NULL value instructs that validation will not be performed. 
</p>
 
<ul>
<li><p> lm model: If package is &quot;none&quot; and the model is &quot;lm&quot;, this argument is 
a vector of row indices of the data frame which should be used for validation. 
</p>
</li>
<li><p> separable model: If package is &quot;none&quot; and the model is &quot;separable&quot; this argument is 
a vector of site indices which should be used for validation. The &quot;separable&quot; 
model  does not allow some sites to be used for both fitting and validation.
Thus it is not possible to validate at selected time points using the separable model.
Further details are provided in Chapter 7 of 
Sahu (2022).
</p>
</li></ul>
</td></tr>
<tr><td><code id="Bsptime_+3A_scale.transform">scale.transform</code></td>
<td>
<p>Transformation of the response variable. It can take three values: SQRT, LOG or NONE.
Default value is &quot;NONE&quot;.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_prior.beta0">prior.beta0</code></td>
<td>
<p>A scalar value or a vector providing the prior mean for beta parameters.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_prior.m">prior.M</code></td>
<td>
<p>Prior precision value (or matrix) for beta.  Defaults to a diagonal 
matrix with diagonal values 10^(-4).</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_prior.sigma2">prior.sigma2</code></td>
<td>
<p>Shape and scale parameter value for the gamma prior on 1/sigma^2, the precision.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_prior.tau2">prior.tau2</code></td>
<td>
<p>Shape and scale parameter value for the gamma prior on tau^2, the nugget effect.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_prior.sigma.eta">prior.sigma.eta</code></td>
<td>
<p>Shape and scale parameter value for the inverse gamma prior 
distribution for sigma^2 eta; only used in the spBayes package.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_phi.s">phi.s</code></td>
<td>
<p>Only used if the model is &quot;separable&quot;. The value of the 
fixed spatial decay parameter for the exponential covariance function.
If this is not provided then a value is chosen which corresponds to an effective range
which is the maximum distance between the data locations.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_phi.t">phi.t</code></td>
<td>
<p>Only used if the model is &quot;separable&quot;. 
The fixed decay parameter for the exponential covariance function in the temporal domain.
If this is not provided then a value is chosen which corresponds to an effective temporal
range which is the maximum time of the data set.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_prior.phi">prior.phi</code></td>
<td>
<p>Specifies the prior distribution for <code class="reqn">\phi</code> only when 
package is one of Stan, spTimer or spTDyn.  Distribution options 
uniform specified by &quot;Unif&quot; and gamma specified by &quot;Gamm&quot; have been implemented in 
both Stan and spTimer. Additionally a half-Cauchy prior distribution specified as &quot;Cauchy&quot;
has been implemented in Stan. In the case of spTimer the uniform distribution is discrete 
while in the case of Stan the uniform distribution is continuous. In the case of 
spTimer the option &quot;FIXED&quot; can be used to keep the value fixed. In that case the fixed value 
can be given by by a scalar value as the argument <code>prior.phi.param</code> below or it can be left 
unspecified in which case the  fixed value of <code class="reqn">\phi</code> is chosen as 3/maximum distance between the 
data locations.  The  &quot;FIXED&quot; option is not available for the Stan package.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_prior.phi.param">prior.phi.param</code></td>
<td>
<p>Lower and upper limits of the uniform prior distribution for
phi the spatial decay parameter. For the default uniform distribution the values correspond
to an effective range that is between 1% and 100% of the maximum distance
between the data locations. For the Gamma distribution the default values are 2 and 1
and for the Cauchy distribution the default values are 0, 1 which specifies
a half-Cauchy distribution in <code class="reqn">(0, \infty)</code>.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_phi.tuning">phi.tuning</code></td>
<td>
<p>Only relevant for spTimer and spTDyn models. 
Tuning parameter fo sampling phi. See the help file for spT.Gibbs</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_phi.npoints">phi.npoints</code></td>
<td>
<p>Only relevant for spTimer and spTDyn models. 
Number of points for the discrete uniform prior distribution on phi. See the help file for spT.Gibbs</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_prior.range">prior.range</code></td>
<td>
<p>A length 2 vector, with (range0, Prange) specifying 
that <code class="reqn">P(\rho &lt; \rho_0)=p_{\rho}</code>, where <code class="reqn">\rho</code> is the spatial range of 
the random field. If Prange is NA, then range0 is used as a fixed range value. 
If this parameter is unspecified then range0=0.90 * maximum distance 
and Prange =0.95. If instead a single value is specified then the range is set at the single value.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_prior.sigma">prior.sigma</code></td>
<td>
<p>A length 2 vector, with (sigma0, Psigma) specifying 
that <code class="reqn">P(\sigma &gt; \sigma_0)=p_{\sigma}</code>, where <code class="reqn">\sigma</code> is the marginal 
standard deviation of the field. If Psigma is NA, then sigma0 is taken as the fixed value of 
this parameter.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_offset">offset</code></td>
<td>
<p>Only used in INLA based modeling.  Offset parameter. See documentation for <code>inla.mesh.2d</code>.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_max.edge">max.edge</code></td>
<td>
<p>Only used in INLA based modeling. See documentation for <code>inla.mesh.2d</code>.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_rhotp">rhotp</code></td>
<td>
<p>Only relevant for models fitted by  spTDyn. 
Initial value for the rho parameters in the temporal dynamic model.
The default is rhotp=0 for which  parameters are sampled from the full conditional distribution
via MCMC with initial value 0.
If rhotp=1,parameters are not sampled and fixed at value 1.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_time.data">time.data</code></td>
<td>
<p>Defining the segments of the time-series set up using the function <code>spT.time</code>.
Only used with the spTimer package.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_truncation.para">truncation.para</code></td>
<td>
<p>Provides truncation parameter lambda and truncation point &quot;at&quot; using list.
Only used with the spTimer package for a truncated model.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_newcoords">newcoords</code></td>
<td>
<p>The locations of the prediction sites in similar format to the <code>coords</code> argument, 
only required if fit and predictions are to be performed simultaneously. 
If omitted, no predictions will be performed.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_newdata">newdata</code></td>
<td>
<p>The covariate values at the prediction sites specified by <code>newcoords</code>. 
This should have same space-time structure as the original data frame.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_annual.aggrn">annual.aggrn</code></td>
<td>
<p>This provides the options for calculating annual summary 
statistics by aggregating different time segments (e.g., annual mean). 
Currently implemented options are: &quot;NONE&quot;, &quot;ave&quot; and &quot;an4th&quot;, 
where &quot;ave&quot; = annual average, &quot;an4th&quot;= annual 4th highest. 
Only applicable if spT.time inputs more than one segment and 
when fit and predict are done simultaneously. Only used in the spTimer package.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_cov.model">cov.model</code></td>
<td>
<p>Model for the covariance function. Only relevant for the spBayes, spTimer and the spTDyn packages.  Default is the exponential model. 
See the documentation for <code>spLM</code> in the package spBayes.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_g_size">g_size</code></td>
<td>
<p>Only relevant for GPP models fitted by either spTimer or spTDyn. 
The grid size c(m, n) for the knots for the GPP model. A square grid is assumed 
if this is passed on as a scalar. This does not need to be given if knots.coords is given instead.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_knots.coords">knots.coords</code></td>
<td>
<p>Only relevant for GPP models fitted by either spTimer or spTDyn. 
Optional two column matrix of UTM-X and UTM-Y coordinates of the knots in kilometers.
It is preferable to specify the g_size parameter instead.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_tol.dist">tol.dist</code></td>
<td>
<p>Minimum separation distance between any two locations out of those specified by 
coords, knots.coords and pred.coords. The default is 0.005. The program 
will exit if the minimum distance is less than the non-zero specified value. 
This will ensure non-singularity of the covariance matrices.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_n">N</code></td>
<td>
<p>MCMC sample size.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_burn.in">burn.in</code></td>
<td>
<p>How many initial iterations to discard. 
Only relevant for MCMC based model fitting, i.e., when package is spBayes or Stan.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_rseed">rseed</code></td>
<td>
<p>Random number seed that controls the starting point for the random number stream.
A set value is required to help reproduce the results.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_n.report">n.report</code></td>
<td>
<p>How many times to report in MCMC progress. This is only used when the package is spBayes or spTimer.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_no.chains">no.chains</code></td>
<td>
<p>Number of parallel chains to run in Stan.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_ad.delta">ad.delta</code></td>
<td>
<p>Adaptive delta controlling the behavior of Stan during fitting.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_t.depth">t.depth</code></td>
<td>
<p>Maximum allowed tree depth in the fitting process of Stan.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_s.size">s.size</code></td>
<td>
<p>step size in the fitting process of Stan.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar value: whether to print various estimates and statistics.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_plotit">plotit</code></td>
<td>
<p>Logical scalar value: whether to plot the predictions against the observed values.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_mchoice">mchoice</code></td>
<td>
<p>Logical scalar value: whether model choice statistics should be calculated.</p>
</td></tr>
<tr><td><code id="Bsptime_+3A_...">...</code></td>
<td>
<p>Any additional arguments that may be passed on to the fitting package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> params - A table of parameter estimates 
</p>
</li>
<li><p> fit  -   The fitted model object. This is present only if a 
named package, e.g.  <code>spTimer</code>  has been used.
</p>
</li>
<li><p> max.d  -   Maximum distance between data locations. 
This is in unit of kilometers unless the <code>coordtype</code> argument 
is set as <code>plain</code>.     
</p>
</li>
<li><p> fitteds  -   A vector of fitted values.   
</p>
</li>
<li><p> mchoice -   Calculated model choice statistics if 
those have been requested by the input argument <code>mchoice=TRUE</code>.
Not all model fits will contain  all the model choice statistics. 
</p>
</li>
<li><p> stats   -   The four validation statistics: 
rmse, mae, crps and coverage.  This is present only if 
model validation has been performed. 
</p>
</li>
<li><p> yobs_preds  -    A data frame containing the 
validation rows of the model fitting data  frame. 
The last five columns of this data frame contains 
the validation prediction summaries: mean, sd, 
median, and 95% prediction interval. 
This is present only if model validation has been performed. 
</p>
</li>
<li><p> valpreds  -   A matrix containing the MCMC samples of 
the validation predictions. 
The dimension of this matrix is the number of validations times 
the number of retained 
MCMC samples. This is present only if model validation has 
been performed.  
</p>
</li>
<li><p> validationplots - Present only if validation has been performed. 
Contains three validation plots with or without segment and 
an ordinary plot.  See <code><a href="#topic+obs_v_pred_plot">obs_v_pred_plot</a></code> for more. 
</p>
</li>
<li><p> residuals   -   A vector of residual values.  
</p>
</li>
<li><p> sn   -   The number of data locations used in fitting.  
</p>
</li>
<li><p> tn   -   The number of time points used in fitting. 
</p>
</li>
<li><p> phi.s, phi.t   -   Adopted value of the spatial and temporal 
decay parameters if those were fixed during model fitting.  
</p>
</li>
<li><p>prior.phi  -   If present this contains the name of 
the prior distribution for 
the spatial decay parameter <code class="reqn">phi</code> used to fit the 
model. 
</p>
</li>
<li><p> prior.phi.param  -    If present this contains the values of 
the hyperparameters of the prior distribution for the spatial 
decay parameter <code class="reqn">phi</code>.  
</p>
</li>
<li><p> prior.range   -    Present only if the <code>INLA</code> package 
has been used in model fitting.  This contains the values of 
the hyperparameters of the prior distribution for the range.  
</p>
</li>
<li><p> logliks   -    A list containing the log-likelihood 
values used in calculation of the model choice statistics 
if those have been requested in the first place. 
</p>
</li>
<li><p> knots.coords  -   The locations of the knots if the 
model has been fitted using the GPP method.  
</p>
</li>
<li><p> formula   -   The input formula for the regression part of 
the model.  
</p>
</li>
<li><p> scale.transform  -   The transformation adopted by the 
input argument with the same name.  
</p>
</li>
<li><p> package   -   The name of the package used for model fitting.  
</p>
</li>
<li><p> model   -   The name of the fitted model.   
</p>
</li>
<li><p> call  -   The command used to call the model fitting function.  
</p>
</li>
<li><p> computation.time  -   Computation time required 
to run the model fitting.  
</p>
</li></ul>



<h3>References</h3>

<p>Sahu SK (2022).
<em>Bayesian Modeling of Spatio Temporal Data with R</em>, 1st edition.
Chapman and Hall, Boca Raton.
<a href="https://doi.org/10.1201/9780429318443">https://doi.org/10.1201/9780429318443</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set the total number of iterations 
N &lt;- 45
# Set the total number of burn-in iterations 
burn.in &lt;- 5
# How many times to report progress 
n.report &lt;- 2
# Model formula used in most model fitting  
f2 &lt;- y8hrmax ~ xmaxtemp + xwdsp + xrh
# Check out the data set 
head(nysptime)
## Fit linear regression model 
M1 &lt;- Bsptime(model = "lm", data = nysptime, formula = f2,
    scale.transform = "SQRT", N = N, burn.in = burn.in, mchoice = TRUE)
names(M1)
plot(M1)
print(M1)
summary(M1)
a &lt;- residuals(M1, numbers = list(sn = 28, tn = 62))
M2 &lt;- Bsptime(model = "separable", data = nysptime, formula = f2,
    coordtype = "utm", coords = 4:5, mchoice = TRUE, scale.transform = "SQRT",
    N = N, burn.in = burn.in)
names(M2)
plot(M2)
print(M2)
summary(M2)
b &lt;- residuals(M2)
# Spatio-temporal model fitting and validation
valids &lt;- c(8, 11)
vrows &lt;- which(nysptime$s.index %in% valids)
## Fit separable spatio-temporal model 
M2.1 &lt;- Bsptime(model = "separable", formula = f2, data = nysptime,
    validrows = vrows, coordtype = "utm", coords = 4:5, phi.s = 0.005,
    phi.t = 0.05, scale.transform = "SQRT", N = N)
summary(M2.1)
plot(M2.1)
# Use spTimer to fit independent GP model 
M3 &lt;- Bsptime(package = "spTimer", formula = f2, data = nysptime,
    coordtype = "utm", coords = 4:5, scale.transform = "SQRT", mchoice = TRUE,
    N = N, burn.in = burn.in, n.report = 2)
summary(M3)

valids &lt;- c(1, 5, 10)
validt &lt;- sort(sample(1:62, size = 31))
vrows &lt;- getvalidrows(sn = 28, tn = 62, valids = valids, validt = validt)
ymat &lt;- matrix(nysptime$y8hrmax, byrow = TRUE, ncol = 62)
yholdout &lt;- ymat[valids, validt]
# Perform validation 
M31 &lt;- Bsptime(package = "spTimer", formula = f2, data = nysptime,
    coordtype = "utm", coords = 4:5, validrows = vrows, model = "GP",
    scale.transform = "NONE", N = N, burn.in = burn.in, n.report = 2)
summary(M31)
modfit &lt;- M31$fit
## Extract the fits for the validation sites
fitall &lt;- data.frame(modfit$fitted)
head(fitall)
tn &lt;- 62
fitall$s.index &lt;- rep(1:28, each = tn)
library(spTimer)
vdat &lt;- spT.subset(data = nysptime, var.name = c("s.index"), s = valids)
fitvalid &lt;- spT.subset(data = fitall, var.name = c("s.index"), s = valids)
head(fitvalid)
fitvalid$low &lt;- fitvalid$Mean - 1.96 * fitvalid$SD
fitvalid$up &lt;- fitvalid$Mean + 1.96 * fitvalid$SD
fitvalid$yobs &lt;- sqrt(vdat$y8hrmax)
fitvalid$yobs &lt;- vdat$y8hrmax
yobs &lt;- matrix(fitvalid$yobs, byrow = TRUE, ncol = tn)
y.valids.low &lt;- matrix(fitvalid$low, byrow = TRUE, ncol = tn)
y.valids.med &lt;- matrix(fitvalid$Mean, byrow = TRUE, ncol = tn)
y.valids.up &lt;- matrix(fitvalid$up, byrow = TRUE, ncol = tn)
library(ggplot2)
p1 &lt;- fig11.13.plot(yobs[1, ], y.valids.low[1, ], y.valids.med[1, ],
    y.valids.up[1, ], misst = validt)
p1 &lt;- p1 + ggtitle("Validation for Site 1")
p1
p2 &lt;- fig11.13.plot(yobs[2, ], y.valids.low[2, ], y.valids.med[2, ],
    y.valids.up[2, ], misst = validt)
p2 &lt;- p2 + ggtitle("Validation for Site 5")
p2
p3 &lt;- fig11.13.plot(yobs[3, ], y.valids.low[3, ], y.valids.med[3, ],
    y.valids.up[3, ], misst = validt)
p3 &lt;- p3 + ggtitle("Validation for Site 10")
p3

## Independent marginal GP model fitting using rstan

M4 &lt;- Bsptime(package = "stan", formula = f2, data = nysptime,
    coordtype = "utm", coords = 4:5, N = N, burn.in = burn.in,
    verbose = FALSE)
summary(M4)

# Spatio-temporal hierarchical auto-regressive modeling useing spTimer 
M5 &lt;- Bsptime(package = "spTimer", model = "AR", formula = f2, data = nysptime,
    coordtype = "utm", coords = 4:5, scale.transform = "SQRT", mchoice = TRUE,
    n.report = n.report, N = N, burn.in = burn.in)
summary(M5)
a &lt;- residuals(M5)

## Spatio-temporal dynamic model fitting using spTDyn
library(spTDyn)

f3 &lt;- y8hrmax ~ xmaxtemp + sp(xmaxtemp) + tp(xwdsp) + xrh
M7 &lt;- Bsptime(package = "sptDyn", model = "GP", formula = f3, data = nysptime,
    coordtype = "utm", coords = 4:5, scale.transform = "SQRT", mchoice = TRUE,
    N = N, burn.in = burn.in, n.report = n.report)
summary(M7)

# Dynamic Model fitting using spBayes 
M8 &lt;- Bsptime(package = "spBayes", formula = f2, data = nysptime,
    prior.sigma2 = c(2, 25), prior.tau2 = c(2, 25), prior.sigma.eta = c(2,
        0.001), coordtype = "utm", coords = 4:5, scale.transform = "SQRT",
    N = N, burn.in = burn.in, n.report = n.report)
summary(M8)

## Gussian Predictive Process based model fitting using spTimer 
M9 &lt;- Bsptime(package = "spTimer", model = "GPP", g_size = 5, formula = f2,
    data = nysptime, coordtype = "utm", coords = 4:5, scale.transform = "SQRT",
    N = N, burn.in = burn.in, n.report = n.report)
summary(M9)

# This INLA run may take a long time
if (require(INLA) &amp; require(inlabru)) {
    f2 &lt;- y8hrmax ~ xmaxtemp + xwdsp + xrh
    M6 &lt;- Bsptime(package = "inla", model = "AR", formula = f2, data = nysptime,
        coordtype = "utm", coords = 4:5, scale.transform = "SQRT", 
        offset = c(100, 200), max.edge = c(500, 10000),
        mchoice = TRUE, plotit=TRUE)
    # Takes a minute
    summary(M6)
}


</code></pre>

<hr>
<h2 id='calculate_dic'>Calculate DIC function.
Has two arguments: (1) log full likelihood at thetahat and (2) vector of log-likelihood at the theta samples
Calculate the DIC criteria values</h2><span id='topic+calculate_dic'></span>

<h3>Description</h3>

<p>Calculate DIC function.
Has two arguments: (1) log full likelihood at thetahat and (2) vector of log-likelihood at the theta samples
Calculate the DIC criteria values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_dic(loglikatthetahat, logliks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_dic_+3A_loglikatthetahat">loglikatthetahat</code></td>
<td>
<p>Log of the likelihood function at theta hat (Bayes). It is a scalar value.</p>
</td></tr>
<tr><td><code id="calculate_dic_+3A_logliks">logliks</code></td>
<td>
<p>A vector of log likelihood values at the theta samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing four values pdic, pdicalt, dic and dicalt
</p>

<hr>
<h2 id='calculate_validation_statistics'>Calculates the four validation statistics: RMSE, MAE, CRPS and coverage
given the observed values and MCMC iterates.</h2><span id='topic+calculate_validation_statistics'></span>

<h3>Description</h3>

<p>Calculates the four validation statistics: RMSE, MAE, CRPS and coverage
given the observed values and MCMC iterates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_validation_statistics(yval, yits, level = 95, summarystat = "mean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_validation_statistics_+3A_yval">yval</code></td>
<td>
<p>A vector containing n observed values of the response 
variable.</p>
</td></tr>
<tr><td><code id="calculate_validation_statistics_+3A_yits">yits</code></td>
<td>
<p>A n by N matrix of predictive samples from the 
n observations contained in yval.</p>
</td></tr>
<tr><td><code id="calculate_validation_statistics_+3A_level">level</code></td>
<td>
<p>The nominal coverage level, defaults to 95%.</p>
</td></tr>
<tr><td><code id="calculate_validation_statistics_+3A_summarystat">summarystat</code></td>
<td>
<p>Summary statistics to use to calculate the validation 
predictions from the samples. It should be a function like mean or 
median which can be calculated by R. The default is mean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list giving the rmse, mae, crps and coverage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4)
vrows &lt;- sample(nrow(nysptime), 100)
M1 &lt;- Bsptime(model="lm", formula=y8hrmax~xmaxtemp+xwdsp+xrh, data=nysptime, 
validrows=vrows, scale.transform = "SQRT")
valstats &lt;- calculate_validation_statistics(M1$yobs_preds$y8hrmax, 
yits=t(M1$valpreds))
unlist(valstats)
</code></pre>

<hr>
<h2 id='calculate_waic'>Calculate WAIC  function.
Has the sole argument component wise likelihood at thetahat samples.
v must be a matrix
Calculate the WAIC criteria values</h2><span id='topic+calculate_waic'></span>

<h3>Description</h3>

<p>Calculate WAIC  function.
Has the sole argument component wise likelihood at thetahat samples.
v must be a matrix
Calculate the WAIC criteria values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_waic(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_waic_+3A_v">v</code></td>
<td>
<p>must be a N (MCMC) by n (data) sample size matrix
of the log-likelihood evaluations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing four values p_waic, p_waic alt, waic and waic_alt
</p>

<hr>
<h2 id='coef.bmstdr'>Prints and returns the estimates of the coefficients</h2><span id='topic+coef.bmstdr'></span>

<h3>Description</h3>

<p>Prints and returns the estimates of the coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmstdr'
coef(object, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.bmstdr_+3A_object">object</code></td>
<td>
<p>A bmstdr model fit object.</p>
</td></tr>
<tr><td><code id="coef.bmstdr_+3A_digits">digits</code></td>
<td>
<p>How many significant digits after the decimal to print, defaults to 3.</p>
</td></tr>
<tr><td><code id="coef.bmstdr_+3A_...">...</code></td>
<td>
<p>Any other additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients are returned as a data frame preserving the names of 
the covariates
</p>

<hr>
<h2 id='colpalette'>The color palette used to draw maps to illustrate the package 
bmstdr, see  Sahu (2022)
It has the values in order: dodgerblue4, dodgerblue2, firebrick2,  
firebrick4 and purple.</h2><span id='topic+colpalette'></span>

<h3>Description</h3>

<p>The color palette used to draw maps to illustrate the package 
bmstdr, see  Sahu (2022)
It has the values in order: dodgerblue4, dodgerblue2, firebrick2,  
firebrick4 and purple.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colpalette
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 5.
</p>


<h3>References</h3>

<p>Sahu SK (2022).
<em>Bayesian Modeling of Spatio Temporal Data with R</em>, 1st edition.
Chapman and Hall, Boca Raton.
<a href="https://doi.org/10.1201/9780429318443">https://doi.org/10.1201/9780429318443</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> colpalette
</code></pre>

<hr>
<h2 id='engdeaths'>Number of weekly Covid-19 deaths and cases in the 313 local 
Local Authority Districts, Counties  and Unitary Authorities (LADCUA) in 
England during the 20 peaks in the first peak from March 13 to July 31, 2020.</h2><span id='topic+engdeaths'></span>

<h3>Description</h3>

<p>Number of weekly Covid-19 deaths and cases in the 313 local 
Local Authority Districts, Counties  and Unitary Authorities (LADCUA) in 
England during the 20 peaks in the first peak from March 13 to July 31, 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engdeaths
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 6260 rows and 24 columns.
</p>


<h3>Source</h3>

<p>Sahu and Böhning (2021). 
@format A data frame with 6260 rows and 24 columns:
</p>

<dl>
<dt>Areacode</dt><dd><p>Areacode identifier of the 313 
Local Authority Districts, Counties  and Unitary Authorities (LADCUA)</p>
</dd>
<dt>mapid</dt><dd><p>A numeric column identifying the map area needed for plotting</p>
</dd>
<dt>spaceid</dt><dd><p>A numeric variable taking value 1 to 313 identifying the LADCUA's</p>
</dd>
<dt>Region</dt><dd><p>Identifies one of the 9 English regions</p>
</dd>
<dt>popn</dt><dd><p>Population number in mid-2019</p>
</dd>
<dt>jsa</dt><dd><p>Percentage of the working age  population receiving job-seekers allowance 
during January 2020</p>
</dd>
<dt>houseprice</dt><dd><p>Median house price  in March 2020</p>
</dd>
<dt>popdensity</dt><dd><p>Population density in mid-2019</p>
</dd>    
<dt>no2</dt><dd><p>Estimated average value of NO2 at the centroid of the LADCUA</p>
</dd>
<dt>covid</dt><dd><p>Number of Covid-19 deaths within 28 days of a positive test</p>
</dd>
<dt>allcause</dt><dd><p>Number deaths</p>
</dd>
<dt>noofcases</dt><dd><p>Number of cases</p>
</dd>
<dt>n0</dt><dd><p>Log of the standardized case morbidity during the current week</p>
</dd>
<dt>n1</dt><dd><p>Log of the standardized case morbidity during the week before</p>
</dd>
<dt>n2</dt><dd><p>Log of the standardized case morbidity during the second week before</p>
</dd>
<dt>n3</dt><dd><p>Log of the standardized case morbidity during the third week before</p>
</dd>
<dt>n4</dt><dd><p>Log of the standardized case morbidity during the fourth week before</p>
</dd>
<dt>Edeaths</dt><dd><p>Expected number of Covid-19 deaths. See Sahu and 
Bohning (2021) for methodology. </p>
</dd>
<dt>Ecases</dt><dd><p>Expected number of cases.</p>
</dd> 
<dt>logEdeaths</dt><dd><p>Log of the column <code>Edeaths</code></p>
</dd>
<dt>logEcases</dt><dd><p>Log of the column Ecases</p>
</dd>
<dt>highdeathsmr</dt><dd><p>A binary (0-1) random variable taking the value 1 if 
the SMR of Covid-19 death is higher than 1</p>
</dd>       
</dl>



<h3>References</h3>

<p>Sahu SK, Böhning D (2021).
&ldquo;Bayesian spatio-temporal joint disease mapping of Covid-19 cases and deaths in local authorities of England.&rdquo;
<em>Spatial Statistics</em>.
<a href="https://doi.org/10.1016/j.spasta.2021.100519">doi:10.1016/j.spasta.2021.100519</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> colnames(engdeaths)
 dim(engdeaths)
 summary(engdeaths[, 11:24])
</code></pre>

<hr>
<h2 id='engtotals'>Total number of weekly Covid-19 deaths and cases in the 313 local 
Local Authority Districts, Counties  and Unitary Authorities (LADCUA) in 
England during the first peak from March 13 to July 31, 2020.</h2><span id='topic+engtotals'></span>

<h3>Description</h3>

<p>Total number of weekly Covid-19 deaths and cases in the 313 local 
Local Authority Districts, Counties  and Unitary Authorities (LADCUA) in 
England during the first peak from March 13 to July 31, 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engtotals
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 313 rows and 19 columns.
</p>


<h3>Source</h3>

<p>Sahu and Böhning (2021). 
@format A data frame with 313 rows and 19 columns:
</p>

<dl>
<dt>Areacode</dt><dd><p>Areacode identifier of the 313 
Local Authority Districts, Counties  and Unitary Authorities (LADCUA)</p>
</dd>
<dt>mapid</dt><dd><p>A numeric column identifying the map area needed for plotting</p>
</dd>
<dt>spaceid</dt><dd><p>A numeric variable taking value 1 to 313 identifying the LADCUA's</p>
</dd>
<dt>Region</dt><dd><p>Identifies one of the 9 English regions</p>
</dd>
<dt>popn</dt><dd><p>Population number in mid-2019</p>
</dd>
<dt>jsa</dt><dd><p>Percentage of the working age  population receiving job-seekers allowance 
during January 2020</p>
</dd>
<dt>houseprice</dt><dd><p>Median house price  in March 2020</p>
</dd>
<dt>popdensity</dt><dd><p>Population density in mid-2019</p>
</dd>    
<dt>startdate</dt><dd><p>Start date of the week</p>
</dd>
<dt>Weeknumber</dt><dd><p>Week numbers 11 to 30</p>
</dd>
<dt>no2</dt><dd><p>Estimated average value of NO2 at the centroid of the LADCUA in that week</p>
</dd>
<dt>covid</dt><dd><p>Number of Covid-19 deaths within 28 days of a positive test</p>
</dd>
<dt>allcause</dt><dd><p>Total number deaths</p>
</dd>
<dt>noofcases</dt><dd><p>Total number of cases</p>
</dd>
<dt>Edeaths</dt><dd><p>Expected number of Covid-19 deaths. See Sahu and 
Bohning (2021) for methodology.</p>
</dd> 
<dt>Ecases</dt><dd><p>Expected number of cases.</p>
</dd> 
<dt>logEdeaths</dt><dd><p>Log of the column <code>Edeaths</code></p>
</dd>
<dt>logEcases</dt><dd><p>Log of the column <code>Ecases</code></p>
</dd>
<dt>casesmr</dt><dd><p>Standaridised morbidity rate for the number of cases, 
<code>noofcases</code>/<code>Ecases</code></p>
</dd>
<dt>nweek</dt><dd><p>Number of weeks during March 13 to July 31, 2020. All values are 20.</p>
</dd>
<dt>noofhighweeks</dt><dd><p>Number of  weeks out of 20 when the <code>casesmr</code> 
was greater than 1</p>
</dd>      
</dl>



<h3>References</h3>

<p>Sahu SK, Böhning D (2021).
&ldquo;Bayesian spatio-temporal joint disease mapping of Covid-19 cases and deaths in local authorities of England.&rdquo;
<em>Spatial Statistics</em>.
<a href="https://doi.org/10.1016/j.spasta.2021.100519">doi:10.1016/j.spasta.2021.100519</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> colnames(engtotals)
 dim(engtotals)
 summary(engtotals[, 5:14])
</code></pre>

<hr>
<h2 id='fig11.13.plot'>Draws a time series (ribbon) plot by combining fitted and predicted values</h2><span id='topic+fig11.13.plot'></span>

<h3>Description</h3>

<p>Draws a time series (ribbon) plot by combining fitted and predicted values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fig11.13.plot(yobs, ylow, ymed, yup, misst)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fig11.13.plot_+3A_yobs">yobs</code></td>
<td>
<p>A vector of the observed values</p>
</td></tr>
<tr><td><code id="fig11.13.plot_+3A_ylow">ylow</code></td>
<td>
<p>A vector of the lower limits of the fitted or predicted values</p>
</td></tr>
<tr><td><code id="fig11.13.plot_+3A_ymed">ymed</code></td>
<td>
<p>A vector of fitted or predicted values</p>
</td></tr>
<tr><td><code id="fig11.13.plot_+3A_yup">yup</code></td>
<td>
<p>A vector of the upper limits of the fitted or predicted values</p>
</td></tr>
<tr><td><code id="fig11.13.plot_+3A_misst">misst</code></td>
<td>
<p>An integer vector which contains the indices of the predicted
values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ribbon plot,  ggplot2 object,  which shows observed values
in red color and open circle, predicted values in blue color and
filled circle.
</p>

<hr>
<h2 id='fitted.bmstdr'>Extract fitted values from bmstdr objects.</h2><span id='topic+fitted.bmstdr'></span>

<h3>Description</h3>

<p>Extract fitted values from bmstdr objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmstdr'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.bmstdr_+3A_object">object</code></td>
<td>
<p>A bmstdr model fit object.</p>
</td></tr>
<tr><td><code id="fitted.bmstdr_+3A_...">...</code></td>
<td>
<p>Any other additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of fitted values.
</p>

<hr>
<h2 id='fnc.delete.map.XYZ'>This function is used to delete values outside the state of New York</h2><span id='topic+fnc.delete.map.XYZ'></span>

<h3>Description</h3>

<p>This function is used to delete values outside the state of New York
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnc.delete.map.XYZ(xyz)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fnc.delete.map.XYZ_+3A_xyz">xyz</code></td>
<td>
<p>A list containing the x values, y values and
interpolated z values at each x and y pair.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input but with NA placed in z values corresponding to
the locations whose x-y coordinates are outside the land boundary of the
USA.
</p>

<hr>
<h2 id='get_parameter_estimates'>Obtains parameter estimates from MCMC samples</h2><span id='topic+get_parameter_estimates'></span>

<h3>Description</h3>

<p>Obtains parameter estimates from MCMC samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parameter_estimates(samps, level = 95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_parameter_estimates_+3A_samps">samps</code></td>
<td>
<p>A matrix of N by p samples for the p parameters</p>
</td></tr>
<tr><td><code id="get_parameter_estimates_+3A_level">level</code></td>
<td>
<p>Desired confidence level - defaults to 95%.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing four columns: mean, sd, low (er limit), 
and up (per limit) for the p parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samps &lt;- matrix(rnorm(10000), ncol= 10 )
dim(samps)
a &lt;- get_parameter_estimates(samps)
a
b &lt;- get_parameter_estimates(samps, level=98)
b
</code></pre>

<hr>
<h2 id='get_validation_summaries'>Obtains suitable validation summary statistics from MCMC samples 
obtained for  validation.</h2><span id='topic+get_validation_summaries'></span>

<h3>Description</h3>

<p>Obtains suitable validation summary statistics from MCMC samples 
obtained for  validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_validation_summaries(samps, level = 95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_validation_summaries_+3A_samps">samps</code></td>
<td>
<p>A matrix of N by p samples for the p parameters</p>
</td></tr>
<tr><td><code id="get_validation_summaries_+3A_level">level</code></td>
<td>
<p>Desired confidence level - defaults to 95%.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing five columns: meanpred, 
medianpred, sdpred, low (er limit), 
and up (per limit) for the p parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4)
vrows &lt;- sample(nrow(nysptime), 100)
M1 &lt;- Bsptime(model="lm", formula=y8hrmax~xmaxtemp+xwdsp+xrh, data=nysptime, 
validrows=vrows, scale.transform = "SQRT")
samps&lt;- M1$valpreds
valsums &lt;- get_validation_summaries(samps)
head(valsums)  
</code></pre>

<hr>
<h2 id='getvalidrows'>Returns a vector of row numbers for validation.</h2><span id='topic+getvalidrows'></span>

<h3>Description</h3>

<p>Returns a vector of row numbers for validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getvalidrows(sn, tn, valids, validt = NULL, allt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getvalidrows_+3A_sn">sn</code></td>
<td>
<p>The total number of spatial locations.</p>
</td></tr>
<tr><td><code id="getvalidrows_+3A_tn">tn</code></td>
<td>
<p>The total number of time points in each location.</p>
</td></tr>
<tr><td><code id="getvalidrows_+3A_valids">valids</code></td>
<td>
<p>A vector of site numbers in (1:sn) to be used for validation.</p>
</td></tr>
<tr><td><code id="getvalidrows_+3A_validt">validt</code></td>
<td>
<p>A vector of time points in (1:tn) to be used for validation.</p>
</td></tr>
<tr><td><code id="getvalidrows_+3A_allt">allt</code></td>
<td>
<p>Whether all the time points should be used for validation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer vector providing the row numbers of the data frame for validation.
Output of this function is suitable as the argument <code>validrows</code> for the
<code>bmstdr</code> model fitting functions <code>Bsptime, Bcartime</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
# To validate at site numbers 1, 5, and 10 at 31 randomly selected
# time points for the nysptime data set we issue the following commands
set.seed(44)
vt &lt;- sample(62, 31)
vrows &lt;- getvalidrows(sn=28, tn=62, valids=c(1, 5, 10), validt=vt)
# To validate at sites 1 and 2 at all time points
vrows &lt;- getvalidrows(sn=28, tn=62, valids=c(1, 2), allt=TRUE)
}
</code></pre>

<hr>
<h2 id='gridnyspatial'>Values of three covariates for 100 grid locations in New York
averaged over the 62 days during the months of July and August, 2006.</h2><span id='topic+gridnyspatial'></span>

<h3>Description</h3>

<p>Values of three covariates for 100 grid locations in New York
averaged over the 62 days during the months of July and August, 2006.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridnyspatial
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 100 rows and 8 columns.
</p>


<h3>Source</h3>

<p>See the NYgrid data  set in spTimer package, 
Bakar and Sahu (2015).
Each data row is the mean of the available covariate
values at the 100 grid locations during the months of July and August in 2006.
</p>
<p>@format A data frame with 100 rows and 8 columns:
</p>

<dl>
<dt>s.index</dt><dd><p>site index (1 to 28)</p>
</dd>
<dt>Longitude</dt><dd><p>Longitude of the site</p>
</dd>
<dt>Latitude</dt><dd><p>Latitude of the site</p>
</dd>
<dt>utmx</dt><dd><p>UTM X-coordinate of the site</p>
</dd>
<dt>utmy</dt><dd><p>UTM Y-coordinate of the site</p>
</dd>
<dt>xmaxtemp</dt><dd><p>Average maximum temperature (degree Celsius) at the site over 62 days in  July and August, 2006</p>
</dd>
<dt>xwdsp</dt><dd><p>Average wind speed (nautical mile per hour) over 62 days in  July and August, 2006</p>
</dd>
<dt>xwdsp</dt><dd><p>Average relative humidity over 62 days in  July and August, 2006</p>
</dd>
</dl>



<h3>References</h3>

<p>Bakar KS, Sahu SK (2015).
&ldquo;spTimer: Spatio-Temporal Bayesian Modeling Using R.&rdquo;
<em>Journal of Statistical Software, Articles</em>, <b>63</b>(15), 1&ndash;32.
ISSN 1548-7660, <a href="https://doi.org/10.18637/jss.v063.i15">doi:10.18637/jss.v063.i15</a>, <a href="https://www.jstatsoft.org/v063/i15">https://www.jstatsoft.org/v063/i15</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> summary(gridnyspatial)
</code></pre>

<hr>
<h2 id='gridnysptime'>Values of three covariates for 100 grid locations in New York for
the 62 days during the months of July and August, 2006.</h2><span id='topic+gridnysptime'></span>

<h3>Description</h3>

<p>Values of three covariates for 100 grid locations in New York for
the 62 days during the months of July and August, 2006.
</p>
<p>Values of three covariates for 100 grid locations in New York for
the 62 days during the months of July and August, 2006.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridnysptime

gridnysptime
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 6200 rows and 11 columns.
</p>
<p>An object of class <code>data.frame</code> with 6200 rows and 11 columns.
</p>


<h3>Source</h3>

<p>It is the same data set as NYgrid data set in the spTimer package, 
Bakar and Sahu (2015).
with two added columns providing the UTM X- and Y- coordinates.
Each data row is  for a particular grid site and day as detailed below.
</p>
<p>@format A data frame with 6200 rows and 11 columns:
</p>

<dl>
<dt>s.index</dt><dd><p>site index (1 to 100)</p>
</dd>
<dt>Longitude</dt><dd><p>Longitude of the site</p>
</dd>
<dt>Latitude</dt><dd><p>Latitude of the site</p>
</dd>
<dt>utmx</dt><dd><p>UTM X-coordinate of the site</p>
</dd>
<dt>utmy</dt><dd><p>UTM Y-coordinate of the site</p>
</dd>
<dt>Year</dt><dd><p>This is 2006 for all the rows</p>
</dd>
<dt>Month</dt><dd><p>Month taking values 7 for July and 8 for August</p>
</dd>
<dt>Day</dt><dd><p>Day taking values 1 to 31</p>
</dd>
<dt>xmaxtemp</dt><dd><p>Maximum temperature (degree Celsius)</p>
</dd>
<dt>xwdsp</dt><dd><p>wind speed (nautical mile per hour)</p>
</dd>
<dt>xrh</dt><dd><p>Relative humidity</p>
</dd>
</dl>

<p>It is the same data set as NYgrid data set in the spTimer package, 
</p>
<p>with two added columns providing the UTM X- and Y- coordinates.
Each data row is  for a particular grid site and day as detailed below.
</p>
<p>@format A data frame with 6200 rows and 11 columns:
</p>

<dl>
<dt>s.index</dt><dd><p>site index (1 to 100)</p>
</dd>
<dt>Longitude</dt><dd><p>Longitude of the site</p>
</dd>
<dt>Latitude</dt><dd><p>Latitude of the site</p>
</dd>
<dt>utmx</dt><dd><p>UTM X-coordinate of the site</p>
</dd>
<dt>utmy</dt><dd><p>UTM Y-coordinate of the site</p>
</dd>
<dt>Year</dt><dd><p>This is 2006 for all the rows</p>
</dd>
<dt>Month</dt><dd><p>Month taking values 7 for July and 8 for August</p>
</dd>
<dt>Day</dt><dd><p>Day taking values 1 to 31</p>
</dd>
<dt>xmaxtemp</dt><dd><p>Maximum temperature (degree Celsius)</p>
</dd>
<dt>xwdsp</dt><dd><p>wind speed (nautical mile per hour)</p>
</dd>
<dt>xrh</dt><dd><p>Relative humidity</p>
</dd>
</dl>



<h3>References</h3>

<p>Bakar KS, Sahu SK (2015).
&ldquo;spTimer: Spatio-Temporal Bayesian Modeling Using R.&rdquo;
<em>Journal of Statistical Software, Articles</em>, <b>63</b>(15), 1&ndash;32.
ISSN 1548-7660, <a href="https://doi.org/10.18637/jss.v063.i15">doi:10.18637/jss.v063.i15</a>, <a href="https://www.jstatsoft.org/v063/i15">https://www.jstatsoft.org/v063/i15</a>.
</p>
<p>Bakar KS, Sahu SK (2015).
&ldquo;spTimer: Spatio-Temporal Bayesian Modeling Using R.&rdquo;
<em>Journal of Statistical Software, Articles</em>, <b>63</b>(15), 1&ndash;32.
ISSN 1548-7660, <a href="https://doi.org/10.18637/jss.v063.i15">doi:10.18637/jss.v063.i15</a>, <a href="https://www.jstatsoft.org/v063/i15">https://www.jstatsoft.org/v063/i15</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> head(gridnysptime)
 summary(gridnysptime[, 9:11])
 summary(gridnysptime[, 9:11])
</code></pre>

<hr>
<h2 id='hitandfalsealarm'>Calculate the hit and false alarm rates</h2><span id='topic+hitandfalsealarm'></span>

<h3>Description</h3>

<p>Calculate the hit and false alarm rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hitandfalsealarm(thresh, yobs, ypred)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hitandfalsealarm_+3A_thresh">thresh</code></td>
<td>
<p>Threshold value</p>
</td></tr>
<tr><td><code id="hitandfalsealarm_+3A_yobs">yobs</code></td>
<td>
<p>A vector of observations, may include missing values</p>
</td></tr>
<tr><td><code id="hitandfalsealarm_+3A_ypred">ypred</code></td>
<td>
<p>Predictions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the calculated hit and false alarm rates
</p>

<hr>
<h2 id='is.bmstdr'>Is it a bmstdr model fitted object?</h2><span id='topic+is.bmstdr'></span>

<h3>Description</h3>

<p>Is it a bmstdr model fitted object?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.bmstdr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.bmstdr_+3A_x">x</code></td>
<td>
<p>Any R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A TRUE/FALSE logical output.
</p>

<hr>
<h2 id='materncov'>Banerjee, Carlin and Gelfand (2015) Mat'ern covariance function</h2><span id='topic+materncov'></span>

<h3>Description</h3>

<p>Banerjee, Carlin and Gelfand (2015) Mat'ern covariance function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>materncov(d, phi, nu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="materncov_+3A_d">d</code></td>
<td>
<p>is the distance</p>
</td></tr>
<tr><td><code id="materncov_+3A_phi">phi</code></td>
<td>
<p>is the rate of decay</p>
</td></tr>
<tr><td><code id="materncov_+3A_nu">nu</code></td>
<td>
<p>is the smoothness parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the Mat'ern covariance for distance object d
</p>

<hr>
<h2 id='maternfun'>Banerjee et al Mat'ern covariance function</h2><span id='topic+maternfun'></span>

<h3>Description</h3>

<p>Banerjee et al Mat'ern covariance function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maternfun(d, phi, nu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maternfun_+3A_d">d</code></td>
<td>
<p>is the distance</p>
</td></tr>
<tr><td><code id="maternfun_+3A_phi">phi</code></td>
<td>
<p>is the rate of decay</p>
</td></tr>
<tr><td><code id="maternfun_+3A_nu">nu</code></td>
<td>
<p>is the smoothness parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the Mat'ern correlation function for distance object d
</p>

<hr>
<h2 id='nyspatial'>Average ozone concentration values and three covariates from 28 sites in New York.</h2><span id='topic+nyspatial'></span>

<h3>Description</h3>

<p>Average ozone concentration values and three covariates from 28 sites in New York.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nyspatial
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 28 rows and 9 columns.
</p>


<h3>Source</h3>

<p>See the NYdata set in spTimer package, Bakar and Sahu (2015).
Each data row is the mean of the available daily 8-hour maximum average ozone 
concentrations in parts per billion (ppb) at each of the
28 sites. The daily values are for the months of July and August in 2006.
@format A data frame with 28 rows and 9 columns:
</p>

<dl>
<dt>s.index</dt><dd><p>site index (1 to 28)</p>
</dd>
<dt>Longitude</dt><dd><p>Longitude of the site</p>
</dd>
<dt>Latitude</dt><dd><p>Latitude of the site</p>
</dd>
<dt>utmx</dt><dd><p>UTM X-coordinate of the site</p>
</dd>
<dt>utmy</dt><dd><p>UTM Y-coordinate of the site</p>
</dd>
<dt>yo3</dt><dd><p>Average ozone concentration value (ppb) at the site over 62 days in July and August, 2006</p>
</dd>
<dt>xmaxtemp</dt><dd><p>Average maximum temperature (degree Celsius) at the site over 62 days in  July and August, 2006</p>
</dd>
<dt>xwdsp</dt><dd><p>Average wind speed (nautical mile per hour) over 62 days in  July and August, 2006</p>
</dd>
<dt>xrh</dt><dd><p>Average relative humidity over 62 days in  July and August, 2006</p>
</dd>
</dl>



<h3>References</h3>

<p>Bakar KS, Sahu SK (2015).
&ldquo;spTimer: Spatio-Temporal Bayesian Modeling Using R.&rdquo;
<em>Journal of Statistical Software, Articles</em>, <b>63</b>(15), 1&ndash;32.
ISSN 1548-7660, <a href="https://doi.org/10.18637/jss.v063.i15">doi:10.18637/jss.v063.i15</a>, <a href="https://www.jstatsoft.org/v063/i15">https://www.jstatsoft.org/v063/i15</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> head(nyspatial)
 summary(nyspatial)
 pairs(nyspatial[, 6:9])
</code></pre>

<hr>
<h2 id='nysptime'>Daily 8-hour maximum ozone concentration values and three covariates from 28 sites in New York for
the 62 days during the months of July and August, 2006.</h2><span id='topic+nysptime'></span>

<h3>Description</h3>

<p>Daily 8-hour maximum ozone concentration values and three covariates from 28 sites in New York for
the 62 days during the months of July and August, 2006.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nysptime
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 1736 rows and 12 columns.
</p>


<h3>Source</h3>

<p>It is the same as the NYdata set in the spTimer package, 
Bakar and Sahu (2015), 
with two added columns providing the UTM X- and Y- coordinates.
Each data row is  for a particular site and a day as detailed below.
</p>
<p>@format A data frame with 1736 rows and 12 columns:
</p>

<dl>
<dt>s.index</dt><dd><p>site index (1 to 28)</p>
</dd>
<dt>Longitude</dt><dd><p>Longitude of the site</p>
</dd>
<dt>Latitude</dt><dd><p>Latitude of the site</p>
</dd>
<dt>utmx</dt><dd><p>UTM X-coordinate of the site</p>
</dd>
<dt>utmy</dt><dd><p>UTM Y-coordinate of the site</p>
</dd>
<dt>Year</dt><dd><p>This is 2006 for all the rows</p>
</dd>
<dt>Month</dt><dd><p>Month taking values 7 for July and 8 for August</p>
</dd>
<dt>Day</dt><dd><p>Day taking values 1 to 31</p>
</dd>
<dt>y8hrmax</dt><dd><p>Daily 8-hour maximum ozone concentration value</p>
</dd>
<dt>xmaxtemp</dt><dd><p>Maximum temperature (degree Celsius)</p>
</dd>
<dt>xwdsp</dt><dd><p>wind speed (nautical mile per hour)</p>
</dd>
<dt>xrh</dt><dd><p>Relative humidity</p>
</dd>
</dl>



<h3>References</h3>

<p>Bakar KS, Sahu SK (2015).
&ldquo;spTimer: Spatio-Temporal Bayesian Modeling Using R.&rdquo;
<em>Journal of Statistical Software, Articles</em>, <b>63</b>(15), 1&ndash;32.
ISSN 1548-7660, <a href="https://doi.org/10.18637/jss.v063.i15">doi:10.18637/jss.v063.i15</a>, <a href="https://www.jstatsoft.org/v063/i15">https://www.jstatsoft.org/v063/i15</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(nysptime)
summary(nysptime[, 9:12])
</code></pre>

<hr>
<h2 id='obs_v_pred_plot'>Observed against predicted plot</h2><span id='topic+obs_v_pred_plot'></span>

<h3>Description</h3>

<p>Observed against predicted plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obs_v_pred_plot(
  yobs,
  predsums,
  segments = TRUE,
  summarystat = "median",
  plotit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obs_v_pred_plot_+3A_yobs">yobs</code></td>
<td>
<p>A vector containing the actual observations</p>
</td></tr>
<tr><td><code id="obs_v_pred_plot_+3A_predsums">predsums</code></td>
<td>
<p>A data frame containing predictive summary 
statistics with the same number of rows as the length of the vector yobs. 
The data frame must have columns named as meanpred, medianpred, sd, low and up. 
Ideally this argument should be the output of the command 
<code><a href="#topic+get_validation_summaries">get_validation_summaries</a></code>.</p>
</td></tr>
<tr><td><code id="obs_v_pred_plot_+3A_segments">segments</code></td>
<td>
<p>Logical: whether to draw line segments for the prediction intervals.</p>
</td></tr>
<tr><td><code id="obs_v_pred_plot_+3A_summarystat">summarystat</code></td>
<td>
<p>Can take one of two values &quot;median&quot; (default) or &quot;mean&quot; 
indicating which one to use for the plot.</p>
</td></tr>
<tr><td><code id="obs_v_pred_plot_+3A_plotit">plotit</code></td>
<td>
<p>Logical scalar value: whether to plot the predictions against the observed values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draws a plot only after removing the missing observations.  It also returns a list of two ggplot2 
objects: (i) a plot with intervals drawn <code>pwithseg</code> and (ii) a plot without the segments drawn: 
<code>pwithoutseg</code> and (iii) a simple plot not showing the range of the prediction intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4)
vrows &lt;- sample(nrow(nysptime), 100)
M1 &lt;- Bsptime(model="lm", formula=y8hrmax~xmaxtemp+xwdsp+xrh, data=nysptime, 
validrows=vrows, scale.transform = "SQRT")
psums &lt;-  get_validation_summaries(M1$valpreds)
oplots &lt;- obs_v_pred_plot(yobs=M1$yobs_preds$y8hrmax, predsum=psums)
names(oplots)
plot(oplots$pwithoutseg)
plot(oplots$pwithseg)
</code></pre>

<hr>
<h2 id='phichoice_sp'>Grid search method for choosing phi
Calculates the validation statistics using the spatial model with a given range of values of
the decay parameter phi.</h2><span id='topic+phichoice_sp'></span>

<h3>Description</h3>

<p>Grid search method for choosing phi
Calculates the validation statistics using the spatial model with a given range of values of
the decay parameter phi.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phichoice_sp(
  formula,
  data,
  coordtype,
  coords,
  phis,
  scale.transform,
  s,
  N,
  burn.in,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phichoice_sp_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;formula&quot; (or one that can be coerced to that class): 
a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="phichoice_sp_+3A_data">data</code></td>
<td>
<p>The data frame for which the model formula is to be fitted. 
If a spatial model is to be fitted then the data 
frame should contain two columns containing the locations 
of the coordinates. See the coords argument below.</p>
</td></tr>
<tr><td><code id="phichoice_sp_+3A_coordtype">coordtype</code></td>
<td>
<p>Type of coordinates: utm, lonlat or plain with utm 
(supplied in meters) as the default. 
Distance will be calculated in units of kilometer 
if this argument is either utm or lonlat. 
Euclidean distance will be calculated if this is 
given as the third type plain. If distance in meter is to be 
calculated then coordtype should be passed on as plain although 
the coords are supplied in UTM.</p>
</td></tr>
<tr><td><code id="phichoice_sp_+3A_coords">coords</code></td>
<td>
<p>A vector of size two identifying the two column 
numbers of the data frame to take as coordinates. Or this can 
be given as a matrix of number of sites by 2 
providing the coordinates of all the data locations.</p>
</td></tr>
<tr><td><code id="phichoice_sp_+3A_phis">phis</code></td>
<td>
<p>A vector values of phi</p>
</td></tr>
<tr><td><code id="phichoice_sp_+3A_scale.transform">scale.transform</code></td>
<td>
<p>Transformation of the response variable. 
It can take three values: SQRT, LOG or NONE.</p>
</td></tr>
<tr><td><code id="phichoice_sp_+3A_s">s</code></td>
<td>
<p>A vector giving the validation sites</p>
</td></tr>
<tr><td><code id="phichoice_sp_+3A_n">N</code></td>
<td>
<p>MCMC sample size. Default value 5000.</p>
</td></tr>
<tr><td><code id="phichoice_sp_+3A_burn.in">burn.in</code></td>
<td>
<p>How many initial iterations to discard. Default value 1000. 
Only relevant for MCMC based model fitting, i.e., when package is spBayes or Stan.</p>
</td></tr>
<tr><td><code id="phichoice_sp_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should it print progress?</p>
</td></tr>
<tr><td><code id="phichoice_sp_+3A_...">...</code></td>
<td>
<p>Any additional parameter that may be passed to <code>Bspatial</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame giving the phi values and the corresponding 
validation statistics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- phichoice_sp(formula=yo3~xmaxtemp+xwdsp+xrh, data=nyspatial, 
coordtype="utm", coords=4:5, 
phis=seq(from=0.1, to=1, by=0.4), scale.transform="NONE", 
s=c(8,11,12,14,18,21,24,28), N=20, burn.in=10, verbose=TRUE)

</code></pre>

<hr>
<h2 id='phichoicep'>Calculates the validation statistics using the spatial model with a given range of values of
the decay parameter phi.</h2><span id='topic+phichoicep'></span>

<h3>Description</h3>

<p>Calculates the validation statistics using the spatial model with a given range of values of
the decay parameter phi.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phichoicep(
  formula,
  data,
  coordtype,
  coords,
  scale.transform,
  phis,
  phit,
  valids,
  N,
  burn.in,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phichoicep_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;formula&quot; (or one that can be coerced to that class): 
a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="phichoicep_+3A_data">data</code></td>
<td>
<p>The data frame for which the model formula is to be fitted. 
If a spatial model is to be fitted then the data 
frame should contain two columns containing the locations 
of the coordinates. See the coords argument below.</p>
</td></tr>
<tr><td><code id="phichoicep_+3A_coordtype">coordtype</code></td>
<td>
<p>Type of coordinates: utm, lonlat or plain with utm 
(supplied in meters) as the default. 
Distance will be calculated in units of kilometer 
if this argument is either utm or lonlat. 
Euclidean distance will be calculated if this is 
given as the third type plain. If distance in meter is to be 
calculated then coordtype should be passed on as plain although 
the coords are supplied in UTM.</p>
</td></tr>
<tr><td><code id="phichoicep_+3A_coords">coords</code></td>
<td>
<p>A vector of size two identifying the two column 
numbers of the data frame to take as coordinates. Or this can 
be given as a matrix of number of sites by 2 
providing the coordinates of all the data locations.</p>
</td></tr>
<tr><td><code id="phichoicep_+3A_scale.transform">scale.transform</code></td>
<td>
<p>Transformation of the response variable. 
It can take three values: SQRT, LOG or NONE.</p>
</td></tr>
<tr><td><code id="phichoicep_+3A_phis">phis</code></td>
<td>
<p>A vector values of phi for spatial decay</p>
</td></tr>
<tr><td><code id="phichoicep_+3A_phit">phit</code></td>
<td>
<p>A vector values of phi for temporal decay</p>
</td></tr>
<tr><td><code id="phichoicep_+3A_valids">valids</code></td>
<td>
<p>A vector giving the validation sites</p>
</td></tr>
<tr><td><code id="phichoicep_+3A_n">N</code></td>
<td>
<p>MCMC sample size.</p>
</td></tr>
<tr><td><code id="phichoicep_+3A_burn.in">burn.in</code></td>
<td>
<p>How many initial iterations to discard. 
Only relevant for MCMC based model fitting, i.e., when package is spBayes or Stan.</p>
</td></tr>
<tr><td><code id="phichoicep_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should progress be printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame giving the phi values and the corresponding validation statistics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;-  phichoicep(formula=y8hrmax ~ xmaxtemp+xwdsp+xrh, data=nysptime, 
coordtype="utm", coords=4:5, scale.transform = "SQRT",  
phis=c(0.001,  0.005, 0.025, 0.125, 0.625), phit=c(0.05, 0.25, 1.25, 6.25), 
valids=c(8,11,12,14,18,21,24,28), N=20, burn.in=10, verbose=TRUE)

</code></pre>

<hr>
<h2 id='plot.bmstdr'>Plot method for  bmstdr objects.</h2><span id='topic+plot.bmstdr'></span>

<h3>Description</h3>

<p>Plot method for  bmstdr objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmstdr'
plot(x, segments = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bmstdr_+3A_x">x</code></td>
<td>
<p>A bmstdr model fit object.</p>
</td></tr>
<tr><td><code id="plot.bmstdr_+3A_segments">segments</code></td>
<td>
<p>TRUE or FALSE. It decides whether to draw the prediction intervals
as line segments.</p>
</td></tr>
<tr><td><code id="plot.bmstdr_+3A_...">...</code></td>
<td>
<p>Any other additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It plots the observed values on the original scale 
against the predictions and the 95% prediction intervals if validation has been 
performed. It then plots the residuals against fitted values. It then applies 
plotting method to the model fitted object as returned by the chosen named package. 
There is no return value.
</p>

<hr>
<h2 id='print.bmstdr'>Provides basic information regarding the fitted model.</h2><span id='topic+print.bmstdr'></span>

<h3>Description</h3>

<p>Provides basic information regarding the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmstdr'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bmstdr_+3A_x">x</code></td>
<td>
<p>A bmstdr model fit object.</p>
</td></tr>
<tr><td><code id="print.bmstdr_+3A_digits">digits</code></td>
<td>
<p>How many significant digits after the decimal to print, defaults to 3.</p>
</td></tr>
<tr><td><code id="print.bmstdr_+3A_...">...</code></td>
<td>
<p>Any other additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>

<hr>
<h2 id='residuals.bmstdr'>Extract residuals from a bmstdr  fitted object.</h2><span id='topic+residuals.bmstdr'></span>

<h3>Description</h3>

<p>Extract residuals from a bmstdr  fitted object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmstdr'
residuals(object, numbers = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.bmstdr_+3A_object">object</code></td>
<td>
<p>A bmstdr model fit object.</p>
</td></tr>
<tr><td><code id="residuals.bmstdr_+3A_numbers">numbers</code></td>
<td>
<p>a list with two components: sn=number of spatial locations 
tn=number of time points. Residuals will be assumed to follow the arrangement 
of the data frame - sorted by space and then time within space.</p>
</td></tr>
<tr><td><code id="residuals.bmstdr_+3A_...">...</code></td>
<td>
<p>Any other additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of residuals. If appropriate, it draws a 
time series plot of residuals. Otherwise, it draws a plot of residuals 
against observation numbers.
</p>

<hr>
<h2 id='summary.bmstdr'>Provides basic summaries of model fitting.</h2><span id='topic+summary.bmstdr'></span>

<h3>Description</h3>

<p>Provides basic summaries of model fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmstdr'
summary(object, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bmstdr_+3A_object">object</code></td>
<td>
<p>A bmstdr model fit object.</p>
</td></tr>
<tr><td><code id="summary.bmstdr_+3A_digits">digits</code></td>
<td>
<p>How many significant digits after the decimal to print, defaults to 3.</p>
</td></tr>
<tr><td><code id="summary.bmstdr_+3A_...">...</code></td>
<td>
<p>Any other additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>

<hr>
<h2 id='terms.bmstdr'>Prints the terms</h2><span id='topic+terms.bmstdr'></span>

<h3>Description</h3>

<p>Prints the terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bmstdr'
terms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="terms.bmstdr_+3A_x">x</code></td>
<td>
<p>A bmstdr model fit object.</p>
</td></tr>
<tr><td><code id="terms.bmstdr_+3A_...">...</code></td>
<td>
<p>Any other additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Terms in the model formula
</p>

<hr>
<h2 id='Weng'>A 313 by 313 proximity matrix for the 313 LADCUAS in England. Each entry is either 0 or 1 
and is 1 if the corresponding row and column LADCUAs share a common boundary.</h2><span id='topic+Weng'></span>

<h3>Description</h3>

<p>A 313 by 313 proximity matrix for the 313 LADCUAS in England. Each entry is either 0 or 1 
and is 1 if the corresponding row and column LADCUAs share a common boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Weng
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 313 rows and 313 columns.
</p>


<h3>Source</h3>

<p>Sahu and Böhning (2021).
</p>


<h3>References</h3>

<p>Sahu SK, Böhning D (2021).
&ldquo;Bayesian spatio-temporal joint disease mapping of Covid-19 cases and deaths in local authorities of England.&rdquo;
<em>Spatial Statistics</em>.
<a href="https://doi.org/10.1016/j.spasta.2021.100519">doi:10.1016/j.spasta.2021.100519</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> dim(Weng)
 summary(apply(Weng, 1, sum))
</code></pre>

<hr>
<h2 id='ydata'>Average air pollution values from 28 sites in New York.</h2><span id='topic+ydata'></span>

<h3>Description</h3>

<p>Average air pollution values from 28 sites in New York.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ydata

ydata
</code></pre>


<h3>Format</h3>

<p>A vector with 28 real values.
</p>
<p>An object of class <code>numeric</code> of length 28.
</p>


<h3>Source</h3>

<p>This is obtained by calculating site-wise averages 
of the NYdata set in the 'spTimer' package
Bakar and Sahu (2015).
Each data point is the mean of the available daily 8-hour maximum average ozone concentrations
in parts per billion (ppb) at each of the
28 sites. The daily values are for the month of July and August in 2006.
</p>


<h3>References</h3>

<p>Bakar KS, Sahu SK (2015).
&ldquo;spTimer: Spatio-Temporal Bayesian Modeling Using R.&rdquo;
<em>Journal of Statistical Software, Articles</em>, <b>63</b>(15), 1&ndash;32.
ISSN 1548-7660, <a href="https://doi.org/10.18637/jss.v063.i15">doi:10.18637/jss.v063.i15</a>, <a href="https://www.jstatsoft.org/v063/i15">https://www.jstatsoft.org/v063/i15</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> summary(ydata)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
