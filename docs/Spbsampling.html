<!DOCTYPE html><html lang="en"><head><title>Help for package Spbsampling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Spbsampling}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hpwd'><p>Heuristic Product Within Distance (Spatially Balanced Sampling Design)</p></a></li>
<li><a href='#income_emilia'><p>The income of municipalities of &quot;Emilia Romagna&quot;.</p></a></li>
<li><a href='#lucas_abruzzo'><p>LUCAS data for the region &quot;Abruzzo&quot;, Italy.</p></a></li>
<li><a href='#pwd'><p>Product Within Distance (Spatially Balanced Sampling Design)</p></a></li>
<li><a href='#sbi'><p>Spatial Balance Index</p></a></li>
<li><a href='#simul1'><p>Simulated Population 1.</p></a></li>
<li><a href='#simul2'><p>Simulated Population 2.</p></a></li>
<li><a href='#simul3'><p>Simulated Population 3.</p></a></li>
<li><a href='#Spbsampling'><p>Spatially balanced sampling designs</p></a></li>
<li><a href='#stprod'><p>Standardize a symmetric matrix (distances) to fixed row (column) products</p></a></li>
<li><a href='#stsum'><p>Standardize a symmetric matrix (distances) to fixed row (column) totals</p></a></li>
<li><a href='#swd'><p>Sum Within Distance (Spatially Balanced Sampling Design)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Spatially Balanced Sampling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Selection of spatially balanced samples. In particular, the implemented sampling designs allow to select probability samples well spread over the population of interest, in any dimension and using any distance function (e.g. Euclidean distance, Manhattan distance). For more details, Pantalone F, Benedetti R, and Piersimoni F (2022) &lt;<a href="https://doi.org/10.18637%2Fjss.v103.c02">doi:10.18637/jss.v103.c02</a>&gt;, Benedetti R and Piersimoni F (2017) &lt;<a href="https://doi.org/10.1002%2Fbimj.201600194">doi:10.1002/bimj.201600194</a>&gt;, and Benedetti R and Piersimoni F (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1710.09116">doi:10.48550/arXiv.1710.09116</a>&gt;. The implementation has been done in C++ through the use of 'Rcpp' and 'RcppArmadillo'. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-24 08:43:36 UTC; francescopantalone</td>
</tr>
<tr>
<td>Author:</td>
<td>Francesco Pantalone [aut, cre],
  Roberto Benedetti [aut],
  Federica Piersimoni [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Francesco Pantalone &lt;pantalone.fra@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-24 09:32:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='hpwd'>Heuristic Product Within Distance (Spatially Balanced Sampling Design)</h2><span id='topic+hpwd'></span>

<h3>Description</h3>

<p>Selects spatially balanced samples through the use of
Heuristic Product Within Distance design (HPWD). To have constant inclusion
probabilities <code class="reqn">\pi_{i}=n/N</code>, where <code class="reqn">n</code> is sample size
and <code class="reqn">N</code> is population size, the distance matrix has to be standardized
with function <code><a href="#topic+stprod">stprod</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hpwd(dis, n, beta = 10, nrepl = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hpwd_+3A_dis">dis</code></td>
<td>
<p>A distance matrix NxN that specifies how far all the pairs
of units in the population are.</p>
</td></tr>
<tr><td><code id="hpwd_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="hpwd_+3A_beta">beta</code></td>
<td>
<p>Parameter <code class="reqn">\beta</code> for the algorithm. The higher
<code class="reqn">\beta</code> is, the more the sample is going to be spread (default = 10).</p>
</td></tr>
<tr><td><code id="hpwd_+3A_nrepl">nrepl</code></td>
<td>
<p>Number of samples to draw (default = 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The HPWD design generates samples approximately with the same
probabilities of the <code><a href="#topic+pwd">pwd</a></code> but with a significantly smaller
number of steps. In fact, this algorithm randomly selects a sample of size
<code class="reqn">n</code> exactly with <code class="reqn">n</code> steps, updating at each step the selection
probability of not-selected units, depending on their distance from the
units that were already selected in the previous steps.
</p>


<h3>Value</h3>

<p>Returns a matrix <code>nrepl</code> x <code>n</code>, which contains the
<code>nrepl</code> selected samples, each of them stored in a row. In particular,
the i-th row contains all labels of units selected in the i-th sample.
</p>


<h3>References</h3>

<p>Benedetti R, Piersimoni F (2017). A spatially balanced design with
probability function proportional to the within sample distance.
<em>Biometrical Journal</em>, <strong>59</strong>(5), 1067-1084.
<a href="https://doi.org/10.1002/bimj.201600194">doi:10.1002/bimj.201600194</a>
</p>
<p>Benedetti R, Piersimoni F (2017). Fast Selection of Spatially Balanced Samples. <em>arXiv</em>.
<a href="https://arxiv.org/abs/1710.09116">https://arxiv.org/abs/1710.09116</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Draw 1 sample of dimension 10 without constant inclusion probabilities
dis &lt;- as.matrix(dist(cbind(lucas_abruzzo$x, lucas_abruzzo$y))) # distance matrix
s &lt;- hpwd(dis = dis, n = 10) # drawn sample

# Example 2
# Draw 1 sample of dimension 15 with constant inclusion probabilities
# equal to n/N, with N = population size
dis &lt;- as.matrix(dist(cbind(lucas_abruzzo$x, lucas_abruzzo$y))) # distance matrix
con &lt;- rep(1, nrow(dis)) # vector of constraints
stand_dist &lt;- stprod(mat = dis, con = con) # standardized matrix
s &lt;- hpwd(dis = stand_dist$mat, n = 15) # drawn sample

# Example 3
# Draw 2 samples of dimension 15 with constant inclusion probabilities
# equal to n/N, with N = population size, and an increased level of spread, beta = 20
dis &lt;- as.matrix(dist(cbind(lucas_abruzzo$x, lucas_abruzzo$y))) # distance matrix
con &lt;- rep(0, nrow(dis)) # vector of constraints
stand_dist &lt;- stprod(mat = dis, con = con) # standardized matrix
s &lt;- hpwd(dis = stand_dist$mat, n = 15, beta = 20, nrepl = 2) # drawn samples

</code></pre>

<hr>
<h2 id='income_emilia'>The income of municipalities of &quot;Emilia Romagna&quot;.</h2><span id='topic+income_emilia'></span>

<h3>Description</h3>

<p>The dataset contains the total income of the municipalities in the region
&quot;Emilia Romagna&quot;, in Italy, for the year 2015. Each municipality is defined
by their own ISTAT (Istituto nazionale di statistica, Italy) code and a name.
For each municipality there are the following auxiliary variables: province,
number of taxpayers and spatial coordinates (geographical position).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>income_emilia
</code></pre>


<h3>Format</h3>

<p>A data frame with 334 rows and 7 variables:
</p>

<dl>
<dt>municipality_code</dt><dd><p>identification municipality code</p>
</dd>
<dt>municipality</dt><dd><p>name of the municipality</p>
</dd>
<dt>province</dt><dd><p>province of the municipality</p>
</dd>
<dt>numtaxpay</dt><dd><p>number of taxpayers in the municipality</p>
</dd>
<dt>tot_inc</dt><dd><p>average income of the municipality</p>
</dd>
<dt>x_coord</dt><dd><p>coordinate x of the municipality</p>
</dd>
<dt>y_coord</dt><dd><p>coordinate y of the municipality</p>
</dd>
</dl>



<h3>Source</h3>

<p>The dataset is a rearrangement from the data released by
the Italian Finance Department, MEF - Dipartimento delle Finanze (Italy).
</p>

<hr>
<h2 id='lucas_abruzzo'>LUCAS data for the region &quot;Abruzzo&quot;, Italy.</h2><span id='topic+lucas_abruzzo'></span>

<h3>Description</h3>

<p>The land use/cover area frame statistical survey, abbreviated as LUCAS, is a
European field survey program funded and executed by Eurostat. Its objective
is to set up area frame surveys for the provision of coherent and harmonised
statistics on land use and land cover in the European Union (EU). Note that
in LUCAS survey the concept of land is extended to inland water areas
(lakes, river, coastal areas, etc.) and does not embrace uses below the
earth's surface (mine deposits, subways, etc.). The LUCAS survey is a point
survey, in particular the basic unit of observation is a circle with a
radius of 1.5m (corresponding to an identifiable point on an orthophoto).
In the classification there is a clear distinction between land cover and
land use: land cover means physical cover (&quot;material&quot;) observed at the
earth's surface; land use means socio-economic function of the observed
earth's surface. For each of both we assign a code to identified which type
the point is. Land cover has 8 main categories, which are indicated by letter:
</p>

<dl>
<dt>A</dt><dd><p>artificial land</p>
</dd>
<dt>B</dt><dd><p>cropland</p>
</dd>
<dt>C</dt><dd><p>woodland</p>
</dd>
<dt>D</dt><dd><p>shrubland</p>
</dd>
<dt>E</dt><dd><p>grassland</p>
</dd>
<dt>F</dt><dd><p>bareland</p>
</dd>
<dt>G</dt><dd><p>water</p>
</dd>
<dt>H</dt><dd><p>wetlands</p>
</dd>
</dl>

<p>Every main category has subclasses, which are indicated by the combination
of the letter of the category and digits. Altogether there are 84 classes.
Land use has 14 main categories. It has altogether 33 classes, which are
indicated by the combination of the letter U and three digits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lucas_abruzzo
</code></pre>


<h3>Format</h3>

<p>A data frame with 2699 rows and 7 variables:
</p>

<dl>
<dt>id</dt><dd><p>identified code for the unit spatial point</p>
</dd>
<dt>prov</dt><dd><p>province</p>
</dd>
<dt>elev</dt><dd><p>elevation of the unit spatial point, meant as the height above or below sea level</p>
</dd>
<dt>x</dt><dd><p>coordinate x</p>
</dd>
<dt>y</dt><dd><p>coordinate y</p>
</dd>
<dt>lc</dt><dd><p>land cover code</p>
</dd>
<dt>lu</dt><dd><p>land use code</p>
</dd>
</dl>



<h3>Source</h3>

<p>The dataset is a rearrangement of the data from LUCAS 2012 for the region &quot;Abruzzo&quot;, Italy.
<a href="https://ec.europa.eu/eurostat/web/lucas/data/primary-data/2012">https://ec.europa.eu/eurostat/web/lucas/data/primary-data/2012</a>
</p>

<hr>
<h2 id='pwd'>Product Within Distance (Spatially Balanced Sampling Design)</h2><span id='topic+pwd'></span>

<h3>Description</h3>

<p>Selects spatially balanced samples through the use of the
Product Within Distance design (PWD). To have constant inclusion
probabilities <code class="reqn">\pi_{i}=n/N</code>, where <code class="reqn">n</code> is sample size and
<code class="reqn">N</code> is population size, the distance matrix has to be standardized with
function <code><a href="#topic+stprod">stprod</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwd(dis, n, beta = 10, nrepl = 1L, niter = 10L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pwd_+3A_dis">dis</code></td>
<td>
<p>A distance matrix NxN that specifies how far all the pairs
of units in the population are.</p>
</td></tr>
<tr><td><code id="pwd_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="pwd_+3A_beta">beta</code></td>
<td>
<p>Parameter <code class="reqn">\beta</code> for the algorithm. The higher
<code class="reqn">\beta</code> is, the more the sample is going to be spread (default = 10).</p>
</td></tr>
<tr><td><code id="pwd_+3A_nrepl">nrepl</code></td>
<td>
<p>Number of samples to draw (default = 1).</p>
</td></tr>
<tr><td><code id="pwd_+3A_niter">niter</code></td>
<td>
<p>Maximum number of iterations for the algorithm. More iterations are
better but require more time. Usually 10 is very efficient (default = 10).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>

<ul>
<li> <p><code>s</code>, a matrix <code>nrepl</code> x <code>n</code>, which contains the
<code>nrepl</code> selected samples, each of them stored in a row. In particular,
the i-th row contains all labels of units selected in the i-th sample.
</p>
</li>
<li> <p><code>iterations</code>, number of iterations run by the algorithm.
</p>
</li></ul>



<h3>References</h3>

<p>Benedetti R, Piersimoni F (2017). A spatially balanced design with
probability function proportional to the within sample distance.
<em>Biometrical Journal</em>, <strong>59</strong>(5), 1067-1084.
<a href="https://doi.org/10.1002/bimj.201600194">doi:10.1002/bimj.201600194</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Draw 1 sample of dimension 15 without constant inclusion probabilities
dis &lt;- as.matrix(dist(cbind(lucas_abruzzo$x, lucas_abruzzo$y))) # distance matrix
s &lt;- pwd(dis = dis, n = 15)$s  # drawn sample

# Example 2
# Draw 1 sample of dimension 15 with constant inclusion probabilities
# equal to n/N, with N = population size
dis &lt;- as.matrix(dist(cbind(lucas_abruzzo$x, lucas_abruzzo$y))) # distance matrix
con &lt;- rep(0, nrow(dis)) # vector of constraints
stand_dist &lt;- stprod(mat = dis, con = con) # standardized matrix
s &lt;- pwd(dis = stand_dist$mat, n = 15)$s  # drawn sample

# Example 3
# Draw 2 samples of dimension 15 with constant inclusion probabilities
# equal to n/N, with N = population size, and an increased level of spread, beta = 20
dis &lt;- as.matrix(dist(cbind(lucas_abruzzo$x, lucas_abruzzo$y))) # distance matrix
con &lt;- rep(0, nrow(dis)) # vector of constraints
stand_dist &lt;- stprod(mat = dis, con = con) # standardized matrix
s &lt;- pwd(dis = stand_dist$mat, n = 15, beta = 20, nrepl = 2)$s  # drawn samples

</code></pre>

<hr>
<h2 id='sbi'>Spatial Balance Index</h2><span id='topic+sbi'></span>

<h3>Description</h3>

<p>Computes the Spatial Balance Index (SBI), which is a measure of
spatial balance of a sample. The lower it is, the better the spread.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbi(dis, pi, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sbi_+3A_dis">dis</code></td>
<td>
<p>A distance matrix NxN that specifies how far all the pairs
of units in the population are.</p>
</td></tr>
<tr><td><code id="sbi_+3A_pi">pi</code></td>
<td>
<p>A vector of first order inclusion probabilities of the units
of the population.</p>
</td></tr>
<tr><td><code id="sbi_+3A_s">s</code></td>
<td>
<p>A vector of labels of the sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SBI is based on Voronoi polygons. Given a sample s, each unit <code class="reqn">i</code>
in the sample has its own Voronoi polygon, which is composed by all
population units closer to <code class="reqn">i</code> than to any other sample unit <code class="reqn">j</code>.
Then, per each Voronoi polygon, define <code class="reqn">v_{i}</code> as the sum of the
inclusion probabilities of all units in the <code class="reqn">i</code>-th Voronoi polygon.
Finally, the variance of <code class="reqn">v_{i}</code> is the SBI.
</p>


<h3>Value</h3>

<p>Returns the Spatial Balance Index.
</p>


<h3>References</h3>

<p>Stevens DL, Olsen AR (2004). Spatially Balanced Sampling of Natural Resources.
<em>Journal of the American Statistical Association</em>, <strong>99</strong>(465), 262-278.
<a href="https://doi.org/10.1198/016214504000000250">doi:10.1198/016214504000000250</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

dis &lt;- as.matrix(dist(cbind(simul1$x, simul1$y))) # distance matrix
con &lt;- rep(0, nrow(dis)) # vector of constraints
stand_dist &lt;- stprod(mat = dis, con = con) # standardized matrix
pi &lt;- rep(100 / nrow(dis), nrow(dis)) # vector of probabilities inclusion
s &lt;- pwd(dis = stand_dist$mat, n = 100)$s # sample
sbi(dis = dis, pi = pi, s = s)

</code></pre>

<hr>
<h2 id='simul1'>Simulated Population 1.</h2><span id='topic+simul1'></span>

<h3>Description</h3>

<p>The dataset contains a simulated georeferenced population of dimension
<code class="reqn">N=1000</code>. The coordinates are generated in the range <code class="reqn">[0,1]</code> as a
simulated realization of a particular random point pattern: the Neyman-Scott
process with Cauchy cluster kernel. The nine values for each unit are
generated according to the outcome of a Gaussian stochastic process, with an
intensity dependence parameter <code class="reqn">\rho=0.001</code> (that means low dependence)
and with no spatial trend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul1
</code></pre>


<h3>Format</h3>

<p>A data frame with  1000 rows and 11 variables:
</p>

<dl>
<dt>x</dt><dd><p>coordinate x</p>
</dd>
<dt>y</dt><dd><p>coordinate y</p>
</dd>
<dt>z11</dt><dd><p>first value of the unit</p>
</dd>
<dt>z12</dt><dd><p>second value of the unit</p>
</dd>
<dt>z13</dt><dd><p>third value of the unit</p>
</dd>
<dt>z14</dt><dd><p>fourth value of the unit</p>
</dd>
<dt>z15</dt><dd><p>fifth value of the unit</p>
</dd>
<dt>z16</dt><dd><p>sixth value of the unit</p>
</dd>
<dt>z17</dt><dd><p>seventh value of the unit</p>
</dd>
<dt>z18</dt><dd><p>eighth value of the unit</p>
</dd>
<dt>z19</dt><dd><p>ninth value of the unit</p>
</dd>
</dl>



<h3>Source</h3>

<p>Benedetti R, Piersimoni F (2017). A spatially balanced design with
probability function proportional to the within sample distance.
<em>Biometrical Journal</em>, <strong>59</strong>(5), 1067-1084.
</p>

<hr>
<h2 id='simul2'>Simulated Population 2.</h2><span id='topic+simul2'></span>

<h3>Description</h3>

<p>The dataset contains a simulated georeferenced population of dimension
<code class="reqn">N=1000</code>. The coordinates are generated in the range <code class="reqn">[0,1]</code> as a
simulated realization of a particular random point pattern: the Neyman-Scott
process with Cauchy cluster kernel. The nine values for each unit are
generated according to the outcome of a Gaussian stochastic process, with an
intensity dependence parameter <code class="reqn">\rho=0.01</code> (that means medium dependence)
and with a spatial trend <code class="reqn">x_{1}+x_{2}+\epsilon</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul2
</code></pre>


<h3>Format</h3>

<p>A data frame with  1000 rows and 11 variables:
</p>

<dl>
<dt>x</dt><dd><p>coordinate x</p>
</dd>
<dt>y</dt><dd><p>coordinate y</p>
</dd>
<dt>z21</dt><dd><p>first value of the unit</p>
</dd>
<dt>z22</dt><dd><p>second value of the unit</p>
</dd>
<dt>z23</dt><dd><p>third value of the unit</p>
</dd>
<dt>z24</dt><dd><p>fourth value of the unit</p>
</dd>
<dt>z25</dt><dd><p>fifth value of the unit</p>
</dd>
<dt>z26</dt><dd><p>sixth value of the unit</p>
</dd>
<dt>z27</dt><dd><p>seventh value of the unit</p>
</dd>
<dt>z28</dt><dd><p>eighth value of the unit</p>
</dd>
<dt>z29</dt><dd><p>ninth value of the unit</p>
</dd>
</dl>



<h3>Source</h3>

<p>Benedetti R, Piersimoni F (2017). A spatially balanced design with
probability function proportional to the within sample distance.
<em>Biometrical Journal</em>, <strong>59</strong>(5), 1067-1084.
</p>

<hr>
<h2 id='simul3'>Simulated Population 3.</h2><span id='topic+simul3'></span>

<h3>Description</h3>

<p>The dataset contains a simulated georeferenced population of dimension
<code class="reqn">N=1000</code>. The coordinates are generated in the range <code class="reqn">[0,1]</code> as a
simulated realization of a particular random point pattern: the Neyman-Scott
process with Cauchy cluster kernel. The nine values for each unit are
generated according to the outcome of a Gaussian stochastic process, with an
intensity dependence parameter <code class="reqn">\rho=0.1</code> (that means high dependence)
and with a spatial trend <code class="reqn">x_{1}+x_{2}+\epsilon</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul3
</code></pre>


<h3>Format</h3>

<p>A data frame with  1000 rows and 11 variables:
</p>

<dl>
<dt>x</dt><dd><p>coordinate x</p>
</dd>
<dt>y</dt><dd><p>coordinate y</p>
</dd>
<dt>z31</dt><dd><p>first value of the unit</p>
</dd>
<dt>z32</dt><dd><p>second value of the unit</p>
</dd>
<dt>z33</dt><dd><p>third value of the unit</p>
</dd>
<dt>z34</dt><dd><p>fourth value of the unit</p>
</dd>
<dt>z35</dt><dd><p>fifth value of the unit</p>
</dd>
<dt>z36</dt><dd><p>sixth value of the unit</p>
</dd>
<dt>z37</dt><dd><p>seventh value of the unit</p>
</dd>
<dt>z38</dt><dd><p>eighth value of the unit</p>
</dd>
<dt>z39</dt><dd><p>ninth value of the unit</p>
</dd>
</dl>



<h3>Source</h3>

<p>Benedetti R, Piersimoni F (2017). A spatially balanced design with
probability function proportional to the within sample distance.
<em>Biometrical Journal</em>, <strong>59</strong>(5), 1067-1084.
</p>

<hr>
<h2 id='Spbsampling'>Spatially balanced sampling designs</h2><span id='topic+Spbsampling'></span>

<h3>Description</h3>

<p>Selection of spatially balanced samples. In particular, the implemented
sampling designs allow to select probability samples well spread over the
population of interest, in any dimension and using any distance function
(e.g. Euclidean distance, Manhattan distance). The implementation has been
done in <code>C++</code> through the use of <code>Rcpp</code> and <code>RcppArmadillo</code>.
</p>


<h3>Author(s)</h3>

<p>Francesco Pantalone, Roberto Benedetti, Federica Piersimoni
</p>
<p>Maintainer: Francesco Pantalone <a href="mailto:pantalone.fra@gmail.com">pantalone.fra@gmail.com</a>
</p>


<h3>References</h3>

<p>Pantalone F, Benedetti R, Piersimoni F (2022). An R Package for
Spatially Balanced Sampling. <em>Journal of Statistical Software, Code Snippets</em>,
<strong>103</strong>(2), 1-22.
&lt;doi:10.18637/jss.v103.c02&gt;
</p>
<p>Benedetti R, Piersimoni F (2017). A spatially balanced design with
probability function proportional to the within sample distance.
<em>Biometrical Journal</em>, <strong>59</strong>(5), 1067-1084.
<a href="https://doi.org/10.1002/bimj.201600194">doi:10.1002/bimj.201600194</a>
</p>
<p>Benedetti R, Piersimoni F (2017). Fast Selection of Spatially Balanced Samples. <em>arXiv</em>.
<a href="https://arxiv.org/abs/1710.09116">https://arxiv.org/abs/1710.09116</a>
</p>

<hr>
<h2 id='stprod'>Standardize a symmetric matrix (distances) to fixed row (column) products</h2><span id='topic+stprod'></span>

<h3>Description</h3>

<p>Standardizes a distance matrix to fixed rows and columns
products. The function iteratively constrains a logarithmic transformed
matrix to know products, and in order to keep the symmetry of the matrix,
at each iteration performs an average with its transpose. When the known
products are all equal to a constant (e.g. 0), this method provides a
simple and accurate way to scale a distance matrix to a doubly stochastic
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stprod(mat, con, differ = 1e-15, niter = 1000L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stprod_+3A_mat">mat</code></td>
<td>
<p>A distance matrix size NxN.</p>
</td></tr>
<tr><td><code id="stprod_+3A_con">con</code></td>
<td>
<p>A vector of row (column) constraints.</p>
</td></tr>
<tr><td><code id="stprod_+3A_differ">differ</code></td>
<td>
<p>A scalar with the maximum accepted difference with the constraint (default = 1e-15).</p>
</td></tr>
<tr><td><code id="stprod_+3A_niter">niter</code></td>
<td>
<p>An integer with the maximum number of iterations (default = 1000).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standardized matrix will not be affected by problems arising from units
with different inclusion probabilities caused by undesired features of the
spatial distribution of the population, as edge effects and/or isolated
points.
</p>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>

<ul>
<li> <p><code>mat</code>, the standardized distance matrix of size NxN.
</p>
</li>
<li> <p><code>iterations</code>, number of iterations run by the algorithm.
</p>
</li>
<li> <p><code>conv</code>, convergence reached by the algorithm.
</p>
</li></ul>



<h3>References</h3>

<p>Benedetti R, Piersimoni F (2017). A spatially balanced design with
probability function proportional to the within sample distance.
<em>Biometrical Journal</em>, <strong>59</strong>(5), 1067-1084.
<a href="https://doi.org/10.1002/bimj.201600194">doi:10.1002/bimj.201600194</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

dis &lt;- as.matrix(dist(cbind(simul1$x, simul1$y))) # distance matrix
con &lt;- rep(0, nrow(dis)) # vector of constraints
stand_dist &lt;- stprod(mat = dis, con = con) # standardized matrix

</code></pre>

<hr>
<h2 id='stsum'>Standardize a symmetric matrix (distances) to fixed row (column) totals</h2><span id='topic+stsum'></span>

<h3>Description</h3>

<p>Standardizes a distance matrix to fixed rows and columns
totals. The function iteratively constrains the rows sums of the matrix
to know totals, and in order to keep the symmetry of the matrix, at each
iteration performs an average with its transpose. When the known totals are
all equal to a constant (e.g. 1), this method provides a simple and
accurate way to scale a distance matrix to a doubly stochastic matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsum(mat, con, differ = 1e-15, niter = 1000L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsum_+3A_mat">mat</code></td>
<td>
<p>A distance matrix size NxN.</p>
</td></tr>
<tr><td><code id="stsum_+3A_con">con</code></td>
<td>
<p>A vector of row (column) constraints.</p>
</td></tr>
<tr><td><code id="stsum_+3A_differ">differ</code></td>
<td>
<p>A scalar with the maximum accepted difference with the constraint (default = 1e-15).</p>
</td></tr>
<tr><td><code id="stsum_+3A_niter">niter</code></td>
<td>
<p>An integer with the maximum number of iterations (default = 1000).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standardized matrix will not be affected by problems arising from units
with different inclusion probabilities caused by undesired features of the
spatial distribution of the population, as edge effects and/or isolated
points.
</p>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>

<ul>
<li> <p><code>mat</code>, the standardized distance matrix of size NxN.
</p>
</li>
<li> <p><code>iterations</code>, number of iterations run by the algorithm.
</p>
</li>
<li> <p><code>conv</code>, convergence reached by the algorithm.
</p>
</li></ul>



<h3>References</h3>

<p>Benedetti R, Piersimoni F (2017). A spatially balanced design with
probability function proportional to the within sample distance.
<em>Biometrical Journal</em>, <strong>59</strong>(5), 1067-1084.
<a href="https://doi.org/10.1002/bimj.201600194">doi:10.1002/bimj.201600194</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis &lt;- as.matrix(dist(cbind(simul2$x, simul2$y))) # distance matrix
con &lt;- rep(1, nrow(dis)) # vector of constraints
stand_dist &lt;- stsum(mat = dis, con = con) # standardized matrix
</code></pre>

<hr>
<h2 id='swd'>Sum Within Distance (Spatially Balanced Sampling Design)</h2><span id='topic+swd'></span>

<h3>Description</h3>

<p>Selects spatially balanced samples through the use of the
Sum Within Distance design (SWD). To have a constant inclusion
probabilities <code class="reqn">\pi_{i}=n/N</code>, where <code class="reqn">n</code> is sample size and
<code class="reqn">N</code> is population size, the distance matrix has to be standardized with
function <code><a href="#topic+stsum">stsum</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swd(dis, n, beta = 10, nrepl = 1L, niter = 10L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swd_+3A_dis">dis</code></td>
<td>
<p>A distance matrix NxN that specifies how far all the pairs
of units in the population are.</p>
</td></tr>
<tr><td><code id="swd_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="swd_+3A_beta">beta</code></td>
<td>
<p>Parameter <code class="reqn">\beta</code> for the algorithm. The higher
<code class="reqn">\beta</code> is, the more the sample is going to be spread.</p>
</td></tr>
<tr><td><code id="swd_+3A_nrepl">nrepl</code></td>
<td>
<p>Number of samples to draw (default = 1).</p>
</td></tr>
<tr><td><code id="swd_+3A_niter">niter</code></td>
<td>
<p>Maximum number of iterations for the algorithm. More iterations are
better but require more time. Usually 10 is very efficient (default = 10).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>

<ul>
<li> <p><code>s</code>, a matrix <code>nrepl</code> x <code>n</code>, which contains the
<code>nrepl</code> selected samples, each of them stored in a row. In particular,
the i-th row contains all labels of units selected in the i-th sample.
</p>
</li>
<li> <p><code>iterations</code>, number of iterations run by the algorithm.
</p>
</li></ul>



<h3>References</h3>

<p>Benedetti R, Piersimoni F (2017). A spatially balanced design with
probability function proportional to the within sample distance.
<em>Biometrical Journal</em>, <strong>59</strong>(5), 1067-1084.
<a href="https://doi.org/10.1002/bimj.201600194">doi:10.1002/bimj.201600194</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# Draw 1 sample of dimension 15 without constant inclusion probabilities
dis &lt;- as.matrix(dist(cbind(income_emilia$x_coord, income_emilia$y_coord))) # distance matrix
s &lt;- swd(dis = dis, n = 15)$s  # drawn sample

# Example 2
# Draw 1 sample of dimension 15 with constant inclusion probabilities
# equal to n/N, with N = population size
dis &lt;- as.matrix(dist(cbind(income_emilia$x_coord,income_emilia$y_coord))) # distance matrix
con &lt;- rep(1, nrow(dis)) # vector of constraints
stand_dist &lt;- stsum(mat = dis, con = con) # standardized matrix
s &lt;- swd(dis = stand_dist$mat, n = 15)$s  # drawn sample

# Example 3
# Draw 2 samples of dimension 15 with constant inclusion probabilities
# equal to n/N, with N = population size and an increased level of spread, i.e. beta = 20
dis &lt;- as.matrix(dist(cbind(income_emilia$x_coord,income_emilia$y_coord))) # distance matrix
con &lt;- rep(1, nrow(dis)) # vector of constraints
stand_dist &lt;- stsum(mat = dis, con = con) # standardized matrix
s &lt;- swd(dis = stand_dist$mat, n = 15, beta = 20, nrepl = 2)$s  # drawn samples

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
