<!DOCTYPE html><html><head><title>Help for package gRc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gRc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add1-drop1'><p>Add or drop colour classes to RCOX models</p></a></li>
<li><a href='#clever_trace'><p>Calculate trace of various matrix products.</p></a></li>
<li><a href='#coerce_parm'><p>Coerce parameters in RCOX models.</p></a></li>
<li><a href='#comparecc'><p>Compare colour classes of an RCOX model</p></a></li>
<li><a href='#fit-doc'><p>Functions used in connection with fitting of RCOX models</p></a></li>
<li><a href='#fit-main'><p>Fit rcox model</p></a></li>
<li><a href='#generating-class'><p>Generating class for RCON / RCOR models</p></a></li>
<li><a href='#get-slot'><p>Get slots from RCOX model object.</p></a></li>
<li><a href='#grc-summary'><p>The package &lsquo;gRc&rsquo;: summary information</p></a></li>
<li><a href='#internals'><p>Internal functions for the gRc package</p></a></li>
<li><a href='#join-split'><p>Joining and splitting of colour classes in RCOX models</p></a></li>
<li><a href='#plot.rcox'><p>Plot rcox object</p></a></li>
<li><a href='#rcox'><p>Main function for specifying RCON/RCOR models.</p></a></li>
<li><a href='#score-information'><p>Get score and information for RCOX models.</p></a></li>
<li><a href='#step'><p>Stepwise model selection in RCOX models</p></a></li>
<li><a href='#toLisp'><p>For printing in lisp style</p></a></li>
<li><a href='#update-doc'><p>Update an RCOX model</p></a></li>
<li><a href='#xxx2yyy'><p>Conversions of the type xxx2yyy</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Inference in Graphical Gaussian Models with Edge and Vertex
Symmetries</td>
</tr>
<tr>
<td>Author:</td>
<td>Søren Højsgaard &lt;sorenh@math.aau.dk&gt;, Steffen L. Lauritzen &lt;lauritzen@math.ku.dk&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Søren Højsgaard &lt;sorenh@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation, model selection and other aspects of
    statistical inference in Graphical Gaussian models with edge and
    vertex symmetries (Graphical Gaussian models with colours).
    Documentation about 'gRc' is provided in the paper by Hojsgaard and
    Lauritzen (2007, &lt;<a href="https://doi.org/10.18637%2Fjss.v023.i06">doi:10.18637/jss.v023.i06</a>&gt;) and the paper by
    Hojsgaard and Lauritzen (2008, &lt;<a href="https://doi.org/10.1111%2Fj.1467-9868.2008.00666.x">doi:10.1111/j.1467-9868.2008.00666.x</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), methods, gRbase (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, igraph, stats4, Rcpp (&ge; 0.11.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>microbenchmark, knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.11.1), RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://people.math.aau.dk/~sorenh/software/gR/">https://people.math.aau.dk/~sorenh/software/gR/</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>Yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-27 10:04:49 UTC; sorenh</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-28 08:40:19 UTC</td>
</tr>
</table>
<hr>
<h2 id='add1-drop1'>Add or drop colour classes to RCOX models</h2><span id='topic+add1-drop1'></span><span id='topic+evalInECC'></span><span id='topic+evalOutECC'></span><span id='topic+add1.rcox'></span><span id='topic+drop1.rcox'></span>

<h3>Description</h3>

<p>Make a test for adding/dropping all colour classes in
scope for an RCOX model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rcox'
add1(object, scope, details = 0, trace = 0, ...)

## S3 method for class 'rcox'
drop1(object, scope, details = 0, trace = 0, stat = "wald", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add1-drop1_+3A_object">object</code></td>
<td>
<p>An RCOX model, an object of class 'rcox'</p>
</td></tr>
<tr><td><code id="add1-drop1_+3A_scope">scope</code></td>
<td>
<p>A set of edge colour classes to be considered for
addition or deletion, see 'details'.</p>
</td></tr>
<tr><td><code id="add1-drop1_+3A_details">details</code></td>
<td>
<p>Control the amount of output created.</p>
</td></tr>
<tr><td><code id="add1-drop1_+3A_trace">trace</code></td>
<td>
<p>For debugging purposes</p>
</td></tr>
<tr><td><code id="add1-drop1_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently unused.</p>
</td></tr>
<tr><td><code id="add1-drop1_+3A_stat">stat</code></td>
<td>
<p>Either &quot;wald&quot; for a Wald statistic or &quot;dev&quot; for a
deviance statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries
* tab: A dataframe with the test results
* cc: A list of colour classes
</p>


<h3>Note</h3>

<p>* Note that the keyword 'stat' is not available for add1
because this function expands the current model and hence the
Wald statistic is not available.
</p>
<p>* Based on fitting a new model for each new ecc, and may hence be slow.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comparecc">comparecc</a></code>, <code><a href="#topic+stepadd1">stepadd1</a></code>,
<code><a href="#topic+stepdrop1">stepdrop1</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(math)
gc.sat &lt;- ~me:ve:al:st:an
gc.1   &lt;- ~me+ve+al+st+an

m.sat &lt;- rcox(gm=gc.sat, data=math)
m.1   &lt;- rcox(gm=gc.1,   data=math)

t.sat &lt;- drop1(m.sat)
t.sat$tab
t.sat$cc

t.1   &lt;- add1(m.1)
t.1$tab
t.1$cc
</code></pre>

<hr>
<h2 id='clever_trace'>Calculate trace of various matrix products.</h2><span id='topic+clever_trace'></span><span id='topic+trA'></span><span id='topic+trAW'></span><span id='topic+trAWB'></span><span id='topic+trAWBW'></span><span id='topic+trAWBV'></span><span id='topic+trAWBlist'></span><span id='topic+trAWBWlist'></span>

<h3>Description</h3>

<p>Calculate trace of various matrix products.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trA(A)

trAW(rA, rW)

trAWB(rA, rW, rB)

trAWBW(rA, rW, rB)

trAWBV(rA, rW, rB, rV)

trAWBlist(Alist, W, Blist, mode = 0L)

trAWBWlist(Alist, W, Blist, mode = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clever_trace_+3A_a">A</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="clever_trace_+3A_ra">rA</code>, <code id="clever_trace_+3A_rb">rB</code></td>
<td>
<p>Square matrices represented as &quot;sparse&quot; matrices. The
dimension is inferred from dimension of V,W.</p>
</td></tr>
<tr><td><code id="clever_trace_+3A_rw">rW</code>, <code id="clever_trace_+3A_rv">rV</code>, <code id="clever_trace_+3A_w">W</code></td>
<td>
<p>Square matrices; must be of same dimension.</p>
</td></tr>
<tr><td><code id="clever_trace_+3A_alist">Alist</code>, <code id="clever_trace_+3A_blist">Blist</code></td>
<td>
<p>Lists of such &quot;sparse&quot; matrices.</p>
</td></tr>
<tr><td><code id="clever_trace_+3A_mode">mode</code></td>
<td>
<p>0 or 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Turn list into "sparse" matrix
to_sp &lt;- function(x){
  ans &lt;- do.call("rbind", x)
  storage.mode(ans)&lt;-"double"
  return(ans)
}

## Turn "sparse" matrix into dense matrix
##
to_de &lt;- function(A,d){
  if (nrow(A) &lt; 1) stop("need non-empty matrix\n")
  ans &lt;- matrix(0,nr=d,nc=d)
  for (i in 1:nrow(A)){
    e &lt;- A[i,]
    if (length(e) == 1){
      ans[e,e] &lt;- 1
    } else { 
      ans[e[1],e[2]] &lt;-   ans[e[2],e[1]] &lt;- 1 
    }
  }  
  return(ans)
}

d &lt;- 5
W &lt;- matrix(rnorm(d * d), nr=d, nc=d);
V &lt;- matrix(rnorm(d * d), nr=d, nc=d); 
W &lt;- W + t(W)
V &lt;- V + t(V)


A1.lst &lt;- list(c(1,2),c(1,3))
A2.lst &lt;- list(1,3,5)

A1.sp &lt;- to_sp(A1.lst)
A2.sp &lt;- to_sp(A2.lst)

A1.de &lt;- to_de(A1.sp, d)
A2.de &lt;- to_de(A2.sp, d)

trAW(A1.sp, W)
sum(diag(A1.de %*% W))

trAW(A2.sp, W)
sum(diag(A2.de %*% W))

trAWB(A1.sp, W, A2.sp)
trAWB(A2.sp, W, A1.sp)
sum(diag(A1.de %*% W %*% A2.de))

trAWBW(A1.sp, W, A2.sp)
trAWBW(A2.sp, W, A1.sp)
sum(diag(A1.de %*% W %*% A2.de %*% W))

trAWBV(A1.sp, W, A2.sp, V)
trAWBV(A2.sp, W, A1.sp, V)
sum(diag(A1.de %*% W %*% A2.de %*% V))

</code></pre>

<hr>
<h2 id='coerce_parm'>Coerce parameters in RCOX models.</h2><span id='topic+coerce_parm'></span><span id='topic+theta2K'></span><span id='topic+K2theta'></span><span id='topic+theta2K.rcon'></span><span id='topic+theta2K.rcor'></span><span id='topic+K2theta.rcon'></span><span id='topic+K2theta.rcor'></span>

<h3>Description</h3>

<p>Coerce parameters in RCOX models. These functions
should not be called directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta2K(object, theta, scale = "original")

K2theta(object, K, scale = "original")

## S3 method for class 'rcon'
theta2K(object, theta, scale = "original")

## S3 method for class 'rcor'
theta2K(object, theta, scale = "original")

## S3 method for class 'rcon'
K2theta(object, K, scale = "original")

## S3 method for class 'rcor'
K2theta(object, K, scale = "original")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce_parm_+3A_object">object</code></td>
<td>
<p>Model object.</p>
</td></tr>
<tr><td><code id="coerce_parm_+3A_theta">theta</code></td>
<td>
<p>Parameter.</p>
</td></tr>
<tr><td><code id="coerce_parm_+3A_scale">scale</code></td>
<td>
<p>On which scales are the parameters computed.</p>
</td></tr>
<tr><td><code id="coerce_parm_+3A_k">K</code></td>
<td>
<p>Concentration matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>

<hr>
<h2 id='comparecc'>Compare colour classes of an RCOX model</h2><span id='topic+comparecc'></span>

<h3>Description</h3>

<p>A general function for pairwise comparisons of colour
classes in an RCOX model, i.e. for testing whether the
corresponding parameters are significantly different
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparecc(
  object,
  cc1 = NULL,
  cc2 = NULL,
  type = "ecc",
  stat = "wald",
  details = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparecc_+3A_object">object</code></td>
<td>
<p>An RCOX model, an object of class 'rcox'</p>
</td></tr>
<tr><td><code id="comparecc_+3A_cc1">cc1</code>, <code id="comparecc_+3A_cc2">cc2</code></td>
<td>
<p>Lists of colour classes of type 'type', see
'details' for an explanation of the defaults.</p>
</td></tr>
<tr><td><code id="comparecc_+3A_type">type</code></td>
<td>
<p>Either &quot;ecc&quot; for edge colour classes or &quot;vcc&quot; for
vertex colour classes</p>
</td></tr>
<tr><td><code id="comparecc_+3A_stat">stat</code></td>
<td>
<p>Base the comparison on either &quot;wald&quot; for a Wald
statistic or &quot;dev&quot; for a deviance statistic</p>
</td></tr>
<tr><td><code id="comparecc_+3A_details">details</code></td>
<td>
<p>Control the amount of output created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All colour classes specified in <code>cc1</code> are compared
with all those given in <code>cc2</code> (duplicate entries are not
compared). If <code>cc2=NULL</code> (the default) then all colour
classes specified in <code>cc1</code> are compared with all colour
classes in the model except those specified in <code>cc1</code>. If
<code>cc1=NULL</code> (the default) and <code>cc2=NULL</code> then all
pairwise comparisons are made.
</p>


<h3>Value</h3>

<p>A list with entries: </p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>A data frame with the test
results</p>
</td></tr> <tr><td><code>cc1</code>, <code>cc2</code></td>
<td>
<p>Lists of colour classes</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, sorenh@math.aau.dk
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add1.rcox">add1.rcox</a></code>, <code><a href="#topic+drop1.rcox">drop1.rcox</a></code>,
<code><a href="#topic+stepadd1">stepadd1</a></code>, <code><a href="#topic+stepdrop1">stepdrop1</a></code>,
<code><a href="#topic+join1">join1</a></code>, <code><a href="#topic+split1">split1</a></code>,
<code><a href="#topic+stepjoin1">stepjoin1</a></code>, <code><a href="#topic+stepsplit1">stepsplit1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data (math)

gm  = ~al:an:st
vcc = list(~me+st, ~ve+an, ~al)
ecc = list(~me:ve+me:al, ~ve:al+al:st)

m1 &lt;- rcox(gm=gm, vcc=vcc, ecc=ecc, data=math)
m1

comparecc(m1, type="vcc")
comparecc(m1, type="ecc")

</code></pre>

<hr>
<h2 id='fit-doc'>Functions used in connection with fitting of RCOX models</h2><span id='topic+fit-doc'></span><span id='topic+ipm.rcon'></span><span id='topic+ipm.rcor'></span><span id='topic+matching.rcon'></span><span id='topic+matching.rcor'></span><span id='topic+rconIPM_c'></span><span id='topic+rconIPM_r'></span><span id='topic+rcorIPM_c'></span><span id='topic+rcorIPM_r'></span><span id='topic+rconScoreMatch'></span><span id='topic+rcorScoreMatch'></span><span id='topic+rconScoreTheta'></span><span id='topic+rcorScoreTheta'></span><span id='topic+fitIPSedge'></span><span id='topic+fitIPSset'></span><span id='topic+fitNR2'></span><span id='topic+fitNR'></span><span id='topic+modNewt'></span><span id='topic+refitA'></span><span id='topic+refitA_old'></span>

<h3>Description</h3>

<p>This is an overview over core functions used in
connection with fitting of RCOX models. The functions described
here will typically not be directly called by the user.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit-doc_+3A_object">object</code></td>
<td>
<p>An RCOX model object (an object of class rcox.Internal)</p>
</td></tr>
<tr><td><code id="fit-doc_+3A_k0">K0</code></td>
<td>
<p>An initial value for K</p>
</td></tr>
<tr><td><code id="fit-doc_+3A_control">control</code></td>
<td>
<p>A list controlling the fitting algorithms.</p>
</td></tr>
<tr><td><code id="fit-doc_+3A_maxit">maxit</code></td>
<td>
<p>Maximal number of scoring iterations</p>
</td></tr>
<tr><td><code id="fit-doc_+3A_trace">trace</code></td>
<td>
<p>Controls various diagnostics print outs. A debugging feature
not intended for the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with fitted values (K, logL etc).
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="gRbase.html#topic+fit">fit</a></code>, <code><a href="#topic+rcox">rcox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gm  = ~al:an:st
vcc = list(~me+st, ~ve+an, ~al)
ecc = list(~me:ve+me:al, ~ve:al+al:st)
data(math)

m1 &lt;- rcox(gm=gm, vcc=vcc, ecc=ecc, data=math, fit=FALSE)
f1 &lt;- matching(m1)

## Use f1$K as starting value
scoring(m1, K0=f1$K)
ipm(m1, K0=f1$K)

</code></pre>

<hr>
<h2 id='fit-main'>Fit rcox model</h2><span id='topic+fit-main'></span><span id='topic+fit.rcox'></span><span id='topic+matching'></span><span id='topic+ipm'></span><span id='topic+scoring'></span>

<h3>Description</h3>

<p>This is a general function for fitting RCOX models
(i.e.\ RCON and RCOR models) using different estimation
algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rcox'
fit(
  object,
  Kstart = object$Kstart,
  method = object$method,
  control = object$control,
  details = object$details,
  trace = object$trace,
  returnModel = TRUE,
  ...
)

matching(object, control = object$control, trace = object$trace)

ipm(object, K0, control = object$control, trace = object$trace)

scoring(
  object,
  K0,
  control = object$control,
  maxit = control$maxouter,
  trace = object$trace
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit-main_+3A_object">object</code></td>
<td>
<p>An RCOX model object (an object of class 'rcox')</p>
</td></tr>
<tr><td><code id="fit-main_+3A_kstart">Kstart</code></td>
<td>
<p>An initial value for the concentration matrix.</p>
</td></tr>
<tr><td><code id="fit-main_+3A_method">method</code></td>
<td>
<p>The specific estimation method. Can be either
&quot;scoring&quot;, (a modified Fisher scoring algorithm), &quot;ipm&quot;
(iterative partial maximization), &quot;matching&quot; (score matching) or
&quot;user&quot; (currently not used).</p>
</td></tr>
<tr><td><code id="fit-main_+3A_control">control</code></td>
<td>
<p>A list controlling the fitting algorithms. See the
'details' section.</p>
</td></tr>
<tr><td><code id="fit-main_+3A_details">details</code></td>
<td>
<p>The amount of details printed on the screen. 0 means
no details at all.</p>
</td></tr>
<tr><td><code id="fit-main_+3A_trace">trace</code></td>
<td>
<p>Controls various diagnostics print outs. A debugging
feature not intended for the user.</p>
</td></tr>
<tr><td><code id="fit-main_+3A_returnmodel">returnModel</code></td>
<td>
<p>If TRUE the model object m is returned with
fitting info added to it. If FALSE only the fitting info is
returned.</p>
</td></tr>
<tr><td><code id="fit-main_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used.</p>
</td></tr>
<tr><td><code id="fit-main_+3A_k0">K0</code></td>
<td>
<p>Initial value for concentration matrix.</p>
</td></tr>
<tr><td><code id="fit-main_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitted parameters etc. can be extracted using
'fitInfo(m)'.  The control argument is a list with named
entries. Most important are the entries 'maxouter' and 'maxinner'
(which both defaults to 25) for controlling the estimation
algorithms. For other components please  refer to the code.
</p>


<h3>Value</h3>

<p>An RCOX model object.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcox">rcox</a></code>, <code><a href="#topic+update.rcox">update.rcox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(math)
gm  = ~al:an:st
vcc = list(~me + st, ~ve + an, ~al)
ecc = list(~me:ve + me:al, ~ve:al + al:st)

m1 &lt;- rcox(gm=gm, vcc=vcc, ecc=ecc, data=math, fit=FALSE)

fit(m1, method="matching")
fit(m1, method="scoring")
fit(m1, method="ipm")

</code></pre>

<hr>
<h2 id='generating-class'>Generating class for RCON / RCOR models</h2><span id='topic+generating-class'></span>

<h3>Description</h3>

<p>Implementation of generating classes for RCOX
models. These functions are not intended to be called by the
user.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>

<hr>
<h2 id='get-slot'>Get slots from RCOX model object.</h2><span id='topic+get-slot'></span><span id='topic+getSlot'></span><span id='topic+dimension'></span><span id='topic+logL'></span><span id='topic+dataRep'></span><span id='topic+intRep'></span><span id='topic+fitInfo'></span><span id='topic+getcc'></span><span id='topic+getecc'></span><span id='topic+getvcc'></span><span id='topic+getedges'></span>

<h3>Description</h3>

<p>Get slots from RCOX model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSlot(object, slot)

dimension(object)

logL(object)

getSlot(object, slot)

dataRep(object, slot = NULL)

intRep(object, slot = NULL)

fitInfo(object, slot = NULL)

getcc(object, type)

getecc(object)

getvcc(object)

getedges(object, complement = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get-slot_+3A_object">object</code></td>
<td>
<p>RCOX model object.</p>
</td></tr>
<tr><td><code id="get-slot_+3A_slot">slot</code></td>
<td>
<p>slot.</p>
</td></tr>
<tr><td><code id="get-slot_+3A_type">type</code></td>
<td>
<p>Type of colour class.</p>
</td></tr>
<tr><td><code id="get-slot_+3A_complement">complement</code></td>
<td>
<p>If FALSE, the edges of the model is returned. If
TRUE, the edges not in the model is returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(math)
gm  = ~al:an:st
vcc = list(~me+st, ~ve+an, ~al)
ecc = list(~me:ve+me:al, ~ve:al+al:st)

m1 &lt;- rcox(gm=gm, vcc=vcc, ecc=ecc, data=math)
getecc(m1)

getSlot(m1,"type")
fitInfo(m1)
fitInfo(m1,"K")
</code></pre>

<hr>
<h2 id='grc-summary'>The package &lsquo;gRc&rsquo;: summary information</h2><span id='topic+grc-summary'></span>

<h3>Description</h3>

<p>This package is for statistical inference in RCOX models. That is,
graphical Gaussian models where specific entries of the inverse
covariance matrix or partial correlation matrix have been
restricted to being equal. Entries which are restricted to being
identical are displayed with identical colours in the independence
graph. Hence the name of the package gRc: The &quot;c&quot; stands for
colours.
</p>


<h3>Details</h3>

<p>#' @author  Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Details</h3>

<p>The function for specifying RCOX models is rcox, and we
refer to the help page for that function for examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcox">rcox</a></code>
</p>

<hr>
<h2 id='internals'>Internal functions for the gRc package</h2><span id='topic+coef.rcox'></span><span id='topic+vcov.rcox'></span><span id='topic+summary.rcox'></span><span id='topic+print.summary.rcox'></span><span id='topic+tocc'></span><span id='topic+cc2str'></span><span id='topic+cholSolve'></span><span id='topic+print.coloutClass'></span><span id='topic+findKinModel'></span><span id='topic+findKinModel.rcox'></span><span id='topic+print.colourClass'></span><span id='topic+print.rcox'></span><span id='topic+print.statTable'></span><span id='topic+regularizeK'></span><span id='topic+calculateVCOV'></span>

<h3>Description</h3>

<p>These functions should not be called directly by the user.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, sorenh@agrsci.dk</p>

<hr>
<h2 id='join-split'>Joining and splitting of colour classes in RCOX models</h2><span id='topic+join-split'></span><span id='topic+join1'></span><span id='topic+split1'></span>

<h3>Description</h3>

<p>Test for joining of two colour classes (of a specific type) by testing if
their corresponding parameters are not significantly different.  Split a
colour class and test how much this changes the fit of the model.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="join-split_+3A_object">object</code></td>
<td>
<p>An RCOX model, an object of class RCOX</p>
</td></tr>
<tr><td><code id="join-split_+3A_scope">scope</code></td>
<td>
<p>A specification of colour classes which should be
considered for joining/splitting. If NULL, then all colour
classes are considered.</p>
</td></tr>
<tr><td><code id="join-split_+3A_type">type</code></td>
<td>
<p>Either &quot;ecc&quot; for edge colour classes or &quot;vcc&quot; for
vertex colour classes.</p>
</td></tr>
<tr><td><code id="join-split_+3A_stat">stat</code></td>
<td>
<p>Either &quot;wald&quot; for a Wald statistic or &quot;dev&quot; for
deviance statistic.</p>
</td></tr>
<tr><td><code id="join-split_+3A_details">details</code></td>
<td>
<p>Control the amount of output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries: </p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>A data frame with the test
results</p>
</td></tr> <tr><td><code>cc</code></td>
<td>
<p>A list of colour classes</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the keyword 'stat' is not available for split1
because this function expands the current and hence the Wald
statistic is not available.  Note also that join1 is simply a
wrapper for comparecc applied to edge colour classes.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcox">rcox</a></code>, <code><a href="stats.html#topic+update">update</a></code>,
<code><a href="#topic+comparecc">comparecc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(math)
g1     &lt;- ~me:ve:al+al:st:an
m1     &lt;- rcox(gm=g1, data=math)
join1(m1)

gm  = ~al:an:st
vcc = list(~me+st, ~ve+an)
ecc = list(~me:ve+me:al, ~ve:al+al:st)
m2 &lt;- rcox(gm=gm, vcc=vcc, ecc=ecc, data=math, type="rcon")
split1(m2)

</code></pre>

<hr>
<h2 id='plot.rcox'>Plot rcox object</h2><span id='topic+plot.rcox'></span>

<h3>Description</h3>

<p>Plot rcox object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rcox'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rcox_+3A_x">x</code></td>
<td>
<p>An rcox object</p>
</td></tr>
<tr><td><code id="plot.rcox_+3A_y">y</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="plot.rcox_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>gm  = ~al:an:st
vcc = list(~me+st, ~ve+an, ~al)
ecc = list(~me:ve+me:al, ~ve:al+al:st)
m1 &lt;- rcox(gm=gm, vcc=vcc, ecc=ecc, data=math, method='matching')
plot(m1)

</code></pre>

<hr>
<h2 id='rcox'>Main function for specifying RCON/RCOR models.</h2><span id='topic+rcox'></span>

<h3>Description</h3>

<p>This is the main function for specifying and fitting
RCON/RCOR models in the package along with certain utility
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcox(
  gm = NULL,
  vcc = NULL,
  ecc = NULL,
  type = c("rcon", "rcor"),
  method = "ipm",
  fit = TRUE,
  data = NULL,
  S = NULL,
  n = NULL,
  Kstart = NULL,
  control = list(),
  details = 1,
  trace = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcox_+3A_gm">gm</code></td>
<td>
<p>Generating class for a grapical Gaussian model, see
'Examples' for an illustration</p>
</td></tr>
<tr><td><code id="rcox_+3A_vcc">vcc</code></td>
<td>
<p>List of vertex colour classes for the model</p>
</td></tr>
<tr><td><code id="rcox_+3A_ecc">ecc</code></td>
<td>
<p>List of edge colour classes for the model</p>
</td></tr>
<tr><td><code id="rcox_+3A_type">type</code></td>
<td>
<p>Type of model. Default is RCON</p>
</td></tr>
<tr><td><code id="rcox_+3A_method">method</code></td>
<td>
<p>Estimation method; see 'Details' below.</p>
</td></tr>
<tr><td><code id="rcox_+3A_fit">fit</code></td>
<td>
<p>Should the model be fitted</p>
</td></tr>
<tr><td><code id="rcox_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="rcox_+3A_s">S</code></td>
<td>
<p>An empirical covariance matrix (as alternative to giving data
as a dataframe)</p>
</td></tr>
<tr><td><code id="rcox_+3A_n">n</code></td>
<td>
<p>The number of observations (which is needed if data is
specified as an empirical covariance matrix)</p>
</td></tr>
<tr><td><code id="rcox_+3A_kstart">Kstart</code></td>
<td>
<p>An initial value for K. Can be omitted.</p>
</td></tr>
<tr><td><code id="rcox_+3A_control">control</code></td>
<td>
<p>Controlling the fitting algorithms</p>
</td></tr>
<tr><td><code id="rcox_+3A_details">details</code></td>
<td>
<p>Controls the amount of output</p>
</td></tr>
<tr><td><code id="rcox_+3A_trace">trace</code></td>
<td>
<p>Debugging info</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation methods:
</p>
<p>*   'ipm' (default) is iterative partial maximization
which when finished calculates the information matrix so that
approximate variances of the parameters can be obtained using vcov().
</p>
<p>*   'ipms' is iterative partial maximization without
calculating the information matrix. This is the fastest method.
</p>
<p>*   'scoring' is stabilised Fisher scoring.
</p>
<p>*   'matching' is score matching followed by one step with Fisher
scoring.  
</p>
<p>*   'hybrid1' is for
internal use and should not be called directly
</p>


<h3>Value</h3>

<p>A model object of type 'RCOX'.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(math)
gm  = ~al:an:st
vcc = list(~me+st, ~ve+an, ~al)
ecc = list(~me:ve+me:al, ~ve:al+al:st)

m1 &lt;- rcox(gm=gm, vcc=vcc, ecc=ecc, data=math, method='matching')
m2 &lt;- rcox(gm=gm, vcc=vcc, ecc=ecc, data=math, method='scoring')
m3 &lt;- rcox(gm=gm, vcc=vcc, ecc=ecc, data=math, method='ipm')

m1
m2
m3

summary(m1)
summary(m2)
summary(m3)

coef(m1)
coef(m2)
coef(m3)

vcov(m1)
vcov(m2)
vcov(m3)

</code></pre>

<hr>
<h2 id='score-information'>Get score and information for RCOX models.</h2><span id='topic+score-information'></span><span id='topic+getScore'></span><span id='topic+getScore.rcon'></span><span id='topic+getScore.rcor'></span>

<h3>Description</h3>

<p>Get score and information for RCOX models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getScore(m, K, scale = "original")

## S3 method for class 'rcon'
getScore(m, K, scale = "original")

## S3 method for class 'rcor'
getScore(m, K, scale = "original")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score-information_+3A_m">m</code></td>
<td>
<p>Model obect.</p>
</td></tr>
<tr><td><code id="score-information_+3A_k">K</code></td>
<td>
<p>Concentration matrix</p>
</td></tr>
<tr><td><code id="score-information_+3A_scale">scale</code></td>
<td>
<p>On which scales are the parameters computed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>

<hr>
<h2 id='step'>Stepwise model selection in RCOX models</h2><span id='topic+step'></span><span id='topic+stepadd1'></span><span id='topic+stepdrop1'></span><span id='topic+stepjoin1'></span><span id='topic+stepsplit1'></span>

<h3>Description</h3>

<p>These allow for stepwise model selection in RCOX models by. Model
expansion (i.e. forward selection) is obtained by adding edge
colour classes and by splitting edge/vertex colour classes.  Model
reduction (i.e. backward selection) is obtained by dropping edge
colour classes and by joining edge/vertex colour classes.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_+3A_object">object</code></td>
<td>
<p>An RCOX model, an object of class RCOX</p>
</td></tr>
<tr><td><code id="step_+3A_scope">scope</code></td>
<td>
<p>A set (list) of items (edge colour classes or vertex
colour classes) to be considered.  If missing, then all items are
considered.</p>
</td></tr>
<tr><td><code id="step_+3A_criterion">criterion</code></td>
<td>
<p>Either &quot;aic&quot; (the default), &quot;bic&quot; or &quot;test&quot; (for
significance test)</p>
</td></tr>
<tr><td><code id="step_+3A_type">type</code></td>
<td>
<p>Either &quot;ecc&quot; for edge colour classes or &quot;vcc&quot; for
vertex colour classes.</p>
</td></tr>
<tr><td><code id="step_+3A_k">k</code></td>
<td>
<p>The multiple of the number of degrees of freedom used for
the penalty when criterion is &quot;aic&quot;. Ignored when criterion is
&quot;bic&quot; or &quot;test&quot;.  Only k = 2 gives the genuine AIC.</p>
</td></tr>
<tr><td><code id="step_+3A_steps">steps</code></td>
<td>
<p>The maximum number of steps to be considered. The
default is 1000 (essentially as many as required). It is
typically used to stop the process early</p>
</td></tr>
<tr><td><code id="step_+3A_stat">stat</code></td>
<td>
<p>Either &quot;wald&quot; for a Wald statistic or &quot;dev&quot; for a
deviance statistic.</p>
</td></tr>
<tr><td><code id="step_+3A_alpha">alpha</code></td>
<td>
<p>Critical value if 'criterion' is &quot;test&quot;. If criterion
is &quot;aic&quot; or &quot;bic&quot;, the critical value is 0.</p>
</td></tr>
<tr><td><code id="step_+3A_headlong">headlong</code></td>
<td>
<p>If TRUE then at each step the first encountered
edge that may be removed/added according to the current criterion
is done so.</p>
</td></tr>
<tr><td><code id="step_+3A_random">random</code></td>
<td>
<p>If TRUE, then the edges are examined in random order</p>
</td></tr>
<tr><td><code id="step_+3A_details">details</code></td>
<td>
<p>Control the amount of output created.</p>
</td></tr>
<tr><td><code id="step_+3A_trace">trace</code></td>
<td>
<p>For debugging purposes</p>
</td></tr>
<tr><td><code id="step_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either NULL or a new RCOX model.
</p>


<h3>Note</h3>

<p>Note that the keyword 'stat' is not available for stepadd1
and stepsplit1 because these functions expand the current model
and hence the Wald statistic is not available.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+split1">split1</a></code> <code><a href="#topic+join1">join1</a></code> <code><a href="#topic+add1.rcox">add1.rcox</a></code>
<code><a href="#topic+drop1.rcox">drop1.rcox</a></code> <code><a href="#topic+comparecc">comparecc</a></code>
</p>

<hr>
<h2 id='toLisp'>For printing in lisp style</h2><span id='topic+toLisp'></span>

<h3>Description</h3>

<p>For printing in lisp style
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toLisp(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toLisp_+3A_v">v</code></td>
<td>
<p>Object to be printed</p>
</td></tr>
</table>

<hr>
<h2 id='update-doc'>Update an RCOX model</h2><span id='topic+update-doc'></span><span id='topic+update.rcox'></span>

<h3>Description</h3>

<p>update will update and (by default) re-fit an RCOX
model.  It does this by extracting the call stored in the
object, updating the call and (by default) evaluating that
call. Sometimes it is useful to call update with only one
argument, for example if the data frame has been corrected
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="update-doc_+3A_object">object</code></td>
<td>
<p>An RCOX model, an object of class RCOX</p>
</td></tr>
<tr><td><code id="update-doc_+3A_vcc">vcc</code></td>
<td>
<p>Specification of the vertex colour classes in the model</p>
</td></tr>
<tr><td><code id="update-doc_+3A_ecc">ecc</code></td>
<td>
<p>Specification of the edge colour classes in the model</p>
</td></tr>
<tr><td><code id="update-doc_+3A_splitvcc">splitvcc</code></td>
<td>
<p>Existing vertex colour class to be split</p>
</td></tr>
<tr><td><code id="update-doc_+3A_splitecc">splitecc</code></td>
<td>
<p>Existing edge colour class to be split</p>
</td></tr>
<tr><td><code id="update-doc_+3A_joinvcc">joinvcc</code></td>
<td>
<p>Existing vertex colour classes to be joined</p>
</td></tr>
<tr><td><code id="update-doc_+3A_joinecc">joinecc</code></td>
<td>
<p>Existing vertex colour classes to be joined</p>
</td></tr>
<tr><td><code id="update-doc_+3A_addecc">addecc</code></td>
<td>
<p>New edge colour classes to be added</p>
</td></tr>
<tr><td><code id="update-doc_+3A_dropecc">dropecc</code></td>
<td>
<p>Existing vertex color classes to be dropped
(deleted)</p>
</td></tr>
<tr><td><code id="update-doc_+3A_kstart">Kstart</code></td>
<td>
<p>A start value for K</p>
</td></tr>
<tr><td><code id="update-doc_+3A_fit">fit</code></td>
<td>
<p>Should the updated model be fitted.</p>
</td></tr>
<tr><td><code id="update-doc_+3A_control">control</code></td>
<td>
<p>A list of control parameters.</p>
</td></tr>
<tr><td><code id="update-doc_+3A_trace">trace</code></td>
<td>
<p>For debugging purposes</p>
</td></tr>
<tr><td><code id="update-doc_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new model object of class 'rcox'.
</p>


<h3>Warning</h3>

<p>Only one of the arguments pertaining to edge
colour classes (i.e. ecc, splitecc, joinecc, dropecc, addecc)
should be applied at the time. Likewise for the arguments
pertaining to the vertex colour classes.
</p>
<p>The result will otherwise be highly unpredictable and is likely to cause an
error.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcox">rcox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(math)
gm  = ~al:an:st
vcc = list(~me+st, ~ve+an, ~al)
ecc = list(~me:ve+me:al, ~ve:al+al:st)

m1 &lt;- rcox(gm=gm, vcc=vcc, ecc=ecc, data=math, method='matching', trace=0)

update(m1, joinvcc=list(~me+st, ~ve+an))
update(m1, joinecc=list(~al:an, ~an:st))

update(m1, splitvcc=~ve+an)
update(m1, splitecc=~me:ve+me:al)


update(m1, dropecc=list(~me:st+st:an,~al:an,~st:al))
update(m1, addecc=list(~an:me+st:ve))

</code></pre>

<hr>
<h2 id='xxx2yyy'>Conversions of the type xxx2yyy</h2><span id='topic+xxx2yyy'></span><span id='topic+formula2names'></span><span id='topic+formula2names.default'></span><span id='topic+formula2names.list'></span><span id='topic+formula2names.formula'></span><span id='topic+formula2names.NULL'></span><span id='topic+names2indices'></span><span id='topic+names2formula'></span><span id='topic+names2formula.list'></span><span id='topic+names2formula.default'></span><span id='topic+indices2vectors'></span><span id='topic+formula2string'></span><span id='topic+formula2string.list'></span><span id='topic+formula2string.default'></span><span id='topic+getIndex'></span><span id='topic+getIndex.default'></span><span id='topic+getIndex.list'></span><span id='topic+getIndex.character'></span><span id='topic+ecc2edges'></span><span id='topic+cc2formula'></span>

<h3>Description</h3>

<p>Conversions of the type xxx2yyy.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
