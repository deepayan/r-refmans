<!DOCTYPE html><html><head><title>Help for package pso</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pso}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pso-package'>
<p>A Particle Swarm Optimizer</p></a></li>
<li><a href='#getSuccessRate-methods'><p> Methods for Function getSuccessRate</p></a></li>
<li><a href='#lines-methods'><p>Methods for Function lines</p></a></li>
<li><a href='#plot-methods'><p>Plot methods for test.result objects</p></a></li>
<li><a href='#points-methods'><p>Methods for Function points</p></a></li>
<li><a href='#psoptim'><p>Particle Swarm Optimizer</p></a></li>
<li><a href='#psoptim-methods'><p>Methods for function psoptim (Particle Swarm Optimization)</p></a></li>
<li><a href='#show-methods'><p> Methods for Function show</p></a></li>
<li><a href='#test.problem'>
<p>Convenience constructor for the test.problem class.</p></a></li>
<li><a href='#test.problem-class'><p>Class &quot;test.problem&quot;</p></a></li>
<li><a href='#test.result-class'><p>Class &quot;test.result&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Particle Swarm Optimization</td>
</tr>
<tr>
<td>Author:</td>
<td>Claus Bendtsen &lt;papyrus.bendtsen@gmail.com&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Claus Bendtsen &lt;papyrus.bendtsen@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>numDeriv, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an implementation of particle swarm optimisation consistent with the standard PSO 2007/2011 by Maurice Clerc. Additionally a number of ancillary routines are provided for easy testing and graphics.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-12 12:56:40 UTC; kwzm106</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-12 16:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='pso-package'>
A Particle Swarm Optimizer
</h2><span id='topic+pso-package'></span><span id='topic+pso'></span>

<h3>Description</h3>

<p>The package provides an implementation of particle swarm optimization
which is consistent with the standard
PSO 2007 and 2011 by Maurice Clerc et al. Additionally a number of ancillary
routines are provided for easy testing and graphics.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> pso</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-04-12</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> methods</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The core function in the package is <code><a href="#topic+psoptim">psoptim</a></code> which can be
used as a drop in replacement for <code><a href="stats.html#topic+optim">optim</a></code>. When used without
additional control parameters the implementation is intended to be
equivalent to SPSO 2007 (by M. Clerc et al.).
</p>
<p>Control parameters can be specified for SPSO 2011 (in its basic
implementation), to clamp the maximal velocity, provide restarting
when the swarm converges to a region as well as using BFGS as a local
search strategy. See <code><a href="#topic+psoptim">psoptim</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Claus Bendtsen &lt;papyrus.bendtsen@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Some examples of using the functions in the package

## Using basic "optim" interface to minimize a function
set.seed(1)
psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
        lower=-5,upper=5,control=list(abstol=1e-8))

## Parabola
p &lt;- test.problem("parabola",10) # one local=global minimum
set.seed(1)
o1 &lt;- psoptim(p,control=list(trace=1,REPORT=50))
show(o1)

set.seed(1)
o2 &lt;- psoptim(p,control=list(trace=1,REPORT=50,w=c(.7,.1)))
show(o2)

set.seed(1)
o3 &lt;- psoptim(p,control=list(trace=1,REPORT=1,hybrid=TRUE))
show(o3) ## hybrid much faster

## Griewank
set.seed(2)
p &lt;- test.problem("griewank",10) # lots of local minima
o1 &lt;- psoptim(p,control=list(trace=1,REPORT=50))
show(o1)

## The above sometimes get stuck in a local minima.
## Adding a restart to increase robustness.
set.seed(2)
o2 &lt;- psoptim(p,control=list(trace=1,REPORT=50,reltol=1e-4))
show(o2)

## An then adding the hybrid
set.seed(2)
o3 &lt;- psoptim(p,control=list(trace=1,REPORT=50,reltol=1e-4,
              hybrid=TRUE,hybrid.control=list(maxit=10)))
show(o3)

## Rosenbrock
set.seed(1)
p &lt;- test.problem("rosenbrock",1)
o1 &lt;- psoptim(p,control=list(trace=1,REPORT=50))
show(o1)

## Change to fully informed
set.seed(1)
o2 &lt;- psoptim(p,control=list(trace=1,REPORT=50,p=1))
show(o2)

## Rastrigin
p &lt;- test.problem("rastrigin",10)
set.seed(1)
o1 &lt;- psoptim(p,control=list(trace=1,REPORT=50))
show(o1)

set.seed(1)
o2 &lt;- psoptim(p,control=list(trace=1,REPORT=50,hybrid=TRUE,
              hybrid.control=list(maxit=10)))
show(o2) # better
plot(o1,xlim=c(0,p@maxf),ylim=c(0,100))
lines(o2,col=2) # and much faster convergence

## Ackley
set.seed(1)
p &lt;- test.problem("ackley",10)
o1 &lt;- psoptim(p,control=list(trace=1,REPORT=50))
show(o1)

## End(Not run)</code></pre>

<hr>
<h2 id='getSuccessRate-methods'> Methods for Function getSuccessRate </h2><span id='topic+getSuccessRate'></span><span id='topic+getSuccessRate-methods'></span><span id='topic+getSuccessRate+2Ctest.result-method'></span>

<h3>Description</h3>

<p>Provides the success rate as the result of conducting a test. Only
implemented method is for objects of class <code>"test.result"</code>
</p>


<h3>Methods</h3>

<p>Calculates the success rate from the number of successful tests
conducted as a function of the number of function evaluations used.
</p>

<dl>
<dt><code>signature(object = "test.result")</code></dt><dd>
<p>This method is used internally by the graphical functions.
Returns a list with components:
</p>

<dl>
<dt>feval:</dt><dd><p>The number of function evaluations.</p>
</dd>
<dt>rate:</dt><dd><p>The corresponding success rate (between 0 and 1).</p>
</dd></dl>

</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+test.result-class">test.result</a></code>.
</p>

<hr>
<h2 id='lines-methods'>Methods for Function lines</h2><span id='topic+lines-methods'></span><span id='topic+lines+2Ctest.result-method'></span>

<h3>Description</h3>

<p>Graphical methods for adding line segments to existing plots.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "test.result")</code></dt><dd>
<p>Add lines of the success rate versus the number of function
evaluations for the test resulted provided as <code>x</code> to the current
plot. Any additional 
arguments to the method will be passed on to
<code><a href="graphics.html#topic+lines">lines</a></code>. Typically this method is used to add new test
results to an existing plot.
</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+lines">lines</a></code>, <code><a href="#topic+test.result-class">test.result</a></code>.
</p>

<hr>
<h2 id='plot-methods'>Plot methods for test.result objects</h2><span id='topic+plot-methods'></span><span id='topic+plot+2Ctest.result+2Cmissing-method'></span>

<h3>Description</h3>

<p>Graphical methods for plotting test results.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "test.result", y = "missing")</code></dt><dd>
<p>Produces a plot of the success rate versus the number of function
evaluations for the test result provided as <code>x</code>. Any additional
arguments to the method will be passed on to <code><a href="base.html#topic+plot">plot</a></code>.
</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="base.html#topic+plot">plot</a></code>, <code><a href="#topic+test.result-class">test.result</a></code>.
</p>

<hr>
<h2 id='points-methods'>Methods for Function points</h2><span id='topic+points-methods'></span><span id='topic+points+2Ctest.result-method'></span>

<h3>Description</h3>

<p>Graphical methods for adding points to existing plots.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "test.result")</code></dt><dd>
<p>Add points with the success rate versus the number of function
evaluations for the test resulted provided as <code>x</code> to the current
plot. Any additional 
arguments to the method will be passed on to
<code><a href="graphics.html#topic+points">points</a></code>. Typically this method is used to add new test
results to an existing plot.
</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+points">points</a></code>, <code><a href="#topic+test.result-class">test.result</a></code>.
</p>

<hr>
<h2 id='psoptim'>Particle Swarm Optimizer</h2><span id='topic+psoptim'></span>

<h3>Description</h3>

<p>General implementation of particle swarm optimization usable as a direct
replacement for <code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psoptim(par, fn, gr = NULL, ..., lower = -1, upper = 1, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psoptim_+3A_par">par</code></td>
<td>
<p>Vector with length defining the dimensionality of the
optimization problem. Providing actual values of <code>par</code> are not
necessary (<code>NA</code> is just fine). Included primarily for
compatibility with
<code><a href="stats.html#topic+optim">optim</a></code> but if values are provided within the <code>lower</code>
and <code>upper</code> bounds then the first particle will be
initialized to the position provided by <code>par</code>.
</p>
</td></tr>
<tr><td><code id="psoptim_+3A_fn">fn</code></td>
<td>

<p>A function to be minimized (or maximized), with first
argument the vector of parameters over which minimization is
to take place.  It should return a scalar result.
</p>
</td></tr>
<tr><td><code id="psoptim_+3A_gr">gr</code></td>
<td>

<p>A function to return the gradient if local search is BFGS.
If it is <code>NULL</code>, a
finite-difference approximation will be used.
</p>
</td></tr>
<tr><td><code id="psoptim_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to <code>fn</code> and <code>gr</code>.
</p>
</td></tr>
<tr><td><code id="psoptim_+3A_lower">lower</code></td>
<td>

<p>Lower bounds on the variables.
</p>
</td></tr>
<tr><td><code id="psoptim_+3A_upper">upper</code></td>
<td>

<p>Upper bounds on the variables.
</p>
</td></tr>
<tr><td><code id="psoptim_+3A_control">control</code></td>
<td>

<p>A list of control parameters. See &ldquo;Details&rdquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default this function performs minimization using a particle swarm
algorithm, but it will maximize if <code>control$fnscale</code> is negative.
</p>
<p>The default control arguments implies that the algorithm follows the
Standard PSO 2007 implementation by Maurice Clerc, but the code also
provides support for PSO 2011, clamping the maximal velocity, restarting when
all particles converge to a single area and using BFGS as
the local search direction.
</p>
<p>The <code>control</code> argument is a list that can supply any of the
following components:
</p>

<dl>
<dt>trace:</dt><dd><p>Non-negative integer. If positive, tracing information on
the progress of the optimization is produced. Defaults to <code>0</code>.
</p>
</dd>
<dt>fnscale:</dt><dd><p>An overall scaling to be applied to the value of <code>fn</code>
and <code>gr</code> (if used) during optimization. If negative, turns the problem
into a maximization problem. Optimization is performed on
<code>fn(par)/fnscale</code>. Defaults to <code>1</code>.
</p>
</dd>
<dt>maxit:</dt><dd>
<p>The maximum number of iterations. Defaults to <code>1000</code>.
</p>
</dd>
<dt>maxf:</dt><dd>
<p>The maximum number of function evaluations (not considering any
performed during numerical gradient computation). Defaults to <code>Inf</code>.
</p>
</dd>
<dt>abstol:</dt><dd>
<p>The absolute convergence tolerance. The method converges once the
best fitness obtained is less than or equal to
<code>abstol</code>. Defaults to <code>-Inf</code>.
</p>
</dd>
<dt>reltol:</dt><dd>
<p>The tolerance for restarting. Once the maximal distance between the
best particle and all other particles is less than <code>reltol*d</code>
the algorithm restarts. Defaults to <code>0</code> which disables the
check for restarting.
</p>
</dd>
<dt>REPORT:</dt><dd>
<p>The frequency for reports if <code>control$trace</code> is
positive. Defaults to <code>10</code>.
</p>
</dd>
<dt>trace.stats:</dt><dd><p>Logical; if <code>TRUE</code> statistics at every
reporting step are collected and returned. Defaults to <code>FALSE</code>.
</p>
</dd>
<dt>s:</dt><dd>
<p>The swarm size. Defaults to <code>floor(10+2*sqrt(length(par)))</code> unless <code>type</code> is &ldquo;SPSO2011&rdquo; in which case the default is <code>40</code>.
</p>
</dd>
<dt>k:</dt><dd>
<p>The exponent for calculating number of informants. Defaults to <code>3</code>.
</p>
</dd>
<dt>p:</dt><dd>
<p>The average percentage of informants for each particle. A value of
<code>1</code> implies that all particles are fully informed. Defaults to
<code>1-(1-1/s)^k</code>.
</p>
</dd>
<dt>w:</dt><dd>
<p>The exploitation constant. A vector of length <code>1</code> or
<code>2</code>. If the length is two, the actual constant used is gradially
changed from <code>w[1]</code> to <code>w[2]</code> as the number of iterations or
function evaluations approach the limit provided.
Defaults to <code>1/(2*log(2))</code>.
</p>
</dd>
<dt>c.p:</dt><dd>
<p>The local exploration constant. Defaults to <code>.5+log(2)</code>.
</p>
</dd>
<dt>c.g:</dt><dd>
<p>The global exploration constant. Defaults to <code>.5+log(2)</code>.
</p>
</dd>
<dt>d:</dt><dd>
<p>The diameter of the search space. Defaults to the euclidean distance
between <code>upper</code> and <code>lower</code>.
</p>
</dd>
<dt>v.max:</dt><dd>
<p>The maximal (euclidean) length of the velocity vector. Defaults to <code>NA</code>
which disables clamping of the velocity. However, if specified the
actual clamping of the length is <code>v.max*d</code>.
</p>
</dd>
<dt>rand.order:</dt><dd>
<p>Logical; if <code>TRUE</code> the particles are processed in random
order. If <code>vectorize</code> is <code>TRUE</code> then the value of
<code>rand.order</code> does not matter. Defaults to <code>TRUE</code>.
</p>
</dd>
<dt>max.restart:</dt><dd>
<p>The maximum number of restarts. Defaults to <code>Inf</code>.
</p>
</dd>
<dt>maxit.stagnate:</dt><dd>
<p>The maximum number of iterations without improvement.
Defaults to <code>Inf</code>.
</p>
</dd>
<dt>vectorize:</dt><dd>
<p>Logical; if <code>TRUE</code> the particles are processed in a vectorized
manner. This reduces the overhead associated with iterating over
each particle and may be more time efficient for cheap function
evaluations. Defaults to <code>FALSE</code>.
</p>
</dd>
<dt>hybrid:</dt><dd>
<p>If true, each normal PSO position update is followed by an
L-BFGS-B search with the provided position as initial guess. This
makes the implementation a hybrid approach. Defaults to
<code>FALSE</code> which disables BFGS for the local search. Note that
no attempt is done to control the maximal number of function
evaluations within the local search step (this can be done
separately through <code>hybrid.control</code>) but the number of
function evaluations used by the local search method counts
towards the limit provided by <code>maxf</code> AFTER the local search
returns. To support a broader class of hybrid approaches a
character vector can also be supplied with &ldquo;off&rdquo; being
equivalent to false, &ldquo;on&rdquo; equivalent to true, and
&ldquo;improved&rdquo; implying that the local search will only be
performed when the swarm finds an improvement.
</p>
</dd>
<dt>hybrid.control:</dt><dd>
<p>List with any additional control parameters to pass on to
<code><a href="stats.html#topic+optim">optim</a></code> when using L-BFGS-B for the local search.
Defaults to <code>NULL</code>.
</p>
</dd>
<dt>type:</dt><dd><p>Character vector which describes which reference implementation of SPSO is followed. Can take the value of &ldquo;SPSO2007&rdquo; or &ldquo;SPSO2011&rdquo;. Defaults to &ldquo;SPSO2007&rdquo;.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list, compatible with the output from <code><a href="stats.html#topic+optim">optim</a></code>, with components:
</p>
<table>
<tr><td><code>par</code></td>
<td>

<p>The best set of parameters found.
</p>
</td></tr>
<tr><td><code>value</code></td>
<td>

<p>The value of <code>fn</code> corresponding to <code>par</code>.
</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>

<p>A three-element vector containing the number of function
evaluations, the number of iterations, and the number of restarts.
</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>

<p>An integer code. <code>0</code> indicates that the algorithm terminated by
reaching the absolute tolerance; otherwise:
</p>

<dl>
<dt><code>1</code>:</dt><dd><p>Maximal number of function evaluations reached.</p>
</dd>
<dt><code>2</code>:</dt><dd><p>Maximal number of iterations reached.</p>
</dd>
<dt><code>3</code>:</dt><dd><p>Maximal number of restarts reached.</p>
</dd>
<dt><code>4</code>:</dt><dd><p>Maximal number of iterations without improvement reached.</p>
</dd></dl>

</td></tr>
<tr><td><code>message</code></td>
<td>
<p>A descriptive message of the reason for termination.
</p>
</td></tr>
</table>
<p>If <code>trace</code> is positive and <code>trace.stats</code> is <code>TRUE</code> additionally the component:
</p>
<table>
<tr><td><code>stats</code></td>
<td>
<p>A list of statistics collected at every reporting step with the following components:
</p>
<dl>
<dt><code>it</code></dt><dd><p>A vector with the iteration numbers</p>
</dd>
<dt><code>error</code></dt><dd><p>A vector with the corresponding best fitness values obtained</p>
</dd>
<dt><code>f</code></dt><dd><p>A list with the corresponding current swarm fitness values as a vector</p>
</dd>
<dt><code>x</code></dt><dd><p>A list with the corresponding current swarm positions as a matrix</p>
</dd>
</dl>
</td></tr>
</table>


<h3>References</h3>

<p>Default parameters follow:
</p>
<p>Clerc, M. (2011)
<a href="https://hal.archives-ouvertes.fr/hal-00764996/document">https://hal.archives-ouvertes.fr/hal-00764996/document</a>.
Notice that the SPSO 2011 implementation does not include any
of the bells and whistles from the implementation by M. Clerc et
al. and effectively only differes from the SPSO 2007 implementation
in the default swarm size, how velocities are initiated and the
update of velocities/positions which in the SPSO 2011 implementation
are invariant to rotation.
</p>
<p>The gradual change of <code>w</code> and clamping the maximal velocity is
described in:
</p>
<p>Parsopoulos, K.E. and Vrahatis M.N. (2002)
<em>Recent approaches to global optimization problems
through Particle Swarm Optimization</em>.
Natural Computing 1: 235-306.
</p>
<p>The restart (provided through <code>reltol</code>) is similar to:
</p>
<p>Evers G.I. and Ghalia M.B.
<em>Regrouping Particle Swarm Optimization:
A New Global Optimization Algorithm with
Improved Performance Consistency Across
Benchmarks</em>. <a href="https://bee22.com/resources/Evers%202009.pdf">https://bee22.com/resources/Evers%202009.pdf</a>
</p>
<p>The hybrid approach is similar to:
</p>
<p>Qin J., Yin Y. and Ban X. (2010)
<em>A Hybrid of Particle Swarm Optimization and Local Search for Multimodal Functions</em>.
Lecture Notes in Computer Science, Volume 6145/2010, 589-596, DOI: 10.1007/978-3-642-13495-1_72
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+test.problem-class">test.problem</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
## Rastrigin function
psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
        lower=-5,upper=5,control=list(abstol=1e-8))

set.seed(1)
## Rastrigin function - local refinement with L-BFGS-B on improvements
psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
        lower=-5,upper=5,control=list(abstol=1e-8,hybrid="improved"))

## Griewank function
psoptim(rep(NA,2),function(x) sum(x*x)/4000-prod(cos(x/sqrt(1:2)))+1,
        lower=-100,upper=100,control=list(abstol=1e-2))

set.seed(1)
## Rastrigin function with reporting
o &lt;- psoptim(rep(NA,2),function(x) 20+sum(x^2-10*cos(2*pi*x)),
             lower=-5,upper=5,control=list(abstol=1e-8,trace=1,REPORT=1,
             trace.stats=TRUE))
## Not run: 
plot(o$stats$it,o$stats$error,log="y",xlab="It",ylab="Error")
points(o$stats$it,sapply(o$stats$f,min),col="blue",pch=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='psoptim-methods'>Methods for function psoptim (Particle Swarm Optimization)</h2><span id='topic+psoptim-methods'></span><span id='topic+psoptim+2CANY+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+psoptim+2Ctest.problem+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>General implementation of particle swarm optimization usable as a direct
replacement for <code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Methods</h3>

<p><code>signature(par = "ANY", fn = "ANY", gr = "ANY", lower = "ANY", upper = "ANY")</code>:
</p>
<p>This is the standard replacement for <code><a href="stats.html#topic+optim">optim</a></code> without S4
object usage.
</p>
<p><code>signature(par = "test.problem", fn = "missing", gr = "missing",</code><br />
<code>lower = "missing", upper = "missing")</code>:
</p>
<p>This is for running PSO on a specific test problem. Typically this is
invoked on repetitive runs of a test problem and used to assess the
choice of parameters for the underlying PSO algorithm. The function
is essentially a wrapper function for <code><a href="#topic+psoptim">psoptim</a></code> but
returns an instance of <code><a href="#topic+test.result-class">test.result</a></code> containing summary
results. 
</p>

<hr>
<h2 id='show-methods'> Methods for Function show </h2><span id='topic+show-methods'></span><span id='topic+show+2Ctest.problem-method'></span><span id='topic+show+2Ctest.result-method'></span>

<h3>Description</h3>

<p>Displays descriptive information of the object provided as argument.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "test.problem")</code></dt><dd>
<p>Provide information on test problem. This includes: problem name,
dimension, objective value, maximal number of function evaluations, and
the number of test repetitions to perform.
</p>
</dd>
<dt><code>signature(object = "test.result")</code></dt><dd>
<p>Provide summary statistics for the test. This includes information on
the mean, s.d., min and max obtained for the value over all
conducted repetitions
as well as the overall success rate (percentage of test runs for
which the target objective was reached) and a measure of efficiency (the
area under the success-rate curve normalized to the maximal area
possible). Additionally displays the timing information for the test conducted.
</p>
</dd>
</dl>

<hr>
<h2 id='test.problem'>
Convenience constructor for the test.problem class.
</h2><span id='topic+test.problem'></span>

<h3>Description</h3>

<p>The method enables creating of objects of class <code>"test.problem"</code>
for a few standard test problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.problem(name, n.test = 100, dim, maxf, objective, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.problem_+3A_name">name</code></td>
<td>
<p> The name of the test problem. Currently supports one of
<code>"parabola"</code>, <code>"griewank"</code>,
<code>"rosenbrock"</code>, <code>"rastrigin"</code>, or <code>"ackley"</code>.
</p>
</td></tr>
<tr><td><code id="test.problem_+3A_n.test">n.test</code></td>
<td>

<p>The number of tests to perform.
</p>
</td></tr>
<tr><td><code id="test.problem_+3A_dim">dim</code></td>
<td>

<p>Override the default dimension of the problem.
</p>
</td></tr>
<tr><td><code id="test.problem_+3A_maxf">maxf</code></td>
<td>

<p>Override the default maximal number of function evaluations for the problem.
</p>
</td></tr>
<tr><td><code id="test.problem_+3A_objective">objective</code></td>
<td>

<p>Override the default objective for the function.
</p>
</td></tr>
<tr><td><code id="test.problem_+3A_lower">lower</code></td>
<td>

<p>Override the default lower bounds for the problem.
</p>
</td></tr>
<tr><td><code id="test.problem_+3A_upper">upper</code></td>
<td>

<p>Override the default upper bounds for the problem.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"test.problem"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.problem-class">test.problem</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test.problem("rast")

test.problem("rast",dim=4,n.test=10)

test.problem("grie")
</code></pre>

<hr>
<h2 id='test.problem-class'>Class &quot;test.problem&quot;</h2><span id='topic+test.problem-class'></span>

<h3>Description</h3>

<p>The class contains a test problem including domain
definition and reference solution. Generally objects from the class
facilitate easy testing of PSO with various parameters.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("test.problem",
  ...)</code>, but the convenience constructer <code><a href="#topic+test.problem">test.problem</a></code> is
the usual approach.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>The name of the test problem. Object of class <code>"character"</code>.</p>
</dd>
<dt><code>f</code>:</dt><dd><p>Function to be minimized. Object of class <code>"function"</code>.</p>
</dd>
<dt><code>grad</code>:</dt><dd><p>Gradient of <code>f</code>. Only used with BFGS for
the local search. Object of class <code>"function"</code>.</p>
</dd>
<dt><code>n</code>:</dt><dd><p>Problem dimensionality. Object of class <code>"integer"</code>.</p>
</dd>
<dt><code>maxf</code>:</dt><dd><p>Maximal number of function evaluations to use. Object of class <code>"integer"</code></p>
</dd>
<dt><code>objective</code>:</dt><dd><p>The absolute tolerance when running PSO. Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>ntest</code>:</dt><dd><p>The number of tests to perform. Object of class <code>"integer"</code>.</p>
</dd>
<dt><code>lower</code>:</dt><dd><p>The lower bounds. Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>upper</code>:</dt><dd><p>The upper bounds. Object of class <code>"numeric"</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>psoptim</dt><dd><p><code>signature(par = "test.problem", fn = "missing",
	gr = "missing",</code><br />
<code>lower = "missing", upper = "missing")</code>: for
running PSO on the test problem. See <code><a href="#topic+psoptim-methods">psoptim-methods</a></code>
for details. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "test.problem")</code>: descriptive
information of the test problem. See <code><a href="#topic+show-methods">show-methods</a></code>
for details.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+test.problem">test.problem</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test.problem("rast")
test.problem("rast",10) # modified for 10 repetitions.

test.problem("para")
</code></pre>

<hr>
<h2 id='test.result-class'>Class &quot;test.result&quot;</h2><span id='topic+test.result-class'></span>

<h3>Description</h3>

<p>A container class with results from executing a (repetition of) test
problem(s).
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("test.result",
  ...)</code>, but the object is normally provided as the result of executing
<code>psoptim</code> on an object of class <code>"test.problem"</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>problem</code>:</dt><dd><p>Object of class <code>"test.problem"</code>.</p>
</dd>
<dt><code>result</code>:</dt><dd><p>A list with each of the results from
repetitive invocation of <code><a href="#topic+psoptim">psoptim</a></code> on <code>problem</code>. </p>
</dd>
<dt><code>time</code>:</dt><dd><p>The overall time taken for executing the test.
Object of class <code>"numeric"</code>. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getSuccessRate</dt><dd><p><code>signature(object = "test.result")</code>:
internal method used to calculate the success rate for a series of
test results. See <code><a href="#topic+getSuccessRate-methods">getSuccessRate-methods</a></code>
for details.</p>
</dd>
<dt>lines</dt><dd><p><code>signature(x = "test.result")</code>: add lines with the
test result to an existing plot. See <code><a href="#topic+lines-methods">lines-methods</a></code>
for details.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "test.result", y = "missing")</code>: plot
the test result. See <code><a href="#topic+plot-methods">plot-methods</a></code>
for details.</p>
</dd>
<dt>points</dt><dd><p><code>signature(x = "test.result")</code>: add points with
the test result to an existing plot. See <code><a href="#topic+points-methods">points-methods</a></code>
for details.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "test.result")</code>: summary
statistics of the test. See <code><a href="#topic+show-methods">show-methods</a></code>
for details.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("test.result")

set.seed(1)
t &lt;- test.problem("rastrigin",10)
o &lt;- psoptim(t)
show(o)

## Not run: 
plot(o)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
