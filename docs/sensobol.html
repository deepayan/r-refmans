<!DOCTYPE html><html lang="en"><head><title>Help for package sensobol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sensobol}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sensobol-package'><p>sensobol: Computation of Variance-Based Sensitivity Indices</p></a></li>
<li><a href='#bratley1988_Fun'><p>Bratley and Fox (1988) function</p></a></li>
<li><a href='#bratley1992_Fun'><p>Bratley, Fox and Niederreiter (1992) function.</p></a></li>
<li><a href='#discrepancy_ersatz'><p>Computation of the S-ersatz discrepancy.</p></a></li>
<li><a href='#ishigami_Fun'><p>Ishigami function</p></a></li>
<li><a href='#load_packages'><p>Load (and install) R packages.</p></a></li>
<li><a href='#metafunction'><p>Random metafunction based on Becker (2020)'s metafunction.</p></a></li>
<li><a href='#oakley_Fun'><p>Oakley &amp; O'Hagan (2004) function</p></a></li>
<li><a href='#plot_multiscatter'><p>Pairwise combinations of model inputs with the colour</p>
proportional the model output value.</a></li>
<li><a href='#plot_scatter'><p>Scatter plots of the model output against the model inputs.</p></a></li>
<li><a href='#plot_uncertainty'><p>Visualization of the model output uncertainty</p></a></li>
<li><a href='#plot.sensobol'><p>Visualization of first, total, second, third and fourth-order Sobol' indices.</p></a></li>
<li><a href='#print.sensobol'><p>Display the results obtained with the <code>sobol_indices</code> function.</p></a></li>
<li><a href='#print.vars'><p>Display the results obtained with the <code>vars_to</code> function.</p></a></li>
<li><a href='#sobol_convergence'><p>Check convergence of Sobol' indices.</p></a></li>
<li><a href='#sobol_dummy'><p>Computation of Sobol' indices for a dummy parameter</p></a></li>
<li><a href='#sobol_Fun'><p>Sobol' G function</p></a></li>
<li><a href='#sobol_indices'><p>Computation of Sobol' indices</p></a></li>
<li><a href='#sobol_matrices'><p>Creation of the sample matrices</p></a></li>
<li><a href='#sobol_ode'><p>Wrapper around <code>deSolve</code> <code>ode</code>.</p></a></li>
<li><a href='#vars_matrices'><p>STAR-VARS sampling strategy</p></a></li>
<li><a href='#vars_to'><p>Computation of VARS Total order index (VARS-TO)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Computation of Variance-Based Sensitivity Indices</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arnald Puy &lt;arnald.puy@pm.me&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>It allows to rapidly compute, bootstrap and plot up to fourth-order Sobol'-based sensitivity indices using several state-of-the-art first and total-order estimators. Sobol' indices can be computed either for models that yield a scalar as a model output or for systems of differential equations. The package also provides a suit of benchmark tests functions and several options to obtain publication-ready figures of the model output uncertainty and sensitivity-related analysis. An overview of the package can be found in Puy et al. (2022) &lt;<a href="https://doi.org/10.18637%2Fjss.v102.i05">doi:10.18637/jss.v102.i05</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot (&ge; 1.3.20), data.table (&ge; 1.12.0), ggplot2 (&ge; 3.1.0),
lhs (&ge; 1.0.2), magrittr (&ge; 1.5), matrixStats (&ge; 0.54.0),
randtoolbox (&ge; 1.17.1), deSolve (&ge; 1.27.1), Rdpack (&ge;
2.1.2), Rfast (&ge; 2.0.1), rlang (&ge; 0.3.1), scales (&ge; 1.0.0),
stats, stringr (&ge; 1.4.0), utils, Rcpp</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0), covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/arnaldpuy/sensobol">https://github.com/arnaldpuy/sensobol</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/arnaldpuy/sensobol/issues">https://github.com/arnaldpuy/sensobol/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rfast, Rcpp, RcppArmadillo,</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-21 13:26:50 UTC; arnaldpuy</td>
</tr>
<tr>
<td>Author:</td>
<td>Arnald Puy <a href="https://orcid.org/0000-0001-9469-2156"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Bertrand Ioos [ctb] (Author of included 'sensitivity' fragments),
  Gilles Pujol [ctb] (Author of included 'sensitivity' fragments),
  RStudio [cph] (Copyright holder of included 'sensitivity' fragments)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-21 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sensobol-package'>sensobol: Computation of Variance-Based Sensitivity Indices</h2><span id='topic+sensobol-package'></span><span id='topic+sensobol'></span>

<h3>Description</h3>

<p>It allows to rapidly compute, bootstrap and plot up to third-order Sobol'-based sensitivity
indices using several state-of-the-art first and total-order estimators. Sobol' indices
can be computed either for models that yield a scalar as a model output or for systems of
differential equations. The package also provides a suit of benchmark tests functions
and several options to obtain publication-ready figures of the model output uncertainty
and sensitivity-related analysis.
</p>


<h3>Details</h3>

<p>A comprehensive empirical study of several total-order estimators included in sensobol can be found in Puy et al. (2021).
</p>


<h3>Author(s)</h3>

<p>Arnald Puy (<a href="mailto:arnald.puy@pm.me">arnald.puy@pm.me</a>)
</p>
<p><strong>Maintainer</strong>: Arnald Puy (<a href="mailto:arnald.puy@pm.me">arnald.puy@pm.me</a>)
</p>


<h3>References</h3>

<p>Puy A, Becker W, Lo Piano S, Saltelli A (2021).
&ldquo;A Comprehensive Comparison of Total-Order Estimators for Global Sensitivity Analysis.&rdquo;
<em>International Journal for Uncertainty Quantification</em>.
<a href="https://doi.org/10.1615/Int.J.UncertaintyQuantification.2021038133">doi:10.1615/Int.J.UncertaintyQuantification.2021038133</a>.
</p>

<hr>
<h2 id='bratley1988_Fun'>Bratley and Fox (1988) function</h2><span id='topic+bratley1988_Fun'></span>

<h3>Description</h3>

<p>It implements the Bratley and Fox (1988) function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bratley1988_Fun(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bratley1988_Fun_+3A_x">X</code></td>
<td>
<p>A data frame or numeric matrix where each column is a model input and each
row a sample point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires <code class="reqn">k</code> model inputs and reads as follows:
</p>
<p style="text-align: center;"><code class="reqn">y=\prod_{i=1}^{k} |4x_i - 2 |\,,</code>
</p>

<p>where <code class="reqn">x_i\sim\mathcal{U}(0,1)</code>.
</p>


<h3>Value</h3>

<p>A numeric vector with the model output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings (test with k = 10)
N &lt;- 100; params &lt;- paste("X", 1:10, sep = "")

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params)

# Compute Bratley and Fox (1988) function
Y &lt;- bratley1988_Fun(mat)
</code></pre>

<hr>
<h2 id='bratley1992_Fun'>Bratley, Fox and Niederreiter (1992) function.</h2><span id='topic+bratley1992_Fun'></span>

<h3>Description</h3>

<p>It implements the Bratley et al. (1992) function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bratley1992_Fun(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bratley1992_Fun_+3A_x">X</code></td>
<td>
<p>A data frame or numeric matrix where each column is a model input and each
row a sample point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires <code class="reqn">k</code> model inputs and reads as:
</p>
<p style="text-align: center;"><code class="reqn">y=\sum_{i=1}^{k}(-1)^i\prod_{j=1}^{i}x_j\,,</code>
</p>

<p>where <code class="reqn">x_i\sim\mathcal{U}(0,1)</code>.
</p>


<h3>Value</h3>

<p>A numeric vector with the model output.
</p>


<h3>References</h3>

<p>Bratley P, Fox BL, Niederreiter H (1992).
&ldquo;Implementation and tests of low-discrepancy sequences.&rdquo;
<em>ACM Transactions on Modeling and Computer Simulation (TOMACS)</em>, <b>2</b>(3), 195&ndash;213.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings (test with k = 10)
N &lt;- 100; params &lt;- paste("X", 1:10, sep = "")

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params)

# Compute Bratley et al. (1992) function
Y &lt;- bratley1992_Fun(mat)
</code></pre>

<hr>
<h2 id='discrepancy_ersatz'>Computation of the S-ersatz discrepancy.</h2><span id='topic+discrepancy_ersatz'></span>

<h3>Description</h3>

<p>It allows to use the S-ersatz discrepancy measure by Puy et al. (2024)
as a sensitivity measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrepancy_ersatz(mat, Y, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discrepancy_ersatz_+3A_mat">mat</code></td>
<td>
<p>A numeric matrix created with <code><a href="#topic+sobol_matrices">sobol_matrices</a></code> and <code>matrices = "A"</code>,
where each column represents an uncertain model input and each row a model simulation.</p>
</td></tr>
<tr><td><code id="discrepancy_ersatz_+3A_y">Y</code></td>
<td>
<p>A numeric vector with the model output obtained from the matrix created with
<code><a href="#topic+sobol_matrices">sobol_matrices</a></code>. The numeric vector should not contain any NA or NaN values.</p>
</td></tr>
<tr><td><code id="discrepancy_ersatz_+3A_params">params</code></td>
<td>
<p>A character vector with the name of the model inputs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to define <code>mat</code> using a power of 2 as a sample size.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> object.
</p>


<h3>References</h3>

<p>Puy A, Roy PT, Saltelli A (2024).
&ldquo;Discrepancy measures for global sensitivity analysis.&rdquo;
<em>Technometrics</em>.
<a href="https://doi.org/10.1080/00401706.2024.2304341">doi:10.1080/00401706.2024.2304341</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
N &lt;- 2^9; params &lt;- paste("X", 1:8, sep = "")

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params, matrices = "A")

# Compute the Sobol' G function
Y &lt;- sobol_Fun(mat)

# Compute the S-ersatz discrepancy values
ind &lt;- discrepancy_ersatz(mat = mat, Y = Y, params = params)
</code></pre>

<hr>
<h2 id='ishigami_Fun'>Ishigami function</h2><span id='topic+ishigami_Fun'></span>

<h3>Description</h3>

<p>It implements the Ishigami and Homma (1990) function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ishigami_Fun(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ishigami_Fun_+3A_x">X</code></td>
<td>
<p>A data frame or numeric matrix where each column is a model input and each
row a sample point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires 3 model inputs and reads as
</p>
<p style="text-align: center;"><code class="reqn">y=\sin(x_1) +a \sin(x_2) ^ 2 + b x_3 ^4 \sin(x_1)\,,</code>
</p>

<p>where <code class="reqn">a=2</code>, <code class="reqn">b=1</code> and <code class="reqn">(x_1,x_2,x_3)\sim\mathcal{U}(-\pi, +\pi)</code>. The
transformation of the distribution of the model inputs from <code class="reqn">U(0, 1)</code> to
<code class="reqn">U(-\pi, +\pi)</code>) is conducted internally.
</p>


<h3>Value</h3>

<p>A numeric vector with the model output.
</p>


<h3>References</h3>

<p>Ishigami T, Homma T (1990).
&ldquo;An importance quantification technique in uncertainty analysis for computer models.&rdquo;
<em>Proceedings. First International Symposium on Uncertainty Modeling and Analysis</em>, <b>12</b>, 398&ndash;403.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
N &lt;- 100; params &lt;- paste("X", 1:3, sep = "")

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params)

# Compute Ishigami function
Y &lt;- ishigami_Fun(mat)
</code></pre>

<hr>
<h2 id='load_packages'>Load (and install) R packages.</h2><span id='topic+load_packages'></span>

<h3>Description</h3>

<p>The function loads R packages. If the packages are not already
in the local system, the function also downloads, installs and loads them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_packages(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_packages_+3A_x">x</code></td>
<td>
<p>A character vector with the name of the packages to load.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Load packages:
## Not run: load_packages(c("tidyverse", "data.table"))
</code></pre>

<hr>
<h2 id='metafunction'>Random metafunction based on Becker (2020)'s metafunction.</h2><span id='topic+metafunction'></span>

<h3>Description</h3>

<p>Random metafunction based on Becker (2020)'s metafunction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metafunction(data, k_2 = 0.5, k_3 = 0.2, epsilon = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metafunction_+3A_data">data</code></td>
<td>
<p>A numeric matrix where each column is a model input and each row a sampling point.</p>
</td></tr>
<tr><td><code id="metafunction_+3A_k_2">k_2</code></td>
<td>
<p>Numeric value indicating the fraction of active pairwise interactions (between 0 and 1).
Default is <code>k_2 = 0.5</code>.</p>
</td></tr>
<tr><td><code id="metafunction_+3A_k_3">k_3</code></td>
<td>
<p>Numeric value indicating the fraction of active three-wise interactions
(between 0 and 1). Default is <code>k_2 = 0.2</code>.</p>
</td></tr>
<tr><td><code id="metafunction_+3A_epsilon">epsilon</code></td>
<td>
<p>Integer value. It fixes the seed for the random number generator.
The default is <code>epsilon = NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The metafunction randomly combines the following functions in a metafunction of dimension <code class="reqn">k</code>:
</p>

<ul>
<li> <p><code class="reqn">f(x) = x ^ 3</code> (cubic).
</p>
</li>
<li> <p><code class="reqn">f(x) = 1~\mbox{if}(x &gt; 0.5), 0~\mbox{otherwise}</code> (discontinuous).
</p>
</li>
<li> <p><code class="reqn">f(x) = \frac{e ^ x}{e - 1}</code> (exponential).
</p>
</li>
<li> <p><code class="reqn">f(x) = \frac{10 - 1}{1.1} ^ {-1} (x + 0.1) ^ {-1}</code> (inverse).
</p>
</li>
<li> <p><code class="reqn">f(x) = x</code> (linear)
</p>
</li>
<li> <p><code class="reqn">f(x) = 0</code> (no effect).
</p>
</li>
<li> <p><code class="reqn">f(x) = 4(x - 0.5) ^  2</code> (non-monotonic).
</p>
</li>
<li> <p><code class="reqn">f(x) = \frac{\sin (2 \pi x)}{2}</code> (periodic).
</p>
</li>
<li> <p><code class="reqn">f(x) = x ^ 2</code> (quadratic).
</p>
</li>
<li> <p><code class="reqn">f(x) = \cos(x)</code> (trigonometric).
</p>
</li></ul>

<p>It is constructed as follows:
</p>
<p style="text-align: center;"><code class="reqn">y=\sum_{i=1}^{k}\alpha_i f^{u_i}(x_i) \\
 + \sum_{i=1}^{k_2}\beta_i f^{u_{V_{i,1}}}(x_{V_{i,1}}) f^{u_{V_{i,2}}} (x_{V_{i,2}}) \\
+ \sum_{i=1}^{k_3}\gamma_i f^{u_{W_{i,1}}}(x_{W_{i,1}}) f^{u_{W_{i,2}}}(x_{W_{i,2}}) f^{u_{W_{i,3}}} (x_{W_{i,3}})</code>
</p>

<p>where <code class="reqn">k</code> is the model dimensionality, <code class="reqn">u</code> is a <code class="reqn">k</code>-length vector formed by randomly
sampling with replacement the ten functions mentioned above, <code class="reqn">V</code> and <code class="reqn">W</code> are two matrices specifying the
number of pairwise and three-wise interactions given the model dimensionality,
and <code class="reqn">\mathbf{\alpha}, \mathbf{\beta}, \mathbf{\gamma}</code> are three
vectors of length <code class="reqn">k</code> generated by sampling from a mixture of two normal distributions
<code class="reqn">\Psi=0.3\mathcal{N}(0, 5) + 0.7\mathcal{N}(0, 0.5)</code>.
See Puy et al. (2020) and Becker (2020) for a full
mathematical description of the metafunction approach.
</p>


<h3>Value</h3>

<p>A numeric vector with the function output.
</p>


<h3>References</h3>

<p>Becker W (2020).
&ldquo;Metafunctions for benchmarking in sensitivity analysis.&rdquo;
<em>Reliability Engineering and System Safety</em>, <b>204</b>, 107189.
<a href="https://doi.org/10.1016/j.ress.2020.107189">doi:10.1016/j.ress.2020.107189</a>.<br /><br /> Puy A, Becker W, Piano SL, Saltelli A (2020).
&ldquo;The battle of total-order sensitivity estimators.&rdquo;
<em>arXiv</em>.
2009.01147, <a href="https://arxiv.org/abs/2009.01147">https://arxiv.org/abs/2009.01147</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings (number of model inputs = 86)
N &lt;- 100; params &lt;- paste("X", 1:86, sep = "")

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params)

# Compute metafunction
Y &lt;- metafunction(mat)
</code></pre>

<hr>
<h2 id='oakley_Fun'>Oakley &amp; O'Hagan (2004) function</h2><span id='topic+oakley_Fun'></span>

<h3>Description</h3>

<p>It implements the Oakley and O'Hagan (2004) function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oakley_Fun(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oakley_Fun_+3A_x">X</code></td>
<td>
<p>A data frame or numeric matrix where each column is a model input and each
row a sample point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires 15 model inputs and reads as
</p>
<p style="text-align: center;"><code class="reqn">y=\mathbf{a}_1^T \bm{x} + \mathbf{a}_2 ^ T \sin(\mathbf{x}) + \mathbf{a}_3 ^ T \cos(\mathbf{x}) + \mathbf{x}^T \mathbf{M}\mathbf{x}\,,</code>
</p>

<p>where <code class="reqn">\mathbf{x}=x_1,x_2,...,x_k</code>, <code class="reqn">k=15</code>, and values
for <code class="reqn">\mathbf{a}^T_i,i=1,2,3</code> and <code class="reqn">\mathbf{M}</code> are defined by Oakley and O'Hagan (2004). The
transformation of the distribution of the model inputs from <code class="reqn">U(0, 1)</code> to
<code class="reqn">N(0, 1)</code>) is conducted internally.
</p>


<h3>Value</h3>

<p>A numeric vector with the model output.
</p>


<h3>References</h3>

<p>Oakley JE, O'Hagan A (2004).
&ldquo;Probabilistic sensitivity analysis of complex models: a Bayesian approach.&rdquo;
<em>Journal of the Royal Statistical Society B</em>, <b>66</b>(3), 751&ndash;769.
<a href="https://doi.org/10.1111/j.1467-9868.2004.05304.x">doi:10.1111/j.1467-9868.2004.05304.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
N &lt;- 100; params &lt;- paste("X", 1:15, sep = "")

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params)

# Compute Oakley and O'Hagan (2004) function
Y &lt;- oakley_Fun(mat)
</code></pre>

<hr>
<h2 id='plot_multiscatter'>Pairwise combinations of model inputs with the colour
proportional the model output value.</h2><span id='topic+plot_multiscatter'></span>

<h3>Description</h3>

<p>It plots all pairwise combinations of model inputs with the colour
proportional the model output value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_multiscatter(data, N, Y, params, smpl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_multiscatter_+3A_data">data</code></td>
<td>
<p>The matrix created with <code><a href="#topic+sobol_matrices">sobol_matrices</a></code>.</p>
</td></tr>
<tr><td><code id="plot_multiscatter_+3A_n">N</code></td>
<td>
<p>Positive integer, the initial sample size of the base sample matrix created with <code><a href="#topic+sobol_matrices">sobol_matrices</a></code>.</p>
</td></tr>
<tr><td><code id="plot_multiscatter_+3A_y">Y</code></td>
<td>
<p>A numeric vector with the model output obtained from the matrix created with
<code><a href="#topic+sobol_matrices">sobol_matrices</a></code>.</p>
</td></tr>
<tr><td><code id="plot_multiscatter_+3A_params">params</code></td>
<td>
<p>Character vector with the name of the model inputs.</p>
</td></tr>
<tr><td><code id="plot_multiscatter_+3A_smpl">smpl</code></td>
<td>
<p>The number of simulations to plot.
The default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
N &lt;- 1000; params &lt;- paste("X", 1:3, sep = ""); R &lt;- 10

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params)

# Compute Ishigami function
Y &lt;- ishigami_Fun(mat)

# Plot scatterplot matrix
plot_multiscatter(data = mat, N = N, Y = Y, params = params)
</code></pre>

<hr>
<h2 id='plot_scatter'>Scatter plots of the model output against the model inputs.</h2><span id='topic+plot_scatter'></span>

<h3>Description</h3>

<p>It creates scatter plots of the model output against the model inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scatter(data, N, Y, params, method = "point", size = 0.7, alpha = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_scatter_+3A_data">data</code></td>
<td>
<p>The matrix created with <code><a href="#topic+sobol_matrices">sobol_matrices</a></code>.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_n">N</code></td>
<td>
<p>Positive integer, the initial sample size of the base sample matrix created with <code>sobol_matrices</code>.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_y">Y</code></td>
<td>
<p>A numeric vector with the model output obtained from the matrix created with
<code><a href="#topic+sobol_matrices">sobol_matrices</a></code>.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_params">params</code></td>
<td>
<p>Character vector with the name of the model inputs.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_method">method</code></td>
<td>
<p>The type of plot. If <code>method = "point"</code> (the default), each simulation is a point.
If <code>method = "bin"</code>, bins are used to aggregate simulations.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_size">size</code></td>
<td>
<p>Number between 0 and 1, argument of <code>geom_point()</code>. Default is 0.7.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_alpha">alpha</code></td>
<td>
<p>Number between 0 and 1, transparency scale of <code>geom_point()</code>. Default is 0.2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
N &lt;- 1000; params &lt;- paste("X", 1:3, sep = ""); R &lt;- 10

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params)

# Compute Ishigami function
Y &lt;- ishigami_Fun(mat)

# Plot scatter
plot_scatter(data = mat, Y = Y, N = N, params = params)
</code></pre>

<hr>
<h2 id='plot_uncertainty'>Visualization of the model output uncertainty</h2><span id='topic+plot_uncertainty'></span>

<h3>Description</h3>

<p>It creates an histogram with the model output distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_uncertainty(Y, N = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_uncertainty_+3A_y">Y</code></td>
<td>
<p>A numeric vector with the model output obtained from the matrix created with
<code><a href="#topic+sobol_matrices">sobol_matrices</a></code>.</p>
</td></tr>
<tr><td><code id="plot_uncertainty_+3A_n">N</code></td>
<td>
<p>Positive integer, the initial sample size of the base sample matrix created with <code><a href="#topic+sobol_matrices">sobol_matrices</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
N &lt;- 1000; params &lt;- paste("X", 1:3, sep = ""); R &lt;- 10

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params)

# Compute Ishigami function
Y &lt;- ishigami_Fun(mat)

# Plot uncertainty
plot_uncertainty(Y = Y, N = N)
</code></pre>

<hr>
<h2 id='plot.sensobol'>Visualization of first, total, second, third and fourth-order Sobol' indices.</h2><span id='topic+plot.sensobol'></span>

<h3>Description</h3>

<p>It plots first, total, second, third and fourth-order Sobol' indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sensobol'
plot(x, order = "first", dummy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sensobol_+3A_x">x</code></td>
<td>
<p>The output of <code><a href="#topic+sobol_indices">sobol_indices</a></code>.</p>
</td></tr>
<tr><td><code id="plot.sensobol_+3A_order">order</code></td>
<td>
<p>If <code>order = "first"</code>, it plots first and total-order effects.
If <code>order = "second"</code>, it plots second-order effects. If <code>order = "third"</code>, it plots
third-order effects. If <code>order = "fourth"</code>, it plots
third-order effects. Default is <code>order = "first"</code>.</p>
</td></tr>
<tr><td><code id="plot.sensobol_+3A_dummy">dummy</code></td>
<td>
<p>The output of <code><a href="#topic+sobol_dummy">sobol_dummy</a></code>. Default is NULL.</p>
</td></tr>
<tr><td><code id="plot.sensobol_+3A_...">...</code></td>
<td>
<p>Other graphical parameters to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
N &lt;- 1000; params &lt;- paste("X", 1:3, sep = ""); R &lt;- 10

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params)

# Compute Ishigami function
Y &lt;- ishigami_Fun(mat)

# Compute and bootstrap Sobol' indices
ind &lt;- sobol_indices(Y = Y, N = N, params = params, boot = TRUE, R = R)

# Plot Sobol' indices
plot(ind)
</code></pre>

<hr>
<h2 id='print.sensobol'>Display the results obtained with the <code>sobol_indices</code> function.</h2><span id='topic+print.sensobol'></span>

<h3>Description</h3>

<p>Display the results obtained with the <code>sobol_indices</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sensobol'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sensobol_+3A_x">x</code></td>
<td>
<p>A <code>sensobol</code> object produced by <code>sobol_indices</code>.</p>
</td></tr>
<tr><td><code id="print.sensobol_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>print.sensobol</code> informs on the first and total-order
estimators used in the computations, the total number of model runs and
the sum of first-order index. It also plots the estimated results.
</p>

<hr>
<h2 id='print.vars'>Display the results obtained with the <code>vars_to</code> function.</h2><span id='topic+print.vars'></span>

<h3>Description</h3>

<p>Display the results obtained with the <code>vars_to</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vars'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.vars_+3A_x">x</code></td>
<td>
<p>A <code>vars</code> object produced by <code>vars_to</code>.</p>
</td></tr>
<tr><td><code id="print.vars_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>print.vars</code> informs on the number of star centers,
the value of h used and the total number of model runs.. It also plots
the VARS-TO indices.
</p>

<hr>
<h2 id='sobol_convergence'>Check convergence of Sobol' indices.</h2><span id='topic+sobol_convergence'></span>

<h3>Description</h3>

<p>It checks the convergence of Sobol' indices on different sub-samples of the model output-.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sobol_convergence(
  matrices,
  Y,
  N,
  sub.sample,
  params,
  first,
  total,
  order = order,
  seed = 666,
  plot.order,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sobol_convergence_+3A_matrices">matrices</code></td>
<td>
<p>Character vector with the required matrices. The default is <code>matrices = c("A", "B", "AB")</code>.
See <code><a href="#topic+sobol_matrices">sobol_matrices</a></code>.</p>
</td></tr>
<tr><td><code id="sobol_convergence_+3A_y">Y</code></td>
<td>
<p>Numeric vector with the model output obtained from the matrix created with
<code><a href="#topic+sobol_matrices">sobol_matrices</a></code>.</p>
</td></tr>
<tr><td><code id="sobol_convergence_+3A_n">N</code></td>
<td>
<p>Positive integer, the initial sample size of the base sample matrix created with <code><a href="#topic+sobol_matrices">sobol_matrices</a></code>.</p>
</td></tr>
<tr><td><code id="sobol_convergence_+3A_sub.sample">sub.sample</code></td>
<td>
<p>Numeric vector with the sub-samples of the model output at which to check convergence.</p>
</td></tr>
<tr><td><code id="sobol_convergence_+3A_params">params</code></td>
<td>
<p>Character vector with the name of the model inputs.</p>
</td></tr>
<tr><td><code id="sobol_convergence_+3A_first">first</code></td>
<td>
<p>Estimator to compute first-order indices. Check options in <code><a href="#topic+sobol_indices">sobol_indices</a></code>.</p>
</td></tr>
<tr><td><code id="sobol_convergence_+3A_total">total</code></td>
<td>
<p>Estimator to compute total-order indices. Check options in <code><a href="#topic+sobol_indices">sobol_indices</a></code>.</p>
</td></tr>
<tr><td><code id="sobol_convergence_+3A_order">order</code></td>
<td>
<p>Whether to plot convergence for &quot;second&quot; or &quot;third&quot; order indices.</p>
</td></tr>
<tr><td><code id="sobol_convergence_+3A_seed">seed</code></td>
<td>
<p>Whether to compute &quot;first&quot;, &quot;second&quot;, or &quot;third&quot; -order Sobol' indices. Default
is <code>order = "first"</code>.</p>
</td></tr>
<tr><td><code id="sobol_convergence_+3A_plot.order">plot.order</code></td>
<td>
<p>Whether to plot convergence for &quot;second&quot; or &quot;third&quot;-order indices.</p>
</td></tr>
<tr><td><code id="sobol_convergence_+3A_...">...</code></td>
<td>
<p>Further arguments in <code><a href="#topic+sobol_indices">sobol_indices</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the results and the plots
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
matrices &lt;- c("A", "B", "AB")
params &lt;- paste("X", 1:3, sep = "")
N &lt;- 2^10
first &lt;- "saltelli"
total &lt;- "jansen"
order &lt;- "second"

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params, order = order)

# Compute Ishigami function
Y &lt;- ishigami_Fun(mat)

# Check convergence at specific sample sizes
sub.sample &lt;- seq(100, N, 500) # Define sub-samples
sobol_convergence(matrices = matrices, Y = Y, N = N, sub.sample = sub.sample,
params = params, first = first, total = total, order = order, plot.order = order)
</code></pre>

<hr>
<h2 id='sobol_dummy'>Computation of Sobol' indices for a dummy parameter</h2><span id='topic+sobol_dummy'></span>

<h3>Description</h3>

<p>This function computes first and total-order Sobol' indices for a dummy
parameter following the formulae shown
in Khorashadi Zadeh et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sobol_dummy(
  Y,
  N,
  params,
  boot = FALSE,
  R = NULL,
  parallel = "no",
  ncpus = 1,
  conf = 0.95,
  type = "norm"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sobol_dummy_+3A_y">Y</code></td>
<td>
<p>A numeric vector with the model output obtained from the matrix created with
<code><a href="#topic+sobol_matrices">sobol_matrices</a></code>. The numeric vector should not contain any NA or NaN values.</p>
</td></tr>
<tr><td><code id="sobol_dummy_+3A_n">N</code></td>
<td>
<p>Positive integer, the initial sample size of the base sample matrix created with <code><a href="#topic+sobol_matrices">sobol_matrices</a></code>.</p>
</td></tr>
<tr><td><code id="sobol_dummy_+3A_params">params</code></td>
<td>
<p>A character vector with the name of the model inputs.</p>
</td></tr>
<tr><td><code id="sobol_dummy_+3A_boot">boot</code></td>
<td>
<p>Logical. If TRUE, the function bootstraps the Sobol' indices. If FALSE, it provides point
estimates. Default is <code>boot = FALSE</code>.</p>
</td></tr>
<tr><td><code id="sobol_dummy_+3A_r">R</code></td>
<td>
<p>Positive integer, number of bootstrap replicas.</p>
</td></tr>
<tr><td><code id="sobol_dummy_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any).
If missing, the default is taken from the option &quot;boot.parallel&quot;
(and if that is not set, &quot;no&quot;). For more information, check the
<code>parallel</code> option in the <code>boot</code> function of the <code><a href="boot.html#topic+boot">boot</a></code> package.</p>
</td></tr>
<tr><td><code id="sobol_dummy_+3A_ncpus">ncpus</code></td>
<td>
<p>Positive integer: number of processes to be used in parallel operation:
typically one would chose this to the number of available CPUs.
Check the <code>ncpus</code> option in the <code>boot</code> function of the <code><a href="boot.html#topic+boot">boot</a></code> package.</p>
</td></tr>
<tr><td><code id="sobol_dummy_+3A_conf">conf</code></td>
<td>
<p>Confidence intervals, number between 0 and 1. Default is <code>conf = 0.95</code>.</p>
</td></tr>
<tr><td><code id="sobol_dummy_+3A_type">type</code></td>
<td>
<p>Method to compute the confidence intervals. Default is <code>type = "norm"</code>.
Check the <code>type</code> option in the <code>boot</code> function of the <code><a href="boot.html#topic+boot">boot</a></code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> object.
</p>


<h3>References</h3>

<p>Khorashadi Zadeh F, Nossent J, Sarrazin F, Pianosi F, van Griensven A, Wagener T, Bauwens W (2017).
&ldquo;Comparison of variance-based and moment-independent global sensitivity analysis approaches by application to the SWAT model.&rdquo;
<em>Environmental Modelling and Software</em>, <b>91</b>, 210&ndash;222.
<a href="https://doi.org/10.1016/j.envsoft.2017.02.001">doi:10.1016/j.envsoft.2017.02.001</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
N &lt;- 100; params &lt;- paste("X", 1:3, sep = ""); R &lt;- 10

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params)

# Compute Ishigami function
Y &lt;- ishigami_Fun(mat)

# Compute and bootstrap Sobol' indices for dummy parameter
ind.dummy &lt;- sobol_dummy(Y = Y, N = N, params = params, boot = TRUE, R = R)
</code></pre>

<hr>
<h2 id='sobol_Fun'>Sobol' G function</h2><span id='topic+sobol_Fun'></span>

<h3>Description</h3>

<p>It implements the Sobol' (1998) G function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sobol_Fun(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sobol_Fun_+3A_x">X</code></td>
<td>
<p>A data frame or numeric matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires eight model inputs and reads as
</p>
<p style="text-align: center;"><code class="reqn">y=\prod_{i=1}^{k} \frac{|4 x_i - 2| + a_i}{1 + a_i}\,,</code>
</p>

<p>where <code class="reqn">k=8</code>, <code class="reqn">x_i\sim\mathcal{U}(0,1)</code> and <code class="reqn">a=(0, 1, 4.5, 9, 99, 99, 99, 99)</code>.
</p>


<h3>Value</h3>

<p>A numeric vector with the model output.
</p>


<h3>References</h3>

<p>Sobol' IM (1998).
&ldquo;On quasi-Monte Carlo integrations.&rdquo;
<em>Mathematics and Computers in Simulation</em>, <b>47</b>(2-5), 103&ndash;112.
<a href="https://doi.org/10.1016/S0378-4754%2898%2900096-2">doi:10.1016/S0378-4754(98)00096-2</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
N &lt;- 100; params &lt;- paste("X", 1:8, sep = "")

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params)

# Compute Sobol' G
Y &lt;- sobol_Fun(mat)
</code></pre>

<hr>
<h2 id='sobol_indices'>Computation of Sobol' indices</h2><span id='topic+sobol_indices'></span>

<h3>Description</h3>

<p>It allows to compute Sobol' indices up to the fourth-order using state-of-the-art estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sobol_indices(
  matrices = c("A", "B", "AB"),
  Y,
  N,
  params,
  first = "saltelli",
  total = "jansen",
  order = "first",
  boot = FALSE,
  R = NULL,
  parallel = "no",
  ncpus = 1,
  conf = 0.95,
  type = "norm"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sobol_indices_+3A_matrices">matrices</code></td>
<td>
<p>Character vector with the required matrices. The default is <code>matrices = c("A", "B", "AB")</code>.
See <code><a href="#topic+sobol_matrices">sobol_matrices</a></code>.</p>
</td></tr>
<tr><td><code id="sobol_indices_+3A_y">Y</code></td>
<td>
<p>Numeric vector with the model output obtained from the matrix created with
<code><a href="#topic+sobol_matrices">sobol_matrices</a></code>. The numeric vector should not contain any NA or NaN values.</p>
</td></tr>
<tr><td><code id="sobol_indices_+3A_n">N</code></td>
<td>
<p>Positive integer, the initial sample size of the base sample matrix created with <code><a href="#topic+sobol_matrices">sobol_matrices</a></code>.</p>
</td></tr>
<tr><td><code id="sobol_indices_+3A_params">params</code></td>
<td>
<p>Character vector with the name of the model inputs.</p>
</td></tr>
<tr><td><code id="sobol_indices_+3A_first">first</code></td>
<td>
<p>Estimator to compute first-order indices. Options are:
</p>

<ul>
<li> <p><code>first = "saltelli"</code> (Saltelli et al. 2010).
</p>
</li>
<li> <p><code>first = "jansen"</code> (Jansen 1999).
</p>
</li>
<li> <p><code>first = "sobol"</code>  (Sobol' 1993).
</p>
</li>
<li> <p><code>first = "azzini"</code> (Azzini et al. 2020).
</p>
</li></ul>
</td></tr>
<tr><td><code id="sobol_indices_+3A_total">total</code></td>
<td>
<p>Estimator to compute total-order indices. Options are:
</p>

<ul>
<li> <p><code>total = "jansen"</code> (Jansen 1999).
</p>
</li>
<li> <p><code>total = "sobol"</code> (Sobol' 2001).
</p>
</li>
<li> <p><code>total = "homma"</code> (Homma and Saltelli 1996).
</p>
</li>
<li> <p><code>total = "janon"</code> (Janon et al. 2014).
</p>
</li>
<li> <p><code>total = "glen"</code> (Glen and Isaacs 2012).
</p>
</li>
<li> <p><code>total = "azzini"</code> (Azzini et al. 2020).
</p>
</li>
<li> <p><code>total = "saltelli"</code> (Saltelli et al. 2008).
</p>
</li></ul>
</td></tr>
<tr><td><code id="sobol_indices_+3A_order">order</code></td>
<td>
<p>Whether to compute &quot;first&quot;, &quot;second&quot;, &quot;third&quot; or fourth-order Sobol' indices. Default
is <code>order = "first"</code>.</p>
</td></tr>
<tr><td><code id="sobol_indices_+3A_boot">boot</code></td>
<td>
<p>Logical. If TRUE, the function bootstraps the Sobol' indices. If FALSE, it provides point
estimates. Default is <code>boot = FALSE</code>.</p>
</td></tr>
<tr><td><code id="sobol_indices_+3A_r">R</code></td>
<td>
<p>Positive integer, number of bootstrap replicas. Default is NULL.</p>
</td></tr>
<tr><td><code id="sobol_indices_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any).
If missing, the default is taken from the option &quot;boot.parallel&quot;
(and if that is not set, &quot;no&quot;). For more information, check the
<code>parallel</code> option in the <code>boot</code> function of the <code><a href="boot.html#topic+boot">boot</a></code> package.</p>
</td></tr>
<tr><td><code id="sobol_indices_+3A_ncpus">ncpus</code></td>
<td>
<p>Positive integer: number of processes to be used in parallel operation:
typically one would chose this to the number of available CPUs.
Check the <code>ncpus</code> option in the <code>boot</code> function of the <code><a href="boot.html#topic+boot">boot</a></code> package.</p>
</td></tr>
<tr><td><code id="sobol_indices_+3A_conf">conf</code></td>
<td>
<p>Confidence interval if <code>boot = TRUE</code>. Number between 0 and 1. Default is <code>conf = 0.95</code>.</p>
</td></tr>
<tr><td><code id="sobol_indices_+3A_type">type</code></td>
<td>
<p>Method to compute the confidence interval if <code>boot = TRUE</code>. Default is &quot;norm&quot;.
Check the <code>type</code> option in the <code>boot</code> function of the <code><a href="boot.html#topic+boot">boot</a></code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any first and total-order estimator can be combined with the appropriate sampling design.
Check Table 3 of the vignette for a summary of all possible combinations, and Tables 1 and 2 for a
mathematical description of the estimators. If the analyst mismatches estimators and sampling designs,
the function will generate an error and urge to redefine the sample matrices or the estimators.
</p>
<p>For all estimators except Azzini et al. (2020)'s and Janon et al. (2014)'s,
<code>sobol_indices()</code> calculates the sample mean as </p>
<p style="text-align: center;"><code class="reqn">\hat{f}_0=\frac{1}{2N} \sum_{v=1}^{N}(f(\mathbf{A})_v + f(\mathbf{B})_v)\,,</code>
</p>

<p>where <code class="reqn">N</code> is the row dimension of the base sample matrix, and the unconditional sample variance as
</p>
<p style="text-align: center;"><code class="reqn">\hat{V}(y) = \frac{1}{2N-1} \sum{v=1}^{N} ((f(\mathbf{A})_v - \hat{f})^2 + (f(\mathbf{B})_v - \hat{f})^2)\,,</code>
</p>

<p>where <code class="reqn">f(\mathbf{A})_v</code> (<code class="reqn">f(\mathbf{B})_v</code>) indicates the model output <code class="reqn">y</code> obtained after running the model <code class="reqn">f</code>
in the <code class="reqn">v</code>-th row of the <code class="reqn">\mathbf{A}</code> (<code class="reqn">\mathbf{B}</code>) matrix.
</p>
<p>For the Azzini estimator,
</p>
<p style="text-align: center;"><code class="reqn">\hat{V}(y) = \sum_{v=1}^{N} (f(\mathbf{A})_v - f(\mathbf{B})_v)^2 + (f(\mathbf{B}_A^{(i)})_v - f(\mathbf{A}_B^{(i)})_v) ^ 2</code>
</p>

<p>and for the Janon estimator,
</p>
<p style="text-align: center;"><code class="reqn">\hat{V}(y)=\frac{1}{N} \sum_{v=1}^{N} \frac{f(\mathbf{A})_v^2 + f(\mathbf{A}_B^{(i)})_v^2}{2}-f_0^2</code>
</p>

<p>where <code class="reqn">f(\mathbf{A}_B^{(i)})_v</code> (<code class="reqn">f(\mathbf{B}_A^{(i)})_v</code>) is the model output obtained after running the model <code class="reqn">f</code> in
the <code class="reqn">v</code>-th row of an <code class="reqn">\mathbf{A}_B^{(i)})_v</code> (<code class="reqn">\mathbf{B}_A^{(i)})_v</code>) matrix, where all columns come from <code class="reqn">\mathbf{A}</code> (<code class="reqn">\mathbf{B}</code>)
except the <code class="reqn">i</code>-th, which comes from <code class="reqn">\mathbf{B}</code> (<code class="reqn">\mathbf{A}</code>).
</p>


<h3>Value</h3>

<p>A <code>sensobol</code> object.
</p>


<h3>References</h3>

<p>Azzini I, Mara T, Rosati R (2020).
&ldquo;Monte Carlo estimators of first-and total-orders Sobol' indices.&rdquo;
<em>arXiv</em>.
2006.08232, <a href="https://arxiv.org/abs/2006.08232">https://arxiv.org/abs/2006.08232</a>.<br /><br /> Glen G, Isaacs K (2012).
&ldquo;Estimating Sobol sensitivity indices using correlations.&rdquo;
<em>Environmental Modelling and Software</em>, <b>37</b>, 157&ndash;166.
<a href="https://doi.org/10.1016/j.envsoft.2012.03.014">doi:10.1016/j.envsoft.2012.03.014</a>.<br /><br /> Homma T, Saltelli A (1996).
&ldquo;Importance measures in global sensitivity analysis of nonlinear models.&rdquo;
<em>Reliability Engineering and System Safety</em>, <b>52</b>, 1&ndash;17.
<a href="https://doi.org/10.1016/0951-8320%2896%2900002-6">doi:10.1016/0951-8320(96)00002-6</a>.<br /><br /> Janon A, Klein T, Lagnoux A, Nodet M, Prieur C (2014).
&ldquo;Asymptotic normality and efficiency of two Sobol index estimators.&rdquo;
<em>ESAIM: Probability and Statistics</em>, <b>18</b>(3), 342&ndash;364.
<a href="https://doi.org/10.1051/ps/2013040">doi:10.1051/ps/2013040</a>.<br /><br /> Jansen M (1999).
&ldquo;Analysis of variance designs for model output.&rdquo;
<em>Computer Physics Communications</em>, <b>117</b>(1), 35&ndash;43.
<a href="https://doi.org/10.1016/S0010-4655%2898%2900154-4">doi:10.1016/S0010-4655(98)00154-4</a>.<br /><br /> Saltelli A, Annoni P, Azzini I, Campolongo F, Ratto M, Tarantola S (2010).
&ldquo;Variance based sensitivity analysis of model output. Design and estimator for the total sensitivity index.&rdquo;
<em>Computer Physics Communications</em>, <b>181</b>(2), 259&ndash;270.
<a href="https://doi.org/10.1016/j.cpc.2009.09.018">doi:10.1016/j.cpc.2009.09.018</a>.<br /><br /> Saltelli A, Ratto M, Andres T, Campolongo F, Cariboni J, Gatelli D, Saisana M, Tarantola S (2008).
<em>Global Sensitivity Analysis. The Primer</em>.
John Wiley and Sons, Ltd, Chichester, UK.
<a href="https://doi.org/10.1002/9780470725184">doi:10.1002/9780470725184</a>.<br /><br /> Sobol' IM (1993).
&ldquo;Sensitivity analysis for nonlinear mathematical models.&rdquo;
<em>Mathematical Modeling and Computational Experiment</em>, <b>1</b>(4), 407&ndash;414.<br /><br /> Sobol' IM (2001).
&ldquo;Global sensitivity indices for nonlinear mathematical models and their Monte Carlo estimates.&rdquo;
<em>Mathematics and Computers in Simulation</em>, <b>55</b>(1-3), 271&ndash;280.
<a href="https://doi.org/10.1016/S0378-4754%2800%2900270-6">doi:10.1016/S0378-4754(00)00270-6</a>.
</p>


<h3>See Also</h3>

<p>Check the function <code><a href="boot.html#topic+boot">boot</a></code> for further details on the bootstrapping
with regards to the methods available for the computation of confidence intervals in the <code>type</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
N &lt;- 1000; params &lt;- paste("X", 1:3, sep = ""); R &lt;- 10

# Create sample matrix
mat &lt;- sobol_matrices(N = N, params = params)

# Compute Ishigami function
Y &lt;- ishigami_Fun(mat)

# Compute and bootstrap Sobol' indices
ind &lt;- sobol_indices(Y = Y, N = N, params = params, boot = TRUE, R = R)
</code></pre>

<hr>
<h2 id='sobol_matrices'>Creation of the sample matrices</h2><span id='topic+sobol_matrices'></span>

<h3>Description</h3>

<p>It creates the sample matrices to compute Sobol' first and total-order indices.
If needed, it also creates the sample matrices required to compute second,
third and fourth-order indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sobol_matrices(
  matrices = c("A", "B", "AB"),
  N,
  params,
  order = "first",
  type = "QRN",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sobol_matrices_+3A_matrices">matrices</code></td>
<td>
<p>Character vector with the required matrices. The default
is <code>matrices = c("A", "B", "AB")</code>.</p>
</td></tr>
<tr><td><code id="sobol_matrices_+3A_n">N</code></td>
<td>
<p>Positive integer, initial sample size of the base sample matrix.</p>
</td></tr>
<tr><td><code id="sobol_matrices_+3A_params">params</code></td>
<td>
<p>Character vector with the name of the model inputs.</p>
</td></tr>
<tr><td><code id="sobol_matrices_+3A_order">order</code></td>
<td>
<p>One of &quot;first&quot;, &quot;second&quot;, &quot;third&quot; or &quot;fourth&quot; to create a matrix to
compute first, second, third or up to fourth-order Sobol' indices. The default is
<code>order = "first"</code>.</p>
</td></tr>
<tr><td><code id="sobol_matrices_+3A_type">type</code></td>
<td>
<p>Approach to construct the sample matrix. Options are:
</p>

<ul>
<li> <p><code>type = "QRN"</code> (default): It uses Sobol' (1967) Quasi-Random Numbers.
through a call to the function <code><a href="randtoolbox.html#topic+sobol">sobol</a></code> of the <code>randtoolbox</code> package.
</p>
</li>
<li> <p><code>type = "LHS"</code>: It uses a Latin Hypercube Sampling Design
(McKay et al. 1979) through a call
to the function <code><a href="lhs.html#topic+randomLHS">randomLHS</a></code> of the <code>lhs</code> package.
</p>
</li>
<li> <p><code>type = "R"</code>: It uses random numbers.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sobol_matrices_+3A_...">...</code></td>
<td>
<p>Further arguments in <code><a href="randtoolbox.html#topic+sobol">sobol</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before calling <code>sobol_matrices</code>, the user must decide which estimators
will be used to compute first and total-order indices, for this option conditions
the design of the sample matrix and therefore the argument <code>matrices</code>.
See Table 3 in the vignette for further details on the specific sampling designs required by
the estimators.
</p>
<p>The user can select one of the following sampling designs:
</p>

<ul>
<li> <p><code class="reqn">\mathbf{A}</code>, <code class="reqn">\mathbf{B}</code>, <code class="reqn">\mathbf{A}_B^{(i)}</code>.
</p>
</li>
<li> <p><code class="reqn">\mathbf{A}</code>, <code class="reqn">\mathbf{B}</code>, <code class="reqn">\mathbf{B}_A^{(i)}</code>.
</p>
</li>
<li> <p><code class="reqn">\mathbf{A}</code>, <code class="reqn">\mathbf{B}</code>, <code class="reqn">\mathbf{A}_B^{(i)}</code>, <code class="reqn">\mathbf{B}_A^{(i)}</code>.
</p>
</li></ul>

<p>If <code>order = "first"</code>, the function creates an <code class="reqn">(N, 2k)</code> matrix according to the approach defined by
<code>type</code>, where the leftmost and the rightmost <code class="reqn">k</code> columns are respectively allocated
to the <code class="reqn">\mathbf{A}</code> and the <code class="reqn">\mathbf{B}</code> matrix. Depending on the sampling design, it
also creates <code class="reqn">k</code> <code class="reqn">\mathbf{A}_B^{(i)}</code> (<code class="reqn">\mathbf{B}_A^{(i)}</code>) matrices, where all
columns come from <code class="reqn">\mathbf{A}</code> (<code class="reqn">\mathbf{B}</code>) except the <code class="reqn">i</code>-th, which comes from
<code class="reqn">\mathbf{B}</code> (<code class="reqn">\mathbf{A}</code>). All matrices are returned row-binded.
</p>
<p>If <code>order = "second"</code>, <code class="reqn">\frac{k!}{2!(k-2)!}</code> extra <code class="reqn">(N, k)</code> <code class="reqn">\mathbf{A}_B^{(ij)}</code>
(<code class="reqn">\mathbf{B}_A^{(ij)}</code>) matrices are created, where all columns come from <code class="reqn">\mathbf{A}</code>
(<code class="reqn">\mathbf{B}</code>) except the <code class="reqn">i</code>-th and <code class="reqn">j</code>-th, which come from <code class="reqn">\mathbf{B}</code>
(<code class="reqn">\mathbf{A}</code>). These matrices allow the computation of second-order effects, and are row-bound
to those created for first and total-order indices.
</p>
<p>If <code>order = "third"</code>, <code class="reqn">\frac{k!}{3!(k-3)!}</code> extra <code class="reqn">(N, k)</code> <code class="reqn">\mathbf{A}_B^{(ijl)}</code>
(<code class="reqn">\mathbf{B}_A^{(ijl)}</code>) matrices are bound below those created
for the computation of second-order effects. In these matrices, all columns come from <code class="reqn">\mathbf{A}</code>
(<code class="reqn">\mathbf{B}</code>) except the <code class="reqn">i</code>-th, the <code class="reqn">j</code>-th and the <code class="reqn">l</code>-th, which come from <code class="reqn">\mathbf{B}</code>
(<code class="reqn">\mathbf{A}</code>). These matrices are needed to compute third-order effects, and are row-bound below
those created for second-order effects.
</p>
<p>The same process applies to create the matrices to compute fourth-order effects.
</p>
<p>All columns are distributed in (0,1). If the uncertainty in some parameter(s) is better described with
another distribution, the user should apply the required quantile inverse transformation to the column of
interest once the sample matrix is produced.
</p>


<h3>Value</h3>

<p>A numeric matrix where each column is a model input distributed in (0,1) and each row
a sampling point.
</p>


<h3>References</h3>

<p>McKay MD, Beckman RJ, Conover WJ (1979).
&ldquo;Comparison of three methods for selecting values of input variables in the analysis of output from a computer code.&rdquo;
<em>Technometrics</em>, <b>21</b>(2), 239&ndash;245.
<a href="https://doi.org/10.1080/00401706.1979.10489755">doi:10.1080/00401706.1979.10489755</a>.<br /><br /> Sobol' IM (1967).
&ldquo;On the distribution of points in a cube and the approximate evaluation of integrals.&rdquo;
<em>USSR Computational Mathematics and Mathematical Physics</em>, <b>7</b>(4), 86&ndash;112.
<a href="https://doi.org/10.1016/0041-5553%2867%2990144-9">doi:10.1016/0041-5553(67)90144-9</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
N &lt;- 100; params &lt;- paste("X", 1:10, sep = ""); order &lt;-  "third"

# Create sample matrix using Sobol' Quasi Random Numbers.
mat &lt;- sobol_matrices(N = N, params = params, order = order)

# Let's assume that the uncertainty in X3 is better described
# with a normal distribution with mean 0 and standard deviation 1:
mat[, 3] &lt;- qnorm(mat[, 3], 0, 1)
</code></pre>

<hr>
<h2 id='sobol_ode'>Wrapper around <code>deSolve</code> <code><a href="deSolve.html#topic+ode">ode</a></code>.</h2><span id='topic+sobol_ode'></span>

<h3>Description</h3>

<p>It solves a system of ordinary differential equations and extracts the model output
at the selected times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sobol_ode(d, times, timeOutput, state, func, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sobol_ode_+3A_d">d</code></td>
<td>
<p>Character vector with the name of the model inputs.</p>
</td></tr>
<tr><td><code id="sobol_ode_+3A_times">times</code></td>
<td>
<p>Time sequence as defined by <code><a href="deSolve.html#topic+ode">ode</a></code>.</p>
</td></tr>
<tr><td><code id="sobol_ode_+3A_timeoutput">timeOutput</code></td>
<td>
<p>Numeric vector determining the time steps at which
the output is wanted.</p>
</td></tr>
<tr><td><code id="sobol_ode_+3A_state">state</code></td>
<td>
<p>Initial values of the state variables.</p>
</td></tr>
<tr><td><code id="sobol_ode_+3A_func">func</code></td>
<td>
<p>An R function as defined by <code><a href="deSolve.html#topic+ode">ode</a></code>.</p>
</td></tr>
<tr><td><code id="sobol_ode_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="deSolve.html#topic+ode">ode</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the output values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define the model: the Lotka-Volterra system of equations
lotka_volterra_fun &lt;- function(t, state, parameters) {
with(as.list(c(state, parameters)), {
  dX &lt;- r * X * (1 - X / K) - alpha * X * Y
  dY &lt;- -m * Y + theta * X * Y
  list(c(dX, dY))
 })
 }

# Define the settings of the sensitivity analysis
N &lt;- 2 ^ 5 # Sample size of sample matrix
params &lt;- c("r", "alpha", "m", "theta", "K", "X", "Y") # Parameters

# Define the times
 times &lt;- seq(5, 20, 1)

 # Define the times at which the output is wanted
 timeOutput &lt;- c(10, 15)

# Construct the sample matrix
mat &lt;- sobol_matrices(N = N, params = params)

# Transform to appropriate distributions
mat[, "r"] &lt;- qunif(mat[, "r"], 0.8, 1.8)
mat[, "alpha"] &lt;- qunif(mat[, "alpha"], 0.2, 1)
mat[, "m"] &lt;- qunif(mat[, "m"], 0.6, 1)
mat[, "theta"] &lt;- qunif(mat[, "theta"], 0.05, 0.15)
mat[, "K"] &lt;- qunif(mat[, "K"], 47, 53)
mat[, "X"] &lt;- floor(mat[, "X"] * (15 - 8 + 1) + 8)
mat[, "Y"] &lt;- floor(mat[, "Y"] * (2 - 6 + 1) + 6)

# Run the model
y &lt;- list()
for (i in 1:nrow(mat)) {
  y[[i]] &lt;- sobol_ode(d = mat[i, ],
                     times = times,
                     timeOutput = timeOutput,
                     state = c(X = mat[[i, "X"]], Y = mat[[i, "Y"]]),
                     func = lotka_volterra_fun)
}
</code></pre>

<hr>
<h2 id='vars_matrices'>STAR-VARS sampling strategy</h2><span id='topic+vars_matrices'></span>

<h3>Description</h3>

<p>It creates the STAR-VARS matrix needed to compute VARS-TO following Razavi and Gupta (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars_matrices(star.centers, params, h = 0.1, type = "QRN", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vars_matrices_+3A_star.centers">star.centers</code></td>
<td>
<p>Positive integer, number of star centers.</p>
</td></tr>
<tr><td><code id="vars_matrices_+3A_params">params</code></td>
<td>
<p>Character vector with the name of the model inputs.</p>
</td></tr>
<tr><td><code id="vars_matrices_+3A_h">h</code></td>
<td>
<p>Distance between pairs. The user should select between 0.001, 0.002, 0.005, 0.01,
0.02, 0.05, 0.1, 0.2. Default is <code>h = 0.1</code>.</p>
</td></tr>
<tr><td><code id="vars_matrices_+3A_type">type</code></td>
<td>
<p>Approach to construct the STAR-VARS. Options are:
</p>

<ul>
<li> <p><code>type = "QRN"</code>: It uses Sobol' (1967) Quasi-Random Numbers
through a call to the function <code><a href="randtoolbox.html#topic+sobol">sobol</a></code> of the <code>randtoolbox</code> package.
</p>
</li>
<li> <p><code>type = "R"</code>: It uses random numbers.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vars_matrices_+3A_...">...</code></td>
<td>
<p>Further arguments in <code><a href="randtoolbox.html#topic+sobol">sobol</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user randomly selects <code class="reqn">N_{star}</code> points across the factor space using
either Sobol' Quasi Random Numbers (<code>type = "QRN"</code>) or random numbers (<code>type = "R"</code>).
These are the <em>star centres</em> and their location can be denoted as
<code class="reqn">\mathbf{s}_v = s_{v_1},...,s_{v_i}, ..., s_{v_k}</code>, where <code class="reqn">v=1,2,...,N_{star}</code>.
Then, for each star centre, the function generates a cross section of equally spaced points
<code class="reqn">\Delta h</code> apart for each of the <code class="reqn">k</code> model inputs, including and passing through the
star centre. The cross section is produced by fixing <code class="reqn">\mathbf{s}_{v_{\sim i}}</code> and varying <code class="reqn">s_i</code>.
Finally, for each factor all pairs of points with <code class="reqn">h</code> values of <code class="reqn">\Delta h, 2\Delta h, 3\Delta h</code>
and so on are extracted. The total computational cost of this design is
<code class="reqn">N_t=N_{star} (k (\frac{1}{\Delta h} - 1) + 1)</code>.
</p>


<h3>Value</h3>

<p>A matrix where each column is a model input and each row a sampling point.
</p>


<h3>References</h3>

<p>Razavi S, Gupta HV (2016).
&ldquo;A new framework for comprehensive, robust, and efficient global sensitivity analysis: 2. Application.&rdquo;
<em>Water Resources Research</em>, <b>52</b>(1), 440&ndash;455.
<a href="https://doi.org/10.1002/2015WR017558">doi:10.1002/2015WR017558</a>, 2014WR016527.<br /><br /> Sobol' IM (1967).
&ldquo;On the distribution of points in a cube and the approximate evaluation of integrals.&rdquo;
<em>USSR Computational Mathematics and Mathematical Physics</em>, <b>7</b>(4), 86&ndash;112.
<a href="https://doi.org/10.1016/0041-5553%2867%2990144-9">doi:10.1016/0041-5553(67)90144-9</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
star.centers &lt;- 10; params &lt;- paste("X", 1:5, sep = ""); h &lt;- 0.1

# Create STAR-VARS
mat &lt;- vars_matrices(star.centers = star.centers, params = params, h = h)
</code></pre>

<hr>
<h2 id='vars_to'>Computation of VARS Total order index (VARS-TO)</h2><span id='topic+vars_to'></span>

<h3>Description</h3>

<p>It computes VARS-TO following Razavi and Gupta (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars_to(Y, star.centers, params, h, method = "all.step")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vars_to_+3A_y">Y</code></td>
<td>
<p>A numeric vector with the model output obtained from the matrix created with
<code><a href="#topic+vars_matrices">vars_matrices</a></code>.</p>
</td></tr>
<tr><td><code id="vars_to_+3A_star.centers">star.centers</code></td>
<td>
<p>Positive integer, number of star centers.</p>
</td></tr>
<tr><td><code id="vars_to_+3A_params">params</code></td>
<td>
<p>Character vector with the name of the model inputs.</p>
</td></tr>
<tr><td><code id="vars_to_+3A_h">h</code></td>
<td>
<p>Distance between pairs.</p>
</td></tr>
<tr><td><code id="vars_to_+3A_method">method</code></td>
<td>
<p>Type of computation. If <code>method = "all.step"</code>, all pairs of points with values
<code class="reqn">\Delta h, 2\Delta h, 3\Delta h,...</code> are used in each dimension. If <code>method = "one.step"</code>,
only the pairs <code class="reqn">\Delta h</code> away are used. The default is <code>method = "all.step"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>VARS is based on variogram analysis to characterize the spatial structure and variability
of a given model output across the input space (Razavi and Gupta 2016). Variance-
based total-order effects can be computed as by-products of the VARS framework. The total-order index
is related to the variogram <code class="reqn">\gamma(.)</code> and co-variogram <code class="reqn">C(.)</code> functions by the
following equation:
</p>
<p style="text-align: center;"><code class="reqn">T_i = \frac{\gamma (h_i) + E \left [C_{\mathbf{x}_{\sim i}} (h_i) \right]}{\hat{V}(y)} </code>
</p>

<p>where <code class="reqn">x^*_{\sim i}</code> is a vector of all <code class="reqn">k</code> factors except <code class="reqn">x_i</code>.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> with the VARS-TO indices of each parameter.
</p>


<h3>References</h3>

<p>Razavi S, Gupta HV (2016).
&ldquo;A new framework for comprehensive, robust, and efficient global sensitivity analysis: 2. Application.&rdquo;
<em>Water Resources Research</em>, <b>52</b>(1), 440&ndash;455.
<a href="https://doi.org/10.1002/2015WR017558">doi:10.1002/2015WR017558</a>, 2014WR016527.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define settings
star.centers &lt;- 10; params &lt;- paste("X", 1:3, sep = ""); h &lt;- 0.1

# Create STAR-VARS
mat &lt;- vars_matrices(star.centers = star.centers, params = params, h = h)

# Run model
y &lt;- sensobol::ishigami_Fun(mat)

# Compute VARS-TO
ind &lt;- vars_to(Y = y, star.centers = star.centers, params = params, h = h)
ind
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
