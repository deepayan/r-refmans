<!DOCTYPE html><html lang="en"><head><title>Help for package profileModel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {profileModel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#confintModel'><p>Confidence intervals for model parameters</p></a></li>
<li><a href='#objectives-profileModel'><p>Objectives to be profiled</p></a></li>
<li><a href='#plot.profileModel'><p>Plot methods for &lsquo;profileModel&rsquo; objects</p></a></li>
<li><a href='#print.profileModel'><p>Printing &lsquo;profileModel&rsquo; objects</p></a></li>
<li><a href='#profileModel'><p>Get the profiles of arbitrary objectives for arbitrary &lsquo;glm&rsquo;-like</p>
models</a></li>
<li><a href='#signedSquareRoots'><p>Get the signed square roots of the profiles in &lsquo;profileModel&rsquo;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Profiling Inference Functions for Various Model Classes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ikosmidis/profileModel">https://github.com/ikosmidis/profileModel</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ikosmidis/profileModel/issues">https://github.com/ikosmidis/profileModel/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools that can be used to calculate, evaluate, plot and use for inference the profiles of *arbitrary* inference functions for *arbitrary* 'glm'-like fitted models with linear predictors. More information on the methods that are implemented can be found in Kosmidis (2008) <a href="https://www.r-project.org/doc/Rnews/Rnews_2008-2.pdf">https://www.r-project.org/doc/Rnews/Rnews_2008-2.pdf</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, gnm</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-08 16:34:01 UTC; yiannis</td>
</tr>
<tr>
<td>Author:</td>
<td>Ioannis Kosmidis <a href="https://orcid.org/0000-0003-1556-0302"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ioannis Kosmidis &lt;ioannis.kosmidis@warwick.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-08 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='confintModel'>Confidence intervals for model parameters</h2><span id='topic+confintModel'></span><span id='topic+profSmooth.profileModel'></span><span id='topic+profConfint.profileModel'></span><span id='topic+profZoom.profileModel'></span><span id='topic+profSmooth'></span><span id='topic+profConfint'></span><span id='topic+profZoom'></span>

<h3>Description</h3>

<p>Computes confidence intervals for one or more parameters in a fitted
model, based on the profiles of a specified objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confintModel(fitted, quantile = qchisq(0.95, 1), verbose = TRUE,
             endpoint.tolerance = 1e-3, max.zoom = 100,
             zero.bound = 1e-08, stepsize = 0.5, stdn = 5,
             gridsize = 20, scale = FALSE, which = 1:length(coef(fitted)),
             objective = stop("'objective' is missing."),
             agreement = TRUE, method = "smooth",
             n.interpolations = 100, ...)


## S3 method for class 'profileModel'
profConfint(prof, method = "smooth",
endpoint.tolerance = 1e-3, max.zoom = 100, n.interpolations = 100,
verbose = FALSE, ...)


## S3 method for class 'profileModel'
profZoom(prof, max.zoom = 100, endpoint.tolerance = 1e-03,
        verbose = FALSE, ...)

## S3 method for class 'profileModel'
profSmooth(prof, n.interpolations = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confintModel_+3A_fitted">fitted</code></td>
<td>
<p>a <code><a href="stats.html#topic+glm">glm</a></code>-like fitted object with <b>linear
predictor</b> (see Details of <code><a href="#topic+profileModel">profileModel</a></code> for the methods
that have to be supported by <code>fitted</code>).</p>
</td></tr>
<tr><td><code id="confintModel_+3A_prof">prof</code></td>
<td>
<p>a <code>"profileModel"</code> object with non-<code>NULL</code>
quantile.</p>
</td></tr>  <tr><td><code id="confintModel_+3A_quantile">quantile</code></td>
<td>
<p>The quantile to be used for the
construction of the confidence intervals. The default is qchisq(0.95,
1).</p>
</td></tr>
<tr><td><code id="confintModel_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default) progress indicators are
printed during the progress of calculating the confidence intervals.</p>
</td></tr>
<tr><td><code id="confintModel_+3A_endpoint.tolerance">endpoint.tolerance</code></td>
<td>
<p>the tolerance on the absolute difference of
the value of the profile at the endpoints from the quantile used. Only
relevant when confidence intervals are constructed via the &quot;profZoom&quot;
method (see Details).</p>
</td></tr>
<tr><td><code id="confintModel_+3A_max.zoom">max.zoom</code></td>
<td>
<p>the maximum number of iterations that the binary
search algorithm will take towards the achievement of
<code>endpoint.tolerance</code>.</p>
</td></tr>
<tr><td><code id="confintModel_+3A_zero.bound">zero.bound</code></td>
<td>
<p>same as in <code><a href="#topic+profileModel">profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="confintModel_+3A_stepsize">stepsize</code></td>
<td>
<p>same as in <code><a href="#topic+profileModel">profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="confintModel_+3A_stdn">stdn</code></td>
<td>
<p>same as in <code><a href="#topic+profileModel">profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="confintModel_+3A_gridsize">gridsize</code></td>
<td>
<p>same as in <code><a href="#topic+profileModel">profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="confintModel_+3A_scale">scale</code></td>
<td>
<p>same as in <code><a href="#topic+profileModel">profileModel</a></code>.</p>
</td></tr>  <tr><td><code id="confintModel_+3A_which">which</code></td>
<td>
<p>for
which parameters should the confidence intervals be calculated?</p>
</td></tr>
<tr><td><code id="confintModel_+3A_objective">objective</code></td>
<td>
<p>same as in <code><a href="#topic+profileModel">profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="confintModel_+3A_agreement">agreement</code></td>
<td>
<p>same as in <code><a href="#topic+profileModel">profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="confintModel_+3A_method">method</code></td>
<td>
<p>the method to be used for the calculation of the
confidence intervals. Possible values are &quot;smooth&quot;, which is the
default, and &quot;zoom&quot; (see Details).</p>
</td></tr>  <tr><td><code id="confintModel_+3A_n.interpolations">n.interpolations</code></td>
<td>
<p>if
<code>method="smooth"</code> the number of interpolations to be used for
spline smoothing. The default is 100.</p>
</td></tr>  <tr><td><code id="confintModel_+3A_...">...</code></td>
<td>
<p>for
<code>confintModel</code>, further arguments passed to the specified
objective. For the methods <code>profZoom</code>, <code>profSmooth</code> and
<code>profConfint</code>, further arguments passed to or from other
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence intervals methods refer to convex
objectives. Objectives that result in disjoint confidence regions are
not currently supported.
</p>
<p>When the profile object is available and was called with the
specification of the appropriate quantile then
<code>profConfint</code> should be used. <code>confintModel</code>
applies directly to the fitted model and calls <code>profileModel</code>.
</p>
<p>When <code>method="zoom"</code> the <code>profZoom</code> method is applied to the
<code>"profileModel"</code> object.   When <code>method="smooth"</code> the
<code>profSmooth</code> method is applied to the <code>"profileModel"</code> object.
</p>
<p>The <code>profZoom</code> method relies on a binary search and can find the
endpoints of the confidence intervals for a pre-specified tolerance
for the absolute difference of the value of the profile at each endpoint
from the quantile used. It is a computationally intensive method and is
useful in cases where the estimate is infinite and in coverage related
simulations.
</p>
<p>The <code>profSmooth</code> method, fits a smoothing spline on the points
specified by the <code>"profileModel"</code> object and then interpolates the
endpoints of the confidence intervals at the specified
<code>quantile</code>. It is much faster than <code>profZoom</code> and can safely
be used in cases where the profiled objective is nearly quadratic in
shape, but could be misleading otherwise.
</p>
<p>Both methods can report an infinite endpoint. The detection is based on the
<code>intersects</code> component of the <code>"profileModel"</code> object.
</p>
<p><code>profConfint</code> is a wrapper method that collects the capabilities
of <code>profZoom</code> and <code>profSmooth</code>.
</p>
<p><code>profSmooth</code>, <code>profZoom</code> and <code>profConfint</code> use the
quantile that comes with the <code>"profileModel"</code> object <code>prof</code>.
</p>


<h3>Value</h3>

<p>All the functions return a matrix with columns the endpoints of the
confidence intervals for the specified (or profiled) parameters.
</p>
<p>Additionally, <code>confintModel</code> and <code>profConfint</code> have
an attribute carrying the name of the fitted object and the name of the
<code>"profileModel"</code> object, respectively.
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis &lt;email: ioannis.kosmidis@warwick.ac.uk&gt;</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+confint">confint</a></code>, <code><a href="#topic+profileModel">profileModel</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Begin Example: quasi likelihood estimation.
## Incidence of leaf-blotch on barley
## McCullagh and Nelder (1989), pp. 328--332
library(gnm)
data(barley)
logitModel &lt;- glm(y ~ site + variety, family = wedderburn, data = barley)
profQuasi &lt;- profileModel(logitModel, objective = "ordinaryDeviance",
                          quantile=qchisq(0.95, 1),
                          which = paste("variety",c(2:9,"X"),sep=""))
# very accurate confidence intervals (with endpoints accurate up to 10
# decimals) for the variety parameters using profConfint with
# method="zoom":
c1 &lt;- profConfint(profQuasi, endpoint.tolerance = 1e-10, maxit = 100,
                  method="zoom" )
# confidence intervals using smoothing:
c2 &lt;- profConfint(profQuasi, method="smooth" )
# c2 has accurate endpoints at least up to four decimals
# this is because of the quadratic shape of the profiles
plot(profQuasi, cis = c1)
plot(profQuasi, cis = c1, signed = TRUE, print.grid.points = TRUE)
# pairs plot
pairs(profQuasi)
# Notice the direction of the pairs plots. The fact that the
# correlations among the estimates are 1/2 is clear.

# profiling using the Rao score statistic
# This can be used as deviance in cases were a quasi likelihood does not
# exist.
profRao &lt;- update(profQuasi, objective = "RaoScoreStatistic",
                  X = model.matrix(logitModel))
## End Example

## End(Not run)
</code></pre>

<hr>
<h2 id='objectives-profileModel'>Objectives to be profiled</h2><span id='topic+ordinaryDeviance'></span><span id='topic+RaoScoreStatistic'></span><span id='topic+objectives'></span>

<h3>Description</h3>

<p>Objectives to be used in <span class="pkg">profileModel</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinaryDeviance(fm, dispersion = 1)

RaoScoreStatistic(fm, X, dispersion = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="objectives-profileModel_+3A_fm">fm</code></td>
<td>
<p>the <b>restricted</b> fit.</p>
</td></tr>
<tr><td><code id="objectives-profileModel_+3A_x">X</code></td>
<td>
<p>the model matrix of the fit on all parameters.</p>
</td></tr>
<tr><td><code id="objectives-profileModel_+3A_dispersion">dispersion</code></td>
<td>
<p>the dispersion parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The objectives used in <span class="pkg">profileModel</span> have to be functions of the
<b>restricted</b> fit. Given a fitted object, the restricted fit is an
object resulted by restricting a parameter to a specific value and
then estimating the remaining parameters. Additional arguments
could be used and are passed to the objective matching the ... in
<code>profileModel</code> or in other associated functions. An objective
function should return a scalar which is the value of the objective at the
restricted fit.
</p>
<p>The construction of a custom objective should follow the above simple
guidelines (see also Example 3 in <code><a href="#topic+profileModel">profileModel</a></code> and the
sources of either <code>ordinaryDeviance</code> or <code>RaoScoreStatistic</code>).
</p>
<p><code>ordinaryDeviance</code> refers to <code><a href="stats.html#topic+glm">glm</a></code>-like objects. It takes as
input the restricted fit <code>fm</code> and optionally the value of the
dispersion parameter and returns the deviance corresponding to the
restricted fit divided by <code>dispersion</code>.
</p>
<p><code>RaoScoreStatistic</code> refers to <code><a href="stats.html#topic+glm">glm</a></code>-like objects. It returns
the value of the Rao score statistic
<code class="reqn">s(\beta)^Ti^{-1}(\beta)s(\beta)/\phi</code>, where <code class="reqn">s</code> is the vector of
estimating equations, <code class="reqn">\phi</code> is the dispersion parameter and
</p>
<p style="text-align: center;"><code class="reqn">i(\beta) = cov(s(\beta)) = X^T W(\beta) X/\phi ,</code>
</p>

<p>in standard GLM notation. The additional argument <code>X</code> is
the model  matrix of the full (<b>not</b> the restricted) fit. In this
way the original fit has always smaller or equal Rao score statistic
from any restricted fit. The Rao score statistic could be used for the
construction of confidence intervals when quasi-likelihood estimation
is used (see Lindsay and Qu, 2003).
</p>


<h3>Value</h3>

<p>A scalar.
</p>


<h3>Note</h3>

<p>Because the objective functions are evaluated many times in
<code><a href="#topic+profiling">profiling</a></code>, <code><a href="#topic+prelim.profiling">prelim.profiling</a></code> and
<code><a href="#topic+profileModel">profileModel</a></code>, they should be as computationally
efficient as possible.
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis &lt;email: ioannis.kosmidis@warwick.ac.uk&gt;</p>


<h3>References</h3>

<p>Lindsay, B. G. and Qu, A. (2003). Inference functions and quadratic
score tests. <em>Statistical Science</em> <b>18</b>, 394&ndash;410.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profiling">profiling</a></code>, <code><a href="#topic+prelim.profiling">prelim.profiling</a></code>, <code><a href="#topic+profileModel">profileModel</a></code>.</p>

<hr>
<h2 id='plot.profileModel'>Plot methods for &lsquo;profileModel&rsquo; objects</h2><span id='topic+plot.profileModel'></span><span id='topic+pairs.profileModel'></span>

<h3>Description</h3>

<p><code>plot.profileModel</code> plots the profiles contained in the profiled
object. <code>pairs.profileModel</code> is a diagnostic tool that plots
pairwise profile traces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profileModel'
plot(x, cis = NULL, signed = FALSE, interpolate = TRUE,
                  n.interpolations = 100, print.grid.points = FALSE,
                  title = NULL, ...)

## S3 method for class 'profileModel'
pairs(x, colours = 2:3, title=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.profileModel_+3A_x">x</code></td>
<td>
<p>a <code>"profileModel"</code> object.</p>
</td></tr>
<tr><td><code id="plot.profileModel_+3A_cis">cis</code></td>
<td>
<p>the confidence intervals resulted from
<code>profConfint(prof)</code>. The default is <code>NULL</code> where no
intervals are plotted. Only used in <code>plot.profileModel</code>.</p>
</td></tr>
<tr><td><code id="plot.profileModel_+3A_signed">signed</code></td>
<td>
<p>if <code>TRUE</code> the signed square roots of the values of
the profiled objective are plotted. The default is
<code>FALSE</code>. Available only in <code>plot.profileModel</code>.</p>
</td></tr>
<tr><td><code id="plot.profileModel_+3A_interpolate">interpolate</code></td>
<td>
<p>if <code>TRUE</code> spline interpolation is used in
order to get a smooth plot of the profiled objective. If <code>FALSE</code>
the points that are contained in the <code>"profileModel"</code> object are simply
joint by segments. The default is <code>TRUE</code>. Available only in
<code>plot.profileModel</code>.</p>
</td></tr>
<tr><td><code id="plot.profileModel_+3A_n.interpolations">n.interpolations</code></td>
<td>
<p>The number of interpolations to take place in
the profile range of each parameter. The default value is 100. It is
only used when <code>interpolate=TRUE</code>. Available only  in
<code>plot.profileModel</code>.</p>
</td></tr>
<tr><td><code id="plot.profileModel_+3A_print.grid.points">print.grid.points</code></td>
<td>
<p>logical indicating whether the points
contained in the <code>"profileModel"</code> object should be printed along
with the objective. The default is <code>FALSE</code>. Available only in
<code>plot.profileModel</code>.</p>
</td></tr>
<tr><td><code id="plot.profileModel_+3A_colours">colours</code></td>
<td>
<p>A vector of two elements indicating the colours to be used
for plotting pairwise profile traces. Available only in
<code>pairs.profileModel</code>.</p>
</td></tr>
<tr><td><code id="plot.profileModel_+3A_title">title</code></td>
<td>
<p>A character string to be displayed at the top of the
resultant plotting device. The default is <code>NULL</code> where nothing is
printed.</p>
</td></tr>
<tr><td><code id="plot.profileModel_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pairs.profileModel</code> is a minor modification of
<code>pairs.profile</code> in <span class="pkg">MASS</span> library. The modification was done
under the GPL licence 2 or greater and after the permission of the
authors, in order to comply with objects of class
<code>"profileModel"</code>. As in the description of <code>pairs.profile</code>
in Venables and Ripley (2002b),  <code>pairs.profileModel</code> shows the
lines that would join up the  points where the contours have
horizontal and vertical tangents, respectively, and the fine &lsquo;hairs&rsquo;
cutting the lines in the pairs plot are an indication of those
tangents.
</p>
<p>The pair plots should only be used for diagnostic purposes.
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis &lt;email: ioannis.kosmidis@warwick.ac.uk&gt;</p>


<h3>References</h3>

<p>Venables, W. N. and Ripley, B. D. (2002a). <em>Modern applied
statistics with S</em> (4th Edition). Springer.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002b). Statistics complements
to modern applied statistics with S (4th Edition). <br />
<a href="http://www.stats.ox.ac.uk/pub/MASS4/VR4stat.pdf">http://www.stats.ox.ac.uk/pub/MASS4/VR4stat.pdf</a>.
</p>
<p>Chambers, J. M. and Hastie, T. J. (1992) <em>Statistical Models in
S</em>. Chapman \&amp; Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profileModel">profileModel</a></code>, <code><a href="#topic+confintModel">confintModel</a></code>, <code><a href="MASS.html#topic+profile.glm">profile.glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># see example in 'confintModel'.
</code></pre>

<hr>
<h2 id='print.profileModel'>Printing &lsquo;profileModel&rsquo; objects</h2><span id='topic+print.profileModel'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>profileModel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profileModel'
print(x, print.fit = FALSE,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.profileModel_+3A_x">x</code></td>
<td>
<p>a <code>"profileModel"</code> object.</p>
</td></tr>
<tr><td><code id="print.profileModel_+3A_print.fit">print.fit</code></td>
<td>
<p>logical indicating whether the fitted object supplied
in <code><a href="#topic+profileModel">profileModel</a></code> should be printed. The default value is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="print.profileModel_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>print</code> method for objects inheriting from class
<code>"profileModel"</code>.
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis &lt;email: ioannis.kosmidis@warwick.ac.uk&gt;</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+profileModel">profileModel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Begin Example
y &lt;- c(1,1,0,0)
x1 &lt;- c(1,0,1,0)
x2 &lt;- c(1,1,0,0)
prof1 &lt;- profileModel(glm(y ~ x1 + x2, family = binomial),
                      objective = "ordinaryDeviance",
                      grid.bounds = rep(c(-1,1),3))
print(prof1)
prof2 &lt;- update(prof1, quantile = qchisq(0.95,1), grid.bounds=NULL)
print(prof2, print.fit = TRUE)
## End Example
</code></pre>

<hr>
<h2 id='profileModel'>Get the profiles of arbitrary objectives for arbitrary &lsquo;glm&rsquo;-like
models</h2><span id='topic+profileModel'></span><span id='topic+prelim.profiling'></span><span id='topic+profiling'></span>

<h3>Description</h3>

<p>Calculates the profiles of <b>arbitrary</b> objectives (inference functions
in the terminology of Lindsay and Qu, 2003) for the parameters of
<b>arbitrary</b> <code><a href="stats.html#topic+glm">glm</a></code>-like models with linear
predictor. It provides a variety of options such as profiling over a
pre-specified grid, profiling until the profile of the objective
reaches the values of a quantile, calculating the profile traces along
with the profiled objectives, and others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profileModel(fitted, gridsize = 20, stdn = 5, stepsize = 0.5,
             grid.bounds = NULL, quantile = NULL,
             objective = stop("'objective' is missing."),
             agreement = TRUE, verbose = TRUE, trace.prelim = FALSE,
             which = 1:length(coef(fitted)), profTraces = TRUE,
             zero.bound = 1e-08, scale = FALSE,
             stdErrors = NULL, ...)

prelim.profiling(fitted, quantile = qchisq(0.95, 1),
                 objective = stop("'objective' is missing."),
                 verbose = TRUE, which = 1:length(coef(fitted)),
                 stepsize = 0.5, stdn = 5, agreement = TRUE,
                 trace.prelim = FALSE,
                 stdErrors = NULL, ...)

profiling(fitted, grid.bounds, gridsize = 20, verbose = TRUE,
          objective = stop("'objective' is missing."),
          agreement = TRUE, which = 1:length(coef(fitted)),
          profTraces = TRUE, zero.bound = 1e-08, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profileModel_+3A_fitted">fitted</code></td>
<td>
<p>a <code><a href="stats.html#topic+glm">glm</a></code>-like fitted object with <b>linear
predictor</b> (see Details for the methods that have to be supported
by <code>fitted</code>).</p>
</td></tr>
<tr><td><code id="profileModel_+3A_which">which</code></td>
<td>
<p>which parameters should be profiled? Has to be a vector
of integers for <code>profiling</code> and <code>prelim.profiling</code> but for
<code>profileModel</code> it  could also be a vector of parameter
names. The default is <code>1:length(coef(fitted))</code>, i.e. all the
parameters estimated in <code>fitted</code>.</p>
</td></tr>
<tr><td><code id="profileModel_+3A_grid.bounds">grid.bounds</code></td>
<td>
<p>a matrix of dimension <code>length(which)</code> by <code>2</code> or a
<code>2*length(which)</code> vector that specifies the range of values in which
profiling takes place for each parameter. It has to be set for
<code>profiling</code> and the default is <code>NULL</code> for <code>profileModel</code></p>
</td></tr>
<tr><td><code id="profileModel_+3A_gridsize">gridsize</code></td>
<td>
<p>The number of equidistant parameter values to be taken
between the values specified in the entries of <code>grid.bounds</code>.</p>
</td></tr>
<tr><td><code id="profileModel_+3A_stepsize">stepsize</code></td>
<td>
<p>a positive integer that is used in
<code>prelim.profiling</code> to penalize the size of the steps taken to the left
and to the right of the estimate. The default value is 0.5.</p>
</td></tr>
<tr><td><code id="profileModel_+3A_stdn">stdn</code></td>
<td>
<p>in <code>profileModel</code>, the number of estimated standard
deviations to move left or right from the estimated parameter
value, when both <code>quantile</code> and <code>grid.bounds</code> are <code>NULL</code>. In
<code>prelim.profiling</code>, <code>stdn/stepsize</code> is the maximum number of
steps that are taken to the left and to the right of the estimate. The
default value of <code>stdn</code> is 5 (see Details).</p>
</td></tr>
<tr><td><code id="profileModel_+3A_quantile">quantile</code></td>
<td>
<p>a quantile, indicating the range that the profile must
cover. The default value in <code>profileModel</code> is <code>NULL</code> and in
<code>prelim.profiling</code>, <code>qchisq(0.95,1)</code> (see Details).</p>
</td></tr>
<tr><td><code id="profileModel_+3A_objective">objective</code></td>
<td>
<p>the function to be profiled. It is a function of the
<b>restricted</b> fitted object and other arguments (see
<code><a href="#topic+objectives">objectives</a></code>). It should be of class <code>function</code> for
<code>profiling</code> and <code>prelim.profiling</code> but it could also be a
character string to be matched for <code>profileModel</code>.</p>
</td></tr>
<tr><td><code id="profileModel_+3A_agreement">agreement</code></td>
<td>
<p>logical indicating whether the fitting method used
for <code>fitting</code> agrees  with the specified objective, i.e. whether
the objective is minimized at <code>coef(fitted)</code>. The default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="profileModel_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) progress indicators
are printed during  the profiling progress.</p>
</td></tr>
<tr><td><code id="profileModel_+3A_trace.prelim">trace.prelim</code></td>
<td>
<p>logical. If <code>TRUE</code> the preliminary iteration is
traced. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="profileModel_+3A_proftraces">profTraces</code></td>
<td>
<p>logical indicating whether the profile traces should
be returned. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="profileModel_+3A_zero.bound">zero.bound</code></td>
<td>
<p>a small positive constant. The difference of the
objective at the <b>restricted</b> fit from the objective at
<code>fitted</code> takes value zero if it is smaller than
<code>zero.bound</code>. <code>zero.bound</code> is only used when
<code>agreement=TRUE</code> and the default value is <code>1e-08</code>.</p>
</td></tr>
<tr><td><code id="profileModel_+3A_scale">scale</code></td>
<td>
<p>logical. The
default is <code>FALSE</code>. Currently has no effect. Only available in <code>profileModel</code>.</p>
</td></tr>
<tr><td><code id="profileModel_+3A_stderrors">stdErrors</code></td>
<td>
<p>The vector estimated asymptotic standard errors reported
from the fitting procedure. The default is <code>NULL</code> (see Details).</p>
</td></tr>
<tr><td><code id="profileModel_+3A_...">...</code></td>
<td>
<p>further arguments passed to the specified objective.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitted</code> has to be an object which supports the method

<code><a href="stats.html#topic+coef">coef</a></code> and which has <code>fitted$terms</code> with the same
meaning as, for example, in <code><a href="stats.html#topic+lm">lm</a></code> and
<code><a href="stats.html#topic+glm">glm</a></code> (see also <code><a href="stats.html#topic+terms">terms</a></code>). <code>coef(fitted)</code>
has to be a <b>vector</b> of coefficients with each component
corresponding to a column of the model matrix returned by
</p>
<p><code>mf &lt;- model.frame(fitted$terms,data=eval(fitted$call$data)) ;
  model.matrix(fitted$terms,mf,contrasts = fitted$contrasts)</code>
</p>
<p>(or just <code>model.matrix(fitted)</code>, for <code>fitted</code> objects that
support the <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> method.)
</p>
<p>Exception to this are objects returned by <code>BTm</code> of the
<span class="pkg">BradleyTerry</span> package, where some special handling of the required
objects takes place.
</p>
<p>Note that any or both of <code>data</code> and <code>contrasts</code> could be
<code>NULL</code>. This depends whether the <code>data</code> argument has been
supplied to the procedure and whether <code>fitted$contrast</code> exists.



</p>
<p>The fitting procedure that resulted <code>fitted</code> has to support
<code><a href="stats.html#topic+offset">offset</a></code> in <code><a href="stats.html#topic+formula">formula</a></code>.
Also, <code>fitted$call</code> has to be the call that generated <code>fitted</code>.
</p>
<p>If the fitting procedure that resulted <code>fitted</code>  supports an
<code>etastart</code> argument (see <code><a href="stats.html#topic+glm">glm</a></code>) and
<code>fitted$linear.predictor</code> contains the estimated linear
predictors then during profiling, the appropriate starting values
are supplied to the fitting procedure. In this way, the iteration is
accelerated and is more stable, numerically. However, it is not necessary
that <code>etastart</code> is supported. In the latter case no starting
values are supplied to the fitting procedure during profiling.
</p>
<p>Support for a <code><a href="base.html#topic+summary">summary</a></code> method is
optional. <code><a href="base.html#topic+summary">summary</a></code> is only used for obtaining the
estimated asymptotic standard errors associated to the coefficients in
<code>fitted</code>. If <code>stdErrors=NULL</code> the standard errors are taken
to be <code>summary(fitted)$coefficients[,2]</code> which is the place where
the estimated asymptotic standard errors usually are for
<code><a href="stats.html#topic+glm">glm</a></code>-like objects. If this this is not the case then
<code>stdErrors</code> should be set appropriately. <br /> <br />
</p>
<p><code>profiling</code> is the workhorse function that does the basic operation of
profiling objectives over a user-specified grid of values. For a given
parameter <code class="reqn">\beta</code>, the <b>restricted</b> fit
<code class="reqn">F_{\beta=b}</code> is calculated by constraining
<code class="reqn">\beta</code> to a point <code class="reqn">b</code> of the grid. Then the difference
</p>
<p style="text-align: center;"><code class="reqn">D(F_{\beta=b}) = P(F_{\beta=b}) - P(F_0),</code>
</p>

<p>is calculated, where <code class="reqn">P</code> is the objective specified by the user
and <code class="reqn">G</code> is the original fit (<code>fitted</code>). For convex
objectives that are minimized at the estimates of <code class="reqn">G</code> (see
<code>agreement</code>), <code class="reqn">D(G)=0</code>.
</p>
<p><code>prelim.profiling</code> refers only to convex objectives and searches for
and returns the grid bounds (<code>grid.bounds</code>) for each
profiled parameter that should be used in order the profile to cover
<code>quantile</code>. For a given parameter <code class="reqn">\beta</code>,
<code>prelim.profiling</code> also checks whether  such enclosure can be
found and returns a logical matrix <code>intersects</code> of dimension
<code>length(which)</code> by <code>2</code> that indicates if the profile covers the
quantile to the left and to the right of the estimate in
<code>fitted</code>. At step <code>i</code> of the search a value <code class="reqn">b_i</code> is
proposed for <code class="reqn">\beta</code> and <code class="reqn">D(F_{\beta=b_i})</code> is calculated. If
<code class="reqn">D(F_{\beta=b_i})&lt;q</code>, where <code class="reqn">q</code> is <code>quantile</code>, the next
proposed value is
</p>
<p style="text-align: center;"><code class="reqn">b_{i+1} = b_{i} \pm (i+1) C \min(s,30)/|L| ,</code>
</p>

<p>where <code class="reqn">C</code> is <code>stepsize</code>, <code class="reqn">s</code> is the
estimated asymptotic standard error of <code class="reqn">\beta</code> from <code class="reqn">G</code> and
<code class="reqn">L</code> is the slope of the line segment connecting the points
<code class="reqn">(b_i, D(F_{\beta=b_i}))</code> and
<code class="reqn">(b_{i-1}, D(F_{\beta=b_{i-1}}))</code>. <code class="reqn">\pm</code> is <code class="reqn">+</code> if the search is on the
right of the estimate of <code class="reqn">\beta</code> and <code class="reqn">-</code> on the left. If an
increase of <code class="reqn">D</code> is expected then the step slows down. If
<code class="reqn">|L|&lt;1</code> then <code class="reqn">|L|</code> is set to 1 and if
<code class="reqn">|L|&gt;500</code> then <code class="reqn">|L|</code>  is set to 500. In
this way the iteration is conservative by avoiding very small steps
but not over-conservative by avoiding very large steps.
</p>
<p>If the maximum number of steps <code>stdn/stepsize</code> (call this <code class="reqn">M</code>)
was taken and the quantile was not covered by the profile but the three
last absolute slopes where  positive then the iteration is restarted
form <code class="reqn">b_{M-1}</code> with <code class="reqn">2C</code> instead of <code class="reqn">C</code> in the step
calculation. If the three last slopes were less than <code>1e-8</code> in
absolute value then the iteration stops and it is considered that
<code class="reqn">D</code> has an asymptote at the corresponding direction (left or right).
Note that when the latter takes place the iteration has already moved
<code class="reqn">6 C\min(s,30)</code> units on the scale of <code class="reqn">\beta</code>,
since the first value of <code class="reqn">b</code> were a slope of 1e-8 in absolute value
was detected. Thus we could safely say that an asymptote has been
detected and avoid calculation of <code class="reqn">F_{beta=b}</code> for
extremely large <code class="reqn">b</code>'s.
</p>
<p>Very small values of <code>stepsize</code> make <code>prelim.profiling</code> take
very small steps with the effect of slowing down the execution
time. Large values of <code>stepsize</code> are only recommended when the
estimated asymptotic standard errors are very small in <code>fitted</code>.
</p>
<p><code>profileModel</code> is a wrapper function that collects and combines
the capabilities of <code>profiling</code> and <code>prelim.profiling</code> by
providing a unified interface for their functions, as well as appropriateness
checks on the arguments. When both <code>quantile</code>  and
<code>grid.bounds</code> are <code>NULL</code> then <code>profiling</code> is called and
profiling takes place for <code>stdn</code> estimated asymptotic standard
errors on the left and on the right of the estimates in
<code>fitted</code>. This could be used for taking a quick look of the
profiles around the estimate. With only the <code>quantile</code> being
<code>NULL</code>, profiling is performed on the the specified grid of
values. When <code>quantile</code> is specified and <code>grid.bounds</code> is
<code>NULL</code>, <code>prelim.profiling</code> is  called and its result is
passed to <code>profiling</code>. If both <code>quantile</code> and
<code>grid.bounds</code> then <code>grid.bounds</code> prevails and profiling is
performed on the specified grid.
</p>


<h3>Value</h3>

<p><code>profiling</code> returns a list of profiles, with one named component
for each parameter profiled. Each component of
the list contains the profiled parameter values and the corresponding
differences of the objective at the <b>restricted</b> fit from the
objective at <code>fitted</code>. When <code>profTraces=TRUE</code> the corresponding
profile traces are <code><a href="base.html#topic+cbind">cbind</a></code>'ed to each component of the
list.
</p>
<p><code>prelim.profiling</code> returns a list with components
<code>intersects</code> and <code>grid.bounds</code>.
</p>
<p><code>profileModel</code> returns an object of class <code>"profileModel"</code>
that has the attribute <code>includes.traces</code> corresponding to the
value of the <code>profTraces</code> argument. The <code>"profileModel"</code>
object is a  list of the following components:
</p>
<table role = "presentation">
<tr><td><code>profiles</code></td>
<td>
<p>the result of <code>profiling</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the <code>fitted</code> object that was passed to
<code>profileModel</code>.</p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>the <code>quantile</code> that was passed to
<code>profileModel</code>.</p>
</td></tr>
<tr><td><code>gridsize</code></td>
<td>
<p>the <code>gridsize</code> that was passed to
<code>profileModel</code>.</p>
</td></tr>
<tr><td><code>intersects</code></td>
<td>
<p>if <code>quantile=NULL</code> then
<code>intersects=NULL</code> else <code>intersects</code> is as for
<code>prelim.profiling</code>.</p>
</td></tr>
<tr><td><code>profiled.parameters</code></td>
<td>
<p>a vector of integers indicating which
parameters were profiled.</p>
</td></tr>
<tr><td><code>profiled.objective</code></td>
<td>
<p>the profiled objective with any additional
arguments passed through <code>...</code> evaluated.</p>
</td></tr>
<tr><td><code>isNA</code></td>
<td>
<p>a logical vector indicating which of the parameters in
<code>which</code> were <code>NA</code> in <code>fitted</code>.</p>
</td></tr>
<tr><td><code>agreement</code></td>
<td>
<p>the <code>agreement</code> that was passed to
<code>profileModel</code>.</p>
</td></tr>
<tr><td><code>zero.bound</code></td>
<td>
<p>the <code>zero.bound</code> that was passed to
<code>profileModel</code>.</p>
</td></tr>
<tr><td><code>grid.bounds</code></td>
<td>
<p>the grid bounds that were used for profiling.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Methods specific to objects of class <code>"profileModel"</code> are
</p>

<ul>
<li> <p><code>print</code>, see <code><a href="#topic+print.profileModel">print.profileModel</a></code>.
</p>
</li>
<li> <p><code>signedSquareRoots</code>, see <code><a href="#topic+signedSquareRoots">signedSquareRoots</a></code>.
</p>
</li>
<li> <p><code>profConfint</code>, see <code><a href="#topic+profConfint">profConfint</a></code>.
</p>
</li>
<li> <p><code>plot</code>, see <code><a href="#topic+plot.profileModel">plot.profileModel</a></code>.
</p>
</li>
<li> <p><code>pairs</code>, see <code><a href="#topic+pairs.profileModel">pairs.profileModel</a></code>.
</p>
</li></ul>

<p><code>profileModel</code> has been tested and is known to work for fitted
objects resulting from  <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>,
<code>polr</code>, <code>gee</code>, <code>geeglm</code>, <code>brglm</code> and <code>BTm</code>.
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis &lt;email: ioannis.kosmidis@warwick.ac.uk&gt;</p>


<h3>References</h3>

<p>Lindsay, B. G. and Qu, A. (2003). Inference functions and quadratic
score tests. <em>Statistical Science</em> <b>18</b>, 394&ndash;410.
</p>
<p>Chambers, J. M. and Hastie, T. J. (1992) <em>Statistical Models in
S</em>. Chapman \&amp; Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confintModel">confintModel</a></code>, <code><a href="#topic+plot.profileModel">plot.profileModel</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Begin Example 1
library(MASS)
m1 &lt;- glm(Claims ~ District + Group + Age + offset(log(Holders)),
          data = Insurance, family = poisson)
# profile deviance +-5 estimated standard errors from the estimate
prof0 &lt;- profileModel(m1, objective = "ordinaryDeviance")
# profile deviance over a grid of values
gridd &lt;- rep(c(-1,1), length(coef(m1)))
prof1 &lt;- profileModel(m1, grid.bounds = gridd,
                      objective = "ordinaryDeviance")
# profile deviance until the profile reaches qchisq(0.95,1)
prof2 &lt;- profileModel(m1, quantile = qchisq(0.95,1) ,
                      objective = "ordinaryDeviance")
# plot the profiles of the deviance
plot(prof2)
# quite quadratic in shape. Just to make sure:
plot(prof2, signed = TRUE)
# Ok straight lines. So we expect first order asymptotics to work well;
## Not run: 
# plot the profiles of the Rao score statistic
# profile Rao's score statistic
prof3 &lt;- update(prof2, objective = "RaoScoreStatistic",
                X = model.matrix(m1))
plot(prof3)
# The 95% confidence intervals based on prof2 and prof3 and the simple Wald
# confidence intervals:
profConfint(prof2)
profConfint(prof3)
stdErrors &lt;- coef(summary(m1))[,2]
coef(m1)+ qnorm(0.975) * cbind(-stdErrors,stdErrors)
# They are all quite similar in value. The result of a quadratic likelihood.
## End Example

## End(Not run)
## Begin Example 2: Monotone likelihood; data separation;
library(MASS)
y &lt;- c(0, 0, 1, 0)
tots &lt;- c(2, 2, 5, 2)
x1 &lt;- c(1, 0, 1, 0)
x2 &lt;- c(1, 1, 0, 0)
m2 &lt;- glm(y/tots ~ x1 + x2, weights = tots,
          family = binomial)
prof &lt;- profileModel(m2, quantile=qchisq(0.95,1),
                     objective = "ordinaryDeviance")
plot(prof)
profConfint(prof)
# profile.glm fails to detect the finite endpoints
confint(m2)
## End Example
## Not run: 
## Begin Example 3: polr
library(MASS)
options(contrasts = c("contr.treatment", "contr.poly"))
house.plr &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
prof.plr0 &lt;- profileModel(house.plr, objective = function(fm) fm$deviance)
plot(prof.plr0)
# do it with a quantile
prof.plr1 &lt;- update(prof.plr0, quantile = qchisq(0.95, 1))
plot(prof.plr1)
## End Example

## End(Not run)
</code></pre>

<hr>
<h2 id='signedSquareRoots'>Get the signed square roots of the profiles in &lsquo;profileModel&rsquo;</h2><span id='topic+signedSquareRoots.profileModel'></span><span id='topic+signedSquareRoots'></span>

<h3>Description</h3>

<p>Convert a <code>"profileModel"</code> object to contain the signed square
roots of the profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profileModel'
signedSquareRoots(prof)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signedSquareRoots_+3A_prof">prof</code></td>
<td>
<p>a <code>"profileModel"</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>signedSquareRoots</code> takes as input a <code>"profileModel"</code> object
and  results to another <code>"profileModel"</code> object that contains the
signed square roots of the profiled differences. The method only
applies if <code>agreement</code> is set to <code>TRUE</code> in <code>prof$call</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"profileModel"</code>.
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis &lt;email: ioannis.kosmidis@warwick.ac.uk&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.profileModel">plot.profileModel</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
