<!DOCTYPE html><html><head><title>Help for package RNiftyReg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RNiftyReg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#applyTransform'><p>Apply a precomputed transformation</p></a></li>
<li><a href='#buildAffine'><p>Build an affine matrix up from its constituent transformations</p></a></li>
<li><a href='#composeTransforms'><p>Compose transformations</p></a></li>
<li><a href='#decomposeAffine'><p>Decompose an affine matrix into its constituent transformations</p></a></li>
<li><a href='#deformationField'><p>Calculate the deformation field for a transformation</p></a></li>
<li><a href='#forward'><p>Extract forward and reverse transformations</p></a></li>
<li><a href='#halfTransform'><p>Calculate a half transformation</p></a></li>
<li><a href='#invertAffine'><p>Invert an affine matrix</p></a></li>
<li><a href='#isAffine'><p>Create, test for and print affine matrices</p></a></li>
<li><a href='#isImage'><p>Test whether an object represents an image</p></a></li>
<li><a href='#jacobian'><p>Extract a Jacobian determinant map</p></a></li>
<li><a href='#niftyreg'><p>Two and three dimensional image registration</p></a></li>
<li><a href='#niftyreg.linear'><p>Two and three dimensional linear image registration</p></a></li>
<li><a href='#niftyreg.nonlinear'><p>Two and three dimensional nonlinear image registration</p></a></li>
<li><a href='#readAffine'><p>Read an affine matrix from a file</p></a></li>
<li><a href='#readNifti'><p>Read a NIfTI format file</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#saveTransform'><p>Save and load transform objects</p></a></li>
<li><a href='#similarity'><p>Similarity measures between images</p></a></li>
<li><a href='#translate'><p>Apply simple transformations</p></a></li>
<li><a href='#writeAffine'><p>Write an affine matrix to a file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.8.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-17</td>
</tr>
<tr>
<td>Title:</td>
<td>Image Registration Using the 'NiftyReg' Library</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jon Clayden &lt;code@clayden.org&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, RNifti, ore</td>
</tr>
<tr>
<td>Suggests:</td>
<td>jpeg, loder, mmand, tinytest, covr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, RNifti</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an 'R' interface to the 'NiftyReg' image registration tools
    <a href="https://github.com/KCL-BMEIS/niftyreg">https://github.com/KCL-BMEIS/niftyreg</a>. Linear and nonlinear registration
    are supported, in two and three dimensions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jonclayden/RNiftyReg">https://github.com/jonclayden/RNiftyReg</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jonclayden/RNiftyReg/issues">https://github.com/jonclayden/RNiftyReg/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-20 19:39:12 UTC; jon</td>
</tr>
<tr>
<td>Author:</td>
<td>Jon Clayden <a href="https://orcid.org/0000-0002-6608-0619"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut],
  Marc Modat [aut],
  Benoit Presles [aut],
  Thanasis Anthopoulos [aut],
  Pankaj Daga [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-20 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='applyTransform'>Apply a precomputed transformation</h2><span id='topic+applyTransform'></span>

<h3>Description</h3>

<p>This function allows a precomputed transformation to be applied to a new
image or set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyTransform(transform, x, interpolation = 3L, nearest = FALSE,
  internal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyTransform_+3A_transform">transform</code></td>
<td>
<p>A transform, possibly obtained from <code><a href="#topic+forward">forward</a></code>
or <code><a href="#topic+reverse">reverse</a></code>.</p>
</td></tr>
<tr><td><code id="applyTransform_+3A_x">x</code></td>
<td>
<p>A numeric vector, representing a pixel/voxel location in source
space, or a matrix with rows representing such points, or an image with
the same dimensions as the original source image.</p>
</td></tr>
<tr><td><code id="applyTransform_+3A_interpolation">interpolation</code></td>
<td>
<p>A single integer specifying the type of interpolation
to be applied to the final resampled image. May be 0 (nearest neighbour),
1 (trilinear) or 3 (cubic spline). No other values are valid.</p>
</td></tr>
<tr><td><code id="applyTransform_+3A_nearest">nearest</code></td>
<td>
<p>Logical value: if <code>TRUE</code> and <code>x</code> contains points,
the nearest voxel centre location in target space will be returned.
Otherwise a more precise subvoxel location will be given.</p>
</td></tr>
<tr><td><code id="applyTransform_+3A_internal">internal</code></td>
<td>
<p>If <code>FALSE</code>, the default, the returned image will be
returned as a standard R array. If <code>TRUE</code>, it will instead be an
object of class <code>"internalImage"</code>, containing only basic metadata and
a C-level pointer to the full image. (See also <code><a href="#topic+readNifti">readNifti</a></code>.)
This can occasionally be useful to save memory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Points may be transformed from source to target space exactly under an
affine transformation, but nonlinear transformation is inexact. Its accuracy
will depend to some extent on the density of the control point grid and the
geometry of the deformation in the vicinity of the points of interest.
Nevertheless, it should be quite sufficient for most purposes.
</p>
<p>The method is to first convert the control points to a deformation field
(cf. <code><a href="#topic+deformationField">deformationField</a></code>), which encodes the location of each
target space voxel in the source space. The target voxel closest to the
requested location is found by searching through this deformation field, and
returned if <code>nearest</code> is <code>TRUE</code> or it coincides exactly with the
requested location. Otherwise, a block of four voxels in each dimension
around the point of interest is extracted from the deformation field, and
the final location is estimated by local cubic spline regression.
</p>


<h3>Value</h3>

<p>A resampled image or matrix of transformed points.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niftyreg.linear">niftyreg.linear</a></code>, <code><a href="#topic+niftyreg.nonlinear">niftyreg.nonlinear</a></code>
</p>

<hr>
<h2 id='buildAffine'>Build an affine matrix up from its constituent transformations</h2><span id='topic+buildAffine'></span>

<h3>Description</h3>

<p>This function does the opposite to <code><a href="#topic+decomposeAffine">decomposeAffine</a></code>, building
up an affine matrix from its components. It can be useful for testing, or
for rescaling images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildAffine(translation = c(0, 0, 0), scales = c(1, 1, 1), skews = c(0,
  0, 0), angles = c(0, 0, 0), source = NULL, target = NULL,
  anchor = c("none", "origin", "centre", "center"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildAffine_+3A_translation">translation</code></td>
<td>
<p>Translations along each axis, in <code><a href="#topic+pixunits">pixunits</a></code>
units. May also be a list, such as that produced by
<code><a href="#topic+decomposeAffine">decomposeAffine</a></code>, with elements for translation, scales,
skews and angles.</p>
</td></tr>
<tr><td><code id="buildAffine_+3A_scales">scales</code></td>
<td>
<p>Scale factors along each axis.</p>
</td></tr>
<tr><td><code id="buildAffine_+3A_skews">skews</code></td>
<td>
<p>Skews in the XY, XZ and YZ planes.</p>
</td></tr>
<tr><td><code id="buildAffine_+3A_angles">angles</code></td>
<td>
<p>Roll, pitch and yaw rotation angles, in radians. If
<code>source</code> is two-dimensional, a single angle will be interpreted as
being in the plane as expected.</p>
</td></tr>
<tr><td><code id="buildAffine_+3A_source">source</code></td>
<td>
<p>The source image for the transformation (required).</p>
</td></tr>
<tr><td><code id="buildAffine_+3A_target">target</code></td>
<td>
<p>The target image for the transformation. If <code>NULL</code> (the
default), it will be equal to <code>source</code>, or a rescaled version of it
if any of the <code>scales</code> are not 1. In the latter case the scales will
be reset back to 1 to produce the right effect.</p>
</td></tr>
<tr><td><code id="buildAffine_+3A_anchor">anchor</code></td>
<td>
<p>The fixed point for the transformation. Setting this parameter
to a value other than <code>"none"</code> will override the <code>translation</code>
parameter, with the final translation set to ensure that the requested
point remains in the same place after transformation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 4x4 affine matrix representing the composite transformation. Note
that NiftyReg affines logically transform backwards, from target to source
space, so the matrix may be the inverse of what is expected.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decomposeAffine">decomposeAffine</a></code>, <code><a href="#topic+isAffine">isAffine</a></code>
</p>

<hr>
<h2 id='composeTransforms'>Compose transformations</h2><span id='topic+composeTransforms'></span>

<h3>Description</h3>

<p>Compute the composition of two or more transforms, the single transform that
combines their effects in order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>composeTransforms(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="composeTransforms_+3A_...">...</code></td>
<td>
<p>Affine or nonlinear transforms, possibly obtained from
<code><a href="#topic+forward">forward</a></code> or <code><a href="#topic+reverse">reverse</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The composed transform. If all arguments are affines then the result
will also be an affine; otherwise it will be a deformation field.
</p>


<h3>Note</h3>

<p>The source image for the composed transform is generally the source
image from the first transform, and the target is the target image from
the second transform. However, the target image attached to half
transforms (as calculated by <code><a href="#topic+halfTransform">halfTransform</a></code>) generally has a
modified xform, compared to the original target. Therefore, composing a
half transform with itself may not be exactly equivalent to the original.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niftyreg.linear">niftyreg.linear</a></code>, <code><a href="#topic+niftyreg.nonlinear">niftyreg.nonlinear</a></code>,
<code><a href="#topic+deformationField">deformationField</a></code>
</p>

<hr>
<h2 id='decomposeAffine'>Decompose an affine matrix into its constituent transformations</h2><span id='topic+decomposeAffine'></span>

<h3>Description</h3>

<p>An affine matrix is composed of translation, scale, skew and rotation
transformations. This function extracts these components, after first
inverting the matrix so that it transforms from source to target space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposeAffine(affine)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomposeAffine_+3A_affine">affine</code></td>
<td>
<p>A 4x4 matrix representing an affine transformation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>

<dl>
<dt>scaleMatrix</dt><dd><p>A 3x3 matrix representing only the scale operation
embodied in the full affine transformation.</p>
</dd>
<dt>skewMatrix</dt><dd><p>A 3x3 matrix representing only the skew operation
embodied in the full affine transformation.</p>
</dd>
<dt>rotationMatrix</dt><dd><p>A 3x3 matrix representing only the rotation
operation embodied in the full affine transformation.</p>
</dd>
<dt>translation</dt><dd><p>A length-3 named numeric vector representing the
translations (in <code><a href="#topic+pixunits">pixunits</a></code> units) in each of the X, Y and
Z directions.</p>
</dd>
<dt>scales</dt><dd><p>A length-3 named numeric vector representing the scale
factors in each of the X, Y and Z directions. Scale factors of 1
represent no effect.</p>
</dd>
<dt>skews</dt><dd><p>A length-3 named numeric vector representing the skews in
each of the XY, XZ and YZ planes.</p>
</dd>
<dt>angles</dt><dd><p>A length-3 named numeric vector representing the rotation
angles (in radians) about each of the X, Y and Z directions, i.e.,
roll, pitch and yaw.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The decomposition is not perfect, and there is one particular
degenerate case when the pitch angle is very close to <code>pi/2</code> radians,
known as &ldquo;Gimbal lock&rdquo;. In this case the yaw angle is arbitrarily set to
zero.
</p>
<p>Affine matrices embodying rigid-body transformations include only 6
degrees of freedom, rather than the full 12, so skews will always be zero
and scales will always be unity (to within rounding error). Likewise,
affine matrices derived from 2D registration will not include components
relating to the Z direction.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildAffine">buildAffine</a></code>, <code><a href="#topic+isAffine">isAffine</a></code>
</p>

<hr>
<h2 id='deformationField'>Calculate the deformation field for a transformation</h2><span id='topic+deformationField'></span>

<h3>Description</h3>

<p>This function is used to calculate the deformation field corresponding to a
specified linear or nonlinear transformation. The deformation field gives
the location in source image space corresponding to the centre of each voxel
in target space. It is used as a common form for linear and nonlinear
transformations, and allows them to be visualised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deformationField(transform, jacobian = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deformationField_+3A_transform">transform</code></td>
<td>
<p>A transform, possibly obtained from <code><a href="#topic+forward">forward</a></code>
or <code><a href="#topic+reverse">reverse</a></code>.</p>
</td></tr>
<tr><td><code id="deformationField_+3A_jacobian">jacobian</code></td>
<td>
<p>A logical value: if <code>TRUE</code>, a Jacobian determinant map
is also calculated and returned in an attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>"internalImage"</code> representing the deformation field. If
requested, the Jacobian map is stored in an attribute, which can be
extracted using the <code><a href="#topic+jacobian">jacobian</a></code> accessor function.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niftyreg.linear">niftyreg.linear</a></code>, <code><a href="#topic+niftyreg.nonlinear">niftyreg.nonlinear</a></code>
</p>

<hr>
<h2 id='forward'>Extract forward and reverse transformations</h2><span id='topic+forward'></span><span id='topic+forward.niftyreg'></span><span id='topic+reverse'></span><span id='topic+reverse.niftyreg'></span>

<h3>Description</h3>

<p>These functions extract forward and reverse transformations in a form
compatible with <code><a href="#topic+applyTransform">applyTransform</a></code> and other functions. They are
(S3) generic, but only methods for <code>"niftyreg"</code> objects currently
exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward(object, ...)

## S3 method for class 'niftyreg'
forward(object, i = 1L, ...)

reverse(object, ...)

## S3 method for class 'niftyreg'
reverse(object, i = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forward_+3A_object">object</code></td>
<td>
<p>An R object.</p>
</td></tr>
<tr><td><code id="forward_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not currently used.</p>
</td></tr>
<tr><td><code id="forward_+3A_i">i</code></td>
<td>
<p>The transformation number to extract. There will only be more than
one in the case of multiple registration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transformation object, an image or affine matrix, with suitable
attributes giving pointers to source and target images. If there is no
transformation information in the object then <code>NULL</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niftyreg">niftyreg</a></code>, <code><a href="#topic+applyTransform">applyTransform</a></code>
</p>

<hr>
<h2 id='halfTransform'>Calculate a half transformation</h2><span id='topic+halfTransform'></span>

<h3>Description</h3>

<p>This function calculates the half-way transformation corresponding to its
argument. Applying this transformation results in points or images in a
space halfway between the original source and target images, which can be a
useful common space in some applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>halfTransform(transform)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="halfTransform_+3A_transform">transform</code></td>
<td>
<p>A transform, possibly obtained from <code><a href="#topic+forward">forward</a></code>
or <code><a href="#topic+reverse">reverse</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The half-way transform, in a similar format to <code>transform</code>.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niftyreg.linear">niftyreg.linear</a></code>, <code><a href="#topic+niftyreg.nonlinear">niftyreg.nonlinear</a></code>
</p>

<hr>
<h2 id='invertAffine'>Invert an affine matrix</h2><span id='topic+invertAffine'></span>

<h3>Description</h3>

<p>This function is used to invert an affine matrix. It is a wrapper around
<code><a href="base.html#topic+solve">solve</a></code>, which additionally sets appropriate attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invertAffine(affine)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invertAffine_+3A_affine">affine</code></td>
<td>
<p>An existing 4x4 affine matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inverted affine matrix.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+solve">solve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>affine &lt;- readAffine(system.file("extdata","affine.txt",package="RNiftyReg"))
print(affine)
print(invertAffine(affine))

</code></pre>

<hr>
<h2 id='isAffine'>Create, test for and print affine matrices</h2><span id='topic+isAffine'></span><span id='topic+affine'></span><span id='topic+asAffine'></span><span id='topic+asAffine.niftyreg'></span><span id='topic+asAffine.niftyregRDS'></span><span id='topic+asAffine.affine'></span><span id='topic+asAffine.niftiImage'></span><span id='topic+asAffine.default'></span><span id='topic+print.affine'></span>

<h3>Description</h3>

<p><code>isAffine</code> returns a logical value indicating whether its argument is,
or resembles, a 4x4 affine matrix. <code>asAffine</code> converts other objects to
the affine class, attaching or updating the source and target image
attributes. Affine transformations are a class of linear transformations
which preserve points, straight lines and planes, and may consist of a
combination of rotation, translation, scale and skew operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isAffine(object, strict = FALSE)

asAffine(object, source = NULL, target = NULL, ...)

## S3 method for class 'niftyreg'
asAffine(object, source = NULL, target = NULL, i = 1L,
  ...)

## S3 method for class 'niftyregRDS'
asAffine(object, source = NULL, target = NULL, ...)

## S3 method for class 'affine'
asAffine(object, source = NULL, target = NULL, ...)

## S3 method for class 'niftiImage'
asAffine(object, source = attr(object, "source"),
  target = attr(object, "target"), ...)

## Default S3 method:
asAffine(object, source = NULL, target = NULL, ...)

## S3 method for class 'affine'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isAffine_+3A_object">object</code></td>
<td>
<p>An R object.</p>
</td></tr>
<tr><td><code id="isAffine_+3A_strict">strict</code></td>
<td>
<p>If <code>TRUE</code>, this function just tests whether the object is
of class <code>"affine"</code>. Otherwise it also tests for an affine-like 4x4
matrix.</p>
</td></tr>
<tr><td><code id="isAffine_+3A_source">source</code>, <code id="isAffine_+3A_target">target</code></td>
<td>
<p>New source and target images for the transformation.</p>
</td></tr>
<tr><td><code id="isAffine_+3A_...">...</code></td>
<td>
<p>Additional parameters to methods.</p>
</td></tr>
<tr><td><code id="isAffine_+3A_i">i</code></td>
<td>
<p>The transformation number, for <code>niftyreg</code> objects containing
more than one.</p>
</td></tr>
<tr><td><code id="isAffine_+3A_x">x</code></td>
<td>
<p>An <code>"affine"</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NiftyReg's convention is for affine matrices to transform world coordinates
(in the sense of <code>voxelToWorld</code>) from TARGET to SOURCE space, although
transforms are logically applied the other way.
</p>


<h3>Value</h3>

<p>For <code>isAffine</code>, a logical value, which is <code>TRUE</code> if
<code>object</code> appears to be an affine matrix. For <code>asAffine</code>, a
classed affine object with source and target attributes set appropriately.
</p>


<h3>Note</h3>

<p>2D affines are a subset of 3D affines, and are stored in a 4x4 matrix
for internal consistency, even though a 3x3 matrix would suffice.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>

<hr>
<h2 id='isImage'>Test whether an object represents an image</h2><span id='topic+isImage'></span>

<h3>Description</h3>

<p>This function tried to determine whether an object is an image that the
package knows how to handle. If its class is <code>"nifti"</code>,
<code>"niftiImage"</code>, <code>"internalImage"</code> or <code>"MriImage"</code>, then the
result is always <code>TRUE</code>. Likewise if it has an internal image pointer.
If it has no <code>dim</code> attribute, or looks like an affine matrix, then the
result is <code>FALSE</code>. Otherwise the value of the <code>unsure</code> argument
is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isImage(object, unsure = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isImage_+3A_object">object</code></td>
<td>
<p>An R object.</p>
</td></tr>
<tr><td><code id="isImage_+3A_unsure">unsure</code></td>
<td>
<p>The value to return if the function can't tell whether or not
the <code>object</code> is an image.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>

<hr>
<h2 id='jacobian'>Extract a Jacobian determinant map</h2><span id='topic+jacobian'></span>

<h3>Description</h3>

<p>This function extracts the Jacobian determinant map associated with a
deformation field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacobian(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jacobian_+3A_x">x</code></td>
<td>
<p>An R object, probably a deformation field.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deformationField">deformationField</a></code>
</p>

<hr>
<h2 id='niftyreg'>Two and three dimensional image registration</h2><span id='topic+niftyreg'></span><span id='topic+asNifti.niftyreg'></span><span id='topic+as.array.niftyreg'></span>

<h3>Description</h3>

<p>The <code>niftyreg</code> function performs linear or nonlinear registration for
two and three dimensional images. 4D images may also be registered
volumewise to a 3D image, or 3D images slicewise to a 2D image. This
function is a common wrapper for <code><a href="#topic+niftyreg.linear">niftyreg.linear</a></code> and
<code><a href="#topic+niftyreg.nonlinear">niftyreg.nonlinear</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niftyreg(source, target, scope = c("affine", "rigid", "nonlinear"),
  init = NULL, sourceMask = NULL, targetMask = NULL, symmetric = TRUE,
  interpolation = 3L, estimateOnly = FALSE, sequentialInit = FALSE,
  internal = NA, precision = c("double", "single"),
  threads = getOption("RNiftyReg.threads"), ...)

## S3 method for class 'niftyreg'
asNifti(x, ...)

## S3 method for class 'niftyreg'
as.array(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niftyreg_+3A_source">source</code></td>
<td>
<p>The source image, an object of class <code>"nifti"</code> or
<code>"internalImage"</code>, or a plain array, or a NIfTI-1 filename. Must have
2, 3 or 4 dimensions.</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_target">target</code></td>
<td>
<p>The target image, an object of class <code>"nifti"</code> or
<code>"internalImage"</code>, or a plain array, or a NIfTI-1 filename. Must have
2 or 3 dimensions.</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_scope">scope</code></td>
<td>
<p>A string describing the scope, or number of degrees of freedom
(DOF), of the registration. The currently supported values are
<code>"affine"</code> (12 DOF), <code>"rigid"</code> (6 DOF) or <code>"nonlinear"</code>
(high DOF, with the exact number depending on the image sizes).</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_init">init</code></td>
<td>
<p>Transformation(s) to be used for initialisation, which may be
<code>NULL</code>, for no initialisation, or an affine matrix or control point
image (nonlinear only). For multiple registration, where the source image
has one more dimension than the target, this may also be a list whose
components are likewise <code>NULL</code> or a suitable initial transform.</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_sourcemask">sourceMask</code></td>
<td>
<p>An optional mask image in source space, whose nonzero
region will be taken as the region of interest for the registration.
Ignored when <code>symmetric</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_targetmask">targetMask</code></td>
<td>
<p>An optional mask image in target space, whose nonzero
region will be taken as the region of interest for the registration.</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_symmetric">symmetric</code></td>
<td>
<p>Logical value. Should forward and reverse transformations
be estimated simultaneously?</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_interpolation">interpolation</code></td>
<td>
<p>A single integer specifying the type of interpolation
to be applied to the final resampled image. May be 0 (nearest neighbour),
1 (trilinear) or 3 (cubic spline). No other values are valid.</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_estimateonly">estimateOnly</code></td>
<td>
<p>Logical value: if <code>TRUE</code>, transformations will be
estimated, but images will not be resampled.</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_sequentialinit">sequentialInit</code></td>
<td>
<p>If <code>TRUE</code> and <code>source</code> has higher
dimensionality than <code>target</code>, transformations which are not
explicitly initialised will begin from the result of the previous
registration.</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_internal">internal</code></td>
<td>
<p>If <code>NA</code>, the default, the final resampled image will be
returned as a standard R array, but control point maps will be objects of
class <code>"internalImage"</code>, containing only basic metadata and a C-level
pointer to the full image. (See also <code><a href="#topic+readNifti">readNifti</a></code>.) If
<code>TRUE</code>, all image-type objects in the result will be internal images;
if <code>FALSE</code>, they will all be R arrays. The default is fine for most
purposes, but using <code>TRUE</code> may save memory, while using <code>FALSE</code>
can be necessary if there is a chance that external pointers will be
invalidated, for example when returning from worker threads.</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_precision">precision</code></td>
<td>
<p>Working precision for the registration. Using single-
precision may be desirable to save memory when coregistering large images.</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_threads">threads</code></td>
<td>
<p>For OpenMP-capable builds of the package, the maximum number
of threads to use.</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="#topic+niftyreg.linear">niftyreg.linear</a></code> or
<code><a href="#topic+niftyreg.nonlinear">niftyreg.nonlinear</a></code>.</p>
</td></tr>
<tr><td><code id="niftyreg_+3A_x">x</code></td>
<td>
<p>A <code>"niftyreg"</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"niftyreg"</code> with components:
</p>

<dl>
<dt>image</dt><dd><p>An array or internal image representing the registered and
resampled <code>source</code> image in the space of the <code>target</code> image.
This element is <code>NULL</code> if the <code>estimateOnly</code> parameter is
<code>TRUE</code>.</p>
</dd>
<dt>forwardTransforms</dt><dd><p>A list of (linear or nonlinear) transformations
from source to target space.</p>
</dd>
<dt>reverseTransforms</dt><dd><p>A list of (linear or nonlinear) transformations
from target to source space.</p>
</dd>
<dt>iterations</dt><dd><p>A list of integer vectors, giving the number of
iterations completed at each &ldquo;level&rdquo; of the algorithm. Note that for
the first level of the linear algorithm specifically, twice the
specified number of iterations is allowed.</p>
</dd>
<dt>source</dt><dd><p>An internal representation of the source image for each
registration.</p>
</dd>
<dt>target</dt><dd><p>An internal representation of the target image.</p>
</dd>
</dl>

<p>The <code>as.array</code> method for this class returns the <code>image</code>
element.
</p>


<h3>Note</h3>

<p>If substantial parts of the target image are zero-valued, for example
because the target image has been brain-extracted, it can be useful to
pass it as a target mask as well as the target image, viz.
<code>niftyreg(source, target, targetMask=target)</code>.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>References</h3>

<p>Please see <code><a href="#topic+niftyreg.linear">niftyreg.linear</a></code> or
<code><a href="#topic+niftyreg.nonlinear">niftyreg.nonlinear</a></code> for references relating to each type of
registration.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niftyreg.linear">niftyreg.linear</a></code> and <code><a href="#topic+niftyreg.nonlinear">niftyreg.nonlinear</a></code>,
which do most of the work. Also, <code><a href="#topic+forward">forward</a></code> and
<code><a href="#topic+reverse">reverse</a></code> to extract transformations, and
<code><a href="#topic+applyTransform">applyTransform</a></code> to apply them to new images or points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
source &lt;- readNifti(system.file("extdata", "epi_t2.nii.gz",
  package="RNiftyReg"))
target &lt;- readNifti(system.file("extdata", "flash_t1.nii.gz",
  package="RNiftyReg"))

result &lt;- niftyreg(source, target, scope="affine")

## End(Not run)

</code></pre>

<hr>
<h2 id='niftyreg.linear'>Two and three dimensional linear image registration</h2><span id='topic+niftyreg.linear'></span>

<h3>Description</h3>

<p>The <code>niftyreg.linear</code> function performs linear registration for two and
three dimensional images. 4D images may also be registered volumewise to a
3D image, or 3D images slicewise to a 2D image. Rigid-body (6 degrees of
freedom) and affine (12 degrees of freedom) registration can currently be
performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niftyreg.linear(source, target, scope = c("affine", "rigid"), init = NULL,
  sourceMask = NULL, targetMask = NULL, symmetric = TRUE, nLevels = 3L,
  maxIterations = 5L, useBlockPercentage = 50L, interpolation = 3L,
  verbose = FALSE, estimateOnly = FALSE, sequentialInit = FALSE,
  internal = NA, precision = c("double", "single"),
  threads = getOption("RNiftyReg.threads"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niftyreg.linear_+3A_source">source</code></td>
<td>
<p>The source image, an object of class <code>"nifti"</code> or
<code>"internalImage"</code>, or a plain array, or a NIfTI-1 filename. Must have
2, 3 or 4 dimensions.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_target">target</code></td>
<td>
<p>The target image, an object of class <code>"nifti"</code> or
<code>"internalImage"</code>, or a plain array, or a NIfTI-1 filename. Must have
2 or 3 dimensions.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_scope">scope</code></td>
<td>
<p>A string describing the scope, or number of degrees of freedom
(DOF), of the registration. The currently supported values are
<code>"affine"</code> (12 DOF), <code>"rigid"</code> (6 DOF) or <code>"nonlinear"</code>
(high DOF, with the exact number depending on the image sizes).</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_init">init</code></td>
<td>
<p>Transformation(s) to be used for initialisation, which may be
<code>NULL</code>, for no initialisation, or an affine matrix or control point
image (nonlinear only). For multiple registration, where the source image
has one more dimension than the target, this may also be a list whose
components are likewise <code>NULL</code> or a suitable initial transform.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_sourcemask">sourceMask</code></td>
<td>
<p>An optional mask image in source space, whose nonzero
region will be taken as the region of interest for the registration.
Ignored when <code>symmetric</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_targetmask">targetMask</code></td>
<td>
<p>An optional mask image in target space, whose nonzero
region will be taken as the region of interest for the registration.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_symmetric">symmetric</code></td>
<td>
<p>Logical value. Should forward and reverse transformations
be estimated simultaneously?</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_nlevels">nLevels</code></td>
<td>
<p>A single integer specifying the number of levels of the
algorithm that should be applied. If zero, no optimisation will be
performed, and the final affine matrix will be the same as its
initialisation value.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_maxiterations">maxIterations</code></td>
<td>
<p>A single integer specifying the maximum number of
iterations to be used within each level. Fewer iterations may be used if a
convergence test deems the process to have completed.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_useblockpercentage">useBlockPercentage</code></td>
<td>
<p>A single integer giving the percentage of blocks
to use for calculating correspondence at each step of the algorithm. The
blocks with the highest intensity variance will be chosen.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_interpolation">interpolation</code></td>
<td>
<p>A single integer specifying the type of interpolation
to be applied to the final resampled image. May be 0 (nearest neighbour),
1 (trilinear) or 3 (cubic spline). No other values are valid.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_verbose">verbose</code></td>
<td>
<p>A single logical value: if <code>TRUE</code>, the code will give
some feedback on its progress; otherwise, nothing will be output while the
algorithm runs. Run time can be seconds or more, depending on the size and
dimensionality of the images.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_estimateonly">estimateOnly</code></td>
<td>
<p>Logical value: if <code>TRUE</code>, transformations will be
estimated, but images will not be resampled.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_sequentialinit">sequentialInit</code></td>
<td>
<p>If <code>TRUE</code> and <code>source</code> has higher
dimensionality than <code>target</code>, transformations which are not
explicitly initialised will begin from the result of the previous
registration.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_internal">internal</code></td>
<td>
<p>If <code>NA</code>, the default, the final resampled image will be
returned as a standard R array, but control point maps will be objects of
class <code>"internalImage"</code>, containing only basic metadata and a C-level
pointer to the full image. (See also <code><a href="#topic+readNifti">readNifti</a></code>.) If
<code>TRUE</code>, all image-type objects in the result will be internal images;
if <code>FALSE</code>, they will all be R arrays. The default is fine for most
purposes, but using <code>TRUE</code> may save memory, while using <code>FALSE</code>
can be necessary if there is a chance that external pointers will be
invalidated, for example when returning from worker threads.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_precision">precision</code></td>
<td>
<p>Working precision for the registration. Using single-
precision may be desirable to save memory when coregistering large images.</p>
</td></tr>
<tr><td><code id="niftyreg.linear_+3A_threads">threads</code></td>
<td>
<p>For OpenMP-capable builds of the package, the maximum number
of threads to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the dual operations of finding a transformation to
optimise image alignment, and resampling the source image into the space of
the target image.
</p>
<p>The algorithm is based on a block-matching approach and Least Trimmed
Squares (LTS) fitting. Firstly, the block matching provides a set of
corresponding points between a target and a source image. Secondly, using
this set of corresponding points, the best rigid or affine transformation is
evaluated. This two-step loop is repeated until convergence to the best
transformation is achieved.
</p>
<p>In the NiftyReg implementation, normalised cross-correlation between the
target and source blocks is used to evaluate correspondence. The block width
is constant and has been set to 4 voxels. A coarse-to-fine approach is used,
where the registration is first performed on down-sampled images (using a
Gaussian filter to resample images), and finally performed on full
resolution images.
</p>
<p>The source image may have 2, 3 or 4 dimensions, and the target 2 or 3. The
dimensionality of the target image determines whether 2D or 3D registration
is applied, and source images with one more dimension than the target (i.e.
4D to 3D, or 3D to 2D) will be registered volumewise or slicewise, as
appropriate. In the latter case the last dimension of the resulting image is
taken from the source image, while all other dimensions come from the
target. One affine matrix is returned for each registration performed.
</p>


<h3>Value</h3>

<p>See <code><a href="#topic+niftyreg">niftyreg</a></code>.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>References</h3>

<p>The algorithm used by this function is described in the
following publication.
</p>
<p>M. Modat, D.M. Cash, P. Daga, G.P. Winston, J.S. Duncan &amp; S. Ourselin
(2014). Global image registration using a symmetric block-matching approach.
Journal of Medical Imaging 1(2):024003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niftyreg">niftyreg</a></code>, which can be used as an interface to this
function, and <code><a href="#topic+niftyreg.nonlinear">niftyreg.nonlinear</a></code> for nonlinear registration.
Also, <code><a href="#topic+forward">forward</a></code> and <code><a href="#topic+reverse">reverse</a></code> to extract
transformations, and <code><a href="#topic+applyTransform">applyTransform</a></code> to apply them to new
images or points.
</p>

<hr>
<h2 id='niftyreg.nonlinear'>Two and three dimensional nonlinear image registration</h2><span id='topic+niftyreg.nonlinear'></span>

<h3>Description</h3>

<p>The <code>niftyreg.nonlinear</code> function performs nonlinear registration for
two and three dimensional images. 4D images may also be registered
volumewise to a 3D image, or 3D images slicewise to a 2D image. The warping
is based on free-form deformations, parameterised using an image of control
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niftyreg.nonlinear(source, target, init = NULL, sourceMask = NULL,
  targetMask = NULL, symmetric = TRUE, nLevels = 3L,
  maxIterations = 150L, nBins = 64L, bendingEnergyWeight = 0.001,
  linearEnergyWeight = 0.01, jacobianWeight = 0, finalSpacing = c(5, 5,
  5), spacingUnit = c("voxel", "world"), interpolation = 3L,
  verbose = FALSE, estimateOnly = FALSE, sequentialInit = FALSE,
  internal = NA, precision = c("double", "single"),
  threads = getOption("RNiftyReg.threads"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niftyreg.nonlinear_+3A_source">source</code></td>
<td>
<p>The source image, an object of class <code>"nifti"</code> or
<code>"internalImage"</code>, or a plain array, or a NIfTI-1 filename. Must have
2, 3 or 4 dimensions.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_target">target</code></td>
<td>
<p>The target image, an object of class <code>"nifti"</code> or
<code>"internalImage"</code>, or a plain array, or a NIfTI-1 filename. Must have
2 or 3 dimensions.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_init">init</code></td>
<td>
<p>Transformation(s) to be used for initialisation, which may be
<code>NULL</code>, for no initialisation, or an affine matrix or control point
image (nonlinear only). For multiple registration, where the source image
has one more dimension than the target, this may also be a list whose
components are likewise <code>NULL</code> or a suitable initial transform.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_sourcemask">sourceMask</code></td>
<td>
<p>An optional mask image in source space, whose nonzero
region will be taken as the region of interest for the registration.
Ignored when <code>symmetric</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_targetmask">targetMask</code></td>
<td>
<p>An optional mask image in target space, whose nonzero
region will be taken as the region of interest for the registration.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_symmetric">symmetric</code></td>
<td>
<p>Logical value. Should forward and reverse transformations
be estimated simultaneously?</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_nlevels">nLevels</code></td>
<td>
<p>A single integer specifying the number of levels of the
algorithm that should be applied. If zero, no optimisation will be
performed, and the final control-point image will be the same as its
initialisation value.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_maxiterations">maxIterations</code></td>
<td>
<p>A single integer specifying the maximum number of
iterations to be used within each level. Fewer iterations may be used if a
convergence test deems the process to have completed.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_nbins">nBins</code></td>
<td>
<p>A single integer giving the number of bins to use for the joint
histogram created by the algorithm.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_bendingenergyweight">bendingEnergyWeight</code></td>
<td>
<p>A numeric value giving the weight of the bending
energy term in the cost function.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_linearenergyweight">linearEnergyWeight</code></td>
<td>
<p>A numeric value giving the weight of the linear
energy term in the cost function.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_jacobianweight">jacobianWeight</code></td>
<td>
<p>A numeric value giving the weight of the Jacobian
determinant term in the cost function.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_finalspacing">finalSpacing</code></td>
<td>
<p>A numeric vector giving the spacing of control points in
the final grid, along the X, Y and Z directions respectively. This is set
from the initial control point image, if one is supplied.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_spacingunit">spacingUnit</code></td>
<td>
<p>A character string giving the units in which the
<code>finalSpacing</code> is specified: either <code>"voxel"</code> for pixels/voxels,
or <code>"world"</code> for real-world units (see <code><a href="#topic+pixunits">pixunits</a></code>).</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_interpolation">interpolation</code></td>
<td>
<p>A single integer specifying the type of interpolation
to be applied to the final resampled image. May be 0 (nearest neighbour),
1 (trilinear) or 3 (cubic spline). No other values are valid.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_verbose">verbose</code></td>
<td>
<p>A single logical value: if <code>TRUE</code>, the code will give
some feedback on its progress; otherwise, nothing will be output while the
algorithm runs. Run time can be seconds or more, depending on the size and
dimensionality of the images.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_estimateonly">estimateOnly</code></td>
<td>
<p>Logical value: if <code>TRUE</code>, transformations will be
estimated, but images will not be resampled.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_sequentialinit">sequentialInit</code></td>
<td>
<p>If <code>TRUE</code> and <code>source</code> has higher
dimensionality than <code>target</code>, transformations which are not
explicitly initialised will begin from the result of the previous
registration.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_internal">internal</code></td>
<td>
<p>If <code>NA</code>, the default, the final resampled image will be
returned as a standard R array, but control point maps will be objects of
class <code>"internalImage"</code>, containing only basic metadata and a C-level
pointer to the full image. (See also <code><a href="#topic+readNifti">readNifti</a></code>.) If
<code>TRUE</code>, all image-type objects in the result will be internal images;
if <code>FALSE</code>, they will all be R arrays. The default is fine for most
purposes, but using <code>TRUE</code> may save memory, while using <code>FALSE</code>
can be necessary if there is a chance that external pointers will be
invalidated, for example when returning from worker threads.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_precision">precision</code></td>
<td>
<p>Working precision for the registration. Using single-
precision may be desirable to save memory when coregistering large images.</p>
</td></tr>
<tr><td><code id="niftyreg.nonlinear_+3A_threads">threads</code></td>
<td>
<p>For OpenMP-capable builds of the package, the maximum number
of threads to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the dual operations of finding a transformation to
optimise image alignment, and resampling the source image into the space of
the target image (and vice-versa, if <code>symmetric</code> is <code>TRUE</code>).
Unlike <code><a href="#topic+niftyreg.linear">niftyreg.linear</a></code>, this transformation is nonlinear, and
the degree of deformation may vary across the image.
</p>
<p>The nonlinear warping is based on free-form deformations. A lattice of
equally-spaced control points is defined over the target image, each of
which can be moved to locally modify the mapping to the source image. In
order to assess the quality of the warping between the two images, an
objective function based on the normalised mutual information is used, with
penalty terms based on the bending energy or the squared log of the Jacobian
determinant. The objective function value is optimised using a conjugate
gradient scheme.
</p>
<p>The source image may have 2, 3 or 4 dimensions, and the target 2 or 3. The
dimensionality of the target image determines whether 2D or 3D registration
is applied, and source images with one more dimension than the target (i.e.
4D to 3D, or 3D to 2D) will be registered volumewise or slicewise, as
appropriate. In the latter case the last dimension of the resulting image is
taken from the source image, while all other dimensions come from the
target. One image of control points is returned for each registration
performed.
</p>


<h3>Value</h3>

<p>See <code><a href="#topic+niftyreg">niftyreg</a></code>.
</p>


<h3>Note</h3>

<p>Performing a linear registration first, and then initialising the
nonlinear transformation with the result (via the <code>init</code> parameter),
is highly recommended in most circumstances.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>References</h3>

<p>The algorithm used by this function is described in the
following publication.
</p>
<p>M. Modat, G.R. Ridgway, Z.A. Taylor, M. Lehmann, J. Barnes, D.J. Hawkes,
N.C. Fox &amp; S. Ourselin (2010). Fast free-form deformation using graphics
processing units. Computer Methods and Programs in Biomedicine
98(3):278-284.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niftyreg">niftyreg</a></code>, which can be used as an interface to this
function, and <code><a href="#topic+niftyreg.linear">niftyreg.linear</a></code> for linear registration. Also,
<code><a href="#topic+forward">forward</a></code> and <code><a href="#topic+reverse">reverse</a></code> to extract
transformations, and <code><a href="#topic+applyTransform">applyTransform</a></code> to apply them to new
images or points.
</p>

<hr>
<h2 id='readAffine'>Read an affine matrix from a file</h2><span id='topic+readAffine'></span>

<h3>Description</h3>

<p>This function is used to read a 4x4 numeric matrix representing an affine
transformation from a file. It is a wrapper around <code>read.table</code> which
additionally ensures that required attributes are set. The type of the
matrix must be specified, as there are differing conventions across
software packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readAffine(fileName, source = NULL, target = NULL, type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readAffine_+3A_filename">fileName</code></td>
<td>
<p>A string giving the file name to read the affine matrix
from.</p>
</td></tr>
<tr><td><code id="readAffine_+3A_source">source</code></td>
<td>
<p>The source image for the transformation. If <code>NULL</code>, the
file will be searched for a comment specifying the path to a NIfTI file.</p>
</td></tr>
<tr><td><code id="readAffine_+3A_target">target</code></td>
<td>
<p>The target image for the transformation. If <code>NULL</code>, the
file will be searched for a comment specifying the path to a NIfTI file.</p>
</td></tr>
<tr><td><code id="readAffine_+3A_type">type</code></td>
<td>
<p>The type of the affine matrix, which describes what convention
is it is stored with. Currently valid values are <code>"niftyreg"</code> and
<code>"fsl"</code> (for FSL FLIRT). If <code>NULL</code>, the function will look in
the file for a comment specifying the type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An matrix with class <code>"affine"</code>, converted to the NiftyReg
convention and with <code>source</code> and <code>target</code> attributes set
appropriately.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="#topic+writeAffine">writeAffine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(readAffine(system.file("extdata","affine.txt",package="RNiftyReg")))

</code></pre>

<hr>
<h2 id='readNifti'>Read a NIfTI format file</h2><span id='topic+readNifti'></span>

<h3>Description</h3>

<p>This function reads files in NIfTI-1 or NIfTI-2 format into R, using the
standard NIfTI C library. It extends the equivalent function from the
<code>RNifti</code> package with source and target image parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readNifti(file, source = NULL, target = NULL, internal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readNifti_+3A_file">file</code></td>
<td>
<p>A character vector of file names.</p>
</td></tr>
<tr><td><code id="readNifti_+3A_source">source</code>, <code id="readNifti_+3A_target">target</code></td>
<td>
<p>If the specified <code>file</code> contains a transformation,
these parameters can be used to specify the associated source and target
images, which are stored in attributes of the same name. Only used if
<code>file</code> is of unit length.</p>
</td></tr>
<tr><td><code id="readNifti_+3A_internal">internal</code></td>
<td>
<p>Logical value. If <code>FALSE</code> (the default), an array
of class <code>"niftiImage"</code>, containing the image pixel or voxel values,
will be returned. If <code>TRUE</code>, the return value will be an object of
class <code>"internalImage"</code>, which contains only minimal metadata about
the image. Either way, the return value has an attribute which points to a
C data structure containing the full image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array or internal image, with class <code>"niftiImage"</code>, and
possibly also <code>"internalImage"</code>.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+pixdim+3C-'></span><span id='topic+pixunits+3C-'></span><span id='topic+qform+3C-'></span><span id='topic+sform+3C-'></span><span id='topic+dumpNifti'></span><span id='topic+ndim'></span><span id='topic+pixdim'></span><span id='topic+pixunits'></span><span id='topic+retrieveNifti'></span><span id='topic+updateNifti'></span><span id='topic+voxelToWorld'></span><span id='topic+worldToVoxel'></span><span id='topic+writeNifti'></span><span id='topic+xform'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>RNifti</dt><dd><p><code><a href="RNifti.html#topic+niftiHeader">dumpNifti</a></code>, <code><a href="RNifti.html#topic+ndim">ndim</a></code>, <code><a href="RNifti.html#topic+pixdim">pixdim</a></code>, <code><a href="RNifti.html#topic+pixdim">pixdim&lt;-</a></code>, <code><a href="RNifti.html#topic+pixdim">pixunits</a></code>, <code><a href="RNifti.html#topic+pixdim">pixunits&lt;-</a></code>, <code><a href="RNifti.html#topic+xform">qform&lt;-</a></code>, <code><a href="RNifti.html#topic+asNifti">retrieveNifti</a></code>, <code><a href="RNifti.html#topic+xform">sform&lt;-</a></code>, <code><a href="RNifti.html#topic+asNifti">updateNifti</a></code>, <code><a href="RNifti.html#topic+voxelToWorld">voxelToWorld</a></code>, <code><a href="RNifti.html#topic+voxelToWorld">worldToVoxel</a></code>, <code><a href="RNifti.html#topic+writeNifti">writeNifti</a></code>, <code><a href="RNifti.html#topic+xform">xform</a></code></p>
</dd>
</dl>

<hr>
<h2 id='saveTransform'>Save and load transform objects</h2><span id='topic+saveTransform'></span><span id='topic+loadTransform'></span>

<h3>Description</h3>

<p>These objects save a full transformation object, including source and target
image metadata, to a self-contained RDS file, or load it back from such a
file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveTransform(transform, fileName = NULL)

loadTransform(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveTransform_+3A_transform">transform</code></td>
<td>
<p>A transform, possibly obtained from <code><a href="#topic+forward">forward</a></code>
or <code><a href="#topic+reverse">reverse</a></code>.</p>
</td></tr>
<tr><td><code id="saveTransform_+3A_filename">fileName</code></td>
<td>
<p>The file name to save to. If <code>NULL</code>, the serialised
object is returned directly instead.</p>
</td></tr>
<tr><td><code id="saveTransform_+3A_x">x</code></td>
<td>
<p>A file name to read from, or a serialised transform object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>saveTransform</code> returns a serialised transform object, if no
filename is given; otherwise it is called for its side-effect of writing
to file. <code>loadTransform</code> returns a deserialised transform object.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+writeAffine">writeAffine</a></code>, <code><a href="#topic+readAffine">readAffine</a></code>
</p>

<hr>
<h2 id='similarity'>Similarity measures between images</h2><span id='topic+similarity'></span>

<h3>Description</h3>

<p>This function calculates a similarity measure between two images, after
resampling one into the space of the other. The only supported measure is
currently normalised mutual information, which is also used as a cost
function by the registration algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarity(source, target, targetMask = NULL, interpolation = 3L,
  threads = getOption("RNiftyReg.threads"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similarity_+3A_source">source</code></td>
<td>
<p>The source image, in any acceptable form.</p>
</td></tr>
<tr><td><code id="similarity_+3A_target">target</code></td>
<td>
<p>The target image. Must have the same dimensionality as the
source image.</p>
</td></tr>
<tr><td><code id="similarity_+3A_targetmask">targetMask</code></td>
<td>
<p>An optional mask image in target space, whose nonzero
region will be the area over which the measure is calculated.</p>
</td></tr>
<tr><td><code id="similarity_+3A_interpolation">interpolation</code></td>
<td>
<p>A single integer specifying the type of interpolation
to be applied to the source image when resampling it into the space of the
target image. May be 0 (nearest neighbour), 1 (trilinear) or 3 (cubic
spline). No other values are valid.</p>
</td></tr>
<tr><td><code id="similarity_+3A_threads">threads</code></td>
<td>
<p>For OpenMP-capable builds of the package, the maximum number
of threads to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value representing the similarity between the
images.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niftyreg">niftyreg</a></code>
</p>

<hr>
<h2 id='translate'>Apply simple transformations</h2><span id='topic+translate'></span><span id='topic+rescale'></span><span id='topic+skew'></span><span id='topic+rotate'></span>

<h3>Description</h3>

<p>These functions allow simple transformations to be applied quickly, or in a
chosen order. They represent simplified interfaces to the
<code><a href="#topic+buildAffine">buildAffine</a></code> and <code><a href="#topic+applyTransform">applyTransform</a></code> functions, and
are compatible with the chaining operator from the popular <code>magrittr</code>
package (although performing one single transformation may be preferable).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate(source, translation, ...)

rescale(source, scales, anchor = c("none", "origin", "centre", "center"),
  ...)

skew(source, skews, anchor = c("none", "origin", "centre", "center"), ...)

rotate(source, angles, anchor = c("none", "origin", "centre", "center"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate_+3A_source">source</code></td>
<td>
<p>A 2D or 3D image, in the sense of <code><a href="#topic+isImage">isImage</a></code>.</p>
</td></tr>
<tr><td><code id="translate_+3A_translation">translation</code></td>
<td>
<p>Translations along each axis, in <code><a href="#topic+pixunits">pixunits</a></code>
units. May also be a list, such as that produced by
<code><a href="#topic+decomposeAffine">decomposeAffine</a></code>, with elements for translation, scales,
skews and angles.</p>
</td></tr>
<tr><td><code id="translate_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+applyTransform">applyTransform</a></code>.</p>
</td></tr>
<tr><td><code id="translate_+3A_scales">scales</code></td>
<td>
<p>Scale factors along each axis.</p>
</td></tr>
<tr><td><code id="translate_+3A_anchor">anchor</code></td>
<td>
<p>The fixed point for the transformation. Setting this parameter
to a value other than <code>"none"</code> will override the <code>translation</code>
parameter, with the final translation set to ensure that the requested
point remains in the same place after transformation.</p>
</td></tr>
<tr><td><code id="translate_+3A_skews">skews</code></td>
<td>
<p>Skews in the XY, XZ and YZ planes.</p>
</td></tr>
<tr><td><code id="translate_+3A_angles">angles</code></td>
<td>
<p>Roll, pitch and yaw rotation angles, in radians. If
<code>source</code> is two-dimensional, a single angle will be interpreted as
being in the plane as expected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformed image.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildAffine">buildAffine</a></code>, <code><a href="#topic+applyTransform">applyTransform</a></code>
</p>

<hr>
<h2 id='writeAffine'>Write an affine matrix to a file</h2><span id='topic+writeAffine'></span>

<h3>Description</h3>

<p>This function is used to write a 4x4 numeric matrix representing an affine
transformation to a file. A comment is also (optionally) written, which
specifies the matrix as using the NiftyReg convention, for the benefit of
<code><a href="#topic+readAffine">readAffine</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeAffine(affine, fileName, comments = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeAffine_+3A_affine">affine</code></td>
<td>
<p>A 4x4 affine matrix.</p>
</td></tr>
<tr><td><code id="writeAffine_+3A_filename">fileName</code></td>
<td>
<p>A string giving the file name to write the matrix to.</p>
</td></tr>
<tr><td><code id="writeAffine_+3A_comments">comments</code></td>
<td>
<p>Logical value: if <code>TRUE</code> comments are written to the
file in lines beginning with <code>#</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+write.table">write.table</a></code>, <code><a href="#topic+readAffine">readAffine</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
