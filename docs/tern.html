<!DOCTYPE html><html><head><title>Help for package tern</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tern}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tern-package'><p>tern Package</p></a></li>
<li><a href='#abnormal'><p>Patient Counts with Abnormal Range Values</p></a></li>
<li><a href='#abnormal_by_baseline'><p>Patient Counts with Abnormal Range Values by Baseline Status</p></a></li>
<li><a href='#abnormal_by_marked'><p>Count Patients with Marked Laboratory Abnormalities</p></a></li>
<li><a href='#abnormal_by_worst_grade'><p>Patient Counts with the Most Extreme Post-baseline Toxicity Grade per Direction of Abnormality</p></a></li>
<li><a href='#abnormal_by_worst_grade_worsen'><p>Patient Counts for Laboratory Events (Worsen From Baseline) by Highest Grade Post-Baseline</p></a></li>
<li><a href='#add_riskdiff'><p>Split Function to Configure Risk Difference Column</p></a></li>
<li><a href='#add_rowcounts'><p>Layout Creating Function to Add Row Total Counts</p></a></li>
<li><a href='#aesi_label'><p>Labels for Adverse Event Baskets</p></a></li>
<li><a href='#afun_riskdiff'><p>Analysis Function to Calculate Risk Difference Column Values</p></a></li>
<li><a href='#afun_selected_stats'><p>Get Selected Statistics Names</p></a></li>
<li><a href='#analyze_colvars_functions'><p>Analyze Functions on Columns</p></a></li>
<li><a href='#analyze_functions'><p>Analyze Functions</p></a></li>
<li><a href='#analyze_variables'><p>Analyze Variables</p></a></li>
<li><a href='#analyze_vars_in_cols'><p>Summary numeric variables in columns</p></a></li>
<li><a href='#append_varlabels'><p>Add Variable Labels to Top Left Corner in Table</p></a></li>
<li><a href='#apply_auto_formatting'><p>Apply Auto Formatting</p></a></li>
<li><a href='#argument_convention'><p>Standard Arguments</p></a></li>
<li><a href='#arrange_grobs'><p>Arrange Multiple Grobs</p></a></li>
<li><a href='#as_factor_keep_attributes'><p>Conversion of a Vector to a Factor</p></a></li>
<li><a href='#as.rtable'><p>Convert to <code>rtable</code></p></a></li>
<li><a href='#assertions'><p>Additional Assertions for <code>checkmate</code></p></a></li>
<li><a href='#bins_percent_labels'><p>Labels for Bins in Percent</p></a></li>
<li><a href='#c_label_n'><p>Content Row Function to Add Row Total to Labels</p></a></li>
<li><a href='#c_label_n_alt'><p>Content Row Function to Add <code>alt_counts_df</code> Row Total to Labels</p></a></li>
<li><a href='#cfun_by_flag'><p>Constructor for Content Functions given Data Frame with Flag Input</p></a></li>
<li><a href='#check_diff_prop_ci'><p>Check: Proportion Difference Arguments</p></a></li>
<li><a href='#check_same_n'><p>Check Element Dimension</p></a></li>
<li><a href='#combination_function'><p>Combination Functions Class</p></a></li>
<li><a href='#combine_counts'><p>Combine Counts</p></a></li>
<li><a href='#combine_groups'><p>Reference and Treatment Group Combination</p></a></li>
<li><a href='#combine_levels'><p>Combine Factor Levels</p></a></li>
<li><a href='#combine_vectors'><p>Combine Two Vectors Element Wise</p></a></li>
<li><a href='#compare_variables'><p>Compare Variables Between Groups</p></a></li>
<li><a href='#control_analyze_vars'><p>Control Function for Descriptive Statistics</p></a></li>
<li><a href='#control_coxph'><p>Control Function for <code>CoxPH</code> Model</p></a></li>
<li><a href='#control_coxreg'><p>Controls for Cox Regression</p></a></li>
<li><a href='#control_incidence_rate'><p>Control function for incidence rate</p></a></li>
<li><a href='#control_lineplot_vars'><p>Control Function for <code>g_lineplot</code> Function</p></a></li>
<li><a href='#control_logistic'><p>Control Function for Logistic Regression Model Fitting</p></a></li>
<li><a href='#control_step'><p>Control Function for Subgroup Treatment Effect Pattern (STEP) Calculations</p></a></li>
<li><a href='#control_surv_time'><p>Control Function for <code>survfit</code> Model for Survival Time</p></a></li>
<li><a href='#control_surv_timepoint'><p>Control Function for <code>survfit</code> Model for Patient's Survival Rate at time point</p></a></li>
<li><a href='#count_cumulative'><p>Cumulative Counts with Thresholds</p></a></li>
<li><a href='#count_missed_doses'><p>Counting Missed Doses</p></a></li>
<li><a href='#count_occurrences'><p>Occurrence Counts</p></a></li>
<li><a href='#count_occurrences_by_grade'><p>Occurrence Counts by Grade</p></a></li>
<li><a href='#count_patients_events_in_cols'><p>Counting Patients and Events in Columns</p></a></li>
<li><a href='#count_patients_with_event'><p>Count the Number of Patients with a Particular Event</p></a></li>
<li><a href='#count_patients_with_flags'><p>Count the Number of Patients with Particular Flags</p></a></li>
<li><a href='#count_values_funs'><p>Counting Specific Values</p></a></li>
<li><a href='#cox_regression'><p>Cox Proportional Hazards Regression</p></a></li>
<li><a href='#cox_regression_inter'><p>Cox Regression Helper: Interactions</p></a></li>
<li><a href='#create_afun_compare'><p>Constructor Function for <code>compare_vars()</code></p></a></li>
<li><a href='#create_afun_summary'><p>Constructor Function for <code>analyze_vars()</code> and <code>summarize_colvars()</code></p></a></li>
<li><a href='#cut_quantile_bins'><p>Cutting Numeric Vector into Empirical Quantile Bins</p></a></li>
<li><a href='#d_count_abnormal_by_baseline'><p>Description Function for <code>s_count_abnormal_by_baseline()</code></p></a></li>
<li><a href='#d_count_cumulative'><p>Description of Cumulative Count</p></a></li>
<li><a href='#d_count_missed_doses'><p>Description Function that Calculates Labels for <code>s_count_missed_doses()</code>.</p></a></li>
<li><a href='#d_onco_rsp_label'><p>Description of Standard Oncology Response</p></a></li>
<li><a href='#d_pkparam'><p>Generate PK reference dataset</p></a></li>
<li><a href='#d_proportion'><p>Description of the Proportion Summary</p></a></li>
<li><a href='#d_proportion_diff'><p>Description of Method Used for Proportion Comparison</p></a></li>
<li><a href='#d_rsp_subgroups_colvars'><p>Labels for Column Variables in Binary Response by Subgroup Table</p></a></li>
<li><a href='#d_survival_subgroups_colvars'><p>Labels for Column Variables in Survival Duration by Subgroup Table</p></a></li>
<li><a href='#d_test_proportion_diff'><p>Description of the Difference Test Between Two Proportions</p></a></li>
<li><a href='#day2month'><p>Conversion of Days to Months</p></a></li>
<li><a href='#decorate_grob'><p>Add Titles, Footnotes, Page Number, and a Bounding Box to a Grid Grob</p></a></li>
<li><a href='#decorate_grob_factory'><p>Update Page Number</p></a></li>
<li><a href='#decorate_grob_set'><p>Decorate Set of <code>grobs</code> and Add Page Numbering</p></a></li>
<li><a href='#default_na_str'><p>Default string replacement for <code>NA</code> values</p></a></li>
<li><a href='#default_stats_formats_labels'><p>Get default statistical methods and their associated formats, labels, and indent modifiers</p></a></li>
<li><a href='#desctools_binom'><p>Confidence Intervals for a Difference of Binomials</p></a></li>
<li><a href='#df_explicit_na'><p>Encode Categorical Missing Values in a Data Frame</p></a></li>
<li><a href='#draw_grob'><p>Draw <code>grob</code></p></a></li>
<li><a href='#empty_vector_if_na'><p>Return an empty numeric if all elements are <code>NA</code>.</p></a></li>
<li><a href='#estimate_coef'><p>Hazard Ratio Estimation in Interactions</p></a></li>
<li><a href='#estimate_multinomial_rsp'><p>Estimation of Proportions per Level of Factor</p></a></li>
<li><a href='#estimate_proportions'><p>Estimation of Proportions</p></a></li>
<li><a href='#ex_data'><p>Simulated <code>CDISC</code> Data for Examples</p></a></li>
<li><a href='#explicit_na'><p>Missing Data</p></a></li>
<li><a href='#extract_by_name'><p>Extract Elements by Name</p></a></li>
<li><a href='#extract_rsp_biomarkers'><p>Prepares Response Data Estimates for Multiple Biomarkers in a Single Data Frame</p></a></li>
<li><a href='#extract_rsp_subgroups'><p>Prepares Response Data for Population Subgroups in Data Frames</p></a></li>
<li><a href='#extract_survival_biomarkers'><p>Prepares Survival Data Estimates for Multiple Biomarkers in a Single Data Frame</p></a></li>
<li><a href='#extract_survival_subgroups'><p>Prepares Survival Data for Population Subgroups in Data Frames</p></a></li>
<li><a href='#extreme_format'><p>Formatting Extreme Values</p></a></li>
<li><a href='#f_conf_level'><p>Utility function to create label for confidence interval</p></a></li>
<li><a href='#f_pval'><p>Utility function to create label for p-value</p></a></li>
<li><a href='#fct_collapse_only'><p>Collapsing of Factor Levels and Keeping Only Those New Group Levels</p></a></li>
<li><a href='#fct_discard'><p>Discard Certain Levels from a Factor</p></a></li>
<li><a href='#fct_explicit_na_if'><p>Insertion of Explicit Missings in a Factor</p></a></li>
<li><a href='#fit_coxreg'><p>Fits for Cox Proportional Hazards Regression</p></a></li>
<li><a href='#fit_logistic'><p>Fit for Logistic Regression</p></a></li>
<li><a href='#fit_rsp_step'><p>Subgroup Treatment Effect Pattern (STEP) Fit for Binary (Response) Outcome</p></a></li>
<li><a href='#fit_survival_step'><p>Subgroup Treatment Effect Pattern (STEP) Fit for Survival Outcome</p></a></li>
<li><a href='#forest_viewport'><p>Create a Viewport Tree for the Forest Plot</p></a></li>
<li><a href='#format_auto'><p>Automatic formats from data significant digits</p></a></li>
<li><a href='#format_count_fraction'><p>Formatting Count and Fraction</p></a></li>
<li><a href='#format_count_fraction_fixed_dp'><p>Formatting Count and Percentage with Fixed Single Decimal Place</p></a></li>
<li><a href='#format_count_fraction_lt10'><p>Formatting Count and Fraction with Special Case for Count &lt; 10</p></a></li>
<li><a href='#format_extreme_values'><p>Formatting a Single Extreme Value</p></a></li>
<li><a href='#format_extreme_values_ci'><p>Formatting Extreme Values Part of a Confidence Interval</p></a></li>
<li><a href='#format_fraction'><p>Formatting Fraction and Percentage</p></a></li>
<li><a href='#format_fraction_fixed_dp'><p>Formatting Fraction and Percentage with Fixed Single Decimal Place</p></a></li>
<li><a href='#format_fraction_threshold'><p>Formatting Fraction with Lower Threshold</p></a></li>
<li><a href='#format_sigfig'><p>Formatting Numeric Values By Significant Figures</p></a></li>
<li><a href='#format_xx'><p>Formatting: XX as Formatting Function</p></a></li>
<li><a href='#formatting_functions'><p>Formatting Functions</p></a></li>
<li><a href='#g_forest'><p>Create a Forest Plot based on a Table</p></a></li>
<li><a href='#g_km'><p>Kaplan-Meier Plot</p></a></li>
<li><a href='#g_lineplot'><p>Line plot with the optional table</p></a></li>
<li><a href='#g_step'><p>Create a STEP Graph</p></a></li>
<li><a href='#g_waterfall'><p>Horizontal Waterfall Plot</p></a></li>
<li><a href='#get_covariates'><p>Utility function to return a named list of covariate names.</p></a></li>
<li><a href='#get_smooths'><p>Smooth Function with Optional Grouping</p></a></li>
<li><a href='#groups_list_to_df'><p>Convert List of Groups to Data Frame</p></a></li>
<li><a href='#h_adlb_abnormal_by_worst_grade'><p>Helper function to prepare <code>ADLB</code> for <code>count_abnormal_by_worst_grade()</code></p></a></li>
<li><a href='#h_adlb_worsen'><p>Helper Function to Prepare <code>ADLB</code> with Worst Labs</p></a></li>
<li><a href='#h_adsl_adlb_merge_using_worst_flag'><p>Helper Function for Deriving Analysis Datasets for <code>LBT13</code> and <code>LBT14</code></p></a></li>
<li><a href='#h_ancova'><p>Helper Function to Return Results of a Linear Model</p></a></li>
<li><a href='#h_append_grade_groups'><p>Helper function for <code>s_count_occurrences_by_grade()</code></p></a></li>
<li><a href='#h_col_indices'><p>Obtain Column Indices</p></a></li>
<li><a href='#h_count_cumulative'><p>Helper Function for <code>s_count_cumulative()</code></p></a></li>
<li><a href='#h_cox_regression'><p>Helper Functions for Cox Proportional Hazards Regression</p></a></li>
<li><a href='#h_data_plot'><p>Helper function: tidy survival fit</p></a></li>
<li><a href='#h_decompose_gg'><p><code>ggplot</code> Decomposition</p></a></li>
<li><a href='#h_format_row'><p>Helper function to get the right formatting in the optional table in <code>g_lineplot</code>.</p></a></li>
<li><a href='#h_g_ipp'><p>Helper Function To Create Simple Line Plot over Time</p></a></li>
<li><a href='#h_ggkm'><p>Helper function: KM plot</p></a></li>
<li><a href='#h_glm_count'><p>Helper Functions for Poisson Models.</p></a></li>
<li><a href='#h_grob_coxph'><p>Helper Function: <code>CoxPH</code> Grob</p></a></li>
<li><a href='#h_grob_median_surv'><p>Helper Function: Survival Estimation Grob</p></a></li>
<li><a href='#h_grob_tbl_at_risk'><p>Helper: Patient-at-Risk Grobs</p></a></li>
<li><a href='#h_grob_y_annot'><p>Helper: Grid Object with y-axis Annotation</p></a></li>
<li><a href='#h_incidence_rate'><p>Helper Functions for Incidence Rate</p></a></li>
<li><a href='#h_km_layout'><p>Helper: KM Layout</p></a></li>
<li><a href='#h_logistic_regression'><p>Helper Functions for Multivariate Logistic Regression</p></a></li>
<li><a href='#h_map_for_count_abnormal'><p>Helper Function to create a map dataframe that can be used in <code>trim_levels_to_map</code> split function.</p></a></li>
<li><a href='#h_odds_ratio'><p>Helper Functions for Odds Ratio Estimation</p></a></li>
<li><a href='#h_pkparam_sort'><p>Sort Data by <code style="white-space: pre;">&#8288;PK PARAM&#8288;</code> Variable</p></a></li>
<li><a href='#h_prop_diff'><p>Helper Functions to Calculate Proportion Difference</p></a></li>
<li><a href='#h_prop_diff_test'><p>Helper Functions to Test Proportion Differences</p></a></li>
<li><a href='#h_proportions'><p>Helper Functions for Calculating Proportion Confidence Intervals</p></a></li>
<li><a href='#h_response_biomarkers_subgroups'><p>Helper Functions for Tabulating Biomarker Effects on Binary Response by Subgroup</p></a></li>
<li><a href='#h_response_subgroups'><p>Helper Functions for Tabulating Binary Response by Subgroup</p></a></li>
<li><a href='#h_split_by_subgroups'><p>Split Dataframe by Subgroups</p></a></li>
<li><a href='#h_split_param'><p>Split parameters</p></a></li>
<li><a href='#h_stack_by_baskets'><p>Helper Function to create a new <code>SMQ</code> variable in <code>ADAE</code> by stacking <code>SMQ</code> and/or <code>CQ</code> records.</p></a></li>
<li><a href='#h_step'><p>Helper Functions for Subgroup Treatment Effect Pattern (STEP) Calculations</p></a></li>
<li><a href='#h_survival_biomarkers_subgroups'><p>Helper Functions for Tabulating Biomarker Effects on Survival by Subgroup</p></a></li>
<li><a href='#h_survival_duration_subgroups'><p>Helper Functions for Tabulating Survival Duration by Subgroup</p></a></li>
<li><a href='#h_tab_one_biomarker'><p>Helper Function for Tabulation of a Single Biomarker Result</p></a></li>
<li><a href='#h_tbl_coxph_pairwise'><p>Helper Function: Pairwise <code>CoxPH</code> table</p></a></li>
<li><a href='#h_tbl_median_surv'><p>Helper Function: Survival Estimations</p></a></li>
<li><a href='#h_worsen_counter'><p>Helper Function to Analyze Patients for <code>s_count_abnormal_lab_worsen_by_baseline()</code></p></a></li>
<li><a href='#h_xticks'><p>Helper function: x tick positions</p></a></li>
<li><a href='#imputation_rule'><p>Apply 1/3 or 1/2 Imputation Rule to Data</p></a></li>
<li><a href='#incidence_rate'><p>Incidence Rate</p></a></li>
<li><a href='#individual_patient_plot'><p>Individual Patient Plots</p></a></li>
<li><a href='#labels_or_names'><p>Labels or Names of List Elements</p></a></li>
<li><a href='#labels_use_control'><p>Update Labels According to Control Specifications</p></a></li>
<li><a href='#logistic_regression_cols'><p>Logistic Regression Multivariate Column Layout Function</p></a></li>
<li><a href='#logistic_summary_by_flag'><p>Logistic Regression Summary Table Constructor Function</p></a></li>
<li><a href='#make_names'><p>Make Names Without Dots</p></a></li>
<li><a href='#month2day'><p>Conversion of Months to Days</p></a></li>
<li><a href='#muffled_car_anova'><p>Muffled <code>car::Anova</code></p></a></li>
<li><a href='#n_available'><p>Number of Available (Non-Missing Entries) in a Vector</p></a></li>
<li><a href='#odds_ratio'><p>Odds Ratio Estimation</p></a></li>
<li><a href='#prop_diff'><p>Proportion Difference</p></a></li>
<li><a href='#prop_diff_test'><p>Difference Test for Two Proportions</p></a></li>
<li><a href='#prune_occurrences'><p>Occurrence Table Pruning</p></a></li>
<li><a href='#range_noinf'><p>Re-implemented <code>range()</code> Default S3 method for numerical objects</p></a></li>
<li><a href='#reapply_varlabels'><p>Reapply Variable Labels</p></a></li>
<li><a href='#response_biomarkers_subgroups'><p>Tabulate Biomarker Effects on Binary Response by Subgroup</p></a></li>
<li><a href='#response_subgroups'><p>Tabulate Binary Response by Subgroup</p></a></li>
<li><a href='#rtable2gg'><p>Convert <code>rtable</code> object to <code>ggplot</code> object</p></a></li>
<li><a href='#rtables_access'><p><code>rtables</code> Access Helper Functions</p></a></li>
<li><a href='#s_cox_multivariate'><p>Multivariate Cox Model - Summarized Results</p></a></li>
<li><a href='#sas_na'><p>Convert Strings to <code>NA</code></p></a></li>
<li><a href='#score_occurrences'><p>Occurrence Table Sorting</p></a></li>
<li><a href='#split_cols_by_groups'><p>Split Columns by Groups of Levels</p></a></li>
<li><a href='#split_text_grob'><p>Split Text According To Available Text Width</p></a></li>
<li><a href='#stack_grobs'><p>Stack Multiple Grobs</p></a></li>
<li><a href='#stat_mean_ci'><p>Confidence Interval for Mean</p></a></li>
<li><a href='#stat_mean_pval'><p>p-Value of the Mean</p></a></li>
<li><a href='#stat_median_ci'><p>Confidence Interval for Median</p></a></li>
<li><a href='#stat_propdiff_ci'><p>Proportion Difference and Confidence Interval</p></a></li>
<li><a href='#strata_normal_quantile'><p>Helper Function for the Estimation of Stratified Quantiles</p></a></li>
<li><a href='#study_arm'><p>Indicate Study Arm Variable in Formula</p></a></li>
<li><a href='#summarize_ancova'><p>Summary for analysis of covariance (<code>ANCOVA</code>).</p></a></li>
<li><a href='#summarize_change'><p>Summarize the Change from Baseline or Absolute Baseline Values</p></a></li>
<li><a href='#summarize_colvars'><p>Summarize Variables in Columns</p></a></li>
<li><a href='#summarize_functions'><p>Summarize Functions</p></a></li>
<li><a href='#summarize_glm_count'><p>Summary for Poisson Negative Binomial.</p></a></li>
<li><a href='#summarize_logistic'><p>Multivariate Logistic Regression Table</p></a></li>
<li><a href='#summarize_num_patients'><p>Number of Patients</p></a></li>
<li><a href='#summarize_patients_exposure_in_cols'><p>Counting Patients Summing Exposure Across All Patients in Columns</p></a></li>
<li><a href='#survival_biomarkers_subgroups'><p>Tabulate Biomarker Effects on Survival by Subgroup</p></a></li>
<li><a href='#survival_coxph_pairwise'><p>Pairwise <code>CoxPH</code> model</p></a></li>
<li><a href='#survival_duration_subgroups'><p>Tabulate Survival Duration by Subgroup</p></a></li>
<li><a href='#survival_time'><p>Survival Time Analysis</p></a></li>
<li><a href='#survival_timepoint'><p>Survival Time Point Analysis</p></a></li>
<li><a href='#tidy_coxreg'><p>Custom Tidy Methods for Cox Regression</p></a></li>
<li><a href='#tidy.glm'><p>Custom Tidy Method for Binomial GLM Results</p></a></li>
<li><a href='#tidy.step'><p>Custom Tidy Method for STEP Results</p></a></li>
<li><a href='#to_n'><p>Replicate Entries of a Vector if Required</p></a></li>
<li><a href='#to_string_matrix'><p>Convert Table into Matrix of Strings</p></a></li>
<li><a href='#try_car_anova'><p><code>tryCatch</code> around <code>car::Anova</code></p></a></li>
<li><a href='#ungroup_stats'><p>Ungroup Non-Numeric Statistics</p></a></li>
<li><a href='#univariate'><p>Univariate Formula Special Term</p></a></li>
<li><a href='#unlist_and_blank_na'><p>Blank for Missing Input</p></a></li>
<li><a href='#update_weights_strat_wilson'><p>Helper Function for the Estimation of Weights for <code>prop_strat_wilson</code></p></a></li>
<li><a href='#utils_split_funs'><p>Custom Split Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Create Common TLGs Used in Clinical Trials</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-07</td>
</tr>
<tr>
<td>Description:</td>
<td>Table, Listings, and Graphs (TLG) library for common outputs
    used in clinical trials.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/insightsengineering/tern">https://github.com/insightsengineering/tern</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/insightsengineering/tern/issues">https://github.com/insightsengineering/tern/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6), rtables (&ge; 0.6.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom (&ge; 0.5.4), car (&ge; 3.0-13), checkmate (&ge; 2.1.0),
cowplot (&ge; 0.7.0), dplyr (&ge; 1.0.0), emmeans (&ge; 1.8.0),
forcats (&ge; 1.0.0), formatters (&ge; 0.5.5), ggplot2 (&ge; 3.4.0),
grid, gridExtra (&ge; 2.0.0), gtable (&ge; 0.3.0), labeling,
lifecycle (&ge; 0.2.0), magrittr (&ge; 1.5), methods, Rdpack (&ge;
2.4), rlang (&ge; 1.1.0), scales (&ge; 1.2.0), stats, survival (&ge;
3.2-13), tibble (&ge; 2.0.0), tidyr (&ge; 0.8.3), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.42), lattice (&ge; 0.18-4), lubridate (&ge; 1.7.9),
nestcolor (&ge; 0.1.1), rmarkdown (&ge; 2.19), stringr (&ge; 1.4.1),
svglite (&ge; 2.1.2), testthat (&ge; 3.1.9), vdiffr (&ge; 1.0.7)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle, Rdpack</td>
</tr>
<tr>
<td>Config/Needs/verdepcheck:</td>
<td>insightsengineering/rtables,
tidymodels/broom, cran/car, mllg/checkmate, wilkelab/cowplot,
tidyverse/dplyr, rvlenth/emmeans, tidyverse/forcats,
insightsengineering/formatters, tidyverse/ggplot2,
r-lib/gtable, r-lib/lifecycle, tidyverse/magrittr,
GeoBosh/Rdpack, r-lib/rlang, r-lib/scales, tidyverse/tibble,
tidyverse/tidyr, yihui/knitr, deepayan/lattice,
tidyverse/lubridate, insightsengineering/nestcolor,
rstudio/rmarkdown, tidyverse/stringr, r-lib/svglite,
r-lib/testthat, r-lib/vdiffr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>insightsengineering/nesttemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'formatting_functions.R' 'abnormal.R' 'abnormal_by_baseline.R'
'abnormal_by_marked.R' 'abnormal_by_worst_grade.R'
'abnormal_by_worst_grade_worsen.R'
'analyze_colvars_functions.R' 'analyze_functions.R'
'analyze_variables.R' 'analyze_vars_in_cols.R'
'argument_convention.R' 'combination_function.R'
'compare_variables.R' 'control_incidence_rate.R'
'control_logistic.R' 'control_step.R' 'control_survival.R'
'count_cumulative.R' 'count_missed_doses.R'
'count_occurrences.R' 'count_occurrences_by_grade.R'
'count_patients_events_in_cols.R' 'count_patients_with_event.R'
'count_patients_with_flags.R' 'count_values.R'
'cox_regression.R' 'cox_regression_inter.R' 'coxph.R'
'd_pkparam.R' 'data.R' 'decorate_grob.R'
'desctools_binom_diff.R' 'df_explicit_na.R'
'estimate_multinomial_rsp.R' 'estimate_proportion.R'
'fit_rsp_step.R' 'fit_survival_step.R' 'g_forest.R'
'g_lineplot.R' 'g_step.R' 'g_waterfall.R'
'h_adsl_adlb_merge_using_worst_flag.R'
'h_biomarkers_subgroups.R' 'h_cox_regression.R'
'h_logistic_regression.R' 'h_map_for_count_abnormal.R'
'h_pkparam_sort.R' 'h_response_biomarkers_subgroups.R'
'h_response_subgroups.R' 'h_stack_by_baskets.R' 'h_step.R'
'h_survival_biomarkers_subgroups.R'
'h_survival_duration_subgroups.R' 'imputation_rule.R'
'incidence_rate.R' 'individual_patient_plot.R'
'kaplan_meier_plot.R' 'logistic_regression.R' 'missing_data.R'
'odds_ratio.R' 'package.R' 'prop_diff.R' 'prop_diff_test.R'
'prune_occurrences.R' 'response_biomarkers_subgroups.R'
'response_subgroups.R' 'riskdiff.R' 'rtables_access.R'
'score_occurrences.R' 'split_cols_by_groups.R' 'stat.R'
'summarize_ancova.R' 'summarize_change.R' 'summarize_colvars.R'
'summarize_coxreg.R' 'summarize_functions.R'
'summarize_glm_count.R' 'summarize_num_patients.R'
'summarize_patients_exposure_in_cols.R'
'survival_biomarkers_subgroups.R' 'survival_coxph_pairwise.R'
'survival_duration_subgroups.R' 'survival_time.R'
'survival_timepoint.R' 'utils.R' 'utils_checkmate.R'
'utils_default_stats_formats_labels.R' 'utils_factor.R'
'utils_ggplot.R' 'utils_grid.R' 'utils_rtables.R'
'utils_split_funs.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-08 13:14:34 UTC; rstudio</td>
</tr>
<tr>
<td>Author:</td>
<td>Joe Zhu [aut, cre],
  Daniel Sabanés Bové [aut],
  Jana Stoilova [aut],
  Heng Wang [aut],
  Francois Collin [aut],
  Adrian Waddell [aut],
  Pawel Rucki [aut],
  Chendi Liao [aut],
  Jennifer Li [aut],
  F. Hoffmann-La Roche AG [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joe Zhu &lt;joe.zhu@roche.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 16:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='tern-package'>tern Package</h2><span id='topic+tern'></span><span id='topic+tern-package'></span>

<h3>Description</h3>

<p>Package to create tables, listings and graphs to analyze clinical trials data.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joe Zhu <a href="mailto:joe.zhu@roche.com">joe.zhu@roche.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Daniel Sabanés Bové <a href="mailto:daniel.sabanes_bove@roche.com">daniel.sabanes_bove@roche.com</a>
</p>
</li>
<li><p> Jana Stoilova <a href="mailto:jana.stoilova@roche.com">jana.stoilova@roche.com</a>
</p>
</li>
<li><p> Heng Wang <a href="mailto:wang.heng@gene.com">wang.heng@gene.com</a>
</p>
</li>
<li><p> Francois Collin
</p>
</li>
<li><p> Adrian Waddell <a href="mailto:adrian.waddell@gene.com">adrian.waddell@gene.com</a>
</p>
</li>
<li><p> Pawel Rucki <a href="mailto:pawel.rucki@roche.com">pawel.rucki@roche.com</a>
</p>
</li>
<li><p> Chendi Liao <a href="mailto:chendi.liao@roche.com">chendi.liao@roche.com</a>
</p>
</li>
<li><p> Jennifer Li <a href="mailto:li.jing@gene.com">li.jing@gene.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> F. Hoffmann-La Roche AG [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/insightsengineering/tern">https://github.com/insightsengineering/tern</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/insightsengineering/tern/issues">https://github.com/insightsengineering/tern/issues</a>
</p>
</li></ul>


<hr>
<h2 id='abnormal'>Patient Counts with Abnormal Range Values</h2><span id='topic+abnormal'></span><span id='topic+count_abnormal'></span><span id='topic+s_count_abnormal'></span><span id='topic+a_count_abnormal'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Primary analysis variable <code>.var</code> indicates the abnormal range result (<code>character</code> or <code>factor</code>)
and additional analysis variables are <code>id</code> (<code>character</code> or <code>factor</code>) and <code>baseline</code> (<code>character</code> or
<code>factor</code>). For each direction specified in <code>abnormal</code> (e.g. high or low) count patients in the
numerator and denominator as follows:
</p>

<ul>
<li> <p><code>num</code> : The number of patients with this abnormality recorded while on treatment.
</p>
</li>
<li> <p><code>denom</code>: The number of patients with at least one post-baseline assessment.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>count_abnormal(
  lyt,
  var,
  abnormal = list(Low = "LOW", High = "HIGH"),
  variables = list(id = "USUBJID", baseline = "BNRIND"),
  exclude_base_abn = FALSE,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  table_names = var,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_count_abnormal(
  df,
  .var,
  abnormal = list(Low = "LOW", High = "HIGH"),
  variables = list(id = "USUBJID", baseline = "BNRIND"),
  exclude_base_abn = FALSE
)

a_count_abnormal(
  df,
  .var,
  abnormal = list(Low = "LOW", High = "HIGH"),
  variables = list(id = "USUBJID", baseline = "BNRIND"),
  exclude_base_abn = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abnormal_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="abnormal_+3A_abnormal">abnormal</code></td>
<td>
<p>(named <code>list</code>)<br /> list identifying the abnormal range level(s) in <code>var</code>. Defaults to
<code>list(Low = "LOW", High = "HIGH")</code> but you can also group different levels into the named list,
for example, <code>abnormal = list(Low = c("LOW", "LOW LOW"), High = c("HIGH", "HIGH HIGH"))</code>.</p>
</td></tr>
<tr><td><code id="abnormal_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="abnormal_+3A_exclude_base_abn">exclude_base_abn</code></td>
<td>
<p>(<code>flag</code>)<br /> whether to exclude subjects with baseline abnormality
from numerator and denominator.</p>
</td></tr>
<tr><td><code id="abnormal_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="abnormal_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="abnormal_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="abnormal_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="abnormal_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("abnormal")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="abnormal_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="abnormal_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="abnormal_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="abnormal_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="abnormal_+3A_.var">.var</code>, <code id="abnormal_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>count_abnormal()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_count_abnormal()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_abnormal()</code> returns the statistic <code>fraction</code> which is a vector with <code>num</code> and <code>denom</code> counts of patients.
</p>
</li></ul>


<ul>
<li> <p><code>a_count_abnormal()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>count_abnormal()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_count_abnormal()</code>: Statistics function which counts patients with abnormal range values
for a single <code>abnormal</code> level.
</p>
</li>
<li> <p><code>a_count_abnormal()</code>: Formatted analysis function which is used as <code>afun</code> in <code>count_abnormal()</code>.
</p>
</li></ul>


<h3>Note</h3>


<ul>
<li> <p><code>count_abnormal()</code> only works with a single variable containing multiple abnormal levels.
</p>
</li>
<li> <p><code>df</code> should be filtered to include only post-baseline records.
</p>
</li>
<li><p> the denominator includes patients that might have other abnormal levels at baseline,
and patients with missing baseline. Patients with these abnormalities at
baseline can be optionally excluded from numerator and denominator.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

df &lt;- data.frame(
  USUBJID = as.character(c(1, 1, 2, 2)),
  ANRIND = factor(c("NORMAL", "LOW", "HIGH", "HIGH")),
  BNRIND = factor(c("NORMAL", "NORMAL", "HIGH", "HIGH")),
  ONTRTFL = c("", "Y", "", "Y"),
  stringsAsFactors = FALSE
)

# Select only post-baseline records.
df &lt;- df %&gt;%
  filter(ONTRTFL == "Y")

# Layout creating function.
basic_table() %&gt;%
  count_abnormal(var = "ANRIND", abnormal = list(high = "HIGH", low = "LOW")) %&gt;%
  build_table(df)

# Passing of statistics function and formatting arguments.
df2 &lt;- data.frame(
  ID = as.character(c(1, 1, 2, 2)),
  RANGE = factor(c("NORMAL", "LOW", "HIGH", "HIGH")),
  BL_RANGE = factor(c("NORMAL", "NORMAL", "HIGH", "HIGH")),
  ONTRTFL = c("", "Y", "", "Y"),
  stringsAsFactors = FALSE
)

# Select only post-baseline records.
df2 &lt;- df2 %&gt;%
  filter(ONTRTFL == "Y")

basic_table() %&gt;%
  count_abnormal(
    var = "RANGE",
    abnormal = list(low = "LOW", high = "HIGH"),
    variables = list(id = "ID", baseline = "BL_RANGE")
  ) %&gt;%
  build_table(df2)

</code></pre>

<hr>
<h2 id='abnormal_by_baseline'>Patient Counts with Abnormal Range Values by Baseline Status</h2><span id='topic+abnormal_by_baseline'></span><span id='topic+count_abnormal_by_baseline'></span><span id='topic+s_count_abnormal_by_baseline'></span><span id='topic+a_count_abnormal_by_baseline'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Primary analysis variable <code>.var</code> indicates the abnormal range result (<code>character</code> or <code>factor</code>), and additional
analysis variables are <code>id</code> (<code>character</code> or <code>factor</code>) and <code>baseline</code> (<code>character</code> or <code>factor</code>). For each
direction specified in <code>abnormal</code> (e.g. high or low) we condition on baseline range result and count
patients in the numerator and denominator as follows:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;Not &lt;Abnormal&gt;&#8288;</code>
</p>

<ul>
<li> <p><code>denom</code>: the number of patients without abnormality at baseline (excluding those with missing baseline)
</p>
</li>
<li> <p><code>num</code>:  the number of patients in <code>denom</code> who also have at least one abnormality post-baseline
</p>
</li></ul>

</li>
<li> <p><code style="white-space: pre;">&#8288;&lt;Abnormal&gt;&#8288;</code>
</p>

<ul>
<li> <p><code>denom</code>: the number of patients with abnormality at baseline
</p>
</li>
<li> <p><code>num</code>: the number of patients in <code>denom</code> who also have at least one abnormality post-baseline
</p>
</li></ul>

</li>
<li> <p><code>Total</code>
</p>

<ul>
<li> <p><code>denom</code>: the number of patients with at least one valid measurement post-baseline
</p>
</li>
<li> <p><code>num</code>: the number of patients in <code>denom</code> who also have at least one abnormality post-baseline
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>count_abnormal_by_baseline(
  lyt,
  var,
  abnormal,
  variables = list(id = "USUBJID", baseline = "BNRIND"),
  na_str = "&lt;Missing&gt;",
  nested = TRUE,
  ...,
  table_names = abnormal,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_count_abnormal_by_baseline(
  df,
  .var,
  abnormal,
  na_level = lifecycle::deprecated(),
  na_str = "&lt;Missing&gt;",
  variables = list(id = "USUBJID", baseline = "BNRIND")
)

a_count_abnormal_by_baseline(
  df,
  .var,
  abnormal,
  na_level = lifecycle::deprecated(),
  na_str = "&lt;Missing&gt;",
  variables = list(id = "USUBJID", baseline = "BNRIND")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abnormal_by_baseline_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="abnormal_by_baseline_+3A_abnormal">abnormal</code></td>
<td>
<p>(<code>character</code>)<br /> identifying the abnormal range level(s) in <code>.var</code>.</p>
</td></tr>
<tr><td><code id="abnormal_by_baseline_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="abnormal_by_baseline_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> the explicit <code>na_level</code> argument you used in the pre-processing steps (maybe with
<code><a href="#topic+df_explicit_na">df_explicit_na()</a></code>). The default is <code>"&lt;Missing&gt;"</code>.</p>
</td></tr>
<tr><td><code id="abnormal_by_baseline_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="abnormal_by_baseline_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="abnormal_by_baseline_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="abnormal_by_baseline_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("abnormal_by_baseline")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="abnormal_by_baseline_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="abnormal_by_baseline_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="abnormal_by_baseline_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="abnormal_by_baseline_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="abnormal_by_baseline_+3A_.var">.var</code>, <code id="abnormal_by_baseline_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="abnormal_by_baseline_+3A_na_level">na_level</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use the <code>na_str</code> argument instead.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>count_abnormal_by_baseline()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_count_abnormal_by_baseline()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_abnormal_by_baseline()</code> returns statistic <code>fraction</code> which is a named list with 3 labeled elements:
<code>not_abnormal</code>, <code>abnormal</code>, and <code>total</code>. Each element contains a vector with <code>num</code> and <code>denom</code> patient counts.
</p>
</li></ul>


<ul>
<li> <p><code>a_count_abnormal_by_baseline()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>count_abnormal_by_baseline()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_count_abnormal_by_baseline()</code>: Statistics function for a single <code>abnormal</code> level.
</p>
</li>
<li> <p><code>a_count_abnormal_by_baseline()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>count_abnormal_by_baseline()</code>.
</p>
</li></ul>


<h3>Note</h3>


<ul>
<li> <p><code>df</code> should be filtered to include only post-baseline records.
</p>
</li>
<li><p> If the baseline variable or analysis variable contains <code>NA</code>, it is expected that <code>NA</code> has been
conveyed to <code>na_level</code> appropriately beforehand with <code><a href="#topic+df_explicit_na">df_explicit_na()</a></code> or <code><a href="#topic+explicit_na">explicit_na()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Relevant description function <code><a href="#topic+d_count_abnormal_by_baseline">d_count_abnormal_by_baseline()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  USUBJID = as.character(c(1:6)),
  ANRIND = factor(c(rep("LOW", 4), "NORMAL", "HIGH")),
  BNRIND = factor(c("LOW", "NORMAL", "HIGH", NA, "LOW", "NORMAL"))
)
df &lt;- df_explicit_na(df)

# Layout creating function.
basic_table() %&gt;%
  count_abnormal_by_baseline(var = "ANRIND", abnormal = c(High = "HIGH")) %&gt;%
  build_table(df)

# Passing of statistics function and formatting arguments.
df2 &lt;- data.frame(
  ID = as.character(c(1, 2, 3, 4)),
  RANGE = factor(c("NORMAL", "LOW", "HIGH", "HIGH")),
  BLRANGE = factor(c("LOW", "HIGH", "HIGH", "NORMAL"))
)

basic_table() %&gt;%
  count_abnormal_by_baseline(
    var = "RANGE",
    abnormal = c(Low = "LOW"),
    variables = list(id = "ID", baseline = "BLRANGE"),
    .formats = c(fraction = "xx / xx"),
    .indent_mods = c(fraction = 2L)
  ) %&gt;%
  build_table(df2)

</code></pre>

<hr>
<h2 id='abnormal_by_marked'>Count Patients with Marked Laboratory Abnormalities</h2><span id='topic+abnormal_by_marked'></span><span id='topic+count_abnormal_by_marked'></span><span id='topic+s_count_abnormal_by_marked'></span><span id='topic+a_count_abnormal_by_marked'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Primary analysis variable <code>.var</code> indicates whether single, replicated or last marked laboratory
abnormality was observed (<code>factor</code>). Additional analysis variables are <code>id</code> (<code>character</code> or <code>factor</code>)
and <code>direction</code> (<code>factor</code>) indicating the direction of the abnormality. Denominator is number of
patients with at least one valid measurement during the analysis.
</p>

<ul>
<li><p> For <code style="white-space: pre;">&#8288;Single, not last&#8288;</code> and <code style="white-space: pre;">&#8288;Last or replicated&#8288;</code>: Numerator is number of patients
with <code style="white-space: pre;">&#8288;Single, not last&#8288;</code> and <code style="white-space: pre;">&#8288;Last or replicated&#8288;</code> levels, respectively.
</p>
</li>
<li><p> For <code>Any</code>: Numerator is the number of patients with either single or
replicated marked abnormalities.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>count_abnormal_by_marked(
  lyt,
  var,
  category = list(single = "SINGLE", last_replicated = c("LAST", "REPLICATED")),
  variables = list(id = "USUBJID", param = "PARAM", direction = "abn_dir"),
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_count_abnormal_by_marked(
  df,
  .var = "AVALCAT1",
  .spl_context,
  category = list(single = "SINGLE", last_replicated = c("LAST", "REPLICATED")),
  variables = list(id = "USUBJID", param = "PARAM", direction = "abn_dir")
)

a_count_abnormal_by_marked(
  df,
  .var = "AVALCAT1",
  .spl_context,
  category = list(single = "SINGLE", last_replicated = c("LAST", "REPLICATED")),
  variables = list(id = "USUBJID", param = "PARAM", direction = "abn_dir")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abnormal_by_marked_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="abnormal_by_marked_+3A_category">category</code></td>
<td>
<p>(<code>list</code>)<br /> with different marked category names for single
and last or replicated.</p>
</td></tr>
<tr><td><code id="abnormal_by_marked_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="abnormal_by_marked_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="abnormal_by_marked_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="abnormal_by_marked_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="abnormal_by_marked_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("abnormal_by_marked")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="abnormal_by_marked_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="abnormal_by_marked_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="abnormal_by_marked_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="abnormal_by_marked_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="abnormal_by_marked_+3A_.var">.var</code>, <code id="abnormal_by_marked_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="abnormal_by_marked_+3A_.spl_context">.spl_context</code></td>
<td>
<p>(<code>data.frame</code>)<br /> gives information about ancestor split states
that is passed by <code>rtables</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>count_abnormal_by_marked()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_count_abnormal_by_marked()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_abnormal_by_marked()</code> returns statistic <code>count_fraction</code> with <code style="white-space: pre;">&#8288;Single, not last&#8288;</code>,
<code style="white-space: pre;">&#8288;Last or replicated&#8288;</code>, and <code>Any</code> results.
</p>
</li></ul>


<ul>
<li> <p><code>a_count_abnormal_by_marked()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>count_abnormal_by_marked()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_count_abnormal_by_marked()</code>: Statistics function for patients with marked lab abnormalities.
</p>
</li>
<li> <p><code>a_count_abnormal_by_marked()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>count_abnormal_by_marked()</code>.
</p>
</li></ul>


<h3>Note</h3>

<p><code style="white-space: pre;">&#8288;Single, not last&#8288;</code> and <code style="white-space: pre;">&#8288;Last or replicated&#8288;</code> levels are mutually exclusive. If a patient has
abnormalities that meet both the <code style="white-space: pre;">&#8288;Single, not last&#8288;</code> and <code style="white-space: pre;">&#8288;Last or replicated&#8288;</code> criteria, then the
patient will be counted only under the <code style="white-space: pre;">&#8288;Last or replicated&#8288;</code> category.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

df &lt;- data.frame(
  USUBJID = as.character(c(rep(1, 5), rep(2, 5), rep(1, 5), rep(2, 5))),
  ARMCD = factor(c(rep("ARM A", 5), rep("ARM B", 5), rep("ARM A", 5), rep("ARM B", 5))),
  ANRIND = factor(c(
    "NORMAL", "HIGH", "HIGH", "HIGH HIGH", "HIGH",
    "HIGH", "HIGH", "HIGH HIGH", "NORMAL", "HIGH HIGH", "NORMAL", "LOW", "LOW", "LOW LOW", "LOW",
    "LOW", "LOW", "LOW LOW", "NORMAL", "LOW LOW"
  )),
  ONTRTFL = rep(c("", "Y", "Y", "Y", "Y", "Y", "Y", "Y", "Y", "Y"), 2),
  PARAMCD = factor(c(rep("CRP", 10), rep("ALT", 10))),
  AVALCAT1 = factor(rep(c("", "", "", "SINGLE", "REPLICATED", "", "", "LAST", "", "SINGLE"), 2)),
  stringsAsFactors = FALSE
)

df &lt;- df %&gt;%
  mutate(abn_dir = factor(
    case_when(
      ANRIND == "LOW LOW" ~ "Low",
      ANRIND == "HIGH HIGH" ~ "High",
      TRUE ~ ""
    ),
    levels = c("Low", "High")
  ))

# Select only post-baseline records.
df &lt;- df %&gt;% filter(ONTRTFL == "Y")
df_crp &lt;- df %&gt;%
  filter(PARAMCD == "CRP") %&gt;%
  droplevels()
full_parent_df &lt;- list(df_crp, "not_needed")
cur_col_subset &lt;- list(rep(TRUE, nrow(df_crp)), "not_needed")
spl_context &lt;- data.frame(
  split = c("PARAMCD", "GRADE_DIR"),
  full_parent_df = I(full_parent_df),
  cur_col_subset = I(cur_col_subset)
)

map &lt;- unique(
  df[df$abn_dir %in% c("Low", "High") &amp; df$AVALCAT1 != "", c("PARAMCD", "abn_dir")]
) %&gt;%
  lapply(as.character) %&gt;%
  as.data.frame() %&gt;%
  arrange(PARAMCD, abn_dir)

basic_table() %&gt;%
  split_cols_by("ARMCD") %&gt;%
  split_rows_by("PARAMCD") %&gt;%
  summarize_num_patients(
    var = "USUBJID",
    .stats = "unique_count"
  ) %&gt;%
  split_rows_by(
    "abn_dir",
    split_fun = trim_levels_to_map(map)
  ) %&gt;%
  count_abnormal_by_marked(
    var = "AVALCAT1",
    variables = list(
      id = "USUBJID",
      param = "PARAMCD",
      direction = "abn_dir"
    )
  ) %&gt;%
  build_table(df = df)

basic_table() %&gt;%
  split_cols_by("ARMCD") %&gt;%
  split_rows_by("PARAMCD") %&gt;%
  summarize_num_patients(
    var = "USUBJID",
    .stats = "unique_count"
  ) %&gt;%
  split_rows_by(
    "abn_dir",
    split_fun = trim_levels_in_group("abn_dir")
  ) %&gt;%
  count_abnormal_by_marked(
    var = "AVALCAT1",
    variables = list(
      id = "USUBJID",
      param = "PARAMCD",
      direction = "abn_dir"
    )
  ) %&gt;%
  build_table(df = df)

</code></pre>

<hr>
<h2 id='abnormal_by_worst_grade'>Patient Counts with the Most Extreme Post-baseline Toxicity Grade per Direction of Abnormality</h2><span id='topic+abnormal_by_worst_grade'></span><span id='topic+count_abnormal_by_worst_grade'></span><span id='topic+s_count_abnormal_by_worst_grade'></span><span id='topic+a_count_abnormal_by_worst_grade'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Primary analysis variable <code>.var</code> indicates the toxicity grade (<code>factor</code>), and additional
analysis variables are <code>id</code> (<code>character</code> or <code>factor</code>), <code>param</code> (<code>factor</code>) and <code>grade_dir</code> (<code>factor</code>).
The pre-processing steps are crucial when using this function.
For a certain direction (e.g. high or low) this function counts
patients in the denominator as number of patients with at least one valid measurement during treatment,
and patients in the numerator as follows:
</p>

<ul>
<li> <p><code>1</code> to <code>4</code>: Numerator is number of patients with worst grades 1-4 respectively;
</p>
</li>
<li> <p><code>Any</code>: Numerator is number of patients with at least one abnormality, which means grade is different from 0.
</p>
</li></ul>

<p>Pre-processing is crucial when using this function and can be done automatically using the
<code><a href="#topic+h_adlb_abnormal_by_worst_grade">h_adlb_abnormal_by_worst_grade()</a></code> helper function. See the description of this function for details on the
necessary pre-processing steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_abnormal_by_worst_grade(
  lyt,
  var,
  variables = list(id = "USUBJID", param = "PARAM", grade_dir = "GRADE_DIR"),
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_count_abnormal_by_worst_grade(
  df,
  .var = "GRADE_ANL",
  .spl_context,
  variables = list(id = "USUBJID", param = "PARAM", grade_dir = "GRADE_DIR")
)

a_count_abnormal_by_worst_grade(
  df,
  .var = "GRADE_ANL",
  .spl_context,
  variables = list(id = "USUBJID", param = "PARAM", grade_dir = "GRADE_DIR")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abnormal_by_worst_grade_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("abnormal_by_worst_grade")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_+3A_.var">.var</code>, <code id="abnormal_by_worst_grade_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_+3A_.spl_context">.spl_context</code></td>
<td>
<p>(<code>data.frame</code>)<br /> gives information about ancestor split states
that is passed by <code>rtables</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>count_abnormal_by_worst_grade()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_count_abnormal_by_worst_grade()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_abnormal_by_worst_grade()</code> returns the single statistic <code>count_fraction</code> with grades 1 to 4 and
&quot;Any&quot; results.
</p>
</li></ul>


<ul>
<li> <p><code>a_count_abnormal_by_worst_grade()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>count_abnormal_by_worst_grade()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_count_abnormal_by_worst_grade()</code>: Statistics function which counts patients by worst grade.
</p>
</li>
<li> <p><code>a_count_abnormal_by_worst_grade()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>count_abnormal_by_worst_grade()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+h_adlb_abnormal_by_worst_grade">h_adlb_abnormal_by_worst_grade()</a></code> which pre-processes <code>ADLB</code> data frames to be used in
<code><a href="#topic+count_abnormal_by_worst_grade">count_abnormal_by_worst_grade()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(forcats)
adlb &lt;- tern_ex_adlb

# Data is modified in order to have some parameters with grades only in one direction
# and simulate the real data.
adlb$ATOXGR[adlb$PARAMCD == "ALT" &amp; adlb$ATOXGR %in% c("1", "2", "3", "4")] &lt;- "-1"
adlb$ANRIND[adlb$PARAMCD == "ALT" &amp; adlb$ANRIND == "HIGH"] &lt;- "LOW"
adlb$WGRHIFL[adlb$PARAMCD == "ALT"] &lt;- ""

adlb$ATOXGR[adlb$PARAMCD == "IGA" &amp; adlb$ATOXGR %in% c("-1", "-2", "-3", "-4")] &lt;- "1"
adlb$ANRIND[adlb$PARAMCD == "IGA" &amp; adlb$ANRIND == "LOW"] &lt;- "HIGH"
adlb$WGRLOFL[adlb$PARAMCD == "IGA"] &lt;- ""

# Pre-processing
adlb_f &lt;- adlb %&gt;% h_adlb_abnormal_by_worst_grade()

# Map excludes records without abnormal grade since they should not be displayed
# in the table.
map &lt;- unique(adlb_f[adlb_f$GRADE_DIR != "ZERO", c("PARAM", "GRADE_DIR", "GRADE_ANL")]) %&gt;%
  lapply(as.character) %&gt;%
  as.data.frame() %&gt;%
  arrange(PARAM, desc(GRADE_DIR), GRADE_ANL)

basic_table() %&gt;%
  split_cols_by("ARMCD") %&gt;%
  split_rows_by("PARAM") %&gt;%
  split_rows_by("GRADE_DIR", split_fun = trim_levels_to_map(map)) %&gt;%
  count_abnormal_by_worst_grade(
    var = "GRADE_ANL",
    variables = list(id = "USUBJID", param = "PARAM", grade_dir = "GRADE_DIR")
  ) %&gt;%
  build_table(df = adlb_f)

</code></pre>

<hr>
<h2 id='abnormal_by_worst_grade_worsen'>Patient Counts for Laboratory Events (Worsen From Baseline) by Highest Grade Post-Baseline</h2><span id='topic+abnormal_by_worst_grade_worsen'></span><span id='topic+count_abnormal_lab_worsen_by_baseline'></span><span id='topic+s_count_abnormal_lab_worsen_by_baseline'></span><span id='topic+a_count_abnormal_lab_worsen_by_baseline'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Patient count and fraction for laboratory events (worsen from baseline) shift table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_abnormal_lab_worsen_by_baseline(
  lyt,
  var,
  variables = list(id = "USUBJID", baseline_var = "BTOXGR", direction_var = "GRADDR"),
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  table_names = NULL,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_count_abnormal_lab_worsen_by_baseline(
  df,
  .var = "ATOXGR",
  variables = list(id = "USUBJID", baseline_var = "BTOXGR", direction_var = "GRADDR")
)

a_count_abnormal_lab_worsen_by_baseline(
  df,
  .var = "ATOXGR",
  variables = list(id = "USUBJID", baseline_var = "BTOXGR", direction_var = "GRADDR")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abnormal_by_worst_grade_worsen_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_worsen_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables including:
</p>

<ul>
<li> <p><code>id</code> (<code>string</code>)<br /> subject variable name.
</p>
</li>
<li> <p><code>baseline_var</code> (<code>string</code>)<br /> name of the data column containing baseline toxicity variable.
</p>
</li>
<li> <p><code>direction_var</code> (<code>string</code>)<br /> see <code>direction_var</code> for more details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_worsen_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_worsen_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_worsen_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_worsen_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_worsen_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("abnormal_by_worst_grade_worsen")</code>
to see all available statistics.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_worsen_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_worsen_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_worsen_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_worsen_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="abnormal_by_worst_grade_worsen_+3A_.var">.var</code>, <code id="abnormal_by_worst_grade_worsen_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>count_abnormal_lab_worsen_by_baseline()</code> returns a layout object suitable for passing to further layouting
functions, or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted
rows containing the statistics from <code>s_count_abnormal_lab_worsen_by_baseline()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_abnormal_lab_worsen_by_baseline()</code> returns the counts and fraction of patients whose worst
post-baseline lab grades are worse than their baseline grades, for post-baseline worst grades
&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot; and &quot;Any&quot;.
</p>
</li></ul>


<ul>
<li> <p><code>a_count_abnormal_lab_worsen_by_baseline()</code> returns the corresponding list with
formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>count_abnormal_lab_worsen_by_baseline()</code>: Layout-creating function which can take statistics function
arguments and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_count_abnormal_lab_worsen_by_baseline()</code>: Statistics function for patients whose worst post-baseline
lab grades are worse than their baseline grades.
</p>
</li>
<li> <p><code>a_count_abnormal_lab_worsen_by_baseline()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>count_abnormal_lab_worsen_by_baseline()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p>Relevant helper functions <code><a href="#topic+h_adlb_worsen">h_adlb_worsen()</a></code> and <code><a href="#topic+h_worsen_counter">h_worsen_counter()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# The direction variable, GRADDR, is based on metadata
adlb &lt;- tern_ex_adlb %&gt;%
  mutate(
    GRADDR = case_when(
      PARAMCD == "ALT" ~ "B",
      PARAMCD == "CRP" ~ "L",
      PARAMCD == "IGA" ~ "H"
    )
  ) %&gt;%
  filter(SAFFL == "Y" &amp; ONTRTFL == "Y" &amp; GRADDR != "")

df &lt;- h_adlb_worsen(
  adlb,
  worst_flag_low = c("WGRLOFL" = "Y"),
  worst_flag_high = c("WGRHIFL" = "Y"),
  direction_var = "GRADDR"
)

basic_table() %&gt;%
  split_cols_by("ARMCD") %&gt;%
  add_colcounts() %&gt;%
  split_rows_by("PARAMCD") %&gt;%
  split_rows_by("GRADDR") %&gt;%
  count_abnormal_lab_worsen_by_baseline(
    var = "ATOXGR",
    variables = list(
      id = "USUBJID",
      baseline_var = "BTOXGR",
      direction_var = "GRADDR"
    )
  ) %&gt;%
  append_topleft("Direction of Abnormality") %&gt;%
  build_table(df = df, alt_counts_df = tern_ex_adsl)

</code></pre>

<hr>
<h2 id='add_riskdiff'>Split Function to Configure Risk Difference Column</h2><span id='topic+add_riskdiff'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Wrapper function for <code><a href="rtables.html#topic+add_combo_levels">rtables::add_combo_levels()</a></code> which configures settings for the risk difference
column to be added to an <code>rtables</code> object. To add a risk difference column to a table, this function
should be used as <code>split_fun</code> in calls to <code><a href="rtables.html#topic+split_cols_by">rtables::split_cols_by()</a></code>, followed by setting argument
<code>riskdiff</code> to <code>TRUE</code> in all following analyze function calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_riskdiff(
  arm_x,
  arm_y,
  col_label = paste0("Risk Difference (%) (95% CI)", if (length(arm_y) &gt; 1)
    paste0("\n", arm_x, " vs. ", arm_y)),
  pct = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_riskdiff_+3A_arm_x">arm_x</code></td>
<td>
<p>(<code>character</code>)<br /> Name of reference arm to use in risk difference calculations.</p>
</td></tr>
<tr><td><code id="add_riskdiff_+3A_arm_y">arm_y</code></td>
<td>
<p>(<code>character</code>)<br /> Names of one or more arms to compare to reference arm in risk difference
calculations. A new column will be added for each value of <code>arm_y</code>.</p>
</td></tr>
<tr><td><code id="add_riskdiff_+3A_col_label">col_label</code></td>
<td>
<p>(<code>character</code>)<br /> Labels to use when rendering the risk difference column within the table.
If more than one comparison arm is specified in <code>arm_y</code>, default labels will specify which two arms are
being compared (reference arm vs. comparison arm).</p>
</td></tr>
<tr><td><code id="add_riskdiff_+3A_pct">pct</code></td>
<td>
<p>(<code>flag</code>)<br /> whether output should be returned as percentages. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A closure suitable for use as a split function (<code>split_fun</code>) within <code><a href="rtables.html#topic+split_cols_by">rtables::split_cols_by()</a></code>
when creating a table layout.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stat_propdiff_ci">stat_propdiff_ci()</a></code> for details on risk difference calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adae &lt;- tern_ex_adae
adae$AESEV &lt;- factor(adae$AESEV)

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARMCD", split_fun = add_riskdiff(arm_x = "ARM A", arm_y = c("ARM B", "ARM C"))) %&gt;%
  count_occurrences_by_grade(
    var = "AESEV",
    riskdiff = TRUE
  )

tbl &lt;- build_table(lyt, df = adae)
tbl

</code></pre>

<hr>
<h2 id='add_rowcounts'>Layout Creating Function to Add Row Total Counts</h2><span id='topic+add_rowcounts'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This works analogously to <code><a href="rtables.html#topic+add_colcounts">rtables::add_colcounts()</a></code> but on the rows. This function
is a wrapper for <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_rowcounts(lyt, alt_counts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_rowcounts_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="add_rowcounts_+3A_alt_counts">alt_counts</code></td>
<td>
<p>(<code>flag</code>)<br /> whether row counts should be taken from <code>alt_counts_df</code> (<code>TRUE</code>)
or from <code>df</code> (<code>FALSE</code>). Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified layout where the latest row split labels now have the row-wise
total counts (i.e. without column-based subsetting) attached in parentheses.
</p>


<h3>Note</h3>

<p>Row count values are contained in these row count rows but are not displayed
so that they are not considered zero rows by default when pruning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_colcounts() %&gt;%
  split_rows_by("RACE", split_fun = drop_split_levels) %&gt;%
  add_rowcounts() %&gt;%
  analyze("AGE", afun = list_wrap_x(summary), format = "xx.xx") %&gt;%
  build_table(DM)

</code></pre>

<hr>
<h2 id='aesi_label'>Labels for Adverse Event Baskets</h2><span id='topic+aesi_label'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aesi_label(aesi, scope = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aesi_label_+3A_aesi">aesi</code></td>
<td>
<p>(<code>character</code>)<br /> with standardized <code>MedDRA</code> query name (e.g. <code>SMQzzNAM</code>) or customized query
name (e.g. <code>CQzzNAM</code>).</p>
</td></tr>
<tr><td><code id="aesi_label_+3A_scope">scope</code></td>
<td>
<p>(<code>character</code>)<br /> with scope of query (e.g. <code>SMQzzSC</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>string</code> with the standard label for the <code>AE</code> basket.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adae &lt;- tern_ex_adae

# Standardized query label includes scope.
aesi_label(adae$SMQ01NAM, scope = adae$SMQ01SC)

# Customized query label.
aesi_label(adae$CQ01NAM)

</code></pre>

<hr>
<h2 id='afun_riskdiff'>Analysis Function to Calculate Risk Difference Column Values</h2><span id='topic+afun_riskdiff'></span>

<h3>Description</h3>

<p>In the risk difference column, this function uses the statistics function associated with <code>afun</code> to
calculates risk difference values from arm X (reference group) and arm Y. These arms are specified
when configuring the risk difference column which is done using the <code><a href="#topic+add_riskdiff">add_riskdiff()</a></code> split function in
the previous call to <code><a href="rtables.html#topic+split_cols_by">rtables::split_cols_by()</a></code>. For all other columns, applies <code>afun</code> as usual. This
function utilizes the <code><a href="#topic+stat_propdiff_ci">stat_propdiff_ci()</a></code> function to perform risk difference calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afun_riskdiff(
  df,
  labelstr = "",
  .var,
  .N_col,
  .N_row,
  .df_row,
  .spl_context,
  .all_col_counts,
  .stats,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL,
  na_str = default_na_str(),
  afun,
  s_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afun_riskdiff_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_labelstr">labelstr</code></td>
<td>
<p>(<code>character</code>)<br /> label of the level of the parent split currently being summarized
(must be present as second argument in Content Row Functions). See <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>
for more information.</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_.n_row">.N_row</code></td>
<td>
<p>(<code>integer</code>)<br /> row-wise N (row group count) for the group of observations being analyzed
(i.e. with no column-based subsetting) that is typically passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_.df_row">.df_row</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data frame across all of the columns for the given row split.</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_.spl_context">.spl_context</code></td>
<td>
<p>(<code>data.frame</code>)<br /> gives information about ancestor split states
that is passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_.all_col_counts">.all_col_counts</code></td>
<td>
<p>(<code>vector</code> of <code>integer</code>)<br /> each value represents a global count for a column. Values are
taken from <code>alt_counts_df</code> if specified (see <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>).</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table.</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_afun">afun</code></td>
<td>
<p>(named <code>list</code>)<br /> A named list containing one name-value pair where the name corresponds to
the name of the statistics function that should be used in calculations and the value is the corresponding
analysis function.</p>
</td></tr>
<tr><td><code id="afun_riskdiff_+3A_s_args">s_args</code></td>
<td>
<p>(named <code>list</code>)<br /> Additional arguments to be passed to the statistics function and analysis
function supplied in <code>afun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+stat_propdiff_ci">stat_propdiff_ci()</a></code> for details on risk difference calculation.
</p>
</li>
<li><p> Split function <code><a href="#topic+add_riskdiff">add_riskdiff()</a></code> which, when used as <code>split_fun</code> within <code><a href="rtables.html#topic+split_cols_by">rtables::split_cols_by()</a></code> with
<code>riskdiff</code> argument set to <code>TRUE</code> in subsequent analyze functions calls, adds a risk difference column
to a table layout.
</p>
</li></ul>


<hr>
<h2 id='afun_selected_stats'>Get Selected Statistics Names</h2><span id='topic+afun_selected_stats'></span>

<h3>Description</h3>

<p>Helper function to be used for creating <code>afun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afun_selected_stats(.stats, all_stats)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afun_selected_stats_+3A_.stats">.stats</code></td>
<td>
<p>(<code>vector</code> or <code>NULL</code>)<br /> input to the layout creating function. Note that <code>NULL</code> means
in this context that all default statistics should be used.</p>
</td></tr>
<tr><td><code id="afun_selected_stats_+3A_all_stats">all_stats</code></td>
<td>
<p>(<code>character</code>)<br /> all statistics which can be selected here potentially.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector with the selected statistics.
</p>

<hr>
<h2 id='analyze_colvars_functions'>Analyze Functions on Columns</h2><span id='topic+analyze_colvars_functions'></span>

<h3>Description</h3>

<p>These functions are wrappers of <code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code> which apply corresponding <code>tern</code>
statistics functions to add an analysis to a given table layout. In particular, these functions
where designed to have the analysis methods split into different columns.
</p>

<ul>
<li> <p><code><a href="#topic+analyze_vars_in_cols">analyze_vars_in_cols()</a></code>: fundamental tabulation of analysis methods onto columns.
In other words, the analysis methods are defined in the column space, i.e. they become
column labels. By changing the variable vector, the list of functions can be applied on
different variables, with the caveat of having the same number of statistical functions.
</p>
</li>
<li> <p><code><a href="#topic+tabulate_rsp_subgroups">tabulate_rsp_subgroups()</a></code>: similarly to <code>analyze_vars_in_cols</code>, this
function combines <code>analyze_colvars</code> and <code>summarize_row_groups</code> in a compact way
to produce standard tables that show analysis methods as columns.
</p>
</li>
<li> <p><code><a href="#topic+tabulate_survival_subgroups">tabulate_survival_subgroups()</a></code>: this function is very similar to the above, but
it is used for other tables.
</p>
</li>
<li> <p><code><a href="#topic+analyze_patients_exposure_in_cols">analyze_patients_exposure_in_cols()</a></code>: based only on <code>analyze_colvars</code>. It needs
<code><a href="#topic+summarize_patients_exposure_in_cols">summarize_patients_exposure_in_cols()</a></code> to leverage nesting of label rows analysis
with <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+summarize_coxreg">summarize_coxreg()</a></code>: generally based on <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>, it behaves
similarly to <code style="white-space: pre;">&#8288;tabulate_*&#8288;</code> functions described above as it is designed to provide
specific standard tables that may contain nested structure with a combination of
<code>summarize_row_groups()</code> and <code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+summarize_functions">summarize_functions</a> for functions which are wrappers for <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>
</li>
<li> <p><a href="#topic+analyze_functions">analyze_functions</a> for functions which are wrappers for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li></ul>


<hr>
<h2 id='analyze_functions'>Analyze Functions</h2><span id='topic+analyze_functions'></span>

<h3>Description</h3>

<p>These functions are wrappers of <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code> which apply corresponding <code>tern</code> statistics functions
to add an analysis to a given table layout:
</p>

<ul>
<li> <p><code><a href="#topic+analyze_num_patients">analyze_num_patients()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+compare_vars">compare_vars()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+count_abnormal">count_abnormal()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+count_abnormal_by_baseline">count_abnormal_by_baseline()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+count_abnormal_by_marked">count_abnormal_by_marked()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+count_abnormal_by_worst_grade">count_abnormal_by_worst_grade()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+count_cumulative">count_cumulative()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+count_missed_doses">count_missed_doses()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+count_occurrences">count_occurrences()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+count_occurrences_by_grade">count_occurrences_by_grade()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+count_patients_events_in_cols">count_patients_events_in_cols()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+count_patients_with_event">count_patients_with_event()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+count_patients_with_flags">count_patients_with_flags()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+count_values">count_values()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+coxph_pairwise">coxph_pairwise()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+estimate_incidence_rate">estimate_incidence_rate()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+estimate_multinomial_rsp">estimate_multinomial_rsp()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+estimate_odds_ratio">estimate_odds_ratio()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+estimate_proportion">estimate_proportion()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+estimate_proportion_diff">estimate_proportion_diff()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+summarize_ancova">summarize_ancova()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+summarize_colvars">summarize_colvars()</a></code>: even if this function uses <code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code>,
it applies the analysis methods as different rows for one or more
variables that are split into different columns. In comparison, <a href="#topic+analyze_colvars_functions">analyze_colvars_functions</a>
leverage <code>analyze_colvars</code> to have the context split in rows and the analysis
methods in columns.
</p>
</li>
<li> <p><code><a href="#topic+summarize_change">summarize_change()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+analyze_vars">analyze_vars()</a></code>: formerly known as <code>summarize_vars()</code>, it was renamed to reflect
core function <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+surv_time">surv_time()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+surv_timepoint">surv_timepoint()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+test_proportion_diff">test_proportion_diff()</a></code>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+summarize_functions">summarize_functions</a> for functions which are wrappers for <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>
</li>
<li> <p><a href="#topic+analyze_colvars_functions">analyze_colvars_functions</a> for functions that are wrappers for <code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code>.
</p>
</li></ul>


<hr>
<h2 id='analyze_variables'>Analyze Variables</h2><span id='topic+analyze_variables'></span><span id='topic+analyze_vars'></span><span id='topic+s_summary'></span><span id='topic+s_summary.numeric'></span><span id='topic+s_summary.factor'></span><span id='topic+s_summary.character'></span><span id='topic+s_summary.logical'></span><span id='topic+a_summary'></span><span id='topic+summarize_vars'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The analyze function <code><a href="#topic+analyze_vars">analyze_vars()</a></code> generates a summary of one or more variables, using the S3 generic function
<code><a href="#topic+s_summary">s_summary()</a></code> to calculate a list of summary statistics. A list of all available statistics for numeric
variables can be viewed by running <code>get_stats("analyze_vars_numeric")</code> and for non-numeric variables by running
<code>get_stats("analyze_vars_counts")</code>. Use the <code>.stats</code> parameter to specify the statistics to include in your output
summary table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_vars(
  lyt,
  vars,
  var_labels = vars,
  na_level = lifecycle::deprecated(),
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  na.rm = TRUE,
  show_labels = "default",
  table_names = vars,
  section_div = NA_character_,
  .stats = c("n", "mean_sd", "median", "range", "count_fraction"),
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_summary(x, na.rm = TRUE, denom, .N_row, .N_col, .var, ...)

## S3 method for class 'numeric'
s_summary(
  x,
  na.rm = TRUE,
  denom,
  .N_row,
  .N_col,
  .var,
  control = control_analyze_vars(),
  ...
)

## S3 method for class 'factor'
s_summary(
  x,
  na.rm = TRUE,
  denom = c("n", "N_row", "N_col"),
  .N_row,
  .N_col,
  ...
)

## S3 method for class 'character'
s_summary(
  x,
  na.rm = TRUE,
  denom = c("n", "N_row", "N_col"),
  .N_row,
  .N_col,
  .var,
  verbose = TRUE,
  ...
)

## S3 method for class 'logical'
s_summary(
  x,
  na.rm = TRUE,
  denom = c("n", "N_row", "N_col"),
  .N_row,
  .N_col,
  ...
)

a_summary(
  x,
  .N_col,
  .N_row,
  .var = NULL,
  .df_row = NULL,
  .ref_group = NULL,
  .in_ref_col = FALSE,
  compare = FALSE,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL,
  na.rm = TRUE,
  na_level = lifecycle::deprecated(),
  na_str = default_na_str(),
  ...
)

summarize_vars(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_variables_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_na_level">na_level</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use the <code>na_str</code> argument instead.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>s_summary()</code>.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>flag</code>)<br /> whether <code>NA</code> values should be removed from <code>x</code> prior to analysis.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_section_div">section_div</code></td>
<td>
<p>(<code>string</code>)<br /> string which should be repeated as a section divider after each group
defined by this split instruction, or <code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("analyze_vars_numeric")</code> to see
statistics available for numeric variables, and <code>get_stats("analyze_vars_counts")</code> for statistics available
for non-numeric variables.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>vector</code> of <code>integer</code>)<br /> indent modifiers for the labels. Each element of the vector
should be a name-value pair with name corresponding to a statistic specified in <code>.stats</code> and value the indentation
for that statistic's row label.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector of numbers we want to analyze.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_denom">denom</code></td>
<td>
<p>(<code>string</code>)<br /> choice of denominator for proportion. Options are:
</p>

<ul>
<li> <p><code>n</code>: number of values in this row and column intersection.
</p>
</li>
<li> <p><code>N_row</code>: total number of values in this row across columns.
</p>
</li>
<li> <p><code>N_col</code>: total number of values in this column across rows.
</p>
</li></ul>
</td></tr>
<tr><td><code id="analyze_variables_+3A_.n_row">.N_row</code></td>
<td>
<p>(<code>integer</code>)<br /> row-wise N (row group count) for the group of observations being analyzed
(i.e. with no column-based subsetting) that is typically passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> parameters for descriptive statistics details, specified by using
the helper function <code><a href="#topic+control_analyze_vars">control_analyze_vars()</a></code>. Some possible parameter options are:
</p>

<ul>
<li> <p><code>conf_level</code> (<code>proportion</code>)<br /> confidence level of the interval for mean and median.
</p>
</li>
<li> <p><code>quantiles</code> (<code>numeric</code>)<br /> vector of length two to specify the quantiles.
</p>
</li>
<li> <p><code>quantile_type</code> (<code>numeric</code>)<br /> between 1 and 9 selecting quantile algorithms to be used.
See more about <code>type</code> in <code><a href="stats.html#topic+quantile">stats::quantile()</a></code>.
</p>
</li>
<li> <p><code>test_mean</code> (<code>numeric</code>)<br /> value to test against the mean under the null hypothesis when calculating p-value.
</p>
</li></ul>
</td></tr>
<tr><td><code id="analyze_variables_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical</code>)<br /> Defaults to <code>TRUE</code>, which prints out warnings and messages. It is mainly used
to print out information about factor casting.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_.df_row">.df_row</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data frame across all of the columns for the given row split.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_.ref_group">.ref_group</code></td>
<td>
<p>(<code>data.frame</code> or <code>vector</code>)<br /> the data corresponding to the reference group.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_.in_ref_col">.in_ref_col</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> when working with the reference level, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="analyze_variables_+3A_compare">compare</code></td>
<td>
<p>(<code>logical</code>)<br /> Whether comparison statistics should be analyzed instead of summary statistics
(<code>compare = TRUE</code> adds <code>pval</code> statistic comparing against reference group).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Automatic digit formatting:</strong> The number of digits to display can be automatically determined from the analyzed
variable(s) (<code>vars</code>) for certain statistics by setting the statistic format to <code>"auto"</code> in <code>.formats</code>.
This utilizes the <code><a href="#topic+format_auto">format_auto()</a></code> formatting function. Note that only data for the current row &amp; variable (for all
columns) will be considered (<code>.df_row[[.var]]</code>, see <code><a href="rtables.html#topic+additional_fun_params">rtables::additional_fun_params</a></code>) and not the whole dataset.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>analyze_vars()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_summary()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_summary()</code> returns different statistics depending on the class of <code>x</code>.
</p>
</li></ul>


<ul>
<li><p> If <code>x</code> is of class <code>numeric</code>, returns a <code>list</code> with the following named <code>numeric</code> items:
</p>

<ul>
<li> <p><code>n</code>: The <code><a href="base.html#topic+length">length()</a></code> of <code>x</code>.
</p>
</li>
<li> <p><code>sum</code>: The <code><a href="base.html#topic+sum">sum()</a></code> of <code>x</code>.
</p>
</li>
<li> <p><code>mean</code>: The <code><a href="base.html#topic+mean">mean()</a></code> of <code>x</code>.
</p>
</li>
<li> <p><code>sd</code>: The <code><a href="stats.html#topic+sd">stats::sd()</a></code> of <code>x</code>.
</p>
</li>
<li> <p><code>se</code>: The standard error of <code>x</code> mean, i.e.: (<code>sd(x) / sqrt(length(x))</code>).
</p>
</li>
<li> <p><code>mean_sd</code>: The <code><a href="base.html#topic+mean">mean()</a></code> and <code><a href="stats.html#topic+sd">stats::sd()</a></code> of <code>x</code>.
</p>
</li>
<li> <p><code>mean_se</code>: The <code><a href="base.html#topic+mean">mean()</a></code> of <code>x</code> and its standard error (see above).
</p>
</li>
<li> <p><code>mean_ci</code>: The CI for the mean of <code>x</code> (from <code><a href="#topic+stat_mean_ci">stat_mean_ci()</a></code>).
</p>
</li>
<li> <p><code>mean_sei</code>: The SE interval for the mean of <code>x</code>, i.e.: (<code><a href="base.html#topic+mean">mean()</a></code> -/+ <code><a href="stats.html#topic+sd">stats::sd()</a></code> / <code><a href="base.html#topic+sqrt">sqrt()</a></code>).
</p>
</li>
<li> <p><code>mean_sdi</code>: The SD interval for the mean of <code>x</code>, i.e.: (<code><a href="base.html#topic+mean">mean()</a></code> -/+ <code><a href="stats.html#topic+sd">stats::sd()</a></code>).
</p>
</li>
<li> <p><code>mean_pval</code>: The two-sided p-value of the mean of <code>x</code> (from <code><a href="#topic+stat_mean_pval">stat_mean_pval()</a></code>).
</p>
</li>
<li> <p><code>median</code>: The <code><a href="stats.html#topic+median">stats::median()</a></code> of <code>x</code>.
</p>
</li>
<li> <p><code>mad</code>: The median absolute deviation of <code>x</code>, i.e.: (<code><a href="stats.html#topic+median">stats::median()</a></code> of <code>xc</code>,
where <code>xc</code> = <code>x</code> - <code><a href="stats.html#topic+median">stats::median()</a></code>).
</p>
</li>
<li> <p><code>median_ci</code>: The CI for the median of <code>x</code> (from <code><a href="#topic+stat_median_ci">stat_median_ci()</a></code>).
</p>
</li>
<li> <p><code>quantiles</code>: Two sample quantiles of <code>x</code> (from <code><a href="stats.html#topic+quantile">stats::quantile()</a></code>).
</p>
</li>
<li> <p><code>iqr</code>: The <code><a href="stats.html#topic+IQR">stats::IQR()</a></code> of <code>x</code>.
</p>
</li>
<li> <p><code>range</code>: The <code><a href="#topic+range_noinf">range_noinf()</a></code> of <code>x</code>.
</p>
</li>
<li> <p><code>min</code>: The <code><a href="base.html#topic+max">max()</a></code> of <code>x</code>.
</p>
</li>
<li> <p><code>max</code>: The <code><a href="base.html#topic+min">min()</a></code> of <code>x</code>.
</p>
</li>
<li> <p><code>median_range</code>: The <code><a href="stats.html#topic+median">median()</a></code> and <code><a href="#topic+range_noinf">range_noinf()</a></code> of <code>x</code>.
</p>
</li>
<li> <p><code>cv</code>: The coefficient of variation of <code>x</code>, i.e.: (<code><a href="stats.html#topic+sd">stats::sd()</a></code> / <code><a href="base.html#topic+mean">mean()</a></code> * 100).
</p>
</li>
<li> <p><code>geom_mean</code>: The geometric mean of <code>x</code>, i.e.: (<code>exp(mean(log(x)))</code>).
</p>
</li>
<li> <p><code>geom_cv</code>: The geometric coefficient of variation of <code>x</code>, i.e.: (<code>sqrt(exp(sd(log(x)) ^ 2) - 1) * 100</code>).
</p>
</li></ul>

</li></ul>


<ul>
<li><p> If <code>x</code> is of class <code>factor</code> or converted from <code>character</code>, returns a <code>list</code> with named <code>numeric</code> items:
</p>

<ul>
<li> <p><code>n</code>: The <code><a href="base.html#topic+length">length()</a></code> of <code>x</code>.
</p>
</li>
<li> <p><code>count</code>: A list with the number of cases for each level of the factor <code>x</code>.
</p>
</li>
<li> <p><code>count_fraction</code>: Similar to <code>count</code> but also includes the proportion of cases for each level of the
factor <code>x</code> relative to the denominator, or <code>NA</code> if the denominator is zero.
</p>
</li></ul>

</li></ul>


<ul>
<li><p> If <code>x</code> is of class <code>logical</code>, returns a <code>list</code> with named <code>numeric</code> items:
</p>

<ul>
<li> <p><code>n</code>: The <code><a href="base.html#topic+length">length()</a></code> of <code>x</code> (possibly after removing <code>NA</code>s).
</p>
</li>
<li> <p><code>count</code>: Count of <code>TRUE</code> in <code>x</code>.
</p>
</li>
<li> <p><code>count_fraction</code>: Count and proportion of <code>TRUE</code> in <code>x</code> relative to the denominator, or <code>NA</code> if the
denominator is zero. Note that <code>NA</code>s in <code>x</code> are never counted or leading to <code>NA</code> here.
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>a_summary()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>analyze_vars()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_summary()</code>: S3 generic function to produces a variable summary.
</p>
</li>
<li> <p><code>s_summary(numeric)</code>: Method for <code>numeric</code> class.
</p>
</li>
<li> <p><code>s_summary(factor)</code>: Method for <code>factor</code> class.
</p>
</li>
<li> <p><code>s_summary(character)</code>: Method for <code>character</code> class. This makes an automatic
conversion to factor (with a warning) and then forwards to the method for factors.
</p>
</li>
<li> <p><code>s_summary(logical)</code>: Method for <code>logical</code> class.
</p>
</li>
<li> <p><code>a_summary()</code>: Formatted analysis function which is used as <code>afun</code> in <code>analyze_vars()</code> and
<code>compare_vars()</code> and as <code>cfun</code> in <code>summarize_colvars()</code>.
</p>
</li>
<li> <p><code>summarize_vars()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>analyze_vars</code> instead.
</p>
</li></ul>


<h3>Note</h3>


<ul>
<li><p> Deprecation cycle started for <code>summarize_vars</code> which has been renamed to <code>analyze_vars</code>. This renaming is intended
to better reflect its core underlying <code>rtables</code> functions - in this case <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li></ul>


<ul>
<li><p> If <code>x</code> is an empty vector, <code>NA</code> is returned. This is the expected feature so as to return <code>rcell</code> content in
<code>rtables</code> when the intersection of a column and a row delimits an empty data selection.
</p>
</li>
<li><p> When the <code>mean</code> function is applied to an empty vector, <code>NA</code> will be returned instead of <code>NaN</code>, the latter
being standard behavior in R.
</p>
</li></ul>


<ul>
<li><p> If <code>x</code> is an empty <code>factor</code>, a list is still returned for <code>counts</code> with one element
per factor level. If there are no levels in <code>x</code>, the function fails.
</p>
</li>
<li><p> If factor variables contain <code>NA</code>, these <code>NA</code> values are excluded by default. To include <code>NA</code> values
set <code>na.rm = FALSE</code> and missing values will be displayed as an <code>NA</code> level. Alternatively, an explicit
factor level can be defined for <code>NA</code> values during pre-processing via <code><a href="#topic+df_explicit_na">df_explicit_na()</a></code> - the
default <code>na_level</code> (<code>"&lt;Missing&gt;"</code>) will also be excluded when <code>na.rm</code> is set to <code>TRUE</code>.
</p>
</li></ul>


<ul>
<li><p> Automatic conversion of character to factor does not guarantee that the table
can be generated correctly. In particular for sparse tables this very likely can fail.
It is therefore better to always pre-process the dataset such that factors are manually
created from character variables before passing the dataset to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>.
</p>
</li></ul>


<ul>
<li><p> To use for comparison (with additional p-value statistic), parameter <code>compare</code> must be set to <code>TRUE</code>.
</p>
</li>
<li><p> Ensure that either all <code>NA</code> values are converted to an explicit <code>NA</code> level or all <code>NA</code> values are left as is.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Fabricated dataset.
dta_test &lt;- data.frame(
  USUBJID = rep(1:6, each = 3),
  PARAMCD = rep("lab", 6 * 3),
  AVISIT  = rep(paste0("V", 1:3), 6),
  ARM     = rep(LETTERS[1:3], rep(6, 3)),
  AVAL    = c(9:1, rep(NA, 9))
)

# `analyze_vars()` in `rtables` pipelines
## Default output within a `rtables` pipeline.
l &lt;- basic_table() %&gt;%
  split_cols_by(var = "ARM") %&gt;%
  split_rows_by(var = "AVISIT") %&gt;%
  analyze_vars(vars = "AVAL")

build_table(l, df = dta_test)

## Select and format statistics output.
l &lt;- basic_table() %&gt;%
  split_cols_by(var = "ARM") %&gt;%
  split_rows_by(var = "AVISIT") %&gt;%
  analyze_vars(
    vars = "AVAL",
    .stats = c("n", "mean_sd", "quantiles"),
    .formats = c("mean_sd" = "xx.x, xx.x"),
    .labels = c(n = "n", mean_sd = "Mean, SD", quantiles = c("Q1 - Q3"))
  )

build_table(l, df = dta_test)

## Use arguments interpreted by `s_summary`.
l &lt;- basic_table() %&gt;%
  split_cols_by(var = "ARM") %&gt;%
  split_rows_by(var = "AVISIT") %&gt;%
  analyze_vars(vars = "AVAL", na.rm = FALSE)

build_table(l, df = dta_test)

## Handle `NA` levels first when summarizing factors.
dta_test$AVISIT &lt;- NA_character_
dta_test &lt;- df_explicit_na(dta_test)
l &lt;- basic_table() %&gt;%
  split_cols_by(var = "ARM") %&gt;%
  analyze_vars(vars = "AVISIT", na.rm = FALSE)

build_table(l, df = dta_test)

# auto format
dt &lt;- data.frame("VAR" = c(0.001, 0.2, 0.0011000, 3, 4))
basic_table() %&gt;%
  analyze_vars(
    vars = "VAR",
    .stats = c("n", "mean", "mean_sd", "range"),
    .formats = c("mean_sd" = "auto", "range" = "auto")
  ) %&gt;%
  build_table(dt)

# `s_summary.numeric`

## Basic usage: empty numeric returns NA-filled items.
s_summary(numeric())

## Management of NA values.
x &lt;- c(NA_real_, 1)
s_summary(x, na.rm = TRUE)
s_summary(x, na.rm = FALSE)

x &lt;- c(NA_real_, 1, 2)
s_summary(x, stats = NULL)

## Benefits in `rtables` contructions:
require(rtables)
dta_test &lt;- data.frame(
  Group = rep(LETTERS[1:3], each = 2),
  sub_group = rep(letters[1:2], each = 3),
  x = 1:6
)

## The summary obtained in with `rtables`:
basic_table() %&gt;%
  split_cols_by(var = "Group") %&gt;%
  split_rows_by(var = "sub_group") %&gt;%
  analyze(vars = "x", afun = s_summary) %&gt;%
  build_table(df = dta_test)

## By comparison with `lapply`:
X &lt;- split(dta_test, f = with(dta_test, interaction(Group, sub_group)))
lapply(X, function(x) s_summary(x$x))

# `s_summary.factor`

## Basic usage:
s_summary(factor(c("a", "a", "b", "c", "a")))

# Empty factor returns zero-filled items.
s_summary(factor(levels = c("a", "b", "c")))

## Management of NA values.
x &lt;- factor(c(NA, "Female"))
x &lt;- explicit_na(x)
s_summary(x, na.rm = TRUE)
s_summary(x, na.rm = FALSE)

## Different denominators.
x &lt;- factor(c("a", "a", "b", "c", "a"))
s_summary(x, denom = "N_row", .N_row = 10L)
s_summary(x, denom = "N_col", .N_col = 20L)

# `s_summary.character`

## Basic usage:
s_summary(c("a", "a", "b", "c", "a"), .var = "x", verbose = FALSE)
s_summary(c("a", "a", "b", "c", "a", ""), .var = "x", na.rm = FALSE, verbose = FALSE)

# `s_summary.logical`

## Basic usage:
s_summary(c(TRUE, FALSE, TRUE, TRUE))

# Empty factor returns zero-filled items.
s_summary(as.logical(c()))

## Management of NA values.
x &lt;- c(NA, TRUE, FALSE)
s_summary(x, na.rm = TRUE)
s_summary(x, na.rm = FALSE)

## Different denominators.
x &lt;- c(TRUE, FALSE, TRUE, TRUE)
s_summary(x, denom = "N_row", .N_row = 10L)
s_summary(x, denom = "N_col", .N_col = 20L)

a_summary(factor(c("a", "a", "b", "c", "a")), .N_row = 10, .N_col = 10)
a_summary(
  factor(c("a", "a", "b", "c", "a")),
  .ref_group = factor(c("a", "a", "b", "c")), compare = TRUE
)

a_summary(c("A", "B", "A", "C"), .var = "x", .N_col = 10, .N_row = 10, verbose = FALSE)
a_summary(
  c("A", "B", "A", "C"),
  .ref_group = c("B", "A", "C"), .var = "x", compare = TRUE, verbose = FALSE
)

a_summary(c(TRUE, FALSE, FALSE, TRUE, TRUE), .N_row = 10, .N_col = 10)
a_summary(
  c(TRUE, FALSE, FALSE, TRUE, TRUE),
  .ref_group = c(TRUE, FALSE), .in_ref_col = TRUE, compare = TRUE
)

a_summary(rnorm(10), .N_col = 10, .N_row = 20, .var = "bla")
a_summary(rnorm(10, 5, 1), .ref_group = rnorm(20, -5, 1), .var = "bla", compare = TRUE)

</code></pre>

<hr>
<h2 id='analyze_vars_in_cols'>Summary numeric variables in columns</h2><span id='topic+analyze_vars_in_cols'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Layout-creating function which can be used for creating column-wise summary tables.
This function sets the analysis methods as column labels and is a wrapper for
<code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code>. It was designed principally for PK tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_vars_in_cols(
  lyt,
  vars,
  ...,
  .stats = c("n", "mean", "sd", "se", "cv", "geom_cv"),
  .labels = c(n = "n", mean = "Mean", sd = "SD", se = "SE", cv = "CV (%)", geom_cv =
    "CV % Geometric Mean"),
  row_labels = NULL,
  do_summarize_row_groups = FALSE,
  split_col_vars = TRUE,
  imp_rule = NULL,
  avalcat_var = "AVALCAT1",
  cache = FALSE,
  .indent_mods = NULL,
  na_level = lifecycle::deprecated(),
  na_str = default_na_str(),
  nested = TRUE,
  .formats = NULL,
  .aligns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_vars_in_cols_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_row_labels">row_labels</code></td>
<td>
<p>(<code>character</code>)<br /> as this function works in columns space, usual <code>.labels</code>
character vector applies on the column space. You can change the row labels by defining this
parameter to a named character vector with names corresponding to the split values. It defaults
to <code>NULL</code> and if it contains only one <code>string</code>, it will duplicate that as a row label.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_do_summarize_row_groups">do_summarize_row_groups</code></td>
<td>
<p>(<code>flag</code>)<br /> defaults to <code>FALSE</code> and applies the analysis to the current
label rows. This is a wrapper of <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code> and it can accept <code>labelstr</code>
to define row labels. This behavior is not supported as we never need to overload row labels.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_split_col_vars">split_col_vars</code></td>
<td>
<p>(<code>flag</code>)<br /> defaults to <code>TRUE</code> and puts the analysis results onto the columns.
This option allows you to add multiple instances of this functions, also in a nested fashion,
without adding more splits. This split must happen only one time on a single layout.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_imp_rule">imp_rule</code></td>
<td>
<p>(<code>character</code>)<br /> imputation rule setting. Defaults to <code>NULL</code> for no imputation rule. Can
also be <code>"1/3"</code> to implement 1/3 imputation rule or <code>"1/2"</code> to implement 1/2 imputation rule. In order
to use an imputation rule, the <code>avalcat_var</code> argument must be specified. See <code><a href="#topic+imputation_rule">imputation_rule()</a></code>
for more details on imputation.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_avalcat_var">avalcat_var</code></td>
<td>
<p>(<code>character</code>)<br /> if <code>imp_rule</code> is not <code>NULL</code>, name of variable that indicates whether a
row in the data corresponds to an analysis value in category <code>"BLQ"</code>, <code>"LTR"</code>, <code>"&lt;PCLLOQ"</code>, or none of
the above (defaults to <code>"AVALCAT1"</code>). Variable must be present in the data and should match the variable
used to calculate the <code>n_blq</code> statistic (if included in <code>.stats</code>).</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_cache">cache</code></td>
<td>
<p>(<code>flag</code>)<br /> whether to store computed values in a temporary caching environment. This will
speed up calculations in large tables, but should be set to <code>FALSE</code> if the same <code>rtable</code> layout is
used for multiple tables with different data. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_na_level">na_level</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use the <code>na_str</code> argument instead.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="analyze_vars_in_cols_+3A_.aligns">.aligns</code></td>
<td>
<p>(<code>character</code>)<br /> alignment for table contents (not including labels). When <code>NULL</code>, <code>"center"</code>
is applied. See <code><a href="formatters.html#topic+list_formats">formatters::list_valid_aligns()</a></code> for a list of all currently supported alignments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A layout object suitable for passing to further layouting functions, or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>.
Adding this function to an <code>rtable</code> layout will summarize the given variables, arrange the output
in columns, and add it to the table layout.
</p>


<h3>Note</h3>

<p>This is an experimental implementation of <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code> and
<code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code> that may be subjected to changes as <code>rtables</code> extends its
support to more complex analysis pipelines on the column space. For the same reasons,
we encourage to read the examples carefully and file issues for cases that differ from
them.
</p>
<p>Here <code>labelstr</code> behaves differently than usual. If it is not defined (default as <code>NULL</code>),
row labels are assigned automatically to the split values in case of <code>rtables::analyze_colvars</code>
(<code>do_summarize_row_groups = FALSE</code>, the default), and to the group label for
<code>do_summarize_row_groups = TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze_vars">analyze_vars()</a></code>, <code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Data preparation
adpp &lt;- tern_ex_adpp %&gt;% h_pkparam_sort()

lyt &lt;- basic_table() %&gt;%
  split_rows_by(var = "STRATA1", label_pos = "topleft") %&gt;%
  split_rows_by(
    var = "SEX",
    label_pos = "topleft",
    child_label = "hidden"
  ) %&gt;% # Removes duplicated labels
  analyze_vars_in_cols(vars = "AGE")
result &lt;- build_table(lyt = lyt, df = adpp)
result

# By selecting just some statistics and ad-hoc labels
lyt &lt;- basic_table() %&gt;%
  split_rows_by(var = "ARM", label_pos = "topleft") %&gt;%
  split_rows_by(
    var = "SEX",
    label_pos = "topleft",
    child_labels = "hidden",
    split_fun = drop_split_levels
  ) %&gt;%
  analyze_vars_in_cols(
    vars = "AGE",
    .stats = c("n", "cv", "geom_mean"),
    .labels = c(
      n = "aN",
      cv = "aCV",
      geom_mean = "aGeomMean"
    )
  )
result &lt;- build_table(lyt = lyt, df = adpp)
result

# Changing row labels
lyt &lt;- basic_table() %&gt;%
  analyze_vars_in_cols(
    vars = "AGE",
    row_labels = "some custom label"
  )
result &lt;- build_table(lyt, df = adpp)
result

# Pharmacokinetic parameters
lyt &lt;- basic_table() %&gt;%
  split_rows_by(
    var = "TLG_DISPLAY",
    split_label = "PK Parameter",
    label_pos = "topleft",
    child_label = "hidden"
  ) %&gt;%
  analyze_vars_in_cols(
    vars = "AVAL"
  )
result &lt;- build_table(lyt, df = adpp)
result

# Multiple calls (summarize label and analyze underneath)
lyt &lt;- basic_table() %&gt;%
  split_rows_by(
    var = "TLG_DISPLAY",
    split_label = "PK Parameter",
    label_pos = "topleft"
  ) %&gt;%
  analyze_vars_in_cols(
    vars = "AVAL",
    do_summarize_row_groups = TRUE # does a summarize level
  ) %&gt;%
  split_rows_by("SEX",
    child_label = "hidden",
    label_pos = "topleft"
  ) %&gt;%
  analyze_vars_in_cols(
    vars = "AVAL",
    split_col_vars = FALSE # avoids re-splitting the columns
  )
result &lt;- build_table(lyt, df = adpp)
result

</code></pre>

<hr>
<h2 id='append_varlabels'>Add Variable Labels to Top Left Corner in Table</h2><span id='topic+append_varlabels'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper layout creating function to just append the variable labels of a given variables vector
from a given dataset in the top left corner. If a variable label is not found then the
variable name itself is used instead. Multiple variable labels are concatenated with slashes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_varlabels(lyt, df, vars, indent = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_varlabels_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="append_varlabels_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="append_varlabels_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names of which the labels are to be looked up in <code>df</code>.</p>
</td></tr>
<tr><td><code id="append_varlabels_+3A_indent">indent</code></td>
<td>
<p>(<code>integer</code>)<br /> non-negative number of nested indent space, default to 0L which means no indent.
1L means two spaces indent, 2L means four spaces indent and so on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified layout with the new variable label(s) added to the top-left material.
</p>


<h3>Note</h3>

<p>This is not an optimal implementation of course, since we are using here the data set
itself during the layout creation. When we have a more mature <code>rtables</code> implementation then
this will also be improved or not necessary anymore.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_colcounts() %&gt;%
  split_rows_by("SEX") %&gt;%
  append_varlabels(DM, "SEX") %&gt;%
  analyze("AGE", afun = mean) %&gt;%
  append_varlabels(DM, "AGE", indent = 1)
build_table(lyt, DM)

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("SEX") %&gt;%
  analyze("AGE", afun = mean) %&gt;%
  append_varlabels(DM, c("SEX", "AGE"))
build_table(lyt, DM)

</code></pre>

<hr>
<h2 id='apply_auto_formatting'>Apply Auto Formatting</h2><span id='topic+apply_auto_formatting'></span>

<h3>Description</h3>

<p>Checks if any of the listed formats in <code>.formats</code> are <code>"auto"</code>, and replaces <code>"auto"</code> with
the correct implementation of <code>format_auto</code> for the given statistics, data, and variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_auto_formatting(.formats, x_stats, .df_row, .var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_auto_formatting_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="apply_auto_formatting_+3A_x_stats">x_stats</code></td>
<td>
<p>(named <code>list</code>)<br /> a named list of statistics where each element corresponds
to an element in <code>.formats</code>, with matching names.</p>
</td></tr>
<tr><td><code id="apply_auto_formatting_+3A_.df_row">.df_row</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data frame across all of the columns for the given row split.</p>
</td></tr>
<tr><td><code id="apply_auto_formatting_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
</table>

<hr>
<h2 id='argument_convention'>Standard Arguments</h2><span id='topic+argument_convention'></span>

<h3>Description</h3>

<p>The documentation to this function lists all the arguments in <code>tern</code>
that are used repeatedly to express an analysis.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="argument_convention_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_.aligns">.aligns</code></td>
<td>
<p>(<code>character</code>)<br /> alignment for table contents (not including labels). When <code>NULL</code>, <code>"center"</code>
is applied. See <code><a href="formatters.html#topic+list_formats">formatters::list_valid_aligns()</a></code> for a list of all currently supported alignments.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_.all_col_counts">.all_col_counts</code></td>
<td>
<p>(<code>vector</code> of <code>integer</code>)<br /> each value represents a global count for a column. Values are
taken from <code>alt_counts_df</code> if specified (see <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>).</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_.df_row">.df_row</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data frame across all of the columns for the given row split.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_.in_ref_col">.in_ref_col</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> when working with the reference level, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_.n_row">.N_row</code></td>
<td>
<p>(<code>integer</code>)<br /> row-wise N (row group count) for the group of observations being analyzed
(i.e. with no column-based subsetting) that is typically passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_.ref_group">.ref_group</code></td>
<td>
<p>(<code>data.frame</code> or <code>vector</code>)<br /> the data corresponding to the reference group.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_.spl_context">.spl_context</code></td>
<td>
<p>(<code>data.frame</code>)<br /> gives information about ancestor split states
that is passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_add_total_level">add_total_level</code></td>
<td>
<p>(<code>flag</code>)<br /> adds a &quot;total&quot; level after the others which includes all the levels
that constitute the split. A custom label can be set for this level via the <code>custom_label</code> argument.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_col_by">col_by</code></td>
<td>
<p>(<code>factor</code>)<br /> defining column groups.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to summarize.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_draw">draw</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the plot should be drawn.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_groups_lists">groups_lists</code></td>
<td>
<p>(named <code>list</code> of <code>list</code>)<br /> optionally contains for each <code>subgroups</code> variable a
list, which specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_id">id</code></td>
<td>
<p>(<code>string</code>)<br /> subject variable name.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_is_event">is_event</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> if event, <code>FALSE</code> if time to event is censored.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_indent_mod">indent_mod</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use the <code>.indent_mods</code> argument instead.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_label_all">label_all</code></td>
<td>
<p>(<code>string</code>)<br /> label for the total population analysis.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_labelstr">labelstr</code></td>
<td>
<p>(<code>character</code>)<br /> label of the level of the parent split currently being summarized
(must be present as second argument in Content Row Functions). See <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>
for more information.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_method">method</code></td>
<td>
<p>(<code>string</code>)<br /> specifies the test used to calculate the p-value for the difference between
two proportions. For options, see <code><a href="#topic+s_test_proportion_diff">s_test_proportion_diff()</a></code>. Default is <code>NULL</code> so no test is performed.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>flag</code>)<br /> whether <code>NA</code> values should be removed from <code>x</code> prior to analysis.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_na_level">na_level</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use the <code>na_str</code> argument instead.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_newpage">newpage</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the plot should be drawn on a new page.
Only considered if <code>draw = TRUE</code> is used.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_prune_zero_rows">prune_zero_rows</code></td>
<td>
<p>(<code>flag</code>)<br /> whether to prune all zero rows.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_riskdiff">riskdiff</code></td>
<td>
<p>(<code>flag</code>)<br /> whether a risk difference column is present. When set to <code>TRUE</code>, <code><a href="#topic+add_riskdiff">add_riskdiff()</a></code> must be
used as <code>split_fun</code> in the prior column split of the table layout, specifying which columns should be compared.
See <code><a href="#topic+stat_propdiff_ci">stat_propdiff_ci()</a></code> for details on risk difference calculation.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_rsp">rsp</code></td>
<td>
<p>(<code>logical</code>)<br /> whether each subject is a responder or not.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_section_div">section_div</code></td>
<td>
<p>(<code>string</code>)<br /> string which should be repeated as a section divider after each group
defined by this split instruction, or <code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_tte">tte</code></td>
<td>
<p>(<code>numeric</code>)<br /> contains time-to-event duration values.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name for the primary analysis variable.</p>
</td></tr>
<tr><td><code id="argument_convention_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector of numbers we want to analyze.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although this function just returns <code>NULL</code> it has two uses, for
the <code>tern</code> users it provides a documentation of arguments that are
commonly and consistently used in the framework. For the developer it adds a
single reference point to import the <code>roxygen</code> argument description with:
<code style="white-space: pre;">&#8288;@inheritParams argument_convention&#8288;</code>
</p>

<hr>
<h2 id='arrange_grobs'>Arrange Multiple Grobs</h2><span id='topic+arrange_grobs'></span>

<h3>Description</h3>

<p>Arrange grobs as a new grob with <code style="white-space: pre;">&#8288;n*m (rows*cols)&#8288;</code> layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange_grobs(
  ...,
  grobs = list(...),
  ncol = NULL,
  nrow = NULL,
  padding_ht = grid::unit(2, "line"),
  padding_wt = grid::unit(2, "line"),
  vp = NULL,
  gp = NULL,
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange_grobs_+3A_...">...</code></td>
<td>
<p>grobs.</p>
</td></tr>
<tr><td><code id="arrange_grobs_+3A_grobs">grobs</code></td>
<td>
<p>list of grobs.</p>
</td></tr>
<tr><td><code id="arrange_grobs_+3A_ncol">ncol</code></td>
<td>
<p>number of columns in layout.</p>
</td></tr>
<tr><td><code id="arrange_grobs_+3A_nrow">nrow</code></td>
<td>
<p>number of rows in layout.</p>
</td></tr>
<tr><td><code id="arrange_grobs_+3A_padding_ht">padding_ht</code></td>
<td>
<p>unit of length 1, vertical space between each grob.</p>
</td></tr>
<tr><td><code id="arrange_grobs_+3A_padding_wt">padding_wt</code></td>
<td>
<p>unit of length 1, horizontal space between each grob.</p>
</td></tr>
<tr><td><code id="arrange_grobs_+3A_vp">vp</code></td>
<td>
<p>a <code><a href="grid.html#topic+viewport">viewport()</a></code> object (or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="arrange_grobs_+3A_gp">gp</code></td>
<td>
<p>A <code><a href="grid.html#topic+gpar">gpar()</a></code> object.</p>
</td></tr>
<tr><td><code id="arrange_grobs_+3A_name">name</code></td>
<td>
<p>a character identifier for the grob.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>grob</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(grid)


num &lt;- lapply(1:9, textGrob)
grid::grid.newpage()
grid.draw(arrange_grobs(grobs = num, ncol = 2))

showViewport()

g1 &lt;- circleGrob(gp = gpar(col = "blue"))
g2 &lt;- circleGrob(gp = gpar(col = "red"))
g3 &lt;- textGrob("TEST TEXT")
grid::grid.newpage()
grid.draw(arrange_grobs(g1, g2, g3, nrow = 2))

showViewport()

grid::grid.newpage()
grid.draw(arrange_grobs(g1, g2, g3, ncol = 3))

grid::grid.newpage()
grid::pushViewport(grid::viewport(layout = grid::grid.layout(1, 2)))
vp1 &lt;- grid::viewport(layout.pos.row = 1, layout.pos.col = 2)
grid.draw(arrange_grobs(g1, g2, g3, ncol = 2, vp = vp1))

showViewport()

</code></pre>

<hr>
<h2 id='as_factor_keep_attributes'>Conversion of a Vector to a Factor</h2><span id='topic+as_factor_keep_attributes'></span>

<h3>Description</h3>

<p>Converts <code>x</code> to a factor and keeps its attributes. Warns appropriately such that the user
can decide whether they prefer converting to factor manually (e.g. for full control of
factor levels).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_factor_keep_attributes(
  x,
  x_name = deparse(substitute(x)),
  na_level = "&lt;Missing&gt;",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_factor_keep_attributes_+3A_x">x</code></td>
<td>
<p>(<code>atomic</code>)<br /> object to convert.</p>
</td></tr>
<tr><td><code id="as_factor_keep_attributes_+3A_x_name">x_name</code></td>
<td>
<p>(<code>string</code>)<br /> name of <code>x</code>.</p>
</td></tr>
<tr><td><code id="as_factor_keep_attributes_+3A_na_level">na_level</code></td>
<td>
<p>(<code>string</code>)<br /> the explicit missing level which should be used when converting a character vector.</p>
</td></tr>
<tr><td><code id="as_factor_keep_attributes_+3A_verbose">verbose</code></td>
<td>
<p>defaults to <code>TRUE</code>. It prints out warnings and messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>factor</code> with same attributes (except class) as <code>x</code>. Does not modify <code>x</code> if already a <code>factor</code>.
</p>

<hr>
<h2 id='as.rtable'>Convert to <code>rtable</code></h2><span id='topic+as.rtable'></span><span id='topic+as.rtable.data.frame'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is a new generic function to convert objects to <code>rtable</code> tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.rtable(x, ...)

## S3 method for class 'data.frame'
as.rtable(x, format = "xx.xx", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.rtable_+3A_x">x</code></td>
<td>
<p>the object which should be converted to an <code>rtable</code>.</p>
</td></tr>
<tr><td><code id="as.rtable_+3A_...">...</code></td>
<td>
<p>additional arguments for methods.</p>
</td></tr>
<tr><td><code id="as.rtable_+3A_format">format</code></td>
<td>
<p>the format which should be used for the columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>rtables</code> table object. Note that the concrete class will depend on the method used.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.rtable(data.frame)</code>: method for converting <code>data.frame</code> that contain numeric columns to <code>rtable</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
  a = 1:10,
  b = rnorm(10)
)
as.rtable(x)

</code></pre>

<hr>
<h2 id='assertions'>Additional Assertions for <code>checkmate</code></h2><span id='topic+assertions'></span><span id='topic+assert_list_of_variables'></span><span id='topic+assert_df_with_variables'></span><span id='topic+assert_valid_factor'></span><span id='topic+assert_df_with_factors'></span><span id='topic+assert_proportion_value'></span>

<h3>Description</h3>

<p>Additional assertion functions which can be used together with the <code>checkmate</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_list_of_variables(x, .var.name = checkmate::vname(x), add = NULL)

assert_df_with_variables(
  df,
  variables,
  na_level = NULL,
  .var.name = checkmate::vname(df),
  add = NULL
)

assert_valid_factor(
  x,
  min.levels = 1,
  max.levels = NULL,
  null.ok = TRUE,
  any.missing = TRUE,
  n.levels = NULL,
  len = NULL,
  .var.name = checkmate::vname(x),
  add = NULL
)

assert_df_with_factors(
  df,
  variables,
  min.levels = 1,
  max.levels = NULL,
  any.missing = TRUE,
  na_level = NULL,
  .var.name = checkmate::vname(df),
  add = NULL
)

assert_proportion_value(x, include_boundaries = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assertions_+3A_x">x</code></td>
<td>
<p>(<code>any</code>)<br /> object to test.</p>
</td></tr>
<tr><td><code id="assertions_+3A_.var.name">.var.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the checked object to print in assertions. Defaults to
the heuristic implemented in <code><a href="checkmate.html#topic+vname">vname</a></code>.</p>
</td></tr>
<tr><td><code id="assertions_+3A_add">add</code></td>
<td>
<p>[<code>AssertCollection</code>]<br />
Collection to store assertion messages. See <code><a href="checkmate.html#topic+AssertCollection">AssertCollection</a></code>.</p>
</td></tr>
<tr><td><code id="assertions_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set to test.</p>
</td></tr>
<tr><td><code id="assertions_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>character</code>)<br /> list of variables to test.</p>
</td></tr>
<tr><td><code id="assertions_+3A_na_level">na_level</code></td>
<td>
<p>(<code>character</code>)<br /> the string you have been using to represent NA or
missing data. For <code>NA</code> values please consider using directly <code><a href="Matrix.html#topic+is.na">is.na()</a></code> or
similar approaches.</p>
</td></tr>
<tr><td><code id="assertions_+3A_min.levels">min.levels</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Minimum number of factor levels.
Default is <code>NULL</code> (no check).</p>
</td></tr>
<tr><td><code id="assertions_+3A_max.levels">max.levels</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Maximum number of factor levels.
Default is <code>NULL</code> (no check).</p>
</td></tr>
<tr><td><code id="assertions_+3A_null.ok">null.ok</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If set to <code>TRUE</code>, <code>x</code> may also be <code>NULL</code>.
In this case only a type check of <code>x</code> is performed, all additional checks are disabled.</p>
</td></tr>
<tr><td><code id="assertions_+3A_any.missing">any.missing</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Are vectors with missing values allowed? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="assertions_+3A_n.levels">n.levels</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Exact number of factor levels.
Default is <code>NULL</code> (no check).</p>
</td></tr>
<tr><td><code id="assertions_+3A_len">len</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Exact expected length of <code>x</code>.</p>
</td></tr>
<tr><td><code id="assertions_+3A_include_boundaries">include_boundaries</code></td>
<td>
<p>(<code>logical</code>)<br /> whether to include boundaries when testing
for proportions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing if assertion passes, otherwise prints the error message.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>assert_list_of_variables()</code>: Checks whether <code>x</code> is a valid list of variable names.
<code>NULL</code> elements of the list <code>x</code> are dropped with <code>Filter(Negate(is.null), x)</code>.
</p>
</li>
<li> <p><code>assert_df_with_variables()</code>: Check whether <code>df</code> is a data frame with the analysis <code>variables</code>.
Please notice how this produces an error when not all variables are present in the
data.frame while the opposite is not required.
</p>
</li>
<li> <p><code>assert_valid_factor()</code>: Check whether <code>x</code> is a valid factor (i.e. has levels and no empty
string levels). Note that <code>NULL</code> and <code>NA</code> elements are allowed.
</p>
</li>
<li> <p><code>assert_df_with_factors()</code>: Check whether <code>df</code> is a data frame where the analysis <code>variables</code>
are all factors. Note that the creation of <code>NA</code> by direct call of <code>factor()</code> will
trim <code>NA</code> levels out of the vector list itself.
</p>
</li>
<li> <p><code>assert_proportion_value()</code>: Check whether <code>x</code> is a proportion: number between 0 and 1.
</p>
</li></ul>

<hr>
<h2 id='bins_percent_labels'>Labels for Bins in Percent</h2><span id='topic+bins_percent_labels'></span>

<h3>Description</h3>

<p>This creates labels for quantile based bins in percent. This assumes the right-closed
intervals as produced by <code><a href="#topic+cut_quantile_bins">cut_quantile_bins()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bins_percent_labels(probs, digits = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bins_percent_labels_+3A_probs">probs</code></td>
<td>
<p>(<code>proportion</code> vector)<br /> the probabilities identifying the quantiles.
This is a sorted vector of unique <code>proportion</code> values, i.e. between 0 and 1, where
the boundaries 0 and 1 must not be included.</p>
</td></tr>
<tr><td><code id="bins_percent_labels_+3A_digits">digits</code></td>
<td>
<p>(<code>integer</code>)<br /> number of decimal places to round the percent numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector with labels in the format <code style="white-space: pre;">&#8288;[0%,20%]&#8288;</code>, <code style="white-space: pre;">&#8288;(20%,50%]&#8288;</code>, etc.
</p>

<hr>
<h2 id='c_label_n'>Content Row Function to Add Row Total to Labels</h2><span id='topic+c_label_n'></span>

<h3>Description</h3>

<p>This takes the label of the latest row split level and adds the row total from <code>df</code> in parentheses.
This function differs from <code><a href="#topic+c_label_n_alt">c_label_n_alt()</a></code> by taking row counts from <code>df</code> rather than
<code>alt_counts_df</code>, and is used by <code><a href="#topic+add_rowcounts">add_rowcounts()</a></code> when <code>alt_counts</code> is set to <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_label_n(df, labelstr, .N_row)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_label_n_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="c_label_n_+3A_labelstr">labelstr</code></td>
<td>
<p>(<code>character</code>)<br /> label of the level of the parent split currently being summarized
(must be present as second argument in Content Row Functions). See <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>
for more information.</p>
</td></tr>
<tr><td><code id="c_label_n_+3A_.n_row">.N_row</code></td>
<td>
<p>(<code>integer</code>)<br /> row-wise N (row group count) for the group of observations being analyzed
(i.e. with no column-based subsetting) that is typically passed by <code>rtables</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code> with the row count value and the correct label.
</p>


<h3>Note</h3>

<p>It is important here to not use <code>df</code> but rather <code>.N_row</code> in the implementation, because
the former is already split by columns and will refer to the first column of the data only.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c_label_n_alt">c_label_n_alt()</a></code> which performs the same function but retrieves row counts from
<code>alt_counts_df</code> instead of <code>df</code>.
</p>

<hr>
<h2 id='c_label_n_alt'>Content Row Function to Add <code>alt_counts_df</code> Row Total to Labels</h2><span id='topic+c_label_n_alt'></span>

<h3>Description</h3>

<p>This takes the label of the latest row split level and adds the row total from <code>alt_counts_df</code>
in parentheses. This function differs from <code><a href="#topic+c_label_n">c_label_n()</a></code> by taking row counts from <code>alt_counts_df</code>
rather than <code>df</code>, and is used by <code><a href="#topic+add_rowcounts">add_rowcounts()</a></code> when <code>alt_counts</code> is set to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_label_n_alt(df, labelstr, .alt_df_row)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_label_n_alt_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="c_label_n_alt_+3A_labelstr">labelstr</code></td>
<td>
<p>(<code>character</code>)<br /> label of the level of the parent split currently being summarized
(must be present as second argument in Content Row Functions). See <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>
for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code> with the row count value and the correct label.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c_label_n">c_label_n()</a></code> which performs the same function but retrieves row counts from <code>df</code> instead
of <code>alt_counts_df</code>.
</p>

<hr>
<h2 id='cfun_by_flag'>Constructor for Content Functions given Data Frame with Flag Input</h2><span id='topic+cfun_by_flag'></span>

<h3>Description</h3>

<p>This can be useful for tabulating model results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfun_by_flag(analysis_var, flag_var, format = "xx", .indent_mods = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfun_by_flag_+3A_analysis_var">analysis_var</code></td>
<td>
<p>(<code>string</code>)<br /> variable name for the column containing values to be returned by the
content function.</p>
</td></tr>
<tr><td><code id="cfun_by_flag_+3A_flag_var">flag_var</code></td>
<td>
<p>(<code>string</code>)<br /> variable name for the logical column identifying which row should be returned.</p>
</td></tr>
<tr><td><code id="cfun_by_flag_+3A_format">format</code></td>
<td>
<p>(<code>string</code>)<br /> <code>rtables</code> format to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A content function which gives <code>df$analysis_var</code> at the row identified by
<code>.df_row$flag</code> in the given format.
</p>

<hr>
<h2 id='check_diff_prop_ci'>Check: Proportion Difference Arguments</h2><span id='topic+check_diff_prop_ci'></span>

<h3>Description</h3>

<p>Verifies that and/or convert arguments into valid values to be used in the
estimation of difference in responder proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_diff_prop_ci(rsp, grp, strata = NULL, conf_level, correct = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_diff_prop_ci_+3A_rsp">rsp</code></td>
<td>
<p>(<code>logical</code>)<br /> whether each subject is a responder or not.</p>
</td></tr>
<tr><td><code id="check_diff_prop_ci_+3A_grp">grp</code></td>
<td>
<p>(<code>factor</code>)<br /> vector assigning observations to one out of two groups
(e.g. reference and treatment group).</p>
</td></tr>
<tr><td><code id="check_diff_prop_ci_+3A_strata">strata</code></td>
<td>
<p>(<code>factor</code>)<br /> variable with one level per stratum and same length as <code>rsp</code>.</p>
</td></tr>
<tr><td><code id="check_diff_prop_ci_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="check_diff_prop_ci_+3A_correct">correct</code></td>
<td>
<p>(<code>logical</code>)<br /> whether to include the continuity correction. For further
information, see <code><a href="stats.html#topic+prop.test">stats::prop.test()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='check_same_n'>Check Element Dimension</h2><span id='topic+check_same_n'></span>

<h3>Description</h3>

<p>Checks if the elements in <code>...</code> have the same dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_same_n(..., omit_null = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_same_n_+3A_...">...</code></td>
<td>
<p>(<code>data.frame</code>s or <code>vector</code>s)<br /> any data frames/vectors.</p>
</td></tr>
<tr><td><code id="check_same_n_+3A_omit_null">omit_null</code></td>
<td>
<p>(<code>logical</code>)<br /> whether <code>NULL</code> elements in <code>...</code> should be omitted from the check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code> value.
</p>

<hr>
<h2 id='combination_function'>Combination Functions Class</h2><span id='topic+combination_function'></span><span id='topic+CombinationFunction'></span><span id='topic+CombinationFunction-class'></span><span id='topic++26+2CCombinationFunction+2CCombinationFunction-method'></span><span id='topic++7C+2CCombinationFunction+2CCombinationFunction-method'></span><span id='topic++21+2CCombinationFunction-method'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p><code>CombinationFunction</code> is an S4 class which extends standard functions. These are special functions that
can be combined and negated with the logical operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'CombinationFunction,CombinationFunction'
e1 &amp; e2

## S4 method for signature 'CombinationFunction,CombinationFunction'
e1 | e2

## S4 method for signature 'CombinationFunction'
!x
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combination_function_+3A_e1">e1</code></td>
<td>
<p>(<code>CombinationFunction</code>)<br /> left hand side of logical operator.</p>
</td></tr>
<tr><td><code id="combination_function_+3A_e2">e2</code></td>
<td>
<p>(<code>CombinationFunction</code>)<br /> right hand side of logical operator.</p>
</td></tr>
<tr><td><code id="combination_function_+3A_x">x</code></td>
<td>
<p>(<code>CombinationFunction</code>)<br /> the function which should be negated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a logical value indicating whether the left hand side of the equation equals the right hand side.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>e1 &amp; e2</code>: Logical &quot;AND&quot; combination of <code>CombinationFunction</code> functions.
The resulting object is of the same class, and evaluates the two argument functions. The result
is then the &quot;AND&quot; of the two individual results.
</p>
</li>
<li> <p><code>e1 | e2</code>: Logical &quot;OR&quot; combination of <code>CombinationFunction</code> functions.
The resulting object is of the same class, and evaluates the two argument functions. The result
is then the &quot;OR&quot; of the two individual results.
</p>
</li>
<li> <p><code>`!`(CombinationFunction)</code>: Logical negation of <code>CombinationFunction</code> functions.
The resulting object is of the same class, and evaluates the original function. The result
is then the opposite of this results.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>higher &lt;- function(a) {
  force(a)
  CombinationFunction(
    function(x) {
      x &gt; a
    }
  )
}

lower &lt;- function(b) {
  force(b)
  CombinationFunction(
    function(x) {
      x &lt; b
    }
  )
}

c1 &lt;- higher(5)
c2 &lt;- lower(10)
c3 &lt;- higher(5) &amp; lower(10)
c3(7)

</code></pre>

<hr>
<h2 id='combine_counts'>Combine Counts</h2><span id='topic+combine_counts'></span>

<h3>Description</h3>

<p>Simplifies the estimation of column counts, especially when group combination is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_counts(fct, groups_list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_counts_+3A_fct">fct</code></td>
<td>
<p>(<code>factor</code>)<br /> the variable with levels which needs to be grouped.</p>
</td></tr>
<tr><td><code id="combine_counts_+3A_groups_list">groups_list</code></td>
<td>
<p>(named <code>list</code> of <code>character</code>)<br /> specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> of column counts.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combine_groups">combine_groups()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ref &lt;- c("A: Drug X", "B: Placebo")
groups &lt;- combine_groups(fct = DM$ARM, ref = ref)

col_counts &lt;- combine_counts(
  fct = DM$ARM,
  groups_list = groups
)

basic_table() %&gt;%
  split_cols_by_groups("ARM", groups) %&gt;%
  add_colcounts() %&gt;%
  analyze_vars("AGE") %&gt;%
  build_table(DM, col_counts = col_counts)

ref &lt;- "A: Drug X"
groups &lt;- combine_groups(fct = DM$ARM, ref = ref)
col_counts &lt;- combine_counts(
  fct = DM$ARM,
  groups_list = groups
)

basic_table() %&gt;%
  split_cols_by_groups("ARM", groups) %&gt;%
  add_colcounts() %&gt;%
  analyze_vars("AGE") %&gt;%
  build_table(DM, col_counts = col_counts)

</code></pre>

<hr>
<h2 id='combine_groups'>Reference and Treatment Group Combination</h2><span id='topic+combine_groups'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Facilitate the re-combination of groups divided as reference and treatment groups; it helps in arranging groups of
columns in the <code>rtables</code> framework and teal modules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_groups(fct, ref = NULL, collapse = "/")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_groups_+3A_fct">fct</code></td>
<td>
<p>(<code>factor</code>)<br /> the variable with levels which needs to be grouped.</p>
</td></tr>
<tr><td><code id="combine_groups_+3A_ref">ref</code></td>
<td>
<p>(<code>string</code>)<br /> the reference level(s).</p>
</td></tr>
<tr><td><code id="combine_groups_+3A_collapse">collapse</code></td>
<td>
<p>(<code>string</code>)<br /> a character string to separate <code>fct</code> and <code>ref</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with first item <code>ref</code> (reference) and second item <code>trt</code> (treatment).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>groups &lt;- combine_groups(
  fct = DM$ARM,
  ref = c("B: Placebo")
)

basic_table() %&gt;%
  split_cols_by_groups("ARM", groups) %&gt;%
  add_colcounts() %&gt;%
  analyze_vars("AGE") %&gt;%
  build_table(DM)

</code></pre>

<hr>
<h2 id='combine_levels'>Combine Factor Levels</h2><span id='topic+combine_levels'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Combine specified old factor Levels in a single new level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_levels(x, levels, new_level = paste(levels, collapse = "/"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_levels_+3A_x">x</code></td>
<td>
<p>factor</p>
</td></tr>
<tr><td><code id="combine_levels_+3A_levels">levels</code></td>
<td>
<p>level names to be combined</p>
</td></tr>
<tr><td><code id="combine_levels_+3A_new_level">new_level</code></td>
<td>
<p>name of new level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>factor</code> with the new levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- factor(letters[1:5], levels = letters[5:1])
combine_levels(x, levels = c("a", "b"))

combine_levels(x, c("e", "b"))

</code></pre>

<hr>
<h2 id='combine_vectors'>Combine Two Vectors Element Wise</h2><span id='topic+combine_vectors'></span>

<h3>Description</h3>

<p>Combine Two Vectors Element Wise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_vectors(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_vectors_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>)<br /> first vector to combine.</p>
</td></tr>
<tr><td><code id="combine_vectors_+3A_y">y</code></td>
<td>
<p>(<code>vector</code>)<br /> second vector to combine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> where each element combines corresponding elements of <code>x</code> and <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>combine_vectors(1:3, 4:6)

</code></pre>

<hr>
<h2 id='compare_variables'>Compare Variables Between Groups</h2><span id='topic+compare_variables'></span><span id='topic+compare_vars'></span><span id='topic+s_compare'></span><span id='topic+s_compare.numeric'></span><span id='topic+s_compare.factor'></span><span id='topic+s_compare.character'></span><span id='topic+s_compare.logical'></span><span id='topic+a_compare'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Comparison with a reference group for different <code>x</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_vars(
  lyt,
  vars,
  var_labels = vars,
  na_level = lifecycle::deprecated(),
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  na.rm = TRUE,
  show_labels = "default",
  table_names = vars,
  section_div = NA_character_,
  .stats = c("n", "mean_sd", "count_fraction", "pval"),
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_compare(x, .ref_group, .in_ref_col, ...)

## S3 method for class 'numeric'
s_compare(x, .ref_group, .in_ref_col, ...)

## S3 method for class 'factor'
s_compare(x, .ref_group, .in_ref_col, denom = "n", na.rm = TRUE, ...)

## S3 method for class 'character'
s_compare(
  x,
  .ref_group,
  .in_ref_col,
  denom = "n",
  na.rm = TRUE,
  .var,
  verbose = TRUE,
  ...
)

## S3 method for class 'logical'
s_compare(x, .ref_group, .in_ref_col, na.rm = TRUE, denom = "n", ...)

a_compare(
  x,
  .N_col,
  .N_row,
  .var = NULL,
  .df_row = NULL,
  .ref_group = NULL,
  .in_ref_col = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_variables_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_na_level">na_level</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use the <code>na_str</code> argument instead.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>s_compare()</code>.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>flag</code>)<br /> whether <code>NA</code> values should be removed from <code>x</code> prior to analysis.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_section_div">section_div</code></td>
<td>
<p>(<code>string</code>)<br /> string which should be repeated as a section divider after each group
defined by this split instruction, or <code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("analyze_vars_numeric")</code> to see
statistics available for numeric variables, and <code>get_stats("analyze_vars_counts")</code> for statistics available
for non-numeric variables.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>vector</code> of <code>integer</code>)<br /> indent modifiers for the labels. Each element of the vector
should be a name-value pair with name corresponding to a statistic specified in <code>.stats</code> and value the indentation
for that statistic's row label.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector of numbers we want to analyze.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_.ref_group">.ref_group</code></td>
<td>
<p>(<code>data.frame</code> or <code>vector</code>)<br /> the data corresponding to the reference group.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_.in_ref_col">.in_ref_col</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> when working with the reference level, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_denom">denom</code></td>
<td>
<p>(<code>string</code>)<br /> choice of denominator for factor proportions,
can only be <code>n</code> (number of values in this row and column intersection).</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical</code>)<br /> Whether warnings and messages should be printed. Mainly used
to print out information about factor casting. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_.n_row">.N_row</code></td>
<td>
<p>(<code>integer</code>)<br /> row-wise N (row group count) for the group of observations being analyzed
(i.e. with no column-based subsetting) that is typically passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="compare_variables_+3A_.df_row">.df_row</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data frame across all of the columns for the given row split.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>compare_vars()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_compare()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_compare()</code> returns output of <code><a href="#topic+s_summary">s_summary()</a></code> and comparisons versus the reference group in the form of p-values.
</p>
</li></ul>


<ul>
<li> <p><code>a_compare()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>compare_vars()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_compare()</code>: S3 generic function to produce a comparison summary.
</p>
</li>
<li> <p><code>s_compare(numeric)</code>: Method for <code>numeric</code> class. This uses the standard t-test
to calculate the p-value.
</p>
</li>
<li> <p><code>s_compare(factor)</code>: Method for <code>factor</code> class. This uses the chi-squared test
to calculate the p-value.
</p>
</li>
<li> <p><code>s_compare(character)</code>: Method for <code>character</code> class. This makes an automatic
conversion to <code>factor</code> (with a warning) and then forwards to the method for factors.
</p>
</li>
<li> <p><code>s_compare(logical)</code>: Method for <code>logical</code> class. A chi-squared test
is used. If missing values are not removed, then they are counted as <code>FALSE</code>.
</p>
</li>
<li> <p><code>a_compare()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>compare_vars()</code>.
</p>
</li></ul>


<h3>Note</h3>


<ul>
<li><p> For factor variables, <code>denom</code> for factor proportions can only be <code>n</code> since the purpose is to compare proportions
between columns, therefore a row-based proportion would not make sense. Proportion based on <code>N_col</code> would
be difficult since we use counts for the chi-squared test statistic, therefore missing values should be accounted
for as explicit factor levels.
</p>
</li>
<li><p> If factor variables contain <code>NA</code>, these <code>NA</code> values are excluded by default. To include <code>NA</code> values
set <code>na.rm = FALSE</code> and missing values will be displayed as an <code>NA</code> level. Alternatively, an explicit
factor level can be defined for <code>NA</code> values during pre-processing via <code><a href="#topic+df_explicit_na">df_explicit_na()</a></code> - the
default <code>na_level</code> (<code>"&lt;Missing&gt;"</code>) will also be excluded when <code>na.rm</code> is set to <code>TRUE</code>.
</p>
</li>
<li><p> For character variables, automatic conversion to factor does not guarantee that the table
will be generated correctly. In particular for sparse tables this very likely can fail.
Therefore it is always better to manually convert character variables to factors during pre-processing.
</p>
</li>
<li><p> For <code>compare_vars()</code>, the column split must define a reference group via <code>ref_group</code> so that the comparison
is well defined.
</p>
</li></ul>

<p><code>a_compare()</code> has been deprecated in favor of <code>a_summary()</code> with argument <code>compare</code> set to <code>TRUE</code>.
</p>


<h3>See Also</h3>

<p>Relevant constructor function <code><a href="#topic+create_afun_compare">create_afun_compare()</a></code>, <code><a href="#topic+s_summary">s_summary()</a></code> which is used internally
to compute a summary within <code>s_compare()</code>, and <code><a href="#topic+a_compare">a_compare()</a></code> which is used (with <code>compare = TRUE</code>) as the analysis
function for <code>compare_vars()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># `compare_vars()` in `rtables` pipelines

## Default output within a `rtables` pipeline.
lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARMCD", ref_group = "ARM B") %&gt;%
  compare_vars(c("AGE", "SEX"))
build_table(lyt, tern_ex_adsl)

## Select and format statistics output.
lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARMCD", ref_group = "ARM C") %&gt;%
  compare_vars(
    vars = "AGE",
    .stats = c("mean_sd", "pval"),
    .formats = c(mean_sd = "xx.x, xx.x"),
    .labels = c(mean_sd = "Mean, SD")
  )
build_table(lyt, df = tern_ex_adsl)

# `s_compare.numeric`

## Usual case where both this and the reference group vector have more than 1 value.
s_compare(rnorm(10, 5, 1), .ref_group = rnorm(5, -5, 1), .in_ref_col = FALSE)

## If one group has not more than 1 value, then p-value is not calculated.
s_compare(rnorm(10, 5, 1), .ref_group = 1, .in_ref_col = FALSE)

## Empty numeric does not fail, it returns NA-filled items and no p-value.
s_compare(numeric(), .ref_group = numeric(), .in_ref_col = FALSE)

# `s_compare.factor`

## Basic usage:
x &lt;- factor(c("a", "a", "b", "c", "a"))
y &lt;- factor(c("a", "b", "c"))
s_compare(x = x, .ref_group = y, .in_ref_col = FALSE)

## Management of NA values.
x &lt;- explicit_na(factor(c("a", "a", "b", "c", "a", NA, NA)))
y &lt;- explicit_na(factor(c("a", "b", "c", NA)))
s_compare(x = x, .ref_group = y, .in_ref_col = FALSE, na.rm = TRUE)
s_compare(x = x, .ref_group = y, .in_ref_col = FALSE, na.rm = FALSE)

# `s_compare.character`

## Basic usage:
x &lt;- c("a", "a", "b", "c", "a")
y &lt;- c("a", "b", "c")
s_compare(x, .ref_group = y, .in_ref_col = FALSE, .var = "x", verbose = FALSE)

## Note that missing values handling can make a large difference:
x &lt;- c("a", "a", "b", "c", "a", NA)
y &lt;- c("a", "b", "c", rep(NA, 20))
s_compare(x,
  .ref_group = y, .in_ref_col = FALSE,
  .var = "x", verbose = FALSE
)
s_compare(x,
  .ref_group = y, .in_ref_col = FALSE, .var = "x",
  na.rm = FALSE, verbose = FALSE
)

# `s_compare.logical`

## Basic usage:
x &lt;- c(TRUE, FALSE, TRUE, TRUE)
y &lt;- c(FALSE, FALSE, TRUE)
s_compare(x, .ref_group = y, .in_ref_col = FALSE)

## Management of NA values.
x &lt;- c(NA, TRUE, FALSE)
y &lt;- c(NA, NA, NA, NA, FALSE)
s_compare(x, .ref_group = y, .in_ref_col = FALSE, na.rm = TRUE)
s_compare(x, .ref_group = y, .in_ref_col = FALSE, na.rm = FALSE)

# `a_compare` deprecated - use `a_summary()` instead
a_compare(rnorm(10, 5, 1), .ref_group = rnorm(20, -5, 1), .stats = c("n", "pval"))

</code></pre>

<hr>
<h2 id='control_analyze_vars'>Control Function for Descriptive Statistics</h2><span id='topic+control_analyze_vars'></span><span id='topic+control_summarize_vars'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Sets a list of parameters for summaries of descriptive statistics. Typically used internally to specify
details for <code><a href="#topic+s_summary">s_summary()</a></code>. This function family is mainly used by <code><a href="#topic+analyze_vars">analyze_vars()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_analyze_vars(
  conf_level = 0.95,
  quantiles = c(0.25, 0.75),
  quantile_type = 2,
  test_mean = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_analyze_vars_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="control_analyze_vars_+3A_quantiles">quantiles</code></td>
<td>
<p>(<code>numeric</code>)<br /> of length two to specify the quantiles to calculate.</p>
</td></tr>
<tr><td><code id="control_analyze_vars_+3A_quantile_type">quantile_type</code></td>
<td>
<p>(<code>numeric</code>)<br /> between 1 and 9 selecting quantile algorithms to be used.
Default is set to 2 as this matches the default quantile algorithm in SAS <code style="white-space: pre;">&#8288;proc univariate&#8288;</code> set by <code>QNTLDEF=5</code>.
This differs from R's default. See more about <code>type</code> in <code><a href="stats.html#topic+quantile">stats::quantile()</a></code>.</p>
</td></tr>
<tr><td><code id="control_analyze_vars_+3A_test_mean">test_mean</code></td>
<td>
<p>(<code>numeric</code>)<br /> to test against the mean under the null hypothesis when calculating p-value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of components with the same names as the arguments.
</p>


<h3>Note</h3>

<p>Deprecation cycle started for <code>control_summarize_vars</code> as it is going to renamed into
<code>control_analyze_vars</code>. Intention is to reflect better the core underlying <code>rtables</code>
functions; in this case <code><a href="#topic+analyze_vars">analyze_vars()</a></code> wraps <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>

<hr>
<h2 id='control_coxph'>Control Function for <code>CoxPH</code> Model</h2><span id='topic+control_coxph'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is an auxiliary function for controlling arguments for <code>CoxPH</code> model, typically used internally to specify
details of <code>CoxPH</code> model for <code><a href="#topic+s_coxph_pairwise">s_coxph_pairwise()</a></code>. <code>conf_level</code> refers to Hazard Ratio estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_coxph(
  pval_method = c("log-rank", "wald", "likelihood"),
  ties = c("efron", "breslow", "exact"),
  conf_level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_coxph_+3A_pval_method">pval_method</code></td>
<td>
<p>(<code>string</code>)<br /> p-value method for testing hazard ratio = 1.
Default method is <code>"log-rank"</code>, can also be set to <code>"wald"</code> or <code>"likelihood"</code>.</p>
</td></tr>
<tr><td><code id="control_coxph_+3A_ties">ties</code></td>
<td>
<p>(<code>string</code>)<br /> specifying the method for tie handling. Default is <code>"efron"</code>,
can also be set to <code>"breslow"</code> or <code>"exact"</code>. See more in <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>.</p>
</td></tr>
<tr><td><code id="control_coxph_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of components with the same names as the arguments
</p>

<hr>
<h2 id='control_coxreg'>Controls for Cox Regression</h2><span id='topic+control_coxreg'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Sets a list of parameters for Cox regression fit. Used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_coxreg(
  pval_method = c("wald", "likelihood"),
  ties = c("exact", "efron", "breslow"),
  conf_level = 0.95,
  interaction = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_coxreg_+3A_pval_method">pval_method</code></td>
<td>
<p>(<code>string</code>)<br /> the method used for estimation of p.values; <code>wald</code> (default) or <code>likelihood</code>.</p>
</td></tr>
<tr><td><code id="control_coxreg_+3A_ties">ties</code></td>
<td>
<p>(<code>string</code>)<br /> among <code>exact</code> (equivalent to <code>DISCRETE</code> in SAS), <code>efron</code> and <code>breslow</code>,
see <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>. Note: there is no equivalent of SAS <code>EXACT</code> method in R.</p>
</td></tr>
<tr><td><code id="control_coxreg_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="control_coxreg_+3A_interaction">interaction</code></td>
<td>
<p>(<code>flag</code>)<br /> if <code>TRUE</code>, the model includes the interaction between the studied
treatment and candidate covariate. Note that for univariate models without treatment arm, and
multivariate models, no interaction can be used so that this needs to be <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of items with names corresponding to the arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_coxreg_univar">fit_coxreg_univar()</a></code> and <code><a href="#topic+fit_coxreg_multivar">fit_coxreg_multivar()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control_coxreg()

</code></pre>

<hr>
<h2 id='control_incidence_rate'>Control function for incidence rate</h2><span id='topic+control_incidence_rate'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is an auxiliary function for controlling arguments for the incidence rate, used
internally to specify details in <code>s_incidence_rate()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_incidence_rate(
  conf_level = 0.95,
  conf_type = c("normal", "normal_log", "exact", "byar"),
  input_time_unit = c("year", "day", "week", "month"),
  num_pt_year = 100,
  time_unit_input = lifecycle::deprecated(),
  time_unit_output = lifecycle::deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_incidence_rate_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="control_incidence_rate_+3A_conf_type">conf_type</code></td>
<td>
<p>(<code>string</code>)<br /> <code>normal</code> (default), <code>normal_log</code>, <code>exact</code>, or <code>byar</code>
for confidence interval type.</p>
</td></tr>
<tr><td><code id="control_incidence_rate_+3A_input_time_unit">input_time_unit</code></td>
<td>
<p>(<code>string</code>)<br /> <code>day</code>, <code>week</code>, <code>month</code>, or <code>year</code> (default)
indicating time unit for data input.</p>
</td></tr>
<tr><td><code id="control_incidence_rate_+3A_num_pt_year">num_pt_year</code></td>
<td>
<p>(<code>numeric</code>)<br /> number of patient-years to use when calculating adverse event rates.</p>
</td></tr>
<tr><td><code id="control_incidence_rate_+3A_time_unit_input">time_unit_input</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use the <code>input_time_unit</code> argument instead.</p>
</td></tr>
<tr><td><code id="control_incidence_rate_+3A_time_unit_output">time_unit_output</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use the <code>num_pt_year</code> argument instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of components with the same names as the arguments.
</p>


<h3>See Also</h3>

<p><a href="#topic+incidence_rate">incidence_rate</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control_incidence_rate(0.9, "exact", "month", 100)

</code></pre>

<hr>
<h2 id='control_lineplot_vars'>Control Function for <code>g_lineplot</code> Function</h2><span id='topic+control_lineplot_vars'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Default values for <code>variables</code> parameter in <code>g_lineplot</code> function.
A variable's default value can be overwritten for any variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_lineplot_vars(
  x = "AVISIT",
  y = "AVAL",
  group_var = "ARM",
  paramcd = "PARAMCD",
  y_unit = "AVALU",
  subject_var = "USUBJID",
  strata = lifecycle::deprecated(),
  cohort_id = lifecycle::deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_lineplot_vars_+3A_x">x</code></td>
<td>
<p>(<code>character</code>)<br /> x variable name.</p>
</td></tr>
<tr><td><code id="control_lineplot_vars_+3A_y">y</code></td>
<td>
<p>(<code>character</code>)<br /> y variable name.</p>
</td></tr>
<tr><td><code id="control_lineplot_vars_+3A_group_var">group_var</code></td>
<td>
<p>(<code>character</code> or <code>NA</code>)<br /> group variable name.</p>
</td></tr>
<tr><td><code id="control_lineplot_vars_+3A_paramcd">paramcd</code></td>
<td>
<p>(<code>character</code> or <code>NA</code>)<br /> <code>paramcd</code> variable name.</p>
</td></tr>
<tr><td><code id="control_lineplot_vars_+3A_y_unit">y_unit</code></td>
<td>
<p>(<code>character</code> or <code>NA</code>)<br /> <code>y_unit</code> variable name.</p>
</td></tr>
<tr><td><code id="control_lineplot_vars_+3A_subject_var">subject_var</code></td>
<td>
<p>(<code>character</code> or <code>NA</code>)<br /> subject variable name.</p>
</td></tr>
<tr><td><code id="control_lineplot_vars_+3A_strata">strata</code></td>
<td>
<p>(<code>character</code> or <code>NA</code>)<br /> deprecated - group variable name.</p>
</td></tr>
<tr><td><code id="control_lineplot_vars_+3A_cohort_id">cohort_id</code></td>
<td>
<p>(<code>character</code> or <code>NA</code>)<br /> deprecated - subject variable name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector of variable names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control_lineplot_vars()
control_lineplot_vars(group_var = NA)

</code></pre>

<hr>
<h2 id='control_logistic'>Control Function for Logistic Regression Model Fitting</h2><span id='topic+control_logistic'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is an auxiliary function for controlling arguments for logistic regression models.
<code>conf_level</code> refers to the confidence level used for the Odds Ratio CIs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_logistic(response_definition = "response", conf_level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_logistic_+3A_response_definition">response_definition</code></td>
<td>
<p>(<code>string</code>)<br /> the definition of what an event is in terms of <code>response</code>.
This will be used when fitting the logistic regression model on the left hand side of the formula.
Note that the evaluated expression should result in either a logical vector or a factor with 2
levels. By default this is just <code>"response"</code> such that the original response variable is used
and not modified further.</p>
</td></tr>
<tr><td><code id="control_logistic_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of components with the same names as the arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Standard options.
control_logistic()

# Modify confidence level.
control_logistic(conf_level = 0.9)

# Use a different response definition.
control_logistic(response_definition = "I(response %in% c('CR', 'PR'))")

</code></pre>

<hr>
<h2 id='control_step'>Control Function for Subgroup Treatment Effect Pattern (STEP) Calculations</h2><span id='topic+control_step'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is an auxiliary function for controlling arguments for STEP calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_step(
  biomarker = NULL,
  use_percentile = TRUE,
  bandwidth,
  degree = 0L,
  num_points = 39L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_step_+3A_biomarker">biomarker</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br /> optional provision of the numeric biomarker variable, which
could be used to infer <code>bandwidth</code>, see below.</p>
</td></tr>
<tr><td><code id="control_step_+3A_use_percentile">use_percentile</code></td>
<td>
<p>(<code>flag</code>)<br /> if <code>TRUE</code>, the running windows are created according to
quantiles rather than actual values, i.e. the bandwidth refers to the percentage of data
covered in each window. Suggest <code>TRUE</code> if the biomarker variable is not uniformly
distributed.</p>
</td></tr>
<tr><td><code id="control_step_+3A_bandwidth">bandwidth</code></td>
<td>
<p>(<code>number</code> or <code>NULL</code>)<br /> indicating the bandwidth of each window.
Depending on the argument <code>use_percentile</code>, it can be either the length of actual-value
windows on the real biomarker scale, or percentage windows.
If <code>use_percentile = TRUE</code>, it should be a number between 0 and 1.
If <code>NULL</code>, treat the bandwidth to be infinity, which means only one global model will be fitted.
By default, <code>0.25</code> is used for percentage windows and one quarter of the range of the <code>biomarker</code>
variable for actual-value windows.</p>
</td></tr>
<tr><td><code id="control_step_+3A_degree">degree</code></td>
<td>
<p>(<code>count</code>)<br /> the degree of polynomial function of the biomarker as an interaction term
with the treatment arm fitted at each window. If 0 (default), then the biomarker variable
is not included in the model fitted in each biomarker window.</p>
</td></tr>
<tr><td><code id="control_step_+3A_num_points">num_points</code></td>
<td>
<p>(<code>count</code>)<br /> the number of points at which the hazard ratios are estimated. The
smallest number is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of components with the same names as the arguments, except <code>biomarker</code> which is
just used to calculate the <code>bandwidth</code> in case that actual biomarker windows are requested.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Provide biomarker values and request actual values to be used,
# so that bandwidth is chosen from range.
control_step(biomarker = 1:10, use_percentile = FALSE)

# Use a global model with quadratic biomarker interaction term.
control_step(bandwidth = NULL, degree = 2)

# Reduce number of points to be used.
control_step(num_points = 10)

</code></pre>

<hr>
<h2 id='control_surv_time'>Control Function for <code>survfit</code> Model for Survival Time</h2><span id='topic+control_surv_time'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is an auxiliary function for controlling arguments for <code>survfit</code> model, typically used internally to specify
details of <code>survfit</code> model for <code><a href="#topic+s_surv_time">s_surv_time()</a></code>. <code>conf_level</code> refers to survival time estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_surv_time(
  conf_level = 0.95,
  conf_type = c("plain", "log", "log-log"),
  quantiles = c(0.25, 0.75)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_surv_time_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="control_surv_time_+3A_conf_type">conf_type</code></td>
<td>
<p>(<code>string</code>)<br /> confidence interval type. Options are &quot;plain&quot; (default), &quot;log&quot;, &quot;log-log&quot;,
see more in <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>. Note option &quot;none&quot; is no longer supported.</p>
</td></tr>
<tr><td><code id="control_surv_time_+3A_quantiles">quantiles</code></td>
<td>
<p>(<code>numeric</code>)<br /> of length two to specify the quantiles of survival time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of components with the same names as the arguments
</p>

<hr>
<h2 id='control_surv_timepoint'>Control Function for <code>survfit</code> Model for Patient's Survival Rate at time point</h2><span id='topic+control_surv_timepoint'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is an auxiliary function for controlling arguments for <code>survfit</code> model, typically used internally to specify
details of <code>survfit</code> model for <code><a href="#topic+s_surv_timepoint">s_surv_timepoint()</a></code>. <code>conf_level</code> refers to patient risk estimation at a time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_surv_timepoint(
  conf_level = 0.95,
  conf_type = c("plain", "log", "log-log")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_surv_timepoint_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="control_surv_timepoint_+3A_conf_type">conf_type</code></td>
<td>
<p>(<code>string</code>)<br /> confidence interval type. Options are &quot;plain&quot; (default), &quot;log&quot;, &quot;log-log&quot;,
see more in <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>. Note option &quot;none&quot; is no longer supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of components with the same names as the arguments
</p>

<hr>
<h2 id='count_cumulative'>Cumulative Counts with Thresholds</h2><span id='topic+count_cumulative'></span><span id='topic+s_count_cumulative'></span><span id='topic+a_count_cumulative'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Summarize cumulative counts of a (<code>numeric</code>) vector that is less than, less or equal to,
greater than, or greater or equal to user-specific thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_cumulative(
  lyt,
  vars,
  thresholds,
  lower_tail = TRUE,
  include_eq = TRUE,
  var_labels = vars,
  show_labels = "visible",
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  table_names = vars,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_count_cumulative(
  x,
  thresholds,
  lower_tail = TRUE,
  include_eq = TRUE,
  .N_col,
  ...
)

a_count_cumulative(
  x,
  thresholds,
  lower_tail = TRUE,
  include_eq = TRUE,
  .N_col,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_cumulative_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_thresholds">thresholds</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector of cutoff value for the counts.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_lower_tail">lower_tail</code></td>
<td>
<p>(<code>logical</code>)<br /> whether to count lower tail, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_include_eq">include_eq</code></td>
<td>
<p>(<code>logical</code>)<br /> whether to include value equal to the <code>threshold</code> in
count, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("count_cumulative")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector of numbers we want to analyze.</p>
</td></tr>
<tr><td><code id="count_cumulative_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>count_cumulative()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_count_cumulative()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_cumulative()</code> returns a named list of <code>count_fraction</code>s: a list with each <code>thresholds</code> value as a
component, each component containing a vector for the count and fraction.
</p>
</li></ul>


<ul>
<li> <p><code>a_count_cumulative()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>count_cumulative()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_count_cumulative()</code>: Statistics function that produces a named list given a numeric vector of thresholds.
</p>
</li>
<li> <p><code>a_count_cumulative()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>count_cumulative()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p>Relevant helper function <code><a href="#topic+h_count_cumulative">h_count_cumulative()</a></code>, and descriptive function <code><a href="#topic+d_count_cumulative">d_count_cumulative()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_colcounts() %&gt;%
  count_cumulative(
    vars = "AGE",
    thresholds = c(40, 60)
  ) %&gt;%
  build_table(tern_ex_adsl)

</code></pre>

<hr>
<h2 id='count_missed_doses'>Counting Missed Doses</h2><span id='topic+count_missed_doses'></span><span id='topic+s_count_nonmissing'></span><span id='topic+s_count_missed_doses'></span><span id='topic+a_count_missed_doses'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>These are specific functions to count patients with missed doses. The difference to <code><a href="#topic+count_cumulative">count_cumulative()</a></code> is
mainly the special labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_missed_doses(
  lyt,
  vars,
  thresholds,
  var_labels = vars,
  show_labels = "visible",
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  table_names = vars,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_count_nonmissing(x)

s_count_missed_doses(x, thresholds, .N_col)

a_count_missed_doses(x, thresholds, .N_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_missed_doses_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_thresholds">thresholds</code></td>
<td>
<p>(vector of <code>count</code>)<br /> number of missed doses the patients at least had.</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("count_missed_doses")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector of numbers we want to analyze.</p>
</td></tr>
<tr><td><code id="count_missed_doses_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>count_missed_doses()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_count_missed_doses()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_nonmissing()</code> returns the statistic <code>n</code> which is the count of non-missing values in <code>x</code>.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_missed_doses()</code> returns the statistics <code>n</code> and <code>count_fraction</code> with one element for each threshold.
</p>
</li></ul>


<ul>
<li> <p><code>a_count_missed_doses()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>count_missed_doses()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_count_nonmissing()</code>: Statistics function to count non-missing values.
</p>
</li>
<li> <p><code>s_count_missed_doses()</code>: Statistics function to count patients with missed doses.
</p>
</li>
<li> <p><code>a_count_missed_doses()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>count_missed_doses()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p>Relevant description function <code><a href="#topic+d_count_missed_doses">d_count_missed_doses()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

anl &lt;- tern_ex_adsl %&gt;%
  distinct(STUDYID, USUBJID, ARM) %&gt;%
  mutate(
    PARAMCD = "TNDOSMIS",
    PARAM = "Total number of missed doses during study",
    AVAL = sample(0:20, size = nrow(tern_ex_adsl), replace = TRUE),
    AVALC = ""
  )

basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_colcounts() %&gt;%
  count_missed_doses("AVAL", thresholds = c(1, 5, 10, 15), var_labels = "Missed Doses") %&gt;%
  build_table(anl, alt_counts_df = tern_ex_adsl)

</code></pre>

<hr>
<h2 id='count_occurrences'>Occurrence Counts</h2><span id='topic+count_occurrences'></span><span id='topic+summarize_occurrences'></span><span id='topic+s_count_occurrences'></span><span id='topic+a_count_occurrences'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Functions for analyzing frequencies and fractions of occurrences for patients with occurrence
data. Primary analysis variables are the dictionary terms. All occurrences are counted for total
counts. Multiple occurrences within patient at the lowest term level displayed in the table are
counted only once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_occurrences(
  lyt,
  vars,
  id = "USUBJID",
  drop = TRUE,
  var_labels = vars,
  show_labels = "hidden",
  riskdiff = FALSE,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  table_names = vars,
  .stats = "count_fraction_fixed_dp",
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

summarize_occurrences(
  lyt,
  var,
  id = "USUBJID",
  drop = TRUE,
  riskdiff = FALSE,
  na_str = default_na_str(),
  ...,
  .stats = "count_fraction_fixed_dp",
  .formats = NULL,
  .indent_mods = NULL,
  .labels = NULL
)

s_count_occurrences(
  df,
  denom = c("N_col", "n"),
  .N_col,
  .df_row,
  drop = TRUE,
  .var = "MHDECOD",
  id = "USUBJID"
)

a_count_occurrences(
  df,
  labelstr = "",
  id = "USUBJID",
  denom = c("N_col", "n"),
  drop = TRUE,
  .N_col,
  .var = NULL,
  .df_row = NULL,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL,
  na_str = default_na_str()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_occurrences_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_id">id</code></td>
<td>
<p>(<code>string</code>)<br /> subject variable name.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_drop">drop</code></td>
<td>
<p>(<code>flag</code>)<br /> should non appearing occurrence levels be dropped from the resulting table.
Note that in that case the remaining occurrence levels in the table are sorted alphabetically.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_riskdiff">riskdiff</code></td>
<td>
<p>(<code>flag</code>)<br /> whether a risk difference column is present. When set to <code>TRUE</code>, <code><a href="#topic+add_riskdiff">add_riskdiff()</a></code> must be
used as <code>split_fun</code> in the prior column split of the table layout, specifying which columns should be compared.
See <code><a href="#topic+stat_propdiff_ci">stat_propdiff_ci()</a></code> for details on risk difference calculation.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("count_occurrences")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_denom">denom</code></td>
<td>
<p>(<code>string</code>)<br /> choice of denominator for patient proportions. Can be:
</p>

<ul>
<li> <p><code>N_col</code>: total number of patients in this column across rows
</p>
</li>
<li> <p><code>n</code>: number of patients with any occurrences
</p>
</li></ul>
</td></tr>
<tr><td><code id="count_occurrences_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_.df_row">.df_row</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data frame across all of the columns for the given row split.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_.var">.var</code>, <code id="count_occurrences_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="count_occurrences_+3A_labelstr">labelstr</code></td>
<td>
<p>(<code>character</code>)<br /> label of the level of the parent split currently being summarized
(must be present as second argument in Content Row Functions). See <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>
for more information.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>count_occurrences()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_count_occurrences()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>summarize_occurrences()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted content rows
containing the statistics from <code>s_count_occurrences()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_occurrences()</code> returns a list with:
</p>

<ul>
<li> <p><code>count</code>: list of counts with one element per occurrence.
</p>
</li>
<li> <p><code>count_fraction</code>: list of counts and fractions with one element per occurrence.
</p>
</li>
<li> <p><code>fraction</code>: list of numerators and denominators with one element per occurrence.
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>a_count_occurrences()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>count_occurrences()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>summarize_occurrences()</code>: Layout-creating function which can take content function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>
</li>
<li> <p><code>s_count_occurrences()</code>: Statistics function which counts number of patients that report an
occurrence.
</p>
</li>
<li> <p><code>a_count_occurrences()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>count_occurrences()</code>.
</p>
</li></ul>


<h3>Note</h3>

<p>By default, occurrences which don't appear in a given row split are dropped from the table and
the occurrences in the table are sorted alphabetically per row split. Therefore, the corresponding layout
needs to use <code>split_fun = drop_split_levels</code> in the <code>split_rows_by</code> calls. Use <code>drop = FALSE</code> if you would
like to show all occurrences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
df &lt;- data.frame(
  USUBJID = as.character(c(
    1, 1, 2, 4, 4, 4,
    6, 6, 6, 7, 7, 8
  )),
  MHDECOD = c(
    "MH1", "MH2", "MH1", "MH1", "MH1", "MH3",
    "MH2", "MH2", "MH3", "MH1", "MH2", "MH4"
  ),
  ARM = rep(c("A", "B"), each = 6),
  SEX = c("F", "F", "M", "M", "M", "M", "F", "F", "F", "M", "M", "F")
)
df_adsl &lt;- df %&gt;%
  select(USUBJID, ARM) %&gt;%
  unique()

# Create table layout
lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_colcounts() %&gt;%
  count_occurrences(vars = "MHDECOD", .stats = c("count_fraction"))

# Apply table layout to data and produce `rtable` object
tbl &lt;- lyt %&gt;%
  build_table(df, alt_counts_df = df_adsl) %&gt;%
  prune_table()

tbl

# Layout creating function with custom format.
basic_table() %&gt;%
  add_colcounts() %&gt;%
  split_rows_by("SEX", child_labels = "visible") %&gt;%
  summarize_occurrences(
    var = "MHDECOD",
    .formats = c("count_fraction" = "xx.xx (xx.xx%)")
  ) %&gt;%
  build_table(df, alt_counts_df = df_adsl)

# Count unique occurrences per subject.
s_count_occurrences(
  df,
  .N_col = 4L,
  .df_row = df,
  .var = "MHDECOD",
  id = "USUBJID"
)

a_count_occurrences(
  df,
  .N_col = 4L,
  .df_row = df,
  .var = "MHDECOD",
  id = "USUBJID"
)

</code></pre>

<hr>
<h2 id='count_occurrences_by_grade'>Occurrence Counts by Grade</h2><span id='topic+count_occurrences_by_grade'></span><span id='topic+summarize_occurrences_by_grade'></span><span id='topic+s_count_occurrences_by_grade'></span><span id='topic+a_count_occurrences_by_grade'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Functions for analyzing frequencies and fractions of occurrences by grade for patients
with occurrence data. Multiple occurrences within one individual are counted once at the
greatest intensity/highest grade level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_occurrences_by_grade(
  lyt,
  var,
  id = "USUBJID",
  grade_groups = list(),
  remove_single = TRUE,
  var_labels = var,
  show_labels = "default",
  riskdiff = FALSE,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  table_names = var,
  .stats = NULL,
  .formats = NULL,
  .indent_mods = NULL,
  .labels = NULL
)

summarize_occurrences_by_grade(
  lyt,
  var,
  id = "USUBJID",
  grade_groups = list(),
  remove_single = TRUE,
  na_str = default_na_str(),
  ...,
  .stats = NULL,
  .formats = NULL,
  .indent_mods = NULL,
  .labels = NULL
)

s_count_occurrences_by_grade(
  df,
  .var,
  .N_col,
  id = "USUBJID",
  grade_groups = list(),
  remove_single = TRUE,
  labelstr = ""
)

a_count_occurrences_by_grade(
  df,
  .var,
  .N_col,
  id = "USUBJID",
  grade_groups = list(),
  remove_single = TRUE,
  labelstr = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_occurrences_by_grade_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_id">id</code></td>
<td>
<p>(<code>string</code>)<br /> subject variable name.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_grade_groups">grade_groups</code></td>
<td>
<p>(named <code>list</code> of <code>character</code>)<br /> containing groupings of grades.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_remove_single">remove_single</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> to not include the elements of one-element grade groups
in the the output list; in this case only the grade groups names will be included in the output.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_riskdiff">riskdiff</code></td>
<td>
<p>(<code>flag</code>)<br /> whether a risk difference column is present. When set to <code>TRUE</code>, <code><a href="#topic+add_riskdiff">add_riskdiff()</a></code> must be
used as <code>split_fun</code> in the prior column split of the table layout, specifying which columns should be compared.
See <code><a href="#topic+stat_propdiff_ci">stat_propdiff_ci()</a></code> for details on risk difference calculation.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("count_occurrences_by_grade")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_.var">.var</code>, <code id="count_occurrences_by_grade_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_occurrences_by_grade_+3A_labelstr">labelstr</code></td>
<td>
<p>(<code>character</code>)<br /> label of the level of the parent split currently being summarized
(must be present as second argument in Content Row Functions). See <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>
for more information.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>count_occurrences_by_grade()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_count_occurrences_by_grade()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>summarize_occurrences_by_grade()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted content rows
containing the statistics from <code>s_count_occurrences_by_grade()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_occurrences_by_grade()</code> returns a list of counts and fractions with one element per grade level or
grade level grouping.
</p>
</li></ul>


<ul>
<li> <p><code>a_count_occurrences_by_grade()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>count_occurrences_by_grade()</code>: Layout-creating function which can take statistics function
arguments and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>summarize_occurrences_by_grade()</code>: Layout-creating function which can take content function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>
</li>
<li> <p><code>s_count_occurrences_by_grade()</code>: Statistics function which counts the
number of patients by highest grade.
</p>
</li>
<li> <p><code>a_count_occurrences_by_grade()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>count_occurrences_by_grade()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p>Relevant helper function <code><a href="#topic+h_append_grade_groups">h_append_grade_groups()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

df &lt;- data.frame(
  USUBJID = as.character(c(1:6, 1)),
  ARM = factor(c("A", "A", "A", "B", "B", "B", "A"), levels = c("A", "B")),
  AETOXGR = factor(c(1, 2, 3, 4, 1, 2, 3), levels = c(1:5)),
  AESEV = factor(
    x = c("MILD", "MODERATE", "SEVERE", "MILD", "MILD", "MODERATE", "SEVERE"),
    levels = c("MILD", "MODERATE", "SEVERE")
  ),
  stringsAsFactors = FALSE
)

df_adsl &lt;- df %&gt;%
  select(USUBJID, ARM) %&gt;%
  unique()

# Layout creating function with custom format.
basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_colcounts() %&gt;%
  count_occurrences_by_grade(
    var = "AESEV",
    .formats = c("count_fraction" = "xx.xx (xx.xx%)")
  ) %&gt;%
  build_table(df, alt_counts_df = df_adsl)

# Define additional grade groupings.
grade_groups &lt;- list(
  "-Any-" = c("1", "2", "3", "4", "5"),
  "Grade 1-2" = c("1", "2"),
  "Grade 3-5" = c("3", "4", "5")
)

basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_colcounts() %&gt;%
  count_occurrences_by_grade(
    var = "AETOXGR",
    grade_groups = grade_groups
  ) %&gt;%
  build_table(df, alt_counts_df = df_adsl)

# Layout creating function with custom format.
basic_table() %&gt;%
  add_colcounts() %&gt;%
  split_rows_by("ARM", child_labels = "visible", nested = TRUE) %&gt;%
  summarize_occurrences_by_grade(
    var = "AESEV",
    .formats = c("count_fraction" = "xx.xx (xx.xx%)")
  ) %&gt;%
  build_table(df, alt_counts_df = df_adsl)

basic_table() %&gt;%
  add_colcounts() %&gt;%
  split_rows_by("ARM", child_labels = "visible", nested = TRUE) %&gt;%
  summarize_occurrences_by_grade(
    var = "AETOXGR",
    grade_groups = grade_groups
  ) %&gt;%
  build_table(df, alt_counts_df = df_adsl)

s_count_occurrences_by_grade(
  df,
  .N_col = 10L,
  .var = "AETOXGR",
  id = "USUBJID",
  grade_groups = list("ANY" = levels(df$AETOXGR))
)

#  We need to ungroup `count_fraction` first so that the `rtables` formatting
# function `format_count_fraction()` can be applied correctly.
afun &lt;- make_afun(a_count_occurrences_by_grade, .ungroup_stats = "count_fraction")
afun(
  df,
  .N_col = 10L,
  .var = "AETOXGR",
  id = "USUBJID",
  grade_groups = list("ANY" = levels(df$AETOXGR))
)

</code></pre>

<hr>
<h2 id='count_patients_events_in_cols'>Counting Patients and Events in Columns</h2><span id='topic+count_patients_events_in_cols'></span><span id='topic+summarize_patients_events_in_cols'></span><span id='topic+s_count_patients_and_multiple_events'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Counting the number of unique patients and the total number of all and specific events
when a column table layout is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_patients_events_in_cols(
  lyt,
  id = "USUBJID",
  filters_list = list(),
  empty_stats = character(),
  na_str = default_na_str(),
  ...,
  .stats = c("unique", "all", names(filters_list)),
  .labels = c(unique = "Patients (All)", all = "Events (All)",
    labels_or_names(filters_list)),
  col_split = TRUE
)

s_count_patients_and_multiple_events(
  df,
  id,
  filters_list,
  empty_stats = character(),
  labelstr = "",
  custom_label = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_patients_events_in_cols_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="count_patients_events_in_cols_+3A_id">id</code></td>
<td>
<p>(<code>string</code>)<br /> subject variable name.</p>
</td></tr>
<tr><td><code id="count_patients_events_in_cols_+3A_filters_list">filters_list</code></td>
<td>
<p>(named <code>list</code> of <code>character</code>)<br /> each element in this list describes one
type of event describe by filters, in the same format as <code><a href="#topic+s_count_patients_with_event">s_count_patients_with_event()</a></code>.
If it has a label, then this will be used for the column title.</p>
</td></tr>
<tr><td><code id="count_patients_events_in_cols_+3A_empty_stats">empty_stats</code></td>
<td>
<p>(<code>character</code>)<br /> optional names of the statistics that should be returned empty such
that corresponding table cells will stay blank.</p>
</td></tr>
<tr><td><code id="count_patients_events_in_cols_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="count_patients_events_in_cols_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="count_patients_events_in_cols_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run
<code>get_stats("summarize_patients_events_in_cols")</code> to see available statistics for this function, in addition
to any added using <code>filters_list</code>.</p>
</td></tr>
<tr><td><code id="count_patients_events_in_cols_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="count_patients_events_in_cols_+3A_col_split">col_split</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the columns should be split.
Set to <code>FALSE</code> when the required column split has been done already earlier in the layout pipe.</p>
</td></tr>
<tr><td><code id="count_patients_events_in_cols_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="count_patients_events_in_cols_+3A_labelstr">labelstr</code></td>
<td>
<p>(<code>character</code>)<br /> label of the level of the parent split currently being summarized
(must be present as second argument in Content Row Functions). See <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>
for more information.</p>
</td></tr>
<tr><td><code id="count_patients_events_in_cols_+3A_custom_label">custom_label</code></td>
<td>
<p>(<code>string</code> or <code>NULL</code>)<br /> if provided and <code>labelstr</code> is empty then this will
be used as label.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>summarize_patients_events_in_cols()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted content rows
containing the statistics from <code>s_count_patients_and_multiple_events()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_patients_and_multiple_events()</code> returns a list with the statistics:
</p>

<ul>
<li> <p><code>unique</code>: number of unique patients in <code>df</code>.
</p>
</li>
<li> <p><code>all</code>: number of rows in <code>df</code>.
</p>
</li>
<li><p> one element with the same name as in <code>filters_list</code>: number of rows in <code>df</code>,
i.e. events, fulfilling the filter condition.
</p>
</li></ul>

</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>summarize_patients_events_in_cols()</code>: Layout-creating function which can take statistics function
arguments and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>
</li>
<li> <p><code>s_count_patients_and_multiple_events()</code>: Statistics function which counts numbers of patients and multiple
events defined by filters. Used as analysis function <code>afun</code> in <code>summarize_patients_events_in_cols()</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  USUBJID = rep(c("id1", "id2", "id3", "id4"), c(2, 3, 1, 1)),
  ARM = c("A", "A", "B", "B", "B", "B", "A"),
  AESER = rep("Y", 7),
  AESDTH = c("Y", "Y", "N", "Y", "Y", "N", "N"),
  AEREL = c("Y", "Y", "N", "Y", "Y", "N", "Y"),
  AEDECOD = c("A", "A", "A", "B", "B", "C", "D"),
  AEBODSYS = rep(c("SOC1", "SOC2", "SOC3"), c(3, 3, 1))
)

# `summarize_patients_events_in_cols()`
basic_table() %&gt;%
  summarize_patients_events_in_cols(
    filters_list = list(
      related = formatters::with_label(c(AEREL = "Y"), "Events (Related)"),
      fatal = c(AESDTH = "Y"),
      fatal_related = c(AEREL = "Y", AESDTH = "Y")
    ),
    custom_label = "%s Total number of patients and events"
  ) %&gt;%
  build_table(df)

</code></pre>

<hr>
<h2 id='count_patients_with_event'>Count the Number of Patients with a Particular Event</h2><span id='topic+count_patients_with_event'></span><span id='topic+s_count_patients_with_event'></span><span id='topic+a_count_patients_with_event'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The primary analysis variable <code>.var</code> denotes the unique patient identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_patients_with_event(
  lyt,
  vars,
  filters,
  riskdiff = FALSE,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  table_names = vars,
  .stats = "count_fraction",
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_count_patients_with_event(
  df,
  .var,
  filters,
  .N_col,
  .N_row,
  denom = c("n", "N_row", "N_col")
)

a_count_patients_with_event(
  df,
  .var,
  filters,
  .N_col,
  .N_row,
  denom = c("n", "N_row", "N_col")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_patients_with_event_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_filters">filters</code></td>
<td>
<p>(<code>character</code>)<br /> a character vector specifying the column names and flag variables
to be used for counting the number of unique identifiers satisfying such conditions.
Multiple column names and flags are accepted in this format
<code>c("column_name1" = "flag1", "column_name2" = "flag2")</code>.
Note that only equality is being accepted as condition.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_riskdiff">riskdiff</code></td>
<td>
<p>(<code>flag</code>)<br /> whether a risk difference column is present. When set to <code>TRUE</code>, <code><a href="#topic+add_riskdiff">add_riskdiff()</a></code> must be
used as <code>split_fun</code> in the prior column split of the table layout, specifying which columns should be compared.
See <code><a href="#topic+stat_propdiff_ci">stat_propdiff_ci()</a></code> for details on risk difference calculation.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("count_patients_with_event")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_.var">.var</code></td>
<td>
<p>(<code>character</code>)<br /> name of the column that contains the unique identifier.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_.n_row">.N_row</code></td>
<td>
<p>(<code>integer</code>)<br /> row-wise N (row group count) for the group of observations being analyzed
(i.e. with no column-based subsetting) that is typically passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_patients_with_event_+3A_denom">denom</code></td>
<td>
<p>(<code>string</code>)<br /> choice of denominator for proportion. Options are:
</p>

<ul>
<li> <p><code>n</code>: number of values in this row and column intersection.
</p>
</li>
<li> <p><code>N_row</code>: total number of values in this row across columns.
</p>
</li>
<li> <p><code>N_col</code>: total number of values in this column across rows.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>count_patients_with_event()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_count_patients_with_event()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_patients_with_event()</code> returns the count and fraction of unique identifiers with the defined event.
</p>
</li></ul>


<ul>
<li> <p><code>a_count_patients_with_event()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>count_patients_with_event()</code>: Layout-creating function which can take statistics function
arguments and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_count_patients_with_event()</code>: Statistics function which counts the number of patients for which
the defined event has occurred.
</p>
</li>
<li> <p><code>a_count_patients_with_event()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>count_patients_with_event()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+count_patients_with_flags">count_patients_with_flags</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># `count_patients_with_event()`

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_colcounts() %&gt;%
  count_values(
    "STUDYID",
    values = "AB12345",
    .stats = "count",
    .labels = c(count = "Total AEs")
  ) %&gt;%
  count_patients_with_event(
    "SUBJID",
    filters = c("TRTEMFL" = "Y"),
    .labels = c(count_fraction = "Total number of patients with at least one adverse event"),
    table_names = "tbl_all"
  ) %&gt;%
  count_patients_with_event(
    "SUBJID",
    filters = c("TRTEMFL" = "Y", "AEOUT" = "FATAL"),
    .labels = c(count_fraction = "Total number of patients with fatal AEs"),
    table_names = "tbl_fatal"
  ) %&gt;%
  count_patients_with_event(
    "SUBJID",
    filters = c("TRTEMFL" = "Y", "AEOUT" = "FATAL", "AEREL" = "Y"),
    .labels = c(count_fraction = "Total number of patients with related fatal AEs"),
    .indent_mods = c(count_fraction = 2L),
    table_names = "tbl_rel_fatal"
  )

build_table(lyt, tern_ex_adae, alt_counts_df = tern_ex_adsl)

# `s_count_patients_with_event()`

s_count_patients_with_event(
  tern_ex_adae,
  .var = "SUBJID",
  filters = c("TRTEMFL" = "Y")
)

s_count_patients_with_event(
  tern_ex_adae,
  .var = "SUBJID",
  filters = c("TRTEMFL" = "Y", "AEOUT" = "FATAL")
)

s_count_patients_with_event(
  tern_ex_adae,
  .var = "SUBJID",
  filters = c("TRTEMFL" = "Y", "AEOUT" = "FATAL"),
  denom = "N_col",
  .N_col = 456
)

# `a_count_patients_with_event()`

a_count_patients_with_event(
  tern_ex_adae,
  .var = "SUBJID",
  filters = c("TRTEMFL" = "Y"),
  .N_col = 100,
  .N_row = 100
)

</code></pre>

<hr>
<h2 id='count_patients_with_flags'>Count the Number of Patients with Particular Flags</h2><span id='topic+count_patients_with_flags'></span><span id='topic+s_count_patients_with_flags'></span><span id='topic+a_count_patients_with_flags'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The primary analysis variable <code>.var</code> denotes the unique patient identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_patients_with_flags(
  lyt,
  var,
  flag_variables,
  flag_labels = NULL,
  var_labels = var,
  show_labels = "hidden",
  riskdiff = FALSE,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  table_names = paste0("tbl_flags_", var),
  .stats = "count_fraction",
  .formats = NULL,
  .indent_mods = NULL
)

s_count_patients_with_flags(
  df,
  .var,
  flag_variables,
  flag_labels = NULL,
  .N_col,
  .N_row,
  denom = c("n", "N_row", "N_col")
)

a_count_patients_with_flags(
  df,
  .var,
  flag_variables,
  flag_labels = NULL,
  .N_col,
  .N_row,
  denom = c("n", "N_row", "N_col")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_patients_with_flags_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_flag_variables">flag_variables</code></td>
<td>
<p>(<code>character</code>)<br /> a character vector specifying the names of <code>logical</code>
variables from analysis dataset used for counting the number of unique identifiers.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_flag_labels">flag_labels</code></td>
<td>
<p>(<code>character</code>)<br /> vector of labels to use for flag variables.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_riskdiff">riskdiff</code></td>
<td>
<p>(<code>flag</code>)<br /> whether a risk difference column is present. When set to <code>TRUE</code>, <code><a href="#topic+add_riskdiff">add_riskdiff()</a></code> must be
used as <code>split_fun</code> in the prior column split of the table layout, specifying which columns should be compared.
See <code><a href="#topic+stat_propdiff_ci">stat_propdiff_ci()</a></code> for details on risk difference calculation.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("count_patients_with_flags")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_.var">.var</code></td>
<td>
<p>(<code>character</code>)<br /> name of the column that contains the unique identifier.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_.n_row">.N_row</code></td>
<td>
<p>(<code>integer</code>)<br /> row-wise N (row group count) for the group of observations being analyzed
(i.e. with no column-based subsetting) that is typically passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_patients_with_flags_+3A_denom">denom</code></td>
<td>
<p>(<code>string</code>)<br /> choice of denominator for proportion. Options are:
</p>

<ul>
<li> <p><code>n</code>: number of values in this row and column intersection.
</p>
</li>
<li> <p><code>N_row</code>: total number of values in this row across columns.
</p>
</li>
<li> <p><code>N_col</code>: total number of values in this column across rows.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>count_patients_with_flags()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_count_patients_with_flags()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_patients_with_flags()</code> returns the count and the fraction of unique identifiers with each particular
flag as a list of statistics <code>n</code>, <code>count</code>, <code>count_fraction</code>, and <code>n_blq</code>, with one element per flag.
</p>
</li></ul>


<ul>
<li> <p><code>a_count_patients_with_flags()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>count_patients_with_flags()</code>: Layout-creating function which can take statistics function
arguments and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_count_patients_with_flags()</code>: Statistics function which counts the number of patients for which
a particular flag variable is <code>TRUE</code>.
</p>
</li>
<li> <p><code>a_count_patients_with_flags()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>count_patients_with_flags()</code>.
</p>
</li></ul>


<h3>Note</h3>

<p>If <code>flag_labels</code> is not specified, variables labels will be extracted from <code>df</code>. If variables are not
labeled, variable names will be used instead. Alternatively, a named <code>vector</code> can be supplied to
<code>flag_variables</code> such that within each name-value pair the name corresponds to the variable name and the value is
the label to use for this variable.
</p>


<h3>See Also</h3>

<p><a href="#topic+count_patients_with_event">count_patients_with_event</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Add labelled flag variables to analysis dataset.
adae &lt;- tern_ex_adae %&gt;%
  mutate(
    fl1 = TRUE %&gt;% with_label("Total AEs"),
    fl2 = (TRTEMFL == "Y") %&gt;%
      with_label("Total number of patients with at least one adverse event"),
    fl3 = (TRTEMFL == "Y" &amp; AEOUT == "FATAL") %&gt;%
      with_label("Total number of patients with fatal AEs"),
    fl4 = (TRTEMFL == "Y" &amp; AEOUT == "FATAL" &amp; AEREL == "Y") %&gt;%
      with_label("Total number of patients with related fatal AEs")
  )

# `count_patients_with_flags()`

lyt2 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_colcounts() %&gt;%
  count_patients_with_flags(
    "SUBJID",
    flag_variables = c("fl1", "fl2", "fl3", "fl4"),
    denom = "N_col"
  )

build_table(lyt2, adae, alt_counts_df = tern_ex_adsl)

# `s_count_patients_with_flags()`

s_count_patients_with_flags(
  adae,
  "SUBJID",
  flag_variables = c("fl1", "fl2", "fl3", "fl4"),
  denom = "N_col",
  .N_col = 1000
)

#  We need to ungroup `count_fraction` first so that the `rtables` formatting
# function `format_count_fraction()` can be applied correctly.

# `a_count_patients_with_flags()`

afun &lt;- make_afun(a_count_patients_with_flags,
  .stats = "count_fraction",
  .ungroup_stats = "count_fraction"
)
afun(
  adae,
  .N_col = 10L,
  .N_row = 10L,
  .var = "USUBJID",
  flag_variables = c("fl1", "fl2", "fl3", "fl4")
)

</code></pre>

<hr>
<h2 id='count_values_funs'>Counting Specific Values</h2><span id='topic+count_values_funs'></span><span id='topic+count_values'></span><span id='topic+s_count_values'></span><span id='topic+s_count_values.character'></span><span id='topic+s_count_values.factor'></span><span id='topic+s_count_values.logical'></span><span id='topic+a_count_values'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>We can count the occurrence of specific values in a variable of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_values(
  lyt,
  vars,
  values,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  table_names = vars,
  .stats = "count_fraction",
  .formats = NULL,
  .labels = c(count_fraction = paste(values, collapse = ", ")),
  .indent_mods = NULL
)

s_count_values(
  x,
  values,
  na.rm = TRUE,
  .N_col,
  .N_row,
  denom = c("n", "N_row", "N_col")
)

## S3 method for class 'character'
s_count_values(x, values = "Y", na.rm = TRUE, ...)

## S3 method for class 'factor'
s_count_values(x, values = "Y", ...)

## S3 method for class 'logical'
s_count_values(x, values = TRUE, ...)

a_count_values(
  x,
  values,
  na.rm = TRUE,
  .N_col,
  .N_row,
  denom = c("n", "N_row", "N_col")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_values_funs_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_values">values</code></td>
<td>
<p>(<code>character</code>)<br /> specific values that should be counted.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("count_values")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector of numbers we want to analyze.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>flag</code>)<br /> whether <code>NA</code> values should be removed from <code>x</code> prior to analysis.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_.n_row">.N_row</code></td>
<td>
<p>(<code>integer</code>)<br /> row-wise N (row group count) for the group of observations being analyzed
(i.e. with no column-based subsetting) that is typically passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="count_values_funs_+3A_denom">denom</code></td>
<td>
<p>(<code>string</code>)<br /> choice of denominator for proportion. Options are:
</p>

<ul>
<li> <p><code>n</code>: number of values in this row and column intersection.
</p>
</li>
<li> <p><code>N_row</code>: total number of values in this row across columns.
</p>
</li>
<li> <p><code>N_col</code>: total number of values in this column across rows.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>count_values()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_count_values()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_values()</code> returns output of <code><a href="#topic+s_summary">s_summary()</a></code> for specified values of a non-numeric variable.
</p>
</li></ul>


<ul>
<li> <p><code>a_count_values()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>count_values()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_count_values()</code>: S3 generic function to count values.
</p>
</li>
<li> <p><code>s_count_values(character)</code>: Method for <code>character</code> class.
</p>
</li>
<li> <p><code>s_count_values(factor)</code>: Method for <code>factor</code> class. This makes an automatic
conversion to <code>character</code> and then forwards to the method for characters.
</p>
</li>
<li> <p><code>s_count_values(logical)</code>: Method for <code>logical</code> class.
</p>
</li>
<li> <p><code>a_count_values()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>count_values()</code>.
</p>
</li></ul>


<h3>Note</h3>


<ul>
<li><p> For <code>factor</code> variables, <code>s_count_values</code> checks whether <code>values</code> are all included in the levels of <code>x</code>
and fails otherwise.
</p>
</li>
<li><p> For <code>count_values()</code>, variable labels are shown when there is more than one element in <code>vars</code>,
otherwise they are hidden.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># `count_values`
basic_table() %&gt;%
  count_values("Species", values = "setosa") %&gt;%
  build_table(iris)

# `s_count_values.character`
s_count_values(x = c("a", "b", "a"), values = "a")
s_count_values(x = c("a", "b", "a", NA, NA), values = "b", na.rm = FALSE)

# `s_count_values.factor`
s_count_values(x = factor(c("a", "b", "a")), values = "a")

# `s_count_values.logical`
s_count_values(x = c(TRUE, FALSE, TRUE))

# `a_count_values`
a_count_values(x = factor(c("a", "b", "a")), values = "a", .N_col = 10, .N_row = 10)

</code></pre>

<hr>
<h2 id='cox_regression'>Cox Proportional Hazards Regression</h2><span id='topic+cox_regression'></span><span id='topic+summarize_coxreg'></span><span id='topic+s_coxreg'></span><span id='topic+a_coxreg'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Fits a Cox regression model and estimates hazard ratio to describe the effect size in a survival analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_coxreg(
  lyt,
  variables,
  control = control_coxreg(),
  at = list(),
  multivar = FALSE,
  common_var = "STUDYID",
  .stats = c("n", "hr", "ci", "pval", "pval_inter"),
  .formats = c(n = "xx", hr = "xx.xx", ci = "(xx.xx, xx.xx)", pval =
    "x.xxxx | (&lt;0.0001)", pval_inter = "x.xxxx | (&lt;0.0001)"),
  varlabels = NULL,
  .indent_mods = NULL,
  na_level = lifecycle::deprecated(),
  na_str = "",
  .section_div = NA_character_
)

s_coxreg(model_df, .stats, .which_vars = "all", .var_nms = NULL)

a_coxreg(
  df,
  labelstr,
  eff = FALSE,
  var_main = FALSE,
  multivar = FALSE,
  variables,
  at = list(),
  control = control_coxreg(),
  .spl_context,
  .stats,
  .formats,
  .indent_mods = NULL,
  na_level = lifecycle::deprecated(),
  na_str = "",
  cache_env = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox_regression_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> a list of parameters as returned by the helper function <code><a href="#topic+control_coxreg">control_coxreg()</a></code>.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_at">at</code></td>
<td>
<p>(<code>list</code> of <code>numeric</code>)<br /> when the candidate covariate is a <code>numeric</code>, use <code>at</code> to specify
the value of the covariate at which the effect should be estimated.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_multivar">multivar</code></td>
<td>
<p>(<code>flag</code>)<br /> Defaults to <code>FALSE</code>. If <code>TRUE</code> multivariate Cox regression will run, otherwise
univariate Cox regression will run.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_common_var">common_var</code></td>
<td>
<p>(<code>character</code>)<br /> the name of a factor variable in the dataset which takes the same value
for all rows. This should be created during pre-processing if no such variable currently exists.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> the name of statistics to be reported among:
</p>

<ul>
<li> <p><code>n</code>: number of observations (univariate only)
</p>
</li>
<li> <p><code>hr</code>: hazard ratio
</p>
</li>
<li> <p><code>ci</code>: confidence interval
</p>
</li>
<li> <p><code>pval</code>: p-value of the treatment effect
</p>
</li>
<li> <p><code>pval_inter</code>: p-value of the interaction effect between the treatment and the covariate (univariate only)
</p>
</li></ul>
</td></tr>
<tr><td><code id="cox_regression_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_varlabels">varlabels</code></td>
<td>
<p>(<code>list</code>)<br /> a named list corresponds to the names of variables found in data, passed
as a named list and corresponding to time, event, arm, strata, and covariates terms. If arm is missing
from variables, then only Cox model(s) including the covariates will be fitted and the corresponding
effect estimates will be tabulated later.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_na_level">na_level</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use the <code>na_str</code> argument instead.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> custom string to replace all <code>NA</code> values with. Defaults to <code>""</code>.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_.section_div">.section_div</code></td>
<td>
<p>(<code>character</code>)<br /> string which should be repeated as a section divider between sections.
Defaults to <code>NA</code> for no section divider. If a vector of two strings are given, the first will be used between
treatment and covariate sections and the second between different covariates.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_model_df">model_df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> contains the resulting model fit from a <a href="#topic+fit_coxreg">fit_coxreg</a>
function with tidying applied via <code><a href="broom.html#topic+reexports">broom::tidy()</a></code>.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_.which_vars">.which_vars</code></td>
<td>
<p>(<code>character</code>)<br /> which rows should statistics be returned for from the given model.
Defaults to &quot;all&quot;. Other options include &quot;var_main&quot; for main effects, <code>"inter"</code> for interaction effects,
and <code>"multi_lvl"</code> for multivariate model covariate level rows. When <code>.which_vars</code> is &quot;all&quot; specific
variables can be selected by specifying <code>.var_nms</code>.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_.var_nms">.var_nms</code></td>
<td>
<p>(<code>character</code>)<br /> the <code>term</code> value of rows in <code>df</code> for which <code>.stats</code> should be returned. Typically
this is the name of a variable. If using variable labels, <code>var</code> should be a vector of both the desired
variable name and the variable label in that order to see all <code>.stats</code> related to that variable. When <code>.which_vars</code>
is <code>"var_main"</code> <code>.var_nms</code> should be only the variable name.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_labelstr">labelstr</code></td>
<td>
<p>(<code>character</code>)<br /> label of the level of the parent split currently being summarized
(must be present as second argument in Content Row Functions). See <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>
for more information.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_eff">eff</code></td>
<td>
<p>(<code>flag</code>)<br /> whether treatment effect should be calculated. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_var_main">var_main</code></td>
<td>
<p>(<code>flag</code>)<br /> whether main effects should be calculated. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_.spl_context">.spl_context</code></td>
<td>
<p>(<code>data.frame</code>)<br /> gives information about ancestor split states
that is passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="cox_regression_+3A_cache_env">cache_env</code></td>
<td>
<p>(<code>environment</code>)<br /> an environment object used to cache the regression model in order to
avoid repeatedly fitting the same model for every row in the table. Defaults to <code>NULL</code> (no caching).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cox models are the most commonly used methods to estimate the magnitude of
the effect in survival analysis. It assumes proportional hazards: the ratio
of the hazards between groups (e.g., two arms) is constant over time.
This ratio is referred to as the &quot;hazard ratio&quot; (HR) and is one of the
most commonly reported metrics to describe the effect size in survival
analysis (NEST Team, 2020).
</p>


<h3>Value</h3>


<ul>
<li> <p><code>summarize_coxreg()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add a Cox regression table
containing the chosen statistics to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_coxreg()</code> returns the selected statistic for from the Cox regression model for the selected variable(s).
</p>
</li></ul>


<ul>
<li> <p><code>a_coxreg()</code> returns formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>summarize_coxreg()</code>: Layout-creating function which creates a Cox regression summary table
layout. This function is a wrapper for several <code>rtables</code> layouting functions. This function
is a wrapper for <code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code> and <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>
</li>
<li> <p><code>s_coxreg()</code>: Statistics function that transforms results tabulated
from <code><a href="#topic+fit_coxreg_univar">fit_coxreg_univar()</a></code> or <code><a href="#topic+fit_coxreg_multivar">fit_coxreg_multivar()</a></code> into a list.
</p>
</li>
<li> <p><code>a_coxreg()</code>: Analysis function which is used as <code>afun</code> in <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>
and <code>cfun</code> in <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code> within <code>summarize_coxreg()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+fit_coxreg">fit_coxreg</a> for relevant fitting functions, <a href="#topic+h_cox_regression">h_cox_regression</a> for relevant
helper functions, and <a href="#topic+tidy_coxreg">tidy_coxreg</a> for custom tidy methods.
</p>
<p><code><a href="#topic+fit_coxreg_univar">fit_coxreg_univar()</a></code> and <code><a href="#topic+fit_coxreg_multivar">fit_coxreg_multivar()</a></code> which also take the <code>variables</code>, <code>data</code>,
<code>at</code> (univariate only), and <code>control</code> arguments but return unformatted univariate and multivariate
Cox regression models, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)

# Testing dataset [survival::bladder].
set.seed(1, kind = "Mersenne-Twister")
dta_bladder &lt;- with(
  data = bladder[bladder$enum &lt; 5, ],
  tibble::tibble(
    TIME = stop,
    STATUS = event,
    ARM = as.factor(rx),
    COVAR1 = as.factor(enum) %&gt;% formatters::with_label("A Covariate Label"),
    COVAR2 = factor(
      sample(as.factor(enum)),
      levels = 1:4, labels = c("F", "F", "M", "M")
    ) %&gt;% formatters::with_label("Sex (F/M)")
  )
)
dta_bladder$AGE &lt;- sample(20:60, size = nrow(dta_bladder), replace = TRUE)
dta_bladder$STUDYID &lt;- factor("X")

u1_variables &lt;- list(
  time = "TIME", event = "STATUS", arm = "ARM", covariates = c("COVAR1", "COVAR2")
)

u2_variables &lt;- list(time = "TIME", event = "STATUS", covariates = c("COVAR1", "COVAR2"))

m1_variables &lt;- list(
  time = "TIME", event = "STATUS", arm = "ARM", covariates = c("COVAR1", "COVAR2")
)

m2_variables &lt;- list(time = "TIME", event = "STATUS", covariates = c("COVAR1", "COVAR2"))

# summarize_coxreg

result_univar &lt;- basic_table() %&gt;%
  summarize_coxreg(variables = u1_variables) %&gt;%
  build_table(dta_bladder)
result_univar

result_univar_covs &lt;- basic_table() %&gt;%
  summarize_coxreg(
    variables = u2_variables,
  ) %&gt;%
  build_table(dta_bladder)
result_univar_covs

result_multivar &lt;- basic_table() %&gt;%
  summarize_coxreg(
    variables = m1_variables,
    multivar = TRUE,
  ) %&gt;%
  build_table(dta_bladder)
result_multivar

result_multivar_covs &lt;- basic_table() %&gt;%
  summarize_coxreg(
    variables = m2_variables,
    multivar = TRUE,
    varlabels = c("Covariate 1", "Covariate 2") # custom labels
  ) %&gt;%
  build_table(dta_bladder)
result_multivar_covs

# s_coxreg

# Univariate
univar_model &lt;- fit_coxreg_univar(variables = u1_variables, data = dta_bladder)
df1 &lt;- broom::tidy(univar_model)

s_coxreg(model_df = df1, .stats = "hr")

# Univariate with interactions
univar_model_inter &lt;- fit_coxreg_univar(
  variables = u1_variables, control = control_coxreg(interaction = TRUE), data = dta_bladder
)
df1_inter &lt;- broom::tidy(univar_model_inter)

s_coxreg(model_df = df1_inter, .stats = "hr", .which_vars = "inter", .var_nms = "COVAR1")

# Univariate without treatment arm - only "COVAR2" covariate effects
univar_covs_model &lt;- fit_coxreg_univar(variables = u2_variables, data = dta_bladder)
df1_covs &lt;- broom::tidy(univar_covs_model)

s_coxreg(model_df = df1_covs, .stats = "hr", .var_nms = c("COVAR2", "Sex (F/M)"))

# Multivariate.
multivar_model &lt;- fit_coxreg_multivar(variables = m1_variables, data = dta_bladder)
df2 &lt;- broom::tidy(multivar_model)

s_coxreg(model_df = df2, .stats = "pval", .which_vars = "var_main", .var_nms = "COVAR1")
s_coxreg(
  model_df = df2, .stats = "pval", .which_vars = "multi_lvl",
  .var_nms = c("COVAR1", "A Covariate Label")
)

# Multivariate without treatment arm - only "COVAR1" main effect
multivar_covs_model &lt;- fit_coxreg_multivar(variables = m2_variables, data = dta_bladder)
df2_covs &lt;- broom::tidy(multivar_covs_model)

s_coxreg(model_df = df2_covs, .stats = "hr")

a_coxreg(
  df = dta_bladder,
  labelstr = "Label 1",
  variables = u1_variables,
  .spl_context = list(value = "COVAR1"),
  .stats = "n",
  .formats = "xx"
)

a_coxreg(
  df = dta_bladder,
  labelstr = "",
  variables = u1_variables,
  .spl_context = list(value = "COVAR2"),
  .stats = "pval",
  .formats = "xx.xxxx"
)

</code></pre>

<hr>
<h2 id='cox_regression_inter'>Cox Regression Helper: Interactions</h2><span id='topic+cox_regression_inter'></span><span id='topic+h_coxreg_inter_effect'></span><span id='topic+h_coxreg_inter_effect.numeric'></span><span id='topic+h_coxreg_inter_effect.factor'></span><span id='topic+h_coxreg_inter_effect.character'></span><span id='topic+h_coxreg_extract_interaction'></span><span id='topic+h_coxreg_inter_estimations'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Test and estimate the effect of a treatment in interaction with a covariate.
The effect is estimated as the HR of the tested treatment for a given level
of the covariate, in comparison to the treatment control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_coxreg_inter_effect(x, effect, covar, mod, label, control, ...)

## S3 method for class 'numeric'
h_coxreg_inter_effect(x, effect, covar, mod, label, control, at, ...)

## S3 method for class 'factor'
h_coxreg_inter_effect(x, effect, covar, mod, label, control, data, ...)

## S3 method for class 'character'
h_coxreg_inter_effect(x, effect, covar, mod, label, control, data, ...)

h_coxreg_extract_interaction(effect, covar, mod, data, at, control)

h_coxreg_inter_estimations(
  variable,
  given,
  lvl_var,
  lvl_given,
  mod,
  conf_level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox_regression_inter_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code> or <code>factor</code>)<br /> the values of the covariate to be tested.</p>
</td></tr>
<tr><td><code id="cox_regression_inter_+3A_effect">effect</code></td>
<td>
<p>(<code>string</code>)<br /> the name of the effect to be tested and estimated.</p>
</td></tr>
<tr><td><code id="cox_regression_inter_+3A_covar">covar</code></td>
<td>
<p>(<code>string</code>)<br /> the name of the covariate in the model.</p>
</td></tr>
<tr><td><code id="cox_regression_inter_+3A_mod">mod</code></td>
<td>
<p>(<code>coxph</code>)<br /> a fitted Cox regression model (see <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>).</p>
</td></tr>
<tr><td><code id="cox_regression_inter_+3A_label">label</code></td>
<td>
<p>(<code>string</code>)<br /> the label to be returned as <code>term_label</code>.</p>
</td></tr>
<tr><td><code id="cox_regression_inter_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> a list of controls as returned by <code><a href="#topic+control_coxreg">control_coxreg()</a></code>.</p>
</td></tr>
<tr><td><code id="cox_regression_inter_+3A_...">...</code></td>
<td>
<p>see methods.</p>
</td></tr>
<tr><td><code id="cox_regression_inter_+3A_at">at</code></td>
<td>
<p>(<code>list</code>)<br /> a list with items named after the covariate, every
item is a vector of levels at which the interaction should be estimated.</p>
</td></tr>
<tr><td><code id="cox_regression_inter_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the data frame on which the model was fit.</p>
</td></tr>
<tr><td><code id="cox_regression_inter_+3A_variable">variable</code>, <code id="cox_regression_inter_+3A_given">given</code></td>
<td>
<p>(<code>string</code>)<br /> the name of variables in interaction. We seek the estimation
of the levels of <code>variable</code> given the levels of <code>given</code>.</p>
</td></tr>
<tr><td><code id="cox_regression_inter_+3A_lvl_var">lvl_var</code>, <code id="cox_regression_inter_+3A_lvl_given">lvl_given</code></td>
<td>
<p>(<code>character</code>)<br /> corresponding levels has given by <code><a href="base.html#topic+levels">levels()</a></code>.</p>
</td></tr>
<tr><td><code id="cox_regression_inter_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the cox regression investigating the effect of Arm (A, B, C; reference A)
and Sex (F, M; reference Female) and the model being abbreviated: y ~ Arm + Sex + Arm:Sex.
The cox regression estimates the coefficients along with a variance-covariance matrix for:
</p>

<ul>
<li><p> b1 (arm b), b2 (arm c)
</p>
</li>
<li><p> b3 (sex m)
</p>
</li>
<li><p> b4 (arm b: sex m), b5 (arm c: sex m)
</p>
</li></ul>

<p>The estimation of the Hazard Ratio for arm C/sex M is given in reference
to arm A/Sex M by exp(b2 + b3 + b5)/ exp(b3) = exp(b2 + b5).
The interaction coefficient is deduced by b2 + b5 while the standard error
is obtained as $sqrt(Var b2 + Var b5 + 2 * covariance (b2,b5))$.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>h_coxreg_inter_effect()</code> returns a <code>data.frame</code> of covariate interaction effects consisting of the following
variables: <code>effect</code>, <code>term</code>, <code>term_label</code>, <code>level</code>, <code>n</code>, <code>hr</code>, <code>lcl</code>, <code>ucl</code>, <code>pval</code>, and <code>pval_inter</code>.
</p>
</li></ul>


<ul>
<li> <p><code>h_coxreg_extract_interaction()</code> returns the result of an interaction test and the estimated values. If
no interaction, <code><a href="#topic+h_coxreg_univar_extract">h_coxreg_univar_extract()</a></code> is applied instead.
</p>
</li></ul>


<ul>
<li> <p><code>h_coxreg_inter_estimations()</code> returns a list of matrices (one per level of variable) with rows corresponding
to the combinations of <code>variable</code> and <code>given</code>, with columns:
</p>

<ul>
<li> <p><code>coef_hat</code>: Estimation of the coefficient.
</p>
</li>
<li> <p><code>coef_se</code>: Standard error of the estimation.
</p>
</li>
<li> <p><code>hr</code>: Hazard ratio.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;lcl, ucl&#8288;</code>: Lower/upper confidence limit of the hazard ratio.
</p>
</li></ul>

</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>h_coxreg_inter_effect()</code>: S3 generic helper function to determine interaction effect.
</p>
</li>
<li> <p><code>h_coxreg_inter_effect(numeric)</code>: Method for <code>numeric</code> class. Estimates the interaction with a <code>numeric</code> covariate.
</p>
</li>
<li> <p><code>h_coxreg_inter_effect(factor)</code>: Method for <code>factor</code> class. Estimate the interaction with a <code>factor</code> covariate.
</p>
</li>
<li> <p><code>h_coxreg_inter_effect(character)</code>: Method for <code>character</code> class. Estimate the interaction with a <code>character</code> covariate.
This makes an automatic conversion to <code>factor</code> and then forwards to the method for factors.
</p>
</li>
<li> <p><code>h_coxreg_extract_interaction()</code>: A higher level function to get
the results of the interaction test and the estimated values.
</p>
</li>
<li> <p><code>h_coxreg_inter_estimations()</code>: Hazard ratio estimation in interactions.
</p>
</li></ul>


<h3>Note</h3>


<ul>
<li><p> Automatic conversion of character to factor does not guarantee results can be generated correctly. It is
therefore better to always pre-process the dataset such that factors are manually created from character
variables before passing the dataset to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(survival)

set.seed(1, kind = "Mersenne-Twister")

# Testing dataset [survival::bladder].
dta_bladder &lt;- with(
  data = bladder[bladder$enum &lt; 5, ],
  data.frame(
    time = stop,
    status = event,
    armcd = as.factor(rx),
    covar1 = as.factor(enum),
    covar2 = factor(
      sample(as.factor(enum)),
      levels = 1:4,
      labels = c("F", "F", "M", "M")
    )
  )
)
labels &lt;- c("armcd" = "ARM", "covar1" = "A Covariate Label", "covar2" = "Sex (F/M)")
formatters::var_labels(dta_bladder)[names(labels)] &lt;- labels
dta_bladder$age &lt;- sample(20:60, size = nrow(dta_bladder), replace = TRUE)

plot(
  survfit(Surv(time, status) ~ armcd + covar1, data = dta_bladder),
  lty = 2:4,
  xlab = "Months",
  col = c("blue1", "blue2", "blue3", "blue4", "red1", "red2", "red3", "red4")
)

mod &lt;- coxph(Surv(time, status) ~ armcd * covar1, data = dta_bladder)
h_coxreg_extract_interaction(
  mod = mod, effect = "armcd", covar = "covar1", data = dta_bladder,
  control = control_coxreg()
)

mod &lt;- coxph(Surv(time, status) ~ armcd * covar1, data = dta_bladder)
result &lt;- h_coxreg_inter_estimations(
  variable = "armcd", given = "covar1",
  lvl_var = levels(dta_bladder$armcd),
  lvl_given = levels(dta_bladder$covar1),
  mod = mod, conf_level = .95
)
result

</code></pre>

<hr>
<h2 id='create_afun_compare'>Constructor Function for <code><a href="#topic+compare_vars">compare_vars()</a></code></h2><span id='topic+create_afun_compare'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Constructor function which creates a combined formatted analysis function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_afun_compare(
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_afun_compare_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table.</p>
</td></tr>
<tr><td><code id="create_afun_compare_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="create_afun_compare_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="create_afun_compare_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>vector</code> of <code>integer</code>)<br /> indent modifiers for the labels. Each element of the vector
should be a name-value pair with name corresponding to a statistic specified in <code>.stats</code> and value the indentation
for that statistic's row label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Combined formatted analysis function for use in <code><a href="#topic+compare_vars">compare_vars()</a></code>.
</p>


<h3>Note</h3>

<p>This function has been deprecated in favor of direct implementation of <code>a_summary()</code> with argument <code>compare</code>
set to <code>TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare_vars">compare_vars()</a></code>
</p>

<hr>
<h2 id='create_afun_summary'>Constructor Function for <code><a href="#topic+analyze_vars">analyze_vars()</a></code> and <code><a href="#topic+summarize_colvars">summarize_colvars()</a></code></h2><span id='topic+create_afun_summary'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Constructor function which creates a combined formatted analysis function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_afun_summary(.stats, .formats, .labels, .indent_mods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_afun_summary_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table.</p>
</td></tr>
<tr><td><code id="create_afun_summary_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="create_afun_summary_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="create_afun_summary_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>vector</code> of <code>integer</code>)<br /> indent modifiers for the labels. Each element of the vector
should be a name-value pair with name corresponding to a statistic specified in <code>.stats</code> and value the indentation
for that statistic's row label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Combined formatted analysis function for use in <code><a href="#topic+analyze_vars">analyze_vars()</a></code>.
</p>


<h3>Note</h3>

<p>This function has been deprecated in favor of direct implementation of <code>a_summary()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze_vars">analyze_vars()</a></code>
</p>

<hr>
<h2 id='cut_quantile_bins'>Cutting Numeric Vector into Empirical Quantile Bins</h2><span id='topic+cut_quantile_bins'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This cuts a numeric vector into sample quantile bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_quantile_bins(
  x,
  probs = c(0.25, 0.5, 0.75),
  labels = NULL,
  type = 7,
  ordered = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_quantile_bins_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> the continuous variable values which should be cut into
quantile bins. This may contain <code>NA</code> values, which are then
not used for the quantile calculations, but included in the return vector.</p>
</td></tr>
<tr><td><code id="cut_quantile_bins_+3A_probs">probs</code></td>
<td>
<p>(<code>proportion</code> vector)<br /> the probabilities identifying the quantiles.
This is a sorted vector of unique <code>proportion</code> values, i.e. between 0 and 1, where
the boundaries 0 and 1 must not be included.</p>
</td></tr>
<tr><td><code id="cut_quantile_bins_+3A_labels">labels</code></td>
<td>
<p>(<code>character</code>)<br /> the unique labels for the quantile bins. When there are <code>n</code>
probabilities in <code>probs</code>, then this must be <code>n + 1</code> long.</p>
</td></tr>
<tr><td><code id="cut_quantile_bins_+3A_type">type</code></td>
<td>
<p>(<code>integer</code>)<br /> type of quantiles to use, see <code><a href="stats.html#topic+quantile">stats::quantile()</a></code> for details.</p>
</td></tr>
<tr><td><code id="cut_quantile_bins_+3A_ordered">ordered</code></td>
<td>
<p>(<code>flag</code>)<br /> should the result be an ordered factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>factor</code> variable with appropriately-labeled bins as levels.
</p>


<h3>Note</h3>

<p>Intervals are closed on the right side. That is, the first bin is the interval
<code style="white-space: pre;">&#8288;[-Inf, q1]&#8288;</code> where <code>q1</code> is the first quantile, the second bin is then <code style="white-space: pre;">&#8288;(q1, q2]&#8288;</code>, etc.,
and the last bin is <code style="white-space: pre;">&#8288;(qn, +Inf]&#8288;</code> where <code>qn</code> is the last quantile.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default is to cut into quartile bins.
cut_quantile_bins(cars$speed)

# Use custom quantiles.
cut_quantile_bins(cars$speed, probs = c(0.1, 0.2, 0.6, 0.88))

# Use custom labels.
cut_quantile_bins(cars$speed, labels = paste0("Q", 1:4))

# NAs are preserved in result factor.
ozone_binned &lt;- cut_quantile_bins(airquality$Ozone)
which(is.na(ozone_binned))
# So you might want to make these explicit.
explicit_na(ozone_binned)

</code></pre>

<hr>
<h2 id='d_count_abnormal_by_baseline'>Description Function for <code><a href="#topic+s_count_abnormal_by_baseline">s_count_abnormal_by_baseline()</a></code></h2><span id='topic+d_count_abnormal_by_baseline'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Description function that produces the labels for <code><a href="#topic+s_count_abnormal_by_baseline">s_count_abnormal_by_baseline()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_count_abnormal_by_baseline(abnormal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_count_abnormal_by_baseline_+3A_abnormal">abnormal</code></td>
<td>
<p>(<code>character</code>)<br /> identifying the abnormal range level(s) in <code>.var</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Abnormal category labels for <code><a href="#topic+s_count_abnormal_by_baseline">s_count_abnormal_by_baseline()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d_count_abnormal_by_baseline("LOW")

</code></pre>

<hr>
<h2 id='d_count_cumulative'>Description of Cumulative Count</h2><span id='topic+d_count_cumulative'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is a helper function that describes the analysis in <code><a href="#topic+s_count_cumulative">s_count_cumulative()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_count_cumulative(threshold, lower_tail, include_eq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_count_cumulative_+3A_threshold">threshold</code></td>
<td>
<p>(<code>number</code>)<br /> a cutoff value as threshold to count values of <code>x</code>.</p>
</td></tr>
<tr><td><code id="d_count_cumulative_+3A_lower_tail">lower_tail</code></td>
<td>
<p>(<code>logical</code>)<br /> whether to count lower tail, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="d_count_cumulative_+3A_include_eq">include_eq</code></td>
<td>
<p>(<code>logical</code>)<br /> whether to include value equal to the <code>threshold</code> in
count, default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Labels for <code><a href="#topic+s_count_cumulative">s_count_cumulative()</a></code>.
</p>

<hr>
<h2 id='d_count_missed_doses'>Description Function that Calculates Labels for <code><a href="#topic+s_count_missed_doses">s_count_missed_doses()</a></code>.</h2><span id='topic+d_count_missed_doses'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_count_missed_doses(thresholds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_count_missed_doses_+3A_thresholds">thresholds</code></td>
<td>
<p>(vector of <code>count</code>)<br /> number of missed doses the patients at least had.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+d_count_missed_doses">d_count_missed_doses()</a></code> returns a named <code>character</code> vector with the labels.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s_count_missed_doses">s_count_missed_doses()</a></code>
</p>

<hr>
<h2 id='d_onco_rsp_label'>Description of Standard Oncology Response</h2><span id='topic+d_onco_rsp_label'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Describe the oncology response in a standard way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_onco_rsp_label(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_onco_rsp_label_+3A_x">x</code></td>
<td>
<p>(<code>character</code>)<br /> the standard oncology code to be described.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Response labels.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_multinomial_rsp">estimate_multinomial_rsp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d_onco_rsp_label(
  c("CR", "PR", "SD", "NON CR/PD", "PD", "NE", "Missing", "&lt;Missing&gt;", "NE/Missing")
)

# Adding some values not considered in d_onco_rsp_label

d_onco_rsp_label(
  c("CR", "PR", "hello", "hi")
)

</code></pre>

<hr>
<h2 id='d_pkparam'>Generate PK reference dataset</h2><span id='topic+d_pkparam'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_pkparam()
</code></pre>


<h3>Value</h3>

<p><code>data.frame</code> of PK parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pk_reference_dataset &lt;- d_pkparam()

</code></pre>

<hr>
<h2 id='d_proportion'>Description of the Proportion Summary</h2><span id='topic+d_proportion'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is a helper function that describes the analysis in <code><a href="#topic+s_proportion">s_proportion()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_proportion(conf_level, method, long = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_proportion_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="d_proportion_+3A_method">method</code></td>
<td>
<p>(<code>string</code>)<br /> the method used to construct the confidence interval
for proportion of successful outcomes; one of <code>waldcc</code>, <code>wald</code>, <code>clopper-pearson</code>,
<code>wilson</code>, <code>wilsonc</code>, <code>strat_wilson</code>, <code>strat_wilsonc</code>, <code>agresti-coull</code> or <code>jeffreys</code>.</p>
</td></tr>
<tr><td><code id="d_proportion_+3A_long">long</code></td>
<td>
<p>(<code>flag</code>)<br /> whether a long or a short (default) description is required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String describing the analysis.
</p>

<hr>
<h2 id='d_proportion_diff'>Description of Method Used for Proportion Comparison</h2><span id='topic+d_proportion_diff'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is an auxiliary function that describes the analysis in
<code>s_proportion_diff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_proportion_diff(conf_level, method, long = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_proportion_diff_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="d_proportion_diff_+3A_method">method</code></td>
<td>
<p>(<code>string</code>)<br /> the method used for the confidence interval estimation.</p>
</td></tr>
<tr><td><code id="d_proportion_diff_+3A_long">long</code></td>
<td>
<p>(<code>logical</code>)<br /> Whether a long or a short (default) description is required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>string</code> describing the analysis.
</p>


<h3>See Also</h3>

<p><a href="#topic+prop_diff">prop_diff</a>
</p>

<hr>
<h2 id='d_rsp_subgroups_colvars'>Labels for Column Variables in Binary Response by Subgroup Table</h2><span id='topic+d_rsp_subgroups_colvars'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Internal function to check variables included in <code><a href="#topic+tabulate_rsp_subgroups">tabulate_rsp_subgroups()</a></code> and create column labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_rsp_subgroups_colvars(vars, conf_level = NULL, method = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_rsp_subgroups_colvars_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="d_rsp_subgroups_colvars_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="d_rsp_subgroups_colvars_+3A_method">method</code></td>
<td>
<p>(<code>string</code>)<br /> specifies the test used to calculate the p-value for the difference between
two proportions. For options, see <code><a href="#topic+s_test_proportion_diff">s_test_proportion_diff()</a></code>. Default is <code>NULL</code> so no test is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of variables to tabulate and their labels.
</p>

<hr>
<h2 id='d_survival_subgroups_colvars'>Labels for Column Variables in Survival Duration by Subgroup Table</h2><span id='topic+d_survival_subgroups_colvars'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Internal function to check variables included in <code><a href="#topic+tabulate_survival_subgroups">tabulate_survival_subgroups()</a></code> and create column labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_survival_subgroups_colvars(vars, conf_level, method, time_unit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_survival_subgroups_colvars_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> the name of statistics to be reported among:
</p>

<ul>
<li> <p><code>n_tot_events</code>: Total number of events per group.
</p>
</li>
<li> <p><code>n_events</code>: Number of events per group.
</p>
</li>
<li> <p><code>n_tot</code>: Total number of observations per group.
</p>
</li>
<li> <p><code>n</code>: Number of observations per group.
</p>
</li>
<li> <p><code>median</code>: Median survival time.
</p>
</li>
<li> <p><code>hr</code>: Hazard ratio.
</p>
</li>
<li> <p><code>ci</code>: Confidence interval of hazard ratio.
</p>
</li>
<li> <p><code>pval</code>: p-value of the effect.
Note, one of the statistics <code>n_tot</code> and <code>n_tot_events</code>, as well as both <code>hr</code> and <code>ci</code>
are required.
</p>
</li></ul>
</td></tr>
<tr><td><code id="d_survival_subgroups_colvars_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="d_survival_subgroups_colvars_+3A_method">method</code></td>
<td>
<p>(<code>character</code>)<br /> p-value method for testing hazard ratio = 1.</p>
</td></tr>
<tr><td><code id="d_survival_subgroups_colvars_+3A_time_unit">time_unit</code></td>
<td>
<p>(<code>string</code>)<br /> label with unit of median survival time. Default <code>NULL</code> skips displaying unit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of variables and their labels to tabulate.
</p>


<h3>Note</h3>

<p>At least one of <code>n_tot</code> and <code>n_tot_events</code> must be provided in <code>vars</code>.
</p>

<hr>
<h2 id='d_test_proportion_diff'>Description of the Difference Test Between Two Proportions</h2><span id='topic+d_test_proportion_diff'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is an auxiliary function that describes the analysis in <code>s_test_proportion_diff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_test_proportion_diff(method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d_test_proportion_diff_+3A_method">method</code></td>
<td>
<p>(<code>string</code>)<br /> one of <code>chisq</code>, <code>cmh</code>, <code>fisher</code>, or <code>schouten</code>; specifies the test used
to calculate the p-value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>string</code> describing the test from which the p-value is derived.
</p>

<hr>
<h2 id='day2month'>Conversion of Days to Months</h2><span id='topic+day2month'></span>

<h3>Description</h3>

<p>Conversion of Days to Months
</p>


<h3>Usage</h3>

<pre><code class='language-R'>day2month(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="day2month_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> time in days.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector with the time in months.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(403, 248, 30, 86)
day2month(x)

</code></pre>

<hr>
<h2 id='decorate_grob'>Add Titles, Footnotes, Page Number, and a Bounding Box to a Grid Grob</h2><span id='topic+decorate_grob'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This function is useful to label grid grobs (also <code>ggplot2</code>, and <code>lattice</code> plots)
with title, footnote, and page numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decorate_grob(
  grob,
  titles,
  footnotes,
  page = "",
  width_titles = grid::unit(1, "npc") - grid::unit(1.5, "cm"),
  width_footnotes = grid::unit(1, "npc") - grid::unit(1.5, "cm"),
  border = TRUE,
  margins = grid::unit(c(1, 0, 1, 0), "lines"),
  padding = grid::unit(rep(1, 4), "lines"),
  outer_margins = grid::unit(c(2, 1.5, 3, 1.5), "cm"),
  gp_titles = grid::gpar(),
  gp_footnotes = grid::gpar(fontsize = 8),
  name = NULL,
  gp = grid::gpar(),
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decorate_grob_+3A_grob">grob</code></td>
<td>
<p>a grid grob object, optionally <code>NULL</code> if only a <code>grob</code> with the decoration should be shown.</p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_titles">titles</code></td>
<td>
<p>vector of character strings. Vector elements are separated by a newline and strings are wrapped
according to the page width.</p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_footnotes">footnotes</code></td>
<td>
<p>vector of character string. Same rules as for <code>titles</code>.</p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_page">page</code></td>
<td>
<p>string with page numeration, if <code>NULL</code> then no page number is displayed.</p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_width_titles">width_titles</code></td>
<td>
<p>unit object</p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_width_footnotes">width_footnotes</code></td>
<td>
<p>unit object</p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_border">border</code></td>
<td>
<p>boolean, whether a a border should be drawn around the plot or not.</p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_margins">margins</code></td>
<td>
<p>unit object of length 4</p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_padding">padding</code></td>
<td>
<p>unit object of length 4</p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_outer_margins">outer_margins</code></td>
<td>
<p>unit object of length 4</p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_gp_titles">gp_titles</code></td>
<td>
<p>a <code>gpar</code> object</p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_gp_footnotes">gp_footnotes</code></td>
<td>
<p>a <code>gpar</code> object</p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_name">name</code></td>
<td>
<p>a character identifier for the grob.  Used to find the
grob on the display list and/or as a child of another grob. </p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_gp">gp</code></td>
<td>
<p>A <code>"gpar"</code> object, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="decorate_grob_+3A_vp">vp</code></td>
<td>
<p>a <code><a href="grid.html#topic+viewport">viewport</a></code> object (or <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The titles and footnotes will be ragged, i.e. each title will be wrapped individually.
</p>


<h3>Value</h3>

<p>A grid grob (<code>gTree</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(grid)

titles &lt;- c(
  "Edgar Anderson's Iris Data",
  paste(
    "This famous (Fisher's or Anderson's) iris data set gives the measurements",
    "in centimeters of the variables sepal length and width and petal length",
    "and width, respectively, for 50 flowers from each of 3 species of iris."
  )
)

footnotes &lt;- c(
  "The species are Iris setosa, versicolor, and virginica.",
  paste(
    "iris is a data frame with 150 cases (rows) and 5 variables (columns) named",
    "Sepal.Length, Sepal.Width, Petal.Length, Petal.Width, and Species."
  )
)

## empty plot
grid.newpage()

grid.draw(
  decorate_grob(
    NULL,
    titles = titles,
    footnotes = footnotes,
    page = "Page 4 of 10"
  )
)

# grid
p &lt;- gTree(
  children = gList(
    rectGrob(),
    xaxisGrob(),
    yaxisGrob(),
    textGrob("Sepal.Length", y = unit(-4, "lines")),
    textGrob("Petal.Length", x = unit(-3.5, "lines"), rot = 90),
    pointsGrob(iris$Sepal.Length, iris$Petal.Length, gp = gpar(col = iris$Species), pch = 16)
  ),
  vp = vpStack(plotViewport(), dataViewport(xData = iris$Sepal.Length, yData = iris$Petal.Length))
)
grid.newpage()
grid.draw(p)

grid.newpage()
grid.draw(
  decorate_grob(
    grob = p,
    titles = titles,
    footnotes = footnotes,
    page = "Page 6 of 129"
  )
)

## with ggplot2
library(ggplot2)

p_gg &lt;- ggplot2::ggplot(iris, aes(Sepal.Length, Sepal.Width, col = Species)) +
  ggplot2::geom_point()
p_gg
p &lt;- ggplotGrob(p_gg)
grid.newpage()
grid.draw(
  decorate_grob(
    grob = p,
    titles = titles,
    footnotes = footnotes,
    page = "Page 6 of 129"
  )
)

## with lattice
library(lattice)

xyplot(Sepal.Length ~ Petal.Length, data = iris, col = iris$Species)
p &lt;- grid.grab()
grid.newpage()
grid.draw(
  decorate_grob(
    grob = p,
    titles = titles,
    footnotes = footnotes,
    page = "Page 6 of 129"
  )
)

# with gridExtra - no borders
library(gridExtra)
grid.newpage()
grid.draw(
  decorate_grob(
    tableGrob(
      head(mtcars)
    ),
    titles = "title",
    footnotes = "footnote",
    border = FALSE
  )
)

</code></pre>

<hr>
<h2 id='decorate_grob_factory'>Update Page Number</h2><span id='topic+decorate_grob_factory'></span>

<h3>Description</h3>

<p>Automatically updates page number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decorate_grob_factory(npages, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decorate_grob_factory_+3A_npages">npages</code></td>
<td>
<p>number of pages in total</p>
</td></tr>
<tr><td><code id="decorate_grob_factory_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="#topic+decorate_grob">decorate_grob()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Closure that increments the page number.
</p>

<hr>
<h2 id='decorate_grob_set'>Decorate Set of <code>grobs</code> and Add Page Numbering</h2><span id='topic+decorate_grob_set'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Note that this uses the <code><a href="#topic+decorate_grob_factory">decorate_grob_factory()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decorate_grob_set(grobs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decorate_grob_set_+3A_grobs">grobs</code></td>
<td>
<p>a list of grid grobs</p>
</td></tr>
<tr><td><code id="decorate_grob_set_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code><a href="#topic+decorate_grob">decorate_grob()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A decorated grob.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(grid)
g &lt;- with(data = iris, {
  list(
    ggplot2::ggplotGrob(
      ggplot2::ggplot(mapping = aes(Sepal.Length, Sepal.Width, col = Species)) +
        ggplot2::geom_point()
    ),
    ggplot2::ggplotGrob(
      ggplot2::ggplot(mapping = aes(Sepal.Length, Petal.Length, col = Species)) +
        ggplot2::geom_point()
    ),
    ggplot2::ggplotGrob(
      ggplot2::ggplot(mapping = aes(Sepal.Length, Petal.Width, col = Species)) +
        ggplot2::geom_point()
    ),
    ggplot2::ggplotGrob(
      ggplot2::ggplot(mapping = aes(Sepal.Width, Petal.Length, col = Species)) +
        ggplot2::geom_point()
    ),
    ggplot2::ggplotGrob(
      ggplot2::ggplot(mapping = aes(Sepal.Width, Petal.Width, col = Species)) +
        ggplot2::geom_point()
    ),
    ggplot2::ggplotGrob(
      ggplot2::ggplot(mapping = aes(Petal.Length, Petal.Width, col = Species)) +
        ggplot2::geom_point()
    )
  )
})
lg &lt;- decorate_grob_set(grobs = g, titles = "Hello\nOne\nTwo\nThree", footnotes = "")

draw_grob(lg[[1]])
draw_grob(lg[[2]])
draw_grob(lg[[6]])

</code></pre>

<hr>
<h2 id='default_na_str'>Default string replacement for <code>NA</code> values</h2><span id='topic+default_na_str'></span><span id='topic+set_default_na_str'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The default string used to represent <code>NA</code> values. This value is used as the default
value for the <code>na_str</code> argument throughout the <code>tern</code> package, and printed in place
of <code>NA</code> values in output tables. If not specified for each <code>tern</code> function by the user
via the <code>na_str</code> argument, or in the R environment options via <code><a href="#topic+set_default_na_str">set_default_na_str()</a></code>,
then <code>NA</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_na_str()

set_default_na_str(na_str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_na_str_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> Single string value to set in the R environment options as
the default value to replace <code>NA</code>s. Use <code>getOption("tern_default_na_str")</code> to check the
current value set in the R environment (defaults to <code>NULL</code> if not set).</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>default_na_str</code> returns the current value if an R environment option has been set
for <code>"tern_default_na_str"</code>, or <code>NA_character_</code> otherwise.
</p>
</li></ul>


<ul>
<li> <p><code>set_default_na_str</code> has no return value.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>default_na_str()</code>: Getter for default <code>NA</code> value replacement string.
</p>
</li>
<li> <p><code>set_default_na_str()</code>: Setter for default <code>NA</code> value replacement string. Sets the
option <code>"tern_default_na_str"</code> within the R environment.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Default settings
default_na_str()
getOption("tern_default_na_str")

# Set custom value
set_default_na_str("&lt;Missing&gt;")

# Settings after value has been set
default_na_str()
getOption("tern_default_na_str")

</code></pre>

<hr>
<h2 id='default_stats_formats_labels'>Get default statistical methods and their associated formats, labels, and indent modifiers</h2><span id='topic+default_stats_formats_labels'></span><span id='topic+get_stats'></span><span id='topic+get_formats_from_stats'></span><span id='topic+get_labels_from_stats'></span><span id='topic+get_indents_from_stats'></span><span id='topic+tern_default_stats'></span><span id='topic+tern_default_formats'></span><span id='topic+tern_default_labels'></span><span id='topic+summary_formats'></span><span id='topic+summary_labels'></span><span id='topic+summary_custom'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Utility functions to get valid statistic methods for different method groups
(<code>.stats</code>) and their associated formats (<code>.formats</code>), labels (<code>.labels</code>), and indent modifiers
(<code>.indent_mods</code>). This utility is used across <code>tern</code>, but some of its working principles can be
seen in <code><a href="#topic+analyze_vars">analyze_vars()</a></code>. See notes to understand why this is experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stats(
  method_groups = "analyze_vars_numeric",
  stats_in = NULL,
  add_pval = FALSE
)

get_formats_from_stats(stats, formats_in = NULL)

get_labels_from_stats(stats, labels_in = NULL, row_nms = NULL)

get_indents_from_stats(stats, indents_in = NULL, row_nms = NULL)

tern_default_stats

tern_default_formats

tern_default_labels

summary_formats(type = "numeric", include_pval = FALSE)

summary_labels(type = "numeric", include_pval = FALSE)

summary_custom(
  type = "numeric",
  include_pval = FALSE,
  stats_custom = NULL,
  formats_custom = NULL,
  labels_custom = NULL,
  indent_mods_custom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_stats_formats_labels_+3A_method_groups">method_groups</code></td>
<td>
<p>(<code>character</code>)<br /> indicates the statistical method group (<code>tern</code> analyze function)
to retrieve default statistics for. A character vector can be used to specify more than one statistical
method group.</p>
</td></tr>
<tr><td><code id="default_stats_formats_labels_+3A_stats_in">stats_in</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to retrieve for the selected method group.</p>
</td></tr>
<tr><td><code id="default_stats_formats_labels_+3A_add_pval">add_pval</code></td>
<td>
<p>(<code>flag</code>)<br /> should <code>"pval"</code> (or <code>"pval_counts"</code> if <code>method_groups</code> contains
<code>"analyze_vars_counts"</code>) be added to the statistical methods?</p>
</td></tr>
<tr><td><code id="default_stats_formats_labels_+3A_stats">stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistical methods to get defaults for.</p>
</td></tr>
<tr><td><code id="default_stats_formats_labels_+3A_formats_in">formats_in</code></td>
<td>
<p>(named <code>vector</code>) <br /> inserted formats to replace defaults. It can be a
character vector from <code><a href="formatters.html#topic+list_formats">formatters::list_valid_format_labels()</a></code> or a custom format function.</p>
</td></tr>
<tr><td><code id="default_stats_formats_labels_+3A_labels_in">labels_in</code></td>
<td>
<p>(named <code>vector</code> of <code>character</code>)<br /> inserted labels to replace defaults.</p>
</td></tr>
<tr><td><code id="default_stats_formats_labels_+3A_row_nms">row_nms</code></td>
<td>
<p>(<code>character</code>)<br /> row names. Levels of a <code>factor</code> or <code>character</code> variable, each
of which the statistics in <code>.stats</code> will be calculated for. If this parameter is set, these
variable levels will be used as the defaults, and the names of the given custom values should
correspond to levels (or have format <code>statistic.level</code>) instead of statistics. Can also be
variable names if rows correspond to different variables instead of levels. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="default_stats_formats_labels_+3A_indents_in">indents_in</code></td>
<td>
<p>(named <code>vector</code>)<br /> inserted indent modifiers to replace defaults (default is <code>0L</code>).</p>
</td></tr>
<tr><td><code id="default_stats_formats_labels_+3A_type">type</code></td>
<td>
<p>(<code>flag</code>)<br /> is it going to be <code>"numeric"</code> or <code>"counts"</code>?</p>
</td></tr>
<tr><td><code id="default_stats_formats_labels_+3A_include_pval">include_pval</code></td>
<td>
<p>(<code>flag</code>)<br /> deprecated parameter. Same as <code>add_pval</code>.</p>
</td></tr>
<tr><td><code id="default_stats_formats_labels_+3A_stats_custom">stats_custom</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;named vector&#8288;</code> of <code>character</code>)<br /> vector of statistics to include if
not the defaults. This argument overrides <code>include_pval</code> and other custom value arguments
such that only settings for these statistics will be returned.</p>
</td></tr>
<tr><td><code id="default_stats_formats_labels_+3A_formats_custom">formats_custom</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;named vector&#8288;</code> of <code>character</code>)<br /> vector of custom statistics formats
to use in place of the defaults defined in <code><a href="#topic+summary_formats">summary_formats()</a></code>. Names should be a subset
of the statistics defined in <code>stats_custom</code> (or default statistics if this is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="default_stats_formats_labels_+3A_labels_custom">labels_custom</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;named vector&#8288;</code> of <code>character</code>)<br /> vector of custom statistics labels
to use in place of the defaults defined in <code><a href="#topic+summary_labels">summary_labels()</a></code>. Names should be a subset
of the statistics defined in <code>stats_custom</code> (or default statistics if this is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="default_stats_formats_labels_+3A_indent_mods_custom">indent_mods_custom</code></td>
<td>
<p>(<code>integer</code> or <code style="white-space: pre;">&#8288;named vector&#8288;</code> of <code>integer</code>)<br /> vector of custom
indentation modifiers for statistics to use instead of the default of <code>0L</code> for all statistics.
Names should be a subset of the statistics defined in <code>stats_custom</code> (or default statistics
if this is <code>NULL</code>). Alternatively, the same indentation modifier can be applied to all
statistics by setting <code>indent_mods_custom</code> to a single integer value.</p>
</td></tr>
</table>


<h3>Format</h3>


<ul>
<li> <p><code>tern_default_stats</code> is a named list of available statistics, with each element
named for their corresponding statistical method group.
</p>
</li></ul>


<ul>
<li> <p><code>tern_default_formats</code> is a named vector of available default formats, with each element
named for their corresponding statistic.
</p>
</li></ul>


<ul>
<li> <p><code>tern_default_labels</code> is a named <code>character</code> vector of available default labels, with each element
named for their corresponding statistic.
</p>
</li></ul>



<h3>Details</h3>

<p>Current choices for <code>type</code> are <code>counts</code> and <code>numeric</code> for <code><a href="#topic+analyze_vars">analyze_vars()</a></code> and affect <code>get_stats()</code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>get_stats()</code> returns a <code>character</code> vector of statistical methods.
</p>
</li></ul>


<ul>
<li> <p><code>get_formats_from_stats()</code> returns a named vector of formats (if present in either
<code>tern_default_formats</code> or <code>formats_in</code>, otherwise <code>NULL</code>). Values can be taken from
<code><a href="formatters.html#topic+list_formats">formatters::list_valid_format_labels()</a></code> or a custom function (e.g. <a href="#topic+formatting_functions">formatting_functions</a>).
</p>
</li></ul>


<ul>
<li> <p><code>get_labels_from_stats()</code> returns a named <code>character</code> vector of labels (if present in either
<code>tern_default_labels</code> or <code>labels_in</code>, otherwise <code>NULL</code>).
</p>
</li></ul>


<ul>
<li> <p><code>get_indents_from_stats()</code> returns a single indent modifier value to apply to all rows
or a named numeric vector of indent modifiers (if present, otherwise <code>NULL</code>).
</p>
</li></ul>


<ul>
<li> <p><code>summary_formats()</code> returns a named <code>vector</code> of default statistic formats for the given data type.
</p>
</li></ul>


<ul>
<li> <p><code>summary_labels</code> returns a named <code>vector</code> of default statistic labels for the given data type.
</p>
</li></ul>


<ul>
<li> <p><code>summary_custom</code> returns a <code>list</code> of 4 named elements: <code>stats</code>, <code>formats</code>, <code>labels</code>,
and <code>indent_mods</code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>get_stats()</code>: Get statistics available for a given method
group (analyze function).
</p>
</li>
<li> <p><code>get_formats_from_stats()</code>: Get formats corresponding to a list of statistics.
</p>
</li>
<li> <p><code>get_labels_from_stats()</code>: Get labels corresponding to a list of statistics.
</p>
</li>
<li> <p><code>get_indents_from_stats()</code>: Format indent modifiers for a given vector/list of statistics.
</p>
</li>
<li> <p><code>tern_default_stats</code>: Named list of available statistics by method group for <code>tern</code>.
</p>
</li>
<li> <p><code>tern_default_formats</code>: Named vector of default formats for <code>tern</code>.
</p>
</li>
<li> <p><code>tern_default_labels</code>: Named <code>character</code> vector of default labels for <code>tern</code>.
</p>
</li>
<li> <p><code>summary_formats()</code>: Quick function to retrieve default formats for summary statistics:
<code><a href="#topic+analyze_vars">analyze_vars()</a></code> and <code><a href="#topic+analyze_vars_in_cols">analyze_vars_in_cols()</a></code> principally.
</p>
</li>
<li> <p><code>summary_labels()</code>: Quick function to retrieve default labels for summary statistics.
Returns labels of descriptive statistics which are understood by <code>rtables</code>. Similar to <code>summary_formats</code>
</p>
</li>
<li> <p><code>summary_custom()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Function to
configure settings for default or custom summary statistics for a given data type. In
addition to selecting a custom subset of statistics, the user can also set custom
formats, labels, and indent modifiers for any of these statistics.
</p>
</li></ul>


<h3>Note</h3>

<p>These defaults are experimental because we use the names of functions to retrieve the default
statistics. This should be generalized in groups of methods according to more reasonable groupings.
</p>
<p>Formats in <code>tern</code> and <code>rtables</code> can be functions that take in the table cell value and
return a string. This is well documented in <code>vignette("custom_appearance", package = "rtables")</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+formatting_functions">formatting_functions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># analyze_vars is numeric
num_stats &lt;- get_stats("analyze_vars_numeric") # also the default

# Other type
cnt_stats &lt;- get_stats("analyze_vars_counts")

# Weirdly taking the pval from count_occurrences
only_pval &lt;- get_stats("count_occurrences", add_pval = TRUE, stats_in = "pval")

# All count_occurrences
all_cnt_occ &lt;- get_stats("count_occurrences")

# Multiple
get_stats(c("count_occurrences", "analyze_vars_counts"))

# Defaults formats
get_formats_from_stats(num_stats)
get_formats_from_stats(cnt_stats)
get_formats_from_stats(only_pval)
get_formats_from_stats(all_cnt_occ)

# Addition of customs
get_formats_from_stats(all_cnt_occ, formats_in = c("fraction" = c("xx")))
get_formats_from_stats(all_cnt_occ, formats_in = list("fraction" = c("xx.xx", "xx")))

# Defaults labels
get_labels_from_stats(num_stats)
get_labels_from_stats(cnt_stats)
get_labels_from_stats(only_pval)
get_labels_from_stats(all_cnt_occ)

# Addition of customs
get_labels_from_stats(all_cnt_occ, labels_in = c("fraction" = "Fraction"))
get_labels_from_stats(all_cnt_occ, labels_in = list("fraction" = c("Some more fractions")))

get_indents_from_stats(all_cnt_occ, indents_in = 3L)
get_indents_from_stats(all_cnt_occ, indents_in = list(count = 2L, count_fraction = 5L))
get_indents_from_stats(
  all_cnt_occ,
  indents_in = list(a = 2L, count.a = 1L, count.b = 5L), row_nms = c("a", "b")
)

summary_formats()
summary_formats(type = "counts", include_pval = TRUE)

summary_labels()
summary_labels(type = "counts", include_pval = TRUE)

summary_custom()
summary_custom(type = "counts", include_pval = TRUE)
summary_custom(
  include_pval = TRUE, stats_custom = c("n", "mean", "sd", "pval"),
  labels_custom = c(sd = "Std. Dev."), indent_mods_custom = 3L
)

</code></pre>

<hr>
<h2 id='desctools_binom'>Confidence Intervals for a Difference of Binomials</h2><span id='topic+desctools_binom'></span><span id='topic+desctools_binomci'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Several confidence intervals for the difference between proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desctools_binom(
  x1,
  n1,
  x2,
  n2,
  conf.level = 0.95,
  sides = c("two.sided", "left", "right"),
  method = c("ac", "wald", "waldcc", "score", "scorecc", "mn", "mee", "blj", "ha", "hal",
    "jp")
)

desctools_binomci(
  x,
  n,
  conf.level = 0.95,
  sides = c("two.sided", "left", "right"),
  method = c("wilson", "wald", "waldcc", "agresti-coull", "jeffreys", "modified wilson",
    "wilsoncc", "modified jeffreys", "clopper-pearson", "arcsine", "logit", "witting",
    "pratt", "midp", "lik", "blaker"),
  rand = 123,
  tol = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desctools_binom_+3A_conf.level">conf.level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level, defaults to 0.95.</p>
</td></tr>
<tr><td><code id="desctools_binom_+3A_sides">sides</code></td>
<td>
<p>(<code>character</code>)<br /> side of the confidence interval to compute. Must be one of <code>"two-sided"</code> (default),
<code>"left"</code>, or <code>"right"</code>.</p>
</td></tr>
<tr><td><code id="desctools_binom_+3A_method">method</code></td>
<td>
<p>(<code>character</code>)<br /> method to use. Can be one out of: <code>"wald"</code>, <code>"wilson"</code>, <code>"wilsoncc"</code>,
<code>"agresti-coull"</code>, <code>"jeffreys"</code>, <code>"modified wilson"</code>, <code>"modified jeffreys"</code>, <code>"clopper-pearson"</code>, <code>"arcsine"</code>,
<code>"logit"</code>, <code>"witting"</code>, <code>"pratt"</code>, <code>"midp"</code>, <code>"lik"</code>, and <code>"blaker"</code>.</p>
</td></tr>
<tr><td><code id="desctools_binom_+3A_x">x</code></td>
<td>
<p>(<code>count</code>)<br /> number of successes</p>
</td></tr>
<tr><td><code id="desctools_binom_+3A_n">n</code></td>
<td>
<p>(<code>count</code>)<br /> number of trials</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of 3 values:
</p>

<ul>
<li> <p><code>est</code>: estimate of proportion difference.
</p>
</li>
<li> <p><code>lwr.ci</code>: estimate of lower end of the confidence interval.
</p>
</li>
<li> <p><code>upr.ci</code>: estimate of upper end of the confidence interval.
</p>
</li></ul>

<p>A <code>matrix</code> with 3 columns containing:
</p>

<ul>
<li> <p><code>est</code>: estimate of proportion difference.
</p>
</li>
<li> <p><code>lwr.ci</code>: lower end of the confidence interval.
</p>
</li>
<li> <p><code>upr.ci</code>: upper end of the confidence interval.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>desctools_binom()</code>: Several confidence intervals for the difference between proportions.
</p>
</li>
<li> <p><code>desctools_binomci()</code>: Compute confidence intervals for binomial proportions.
</p>
</li></ul>

<hr>
<h2 id='df_explicit_na'>Encode Categorical Missing Values in a Data Frame</h2><span id='topic+df_explicit_na'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is a helper function to encode missing entries across groups of categorical
variables in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_explicit_na(
  data,
  omit_columns = NULL,
  char_as_factor = TRUE,
  logical_as_factor = FALSE,
  na_level = "&lt;Missing&gt;"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_explicit_na_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set.</p>
</td></tr>
<tr><td><code id="df_explicit_na_+3A_omit_columns">omit_columns</code></td>
<td>
<p>(<code>character</code>)<br /> names of variables from <code>data</code> that should
not be modified by this function.</p>
</td></tr>
<tr><td><code id="df_explicit_na_+3A_char_as_factor">char_as_factor</code></td>
<td>
<p>(<code>flag</code>)<br /> whether to convert character variables
in <code>data</code> to factors.</p>
</td></tr>
<tr><td><code id="df_explicit_na_+3A_logical_as_factor">logical_as_factor</code></td>
<td>
<p>(<code>flag</code>)<br /> whether to convert logical variables
in <code>data</code> to factors.</p>
</td></tr>
<tr><td><code id="df_explicit_na_+3A_na_level">na_level</code></td>
<td>
<p>(<code>string</code>)<br /> used to replace all <code>NA</code> or empty
values inside non-<code>omit_columns</code> columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing entries are those with <code>NA</code> or empty strings and will
be replaced with a specified value. If factor variables include missing
values, the missing value will be inserted as the last level.
Similarly, in case character or logical variables should be converted to factors
with the <code>char_as_factor</code> or <code>logical_as_factor</code> options, the missing values will
be set as the last level.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the chosen modifications applied.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sas_na">sas_na()</a></code> and <code><a href="#topic+explicit_na">explicit_na()</a></code> for other missing data helper functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_data &lt;- data.frame(
  u = c(TRUE, FALSE, NA, TRUE),
  v = factor(c("A", NA, NA, NA), levels = c("Z", "A")),
  w = c("A", "B", NA, "C"),
  x = c("D", "E", "F", NA),
  y = c("G", "H", "I", ""),
  z = c(1, 2, 3, 4),
  stringsAsFactors = FALSE
)

# Example 1
# Encode missing values in all character or factor columns.
df_explicit_na(my_data)
# Also convert logical columns to factor columns.
df_explicit_na(my_data, logical_as_factor = TRUE)
# Encode missing values in a subset of columns.
df_explicit_na(my_data, omit_columns = c("x", "y"))

# Example 2
# Here we purposefully convert all `M` values to `NA` in the `SEX` variable.
# After running `df_explicit_na` the `NA` values are encoded as `&lt;Missing&gt;` but they are not
# included when generating `rtables`.
adsl &lt;- tern_ex_adsl
adsl$SEX[adsl$SEX == "M"] &lt;- NA
adsl &lt;- df_explicit_na(adsl)

# If you want the `Na` values to be displayed in the table use the `na_level` argument.
adsl &lt;- tern_ex_adsl
adsl$SEX[adsl$SEX == "M"] &lt;- NA
adsl &lt;- df_explicit_na(adsl, na_level = "Missing Values")

# Example 3
# Numeric variables that have missing values are not altered. This means that any `NA` value in
# a numeric variable will not be included in the summary statistics, nor will they be included
# in the denominator value for calculating the percent values.
adsl &lt;- tern_ex_adsl
adsl$AGE[adsl$AGE &lt; 30] &lt;- NA
adsl &lt;- df_explicit_na(adsl)

</code></pre>

<hr>
<h2 id='draw_grob'>Draw <code>grob</code></h2><span id='topic+draw_grob'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Draw grob on device page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_grob(grob, newpage = TRUE, vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_grob_+3A_grob">grob</code></td>
<td>
<p>grid object</p>
</td></tr>
<tr><td><code id="draw_grob_+3A_newpage">newpage</code></td>
<td>
<p>draw on a new page</p>
</td></tr>
<tr><td><code id="draw_grob_+3A_vp">vp</code></td>
<td>
<p>a <code><a href="grid.html#topic+viewport">viewport()</a></code> object (or <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>grob</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(grid)


rect &lt;- rectGrob(width = grid::unit(0.5, "npc"), height = grid::unit(0.5, "npc"))
rect %&gt;% draw_grob(vp = grid::viewport(angle = 45))

num &lt;- lapply(1:10, textGrob)
num %&gt;%
  arrange_grobs(grobs = .) %&gt;%
  draw_grob()
showViewport()


</code></pre>

<hr>
<h2 id='empty_vector_if_na'>Return an empty numeric if all elements are <code>NA</code>.</h2><span id='topic+empty_vector_if_na'></span>

<h3>Description</h3>

<p>Return an empty numeric if all elements are <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty_vector_if_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empty_vector_if_na_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empty <code>numeric</code> if all elements of <code>x</code> are <code>NA</code>, otherwise <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(NA, NA, NA)
# Internal function - empty_vector_if_na
</code></pre>

<hr>
<h2 id='estimate_coef'>Hazard Ratio Estimation in Interactions</h2><span id='topic+estimate_coef'></span>

<h3>Description</h3>

<p>This function estimates the hazard ratios between arms when an interaction variable is given with
specific values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_coef(
  variable,
  given,
  lvl_var,
  lvl_given,
  coef,
  mmat,
  vcov,
  conf_level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_coef_+3A_variable">variable</code>, <code id="estimate_coef_+3A_given">given</code></td>
<td>
<p>Names of two variable in interaction. We seek the estimation of the levels of <code>variable</code>
given the levels of <code>given</code>.</p>
</td></tr>
<tr><td><code id="estimate_coef_+3A_lvl_var">lvl_var</code>, <code id="estimate_coef_+3A_lvl_given">lvl_given</code></td>
<td>
<p>corresponding levels has given by <code>levels</code>.</p>
</td></tr>
<tr><td><code id="estimate_coef_+3A_coef">coef</code></td>
<td>
<p>Numeric of estimated coefficients.</p>
</td></tr>
<tr><td><code id="estimate_coef_+3A_mmat">mmat</code></td>
<td>
<p>A name numeric filled with 0 used as template to obtain the design matrix.</p>
</td></tr>
<tr><td><code id="estimate_coef_+3A_vcov">vcov</code></td>
<td>
<p>Variance-covariance matrix of underlying model.</p>
</td></tr>
<tr><td><code id="estimate_coef_+3A_conf_level">conf_level</code></td>
<td>
<p>Single numeric for the confidence level of estimate intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the cox regression investigating the effect of Arm (A, B, C; reference A)
and Sex (F, M; reference Female). The model is abbreviated: y ~ Arm + Sex + Arm x Sex.
The cox regression estimates the coefficients along with a variance-covariance matrix for:
</p>

<ul>
<li><p> b1 (arm b), b2 (arm c)
</p>
</li>
<li><p> b3 (sex m)
</p>
</li>
<li><p> b4 (arm b: sex m), b5 (arm c: sex m)
</p>
</li></ul>

<p>Given that I want an estimation of the Hazard Ratio for arm C/sex M, the estimation
will be given in reference to arm A/Sex M by exp(b2 + b3 + b5)/ exp(b3) = exp(b2 + b5),
therefore the interaction coefficient is given by b2 + b5 while the standard error is obtained
as $1.96 * sqrt(Var b2 + Var b5 + 2 * covariance (b2,b5))$ for a confidence level of 0.95.
</p>


<h3>Value</h3>

<p>A list of matrix (one per level of variable) with rows corresponding to the combinations of
<code>variable</code> and <code>given</code>, with columns:
</p>

<ul>
<li> <p><code>coef_hat</code>: Estimation of the coefficient.
</p>
</li>
<li> <p><code>coef_se</code>: Standard error of the estimation.
</p>
</li>
<li> <p><code>hr</code>: Hazard ratio.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;lcl, ucl&#8288;</code>: Lower/upper confidence limit of the hazard ratio.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+s_cox_multivariate">s_cox_multivariate()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(survival)

ADSL &lt;- tern_ex_adsl %&gt;%
  filter(SEX %in% c("F", "M"))

adtte &lt;- tern_ex_adtte %&gt;% filter(PARAMCD == "PFS")
adtte$ARMCD &lt;- droplevels(adtte$ARMCD)
adtte$SEX &lt;- droplevels(adtte$SEX)

mod &lt;- coxph(
  formula = Surv(time = AVAL, event = 1 - CNSR) ~ (SEX + ARMCD)^2,
  data = adtte
)

mmat &lt;- stats::model.matrix(mod)[1, ]
mmat[!mmat == 0] &lt;- 0

</code></pre>

<hr>
<h2 id='estimate_multinomial_rsp'>Estimation of Proportions per Level of Factor</h2><span id='topic+estimate_multinomial_rsp'></span><span id='topic+estimate_multinomial_response'></span><span id='topic+s_length_proportion'></span><span id='topic+a_length_proportion'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Estimate the proportion along with confidence interval of a proportion
regarding the level of a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_multinomial_response(
  lyt,
  var,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  show_labels = "hidden",
  table_names = var,
  .stats = "prop_ci",
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_length_proportion(x, .N_col, ...)

a_length_proportion(x, .N_col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_multinomial_rsp_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="estimate_multinomial_rsp_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="estimate_multinomial_rsp_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="estimate_multinomial_rsp_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="estimate_multinomial_rsp_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="estimate_multinomial_rsp_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="estimate_multinomial_rsp_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="estimate_multinomial_rsp_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("estimate_multinomial_response")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="estimate_multinomial_rsp_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="estimate_multinomial_rsp_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="estimate_multinomial_rsp_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="estimate_multinomial_rsp_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector of numbers we want to analyze.</p>
</td></tr>
<tr><td><code id="estimate_multinomial_rsp_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>estimate_multinomial_response()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_length_proportion()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_length_proportion()</code> returns statistics from <code><a href="#topic+s_proportion">s_proportion()</a></code>.
</p>
</li></ul>


<ul>
<li> <p><code>a_length_proportion()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>estimate_multinomial_response()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code> and
<code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>
</li>
<li> <p><code>s_length_proportion()</code>: Statistics function which feeds the length of <code>x</code> as number
of successes, and <code>.N_col</code> as total number of successes and failures into <code><a href="#topic+s_proportion">s_proportion()</a></code>.
</p>
</li>
<li> <p><code>a_length_proportion()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>estimate_multinomial_response()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p>Relevant description function <code><a href="#topic+d_onco_rsp_label">d_onco_rsp_label()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Use of the layout creating function.
dta_test &lt;- data.frame(
  USUBJID = paste0("S", 1:12),
  ARM     = factor(rep(LETTERS[1:3], each = 4)),
  AVAL    = c(A = c(1, 1, 1, 1), B = c(0, 0, 1, 1), C = c(0, 0, 0, 0))
) %&gt;% mutate(
  AVALC = factor(AVAL,
    levels = c(0, 1),
    labels = c("Complete Response (CR)", "Partial Response (PR)")
  )
)

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  estimate_multinomial_response(var = "AVALC")

tbl &lt;- build_table(lyt, dta_test)

tbl

s_length_proportion(rep("CR", 10), .N_col = 100)
s_length_proportion(factor(character(0)), .N_col = 100)

a_length_proportion(rep("CR", 10), .N_col = 100)
a_length_proportion(factor(character(0)), .N_col = 100)

</code></pre>

<hr>
<h2 id='estimate_proportions'>Estimation of Proportions</h2><span id='topic+estimate_proportions'></span><span id='topic+estimate_proportion'></span><span id='topic+s_proportion'></span><span id='topic+a_proportion'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Estimate the proportion of responders within a studied population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_proportion(
  lyt,
  vars,
  conf_level = 0.95,
  method = c("waldcc", "wald", "clopper-pearson", "wilson", "wilsonc", "strat_wilson",
    "strat_wilsonc", "agresti-coull", "jeffreys"),
  weights = NULL,
  max_iterations = 50,
  variables = list(strata = NULL),
  long = FALSE,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  show_labels = "hidden",
  table_names = vars,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_proportion(
  df,
  .var,
  conf_level = 0.95,
  method = c("waldcc", "wald", "clopper-pearson", "wilson", "wilsonc", "strat_wilson",
    "strat_wilsonc", "agresti-coull", "jeffreys"),
  weights = NULL,
  max_iterations = 50,
  variables = list(strata = NULL),
  long = FALSE
)

a_proportion(
  df,
  .var,
  conf_level = 0.95,
  method = c("waldcc", "wald", "clopper-pearson", "wilson", "wilsonc", "strat_wilson",
    "strat_wilsonc", "agresti-coull", "jeffreys"),
  weights = NULL,
  max_iterations = 50,
  variables = list(strata = NULL),
  long = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_proportions_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_method">method</code></td>
<td>
<p>(<code>string</code>)<br /> the method used to construct the confidence interval
for proportion of successful outcomes; one of <code>waldcc</code>, <code>wald</code>, <code>clopper-pearson</code>,
<code>wilson</code>, <code>wilsonc</code>, <code>strat_wilson</code>, <code>strat_wilsonc</code>, <code>agresti-coull</code> or <code>jeffreys</code>.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_weights">weights</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br /> weights for each level of the strata. If <code>NULL</code>, they are
estimated using the iterative algorithm proposed in Yan and Su (2010) that
minimizes the weighted squared length of the confidence interval.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_max_iterations">max_iterations</code></td>
<td>
<p>(<code>count</code>)<br /> maximum number of iterations for the iterative procedure used
to find estimates of optimal weights.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_long">long</code></td>
<td>
<p>(<code>flag</code>)<br /> a long description is required.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("estimate_proportion")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_df">df</code></td>
<td>
<p>(<code>logical</code> or <code>data.frame</code>)<br /> if only a logical vector is used,
it indicates whether each subject is a responder or not. <code>TRUE</code> represents
a successful outcome. If a <code>data.frame</code> is provided, also the <code>strata</code> variable
names must be provided in <code>variables</code> as a list element with the strata strings.
In the case of <code>data.frame</code>, the logical vector of responses must be indicated as a
variable name in <code>.var</code>.</p>
</td></tr>
<tr><td><code id="estimate_proportions_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>estimate_proportion()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_proportion()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_proportion()</code> returns statistics <code>n_prop</code> (<code>n</code> and proportion) and <code>prop_ci</code> (proportion CI) for a
given variable.
</p>
</li></ul>


<ul>
<li> <p><code>a_proportion()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>estimate_proportion()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_proportion()</code>: Statistics function estimating a
proportion along with its confidence interval.
</p>
</li>
<li> <p><code>a_proportion()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>estimate_proportion()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+h_proportions">h_proportions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dta_test &lt;- data.frame(
  USUBJID = paste0("S", 1:12),
  ARM     = rep(LETTERS[1:3], each = 4),
  AVAL    = c(A = c(1, 1, 1, 1), B = c(0, 0, 1, 1), C = c(0, 0, 0, 0))
)

basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  estimate_proportion(vars = "AVAL") %&gt;%
  build_table(df = dta_test)

# Case with only logical vector.
rsp_v &lt;- c(1, 0, 1, 0, 1, 1, 0, 0)
s_proportion(rsp_v)

# Example for Stratified Wilson CI
nex &lt;- 100 # Number of example rows
dta &lt;- data.frame(
  "rsp" = sample(c(TRUE, FALSE), nex, TRUE),
  "grp" = sample(c("A", "B"), nex, TRUE),
  "f1" = sample(c("a1", "a2"), nex, TRUE),
  "f2" = sample(c("x", "y", "z"), nex, TRUE),
  stringsAsFactors = TRUE
)

s_proportion(
  df = dta,
  .var = "rsp",
  variables = list(strata = c("f1", "f2")),
  conf_level = 0.90,
  method = "strat_wilson"
)

</code></pre>

<hr>
<h2 id='ex_data'>Simulated <code>CDISC</code> Data for Examples</h2><span id='topic+ex_data'></span><span id='topic+tern_ex_adsl'></span><span id='topic+tern_ex_adae'></span><span id='topic+tern_ex_adlb'></span><span id='topic+tern_ex_adpp'></span><span id='topic+tern_ex_adrs'></span><span id='topic+tern_ex_adtte'></span>

<h3>Description</h3>

<p>Simulated <code>CDISC</code> Data for Examples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tern_ex_adsl

tern_ex_adae

tern_ex_adlb

tern_ex_adpp

tern_ex_adrs

tern_ex_adtte
</code></pre>


<h3>Format</h3>

<p><code>rds</code> (data.frame)
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 200 rows and 21 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 541 rows and 42 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 4200 rows and 50 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 522 rows and 25 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 1600 rows and 29 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 1000 rows and 28 columns.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>tern_ex_adsl</code>: <code>ADSL</code> data
</p>
</li>
<li> <p><code>tern_ex_adae</code>: <code>ADAE</code> data
</p>
</li>
<li> <p><code>tern_ex_adlb</code>: <code>ADLB</code> data
</p>
</li>
<li> <p><code>tern_ex_adpp</code>: <code>ADPP</code> data
</p>
</li>
<li> <p><code>tern_ex_adrs</code>: <code>ADRS</code> data
</p>
</li>
<li> <p><code>tern_ex_adtte</code>: <code>ADTTE</code> data
</p>
</li></ul>

<hr>
<h2 id='explicit_na'>Missing Data</h2><span id='topic+explicit_na'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Substitute missing data with a string or factor level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explicit_na(x, label = "&lt;Missing&gt;")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explicit_na_+3A_x">x</code></td>
<td>
<p>(<code>factor</code> or <code>character</code> vector)<br /> values for which any missing values should be substituted.</p>
</td></tr>
<tr><td><code id="explicit_na_+3A_label">label</code></td>
<td>
<p>(<code>character</code>)<br /> string that missing data should be replaced with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with any <code>NA</code> values substituted by <code>label</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>explicit_na(c(NA, "a", "b"))
is.na(explicit_na(c(NA, "a", "b")))

explicit_na(factor(c(NA, "a", "b")))
is.na(explicit_na(factor(c(NA, "a", "b"))))

explicit_na(sas_na(c("a", "")))

</code></pre>

<hr>
<h2 id='extract_by_name'>Extract Elements by Name</h2><span id='topic+extract_by_name'></span>

<h3>Description</h3>

<p>This utility function extracts elements from a vector <code>x</code> by <code>names</code>.
Differences to the standard <code>[</code> function are:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_by_name(x, names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_by_name_+3A_x">x</code></td>
<td>
<p>(named <code>vector</code>)<br /> where to extract named elements from.</p>
</td></tr>
<tr><td><code id="extract_by_name_+3A_names">names</code></td>
<td>
<p>(<code>character</code>)<br /> vector of names to extract.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If <code>x</code> is <code>NULL</code>, then still always <code>NULL</code> is returned (same as in base function).
</p>
</li>
<li><p> If <code>x</code> is not <code>NULL</code>, then the intersection of its names is made with <code>names</code> and those
elements are returned. That is, <code>names</code> which don't appear in <code>x</code> are not returned as <code>NA</code>s.
</p>
</li></ul>



<h3>Value</h3>

<p><code>NULL</code> if <code>x</code> is <code>NULL</code>, otherwise the extracted elements from <code>x</code>.
</p>

<hr>
<h2 id='extract_rsp_biomarkers'>Prepares Response Data Estimates for Multiple Biomarkers in a Single Data Frame</h2><span id='topic+extract_rsp_biomarkers'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Prepares estimates for number of responses, patients and overall response rate,
as well as odds ratio estimates, confidence intervals and p-values,
for multiple biomarkers across population subgroups in a single data frame.
<code>variables</code> corresponds to the names of variables found in <code>data</code>, passed as a
named list and requires elements <code>rsp</code> and <code>biomarkers</code> (vector of continuous
biomarker variables) and optionally <code>covariates</code>, <code>subgroups</code> and <code>strat</code>.
<code>groups_lists</code> optionally specifies groupings for <code>subgroups</code> variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_rsp_biomarkers(
  variables,
  data,
  groups_lists = list(),
  control = control_logistic(),
  label_all = "All Patients"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_rsp_biomarkers_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="extract_rsp_biomarkers_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to summarize.</p>
</td></tr>
<tr><td><code id="extract_rsp_biomarkers_+3A_groups_lists">groups_lists</code></td>
<td>
<p>(named <code>list</code> of <code>list</code>)<br /> optionally contains for each <code>subgroups</code> variable a
list, which specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
<tr><td><code id="extract_rsp_biomarkers_+3A_control">control</code></td>
<td>
<p>(named <code>list</code>)<br /> controls for the response definition and the
confidence level produced by <code><a href="#topic+control_logistic">control_logistic()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_rsp_biomarkers_+3A_label_all">label_all</code></td>
<td>
<p>(<code>string</code>)<br /> label for the total population analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns <code>biomarker</code>, <code>biomarker_label</code>, <code>n_tot</code>, <code>n_rsp</code>,
<code>prop</code>, <code>or</code>, <code>lcl</code>, <code>ucl</code>, <code>conf_level</code>, <code>pval</code>, <code>pval_label</code>, <code>subgroup</code>, <code>var</code>,
<code>var_label</code>, and <code>row_type</code>.
</p>


<h3>Note</h3>

<p>You can also specify a continuous variable in <code>rsp</code> and then use the
<code>response_definition</code> control to convert that internally to a logical
variable reflecting binary response.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+h_logistic_mult_cont_df">h_logistic_mult_cont_df()</a></code> which is used internally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(forcats)

adrs &lt;- tern_ex_adrs
adrs_labels &lt;- formatters::var_labels(adrs)

adrs_f &lt;- adrs %&gt;%
  filter(PARAMCD == "BESRSPI") %&gt;%
  mutate(rsp = AVALC == "CR")

# Typical analysis of two continuous biomarkers `BMRKR1` and `AGE`,
# in logistic regression models with one covariate `RACE`. The subgroups
# are defined by the levels of `BMRKR2`.
df &lt;- extract_rsp_biomarkers(
  variables = list(
    rsp = "rsp",
    biomarkers = c("BMRKR1", "AGE"),
    covariates = "SEX",
    subgroups = "BMRKR2"
  ),
  data = adrs_f
)
df

# Here we group the levels of `BMRKR2` manually, and we add a stratification
# variable `STRATA1`. We also here use a continuous variable `EOSDY`
# which is then binarized internally (response is defined as this variable
# being larger than 500).
df_grouped &lt;- extract_rsp_biomarkers(
  variables = list(
    rsp = "EOSDY",
    biomarkers = c("BMRKR1", "AGE"),
    covariates = "SEX",
    subgroups = "BMRKR2",
    strat = "STRATA1"
  ),
  data = adrs_f,
  groups_lists = list(
    BMRKR2 = list(
      "low" = "LOW",
      "low/medium" = c("LOW", "MEDIUM"),
      "low/medium/high" = c("LOW", "MEDIUM", "HIGH")
    )
  ),
  control = control_logistic(
    response_definition = "I(response &gt; 500)"
  )
)
df_grouped

</code></pre>

<hr>
<h2 id='extract_rsp_subgroups'>Prepares Response Data for Population Subgroups in Data Frames</h2><span id='topic+extract_rsp_subgroups'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Prepares response rates and odds ratios for population subgroups in data frames. Simple wrapper
for <code><a href="#topic+h_odds_ratio_subgroups_df">h_odds_ratio_subgroups_df()</a></code> and <code><a href="#topic+h_proportion_subgroups_df">h_proportion_subgroups_df()</a></code>. Result is a list of two
<code>data.frames</code>: <code>prop</code> and <code>or</code>. <code>variables</code> corresponds to the names of variables found in <code>data</code>,
passed as a named <code>list</code> and requires elements <code>rsp</code>, <code>arm</code> and optionally <code>subgroups</code> and <code>strat</code>.
<code>groups_lists</code> optionally specifies groupings for <code>subgroups</code> variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_rsp_subgroups(
  variables,
  data,
  groups_lists = list(),
  conf_level = 0.95,
  method = NULL,
  label_all = "All Patients"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_rsp_subgroups_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="extract_rsp_subgroups_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to summarize.</p>
</td></tr>
<tr><td><code id="extract_rsp_subgroups_+3A_groups_lists">groups_lists</code></td>
<td>
<p>(named <code>list</code> of <code>list</code>)<br /> optionally contains for each <code>subgroups</code> variable a
list, which specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
<tr><td><code id="extract_rsp_subgroups_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="extract_rsp_subgroups_+3A_method">method</code></td>
<td>
<p>(<code>string</code>)<br /> specifies the test used to calculate the p-value for the difference between
two proportions. For options, see <code><a href="#topic+s_test_proportion_diff">s_test_proportion_diff()</a></code>. Default is <code>NULL</code> so no test is performed.</p>
</td></tr>
<tr><td><code id="extract_rsp_subgroups_+3A_label_all">label_all</code></td>
<td>
<p>(<code>string</code>)<br /> label for the total population analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of two elements:
</p>

<ul>
<li> <p><code>prop</code>: A <code>data.frame</code> containing columns <code>arm</code>, <code>n</code>, <code>n_rsp</code>, <code>prop</code>, <code>subgroup</code>, <code>var</code>,
<code>var_label</code>, and <code>row_type</code>.
</p>
</li>
<li> <p><code>or</code>: A <code>data.frame</code> containing columns <code>arm</code>, <code>n_tot</code>, <code>or</code>, <code>lcl</code>, <code>ucl</code>, <code>conf_level</code>,
<code>subgroup</code>, <code>var</code>, <code>var_label</code>, and <code>row_type</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+response_subgroups">response_subgroups</a>
</p>

<hr>
<h2 id='extract_survival_biomarkers'>Prepares Survival Data Estimates for Multiple Biomarkers in a Single Data Frame</h2><span id='topic+extract_survival_biomarkers'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Prepares estimates for number of events, patients and median survival times, as well as hazard ratio estimates,
confidence intervals and p-values, for multiple biomarkers across population subgroups in a single data frame.
<code>variables</code> corresponds to the names of variables found in <code>data</code>, passed as a named <code>list</code> and requires elements
<code>tte</code>, <code>is_event</code>, <code>biomarkers</code> (vector of continuous biomarker variables), and optionally <code>subgroups</code> and <code>strat</code>.
<code>groups_lists</code> optionally specifies groupings for <code>subgroups</code> variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_survival_biomarkers(
  variables,
  data,
  groups_lists = list(),
  control = control_coxreg(),
  label_all = "All Patients"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_survival_biomarkers_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="extract_survival_biomarkers_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to summarize.</p>
</td></tr>
<tr><td><code id="extract_survival_biomarkers_+3A_groups_lists">groups_lists</code></td>
<td>
<p>(named <code>list</code> of <code>list</code>)<br /> optionally contains for each <code>subgroups</code> variable a
list, which specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
<tr><td><code id="extract_survival_biomarkers_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> a list of parameters as returned by the helper function <code><a href="#topic+control_coxreg">control_coxreg()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_survival_biomarkers_+3A_label_all">label_all</code></td>
<td>
<p>(<code>string</code>)<br /> label for the total population analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns <code>biomarker</code>, <code>biomarker_label</code>, <code>n_tot</code>, <code>n_tot_events</code>,
<code>median</code>, <code>hr</code>, <code>lcl</code>, <code>ucl</code>, <code>conf_level</code>, <code>pval</code>, <code>pval_label</code>, <code>subgroup</code>, <code>var</code>,
<code>var_label</code>, and <code>row_type</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+h_coxreg_mult_cont_df">h_coxreg_mult_cont_df()</a></code> which is used internally, <code><a href="#topic+tabulate_survival_biomarkers">tabulate_survival_biomarkers()</a></code>.
</p>

<hr>
<h2 id='extract_survival_subgroups'>Prepares Survival Data for Population Subgroups in Data Frames</h2><span id='topic+extract_survival_subgroups'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Prepares estimates of median survival times and treatment hazard ratios for population subgroups in
data frames. Simple wrapper for <code><a href="#topic+h_survtime_subgroups_df">h_survtime_subgroups_df()</a></code> and <code><a href="#topic+h_coxph_subgroups_df">h_coxph_subgroups_df()</a></code>. Result is a <code>list</code>
of two <code>data.frame</code>s: <code>survtime</code> and <code>hr</code>. <code>variables</code> corresponds to the names of variables found in <code>data</code>,
passed as a named <code>list</code> and requires elements <code>tte</code>, <code>is_event</code>, <code>arm</code> and optionally <code>subgroups</code> and <code>strat</code>.
<code>groups_lists</code> optionally specifies groupings for <code>subgroups</code> variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_survival_subgroups(
  variables,
  data,
  groups_lists = list(),
  control = control_coxph(),
  label_all = "All Patients"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_survival_subgroups_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="extract_survival_subgroups_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to summarize.</p>
</td></tr>
<tr><td><code id="extract_survival_subgroups_+3A_groups_lists">groups_lists</code></td>
<td>
<p>(named <code>list</code> of <code>list</code>)<br /> optionally contains for each <code>subgroups</code> variable a
list, which specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
<tr><td><code id="extract_survival_subgroups_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> parameters for comparison details, specified by using the helper function
<code><a href="#topic+control_coxph">control_coxph()</a></code>. Some possible parameter options are:
</p>

<ul>
<li> <p><code>pval_method</code> (<code>string</code>)<br /> p-value method for testing hazard ratio = 1. Default method is <code>"log-rank"</code> which
comes from <code><a href="survival.html#topic+survdiff">survival::survdiff()</a></code>, can also be set to <code>"wald"</code> or <code>"likelihood"</code> (from <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>).
</p>
</li>
<li> <p><code>ties</code> (<code>string</code>)<br /> specifying the method for tie handling. Default is <code>"efron"</code>,
can also be set to <code>"breslow"</code> or <code>"exact"</code>. See more in <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>
</p>
</li>
<li> <p><code>conf_level</code> (<code>proportion</code>)<br /> confidence level of the interval for HR.
</p>
</li></ul>
</td></tr>
<tr><td><code id="extract_survival_subgroups_+3A_label_all">label_all</code></td>
<td>
<p>(<code>string</code>)<br /> label for the total population analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code> of two elements:
</p>

<ul>
<li> <p><code>survtime</code>: A <code>data.frame</code> containing columns <code>arm</code>, <code>n</code>, <code>n_events</code>, <code>median</code>, <code>subgroup</code>, <code>var</code>,
<code>var_label</code>, and <code>row_type</code>.
</p>
</li>
<li> <p><code>hr</code>: A <code>data.frame</code> containing columns <code>arm</code>, <code>n_tot</code>, <code>n_tot_events</code>, <code>hr</code>, <code>lcl</code>, <code>ucl</code>, <code>conf_level</code>,
<code>pval</code>, <code>pval_label</code>, <code>subgroup</code>, <code>var</code>, <code>var_label</code>, and <code>row_type</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+survival_duration_subgroups">survival_duration_subgroups</a>
</p>

<hr>
<h2 id='extreme_format'>Formatting Extreme Values</h2><span id='topic+extreme_format'></span><span id='topic+h_get_format_threshold'></span><span id='topic+h_format_threshold'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p><code>rtables</code> formatting functions that handle extreme values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_get_format_threshold(digits = 2L)

h_format_threshold(x, digits = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extreme_format_+3A_digits">digits</code></td>
<td>
<p>(<code>integer</code>)<br /> number of decimal places to display.</p>
</td></tr>
<tr><td><code id="extreme_format_+3A_x">x</code></td>
<td>
<p>(<code>number</code>)<br /> value to format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each input, apply a format to the specified number of <code>digits</code>. If the value is
below a threshold, it returns &quot;&lt;0.01&quot; e.g. if the number of <code>digits</code> is 2. If the value is
above a threshold, it returns &quot;&gt;999.99&quot; e.g. if the number of <code>digits</code> is 2.
If it is zero, then returns &quot;0.00&quot;.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>h_get_format_threshold()</code> returns a <code>list</code> of 2 elements: <code>threshold</code>, with <code>low</code> and <code>high</code> thresholds,
and <code>format_string</code>, with thresholds formatted as strings.
</p>
</li></ul>


<ul>
<li> <p><code>h_format_threshold()</code> returns the given value, or if the value is not within the digit threshold the relation
of the given value to the digit threshold, as a formatted string.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>h_get_format_threshold()</code>: Internal helper function to calculate the threshold and create formatted strings
used in Formatting Functions. Returns a list with elements <code>threshold</code> and <code>format_string</code>.
</p>
</li>
<li> <p><code>h_format_threshold()</code>: Internal helper function to apply a threshold format to a value.
Creates a formatted string to be used in Formatting Functions.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other formatting functions: 
<code><a href="#topic+format_auto">format_auto</a>()</code>,
<code><a href="#topic+format_count_fraction_fixed_dp">format_count_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_count_fraction_lt10">format_count_fraction_lt10</a>()</code>,
<code><a href="#topic+format_count_fraction">format_count_fraction</a>()</code>,
<code><a href="#topic+format_extreme_values_ci">format_extreme_values_ci</a>()</code>,
<code><a href="#topic+format_extreme_values">format_extreme_values</a>()</code>,
<code><a href="#topic+format_fraction_fixed_dp">format_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_fraction_threshold">format_fraction_threshold</a>()</code>,
<code><a href="#topic+format_fraction">format_fraction</a>()</code>,
<code><a href="#topic+format_sigfig">format_sigfig</a>()</code>,
<code><a href="#topic+format_xx">format_xx</a>()</code>,
<code><a href="#topic+formatting_functions">formatting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h_get_format_threshold(2L)

h_format_threshold(0.001)
h_format_threshold(1000)

</code></pre>

<hr>
<h2 id='f_conf_level'>Utility function to create label for confidence interval</h2><span id='topic+f_conf_level'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_conf_level(conf_level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_conf_level_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>string</code>.
</p>

<hr>
<h2 id='f_pval'>Utility function to create label for p-value</h2><span id='topic+f_pval'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_pval(test_mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_pval_+3A_test_mean">test_mean</code></td>
<td>
<p>(<code>number</code>)<br /> mean value to test under the null hypothesis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>string</code>.
</p>

<hr>
<h2 id='fct_collapse_only'>Collapsing of Factor Levels and Keeping Only Those New Group Levels</h2><span id='topic+fct_collapse_only'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This collapses levels and only keeps those new group levels, in the order provided.
The returned factor has levels in the order given, with the possible missing level last (this will
only be included if there are missing values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fct_collapse_only(.f, ..., .na_level = "&lt;Missing&gt;")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fct_collapse_only_+3A_.f">.f</code></td>
<td>
<p>(<code>factor</code> or <code>character</code>)<br /> original vector.</p>
</td></tr>
<tr><td><code id="fct_collapse_only_+3A_...">...</code></td>
<td>
<p>(named <code>character</code> vectors)<br /> levels in each vector provided will be collapsed into
the new level given by the respective name.</p>
</td></tr>
<tr><td><code id="fct_collapse_only_+3A_.na_level">.na_level</code></td>
<td>
<p>(<code>string</code>)<br /> which level to use for other levels, which should be missing in the
new factor. Note that this level must not be contained in the new levels specified in <code>...</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code>factor</code> with collapsed levels. Values and levels which are not included
in the given <code>character</code> vector input will be set to the missing level <code>.na_level</code>.
</p>


<h3>Note</h3>

<p>Any existing <code>NA</code>s in the input vector will not be replaced by the missing level. If needed,
<code><a href="#topic+explicit_na">explicit_na()</a></code> can be called separately on the result.
</p>


<h3>See Also</h3>

<p><code><a href="forcats.html#topic+fct_collapse">forcats::fct_collapse()</a></code>, <code><a href="forcats.html#topic+fct_relevel">forcats::fct_relevel()</a></code> which are used internally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fct_collapse_only(factor(c("a", "b", "c", "d")), TRT = "b", CTRL = c("c", "d"))

</code></pre>

<hr>
<h2 id='fct_discard'>Discard Certain Levels from a Factor</h2><span id='topic+fct_discard'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This discards the observations as well as the levels specified from a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fct_discard(x, discard)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fct_discard_+3A_x">x</code></td>
<td>
<p>(<code>factor</code>)<br /> the original factor.</p>
</td></tr>
<tr><td><code id="fct_discard_+3A_discard">discard</code></td>
<td>
<p>(<code>character</code>)<br /> which levels to discard.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code>factor</code> with observations as well as levels from <code>discard</code> dropped.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fct_discard(factor(c("a", "b", "c")), "c")

</code></pre>

<hr>
<h2 id='fct_explicit_na_if'>Insertion of Explicit Missings in a Factor</h2><span id='topic+fct_explicit_na_if'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This inserts explicit missings in a factor based on a condition. Additionally,
existing <code>NA</code> values will be explicitly converted to given <code>na_level</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fct_explicit_na_if(x, condition, na_level = "&lt;Missing&gt;")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fct_explicit_na_if_+3A_x">x</code></td>
<td>
<p>(<code>factor</code>)<br /> the original factor.</p>
</td></tr>
<tr><td><code id="fct_explicit_na_if_+3A_condition">condition</code></td>
<td>
<p>(<code>logical</code>)<br /> where to insert missings.</p>
</td></tr>
<tr><td><code id="fct_explicit_na_if_+3A_na_level">na_level</code></td>
<td>
<p>(<code>string</code>)<br /> which level to use for missings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code>factor</code> with inserted and existing <code>NA</code> converted to <code>na_level</code>.
</p>


<h3>See Also</h3>

<p><code><a href="forcats.html#topic+fct_na_value_to_level">forcats::fct_na_value_to_level()</a></code> which is used internally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fct_explicit_na_if(factor(c("a", "b", NA)), c(TRUE, FALSE, FALSE))

</code></pre>

<hr>
<h2 id='fit_coxreg'>Fits for Cox Proportional Hazards Regression</h2><span id='topic+fit_coxreg'></span><span id='topic+fit_coxreg_univar'></span><span id='topic+fit_coxreg_multivar'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Fitting functions for univariate and multivariate Cox regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_coxreg_univar(variables, data, at = list(), control = control_coxreg())

fit_coxreg_multivar(variables, data, control = control_coxreg())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_coxreg_+3A_variables">variables</code></td>
<td>
<p>(<code>list</code>)<br /> a named list corresponds to the names of variables found in <code>data</code>, passed as a named
list and corresponding to <code>time</code>, <code>event</code>, <code>arm</code>, <code>strata</code>, and <code>covariates</code> terms. If <code>arm</code> is missing from
<code>variables</code>, then only Cox model(s) including the <code>covariates</code> will be fitted and the corresponding effect
estimates will be tabulated later.</p>
</td></tr>
<tr><td><code id="fit_coxreg_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to fit the models.</p>
</td></tr>
<tr><td><code id="fit_coxreg_+3A_at">at</code></td>
<td>
<p>(<code>list</code> of <code>numeric</code>)<br /> when the candidate covariate is a <code>numeric</code>, use <code>at</code> to specify
the value of the covariate at which the effect should be estimated.</p>
</td></tr>
<tr><td><code id="fit_coxreg_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> a list of parameters as returned by the helper function <code><a href="#topic+control_coxreg">control_coxreg()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>fit_coxreg_univar()</code> returns a <code>coxreg.univar</code> class object which is a named <code>list</code>
with 5 elements:
</p>

<ul>
<li> <p><code>mod</code>: Cox regression models fitted by <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>.
</p>
</li>
<li> <p><code>data</code>: The original data frame input.
</p>
</li>
<li> <p><code>control</code>: The original control input.
</p>
</li>
<li> <p><code>vars</code>: The variables used in the model.
</p>
</li>
<li> <p><code>at</code>: Value of the covariate at which the effect should be estimated.
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>fit_coxreg_multivar()</code> returns a <code>coxreg.multivar</code> class object which is a named list
with 4 elements:
</p>

<ul>
<li> <p><code>mod</code>: Cox regression model fitted by <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>.
</p>
</li>
<li> <p><code>data</code>: The original data frame input.
</p>
</li>
<li> <p><code>control</code>: The original control input.
</p>
</li>
<li> <p><code>vars</code>: The variables used in the model.
</p>
</li></ul>

</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>fit_coxreg_univar()</code>: Fit a series of univariate Cox regression models given the inputs.
</p>
</li>
<li> <p><code>fit_coxreg_multivar()</code>: Fit a multivariate Cox regression model.
</p>
</li></ul>


<h3>Note</h3>

<p>When using <code>fit_coxreg_univar</code> there should be two study arms.
</p>


<h3>See Also</h3>

<p><a href="#topic+h_cox_regression">h_cox_regression</a> for relevant helper functions, <a href="#topic+cox_regression">cox_regression</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)

set.seed(1, kind = "Mersenne-Twister")

# Testing dataset [survival::bladder].
dta_bladder &lt;- with(
  data = bladder[bladder$enum &lt; 5, ],
  data.frame(
    time = stop,
    status = event,
    armcd = as.factor(rx),
    covar1 = as.factor(enum),
    covar2 = factor(
      sample(as.factor(enum)),
      levels = 1:4, labels = c("F", "F", "M", "M")
    )
  )
)
labels &lt;- c("armcd" = "ARM", "covar1" = "A Covariate Label", "covar2" = "Sex (F/M)")
formatters::var_labels(dta_bladder)[names(labels)] &lt;- labels
dta_bladder$age &lt;- sample(20:60, size = nrow(dta_bladder), replace = TRUE)

plot(
  survfit(Surv(time, status) ~ armcd + covar1, data = dta_bladder),
  lty = 2:4,
  xlab = "Months",
  col = c("blue1", "blue2", "blue3", "blue4", "red1", "red2", "red3", "red4")
)

# fit_coxreg_univar

## Cox regression: arm + 1 covariate.
mod1 &lt;- fit_coxreg_univar(
  variables = list(
    time = "time", event = "status", arm = "armcd",
    covariates = "covar1"
  ),
  data = dta_bladder,
  control = control_coxreg(conf_level = 0.91)
)

## Cox regression: arm + 1 covariate + interaction, 2 candidate covariates.
mod2 &lt;- fit_coxreg_univar(
  variables = list(
    time = "time", event = "status", arm = "armcd",
    covariates = c("covar1", "covar2")
  ),
  data = dta_bladder,
  control = control_coxreg(conf_level = 0.91, interaction = TRUE)
)

## Cox regression: arm + 1 covariate, stratified analysis.
mod3 &lt;- fit_coxreg_univar(
  variables = list(
    time = "time", event = "status", arm = "armcd", strata = "covar2",
    covariates = c("covar1")
  ),
  data = dta_bladder,
  control = control_coxreg(conf_level = 0.91)
)

## Cox regression: no arm, only covariates.
mod4 &lt;- fit_coxreg_univar(
  variables = list(
    time = "time", event = "status",
    covariates = c("covar1", "covar2")
  ),
  data = dta_bladder
)

# fit_coxreg_multivar

## Cox regression: multivariate Cox regression.
multivar_model &lt;- fit_coxreg_multivar(
  variables = list(
    time = "time", event = "status", arm = "armcd",
    covariates = c("covar1", "covar2")
  ),
  data = dta_bladder
)

# Example without treatment arm.
multivar_covs_model &lt;- fit_coxreg_multivar(
  variables = list(
    time = "time", event = "status",
    covariates = c("covar1", "covar2")
  ),
  data = dta_bladder
)

</code></pre>

<hr>
<h2 id='fit_logistic'>Fit for Logistic Regression</h2><span id='topic+fit_logistic'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Fit a (conditional) logistic regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_logistic(
  data,
  variables = list(response = "Response", arm = "ARMCD", covariates = NULL, interaction =
    NULL, strata = NULL),
  response_definition = "response"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_logistic_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the data frame on which the model was fit.</p>
</td></tr>
<tr><td><code id="fit_logistic_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="fit_logistic_+3A_response_definition">response_definition</code></td>
<td>
<p>(<code>string</code>)<br /> the definition of what an event is in terms of <code>response</code>.
This will be used when fitting the (conditional) logistic regression model on the left hand
side of the formula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted logistic regression model.
</p>


<h3>Model Specification</h3>

<p>The <code>variables</code> list needs to include the following elements:
</p>

<ul>
<li> <p><code>arm</code>: Treatment arm variable name.
</p>
</li>
<li> <p><code>response</code>: The response arm variable name. Usually this is a 0/1 variable.
</p>
</li>
<li> <p><code>covariates</code>: This is either <code>NULL</code> (no covariates) or a character vector of covariate variable names.
</p>
</li>
<li> <p><code>interaction</code>: This is either <code>NULL</code> (no interaction) or a string of a single covariate variable name already
included in <code>covariates</code>. Then the interaction with the treatment arm is included in the model.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

adrs_f &lt;- tern_ex_adrs %&gt;%
  filter(PARAMCD == "BESRSPI") %&gt;%
  filter(RACE %in% c("ASIAN", "WHITE", "BLACK OR AFRICAN AMERICAN")) %&gt;%
  mutate(
    Response = case_when(AVALC %in% c("PR", "CR") ~ 1, TRUE ~ 0),
    RACE = factor(RACE),
    SEX = factor(SEX)
  )
formatters::var_labels(adrs_f) &lt;- c(formatters::var_labels(tern_ex_adrs), Response = "Response")
mod1 &lt;- fit_logistic(
  data = adrs_f,
  variables = list(
    response = "Response",
    arm = "ARMCD",
    covariates = c("AGE", "RACE")
  )
)
mod2 &lt;- fit_logistic(
  data = adrs_f,
  variables = list(
    response = "Response",
    arm = "ARMCD",
    covariates = c("AGE", "RACE"),
    interaction = "AGE"
  )
)

</code></pre>

<hr>
<h2 id='fit_rsp_step'>Subgroup Treatment Effect Pattern (STEP) Fit for Binary (Response) Outcome</h2><span id='topic+fit_rsp_step'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This fits the Subgroup Treatment Effect Pattern logistic regression models for a binary
(response) outcome. The treatment arm variable must have exactly 2 levels,
where the first one is taken as reference and the estimated odds ratios are
for the comparison of the second level vs. the first one.
</p>
<p>The (conditional) logistic regression model which is fit is:
</p>
<p><code>response ~ arm * poly(biomarker, degree) + covariates + strata(strata)</code>
</p>
<p>where <code>degree</code> is specified by <code>control_step()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_rsp_step(variables, data, control = c(control_step(), control_logistic()))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_rsp_step_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>character</code>)<br /> list of analysis variables:
needs <code>response</code>, <code>arm</code>, <code>biomarker</code>, and optional <code>covariates</code> and <code>strata</code>.</p>
</td></tr>
<tr><td><code id="fit_rsp_step_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to summarize.</p>
</td></tr>
<tr><td><code id="fit_rsp_step_+3A_control">control</code></td>
<td>
<p>(named <code>list</code>)<br /> combined control list from <code><a href="#topic+control_step">control_step()</a></code>
and <code><a href="#topic+control_logistic">control_logistic()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of class <code>step</code>. The first part of the columns describe the
subgroup intervals used for the biomarker variable, including where the
center of the intervals are and their bounds. The second part of the
columns contain the estimates for the treatment arm comparison.
</p>


<h3>Note</h3>

<p>For the default degree 0 the <code>biomarker</code> variable is not included in the model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control_step">control_step()</a></code> and <code><a href="#topic+control_logistic">control_logistic()</a></code> for the available
customization options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Testing dataset with just two treatment arms.
library(survival)
library(dplyr)

adrs_f &lt;- tern_ex_adrs %&gt;%
  filter(
    PARAMCD == "BESRSPI",
    ARM %in% c("B: Placebo", "A: Drug X")
  ) %&gt;%
  mutate(
    # Reorder levels of ARM to have Placebo as reference arm for Odds Ratio calculations.
    ARM = droplevels(forcats::fct_relevel(ARM, "B: Placebo")),
    RSP = case_when(AVALC %in% c("PR", "CR") ~ 1, TRUE ~ 0),
    SEX = factor(SEX)
  )

variables &lt;- list(
  arm = "ARM",
  biomarker = "BMRKR1",
  covariates = "AGE",
  response = "RSP"
)

# Fit default STEP models: Here a constant treatment effect is estimated in each subgroup.
# We use a large enough bandwidth to avoid too small subgroups and linear separation in those.
step_matrix &lt;- fit_rsp_step(
  variables = variables,
  data = adrs_f,
  control = c(control_logistic(), control_step(bandwidth = 0.5))
)
dim(step_matrix)
head(step_matrix)

# Specify different polynomial degree for the biomarker interaction to use more flexible local
# models. Or specify different logistic regression options, including confidence level.
step_matrix2 &lt;- fit_rsp_step(
  variables = variables,
  data = adrs_f,
  control = c(control_logistic(conf_level = 0.9), control_step(bandwidth = 0.6, degree = 1))
)

# Use a global constant model. This is helpful as a reference for the subgroup models.
step_matrix3 &lt;- fit_rsp_step(
  variables = variables,
  data = adrs_f,
  control = c(control_logistic(), control_step(bandwidth = NULL, num_points = 2L))
)

# It is also possible to use strata, i.e. use conditional logistic regression models.
variables2 &lt;- list(
  arm = "ARM",
  biomarker = "BMRKR1",
  covariates = "AGE",
  response = "RSP",
  strata = c("STRATA1", "STRATA2")
)

step_matrix4 &lt;- fit_rsp_step(
  variables = variables2,
  data = adrs_f,
  control = c(control_logistic(), control_step(bandwidth = 0.6))
)

</code></pre>

<hr>
<h2 id='fit_survival_step'>Subgroup Treatment Effect Pattern (STEP) Fit for Survival Outcome</h2><span id='topic+fit_survival_step'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This fits the Subgroup Treatment Effect Pattern models for a survival outcome. The treatment arm
variable must have exactly 2 levels, where the first one is taken as reference and the estimated
hazard ratios are for the comparison of the second level vs. the first one.
</p>
<p>The model which is fit is:
</p>
<p><code>Surv(time, event) ~ arm * poly(biomarker, degree) + covariates + strata(strata)</code>
</p>
<p>where <code>degree</code> is specified by <code>control_step()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_survival_step(
  variables,
  data,
  control = c(control_step(), control_coxph())
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_survival_step_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>character</code>)<br /> list of analysis variables: needs <code>time</code>, <code>event</code>,
<code>arm</code>, <code>biomarker</code>, and optional <code>covariates</code> and <code>strata</code>.</p>
</td></tr>
<tr><td><code id="fit_survival_step_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to summarize.</p>
</td></tr>
<tr><td><code id="fit_survival_step_+3A_control">control</code></td>
<td>
<p>(named <code>list</code>)<br /> combined control list from <code><a href="#topic+control_step">control_step()</a></code> and <code><a href="#topic+control_coxph">control_coxph()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of class <code>step</code>. The first part of the columns describe the subgroup intervals used
for the biomarker variable, including where the center of the intervals are and their bounds. The
second part of the columns contain the estimates for the treatment arm comparison.
</p>


<h3>Note</h3>

<p>For the default degree 0 the <code>biomarker</code> variable is not included in the model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control_step">control_step()</a></code> and <code><a href="#topic+control_coxph">control_coxph()</a></code> for the available customization options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Testing dataset with just two treatment arms.
library(dplyr)

adtte_f &lt;- tern_ex_adtte %&gt;%
  filter(
    PARAMCD == "OS",
    ARM %in% c("B: Placebo", "A: Drug X")
  ) %&gt;%
  mutate(
    # Reorder levels of ARM to display reference arm before treatment arm.
    ARM = droplevels(forcats::fct_relevel(ARM, "B: Placebo")),
    is_event = CNSR == 0
  )
labels &lt;- c("ARM" = "Treatment Arm", "is_event" = "Event Flag")
formatters::var_labels(adtte_f)[names(labels)] &lt;- labels

variables &lt;- list(
  arm = "ARM",
  biomarker = "BMRKR1",
  covariates = c("AGE", "BMRKR2"),
  event = "is_event",
  time = "AVAL"
)

# Fit default STEP models: Here a constant treatment effect is estimated in each subgroup.
step_matrix &lt;- fit_survival_step(
  variables = variables,
  data = adtte_f
)
dim(step_matrix)
head(step_matrix)

# Specify different polynomial degree for the biomarker interaction to use more flexible local
# models. Or specify different Cox regression options.
step_matrix2 &lt;- fit_survival_step(
  variables = variables,
  data = adtte_f,
  control = c(control_coxph(conf_level = 0.9), control_step(degree = 2))
)

# Use a global model with cubic interaction and only 5 points.
step_matrix3 &lt;- fit_survival_step(
  variables = variables,
  data = adtte_f,
  control = c(control_coxph(), control_step(bandwidth = NULL, degree = 3, num_points = 5L))
)

</code></pre>

<hr>
<h2 id='forest_viewport'>Create a Viewport Tree for the Forest Plot</h2><span id='topic+forest_viewport'></span>

<h3>Description</h3>

<p>Create a Viewport Tree for the Forest Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forest_viewport(
  tbl,
  width_row_names = NULL,
  width_columns = NULL,
  width_forest = grid::unit(1, "null"),
  gap_column = grid::unit(1, "lines"),
  gap_header = grid::unit(1, "lines"),
  mat_form = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forest_viewport_+3A_tbl">tbl</code></td>
<td>
<p>(<code>rtable</code>)</p>
</td></tr>
<tr><td><code id="forest_viewport_+3A_width_row_names">width_row_names</code></td>
<td>
<p>(<code>grid::unit</code>)<br /> Width of row names</p>
</td></tr>
<tr><td><code id="forest_viewport_+3A_width_columns">width_columns</code></td>
<td>
<p>(<code>grid::unit</code>)<br /> Width of column spans</p>
</td></tr>
<tr><td><code id="forest_viewport_+3A_width_forest">width_forest</code></td>
<td>
<p>(<code>grid::unit</code>)<br /> Width of the forest plot</p>
</td></tr>
<tr><td><code id="forest_viewport_+3A_gap_column">gap_column</code></td>
<td>
<p>(<code>grid::unit</code>)<br /> Gap width between the columns</p>
</td></tr>
<tr><td><code id="forest_viewport_+3A_gap_header">gap_header</code></td>
<td>
<p>(<code>grid::unit</code>)<br /> Gap width between the header</p>
</td></tr>
<tr><td><code id="forest_viewport_+3A_mat_form">mat_form</code></td>
<td>
<p>matrix print form of the table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A viewport tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(grid)

tbl &lt;- rtable(
  header = rheader(
    rrow("", "E", rcell("CI", colspan = 2)),
    rrow("", "A", "B", "C")
  ),
  rrow("row 1", 1, 0.8, 1.1),
  rrow("row 2", 1.4, 0.8, 1.6),
  rrow("row 3", 1.2, 0.8, 1.2)
)


v &lt;- forest_viewport(tbl)

grid::grid.newpage()
showViewport(v)


</code></pre>

<hr>
<h2 id='format_auto'>Automatic formats from data significant digits</h2><span id='topic+format_auto'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Formatting function for the majority of default methods used in <code><a href="#topic+analyze_vars">analyze_vars()</a></code>.
For non-derived values, the significant digits of data is used (e.g. range), while derived
values have one more digits (measure of location and dispersion like mean, standard deviation).
This function can be called internally with &quot;auto&quot; like, for example,
<code>.formats = c("mean" = "auto")</code>. See details to see how this works with the inner function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_auto(dt_var, x_stat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_auto_+3A_dt_var">dt_var</code></td>
<td>
<p>(<code>numeric</code>) <br /> all the data the statistics was created upon. Used only to find
significant digits. In <a href="#topic+analyze_vars">analyze_vars</a> this comes from <code>.df_row</code> (see
<a href="rtables.html#topic+additional_fun_params">rtables::additional_fun_params</a>), and it is the row data after the above row splits. No
column split is considered.</p>
</td></tr>
<tr><td><code id="format_auto_+3A_x_stat">x_stat</code></td>
<td>
<p>(<code>string</code>) <br /> string indicating the current statistical method used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The internal function is needed to work with <code>rtables</code> default structure for
format functions, i.e. <code style="white-space: pre;">&#8288;function(x, ...)&#8288;</code>, where is x are results from statistical evaluation.
It can be more than one element (e.g. for <code>.stats = "mean_sd"</code>).
</p>


<h3>Value</h3>

<p>A string that <code>rtables</code> prints in a table cell.
</p>


<h3>See Also</h3>

<p>Other formatting functions: 
<code><a href="#topic+extreme_format">extreme_format</a></code>,
<code><a href="#topic+format_count_fraction_fixed_dp">format_count_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_count_fraction_lt10">format_count_fraction_lt10</a>()</code>,
<code><a href="#topic+format_count_fraction">format_count_fraction</a>()</code>,
<code><a href="#topic+format_extreme_values_ci">format_extreme_values_ci</a>()</code>,
<code><a href="#topic+format_extreme_values">format_extreme_values</a>()</code>,
<code><a href="#topic+format_fraction_fixed_dp">format_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_fraction_threshold">format_fraction_threshold</a>()</code>,
<code><a href="#topic+format_fraction">format_fraction</a>()</code>,
<code><a href="#topic+format_sigfig">format_sigfig</a>()</code>,
<code><a href="#topic+format_xx">format_xx</a>()</code>,
<code><a href="#topic+formatting_functions">formatting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_todo &lt;- c(0.001, 0.2, 0.0011000, 3, 4)
res &lt;- c(mean(x_todo[1:3]), sd(x_todo[1:3]))

# x is the result coming into the formatting function -&gt; res!!
format_auto(dt_var = x_todo, x_stat = "mean_sd")(x = res)
format_auto(x_todo, "range")(x = range(x_todo))
no_sc_x &lt;- c(0.0000001, 1)
format_auto(no_sc_x, "range")(x = no_sc_x)

</code></pre>

<hr>
<h2 id='format_count_fraction'>Formatting Count and Fraction</h2><span id='topic+format_count_fraction'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Formats a count together with fraction with special consideration when count is <code>0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_count_fraction(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_count_fraction_+3A_x">x</code></td>
<td>
<p>(<code>integer</code>)<br /> vector of length 2, count and fraction.</p>
</td></tr>
<tr><td><code id="format_count_fraction_+3A_...">...</code></td>
<td>
<p>required for <code>rtables</code> interface.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string in the format <code style="white-space: pre;">&#8288;count (fraction %)&#8288;</code>. If <code>count</code> is 0, the format is <code>0</code>.
</p>


<h3>See Also</h3>

<p>Other formatting functions: 
<code><a href="#topic+extreme_format">extreme_format</a></code>,
<code><a href="#topic+format_auto">format_auto</a>()</code>,
<code><a href="#topic+format_count_fraction_fixed_dp">format_count_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_count_fraction_lt10">format_count_fraction_lt10</a>()</code>,
<code><a href="#topic+format_extreme_values_ci">format_extreme_values_ci</a>()</code>,
<code><a href="#topic+format_extreme_values">format_extreme_values</a>()</code>,
<code><a href="#topic+format_fraction_fixed_dp">format_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_fraction_threshold">format_fraction_threshold</a>()</code>,
<code><a href="#topic+format_fraction">format_fraction</a>()</code>,
<code><a href="#topic+format_sigfig">format_sigfig</a>()</code>,
<code><a href="#topic+format_xx">format_xx</a>()</code>,
<code><a href="#topic+formatting_functions">formatting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_count_fraction(x = c(2, 0.6667))
format_count_fraction(x = c(0, 0))

</code></pre>

<hr>
<h2 id='format_count_fraction_fixed_dp'>Formatting Count and Percentage with Fixed Single Decimal Place</h2><span id='topic+format_count_fraction_fixed_dp'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Formats a count together with fraction with special consideration when count is <code>0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_count_fraction_fixed_dp(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_count_fraction_fixed_dp_+3A_x">x</code></td>
<td>
<p>(<code>integer</code>)<br /> vector of length 2, count and fraction.</p>
</td></tr>
<tr><td><code id="format_count_fraction_fixed_dp_+3A_...">...</code></td>
<td>
<p>required for <code>rtables</code> interface.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string in the format <code style="white-space: pre;">&#8288;count (fraction %)&#8288;</code>. If <code>count</code> is 0, the format is <code>0</code>.
</p>


<h3>See Also</h3>

<p>Other formatting functions: 
<code><a href="#topic+extreme_format">extreme_format</a></code>,
<code><a href="#topic+format_auto">format_auto</a>()</code>,
<code><a href="#topic+format_count_fraction_lt10">format_count_fraction_lt10</a>()</code>,
<code><a href="#topic+format_count_fraction">format_count_fraction</a>()</code>,
<code><a href="#topic+format_extreme_values_ci">format_extreme_values_ci</a>()</code>,
<code><a href="#topic+format_extreme_values">format_extreme_values</a>()</code>,
<code><a href="#topic+format_fraction_fixed_dp">format_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_fraction_threshold">format_fraction_threshold</a>()</code>,
<code><a href="#topic+format_fraction">format_fraction</a>()</code>,
<code><a href="#topic+format_sigfig">format_sigfig</a>()</code>,
<code><a href="#topic+format_xx">format_xx</a>()</code>,
<code><a href="#topic+formatting_functions">formatting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_count_fraction_fixed_dp(x = c(2, 0.6667))
format_count_fraction_fixed_dp(x = c(2, 0.5))
format_count_fraction_fixed_dp(x = c(0, 0))

</code></pre>

<hr>
<h2 id='format_count_fraction_lt10'>Formatting Count and Fraction with Special Case for Count &lt; 10</h2><span id='topic+format_count_fraction_lt10'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Formats a count together with fraction with special consideration when count is less than 10.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_count_fraction_lt10(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_count_fraction_lt10_+3A_x">x</code></td>
<td>
<p>(<code>integer</code>)<br /> vector of length 2, count and fraction.</p>
</td></tr>
<tr><td><code id="format_count_fraction_lt10_+3A_...">...</code></td>
<td>
<p>required for <code>rtables</code> interface.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string in the format <code style="white-space: pre;">&#8288;count (fraction %)&#8288;</code>. If <code>count</code> is less than 10, only <code>count</code> is printed.
</p>


<h3>See Also</h3>

<p>Other formatting functions: 
<code><a href="#topic+extreme_format">extreme_format</a></code>,
<code><a href="#topic+format_auto">format_auto</a>()</code>,
<code><a href="#topic+format_count_fraction_fixed_dp">format_count_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_count_fraction">format_count_fraction</a>()</code>,
<code><a href="#topic+format_extreme_values_ci">format_extreme_values_ci</a>()</code>,
<code><a href="#topic+format_extreme_values">format_extreme_values</a>()</code>,
<code><a href="#topic+format_fraction_fixed_dp">format_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_fraction_threshold">format_fraction_threshold</a>()</code>,
<code><a href="#topic+format_fraction">format_fraction</a>()</code>,
<code><a href="#topic+format_sigfig">format_sigfig</a>()</code>,
<code><a href="#topic+format_xx">format_xx</a>()</code>,
<code><a href="#topic+formatting_functions">formatting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_count_fraction_lt10(x = c(275, 0.9673))
format_count_fraction_lt10(x = c(2, 0.6667))
format_count_fraction_lt10(x = c(9, 1))

</code></pre>

<hr>
<h2 id='format_extreme_values'>Formatting a Single Extreme Value</h2><span id='topic+format_extreme_values'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Create Formatting Function for a single extreme value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_extreme_values(digits = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_extreme_values_+3A_digits">digits</code></td>
<td>
<p>(<code>integer</code>)<br /> number of decimal places to display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>rtables</code> formatting function that uses threshold <code>digits</code> to return a formatted extreme value.
</p>


<h3>See Also</h3>

<p>Other formatting functions: 
<code><a href="#topic+extreme_format">extreme_format</a></code>,
<code><a href="#topic+format_auto">format_auto</a>()</code>,
<code><a href="#topic+format_count_fraction_fixed_dp">format_count_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_count_fraction_lt10">format_count_fraction_lt10</a>()</code>,
<code><a href="#topic+format_count_fraction">format_count_fraction</a>()</code>,
<code><a href="#topic+format_extreme_values_ci">format_extreme_values_ci</a>()</code>,
<code><a href="#topic+format_fraction_fixed_dp">format_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_fraction_threshold">format_fraction_threshold</a>()</code>,
<code><a href="#topic+format_fraction">format_fraction</a>()</code>,
<code><a href="#topic+format_sigfig">format_sigfig</a>()</code>,
<code><a href="#topic+format_xx">format_xx</a>()</code>,
<code><a href="#topic+formatting_functions">formatting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_fun &lt;- format_extreme_values(2L)
format_fun(x = 0.127)
format_fun(x = Inf)
format_fun(x = 0)
format_fun(x = 0.009)

</code></pre>

<hr>
<h2 id='format_extreme_values_ci'>Formatting Extreme Values Part of a Confidence Interval</h2><span id='topic+format_extreme_values_ci'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Formatting Function for extreme values part of a confidence interval. Values
are formatted as e.g. &quot;(xx.xx, xx.xx)&quot; if the number of <code>digits</code> is 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_extreme_values_ci(digits = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_extreme_values_ci_+3A_digits">digits</code></td>
<td>
<p>(<code>integer</code>)<br /> number of decimal places to display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>rtables</code> formatting function that uses threshold <code>digits</code> to return a formatted extreme
values confidence interval.
</p>


<h3>See Also</h3>

<p>Other formatting functions: 
<code><a href="#topic+extreme_format">extreme_format</a></code>,
<code><a href="#topic+format_auto">format_auto</a>()</code>,
<code><a href="#topic+format_count_fraction_fixed_dp">format_count_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_count_fraction_lt10">format_count_fraction_lt10</a>()</code>,
<code><a href="#topic+format_count_fraction">format_count_fraction</a>()</code>,
<code><a href="#topic+format_extreme_values">format_extreme_values</a>()</code>,
<code><a href="#topic+format_fraction_fixed_dp">format_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_fraction_threshold">format_fraction_threshold</a>()</code>,
<code><a href="#topic+format_fraction">format_fraction</a>()</code>,
<code><a href="#topic+format_sigfig">format_sigfig</a>()</code>,
<code><a href="#topic+format_xx">format_xx</a>()</code>,
<code><a href="#topic+formatting_functions">formatting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_fun &lt;- format_extreme_values_ci(2L)
format_fun(x = c(0.127, Inf))
format_fun(x = c(0, 0.009))

</code></pre>

<hr>
<h2 id='format_fraction'>Formatting Fraction and Percentage</h2><span id='topic+format_fraction'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Formats a fraction together with ratio in percent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_fraction(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_fraction_+3A_x">x</code></td>
<td>
<p>(<code>integer</code>)<br /> with elements <code>num</code> and <code>denom</code>.</p>
</td></tr>
<tr><td><code id="format_fraction_+3A_...">...</code></td>
<td>
<p>required for <code>rtables</code> interface.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string in the format <code style="white-space: pre;">&#8288;num / denom (ratio %)&#8288;</code>. If <code>num</code> is 0, the format is <code>num / denom</code>.
</p>


<h3>See Also</h3>

<p>Other formatting functions: 
<code><a href="#topic+extreme_format">extreme_format</a></code>,
<code><a href="#topic+format_auto">format_auto</a>()</code>,
<code><a href="#topic+format_count_fraction_fixed_dp">format_count_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_count_fraction_lt10">format_count_fraction_lt10</a>()</code>,
<code><a href="#topic+format_count_fraction">format_count_fraction</a>()</code>,
<code><a href="#topic+format_extreme_values_ci">format_extreme_values_ci</a>()</code>,
<code><a href="#topic+format_extreme_values">format_extreme_values</a>()</code>,
<code><a href="#topic+format_fraction_fixed_dp">format_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_fraction_threshold">format_fraction_threshold</a>()</code>,
<code><a href="#topic+format_sigfig">format_sigfig</a>()</code>,
<code><a href="#topic+format_xx">format_xx</a>()</code>,
<code><a href="#topic+formatting_functions">formatting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_fraction(x = c(num = 2L, denom = 3L))
format_fraction(x = c(num = 0L, denom = 3L))

</code></pre>

<hr>
<h2 id='format_fraction_fixed_dp'>Formatting Fraction and Percentage with Fixed Single Decimal Place</h2><span id='topic+format_fraction_fixed_dp'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Formats a fraction together with ratio in percent with fixed single decimal place.
Includes trailing zero in case of whole number percentages to always keep one decimal place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_fraction_fixed_dp(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_fraction_fixed_dp_+3A_x">x</code></td>
<td>
<p>(<code>integer</code>)<br /> with elements <code>num</code> and <code>denom</code>.</p>
</td></tr>
<tr><td><code id="format_fraction_fixed_dp_+3A_...">...</code></td>
<td>
<p>required for <code>rtables</code> interface.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string in the format <code style="white-space: pre;">&#8288;num / denom (ratio %)&#8288;</code>. If <code>num</code> is 0, the format is <code>num / denom</code>.
</p>


<h3>See Also</h3>

<p>Other formatting functions: 
<code><a href="#topic+extreme_format">extreme_format</a></code>,
<code><a href="#topic+format_auto">format_auto</a>()</code>,
<code><a href="#topic+format_count_fraction_fixed_dp">format_count_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_count_fraction_lt10">format_count_fraction_lt10</a>()</code>,
<code><a href="#topic+format_count_fraction">format_count_fraction</a>()</code>,
<code><a href="#topic+format_extreme_values_ci">format_extreme_values_ci</a>()</code>,
<code><a href="#topic+format_extreme_values">format_extreme_values</a>()</code>,
<code><a href="#topic+format_fraction_threshold">format_fraction_threshold</a>()</code>,
<code><a href="#topic+format_fraction">format_fraction</a>()</code>,
<code><a href="#topic+format_sigfig">format_sigfig</a>()</code>,
<code><a href="#topic+format_xx">format_xx</a>()</code>,
<code><a href="#topic+formatting_functions">formatting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_fraction_fixed_dp(x = c(num = 1L, denom = 2L))
format_fraction_fixed_dp(x = c(num = 1L, denom = 4L))
format_fraction_fixed_dp(x = c(num = 0L, denom = 3L))

</code></pre>

<hr>
<h2 id='format_fraction_threshold'>Formatting Fraction with Lower Threshold</h2><span id='topic+format_fraction_threshold'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Formats a fraction when the second element of the input <code>x</code> is the fraction. It applies
a lower threshold, below which it is just stated that the fraction is smaller than that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_fraction_threshold(threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_fraction_threshold_+3A_threshold">threshold</code></td>
<td>
<p>(<code>proportion</code>)<br /> lower threshold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>rtables</code> formatting function that takes numeric input <code>x</code> where the second
element is the fraction that is formatted. If the fraction is above or equal to the threshold,
then it is displayed in percentage. If it is positive but below the threshold, it returns,
e.g. &quot;&lt;1&quot; if the threshold is <code>0.01</code>. If it is zero, then just &quot;0&quot; is returned.
</p>


<h3>See Also</h3>

<p>Other formatting functions: 
<code><a href="#topic+extreme_format">extreme_format</a></code>,
<code><a href="#topic+format_auto">format_auto</a>()</code>,
<code><a href="#topic+format_count_fraction_fixed_dp">format_count_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_count_fraction_lt10">format_count_fraction_lt10</a>()</code>,
<code><a href="#topic+format_count_fraction">format_count_fraction</a>()</code>,
<code><a href="#topic+format_extreme_values_ci">format_extreme_values_ci</a>()</code>,
<code><a href="#topic+format_extreme_values">format_extreme_values</a>()</code>,
<code><a href="#topic+format_fraction_fixed_dp">format_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_fraction">format_fraction</a>()</code>,
<code><a href="#topic+format_sigfig">format_sigfig</a>()</code>,
<code><a href="#topic+format_xx">format_xx</a>()</code>,
<code><a href="#topic+formatting_functions">formatting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_fun &lt;- format_fraction_threshold(0.05)
format_fun(x = c(20, 0.1))
format_fun(x = c(2, 0.01))
format_fun(x = c(0, 0))

</code></pre>

<hr>
<h2 id='format_sigfig'>Formatting Numeric Values By Significant Figures</h2><span id='topic+format_sigfig'></span>

<h3>Description</h3>

<p>Format numeric values to print with a specified number of significant figures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_sigfig(sigfig, format = "xx", num_fmt = "fg")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_sigfig_+3A_sigfig">sigfig</code></td>
<td>
<p>(<code>integer</code>)<br /> number of significant figures to display.</p>
</td></tr>
<tr><td><code id="format_sigfig_+3A_format">format</code></td>
<td>
<p>(<code>character</code>)<br /> the format label (string) to apply when printing the value. Decimal
places in string are ignored in favor of formatting by significant figures. Formats options are:
<code>"xx"</code>, <code>"xx / xx"</code>, <code>"(xx, xx)"</code>, <code>"xx - xx"</code>, and <code>"xx (xx)"</code>.</p>
</td></tr>
<tr><td><code id="format_sigfig_+3A_num_fmt">num_fmt</code></td>
<td>
<p>(<code>character</code>)<br /> numeric format modifiers to apply to the value. Defaults to <code>"fg"</code> for
standard significant figures formatting - fixed (non-scientific notation) format (<code>"f"</code>)
and <code>sigfig</code> equal to number of significant figures instead of decimal places (<code>"g"</code>). See the
<code><a href="base.html#topic+formatC">formatC()</a></code> <code>format</code> argument for more options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>rtables</code> formatting function.
</p>


<h3>See Also</h3>

<p>Other formatting functions: 
<code><a href="#topic+extreme_format">extreme_format</a></code>,
<code><a href="#topic+format_auto">format_auto</a>()</code>,
<code><a href="#topic+format_count_fraction_fixed_dp">format_count_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_count_fraction_lt10">format_count_fraction_lt10</a>()</code>,
<code><a href="#topic+format_count_fraction">format_count_fraction</a>()</code>,
<code><a href="#topic+format_extreme_values_ci">format_extreme_values_ci</a>()</code>,
<code><a href="#topic+format_extreme_values">format_extreme_values</a>()</code>,
<code><a href="#topic+format_fraction_fixed_dp">format_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_fraction_threshold">format_fraction_threshold</a>()</code>,
<code><a href="#topic+format_fraction">format_fraction</a>()</code>,
<code><a href="#topic+format_xx">format_xx</a>()</code>,
<code><a href="#topic+formatting_functions">formatting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fmt_3sf &lt;- format_sigfig(3)
fmt_3sf(1.658)
fmt_3sf(1e1)

fmt_5sf &lt;- format_sigfig(5)
fmt_5sf(0.57)
fmt_5sf(0.000025645)

</code></pre>

<hr>
<h2 id='format_xx'>Formatting: XX as Formatting Function</h2><span id='topic+format_xx'></span>

<h3>Description</h3>

<p>Translate a string where x and dots are interpreted as number place
holders, and others as formatting elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_xx(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_xx_+3A_str">str</code></td>
<td>
<p>(<code>string</code>)<br /> template.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>rtables</code> formatting function.
</p>


<h3>See Also</h3>

<p>Other formatting functions: 
<code><a href="#topic+extreme_format">extreme_format</a></code>,
<code><a href="#topic+format_auto">format_auto</a>()</code>,
<code><a href="#topic+format_count_fraction_fixed_dp">format_count_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_count_fraction_lt10">format_count_fraction_lt10</a>()</code>,
<code><a href="#topic+format_count_fraction">format_count_fraction</a>()</code>,
<code><a href="#topic+format_extreme_values_ci">format_extreme_values_ci</a>()</code>,
<code><a href="#topic+format_extreme_values">format_extreme_values</a>()</code>,
<code><a href="#topic+format_fraction_fixed_dp">format_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_fraction_threshold">format_fraction_threshold</a>()</code>,
<code><a href="#topic+format_fraction">format_fraction</a>()</code>,
<code><a href="#topic+format_sigfig">format_sigfig</a>()</code>,
<code><a href="#topic+formatting_functions">formatting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- list(c(1.658, 0.5761), c(1e1, 785.6))

z &lt;- format_xx("xx (xx.x)")
sapply(test, z)

z &lt;- format_xx("xx.x - xx.x")
sapply(test, z)

z &lt;- format_xx("xx.x, incl. xx.x% NE")
sapply(test, z)

</code></pre>

<hr>
<h2 id='formatting_functions'>Formatting Functions</h2><span id='topic+formatting_functions'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>See below for the list of formatting functions created in <code>tern</code> to work with <code>rtables</code>.
</p>
<p>Other available formats can be listed via <code><a href="formatters.html#topic+list_formats">formatters::list_valid_format_labels()</a></code>. Additional
custom formats can be created via the <code><a href="formatters.html#topic+sprintf_format">formatters::sprintf_format()</a></code> function.
</p>


<h3>See Also</h3>

<p>Other formatting functions: 
<code><a href="#topic+extreme_format">extreme_format</a></code>,
<code><a href="#topic+format_auto">format_auto</a>()</code>,
<code><a href="#topic+format_count_fraction_fixed_dp">format_count_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_count_fraction_lt10">format_count_fraction_lt10</a>()</code>,
<code><a href="#topic+format_count_fraction">format_count_fraction</a>()</code>,
<code><a href="#topic+format_extreme_values_ci">format_extreme_values_ci</a>()</code>,
<code><a href="#topic+format_extreme_values">format_extreme_values</a>()</code>,
<code><a href="#topic+format_fraction_fixed_dp">format_fraction_fixed_dp</a>()</code>,
<code><a href="#topic+format_fraction_threshold">format_fraction_threshold</a>()</code>,
<code><a href="#topic+format_fraction">format_fraction</a>()</code>,
<code><a href="#topic+format_sigfig">format_sigfig</a>()</code>,
<code><a href="#topic+format_xx">format_xx</a>()</code>
</p>

<hr>
<h2 id='g_forest'>Create a Forest Plot based on a Table</h2><span id='topic+g_forest'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_forest(
  tbl,
  col_x = attr(tbl, "col_x"),
  col_ci = attr(tbl, "col_ci"),
  vline = 1,
  forest_header = attr(tbl, "forest_header"),
  xlim = c(0.1, 10),
  logx = TRUE,
  x_at = c(0.1, 1, 10),
  width_row_names = NULL,
  width_columns = NULL,
  width_forest = grid::unit(1, "null"),
  col_symbol_size = attr(tbl, "col_symbol_size"),
  col = getOption("ggplot2.discrete.colour")[1],
  gp = NULL,
  draw = TRUE,
  newpage = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_forest_+3A_tbl">tbl</code></td>
<td>
<p>(<code>rtable</code>)</p>
</td></tr>
<tr><td><code id="g_forest_+3A_col_x">col_x</code></td>
<td>
<p>(<code>integer</code>)<br /> column index with estimator. By default tries to get this from
<code>tbl</code> attribute <code>col_x</code>, otherwise needs to be manually specified.</p>
</td></tr>
<tr><td><code id="g_forest_+3A_col_ci">col_ci</code></td>
<td>
<p>(<code>integer</code>)<br /> column index with confidence intervals. By default tries
to get this from <code>tbl</code> attribute <code>col_ci</code>, otherwise needs to be manually specified.</p>
</td></tr>
<tr><td><code id="g_forest_+3A_vline">vline</code></td>
<td>
<p>(<code>number</code>)<br /> x coordinate for vertical line, if <code>NULL</code> then the line is omitted.</p>
</td></tr>
<tr><td><code id="g_forest_+3A_forest_header">forest_header</code></td>
<td>
<p>(<code>character</code>, length 2)<br /> text displayed to the left and right of <code>vline</code>, respectively.
If <code>vline = NULL</code> then <code>forest_header</code> needs to be <code>NULL</code> too.
By default tries to get this from <code>tbl</code> attribute <code>forest_header</code>.</p>
</td></tr>
<tr><td><code id="g_forest_+3A_xlim">xlim</code></td>
<td>
<p>(<code>numeric</code>)<br /> limits for x axis.</p>
</td></tr>
<tr><td><code id="g_forest_+3A_logx">logx</code></td>
<td>
<p>(<code>flag</code>)<br /> show the x-values on logarithm scale.</p>
</td></tr>
<tr><td><code id="g_forest_+3A_x_at">x_at</code></td>
<td>
<p>(<code>numeric</code>)<br /> x-tick locations, if <code>NULL</code> they get automatically chosen.</p>
</td></tr>
<tr><td><code id="g_forest_+3A_width_row_names">width_row_names</code></td>
<td>
<p>(<code>unit</code>)<br /> width for row names.
If <code>NULL</code> the widths get automatically calculated. See <code><a href="grid.html#topic+unit">grid::unit()</a></code>.</p>
</td></tr>
<tr><td><code id="g_forest_+3A_width_columns">width_columns</code></td>
<td>
<p>(<code>unit</code>)<br /> widths for the table columns.
If <code>NULL</code> the widths get automatically calculated. See <code><a href="grid.html#topic+unit">grid::unit()</a></code>.</p>
</td></tr>
<tr><td><code id="g_forest_+3A_width_forest">width_forest</code></td>
<td>
<p>(<code>unit</code>)<br /> width for the forest column.
If <code>NULL</code> the widths get automatically calculated. See <code><a href="grid.html#topic+unit">grid::unit()</a></code>.</p>
</td></tr>
<tr><td><code id="g_forest_+3A_col_symbol_size">col_symbol_size</code></td>
<td>
<p>(<code>integer</code>)<br /> column index from <code>tbl</code> containing data to be used
to determine relative size for estimator plot symbol. Typically, the symbol size is proportional
to the sample size used to calculate the estimator. If <code>NULL</code>, the same symbol size is used for all subgroups.
By default tries to get this from <code>tbl</code> attribute <code>col_symbol_size</code>, otherwise needs to be manually specified.</p>
</td></tr>
<tr><td><code id="g_forest_+3A_col">col</code></td>
<td>
<p>(<code>character</code>)<br /> color(s).</p>
</td></tr>
<tr><td><code id="g_forest_+3A_gp">gp</code></td>
<td>
<p>A <code>"gpar"</code> object, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="g_forest_+3A_draw">draw</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the plot should be drawn.</p>
</td></tr>
<tr><td><code id="g_forest_+3A_newpage">newpage</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the plot should be drawn on a new page.
Only considered if <code>draw = TRUE</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a forest plot from any <code><a href="rtables.html#topic+rtable">rtables::rtable()</a></code> object that has a
column with a single value and a column with 2 values.
</p>


<h3>Value</h3>

<p><code>gTree</code> object containing the forest plot and table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(forcats)
library(nestcolor)

adrs &lt;- tern_ex_adrs
n_records &lt;- 20
adrs_labels &lt;- formatters::var_labels(adrs, fill = TRUE)
adrs &lt;- adrs %&gt;%
  filter(PARAMCD == "BESRSPI") %&gt;%
  filter(ARM %in% c("A: Drug X", "B: Placebo")) %&gt;%
  slice(seq_len(n_records)) %&gt;%
  droplevels() %&gt;%
  mutate(
    # Reorder levels of factor to make the placebo group the reference arm.
    ARM = fct_relevel(ARM, "B: Placebo"),
    rsp = AVALC == "CR"
  )
formatters::var_labels(adrs) &lt;- c(adrs_labels, "Response")
df &lt;- extract_rsp_subgroups(
  variables = list(rsp = "rsp", arm = "ARM", subgroups = c("SEX", "STRATA2")),
  data = adrs
)
# Full commonly used response table.

tbl &lt;- basic_table() %&gt;%
  tabulate_rsp_subgroups(df)
p &lt;- g_forest(tbl, gp = grid::gpar(fontsize = 10))

draw_grob(p)

# Odds ratio only table.

tbl_or &lt;- basic_table() %&gt;%
  tabulate_rsp_subgroups(df, vars = c("n_tot", "or", "ci"))
tbl_or
p &lt;- g_forest(
  tbl_or,
  forest_header = c("Comparison\nBetter", "Treatment\nBetter")
)

draw_grob(p)

# Survival forest plot example.
adtte &lt;- tern_ex_adtte
# Save variable labels before data processing steps.
adtte_labels &lt;- formatters::var_labels(adtte, fill = TRUE)
adtte_f &lt;- adtte %&gt;%
  filter(
    PARAMCD == "OS",
    ARM %in% c("B: Placebo", "A: Drug X"),
    SEX %in% c("M", "F")
  ) %&gt;%
  mutate(
    # Reorder levels of ARM to display reference arm before treatment arm.
    ARM = droplevels(fct_relevel(ARM, "B: Placebo")),
    SEX = droplevels(SEX),
    AVALU = as.character(AVALU),
    is_event = CNSR == 0
  )
labels &lt;- list(
  "ARM" = adtte_labels["ARM"],
  "SEX" = adtte_labels["SEX"],
  "AVALU" = adtte_labels["AVALU"],
  "is_event" = "Event Flag"
)
formatters::var_labels(adtte_f)[names(labels)] &lt;- as.character(labels)
df &lt;- extract_survival_subgroups(
  variables = list(
    tte = "AVAL",
    is_event = "is_event",
    arm = "ARM", subgroups = c("SEX", "BMRKR2")
  ),
  data = adtte_f
)
table_hr &lt;- basic_table() %&gt;%
  tabulate_survival_subgroups(df, time_unit = adtte_f$AVALU[1])
g_forest(table_hr)
# Works with any `rtable`.
tbl &lt;- rtable(
  header = c("E", "CI", "N"),
  rrow("", 1, c(.8, 1.2), 200),
  rrow("", 1.2, c(1.1, 1.4), 50)
)
g_forest(
  tbl = tbl,
  col_x = 1,
  col_ci = 2,
  xlim = c(0.5, 2),
  x_at = c(0.5, 1, 2),
  col_symbol_size = 3
)
tbl &lt;- rtable(
  header = rheader(
    rrow("", rcell("A", colspan = 2)),
    rrow("", "c1", "c2")
  ),
  rrow("row 1", 1, c(.8, 1.2)),
  rrow("row 2", 1.2, c(1.1, 1.4))
)
g_forest(
  tbl = tbl,
  col_x = 1,
  col_ci = 2,
  xlim = c(0.5, 2),
  x_at = c(0.5, 1, 2),
  vline = 1,
  forest_header = c("Hello", "World")
)


</code></pre>

<hr>
<h2 id='g_km'>Kaplan-Meier Plot</h2><span id='topic+g_km'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>From a survival model, a graphic is rendered along with tabulated annotation
including the number of patient at risk at given time and the median survival
per group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_km(
  df,
  variables,
  control_surv = control_surv_timepoint(),
  col = NULL,
  lty = NULL,
  lwd = 0.5,
  censor_show = TRUE,
  pch = 3,
  size = 2,
  max_time = NULL,
  xticks = NULL,
  xlab = "Days",
  yval = c("Survival", "Failure"),
  ylab = paste(yval, "Probability"),
  ylim = NULL,
  title = NULL,
  footnotes = NULL,
  draw = TRUE,
  newpage = TRUE,
  gp = NULL,
  vp = NULL,
  name = NULL,
  font_size = 12,
  ci_ribbon = FALSE,
  ggtheme = nestcolor::theme_nest(),
  annot_at_risk = TRUE,
  annot_at_risk_title = TRUE,
  annot_surv_med = TRUE,
  annot_coxph = FALSE,
  annot_stats = NULL,
  annot_stats_vlines = FALSE,
  control_coxph_pw = control_coxph(),
  ref_group_coxph = NULL,
  annot_coxph_ref_lbls = FALSE,
  position_coxph = c(-0.03, -0.02),
  position_surv_med = c(0.95, 0.9),
  width_annots = list(surv_med = grid::unit(0.3, "npc"), coxph = grid::unit(0.4, "npc"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_km_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="g_km_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code>)<br /> variable names. Details are:
</p>

<ul>
<li> <p><code>tte</code> (<code>numeric</code>)<br /> variable indicating time-to-event duration values.
</p>
</li>
<li> <p><code>is_event</code> (<code>logical</code>)<br /> event variable. <code>TRUE</code> if event, <code>FALSE</code> if time to event is censored.
</p>
</li>
<li> <p><code>arm</code> (<code>factor</code>)<br /> the treatment group variable.
</p>
</li>
<li> <p><code>strat</code> (<code>character</code> or <code>NULL</code>)<br /> variable names indicating stratification factors.
</p>
</li></ul>
</td></tr>
<tr><td><code id="g_km_+3A_control_surv">control_surv</code></td>
<td>
<p>(<code>list</code>)<br /> parameters for comparison details, specified by using
the helper function <code><a href="#topic+control_surv_timepoint">control_surv_timepoint()</a></code>. Some possible parameter options are:
</p>

<ul>
<li> <p><code>conf_level</code> (<code>proportion</code>)<br /> confidence level of the interval for survival rate.
</p>
</li>
<li> <p><code>conf_type</code> (<code>string</code>)<br /> <code>"plain"</code> (default), <code>"log"</code>, <code>"log-log"</code> for confidence interval type,
see more in <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>. Note that the option &quot;none&quot; is no longer supported.
</p>
</li></ul>
</td></tr>
<tr><td><code id="g_km_+3A_col">col</code></td>
<td>
<p>(<code>character</code>)<br /> lines colors. Length of a vector should be equal
to number of strata from <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>.</p>
</td></tr>
<tr><td><code id="g_km_+3A_lty">lty</code></td>
<td>
<p>(<code>numeric</code>)<br /> line type. Length of a vector should be equal
to number of strata from <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>.</p>
</td></tr>
<tr><td><code id="g_km_+3A_lwd">lwd</code></td>
<td>
<p>(<code>numeric</code>)<br /> line width. Length of a vector should be equal
to number of strata from <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>.</p>
</td></tr>
<tr><td><code id="g_km_+3A_censor_show">censor_show</code></td>
<td>
<p>(<code>flag</code>)<br /> whether to show censored.</p>
</td></tr>
<tr><td><code id="g_km_+3A_pch">pch</code></td>
<td>
<p>(<code>numeric</code>, <code>string</code>)<br /> value or character of points symbol to indicate censored cases.</p>
</td></tr>
<tr><td><code id="g_km_+3A_size">size</code></td>
<td>
<p>(<code>numeric</code>)<br /> size of censored point, a class of <code>unit</code>.</p>
</td></tr>
<tr><td><code id="g_km_+3A_max_time">max_time</code></td>
<td>
<p>(<code>numeric</code>)<br /> maximum value to show on X axis. Only data values less than or up to
this threshold value will be plotted (defaults to <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="g_km_+3A_xticks">xticks</code></td>
<td>
<p>(<code>numeric</code>, <code>number</code>, or <code>NULL</code>)<br /> numeric vector of ticks or single number with spacing
between ticks on the x axis. If <code>NULL</code> (default), <code><a href="labeling.html#topic+extended">labeling::extended()</a></code> is used to determine
an optimal tick position on the x axis.</p>
</td></tr>
<tr><td><code id="g_km_+3A_xlab">xlab</code></td>
<td>
<p>(<code>string</code>)<br /> label of x-axis.</p>
</td></tr>
<tr><td><code id="g_km_+3A_yval">yval</code></td>
<td>
<p>(<code>string</code>)<br /> value of y-axis. Options are <code>Survival</code> (default) and <code>Failure</code> probability.</p>
</td></tr>
<tr><td><code id="g_km_+3A_ylab">ylab</code></td>
<td>
<p>(<code>string</code>)<br /> label of y-axis.</p>
</td></tr>
<tr><td><code id="g_km_+3A_ylim">ylim</code></td>
<td>
<p>(<code>vector</code> of <code>numeric</code>)<br /> vector of length 2 containing lower and upper limits for the y-axis.
If <code>NULL</code> (default), the minimum and maximum y-values displayed are used as limits.</p>
</td></tr>
<tr><td><code id="g_km_+3A_title">title</code></td>
<td>
<p>(<code>string</code>)<br /> title for plot.</p>
</td></tr>
<tr><td><code id="g_km_+3A_footnotes">footnotes</code></td>
<td>
<p>(<code>string</code>)<br /> footnotes for plot.</p>
</td></tr>
<tr><td><code id="g_km_+3A_draw">draw</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the plot should be drawn.</p>
</td></tr>
<tr><td><code id="g_km_+3A_newpage">newpage</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the plot should be drawn on a new page.
Only considered if <code>draw = TRUE</code> is used.</p>
</td></tr>
<tr><td><code id="g_km_+3A_gp">gp</code></td>
<td>
<p>A <code>"gpar"</code> object, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="g_km_+3A_vp">vp</code></td>
<td>
<p>a <code><a href="grid.html#topic+viewport">viewport</a></code> object (or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="g_km_+3A_name">name</code></td>
<td>
<p>a character identifier for the grob.  Used to find the
grob on the display list and/or as a child of another grob. </p>
</td></tr>
<tr><td><code id="g_km_+3A_font_size">font_size</code></td>
<td>
<p>(<code>number</code>)<br /> font size to be used.</p>
</td></tr>
<tr><td><code id="g_km_+3A_ci_ribbon">ci_ribbon</code></td>
<td>
<p>(<code>flag</code>)<br /> draw the confidence interval around the Kaplan-Meier curve.</p>
</td></tr>
<tr><td><code id="g_km_+3A_ggtheme">ggtheme</code></td>
<td>
<p>(<code>theme</code>)<br /> a graphical theme as provided by <code>ggplot2</code> to control outlook of the Kaplan-Meier curve.</p>
</td></tr>
<tr><td><code id="g_km_+3A_annot_at_risk">annot_at_risk</code></td>
<td>
<p>(<code>flag</code>)<br /> compute and add the annotation table reporting the number of patient at risk
matching the main grid of the Kaplan-Meier curve.</p>
</td></tr>
<tr><td><code id="g_km_+3A_annot_at_risk_title">annot_at_risk_title</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the &quot;Patients at Risk&quot; title should be added above the <code>annot_at_risk</code>
table. Has no effect if <code>annot_at_risk</code> is <code>FALSE</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="g_km_+3A_annot_surv_med">annot_surv_med</code></td>
<td>
<p>(<code>flag</code>)<br /> compute and add the annotation table on the Kaplan-Meier curve estimating the
median survival time per group.</p>
</td></tr>
<tr><td><code id="g_km_+3A_annot_coxph">annot_coxph</code></td>
<td>
<p>(<code>flag</code>)<br /> add the annotation table from a <code><a href="survival.html#topic+coxph">survival::coxph()</a></code> model.</p>
</td></tr>
<tr><td><code id="g_km_+3A_annot_stats">annot_stats</code></td>
<td>
<p>(<code>string</code>)<br /> statistics annotations to add to the plot. Options are
<code>median</code> (median survival follow-up time) and <code>min</code> (minimum survival follow-up time).</p>
</td></tr>
<tr><td><code id="g_km_+3A_annot_stats_vlines">annot_stats_vlines</code></td>
<td>
<p>(<code>flag</code>)<br /> add vertical lines corresponding to each of the statistics
specified by <code>annot_stats</code>. If <code>annot_stats</code> is <code>NULL</code> no lines will be added.</p>
</td></tr>
<tr><td><code id="g_km_+3A_control_coxph_pw">control_coxph_pw</code></td>
<td>
<p>(<code>list</code>)<br /> parameters for comparison details, specified by using
the helper function <code><a href="#topic+control_coxph">control_coxph()</a></code>. Some possible parameter options are:
</p>

<ul>
<li> <p><code>pval_method</code> (<code>string</code>)<br /> p-value method for testing hazard ratio = 1.
Default method is <code>"log-rank"</code>, can also be set to <code>"wald"</code> or <code>"likelihood"</code>.
</p>
</li>
<li> <p><code>ties</code> (<code>string</code>)<br /> method for tie handling. Default is <code>"efron"</code>,
can also be set to <code>"breslow"</code> or <code>"exact"</code>. See more in <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>
</p>
</li>
<li> <p><code>conf_level</code> (<code>proportion</code>)<br /> confidence level of the interval for HR.
</p>
</li></ul>
</td></tr>
<tr><td><code id="g_km_+3A_ref_group_coxph">ref_group_coxph</code></td>
<td>
<p>(<code>character</code>)<br /> level of arm variable to use as reference group in calculations for
<code>annot_coxph</code> table. If <code>NULL</code> (default), uses the first level of the arm variable.</p>
</td></tr>
<tr><td><code id="g_km_+3A_annot_coxph_ref_lbls">annot_coxph_ref_lbls</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the reference group should be explicitly printed in labels for the
<code>annot_coxph</code> table. If <code>FALSE</code> (default), only comparison groups will be printed in <code>annot_coxph</code> table labels.</p>
</td></tr>
<tr><td><code id="g_km_+3A_position_coxph">position_coxph</code></td>
<td>
<p>(<code>numeric</code>)<br /> x and y positions for plotting <code><a href="survival.html#topic+coxph">survival::coxph()</a></code> model.</p>
</td></tr>
<tr><td><code id="g_km_+3A_position_surv_med">position_surv_med</code></td>
<td>
<p>(<code>numeric</code>)<br /> x and y positions for plotting annotation table estimating median survival
time per group.</p>
</td></tr>
<tr><td><code id="g_km_+3A_width_annots">width_annots</code></td>
<td>
<p>(named <code>list</code> of <code>unit</code>s)<br /> a named list of widths for annotation tables with names <code>surv_med</code>
(median survival time table) and <code>coxph</code> (<code><a href="survival.html#topic+coxph">survival::coxph()</a></code> model table), where each value is the width
(in units) to implement when printing the annotation table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>grob</code> of class <code>gTree</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)
library(survival)
library(grid)
library(nestcolor)

df &lt;- tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  mutate(is_event = CNSR == 0)
variables &lt;- list(tte = "AVAL", is_event = "is_event", arm = "ARMCD")

# 1. Example - basic option

res &lt;- g_km(df = df, variables = variables)
res &lt;- g_km(df = df, variables = variables, yval = "Failure")
res &lt;- g_km(
  df = df,
  variables = variables,
  control_surv = control_surv_timepoint(conf_level = 0.9),
  col = c("grey25", "grey50", "grey75"),
  annot_at_risk_title = FALSE
)
res &lt;- g_km(df = df, variables = variables, ggtheme = theme_minimal())
res &lt;- g_km(df = df, variables = variables, ggtheme = theme_minimal(), lty = 1:3)
res &lt;- g_km(df = df, variables = variables, max = 2000)
res &lt;- g_km(
  df = df,
  variables = variables,
  annot_stats = c("min", "median"),
  annot_stats_vlines = TRUE
)

# 2. Example - Arrange several KM curve on a single graph device

# 2.1 Use case: A general graph on the top, a zoom on the bottom.
grid.newpage()
lyt &lt;- grid.layout(nrow = 2, ncol = 1) %&gt;%
  viewport(layout = .) %&gt;%
  pushViewport()

res &lt;- g_km(
  df = df, variables = variables, newpage = FALSE, annot_surv_med = FALSE,
  vp = viewport(layout.pos.row = 1, layout.pos.col = 1)
)
res &lt;- g_km(
  df = df, variables = variables, max = 1000, newpage = FALSE, annot_surv_med = FALSE,
  ggtheme = theme_dark(),
  vp = viewport(layout.pos.row = 2, layout.pos.col = 1)
)

# 2.1 Use case: No annotations on top, annotated graph on bottom
grid.newpage()
lyt &lt;- grid.layout(nrow = 2, ncol = 1) %&gt;%
  viewport(layout = .) %&gt;%
  pushViewport()

res &lt;- g_km(
  df = df, variables = variables, newpage = FALSE,
  annot_surv_med = FALSE, annot_at_risk = FALSE,
  vp = viewport(layout.pos.row = 1, layout.pos.col = 1)
)
res &lt;- g_km(
  df = df, variables = variables, max = 2000, newpage = FALSE, annot_surv_med = FALSE,
  annot_at_risk = TRUE,
  ggtheme = theme_dark(),
  vp = viewport(layout.pos.row = 2, layout.pos.col = 1)
)

# Add annotation from a pairwise coxph analysis
g_km(
  df = df, variables = variables,
  annot_coxph = TRUE
)

# Change widths/sizes of surv_med and coxph annotation tables.
g_km(
  df = df, variables = c(variables, list(strat = "SEX")),
  annot_coxph = TRUE,
  width_annots = list(surv_med = grid::unit(2, "in"), coxph = grid::unit(3, "in"))
)

g_km(
  df = df, variables = c(variables, list(strat = "SEX")),
  font_size = 15,
  annot_coxph = TRUE,
  control_coxph = control_coxph(pval_method = "wald", ties = "exact", conf_level = 0.99),
  position_coxph = c(0.5, 0.5)
)

# Change position of the treatment group annotation table.
g_km(
  df = df, variables = c(variables, list(strat = "SEX")),
  font_size = 15,
  annot_coxph = TRUE,
  control_coxph = control_coxph(pval_method = "wald", ties = "exact", conf_level = 0.99),
  position_surv_med = c(1, 0.7)
)


</code></pre>

<hr>
<h2 id='g_lineplot'>Line plot with the optional table</h2><span id='topic+g_lineplot'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Line plot with the optional table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_lineplot(
  df,
  alt_counts_df = NULL,
  variables = control_lineplot_vars(),
  mid = "mean",
  interval = "mean_ci",
  whiskers = c("mean_ci_lwr", "mean_ci_upr"),
  table = NULL,
  sfun = tern::s_summary,
  ...,
  mid_type = "pl",
  mid_point_size = 2,
  position = ggplot2::position_dodge(width = 0.4),
  legend_title = NULL,
  legend_position = "bottom",
  ggtheme = nestcolor::theme_nest(),
  x_lab = obj_label(df[[variables[["x"]]]]),
  y_lab = NULL,
  y_lab_add_paramcd = TRUE,
  y_lab_add_unit = TRUE,
  title = "Plot of Mean and 95% Confidence Limits by Visit",
  subtitle = "",
  subtitle_add_paramcd = TRUE,
  subtitle_add_unit = TRUE,
  caption = NULL,
  table_format = summary_formats(),
  table_labels = summary_labels(),
  table_font_size = 3,
  newpage = TRUE,
  col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_lineplot_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_alt_counts_df">alt_counts_df</code></td>
<td>
<p>(<code>data.frame</code> or <code>NULL</code>)<br /> data set that will be used (only)
to counts objects in groups for stratification.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_variables">variables</code></td>
<td>
<p>(named <code>character</code> vector) of variable names in <code>df</code> data set. Details are:
</p>

<ul>
<li> <p><code>x</code> (<code>character</code>)<br /> name of x-axis variable.
</p>
</li>
<li> <p><code>y</code> (<code>character</code>)<br /> name of y-axis variable.
</p>
</li>
<li> <p><code>group_var</code> (<code>character</code>)<br /> name of grouping variable (or strata), i.e. treatment arm.
Can be <code>NA</code> to indicate lack of groups.
</p>
</li>
<li> <p><code>subject_var</code> (<code>character</code>)<br /> name of subject variable. Only applies if <code>group_var</code> is
not NULL.
</p>
</li>
<li> <p><code>paramcd</code> (<code>character</code>)<br /> name of the variable for parameter's code. Used for y-axis label and plot's subtitle.
Can be <code>NA</code> if <code>paramcd</code> is not to be added to the y-axis label or subtitle.
</p>
</li>
<li> <p><code>y_unit</code> (<code>character</code>)<br /> name of variable with units of <code>y</code>. Used for y-axis label and plot's subtitle.
Can be <code>NA</code> if y unit is not to be added to the y-axis label or subtitle.
</p>
</li></ul>
</td></tr>
<tr><td><code id="g_lineplot_+3A_mid">mid</code></td>
<td>
<p>(<code>character</code> or <code>NULL</code>)<br /> names of the statistics that will be plotted as midpoints.
All the statistics indicated in <code>mid</code> variable must be present in the object returned by <code>sfun</code>,
and be of a <code>double</code> or <code>numeric</code> type vector of length one.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_interval">interval</code></td>
<td>
<p>(<code>character</code> or <code>NULL</code>)<br /> names of the statistics that will be plotted as intervals.
All the statistics indicated in <code>interval</code> variable must be present in the object returned by <code>sfun</code>,
and be of a <code>double</code> or <code>numeric</code> type vector of length two. Set <code>interval = NULL</code> if intervals should not be
added to the plot.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_whiskers">whiskers</code></td>
<td>
<p>(<code>character</code>)<br /> names of the interval whiskers that will be plotted. Names must match names
of the list element <code>interval</code> that will be returned by <code>sfun</code> (e.g. <code>mean_ci_lwr</code> element of
<code>sfun(x)[["mean_ci"]]</code>). It is possible to specify one whisker only, or to suppress all whiskers by setting
<code>interval = NULL</code>.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_table">table</code></td>
<td>
<p>(<code>character</code> or <code>NULL</code>)<br /> names of the statistics that will be displayed in the table below the plot.
All the statistics indicated in <code>table</code> variable must be present in the object returned by <code>sfun</code>.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_sfun">sfun</code></td>
<td>
<p>(<code>closure</code>)<br /> the function to compute the values of required statistics. It must return a named <code>list</code>
with atomic vectors. The names of the <code>list</code> elements refer to the names of the statistics and are used by <code>mid</code>,
<code>interval</code>, <code>table</code>. It must be able to accept as input a vector with data for which statistics are computed.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>sfun</code>.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_mid_type">mid_type</code></td>
<td>
<p>(<code>character</code>)<br /> controls the type of the <code>mid</code> plot, it can be point (<code>p</code>), line (<code>l</code>),
or point and line (<code>pl</code>).</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_mid_point_size">mid_point_size</code></td>
<td>
<p>(<code>integer</code> or <code>double</code>)<br /> controls the font size of the point for <code>mid</code> plot.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_position">position</code></td>
<td>
<p>(<code>character</code> or <code>call</code>)<br /> geom element position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_legend_title">legend_title</code></td>
<td>
<p>(<code>character</code> string)<br /> legend title.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_legend_position">legend_position</code></td>
<td>
<p>(<code>character</code>)<br /> the position of the plot legend (<code>none</code>, <code>left</code>, <code>right</code>, <code>bottom</code>, <code>top</code>,
or two-element numeric vector).</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_ggtheme">ggtheme</code></td>
<td>
<p>(<code>theme</code>)<br /> a graphical theme as provided by <code>ggplot2</code> to control styling of the plot.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_x_lab">x_lab</code></td>
<td>
<p>(<code>character</code>)<br /> x-axis label. If equal to <code>NULL</code>, then no label will be added.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_y_lab">y_lab</code></td>
<td>
<p>(<code>character</code>)<br /> y-axis label. If equal to <code>NULL</code>, then no label will be added.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_y_lab_add_paramcd">y_lab_add_paramcd</code></td>
<td>
<p>(<code>logical</code>)<br /> should <code>paramcd</code>, i.e. <code>unique(df[[variables["paramcd"]]])</code> be added to the
y-axis label <code>y_lab</code>?</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_y_lab_add_unit">y_lab_add_unit</code></td>
<td>
<p>(<code>logical</code>)<br /> should y unit, i.e. <code>unique(df[[variables["y_unit"]]])</code> be added to the y-axis
label <code>y_lab</code>?</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_title">title</code></td>
<td>
<p>(<code>character</code>)<br /> plot title.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_subtitle">subtitle</code></td>
<td>
<p>(<code>character</code>)<br /> plot subtitle.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_subtitle_add_paramcd">subtitle_add_paramcd</code></td>
<td>
<p>(<code>logical</code>)<br /> should <code>paramcd</code>, i.e. <code>unique(df[[variables["paramcd"]]])</code> be added to
the plot's subtitle <code>subtitle</code>?</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_subtitle_add_unit">subtitle_add_unit</code></td>
<td>
<p>(<code>logical</code>)<br /> should y unit, i.e. <code>unique(df[[variables["y_unit"]]])</code> be added to the
plot's subtitle <code>subtitle</code>?</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_caption">caption</code></td>
<td>
<p>(<code>character</code>)<br /> optional caption below the plot.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_table_format">table_format</code></td>
<td>
<p>(named <code>character</code> or <code>NULL</code>)<br /> format patterns for descriptive statistics used in the
(optional) table appended to the plot. It is passed directly to the <code>h_format_row</code> function through the <code>format</code>
parameter. Names of <code>table_format</code> must match the names of statistics returned by <code>sfun</code> function.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_table_labels">table_labels</code></td>
<td>
<p>(named <code>character</code> or <code>NULL</code>)<br /> labels for descriptive statistics used in the (optional) table
appended to the plot. Names of <code>table_labels</code> must match the names of statistics returned by <code>sfun</code> function.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_table_font_size">table_font_size</code></td>
<td>
<p>(<code>integer</code> or <code>double</code>)<br /> controls the font size of values in the table.</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_newpage">newpage</code></td>
<td>
<p>(<code>logical</code>)<br /> should plot be drawn on new page?</p>
</td></tr>
<tr><td><code id="g_lineplot_+3A_col">col</code></td>
<td>
<p>(<code>character</code>)<br /> colors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> line plot (and statistics table if applicable).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nestcolor)

adsl &lt;- tern_ex_adsl
adlb &lt;- tern_ex_adlb %&gt;% dplyr::filter(ANL01FL == "Y", PARAMCD == "ALT", AVISIT != "SCREENING")
adlb$AVISIT &lt;- droplevels(adlb$AVISIT)
adlb &lt;- dplyr::mutate(adlb, AVISIT = forcats::fct_reorder(AVISIT, AVISITN, min))

# Mean with CI
g_lineplot(adlb, adsl, subtitle = "Laboratory Test:")

# Mean with CI, no stratification with group_var
g_lineplot(adlb, variables = control_lineplot_vars(group_var = NA))

# Mean, upper whisker of CI, no group_var(strata) counts N
g_lineplot(
  adlb,
  whiskers = "mean_ci_upr",
  title = "Plot of Mean and Upper 95% Confidence Limit by Visit"
)

# Median with CI
g_lineplot(
  adlb,
  adsl,
  mid = "median",
  interval = "median_ci",
  whiskers = c("median_ci_lwr", "median_ci_upr"),
  title = "Plot of Median and 95% Confidence Limits by Visit"
)

# Mean, +/- SD
g_lineplot(adlb, adsl,
  interval = "mean_sdi",
  whiskers = c("mean_sdi_lwr", "mean_sdi_upr"),
  title = "Plot of Median +/- SD by Visit"
)

# Mean with CI plot with stats table
g_lineplot(adlb, adsl, table = c("n", "mean", "mean_ci"))

# Mean with CI, table and customized confidence level
g_lineplot(
  adlb,
  adsl,
  table = c("n", "mean", "mean_ci"),
  control = control_analyze_vars(conf_level = 0.80),
  title = "Plot of Mean and 80% Confidence Limits by Visit"
)

# Mean with CI, table, filtered data
adlb_f &lt;- dplyr::filter(adlb, ARMCD != "ARM A" | AVISIT == "BASELINE")
g_lineplot(adlb_f, table = c("n", "mean"))

</code></pre>

<hr>
<h2 id='g_step'>Create a STEP Graph</h2><span id='topic+g_step'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Based on the STEP results, creates a <code>ggplot</code> graph showing the estimated HR or OR
along the continuous biomarker value subgroups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_step(
  df,
  use_percentile = "Percentile Center" %in% names(df),
  est = list(col = "blue", lty = 1),
  ci_ribbon = list(fill = getOption("ggplot2.discrete.colour")[1], alpha = 0.5),
  col = getOption("ggplot2.discrete.colour")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_step_+3A_df">df</code></td>
<td>
<p>(<code>tibble</code>)<br /> result of <code><a href="#topic+tidy.step">tidy.step()</a></code>.</p>
</td></tr>
<tr><td><code id="g_step_+3A_use_percentile">use_percentile</code></td>
<td>
<p>(<code>flag</code>)<br /> whether to use percentiles for the x axis or actual
biomarker values.</p>
</td></tr>
<tr><td><code id="g_step_+3A_est">est</code></td>
<td>
<p>(named <code>list</code>)<br /> <code>col</code> and <code>lty</code> settings for estimate line.</p>
</td></tr>
<tr><td><code id="g_step_+3A_ci_ribbon">ci_ribbon</code></td>
<td>
<p>(named <code>list</code> or <code>NULL</code>)<br /> <code>fill</code> and <code>alpha</code> settings for the confidence interval
ribbon area, or <code>NULL</code> to not plot a CI ribbon.</p>
</td></tr>
<tr><td><code id="g_step_+3A_col">col</code></td>
<td>
<p>(<code>character</code>)<br /> colors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> STEP graph.
</p>


<h3>See Also</h3>

<p>Custom tidy method <code><a href="#topic+tidy.step">tidy.step()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nestcolor)
library(survival)
lung$sex &lt;- factor(lung$sex)

# Survival example.
vars &lt;- list(
  time = "time",
  event = "status",
  arm = "sex",
  biomarker = "age"
)

step_matrix &lt;- fit_survival_step(
  variables = vars,
  data = lung,
  control = c(control_coxph(), control_step(num_points = 10, degree = 2))
)
step_data &lt;- broom::tidy(step_matrix)

# Default plot.
g_step(step_data)

# Add the reference 1 horizontal line.
library(ggplot2)
g_step(step_data) +
  ggplot2::geom_hline(ggplot2::aes(yintercept = 1), linetype = 2)

# Use actual values instead of percentiles, different color for estimate and no CI,
# use log scale for y axis.
g_step(
  step_data,
  use_percentile = FALSE,
  est = list(col = "blue", lty = 1),
  ci_ribbon = NULL
) + scale_y_log10()

# Adding another curve based on additional column.
step_data$extra &lt;- exp(step_data$`Percentile Center`)
g_step(step_data) +
  ggplot2::geom_line(ggplot2::aes(y = extra), linetype = 2, color = "green")

# Response example.
vars &lt;- list(
  response = "status",
  arm = "sex",
  biomarker = "age"
)

step_matrix &lt;- fit_rsp_step(
  variables = vars,
  data = lung,
  control = c(
    control_logistic(response_definition = "I(response == 2)"),
    control_step()
  )
)
step_data &lt;- broom::tidy(step_matrix)
g_step(step_data)

</code></pre>

<hr>
<h2 id='g_waterfall'>Horizontal Waterfall Plot</h2><span id='topic+g_waterfall'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_waterfall(
  height,
  id,
  col_var = NULL,
  col = getOption("ggplot2.discrete.colour"),
  xlab = NULL,
  ylab = NULL,
  col_legend_title = NULL,
  title = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_waterfall_+3A_height">height</code></td>
<td>
<p>('numeric&ldquo;)<br /> vector containing values to be plotted as the waterfall bars.</p>
</td></tr>
<tr><td><code id="g_waterfall_+3A_id">id</code></td>
<td>
<p>(<code>character</code>)<br /> vector containing IDs to use as the x-axis label for the waterfall bars.</p>
</td></tr>
<tr><td><code id="g_waterfall_+3A_col_var">col_var</code></td>
<td>
<p>(<code>factor</code>, <code>character</code> or <code>NULL</code>)<br /> categorical variable for bar coloring. <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="g_waterfall_+3A_col">col</code></td>
<td>
<p>(<code>character</code>)<br /> colors.</p>
</td></tr>
<tr><td><code id="g_waterfall_+3A_xlab">xlab</code></td>
<td>
<p>(<code>character</code>)<br /> x label. Default is <code>"ID"</code>.</p>
</td></tr>
<tr><td><code id="g_waterfall_+3A_ylab">ylab</code></td>
<td>
<p>(<code>character</code>)<br /> y label. Default is <code>"Value"</code>.</p>
</td></tr>
<tr><td><code id="g_waterfall_+3A_col_legend_title">col_legend_title</code></td>
<td>
<p>(<code>character</code>)<br /> text to be displayed as legend title.</p>
</td></tr>
<tr><td><code id="g_waterfall_+3A_title">title</code></td>
<td>
<p>(<code>character</code>)<br /> text to be displayed as plot title.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This basic waterfall plot visualizes a quantity <code>height</code> ordered by value with some markup.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> waterfall plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(nestcolor)

g_waterfall(height = c(3, 5, -1), id = letters[1:3])

g_waterfall(
  height = c(3, 5, -1),
  id = letters[1:3],
  col_var = letters[1:3]
)

adsl_f &lt;- tern_ex_adsl %&gt;%
  select(USUBJID, STUDYID, ARM, ARMCD, SEX)

adrs_f &lt;- tern_ex_adrs %&gt;%
  filter(PARAMCD == "OVRINV") %&gt;%
  mutate(pchg = rnorm(n(), 10, 50))

adrs_f &lt;- head(adrs_f, 30)
adrs_f &lt;- adrs_f[!duplicated(adrs_f$USUBJID), ]
head(adrs_f)

g_waterfall(
  height = adrs_f$pchg,
  id = adrs_f$USUBJID,
  col_var = adrs_f$AVALC
)

g_waterfall(
  height = adrs_f$pchg,
  id = paste("asdfdsfdsfsd", adrs_f$USUBJID),
  col_var = adrs_f$SEX
)

g_waterfall(
  height = adrs_f$pchg,
  id = paste("asdfdsfdsfsd", adrs_f$USUBJID),
  xlab = "ID",
  ylab = "Percentage Change",
  title = "Waterfall plot"
)

</code></pre>

<hr>
<h2 id='get_covariates'>Utility function to return a named list of covariate names.</h2><span id='topic+get_covariates'></span>

<h3>Description</h3>

<p>Utility function to return a named list of covariate names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_covariates(covariates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_covariates_+3A_covariates">covariates</code></td>
<td>
<p>(<code>character</code>)<br /> a vector that can contain single variable names (such as
<code>"X1"</code>), and/or interaction terms indicated by <code>"X1 * X2"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code> of <code>character</code> vector.
</p>

<hr>
<h2 id='get_smooths'>Smooth Function with Optional Grouping</h2><span id='topic+get_smooths'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This produces <code>loess</code> smoothed estimates of <code>y</code> with Student confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_smooths(df, x, y, groups = NULL, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_smooths_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="get_smooths_+3A_x">x</code></td>
<td>
<p>(<code>character</code>)<br /> value with x column name.</p>
</td></tr>
<tr><td><code id="get_smooths_+3A_y">y</code></td>
<td>
<p>(<code>character</code>)<br /> value with y column name.</p>
</td></tr>
<tr><td><code id="get_smooths_+3A_groups">groups</code></td>
<td>
<p>(<code>character</code>)<br /> vector with optional grouping variables names.</p>
</td></tr>
<tr><td><code id="get_smooths_+3A_level">level</code></td>
<td>
<p>(<code>numeric</code>)<br /> level of confidence interval to use (0.95 by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with original <code>x</code>, smoothed <code>y</code>, <code>ylow</code>, and <code>yhigh</code>, and
optional <code>groups</code> variables formatted as <code>factor</code> type.
</p>

<hr>
<h2 id='groups_list_to_df'>Convert List of Groups to Data Frame</h2><span id='topic+groups_list_to_df'></span>

<h3>Description</h3>

<p>This converts a list of group levels into a data frame format which is expected by <code><a href="rtables.html#topic+add_combo_levels">rtables::add_combo_levels()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groups_list_to_df(groups_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groups_list_to_df_+3A_groups_list">groups_list</code></td>
<td>
<p>(named <code>list</code> of <code>character</code>)<br /> specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> in the required format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grade_groups &lt;- list(
  "Any Grade (%)" = c("1", "2", "3", "4", "5"),
  "Grade 3-4 (%)" = c("3", "4"),
  "Grade 5 (%)" = "5"
)
groups_list_to_df(grade_groups)

</code></pre>

<hr>
<h2 id='h_adlb_abnormal_by_worst_grade'>Helper function to prepare <code>ADLB</code> for <code><a href="#topic+count_abnormal_by_worst_grade">count_abnormal_by_worst_grade()</a></code></h2><span id='topic+h_adlb_abnormal_by_worst_grade'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper function to prepare an <code>ADLB</code> data frame to be used as input in
<code><a href="#topic+count_abnormal_by_worst_grade">count_abnormal_by_worst_grade()</a></code>. The following pre-processing steps are applied:
</p>

<ol>
<li> <p><code>adlb</code> is filtered on variable <code>avisit</code> to only include post-baseline visits.
</p>
</li>
<li> <p><code>adlb</code> is filtered on variables <code>worst_flag_low</code> and <code>worst_flag_high</code> so that only
worst grades (in either direction) are included.
</p>
</li>
<li><p> From the standard lab grade variable <code>atoxgr</code>, the following two variables are derived
and added to <code>adlb</code>:
</p>
</li></ol>


<ul>
<li><p> A grade direction variable (e.g. <code>GRADE_DIR</code>). The variable takes value <code>"HIGH"</code> when
<code>atoxgr &gt; 0</code>, <code>"LOW"</code> when <code>atoxgr &lt; 0</code>, and <code>"ZERO"</code> otherwise.
</p>
</li>
<li><p> A toxicity grade variable (e.g. <code>GRADE_ANL</code>) where all negative values from <code>atoxgr</code> are
replaced by their absolute values.
</p>
</li></ul>


<ol>
<li><p> Unused factor levels are dropped from <code>adlb</code> via <code><a href="base.html#topic+droplevels">droplevels()</a></code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>h_adlb_abnormal_by_worst_grade(
  adlb,
  atoxgr = "ATOXGR",
  avisit = "AVISIT",
  worst_flag_low = "WGRLOFL",
  worst_flag_high = "WGRHIFL"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_adlb_abnormal_by_worst_grade_+3A_adlb">adlb</code></td>
<td>
<p>(<code>data.frame</code>)<br /> <code>ADLB</code> dataframe.</p>
</td></tr>
<tr><td><code id="h_adlb_abnormal_by_worst_grade_+3A_atoxgr">atoxgr</code></td>
<td>
<p>(<code>character</code>)<br /> Analysis toxicity grade variable. This must be a <code>factor</code>
variable.</p>
</td></tr>
<tr><td><code id="h_adlb_abnormal_by_worst_grade_+3A_avisit">avisit</code></td>
<td>
<p>(<code>character</code>)<br /> Analysis visit variable.</p>
</td></tr>
<tr><td><code id="h_adlb_abnormal_by_worst_grade_+3A_worst_flag_low">worst_flag_low</code></td>
<td>
<p>(<code>character</code>)<br /> Worst low lab grade flag variable. This variable is
set to <code>"Y"</code> when indicating records of worst low lab grades.</p>
</td></tr>
<tr><td><code id="h_adlb_abnormal_by_worst_grade_+3A_worst_flag_high">worst_flag_high</code></td>
<td>
<p>(<code>character</code>)<br /> Worst high lab grade flag variable. This variable is
set to <code>"Y"</code> when indicating records of worst high lab grades.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>h_adlb_abnormal_by_worst_grade()</code> returns the <code>adlb</code> data frame with two new
variables: <code>GRADE_DIR</code> and <code>GRADE_ANL</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+abnormal_by_worst_grade">abnormal_by_worst_grade</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h_adlb_abnormal_by_worst_grade(tern_ex_adlb) %&gt;%
  dplyr::select(ATOXGR, GRADE_DIR, GRADE_ANL) %&gt;%
  head(10)

</code></pre>

<hr>
<h2 id='h_adlb_worsen'>Helper Function to Prepare <code>ADLB</code> with Worst Labs</h2><span id='topic+h_adlb_worsen'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper function to prepare a <code>df</code> for generate the patient count shift table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_adlb_worsen(
  adlb,
  worst_flag_low = NULL,
  worst_flag_high = NULL,
  direction_var
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_adlb_worsen_+3A_adlb">adlb</code></td>
<td>
<p>(<code>data.frame</code>)<br /> <code>ADLB</code> dataframe</p>
</td></tr>
<tr><td><code id="h_adlb_worsen_+3A_worst_flag_low">worst_flag_low</code></td>
<td>
<p>(named <code>vector</code>)<br /> Worst low post-baseline lab grade flag variable</p>
</td></tr>
<tr><td><code id="h_adlb_worsen_+3A_worst_flag_high">worst_flag_high</code></td>
<td>
<p>(named <code>vector</code>)<br /> Worst high post-baseline lab grade flag variable</p>
</td></tr>
<tr><td><code id="h_adlb_worsen_+3A_direction_var">direction_var</code></td>
<td>
<p>(<code>string</code>)<br /> Direction variable specifying the direction of the shift table of interest.
Only lab records flagged by <code>L</code>, <code>H</code> or <code>B</code> are included in the shift table.
</p>

<ul>
<li> <p><code>L</code>: low direction only
</p>
</li>
<li> <p><code>H</code>: high direction only
</p>
</li>
<li> <p><code>B</code>: both low and high directions
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>h_adlb_worsen()</code> returns the <code>adlb</code> <code>data.frame</code> containing only the
worst labs specified according to <code>worst_flag_low</code> or <code>worst_flag_high</code> for the
direction specified according to <code>direction_var</code>. For instance, for a lab that is
needed for the low direction only, only records flagged by <code>worst_flag_low</code> are
selected. For a lab that is needed for both low and high directions, the worst
low records are selected for the low direction, and the worst high record are selected
for the high direction.
</p>


<h3>See Also</h3>

<p><a href="#topic+abnormal_by_worst_grade_worsen">abnormal_by_worst_grade_worsen</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# The direction variable, GRADDR, is based on metadata
adlb &lt;- tern_ex_adlb %&gt;%
  mutate(
    GRADDR = case_when(
      PARAMCD == "ALT" ~ "B",
      PARAMCD == "CRP" ~ "L",
      PARAMCD == "IGA" ~ "H"
    )
  ) %&gt;%
  filter(SAFFL == "Y" &amp; ONTRTFL == "Y" &amp; GRADDR != "")

df &lt;- h_adlb_worsen(
  adlb,
  worst_flag_low = c("WGRLOFL" = "Y"),
  worst_flag_high = c("WGRHIFL" = "Y"),
  direction_var = "GRADDR"
)

</code></pre>

<hr>
<h2 id='h_adsl_adlb_merge_using_worst_flag'>Helper Function for Deriving Analysis Datasets for <code>LBT13</code> and <code>LBT14</code></h2><span id='topic+h_adsl_adlb_merge_using_worst_flag'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper function that merges <code>ADSL</code> and <code>ADLB</code> datasets so that missing lab test records are inserted in the
output dataset. Remember that <code>na_level</code> must match the needed pre-processing
done with <code><a href="#topic+df_explicit_na">df_explicit_na()</a></code> to have the desired output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_adsl_adlb_merge_using_worst_flag(
  adsl,
  adlb,
  worst_flag = c(WGRHIFL = "Y"),
  by_visit = FALSE,
  no_fillin_visits = c("SCREENING", "BASELINE")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_adsl_adlb_merge_using_worst_flag_+3A_adsl">adsl</code></td>
<td>
<p>(<code>data.frame</code>)<br /> <code>ADSL</code> dataframe.</p>
</td></tr>
<tr><td><code id="h_adsl_adlb_merge_using_worst_flag_+3A_adlb">adlb</code></td>
<td>
<p>(<code>data.frame</code>)<br /> <code>ADLB</code> dataframe.</p>
</td></tr>
<tr><td><code id="h_adsl_adlb_merge_using_worst_flag_+3A_worst_flag">worst_flag</code></td>
<td>
<p>(named <code>vector</code>)<br /> Worst post-baseline lab flag variable.</p>
</td></tr>
<tr><td><code id="h_adsl_adlb_merge_using_worst_flag_+3A_by_visit">by_visit</code></td>
<td>
<p>(<code>logical</code>)<br /> defaults to <code>FALSE</code> to generate worst grade per patient.
If worst grade per patient per visit is specified for <code>worst_flag</code>, then
<code>by_visit</code> should be <code>TRUE</code> to generate worst grade patient per visit.</p>
</td></tr>
<tr><td><code id="h_adsl_adlb_merge_using_worst_flag_+3A_no_fillin_visits">no_fillin_visits</code></td>
<td>
<p>(named <code>character</code>)<br /> Visits that are not considered for post-baseline worst toxicity
grade. Defaults to <code>c("SCREENING", "BASELINE")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the result data missing records will be created for the following situations:
</p>

<ul>
<li><p> Patients who are present in <code>adsl</code> but have no lab data in <code>adlb</code> (both baseline and post-baseline).
</p>
</li>
<li><p> Patients who do not have any post-baseline lab values.
</p>
</li>
<li><p> Patients without any post-baseline values flagged as the worst.
</p>
</li></ul>



<h3>Value</h3>

<p><code>df</code> containing variables shared between <code>adlb</code> and <code>adsl</code> along with variables <code>PARAM</code>, <code>PARAMCD</code>,
<code>ATOXGR</code>, and <code>BTOXGR</code> relevant for analysis. Optionally, <code>AVISIT</code> are <code>AVISITN</code> are included when
<code>by_visit = TRUE</code> and <code>no_fillin_visits = c("SCREENING", "BASELINE")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># `h_adsl_adlb_merge_using_worst_flag`
adlb_out &lt;- h_adsl_adlb_merge_using_worst_flag(
  tern_ex_adsl,
  tern_ex_adlb,
  worst_flag = c("WGRHIFL" = "Y")
)

# `h_adsl_adlb_merge_using_worst_flag` by visit example
adlb_out_by_visit &lt;- h_adsl_adlb_merge_using_worst_flag(
  tern_ex_adsl,
  tern_ex_adlb,
  worst_flag = c("WGRLOVFL" = "Y"),
  by_visit = TRUE
)

</code></pre>

<hr>
<h2 id='h_ancova'>Helper Function to Return Results of a Linear Model</h2><span id='topic+h_ancova'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_ancova(.var, .df_row, variables, interaction_item = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_ancova_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="h_ancova_+3A_.df_row">.df_row</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set that includes all the variables that are called in <code>.var</code> and <code>variables</code>.</p>
</td></tr>
<tr><td><code id="h_ancova_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>strings</code>)<br /> list of additional analysis variables, with expected elements:
</p>

<ul>
<li> <p><code>arm</code> (<code>string</code>)<br /> group variable, for which the covariate adjusted means of multiple groups will be
summarized. Specifically, the first level of <code>arm</code> variable is taken as the reference group.
</p>
</li>
<li> <p><code>covariates</code> (<code>character</code>)<br /> a vector that can contain single variable names (such as <code>"X1"</code>), and/or
interaction terms indicated by <code>"X1 * X2"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="h_ancova_+3A_interaction_item">interaction_item</code></td>
<td>
<p>(<code>character</code>)<br /> name of the variable that should have interactions
with arm. if the interaction is not needed, the default option is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The summary of a linear model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h_ancova(
  .var = "Sepal.Length",
  .df_row = iris,
  variables = list(arm = "Species", covariates = c("Petal.Length * Petal.Width", "Sepal.Width"))
)

</code></pre>

<hr>
<h2 id='h_append_grade_groups'>Helper function for <code><a href="#topic+s_count_occurrences_by_grade">s_count_occurrences_by_grade()</a></code></h2><span id='topic+h_append_grade_groups'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper function for <code><a href="#topic+s_count_occurrences_by_grade">s_count_occurrences_by_grade()</a></code> to insert grade groupings into list with
individual grade frequencies. The order of the final result follows the order of <code>grade_groups</code>.
The elements under any-grade group (if any), i.e. the grade group equal to <code>refs</code> will be moved to
the end. Grade groups names must be unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_append_grade_groups(grade_groups, refs, remove_single = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_append_grade_groups_+3A_grade_groups">grade_groups</code></td>
<td>
<p>(named <code>list</code> of <code>character</code>)<br /> containing groupings of grades.</p>
</td></tr>
<tr><td><code id="h_append_grade_groups_+3A_refs">refs</code></td>
<td>
<p>(named <code>list</code> of <code>numeric</code>)<br /> where each name corresponds to a reference grade level
and each entry represents a count.</p>
</td></tr>
<tr><td><code id="h_append_grade_groups_+3A_remove_single">remove_single</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> to not include the elements of one-element grade groups
in the the output list; in this case only the grade groups names will be included in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted list of grade groupings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h_append_grade_groups(
  list(
    "Any Grade" = as.character(1:5),
    "Grade 1-2" = c("1", "2"),
    "Grade 3-4" = c("3", "4")
  ),
  list("1" = 10, "2" = 20, "3" = 30, "4" = 40, "5" = 50)
)

h_append_grade_groups(
  list(
    "Any Grade" = as.character(5:1),
    "Grade A" = "5",
    "Grade B" = c("4", "3")
  ),
  list("1" = 10, "2" = 20, "3" = 30, "4" = 40, "5" = 50)
)

h_append_grade_groups(
  list(
    "Any Grade" = as.character(1:5),
    "Grade 1-2" = c("1", "2"),
    "Grade 3-4" = c("3", "4")
  ),
  list("1" = 10, "2" = 5, "3" = 0)
)

</code></pre>

<hr>
<h2 id='h_col_indices'>Obtain Column Indices</h2><span id='topic+h_col_indices'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper function to extract column indices from a <code>VTableTree</code> for a given
vector of column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_col_indices(table_tree, col_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_col_indices_+3A_table_tree">table_tree</code></td>
<td>
<p>(<code>VTableTree</code>)<br /> table to extract the indices from.</p>
</td></tr>
<tr><td><code id="h_col_indices_+3A_col_names">col_names</code></td>
<td>
<p>(<code>character</code>)<br /> vector of column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of column indices.
</p>

<hr>
<h2 id='h_count_cumulative'>Helper Function for <code><a href="#topic+s_count_cumulative">s_count_cumulative()</a></code></h2><span id='topic+h_count_cumulative'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper function to calculate count and fraction of <code>x</code> values in the lower or upper tail given a threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_count_cumulative(
  x,
  threshold,
  lower_tail = TRUE,
  include_eq = TRUE,
  na.rm = TRUE,
  .N_col
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_count_cumulative_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector of numbers we want to analyze.</p>
</td></tr>
<tr><td><code id="h_count_cumulative_+3A_threshold">threshold</code></td>
<td>
<p>(<code>number</code>)<br /> a cutoff value as threshold to count values of <code>x</code>.</p>
</td></tr>
<tr><td><code id="h_count_cumulative_+3A_lower_tail">lower_tail</code></td>
<td>
<p>(<code>logical</code>)<br /> whether to count lower tail, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="h_count_cumulative_+3A_include_eq">include_eq</code></td>
<td>
<p>(<code>logical</code>)<br /> whether to include value equal to the <code>threshold</code> in
count, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="h_count_cumulative_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>flag</code>)<br /> whether <code>NA</code> values should be removed from <code>x</code> prior to analysis.</p>
</td></tr>
<tr><td><code id="h_count_cumulative_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with items:
</p>

<ul>
<li> <p><code>count</code>: the count of values less than, less or equal to, greater than, or greater or equal to a threshold
of user specification.
</p>
</li>
<li> <p><code>fraction</code>: the fraction of the count.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+count_cumulative">count_cumulative</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1, kind = "Mersenne-Twister")
x &lt;- c(sample(1:10, 10), NA)
.N_col &lt;- length(x)

h_count_cumulative(x, 5, .N_col = .N_col)
h_count_cumulative(x, 5, lower_tail = FALSE, include_eq = FALSE, na.rm = FALSE, .N_col = .N_col)
h_count_cumulative(x, 0, lower_tail = FALSE, .N_col = .N_col)
h_count_cumulative(x, 100, lower_tail = FALSE, .N_col = .N_col)

</code></pre>

<hr>
<h2 id='h_cox_regression'>Helper Functions for Cox Proportional Hazards Regression</h2><span id='topic+h_cox_regression'></span><span id='topic+h_coxreg_univar_formulas'></span><span id='topic+h_coxreg_multivar_formula'></span><span id='topic+h_coxreg_univar_extract'></span><span id='topic+h_coxreg_multivar_extract'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper functions used in <code><a href="#topic+fit_coxreg_univar">fit_coxreg_univar()</a></code> and <code><a href="#topic+fit_coxreg_multivar">fit_coxreg_multivar()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_coxreg_univar_formulas(variables, interaction = FALSE)

h_coxreg_multivar_formula(variables)

h_coxreg_univar_extract(effect, covar, data, mod, control = control_coxreg())

h_coxreg_multivar_extract(var, data, mod, control = control_coxreg())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_cox_regression_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="h_cox_regression_+3A_interaction">interaction</code></td>
<td>
<p>(<code>flag</code>)<br /> if <code>TRUE</code>, the model includes the interaction between the studied
treatment and candidate covariate. Note that for univariate models without treatment arm, and
multivariate models, no interaction can be used so that this needs to be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="h_cox_regression_+3A_effect">effect</code></td>
<td>
<p>(<code>string</code>)<br /> the treatment variable.</p>
</td></tr>
<tr><td><code id="h_cox_regression_+3A_covar">covar</code></td>
<td>
<p>(<code>string</code>)<br /> the name of the covariate in the model.</p>
</td></tr>
<tr><td><code id="h_cox_regression_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to summarize.</p>
</td></tr>
<tr><td><code id="h_cox_regression_+3A_mod">mod</code></td>
<td>
<p>(<code>coxph</code>)<br /> Cox regression model fitted by <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>.</p>
</td></tr>
<tr><td><code id="h_cox_regression_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> a list of controls as returned by <code><a href="#topic+control_coxreg">control_coxreg()</a></code>.</p>
</td></tr>
<tr><td><code id="h_cox_regression_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>h_coxreg_univar_formulas()</code> returns a <code>character</code> vector coercible into formulas (e.g <code><a href="stats.html#topic+formula">stats::as.formula()</a></code>).
</p>
</li></ul>


<ul>
<li> <p><code>h_coxreg_multivar_formula()</code> returns a <code>string</code> coercible into a formula (e.g <code><a href="stats.html#topic+formula">stats::as.formula()</a></code>).
</p>
</li></ul>


<ul>
<li> <p><code>h_coxreg_univar_extract()</code> returns a <code>data.frame</code> with variables <code>effect</code>, <code>term</code>, <code>term_label</code>, <code>level</code>,
<code>n</code>, <code>hr</code>, <code>lcl</code>, <code>ucl</code>, and <code>pval</code>.
</p>
</li></ul>


<ul>
<li> <p><code>h_coxreg_multivar_extract()</code> returns a <code>data.frame</code> with variables <code>pval</code>, <code>hr</code>, <code>lcl</code>, <code>ucl</code>, <code>level</code>,
<code>n</code>, <code>term</code>, and <code>term_label</code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>h_coxreg_univar_formulas()</code>: Helper for Cox regression formula. Creates a list of formulas. It is used
internally by <code><a href="#topic+fit_coxreg_univar">fit_coxreg_univar()</a></code> for the comparison of univariate Cox regression models.
</p>
</li>
<li> <p><code>h_coxreg_multivar_formula()</code>: Helper for multivariate Cox regression formula. Creates a formulas
string. It is used internally by <code><a href="#topic+fit_coxreg_multivar">fit_coxreg_multivar()</a></code> for the comparison of multivariate Cox
regression models. Interactions will not be included in multivariate Cox regression model.
</p>
</li>
<li> <p><code>h_coxreg_univar_extract()</code>: Utility function to help tabulate the result of
a univariate Cox regression model.
</p>
</li>
<li> <p><code>h_coxreg_multivar_extract()</code>: Tabulation of multivariate Cox regressions. Utility function to help
tabulate the result of a multivariate Cox regression model for a treatment/covariate variable.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+cox_regression">cox_regression</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># `h_coxreg_univar_formulas`

## Simple formulas.
h_coxreg_univar_formulas(
  variables = list(
    time = "time", event = "status", arm = "armcd", covariates = c("X", "y")
  )
)

## Addition of an optional strata.
h_coxreg_univar_formulas(
  variables = list(
    time = "time", event = "status", arm = "armcd", covariates = c("X", "y"),
    strata = "SITE"
  )
)

## Inclusion of the interaction term.
h_coxreg_univar_formulas(
  variables = list(
    time = "time", event = "status", arm = "armcd", covariates = c("X", "y"),
    strata = "SITE"
  ),
  interaction = TRUE
)

## Only covariates fitted in separate models.
h_coxreg_univar_formulas(
  variables = list(
    time = "time", event = "status", covariates = c("X", "y")
  )
)

# `h_coxreg_multivar_formula`

h_coxreg_multivar_formula(
  variables = list(
    time = "AVAL", event = "event", arm = "ARMCD", covariates = c("RACE", "AGE")
  )
)

# Addition of an optional strata.
h_coxreg_multivar_formula(
  variables = list(
    time = "AVAL", event = "event", arm = "ARMCD", covariates = c("RACE", "AGE"),
    strata = "SITE"
  )
)

# Example without treatment arm.
h_coxreg_multivar_formula(
  variables = list(
    time = "AVAL", event = "event", covariates = c("RACE", "AGE"),
    strata = "SITE"
  )
)

library(survival)

dta_simple &lt;- data.frame(
  time = c(5, 5, 10, 10, 5, 5, 10, 10),
  status = c(0, 0, 1, 0, 0, 1, 1, 1),
  armcd = factor(LETTERS[c(1, 1, 1, 1, 2, 2, 2, 2)], levels = c("A", "B")),
  var1 = c(45, 55, 65, 75, 55, 65, 85, 75),
  var2 = c("F", "M", "F", "M", "F", "M", "F", "U")
)
mod &lt;- coxph(Surv(time, status) ~ armcd + var1, data = dta_simple)
result &lt;- h_coxreg_univar_extract(
  effect = "armcd", covar = "armcd", mod = mod, data = dta_simple
)
result

mod &lt;- coxph(Surv(time, status) ~ armcd + var1, data = dta_simple)
result &lt;- h_coxreg_multivar_extract(
  var = "var1", mod = mod, data = dta_simple
)
result

</code></pre>

<hr>
<h2 id='h_data_plot'>Helper function: tidy survival fit</h2><span id='topic+h_data_plot'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Convert the survival fit data into a data frame designed for plotting
within <code>g_km</code>.
</p>
<p>This starts from the <code><a href="broom.html#topic+reexports">broom::tidy()</a></code> result, and then:
</p>

<ul>
<li><p> Post-processes the <code>strata</code> column into a factor.
</p>
</li>
<li><p> Extends each stratum by an additional first row with time 0 and probability 1 so that
downstream plot lines start at those coordinates.
</p>
</li>
<li><p> Adds a <code>censor</code> column.
</p>
</li>
<li><p> Filters the rows before <code>max_time</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>h_data_plot(fit_km, armval = "All", max_time = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_data_plot_+3A_fit_km">fit_km</code></td>
<td>
<p>(<code>survfit</code>)<br /> result of <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>.</p>
</td></tr>
<tr><td><code id="h_data_plot_+3A_armval">armval</code></td>
<td>
<p>(<code>string</code>)<br /> used as strata name when treatment arm variable only has one level. Default is <code>"All"</code>.</p>
</td></tr>
<tr><td><code id="h_data_plot_+3A_max_time">max_time</code></td>
<td>
<p>(<code>numeric</code>)<br /> maximum value to show on X axis. Only data values less than or up to
this threshold value will be plotted (defaults to <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with columns <code>time</code>, <code>n.risk</code>, <code>n.event</code>, <code>n.censor</code>, <code>estimate</code>, <code>std.error</code>, <code>conf.high</code>,
<code>conf.low</code>, <code>strata</code>, and <code>censor</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(survival)

# Test with multiple arms
tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  survfit(form = Surv(AVAL, 1 - CNSR) ~ ARMCD, data = .) %&gt;%
  h_data_plot()

# Test with single arm
tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS", ARMCD == "ARM B") %&gt;%
  survfit(form = Surv(AVAL, 1 - CNSR) ~ ARMCD, data = .) %&gt;%
  h_data_plot(armval = "ARM B")


</code></pre>

<hr>
<h2 id='h_decompose_gg'><code>ggplot</code> Decomposition</h2><span id='topic+h_decompose_gg'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The elements composing the <code>ggplot</code> are extracted and organized in a <code>list</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_decompose_gg(gg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_decompose_gg_+3A_gg">gg</code></td>
<td>
<p>(<code>ggplot</code>)<br /> a graphic to decompose.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code> with elements:
</p>

<ul>
<li> <p><code>panel</code>: The panel.
</p>
</li>
<li> <p><code>yaxis</code>: The y-axis.
</p>
</li>
<li> <p><code>xaxis</code>: The x-axis.
</p>
</li>
<li> <p><code>xlab</code>: The x-axis label.
</p>
</li>
<li> <p><code>ylab</code>: The y-axis label.
</p>
</li>
<li> <p><code>guide</code>: The legend.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(survival)
library(grid)

fit_km &lt;- tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  survfit(form = Surv(AVAL, 1 - CNSR) ~ ARMCD, data = .)
data_plot &lt;- h_data_plot(fit_km = fit_km)
xticks &lt;- h_xticks(data = data_plot)
gg &lt;- h_ggkm(
  data = data_plot,
  yval = "Survival",
  censor_show = TRUE,
  xticks = xticks, xlab = "Days", ylab = "Survival Probability",
  title = "tt",
  footnotes = "ff"
)

g_el &lt;- h_decompose_gg(gg)
grid::grid.newpage()
grid.rect(gp = grid::gpar(lty = 1, col = "red", fill = "gray85", lwd = 5))
grid::grid.draw(g_el$panel)

grid::grid.newpage()
grid.rect(gp = grid::gpar(lty = 1, col = "royalblue", fill = "gray85", lwd = 5))
grid::grid.draw(with(g_el, cbind(ylab, yaxis)))


</code></pre>

<hr>
<h2 id='h_format_row'>Helper function to get the right formatting in the optional table in <code>g_lineplot</code>.</h2><span id='topic+h_format_row'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_format_row(x, format, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_format_row_+3A_x">x</code></td>
<td>
<p>(named <code>list</code>)<br /> list of numerical values to be formatted and optionally labeled.
Elements of <code>x</code> must be <code>numeric</code> vectors.</p>
</td></tr>
<tr><td><code id="h_format_row_+3A_format">format</code></td>
<td>
<p>(named <code>character</code> or <code>NULL</code>)<br /> format patterns for <code>x</code>. Names of the <code>format</code> must
match the names of <code>x</code>. This parameter is passed directly to the <code>rtables::format_rcell</code>
function through the <code>format</code> parameter.</p>
</td></tr>
<tr><td><code id="h_format_row_+3A_labels">labels</code></td>
<td>
<p>(named <code>character</code> or <code>NULL</code>)<br /> optional labels for <code>x</code>. Names of the <code>labels</code> must
match the names of <code>x</code>. When a label is not specified for an element of <code>x</code>,
then this function tries to use <code>label</code> or <code>names</code> (in this order) attribute of that element
(depending on which one exists and it is not <code>NULL</code> or <code>NA</code> or <code>NaN</code>). If none of these attributes
are attached to a given element of <code>x</code>, then the label is automatically generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single row <code>data.frame</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean_ci &lt;- c(48, 51)
x &lt;- list(mean = 50, mean_ci = mean_ci)
format &lt;- c(mean = "xx.x", mean_ci = "(xx.xx, xx.xx)")
labels &lt;- c(mean = "My Mean")
h_format_row(x, format, labels)

attr(mean_ci, "label") &lt;- "Mean 95% CI"
x &lt;- list(mean = 50, mean_ci = mean_ci)
h_format_row(x, format, labels)

</code></pre>

<hr>
<h2 id='h_g_ipp'>Helper Function To Create Simple Line Plot over Time</h2><span id='topic+h_g_ipp'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Function that generates a simple line plot displaying parameter trends over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_g_ipp(
  df,
  xvar,
  yvar,
  xlab,
  ylab,
  id_var,
  title = "Individual Patient Plots",
  subtitle = "",
  caption = NULL,
  add_baseline_hline = FALSE,
  yvar_baseline = "BASE",
  ggtheme = nestcolor::theme_nest(),
  col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_g_ipp_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="h_g_ipp_+3A_xvar">xvar</code></td>
<td>
<p>(<code>string</code>)<br /> time point variable to be plotted on x-axis.</p>
</td></tr>
<tr><td><code id="h_g_ipp_+3A_yvar">yvar</code></td>
<td>
<p>(<code>string</code>)<br /> continuous analysis variable to be plotted on y-axis.</p>
</td></tr>
<tr><td><code id="h_g_ipp_+3A_xlab">xlab</code></td>
<td>
<p>(<code>string</code>)<br /> plot label for x-axis.</p>
</td></tr>
<tr><td><code id="h_g_ipp_+3A_ylab">ylab</code></td>
<td>
<p>(<code>string</code>)<br /> plot label for y-axis.</p>
</td></tr>
<tr><td><code id="h_g_ipp_+3A_id_var">id_var</code></td>
<td>
<p>(<code>string</code>)<br /> variable used as patient identifier.</p>
</td></tr>
<tr><td><code id="h_g_ipp_+3A_title">title</code></td>
<td>
<p>(<code>string</code>)<br /> title for plot.</p>
</td></tr>
<tr><td><code id="h_g_ipp_+3A_subtitle">subtitle</code></td>
<td>
<p>(<code>string</code>)<br /> subtitle for plot.</p>
</td></tr>
<tr><td><code id="h_g_ipp_+3A_caption">caption</code></td>
<td>
<p>(<code>character</code> scalar)<br /> optional caption below the plot.</p>
</td></tr>
<tr><td><code id="h_g_ipp_+3A_add_baseline_hline">add_baseline_hline</code></td>
<td>
<p>(<code>flag</code>)<br /> adds horizontal line at baseline y-value on
plot when TRUE.</p>
</td></tr>
<tr><td><code id="h_g_ipp_+3A_yvar_baseline">yvar_baseline</code></td>
<td>
<p>(<code>string</code>)<br /> variable with baseline values only.
Ignored when <code>add_baseline_hline</code> is FALSE.</p>
</td></tr>
<tr><td><code id="h_g_ipp_+3A_ggtheme">ggtheme</code></td>
<td>
<p>(<code>theme</code>)<br /> optional graphical theme function as provided
by <code>ggplot2</code> to control outlook of plot. Use <code>ggplot2::theme()</code> to tweak the display.</p>
</td></tr>
<tr><td><code id="h_g_ipp_+3A_col">col</code></td>
<td>
<p>(<code>character</code>)<br /> lines colors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> line plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+g_ipp">g_ipp()</a></code> which uses this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(nestcolor)

# Select a small sample of data to plot.
adlb &lt;- tern_ex_adlb %&gt;%
  filter(PARAMCD == "ALT", !(AVISIT %in% c("SCREENING", "BASELINE"))) %&gt;%
  slice(1:36)

p &lt;- h_g_ipp(
  df = adlb,
  xvar = "AVISIT",
  yvar = "AVAL",
  xlab = "Visit",
  id_var = "USUBJID",
  ylab = "SGOT/ALT (U/L)",
  add_baseline_hline = TRUE
)
p

</code></pre>

<hr>
<h2 id='h_ggkm'>Helper function: KM plot</h2><span id='topic+h_ggkm'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Draw the Kaplan-Meier plot using <code>ggplot2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_ggkm(
  data,
  xticks = NULL,
  yval = "Survival",
  censor_show,
  xlab,
  ylab,
  ylim = NULL,
  title,
  footnotes = NULL,
  max_time = NULL,
  lwd = 1,
  lty = NULL,
  pch = 3,
  size = 2,
  col = NULL,
  ci_ribbon = FALSE,
  ggtheme = nestcolor::theme_nest()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_ggkm_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> survival data as pre-processed by <code>h_data_plot</code>.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_xticks">xticks</code></td>
<td>
<p>(<code>numeric</code>, <code>number</code>, or <code>NULL</code>)<br /> numeric vector of ticks or single number with spacing
between ticks on the x axis. If <code>NULL</code> (default), <code><a href="labeling.html#topic+extended">labeling::extended()</a></code> is used to determine
an optimal tick position on the x axis.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_yval">yval</code></td>
<td>
<p>(<code>string</code>)<br /> value of y-axis. Options are <code>Survival</code> (default) and <code>Failure</code> probability.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_censor_show">censor_show</code></td>
<td>
<p>(<code>flag</code>)<br /> whether to show censored.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_xlab">xlab</code></td>
<td>
<p>(<code>string</code>)<br /> label of x-axis.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_ylab">ylab</code></td>
<td>
<p>(<code>string</code>)<br /> label of y-axis.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_ylim">ylim</code></td>
<td>
<p>(<code>vector</code> of <code>numeric</code>)<br /> vector of length 2 containing lower and upper limits for the y-axis.
If <code>NULL</code> (default), the minimum and maximum y-values displayed are used as limits.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_title">title</code></td>
<td>
<p>(<code>string</code>)<br /> title for plot.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_footnotes">footnotes</code></td>
<td>
<p>(<code>string</code>)<br /> footnotes for plot.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_max_time">max_time</code></td>
<td>
<p>(<code>numeric</code>)<br /> maximum value to show on X axis. Only data values less than or up to
this threshold value will be plotted (defaults to <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_lwd">lwd</code></td>
<td>
<p>(<code>numeric</code>)<br /> line width. Length of a vector should be equal
to number of strata from <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_lty">lty</code></td>
<td>
<p>(<code>numeric</code>)<br /> line type. Length of a vector should be equal
to number of strata from <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_pch">pch</code></td>
<td>
<p>(<code>numeric</code>, <code>string</code>)<br /> value or character of points symbol to indicate censored cases.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_size">size</code></td>
<td>
<p>(<code>numeric</code>)<br /> size of censored point, a class of <code>unit</code>.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_col">col</code></td>
<td>
<p>(<code>character</code>)<br /> lines colors. Length of a vector should be equal
to number of strata from <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_ci_ribbon">ci_ribbon</code></td>
<td>
<p>(<code>flag</code>)<br /> draw the confidence interval around the Kaplan-Meier curve.</p>
</td></tr>
<tr><td><code id="h_ggkm_+3A_ggtheme">ggtheme</code></td>
<td>
<p>(<code>theme</code>)<br /> a graphical theme as provided by <code>ggplot2</code> to control outlook of the Kaplan-Meier curve.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(survival)

fit_km &lt;- tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  survfit(form = Surv(AVAL, 1 - CNSR) ~ ARMCD, data = .)
data_plot &lt;- h_data_plot(fit_km = fit_km)
xticks &lt;- h_xticks(data = data_plot)
gg &lt;- h_ggkm(
  data = data_plot,
  censor_show = TRUE,
  xticks = xticks,
  xlab = "Days",
  yval = "Survival",
  ylab = "Survival Probability",
  title = "Survival"
)
gg


</code></pre>

<hr>
<h2 id='h_glm_count'>Helper Functions for Poisson Models.</h2><span id='topic+h_glm_count'></span><span id='topic+h_glm_poisson'></span><span id='topic+h_glm_quasipoisson'></span><span id='topic+h_ppmeans'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Helper functions that can be used to return the results of various Poisson models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_glm_poisson(.var, .df_row, variables, weights)

h_glm_quasipoisson(.var, .df_row, variables, weights)

h_glm_count(.var, .df_row, variables, distribution, weights)

h_ppmeans(obj, .df_row, arm, conf_level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_glm_count_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="h_glm_count_+3A_.df_row">.df_row</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set that includes all the variables that are called in <code>.var</code> and <code>variables</code>.</p>
</td></tr>
<tr><td><code id="h_glm_count_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>strings</code>)<br /> list of additional analysis variables, with
expected elements:
</p>

<ul>
<li> <p><code>arm</code> (<code>string</code>)<br /> group variable, for which the covariate adjusted means of multiple
groups will be summarized. Specifically, the first level of <code>arm</code> variable is taken as the
reference group.
</p>
</li>
<li> <p><code>covariates</code> (<code>character</code>)<br /> a vector that can contain single variable names (such as
<code>"X1"</code>), and/or interaction terms indicated by <code>"X1 * X2"</code>.
</p>
</li>
<li> <p><code>offset</code> (<code>numeric</code>)<br /> a numeric vector or scalar adding an offset.
</p>
</li></ul>
</td></tr>
<tr><td><code id="h_glm_count_+3A_weights">weights</code></td>
<td>
<p>(<code>character</code>)<br /> a character vector specifying weights used
in averaging predictions. Number of weights must equal the number of levels included in the covariates.
Weights option passed to <code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code>.</p>
</td></tr>
<tr><td><code id="h_glm_count_+3A_distribution">distribution</code></td>
<td>
<p>(<code>character</code>)<br /> a character value specifying the distribution
used in the regression (poisson, quasipoisson).</p>
</td></tr>
<tr><td><code id="h_glm_count_+3A_obj">obj</code></td>
<td>
<p>(<code>glm.fit</code>)<br /> fitted model object used to derive the mean rate estimates in each treatment arm.</p>
</td></tr>
<tr><td><code id="h_glm_count_+3A_arm">arm</code></td>
<td>
<p>(<code>string</code>)<br /> group variable, for which the covariate adjusted means of multiple groups will be
summarized. Specifically, the first level of <code>arm</code> variable is taken as the reference group.</p>
</td></tr>
<tr><td><code id="h_glm_count_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>numeric</code>)<br /> value used to derive the confidence interval for the rate.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>h_glm_poisson()</code> returns the results of a Poisson model.
</p>
</li></ul>


<ul>
<li> <p><code>h_glm_quasipoisson()</code> returns the results of a Quasi-Poisson model.
</p>
</li></ul>


<ul>
<li> <p><code>h_glm_count()</code> returns the results of the selected model.
</p>
</li></ul>


<ul>
<li> <p><code>h_ppmeans()</code> returns the estimated means.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>h_glm_poisson()</code>: Helper function to return results of a poisson model.
</p>
</li>
<li> <p><code>h_glm_quasipoisson()</code>: Helper function to return results of a quasipoisson model.
</p>
</li>
<li> <p><code>h_glm_count()</code>: Helper function to return the results of the
selected model (poisson, quasipoisson, negative binomial).
</p>
</li>
<li> <p><code>h_ppmeans()</code>: Helper function to return the estimated means.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+summarize_glm_count">summarize_glm_count</a>
</p>

<hr>
<h2 id='h_grob_coxph'>Helper Function: <code>CoxPH</code> Grob</h2><span id='topic+h_grob_coxph'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Grob of <code>rtable</code> output from <code><a href="#topic+h_tbl_coxph_pairwise">h_tbl_coxph_pairwise()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_grob_coxph(
  ...,
  x = 0,
  y = 0,
  width = grid::unit(0.4, "npc"),
  ttheme = gridExtra::ttheme_default(padding = grid::unit(c(1, 0.5), "lines"), core =
    list(bg_params = list(fill = c("grey95", "grey90"), alpha = 0.5)))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_grob_coxph_+3A_...">...</code></td>
<td>
<p>arguments will be passed to <code><a href="#topic+h_tbl_coxph_pairwise">h_tbl_coxph_pairwise()</a></code>.</p>
</td></tr>
<tr><td><code id="h_grob_coxph_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> a value between 0 and 1 specifying x-location.</p>
</td></tr>
<tr><td><code id="h_grob_coxph_+3A_y">y</code></td>
<td>
<p>(<code>numeric</code>)<br /> a value between 0 and 1 specifying y-location.</p>
</td></tr>
<tr><td><code id="h_grob_coxph_+3A_width">width</code></td>
<td>
<p>(<code>unit</code>)<br /> width (as a unit) to use when printing the grob.</p>
</td></tr>
<tr><td><code id="h_grob_coxph_+3A_ttheme">ttheme</code></td>
<td>
<p>(<code>list</code>)<br /> see <code><a href="gridExtra.html#topic+tableGrob">gridExtra::ttheme_default()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>grob</code> of a table containing statistics <code>HR</code>, <code style="white-space: pre;">&#8288;XX% CI&#8288;</code> (<code>XX</code> taken from <code>control_coxph_pw</code>),
and <code>p-value (log-rank)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(survival)
library(grid)

grid::grid.newpage()
grid.rect(gp = grid::gpar(lty = 1, col = "pink", fill = "gray85", lwd = 1))
data &lt;- tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  mutate(is_event = CNSR == 0)
tbl_grob &lt;- h_grob_coxph(
  df = data,
  variables = list(tte = "AVAL", is_event = "is_event", arm = "ARMCD"),
  control_coxph_pw = control_coxph(conf_level = 0.9), x = 0.5, y = 0.5
)
grid::grid.draw(tbl_grob)


</code></pre>

<hr>
<h2 id='h_grob_median_surv'>Helper Function: Survival Estimation Grob</h2><span id='topic+h_grob_median_surv'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The survival fit is transformed in a grob containing a table with groups in
rows characterized by N, median and 95% confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_grob_median_surv(
  fit_km,
  armval = "All",
  x = 0.9,
  y = 0.9,
  width = grid::unit(0.3, "npc"),
  ttheme = gridExtra::ttheme_default()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_grob_median_surv_+3A_fit_km">fit_km</code></td>
<td>
<p>(<code>survfit</code>)<br /> result of <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>.</p>
</td></tr>
<tr><td><code id="h_grob_median_surv_+3A_armval">armval</code></td>
<td>
<p>(<code>string</code>)<br /> used as strata name when treatment arm variable only has one level. Default is <code>"All"</code>.</p>
</td></tr>
<tr><td><code id="h_grob_median_surv_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> a value between 0 and 1 specifying x-location.</p>
</td></tr>
<tr><td><code id="h_grob_median_surv_+3A_y">y</code></td>
<td>
<p>(<code>numeric</code>)<br /> a value between 0 and 1 specifying y-location.</p>
</td></tr>
<tr><td><code id="h_grob_median_surv_+3A_width">width</code></td>
<td>
<p>(<code>unit</code>)<br /> width (as a unit) to use when printing the grob.</p>
</td></tr>
<tr><td><code id="h_grob_median_surv_+3A_ttheme">ttheme</code></td>
<td>
<p>(<code>list</code>)<br /> see <code><a href="gridExtra.html#topic+tableGrob">gridExtra::ttheme_default()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>grob</code> of a table containing statistics <code>N</code>, <code>Median</code>, and <code style="white-space: pre;">&#8288;XX% CI&#8288;</code> (<code>XX</code> taken from <code>fit_km</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(survival)
library(grid)

grid::grid.newpage()
grid.rect(gp = grid::gpar(lty = 1, col = "pink", fill = "gray85", lwd = 1))
tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  survfit(form = Surv(AVAL, 1 - CNSR) ~ ARMCD, data = .) %&gt;%
  h_grob_median_surv() %&gt;%
  grid::grid.draw()


</code></pre>

<hr>
<h2 id='h_grob_tbl_at_risk'>Helper: Patient-at-Risk Grobs</h2><span id='topic+h_grob_tbl_at_risk'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Two graphical objects are obtained, one corresponding to row labeling and the second to the table of
numbers of patients at risk. If <code>title = TRUE</code>, a third object corresponding to the table title is
also obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_grob_tbl_at_risk(data, annot_tbl, xlim, title = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_grob_tbl_at_risk_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> survival data as pre-processed by <code>h_data_plot</code>.</p>
</td></tr>
<tr><td><code id="h_grob_tbl_at_risk_+3A_annot_tbl">annot_tbl</code></td>
<td>
<p>(<code>data.frame</code>)<br /> annotation as prepared by <code><a href="survival.html#topic+summary.survfit">survival::summary.survfit()</a></code> which
includes the number of patients at risk at given time points.</p>
</td></tr>
<tr><td><code id="h_grob_tbl_at_risk_+3A_xlim">xlim</code></td>
<td>
<p>(<code>numeric</code>)<br /> the maximum value on the x-axis (used to
ensure the at risk table aligns with the KM graph).</p>
</td></tr>
<tr><td><code id="h_grob_tbl_at_risk_+3A_title">title</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the &quot;Patients at Risk&quot; title should be added above the <code>annot_at_risk</code>
table. Has no effect if <code>annot_at_risk</code> is <code>FALSE</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code> of two <code>gTree</code> objects if <code>title = FALSE</code>: <code>at_risk</code> and <code>label</code>, or three
<code>gTree</code> objects if <code>title = TRUE</code>: <code>at_risk</code>, <code>label</code>, and <code>title</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(survival)
library(grid)

fit_km &lt;- tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  survfit(form = Surv(AVAL, 1 - CNSR) ~ ARMCD, data = .)

data_plot &lt;- h_data_plot(fit_km = fit_km)

xticks &lt;- h_xticks(data = data_plot)

gg &lt;- h_ggkm(
  data = data_plot,
  censor_show = TRUE,
  xticks = xticks, xlab = "Days", ylab = "Survival Probability",
  title = "tt", footnotes = "ff", yval = "Survival"
)

# The annotation table reports the patient at risk for a given strata and
# time (`xticks`).
annot_tbl &lt;- summary(fit_km, time = xticks)
if (is.null(fit_km$strata)) {
  annot_tbl &lt;- with(annot_tbl, data.frame(n.risk = n.risk, time = time, strata = "All"))
} else {
  strata_lst &lt;- strsplit(sub("=", "equals", levels(annot_tbl$strata)), "equals")
  levels(annot_tbl$strata) &lt;- matrix(unlist(strata_lst), ncol = 2, byrow = TRUE)[, 2]
  annot_tbl &lt;- data.frame(
    n.risk = annot_tbl$n.risk,
    time = annot_tbl$time,
    strata = annot_tbl$strata
  )
}

# The annotation table is transformed into a grob.
tbl &lt;- h_grob_tbl_at_risk(data = data_plot, annot_tbl = annot_tbl, xlim = max(xticks))

# For the representation, the layout is estimated for which the decomposition
# of the graphic element is necessary.
g_el &lt;- h_decompose_gg(gg)
lyt &lt;- h_km_layout(data = data_plot, g_el = g_el, title = "t", footnotes = "f")

grid::grid.newpage()
pushViewport(viewport(layout = lyt, height = .95, width = .95))
grid.rect(gp = grid::gpar(lty = 1, col = "purple", fill = "gray85", lwd = 1))
pushViewport(viewport(layout.pos.row = 3:4, layout.pos.col = 2))
grid.rect(gp = grid::gpar(lty = 1, col = "orange", fill = "gray85", lwd = 1))
grid::grid.draw(tbl$at_risk)
popViewport()
pushViewport(viewport(layout.pos.row = 3:4, layout.pos.col = 1))
grid.rect(gp = grid::gpar(lty = 1, col = "green3", fill = "gray85", lwd = 1))
grid::grid.draw(tbl$label)


</code></pre>

<hr>
<h2 id='h_grob_y_annot'>Helper: Grid Object with y-axis Annotation</h2><span id='topic+h_grob_y_annot'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Build the y-axis annotation from a decomposed <code>ggplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_grob_y_annot(ylab, yaxis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_grob_y_annot_+3A_ylab">ylab</code></td>
<td>
<p>(<code>gtable</code>)<br /> the y-lab as a graphical object derived from a <code>ggplot</code>.</p>
</td></tr>
<tr><td><code id="h_grob_y_annot_+3A_yaxis">yaxis</code></td>
<td>
<p>(<code>gtable</code>)<br /> the y-axis as a graphical object derived from a <code>ggplot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>gTree</code> object containing the y-axis annotation from a <code>ggplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(survival)
library(grid)

fit_km &lt;- tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  survfit(form = Surv(AVAL, 1 - CNSR) ~ ARMCD, data = .)
data_plot &lt;- h_data_plot(fit_km = fit_km)
xticks &lt;- h_xticks(data = data_plot)
gg &lt;- h_ggkm(
  data = data_plot,
  censor_show = TRUE,
  xticks = xticks, xlab = "Days", ylab = "Survival Probability",
  title = "title", footnotes = "footnotes", yval = "Survival"
)

g_el &lt;- h_decompose_gg(gg)

grid::grid.newpage()
pvp &lt;- grid::plotViewport(margins = c(5, 4, 2, 20))
pushViewport(pvp)
grid::grid.draw(h_grob_y_annot(ylab = g_el$ylab, yaxis = g_el$yaxis))
grid.rect(gp = grid::gpar(lty = 1, col = "gray35", fill = NA))


</code></pre>

<hr>
<h2 id='h_incidence_rate'>Helper Functions for Incidence Rate</h2><span id='topic+h_incidence_rate'></span><span id='topic+h_incidence_rate_normal'></span><span id='topic+h_incidence_rate_normal_log'></span><span id='topic+h_incidence_rate_exact'></span><span id='topic+h_incidence_rate_byar'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_incidence_rate_normal(person_years, n_events, alpha = 0.05)

h_incidence_rate_normal_log(person_years, n_events, alpha = 0.05)

h_incidence_rate_exact(person_years, n_events, alpha = 0.05)

h_incidence_rate_byar(person_years, n_events, alpha = 0.05)

h_incidence_rate(person_years, n_events, control = control_incidence_rate())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_incidence_rate_+3A_person_years">person_years</code></td>
<td>
<p>(<code>numeric</code>)<br /> total person-years at risk.</p>
</td></tr>
<tr><td><code id="h_incidence_rate_+3A_n_events">n_events</code></td>
<td>
<p>(<code>integer</code>)<br /> number of events observed.</p>
</td></tr>
<tr><td><code id="h_incidence_rate_+3A_alpha">alpha</code></td>
<td>
<p>(<code>numeric</code>)<br /> two-sided alpha-level for confidence interval.</p>
</td></tr>
<tr><td><code id="h_incidence_rate_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> parameters for estimation details, specified by using
the helper function <code><a href="#topic+control_incidence_rate">control_incidence_rate()</a></code>. Possible parameter options are:
</p>

<ul>
<li> <p><code>conf_level</code>: (<code>proportion</code>)<br /> confidence level for the estimated incidence rate.
</p>
</li>
<li> <p><code>conf_type</code>: (<code>string</code>)<br /> <code>normal</code> (default), <code>normal_log</code>, <code>exact</code>, or <code>byar</code>
for confidence interval type.
</p>
</li>
<li> <p><code>input_time_unit</code>: (<code>string</code>)<br /> <code>day</code>, <code>week</code>, <code>month</code>, or <code>year</code> (default)
indicating time unit for data input.
</p>
</li>
<li> <p><code>num_pt_year</code>: (<code>numeric</code>)<br /> time unit for desired output (in person-years).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated incidence rate <code>rate</code> and associated confidence interval <code>rate_ci</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>h_incidence_rate_normal()</code>: Helper function to estimate the incidence rate and
associated confidence interval based on the normal approximation for the
incidence rate. Unit is one person-year.
</p>
</li>
<li> <p><code>h_incidence_rate_normal_log()</code>: Helper function to estimate the incidence rate and
associated confidence interval based on the normal approximation for the
logarithm of the incidence rate. Unit is one person-year.
</p>
</li>
<li> <p><code>h_incidence_rate_exact()</code>: Helper function to estimate the incidence rate and
associated exact confidence interval. Unit is one person-year.
</p>
</li>
<li> <p><code>h_incidence_rate_byar()</code>: Helper function to estimate the incidence rate and
associated <code>Byar</code>'s confidence interval. Unit is one person-year.
</p>
</li>
<li> <p><code>h_incidence_rate()</code>: Helper function to estimate the incidence rate and
associated confidence interval.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+incidence_rate">incidence_rate</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h_incidence_rate_normal(200, 2)

h_incidence_rate_normal_log(200, 2)

h_incidence_rate_exact(200, 2)

h_incidence_rate_byar(200, 2)

</code></pre>

<hr>
<h2 id='h_km_layout'>Helper: KM Layout</h2><span id='topic+h_km_layout'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Prepares a (5 rows) x (2 cols) layout for the Kaplan-Meier curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_km_layout(
  data,
  g_el,
  title,
  footnotes,
  annot_at_risk = TRUE,
  annot_at_risk_title = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_km_layout_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> survival data as pre-processed by <code>h_data_plot</code>.</p>
</td></tr>
<tr><td><code id="h_km_layout_+3A_g_el">g_el</code></td>
<td>
<p>(<code>list</code> of <code>gtable</code>)<br /> list as obtained by <code>h_decompose_gg()</code>.</p>
</td></tr>
<tr><td><code id="h_km_layout_+3A_title">title</code></td>
<td>
<p>(<code>string</code>)<br /> title for plot.</p>
</td></tr>
<tr><td><code id="h_km_layout_+3A_footnotes">footnotes</code></td>
<td>
<p>(<code>string</code>)<br /> footnotes for plot.</p>
</td></tr>
<tr><td><code id="h_km_layout_+3A_annot_at_risk">annot_at_risk</code></td>
<td>
<p>(<code>flag</code>)<br /> compute and add the annotation table reporting the number of
patient at risk matching the main grid of the Kaplan-Meier curve.</p>
</td></tr>
<tr><td><code id="h_km_layout_+3A_annot_at_risk_title">annot_at_risk_title</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the &quot;Patients at Risk&quot; title should be added above the <code>annot_at_risk</code>
table. Has no effect if <code>annot_at_risk</code> is <code>FALSE</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The layout corresponds to a grid of two columns and five rows of unequal dimensions. Most of the
dimension are fixed, only the curve is flexible and will accommodate with the remaining free space.
</p>

<ul>
<li><p> The left column gets the annotation of the <code>ggplot</code> (y-axis) and the names of the strata for the patient
at risk tabulation. The main constraint is about the width of the columns which must allow the writing of
the strata name.
</p>
</li>
<li><p> The right column receive the <code>ggplot</code>, the legend, the x-axis and the patient at risk table.
</p>
</li></ul>



<h3>Value</h3>

<p>A grid layout.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(survival)
library(grid)

fit_km &lt;- tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  survfit(form = Surv(AVAL, 1 - CNSR) ~ ARMCD, data = .)
data_plot &lt;- h_data_plot(fit_km = fit_km)
xticks &lt;- h_xticks(data = data_plot)
gg &lt;- h_ggkm(
  data = data_plot,
  censor_show = TRUE,
  xticks = xticks, xlab = "Days", ylab = "Survival Probability",
  title = "tt", footnotes = "ff", yval = "Survival"
)
g_el &lt;- h_decompose_gg(gg)
lyt &lt;- h_km_layout(data = data_plot, g_el = g_el, title = "t", footnotes = "f")
grid.show.layout(lyt)


</code></pre>

<hr>
<h2 id='h_logistic_regression'>Helper Functions for Multivariate Logistic Regression</h2><span id='topic+h_logistic_regression'></span><span id='topic+h_get_interaction_vars'></span><span id='topic+h_interaction_coef_name'></span><span id='topic+h_or_cat_interaction'></span><span id='topic+h_or_cont_interaction'></span><span id='topic+h_or_interaction'></span><span id='topic+h_simple_term_labels'></span><span id='topic+h_interaction_term_labels'></span><span id='topic+h_glm_simple_term_extract'></span><span id='topic+h_glm_interaction_extract'></span><span id='topic+h_glm_inter_term_extract'></span><span id='topic+h_logistic_simple_terms'></span><span id='topic+h_logistic_inter_terms'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper functions used in calculations for logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_get_interaction_vars(fit_glm)

h_interaction_coef_name(
  interaction_vars,
  first_var_with_level,
  second_var_with_level
)

h_or_cat_interaction(
  odds_ratio_var,
  interaction_var,
  fit_glm,
  conf_level = 0.95
)

h_or_cont_interaction(
  odds_ratio_var,
  interaction_var,
  fit_glm,
  at = NULL,
  conf_level = 0.95
)

h_or_interaction(
  odds_ratio_var,
  interaction_var,
  fit_glm,
  at = NULL,
  conf_level = 0.95
)

h_simple_term_labels(terms, table)

h_interaction_term_labels(terms1, terms2, table, any = FALSE)

h_glm_simple_term_extract(x, fit_glm)

h_glm_interaction_extract(x, fit_glm)

h_glm_inter_term_extract(odds_ratio_var, interaction_var, fit_glm, ...)

h_logistic_simple_terms(x, fit_glm, conf_level = 0.95)

h_logistic_inter_terms(x, fit_glm, conf_level = 0.95, at = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_logistic_regression_+3A_fit_glm">fit_glm</code></td>
<td>
<p>(<code>glm</code>)<br /> logistic regression model fitted by <code><a href="stats.html#topic+glm">stats::glm()</a></code> with &quot;binomial&quot; family.
Limited functionality is also available for conditional logistic regression models fitted by
<code><a href="survival.html#topic+clogit">survival::clogit()</a></code>, currently this is used only by <code><a href="#topic+extract_rsp_biomarkers">extract_rsp_biomarkers()</a></code>.</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_interaction_vars">interaction_vars</code></td>
<td>
<p>(<code>character</code> of length 2)<br /> interaction variable names.</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_first_var_with_level">first_var_with_level</code></td>
<td>
<p>(<code>character</code> of length 2)<br /> the first variable name with
the interaction level.</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_second_var_with_level">second_var_with_level</code></td>
<td>
<p>(<code>character</code> of length 2)<br /> the second variable name with
the interaction level.</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_odds_ratio_var">odds_ratio_var</code></td>
<td>
<p>(<code>string</code>)<br /> the odds ratio variable.</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_interaction_var">interaction_var</code></td>
<td>
<p>(<code>string</code>)<br /> the interaction variable.</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_at">at</code></td>
<td>
<p>(<code>NULL</code> or <code>numeric</code>)<br /> optional values for the interaction variable. Otherwise
the median is used.</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_terms">terms</code></td>
<td>
<p>(<code>character</code>)<br /> simple terms.</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_table">table</code></td>
<td>
<p>(<code>table</code>)<br /> table containing numbers for terms.</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_terms1">terms1</code></td>
<td>
<p>(<code>character</code>)<br /> terms for first dimension (rows).</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_terms2">terms2</code></td>
<td>
<p>(<code>character</code>)<br /> terms for second dimension (rows).</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_any">any</code></td>
<td>
<p>(<code>flag</code>)<br /> whether any of <code>term1</code> and <code>term2</code> can be fulfilled to count the
number of patients. In that case they can only be scalar (strings).</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_x">x</code></td>
<td>
<p>(<code>string</code> or <code>character</code>)<br /> a variable or interaction term in <code>fit_glm</code> (depending on the
helper function).</p>
</td></tr>
<tr><td><code id="h_logistic_regression_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of names of interaction variables.
</p>
<p>Name of coefficient.
</p>
<p>Odds ratio.
</p>
<p>Odds ratio.
</p>
<p>Odds ratio.
</p>
<p>Term labels containing numbers of patients.
</p>
<p>Term labels containing numbers of patients.
</p>
<p>Tabulated main effect results from a logistic regression model.
</p>
<p>Tabulated interaction term results from a logistic regression model.
</p>
<p>A <code>data.frame</code> of tabulated interaction term results from a logistic regression model.
</p>
<p>Tabulated statistics for the given variable(s) from the logistic regression model.
</p>
<p>Tabulated statistics for the given variable(s) from the logistic regression model.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>h_get_interaction_vars()</code>: Helper function to extract interaction variable names from a fitted
model assuming only one interaction term.
</p>
</li>
<li> <p><code>h_interaction_coef_name()</code>: Helper function to get the right coefficient name from the
interaction variable names and the given levels. The main value here is that the order
of first and second variable is checked in the <code>interaction_vars</code> input.
</p>
</li>
<li> <p><code>h_or_cat_interaction()</code>: Helper function to calculate the odds ratio estimates
for the case when both the odds ratio and the interaction variable are categorical.
</p>
</li>
<li> <p><code>h_or_cont_interaction()</code>: Helper function to calculate the odds ratio estimates
for the case when either the odds ratio or the interaction variable is continuous.
</p>
</li>
<li> <p><code>h_or_interaction()</code>: Helper function to calculate the odds ratio estimates
in case of an interaction. This is a wrapper for <code><a href="#topic+h_or_cont_interaction">h_or_cont_interaction()</a></code> and
<code><a href="#topic+h_or_cat_interaction">h_or_cat_interaction()</a></code>.
</p>
</li>
<li> <p><code>h_simple_term_labels()</code>: Helper function to construct term labels from simple terms and the table
of numbers of patients.
</p>
</li>
<li> <p><code>h_interaction_term_labels()</code>: Helper function to construct term labels from interaction terms and the table
of numbers of patients.
</p>
</li>
<li> <p><code>h_glm_simple_term_extract()</code>: Helper function to tabulate the main effect
results of a (conditional) logistic regression model.
</p>
</li>
<li> <p><code>h_glm_interaction_extract()</code>: Helper function to tabulate the interaction term
results of a logistic regression model.
</p>
</li>
<li> <p><code>h_glm_inter_term_extract()</code>: Helper function to tabulate the interaction
results of a logistic regression model. This basically is a wrapper for
<code><a href="#topic+h_or_interaction">h_or_interaction()</a></code> and <code><a href="#topic+h_glm_simple_term_extract">h_glm_simple_term_extract()</a></code> which puts the results
in the right data frame format.
</p>
</li>
<li> <p><code>h_logistic_simple_terms()</code>: Helper function to tabulate the results including
odds ratios and confidence intervals of simple terms.
</p>
</li>
<li> <p><code>h_logistic_inter_terms()</code>: Helper function to tabulate the results including
odds ratios and confidence intervals of interaction terms.
</p>
</li></ul>


<h3>Note</h3>

<p>We don't provide a function for the case when both variables are continuous because
this does not arise in this table, as the treatment arm variable will always be involved
and categorical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(broom)

adrs_f &lt;- tern_ex_adrs %&gt;%
  filter(PARAMCD == "BESRSPI") %&gt;%
  filter(RACE %in% c("ASIAN", "WHITE", "BLACK OR AFRICAN AMERICAN")) %&gt;%
  mutate(
    Response = case_when(AVALC %in% c("PR", "CR") ~ 1, TRUE ~ 0),
    RACE = factor(RACE),
    SEX = factor(SEX)
  )
formatters::var_labels(adrs_f) &lt;- c(formatters::var_labels(tern_ex_adrs), Response = "Response")
mod1 &lt;- fit_logistic(
  data = adrs_f,
  variables = list(
    response = "Response",
    arm = "ARMCD",
    covariates = c("AGE", "RACE")
  )
)
mod2 &lt;- fit_logistic(
  data = adrs_f,
  variables = list(
    response = "Response",
    arm = "ARMCD",
    covariates = c("AGE", "RACE"),
    interaction = "AGE"
  )
)

h_glm_simple_term_extract("AGE", mod1)
h_glm_simple_term_extract("ARMCD", mod1)

h_glm_interaction_extract("ARMCD:AGE", mod2)

h_glm_inter_term_extract("AGE", "ARMCD", mod2)

h_logistic_simple_terms("AGE", mod1)

h_logistic_inter_terms(c("RACE", "AGE", "ARMCD", "AGE:ARMCD"), mod2)

</code></pre>

<hr>
<h2 id='h_map_for_count_abnormal'>Helper Function to create a map dataframe that can be used in <code>trim_levels_to_map</code> split function.</h2><span id='topic+h_map_for_count_abnormal'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper Function to create a map dataframe from the input dataset, which can be used as an argument in the
<code>trim_levels_to_map</code> split function. Based on different method, the map is constructed differently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_map_for_count_abnormal(
  df,
  variables = list(anl = "ANRIND", split_rows = c("PARAM"), range_low = "ANRLO",
    range_high = "ANRHI"),
  abnormal = list(low = c("LOW", "LOW LOW"), high = c("HIGH", "HIGH HIGH")),
  method = c("default", "range"),
  na_level = lifecycle::deprecated(),
  na_str = "&lt;Missing&gt;"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_map_for_count_abnormal_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="h_map_for_count_abnormal_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="h_map_for_count_abnormal_+3A_abnormal">abnormal</code></td>
<td>
<p>(named <code>list</code>)<br /> identifying the abnormal range level(s) in <code>df</code>. Based on the levels of
abnormality of the input dataset, it can be something like <code>list(Low = "LOW LOW", High = "HIGH HIGH")</code> or
<code style="white-space: pre;">&#8288;abnormal = list(Low = "LOW", High = "HIGH"))&#8288;</code></p>
</td></tr>
<tr><td><code id="h_map_for_count_abnormal_+3A_method">method</code></td>
<td>
<p>(<code>string</code>)<br /> indicates how the returned map will be constructed. Can be <code>"default"</code> or <code>"range"</code>.</p>
</td></tr>
<tr><td><code id="h_map_for_count_abnormal_+3A_na_level">na_level</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use the <code>na_str</code> argument instead.</p>
</td></tr>
<tr><td><code id="h_map_for_count_abnormal_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A map <code>data.frame</code>.
</p>


<h3>Note</h3>

<p>If method is <code>"default"</code>, the returned map will only have the abnormal directions that are observed in the
<code>df</code>, and records with all normal values will be excluded to avoid error in creating layout. If method is
<code>"range"</code>, the returned map will be based on the rule that at least one observation with low range &gt; 0
for low direction and at least one observation with high range is not missing for high direction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adlb &lt;- df_explicit_na(tern_ex_adlb)

h_map_for_count_abnormal(
  df = adlb,
  variables = list(anl = "ANRIND", split_rows = c("LBCAT", "PARAM")),
  abnormal = list(low = c("LOW"), high = c("HIGH")),
  method = "default",
  na_str = "&lt;Missing&gt;"
)

df &lt;- data.frame(
  USUBJID = c(rep("1", 4), rep("2", 4), rep("3", 4)),
  AVISIT = c(
    rep("WEEK 1", 2),
    rep("WEEK 2", 2),
    rep("WEEK 1", 2),
    rep("WEEK 2", 2),
    rep("WEEK 1", 2),
    rep("WEEK 2", 2)
  ),
  PARAM = rep(c("ALT", "CPR"), 6),
  ANRIND = c(
    "NORMAL", "NORMAL", "LOW",
    "HIGH", "LOW", "LOW", "HIGH", "HIGH", rep("NORMAL", 4)
  ),
  ANRLO = rep(5, 12),
  ANRHI = rep(20, 12)
)
df$ANRIND &lt;- factor(df$ANRIND, levels = c("LOW", "HIGH", "NORMAL"))
h_map_for_count_abnormal(
  df = df,
  variables = list(
    anl = "ANRIND",
    split_rows = c("PARAM"),
    range_low = "ANRLO",
    range_high = "ANRHI"
  ),
  abnormal = list(low = c("LOW"), high = c("HIGH")),
  method = "range",
  na_str = "&lt;Missing&gt;"
)

</code></pre>

<hr>
<h2 id='h_odds_ratio'>Helper Functions for Odds Ratio Estimation</h2><span id='topic+h_odds_ratio'></span><span id='topic+or_glm'></span><span id='topic+or_clogit'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Functions to calculate odds ratios in <code><a href="#topic+estimate_odds_ratio">estimate_odds_ratio()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>or_glm(data, conf_level)

or_clogit(data, conf_level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_odds_ratio_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data frame containing at least the variables <code>rsp</code> and <code>grp</code>, and optionally
<code>strata</code> for <code><a href="#topic+or_clogit">or_clogit()</a></code>.</p>
</td></tr>
<tr><td><code id="h_odds_ratio_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code> of elements <code>or_ci</code> and <code>n_tot</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>or_glm()</code>: Estimates the odds ratio based on <code><a href="stats.html#topic+glm">stats::glm()</a></code>. Note that there must be
exactly 2 groups in <code>data</code> as specified by the <code>grp</code> variable.
</p>
</li>
<li> <p><code>or_clogit()</code>: estimates the odds ratio based on <code><a href="survival.html#topic+clogit">survival::clogit()</a></code>. This is done for
the whole data set including all groups, since the results are not the same as when doing
pairwise comparisons between the groups.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+odds_ratio">odds_ratio</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data with 2 groups.
data &lt;- data.frame(
  rsp = as.logical(c(1, 1, 0, 1, 0, 0, 1, 1)),
  grp = letters[c(1, 1, 1, 2, 2, 2, 1, 2)],
  strata = letters[c(1, 2, 1, 2, 2, 2, 1, 2)],
  stringsAsFactors = TRUE
)

# Odds ratio based on glm.
or_glm(data, conf_level = 0.95)

# Data with 3 groups.
data &lt;- data.frame(
  rsp = as.logical(c(1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0)),
  grp = letters[c(1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3)],
  strata = LETTERS[c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)],
  stringsAsFactors = TRUE
)

# Odds ratio based on stratified estimation by conditional logistic regression.
or_clogit(data, conf_level = 0.95)

</code></pre>

<hr>
<h2 id='h_pkparam_sort'>Sort Data by <code style="white-space: pre;">&#8288;PK PARAM&#8288;</code> Variable</h2><span id='topic+h_pkparam_sort'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_pkparam_sort(pk_data, key_var = "PARAMCD")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_pkparam_sort_+3A_pk_data">pk_data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> <code>Pharmacokinetics</code> dataframe</p>
</td></tr>
<tr><td><code id="h_pkparam_sort_+3A_key_var">key_var</code></td>
<td>
<p>(<code>character</code>)<br /> key variable used to merge pk_data and metadata created by <code>d_pkparam()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A PK <code>data.frame</code> sorted by a <code>PARAM</code> variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

adpp &lt;- tern_ex_adpp %&gt;% mutate(PKPARAM = factor(paste0(PARAM, " (", AVALU, ")")))
pk_ordered_data &lt;- h_pkparam_sort(adpp)

</code></pre>

<hr>
<h2 id='h_prop_diff'>Helper Functions to Calculate Proportion Difference</h2><span id='topic+h_prop_diff'></span><span id='topic+prop_diff_wald'></span><span id='topic+prop_diff_ha'></span><span id='topic+prop_diff_nc'></span><span id='topic+prop_diff_cmh'></span><span id='topic+prop_diff_strat_nc'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_diff_wald(rsp, grp, conf_level = 0.95, correct = FALSE)

prop_diff_ha(rsp, grp, conf_level)

prop_diff_nc(rsp, grp, conf_level, correct = FALSE)

prop_diff_cmh(rsp, grp, strata, conf_level = 0.95)

prop_diff_strat_nc(
  rsp,
  grp,
  strata,
  weights_method = c("cmh", "wilson_h"),
  conf_level = 0.95,
  correct = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_prop_diff_+3A_rsp">rsp</code></td>
<td>
<p>(<code>logical</code>)<br /> whether each subject is a responder or not.</p>
</td></tr>
<tr><td><code id="h_prop_diff_+3A_grp">grp</code></td>
<td>
<p>(<code>factor</code>)<br /> vector assigning observations to one out of two groups
(e.g. reference and treatment group).</p>
</td></tr>
<tr><td><code id="h_prop_diff_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="h_prop_diff_+3A_correct">correct</code></td>
<td>
<p>(<code>logical</code>)<br /> whether to include the continuity correction. For further
information, see <code><a href="stats.html#topic+prop.test">stats::prop.test()</a></code>.</p>
</td></tr>
<tr><td><code id="h_prop_diff_+3A_strata">strata</code></td>
<td>
<p>(<code>factor</code>)<br /> variable with one level per stratum and same length as <code>rsp</code>.</p>
</td></tr>
<tr><td><code id="h_prop_diff_+3A_weights_method">weights_method</code></td>
<td>
<p>(<code>string</code>)<br /> weights method. Can be either <code>"cmh"</code> or <code>"heuristic"</code>
and directs the way weights are estimated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code> of elements <code>diff</code> (proportion difference) and <code>diff_ci</code>
(proportion difference confidence interval).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>prop_diff_wald()</code>: The Wald interval follows the usual textbook
definition for a single proportion confidence interval using the normal
approximation. It is possible to include a continuity correction for Wald's
interval.
</p>
</li>
<li> <p><code>prop_diff_ha()</code>: Anderson-Hauck confidence interval.
</p>
</li>
<li> <p><code>prop_diff_nc()</code>: <code>Newcombe</code> confidence interval. It is based on
the Wilson score confidence interval for a single binomial proportion.
</p>
</li>
<li> <p><code>prop_diff_cmh()</code>: Calculates the weighted difference. This is defined as the difference in
response rates between the experimental treatment group and the control treatment group, adjusted
for stratification factors by applying <code>Cochran-Mantel-Haenszel</code> (<code>CMH</code>) weights. For the <code>CMH</code> chi-squared
test, use <code><a href="stats.html#topic+mantelhaen.test">stats::mantelhaen.test()</a></code>.
</p>
</li>
<li> <p><code>prop_diff_strat_nc()</code>: Calculates the stratified <code>Newcombe</code> confidence interval and difference in response
rates between the experimental treatment group and the control treatment group, adjusted for stratification
factors. This implementation follows closely the one proposed by Yan and Su (2010).
Weights can be estimated from the heuristic proposed in <code><a href="#topic+prop_strat_wilson">prop_strat_wilson()</a></code> or from <code>CMH</code>-derived weights
(see <code><a href="#topic+prop_diff_cmh">prop_diff_cmh()</a></code>).
</p>
</li></ul>


<h3>References</h3>

<p>Yan X, Su XG (2010).
&ldquo;Stratified Wilson and Newcombe Confidence Intervals for Multiple Binomial Proportions.&rdquo;
<em>Stat. Biopharm. Res.</em>, <b>2</b>(3), 329&ndash;335.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prop_diff">prop_diff()</a></code> for implementation of these helper functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Wald confidence interval
set.seed(2)
rsp &lt;- sample(c(TRUE, FALSE), replace = TRUE, size = 20)
grp &lt;- factor(c(rep("A", 10), rep("B", 10)))

prop_diff_wald(rsp = rsp, grp = grp, conf_level = 0.95, correct = FALSE)

# Anderson-Hauck confidence interval
## "Mid" case: 3/4 respond in group A, 1/2 respond in group B.
rsp &lt;- c(TRUE, FALSE, FALSE, TRUE, TRUE, TRUE)
grp &lt;- factor(c("A", "B", "A", "B", "A", "A"), levels = c("B", "A"))

prop_diff_ha(rsp = rsp, grp = grp, conf_level = 0.90)

## Edge case: Same proportion of response in A and B.
rsp &lt;- c(TRUE, FALSE, TRUE, FALSE)
grp &lt;- factor(c("A", "A", "B", "B"), levels = c("A", "B"))

prop_diff_ha(rsp = rsp, grp = grp, conf_level = 0.6)

# `Newcombe` confidence interval

set.seed(1)
rsp &lt;- c(
  sample(c(TRUE, FALSE), size = 40, prob = c(3 / 4, 1 / 4), replace = TRUE),
  sample(c(TRUE, FALSE), size = 40, prob = c(1 / 2, 1 / 2), replace = TRUE)
)
grp &lt;- factor(rep(c("A", "B"), each = 40), levels = c("B", "A"))
table(rsp, grp)

prop_diff_nc(rsp = rsp, grp = grp, conf_level = 0.9)

# Cochran-Mantel-Haenszel confidence interval

set.seed(2)
rsp &lt;- sample(c(TRUE, FALSE), 100, TRUE)
grp &lt;- sample(c("Placebo", "Treatment"), 100, TRUE)
grp &lt;- factor(grp, levels = c("Placebo", "Treatment"))
strata_data &lt;- data.frame(
  "f1" = sample(c("a", "b"), 100, TRUE),
  "f2" = sample(c("x", "y", "z"), 100, TRUE),
  stringsAsFactors = TRUE
)

prop_diff_cmh(
  rsp = rsp, grp = grp, strata = interaction(strata_data),
  conf_level = 0.90
)

# Stratified `Newcombe` confidence interval

set.seed(2)
data_set &lt;- data.frame(
  "rsp" = sample(c(TRUE, FALSE), 100, TRUE),
  "f1" = sample(c("a", "b"), 100, TRUE),
  "f2" = sample(c("x", "y", "z"), 100, TRUE),
  "grp" = sample(c("Placebo", "Treatment"), 100, TRUE),
  stringsAsFactors = TRUE
)

prop_diff_strat_nc(
  rsp = data_set$rsp, grp = data_set$grp, strata = interaction(data_set[2:3]),
  weights_method = "cmh",
  conf_level = 0.90
)

prop_diff_strat_nc(
  rsp = data_set$rsp, grp = data_set$grp, strata = interaction(data_set[2:3]),
  weights_method = "wilson_h",
  conf_level = 0.90
)

</code></pre>

<hr>
<h2 id='h_prop_diff_test'>Helper Functions to Test Proportion Differences</h2><span id='topic+h_prop_diff_test'></span><span id='topic+prop_chisq'></span><span id='topic+prop_cmh'></span><span id='topic+prop_schouten'></span><span id='topic+prop_fisher'></span>

<h3>Description</h3>

<p>Helper functions to implement various tests on the difference between two proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_chisq(tbl)

prop_cmh(ary)

prop_schouten(tbl)

prop_fisher(tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_prop_diff_test_+3A_tbl">tbl</code></td>
<td>
<p>(<code>matrix</code>)<br /> matrix with two groups in rows and the binary response (<code>TRUE</code>/<code>FALSE</code>) in columns.</p>
</td></tr>
<tr><td><code id="h_prop_diff_test_+3A_ary">ary</code></td>
<td>
<p>(<code>array</code>, 3 dimensions)<br /> array with two groups in rows, the binary response
(<code>TRUE</code>/<code>FALSE</code>) in columns, and the strata in the third dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A p-value.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>prop_chisq()</code>: performs Chi-Squared test. Internally calls <code><a href="stats.html#topic+prop.test">stats::prop.test()</a></code>.
</p>
</li>
<li> <p><code>prop_cmh()</code>: performs stratified Cochran-Mantel-Haenszel test. Internally calls
<code><a href="stats.html#topic+mantelhaen.test">stats::mantelhaen.test()</a></code>. Note that strata with less than two observations are automatically discarded.
</p>
</li>
<li> <p><code>prop_schouten()</code>: performs the Chi-Squared test with Schouten correction.
</p>
</li>
<li> <p><code>prop_fisher()</code>: performs the Fisher's exact test. Internally calls <code><a href="stats.html#topic+fisher.test">stats::fisher.test()</a></code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+prop_diff_test">prop_diff_test()</a></code> for implementation of these helper functions.
</p>
<p>Schouten correction is based upon Schouten et al. (1980).
</p>

<hr>
<h2 id='h_proportions'>Helper Functions for Calculating Proportion Confidence Intervals</h2><span id='topic+h_proportions'></span><span id='topic+prop_wilson'></span><span id='topic+prop_strat_wilson'></span><span id='topic+prop_clopper_pearson'></span><span id='topic+prop_wald'></span><span id='topic+prop_agresti_coull'></span><span id='topic+prop_jeffreys'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Functions to calculate different proportion confidence intervals for use in <code><a href="#topic+estimate_proportion">estimate_proportion()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_wilson(rsp, conf_level, correct = FALSE)

prop_strat_wilson(
  rsp,
  strata,
  weights = NULL,
  conf_level = 0.95,
  max_iterations = NULL,
  correct = FALSE
)

prop_clopper_pearson(rsp, conf_level)

prop_wald(rsp, conf_level, correct = FALSE)

prop_agresti_coull(rsp, conf_level)

prop_jeffreys(rsp, conf_level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_proportions_+3A_rsp">rsp</code></td>
<td>
<p>(<code>logical</code>)<br /> whether each subject is a responder or not.</p>
</td></tr>
<tr><td><code id="h_proportions_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="h_proportions_+3A_correct">correct</code></td>
<td>
<p>(<code>flag</code>)<br /> apply continuity correction.</p>
</td></tr>
<tr><td><code id="h_proportions_+3A_strata">strata</code></td>
<td>
<p>(<code>factor</code>)<br /> variable with one level per stratum and same length as <code>rsp</code>.</p>
</td></tr>
<tr><td><code id="h_proportions_+3A_weights">weights</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br /> weights for each level of the strata. If <code>NULL</code>, they are
estimated using the iterative algorithm proposed in Yan and Su (2010) that
minimizes the weighted squared length of the confidence interval.</p>
</td></tr>
<tr><td><code id="h_proportions_+3A_max_iterations">max_iterations</code></td>
<td>
<p>(<code>count</code>)<br /> maximum number of iterations for the iterative procedure used
to find estimates of optimal weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Confidence interval of a proportion.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>prop_wilson()</code>: Calculates the Wilson interval by calling <code><a href="stats.html#topic+prop.test">stats::prop.test()</a></code>.
Also referred to as Wilson score interval.
</p>
</li>
<li> <p><code>prop_strat_wilson()</code>: Calculates the stratified Wilson confidence
interval for unequal proportions as described in Yan and Su (2010)
</p>
</li>
<li> <p><code>prop_clopper_pearson()</code>: Calculates the Clopper-Pearson interval by calling <code><a href="stats.html#topic+binom.test">stats::binom.test()</a></code>.
Also referred to as the <code>exact</code> method.
</p>
</li>
<li> <p><code>prop_wald()</code>: Calculates the Wald interval by following the usual textbook definition
for a single proportion confidence interval using the normal approximation.
</p>
</li>
<li> <p><code>prop_agresti_coull()</code>: Calculates the <code>Agresti-Coull</code> interval (created by <code style="white-space: pre;">&#8288;Alan Agresti&#8288;</code> and <code style="white-space: pre;">&#8288;Brent Coull&#8288;</code>) by
(for 95% CI) adding two successes and two failures to the data and then using the Wald formula to construct a CI.
</p>
</li>
<li> <p><code>prop_jeffreys()</code>: Calculates the Jeffreys interval, an equal-tailed interval based on the
non-informative Jeffreys prior for a binomial proportion.
</p>
</li></ul>


<h3>References</h3>

<p>Yan X, Su XG (2010).
&ldquo;Stratified Wilson and Newcombe Confidence Intervals for Multiple Binomial Proportions.&rdquo;
<em>Stat. Biopharm. Res.</em>, <b>2</b>(3), 329&ndash;335.
</p>


<h3>See Also</h3>

<p><a href="#topic+estimate_proportions">estimate_proportions</a>, descriptive function <code><a href="#topic+d_proportion">d_proportion()</a></code>,
and helper functions <code><a href="#topic+strata_normal_quantile">strata_normal_quantile()</a></code> and <code><a href="#topic+update_weights_strat_wilson">update_weights_strat_wilson()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rsp &lt;- c(
  TRUE, TRUE, TRUE, TRUE, TRUE,
  FALSE, FALSE, FALSE, FALSE, FALSE
)
prop_wilson(rsp, conf_level = 0.9)

# Stratified Wilson confidence interval with unequal probabilities

set.seed(1)
rsp &lt;- sample(c(TRUE, FALSE), 100, TRUE)
strata_data &lt;- data.frame(
  "f1" = sample(c("a", "b"), 100, TRUE),
  "f2" = sample(c("x", "y", "z"), 100, TRUE),
  stringsAsFactors = TRUE
)
strata &lt;- interaction(strata_data)
n_strata &lt;- ncol(table(rsp, strata)) # Number of strata

prop_strat_wilson(
  rsp = rsp, strata = strata,
  conf_level = 0.90
)

# Not automatic setting of weights
prop_strat_wilson(
  rsp = rsp, strata = strata,
  weights = rep(1 / n_strata, n_strata),
  conf_level = 0.90
)

prop_clopper_pearson(rsp, conf_level = .95)

prop_wald(rsp, conf_level = 0.95)
prop_wald(rsp, conf_level = 0.95, correct = TRUE)

prop_agresti_coull(rsp, conf_level = 0.95)

prop_jeffreys(rsp, conf_level = 0.95)

</code></pre>

<hr>
<h2 id='h_response_biomarkers_subgroups'>Helper Functions for Tabulating Biomarker Effects on Binary Response by Subgroup</h2><span id='topic+h_response_biomarkers_subgroups'></span><span id='topic+h_rsp_to_logistic_variables'></span><span id='topic+h_logistic_mult_cont_df'></span><span id='topic+h_tab_rsp_one_biomarker'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper functions which are documented here separately to not confuse the user
when reading about the user-facing functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_rsp_to_logistic_variables(variables, biomarker)

h_logistic_mult_cont_df(variables, data, control = control_logistic())

h_tab_rsp_one_biomarker(df, vars, na_str = default_na_str(), .indent_mods = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_response_biomarkers_subgroups_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="h_response_biomarkers_subgroups_+3A_biomarker">biomarker</code></td>
<td>
<p>(<code>string</code>)<br /> the name of the biomarker variable.</p>
</td></tr>
<tr><td><code id="h_response_biomarkers_subgroups_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to summarize.</p>
</td></tr>
<tr><td><code id="h_response_biomarkers_subgroups_+3A_control">control</code></td>
<td>
<p>(named <code>list</code>)<br /> controls for the response definition and the
confidence level produced by <code><a href="#topic+control_logistic">control_logistic()</a></code>.</p>
</td></tr>
<tr><td><code id="h_response_biomarkers_subgroups_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> results for a single biomarker, as part of what is
returned by <code><a href="#topic+extract_rsp_biomarkers">extract_rsp_biomarkers()</a></code> (it needs a couple of columns which are
added by that high-level function relative to what is returned by <code><a href="#topic+h_logistic_mult_cont_df">h_logistic_mult_cont_df()</a></code>,
see the example).</p>
</td></tr>
<tr><td><code id="h_response_biomarkers_subgroups_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> the names of statistics to be reported among:
</p>

<ul>
<li> <p><code>n_tot</code>: Total number of patients per group.
</p>
</li>
<li> <p><code>n_rsp</code>: Total number of responses per group.
</p>
</li>
<li> <p><code>prop</code>: Total response proportion per group.
</p>
</li>
<li> <p><code>or</code>: Odds ratio.
</p>
</li>
<li> <p><code>ci</code>: Confidence interval of odds ratio.
</p>
</li>
<li> <p><code>pval</code>: p-value of the effect.
Note, the statistics <code>n_tot</code>, <code>or</code> and <code>ci</code> are required.
</p>
</li></ul>
</td></tr>
<tr><td><code id="h_response_biomarkers_subgroups_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="h_response_biomarkers_subgroups_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>h_rsp_to_logistic_variables()</code> returns a named <code>list</code> of elements <code>response</code>, <code>arm</code>, <code>covariates</code>, and <code>strata</code>.
</p>
</li></ul>


<ul>
<li> <p><code>h_logistic_mult_cont_df()</code> returns a <code>data.frame</code> containing estimates and statistics for the selected biomarkers.
</p>
</li></ul>


<ul>
<li> <p><code>h_tab_rsp_one_biomarker()</code> returns an <code>rtables</code> table object with the given statistics arranged in columns.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>h_rsp_to_logistic_variables()</code>: helps with converting the &quot;response&quot; function variable list
to the &quot;logistic regression&quot; variable list. The reason is that currently there is an
inconsistency between the variable names accepted by <code>extract_rsp_subgroups()</code> and <code>fit_logistic()</code>.
</p>
</li>
<li> <p><code>h_logistic_mult_cont_df()</code>: prepares estimates for number of responses, patients and
overall response rate, as well as odds ratio estimates, confidence intervals and p-values, for multiple
biomarkers in a given single data set.
<code>variables</code> corresponds to names of variables found in <code>data</code>, passed as a named list and requires elements
<code>rsp</code> and <code>biomarkers</code> (vector of continuous biomarker variables) and optionally <code>covariates</code>
and <code>strat</code>.
</p>
</li>
<li> <p><code>h_tab_rsp_one_biomarker()</code>: prepares a single sub-table given a <code>df_sub</code> containing
the results for a single biomarker.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(forcats)

adrs &lt;- tern_ex_adrs
adrs_labels &lt;- formatters::var_labels(adrs)

adrs_f &lt;- adrs %&gt;%
  filter(PARAMCD == "BESRSPI") %&gt;%
  mutate(rsp = AVALC == "CR")
formatters::var_labels(adrs_f) &lt;- c(adrs_labels, "Response")

# This is how the variable list is converted internally.
h_rsp_to_logistic_variables(
  variables = list(
    rsp = "RSP",
    covariates = c("A", "B"),
    strat = "D"
  ),
  biomarker = "AGE"
)

# For a single population, estimate separately the effects
# of two biomarkers.
df &lt;- h_logistic_mult_cont_df(
  variables = list(
    rsp = "rsp",
    biomarkers = c("BMRKR1", "AGE"),
    covariates = "SEX"
  ),
  data = adrs_f
)
df

# If the data set is empty, still the corresponding rows with missings are returned.
h_coxreg_mult_cont_df(
  variables = list(
    rsp = "rsp",
    biomarkers = c("BMRKR1", "AGE"),
    covariates = "SEX",
    strat = "STRATA1"
  ),
  data = adrs_f[NULL, ]
)

# Starting from above `df`, zoom in on one biomarker and add required columns.
df1 &lt;- df[1, ]
df1$subgroup &lt;- "All patients"
df1$row_type &lt;- "content"
df1$var &lt;- "ALL"
df1$var_label &lt;- "All patients"

h_tab_rsp_one_biomarker(
  df1,
  vars = c("n_tot", "n_rsp", "prop", "or", "ci", "pval")
)

</code></pre>

<hr>
<h2 id='h_response_subgroups'>Helper Functions for Tabulating Binary Response by Subgroup</h2><span id='topic+h_response_subgroups'></span><span id='topic+h_proportion_df'></span><span id='topic+h_proportion_subgroups_df'></span><span id='topic+h_odds_ratio_df'></span><span id='topic+h_odds_ratio_subgroups_df'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper functions that tabulate in a data frame statistics such as response rate
and odds ratio for population subgroups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_proportion_df(rsp, arm)

h_proportion_subgroups_df(
  variables,
  data,
  groups_lists = list(),
  label_all = "All Patients"
)

h_odds_ratio_df(rsp, arm, strata_data = NULL, conf_level = 0.95, method = NULL)

h_odds_ratio_subgroups_df(
  variables,
  data,
  groups_lists = list(),
  conf_level = 0.95,
  method = NULL,
  label_all = "All Patients"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_response_subgroups_+3A_rsp">rsp</code></td>
<td>
<p>(<code>logical</code>)<br /> whether each subject is a responder or not.</p>
</td></tr>
<tr><td><code id="h_response_subgroups_+3A_arm">arm</code></td>
<td>
<p>(<code>factor</code>)<br /> the treatment group variable.</p>
</td></tr>
<tr><td><code id="h_response_subgroups_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="h_response_subgroups_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to summarize.</p>
</td></tr>
<tr><td><code id="h_response_subgroups_+3A_groups_lists">groups_lists</code></td>
<td>
<p>(named <code>list</code> of <code>list</code>)<br /> optionally contains for each <code>subgroups</code> variable a
list, which specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
<tr><td><code id="h_response_subgroups_+3A_label_all">label_all</code></td>
<td>
<p>(<code>string</code>)<br /> label for the total population analysis.</p>
</td></tr>
<tr><td><code id="h_response_subgroups_+3A_strata_data">strata_data</code></td>
<td>
<p>(<code>factor</code>, <code>data.frame</code> or <code>NULL</code>)<br /> required if stratified analysis is performed.</p>
</td></tr>
<tr><td><code id="h_response_subgroups_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="h_response_subgroups_+3A_method">method</code></td>
<td>
<p>(<code>string</code>)<br /> specifies the test used to calculate the p-value for the difference between
two proportions. For options, see <code><a href="#topic+s_test_proportion_diff">s_test_proportion_diff()</a></code>. Default is <code>NULL</code> so no test is performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Main functionality is to prepare data for use in a layout-creating function.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>h_proportion_df()</code> returns a <code>data.frame</code> with columns <code>arm</code>, <code>n</code>, <code>n_rsp</code>, and <code>prop</code>.
</p>
</li></ul>


<ul>
<li> <p><code>h_proportion_subgroups_df()</code> returns a <code>data.frame</code> with columns <code>arm</code>, <code>n</code>, <code>n_rsp</code>, <code>prop</code>, <code>subgroup</code>,
<code>var</code>, <code>var_label</code>, and <code>row_type</code>.
</p>
</li></ul>


<ul>
<li> <p><code>h_odds_ratio_df()</code> returns a <code>data.frame</code> with columns <code>arm</code>, <code>n_tot</code>, <code>or</code>, <code>lcl</code>, <code>ucl</code>, <code>conf_level</code>, and
optionally <code>pval</code> and <code>pval_label</code>.
</p>
</li></ul>


<ul>
<li> <p><code>h_odds_ratio_subgroups_df()</code> returns a <code>data.frame</code> with columns <code>arm</code>, <code>n_tot</code>, <code>or</code>, <code>lcl</code>, <code>ucl</code>,
<code>conf_level</code>, <code>subgroup</code>, <code>var</code>, <code>var_label</code>, and <code>row_type</code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>h_proportion_df()</code>: helper to prepare a data frame of binary responses by arm.
</p>
</li>
<li> <p><code>h_proportion_subgroups_df()</code>: summarizes proportion of binary responses by arm and across subgroups
in a data frame. <code>variables</code> corresponds to the names of variables found in <code>data</code>, passed as a named list and
requires elements <code>rsp</code>, <code>arm</code> and optionally <code>subgroups</code>. <code>groups_lists</code> optionally specifies
groupings for <code>subgroups</code> variables.
</p>
</li>
<li> <p><code>h_odds_ratio_df()</code>: helper to prepare a data frame with estimates of
the odds ratio between a treatment and a control arm.
</p>
</li>
<li> <p><code>h_odds_ratio_subgroups_df()</code>: summarizes estimates of the odds ratio between a treatment and a control
arm across subgroups in a data frame. <code>variables</code> corresponds to the names of variables found in
<code>data</code>, passed as a named list and requires elements <code>rsp</code>, <code>arm</code> and optionally <code>subgroups</code>
and <code>strat</code>. <code>groups_lists</code> optionally specifies groupings for <code>subgroups</code> variables.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(forcats)

adrs &lt;- tern_ex_adrs
adrs_labels &lt;- formatters::var_labels(adrs)

adrs_f &lt;- adrs %&gt;%
  filter(PARAMCD == "BESRSPI") %&gt;%
  filter(ARM %in% c("A: Drug X", "B: Placebo")) %&gt;%
  droplevels() %&gt;%
  mutate(
    # Reorder levels of factor to make the placebo group the reference arm.
    ARM = fct_relevel(ARM, "B: Placebo"),
    rsp = AVALC == "CR"
  )
formatters::var_labels(adrs_f) &lt;- c(adrs_labels, "Response")

h_proportion_df(
  c(TRUE, FALSE, FALSE),
  arm = factor(c("A", "A", "B"), levels = c("A", "B"))
)

h_proportion_subgroups_df(
  variables = list(rsp = "rsp", arm = "ARM", subgroups = c("SEX", "BMRKR2")),
  data = adrs_f
)

# Define groupings for BMRKR2 levels.
h_proportion_subgroups_df(
  variables = list(rsp = "rsp", arm = "ARM", subgroups = c("SEX", "BMRKR2")),
  data = adrs_f,
  groups_lists = list(
    BMRKR2 = list(
      "low" = "LOW",
      "low/medium" = c("LOW", "MEDIUM"),
      "low/medium/high" = c("LOW", "MEDIUM", "HIGH")
    )
  )
)

# Unstratatified analysis.
h_odds_ratio_df(
  c(TRUE, FALSE, FALSE, TRUE),
  arm = factor(c("A", "A", "B", "B"), levels = c("A", "B"))
)

# Include p-value.
h_odds_ratio_df(adrs_f$rsp, adrs_f$ARM, method = "chisq")

# Stratatified analysis.
h_odds_ratio_df(
  rsp = adrs_f$rsp,
  arm = adrs_f$ARM,
  strata_data = adrs_f[, c("STRATA1", "STRATA2")],
  method = "cmh"
)

# Unstratified analysis.
h_odds_ratio_subgroups_df(
  variables = list(rsp = "rsp", arm = "ARM", subgroups = c("SEX", "BMRKR2")),
  data = adrs_f
)

# Stratified analysis.
h_odds_ratio_subgroups_df(
  variables = list(
    rsp = "rsp",
    arm = "ARM",
    subgroups = c("SEX", "BMRKR2"),
    strat = c("STRATA1", "STRATA2")
  ),
  data = adrs_f
)

# Define groupings of BMRKR2 levels.
h_odds_ratio_subgroups_df(
  variables = list(
    rsp = "rsp",
    arm = "ARM",
    subgroups = c("SEX", "BMRKR2")
  ),
  data = adrs_f,
  groups_lists = list(
    BMRKR2 = list(
      "low" = "LOW",
      "low/medium" = c("LOW", "MEDIUM"),
      "low/medium/high" = c("LOW", "MEDIUM", "HIGH")
    )
  )
)

</code></pre>

<hr>
<h2 id='h_split_by_subgroups'>Split Dataframe by Subgroups</h2><span id='topic+h_split_by_subgroups'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Split a dataframe into a non-nested list of subsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_split_by_subgroups(data, subgroups, groups_lists = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_split_by_subgroups_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> dataset to split.</p>
</td></tr>
<tr><td><code id="h_split_by_subgroups_+3A_subgroups">subgroups</code></td>
<td>
<p>(<code>character</code>)<br /> names of factor variables from <code>data</code> used to create subsets.
Unused levels not present in <code>data</code> are dropped. Note that the order in this vector
determines the order in the downstream table.</p>
</td></tr>
<tr><td><code id="h_split_by_subgroups_+3A_groups_lists">groups_lists</code></td>
<td>
<p>(named <code>list</code> of <code>list</code>)<br /> optionally contains for each <code>subgroups</code> variable a
list, which specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Main functionality is to prepare data for use in forest plot layouts.
</p>


<h3>Value</h3>

<p>A list with subset data (<code>df</code>) and metadata about the subset (<code>df_labels</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  x = c(1:5),
  y = factor(c("A", "B", "A", "B", "A"), levels = c("A", "B", "C")),
  z = factor(c("C", "C", "D", "D", "D"), levels = c("D", "C"))
)
formatters::var_labels(df) &lt;- paste("label for", names(df))

h_split_by_subgroups(
  data = df,
  subgroups = c("y", "z")
)

h_split_by_subgroups(
  data = df,
  subgroups = c("y", "z"),
  groups_lists = list(
    y = list("AB" = c("A", "B"), "C" = "C")
  )
)

</code></pre>

<hr>
<h2 id='h_split_param'>Split parameters</h2><span id='topic+h_split_param'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>It divides the data in the vector <code>param</code> into the groups defined by <code>f</code> based on specified <code>values</code>. It is relevant
in <code>rtables</code> layers so as to distribute parameters <code>.stats</code> or' <code>.formats</code> into lists with items corresponding to
specific analysis function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_split_param(param, value, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_split_param_+3A_param">param</code></td>
<td>
<p>(<code>vector</code>)<br /> the parameter to be split.</p>
</td></tr>
<tr><td><code id="h_split_param_+3A_value">value</code></td>
<td>
<p>(<code>vector</code>)<br /> the value used to split.</p>
</td></tr>
<tr><td><code id="h_split_param_+3A_f">f</code></td>
<td>
<p>(<code>list</code> of <code>vectors</code>)<br /> the reference to make the split</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code> with the same element names as <code>f</code>, each containing the elements specified in <code>.stats</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- list(
  surv = c("pt_at_risk", "event_free_rate", "rate_se", "rate_ci"),
  surv_diff = c("rate_diff", "rate_diff_ci", "ztest_pval")
)

.stats &lt;- c("pt_at_risk", "rate_diff")
h_split_param(.stats, .stats, f = f)

# $surv
# [1] "pt_at_risk"
#
# $surv_diff
# [1] "rate_diff"

.formats &lt;- c("pt_at_risk" = "xx", "event_free_rate" = "xxx")
h_split_param(.formats, names(.formats), f = f)

# $surv
# pt_at_risk event_free_rate
# "xx"           "xxx"
#
# $surv_diff
# NULL

</code></pre>

<hr>
<h2 id='h_stack_by_baskets'>Helper Function to create a new <code>SMQ</code> variable in <code>ADAE</code> by stacking <code>SMQ</code> and/or <code>CQ</code> records.</h2><span id='topic+h_stack_by_baskets'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper Function to create a new <code>SMQ</code> variable in <code>ADAE</code> that consists of all adverse events belonging to
selected Standardized/Customized queries. The new dataset will only contain records of the adverse events
belonging to any of the selected baskets. Remember that <code>na_str</code> must match the needed pre-processing
done with <code><a href="#topic+df_explicit_na">df_explicit_na()</a></code> to have the desired output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_stack_by_baskets(
  df,
  baskets = grep("^(SMQ|CQ).+NAM$", names(df), value = TRUE),
  smq_varlabel = "Standardized MedDRA Query",
  keys = c("STUDYID", "USUBJID", "ASTDTM", "AEDECOD", "AESEQ"),
  aag_summary = NULL,
  na_level = lifecycle::deprecated(),
  na_str = "&lt;Missing&gt;"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_stack_by_baskets_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="h_stack_by_baskets_+3A_baskets">baskets</code></td>
<td>
<p>(<code>character</code>)<br /> variable names of the selected Standardized/Customized queries.</p>
</td></tr>
<tr><td><code id="h_stack_by_baskets_+3A_smq_varlabel">smq_varlabel</code></td>
<td>
<p>(<code>string</code>)<br /> a label for the new variable created.</p>
</td></tr>
<tr><td><code id="h_stack_by_baskets_+3A_keys">keys</code></td>
<td>
<p>(<code>character</code>)<br /> names of the key variables to be returned along with the new variable created.</p>
</td></tr>
<tr><td><code id="h_stack_by_baskets_+3A_aag_summary">aag_summary</code></td>
<td>
<p>(<code>data.frame</code>)<br /> containing the <code>SMQ</code> baskets and the levels of interest for the final <code>SMQ</code>
variable. This is useful when there are some levels of interest that are not observed in the <code>df</code> dataset.
The two columns of this dataset should be named <code>basket</code> and <code>basket_name</code>.</p>
</td></tr>
<tr><td><code id="h_stack_by_baskets_+3A_na_level">na_level</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use the <code>na_str</code> argument instead.</p>
</td></tr>
<tr><td><code id="h_stack_by_baskets_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with variables in <code>keys</code> taken from <code>df</code> and new variable <code>SMQ</code> containing
records belonging to the baskets selected via the <code>baskets</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adae &lt;- tern_ex_adae[1:20, ] %&gt;% df_explicit_na()
h_stack_by_baskets(df = adae)

aag &lt;- data.frame(
  NAMVAR = c("CQ01NAM", "CQ02NAM", "SMQ01NAM", "SMQ02NAM"),
  REFNAME = c(
    "D.2.1.5.3/A.1.1.1.1 AESI", "X.9.9.9.9/Y.8.8.8.8 AESI",
    "C.1.1.1.3/B.2.2.3.1 AESI", "C.1.1.1.3/B.3.3.3.3 AESI"
  ),
  SCOPE = c("", "", "BROAD", "BROAD"),
  stringsAsFactors = FALSE
)

basket_name &lt;- character(nrow(aag))
cq_pos &lt;- grep("^(CQ).+NAM$", aag$NAMVAR)
smq_pos &lt;- grep("^(SMQ).+NAM$", aag$NAMVAR)
basket_name[cq_pos] &lt;- aag$REFNAME[cq_pos]
basket_name[smq_pos] &lt;- paste0(
  aag$REFNAME[smq_pos], "(", aag$SCOPE[smq_pos], ")"
)

aag_summary &lt;- data.frame(
  basket = aag$NAMVAR,
  basket_name = basket_name,
  stringsAsFactors = TRUE
)

result &lt;- h_stack_by_baskets(df = adae, aag_summary = aag_summary)
all(levels(aag_summary$basket_name) %in% levels(result$SMQ))

h_stack_by_baskets(
  df = adae,
  aag_summary = NULL,
  keys = c("STUDYID", "USUBJID", "AEDECOD", "ARM"),
  baskets = "SMQ01NAM"
)

</code></pre>

<hr>
<h2 id='h_step'>Helper Functions for Subgroup Treatment Effect Pattern (STEP) Calculations</h2><span id='topic+h_step'></span><span id='topic+h_step_window'></span><span id='topic+h_step_trt_effect'></span><span id='topic+h_step_survival_formula'></span><span id='topic+h_step_survival_est'></span><span id='topic+h_step_rsp_formula'></span><span id='topic+h_step_rsp_est'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper functions that are used internally for the STEP calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_step_window(x, control = control_step())

h_step_trt_effect(data, model, variables, x)

h_step_survival_formula(variables, control = control_step())

h_step_survival_est(
  formula,
  data,
  variables,
  x,
  subset = rep(TRUE, nrow(data)),
  control = control_coxph()
)

h_step_rsp_formula(variables, control = c(control_step(), control_logistic()))

h_step_rsp_est(
  formula,
  data,
  variables,
  x,
  subset = rep(TRUE, nrow(data)),
  control = control_logistic()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_step_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> biomarker value(s) to use (without <code>NA</code>).</p>
</td></tr>
<tr><td><code id="h_step_+3A_control">control</code></td>
<td>
<p>(named <code>list</code>)<br /> output from <code>control_step()</code>.</p>
</td></tr>
<tr><td><code id="h_step_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to summarize.</p>
</td></tr>
<tr><td><code id="h_step_+3A_model">model</code></td>
<td>
<p>the regression model object.</p>
</td></tr>
<tr><td><code id="h_step_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="h_step_+3A_formula">formula</code></td>
<td>
<p>(<code>formula</code>)<br /> the regression model formula.</p>
</td></tr>
<tr><td><code id="h_step_+3A_subset">subset</code></td>
<td>
<p>(<code>logical</code>)<br /> subset vector.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>h_step_window()</code> returns a list containing the window-selection matrix <code>sel</code>
and the interval information matrix <code>interval</code>.
</p>
</li></ul>


<ul>
<li> <p><code>h_step_trt_effect()</code> returns a vector with elements <code>est</code> and <code>se</code>.
</p>
</li></ul>


<ul>
<li> <p><code>h_step_survival_formula()</code> returns a model formula.
</p>
</li></ul>


<ul>
<li> <p><code>h_step_survival_est()</code> returns a matrix of number of observations <code>n</code>,
<code>events</code>, log hazard ratio estimates <code>loghr</code>, standard error <code>se</code>,
and Wald confidence interval bounds <code>ci_lower</code> and <code>ci_upper</code>. One row is
included for each biomarker value in <code>x</code>.
</p>
</li></ul>


<ul>
<li> <p><code>h_step_rsp_formula()</code> returns a model formula.
</p>
</li></ul>


<ul>
<li> <p><code>h_step_rsp_est()</code> returns a matrix of number of observations <code>n</code>, log odds
ratio estimates <code>logor</code>, standard error <code>se</code>, and Wald confidence interval bounds
<code>ci_lower</code> and <code>ci_upper</code>. One row is included for each biomarker value in <code>x</code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>h_step_window()</code>: creates the windows for STEP, based on the control settings
provided.
</p>
</li>
<li> <p><code>h_step_trt_effect()</code>: calculates the estimated treatment effect estimate
on the linear predictor scale and corresponding standard error from a STEP <code>model</code> fitted
on <code>data</code> given <code>variables</code> specification, for a single biomarker value <code>x</code>.
This works for both <code>coxph</code> and <code>glm</code> models, i.e. for calculating log hazard ratio or log odds
ratio estimates.
</p>
</li>
<li> <p><code>h_step_survival_formula()</code>: builds the model formula used in survival STEP calculations.
</p>
</li>
<li> <p><code>h_step_survival_est()</code>: estimates the model with <code>formula</code> built based on
<code>variables</code> in <code>data</code> for a given <code>subset</code> and <code>control</code> parameters for the
Cox regression.
</p>
</li>
<li> <p><code>h_step_rsp_formula()</code>: builds the model formula used in response STEP calculations.
</p>
</li>
<li> <p><code>h_step_rsp_est()</code>: estimates the model with <code>formula</code> built based on
<code>variables</code> in <code>data</code> for a given <code>subset</code> and <code>control</code> parameters for the
logistic regression.
</p>
</li></ul>

<hr>
<h2 id='h_survival_biomarkers_subgroups'>Helper Functions for Tabulating Biomarker Effects on Survival by Subgroup</h2><span id='topic+h_survival_biomarkers_subgroups'></span><span id='topic+h_surv_to_coxreg_variables'></span><span id='topic+h_coxreg_mult_cont_df'></span><span id='topic+h_tab_surv_one_biomarker'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper functions which are documented here separately to not confuse the user
when reading about the user-facing functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_surv_to_coxreg_variables(variables, biomarker)

h_coxreg_mult_cont_df(variables, data, control = control_coxreg())

h_tab_surv_one_biomarker(
  df,
  vars,
  time_unit,
  na_str = default_na_str(),
  .indent_mods = 0L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_survival_biomarkers_subgroups_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="h_survival_biomarkers_subgroups_+3A_biomarker">biomarker</code></td>
<td>
<p>(<code>string</code>)<br /> the name of the biomarker variable.</p>
</td></tr>
<tr><td><code id="h_survival_biomarkers_subgroups_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to summarize.</p>
</td></tr>
<tr><td><code id="h_survival_biomarkers_subgroups_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> a list of parameters as returned by the helper function <code><a href="#topic+control_coxreg">control_coxreg()</a></code>.</p>
</td></tr>
<tr><td><code id="h_survival_biomarkers_subgroups_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> results for a single biomarker, as part of what is
returned by <code><a href="#topic+extract_survival_biomarkers">extract_survival_biomarkers()</a></code> (it needs a couple of columns which are
added by that high-level function relative to what is returned by <code><a href="#topic+h_coxreg_mult_cont_df">h_coxreg_mult_cont_df()</a></code>,
see the example).</p>
</td></tr>
<tr><td><code id="h_survival_biomarkers_subgroups_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> the names of statistics to be reported among:
</p>

<ul>
<li> <p><code>n_tot_events</code>: Total number of events per group.
</p>
</li>
<li> <p><code>n_tot</code>: Total number of observations per group.
</p>
</li>
<li> <p><code>median</code>: Median survival time.
</p>
</li>
<li> <p><code>hr</code>: Hazard ratio.
</p>
</li>
<li> <p><code>ci</code>: Confidence interval of hazard ratio.
</p>
</li>
<li> <p><code>pval</code>: p-value of the effect.
Note, one of the statistics <code>n_tot</code> and <code>n_tot_events</code>, as well as both <code>hr</code> and <code>ci</code> are required.
</p>
</li></ul>
</td></tr>
<tr><td><code id="h_survival_biomarkers_subgroups_+3A_time_unit">time_unit</code></td>
<td>
<p>(<code>string</code>)<br /> label with unit of median survival time. Default <code>NULL</code> skips displaying unit.</p>
</td></tr>
<tr><td><code id="h_survival_biomarkers_subgroups_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="h_survival_biomarkers_subgroups_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="h_survival_biomarkers_subgroups_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>h_surv_to_coxreg_variables()</code> returns a named <code>list</code> of elements <code>time</code>, <code>event</code>, <code>arm</code>,
<code>covariates</code>, and <code>strata</code>.
</p>
</li></ul>


<ul>
<li> <p><code>h_coxreg_mult_cont_df()</code> returns a <code>data.frame</code> containing estimates and statistics for the selected biomarkers.
</p>
</li></ul>


<ul>
<li> <p><code>h_tab_surv_one_biomarker()</code> returns an <code>rtables</code> table object with the given statistics arranged in columns.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>h_surv_to_coxreg_variables()</code>: helps with converting the &quot;survival&quot; function variable list
to the &quot;Cox regression&quot; variable list. The reason is that currently there is an inconsistency between the variable
names accepted by <code>extract_survival_subgroups()</code> and <code>fit_coxreg_multivar()</code>.
</p>
</li>
<li> <p><code>h_coxreg_mult_cont_df()</code>: prepares estimates for number of events, patients and median survival
times, as well as hazard ratio estimates, confidence intervals and p-values, for multiple biomarkers
in a given single data set.
<code>variables</code> corresponds to names of variables found in <code>data</code>, passed as a named list and requires elements
<code>tte</code>, <code>is_event</code>, <code>biomarkers</code> (vector of continuous biomarker variables) and optionally <code>subgroups</code> and <code>strat</code>.
</p>
</li>
<li> <p><code>h_tab_surv_one_biomarker()</code>: prepares a single sub-table given a <code>df_sub</code> containing
the results for a single biomarker.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(forcats)

adtte &lt;- tern_ex_adtte

# Save variable labels before data processing steps.
adtte_labels &lt;- formatters::var_labels(adtte, fill = FALSE)

adtte_f &lt;- adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  mutate(
    AVALU = as.character(AVALU),
    is_event = CNSR == 0
  )
labels &lt;- c("AVALU" = adtte_labels[["AVALU"]], "is_event" = "Event Flag")
formatters::var_labels(adtte_f)[names(labels)] &lt;- labels

# This is how the variable list is converted internally.
h_surv_to_coxreg_variables(
  variables = list(
    tte = "AVAL",
    is_event = "EVNT",
    covariates = c("A", "B"),
    strata = "D"
  ),
  biomarker = "AGE"
)

# For a single population, estimate separately the effects
# of two biomarkers.
df &lt;- h_coxreg_mult_cont_df(
  variables = list(
    tte = "AVAL",
    is_event = "is_event",
    biomarkers = c("BMRKR1", "AGE"),
    covariates = "SEX",
    strata = c("STRATA1", "STRATA2")
  ),
  data = adtte_f
)
df

# If the data set is empty, still the corresponding rows with missings are returned.
h_coxreg_mult_cont_df(
  variables = list(
    tte = "AVAL",
    is_event = "is_event",
    biomarkers = c("BMRKR1", "AGE"),
    covariates = "REGION1",
    strata = c("STRATA1", "STRATA2")
  ),
  data = adtte_f[NULL, ]
)

# Starting from above `df`, zoom in on one biomarker and add required columns.
df1 &lt;- df[1, ]
df1$subgroup &lt;- "All patients"
df1$row_type &lt;- "content"
df1$var &lt;- "ALL"
df1$var_label &lt;- "All patients"
h_tab_surv_one_biomarker(
  df1,
  vars = c("n_tot", "n_tot_events", "median", "hr", "ci", "pval"),
  time_unit = "days"
)

</code></pre>

<hr>
<h2 id='h_survival_duration_subgroups'>Helper Functions for Tabulating Survival Duration by Subgroup</h2><span id='topic+h_survival_duration_subgroups'></span><span id='topic+h_survtime_df'></span><span id='topic+h_survtime_subgroups_df'></span><span id='topic+h_coxph_df'></span><span id='topic+h_coxph_subgroups_df'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper functions that tabulate in a data frame statistics such as median survival
time and hazard ratio for population subgroups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_survtime_df(tte, is_event, arm)

h_survtime_subgroups_df(
  variables,
  data,
  groups_lists = list(),
  label_all = "All Patients"
)

h_coxph_df(tte, is_event, arm, strata_data = NULL, control = control_coxph())

h_coxph_subgroups_df(
  variables,
  data,
  groups_lists = list(),
  control = control_coxph(),
  label_all = "All Patients"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_survival_duration_subgroups_+3A_tte">tte</code></td>
<td>
<p>(<code>numeric</code>)<br /> contains time-to-event duration values.</p>
</td></tr>
<tr><td><code id="h_survival_duration_subgroups_+3A_is_event">is_event</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> if event, <code>FALSE</code> if time to event is censored.</p>
</td></tr>
<tr><td><code id="h_survival_duration_subgroups_+3A_arm">arm</code></td>
<td>
<p>(<code>factor</code>)<br /> the treatment group variable.</p>
</td></tr>
<tr><td><code id="h_survival_duration_subgroups_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="h_survival_duration_subgroups_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> the dataset containing the variables to summarize.</p>
</td></tr>
<tr><td><code id="h_survival_duration_subgroups_+3A_groups_lists">groups_lists</code></td>
<td>
<p>(named <code>list</code> of <code>list</code>)<br /> optionally contains for each <code>subgroups</code> variable a
list, which specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
<tr><td><code id="h_survival_duration_subgroups_+3A_label_all">label_all</code></td>
<td>
<p>(<code>string</code>)<br /> label for the total population analysis.</p>
</td></tr>
<tr><td><code id="h_survival_duration_subgroups_+3A_strata_data">strata_data</code></td>
<td>
<p>(<code>factor</code>, <code>data.frame</code> or <code>NULL</code>)<br /> required if stratified analysis is performed.</p>
</td></tr>
<tr><td><code id="h_survival_duration_subgroups_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> parameters for comparison details, specified by using the helper function
<code><a href="#topic+control_coxph">control_coxph()</a></code>. Some possible parameter options are:
</p>

<ul>
<li> <p><code>pval_method</code> (<code>string</code>)<br /> p-value method for testing hazard ratio = 1. Default method is <code>"log-rank"</code> which
comes from <code><a href="survival.html#topic+survdiff">survival::survdiff()</a></code>, can also be set to <code>"wald"</code> or <code>"likelihood"</code> (from <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>).
</p>
</li>
<li> <p><code>ties</code> (<code>string</code>)<br /> specifying the method for tie handling. Default is <code>"efron"</code>,
can also be set to <code>"breslow"</code> or <code>"exact"</code>. See more in <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>
</p>
</li>
<li> <p><code>conf_level</code> (<code>proportion</code>)<br /> confidence level of the interval for HR.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Main functionality is to prepare data for use in a layout-creating function.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>h_survtime_df()</code> returns a <code>data.frame</code> with columns <code>arm</code>, <code>n</code>, <code>n_events</code>, and <code>median</code>.
</p>
</li></ul>


<ul>
<li> <p><code>h_survtime_subgroups_df()</code> returns a <code>data.frame</code> with columns <code>arm</code>, <code>n</code>, <code>n_events</code>, <code>median</code>, <code>subgroup</code>,
<code>var</code>, <code>var_label</code>, and <code>row_type</code>.
</p>
</li></ul>


<ul>
<li> <p><code>h_coxph_df()</code> returns a <code>data.frame</code> with columns <code>arm</code>, <code>n_tot</code>, <code>n_tot_events</code>, <code>hr</code>, <code>lcl</code>, <code>ucl</code>,
<code>conf_level</code>, <code>pval</code> and <code>pval_label</code>.
</p>
</li></ul>


<ul>
<li> <p><code>h_coxph_subgroups_df()</code> returns a <code>data.frame</code> with columns <code>arm</code>, <code>n_tot</code>, <code>n_tot_events</code>, <code>hr</code>,
<code>lcl</code>, <code>ucl</code>, <code>conf_level</code>, <code>pval</code>, <code>pval_label</code>, <code>subgroup</code>, <code>var</code>, <code>var_label</code>, and <code>row_type</code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>h_survtime_df()</code>: helper to prepare a data frame of median survival times by arm.
</p>
</li>
<li> <p><code>h_survtime_subgroups_df()</code>: summarizes median survival times by arm and across subgroups
in a data frame. <code>variables</code> corresponds to the names of variables found in <code>data</code>, passed as a named list and
requires elements <code>tte</code>, <code>is_event</code>, <code>arm</code> and optionally <code>subgroups</code>. <code>groups_lists</code> optionally specifies
groupings for <code>subgroups</code> variables.
</p>
</li>
<li> <p><code>h_coxph_df()</code>: helper to prepare a data frame with estimates of
treatment hazard ratio.
</p>
</li>
<li> <p><code>h_coxph_subgroups_df()</code>: summarizes estimates of the treatment hazard ratio
across subgroups in a data frame. <code>variables</code> corresponds to the names of variables found in
<code>data</code>, passed as a named list and requires elements <code>tte</code>, <code>is_event</code>, <code>arm</code> and
optionally <code>subgroups</code> and <code>strat</code>. <code>groups_lists</code> optionally specifies
groupings for <code>subgroups</code> variables.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(forcats)

adtte &lt;- tern_ex_adtte

# Save variable labels before data processing steps.
adtte_labels &lt;- formatters::var_labels(adtte)

adtte_f &lt;- adtte %&gt;%
  filter(
    PARAMCD == "OS",
    ARM %in% c("B: Placebo", "A: Drug X"),
    SEX %in% c("M", "F")
  ) %&gt;%
  mutate(
    # Reorder levels of ARM to display reference arm before treatment arm.
    ARM = droplevels(fct_relevel(ARM, "B: Placebo")),
    SEX = droplevels(SEX),
    is_event = CNSR == 0
  )
labels &lt;- c("ARM" = adtte_labels[["ARM"]], "SEX" = adtte_labels[["SEX"]], "is_event" = "Event Flag")
formatters::var_labels(adtte_f)[names(labels)] &lt;- labels

# Extract median survival time for one group.
h_survtime_df(
  tte = adtte_f$AVAL,
  is_event = adtte_f$is_event,
  arm = adtte_f$ARM
)

# Extract median survival time for multiple groups.
h_survtime_subgroups_df(
  variables = list(
    tte = "AVAL",
    is_event = "is_event",
    arm = "ARM",
    subgroups = c("SEX", "BMRKR2")
  ),
  data = adtte_f
)

# Define groupings for BMRKR2 levels.
h_survtime_subgroups_df(
  variables = list(
    tte = "AVAL",
    is_event = "is_event",
    arm = "ARM",
    subgroups = c("SEX", "BMRKR2")
  ),
  data = adtte_f,
  groups_lists = list(
    BMRKR2 = list(
      "low" = "LOW",
      "low/medium" = c("LOW", "MEDIUM"),
      "low/medium/high" = c("LOW", "MEDIUM", "HIGH")
    )
  )
)

# Extract hazard ratio for one group.
h_coxph_df(adtte_f$AVAL, adtte_f$is_event, adtte_f$ARM)

# Extract hazard ratio for one group with stratification factor.
h_coxph_df(adtte_f$AVAL, adtte_f$is_event, adtte_f$ARM, strata_data = adtte_f$STRATA1)

# Extract hazard ratio for multiple groups.
h_coxph_subgroups_df(
  variables = list(
    tte = "AVAL",
    is_event = "is_event",
    arm = "ARM",
    subgroups = c("SEX", "BMRKR2")
  ),
  data = adtte_f
)

# Define groupings of BMRKR2 levels.
h_coxph_subgroups_df(
  variables = list(
    tte = "AVAL",
    is_event = "is_event",
    arm = "ARM",
    subgroups = c("SEX", "BMRKR2")
  ),
  data = adtte_f,
  groups_lists = list(
    BMRKR2 = list(
      "low" = "LOW",
      "low/medium" = c("LOW", "MEDIUM"),
      "low/medium/high" = c("LOW", "MEDIUM", "HIGH")
    )
  )
)

# Extract hazard ratio for multiple groups with stratification factors.
h_coxph_subgroups_df(
  variables = list(
    tte = "AVAL",
    is_event = "is_event",
    arm = "ARM",
    subgroups = c("SEX", "BMRKR2"),
    strat = c("STRATA1", "STRATA2")
  ),
  data = adtte_f
)

</code></pre>

<hr>
<h2 id='h_tab_one_biomarker'>Helper Function for Tabulation of a Single Biomarker Result</h2><span id='topic+h_tab_one_biomarker'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Please see <code><a href="#topic+h_tab_surv_one_biomarker">h_tab_surv_one_biomarker()</a></code> and <code><a href="#topic+h_tab_rsp_one_biomarker">h_tab_rsp_one_biomarker()</a></code>, which use this function for examples.
This function is a wrapper for <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_tab_one_biomarker(
  df,
  afuns,
  colvars,
  na_str = default_na_str(),
  .indent_mods = 0L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_tab_one_biomarker_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> results for a single biomarker.</p>
</td></tr>
<tr><td><code id="h_tab_one_biomarker_+3A_afuns">afuns</code></td>
<td>
<p>(named <code>list</code> of <code>function</code>)<br /> analysis functions.</p>
</td></tr>
<tr><td><code id="h_tab_one_biomarker_+3A_colvars">colvars</code></td>
<td>
<p>(<code>list</code> with <code>vars</code> and <code>labels</code>)<br /> variables to tabulate and their labels.</p>
</td></tr>
<tr><td><code id="h_tab_one_biomarker_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="h_tab_one_biomarker_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="h_tab_one_biomarker_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>rtables</code> table object with statistics in columns.
</p>

<hr>
<h2 id='h_tbl_coxph_pairwise'>Helper Function: Pairwise <code>CoxPH</code> table</h2><span id='topic+h_tbl_coxph_pairwise'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Create a <code>data.frame</code> of pairwise stratified or unstratified <code>CoxPH</code> analysis results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_tbl_coxph_pairwise(
  df,
  variables,
  ref_group_coxph = NULL,
  control_coxph_pw = control_coxph(),
  annot_coxph_ref_lbls = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_tbl_coxph_pairwise_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="h_tbl_coxph_pairwise_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code>)<br /> variable names. Details are:
</p>

<ul>
<li> <p><code>tte</code> (<code>numeric</code>)<br /> variable indicating time-to-event duration values.
</p>
</li>
<li> <p><code>is_event</code> (<code>logical</code>)<br /> event variable. <code>TRUE</code> if event, <code>FALSE</code> if time to event is censored.
</p>
</li>
<li> <p><code>arm</code> (<code>factor</code>)<br /> the treatment group variable.
</p>
</li>
<li> <p><code>strat</code> (<code>character</code> or <code>NULL</code>)<br /> variable names indicating stratification factors.
</p>
</li></ul>
</td></tr>
<tr><td><code id="h_tbl_coxph_pairwise_+3A_ref_group_coxph">ref_group_coxph</code></td>
<td>
<p>(<code>character</code>)<br /> level of arm variable to use as reference group in calculations for
<code>annot_coxph</code> table. If <code>NULL</code> (default), uses the first level of the arm variable.</p>
</td></tr>
<tr><td><code id="h_tbl_coxph_pairwise_+3A_control_coxph_pw">control_coxph_pw</code></td>
<td>
<p>(<code>list</code>)<br /> parameters for comparison details, specified by using
the helper function <code><a href="#topic+control_coxph">control_coxph()</a></code>. Some possible parameter options are:
</p>

<ul>
<li> <p><code>pval_method</code> (<code>string</code>)<br /> p-value method for testing hazard ratio = 1.
Default method is <code>"log-rank"</code>, can also be set to <code>"wald"</code> or <code>"likelihood"</code>.
</p>
</li>
<li> <p><code>ties</code> (<code>string</code>)<br /> method for tie handling. Default is <code>"efron"</code>,
can also be set to <code>"breslow"</code> or <code>"exact"</code>. See more in <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>
</p>
</li>
<li> <p><code>conf_level</code> (<code>proportion</code>)<br /> confidence level of the interval for HR.
</p>
</li></ul>
</td></tr>
<tr><td><code id="h_tbl_coxph_pairwise_+3A_annot_coxph_ref_lbls">annot_coxph_ref_lbls</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the reference group should be explicitly printed in labels for the
<code>annot_coxph</code> table. If <code>FALSE</code> (default), only comparison groups will be printed in <code>annot_coxph</code> table labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing statistics <code>HR</code>, <code style="white-space: pre;">&#8288;XX% CI&#8288;</code> (<code>XX</code> taken from <code>control_coxph_pw</code>),
and <code>p-value (log-rank)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

adtte &lt;- tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  mutate(is_event = CNSR == 0)

h_tbl_coxph_pairwise(
  df = adtte,
  variables = list(tte = "AVAL", is_event = "is_event", arm = "ARM"),
  control_coxph_pw = control_coxph(conf_level = 0.9)
)


</code></pre>

<hr>
<h2 id='h_tbl_median_surv'>Helper Function: Survival Estimations</h2><span id='topic+h_tbl_median_surv'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Transform a survival fit to a table with groups in rows characterized by N, median and confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_tbl_median_surv(fit_km, armval = "All")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_tbl_median_surv_+3A_fit_km">fit_km</code></td>
<td>
<p>(<code>survfit</code>)<br /> result of <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>.</p>
</td></tr>
<tr><td><code id="h_tbl_median_surv_+3A_armval">armval</code></td>
<td>
<p>(<code>string</code>)<br /> used as strata name when treatment arm variable only has one level. Default is <code>"All"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary table with statistics <code>N</code>, <code>Median</code>, and <code style="white-space: pre;">&#8288;XX% CI&#8288;</code> (<code>XX</code> taken from <code>fit_km</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(survival)

adtte &lt;- tern_ex_adtte %&gt;% filter(PARAMCD == "OS")
fit &lt;- survfit(
  form = Surv(AVAL, 1 - CNSR) ~ ARMCD,
  data = adtte
)
h_tbl_median_surv(fit_km = fit)


</code></pre>

<hr>
<h2 id='h_worsen_counter'>Helper Function to Analyze Patients for <code><a href="#topic+s_count_abnormal_lab_worsen_by_baseline">s_count_abnormal_lab_worsen_by_baseline()</a></code></h2><span id='topic+h_worsen_counter'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper function to count the number of patients and the fraction of patients according to
highest post-baseline lab grade variable <code>.var</code>, baseline lab grade variable <code>baseline_var</code>,
and the direction of interest specified in <code>direction_var</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_worsen_counter(df, id, .var, baseline_var, direction_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_worsen_counter_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="h_worsen_counter_+3A_id">id</code></td>
<td>
<p>(<code>string</code>)<br /> subject variable name.</p>
</td></tr>
<tr><td><code id="h_worsen_counter_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="h_worsen_counter_+3A_baseline_var">baseline_var</code></td>
<td>
<p>(<code>string</code>)<br /> baseline lab grade variable</p>
</td></tr>
<tr><td><code id="h_worsen_counter_+3A_direction_var">direction_var</code></td>
<td>
<p>(<code>string</code>)<br /> Direction variable specifying the direction of the shift table of interest.
Only lab records flagged by <code>L</code>, <code>H</code> or <code>B</code> are included in the shift table.
</p>

<ul>
<li> <p><code>L</code>: low direction only
</p>
</li>
<li> <p><code>H</code>: high direction only
</p>
</li>
<li> <p><code>B</code>: both low and high directions
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>h_worsen_counter()</code> returns the counts and fraction of patients
whose worst post-baseline lab grades are worse than their baseline grades, for
post-baseline worst grades &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot; and &quot;Any&quot;.
</p>


<h3>See Also</h3>

<p><a href="#topic+abnormal_by_worst_grade_worsen">abnormal_by_worst_grade_worsen</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# The direction variable, GRADDR, is based on metadata
adlb &lt;- tern_ex_adlb %&gt;%
  mutate(
    GRADDR = case_when(
      PARAMCD == "ALT" ~ "B",
      PARAMCD == "CRP" ~ "L",
      PARAMCD == "IGA" ~ "H"
    )
  ) %&gt;%
  filter(SAFFL == "Y" &amp; ONTRTFL == "Y" &amp; GRADDR != "")

df &lt;- h_adlb_worsen(
  adlb,
  worst_flag_low = c("WGRLOFL" = "Y"),
  worst_flag_high = c("WGRHIFL" = "Y"),
  direction_var = "GRADDR"
)

# `h_worsen_counter`
h_worsen_counter(
  df %&gt;% filter(PARAMCD == "CRP" &amp; GRADDR == "Low"),
  id = "USUBJID",
  .var = "ATOXGR",
  baseline_var = "BTOXGR",
  direction_var = "GRADDR"
)

</code></pre>

<hr>
<h2 id='h_xticks'>Helper function: x tick positions</h2><span id='topic+h_xticks'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Calculate the positions of ticks on the x-axis. However, if <code>xticks</code> already
exists it is kept as is. It is based on the same function <code>ggplot2</code> relies on,
and is required in the graphic and the patient-at-risk annotation table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_xticks(data, xticks = NULL, max_time = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_xticks_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> survival data as pre-processed by <code>h_data_plot</code>.</p>
</td></tr>
<tr><td><code id="h_xticks_+3A_xticks">xticks</code></td>
<td>
<p>(<code>numeric</code>, <code>number</code>, or <code>NULL</code>)<br /> numeric vector of ticks or single number with spacing
between ticks on the x axis. If <code>NULL</code> (default), <code><a href="labeling.html#topic+extended">labeling::extended()</a></code> is used to determine
an optimal tick position on the x axis.</p>
</td></tr>
<tr><td><code id="h_xticks_+3A_max_time">max_time</code></td>
<td>
<p>(<code>numeric</code>)<br /> maximum value to show on X axis. Only data values less than or up to
this threshold value will be plotted (defaults to <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of positions to use for x-axis ticks on a <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(survival)

data &lt;- tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  survfit(form = Surv(AVAL, 1 - CNSR) ~ ARMCD, data = .) %&gt;%
  h_data_plot()

h_xticks(data)
h_xticks(data, xticks = seq(0, 3000, 500))
h_xticks(data, xticks = 500)
h_xticks(data, xticks = 500, max_time = 6000)
h_xticks(data, xticks = c(0, 500), max_time = 300)
h_xticks(data, xticks = 500, max_time = 300)


</code></pre>

<hr>
<h2 id='imputation_rule'>Apply 1/3 or 1/2 Imputation Rule to Data</h2><span id='topic+imputation_rule'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputation_rule(
  df,
  x_stats,
  stat,
  imp_rule,
  post = FALSE,
  avalcat_var = "AVALCAT1"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputation_rule_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="imputation_rule_+3A_x_stats">x_stats</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;named list&#8288;</code>)<br /> a named list of statistics, typically the results of <code><a href="#topic+s_summary">s_summary()</a></code>.</p>
</td></tr>
<tr><td><code id="imputation_rule_+3A_stat">stat</code></td>
<td>
<p>(<code>character</code>)<br /> statistic to return the value/NA level of according to the imputation
rule applied.</p>
</td></tr>
<tr><td><code id="imputation_rule_+3A_imp_rule">imp_rule</code></td>
<td>
<p>(<code>character</code>)<br /> imputation rule setting. Set to <code>"1/3"</code> to implement 1/3 imputation
rule or <code>"1/2"</code> to implement 1/2 imputation rule.</p>
</td></tr>
<tr><td><code id="imputation_rule_+3A_post">post</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the data corresponds to a post-dose time-point (defaults to <code>FALSE</code>).
This parameter is only used when <code>imp_rule</code> is set to <code>"1/3"</code>.</p>
</td></tr>
<tr><td><code id="imputation_rule_+3A_avalcat_var">avalcat_var</code></td>
<td>
<p>(<code>character</code>)<br /> name of variable that indicates whether a row in <code>df</code> corresponds
to an analysis value in category <code>"BLQ"</code>, <code>"LTR"</code>, <code>"&lt;PCLLOQ"</code>, or none of the above
(defaults to <code>"AVALCAT1"</code>). Variable <code>avalcat_var</code> must be present in <code>df</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing statistic value (<code>val</code>) and NA level (<code>na_str</code>) that should be displayed
according to the specified imputation rule.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze_vars_in_cols">analyze_vars_in_cols()</a></code> where this function can be implemented by setting the <code>imp_rule</code>
argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
df &lt;- data.frame(
  AVAL = runif(50, 0, 1),
  AVALCAT1 = sample(c(1, "BLQ"), 50, replace = TRUE)
)
x_stats &lt;- s_summary(df$AVAL)
imputation_rule(df, x_stats, "max", "1/3")
imputation_rule(df, x_stats, "geom_mean", "1/3")
imputation_rule(df, x_stats, "mean", "1/2")

</code></pre>

<hr>
<h2 id='incidence_rate'>Incidence Rate</h2><span id='topic+incidence_rate'></span><span id='topic+estimate_incidence_rate'></span><span id='topic+s_incidence_rate'></span><span id='topic+a_incidence_rate'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Estimate the event rate adjusted for person-years at risk, otherwise known
as incidence rate. Primary analysis variable is the person-years at risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_incidence_rate(
  lyt,
  vars,
  n_events,
  control = control_incidence_rate(),
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  show_labels = "hidden",
  table_names = vars,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_incidence_rate(
  df,
  .var,
  n_events,
  is_event,
  control = control_incidence_rate()
)

a_incidence_rate(
  df,
  .var,
  n_events,
  is_event,
  control = control_incidence_rate()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incidence_rate_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_n_events">n_events</code></td>
<td>
<p>(<code>integer</code>)<br /> number of events observed.</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> parameters for estimation details, specified by using
the helper function <code><a href="#topic+control_incidence_rate">control_incidence_rate()</a></code>. Possible parameter options are:
</p>

<ul>
<li> <p><code>conf_level</code> (<code>proportion</code>)<br /> confidence level for the estimated incidence rate.
</p>
</li>
<li> <p><code>conf_type</code> (<code>string</code>)<br /> <code>normal</code> (default), <code>normal_log</code>, <code>exact</code>, or <code>byar</code>
for confidence interval type.
</p>
</li>
<li> <p><code>input_time_unit</code> (<code>string</code>)<br /> <code>day</code>, <code>week</code>, <code>month</code>, or <code>year</code> (default)
indicating time unit for data input.
</p>
</li>
<li> <p><code>num_pt_year</code> (<code>numeric</code>)<br /> time unit for desired output (in person-years).
</p>
</li></ul>
</td></tr>
<tr><td><code id="incidence_rate_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("estimate_incidence_rate")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="incidence_rate_+3A_is_event">is_event</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> if event, <code>FALSE</code> if time to event is censored.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>estimate_incidence_rate()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_incidence_rate()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_incidence_rate()</code> returns the following statistics:
</p>

<ul>
<li> <p><code>person_years</code>: Total person-years at risk.
</p>
</li>
<li> <p><code>n_events</code>: Total number of events observed.
</p>
</li>
<li> <p><code>rate</code>: Estimated incidence rate.
</p>
</li>
<li> <p><code>rate_ci</code>: Confidence interval for the incidence rate.
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>a_incidence_rate()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>estimate_incidence_rate()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_incidence_rate()</code>: Statistics function which estimates the incidence rate and the
associated confidence interval.
</p>
</li>
<li> <p><code>a_incidence_rate()</code>: Formatted analysis function which is used as <code>afun</code>
in <code>estimate_incidence_rate()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+control_incidence_rate">control_incidence_rate()</a></code> and helper functions <a href="#topic+h_incidence_rate">h_incidence_rate</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

df &lt;- data.frame(
  USUBJID = as.character(seq(6)),
  CNSR = c(0, 1, 1, 0, 0, 0),
  AVAL = c(10.1, 20.4, 15.3, 20.8, 18.7, 23.4),
  ARM = factor(c("A", "A", "A", "B", "B", "B"))
) %&gt;%
  mutate(is_event = CNSR == 0) %&gt;%
  mutate(n_events = as.integer(is_event))

basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_colcounts() %&gt;%
  estimate_incidence_rate(
    vars = "AVAL",
    n_events = "n_events",
    control = control_incidence_rate(
      input_time_unit = "month",
      num_pt_year = 100
    )
  ) %&gt;%
  build_table(df)

</code></pre>

<hr>
<h2 id='individual_patient_plot'>Individual Patient Plots</h2><span id='topic+individual_patient_plot'></span><span id='topic+g_ipp'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Line plot(s) displaying trend in patients' parameter values over time is rendered.
Patients' individual baseline values can be added to the plot(s) as reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_ipp(
  df,
  xvar,
  yvar,
  xlab,
  ylab,
  id_var = "USUBJID",
  title = "Individual Patient Plots",
  subtitle = "",
  caption = NULL,
  add_baseline_hline = FALSE,
  yvar_baseline = "BASE",
  ggtheme = nestcolor::theme_nest(),
  plotting_choices = c("all_in_one", "split_by_max_obs", "separate_by_obs"),
  max_obs_per_plot = 4,
  col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="individual_patient_plot_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_xvar">xvar</code></td>
<td>
<p>(<code>string</code>)<br /> time point variable to be plotted on x-axis.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_yvar">yvar</code></td>
<td>
<p>(<code>string</code>)<br /> continuous analysis variable to be plotted on y-axis.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_xlab">xlab</code></td>
<td>
<p>(<code>string</code>)<br /> plot label for x-axis.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_ylab">ylab</code></td>
<td>
<p>(<code>string</code>)<br /> plot label for y-axis.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_id_var">id_var</code></td>
<td>
<p>(<code>string</code>)<br /> variable used as patient identifier.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_title">title</code></td>
<td>
<p>(<code>string</code>)<br /> title for plot.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_subtitle">subtitle</code></td>
<td>
<p>(<code>string</code>)<br /> subtitle for plot.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_caption">caption</code></td>
<td>
<p>(<code>character</code> scalar)<br /> optional caption below the plot.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_add_baseline_hline">add_baseline_hline</code></td>
<td>
<p>(<code>flag</code>)<br /> adds horizontal line at baseline y-value on
plot when TRUE.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_yvar_baseline">yvar_baseline</code></td>
<td>
<p>(<code>string</code>)<br /> variable with baseline values only.
Ignored when <code>add_baseline_hline</code> is FALSE.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_ggtheme">ggtheme</code></td>
<td>
<p>(<code>theme</code>)<br /> optional graphical theme function as provided
by <code>ggplot2</code> to control outlook of plot. Use <code>ggplot2::theme()</code> to tweak the display.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_plotting_choices">plotting_choices</code></td>
<td>
<p>(<code>character</code>)<br /> specifies options for displaying
plots. Must be one of &quot;all_in_one&quot;, &quot;split_by_max_obs&quot;, &quot;separate_by_obs&quot;.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_max_obs_per_plot">max_obs_per_plot</code></td>
<td>
<p>(<code>count</code>)<br /> Number of observations to be plotted on one
plot. Ignored when <code>plotting_choices</code> is not &quot;separate_by_obs&quot;.</p>
</td></tr>
<tr><td><code id="individual_patient_plot_+3A_col">col</code></td>
<td>
<p>(<code>character</code>)<br /> lines colors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object or a list of <code>ggplot</code> objects.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>g_ipp()</code>: Plotting function for individual patient plots which, depending on user
preference, renders a single graphic or compiles a list of graphics that show trends in individual's parameter
values over time.
</p>
</li></ul>


<h3>See Also</h3>

<p>Relevant helper function <code><a href="#topic+h_g_ipp">h_g_ipp()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(nestcolor)

# Select a small sample of data to plot.
adlb &lt;- tern_ex_adlb %&gt;%
  filter(PARAMCD == "ALT", !(AVISIT %in% c("SCREENING", "BASELINE"))) %&gt;%
  slice(1:36)

plot_list &lt;- g_ipp(
  df = adlb,
  xvar = "AVISIT",
  yvar = "AVAL",
  xlab = "Visit",
  ylab = "SGOT/ALT (U/L)",
  title = "Individual Patient Plots",
  add_baseline_hline = TRUE,
  plotting_choices = "split_by_max_obs",
  max_obs_per_plot = 5
)
plot_list

</code></pre>

<hr>
<h2 id='labels_or_names'>Labels or Names of List Elements</h2><span id='topic+labels_or_names'></span>

<h3>Description</h3>

<p>Internal helper function for working with nested statistic function results which typically
don't have labels but names that we can use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labels_or_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels_or_names_+3A_x">x</code></td>
<td>
<p>a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector with the labels or names for the list elements.
</p>

<hr>
<h2 id='labels_use_control'>Update Labels According to Control Specifications</h2><span id='topic+labels_use_control'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Given a list of statistic labels and and a list of control parameters, updates labels with a relevant
control specification. For example, if control has element <code>conf_level</code> set to <code>0.9</code>, the default
label for statistic <code>mean_ci</code> will be updated to <code>"Mean 90% CI"</code>. Any labels that are supplied
via <code>labels_custom</code> will not be updated regardless of <code>control</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labels_use_control(labels_default, control, labels_custom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels_use_control_+3A_labels_default">labels_default</code></td>
<td>
<p>(named <code>vector</code> of <code>character</code>)<br /> a named vector of statistic labels to modify
according to the control specifications. Labels that are explicitly defined in <code>labels_custom</code> will
not be affected.</p>
</td></tr>
<tr><td><code id="labels_use_control_+3A_control">control</code></td>
<td>
<p>(named <code>list</code>)<br /> list of control parameters to apply to adjust default labels.</p>
</td></tr>
<tr><td><code id="labels_use_control_+3A_labels_custom">labels_custom</code></td>
<td>
<p>(named <code>vector</code> of <code>character</code>)<br /> named vector of labels that are customized by
the user and should not be affected by <code>control</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector of labels with control specifications applied to relevant labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control &lt;- list(conf_level = 0.80, quantiles = c(0.1, 0.83), test_mean = 0.57)
get_labels_from_stats(c("mean_ci", "quantiles", "mean_pval")) %&gt;%
  labels_use_control(control = control)

</code></pre>

<hr>
<h2 id='logistic_regression_cols'>Logistic Regression Multivariate Column Layout Function</h2><span id='topic+logistic_regression_cols'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Layout-creating function which creates a multivariate column layout summarizing logistic
regression results. This function is a wrapper for <code><a href="rtables.html#topic+split_cols_by_multivar">rtables::split_cols_by_multivar()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic_regression_cols(lyt, conf_level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic_regression_cols_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="logistic_regression_cols_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A layout object suitable for passing to further layouting functions. Adding this
function to an <code>rtable</code> layout will split the table into columns corresponding to
statistics <code>df</code>, <code>estimate</code>, <code>std_error</code>, <code>odds_ratio</code>, <code>ci</code>, and <code>pvalue</code>.
</p>

<hr>
<h2 id='logistic_summary_by_flag'>Logistic Regression Summary Table Constructor Function</h2><span id='topic+logistic_summary_by_flag'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Constructor for content functions to be used in <code><a href="#topic+summarize_logistic">summarize_logistic()</a></code> to summarize
logistic regression results. This function is a wrapper for <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic_summary_by_flag(
  flag_var,
  na_str = default_na_str(),
  .indent_mods = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic_summary_by_flag_+3A_flag_var">flag_var</code></td>
<td>
<p>(<code>string</code>)<br /> variable name identifying which row should be used in this
content function.</p>
</td></tr>
<tr><td><code id="logistic_summary_by_flag_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="logistic_summary_by_flag_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A content function.
</p>

<hr>
<h2 id='make_names'>Make Names Without Dots</h2><span id='topic+make_names'></span>

<h3>Description</h3>

<p>Make Names Without Dots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_names(nams)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_names_+3A_nams">nams</code></td>
<td>
<p>(<code>character</code>)<br /> vector of original names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> <code>vector</code> of proper names, which does not use dots in contrast to <code><a href="base.html#topic+make.names">make.names()</a></code>.
</p>

<hr>
<h2 id='month2day'>Conversion of Months to Days</h2><span id='topic+month2day'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Conversion of Months to Days. This is an approximative calculation because it
considers each month as having an average of 30.4375 days.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>month2day(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="month2day_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> time in months.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector with the time in days.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(13.25, 8.15, 1, 2.834)
month2day(x)

</code></pre>

<hr>
<h2 id='muffled_car_anova'>Muffled <code>car::Anova</code></h2><span id='topic+muffled_car_anova'></span>

<h3>Description</h3>

<p>Applied on survival models, <code><a href="car.html#topic+Anova">car::Anova()</a></code> signal that the <code>strata</code> terms is dropped from the model formula when
present, this function deliberately muffles this message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muffled_car_anova(mod, test_statistic)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="muffled_car_anova_+3A_mod">mod</code></td>
<td>
<p>(<code>coxph</code>)<br /> Cox regression model fitted by <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>.</p>
</td></tr>
<tr><td><code id="muffled_car_anova_+3A_test_statistic">test_statistic</code></td>
<td>
<p>(<code>string</code>)<br /> the method used for estimation of p.values; <code>wald</code> (default) or <code>likelihood</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the output of <code><a href="car.html#topic+Anova">car::Anova()</a></code>, with convergence message muffled.
</p>

<hr>
<h2 id='n_available'>Number of Available (Non-Missing Entries) in a Vector</h2><span id='topic+n_available'></span>

<h3>Description</h3>

<p>Small utility function for better readability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_available(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_available_+3A_x">x</code></td>
<td>
<p>(<code>any</code>)<br /> vector in which to count non-missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of non-missing values.
</p>

<hr>
<h2 id='odds_ratio'>Odds Ratio Estimation</h2><span id='topic+odds_ratio'></span><span id='topic+estimate_odds_ratio'></span><span id='topic+s_odds_ratio'></span><span id='topic+a_odds_ratio'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Compares bivariate responses between two groups in terms of odds ratios
along with a confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_odds_ratio(
  lyt,
  vars,
  variables = list(arm = NULL, strata = NULL),
  conf_level = 0.95,
  groups_list = NULL,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  show_labels = "hidden",
  table_names = vars,
  .stats = "or_ci",
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_odds_ratio(
  df,
  .var,
  .ref_group,
  .in_ref_col,
  .df_row,
  variables = list(arm = NULL, strata = NULL),
  conf_level = 0.95,
  groups_list = NULL
)

a_odds_ratio(
  df,
  .var,
  .ref_group,
  .in_ref_col,
  .df_row,
  variables = list(arm = NULL, strata = NULL),
  conf_level = 0.95,
  groups_list = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odds_ratio_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_groups_list">groups_list</code></td>
<td>
<p>(named <code>list</code> of <code>character</code>)<br /> specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>s_odds_ratio()</code>.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("estimate_odds_ratio")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_.ref_group">.ref_group</code></td>
<td>
<p>(<code>data.frame</code> or <code>vector</code>)<br /> the data corresponding to the reference group.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_.in_ref_col">.in_ref_col</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> when working with the reference level, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="odds_ratio_+3A_.df_row">.df_row</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data frame across all of the columns for the given row split.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses either logistic regression for unstratified
analyses, or conditional logistic regression for stratified analyses.
The Wald confidence interval with the specified confidence level is
calculated.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>estimate_odds_ratio()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_odds_ratio()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_odds_ratio()</code> returns a named list with the statistics <code>or_ci</code>
(containing <code>est</code>, <code>lcl</code>, and <code>ucl</code>) and <code>n_tot</code>.
</p>
</li></ul>


<ul>
<li> <p><code>a_odds_ratio()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>estimate_odds_ratio()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_odds_ratio()</code>: Statistics function which estimates the odds ratio
between a treatment and a control. A <code>variables</code> list with <code>arm</code> and <code>strata</code>
variable names must be passed if a stratified analysis is required.
</p>
</li>
<li> <p><code>a_odds_ratio()</code>: Formatted analysis function which is used as <code>afun</code> in <code>estimate_odds_ratio()</code>.
</p>
</li></ul>


<h3>Note</h3>

<p>For stratified analyses, there is currently no implementation for conditional
likelihood confidence intervals, therefore the likelihood confidence interval is not
yet available as an option. Besides, when <code>rsp</code> contains only responders or non-responders,
then the result values will be <code>NA</code>, because no odds ratio estimation is possible.
</p>


<h3>See Also</h3>

<p>Relevant helper function <code><a href="#topic+h_odds_ratio">h_odds_ratio()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
dta &lt;- data.frame(
  rsp = sample(c(TRUE, FALSE), 100, TRUE),
  grp = factor(rep(c("A", "B"), each = 50), levels = c("A", "B")),
  strata = factor(sample(c("C", "D"), 100, TRUE))
)

l &lt;- basic_table() %&gt;%
  split_cols_by(var = "grp", ref_group = "B") %&gt;%
  estimate_odds_ratio(vars = "rsp")

build_table(l, df = dta)

# Unstratified analysis.
s_odds_ratio(
  df = subset(dta, grp == "A"),
  .var = "rsp",
  .ref_group = subset(dta, grp == "B"),
  .in_ref_col = FALSE,
  .df_row = dta
)

# Stratified analysis.
s_odds_ratio(
  df = subset(dta, grp == "A"),
  .var = "rsp",
  .ref_group = subset(dta, grp == "B"),
  .in_ref_col = FALSE,
  .df_row = dta,
  variables = list(arm = "grp", strata = "strata")
)

a_odds_ratio(
  df = subset(dta, grp == "A"),
  .var = "rsp",
  .ref_group = subset(dta, grp == "B"),
  .in_ref_col = FALSE,
  .df_row = dta
)

</code></pre>

<hr>
<h2 id='prop_diff'>Proportion Difference</h2><span id='topic+prop_diff'></span><span id='topic+estimate_proportion_diff'></span><span id='topic+s_proportion_diff'></span><span id='topic+a_proportion_diff'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_proportion_diff(
  lyt,
  vars,
  variables = list(strata = NULL),
  conf_level = 0.95,
  method = c("waldcc", "wald", "cmh", "ha", "newcombe", "newcombecc", "strat_newcombe",
    "strat_newcombecc"),
  weights_method = "cmh",
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  var_labels = vars,
  show_labels = "hidden",
  table_names = vars,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_proportion_diff(
  df,
  .var,
  .ref_group,
  .in_ref_col,
  variables = list(strata = NULL),
  conf_level = 0.95,
  method = c("waldcc", "wald", "cmh", "ha", "newcombe", "newcombecc", "strat_newcombe",
    "strat_newcombecc"),
  weights_method = "cmh"
)

a_proportion_diff(
  df,
  .var,
  .ref_group,
  .in_ref_col,
  variables = list(strata = NULL),
  conf_level = 0.95,
  method = c("waldcc", "wald", "cmh", "ha", "newcombe", "newcombecc", "strat_newcombe",
    "strat_newcombecc"),
  weights_method = "cmh"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_diff_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_method">method</code></td>
<td>
<p>(<code>string</code>)<br /> the method used for the confidence interval estimation.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_weights_method">weights_method</code></td>
<td>
<p>(<code>string</code>)<br /> weights method. Can be either <code>"cmh"</code> or <code>"heuristic"</code>
and directs the way weights are estimated.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("estimate_proportion_diff")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_.ref_group">.ref_group</code></td>
<td>
<p>(<code>data.frame</code> or <code>vector</code>)<br /> the data corresponding to the reference group.</p>
</td></tr>
<tr><td><code id="prop_diff_+3A_.in_ref_col">.in_ref_col</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> when working with the reference level, <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>estimate_proportion_diff()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_proportion_diff()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_proportion_diff()</code> returns a named list of elements <code>diff</code> and <code>diff_ci</code>.
</p>
</li></ul>


<ul>
<li> <p><code>a_proportion_diff()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>estimate_proportion_diff()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_proportion_diff()</code>: Statistics function estimating the difference
in terms of responder proportion.
</p>
</li>
<li> <p><code>a_proportion_diff()</code>: Formatted analysis function which is used as <code>afun</code> in <code>estimate_proportion_diff()</code>.
</p>
</li></ul>


<h3>Note</h3>

<p>When performing an unstratified analysis, methods <code>"cmh"</code>, <code>"strat_newcombe"</code>, and <code>"strat_newcombecc"</code> are
not permitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+d_proportion_diff">d_proportion_diff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## "Mid" case: 4/4 respond in group A, 1/2 respond in group B.
nex &lt;- 100 # Number of example rows
dta &lt;- data.frame(
  "rsp" = sample(c(TRUE, FALSE), nex, TRUE),
  "grp" = sample(c("A", "B"), nex, TRUE),
  "f1" = sample(c("a1", "a2"), nex, TRUE),
  "f2" = sample(c("x", "y", "z"), nex, TRUE),
  stringsAsFactors = TRUE
)

l &lt;- basic_table() %&gt;%
  split_cols_by(var = "grp", ref_group = "B") %&gt;%
  estimate_proportion_diff(
    vars = "rsp",
    conf_level = 0.90,
    method = "ha"
  )

build_table(l, df = dta)

s_proportion_diff(
  df = subset(dta, grp == "A"),
  .var = "rsp",
  .ref_group = subset(dta, grp == "B"),
  .in_ref_col = FALSE,
  conf_level = 0.90,
  method = "ha"
)

# CMH example with strata
s_proportion_diff(
  df = subset(dta, grp == "A"),
  .var = "rsp",
  .ref_group = subset(dta, grp == "B"),
  .in_ref_col = FALSE,
  variables = list(strata = c("f1", "f2")),
  conf_level = 0.90,
  method = "cmh"
)

a_proportion_diff(
  df = subset(dta, grp == "A"),
  .var = "rsp",
  .ref_group = subset(dta, grp == "B"),
  .in_ref_col = FALSE,
  conf_level = 0.90,
  method = "ha"
)

</code></pre>

<hr>
<h2 id='prop_diff_test'>Difference Test for Two Proportions</h2><span id='topic+prop_diff_test'></span><span id='topic+test_proportion_diff'></span><span id='topic+s_test_proportion_diff'></span><span id='topic+a_test_proportion_diff'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Various tests were implemented to test the difference between two proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_proportion_diff(
  lyt,
  vars,
  variables = list(strata = NULL),
  method = c("chisq", "schouten", "fisher", "cmh"),
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  var_labels = vars,
  show_labels = "hidden",
  table_names = vars,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_test_proportion_diff(
  df,
  .var,
  .ref_group,
  .in_ref_col,
  variables = list(strata = NULL),
  method = c("chisq", "schouten", "fisher", "cmh")
)

a_test_proportion_diff(
  df,
  .var,
  .ref_group,
  .in_ref_col,
  variables = list(strata = NULL),
  method = c("chisq", "schouten", "fisher", "cmh")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_diff_test_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_method">method</code></td>
<td>
<p>(<code>string</code>)<br /> one of <code>chisq</code>, <code>cmh</code>, <code>fisher</code>, or <code>schouten</code>; specifies the test used
to calculate the p-value.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("test_proportion_diff")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_.ref_group">.ref_group</code></td>
<td>
<p>(<code>data.frame</code> or <code>vector</code>)<br /> the data corresponding to the reference group.</p>
</td></tr>
<tr><td><code id="prop_diff_test_+3A_.in_ref_col">.in_ref_col</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> when working with the reference level, <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>test_proportion_diff()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_test_proportion_diff()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_test_proportion_diff()</code> returns a named <code>list</code> with a single item <code>pval</code> with an attribute <code>label</code>
describing the method used. The p-value tests the null hypothesis that proportions in two groups are the same.
</p>
</li></ul>


<ul>
<li> <p><code>a_test_proportion_diff()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>test_proportion_diff()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_test_proportion_diff()</code>: Statistics function which tests the difference between two proportions.
</p>
</li>
<li> <p><code>a_test_proportion_diff()</code>: Formatted analysis function which is used as <code>afun</code> in <code>test_proportion_diff()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+h_prop_diff_test">h_prop_diff_test</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dta &lt;- data.frame(
  rsp = sample(c(TRUE, FALSE), 100, TRUE),
  grp = factor(rep(c("A", "B"), each = 50)),
  strat = factor(rep(c("V", "W", "X", "Y", "Z"), each = 20))
)

# With `rtables` pipelines.
l &lt;- basic_table() %&gt;%
  split_cols_by(var = "grp", ref_group = "B") %&gt;%
  test_proportion_diff(
    vars = "rsp",
    method = "cmh", variables = list(strata = "strat")
  )

build_table(l, df = dta)

</code></pre>

<hr>
<h2 id='prune_occurrences'>Occurrence Table Pruning</h2><span id='topic+prune_occurrences'></span><span id='topic+keep_rows'></span><span id='topic+keep_content_rows'></span><span id='topic+has_count_in_cols'></span><span id='topic+has_count_in_any_col'></span><span id='topic+has_fraction_in_cols'></span><span id='topic+has_fraction_in_any_col'></span><span id='topic+has_fractions_difference'></span><span id='topic+has_counts_difference'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Family of constructor and condition functions to flexibly prune occurrence tables.
The condition functions always return whether the row result is higher than the threshold.
Since they are of class <code><a href="#topic+CombinationFunction">CombinationFunction()</a></code> they can be logically combined with other condition
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keep_rows(row_condition)

keep_content_rows(content_row_condition)

has_count_in_cols(atleast, ...)

has_count_in_any_col(atleast, ...)

has_fraction_in_cols(atleast, ...)

has_fraction_in_any_col(atleast, ...)

has_fractions_difference(atleast, ...)

has_counts_difference(atleast, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_occurrences_+3A_row_condition">row_condition</code></td>
<td>
<p>(<code>CombinationFunction</code>)<br /> condition function which works on individual
analysis rows and flags whether these should be kept in the pruned table.</p>
</td></tr>
<tr><td><code id="prune_occurrences_+3A_content_row_condition">content_row_condition</code></td>
<td>
<p>(<code>CombinationFunction</code>)<br /> condition function which works on individual
first content rows of leaf tables and flags whether these leaf tables should be kept in the pruned table.</p>
</td></tr>
<tr><td><code id="prune_occurrences_+3A_atleast">atleast</code></td>
<td>
<p>(<code>count</code> or <code>proportion</code>)<br /> threshold which should be met in order to keep the row.</p>
</td></tr>
<tr><td><code id="prune_occurrences_+3A_...">...</code></td>
<td>
<p>arguments for row or column access, see <code><a href="#topic+rtables_access">rtables_access</a></code>: either <code>col_names</code> (<code>character</code>) including
the names of the columns which should be used, or alternatively <code>col_indices</code> (<code>integer</code>) giving the indices
directly instead.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>keep_rows()</code> returns a pruning function that can be used with <code><a href="rtables.html#topic+prune_table">rtables::prune_table()</a></code>
to prune an <code>rtables</code> table.
</p>
</li></ul>


<ul>
<li> <p><code>keep_content_rows()</code> returns a pruning function that checks the condition on the first content
row of leaf tables in the table.
</p>
</li></ul>


<ul>
<li> <p><code>has_count_in_cols()</code> returns a condition function that sums the counts in the specified column.
</p>
</li></ul>


<ul>
<li> <p><code>has_count_in_any_col()</code> returns a condition function that compares the counts in the
specified columns with the threshold.
</p>
</li></ul>


<ul>
<li> <p><code>has_fraction_in_cols()</code> returns a condition function that sums the counts in the
specified column, and computes the fraction by dividing by the total column counts.
</p>
</li></ul>


<ul>
<li> <p><code>has_fraction_in_any_col()</code> returns a condition function that looks at the fractions
in the specified columns and checks whether any of them fulfill the threshold.
</p>
</li></ul>


<ul>
<li> <p><code>has_fractions_difference()</code> returns a condition function that extracts the fractions of each
specified column, and computes the difference of the minimum and maximum.
</p>
</li></ul>


<ul>
<li> <p><code>has_counts_difference()</code> returns a condition function that extracts the counts of each
specified column, and computes the difference of the minimum and maximum.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>keep_rows()</code>: Constructor for creating pruning functions based on
a row condition function. This removes all analysis rows (<code>TableRow</code>) that should be
pruned, i.e., don't fulfill the row condition. It removes the sub-tree if there are no
children left.
</p>
</li>
<li> <p><code>keep_content_rows()</code>: Constructor for creating pruning functions based on
a condition for the (first) content row in leaf tables. This removes all leaf tables where
the first content row does not fulfill the condition. It does not check individual rows.
It then proceeds recursively by removing the sub tree if there are no children left.
</p>
</li>
<li> <p><code>has_count_in_cols()</code>: Constructor for creating condition functions on total counts in the specified columns.
</p>
</li>
<li> <p><code>has_count_in_any_col()</code>: Constructor for creating condition functions on any of the counts in
the specified columns satisfying a threshold.
</p>
</li>
<li> <p><code>has_fraction_in_cols()</code>: Constructor for creating condition functions on total fraction in
the specified columns.
</p>
</li>
<li> <p><code>has_fraction_in_any_col()</code>: Constructor for creating condition functions on any fraction in
the specified columns.
</p>
</li>
<li> <p><code>has_fractions_difference()</code>: Constructor for creating condition function that checks the difference
between the fractions reported in each specified column.
</p>
</li>
<li> <p><code>has_counts_difference()</code>: Constructor for creating condition function that checks the difference
between the counts reported in each specified column.
</p>
</li></ul>


<h3>Note</h3>

<p>Since most table specifications are worded positively, we name our constructor and condition
functions positively, too. However, note that the result of <code><a href="#topic+keep_rows">keep_rows()</a></code> says what
should be pruned, to conform with the <code><a href="rtables.html#topic+prune_table">rtables::prune_table()</a></code> interface.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tab &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("RACE") %&gt;%
  split_rows_by("STRATA1") %&gt;%
  summarize_row_groups() %&gt;%
  analyze_vars("COUNTRY", .stats = "count_fraction") %&gt;%
  build_table(DM)



# `keep_rows`
is_non_empty &lt;- !CombinationFunction(all_zero_or_na)
prune_table(tab, keep_rows(is_non_empty))


# `keep_content_rows`

more_than_twenty &lt;- has_count_in_cols(atleast = 20L, col_names = names(tab))
prune_table(tab, keep_content_rows(more_than_twenty))



more_than_one &lt;- has_count_in_cols(atleast = 1L, col_names = names(tab))
prune_table(tab, keep_rows(more_than_one))



# `has_count_in_any_col`
any_more_than_one &lt;- has_count_in_any_col(atleast = 1L, col_names = names(tab))
prune_table(tab, keep_rows(any_more_than_one))



# `has_fraction_in_cols`
more_than_five_percent &lt;- has_fraction_in_cols(atleast = 0.05, col_names = names(tab))
prune_table(tab, keep_rows(more_than_five_percent))



# `has_fraction_in_any_col`
any_atleast_five_percent &lt;- has_fraction_in_any_col(atleast = 0.05, col_names = names(tab))
prune_table(tab, keep_rows(more_than_five_percent))



# `has_fractions_difference`
more_than_five_percent_diff &lt;- has_fractions_difference(atleast = 0.05, col_names = names(tab))
prune_table(tab, keep_rows(more_than_five_percent_diff))



more_than_one_diff &lt;- has_counts_difference(atleast = 1L, col_names = names(tab))
prune_table(tab, keep_rows(more_than_one_diff))


</code></pre>

<hr>
<h2 id='range_noinf'>Re-implemented <code><a href="base.html#topic+range">range()</a></code> Default S3 method for numerical objects</h2><span id='topic+range_noinf'></span>

<h3>Description</h3>

<p>This function returns <code>c(NA, NA)</code> instead of <code>c(-Inf, Inf)</code> for zero-length data
without any warnings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_noinf(x, na.rm = FALSE, finite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_noinf_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> a sequence of numbers for which the range is computed.</p>
</td></tr>
<tr><td><code id="range_noinf_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>logical</code>)<br /> indicating if <code>NA</code> should be omitted.</p>
</td></tr>
<tr><td><code id="range_noinf_+3A_finite">finite</code></td>
<td>
<p>(<code>logical</code>)<br /> indicating if non-finite elements should be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-element vector of class <code>numeric</code>.
</p>

<hr>
<h2 id='reapply_varlabels'>Reapply Variable Labels</h2><span id='topic+reapply_varlabels'></span>

<h3>Description</h3>

<p>This is a helper function that is used in tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reapply_varlabels(x, varlabels, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reapply_varlabels_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>)<br /> vector of elements that needs new labels.</p>
</td></tr>
<tr><td><code id="reapply_varlabels_+3A_varlabels">varlabels</code></td>
<td>
<p>(<code>character</code>)<br /> vector of labels for <code>x</code>.</p>
</td></tr>
<tr><td><code id="reapply_varlabels_+3A_...">...</code></td>
<td>
<p>further parameters to be added to the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with variable labels reapplied.
</p>

<hr>
<h2 id='response_biomarkers_subgroups'>Tabulate Biomarker Effects on Binary Response by Subgroup</h2><span id='topic+response_biomarkers_subgroups'></span><span id='topic+tabulate_rsp_biomarkers'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Tabulate the estimated effects of multiple continuous biomarker variables
on a binary response endpoint across population subgroups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabulate_rsp_biomarkers(
  df,
  vars = c("n_tot", "n_rsp", "prop", "or", "ci", "pval"),
  na_str = default_na_str(),
  .indent_mods = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response_biomarkers_subgroups_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> containing all analysis variables, as returned by
<code><a href="#topic+extract_rsp_biomarkers">extract_rsp_biomarkers()</a></code>.</p>
</td></tr>
<tr><td><code id="response_biomarkers_subgroups_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> the names of statistics to be reported among:
</p>

<ul>
<li> <p><code>n_tot</code>: Total number of patients per group.
</p>
</li>
<li> <p><code>n_rsp</code>: Total number of responses per group.
</p>
</li>
<li> <p><code>prop</code>: Total response proportion per group.
</p>
</li>
<li> <p><code>or</code>: Odds ratio.
</p>
</li>
<li> <p><code>ci</code>: Confidence interval of odds ratio.
</p>
</li>
<li> <p><code>pval</code>: p-value of the effect.
Note, the statistics <code>n_tot</code>, <code>or</code> and <code>ci</code> are required.
</p>
</li></ul>
</td></tr>
<tr><td><code id="response_biomarkers_subgroups_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="response_biomarkers_subgroups_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions create a layout starting from a data frame which contains
the required statistics. The tables are then typically used as input for forest plots.
</p>


<h3>Value</h3>

<p>An <code>rtables</code> table summarizing biomarker effects on binary response by subgroup.
</p>


<h3>Note</h3>

<p>In contrast to <code><a href="#topic+tabulate_rsp_subgroups">tabulate_rsp_subgroups()</a></code> this tabulation function does
not start from an input layout <code>lyt</code>. This is because internally the table is
created by combining multiple subtables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+h_tab_rsp_one_biomarker">h_tab_rsp_one_biomarker()</a></code> which is used internally, <code><a href="#topic+extract_rsp_biomarkers">extract_rsp_biomarkers()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(forcats)

adrs &lt;- tern_ex_adrs
adrs_labels &lt;- formatters::var_labels(adrs)

adrs_f &lt;- adrs %&gt;%
  filter(PARAMCD == "BESRSPI") %&gt;%
  mutate(rsp = AVALC == "CR")
formatters::var_labels(adrs_f) &lt;- c(adrs_labels, "Response")

df &lt;- extract_rsp_biomarkers(
  variables = list(
    rsp = "rsp",
    biomarkers = c("BMRKR1", "AGE"),
    covariates = "SEX",
    subgroups = "BMRKR2"
  ),
  data = adrs_f
)


## Table with default columns.
tabulate_rsp_biomarkers(df)

## Table with a manually chosen set of columns: leave out "pval", reorder.
tab &lt;- tabulate_rsp_biomarkers(
  df = df,
  vars = c("n_rsp", "ci", "n_tot", "prop", "or")
)

## Finally produce the forest plot.
g_forest(tab, xlim = c(0.7, 1.4))


</code></pre>

<hr>
<h2 id='response_subgroups'>Tabulate Binary Response by Subgroup</h2><span id='topic+response_subgroups'></span><span id='topic+tabulate_rsp_subgroups'></span><span id='topic+a_response_subgroups'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Tabulate statistics such as response rate and odds ratio for population subgroups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabulate_rsp_subgroups(
  lyt,
  df,
  vars = c("n_tot", "n", "prop", "or", "ci"),
  groups_lists = list(),
  label_all = "All Patients",
  na_str = default_na_str()
)

a_response_subgroups(
  .formats = list(n = "xx", n_rsp = "xx", prop = "xx.x%", n_tot = "xx", or =
    list(format_extreme_values(2L)), ci = list(format_extreme_values_ci(2L)), pval =
    "x.xxxx | (&lt;0.0001)"),
  na_str = default_na_str()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response_subgroups_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="response_subgroups_+3A_df">df</code></td>
<td>
<p>(<code>list</code>)<br /> of data frames containing all analysis variables. List should be
created using <code><a href="#topic+extract_rsp_subgroups">extract_rsp_subgroups()</a></code>.</p>
</td></tr>
<tr><td><code id="response_subgroups_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> the names of statistics to be reported among:
</p>

<ul>
<li> <p><code>n</code>: Total number of observations per group.
</p>
</li>
<li> <p><code>n_rsp</code>: Number of responders per group.
</p>
</li>
<li> <p><code>prop</code>: Proportion of responders.
</p>
</li>
<li> <p><code>n_tot</code>: Total number of observations.
</p>
</li>
<li> <p><code>or</code>: Odds ratio.
</p>
</li>
<li> <p><code>ci</code> : Confidence interval of odds ratio.
</p>
</li>
<li> <p><code>pval</code>: p-value of the effect.
Note, the statistics <code>n_tot</code>, <code>or</code> and <code>ci</code> are required.
</p>
</li></ul>
</td></tr>
<tr><td><code id="response_subgroups_+3A_groups_lists">groups_lists</code></td>
<td>
<p>(named <code>list</code> of <code>list</code>)<br /> optionally contains for each <code>subgroups</code> variable a
list, which specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
<tr><td><code id="response_subgroups_+3A_label_all">label_all</code></td>
<td>
<p>(<code>string</code>)<br /> label for the total population analysis.</p>
</td></tr>
<tr><td><code id="response_subgroups_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="response_subgroups_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions create a layout starting from a data frame which contains
the required statistics. Tables typically used as part of forest plot.
</p>


<h3>Value</h3>

<p>An <code>rtables</code> table summarizing binary response by subgroup.
</p>

<ul>
<li> <p><code>a_response_subgroups()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>tabulate_rsp_subgroups()</code>: Table-creating function which creates a table
summarizing binary response by subgroup. This function is a wrapper for <code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code>
and <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>
</li>
<li> <p><code>a_response_subgroups()</code>: Formatted analysis function which is used as <code>afun</code> in <code>tabulate_rsp_subgroups()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+extract_rsp_subgroups">extract_rsp_subgroups()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(forcats)

adrs &lt;- tern_ex_adrs
adrs_labels &lt;- formatters::var_labels(adrs)

adrs_f &lt;- adrs %&gt;%
  filter(PARAMCD == "BESRSPI") %&gt;%
  filter(ARM %in% c("A: Drug X", "B: Placebo")) %&gt;%
  droplevels() %&gt;%
  mutate(
    # Reorder levels of factor to make the placebo group the reference arm.
    ARM = fct_relevel(ARM, "B: Placebo"),
    rsp = AVALC == "CR"
  )
formatters::var_labels(adrs_f) &lt;- c(adrs_labels, "Response")

# Unstratified analysis.
df &lt;- extract_rsp_subgroups(
  variables = list(rsp = "rsp", arm = "ARM", subgroups = c("SEX", "BMRKR2")),
  data = adrs_f
)
df

# Stratified analysis.
df_strat &lt;- extract_rsp_subgroups(
  variables = list(rsp = "rsp", arm = "ARM", subgroups = c("SEX", "BMRKR2"), strat = "STRATA1"),
  data = adrs_f
)
df_strat

# Grouping of the BMRKR2 levels.
df_grouped &lt;- extract_rsp_subgroups(
  variables = list(rsp = "rsp", arm = "ARM", subgroups = c("SEX", "BMRKR2")),
  data = adrs_f,
  groups_lists = list(
    BMRKR2 = list(
      "low" = "LOW",
      "low/medium" = c("LOW", "MEDIUM"),
      "low/medium/high" = c("LOW", "MEDIUM", "HIGH")
    )
  )
)
df_grouped

## Table with default columns.
basic_table() %&gt;%
  tabulate_rsp_subgroups(df)

## Table with selected columns.
basic_table() %&gt;%
  tabulate_rsp_subgroups(
    df = df,
    vars = c("n_tot", "n", "n_rsp", "prop", "or", "ci")
  )

</code></pre>

<hr>
<h2 id='rtable2gg'>Convert <code>rtable</code> object to <code>ggplot</code> object</h2><span id='topic+rtable2gg'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Given a <code><a href="rtables.html#topic+rtable">rtables::rtable()</a></code> object, performs basic conversion to a <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> object built using
functions from the <code>ggplot2</code> package. Any table titles and/or footnotes are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtable2gg(tbl, fontsize = 4, colwidths = NULL, lbl_col_padding = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtable2gg_+3A_tbl">tbl</code></td>
<td>
<p>(<code>rtable</code>)<br /> a <code>rtable</code> object.</p>
</td></tr>
<tr><td><code id="rtable2gg_+3A_fontsize">fontsize</code></td>
<td>
<p>(<code>numeric</code>)<br /> font size.</p>
</td></tr>
<tr><td><code id="rtable2gg_+3A_colwidths">colwidths</code></td>
<td>
<p>(<code>vector</code> of <code>numeric</code>)<br /> a vector of column widths. Each element's position in
<code>colwidths</code> corresponds to the column of <code>tbl</code> in the same position. If <code>NULL</code>, column widths
are calculated according to maximum number of characters per column.</p>
</td></tr>
<tr><td><code id="rtable2gg_+3A_lbl_col_padding">lbl_col_padding</code></td>
<td>
<p>(<code>numeric</code>)<br /> additional padding to use when calculating spacing between
the first (label) column and the second column of <code>tbl</code>. If <code>colwidths</code> is specified,
the width of the first column becomes <code>colwidths[1] + lbl_col_padding</code>. Defaults to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dta &lt;- data.frame(
  ARM     = rep(LETTERS[1:3], rep(6, 3)),
  AVISIT  = rep(paste0("V", 1:3), 6),
  AVAL    = c(9:1, rep(NA, 9))
)

lyt &lt;- basic_table() %&gt;%
  split_cols_by(var = "ARM") %&gt;%
  split_rows_by(var = "AVISIT") %&gt;%
  analyze_vars(vars = "AVAL")

tbl &lt;- build_table(lyt, df = dta)

rtable2gg(tbl)

rtable2gg(tbl, fontsize = 5, colwidths = c(2, 1, 1, 1))

</code></pre>

<hr>
<h2 id='rtables_access'><code>rtables</code> Access Helper Functions</h2><span id='topic+rtables_access'></span><span id='topic+h_row_first_values'></span><span id='topic+h_row_counts'></span><span id='topic+h_row_fractions'></span><span id='topic+h_col_counts'></span><span id='topic+h_content_first_row'></span><span id='topic+is_leaf_table'></span><span id='topic+check_names_indices'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>These are a couple of functions that help with accessing the data in <code>rtables</code> objects.
Currently these work for occurrence tables, which are defined as having a count as the first
element and a fraction as the second element in each cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_row_first_values(table_row, col_names = NULL, col_indices = NULL)

h_row_counts(table_row, col_names = NULL, col_indices = NULL)

h_row_fractions(table_row, col_names = NULL, col_indices = NULL)

h_col_counts(table, col_names = NULL, col_indices = NULL)

h_content_first_row(table)

is_leaf_table(table)

check_names_indices(table_row, col_names = NULL, col_indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtables_access_+3A_table_row">table_row</code></td>
<td>
<p>(<code>TableRow</code>)<br /> an analysis row in a occurrence table.</p>
</td></tr>
<tr><td><code id="rtables_access_+3A_col_names">col_names</code></td>
<td>
<p>(<code>character</code>)<br /> the names of the columns to extract from.</p>
</td></tr>
<tr><td><code id="rtables_access_+3A_col_indices">col_indices</code></td>
<td>
<p>(<code>integer</code>)<br /> the indices of the columns to extract from. If <code>col_names</code> are provided,
then these are inferred from the names of <code>table_row</code>. Note that this currently only works well with a single
column split.</p>
</td></tr>
<tr><td><code id="rtables_access_+3A_table">table</code></td>
<td>
<p>(<code>VTableNodeInfo</code>)<br /> an occurrence table or row.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>h_row_first_values()</code> returns a <code>vector</code> of numeric values.
</p>
</li></ul>


<ul>
<li> <p><code>h_row_counts()</code> returns a <code>vector</code> of numeric values.
</p>
</li></ul>


<ul>
<li> <p><code>h_row_fractions()</code> returns a <code>vector</code> of proportions.
</p>
</li></ul>


<ul>
<li> <p><code>h_col_counts()</code> returns a <code>vector</code> of column counts.
</p>
</li></ul>


<ul>
<li> <p><code>h_content_first_row()</code> returns a row from an <code>rtables</code> table.
</p>
</li></ul>


<ul>
<li> <p><code>is_leaf_table()</code> returns a <code>logical</code> value indicating whether current table is a leaf.
</p>
</li></ul>


<ul>
<li> <p><code>check_names_indices</code> returns column indices.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>h_row_first_values()</code>: Helper function to extract the first values from each content
cell and from specified columns in a <code>TableRow</code>. Defaults to all columns.
</p>
</li>
<li> <p><code>h_row_counts()</code>: Helper function that extracts row values and checks if they are
convertible to integers (<code>integerish</code> values).
</p>
</li>
<li> <p><code>h_row_fractions()</code>: helper function to extract fractions from specified columns in a <code>TableRow</code>.
More specifically it extracts the second values from each content cell and checks it is a fraction.
</p>
</li>
<li> <p><code>h_col_counts()</code>: Helper function to extract column counts from specified columns in a table.
</p>
</li>
<li> <p><code>h_content_first_row()</code>: Helper function to get first row of content table of current table.
</p>
</li>
<li> <p><code>is_leaf_table()</code>: Helper function which says whether current table is a leaf in the tree.
</p>
</li>
<li> <p><code>check_names_indices()</code>: Internal helper function that tests standard inputs for column indices.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+prune_occurrences">prune_occurrences</a> for usage of these functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tbl &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("RACE") %&gt;%
  analyze("AGE", function(x) {
    list(
      "mean (sd)" = rcell(c(mean(x), sd(x)), format = "xx.x (xx.x)"),
      "n" = length(x),
      "frac" = rcell(c(0.1, 0.1), format = "xx (xx)")
    )
  }) %&gt;%
  build_table(tern_ex_adsl) %&gt;%
  prune_table()
tree_row_elem &lt;- collect_leaves(tbl[2, ])[[1]]
result &lt;- max(h_row_first_values(tree_row_elem))
result

# Row counts (integer values)
# h_row_counts(tree_row_elem) # Fails because there are no integers
# Using values with integers
tree_row_elem &lt;- collect_leaves(tbl[3, ])[[1]]
result &lt;- h_row_counts(tree_row_elem)
# result

# Row fractions
tree_row_elem &lt;- collect_leaves(tbl[4, ])[[1]]
h_row_fractions(tree_row_elem)

</code></pre>

<hr>
<h2 id='s_cox_multivariate'>Multivariate Cox Model - Summarized Results</h2><span id='topic+s_cox_multivariate'></span>

<h3>Description</h3>

<p>Analyses based on multivariate Cox model are usually not performed for the Controlled Substance Reporting or
regulatory documents but serve exploratory purposes only (e.g., for publication). In practice, the model usually
includes only the main effects (without interaction terms). It produces the hazard ratio estimates for each of the
covariates included in the model.
The analysis follows the same principles (e.g., stratified vs. unstratified analysis and tie handling) as the
usual Cox model analysis. Since there is usually no pre-specified hypothesis testing for such analysis,
the p.values need to be interpreted with caution. (<strong>Statistical Analysis of Clinical Trials Data with R</strong>,
<code style="white-space: pre;">&#8288;NEST's bookdown&#8288;</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_cox_multivariate(
  formula,
  data,
  conf_level = 0.95,
  pval_method = c("wald", "likelihood"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_cox_multivariate_+3A_formula">formula</code></td>
<td>
<p>(<code>formula</code>)<br /> A formula corresponding to the investigated <code><a href="survival.html#topic+Surv">survival::Surv()</a></code> survival model
including covariates.</p>
</td></tr>
<tr><td><code id="s_cox_multivariate_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>)<br /> A data frame which includes the variable in formula and covariates.</p>
</td></tr>
<tr><td><code id="s_cox_multivariate_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> The confidence level for the hazard ratio interval estimations. Default is 0.95.</p>
</td></tr>
<tr><td><code id="s_cox_multivariate_+3A_pval_method">pval_method</code></td>
<td>
<p>(<code>character</code>)<br /> The method used for the estimation of p-values, should be one of
<code>"wald"</code> (default) or <code>"likelihood"</code>.</p>
</td></tr>
<tr><td><code id="s_cox_multivariate_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>. Can include <code>ties</code>, a character string specifying the
method for tie handling, one of <code>exact</code> (default), <code>efron</code>, <code>breslow</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output is limited to single effect terms. Work in ongoing for estimation of interaction terms
but is out of scope as defined by the  Global Data Standards Repository
(<strong><code>GDS_Standard_TLG_Specs_Tables_2.doc</code></strong>).
</p>


<h3>Value</h3>

<p>A <code>list</code> with elements <code>mod</code>, <code>msum</code>, <code>aov</code>, and <code>coef_inter</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_coef">estimate_coef()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

adtte &lt;- tern_ex_adtte
adtte_f &lt;- subset(adtte, PARAMCD == "OS") # _f: filtered
adtte_f &lt;- filter(
  adtte_f,
  PARAMCD == "OS" &amp;
    SEX %in% c("F", "M") &amp;
    RACE %in% c("ASIAN", "BLACK OR AFRICAN AMERICAN", "WHITE")
)
adtte_f$SEX &lt;- droplevels(adtte_f$SEX)
adtte_f$RACE &lt;- droplevels(adtte_f$RACE)

</code></pre>

<hr>
<h2 id='sas_na'>Convert Strings to <code>NA</code></h2><span id='topic+sas_na'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>SAS imports missing data as empty strings or strings with whitespaces only. This helper function can be used to
convert these values to <code>NA</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sas_na(x, empty = TRUE, whitespaces = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sas_na_+3A_x">x</code></td>
<td>
<p>(<code>factor</code> or <code>character</code> vector)<br /> values for which any missing values should be substituted.</p>
</td></tr>
<tr><td><code id="sas_na_+3A_empty">empty</code></td>
<td>
<p>(<code>logical</code>)<br /> if <code>TRUE</code> empty strings get replaced by <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sas_na_+3A_whitespaces">whitespaces</code></td>
<td>
<p>(<code>logical</code>)<br /> if <code>TRUE</code> then strings made from whitespaces only get replaced with <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with <code>""</code> and/or whitespace-only values substituted by <code>NA</code>, depending on the values of
<code>empty</code> and <code>whitespaces</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sas_na(c("1", "", " ", "   ", "b"))
sas_na(factor(c("", " ", "b")))

is.na(sas_na(c("1", "", " ", "   ", "b")))

</code></pre>

<hr>
<h2 id='score_occurrences'>Occurrence Table Sorting</h2><span id='topic+score_occurrences'></span><span id='topic+score_occurrences_cols'></span><span id='topic+score_occurrences_subtable'></span><span id='topic+score_occurrences_cont_cols'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Functions to score occurrence table subtables and rows which can be used in the
sorting of occurrence tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_occurrences(table_row)

score_occurrences_cols(...)

score_occurrences_subtable(...)

score_occurrences_cont_cols(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_occurrences_+3A_table_row">table_row</code></td>
<td>
<p>(<code>TableRow</code>)<br /> an analysis row in a occurrence table.</p>
</td></tr>
<tr><td><code id="score_occurrences_+3A_...">...</code></td>
<td>
<p>arguments for row or column access, see <code><a href="#topic+rtables_access">rtables_access</a></code>: either <code>col_names</code> (<code>character</code>) including
the names of the columns which should be used, or alternatively <code>col_indices</code> (<code>integer</code>) giving the indices
directly instead.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>score_occurrences()</code> returns the sum of counts across all columns of a table row.
</p>
</li></ul>


<ul>
<li> <p><code>score_occurrences_cols()</code> returns a function that sums counts across all specified columns
of a table row.
</p>
</li></ul>


<ul>
<li> <p><code>score_occurrences_subtable()</code> returns a function that sums counts in each subtable
across all specified columns.
</p>
</li></ul>


<ul>
<li> <p><code>score_occurrences_cont_cols()</code> returns a function that sums counts in the first content row in
specified columns.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>score_occurrences()</code>: Scoring function which sums the counts across all
columns. It will fail if anything else but counts are used.
</p>
</li>
<li> <p><code>score_occurrences_cols()</code>: Scoring functions can be produced by this constructor to only include
specific columns in the scoring. See <code><a href="#topic+h_row_counts">h_row_counts()</a></code> for further information.
</p>
</li>
<li> <p><code>score_occurrences_subtable()</code>: Scoring functions produced by this constructor can be used on
subtables: They sum up all specified column counts in the subtable. This is useful when
there is no available content row summing up these counts.
</p>
</li>
<li> <p><code>score_occurrences_cont_cols()</code>: Produce score function for sorting table by summing the first content row in
specified columns. Note that this is extending <code><a href="rtables.html#topic+score_funs">rtables::cont_n_onecol()</a></code> and <code><a href="rtables.html#topic+score_funs">rtables::cont_n_allcols()</a></code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+h_row_first_values">h_row_first_values()</a></code>
</p>
<p><code><a href="#topic+h_row_counts">h_row_counts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_colcounts() %&gt;%
  analyze_num_patients(
    vars = "USUBJID",
    .stats = c("unique"),
    .labels = c("Total number of patients with at least one event")
  ) %&gt;%
  split_rows_by("AEBODSYS", child_labels = "visible", nested = FALSE) %&gt;%
  summarize_num_patients(
    var = "USUBJID",
    .stats = c("unique", "nonunique"),
    .labels = c(
      "Total number of patients with at least one event",
      "Total number of events"
    )
  ) %&gt;%
  count_occurrences(vars = "AEDECOD")

tbl &lt;- build_table(lyt, tern_ex_adae, alt_counts_df = tern_ex_adsl) %&gt;%
  prune_table()

tbl_sorted &lt;- tbl %&gt;%
  sort_at_path(path = c("AEBODSYS", "*", "AEDECOD"), scorefun = score_occurrences)

tbl_sorted

score_cols_a_and_b &lt;- score_occurrences_cols(col_names = c("A: Drug X", "B: Placebo"))

# Note that this here just sorts the AEDECOD inside the AEBODSYS. The AEBODSYS are not sorted.
# That would require a second pass of `sort_at_path`.
tbl_sorted &lt;- tbl %&gt;%
  sort_at_path(path = c("AEBODSYS", "*", "AEDECOD"), scorefun = score_cols_a_and_b)

tbl_sorted

score_subtable_all &lt;- score_occurrences_subtable(col_names = names(tbl))

# Note that this code just sorts the AEBODSYS, not the AEDECOD within AEBODSYS. That
# would require a second pass of `sort_at_path`.
tbl_sorted &lt;- tbl %&gt;%
  sort_at_path(path = c("AEBODSYS"), scorefun = score_subtable_all, decreasing = FALSE)

tbl_sorted

</code></pre>

<hr>
<h2 id='split_cols_by_groups'>Split Columns by Groups of Levels</h2><span id='topic+split_cols_by_groups'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_cols_by_groups(lyt, var, groups_list = NULL, ref_group = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_cols_by_groups_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="split_cols_by_groups_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="split_cols_by_groups_+3A_groups_list">groups_list</code></td>
<td>
<p>(named <code>list</code> of <code>character</code>)<br /> specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
<tr><td><code id="split_cols_by_groups_+3A_ref_group">ref_group</code></td>
<td>
<p>(<code>data.frame</code> or <code>vector</code>)<br /> the data corresponding to the reference group.</p>
</td></tr>
<tr><td><code id="split_cols_by_groups_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="rtables.html#topic+split_cols_by">rtables::split_cols_by()</a></code> in order. For instance, to
control formats (<code>format</code>), add a joint column for all groups (<code>incl_all</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A layout object suitable for passing to further layouting functions. Adding
this function to an <code>rtable</code> layout will add a column split including the given
groups to the table layout.
</p>


<h3>See Also</h3>

<p><code><a href="rtables.html#topic+split_cols_by">rtables::split_cols_by()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1 - Basic use

# Without group combination `split_cols_by_groups` is
# equivalent to [rtables::split_cols_by()].
basic_table() %&gt;%
  split_cols_by_groups("ARM") %&gt;%
  add_colcounts() %&gt;%
  analyze("AGE") %&gt;%
  build_table(DM)

# Add a reference column.
basic_table() %&gt;%
  split_cols_by_groups("ARM", ref_group = "B: Placebo") %&gt;%
  add_colcounts() %&gt;%
  analyze(
    "AGE",
    afun = function(x, .ref_group, .in_ref_col) {
      if (.in_ref_col) {
        in_rows("Diff Mean" = rcell(NULL))
      } else {
        in_rows("Diff Mean" = rcell(mean(x) - mean(.ref_group), format = "xx.xx"))
      }
    }
  ) %&gt;%
  build_table(DM)

# 2 - Adding group specification

# Manual preparation of the groups.
groups &lt;- list(
  "Arms A+B" = c("A: Drug X", "B: Placebo"),
  "Arms A+C" = c("A: Drug X", "C: Combination")
)

# Use of split_cols_by_groups without reference column.
basic_table() %&gt;%
  split_cols_by_groups("ARM", groups) %&gt;%
  add_colcounts() %&gt;%
  analyze("AGE") %&gt;%
  build_table(DM)

# Including differentiated output in the reference column.
basic_table() %&gt;%
  split_cols_by_groups("ARM", groups_list = groups, ref_group = "Arms A+B") %&gt;%
  analyze(
    "AGE",
    afun = function(x, .ref_group, .in_ref_col) {
      if (.in_ref_col) {
        in_rows("Diff. of Averages" = rcell(NULL))
      } else {
        in_rows("Diff. of Averages" = rcell(mean(x) - mean(.ref_group), format = "xx.xx"))
      }
    }
  ) %&gt;%
  build_table(DM)

# 3 - Binary list dividing factor levels into reference and treatment

# `combine_groups` defines reference and treatment.
groups &lt;- combine_groups(
  fct = DM$ARM,
  ref = c("A: Drug X", "B: Placebo")
)
groups

# Use group definition without reference column.
basic_table() %&gt;%
  split_cols_by_groups("ARM", groups_list = groups) %&gt;%
  add_colcounts() %&gt;%
  analyze("AGE") %&gt;%
  build_table(DM)

# Use group definition with reference column (first item of groups).
basic_table() %&gt;%
  split_cols_by_groups("ARM", groups, ref_group = names(groups)[1]) %&gt;%
  add_colcounts() %&gt;%
  analyze(
    "AGE",
    afun = function(x, .ref_group, .in_ref_col) {
      if (.in_ref_col) {
        in_rows("Diff Mean" = rcell(NULL))
      } else {
        in_rows("Diff Mean" = rcell(mean(x) - mean(.ref_group), format = "xx.xx"))
      }
    }
  ) %&gt;%
  build_table(DM)

</code></pre>

<hr>
<h2 id='split_text_grob'>Split Text According To Available Text Width</h2><span id='topic+split_text_grob'></span>

<h3>Description</h3>

<p>Dynamically wrap text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_text_grob(
  text,
  x = grid::unit(0.5, "npc"),
  y = grid::unit(0.5, "npc"),
  width = grid::unit(1, "npc"),
  just = "centre",
  hjust = NULL,
  vjust = NULL,
  default.units = "npc",
  name = NULL,
  gp = grid::gpar(),
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_text_grob_+3A_text">text</code></td>
<td>
<p>character string</p>
</td></tr>
<tr><td><code id="split_text_grob_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-values.</p>
</td></tr>
<tr><td><code id="split_text_grob_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-values.</p>
</td></tr>
<tr><td><code id="split_text_grob_+3A_width">width</code></td>
<td>
<p>a unit object specifying max width of text</p>
</td></tr>
<tr><td><code id="split_text_grob_+3A_just">just</code></td>
<td>
<p>The justification of the text
relative to its (x, y) location.  If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: <code>"left"</code>,
<code>"right"</code>, <code>"centre"</code>, <code>"center"</code>, <code>"bottom"</code>,
and <code>"top"</code>.  For numeric values, 0 means left (bottom) alignment
and 1 means right (top) alignment.
</p>
</td></tr>
<tr><td><code id="split_text_grob_+3A_hjust">hjust</code></td>
<td>
<p>A numeric vector specifying horizontal justification.
If specified, overrides the <code>just</code> setting.</p>
</td></tr>
<tr><td><code id="split_text_grob_+3A_vjust">vjust</code></td>
<td>
<p>A numeric vector specifying vertical justification.
If specified, overrides the <code>just</code> setting.</p>
</td></tr>
<tr><td><code id="split_text_grob_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="split_text_grob_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="split_text_grob_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="split_text_grob_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code is taken from <code style="white-space: pre;">&#8288;R Graphics by Paul Murell, 2nd edition&#8288;</code>
</p>


<h3>Value</h3>

<p>A text grob.
</p>

<hr>
<h2 id='stack_grobs'>Stack Multiple Grobs</h2><span id='topic+stack_grobs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Stack grobs as a new grob with 1 column and multiple rows layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stack_grobs(
  ...,
  grobs = list(...),
  padding = grid::unit(2, "line"),
  vp = NULL,
  gp = NULL,
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_grobs_+3A_...">...</code></td>
<td>
<p>grobs.</p>
</td></tr>
<tr><td><code id="stack_grobs_+3A_grobs">grobs</code></td>
<td>
<p>list of grobs.</p>
</td></tr>
<tr><td><code id="stack_grobs_+3A_padding">padding</code></td>
<td>
<p>unit of length 1, space between each grob.</p>
</td></tr>
<tr><td><code id="stack_grobs_+3A_vp">vp</code></td>
<td>
<p>a <code><a href="grid.html#topic+viewport">viewport()</a></code> object (or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="stack_grobs_+3A_gp">gp</code></td>
<td>
<p>A <code><a href="grid.html#topic+gpar">gpar()</a></code> object.</p>
</td></tr>
<tr><td><code id="stack_grobs_+3A_name">name</code></td>
<td>
<p>a character identifier for the grob.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>grob</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(grid)

g1 &lt;- circleGrob(gp = gpar(col = "blue"))
g2 &lt;- circleGrob(gp = gpar(col = "red"))
g3 &lt;- textGrob("TEST TEXT")
grid.newpage()
grid.draw(stack_grobs(g1, g2, g3))

showViewport()

grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
vp1 &lt;- viewport(layout.pos.row = 1, layout.pos.col = 2)
grid.draw(stack_grobs(g1, g2, g3, vp = vp1, name = "test"))

showViewport()
grid.ls(grobs = TRUE, viewports = TRUE, print = FALSE)

</code></pre>

<hr>
<h2 id='stat_mean_ci'>Confidence Interval for Mean</h2><span id='topic+stat_mean_ci'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Convenient function for calculating the mean confidence interval. It calculates the arithmetic as well as the
geometric mean. It can be used as a <code>ggplot</code> helper function for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_mean_ci(
  x,
  conf_level = 0.95,
  na.rm = TRUE,
  n_min = 2,
  gg_helper = TRUE,
  geom_mean = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_mean_ci_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector of numbers we want to analyze.</p>
</td></tr>
<tr><td><code id="stat_mean_ci_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="stat_mean_ci_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>flag</code>)<br /> whether <code>NA</code> values should be removed from <code>x</code> prior to analysis.</p>
</td></tr>
<tr><td><code id="stat_mean_ci_+3A_n_min">n_min</code></td>
<td>
<p>(<code>number</code>)<br /> a minimum number of non-missing <code>x</code> to estimate the confidence interval for mean.</p>
</td></tr>
<tr><td><code id="stat_mean_ci_+3A_gg_helper">gg_helper</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> when output should be aligned for the use with <code>ggplot</code>.</p>
</td></tr>
<tr><td><code id="stat_mean_ci_+3A_geom_mean">geom_mean</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> when the geometric mean should be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>vector</code> of values <code>mean_ci_lwr</code> and <code>mean_ci_upr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stat_mean_ci(sample(10), gg_helper = FALSE)

p &lt;- ggplot2::ggplot(mtcars, ggplot2::aes(cyl, mpg)) +
  ggplot2::geom_point()

p + ggplot2::stat_summary(
  fun.data = stat_mean_ci,
  geom = "errorbar"
)

p + ggplot2::stat_summary(
  fun.data = stat_mean_ci,
  fun.args = list(conf_level = 0.5),
  geom = "errorbar"
)

p + ggplot2::stat_summary(
  fun.data = stat_mean_ci,
  fun.args = list(conf_level = 0.5, geom_mean = TRUE),
  geom = "errorbar"
)

</code></pre>

<hr>
<h2 id='stat_mean_pval'>p-Value of the Mean</h2><span id='topic+stat_mean_pval'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Convenient function for calculating the two-sided p-value of the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_mean_pval(x, na.rm = TRUE, n_min = 2, test_mean = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_mean_pval_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector of numbers we want to analyze.</p>
</td></tr>
<tr><td><code id="stat_mean_pval_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>flag</code>)<br /> whether <code>NA</code> values should be removed from <code>x</code> prior to analysis.</p>
</td></tr>
<tr><td><code id="stat_mean_pval_+3A_n_min">n_min</code></td>
<td>
<p>(<code>numeric</code>)<br /> a minimum number of non-missing <code>x</code> to estimate the p-value of the mean.</p>
</td></tr>
<tr><td><code id="stat_mean_pval_+3A_test_mean">test_mean</code></td>
<td>
<p>(<code>numeric</code>)<br /> mean value to test under the null hypothesis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A p-value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stat_mean_pval(sample(10))

stat_mean_pval(rnorm(10), test_mean = 0.5)

</code></pre>

<hr>
<h2 id='stat_median_ci'>Confidence Interval for Median</h2><span id='topic+stat_median_ci'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Convenient function for calculating the median confidence interval. It can be used as a <code>ggplot</code> helper
function for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_median_ci(x, conf_level = 0.95, na.rm = TRUE, gg_helper = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_median_ci_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector of numbers we want to analyze.</p>
</td></tr>
<tr><td><code id="stat_median_ci_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="stat_median_ci_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>flag</code>)<br /> whether <code>NA</code> values should be removed from <code>x</code> prior to analysis.</p>
</td></tr>
<tr><td><code id="stat_median_ci_+3A_gg_helper">gg_helper</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> when output should be aligned for the use with <code>ggplot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function was adapted from <code style="white-space: pre;">&#8288;DescTools/versions/0.99.35/source&#8288;</code>
</p>


<h3>Value</h3>

<p>A named <code>vector</code> of values <code>median_ci_lwr</code> and <code>median_ci_upr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stat_median_ci(sample(10), gg_helper = FALSE)

p &lt;- ggplot2::ggplot(mtcars, ggplot2::aes(cyl, mpg)) +
  ggplot2::geom_point()
p + ggplot2::stat_summary(
  fun.data = stat_median_ci,
  geom = "errorbar"
)

</code></pre>

<hr>
<h2 id='stat_propdiff_ci'>Proportion Difference and Confidence Interval</h2><span id='topic+stat_propdiff_ci'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Function for calculating the proportion (or risk) difference and confidence interval between arm
X (reference group) and arm Y. Risk difference is calculated by subtracting cumulative incidence
in arm Y from cumulative incidence in arm X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_propdiff_ci(
  x,
  y,
  N_x,
  N_y,
  list_names = NULL,
  conf_level = 0.95,
  pct = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_propdiff_ci_+3A_x">x</code></td>
<td>
<p>(<code>list</code> of <code>integer</code>)<br /> list of number of occurrences in arm X (reference group).</p>
</td></tr>
<tr><td><code id="stat_propdiff_ci_+3A_y">y</code></td>
<td>
<p>(<code>list</code> of <code>integer</code>)<br /> list of number of occurrences in arm Y. Must be of equal length to <code>x</code>.</p>
</td></tr>
<tr><td><code id="stat_propdiff_ci_+3A_n_x">N_x</code></td>
<td>
<p>(<code>numeric</code>)<br /> total number of records in arm X.</p>
</td></tr>
<tr><td><code id="stat_propdiff_ci_+3A_n_y">N_y</code></td>
<td>
<p>(<code>numeric</code>)<br /> total number of records in arm Y.</p>
</td></tr>
<tr><td><code id="stat_propdiff_ci_+3A_list_names">list_names</code></td>
<td>
<p>(<code>character</code>)<br /> names of each variable/level corresponding to pair of proportions in
<code>x</code> and <code>y</code>. Must be of equal length to <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="stat_propdiff_ci_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="stat_propdiff_ci_+3A_pct">pct</code></td>
<td>
<p>(<code>flag</code>)<br /> whether output should be returned as percentages. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of proportion differences and CIs corresponding to each pair of number of occurrences in <code>x</code> and
<code>y</code>. Each list element consists of 3 statistics: proportion difference, CI lower bound, and CI upper bound.
</p>


<h3>See Also</h3>

<p>Split function <code><a href="#topic+add_riskdiff">add_riskdiff()</a></code> which, when used as <code>split_fun</code> within <code><a href="rtables.html#topic+split_cols_by">rtables::split_cols_by()</a></code>
with <code>riskdiff</code> argument is set to <code>TRUE</code> in subsequent analyze functions, adds a column containing
proportion (risk) difference to an <code>rtables</code> layout.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stat_propdiff_ci(
  x = list(0.375), y = list(0.01), N_x = 5, N_y = 5, list_names = "x", conf_level = 0.9
)

stat_propdiff_ci(
  x = list(0.5, 0.75, 1), y = list(0.25, 0.05, 0.5), N_x = 10, N_y = 20, pct = FALSE
)

</code></pre>

<hr>
<h2 id='strata_normal_quantile'>Helper Function for the Estimation of Stratified Quantiles</h2><span id='topic+strata_normal_quantile'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This function wraps the estimation of stratified percentiles when we assume
the approximation for large numbers. This is necessary only in the case
proportions for each strata are unequal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata_normal_quantile(vars, weights, conf_level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strata_normal_quantile_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="strata_normal_quantile_+3A_weights">weights</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br /> weights for each level of the strata. If <code>NULL</code>, they are
estimated using the iterative algorithm proposed in Yan and Su (2010) that
minimizes the weighted squared length of the confidence interval.</p>
</td></tr>
<tr><td><code id="strata_normal_quantile_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Stratified quantile.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prop_strat_wilson">prop_strat_wilson()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strata_data &lt;- table(data.frame(
  "f1" = sample(c(TRUE, FALSE), 100, TRUE),
  "f2" = sample(c("x", "y", "z"), 100, TRUE),
  stringsAsFactors = TRUE
))
ns &lt;- colSums(strata_data)
ests &lt;- strata_data["TRUE", ] / ns
vars &lt;- ests * (1 - ests) / ns
weights &lt;- rep(1 / length(ns), length(ns))

strata_normal_quantile(vars, weights, 0.95)

</code></pre>

<hr>
<h2 id='study_arm'>Indicate Study Arm Variable in Formula</h2><span id='topic+study_arm'></span>

<h3>Description</h3>

<p>We use <code>study_arm</code> to indicate the study arm variable in <code>tern</code> formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>study_arm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="study_arm_+3A_x">x</code></td>
<td>
<p>arm information</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>
</p>

<hr>
<h2 id='summarize_ancova'>Summary for analysis of covariance (<code>ANCOVA</code>).</h2><span id='topic+summarize_ancova'></span><span id='topic+s_ancova'></span><span id='topic+a_ancova'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Summarize results of <code>ANCOVA</code>. This can be used to analyze multiple endpoints and/or
multiple timepoints within the same response variable <code>.var</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_ancova(
  lyt,
  vars,
  variables,
  conf_level,
  interaction_y = FALSE,
  interaction_item = NULL,
  var_labels,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  show_labels = "visible",
  table_names = vars,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_ancova(
  df,
  .var,
  .df_row,
  variables,
  .ref_group,
  .in_ref_col,
  conf_level,
  interaction_y = FALSE,
  interaction_item = NULL
)

a_ancova(
  df,
  .var,
  .df_row,
  variables,
  .ref_group,
  .in_ref_col,
  conf_level,
  interaction_y = FALSE,
  interaction_item = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_ancova_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>strings</code>)<br /> list of additional analysis variables, with expected elements:
</p>

<ul>
<li> <p><code>arm</code> (<code>string</code>)<br /> group variable, for which the covariate adjusted means of multiple groups will be
summarized. Specifically, the first level of <code>arm</code> variable is taken as the reference group.
</p>
</li>
<li> <p><code>covariates</code> (<code>character</code>)<br /> a vector that can contain single variable names (such as <code>"X1"</code>), and/or
interaction terms indicated by <code>"X1 * X2"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_interaction_y">interaction_y</code></td>
<td>
<p>(<code>character</code>)<br /> a selected item inside of the interaction_item column which will be used
to select the specific <code>ANCOVA</code> results. if the interaction is not needed, the default option is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_interaction_item">interaction_item</code></td>
<td>
<p>(<code>character</code>)<br /> name of the variable that should have interactions
with arm. if the interaction is not needed, the default option is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("summarize_ancova")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_.df_row">.df_row</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set that includes all the variables that are called in <code>.var</code> and <code>variables</code>.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_.ref_group">.ref_group</code></td>
<td>
<p>(<code>data.frame</code> or <code>vector</code>)<br /> the data corresponding to the reference group.</p>
</td></tr>
<tr><td><code id="summarize_ancova_+3A_.in_ref_col">.in_ref_col</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> when working with the reference level, <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>summarize_ancova()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_ancova()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_ancova()</code> returns a named list of 5 statistics:
</p>

<ul>
<li> <p><code>n</code>: Count of complete sample size for the group.
</p>
</li>
<li> <p><code>lsmean</code>: Estimated marginal means in the group.
</p>
</li>
<li> <p><code>lsmean_diff</code>: Difference in estimated marginal means in comparison to the reference group.
If working with the reference group, this will be empty.
</p>
</li>
<li> <p><code>lsmean_diff_ci</code>: Confidence level for difference in estimated marginal means in comparison
to the reference group.
</p>
</li>
<li> <p><code>pval</code>: p-value (not adjusted for multiple comparisons).
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>a_ancova()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>summarize_ancova()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_ancova()</code>: Statistics function that produces a named list of results
of the investigated linear model.
</p>
</li>
<li> <p><code>a_ancova()</code>: Formatted analysis function which is used as <code>afun</code> in <code>summarize_ancova()</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>basic_table() %&gt;%
  split_cols_by("Species", ref_group = "setosa") %&gt;%
  add_colcounts() %&gt;%
  summarize_ancova(
    vars = "Petal.Length",
    variables = list(arm = "Species", covariates = NULL),
    table_names = "unadj",
    conf_level = 0.95, var_labels = "Unadjusted comparison",
    .labels = c(lsmean = "Mean", lsmean_diff = "Difference in Means")
  ) %&gt;%
  summarize_ancova(
    vars = "Petal.Length",
    variables = list(arm = "Species", covariates = c("Sepal.Length", "Sepal.Width")),
    table_names = "adj",
    conf_level = 0.95, var_labels = "Adjusted comparison (covariates: Sepal.Length and Sepal.Width)"
  ) %&gt;%
  build_table(iris)

</code></pre>

<hr>
<h2 id='summarize_change'>Summarize the Change from Baseline or Absolute Baseline Values</h2><span id='topic+summarize_change'></span><span id='topic+s_change_from_baseline'></span><span id='topic+a_change_from_baseline'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The primary analysis variable <code>.var</code> indicates the numerical change from baseline results,
and additional required secondary analysis variables are <code>value</code> and <code>baseline_flag</code>.
Depending on the baseline flag, either the absolute baseline values (at baseline)
or the change from baseline values (post-baseline) are then summarized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_change(
  lyt,
  vars,
  variables,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  table_names = vars,
  .stats = c("n", "mean_sd", "median", "range"),
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_change_from_baseline(df, .var, variables, na.rm = TRUE, ...)

a_change_from_baseline(df, .var, variables, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_change_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="summarize_change_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="summarize_change_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>string</code>)<br /> list of additional analysis variables.</p>
</td></tr>
<tr><td><code id="summarize_change_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="summarize_change_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="summarize_change_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="summarize_change_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="summarize_change_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code style="white-space: pre;">&#8288;get_stats("analyze_vars_numeric)&#8288;</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="summarize_change_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="summarize_change_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="summarize_change_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="summarize_change_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="summarize_change_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="summarize_change_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>flag</code>)<br /> whether <code>NA</code> values should be removed from <code>x</code> prior to analysis.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>summarize_change()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_change_from_baseline()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_change_from_baseline()</code> returns the same values returned by <code><a href="#topic+s_summary.numeric">s_summary.numeric()</a></code>.
</p>
</li></ul>


<ul>
<li> <p><code>a_change_from_baseline()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>summarize_change()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_change_from_baseline()</code>: Statistics function that summarizes baseline or post-baseline visits.
</p>
</li>
<li> <p><code>a_change_from_baseline()</code>: Formatted analysis function which is used as <code>afun</code> in <code>summarize_change()</code>.
</p>
</li></ul>


<h3>Note</h3>

<p>To be used after a split on visits in the layout, such that each data subset only contains
either baseline or post-baseline data.
</p>
<p>The data in <code>df</code> must be either all be from baseline or post-baseline visits. Otherwise
an error will be thrown.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

## Fabricate dataset
dta_test &lt;- data.frame(
  USUBJID = rep(1:6, each = 3),
  AVISIT = rep(paste0("V", 1:3), 6),
  ARM = rep(LETTERS[1:3], rep(6, 3)),
  AVAL = c(9:1, rep(NA, 9))
) %&gt;%
  mutate(ABLFLL = AVISIT == "V1") %&gt;%
  group_by(USUBJID) %&gt;%
  mutate(
    BLVAL = AVAL[ABLFLL],
    CHG = AVAL - BLVAL
  ) %&gt;%
  ungroup()

results &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("AVISIT") %&gt;%
  summarize_change("CHG", variables = list(value = "AVAL", baseline_flag = "ABLFLL")) %&gt;%
  build_table(dta_test)

results

</code></pre>

<hr>
<h2 id='summarize_colvars'>Summarize Variables in Columns</h2><span id='topic+summarize_colvars'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This analyze function uses the S3 generic function <code><a href="#topic+s_summary">s_summary()</a></code> to summarize different variables
that are arranged in columns. Additional standard formatting arguments are available. It is a
minimal wrapper for <code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code>. The latter function is meant to add different
analysis methods for each column variables as different rows. To have the analysis methods as
column labels, please refer to <code><a href="#topic+analyze_vars_in_cols">analyze_vars_in_cols()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_colvars(
  lyt,
  ...,
  na_level = lifecycle::deprecated(),
  na_str = default_na_str(),
  .stats = c("n", "mean_sd", "median", "range", "count_fraction"),
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_colvars_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="summarize_colvars_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>s_summary()</code>.</p>
</td></tr>
<tr><td><code id="summarize_colvars_+3A_na_level">na_level</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use the <code>na_str</code> argument instead.</p>
</td></tr>
<tr><td><code id="summarize_colvars_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="summarize_colvars_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table.</p>
</td></tr>
<tr><td><code id="summarize_colvars_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="summarize_colvars_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="summarize_colvars_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>vector</code> of <code>integer</code>)<br /> indent modifiers for the labels. Each element of the vector
should be a name-value pair with name corresponding to a statistic specified in <code>.stats</code> and value the indentation
for that statistic's row label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A layout object suitable for passing to further layouting functions, or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>.
Adding this function to an <code>rtable</code> layout will summarize the given variables, arrange the output
in columns, and add it to the table layout.
</p>


<h3>See Also</h3>

<p><code><a href="rtables.html#topic+split_cols_by_multivar">rtables::split_cols_by_multivar()</a></code> and <code><a href="#topic+analyze_colvars_functions">analyze_colvars_functions</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dta_test &lt;- data.frame(
  USUBJID = rep(1:6, each = 3),
  PARAMCD = rep("lab", 6 * 3),
  AVISIT = rep(paste0("V", 1:3), 6),
  ARM = rep(LETTERS[1:3], rep(6, 3)),
  AVAL = c(9:1, rep(NA, 9)),
  CHG = c(1:9, rep(NA, 9))
)

## Default output within a `rtables` pipeline.
basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("AVISIT") %&gt;%
  split_cols_by_multivar(vars = c("AVAL", "CHG")) %&gt;%
  summarize_colvars() %&gt;%
  build_table(dta_test)

## Selection of statistics, formats and labels also work.
basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("AVISIT") %&gt;%
  split_cols_by_multivar(vars = c("AVAL", "CHG")) %&gt;%
  summarize_colvars(
    .stats = c("n", "mean_sd"),
    .formats = c("mean_sd" = "xx.x, xx.x"),
    .labels = c(n = "n", mean_sd = "Mean, SD")
  ) %&gt;%
  build_table(dta_test)

## Use arguments interpreted by `s_summary`.
basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("AVISIT") %&gt;%
  split_cols_by_multivar(vars = c("AVAL", "CHG")) %&gt;%
  summarize_colvars(na.rm = FALSE) %&gt;%
  build_table(dta_test)

</code></pre>

<hr>
<h2 id='summarize_functions'>Summarize Functions</h2><span id='topic+summarize_functions'></span>

<h3>Description</h3>

<p>These functions are wrappers for <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>, applying corresponding <code>tern</code> content functions
to add summary rows to a given table layout:
</p>

<ul>
<li> <p><code><a href="#topic+add_rowcounts">add_rowcounts()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+estimate_multinomial_response">estimate_multinomial_response()</a></code> (with <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>)
</p>
</li>
<li> <p><code><a href="#topic+h_tab_one_biomarker">h_tab_one_biomarker()</a></code> (probably to deprecate)
</p>
</li>
<li> <p><code><a href="#topic+logistic_summary_by_flag">logistic_summary_by_flag()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+summarize_num_patients">summarize_num_patients()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+summarize_occurrences">summarize_occurrences()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+summarize_occurrences_by_grade">summarize_occurrences_by_grade()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+summarize_patients_events_in_cols">summarize_patients_events_in_cols()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+summarize_patients_exposure_in_cols">summarize_patients_exposure_in_cols()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+tabulate_rsp_subgroups">tabulate_rsp_subgroups()</a></code>
</p>
</li></ul>

<p>Additionally, the <code><a href="#topic+summarize_coxreg">summarize_coxreg()</a></code> function utilizes <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>
(in combination with several other <code>rtables</code> functions like <code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code>) to
output a Cox regression summary table.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+analyze_functions">analyze_functions</a> for functions which are wrappers for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><a href="#topic+analyze_colvars_functions">analyze_colvars_functions</a> for functions that are wrappers for <code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code>.
</p>
</li></ul>


<hr>
<h2 id='summarize_glm_count'>Summary for Poisson Negative Binomial.</h2><span id='topic+summarize_glm_count'></span><span id='topic+s_glm_count'></span><span id='topic+a_glm_count'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Summarize results of a Poisson Negative Binomial Regression.
This can be used to analyze count and/or frequency data using a linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_glm_count(
  lyt,
  vars,
  variables,
  distribution,
  conf_level,
  rate_mean_method,
  weights = stats::weights,
  scale = 1,
  var_labels,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  show_labels = "visible",
  table_names = vars,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_glm_count(
  df,
  .var,
  .df_row,
  variables,
  .ref_group,
  .in_ref_col,
  distribution,
  conf_level,
  rate_mean_method,
  weights,
  scale = 1
)

a_glm_count(
  df,
  .var,
  .df_row,
  variables,
  .ref_group,
  .in_ref_col,
  distribution,
  conf_level,
  rate_mean_method,
  weights,
  scale = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_glm_count_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_variables">variables</code></td>
<td>
<p>(named <code>list</code> of <code>strings</code>)<br /> list of additional analysis variables, with
expected elements:
</p>

<ul>
<li> <p><code>arm</code> (<code>string</code>)<br /> group variable, for which the covariate adjusted means of multiple
groups will be summarized. Specifically, the first level of <code>arm</code> variable is taken as the
reference group.
</p>
</li>
<li> <p><code>covariates</code> (<code>character</code>)<br /> a vector that can contain single variable names (such as
<code>"X1"</code>), and/or interaction terms indicated by <code>"X1 * X2"</code>.
</p>
</li>
<li> <p><code>offset</code> (<code>numeric</code>)<br /> a numeric vector or scalar adding an offset.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_distribution">distribution</code></td>
<td>
<p>(<code>character</code>)<br /> a character value specifying the distribution
used in the regression (poisson, quasipoisson).</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>numeric</code>)<br /> value used to derive the confidence interval for the rate.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_weights">weights</code></td>
<td>
<p>(<code>character</code>)<br /> a character vector specifying weights used
in averaging predictions. Number of weights must equal the number of levels included in the covariates.
Weights option passed to <code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code>.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("summarize_glm_count")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_.df_row">.df_row</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set that includes all the variables that are called in <code>.var</code> and <code>variables</code>.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_.ref_group">.ref_group</code></td>
<td>
<p>(<code>data.frame</code> or <code>vector</code>)<br /> the data corresponding to the reference group.</p>
</td></tr>
<tr><td><code id="summarize_glm_count_+3A_.in_ref_col">.in_ref_col</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> when working with the reference level, <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>summarize_glm_count()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_glm_count()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_glm_count()</code> returns a named <code>list</code> of 5 statistics:
</p>

<ul>
<li> <p><code>n</code>: Count of complete sample size for the group.
</p>
</li>
<li> <p><code>rate</code>: Estimated event rate per follow-up time.
</p>
</li>
<li> <p><code>rate_ci</code>: Confidence level for estimated rate per follow-up time.
</p>
</li>
<li> <p><code>rate_ratio</code>: Ratio of event rates in each treatment arm to the reference arm.
</p>
</li>
<li> <p><code>rate_ratio_ci</code>: Confidence level for the rate ratio.
</p>
</li>
<li> <p><code>pval</code>: p-value.
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>a_glm_count()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>summarize_glm_count()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_glm_count()</code>: Statistics function that produces a named list of results
of the investigated Poisson model.
</p>
</li>
<li> <p><code>a_glm_count()</code>: Formatted analysis function which is used as <code>afun</code> in <code>summarize_glm_count()</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

anl &lt;- tern_ex_adtte %&gt;% filter(PARAMCD == "TNE")
anl$AVAL_f &lt;- as.factor(anl$AVAL)

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM", ref_group = "B: Placebo") %&gt;%
  add_colcounts() %&gt;%
  analyze_vars(
    "AVAL_f",
    var_labels = "Number of exacerbations per patient",
    .stats = c("count_fraction"),
    .formats = c("count_fraction" = "xx (xx.xx%)"),
    .label = c("Number of exacerbations per patient")
  ) %&gt;%
  summarize_glm_count(
    vars = "AVAL",
    variables = list(arm = "ARM", offset = "lgTMATRSK", covariates = NULL),
    conf_level = 0.95,
    distribution = "poisson",
    rate_mean_method = "emmeans",
    var_labels = "Unadjusted exacerbation rate (per year)",
    table_names = "unadj",
    .stats = c("rate"),
    .labels = c(rate = "Rate")
  ) %&gt;%
  summarize_glm_count(
    vars = "AVAL",
    variables = list(arm = "ARM", offset = "lgTMATRSK", covariates = c("REGION1")),
    conf_level = 0.95,
    distribution = "quasipoisson",
    rate_mean_method = "ppmeans",
    var_labels = "Adjusted (QP) exacerbation rate (per year)",
    table_names = "adj",
    .stats = c("rate", "rate_ci", "rate_ratio", "rate_ratio_ci", "pval"),
    .labels = c(
      rate = "Rate", rate_ci = "Rate CI", rate_ratio = "Rate Ratio",
      rate_ratio_ci = "Rate Ratio CI", pval = "p value"
    )
  )

build_table(lyt = lyt, df = anl)

</code></pre>

<hr>
<h2 id='summarize_logistic'>Multivariate Logistic Regression Table</h2><span id='topic+summarize_logistic'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Layout-creating function which summarizes a logistic variable regression for binary outcome with
categorical/continuous covariates in model statement. For each covariate category (if categorical)
or specified values (if continuous), present degrees of freedom, regression parameter estimate and
standard error (SE) relative to reference group or category. Report odds ratios for each covariate
category or specified values and corresponding Wald confidence intervals as default but allow user
to specify other confidence levels. Report p-value for Wald chi-square test of the null hypothesis
that covariate has no effect on response in model containing all specified covariates.
Allow option to include one two-way interaction and present similar output for
each interaction degree of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_logistic(
  lyt,
  conf_level,
  drop_and_remove_str = "",
  .indent_mods = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_logistic_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="summarize_logistic_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="summarize_logistic_+3A_drop_and_remove_str">drop_and_remove_str</code></td>
<td>
<p>(<code>character</code>)<br /> string to be dropped and removed.</p>
</td></tr>
<tr><td><code id="summarize_logistic_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A layout object suitable for passing to further layouting functions, or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>.
Adding this function to an <code>rtable</code> layout will add a logistic regression variable summary to the table layout.
</p>


<h3>Note</h3>

<p>For the formula, the variable names need to be standard <code>data.frame</code> column names without
special characters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(broom)

adrs_f &lt;- tern_ex_adrs %&gt;%
  filter(PARAMCD == "BESRSPI") %&gt;%
  filter(RACE %in% c("ASIAN", "WHITE", "BLACK OR AFRICAN AMERICAN")) %&gt;%
  mutate(
    Response = case_when(AVALC %in% c("PR", "CR") ~ 1, TRUE ~ 0),
    RACE = factor(RACE),
    SEX = factor(SEX)
  )
formatters::var_labels(adrs_f) &lt;- c(formatters::var_labels(tern_ex_adrs), Response = "Response")
mod1 &lt;- fit_logistic(
  data = adrs_f,
  variables = list(
    response = "Response",
    arm = "ARMCD",
    covariates = c("AGE", "RACE")
  )
)
mod2 &lt;- fit_logistic(
  data = adrs_f,
  variables = list(
    response = "Response",
    arm = "ARMCD",
    covariates = c("AGE", "RACE"),
    interaction = "AGE"
  )
)

df &lt;- tidy(mod1, conf_level = 0.99)
df2 &lt;- tidy(mod2, conf_level = 0.99)

# flagging empty strings with "_"
df &lt;- df_explicit_na(df, na_level = "_")
df2 &lt;- df_explicit_na(df2, na_level = "_")

result1 &lt;- basic_table() %&gt;%
  summarize_logistic(
    conf_level = 0.95,
    drop_and_remove_str = "_"
  ) %&gt;%
  build_table(df = df)
result1

result2 &lt;- basic_table() %&gt;%
  summarize_logistic(
    conf_level = 0.95,
    drop_and_remove_str = "_"
  ) %&gt;%
  build_table(df = df2)
result2

</code></pre>

<hr>
<h2 id='summarize_num_patients'>Number of Patients</h2><span id='topic+summarize_num_patients'></span><span id='topic+analyze_num_patients'></span><span id='topic+s_num_patients'></span><span id='topic+s_num_patients_content'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Count the number of unique and non-unique patients in a column (variable).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_num_patients(
  lyt,
  vars,
  required = NULL,
  count_by = NULL,
  unique_count_suffix = TRUE,
  na_str = default_na_str(),
  nested = TRUE,
  .stats = NULL,
  .formats = NULL,
  .labels = c(unique = "Number of patients with at least one event", nonunique =
    "Number of events"),
  show_labels = c("default", "visible", "hidden"),
  indent_mod = lifecycle::deprecated(),
  .indent_mods = 0L,
  riskdiff = FALSE,
  ...
)

summarize_num_patients(
  lyt,
  var,
  required = NULL,
  count_by = NULL,
  unique_count_suffix = TRUE,
  na_str = default_na_str(),
  .stats = NULL,
  .formats = NULL,
  .labels = c(unique = "Number of patients with at least one event", nonunique =
    "Number of events"),
  indent_mod = lifecycle::deprecated(),
  .indent_mods = 0L,
  riskdiff = FALSE,
  ...
)

s_num_patients(
  x,
  labelstr,
  .N_col,
  count_by = NULL,
  unique_count_suffix = TRUE
)

s_num_patients_content(
  df,
  labelstr = "",
  .N_col,
  .var,
  required = NULL,
  count_by = NULL,
  unique_count_suffix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_num_patients_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_required">required</code></td>
<td>
<p>(<code>character</code> or <code>NULL</code>)<br /> optional name of a variable that is required to be non-missing.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_count_by">count_by</code></td>
<td>
<p>(<code>vector</code>)<br /> optional vector of any type to be combined with <code>x</code> when counting <code>nonunique</code>
records.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_unique_count_suffix">unique_count_suffix</code></td>
<td>
<p>(<code>logical</code>)<br /> should <code>"(n)"</code> suffix be added to <code>unique_count</code> labels.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("summarize_num_patients")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_indent_mod">indent_mod</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use the <code>.indent_mods</code> argument instead.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_riskdiff">riskdiff</code></td>
<td>
<p>(<code>flag</code>)<br /> whether a risk difference column is present. When set to <code>TRUE</code>, <code><a href="#topic+add_riskdiff">add_riskdiff()</a></code> must be
used as <code>split_fun</code> in the prior column split of the table layout, specifying which columns should be compared.
See <code><a href="#topic+stat_propdiff_ci">stat_propdiff_ci()</a></code> for details on risk difference calculation.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_x">x</code></td>
<td>
<p>(<code>character</code> or <code>factor</code>)<br /> vector of patient IDs.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_labelstr">labelstr</code></td>
<td>
<p>(<code>character</code>)<br /> label of the level of the parent split currently being summarized
(must be present as second argument in Content Row Functions). See <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>
for more information.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="summarize_num_patients_+3A_.var">.var</code>, <code id="summarize_num_patients_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, functions that starts with <code style="white-space: pre;">&#8288;analyze*&#8288;</code> are expected to
work like <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>, while functions that starts with <code style="white-space: pre;">&#8288;summarize*&#8288;</code>
are based upon <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>. The latter provides a
value for each dividing split in the row and column space, but, being it
bound to the fundamental splits, it is repeated by design in every page
when pagination is involved.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>analyze_num_patients()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_num_patients_content()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>summarize_num_patients()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_num_patients_content()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_num_patients()</code> returns a named <code>list</code> of 3 statistics:
</p>

<ul>
<li> <p><code>unique</code>: Vector of counts and percentages.
</p>
</li>
<li> <p><code>nonunique</code>: Vector of counts.
</p>
</li>
<li> <p><code>unique_count</code>: Counts.
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>s_num_patients_content()</code> returns the same values as <code>s_num_patients()</code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>analyze_num_patients()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>summarize_num_patients()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>
</li>
<li> <p><code>s_num_patients()</code>: Statistics function which counts the number of
unique patients, the corresponding percentage taken with respect to the
total number of patients, and the number of non-unique patients.
</p>
</li>
<li> <p><code>s_num_patients_content()</code>: Statistics function which counts the number of unique patients
in a column (variable), the corresponding percentage taken with respect to the total number of
patients, and the number of non-unique patients in the column.
</p>
</li></ul>


<h3>Note</h3>

<p>As opposed to <code><a href="#topic+summarize_num_patients">summarize_num_patients()</a></code>, this function does not repeat the produced rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  USUBJID = as.character(c(1, 2, 1, 4, NA, 6, 6, 8, 9)),
  ARM = c("A", "A", "A", "A", "A", "B", "B", "B", "B"),
  AGE = c(10, 15, 10, 17, 8, 11, 11, 19, 17)
)

tbl &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_colcounts() %&gt;%
  analyze_num_patients("USUBJID", .stats = c("unique")) %&gt;%
  build_table(df)

tbl

# Use the statistics function to count number of unique and nonunique patients.
s_num_patients(x = as.character(c(1, 1, 1, 2, 4, NA)), labelstr = "", .N_col = 6L)
s_num_patients(
  x = as.character(c(1, 1, 1, 2, 4, NA)),
  labelstr = "",
  .N_col = 6L,
  count_by = c(1, 1, 2, 1, 1, 1)
)

# Count number of unique and non-unique patients.

df &lt;- data.frame(
  USUBJID = as.character(c(1, 2, 1, 4, NA)),
  EVENT = as.character(c(10, 15, 10, 17, 8))
)
s_num_patients_content(df, .N_col = 5, .var = "USUBJID")

df_by_event &lt;- data.frame(
  USUBJID = as.character(c(1, 2, 1, 4, NA)),
  EVENT = c(10, 15, 10, 17, 8)
)
s_num_patients_content(df_by_event, .N_col = 5, .var = "USUBJID", count_by = "EVENT")

</code></pre>

<hr>
<h2 id='summarize_patients_exposure_in_cols'>Counting Patients Summing Exposure Across All Patients in Columns</h2><span id='topic+summarize_patients_exposure_in_cols'></span><span id='topic+analyze_patients_exposure_in_cols'></span><span id='topic+s_count_patients_sum_exposure'></span><span id='topic+a_count_patients_sum_exposure'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Counting the number of patients and summing analysis value (i.e exposure values) across all patients
when a column table layout is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_patients_exposure_in_cols(
  lyt,
  var = NULL,
  ex_var = "AVAL",
  id = "USUBJID",
  add_total_level = FALSE,
  custom_label = NULL,
  col_split = TRUE,
  na_str = default_na_str(),
  .stats = c("n_patients", "sum_exposure"),
  .labels = c(n_patients = "Patients", sum_exposure = "Person time"),
  .indent_mods = 0L,
  ...
)

summarize_patients_exposure_in_cols(
  lyt,
  var,
  ex_var = "AVAL",
  id = "USUBJID",
  add_total_level = FALSE,
  custom_label = NULL,
  col_split = TRUE,
  na_str = default_na_str(),
  ...,
  .stats = c("n_patients", "sum_exposure"),
  .labels = c(n_patients = "Patients", sum_exposure = "Person time"),
  .indent_mods = NULL
)

s_count_patients_sum_exposure(
  df,
  ex_var = "AVAL",
  id = "USUBJID",
  labelstr = "",
  .stats = c("n_patients", "sum_exposure"),
  .N_col,
  custom_label = NULL
)

a_count_patients_sum_exposure(
  df,
  var = NULL,
  ex_var = "AVAL",
  id = "USUBJID",
  add_total_level = FALSE,
  custom_label = NULL,
  labelstr = "",
  .N_col,
  .stats,
  .formats = list(n_patients = "xx (xx.x%)", sum_exposure = "xx")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_var">var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_ex_var">ex_var</code></td>
<td>
<p>(<code>character</code>)<br /> name of the variable within <code>df</code> containing exposure values.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_id">id</code></td>
<td>
<p>(<code>string</code>)<br /> subject variable name.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_add_total_level">add_total_level</code></td>
<td>
<p>(<code>flag</code>)<br /> adds a &quot;total&quot; level after the others which includes all the levels
that constitute the split. A custom label can be set for this level via the <code>custom_label</code> argument.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_custom_label">custom_label</code></td>
<td>
<p>(<code>string</code> or <code>NULL</code>)<br /> if provided and <code>labelstr</code> is empty then this will be used as label.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_col_split">col_split</code></td>
<td>
<p>(<code>flag</code>)<br /> whether the columns should be split. Set to <code>FALSE</code> when the required
column split has been done already earlier in the layout pipe.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run
<code>get_stats("analyze_patients_exposure_in_cols")</code> to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_labelstr">labelstr</code></td>
<td>
<p>(<code>character</code>)<br /> label of the level of the parent split currently being summarized
(must be present as second argument in Content Row Functions). See <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>
for more information.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_.n_col">.N_col</code></td>
<td>
<p>(<code>integer</code>)<br /> column-wise N (column count) for the full column being analyzed that is typically
passed by <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="summarize_patients_exposure_in_cols_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>analyze_patients_exposure_in_cols()</code> returns a layout object suitable for passing to further
layouting functions, or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will
add formatted data rows, with the statistics from <code>s_count_patients_sum_exposure()</code> arranged in
columns, to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>summarize_patients_exposure_in_cols()</code> returns a layout object suitable for passing to further
layouting functions, or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will
add formatted content rows, with the statistics from <code>s_count_patients_sum_exposure()</code> arranged in
columns, to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_count_patients_sum_exposure()</code> returns a named <code>list</code> with the statistics:
</p>

<ul>
<li> <p><code>n_patients</code>: Number of unique patients in <code>df</code>.
</p>
</li>
<li> <p><code>sum_exposure</code>: Sum of <code>ex_var</code> across all patients in <code>df</code>.
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>a_count_patients_sum_exposure()</code> returns formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>analyze_patients_exposure_in_cols()</code>: Layout-creating function which can take statistics
function arguments and additional format arguments. This function is a wrapper for
<code><a href="rtables.html#topic+split_cols_by_multivar">rtables::split_cols_by_multivar()</a></code> and <code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code>.
</p>
</li>
<li> <p><code>summarize_patients_exposure_in_cols()</code>: Layout-creating function which can take statistics
function arguments and additional format arguments. This function is a wrapper for
<code><a href="rtables.html#topic+split_cols_by_multivar">rtables::split_cols_by_multivar()</a></code> and <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>
</li>
<li> <p><code>s_count_patients_sum_exposure()</code>: Statistics function which counts numbers
of patients and the sum of exposure across all patients.
</p>
</li>
<li> <p><code>a_count_patients_sum_exposure()</code>: Analysis function which is used as <code>afun</code> in
<code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code> within <code>analyze_patients_exposure_in_cols()</code> and as <code>cfun</code> in
<code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code> within <code>summarize_patients_exposure_in_cols()</code>.
</p>
</li></ul>


<h3>Note</h3>

<p>As opposed to <code><a href="#topic+summarize_patients_exposure_in_cols">summarize_patients_exposure_in_cols()</a></code> which generates content rows,
<code>analyze_patients_exposure_in_cols()</code> generates data rows which will <em>not</em> be repeated on multiple
pages when pagination is used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
df &lt;- data.frame(
  USUBJID = c(paste("id", seq(1, 12), sep = "")),
  ARMCD = c(rep("ARM A", 6), rep("ARM B", 6)),
  SEX = c(rep("Female", 6), rep("Male", 6)),
  AVAL = as.numeric(sample(seq(1, 20), 12)),
  stringsAsFactors = TRUE
)
adsl &lt;- data.frame(
  USUBJID = c(paste("id", seq(1, 12), sep = "")),
  ARMCD = c(rep("ARM A", 2), rep("ARM B", 2)),
  SEX = c(rep("Female", 2), rep("Male", 2)),
  stringsAsFactors = TRUE
)

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARMCD", split_fun = add_overall_level("Total", first = FALSE)) %&gt;%
  summarize_patients_exposure_in_cols(var = "AVAL", col_split = TRUE) %&gt;%
  analyze_patients_exposure_in_cols(var = "SEX", col_split = FALSE)
result &lt;- build_table(lyt, df = df, alt_counts_df = adsl)
result

lyt2 &lt;- basic_table() %&gt;%
  split_cols_by("ARMCD", split_fun = add_overall_level("Total", first = FALSE)) %&gt;%
  summarize_patients_exposure_in_cols(
    var = "AVAL", col_split = TRUE,
    .stats = "n_patients", custom_label = "some custom label"
  ) %&gt;%
  analyze_patients_exposure_in_cols(var = "SEX", col_split = FALSE, ex_var = "AVAL")
result2 &lt;- build_table(lyt2, df = df, alt_counts_df = adsl)
result2

lyt3 &lt;- basic_table() %&gt;%
  analyze_patients_exposure_in_cols(var = "SEX", col_split = TRUE, ex_var = "AVAL")
result3 &lt;- build_table(lyt3, df = df, alt_counts_df = adsl)
result3

# Adding total levels and custom label
lyt4 &lt;- basic_table(
  show_colcounts = TRUE
) %&gt;%
  analyze_patients_exposure_in_cols(
    var = "ARMCD",
    col_split = TRUE,
    add_total_level = TRUE,
    custom_label = "TOTAL"
  ) %&gt;%
  append_topleft(c("", "Sex"))

result4 &lt;- build_table(lyt4, df = df, alt_counts_df = adsl)
result4

lyt5 &lt;- basic_table() %&gt;%
  summarize_patients_exposure_in_cols(var = "AVAL", col_split = TRUE)

result5 &lt;- build_table(lyt5, df = df, alt_counts_df = adsl)
result5

lyt6 &lt;- basic_table() %&gt;%
  summarize_patients_exposure_in_cols(var = "AVAL", col_split = TRUE, .stats = "sum_exposure")

result6 &lt;- build_table(lyt6, df = df, alt_counts_df = adsl)
result6

a_count_patients_sum_exposure(
  df = df,
  var = "SEX",
  .N_col = nrow(df),
  .stats = "n_patients"
)

</code></pre>

<hr>
<h2 id='survival_biomarkers_subgroups'>Tabulate Biomarker Effects on Survival by Subgroup</h2><span id='topic+survival_biomarkers_subgroups'></span><span id='topic+tabulate_survival_biomarkers'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Tabulate the estimated effects of multiple continuous biomarker variables
across population subgroups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabulate_survival_biomarkers(
  df,
  vars = c("n_tot", "n_tot_events", "median", "hr", "ci", "pval"),
  groups_lists = list(),
  control = control_coxreg(),
  label_all = "All Patients",
  time_unit = NULL,
  na_str = default_na_str(),
  .indent_mods = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survival_biomarkers_subgroups_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> containing all analysis variables, as returned by
<code><a href="#topic+extract_survival_biomarkers">extract_survival_biomarkers()</a></code>.</p>
</td></tr>
<tr><td><code id="survival_biomarkers_subgroups_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> the names of statistics to be reported among:
</p>

<ul>
<li> <p><code>n_tot_events</code>: Total number of events per group.
</p>
</li>
<li> <p><code>n_tot</code>: Total number of observations per group.
</p>
</li>
<li> <p><code>median</code>: Median survival time.
</p>
</li>
<li> <p><code>hr</code>: Hazard ratio.
</p>
</li>
<li> <p><code>ci</code>: Confidence interval of hazard ratio.
</p>
</li>
<li> <p><code>pval</code>: p-value of the effect.
Note, one of the statistics <code>n_tot</code> and <code>n_tot_events</code>, as well as both <code>hr</code> and <code>ci</code> are required.
</p>
</li></ul>
</td></tr>
<tr><td><code id="survival_biomarkers_subgroups_+3A_groups_lists">groups_lists</code></td>
<td>
<p>(named <code>list</code> of <code>list</code>)<br /> optionally contains for each <code>subgroups</code> variable a
list, which specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
<tr><td><code id="survival_biomarkers_subgroups_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> a list of parameters as returned by the helper function <code><a href="#topic+control_coxreg">control_coxreg()</a></code>.</p>
</td></tr>
<tr><td><code id="survival_biomarkers_subgroups_+3A_label_all">label_all</code></td>
<td>
<p>(<code>string</code>)<br /> label for the total population analysis.</p>
</td></tr>
<tr><td><code id="survival_biomarkers_subgroups_+3A_time_unit">time_unit</code></td>
<td>
<p>(<code>string</code>)<br /> label with unit of median survival time. Default <code>NULL</code> skips displaying unit.</p>
</td></tr>
<tr><td><code id="survival_biomarkers_subgroups_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="survival_biomarkers_subgroups_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions create a layout starting from a data frame which contains
the required statistics. The tables are then typically used as input for forest plots.
</p>


<h3>Value</h3>

<p>An <code>rtables</code> table summarizing biomarker effects on survival by subgroup.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>tabulate_survival_biomarkers()</code>: Table-creating function which creates a table
summarizing biomarker effects on survival by subgroup.
</p>
</li></ul>


<h3>Note</h3>

<p>In contrast to <code><a href="#topic+tabulate_survival_subgroups">tabulate_survival_subgroups()</a></code> this tabulation function does
not start from an input layout <code>lyt</code>. This is because internally the table is
created by combining multiple subtables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+h_tab_surv_one_biomarker">h_tab_surv_one_biomarker()</a></code> which is used internally, <code><a href="#topic+extract_survival_biomarkers">extract_survival_biomarkers()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

adtte &lt;- tern_ex_adtte

# Save variable labels before data processing steps.
adtte_labels &lt;- formatters::var_labels(adtte)

adtte_f &lt;- adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  mutate(
    AVALU = as.character(AVALU),
    is_event = CNSR == 0
  )
labels &lt;- c("AVALU" = adtte_labels[["AVALU"]], "is_event" = "Event Flag")
formatters::var_labels(adtte_f)[names(labels)] &lt;- labels

# Typical analysis of two continuous biomarkers `BMRKR1` and `AGE`,
# in multiple regression models containing one covariate `RACE`,
# as well as one stratification variable `STRATA1`. The subgroups
# are defined by the levels of `BMRKR2`.

df &lt;- extract_survival_biomarkers(
  variables = list(
    tte = "AVAL",
    is_event = "is_event",
    biomarkers = c("BMRKR1", "AGE"),
    strata = "STRATA1",
    covariates = "SEX",
    subgroups = "BMRKR2"
  ),
  data = adtte_f
)
df

# Here we group the levels of `BMRKR2` manually.
df_grouped &lt;- extract_survival_biomarkers(
  variables = list(
    tte = "AVAL",
    is_event = "is_event",
    biomarkers = c("BMRKR1", "AGE"),
    strata = "STRATA1",
    covariates = "SEX",
    subgroups = "BMRKR2"
  ),
  data = adtte_f,
  groups_lists = list(
    BMRKR2 = list(
      "low" = "LOW",
      "low/medium" = c("LOW", "MEDIUM"),
      "low/medium/high" = c("LOW", "MEDIUM", "HIGH")
    )
  )
)
df_grouped

## Table with default columns.
tabulate_survival_biomarkers(df)

## Table with a manually chosen set of columns: leave out "pval", reorder.
tab &lt;- tabulate_survival_biomarkers(
  df = df,
  vars = c("n_tot_events", "ci", "n_tot", "median", "hr"),
  time_unit = as.character(adtte_f$AVALU[1])
)

## Finally produce the forest plot.

g_forest(tab, xlim = c(0.8, 1.2))


</code></pre>

<hr>
<h2 id='survival_coxph_pairwise'>Pairwise <code>CoxPH</code> model</h2><span id='topic+survival_coxph_pairwise'></span><span id='topic+coxph_pairwise'></span><span id='topic+s_coxph_pairwise'></span><span id='topic+a_coxph_pairwise'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Summarize p-value, HR and CIs from stratified or unstratified <code>CoxPH</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxph_pairwise(
  lyt,
  vars,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  var_labels = "CoxPH",
  show_labels = "visible",
  table_names = vars,
  .stats = c("pvalue", "hr", "hr_ci"),
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL
)

s_coxph_pairwise(
  df,
  .ref_group,
  .in_ref_col,
  .var,
  is_event,
  strat = NULL,
  control = control_coxph()
)

a_coxph_pairwise(
  df,
  .ref_group,
  .in_ref_col,
  .var,
  is_event,
  strat = NULL,
  control = control_coxph()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survival_coxph_pairwise_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("coxph_pairwise")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_.ref_group">.ref_group</code></td>
<td>
<p>(<code>data.frame</code> or <code>vector</code>)<br /> the data corresponding to the reference group.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_.in_ref_col">.in_ref_col</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> when working with the reference level, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_is_event">is_event</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> if event, <code>FALSE</code> if time to event is censored.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_strat">strat</code></td>
<td>
<p>(<code>character</code> or <code>NULL</code>)<br /> variable names indicating stratification factors.</p>
</td></tr>
<tr><td><code id="survival_coxph_pairwise_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> parameters for comparison details, specified by using the helper function
<code><a href="#topic+control_coxph">control_coxph()</a></code>. Some possible parameter options are:
</p>

<ul>
<li> <p><code>pval_method</code> (<code>string</code>)<br /> p-value method for testing hazard ratio = 1. Default method is <code>"log-rank"</code> which
comes from <code><a href="survival.html#topic+survdiff">survival::survdiff()</a></code>, can also be set to <code>"wald"</code> or <code>"likelihood"</code> (from <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>).
</p>
</li>
<li> <p><code>ties</code> (<code>string</code>)<br /> specifying the method for tie handling. Default is <code>"efron"</code>,
can also be set to <code>"breslow"</code> or <code>"exact"</code>. See more in <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>
</p>
</li>
<li> <p><code>conf_level</code> (<code>proportion</code>)<br /> confidence level of the interval for HR.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>coxph_pairwise()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_coxph_pairwise()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_coxph_pairwise()</code> returns the statistics:
</p>

<ul>
<li> <p><code>pvalue</code>: p-value to test HR = 1.
</p>
</li>
<li> <p><code>hr</code>: Hazard ratio.
</p>
</li>
<li> <p><code>hr_ci</code>: Confidence interval for hazard ratio.
</p>
</li>
<li> <p><code>n_tot</code>: Total number of observations.
</p>
</li>
<li> <p><code>n_tot_events</code>: Total number of events.
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>a_coxph_pairwise()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>coxph_pairwise()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_coxph_pairwise()</code>: Statistics function which analyzes HR, CIs of HR and p-value of a <code>coxph</code> model.
</p>
</li>
<li> <p><code>a_coxph_pairwise()</code>: Formatted analysis function which is used as <code>afun</code> in <code>coxph_pairwise()</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

adtte_f &lt;- tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  mutate(is_event = CNSR == 0)

df &lt;- adtte_f %&gt;% filter(ARMCD == "ARM A")
df_ref_group &lt;- adtte_f %&gt;% filter(ARMCD == "ARM B")

basic_table() %&gt;%
  split_cols_by(var = "ARMCD", ref_group = "ARM A") %&gt;%
  add_colcounts() %&gt;%
  coxph_pairwise(
    vars = "AVAL",
    is_event = "is_event",
    var_labels = "Unstratified Analysis"
  ) %&gt;%
  build_table(df = adtte_f)

basic_table() %&gt;%
  split_cols_by(var = "ARMCD", ref_group = "ARM A") %&gt;%
  add_colcounts() %&gt;%
  coxph_pairwise(
    vars = "AVAL",
    is_event = "is_event",
    var_labels = "Stratified Analysis",
    strat = "SEX",
    control = control_coxph(pval_method = "wald")
  ) %&gt;%
  build_table(df = adtte_f)

</code></pre>

<hr>
<h2 id='survival_duration_subgroups'>Tabulate Survival Duration by Subgroup</h2><span id='topic+survival_duration_subgroups'></span><span id='topic+tabulate_survival_subgroups'></span><span id='topic+a_survival_subgroups'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Tabulate statistics such as median survival time and hazard ratio for population subgroups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabulate_survival_subgroups(
  lyt,
  df,
  vars = c("n_tot_events", "n_events", "median", "hr", "ci"),
  groups_lists = list(),
  label_all = "All Patients",
  time_unit = NULL,
  na_str = default_na_str()
)

a_survival_subgroups(
  .formats = list(n = "xx", n_events = "xx", n_tot_events = "xx", median = "xx.x", n_tot
    = "xx", hr = list(format_extreme_values(2L)), ci =
    list(format_extreme_values_ci(2L)), pval = "x.xxxx | (&lt;0.0001)"),
  na_str = default_na_str()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survival_duration_subgroups_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="survival_duration_subgroups_+3A_df">df</code></td>
<td>
<p>(<code>list</code>)<br /> of data frames containing all analysis variables. List should be
created using <code><a href="#topic+extract_survival_subgroups">extract_survival_subgroups()</a></code>.</p>
</td></tr>
<tr><td><code id="survival_duration_subgroups_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> the name of statistics to be reported among:
</p>

<ul>
<li> <p><code>n_tot_events</code>: Total number of events per group.
</p>
</li>
<li> <p><code>n_events</code>: Number of events per group.
</p>
</li>
<li> <p><code>n_tot</code>: Total number of observations per group.
</p>
</li>
<li> <p><code>n</code>: Number of observations per group.
</p>
</li>
<li> <p><code>median</code>: Median survival time.
</p>
</li>
<li> <p><code>hr</code>: Hazard ratio.
</p>
</li>
<li> <p><code>ci</code>: Confidence interval of hazard ratio.
</p>
</li>
<li> <p><code>pval</code>: p-value of the effect.
Note, one of the statistics <code>n_tot</code> and <code>n_tot_events</code>, as well as both <code>hr</code> and <code>ci</code>
are required.
</p>
</li></ul>
</td></tr>
<tr><td><code id="survival_duration_subgroups_+3A_groups_lists">groups_lists</code></td>
<td>
<p>(named <code>list</code> of <code>list</code>)<br /> optionally contains for each <code>subgroups</code> variable a
list, which specifies the new group levels via the names and the
levels that belong to it in the character vectors that are elements of the list.</p>
</td></tr>
<tr><td><code id="survival_duration_subgroups_+3A_label_all">label_all</code></td>
<td>
<p>(<code>string</code>)<br /> label for the total population analysis.</p>
</td></tr>
<tr><td><code id="survival_duration_subgroups_+3A_time_unit">time_unit</code></td>
<td>
<p>(<code>string</code>)<br /> label with unit of median survival time. Default <code>NULL</code> skips displaying unit.</p>
</td></tr>
<tr><td><code id="survival_duration_subgroups_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="survival_duration_subgroups_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions create a layout starting from a data frame which contains
the required statistics. Tables typically used as part of forest plot.
</p>


<h3>Value</h3>

<p>An <code>rtables</code> table summarizing survival by subgroup.
</p>

<ul>
<li> <p><code>a_survival_subgroups()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>tabulate_survival_subgroups()</code>: Table-creating function which creates a table
summarizing survival by subgroup. This function is a wrapper for <code><a href="rtables.html#topic+analyze_colvars">rtables::analyze_colvars()</a></code>
and <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>.
</p>
</li>
<li> <p><code>a_survival_subgroups()</code>: Formatted analysis function which is used as
<code>afun</code> in <code>tabulate_survival_subgroups()</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+extract_survival_subgroups">extract_survival_subgroups()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(forcats)

adtte &lt;- tern_ex_adtte

# Save variable labels before data processing steps.
adtte_labels &lt;- formatters::var_labels(adtte)

adtte_f &lt;- adtte %&gt;%
  filter(
    PARAMCD == "OS",
    ARM %in% c("B: Placebo", "A: Drug X"),
    SEX %in% c("M", "F")
  ) %&gt;%
  mutate(
    # Reorder levels of ARM to display reference arm before treatment arm.
    ARM = droplevels(fct_relevel(ARM, "B: Placebo")),
    SEX = droplevels(SEX),
    AVALU = as.character(AVALU),
    is_event = CNSR == 0
  )
labels &lt;- c(
  "ARM" = adtte_labels[["ARM"]],
  "SEX" = adtte_labels[["SEX"]],
  "AVALU" = adtte_labels[["AVALU"]],
  "is_event" = "Event Flag"
)
formatters::var_labels(adtte_f)[names(labels)] &lt;- labels

df &lt;- extract_survival_subgroups(
  variables = list(
    tte = "AVAL",
    is_event = "is_event",
    arm = "ARM", subgroups = c("SEX", "BMRKR2")
  ),
  data = adtte_f
)
df

df_grouped &lt;- extract_survival_subgroups(
  variables = list(
    tte = "AVAL",
    is_event = "is_event",
    arm = "ARM", subgroups = c("SEX", "BMRKR2")
  ),
  data = adtte_f,
  groups_lists = list(
    BMRKR2 = list(
      "low" = "LOW",
      "low/medium" = c("LOW", "MEDIUM"),
      "low/medium/high" = c("LOW", "MEDIUM", "HIGH")
    )
  )
)
df_grouped

## Table with default columns.
basic_table() %&gt;%
  tabulate_survival_subgroups(df, time_unit = adtte_f$AVALU[1])

## Table with a manually chosen set of columns: adding "pval".
basic_table() %&gt;%
  tabulate_survival_subgroups(
    df = df,
    vars = c("n_tot_events", "n_events", "median", "hr", "ci", "pval"),
    time_unit = adtte_f$AVALU[1]
  )

</code></pre>

<hr>
<h2 id='survival_time'>Survival Time Analysis</h2><span id='topic+survival_time'></span><span id='topic+surv_time'></span><span id='topic+s_surv_time'></span><span id='topic+a_surv_time'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Summarize median survival time and CIs, percentiles of survival times, survival
time range of censored/event patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv_time(
  lyt,
  vars,
  is_event,
  control = control_surv_time(),
  ref_fn_censor = TRUE,
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  var_labels = "Time to Event",
  show_labels = "visible",
  table_names = vars,
  .stats = c("median", "median_ci", "quantiles", "range"),
  .formats = NULL,
  .labels = NULL,
  .indent_mods = c(median_ci = 1L)
)

s_surv_time(df, .var, is_event, control = control_surv_time())

a_surv_time(
  df,
  labelstr = "",
  .var = NULL,
  .df_row = NULL,
  is_event,
  control = control_surv_time(),
  ref_fn_censor = TRUE,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL,
  na_str = default_na_str()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survival_time_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_is_event">is_event</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> if event, <code>FALSE</code> if time to event is censored.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> parameters for comparison details, specified by using the helper function
<code><a href="#topic+control_surv_time">control_surv_time()</a></code>. Some possible parameter options are:
</p>

<ul>
<li> <p><code>conf_level</code> (<code>proportion</code>)<br /> confidence level of the interval for survival time.
</p>
</li>
<li> <p><code>conf_type</code> (<code>string</code>)<br /> confidence interval type. Options are &quot;plain&quot; (default), &quot;log&quot;, or &quot;log-log&quot;,
see more in <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>. Note option &quot;none&quot; is not supported.
</p>
</li>
<li> <p><code>quantiles</code> (<code>numeric</code>)<br /> vector of length two to specify the quantiles of survival time.
</p>
</li></ul>
</td></tr>
<tr><td><code id="survival_time_+3A_ref_fn_censor">ref_fn_censor</code></td>
<td>
<p>(<code>flag</code>)<br /> whether referential footnotes indicating censored observations should be printed
when the <code>range</code> statistic is included.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_table_names">table_names</code></td>
<td>
<p>(<code>character</code>)<br /> this can be customized in case that the same <code>vars</code> are analyzed multiple times,
to avoid warnings from <code>rtables</code>.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("surv_time")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="survival_time_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>vector</code> of <code>integer</code>)<br /> indent modifiers for the labels. Each element of the vector
should be a name-value pair with name corresponding to a statistic specified in <code>.stats</code> and value the indentation
for that statistic's row label.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_labelstr">labelstr</code></td>
<td>
<p>(<code>character</code>)<br /> label of the level of the parent split currently being summarized
(must be present as second argument in Content Row Functions). See <code><a href="rtables.html#topic+summarize_row_groups">rtables::summarize_row_groups()</a></code>
for more information.</p>
</td></tr>
<tr><td><code id="survival_time_+3A_.df_row">.df_row</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data frame across all of the columns for the given row split.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>surv_time()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_surv_time()</code> to the table layout.
</p>
</li></ul>


<ul>
<li> <p><code>s_surv_time()</code> returns the statistics:
</p>

<ul>
<li> <p><code>median</code>: Median survival time.
</p>
</li>
<li> <p><code>median_ci</code>: Confidence interval for median time.
</p>
</li>
<li> <p><code>quantiles</code>: Survival time for two specified quantiles.
</p>
</li>
<li> <p><code>range_censor</code>: Survival time range for censored observations.
</p>
</li>
<li> <p><code>range_event</code>: Survival time range for observations with events.
</p>
</li>
<li> <p><code>range</code>: Survival time range for all observations.
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>a_surv_time()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>surv_time()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_surv_time()</code>: Statistics function which analyzes survival times.
</p>
</li>
<li> <p><code>a_surv_time()</code>: Formatted analysis function which is used as <code>afun</code> in <code>surv_time()</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

adtte_f &lt;- tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  mutate(
    AVAL = day2month(AVAL),
    is_event = CNSR == 0
  )
df &lt;- adtte_f %&gt;% filter(ARMCD == "ARM A")

basic_table() %&gt;%
  split_cols_by(var = "ARMCD") %&gt;%
  add_colcounts() %&gt;%
  surv_time(
    vars = "AVAL",
    var_labels = "Survival Time (Months)",
    is_event = "is_event",
    control = control_surv_time(conf_level = 0.9, conf_type = "log-log")
  ) %&gt;%
  build_table(df = adtte_f)

a_surv_time(
  df,
  .df_row = df,
  .var = "AVAL",
  is_event = "is_event"
)

</code></pre>

<hr>
<h2 id='survival_timepoint'>Survival Time Point Analysis</h2><span id='topic+survival_timepoint'></span><span id='topic+surv_timepoint'></span><span id='topic+s_surv_timepoint'></span><span id='topic+a_surv_timepoint'></span><span id='topic+s_surv_timepoint_diff'></span><span id='topic+a_surv_timepoint_diff'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Summarize patients' survival rate and difference of survival rates between groups at a time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv_timepoint(
  lyt,
  vars,
  time_point,
  is_event,
  control = control_surv_timepoint(),
  method = c("surv", "surv_diff", "both"),
  na_str = default_na_str(),
  nested = TRUE,
  ...,
  table_names_suffix = "",
  var_labels = "Time",
  show_labels = "visible",
  .stats = c("pt_at_risk", "event_free_rate", "rate_ci", "rate_diff", "rate_diff_ci",
    "ztest_pval"),
  .formats = NULL,
  .labels = NULL,
  .indent_mods = if (method == "both") {
     c(rate_diff = 1L, rate_diff_ci = 2L,
    ztest_pval = 2L)
 } else {
     c(rate_diff_ci = 1L, ztest_pval = 1L)
 }
)

s_surv_timepoint(
  df,
  .var,
  time_point,
  is_event,
  control = control_surv_timepoint()
)

a_surv_timepoint(
  df,
  .var,
  time_point,
  is_event,
  control = control_surv_timepoint()
)

s_surv_timepoint_diff(
  df,
  .var,
  .ref_group,
  .in_ref_col,
  time_point,
  control = control_surv_timepoint(),
  ...
)

a_surv_timepoint_diff(
  df,
  .var,
  .ref_group,
  .in_ref_col,
  time_point,
  control = control_surv_timepoint(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survival_timepoint_+3A_lyt">lyt</code></td>
<td>
<p>(<code>layout</code>)<br /> input layout where analyses will be added to.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code>)<br /> variable names for the primary analysis variable to be iterated over.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_time_point">time_point</code></td>
<td>
<p>(<code>number</code>)<br /> survival time point of interest.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_is_event">is_event</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> if event, <code>FALSE</code> if time to event is censored.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_control">control</code></td>
<td>
<p>(<code>list</code>)<br /> parameters for comparison details, specified by using the helper function
<code><a href="#topic+control_surv_timepoint">control_surv_timepoint()</a></code>. Some possible parameter options are:
</p>

<ul>
<li> <p><code>conf_level</code> (<code>proportion</code>)<br /> confidence level of the interval for survival rate.
</p>
</li>
<li> <p><code>conf_type</code> (<code>string</code>)<br /> confidence interval type. Options are &quot;plain&quot; (default), &quot;log&quot;, &quot;log-log&quot;,
see more in <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>. Note option &quot;none&quot; is no longer supported.
</p>
</li>
<li> <p><code>time_point</code> (<code>number</code>)<br /> survival time point of interest.
</p>
</li></ul>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_method">method</code></td>
<td>
<p>(<code>string</code>)<br /> either <code>surv</code> (survival estimations),
<code>surv_diff</code> (difference in survival with the control) or <code>both</code>.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_na_str">na_str</code></td>
<td>
<p>(<code>string</code>)<br /> string used to replace all <code>NA</code> or empty values in the output.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_nested">nested</code></td>
<td>
<p>(<code>flag</code>)<br /> whether this layout instruction should be applied within the existing layout structure <em>if
possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_table_names_suffix">table_names_suffix</code></td>
<td>
<p>(<code>string</code>)<br /> optional suffix for the <code>table_names</code> used for the <code>rtables</code> to
avoid warnings from duplicate table names.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_var_labels">var_labels</code></td>
<td>
<p>(<code>character</code>)<br /> character for label.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_show_labels">show_labels</code></td>
<td>
<p>(<code>string</code>)<br /> label visibility: one of &quot;default&quot;, &quot;visible&quot; and &quot;hidden&quot;.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_.stats">.stats</code></td>
<td>
<p>(<code>character</code>)<br /> statistics to select for the table. Run <code>get_stats("surv_timepoint")</code>
to see available statistics for this function.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>vector</code> of <code>integer</code>)<br /> indent modifiers for the labels. Each element of the vector
should be a name-value pair with name corresponding to a statistic specified in <code>.stats</code> and value the indentation
for that statistic's row label.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>)<br /> data set containing all analysis variables.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_.var">.var</code></td>
<td>
<p>(<code>string</code>)<br /> single variable name that is passed by <code>rtables</code> when requested
by a statistics function.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_.ref_group">.ref_group</code></td>
<td>
<p>(<code>data.frame</code> or <code>vector</code>)<br /> the data corresponding to the reference group.</p>
</td></tr>
<tr><td><code id="survival_timepoint_+3A_.in_ref_col">.in_ref_col</code></td>
<td>
<p>(<code>logical</code>)<br /> <code>TRUE</code> when working with the reference level, <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>surv_timepoint()</code> returns a layout object suitable for passing to further layouting functions,
or to <code><a href="rtables.html#topic+build_table">rtables::build_table()</a></code>. Adding this function to an <code>rtable</code> layout will add formatted rows containing
the statistics from <code>s_surv_timepoint()</code> and/or <code>s_surv_timepoint_diff()</code> to the table layout depending on
the value of <code>method</code>.
</p>
</li></ul>


<ul>
<li> <p><code>s_surv_timepoint()</code> returns the statistics:
</p>

<ul>
<li> <p><code>pt_at_risk</code>: Patients remaining at risk.
</p>
</li>
<li> <p><code>event_free_rate</code>: Event-free rate (%).
</p>
</li>
<li> <p><code>rate_se</code>: Standard error of event free rate.
</p>
</li>
<li> <p><code>rate_ci</code>: Confidence interval for event free rate.
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>a_surv_timepoint()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>


<ul>
<li> <p><code>s_surv_timepoint_diff()</code> returns the statistics:
</p>

<ul>
<li> <p><code>rate_diff</code>: Event-free rate difference between two groups.
</p>
</li>
<li> <p><code>rate_diff_ci</code>: Confidence interval for the difference.
</p>
</li>
<li> <p><code>ztest_pval</code>: p-value to test the difference is 0.
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>a_surv_timepoint_diff()</code> returns the corresponding list with formatted <code><a href="rtables.html#topic+CellValue">rtables::CellValue()</a></code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>surv_timepoint()</code>: Layout-creating function which can take statistics function arguments
and additional format arguments. This function is a wrapper for <code><a href="rtables.html#topic+analyze">rtables::analyze()</a></code>.
</p>
</li>
<li> <p><code>s_surv_timepoint()</code>: Statistics function which analyzes survival rate.
</p>
</li>
<li> <p><code>a_surv_timepoint()</code>: Formatted analysis function which is used as <code>afun</code> in <code>surv_timepoint()</code>
when <code>method = "surv"</code>.
</p>
</li>
<li> <p><code>s_surv_timepoint_diff()</code>: Statistics function which analyzes difference between two survival rates.
</p>
</li>
<li> <p><code>a_surv_timepoint_diff()</code>: Formatted analysis function which is used as <code>afun</code> in <code>surv_timepoint()</code>
when <code>method = "surv_diff"</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

adtte_f &lt;- tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  mutate(
    AVAL = day2month(AVAL),
    is_event = CNSR == 0
  )

# Survival at given time points.
basic_table() %&gt;%
  split_cols_by(var = "ARMCD", ref_group = "ARM A") %&gt;%
  add_colcounts() %&gt;%
  surv_timepoint(
    vars = "AVAL",
    var_labels = "Months",
    is_event = "is_event",
    time_point = 7
  ) %&gt;%
  build_table(df = adtte_f)

# Difference in survival at given time points.
basic_table() %&gt;%
  split_cols_by(var = "ARMCD", ref_group = "ARM A") %&gt;%
  add_colcounts() %&gt;%
  surv_timepoint(
    vars = "AVAL",
    var_labels = "Months",
    is_event = "is_event",
    time_point = 9,
    method = "surv_diff",
    .indent_mods = c("rate_diff" = 0L, "rate_diff_ci" = 2L, "ztest_pval" = 2L)
  ) %&gt;%
  build_table(df = adtte_f)

# Survival and difference in survival at given time points.
basic_table() %&gt;%
  split_cols_by(var = "ARMCD", ref_group = "ARM A") %&gt;%
  add_colcounts() %&gt;%
  surv_timepoint(
    vars = "AVAL",
    var_labels = "Months",
    is_event = "is_event",
    time_point = 9,
    method = "both"
  ) %&gt;%
  build_table(df = adtte_f)

</code></pre>

<hr>
<h2 id='tidy_coxreg'>Custom Tidy Methods for Cox Regression</h2><span id='topic+tidy_coxreg'></span><span id='topic+tidy.summary.coxph'></span><span id='topic+tidy.coxreg.univar'></span><span id='topic+tidy.coxreg.multivar'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.coxph'
tidy(x, ...)

## S3 method for class 'coxreg.univar'
tidy(x, ...)

## S3 method for class 'coxreg.multivar'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_coxreg_+3A_x">x</code></td>
<td>
<p>(<code>list</code>)<br /> Result of the Cox regression model fitted by <code><a href="#topic+fit_coxreg_univar">fit_coxreg_univar()</a></code> (for univariate models)
or <code><a href="#topic+fit_coxreg_multivar">fit_coxreg_multivar()</a></code> (for multivariate models).</p>
</td></tr>
<tr><td><code id="tidy_coxreg_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="broom.html#topic+tidy">tidy()</a></code> returns:
</p>

<ul>
<li><p> For <code>summary.coxph</code> objects,  a <code>data.frame</code> with columns: <code style="white-space: pre;">&#8288;Pr(&gt;|z|)&#8288;</code>, <code>exp(coef)</code>, <code>exp(-coef)</code>, <code style="white-space: pre;">&#8288;lower .95&#8288;</code>,
<code style="white-space: pre;">&#8288;upper .95&#8288;</code>, <code>level</code>, and <code>n</code>.
</p>
</li>
<li><p> For <code>coxreg.univar</code> objects, a <code>data.frame</code> with columns: <code>effect</code>, <code>term</code>, <code>term_label</code>, <code>level</code>, <code>n</code>, <code>hr</code>,
<code>lcl</code>, <code>ucl</code>, <code>pval</code>, and <code>ci</code>.
</p>
</li>
<li><p> For <code>coxreg.multivar</code> objects, a <code>data.frame</code> with columns: <code>term</code>, <code>pval</code>, <code>term_label</code>, <code>hr</code>, <code>lcl</code>, <code>ucl</code>,
<code>level</code>, and <code>ci</code>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>tidy(summary.coxph)</code>: Custom tidy method for <code><a href="survival.html#topic+coxph">survival::coxph()</a></code> summary results.
</p>
<p>Tidy the <code><a href="survival.html#topic+coxph">survival::coxph()</a></code> results into a <code>data.frame</code> to extract model results.
</p>
</li>
<li> <p><code>tidy(coxreg.univar)</code>: Custom tidy method for a univariate Cox regression.
</p>
<p>Tidy up the result of a Cox regression model fitted by <code><a href="#topic+fit_coxreg_univar">fit_coxreg_univar()</a></code>.
</p>
</li>
<li> <p><code>tidy(coxreg.multivar)</code>: Custom tidy method for a multivariate Cox regression.
</p>
<p>Tidy up the result of a Cox regression model fitted by <code><a href="#topic+fit_coxreg_multivar">fit_coxreg_multivar()</a></code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+cox_regression">cox_regression</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(broom)

set.seed(1, kind = "Mersenne-Twister")

dta_bladder &lt;- with(
  data = bladder[bladder$enum &lt; 5, ],
  data.frame(
    time = stop,
    status = event,
    armcd = as.factor(rx),
    covar1 = as.factor(enum),
    covar2 = factor(
      sample(as.factor(enum)),
      levels = 1:4, labels = c("F", "F", "M", "M")
    )
  )
)
labels &lt;- c("armcd" = "ARM", "covar1" = "A Covariate Label", "covar2" = "Sex (F/M)")
formatters::var_labels(dta_bladder)[names(labels)] &lt;- labels
dta_bladder$age &lt;- sample(20:60, size = nrow(dta_bladder), replace = TRUE)

formula &lt;- "survival::Surv(time, status) ~ armcd + covar1"
msum &lt;- summary(coxph(stats::as.formula(formula), data = dta_bladder))
tidy(msum)

## Cox regression: arm + 1 covariate.
mod1 &lt;- fit_coxreg_univar(
  variables = list(
    time = "time", event = "status", arm = "armcd",
    covariates = "covar1"
  ),
  data = dta_bladder,
  control = control_coxreg(conf_level = 0.91)
)

## Cox regression: arm + 1 covariate + interaction, 2 candidate covariates.
mod2 &lt;- fit_coxreg_univar(
  variables = list(
    time = "time", event = "status", arm = "armcd",
    covariates = c("covar1", "covar2")
  ),
  data = dta_bladder,
  control = control_coxreg(conf_level = 0.91, interaction = TRUE)
)

tidy(mod1)
tidy(mod2)

multivar_model &lt;- fit_coxreg_multivar(
  variables = list(
    time = "time", event = "status", arm = "armcd",
    covariates = c("covar1", "covar2")
  ),
  data = dta_bladder
)
broom::tidy(multivar_model)

</code></pre>

<hr>
<h2 id='tidy.glm'>Custom Tidy Method for Binomial GLM Results</h2><span id='topic+tidy.glm'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper method (for <code><a href="broom.html#topic+reexports">broom::tidy()</a></code>) to prepare a data frame from a <code>glm</code> object
with <code>binomial</code> family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
tidy(x, conf_level = 0.95, at = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.glm_+3A_x">x</code></td>
<td>
<p>logistic regression model fitted by <code><a href="stats.html#topic+glm">stats::glm()</a></code> with &quot;binomial&quot; family.</p>
</td></tr>
<tr><td><code id="tidy.glm_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="tidy.glm_+3A_at">at</code></td>
<td>
<p>(<code>NULL</code> or <code>numeric</code>)<br /> optional values for the interaction variable. Otherwise the median is used.</p>
</td></tr>
<tr><td><code id="tidy.glm_+3A_...">...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the tidied model.
</p>


<h3>See Also</h3>

<p><a href="#topic+h_logistic_regression">h_logistic_regression</a> for relevant helper functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(broom)

adrs_f &lt;- tern_ex_adrs %&gt;%
  filter(PARAMCD == "BESRSPI") %&gt;%
  filter(RACE %in% c("ASIAN", "WHITE", "BLACK OR AFRICAN AMERICAN")) %&gt;%
  mutate(
    Response = case_when(AVALC %in% c("PR", "CR") ~ 1, TRUE ~ 0),
    RACE = factor(RACE),
    SEX = factor(SEX)
  )
formatters::var_labels(adrs_f) &lt;- c(formatters::var_labels(tern_ex_adrs), Response = "Response")
mod1 &lt;- fit_logistic(
  data = adrs_f,
  variables = list(
    response = "Response",
    arm = "ARMCD",
    covariates = c("AGE", "RACE")
  )
)
mod2 &lt;- fit_logistic(
  data = adrs_f,
  variables = list(
    response = "Response",
    arm = "ARMCD",
    covariates = c("AGE", "RACE"),
    interaction = "AGE"
  )
)

df &lt;- tidy(mod1, conf_level = 0.99)
df2 &lt;- tidy(mod2, conf_level = 0.99)

</code></pre>

<hr>
<h2 id='tidy.step'>Custom Tidy Method for STEP Results</h2><span id='topic+tidy.step'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Tidy the STEP results into a <code>tibble</code> format ready for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'step'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.step_+3A_x">x</code></td>
<td>
<p>(<code>step</code> matrix)<br /> results from <code><a href="#topic+fit_survival_step">fit_survival_step()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.step_+3A_...">...</code></td>
<td>
<p>not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with one row per STEP subgroup. The estimates and CIs are on the HR or OR scale,
respectively. Additional attributes carry metadata also used for plotting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+g_step">g_step()</a></code> which consumes the result from this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
lung$sex &lt;- factor(lung$sex)
vars &lt;- list(
  time = "time",
  event = "status",
  arm = "sex",
  biomarker = "age"
)
step_matrix &lt;- fit_survival_step(
  variables = vars,
  data = lung,
  control = c(control_coxph(), control_step(num_points = 10, degree = 2))
)
broom::tidy(step_matrix)

</code></pre>

<hr>
<h2 id='to_n'>Replicate Entries of a Vector if Required</h2><span id='topic+to_n'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Replicate entries of a vector if required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_n(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_n_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> vector of numbers we want to analyze.</p>
</td></tr>
<tr><td><code id="to_n_+3A_n">n</code></td>
<td>
<p>(<code>count</code>)<br /> how many entries we need.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> if it has the required length already or is <code>NULL</code>,
otherwise if it is scalar the replicated version of it with <code>n</code> entries.
</p>


<h3>Note</h3>

<p>This function will fail if <code>x</code> is not of length <code>n</code> and/or is not a scalar.
</p>

<hr>
<h2 id='to_string_matrix'>Convert Table into Matrix of Strings</h2><span id='topic+to_string_matrix'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Helper function to use mostly within tests. <code>with_spaces</code>parameter allows
to test not only for content but also indentation and table structure.
<code>print_txt_to_copy</code> instead facilitate the testing development by returning a well
formatted text that needs only to be copied and pasted in the expected output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_string_matrix(
  x,
  widths = NULL,
  max_width = NULL,
  hsep = formatters::default_hsep(),
  with_spaces = TRUE,
  print_txt_to_copy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_string_matrix_+3A_x">x</code></td>
<td>
<p><code>rtables</code> table.</p>
</td></tr>
<tr><td><code id="to_string_matrix_+3A_widths">widths</code></td>
<td>
<p>numeric (or  <code>NULL</code>). (proposed) widths for the columns
of <code>x</code>. The expected length  of this numeric vector can be
retrieved with  <code>ncol() + 1</code>  as the  column of row  names must
also be considered.</p>
</td></tr>
<tr><td><code id="to_string_matrix_+3A_max_width">max_width</code></td>
<td>
<p>integer(1), character(1) or <code>NULL</code>. Width that title
and   footer   (including   footnotes)  materials   should   be
word-wrapped to. If <code>NULL</code>, it is  set to the current print width
of the  session (<code>getOption("width")</code>). If set to <code>"auto"</code>,
the width of the table (plus any table inset) is used. Ignored
completely if <code>tf_wrap</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="to_string_matrix_+3A_hsep">hsep</code></td>
<td>
<p>character(1). Characters to repeat to create
header/body separator line. If <code>NULL</code>, the object value will be
used. If <code>" "</code>, an empty separator will be printed. Check <code><a href="formatters.html#topic+default_hsep">default_hsep()</a></code>
for more information.</p>
</td></tr>
<tr><td><code id="to_string_matrix_+3A_with_spaces">with_spaces</code></td>
<td>
<p>(<code>logical</code>)<br /> should the tested table keep the indentation and other relevant spaces?</p>
</td></tr>
<tr><td><code id="to_string_matrix_+3A_print_txt_to_copy">print_txt_to_copy</code></td>
<td>
<p>(<code>logical</code>)<br /> utility to have a way to copy the input table directly
into the expected variable instead of copying it too manually.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of <code>string</code>s. If <code>print_txt_to_copy = TRUE</code> the well formatted printout of the
table will be printed to console, ready to be copied as a expected value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tbl &lt;- basic_table() %&gt;%
  split_rows_by("SEX") %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze("AGE") %&gt;%
  build_table(tern_ex_adsl)

to_string_matrix(tbl, widths = ceiling(propose_column_widths(tbl) / 2))

</code></pre>

<hr>
<h2 id='try_car_anova'><code>tryCatch</code> around <code>car::Anova</code></h2><span id='topic+try_car_anova'></span>

<h3>Description</h3>

<p>Captures warnings when executing <a href="car.html#topic+Anova">car::Anova</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_car_anova(mod, test.statistic)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_car_anova_+3A_mod">mod</code></td>
<td>
<p><code>lm</code>, <code>aov</code>, <code>glm</code>, <code>multinom</code>, <code>polr</code>
<code>mlm</code>, <code>coxph</code>, <code>coxme</code>, <code>lme</code>, <code>mer</code>, <code>merMod</code>, <code>svyglm</code>, <code>svycoxph</code>,
<code>rlm</code>, or other suitable model object.</p>
</td></tr>
<tr><td><code id="try_car_anova_+3A_test.statistic">test.statistic</code></td>
<td>
<p>for a generalized linear model, whether to calculate
<code>"LR"</code> (likelihood-ratio), <code>"Wald"</code>, or <code>"F"</code> tests; for a Cox
or Cox mixed-effects model, whether to calculate <code>"LR"</code> (partial-likelihood ratio) or
<code>"Wald"</code> tests; in the default case or for linear mixed models fit by
<code>lmer</code>, whether to calculate Wald <code>"Chisq"</code> or Kenward-Roger
<code>"F"</code> tests with Satterthwaite degrees of freedom (<em>warning:</em> the KR F-tests
can be very time-consuming).
For a multivariate linear model, the multivariate test statistic to compute &mdash; one of
<code>"Pillai"</code>, <code>"Wilks"</code>, <code>"Hotelling-Lawley"</code>, or <code>"Roy"</code>,
with <code>"Pillai"</code> as the default. The <code>summary</code> method for <code>Anova.mlm</code>
objects permits the specification of more than one multivariate
test statistic, and the default is to report all four.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with item <code>aov</code> for the result of the model and <code>error_text</code> for the captured warnings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># `car::Anova` on cox regression model including strata and expected
# a likelihood ratio test triggers a warning as only `Wald` method is
# accepted.

library(survival)

mod &lt;- coxph(
  formula = Surv(time = futime, event = fustat) ~ factor(rx) + strata(ecog.ps),
  data = ovarian
)

</code></pre>

<hr>
<h2 id='ungroup_stats'>Ungroup Non-Numeric Statistics</h2><span id='topic+ungroup_stats'></span>

<h3>Description</h3>

<p>Ungroups grouped non-numeric statistics within input vectors <code>.formats</code>, <code>.labels</code>, and <code>.indent_mods</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ungroup_stats(x, .formats, .labels, .indent_mods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ungroup_stats_+3A_x">x</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;named list&#8288;</code> of <code>numeric</code>)<br /> list of numeric statistics containing the statistics to ungroup.</p>
</td></tr>
<tr><td><code id="ungroup_stats_+3A_.formats">.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br /> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td></tr>
<tr><td><code id="ungroup_stats_+3A_.labels">.labels</code></td>
<td>
<p>(named <code>character</code>)<br /> labels for the statistics (without indent).</p>
</td></tr>
<tr><td><code id="ungroup_stats_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br /> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with modified elements <code>x</code>, <code>.formats</code>, <code>.labels</code>, and <code>.indent_mods</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+a_summary">a_summary()</a></code> which uses this function internally.
</p>

<hr>
<h2 id='univariate'>Univariate Formula Special Term</h2><span id='topic+univariate'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The special term <code>univariate</code> indicate that the model should be fitted individually for
every variable included in univariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>univariate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="univariate_+3A_x">x</code></td>
<td>
<p>A vector of variable name separated by commas.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If provided alongside with pairwise specification, the model
<code>y ~ ARM + univariate(SEX, AGE, RACE)</code> lead to the study and comparison of the models
</p>

<ul>
<li> <p><code>y ~ ARM</code>
</p>
</li>
<li> <p><code>y ~ ARM + SEX</code>
</p>
</li>
<li> <p><code>y ~ ARM + AGE</code>
</p>
</li>
<li> <p><code>y ~ ARM + RACE</code>
</p>
</li></ul>



<h3>Value</h3>

<p>When used within a model formula, produces univariate models for each variable provided.
</p>

<hr>
<h2 id='unlist_and_blank_na'>Blank for Missing Input</h2><span id='topic+unlist_and_blank_na'></span>

<h3>Description</h3>

<p>Helper function to use in tabulating model results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unlist_and_blank_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlist_and_blank_na_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>)<br /> input for a cell.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empty <code>character</code> vector if all entries in <code>x</code> are missing (<code>NA</code>), otherwise
the unlisted version of <code>x</code>.
</p>

<hr>
<h2 id='update_weights_strat_wilson'>Helper Function for the Estimation of Weights for <code>prop_strat_wilson</code></h2><span id='topic+update_weights_strat_wilson'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This function wraps the iteration procedure that allows you to estimate
the weights for each proportional strata. This assumes to minimize the
weighted squared length of the confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_weights_strat_wilson(
  vars,
  strata_qnorm,
  initial_weights,
  n_per_strata,
  max_iterations = 50,
  conf_level = 0.95,
  tol = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_weights_strat_wilson_+3A_vars">vars</code></td>
<td>
<p>(<code>numeric</code>)<br /> normalized proportions for each strata.</p>
</td></tr>
<tr><td><code id="update_weights_strat_wilson_+3A_strata_qnorm">strata_qnorm</code></td>
<td>
<p>(<code>numeric</code>)<br /> initial estimation with identical weights of the quantiles.</p>
</td></tr>
<tr><td><code id="update_weights_strat_wilson_+3A_initial_weights">initial_weights</code></td>
<td>
<p>(<code>numeric</code>)<br /> initial weights used to calculate <code>strata_qnorm</code>. This can
be optimized in the future if we need to estimate better initial weights.</p>
</td></tr>
<tr><td><code id="update_weights_strat_wilson_+3A_n_per_strata">n_per_strata</code></td>
<td>
<p>(<code>numeric</code>)<br /> number of elements in each strata.</p>
</td></tr>
<tr><td><code id="update_weights_strat_wilson_+3A_max_iterations">max_iterations</code></td>
<td>
<p>(<code>count</code>)<br /> maximum number of iterations to be tried. Convergence is always checked.</p>
</td></tr>
<tr><td><code id="update_weights_strat_wilson_+3A_conf_level">conf_level</code></td>
<td>
<p>(<code>proportion</code>)<br /> confidence level of the interval.</p>
</td></tr>
<tr><td><code id="update_weights_strat_wilson_+3A_tol">tol</code></td>
<td>
<p>(<code>number</code>)<br /> tolerance threshold for convergence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of 3 elements: <code>n_it</code>, <code>weights</code>, and <code>diff_v</code>.
</p>


<h3>See Also</h3>

<p>For references and details see <code><a href="#topic+prop_strat_wilson">prop_strat_wilson()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vs &lt;- c(0.011, 0.013, 0.012, 0.014, 0.017, 0.018)
sq &lt;- 0.674
ws &lt;- rep(1 / length(vs), length(vs))
ns &lt;- c(22, 18, 17, 17, 14, 12)

update_weights_strat_wilson(vs, sq, ws, ns, 100, 0.95, 0.001)

</code></pre>

<hr>
<h2 id='utils_split_funs'>Custom Split Functions</h2><span id='topic+utils_split_funs'></span><span id='topic+ref_group_position'></span><span id='topic+level_order'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Collection of useful functions that are expanding on the core list of functions
provided by <code>rtables</code>. See <a href="rtables.html#topic+custom_split_funs">rtables::custom_split_funs</a> and <code><a href="rtables.html#topic+make_split_fun">rtables::make_split_fun()</a></code>
for more information on how to make a custom split function. All these functions
work with <code><a href="rtables.html#topic+split_rows_by">split_rows_by()</a></code> argument <code>split_fun</code> to modify the way the split
happens. For other split functions, consider consulting <code><a href="rtables.html#topic+split_funcs">rtables::split_funcs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref_group_position(position = "first")

level_order(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_split_funs_+3A_position">position</code></td>
<td>
<p>(<code>string</code> or <code>integer</code>)<br /> should it be <code>"first"</code> or <code>"last"</code> or in a specific position?</p>
</td></tr>
<tr><td><code id="utils_split_funs_+3A_order">order</code></td>
<td>
<p>(<code>character</code> or <code>integer</code>)<br /> vector of ordering indexes for the split facets.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>ref_group_position</code> returns an utility function that puts the reference group
as first, last or at a certain position and needs to be assigned to <code>split_fun</code>.
</p>
</li></ul>


<ul>
<li> <p><code>level_order</code> returns an utility function that changes the original levels' order,
depending on input <code>order</code> and split levels.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>ref_group_position()</code>: split function to place reference group facet at a specific position
during post-processing stage.
</p>
</li>
<li> <p><code>level_order()</code>: split function to change level order based on a <code>integer</code>
vector or a <code>character</code> vector that represent the split variable's factor levels.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="rtables.html#topic+make_split_fun">rtables::make_split_fun()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

dat &lt;- data.frame(
  x = factor(letters[1:5], levels = letters[5:1]),
  y = 1:5
)

# With rtables layout functions
basic_table() %&gt;%
  split_cols_by("x", ref_group = "c", split_fun = ref_group_position("last")) %&gt;%
  analyze("y") %&gt;%
  build_table(dat)

# With tern layout funcitons
adtte_f &lt;- tern_ex_adtte %&gt;%
  filter(PARAMCD == "OS") %&gt;%
  mutate(
    AVAL = day2month(AVAL),
    is_event = CNSR == 0
  )

basic_table() %&gt;%
  split_cols_by(var = "ARMCD", ref_group = "ARM B", split_fun = ref_group_position("first")) %&gt;%
  add_colcounts() %&gt;%
  surv_time(
    vars = "AVAL",
    var_labels = "Survival Time (Months)",
    is_event = "is_event",
  ) %&gt;%
  build_table(df = adtte_f)

basic_table() %&gt;%
  split_cols_by(var = "ARMCD", ref_group = "ARM B", split_fun = ref_group_position(2)) %&gt;%
  add_colcounts() %&gt;%
  surv_time(
    vars = "AVAL",
    var_labels = "Survival Time (Months)",
    is_event = "is_event",
  ) %&gt;%
  build_table(df = adtte_f)

# level_order --------
# Even if default would bring ref_group first, the original order puts it last
basic_table() %&gt;%
  split_cols_by("Species", split_fun = level_order(c(1, 3, 2))) %&gt;%
  analyze("Sepal.Length") %&gt;%
  build_table(iris)

# character vector
new_order &lt;- level_order(levels(iris$Species)[c(1, 3, 2)])
basic_table() %&gt;%
  split_cols_by("Species", ref_group = "virginica", split_fun = new_order) %&gt;%
  analyze("Sepal.Length") %&gt;%
  build_table(iris)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
