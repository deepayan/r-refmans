<!DOCTYPE html><html><head><title>Help for package baseline</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {baseline}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#baseline-package'>
<p>Baseline correction</p></a></li>
<li><a href='#algorithm'>
<p>Extraction methods for &quot;baselineAlgTest&quot; objects</p></a></li>
<li><a href='#baseline'><p> Baseline correction</p></a></li>
<li><a href='#baseline-class'><p>Class &quot;baseline&quot;</p></a></li>
<li><a href='#baseline.als'><p> Asymmetric Least Squares</p></a></li>
<li><a href='#baseline.fillPeaks'><p> Fill peaks</p></a></li>
<li><a href='#baseline.irls'><p> Iterative Restricted Least Squares</p></a></li>
<li><a href='#baseline.lowpass'><p> Low-pass FFT filter</p></a></li>
<li><a href='#baseline.medianWindow'><p> Median window</p></a></li>
<li><a href='#baseline.modpolyfit'><p> Modified polynomial fitting</p></a></li>
<li><a href='#baseline.peakDetection'><p> Simultaneous Peak Detection and Baseline Correction</p></a></li>
<li><a href='#baseline.rfbaseline'><p> Robust Baseline Estimation</p></a></li>
<li><a href='#baseline.rollingBall'><p> Rolling ball</p></a></li>
<li><a href='#baseline.shirley'><p>Shirley Background Estimation</p></a></li>
<li><a href='#baseline.TAP'><p> TAP</p></a></li>
<li><a href='#baselineAlg-class'><p>Class &quot;baselineAlg&quot;</p></a></li>
<li><a href='#baselineAlgorithms'>
<p>List of available baseline algorithms</p></a></li>
<li><a href='#baselineAlgorithmsGUI'>
<p>List of available baseline algorithms for GUI function</p></a></li>
<li><a href='#baselineAlgResult-class'><p>Class &quot;baselineAlgResult&quot;</p></a></li>
<li><a href='#baselineAlgTest-class'><p>Class &quot;baselineAlgTest&quot;</p></a></li>
<li><a href='#baselineEnv'><p> Baseline environment</p></a></li>
<li><a href='#baselineGUI'><p> Interactive plotting tool</p></a></li>
<li><a href='#custom.baseline'>
<p>Customized baseline correction</p></a></li>
<li><a href='#doOptim'>
<p>Optimise several baseline algorithms on a data set</p></a></li>
<li><a href='#funcName'>
<p>Extract the &quot;funcName&quot; slot.</p></a></li>
<li><a href='#getBaseline'>
<p>Functions to extract the components of a &quot;baseline&quot; object</p></a></li>
<li><a href='#ind.min'><p>Extraction methods specific for &quot;predictionResult&quot; objects</p></a></li>
<li><a href='#milk'><p> MALDI-TOF mass spectra</p></a></li>
<li><a href='#name'><p>Extraction methods for &quot;baselineAlg&quot; objects</p></a></li>
<li><a href='#optimWizard'><p> Visual tool for setting up optimization</p></a></li>
<li><a href='#overall.min'>
<p>Extract the minimum from a baseline optimisation</p></a></li>
<li><a href='#param'><p>Extract the &quot;param&quot; slot</p></a></li>
<li><a href='#param.ind.min'>
<p>Extraction methods for &quot;baselineAlgResult&quot; objects</p></a></li>
<li><a href='#plotBaseline'>
<p>Plot method for &quot;baseline&quot; objects</p></a></li>
<li><a href='#plotOptim'><p> Plotting tool for result objects from optimization</p></a></li>
<li><a href='#PLSRTest-class'><p>Class &quot;PLSRTest&quot;</p></a></li>
<li><a href='#predictionResult-class'><p>Class &quot;predictionResult&quot;</p></a></li>
<li><a href='#predictionTest-class'><p>Class &quot;predictionTest&quot;</p></a></li>
<li><a href='#qualMeas'><p>Extraction functions for &quot;predictionResult&quot; or &quot;baselineAlgResult&quot;</p>
objects</a></li>
<li><a href='#ridgeRegressionTest-class'><p>Class &quot;ridgeRegressionTest&quot;</p></a></li>
<li><a href='#runTest'><p>Run a predictionTest or baselineAlgTest</p></a></li>
<li><a href='#XPSdata'><p> XPS core line data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Baseline Correction of Spectra</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-18</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kristian Hovde Liland &lt;kristian.liland@nmbu.no&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of baseline correction algorithms, along with a framework and a Tcl/Tk enabled GUI for optimising baseline algorithm parameters. Typical use of the package is for removing background effects from spectra originating from various types of spectroscopy and spectrometry, possibly optimizing this with regard to regression or classification results. Correction methods include polynomial fitting, weighted local smoothers and many more.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, SparseM, grDevices, stats, methods, limSolve</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gWidgets2, gWidgets2tcltk, IDPmisc, lattice, pls, MASS</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/khliland/baseline/">https://github.com/khliland/baseline/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/khliland/baseline/issues/">https://github.com/khliland/baseline/issues/</a></td>
</tr>
<tr>
<td>ZipData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-18 11:16:05 UTC; kristian</td>
</tr>
<tr>
<td>Author:</td>
<td>Kristian Hovde Liland
    <a href="https://orcid.org/0000-0001-6468-9423"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Bjørn-Helge Mevik [aut],
  Roberto Canteri [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-18 11:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='baseline-package'>
Baseline correction
</h2><span id='topic+baseline-package'></span>

<h3>Description</h3>

<p>A common framework with implementations of several baseline correction methods
</p>


<h3>Details</h3>

<p>Use function baseline for baseline correction. This function takes matrices of
spectra, a method name and parameters needed for the specific method. See
helpfiles for details.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland and Bjørn-Helge Mevik
</p>
<p>Maintainer: Kristian Hovde Liland &lt;kristian.liland@nmbu.no&gt;
</p>


<h3>References</h3>

<p>Andreas F. Ruckstuhl, Matthew P. Jacobson, Robert W. Field,
James A. Dodd:
Baseline subtraction using robust local regression estimation;
CHAD A. LIEBER and ANITA MAHADEVAN-JANSEN:
Automated Method for Subtraction of Fluorescence from
Biological Raman Spectra;
Mark S. Friedrichs:
A model-free algorithm for the removal of baseline artifacts;
AHMET K. ATAKAN, W. E. BLASS, and D. E. JENNINGS:
Elimination of Baseline Variations from a Recorded Spectrum
by Ultra-low Frequency Filtering;
M.A. Kneen, H.J. Annegarn:
Algorithm for fitting XRF, SEM and PIXE X-ray spectra backgrounds;
K.H. Liland, B.-H. Mevik, E.-O. Rukke, T.
Almøy, M. Skaugen and T. Isaksson (2009)
Quantitative whole spectrum analysis with MALDI-TOF MS, Part I:
Measurement optimisation.
<em>Chemometrics and Intelligent Laboratory Systems</em>, <b>96</b>(2),
210&ndash;218.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(milk)
# The baseline() function is an S4 wrapper for all the different 
# baseline correction methods. The default correction method
# is IRLS. Data must be organized as row vectors in a matrix
# or data.frame.
bc.irls &lt;- baseline(milk$spectra[1,, drop=FALSE])
## Not run: 
  # Computationally heavy
	plot(bc.irls)

## End(Not run)

# Available extractors are:
# getBaseline(bc.irls)
# getSpectra(bc.irls)
# getCorrected(bc.irls)
# getCall(bc.irls)

# Correction methods and parameters can be specified through the wrapper.
bc.fillPeaks &lt;- baseline(milk$spectra[1,, drop=FALSE], lambda=6,
	hwi=50, it=10, int=2000, method='fillPeaks')
## Not run: 
  # Computationally heavy
	plot(bc.fillPeaks)

## End(Not run)

# If a suitable gWidgets2 implementation is installed, a 
# graphical user interface is available for interactive
# parameter adaption.
## Not run: 
  # Dependent on external software
  baselineGUI(milk$spectra)

## End(Not run)
</code></pre>

<hr>
<h2 id='algorithm'>
Extraction methods for &quot;baselineAlgTest&quot; objects
</h2><span id='topic+algorithm'></span><span id='topic+algorithm-methods'></span><span id='topic+algorithm+2CbaselineAlgTest-method'></span><span id='topic+extraArgs'></span><span id='topic+extraArgs-methods'></span><span id='topic+extraArgs+2CbaselineAlgTest-method'></span>

<h3>Description</h3>

<p>Extraction methods specifically for objects of class <code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>algorithm(object)
extraArgs(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="algorithm_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding slot
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p><code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code>
</p>

<hr>
<h2 id='baseline'> Baseline correction </h2><span id='topic+baseline'></span>

<h3>Description</h3>

<p>Common framework for baseline correction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline(spectra, method = "irls", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline_+3A_spectra">spectra</code></td>
<td>
<p> Matrix with spectra in rows </p>
</td></tr>
<tr><td><code id="baseline_+3A_method">method</code></td>
<td>
<p> Baseline correction method </p>
</td></tr>
<tr><td><code id="baseline_+3A_...">...</code></td>
<td>
<p> Additional parameters, sent to the method </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates baselines for the <code>spectra</code>, using the algorithm named
in <code>method</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+baseline-class">baseline</a></code>.
</p>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>References</h3>

<p>Kristian Hovde Liland, Trygve Almøy, Bjørn-Helge Mevik (2010), 
Optimal Choice of Baseline Correction for Multivariate Calibration of Spectra, 
Applied Spectroscopy 64, pp. 1007-1016.
</p>


<h3>See Also</h3>

<p>The functions implementing the baseline algorithms:
<code><a href="#topic+baseline.als">baseline.als</a></code>, <code><a href="#topic+baseline.fillPeaks">baseline.fillPeaks</a></code>,
<code><a href="#topic+baseline.irls">baseline.irls</a></code>, <code><a href="#topic+baseline.lowpass">baseline.lowpass</a></code>,
<code><a href="#topic+baseline.medianWindow">baseline.medianWindow</a></code>,
<code><a href="#topic+baseline.modpolyfit">baseline.modpolyfit</a></code>,
<code><a href="#topic+baseline.peakDetection">baseline.peakDetection</a></code>,
<code><a href="#topic+baseline.rfbaseline">baseline.rfbaseline</a></code>, <code><a href="#topic+baseline.rollingBall">baseline.rollingBall</a></code>,
<code><a href="#topic+baseline.shirley">baseline.shirley</a></code>,  <code><a href="#topic+baseline.TAP">baseline.TAP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(milk)
# The baseline() function is an S4 wrapper for all the different 
# baseline correction methods. The default correction method
# is IRLS. Data must be organized as row vectors in a matrix
# or data.frame.
bc.irls &lt;- baseline(milk$spectra[1,, drop=FALSE])
## Not run: 
  # Computationally heavy
	plot(bc.irls)

## End(Not run)

# Available extractors are:
# getBaseline(bc.irls)
# getSpectra(bc.irls)
# getCorrected(bc.irls)
# getCall(bc.irls)

# Correction methods and parameters can be specified through the wrapper.
bc.fillPeaks &lt;- baseline(milk$spectra[1,, drop=FALSE], lambda=6,
	hwi=50, it=10, int=2000, method='fillPeaks')
## Not run: 
  # Computationally heavy
	plot(bc.fillPeaks)

## End(Not run)

# If a suitable gWidgets2 implementation is installed, a 
# graphical user interface is available for interactive
# parameter adaption.
## Not run: 
  # Dependent on external software
  baselineGUI(milk$spectra)

## End(Not run)
</code></pre>

<hr>
<h2 id='baseline-class'>Class &quot;baseline&quot;</h2><span id='topic+baseline-class'></span><span id='topic+getBaseline+2Cbaseline-method'></span><span id='topic+getCall+2Cbaseline-method'></span><span id='topic+getCorrected+2Cbaseline-method'></span><span id='topic+getSpectra+2Cbaseline-method'></span>

<h3>Description</h3>

<p>Stores the result of estimating baselines for one or more spectra.</p>


<h3>Objects from the Class</h3>

<p>The normal way to create objects is with the function
<code><a href="#topic+baseline">baseline</a></code>.  Several baseline algorithms are available.  See
<code><a href="#topic+baseline">baseline</a></code> for details.  There is a plot method for the
class; see <code><a href="#topic+plot+2Cbaseline-method">plot,baseline-method</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>baseline</code>:</dt><dd><p>A matrix with the estimated baselines</p>
</dd>
<dt><code>corrected</code>:</dt><dd><p>A matrix with the corrected spectra</p>
</dd>
<dt><code>spectra</code>:</dt><dd><p>A matrix with the original spectra</p>
</dd>
<dt><code>call</code>:</dt><dd><p>The call to <code><a href="#topic+baseline">baseline</a></code></p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getBaseline</dt><dd><p><code>signature(object = "baseline")</code>: Extract
the estimated baselines</p>
</dd>
<dt>getCall</dt><dd><p><code>signature(object = "baseline")</code>: Extract the
call to <code><a href="#topic+baseline">baseline</a></code> used to create the object</p>
</dd>
<dt>getCorrected</dt><dd><p><code>signature(object = "baseline")</code>: Extract
the corrected spectra</p>
</dd>
<dt>getSpectra</dt><dd><p><code>signature(object = "baseline")</code>: Extract the
original spectra</p>
</dd>
</dl>



<h3>Warning</h3>

<p>In a future versoion, one of the slots might be
removed from the class definition and calculated on the fly instead,
in order to save space.  Therefore, <em>do</em> use the extractor
functions (<code>getSpectra</code>, <code>getBaseline</code> and
<code>getCorrected</code>) instead of accessing the slots directly.</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p><code><a href="#topic+baseline">baseline</a></code>, <code><a href="#topic+getBaseline">getBaseline</a></code>,
<code><a href="#topic+getSpectra">getSpectra</a></code>, <code><a href="#topic+getCorrected">getCorrected</a></code>,
<code><a href="#topic+getCall">getCall</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("baseline")
</code></pre>

<hr>
<h2 id='baseline.als'> Asymmetric Least Squares </h2><span id='topic+baseline.als'></span><span id='topic+als'></span>

<h3>Description</h3>

<p>Baseline correction by 2nd derivative constrained weighted regression.
Original algorithm proposed by Paul H. C. Eilers and Hans F.M. Boelens
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline.als(spectra, lambda = 6, p = 0.05, maxit = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline.als_+3A_spectra">spectra</code></td>
<td>
<p> Matrix with spectra in rows </p>
</td></tr>
<tr><td><code id="baseline.als_+3A_lambda">lambda</code></td>
<td>
<p> 2nd derivative constraint </p>
</td></tr>
<tr><td><code id="baseline.als_+3A_p">p</code></td>
<td>
<p> Weighting of positive residuals </p>
</td></tr>
<tr><td><code id="baseline.als_+3A_maxit">maxit</code></td>
<td>
<p> Maximum number of iterations </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iterative algorithm applying 2nd derivative constraints. Weights from previous
iteration is <code>p</code> for positive residuals and <code>1-p</code> for negative residuals.
</p>


<h3>Value</h3>

<table>
<tr><td><code>baseline</code></td>
<td>
<p>Matrix of baselines corresponding to spectra <code>spectra</code></p>
</td></tr>
<tr><td><code>corrected</code></td>
<td>
<p>Matrix of baseline corrected spectra</p>
</td></tr>
<tr><td><code>wgts</code></td>
<td>
<p>Matrix of final regression weights</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>References</h3>

<p> Paul H. C. Eilers and Hans F.M. Boelens:
Baseline Correction with Asymmetric Least Squares Smoothing  </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
bc.als &lt;- baseline(milk$spectra[1,, drop=FALSE], lambda=10, method='als')
## Not run: 
plot(bc.als)

## End(Not run)
</code></pre>

<hr>
<h2 id='baseline.fillPeaks'> Fill peaks </h2><span id='topic+baseline.fillPeaks'></span><span id='topic+fillPeaks'></span>

<h3>Description</h3>

<p>An iterative algorithm using suppression of baseline by means in local windows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline.fillPeaks(spectra, lambda, hwi, it, int)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline.fillPeaks_+3A_spectra">spectra</code></td>
<td>
<p> Matrix with spectra in rows </p>
</td></tr>
<tr><td><code id="baseline.fillPeaks_+3A_lambda">lambda</code></td>
<td>
<p> 2nd derivative penalty for primary smoothing</p>
</td></tr>
<tr><td><code id="baseline.fillPeaks_+3A_hwi">hwi</code></td>
<td>
<p> Half width of local windows </p>
</td></tr>
<tr><td><code id="baseline.fillPeaks_+3A_it">it</code></td>
<td>
<p> Number of iterations in suppression loop </p>
</td></tr>
<tr><td><code id="baseline.fillPeaks_+3A_int">int</code></td>
<td>
<p> Number of buckets to divide spectra into </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In local windows of buckets the minimum of the mean and the previous iteration
is chosen as the new baseline
</p>


<h3>Value</h3>

<table>
<tr><td><code>baseline</code></td>
<td>
<p>Matrix of baselines corresponding to spectra <code>spectra</code></p>
</td></tr>
<tr><td><code>corrected</code></td>
<td>
<p>Matrix of baseline corrected spectra</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>References</h3>

<p>Kristian Hovde Liland, 4S Peak Filling - baseline estimation by iterative
mean suppression, MethodsX 2015</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
bc.fillPeaks &lt;- baseline(milk$spectra[1,, drop=FALSE], lambda=6,
	hwi=50, it=10, int=2000, method='fillPeaks')
## Not run: 
	plot(bc.fillPeaks)

## End(Not run)
</code></pre>

<hr>
<h2 id='baseline.irls'> Iterative Restricted Least Squares </h2><span id='topic+baseline.irls'></span><span id='topic+irls'></span>

<h3>Description</h3>

<p>An algorithm with primary smoothing and repeated baseline suppressions and
regressions with 2nd derivative constraint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline.irls(spectra, lambda1 = 5, lambda2 = 9, maxit = 200, wi = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline.irls_+3A_spectra">spectra</code></td>
<td>
<p> Matrix with spectra in rows </p>
</td></tr>
<tr><td><code id="baseline.irls_+3A_lambda1">lambda1</code></td>
<td>
<p> 2nd derivative constraint for primary smoothing</p>
</td></tr>
<tr><td><code id="baseline.irls_+3A_lambda2">lambda2</code></td>
<td>
<p> 2nd derivative constraint for secondary smoothing</p>
</td></tr>
<tr><td><code id="baseline.irls_+3A_maxit">maxit</code></td>
<td>
<p> Maximum number of iterations </p>
</td></tr>
<tr><td><code id="baseline.irls_+3A_wi">wi</code></td>
<td>
<p> Weighting of positive residuals </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>baseline</code></td>
<td>
<p>Matrix of baselines corresponding to spectra <code>spectra</code></p>
</td></tr>
<tr><td><code>corrected</code></td>
<td>
<p>Matrix of baseline corrected spectra</p>
</td></tr>
<tr><td><code>smoothed</code></td>
<td>
<p>Matrix of primary smoothed spectra</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
bc.irls &lt;- baseline(milk$spectra[1,, drop=FALSE], method='irls')
## Not run: 
	plot(bc.irls)

## End(Not run)
</code></pre>

<hr>
<h2 id='baseline.lowpass'> Low-pass FFT filter </h2><span id='topic+baseline.lowpass'></span><span id='topic+lowpass'></span>

<h3>Description</h3>

<p>An algorithm for removing baselines based on Fast Fourier Transform filtering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline.lowpass(spectra, steep = 2, half = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline.lowpass_+3A_spectra">spectra</code></td>
<td>
<p> Matrix with spectra in rows </p>
</td></tr>
<tr><td><code id="baseline.lowpass_+3A_steep">steep</code></td>
<td>
<p> Steepness of filter curve </p>
</td></tr>
<tr><td><code id="baseline.lowpass_+3A_half">half</code></td>
<td>
<p> Half-way point of filter curve </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the scale of the spectra will be different after filtering, baselines
will not be returned by the algorithm
</p>


<h3>Value</h3>

<table>
<tr><td><code>baseline</code></td>
<td>
<p>Matrix of baselines corresponding to spectra <code>spectra</code></p>
</td></tr>
<tr><td><code>corrected</code></td>
<td>
<p>Matrix of baseline corrected spectra</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>References</h3>

<p> AHMET K. ATAKAN, W. E. BLASS, and D. E. JENNINGS:
Elimination of Baseline Variations from a Recorded Spectrum
by Ultra-low Frequency Filtering </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
bc.lowpass &lt;- baseline(milk$spectra[1,, drop=FALSE], method='lowpass')
## Not run: 
	plot(bc.lowpass)

## End(Not run)
</code></pre>

<hr>
<h2 id='baseline.medianWindow'> Median window </h2><span id='topic+baseline.medianWindow'></span><span id='topic+medianWindow'></span>

<h3>Description</h3>

<p>An implementation and extention of Mark S. Friedrichs' model-free algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline.medianWindow(spectra, hwm, hws, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline.medianWindow_+3A_spectra">spectra</code></td>
<td>
<p> Matrix with spectra in rows </p>
</td></tr>
<tr><td><code id="baseline.medianWindow_+3A_hwm">hwm</code></td>
<td>
<p> Window half width for local medians </p>
</td></tr>
<tr><td><code id="baseline.medianWindow_+3A_hws">hws</code></td>
<td>
<p> Window half width for local smoothing (optional) </p>
</td></tr>
<tr><td><code id="baseline.medianWindow_+3A_end">end</code></td>
<td>
<p> Original endpoint handling (optional boolean) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>An algorithm finding medians in local windows and smoothing with gaussian
weighting
</p>


<h3>Value</h3>

<table>
<tr><td><code>baseline</code></td>
<td>
<p>Matrix of baselines corresponding to spectra <code>spectra</code></p>
</td></tr>
<tr><td><code>corrected</code></td>
<td>
<p>Matrix of baseline corrected spectra</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>References</h3>

<p> Mark S. Friedrichs:
A model-free algorithm for the removal of baseline artifacts </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
bc.medianWindow &lt;- baseline(milk$spectra[1,, drop=FALSE], hwm=300,
	method='medianWindow')
## Not run: 
	plot(bc.medianWindow)

## End(Not run)
</code></pre>

<hr>
<h2 id='baseline.modpolyfit'> Modified polynomial fitting </h2><span id='topic+baseline.modpolyfit'></span><span id='topic+modpolyfit'></span>

<h3>Description</h3>

<p>An implementation of CHAD A. LIEBER and ANITA MAHADEVAN-JANSENs algorithm
for polynomial fiting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline.modpolyfit(spectra, t, degree = 4, tol = 0.001, rep = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline.modpolyfit_+3A_spectra">spectra</code></td>
<td>
<p> Matrix with spectra in rows </p>
</td></tr>
<tr><td><code id="baseline.modpolyfit_+3A_t">t</code></td>
<td>
<p> Optional vector of spectrum abcissa </p>
</td></tr>
<tr><td><code id="baseline.modpolyfit_+3A_degree">degree</code></td>
<td>
<p> Degree of polynomial </p>
</td></tr>
<tr><td><code id="baseline.modpolyfit_+3A_tol">tol</code></td>
<td>
<p> Tolerance of difference between iterations </p>
</td></tr>
<tr><td><code id="baseline.modpolyfit_+3A_rep">rep</code></td>
<td>
<p> Maximum number of iterations </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Polynomial fitting with baseline suppression relative to original spectrum
</p>


<h3>Value</h3>

<table>
<tr><td><code>baseline</code></td>
<td>
<p>Matrix of baselines corresponding to spectra <code>spectra</code></p>
</td></tr>
<tr><td><code>corrected</code></td>
<td>
<p>Matrix of baseline corrected spectra</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>References</h3>

<p> CHAD A. LIEBER and ANITA MAHADEVAN-JANSEN:
Automated Method for Subtraction of Fluorescence from
Biological Raman Spectra </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
bc.modpolyfit &lt;- baseline(milk$spectra[1,, drop=FALSE], method='modpolyfit', deg=6)
## Not run: 
	plot(bc.modpolyfit)

## End(Not run)
</code></pre>

<hr>
<h2 id='baseline.peakDetection'> Simultaneous Peak Detection and Baseline Correction </h2><span id='topic+baseline.peakDetection'></span><span id='topic+peakDetection'></span>

<h3>Description</h3>

<p>A translation from Kevin R. Coombes et al.'s MATLAB code for detecting peaks and removing baselines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline.peakDetection(spectra, left, right, lwin, rwin, snminimum,
mono=0, multiplier=5, left.right, lwin.rwin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline.peakDetection_+3A_spectra">spectra</code></td>
<td>
<p> Matrix with spectra in rows </p>
</td></tr>
<tr><td><code id="baseline.peakDetection_+3A_left">left</code></td>
<td>
<p> Smallest window size for peak widths </p>
</td></tr>
<tr><td><code id="baseline.peakDetection_+3A_right">right</code></td>
<td>
<p> Largest window size for peak widths </p>
</td></tr>
<tr><td><code id="baseline.peakDetection_+3A_lwin">lwin</code></td>
<td>
<p> Smallest window size for minimums and medians in peak removed spectra </p>
</td></tr>
<tr><td><code id="baseline.peakDetection_+3A_rwin">rwin</code></td>
<td>
<p> Largest window size for minimums and medians in peak removed spectra </p>
</td></tr>
<tr><td><code id="baseline.peakDetection_+3A_snminimum">snminimum</code></td>
<td>
<p> Minimum signal to noise ratio for accepting peaks </p>
</td></tr>
<tr><td><code id="baseline.peakDetection_+3A_mono">mono</code></td>
<td>
<p> Monotonically decreasing baseline if <code>mono</code>&gt;0 </p>
</td></tr>
<tr><td><code id="baseline.peakDetection_+3A_multiplier">multiplier</code></td>
<td>
<p> Internal window size multiplier </p>
</td></tr>
<tr><td><code id="baseline.peakDetection_+3A_left.right">left.right</code></td>
<td>
<p> Sets eflt and right to value of <code>left.right</code> </p>
</td></tr>
<tr><td><code id="baseline.peakDetection_+3A_lwin.rwin">lwin.rwin</code></td>
<td>
<p> Sets lwin and rwin to value of <code>lwin.rwin</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Peak detection is done in several steps sorting out real peaks through different criteria.
Peaks are removed from spectra and minimums and medians are used to smooth the remaining parts of the spectra.
If <code>snminimum</code> is omitted, y3, midspec, y and y2 are not returned (faster)
</p>


<h3>Value</h3>

<table>
<tr><td><code>baseline</code></td>
<td>
<p>Matrix of baselines corresponding to spectra <code>spectra</code></p>
</td></tr>
<tr><td><code>corrected</code></td>
<td>
<p>Matrix of baseline corrected spectra</p>
</td></tr>
<tr><td><code>peaks</code></td>
<td>
<p>Final list of selected peaks</p>
</td></tr>
<tr><td><code>sn</code></td>
<td>
<p>List signal to noise ratios for peaks</p>
</td></tr>
<tr><td><code>y3</code></td>
<td>
<p>List of peaks prior to singal to noise selection</p>
</td></tr>
<tr><td><code>midspec</code></td>
<td>
<p>Mid-way baseline estimation</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>First estimate of peaks</p>
</td></tr>
<tr><td><code>y2</code></td>
<td>
<p>Second estimate of peaks</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>References</h3>

<p> KEVIN R. COOMBES et al.:
Quality control and peak finding for proteomics data collected from nipple aspirate fluid
by surface-enhanced laser desorption and ionization. </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
bc.peakDetection &lt;- baseline(milk$spectra[1,, drop=FALSE], method='peakDetection',
	left=300, right=300, lwin=50, rwin=50)
## Not run: 
	plot(bc.peakDetection)

## End(Not run)
</code></pre>

<hr>
<h2 id='baseline.rfbaseline'> Robust Baseline Estimation </h2><span id='topic+baseline.rfbaseline'></span><span id='topic+rfbaseline'></span>

<h3>Description</h3>

<p>Wrapper for Andreas F. Ruckstuhl, Matthew P. Jacobson, Robert W. Field,
James A. Dodd's algorithm based on LOWESS and weighted regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline.rfbaseline(spectra, span = 2/3, NoXP = NULL, maxit = c(2, 2),
  b = 3.5, weight = NULL, Scale = function(r) median(abs(r))/0.6745,
  delta = NULL, SORT = FALSE, DOT = FALSE, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline.rfbaseline_+3A_spectra">spectra</code></td>
<td>
<p> Matrix with spectra in rows </p>
</td></tr>
<tr><td><code id="baseline.rfbaseline_+3A_span">span</code></td>
<td>
<p> Amount of smoothing (by fraction of points) </p>
</td></tr>
<tr><td><code id="baseline.rfbaseline_+3A_noxp">NoXP</code></td>
<td>
<p> Amount of smoothing (by number of points) </p>
</td></tr>
<tr><td><code id="baseline.rfbaseline_+3A_maxit">maxit</code></td>
<td>
<p> Maximum number of iterations in robust fit </p>
</td></tr>
<tr><td><code id="baseline.rfbaseline_+3A_b">b</code></td>
<td>
<p> Tuning constant in the biweight function </p>
</td></tr>
<tr><td><code id="baseline.rfbaseline_+3A_weight">weight</code></td>
<td>
<p> Optional weights to be given to individual observations </p>
</td></tr>
<tr><td><code id="baseline.rfbaseline_+3A_scale">Scale</code></td>
<td>
<p> S function specifying how to calculate the scale of the residuals </p>
</td></tr>
<tr><td><code id="baseline.rfbaseline_+3A_delta">delta</code></td>
<td>
<p> Nonnegative parameter which may be used to save computation. (See <code>rfbaseline</code> </p>
</td></tr>
<tr><td><code id="baseline.rfbaseline_+3A_sort">SORT</code></td>
<td>
<p>Boolean variable indicating whether x data must be sorted.</p>
</td></tr>
<tr><td><code id="baseline.rfbaseline_+3A_dot">DOT</code></td>
<td>
<p> Disregard outliers totally (boolean) </p>
</td></tr>
<tr><td><code id="baseline.rfbaseline_+3A_init">init</code></td>
<td>
<p> Values of initial fit </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of the code is the original code as given by the authors. The ability to
sort by X-values has been removed and ability to handle multiple spectra
has been added
</p>


<h3>Value</h3>

<table>
<tr><td><code>baseline</code></td>
<td>
<p>Matrix of baselines corresponding to spectra <code>spectra</code></p>
</td></tr>
<tr><td><code>corrected</code></td>
<td>
<p>Matrix of baseline corrected spectra</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>References</h3>

<p> Andreas F. Ruckstuhl, Matthew P. Jacobson, Robert W. Field,
James A. Dodd:
Baseline subtraction using robust local regression estimation </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
bc.rbe &lt;- baseline(milk$spectra[1,, drop=FALSE], method='rfbaseline',
  span=NULL, NoXP=1000)
## Not run: 
	plot(bc.rbe)

## End(Not run)
</code></pre>

<hr>
<h2 id='baseline.rollingBall'> Rolling ball </h2><span id='topic+baseline.rollingBall'></span><span id='topic+rollingBall'></span>

<h3>Description</h3>

<p>Ideas from Rolling Ball algorithm for X-ray spectra by M.A.Kneen and
H.J. Annegarn. Variable window width has been left out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline.rollingBall(spectra, wm, ws)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline.rollingBall_+3A_spectra">spectra</code></td>
<td>
<p> Matrix with spectra in rows </p>
</td></tr>
<tr><td><code id="baseline.rollingBall_+3A_wm">wm</code></td>
<td>
<p> Width of local window for minimization/maximization </p>
</td></tr>
<tr><td><code id="baseline.rollingBall_+3A_ws">ws</code></td>
<td>
<p> Width of local window for smoothing </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>baseline</code></td>
<td>
<p>Matrix of baselines corresponding to spectra <code>spectra</code></p>
</td></tr>
<tr><td><code>corrected</code></td>
<td>
<p>Matrix of baseline corrected spectra</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>References</h3>

<p> M.A. Kneen, H.J. Annegarn:
Algorithm for fitting XRF, SEM and PIXE X-ray spectra backgrounds </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
bc.rollingBall &lt;- baseline(milk$spectra[1,, drop=FALSE], wm=200, ws=200,
	method='rollingBall')
## Not run: 
	plot(bc.rollingBall)

## End(Not run)
</code></pre>

<hr>
<h2 id='baseline.shirley'>Shirley Background Estimation</h2><span id='topic+baseline.shirley'></span><span id='topic+shirley'></span>

<h3>Description</h3>

<p>Shirley Background correction for X-ray Photoelectron Spectroscopy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline.shirley(spectra, t = NULL, limits = NULL, maxit = 50, err = 1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline.shirley_+3A_spectra">spectra</code></td>
<td>
<p>matrix with only 1 y-coordinates by rows (i.e.: y = spectra[1,])</p>
</td></tr>
<tr><td><code id="baseline.shirley_+3A_t">t</code></td>
<td>
<p> Optional vector of spectrum abscissa </p>
</td></tr>
<tr><td><code id="baseline.shirley_+3A_limits">limits</code></td>
<td>
<p>list with the y coordinates between calculation of background. Ususally these are the extreme point of the data range. </p>
</td></tr>
<tr><td><code id="baseline.shirley_+3A_maxit">maxit</code></td>
<td>
<p>max number of iteration</p>
</td></tr>
<tr><td><code id="baseline.shirley_+3A_err">err</code></td>
<td>
<p> Tolerance of difference between iterations </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shape of the spectrum background or baseline is affected by inelastic energy loss processes, secondary electrons and nearby peaks. A reasonable approximation is essential for a qualitative and quantitative analysis of XPS data especially if several components interfere in one spectrum. The choice of an adequate background model is determined by the physical and chemical conditions of the measurements and the significance of the background to the information to be obtained. The subtraction of the baseline before entering the fit iterations or the calculation of the peak area can be an acceptable approximation for simple analytical problems. In order to obtain chemical and physical parameters in detail, however, it is absolutely necessary to include the background function in the iterative peak fit procedure. 
The primary function F(E) results from the experimentally obtained function M(E) and the background function U(E) as 
</p>
<p style="text-align: center;"><code class="reqn">F(E) = M(E)-U(E)</code>
</p>

<p>The kinetic energy E of the spectra can be described as 
</p>
<p style="text-align: center;"><code class="reqn">E = SE + SW * (i-1)</code>
</p>

<p>SE means the start energy in eV, SW is the step width in eV and i the channel number. i can assume values between 1 and N with N as the number of data points. 
</p>
<p>In case of baseline calculation before initiating the fit procedure, the background is set to the averaged experimental function M(E) in a sector around the chosen start and end channels. With <code class="reqn">i{_1}</code> as left channel (<code class="reqn">E{_1}</code>: low energy side) and <code class="reqn">i{_2}</code> as right channel (<code class="reqn">E{_2}</code>: high energy side) the simulation of the baseline is obtained as 
</p>
<p style="text-align: center;"><code class="reqn">U(E_{1})=M(E_{1})</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">U(E_{2})=M(E_{2})</code>
</p>

<p>If ZAP is the number of points used for averaging (can be set in the preferences), the intensity of the averaged measuring function at the low energy side is calculated by 
</p>
<p style="text-align: center;"><code class="reqn">M(i_{1})=\frac{\sum_{i=0}^{ZAP-1}M(i_{1}+i)}{ZAP}</code>
</p>

<p>and at the high energy side by
</p>
<p style="text-align: center;"><code class="reqn">M(i_{2})=\frac{\sum_{i=0}^{ZAP-1}M(i_{2}+i)}{ZAP}</code>
</p>

<p>In many cases the Shirley model turned out to be a successful approximation for the inelastic background of core level peaks of buried species, which suffered significantly from inelastic losses of the emitted photoelectrons. The calculation of the baseline is an iterative procedure. The number of iteration cycles should be chosen high enough so that the shape of the obtained background function does not change anymore. The analytical expression for the Shirley background is 
</p>
<p style="text-align: center;"><code class="reqn">U(E)= \int_{E}^{\infty}F(E')dE'+c</code>
</p>

<p>The algorithm of Proctor and Sherwood ([1] A. Proctor, P.M.A. Sherwood, Anal. Chem. 54 (1982) 13) 
is 
based on the assumption that for every point of the spectrum the background intensity generated by a photoelectron line is proportional to the number of all photoelectrons with higher kinetic energy. The intensity of the background U(i) in channel i is given by 
</p>
<p style="text-align: center;"><code class="reqn">U(i)=\frac{(a-b)Q(i)}{P(i)+Q(i)}+b</code>
</p>

<p>where a and b are the measured intensities in channel <code class="reqn">i{_1}</code> and <code class="reqn">i{_2}</code>, respectively, and P(i) and Q(i) represent the effective peak areas to lower and higher kinetic energies relative to the channel under consideration. An iterative procedure is necessary because P, Q, and U(i) are unknown. In first approximation U(i) = b is used. 
</p>
<p>The function <code>baseline.shirley</code> implements the <code>shirley baseline</code>.  It is an iterative algorithm.
The iteration stops when the deviation between two consequent iteration is
lower than <code>err</code> or when the max number of iterations <code>maxit</code> is
reached. 
</p>


<h3>Value</h3>

<p>The baseline function return an object of class <code>baseline</code>.
</p>


<h3>References</h3>

<p>A. Proctor, P.M.A. Sherwood, Anal. Chem. 54 (1982) 13.
</p>


<h3>See Also</h3>

<p><a href="#topic+baseline">baseline</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("O1s")
Data &lt;- O1s

## The same example with C1s data 
# data("C1s")
# Data &lt;- C1s

Y &lt;- Data[2,, drop = FALSE]
X &lt;- Data[1,]

corrected &lt;- baseline(Y, method = "shirley", t = X)
plot(corrected, rev.x = TRUE, labels = X)

## Not run: 
# Dependent on external software
baselineGUI(Y, labels=X, method="shirley")

## End(Not run)
</code></pre>

<hr>
<h2 id='baseline.TAP'> TAP </h2><span id='topic+baseline.TAP'></span><span id='topic+TAP'></span>

<h3>Description</h3>

<p>An implementation of Roman Svoboda and Jirí Málek's algorithm for baseline identification in kinetic anlaysis of derivative kinetic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline.TAP(spectra, t, interval = 15, tol = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline.TAP_+3A_spectra">spectra</code></td>
<td>
<p> Matrix with spectra in rows </p>
</td></tr>
<tr><td><code id="baseline.TAP_+3A_t">t</code></td>
<td>
<p> Optional vector of spectrum abcissa </p>
</td></tr>
<tr><td><code id="baseline.TAP_+3A_interval">interval</code></td>
<td>
<p> Distance from spectrum end to starting points for the TAP (default = 15) </p>
</td></tr>
<tr><td><code id="baseline.TAP_+3A_tol">tol</code></td>
<td>
<p> Tolerance of difference between iterations (default = 0.001) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>(i) A first approximation of the baseline equation is selected as the straight line between start and end of the curve.
(ii) Based on the first approximation of the baseline equation, the phase change progress parameter is calculated.
(iii) An updated equation of the baseline is calculated and the phase change progress parameter equation from step (ii).
(iv) The baseline equation from step (iii) is compared (point by point) with the one from the previous iteration. If the convergence criterion is met (the difference between every baseline value corresponding to two successive iterations was less than 0.1%) the procedure is stopped and the final baseline equation is selected. If the convergence criterion is not fulfilled then a new iteration is carried out from step (ii) until convergence was achieved.
</p>


<h3>Value</h3>

<table>
<tr><td><code>baseline</code></td>
<td>
<p>Matrix of baselines corresponding to spectra <code>spectra</code></p>
</td></tr>
<tr><td><code>corrected</code></td>
<td>
<p>Matrix of baseline corrected spectra</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland </p>


<h3>References</h3>

<p> Roman Svoboda and Jirí Málek:
Importance of proper baseline identification for the subsequent kinetic analysis of derivative kinetic data, Journal of Thermal Analysis and Calorimetry. </p>


<h3>Examples</h3>

<pre><code class='language-R'># My T
myT &lt;- 40:170

# My artifical curve
myAlpha &lt;- c(seq(0.01, 0.02, length.out=40),
             dnorm(seq(-3,3,length.out=51))/2+(0:50)/2000+0.02)
myAlpha &lt;- c(myAlpha,
             seq(myAlpha[90]-0.001, 0.01, length.out=40))
myAlpha &lt;- myAlpha - min(myAlpha)
myAlpha &lt;- cumsum(dadt &lt;- myAlpha/sum(myAlpha))

# Discrete derivative
mydAlpha &lt;- c(0,diff(myAlpha)); mydAlpha &lt;- matrix(mydAlpha, ncol=length(mydAlpha))
rm(myAlpha) # Throw away myAlpha

# Compute baseline from T and derivative
B &lt;- baseline(mydAlpha, t=myT, method="TAP")

# Plot 
plot(B, xlab = "T", ylab = "da/dT")
</code></pre>

<hr>
<h2 id='baselineAlg-class'>Class &quot;baselineAlg&quot;</h2><span id='topic+baselineAlg-class'></span>

<h3>Description</h3>

<p>A class that describes a baseline correction algorithm.  The idea is
that it contains
all information needed to use an algorithm with the optimisation
framework and the graphical user interface (but see Notes below).
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("baselineAlg", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>Short-name of the algorithm.  This must match
the name of the object in the <code>baselineAlgorithms</code> list of
algorithms, and is used throughout the code to identify the
algorithm.  It should thus start with a letter and contain only
letters, digits, underscores (&quot;_&quot;) or dots (&quot;.&quot;).</p>
</dd>
<dt><code>description</code>:</dt><dd><p>Description of the algorithm, typically
the full name.  This will be used in the code to describe the
algorith, so it should not be too long, and not contain newline characters.</p>
</dd>
<dt><code>funcName</code>:</dt><dd><p>The name of the function used to estimate
the baseline.  The function must take an argument
<code>spectra</code>, and return a list with the estimated baselines
(<code>baseline</code>) original spectra (<code>spectra</code>) and the
corrected spectra (<code>corrected</code>).  It can also take other
arguments (typically parameters) and return additional components
in the list.</p>
</dd>
<dt><code>param</code>:</dt><dd><p>A data frame with information about the
parameters of the algorithm.  It should contain the following
coloumns: <code>name</code> - the name of the parameter; <code>integer</code>
- <code>TRUE</code> if the parameter only takes integer values,
otherwise <code>FALSE</code>; <code>min</code> - the lower limit of allowed values;
<code>incl.min</code> - <code>TRUE</code> if the lower limit is an allowed
value, otherwise <code>FALSE</code>; <code>default</code> - the default value;
<code>max</code> - the upper limit of allowed values; <code>incl.max</code> -
<code>TRUE</code> if the upper limit is an allowed value, otherwise <code>FALSE</code></p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>description</dt><dd><p><code>signature(object = "baselineAlg")</code>: Extract
the <code>description</code> slot</p>
</dd>
<dt>funcName</dt><dd><p><code>signature(object = "baselineAlg")</code>: Extract
the <code>funcName</code> slot </p>
</dd>
<dt>name</dt><dd><p><code>signature(object = "baselineAlg")</code>: Extract
the <code>name</code> slot </p>
</dd>
<dt>param</dt><dd><p><code>signature(object = "baselineAlg")</code>: Extract
the <code>param</code> slot</p>
</dd>
</dl>



<h3>Note</h3>

<p>The goal is that the
optimisation framework and the GUI code should get all information about
available baseline algorithms through a list of <code>baselineAlg</code>
objects.  This will make it relatively simple to add new baseline algorithms.
</p>
<p>Currenly, there is information about the algorithms spread around in the
code.  We plan to move that information into the <code>baselineAlg</code>
objects, and expand the class accordingly.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("baselineAlg")
</code></pre>

<hr>
<h2 id='baselineAlgorithms'>
List of available baseline algorithms
</h2><span id='topic+baselineAlgorithms'></span>

<h3>Description</h3>

<p>A list with descriptions of all baseline algorithms available through
the optimisaiont framework and graphical user interface.  The elements
of the list are <code><a href="#topic+baselineAlg-class">baselineAlg</a></code> objects.  The list is
used by the code to extract names and information about the baseline
algorithms.
</p>


<h3>Details</h3>

<p>The list is not meant for usage by end-users, but is extendable
and customizable, allowing for extra algorithms or removal of algoritms.
</p>
<p>The names of the list must match the <code>name</code> slot of the
elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get a list of all algorithms:
names(baselineAlgorithms)
## Show the descriptions
sapply(baselineAlgorithms, description)
## Add new algorithm
baseline.my.alg &lt;- function(spectra, kappa=1, gamma=1){
   baseline  &lt;- spectra-kappa+gamma
   corrected &lt;- spectra-baseline
   list(baseline=baseline,corrected=corrected)
}

baselineAlgorithms$my.alg = new("baselineAlg",
     name = "my.alg",
     description = "A new baseline correction algorithm",
     funcName = "baseline.my.alg",
     param = data.frame(
        name = c("kappa","gamma"), # maxit
        integer = c(FALSE, FALSE),
        min = c(0, 0),
        incl.min = c(TRUE, TRUE),
        default = c(1, 1),
        max = c(Inf, 1),
        incl.max = c(FALSE, TRUE)
    ))
</code></pre>

<hr>
<h2 id='baselineAlgorithmsGUI'>
List of available baseline algorithms for GUI function
</h2><span id='topic+baselineAlgorithmsGUI'></span>

<h3>Description</h3>

<p>A list with data.frames containing parameters, minimum and maximum
values for GUIs, step lengths for sliders, default values and currently
selected values, plus a short description of each parameter. The list
is used by the GUIs, and is user customizable.
</p>


<h3>Details</h3>

<p>The list is not meant for usage by end-users, but is extendable
and customizable, allowing for extra algorithms, removal of algoritms
or changing of parameter sets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get a list of all algorithms:
names(baselineAlgorithmsGUI)
## Add new algorithm:
baselineAlgorithmsGUI$my.alg &lt;- as.data.frame(matrix(c(0,20,1,1, 0,20,1,1), 2,4, byrow=TRUE))
dimnames(baselineAlgorithmsGUI$my.alg) &lt;- list(par=c("kappa", "gamma"),
	val=c("min","max","step","default"))
baselineAlgorithmsGUI$my.alg$current &lt;- c(1,1)
baselineAlgorithmsGUI$my.alg$name &lt;- c("Subtractive constand", "Additive constant")
</code></pre>

<hr>
<h2 id='baselineAlgResult-class'>Class &quot;baselineAlgResult&quot;</h2><span id='topic+baselineAlgResult-class'></span>

<h3>Description</h3>

<p>A class describing the result of a baseline algorithm test
</p>


<h3>Objects from the Class</h3>

<p>Objects are typically created by running <code>runTest</code> on a
<code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code> object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>param</code>:</dt><dd><p>A named list with the parameter values that
were tested.  This includes both the predictor parameters and the
baseline algorithm parameters.  All combinations of values are tested.</p>
</dd>
<dt><code>qualMeas</code>:</dt><dd><p>A matrix of quality measure values for the
different combinations of parameter values.  Each row corresponds
to one prediction parameter value, and each coloumn to one
combination of baseline parameters.</p>
</dd>
<dt><code>qualMeas.ind.min</code>:</dt><dd><p>The index in <code>qualMeas</code>
of the minimum quality measure value</p>
</dd>
<dt><code>minQualMeas</code>:</dt><dd><p>The minimum quality measure value</p>
</dd>
<dt><code>param.ind.min</code>:</dt><dd><p>A vector of indices into the elemets of
<code>param</code> of the parameter values corresponding to the minimum
quality measure value</p>
</dd>
<dt><code>param.min</code>:</dt><dd><p>A list of the parameter values
corresponding to the minimum quality measure value</p>
</dd>
<dt><code>qualMeasName</code>:</dt><dd><p>The name of the quality measure</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>minQualMeas</dt><dd><p><code>signature(object = "baselineAlgResult")</code>:
Extract the <code>minQualMeas</code> slot </p>
</dd>
<dt>param</dt><dd><p><code>signature(object = "baselineAlgResult")</code>:
Extract the <code>param</code> slot </p>
</dd>
<dt>param.ind.min</dt><dd><p><code>signature(object = "baselineAlgResult")</code>:
Extract the <code>param.ind.min</code> slot </p>
</dd>
<dt>param.min</dt><dd><p><code>signature(object = "baselineAlgResult")</code>:
Extract the <code>param.min</code> slot </p>
</dd>
<dt>qualMeas</dt><dd><p><code>signature(object = "baselineAlgResult")</code>:
Extract the <code>qualMeas</code> slot </p>
</dd>
<dt>qualMeas.ind.min</dt><dd><p><code>signature(object = "baselineAlgResult")</code>:
Extract the <code>qualMeas.ind.min</code> slot </p>
</dd>
<dt>qualMeasName</dt><dd><p><code>signature(object = "baselineAlgResult")</code>:
Extract the <code>qualMeasName</code> slot </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code>, function <code>runTest</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("baselineAlgResult")
</code></pre>

<hr>
<h2 id='baselineAlgTest-class'>Class &quot;baselineAlgTest&quot;</h2><span id='topic+baselineAlgTest-class'></span>

<h3>Description</h3>

<p>A class that describes a baseline algorithm test.  The test is
performed with the function <code>runTest</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("baselineAlgTest", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>algorithm</code>:</dt><dd><p>A <code>"baselineAlg"</code> object.  The
baseline algorithm to test.</p>
</dd>
<dt><code>param</code>:</dt><dd><p>A named list with parameter values to test.
All combinations of parameters are tested.</p>
</dd>
<dt><code>extraArgs</code>:</dt><dd><p>A named list of extra parameters to the
baseline algorithm.  These will be held fixed during the testing.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>algorithm</dt><dd><p><code>signature(object = "baselineAlgTest")</code>:
Extract the <code>algorithm</code> slot </p>
</dd>
<dt>extraArgs</dt><dd><p><code>signature(object = "baselineAlgTest")</code>:
Extract the <code>extraArgs</code> slot ... </p>
</dd>
<dt>funcName</dt><dd><p><code>signature(object = "baselineAlgTest")</code>:
Extract the <code>funcName</code> slot ... </p>
</dd>
<dt>param</dt><dd><p><code>signature(object = "baselineAlgTest")</code>:
Extract the <code>param</code> slot </p>
</dd>
<dt>runTest</dt><dd><p><code>signature(object = "baselineAlgTest")</code>: Run the
test.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+baselineAlg-class">baselineAlg</a></code>,
<code><a href="#topic+baselineAlgResult-class">baselineAlgResult</a></code>.  Function <code>runTest</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("baselineAlgTest")
</code></pre>

<hr>
<h2 id='baselineEnv'> Baseline environment </h2><span id='topic+baselineEnv'></span><span id='topic+putBaselineEnv'></span><span id='topic+getBaselineEnv'></span>

<h3>Description</h3>

<p>Methods to access the baseline environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baselineEnv()
getBaselineEnv(x, mode="any")
putBaselineEnv(x, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baselineEnv_+3A_x">x</code></td>
<td>
<p> Name of object to put/get. </p>
</td></tr>
<tr><td><code id="baselineEnv_+3A_mode">mode</code></td>
<td>
<p> Mode of object to get. </p>
</td></tr>
<tr><td><code id="baselineEnv_+3A_value">value</code></td>
<td>
<p> Object to put. </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getBaseline</code> retrieves an object.
</p>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>See Also</h3>

<p>The functions implementing the baseline algorithms:
<code><a href="#topic+baseline.als">baseline.als</a></code>, <code><a href="#topic+baseline.fillPeaks">baseline.fillPeaks</a></code>,
<code><a href="#topic+baseline.irls">baseline.irls</a></code>, <code><a href="#topic+baseline.lowpass">baseline.lowpass</a></code>,
<code><a href="#topic+baseline.medianWindow">baseline.medianWindow</a></code>,
<code><a href="#topic+baseline.modpolyfit">baseline.modpolyfit</a></code>,
<code><a href="#topic+baseline.peakDetection">baseline.peakDetection</a></code>,
<code><a href="#topic+baseline.rfbaseline">baseline.rfbaseline</a></code>, <code><a href="#topic+baseline.rollingBall">baseline.rollingBall</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>putBaselineEnv('fish', '&lt;==x-&lt;')
getBaselineEnv('fish')
</code></pre>

<hr>
<h2 id='baselineGUI'> Interactive plotting tool </h2><span id='topic+baselineGUI'></span>

<h3>Description</h3>

<p>An interactive plotting tool for dynamic visualization of baselines and their effect
using the gWidgets2 package with GTK+ or Tcl/Tk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baselineGUI(spectra, method='irls', labels, rev.x = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baselineGUI_+3A_spectra">spectra</code></td>
<td>
<p> Matrix with spectra in rows </p>
</td></tr>
<tr><td><code id="baselineGUI_+3A_method">method</code></td>
<td>
<p> Baseline correction method (optional)</p>
</td></tr>
<tr><td><code id="baselineGUI_+3A_labels">labels</code></td>
<td>
<p> Labels for X-axis (optional)</p>
</td></tr>
<tr><td><code id="baselineGUI_+3A_rev.x">rev.x</code></td>
<td>
<p> Reverse X-axis (optional, default=FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates and updates a list containing current baseline and spectrum (baseline.result).
Make sure a gWidget2 implementation is available, e.g gWidgets2RGtk2 or gWidgets2tcltk
and a corresponding backend like GTK+ or Tcl/Tk. The GUI was developed using GTK which
is an external dependency in Windows ans OS X.
</p>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
## Not run: 
# Dependent on external software
baselineGUI(milk$spectra)

## End(Not run)
</code></pre>

<hr>
<h2 id='custom.baseline'>
Customized baseline correction
</h2><span id='topic+custom.baseline'></span>

<h3>Description</h3>

<p>This function rescales spectrum abscissa by use of <code>breaks</code> and
<code>gaps</code> before baseline correction. The effect is that the
chosen baseline correction algorithm and paramters will have varying
effects along the spectra, effectively giving local control of the amount
of rigidity/flexibility of the estimated baseline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom.baseline(spectra, breaks, gaps, trans.win = NULL, just.plot = FALSE, method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom.baseline_+3A_spectra">spectra</code></td>
<td>

<p>Matrix with spectra in rows.
</p>
</td></tr>
<tr><td><code id="custom.baseline_+3A_breaks">breaks</code></td>
<td>

<p>Vector of locations of break points between sections of varying
baseline flexibility (given as abscissa numbers).
</p>
</td></tr>
<tr><td><code id="custom.baseline_+3A_gaps">gaps</code></td>
<td>

<p>Vector giving the abscissa spacing between each instance of
<code>breaks</code> (and endpoints if not specified in <code>breaks</code>).
</p>
</td></tr>
<tr><td><code id="custom.baseline_+3A_trans.win">trans.win</code></td>
<td>

<p>Optional width of transition window around break points used
for smoothing rough breaks by LOWESS (default = NULL).
</p>
</td></tr>
<tr><td><code id="custom.baseline_+3A_just.plot">just.plot</code></td>
<td>

<p>Plot the rescaled spectra instead of applying the customized
baseline correction if <code>just.plot</code>=TRUE (default = FALSE).
</p>
</td></tr>
<tr><td><code id="custom.baseline_+3A_method">method</code></td>
<td>

<p>Baseline correction method to use (class character).
</p>
</td></tr>
<tr><td><code id="custom.baseline_+3A_...">...</code></td>
<td>

<p>Additional named arguments to be passed to the baseline correction method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of the customized baseline correction suggested
by Liland et al. 2011 for local changes in baseline flexibility.
</p>


<h3>Value</h3>

<table>
<tr><td><code>baseline</code></td>
<td>
<p>Estimated custom baselines.</p>
</td></tr>
<tr><td><code>corrected</code></td>
<td>
<p>Spectra corrected by custom baselines.</p>
</td></tr>
<tr><td><code>spectra.scaled</code></td>
<td>
<p>Re-scaled spectra.</p>
</td></tr>
<tr><td><code>baseline.scaled</code></td>
<td>
<p>Estimated baselines of re-scaled spectra.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>References</h3>

<p> Kristian Hovde Liland et al.:
Customized baseline correction
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
spectrum1  &lt;- milk$spectra[1,1:10000,drop=FALSE]
ordinary   &lt;- baseline(spectrum1, method="als", lambda=6, p=0.01)
customized &lt;- custom.baseline(spectrum1, 2900, c(1,20), trans.win=100, 
	just.plot=FALSE, method="als", lambda=6, p=0.01)
## Not run: 
plot(1:10000,spectrum1, type='l')
lines(1:10000,getBaseline(ordinary), lty=2, col=2, lwd=2)
lines(1:10000,customized$baseline, lty=3, col=3, lwd=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='doOptim'>
Optimise several baseline algorithms on a data set
</h2><span id='topic+doOptim'></span><span id='topic+mvrValstats'></span>

<h3>Description</h3>

<p>Tests several baseline algorithms with one predictor for a given data
set.  The baseline algorithms are represented as a list of
<code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code> objects, and the predictor as a
<code><a href="#topic+predictionTest-class">predictionTest</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doOptim(baselineTests, X, y, predictionTest, postproc = NULL,
        tmpfile = "tmp.baseline", verbose = FALSE, cleanTmp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doOptim_+3A_baselinetests">baselineTests</code></td>
<td>
<p>a list of <code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code>
objects.  The baseline algorithms and parameter values to test</p>
</td></tr>
<tr><td><code id="doOptim_+3A_x">X</code></td>
<td>
<p>A matrix.  The spectra to use in the test</p>
</td></tr>
<tr><td><code id="doOptim_+3A_y">y</code></td>
<td>
<p>A vector or matrix.  The response(s) to use in the test</p>
</td></tr>
<tr><td><code id="doOptim_+3A_predictiontest">predictionTest</code></td>
<td>
<p>A <code><a href="#topic+predictionTest-class">predictionTest</a></code> object.  The
predictor and parameter values to use in the test</p>
</td></tr>
<tr><td><code id="doOptim_+3A_postproc">postproc</code></td>
<td>
<p>A function, used to postprocess the baseline corrected
spectra prior to prediction testing.  The function should take a
matrix of spectra as its only argument, and return a matrix of
postprocessed spectra</p>
</td></tr>
<tr><td><code id="doOptim_+3A_tmpfile">tmpfile</code></td>
<td>
<p>The basename of the files used to store intermediate
calculations for checkpointing.  Defaults to <code>"tmp.baseline"</code></p>
</td></tr>
<tr><td><code id="doOptim_+3A_verbose">verbose</code></td>
<td>
<p>Logical, specifying whether the test should print out
progress information.  Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="doOptim_+3A_cleantmp">cleanTmp</code></td>
<td>
<p>Logical, specifying whether the intermediate files should
be deleted when the optimisation has finished.  Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function loops through the baseline algorithm tests in
<code>baselineTests</code>, testing each of them with the given data and
prediction test, and collects the results.  The results of each
baseline algorithm test is saved in a temporary file so that if the
optimisation is interrupted, it can be re-run and will use the
pre-calculated results.  If <code>cleanTmp</code> is <code>TRUE</code>, the temporary
files are deleted when the whole optimisation has finished.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>baselineTests</code></td>
<td>
<p>The <code>baselineTests</code> argument</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>A list with the <code>baselineAlgResult</code> objects
for each baseline test</p>
</td></tr>
<tr><td><code>minQualMeas</code></td>
<td>
<p>The minimum quality measure value</p>
</td></tr>
<tr><td><code>baselineAlg.min</code></td>
<td>
<p>The name of the baseline algorithm giving the
minimum quality measure value</p>
</td></tr>
<tr><td><code>param.min</code></td>
<td>
<p>A list with the parameter values corresponding to the
minimum quality measure value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p><code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code>,<code><a href="#topic+predictionTest-class">predictionTest</a></code>
</p>

<hr>
<h2 id='funcName'>
Extract the &quot;funcName&quot; slot.
</h2><span id='topic+funcName'></span><span id='topic+funcName-methods'></span><span id='topic+funcName+2CbaselineAlg-method'></span><span id='topic+funcName+2CbaselineAlgTest-method'></span>

<h3>Description</h3>

<p>Extract the <code>funcName</code> slot from an object of class
<code><a href="#topic+baselineAlg-class">baselineAlg</a></code> or <code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funcName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funcName_+3A_object">object</code></td>
<td>
<p>An object of class
<code><a href="#topic+baselineAlg-class">baselineAlg</a></code> or <code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>funcName</code> slot of the object.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p><code><a href="#topic+baselineAlg-class">baselineAlg</a></code>, <code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code>
</p>

<hr>
<h2 id='getBaseline'>
Functions to extract the components of a &quot;baseline&quot; object
</h2><span id='topic+getBaseline'></span><span id='topic+getSpectra'></span><span id='topic+getCorrected'></span><span id='topic+getCall'></span>

<h3>Description</h3>

<p>The functions extract the <code>baseline</code>, <code>spectra</code>,
<code>corrected</code> or <code>call</code> slot of a <code><a href="#topic+baseline-class">baseline</a></code>
object; usually the result of a call to <code><a href="#topic+baseline">baseline</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBaseline(object)
getSpectra(object)
getCorrected(object)
getCall(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBaseline_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+baseline-class">baseline</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getCall</code> returns the <code>baseline</code> call used to create the
object.  The other functions return a matrix with the original
spectra, estimated baselines or corrected spectra.
</p>


<h3>Warning</h3>

<p>In a future versoion, one of the slots might be
removed from the class definition and calculated on the fly instead,
in order to save space.  Therefore, <em>do</em> use the extractor
functions (<code>getSpectra</code>, <code>getBaseline</code> and
<code>getCorrected</code>) instead of accessing the slots directly.</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+baseline">baseline</a></code>, the class <code><a href="#topic+baseline-class">baseline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
bl &lt;- baseline(milk$spectra[1:2,])
baseline  &lt;- getBaseline(bl)
spectra   &lt;- getSpectra(bl)
corrected &lt;- getCorrected(bl)
call      &lt;- getCall(bl)
</code></pre>

<hr>
<h2 id='ind.min'>Extraction methods specific for &quot;predictionResult&quot; objects</h2><span id='topic+ind.min'></span><span id='topic+ind.min-methods'></span><span id='topic+ind.min+2CpredictionResult-method'></span><span id='topic+paramName'></span><span id='topic+paramName-methods'></span><span id='topic+paramName+2CpredictionResult-method'></span>

<h3>Description</h3>

<p>Extract information from objects of class
<code><a href="#topic+predictionResult-class">predictionResult</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind.min(object)
paramName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind.min_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+predictionResult-class">predictionResult</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding slot of the object.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictionResult-class">predictionResult</a></code>
</p>

<hr>
<h2 id='milk'> MALDI-TOF mass spectra</h2><span id='topic+milk'></span>

<h3>Description</h3>

<p>Matrix of 45 spectra of 21451 m/z values from MALDI-TOF on mixed milk samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(milk)</code></pre>


<h3>Format</h3>

<p>A data frame with 45 observations on the following 2 variables.
</p>

<dl>
<dt><code>cow</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>spectra</code></dt><dd><p>a matrix with 21451 columns</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>cow</code> is the concentration of cow milk
in mixed samples of cow, goat, and ewe milk.
</p>


<h3>References</h3>

<p>Kristian Hovde Liland, Bjørn-Helge Mevik, Elling-Olav Rukke, Trygve
Almøy, Morten Skaugen and Tomas Isaksson (2009)
Quantitative whole spectrum analysis with MALDI-TOF MS, Part I:
Measurement optimisation.
<em>Chemometrics and Intelligent Laboratory Systems</em>, <b>96</b>(2),
210&ndash;218.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
## Not run: 
plot(milk$spectra[1,], type = "l")

## End(Not run)
</code></pre>

<hr>
<h2 id='name'>Extraction methods for &quot;baselineAlg&quot; objects</h2><span id='topic+name'></span><span id='topic+name-methods'></span><span id='topic+name+2CbaselineAlg-method'></span><span id='topic+description'></span><span id='topic+description-methods'></span><span id='topic+description+2CbaselineAlg-method'></span>

<h3>Description</h3>

<p>Extraction methods specifically for objects of class <code><a href="#topic+baselineAlg-class">baselineAlg</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>name(object)
description(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+baselineAlg-class">baselineAlg</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The methods return the corresponding slot of the object.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p><code><a href="#topic+baselineAlg-class">baselineAlg</a></code>, <code><a href="#topic+funcName">funcName</a></code>.
</p>

<hr>
<h2 id='optimWizard'> Visual tool for setting up optimization </h2><span id='topic+optimWizard'></span><span id='topic+getOptim'></span><span id='topic+getOptimRes'></span>

<h3>Description</h3>

<p>Set up optimization through a graphical user interface. Optionally collecting values directly from 'baselineGUI'.
Retrieve optimisation parameters and results with <code>getOptim</code> and <code>getOptimRes</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimWizard(X, y, postproc, predictionTest, cvsegments)
getOptim()
getOptimRes()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimWizard_+3A_x">X</code></td>
<td>
<p> Matrix with spectra in rows </p>
</td></tr>
<tr><td><code id="optimWizard_+3A_y">y</code></td>
<td>
<p> Response vector or matrix in analysis </p>
</td></tr>
<tr><td><code id="optimWizard_+3A_postproc">postproc</code></td>
<td>
<p> Custum function for post processing of spectra (optional) </p>
</td></tr>
<tr><td><code id="optimWizard_+3A_predictiontest">predictionTest</code></td>
<td>
<p> Custom prediction object (optional) </p>
</td></tr>
<tr><td><code id="optimWizard_+3A_cvsegments">cvsegments</code></td>
<td>
<p> Cross-validation segments (optional)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Computationally intensive
data(milk)
X &lt;- milk$spectra[,-1]
y &lt;- milk$spectra[,1]
optimWizard(X,y)

# Retrieve optimisation
myResults &lt;- getOptimRes()

# After optimisation is complete
plotOptim(myResults)

## End(Not run)
</code></pre>

<hr>
<h2 id='overall.min'>
Extract the minimum from a baseline optimisation
</h2><span id='topic+overall.min'></span>

<h3>Description</h3>

<p>Takes the result of an optimisation (a call to <code><a href="#topic+doOptim">doOptim</a></code>)
and extracts the minimum quality measure value along with the
parameters giving rise to the value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overall.min(results)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overall.min_+3A_results">results</code></td>
<td>
<p>Result of call to <code><a href="#topic+doOptim">doOptim</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>qualMeas</code></td>
<td>
<p>The minimum quality measure value</p>
</td></tr>
<tr><td><code>algorithm</code></td>
<td>
<p>The name of the baseline algorithm corresponding to
the minimum</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A list with the parameter values corresponding to the
minimum quality measure value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p><code><a href="#topic+doOptim">doOptim</a></code>
</p>

<hr>
<h2 id='param'>Extract the &quot;param&quot; slot</h2><span id='topic+param'></span><span id='topic+param-methods'></span><span id='topic+param+2CbaselineAlg-method'></span><span id='topic+param+2CbaselineAlgResult-method'></span><span id='topic+param+2CbaselineAlgTest-method'></span><span id='topic+param+2CpredictionResult-method'></span>

<h3>Description</h3>

<p>Extracts the <code>param</code> slot of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+baselineAlg-class">baselineAlg</a></code>,
<code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code>,
<code><a href="#topic+baselineAlgResult-class">baselineAlgResult</a></code> or
<code><a href="#topic+predictionResult-class">predictionResult</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>param</code> slot of the object.  Usually a data frame, list or numeric.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+baselineAlg-class">baselineAlg</a></code>,
<code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code>,
<code><a href="#topic+baselineAlgResult-class">baselineAlgResult</a></code>,
<code><a href="#topic+predictionResult-class">predictionResult</a></code>
</p>

<hr>
<h2 id='param.ind.min'>
Extraction methods for &quot;baselineAlgResult&quot; objects
</h2><span id='topic+param.ind.min'></span><span id='topic+param.ind.min-methods'></span><span id='topic+param.ind.min+2CbaselineAlgResult-method'></span><span id='topic+qualMeas.ind.min'></span><span id='topic+qualMeas.ind.min-methods'></span><span id='topic+qualMeas.ind.min+2CbaselineAlgResult-method'></span>

<h3>Description</h3>

<p>Extraction methods that are specific for objects of class
<code><a href="#topic+baselineAlgResult-class">baselineAlgResult</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>param.ind.min(object)
qualMeas.ind.min(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param.ind.min_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+baselineAlgResult-class">baselineAlgResult</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding slot
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+baselineAlgResult-class">baselineAlgResult</a></code>
</p>

<hr>
<h2 id='plotBaseline'>
Plot method for &quot;baseline&quot; objects
</h2><span id='topic+plotBaseline'></span><span id='topic+plot+2Cbaseline-method'></span>

<h3>Description</h3>

<p>Plot the original spectrum, the estimated baseline, and the corrected
spectrum.  Optionally zoom and pan plot, either with arguments or
interactively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'baseline'
plot(x, y, specNo = 1, grid = FALSE, labels = 1:n, rev.x = FALSE,
     zoom = NULL, ...)
plotBaseline(x, y, specNo = 1, grid = FALSE, labels = 1:n, rev.x = FALSE,
             zoom = list(xz = 1, yz = 1, xc = 0, yc = 0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBaseline_+3A_x">x</code></td>
<td>
<p>The <code>baseline</code> object to be plotted</p>
</td></tr>
<tr><td><code id="plotBaseline_+3A_y">y</code></td>
<td>
<p>Unused.  Ignored with a warning</p>
</td></tr>
<tr><td><code id="plotBaseline_+3A_specno">specNo</code></td>
<td>
<p>The row number of the spectrum and baseline to plot.
Defaults to 1</p>
</td></tr>
<tr><td><code id="plotBaseline_+3A_grid">grid</code></td>
<td>
<p>Logical.  Whether to show a grid or not.  Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plotBaseline_+3A_labels">labels</code></td>
<td>
<p>Vector.  Labels for the x tick marks.  Defaults to <code>1:n</code></p>
</td></tr>
<tr><td><code id="plotBaseline_+3A_rev.x">rev.x</code></td>
<td>
<p>Logical.  Whether the spectrum should be reversed.
Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plotBaseline_+3A_zoom">zoom</code></td>
<td>
<p>Either <code>TRUE</code> (only for the plot method), which turns
on the interactive zoom controls, or a list with components <code>xz</code>,
<code>xc</code>, <code>yz</code> and <code>yc</code>, which specifies the desired zoom
and pan.  Defaults to no zoom or pan</p>
</td></tr>
<tr><td><code id="plotBaseline_+3A_...">...</code></td>
<td>
<p>Other arguments.  Currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normal way to plot <code>baseline</code> objects is to use the
<code>plot</code> method.  The <code>plotBaseline</code> function is the
underlying work-horse function, and is not meant for interactive use.
</p>


<h3>Note</h3>

<p>Because the argument list of any plot method must start with <code>x</code>,
<code>y</code>, and the plot method for the <code>baseline</code> class does not
use the <code>y</code> argument, all arguments except <code>x</code> must be named
explicitly.  Positional matching will not work.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland and Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="#topic+baseline">baseline</a></code>, <code><a href="#topic+baseline-class">baseline</a></code>,
<code><a href="#topic+baselineGUI">baselineGUI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk)
bl &lt;- baseline(milk$spectra[1,, drop=FALSE])
## Not run: 
  # Computationally intensive
  plot(bl)
  plot(bl, zoom = TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='plotOptim'> Plotting tool for result objects from optimization </h2><span id='topic+plotOptim'></span>

<h3>Description</h3>

<p>A graphical user interface for plotting optimisation results, either
one algorithm at the time or comparing algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotOptim(results)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotOptim_+3A_results">results</code></td>
<td>
<p> Result list from optimization </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotOptim</code> creates a user interface based on the supplied results.
Curve and level plots from single algorithms or comparison of algorithms
is avilable.
</p>
<p>For single algorithms subsets, levels corresponding to local or global
minima, and averages can be extracted for plotting. For comparison of
algorithms levels corresponding to local or global minima can be used,
or levels corresponding to the minimum when averaging over selected
values of the regression parameter, e.g. selected components in PLSR.
</p>


<h3>Author(s)</h3>

<p> Kristian Hovde Liland and Bjørn-Helge Mevik </p>

<hr>
<h2 id='PLSRTest-class'>Class &quot;PLSRTest&quot;</h2><span id='topic+PLSRTest-class'></span>

<h3>Description</h3>

<p>A class describing a PLSR prediction test.  To run the test, the
&quot;pls&quot; package must be installed.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PLSRTest",
  ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ncomp</code>:</dt><dd><p>Integer vector.  The number of PLSR components
to test</p>
</dd>
<dt><code>cvsegments</code>:</dt><dd><p>A list of the segments to use in the
cross-validation</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+predictionTest-class">predictionTest</a></code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>runTest</dt><dd><p><code>signature(object = "PLSRTest")</code>: Run the test</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Krisitan Hovde Liland</p>


<h3>See Also</h3>

<p>The base class <code><a href="#topic+predictionTest-class">predictionTest</a></code>.  The
<code><a href="#topic+runTest">runTest</a></code> function.  The <code><a href="pls.html#topic+mvr">plsr</a></code>
function from the &quot;pls&quot; package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PLSRTest")
</code></pre>

<hr>
<h2 id='predictionResult-class'>Class &quot;predictionResult&quot;</h2><span id='topic+predictionResult-class'></span>

<h3>Description</h3>

<p>A class containing the result of running a
<code><a href="#topic+predictionTest-class">predictionTest</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>The normal way to create objects is by calling the method
<code>runTest</code> for any object of subclass of
<code><a href="#topic+predictionTest-class">predictionTest</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>param</code>:</dt><dd><p>Numeric vector.  The regression parameter values tested.</p>
</dd>
<dt><code>qualMeas</code>:</dt><dd><p>Numeric vector.  The quality measure values
for each of the values of the <code>param</code> slot</p>
</dd>
<dt><code>ind.min</code>:</dt><dd><p>The index (into <code>qualMeas</code>) of the
minimum quality measure value</p>
</dd>
<dt><code>minQualMeas</code>:</dt><dd><p>The minimum quality measure value</p>
</dd>
<dt><code>param.min</code>:</dt><dd><p>The value of the parameter value
corresponding to the minimum quality measure value</p>
</dd>
<dt><code>qualMeasName</code>:</dt><dd><p>The name of the quality measure</p>
</dd>
<dt><code>paramName</code>:</dt><dd><p>The name of the regression parameter</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>ind.min</dt><dd><p><code>signature(object = "predictionResult")</code>: Extract
the <code>ind.min</code> slot </p>
</dd>
<dt>minQualMeas</dt><dd><p><code>signature(object = "predictionResult")</code>: Extract the <code>minQualMeas</code> slot</p>
</dd>
<dt>param</dt><dd><p><code>signature(object = "predictionResult")</code>: Extract the <code>param</code> slot</p>
</dd>
<dt>param.min</dt><dd><p><code>signature(object = "predictionResult")</code>: Extract the <code>param.min</code> slot</p>
</dd>
<dt>paramName</dt><dd><p><code>signature(object = "predictionResult")</code>: Extract the <code>paramName</code> slot</p>
</dd>
<dt>qualMeas</dt><dd><p><code>signature(object = "predictionResult")</code>: Extract the <code>qualMeas</code> slot</p>
</dd>
<dt>qualMeasName</dt><dd><p><code>signature(object = "predictionResult")</code>: Extract the <code>qualMeasName</code> slot</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p>Function <code><a href="#topic+runTest">runTest</a></code>, class
<code><a href="#topic+predictionTest-class">predictionTest</a></code>, subclasses 
<code><a href="#topic+PLSRTest-class">PLSRTest</a></code> and
<code><a href="#topic+ridgeRegressionTest-class">ridgeRegressionTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("predictionResult")
</code></pre>

<hr>
<h2 id='predictionTest-class'>Class &quot;predictionTest&quot;</h2><span id='topic+predictionTest-class'></span>

<h3>Description</h3>

<p>A virtual class for all predictor test subclasses.  Currently
subclasses <code><a href="#topic+PLSRTest-class">PLSRTest</a></code> and
<code><a href="#topic+ridgeRegressionTest-class">ridgeRegressionTest</a></code> are defined.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;predictionTest&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p>Subclasses <code><a href="#topic+PLSRTest-class">PLSRTest</a></code> and
<code><a href="#topic+ridgeRegressionTest-class">ridgeRegressionTest</a></code>.
</p>

<hr>
<h2 id='qualMeas'>Extraction functions for &quot;predictionResult&quot; or &quot;baselineAlgResult&quot;
objects</h2><span id='topic+qualMeas'></span><span id='topic+qualMeas-methods'></span><span id='topic+qualMeas+2CbaselineAlgResult-method'></span><span id='topic+qualMeas+2CpredictionResult-method'></span><span id='topic+minQualMeas'></span><span id='topic+minQualMeas-methods'></span><span id='topic+minQualMeas+2CbaselineAlgResult-method'></span><span id='topic+minQualMeas+2CpredictionResult-method'></span><span id='topic+param.min'></span><span id='topic+param.min-methods'></span><span id='topic+param.min+2CbaselineAlgResult-method'></span><span id='topic+param.min+2CpredictionResult-method'></span><span id='topic+qualMeasName'></span><span id='topic+qualMeasName-methods'></span><span id='topic+qualMeasName+2CbaselineAlgResult-method'></span><span id='topic+qualMeasName+2CpredictionResult-method'></span>

<h3>Description</h3>

<p>Extract slots from objects of class
<code><a href="#topic+predictionResult-class">predictionResult</a></code> or
<code><a href="#topic+baselineAlgResult-class">baselineAlgResult</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualMeas(object, ...)
## S4 method for signature 'predictionResult'
qualMeas(object, ...)
## S4 method for signature 'baselineAlgResult'
qualMeas(object, ..., MIN, AVG,
  DEFAULT = c("all", "cond.min", "overall.min", "avg"))
minQualMeas(object)
param.min(object)
qualMeasName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qualMeas_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+predictionResult-class">predictionResult</a></code> or
<code><a href="#topic+baselineAlgResult-class">baselineAlgResult</a></code></p>
</td></tr>
<tr><td><code id="qualMeas_+3A_min">MIN</code></td>
<td>
<p>List or vector of parameter names to take the minimum
over.  Not used if <code>DEFAULT</code> is <code>"cond.min"</code>.  See Details</p>
</td></tr>
<tr><td><code id="qualMeas_+3A_avg">AVG</code></td>
<td>
<p>List or vector of parameter names to take the average
over.  Not used if <code>DEFAULT</code> is <code>"avg"</code>.  See Details</p>
</td></tr>
<tr><td><code id="qualMeas_+3A_default">DEFAULT</code></td>
<td>
<p>Character string.  The default way to calculate the minimum
(or average) for all parameters.  See Details</p>
</td></tr>
<tr><td><code id="qualMeas_+3A_...">...</code></td>
<td>
<p>Other arguments. Selection of subsets of parameter levels.  See Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments to the <code><a href="#topic+baselineAlgResult-class">baselineAlgResult</a></code> method are
interpreted in the following way:
</p>
<p>Subsets of parameters levels can be selected by supplying their names
and specifying the level indices as vectors. Substituting a vector
with <code>"all"</code> will return all levels of the corresponding parameter, and
substituting it with <code>"overall"</code> will return the level corresponding
to the overall minimum.
Minimum and average values for selected parameters can be chosen using
<code>MIN</code> and <code>AVG</code>, respectively, together with a vector of parameter names.
</p>
<p><code>DEFAULT</code> specifies the action for each remaining parameters:
If <code>"all"</code> (default): returns all levels.  If <code>"cond.min"</code>: 
take minimum for each remaining parameter (MIN is not used).  If
<code>"overall.min"</code>: set any remaining parameters to their value
corresponding to the overall min. If <code>"avg"</code>: take average for
each remaining parameter (AVG is not used).
</p>


<h3>Value</h3>

<p>The <code>qualMeas</code> method for <code><a href="#topic+baselineAlgResult-class">baselineAlgResult</a></code> objects returns
the subsets or minimum values of the <code>qualMeas</code> slot of the object as specified
above. All other methods simply return the corresponding slot.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p>Function <code><a href="#topic+runTest">runTest</a></code>, classes
<code><a href="#topic+baselineAlgResult-class">baselineAlgResult</a></code> and <code><a href="#topic+predictionResult-class">predictionResult</a></code>
</p>

<hr>
<h2 id='ridgeRegressionTest-class'>Class &quot;ridgeRegressionTest&quot;</h2><span id='topic+ridgeRegressionTest-class'></span>

<h3>Description</h3>

<p>A class describing a ridge regression test.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ridgeRegressionTest", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>lambda</code>:</dt><dd><p>Numeric vector.  The smoothing parameter
values to test</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+predictionTest-class">predictionTest</a></code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>runTest</dt><dd><p><code>signature(object = "ridgeRegressionTest")</code>: Run
the test</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p>The base class <code><a href="#topic+predictionTest-class">predictionTest</a></code>.  The
<code><a href="#topic+runTest">runTest</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("ridgeRegressionTest")
</code></pre>

<hr>
<h2 id='runTest'>Run a predictionTest or baselineAlgTest</h2><span id='topic+runTest'></span><span id='topic+runTest-methods'></span><span id='topic+runTest+2CbaselineAlgTest-method'></span><span id='topic+runTest+2CPLSRTest-method'></span><span id='topic+runTest+2CridgeRegressionTest-method'></span>

<h3>Description</h3>

<p>Runs the test defined in a <code><a href="#topic+predictionTest-class">predictionTest</a></code> or
<code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runTest(object, X, y, ...)
## S4 method for signature 'PLSRTest'
runTest(object, X, y)
## S4 method for signature 'ridgeRegressionTest'
runTest(object, X, y)
## S4 method for signature 'baselineAlgTest'
runTest(object, X, y, predictionTest, postproc, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runTest_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code>
or subclass of <code><a href="#topic+predictionTest-class">predictionTest</a></code> (currently
<code><a href="#topic+PLSRTest-class">PLSRTest</a></code> or
<code><a href="#topic+ridgeRegressionTest-class">ridgeRegressionTest</a></code>).  The object specify the
test to be run</p>
</td></tr>
<tr><td><code id="runTest_+3A_x">X</code></td>
<td>
<p>A matrix.  The spectra to use in the test</p>
</td></tr>
<tr><td><code id="runTest_+3A_y">y</code></td>
<td>
<p>A vector or matrix.  The response(s) to use in the test</p>
</td></tr>
<tr><td><code id="runTest_+3A_predictiontest">predictionTest</code></td>
<td>
<p>A <code><a href="#topic+predictionTest-class">predictionTest</a></code> object,
describing the prediction test to use for this baseline algorithm
test</p>
</td></tr>
<tr><td><code id="runTest_+3A_postproc">postproc</code></td>
<td>
<p>A function, used to postprocess the baseline corrected
spectra prior to prediction testing.  The function should take a
matrix of spectra as its only argument, and return a matrix of
postprocessed spectra</p>
</td></tr>
<tr><td><code id="runTest_+3A_verbose">verbose</code></td>
<td>
<p>Logical, specifying whether the test should print out
progress information.  Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="runTest_+3A_...">...</code></td>
<td>
<p>Other arguments.   Currently only used by the
<code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>runTest</code> returns an object of class
<code><a href="#topic+predictionResult-class">predictionResult</a></code> or <code><a href="#topic+baselineAlgResult-class">baselineAlgResult</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "baselineAlgTest")</code></dt><dd><p>Baseline corrects
the spectra, optionally postprocesses them, and runs a prediction test
on the corrected spectra.</p>
</dd>
<dt><code>signature(object = "PLSRTest")</code></dt><dd><p>Runs PLSR
on the data and calculates the cross-validated RMSEP</p>
</dd>
<dt><code>signature(object = "ridgeRegressionTest")</code></dt><dd><p>Runs ridge
regression on the data and calculates the GCV</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Kristian Hovde Liland</p>


<h3>See Also</h3>

<p><code><a href="#topic+baselineAlgTest-class">baselineAlgTest</a></code>,
<code><a href="#topic+predictionTest-class">predictionTest</a></code>, <code><a href="#topic+PLSRTest-class">PLSRTest</a></code>,
<code><a href="#topic+ridgeRegressionTest-class">ridgeRegressionTest</a></code>
</p>

<hr>
<h2 id='XPSdata'> XPS core line data</h2><span id='topic+C1s'></span><span id='topic+O1s'></span>

<h3>Description</h3>

<p>Matrix of x,y values from X-Ray Photoelectron Spectroscopy on test sample.<br />
The data are about the <code>Carbon</code> and <code>Oxygen</code> element for
<code>1s</code> shell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data(C1s)
	data(O1s)
	</code></pre>


<h3>Format</h3>

<p>A matrix with the following 2 variables (rows).
</p>

<dl>
<dt><code>first row</code></dt><dd><p>is the abscissa, ( Binding Energy [eV] )</p>
</dd>
<dt><code>second row</code></dt><dd><p>is the Intensity, ( a.u. )</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="#topic+baseline.shirley">baseline.shirley</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(C1s)
data(O1s)
plot(C1s[1,], C1s[2,], type = "l")
plot(O1s[1,], O1s[2,], type = "l")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
