<!DOCTYPE html><html><head><title>Help for package statGraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {statGraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#statGraph-package'><p>Statistical Methods for Graphs</p></a></li>
<li><a href='#anogva'><p>ANOGVA Analysis Of Graph Variability</p></a></li>
<li><a href='#cerqueira.test'><p>Andressa Cerqueira, Daniel Fraiman, Claudia D. Vargas and Florencia Leonardi</p>
non-parametric test of hypotheses to verify if two samples of random graphs
were originated from the same probability distribution.</a></li>
<li><a href='#fast.eigenvalue.probability'><p>Degree-based eigenvalue probability</p></a></li>
<li><a href='#fast.graph.param.estimator'><p>Degree-based graph parameter estimator</p></a></li>
<li><a href='#fast.spectral.density'><p>Degree-based spectral density</p></a></li>
<li><a href='#fraiman.test'><p>Daniel Fraiman and Ricardo Fraiman test for network differences between</p>
groups with an analysis of variance test (ANOVA).</a></li>
<li><a href='#ghoshdastidar.test'><p>Ghoshdastidar hypothesis testing for large random graphs.</p></a></li>
<li><a href='#GIC'><p>Graph Information Criterion (GIC)</p></a></li>
<li><a href='#graph.acf'><p>Auto Correlation Function Estimation for Graphs</p></a></li>
<li><a href='#graph.cem'><p>Clustering Expectation-Maximization for Graphs (graph.cem)</p></a></li>
<li><a href='#graph.cor.test'><p>Test for Association / Correlation Between Paired Samples of Graphs</p></a></li>
<li><a href='#graph.entropy'><p>Graph spectral entropy</p></a></li>
<li><a href='#graph.hclust'><p>Hierarchical cluster analysis on a list of graphs.</p></a></li>
<li><a href='#graph.kmeans'><p>K-means for Graphs</p></a></li>
<li><a href='#graph.model.selection'><p>Graph model selection</p></a></li>
<li><a href='#graph.mult.scaling'><p>Multidimensional scaling of graphs</p></a></li>
<li><a href='#graph.param.estimator'><p>Graph parameter estimator</p></a></li>
<li><a href='#sp.anogva'><p>Semi-Parametric Analysis Of Graph Variability (ANOGVA)</p></a></li>
<li><a href='#takahashi.test'><p>Test for the Jensen-Shannon divergence between graphs</p></a></li>
<li><a href='#tang.test'><p>Tang hypothesis testing for random graphs.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Methods for Graphs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andre Fujita &lt;andrefujita@usp.br&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0), stats, graphics</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, MASS, rARPACK, cluster, foreach, parallel, doParallel,
methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains statistical methods to analyze graphs, such as graph parameter estimation, 
    model selection based on the Graph Information Criterion, statistical tests to discriminate two or more populations of graphs, 
    correlation between graphs, and clustering of graphs.
    References: Takahashi et al. (2012) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0049949">doi:10.1371/journal.pone.0049949</a>&gt;, Fujita et al. (2017) &lt;<a href="https://doi.org/10.3389%2Ffnins.2017.00066">doi:10.3389/fnins.2017.00066</a>&gt;,
    Fujita et al. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2016.11.016">doi:10.1016/j.csda.2016.11.016</a>&gt;, Tang et al. (2017) &lt;<a href="https://doi.org/10.3150%2F15-BEJ789">doi:10.3150/15-BEJ789</a>&gt;,
    Tang et al. (2017) &lt;<a href="https://doi.org/10.1080%2F10618600.2016.1193505">doi:10.1080/10618600.2016.1193505</a>&gt;, Ghoshdastidar et al. (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1705.06168">doi:10.48550/arXiv.1705.06168</a>&gt;,
    Ghoshdastidar et al. (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1707.00833">doi:10.48550/arXiv.1707.00833</a>&gt;, Cerqueira et al. (2017) &lt;<a href="https://doi.org/10.1109%2FTNSE.2017.2674026">doi:10.1109/TNSE.2017.2674026</a>&gt;,
    Fraiman and Fraiman (2018) &lt;<a href="https://doi.org/10.1038%2Fs41598-018-23152-5">doi:10.1038/s41598-018-23152-5</a>&gt;, Fujita et al. (2019) &lt;<a href="https://doi.org/10.1093%2Fcomnet%2Fcnz028">doi:10.1093/comnet/cnz028</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.ime.usp.br/~fujita/software.html">https://www.ime.usp.br/~fujita/software.html</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-23</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-25 15:17:34 UTC; grover</td>
</tr>
<tr>
<td>Author:</td>
<td>Diogo R. da Costa [aut],
  Taiane C. Ramos [aut],
  Grover E. Castro Guzman [aut],
  Suzana S. Santos [aut],
  Eduardo S. Lira [aut],
  Andre Fujita [aut, cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-25 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='statGraph-package'>Statistical Methods for Graphs</h2><span id='topic+statGraph'></span><span id='topic+statGraph-package'></span>

<h3>Description</h3>

<p>Contains statistical methods to analyze graphs, such as graph parameter estimation, 
    model selection based on the Graph Information Criterion, statistical tests to discriminate two or more populations of graphs, 
    correlation between graphs, and clustering of graphs.
    References: Takahashi et al. (2012) &lt;doi:10.1371/journal.pone.0049949&gt;, Fujita et al. (2017) &lt;doi:10.3389/fnins.2017.00066&gt;,
    Fujita et al. (2017) &lt;doi:10.1016/j.csda.2016.11.016&gt;, Tang et al. (2017) &lt;doi:10.3150/15-BEJ789&gt;,
    Tang et al. (2017) &lt;doi:10.1080/10618600.2016.1193505&gt;, Ghoshdastidar et al. (2017) &lt;arXiv:1705.06168&gt;,
    Ghoshdastidar et al. (2017) &lt;arXiv:1707.00833&gt;, Cerqueira et al. (2017) &lt;doi:10.1109/TNSE.2017.2674026&gt;,
    Fraiman and Fraiman (2018) &lt;doi:10.1038/s41598-018-23152-5&gt;, Fujita et al. (2019) &lt;doi:10.1093/comnet/cnz028&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> statGraph</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.5.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-05-18</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.6.0), stats, graphics</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> igraph, MASS, rARPACK, cluster, foreach, parallel, doParallel</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 3)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://www.ime.usp.br/~fujita/software.html</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Diogo R. da Costa [aut],
  Taiane C. Ramos [aut],
  Grover E. Castro Guzman [aut],
  Suzana S. Santos [aut],
  Eduardo S. Lira [aut],
  Andre Fujita [aut, cre]
</p>
<p>Maintainer: Andre Fujita &lt;andrefujita@usp.br&gt;
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://www.ime.usp.br/~fujita/software.html">https://www.ime.usp.br/~fujita/software.html</a>
</p>
</li></ul>


<hr>
<h2 id='anogva'>ANOGVA Analysis Of Graph Variability</h2><span id='topic+anogva'></span>

<h3>Description</h3>

<p><code>anogva</code> statistically tests whether two or more sets of graphs are generated
by the same random graph model. It is a generalization of the 'takahashi.test'
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anogva(G, labels, maxBoot = 1000, bandwidth = "Silverman")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anogva_+3A_g">G</code></td>
<td>
<p>a list of undirected graphs (igraph type) or their adjacency
matrices. The adjacency matrix of an unweighted graph contains only 0s and
1s, while the weighted graph may have nonnegative real values that correspond
to the weights of the edges.</p>
</td></tr>
<tr><td><code id="anogva_+3A_labels">labels</code></td>
<td>
<p>an array of integers indicating the labels of each graph.</p>
</td></tr>
<tr><td><code id="anogva_+3A_maxboot">maxBoot</code></td>
<td>
<p>integer indicating the number of bootstrap resamplings.</p>
</td></tr>
<tr><td><code id="anogva_+3A_bandwidth">bandwidth</code></td>
<td>
<p>string showing which criterion is used to choose the
bandwidth during the spectral density estimation. Choose between the
following criteria: &quot;Silverman&quot; (default), &quot;Sturges&quot;, &quot;bcv&quot;, &quot;ucv&quot; and &quot;SJ&quot;.
&quot;bcv&quot; is an abbreviation of biased cross-validation, while &quot;ucv&quot; means
unbiased cross-validation. &quot;SJ&quot;  implements the methods of Sheather &amp; Jones
(1991) to select the bandwidth using pilot estimation of derivatives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the statistic of the test.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Fujita, A., Vidal, M. C. and Takahashi, D. Y. (2017) A Statistical Method to
Distinguish Functional Brain Networks. _Front. Neurosci._, *11*, 66.
doi:10.3389/fnins.2017.00066.
</p>
<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
g1 &lt;- g2 &lt;- g3 &lt;- list()
for (i in 1:20) {
  g1[[i]] &lt;- igraph::sample_gnp(50, 0.50)
  g2[[i]] &lt;- igraph::sample_gnp(50, 0.50)
  g3[[i]] &lt;- igraph::sample_gnp(50, 0.52)
}
G &lt;- c(g1, g2, g3)
label &lt;- c(rep(1,20),rep(2,20),rep(3,20))
result &lt;- anogva(G, label, maxBoot=50)
result

</code></pre>

<hr>
<h2 id='cerqueira.test'>Andressa Cerqueira, Daniel Fraiman, Claudia D. Vargas and Florencia Leonardi
non-parametric test of hypotheses to verify if two samples of random graphs
were originated from the same probability distribution.</h2><span id='topic+cerqueira.test'></span>

<h3>Description</h3>

<p>Given two identically independently distributed (idd) samples of graphs G1 and
G2, the test verifies if they have the same distribution by calculating the
mean distance D from G1 to G2. The test rejects the null hypothesis if D is
greater than the (1-alpha)-quantile of the distribution of the test under the
null hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cerqueira.test(G1, G2, maxBoot = 300)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cerqueira.test_+3A_g1">G1</code></td>
<td>
<p>the first iid sample of graphs to be compared. Must be a list of
igraph objects.</p>
</td></tr>
<tr><td><code id="cerqueira.test_+3A_g2">G2</code></td>
<td>
<p>the second iid sample of graphs to be compared. Must be a list of
igraph objects.</p>
</td></tr>
<tr><td><code id="cerqueira.test_+3A_maxboot">maxBoot</code></td>
<td>
<p>integer indicating the number of bootstrap resamples (default
is 300).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>the value of the test.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Andressa Cerqueira, Daniel Fraiman, Claudia D. Vargas and Florencia Leonardi.
&quot;A test of hypotheses for random graph distributions built from EEG data&quot;,
https://ieeexplore.ieee.org/document/7862892
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(42)

## test under H0
G1 &lt;- G2 &lt;- list()
for(i in 1:10){
  G1[[i]] &lt;- igraph::sample_gnp(50,0.5)
  G2[[i]] &lt;- igraph::sample_gnp(50,0.5)
}
k1 &lt;- cerqueira.test(G1, G2)
k1

## test under H1
G1 &lt;- G2 &lt;- list()
for(i in 1:10){
  G1[[i]] &lt;- igraph::sample_gnp(50,0.5)
  G2[[i]] &lt;- igraph::sample_gnp(50,0.6)
}
k2 &lt;- cerqueira.test(G1, G2)
k2

## End(Not run)

</code></pre>

<hr>
<h2 id='fast.eigenvalue.probability'>Degree-based eigenvalue probability</h2><span id='topic+fast.eigenvalue.probability'></span>

<h3>Description</h3>

<p><code>fast.eigenvalue.probability</code> returns the probability of an eigenvalue
given the degree and excess degree probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.eigenvalue.probability(deg_prob, q_prob, all_k, z, n_iter = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast.eigenvalue.probability_+3A_deg_prob">deg_prob</code></td>
<td>
<p>The degree probability of the graph.</p>
</td></tr>
<tr><td><code id="fast.eigenvalue.probability_+3A_q_prob">q_prob</code></td>
<td>
<p>The excess degree probability of the graph.</p>
</td></tr>
<tr><td><code id="fast.eigenvalue.probability_+3A_all_k">all_k</code></td>
<td>
<p>List of sorted unique degrees greater than 1 of the graph.</p>
</td></tr>
<tr><td><code id="fast.eigenvalue.probability_+3A_z">z</code></td>
<td>
<p>Complex number whose real part is the eigenvalue whose probability
we want to obtain, the imaginary part is a small value (e.g., 1e-3).</p>
</td></tr>
<tr><td><code id="fast.eigenvalue.probability_+3A_n_iter">n_iter</code></td>
<td>
<p>The maximum number of iterations to perform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A complex number whose imaginary part absolute value corresponds to
the probability of the given eigenvalue.
</p>


<h3>References</h3>

<p>Newman, M. E. J., Zhang, X., &amp; Nadakuditi, R. R. (2019).
Spectra of random networks with arbitrary degrees.
Physical Review E, 99(4), 042309.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
G &lt;- igraph::sample_smallworld(dim = 1, size = 10, nei = 2, p = 0.2)

# Obtain the degree distribution
deg_prob &lt;- c(igraph::degree_distribution(graph = G, mode = "all"),0.0)
k_deg &lt;- seq(1,length(deg_prob)) - 1

# Obtain the excess degree distribution
c &lt;- sum(k_deg * deg_prob)
q_prob &lt;- c()
for(k in 0:(length(deg_prob) - 1)){
  aux_q &lt;- (k + 1) * deg_prob[k + 1]/c
  q_prob &lt;- c(q_prob,aux_q)
}

# Obtain the sorted unique degrees greater than 1
all_k &lt;- c(1:length(q_prob))
valid_idx &lt;- q_prob != 0
q_prob &lt;- q_prob[valid_idx]
all_k &lt;- all_k[valid_idx]

# Obtain the probability of the eigenvalue 0
z &lt;- 0 + 0.01*1i
eigenval_prob &lt;- -Im(fast.eigenvalue.probability(deg_prob,q_prob,all_k,z))
eigenval_prob

</code></pre>

<hr>
<h2 id='fast.graph.param.estimator'>Degree-based graph parameter estimator</h2><span id='topic+fast.graph.param.estimator'></span>

<h3>Description</h3>

<p><code>fast.graph.param.estimator</code> estimates the parameter of the complex
network model using the degree-based spectral density and ternary search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.graph.param.estimator(
  G,
  model,
  lo = NULL,
  hi = NULL,
  eps = 0.001,
  from = NULL,
  to = NULL,
  npoints = 2000,
  numCores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast.graph.param.estimator_+3A_g">G</code></td>
<td>
<p>The undirected unweighted graph (igraph type).</p>
</td></tr>
<tr><td><code id="fast.graph.param.estimator_+3A_model">model</code></td>
<td>
<p>Either a string or a function:
</p>
<p>A string that indicates one of the following models: &quot;ER&quot; (Erdos-Renyi random
graph model), &quot;GRG&quot; (geometric random graph model), &quot;WS&quot; (Watts-Strogatz
model), and &quot;BA&quot; (Barabasi-Albert model).
</p>
<p>A function that returns a Graph generated by a graph model. It must contain
two arguments: the first one corresponds to the graph size and the second to
the parameter of the model.</p>
</td></tr>
<tr><td><code id="fast.graph.param.estimator_+3A_lo">lo</code></td>
<td>
<p>Smallest parameter value that the graph model can take.
</p>
<p>If &ldquo;model&rdquo; is an string, then the default value of 0 is used for the
predefined models (&quot;ER&quot;, &quot;GRG&quot;, &quot;WS&quot;, and &quot;BA&quot;).</p>
</td></tr>
<tr><td><code id="fast.graph.param.estimator_+3A_hi">hi</code></td>
<td>
<p>Largest parameter value that the graph model can take.
</p>
<p>If &ldquo;model&rdquo; is an string, then the default values are used for the
predefined models 1 for &quot;ER&quot;, sqrt(2) for &quot;GRG&quot;, 1 for &quot;WS&quot;, and 5 for &quot;BA&quot;).</p>
</td></tr>
<tr><td><code id="fast.graph.param.estimator_+3A_eps">eps</code></td>
<td>
<p>Desired precision of the parameter estimate.</p>
</td></tr>
<tr><td><code id="fast.graph.param.estimator_+3A_from">from</code></td>
<td>
<p>Lower end of the interval that contain the eigenvalues to
generate the degree-based spectral densities. The smallest eigenvalue of the
adjacency matrix corresponding to &ldquo;graph&rdquo; is used if the value is not given.</p>
</td></tr>
<tr><td><code id="fast.graph.param.estimator_+3A_to">to</code></td>
<td>
<p>Upper end of the interval that contain the eigenvalues to generate
the degree-based spectral densities. The largest eigenvalue of the adjacency
matrix corresponding to &ldquo;graph&rdquo; is used if the value is not given.</p>
</td></tr>
<tr><td><code id="fast.graph.param.estimator_+3A_npoints">npoints</code></td>
<td>
<p>Number of points to discretize the interval &lt;<code>from</code>,<code>to</code>&gt;.</p>
</td></tr>
<tr><td><code id="fast.graph.param.estimator_+3A_numcores">numCores</code></td>
<td>
<p>Number of cores to use for parallelization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>The degree-based parameter estimate. For the &quot;ER&quot;, &quot;GRG&quot;, &quot;WS&quot;,
and &quot;BA&quot; models, the parameter corresponds to the probability to connect a
pair of vertices, the radius used to construct the geometric graph in a unit
square, the probability to reconnect a vertex, and the scaling exponent
respectively.</p>
</td></tr>
<tr><td><code>L1_dist</code></td>
<td>
<p>The L1 distance between the observed graph and the graph model
with the estimated value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

### Example giving only the name of the model to use
G &lt;- igraph::sample_smallworld(dim = 1, size = 15, nei = 2, p = 0.2)

# Obtain the parameter of the WS model
estimated.parameter1 &lt;- fast.graph.param.estimator(G, "WS", lo = 0.1, hi = 0.5,
                                                  eps = 1e-1, npoints = 10,
                                                  numCores = 1)
estimated.parameter1

## Not run: 
### Example giving a function instead of a model

# Defining the model to use
G &lt;- igraph::sample_smallworld(dim = 1, size = 5000, nei = 2, p = 0.2)
K &lt;- as.integer(igraph::ecount(G)/igraph::vcount(G))
fun_WS &lt;- function(n, param, nei = K){
 return (igraph::sample_smallworld(dim = 1,size = n, nei = nei, p = param))
}

# Obtain the parameter of the WS model
estimated.parameter2 &lt;- fast.graph.param.estimator(G, fun_WS, lo = 0.0, hi = 1.0,
                                                   npoints = 100, numCores = 2)
estimated.parameter2

## End(Not run)

</code></pre>

<hr>
<h2 id='fast.spectral.density'>Degree-based spectral density</h2><span id='topic+fast.spectral.density'></span>

<h3>Description</h3>

<p><code>fast.spectral.density</code> returns the degree-based spectral density in
the interval &lt;<code>from</code>,<code>to</code>&gt; by using npoints discretization points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.spectral.density(G, from = NULL, to = NULL, npoints = 2000, numCores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast.spectral.density_+3A_g">G</code></td>
<td>
<p>The undirected unweighted graph (igraph type) whose spectral
density we want to obtain.</p>
</td></tr>
<tr><td><code id="fast.spectral.density_+3A_from">from</code></td>
<td>
<p>Lower end of the interval that contain the eigenvalues or
smallest eigenvalue of the adjacency matrix of the graph. The smallest
eigenvalue is used if the value is not given.</p>
</td></tr>
<tr><td><code id="fast.spectral.density_+3A_to">to</code></td>
<td>
<p>Upper end of the interval that contain the eigenvalues or largest
eigenvalue of the adjacency matrix of the graph. The largest eigenvalue is
used if the value is not given.</p>
</td></tr>
<tr><td><code id="fast.spectral.density_+3A_npoints">npoints</code></td>
<td>
<p>Number of discretization points of the interval &lt;<code>from</code>,<code>to</code>&gt;.</p>
</td></tr>
<tr><td><code id="fast.spectral.density_+3A_numcores">numCores</code></td>
<td>
<p>Number of cores to use for parallelization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the degree-based spectral density of the graph in the
</p>


<h3>References</h3>

<p>Newman, M. E. J., Zhang, X., &amp; Nadakuditi, R. R. (2019).
Spectra of random networks with arbitrary degrees.
Physical Review E, 99(4), 042309.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
G &lt;- igraph::sample_smallworld(dim = 1, size = 100, nei = 2, p = 0.2)

# Obtain the degree-based spectral density
density &lt;- fast.spectral.density(G = G, npoints = 80, numCores = 1)
density

</code></pre>

<hr>
<h2 id='fraiman.test'>Daniel Fraiman and Ricardo Fraiman test for network differences between
groups with an analysis of variance test (ANOVA).</h2><span id='topic+fraiman.test'></span>

<h3>Description</h3>

<p>Given a list of graphs, the test verifies if all the subpopulations have the
same mean network, under the alternative that at least one subpopulation has
a different mean network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fraiman.test(G, maxBoot = 300)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fraiman.test_+3A_g">G</code></td>
<td>
<p>the undirected graphs to be compared. Must be a list of lists of
igraph objects or a list of lists of adjacency matrices.</p>
</td></tr>
<tr><td><code id="fraiman.test_+3A_maxboot">maxBoot</code></td>
<td>
<p>integer indicating the number of bootstrap resamples
(default is 300).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>T</code></td>
<td>
<p>the value of the test.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Fraiman, Daniel, and Ricardo Fraiman. &quot;An ANOVA approach for statistical
comparisons of brain networks&quot;,
https://www.nature.com/articles/s41598-018-23152-5
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(42)

## test under H0
a &lt;- b &lt;- G &lt;- list()
for(i in 1:10){
  a[[i]] &lt;- igraph::sample_gnp(50,0.5)
  b[[i]] &lt;- igraph::sample_gnp(50,0.5)
}
G &lt;- list(a,b)
k1 &lt;- fraiman.test(G)
k1

## test under H1
a &lt;- b &lt;- G &lt;- list()
for(i in 1:10){
  a[[i]] &lt;- igraph::sample_gnp(50,0.5)
  b[[i]] &lt;- igraph::sample_gnp(50,0.6)
}
G &lt;- list(a,b)
k2 &lt;- fraiman.test(G)
k2

## End(Not run)

</code></pre>

<hr>
<h2 id='ghoshdastidar.test'>Ghoshdastidar hypothesis testing for large random graphs.</h2><span id='topic+ghoshdastidar.test'></span>

<h3>Description</h3>

<p>Given two lists of graphs generated by the inhomogeneous random graph model,
<code>ghoshdastidar.test</code> tests if they were generated by the same parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghoshdastidar.test(G1, G2, maxBoot = 300, two.sample = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghoshdastidar.test_+3A_g1">G1</code></td>
<td>
<p>the first list of undirected graphs to be compared. Must be a list
of matrices or igraph objects.</p>
</td></tr>
<tr><td><code id="ghoshdastidar.test_+3A_g2">G2</code></td>
<td>
<p>the second list of undirected graphs to be compared. Must be a list
of matrices or igraph objects.</p>
</td></tr>
<tr><td><code id="ghoshdastidar.test_+3A_maxboot">maxBoot</code></td>
<td>
<p>integer indicating the number of bootstrap resamples (default
is 300).</p>
</td></tr>
<tr><td><code id="ghoshdastidar.test_+3A_two.sample">two.sample</code></td>
<td>
<p>logical. If TRUE the sets contain only one graph each. If
FALSE the sets contain more than one graph each (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>T</code></td>
<td>
<p>the value of the test.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test (only returned when the parameter
'two.sample' is FALSE).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ghoshdastidar, Debarghya, et al. &quot;Two-sample tests for large random graphs
using network statistics&quot;. arXiv preprint arXiv:1705.06168 (2017).
</p>
<p>Ghoshdastidar, Debarghya, et al. &quot;Two-sample hypothesis testing for
inhomogeneous random graphs&quot;. arXiv preprint, arXiv:1707.00833 (2017).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(42)

## test for sets with more than one graph each under H0
G1 &lt;- G2 &lt;- list()
for(i in 1:10){
  G1[[i]] &lt;- as.matrix(igraph::get.adjacency(igraph::sample_gnp(50,0.6)))
  G2[[i]] &lt;- as.matrix(igraph::get.adjacency(igraph::sample_gnp(50,0.6)))
}
D1 &lt;- ghoshdastidar.test(G1, G2)
D1

## test for sets with more than one graph each under H1
G1 &lt;- G2 &lt;- list()
for(i in 1:10){
  G1[[i]] &lt;- as.matrix(igraph::get.adjacency(igraph::sample_gnp(50,0.6)))
  G2[[i]] &lt;- as.matrix(igraph::get.adjacency(igraph::sample_gnp(50,0.7)))
}
D2 &lt;- ghoshdastidar.test(G1, G2)
D2

## test for sets with only one graph each under H0
G1 &lt;- G2 &lt;- list()
G1[[1]] &lt;- igraph::sample_gnp(300, 0.6)
G2[[1]] &lt;- igraph::sample_gnp(300, 0.6)
D3 &lt;- ghoshdastidar.test(G1, G2, two.sample= TRUE)
D3

## test for sets with only one graph each under H1
G1 &lt;- G2 &lt;- list()
G1[[1]] &lt;- igraph::sample_gnp(300, 0.6)
G2[[1]] &lt;- igraph::sample_gnp(300, 0.7)
D4 &lt;- ghoshdastidar.test(G1, G2, two.sample= TRUE)
D4

## End(Not run)

</code></pre>

<hr>
<h2 id='GIC'>Graph Information Criterion (GIC)</h2><span id='topic+GIC'></span>

<h3>Description</h3>

<p><code>GIC</code> returns the Kullback-Leibler divergence or L2 distance between an
undirected graph and a given graph model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GIC(
  G,
  model,
  p = NULL,
  bandwidth = "Silverman",
  eigenvalues = NULL,
  dist = "KL"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GIC_+3A_g">G</code></td>
<td>
<p>the undirected graph (igraph type) or its adjacency matrix. The
adjacency matrix of an unweighted graph contains only 0s and 1s, while the
weighted graph may have nonnegative real values that correspond to the
weights of the edges.</p>
</td></tr>
<tr><td><code id="GIC_+3A_model">model</code></td>
<td>
<p>either a list, a string, a function or a matrix describing a
graph model:
</p>
<p>A list that represents the spectral density of a model. It contains the
components &quot;x&quot; and &quot;y&quot;, which are numeric vectors of the same size. The &quot;x&quot;
component contains the points at which the density was computed and the &quot;y&quot;
component contains the observed density.
</p>
<p>A string that indicates one of the following models: &quot;ER&quot; (Erdos-Renyi random
graph), &quot;GRG&quot; (geometric random graph), &quot;KR&quot; (k regular random graph), &quot;WS&quot;
(Watts-Strogatz model), and &quot;BA&quot; (Barabasi-Albert model). When the argument
'model' is a string, the user must also provides the model parameter by using
the argument 'p'.
</p>
<p>A function that returns a graph (represented by its adjacency matrix)
generated by a graph model. It must contain two arguments: the first one
corresponds to the graph size and the second to the parameter of the model.
The model parameter will be provided by the argument 'p' of the 'GIC'
function.
</p>
<p>A matrix containing the spectrum of the model. Each column contains the
eigenvalues of a graph generated by the model. To estimate the spectral
density of the model, the method will estimate the density of the values of
each column, and then will take the average density.</p>
</td></tr>
<tr><td><code id="GIC_+3A_p">p</code></td>
<td>
<p>the model parameter. The user must provide a valid parameter if the
argument 'model' is a string or a function.
For the predefined models (&quot;ER&quot;, &quot;GRG&quot;, &quot;KR&quot;, &quot;WS&quot;, and &quot;BA&quot;), the parameter
the probability to connect a pair of vertices, for the &quot;ER&quot; model
(Erdos-Renyi random graph);
</p>
<p>the radius used to construct the geometric graph in a unit square, for the
&quot;GRG&quot; model (geometric random graph);
</p>
<p>the degree 'k' of a regular graph, for the &quot;KR&quot; model (k regular random
graph);
</p>
<p>the probability to reconnect a vertex, for the &quot;WS&quot; model (Watts-Strogatz
model);
</p>
<p>and the scaling exponent, for the &quot;BA&quot; model (Barabasi-Albert model).</p>
</td></tr>
<tr><td><code id="GIC_+3A_bandwidth">bandwidth</code></td>
<td>
<p>string showing which criterion is used to choose the
bandwidth during the spectral density estimation. Choose between the
following criteria: &quot;Silverman&quot; (default), &quot;Sturges&quot;, &quot;bcv&quot;, &quot;ucv&quot; and &quot;SJ&quot;.
&quot;bcv&quot; is an abbreviation of biased cross-validation, while &quot;ucv&quot; means
unbiased cross-validation. &quot;SJ&quot;  implements the methods of Sheather &amp; Jones
(1991) to select the bandwidth using pilot estimation of derivatives.</p>
</td></tr>
<tr><td><code id="GIC_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p>optional parameter. It contains the eigenvalues of matrix
G. Then, it can be used when the eigenvalues of G were previously computed.
If no value is passed, then the eigenvalues of G will be computed by 'GIC'.</p>
</td></tr>
<tr><td><code id="GIC_+3A_dist">dist</code></td>
<td>
<p>string indicating if you want to use the &quot;KL&quot; (default) or &quot;L2&quot;
distances. &quot;KL&quot; means Kullback-Leibler divergence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number corresponding to the Kullback-Leibler divergence or L2
distance between the observed graph and the graph model.
</p>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G &lt;- as.matrix(igraph::get.adjacency(igraph::sample_gnp(n=50, p=0.5)))

# Using a string to indicate the graph model
result1 &lt;- GIC(G, "ER", 0.5)
result1

# Using a function to describe the graph model
# Erdos-Renyi graph
model &lt;- function(n, p) {
   return(as.matrix(igraph::get.adjacency(igraph::sample_gnp(n, p))))
}
result2 &lt;- GIC(G, model, 0.5)
result2

</code></pre>

<hr>
<h2 id='graph.acf'>Auto Correlation Function Estimation for Graphs</h2><span id='topic+graph.acf'></span>

<h3>Description</h3>

<p>The function <code>graph.acf</code> computes estimates of the autocorrelation
function for graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.acf(G, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.acf_+3A_g">G</code></td>
<td>
<p>a list of undirected graphs (igraph type) or their adjacency
matrices. The adjacency matrix of an unweighted graph contains only 0s and
1s, while the weighted graph may have nonnegative real values that correspond
to the weights of the edges.</p>
</td></tr>
<tr><td><code id="graph.acf_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (default) the graph.acf is plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class acf.
</p>


<h3>References</h3>

<p>Fujita, A., Takahashi, D. Y., Balardin, J. B., Vidal, M. C. and Sato, J. R.
(2017) Correlation between graphs with an application to brain network
analysis. _Computational Statistics &amp; Data Analysis_ *109*, 76-92.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G &lt;- list()
p &lt;- array(0, 100)
p[1:3] &lt;- rnorm(3)
for (t in 4:100) {
  p[t] &lt;- 0.5*p[t-3] + rnorm(1)
}
ma &lt;- max(p)
mi &lt;- min(p)
p &lt;- (p - mi)/(ma-mi)
for (t in 1:100) {
  G[[t]] &lt;- igraph::sample_gnp(100, p[t])
}
graph.acf(G, plot=TRUE)

</code></pre>

<hr>
<h2 id='graph.cem'>Clustering Expectation-Maximization for Graphs (graph.cem)</h2><span id='topic+graph.cem'></span>

<h3>Description</h3>

<p><code>graph.cem</code> clusters graphs following an expectation-maximization algorithm based
on the Kullback-Leibler divergence between the spectral densities of the
graph and of the random graph model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.cem(g, model, k, max_iter = 10, ncores = 1, bandwidth = "Sturges")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.cem_+3A_g">g</code></td>
<td>
<p>a list containing the graphs or their adjacency matrices to be
clustered.</p>
</td></tr>
<tr><td><code id="graph.cem_+3A_model">model</code></td>
<td>
<p>a string that indicates one of the following random graph
models: &quot;ER&quot; (Erdos-Renyi random graph), &quot;GRG&quot; (geometric random graph), &quot;KR&quot;
(k regular graph), &quot;WS&quot; (Watts-Strogatz model), and &quot;BA&quot; (Barabasi-Albert
model).</p>
</td></tr>
<tr><td><code id="graph.cem_+3A_k">k</code></td>
<td>
<p>an integer specifying the number of clusters.</p>
</td></tr>
<tr><td><code id="graph.cem_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of expectation-maximization steps to execute.</p>
</td></tr>
<tr><td><code id="graph.cem_+3A_ncores">ncores</code></td>
<td>
<p>the number of cores to be used for the parallel processing. The
default value is 1.</p>
</td></tr>
<tr><td><code id="graph.cem_+3A_bandwidth">bandwidth</code></td>
<td>
<p>string showing which criterion is used to choose the
bandwidth during the spectral density estimation. Choose between the
following criteria: &quot;Silverman&quot; (default), &quot;Sturges&quot;, &quot;bcv&quot;, &quot;ucv&quot; and &quot;SJ&quot;.
&quot;bcv&quot; is an abbreviation of biased cross-validation, while &quot;ucv&quot; means
unbiased cross-validation. &quot;SJ&quot;  implements the methods of Sheather &amp; Jones
(1991) to select the bandwidth using pilot estimation of derivatives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing three fields:
labels a vector of the same length of g containing the clusterization labels;
a vector containing the estimated parameters for the groups. It has the
length equals to <code>k</code>;
</p>


<h3>References</h3>

<p>Celeux, Gilles, and Gerard Govaert. &quot;Gaussian parsimonious clustering
models.&quot; Pattern recognition 28.5 (1995): 781-793.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(42)
 g &lt;- list()
 for(i in 1:2){
   g[[i]] &lt;- igraph::sample_gnp(n=10, p=0.5)
 }
 for(i in 3:4){
   g[[i]] &lt;- igraph::sample_gnp(n=10, p=1)
 }
 res &lt;- graph.cem(g, model="ER", k=2, max_iter=1, ncores=1)
 res
</code></pre>

<hr>
<h2 id='graph.cor.test'>Test for Association / Correlation Between Paired Samples of Graphs</h2><span id='topic+graph.cor.test'></span>

<h3>Description</h3>

<p><code>graph.cor.test</code> tests for association between paired samples of graphs,
using Spearman's rho correlation coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.cor.test(G1, G2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.cor.test_+3A_g1">G1</code></td>
<td>
<p>a list of undirected graphs (igraph type) or their adjacency
matrices. The adjacency matrix of an unweighted graph contains only 0s and
1s, while the weighted graph may have nonnegative real values that correspond
to the weights of the edges.</p>
</td></tr>
<tr><td><code id="graph.cor.test_+3A_g2">G2</code></td>
<td>
<p>a list of undirected graphs (igraph type) or their adjacency
matrices. The adjacency matrix of an unweighted graph contains only 0s and
1s, while the weighted graph may have nonnegative real values that correspond
to the weights of the edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>statistic</code></td>
<td>
<p> the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated measure of association 'rho'.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Fujita, A., Takahashi, D. Y., Balardin, J. B., Vidal, M. C. and Sato, J. R.
(2017) Correlation between graphs with an application to brain network
analysis. _Computational Statistics &amp; Data Analysis_ *109*, 76-92.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G1 &lt;- G2 &lt;- list()

p &lt;- MASS::mvrnorm(50, mu=c(0,0), Sigma=matrix(c(1, 0.5, 0.5, 1), 2, 2))

ma &lt;- max(p)
mi &lt;- min(p)
p[,1] &lt;- (p[,1] - mi)/(ma - mi)
p[,2] &lt;- (p[,2] - mi)/(ma - mi)

for (i in 1:50) {
  G1[[i]] &lt;- igraph::sample_gnp(50, p[i,1])
  G2[[i]] &lt;- igraph::sample_gnp(50, p[i,2])
}
graph.cor.test(G1, G2)

</code></pre>

<hr>
<h2 id='graph.entropy'>Graph spectral entropy</h2><span id='topic+graph.entropy'></span>

<h3>Description</h3>

<p><code>graph.entropy</code> returns the spectral entropy of an undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.entropy(G = NULL, bandwidth = "Silverman", eigenvalues = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.entropy_+3A_g">G</code></td>
<td>
<p>the undirected graph (igraph type) or its adjacency matrix. The
adjacency matrix of an unweighted graph contains only 0s and 1s, while the
weighted graph may have nonnegative real values that correspond to the
weights of the edges.</p>
</td></tr>
<tr><td><code id="graph.entropy_+3A_bandwidth">bandwidth</code></td>
<td>
<p>string showing which criterion is used to choose the
bandwidth during the spectral density estimation. Choose between the
following criteria: &quot;Silverman&quot; (default), &quot;Sturges&quot;, &quot;bcv&quot;, &quot;ucv&quot; and &quot;SJ&quot;.
&quot;bcv&quot; is an abbreviation of biased cross-validation, while &quot;ucv&quot; means
unbiased cross-validation. &quot;SJ&quot;  implements the methods of Sheather &amp; Jones
(1991) to select the bandwidth using pilot estimation of derivatives.</p>
</td></tr>
<tr><td><code id="graph.entropy_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p>optional parameter. It contains the eigenvalues of matrix
G. Then, if the eigenvalues of matrix G have already been computed, this
parameter can be used instead of G. If no value is passed, then the
eigenvalues of G will be computed by 'graph.entropy'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a real number corresponding to the graph spectral entropy.
</p>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;- igraph::sample_gnp(n=100, p=0.5)
entropy &lt;- graph.entropy(G)
entropy

</code></pre>

<hr>
<h2 id='graph.hclust'>Hierarchical cluster analysis on a list of graphs.</h2><span id='topic+graph.hclust'></span>

<h3>Description</h3>

<p>Given a list of graphs, <code>graph.hclust</code> builds a hierarchy of clusters
according to the Jensen-Shannon divergence between graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.hclust(G, k, method = "complete", bandwidth = "Silverman")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.hclust_+3A_g">G</code></td>
<td>
<p>a list of undirected graphs (igraph type) or their adjacency
matrices. The adjacency matrix of an unweighted graph contains only 0s and
1s, while the weighted graph may have nonnegative real values that correspond
to the weights of the edges.</p>
</td></tr>
<tr><td><code id="graph.hclust_+3A_k">k</code></td>
<td>
<p>the number of clusters.</p>
</td></tr>
<tr><td><code id="graph.hclust_+3A_method">method</code></td>
<td>
<p>the agglomeration method to be used. This should be (an
unambiguous abbreviation of) one of '&quot;ward.D&quot;', '&quot;ward.D2&quot;', '&quot;single&quot;',
'&quot;complete&quot;', '&quot;average&quot;' (= UPGMA), '&quot;mcquitty&quot;' (= WPGMA), '&quot;median&quot;'
(= WPGMC) or '&quot;centroid&quot;' (= UPGMC).</p>
</td></tr>
<tr><td><code id="graph.hclust_+3A_bandwidth">bandwidth</code></td>
<td>
<p>string showing which criterion is used to choose the
bandwidth during the spectral density estimation. Choose between the
following criteria: &quot;Silverman&quot; (default), &quot;Sturges&quot;, &quot;bcv&quot;, &quot;ucv&quot; and &quot;SJ&quot;.
&quot;bcv&quot; is an abbreviation of biased cross-validation, while &quot;ucv&quot; means
unbiased cross-validation. &quot;SJ&quot;  implements the methods of Sheather &amp; Jones
(1991) to select the bandwidth using pilot estimation of derivatives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>hclust</code></td>
<td>
<p>an object of class *hclust* which describes the tree produced
by the clustering process.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>the clustering labels for each graph.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G &lt;- list()
for (i in 1:5) {
  G[[i]] &lt;- igraph::sample_gnp(50, 0.5)
}
for (i in 6:10) {
  G[[i]] &lt;- igraph::sample_smallworld(1, 50, 8, 0.2)
}
for (i in 11:15) {
  G[[i]] &lt;- igraph::sample_pa(50, power = 1, directed = FALSE)
}
graph.hclust(G, 3)

</code></pre>

<hr>
<h2 id='graph.kmeans'>K-means for Graphs</h2><span id='topic+graph.kmeans'></span>

<h3>Description</h3>

<p><code>graph.kmeans</code> clusters graphs following a k-means algorithm based on the
Jensen-Shannon divergence between the spectral densities of the graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.kmeans(x, k, nstart = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.kmeans_+3A_x">x</code></td>
<td>
<p>a list containing the graphs or their adjacency matrices to be
clustered.</p>
</td></tr>
<tr><td><code id="graph.kmeans_+3A_k">k</code></td>
<td>
<p>an integer specifying the number of clusters.</p>
</td></tr>
<tr><td><code id="graph.kmeans_+3A_nstart">nstart</code></td>
<td>
<p>the number of trials of k-means clusterizations. The algorithm
returns the clusterization with the best silhouette.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length of x containing the clusterization
labels.
</p>


<h3>References</h3>

<p>MacQueen, James. &quot;Some methods for classification and analysis of
multivariate observations.&quot; Proceedings of the fifth Berkeley symposium on
mathematical statistics and probability. Vol. 1. No. 14. 1967.
</p>
<p>Lloyd, Stuart. &quot;Least squares quantization in PCM.&quot; IEEE transactions on
information theory 28.2 (1982): 129-137.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
g &lt;- list()
for(i in 1:5){
  g[[i]] &lt;- igraph::sample_gnp(30, p=0.2)
}
for(i in 6:10){
  g[[i]] &lt;- igraph::sample_gnp(30, p=0.5)
}
res &lt;- graph.kmeans(g, k=2, nstart=2)
res

</code></pre>

<hr>
<h2 id='graph.model.selection'>Graph model selection</h2><span id='topic+graph.model.selection'></span>

<h3>Description</h3>

<p><code>graph.model.selection</code> selects the graph model that best approximates the
observed graph according to the Graph Information Criterion (GIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.model.selection(
  G,
  models = NULL,
  parameters = NULL,
  eps = 0.01,
  bandwidth = "Silverman",
  eigenvalues = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.model.selection_+3A_g">G</code></td>
<td>
<p>the undirected graph (igraph type) or its adjacency matrix. The
adjacency matrix of an unweighted graph contains only 0s and 1s, while the
weighted graph may have nonnegative real values that correspond to the
weights of the edges.</p>
</td></tr>
<tr><td><code id="graph.model.selection_+3A_models">models</code></td>
<td>
<p>either a vector of strings, a list of functions or a list of
arrays describing graph models:
</p>
<p>A vector of strings containing some of the following models: &quot;ER&quot; (Erdos-Renyi
random graph), &quot;GRG&quot; (geometric random graph), &quot;KR&quot; (k regular random graph),
&quot;WS&quot; (Watts-Strogatz model), and &quot;BA&quot; (Barabasi-Albert model).
</p>
<p>A list of functions. Each function returns a graph (represented by its
adjacency matrix) generated by a graph model and has two arguments: the graph
size and the model parameter, in this order.
</p>
<p>A list of arrays. Each elememt of the list is a three-dimensional array
containing the precomputed spectrum of each model. Let M be a graph model.
For each parameter p considered for M, the array of model M contains the
eigenvalues of graphs randomly generated by M with parameter p. The position
(i,j,k) of the array contains the j-th eigenvalue of the k-th graph
that generated by M with the i-th parameter. The attribute 'rownames' of
the array corresponds to the parameters converted to string.
</p>
<p>If the argument &quot;models&quot; is NULL, then the &quot;ER&quot;, &quot;WS&quot;, and &quot;BA&quot; models will
be considered for the model selection.</p>
</td></tr>
<tr><td><code id="graph.model.selection_+3A_parameters">parameters</code></td>
<td>
<p>list of numeric vectors. Each vector contains the values
that will be considerated for the parameter estimation of the corresponding
model.
If the user does not provide the argument 'parameters', then default values
are used for the predefined models (&quot;ER&quot;, &quot;GRG&quot;, &quot;KR&quot;, &quot;WS&quot;, and &quot;BA&quot;).
The default vector corresponds to a sequence from
</p>
<p>0 to 1 with step 'eps' for the &quot;ER&quot; model (Erdos-Renyi random graph), in
which the parameter corresponds to the probability to connect a pair of
vertices;
</p>
<p>0 to sqrt(2) with step 'eps' for the &quot;GRG&quot; model (geometric random graph), in
which the parameter corresponds to the radius used to contruct the geometric
graph in a unit square;
</p>
<p>0 to 'n' with step 'n*eps' for the &quot;KR&quot; model (k regular random graph), in
which the parameter of the model corresponds to the degree 'k' of a regular
graph;
</p>
<p>0 to 1 with step 'eps' for the &quot;WS&quot; model (Watts-Strogatz model), in which
the parameter corresponds to the probability to reconnect a vertex;
</p>
<p>and 0 to 3 with step 'eps' for the &quot;BA&quot; model (Barabasi-Albert model), in
which the parameter corresponds to the scaling exponent.</p>
</td></tr>
<tr><td><code id="graph.model.selection_+3A_eps">eps</code></td>
<td>
<p>precision of the grid (default is 0.01).</p>
</td></tr>
<tr><td><code id="graph.model.selection_+3A_bandwidth">bandwidth</code></td>
<td>
<p>string showing which criterion is used to choose the
bandwidth during the spectral density estimation. Choose between the
following criteria: &quot;Silverman&quot; (default), &quot;Sturges&quot;, &quot;bcv&quot;, &quot;ucv&quot; and &quot;SJ&quot;.
&quot;bcv&quot; is an abbreviation of biased cross-validation, while &quot;ucv&quot; means
unbiased cross-validation. &quot;SJ&quot;  implements the methods of Sheather &amp; Jones
(1991) to select the bandwidth using pilot estimation of derivatives.</p>
</td></tr>
<tr><td><code id="graph.model.selection_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p>optional parameter. It contains the eigenvalues of matrix
G. Then, it can be used when the eigenvalues of G were previously computed.
If no value is passed, then the eigenvalues of G will be computed by
'graph.model.selection'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>the indice(s) or name(s) of the selected model(s), i. e. the
model(s) that minimize(s) the Graph Information Criterion (GIC).</p>
</td></tr>
<tr><td><code>estimates</code></td>
<td>
<p>a matrix in which each row corresponds to a model, the
column &quot;param&quot; corresponds to the parameter estimate, and the column &quot;GIC&quot;
corresponds to the Graph Information Criterion (GIC), i. e. the
Kullback-Leibler divergence between the observed graph and the model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example using an igraph object as input data
set.seed(1)
G &lt;- igraph::sample_gnp(n=30, p=0.5)

# Using strings to indicate the graph models
result1 &lt;- graph.model.selection(G, models=c("ER", "WS"), eps=0.5)
result1


## Using functions to describe the graph models
# Erdos-Renyi graph
model1 &lt;- function(n, p) {
  return(igraph::sample_gnp(n, p))
}
# Watts-Strogatz small-world graph
model2 &lt;- function(n, pr, K=8) {
  return(igraph::sample_smallworld(1, n, K, pr))
}
parameters &lt;- list(seq(0.01, 0.99, 0.49), seq(0.01, 0.99, 0.49))
result2 &lt;- graph.model.selection(G, list(model1, model2), parameters)
result2

</code></pre>

<hr>
<h2 id='graph.mult.scaling'>Multidimensional scaling of graphs</h2><span id='topic+graph.mult.scaling'></span>

<h3>Description</h3>

<p><code>graph.mult.scaling</code> performs multidimensional scaling of graphs. It
takes the Jensen-Shannon divergence between graphs (JS) and uses the
'cmdscale' function from the 'stats' package to obtain a set of points such
that the distances between the points are similar to JS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.mult.scaling(
  G,
  plot = TRUE,
  bandwidth = "Silverman",
  type = "n",
  main = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.mult.scaling_+3A_g">G</code></td>
<td>
<p>a list of undirected graphs (igraph type) or their adjacency
matrices. The adjacency matrix of an unweighted graph contains only 0s and
1s, while the weighted graph may have nonnegative real values that correspond
to the weights of the edges.</p>
</td></tr>
<tr><td><code id="graph.mult.scaling_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (default) the points chosen to represent the
Jensen-Shannon divergence between graphs are plotted.</p>
</td></tr>
<tr><td><code id="graph.mult.scaling_+3A_bandwidth">bandwidth</code></td>
<td>
<p>string showing which criterion is used to choose the
bandwidth during the spectral density estimation. Choose between the
following criteria: &quot;Silverman&quot; (default), &quot;Sturges&quot;, &quot;bcv&quot;, &quot;ucv&quot; and &quot;SJ&quot;.
&quot;bcv&quot; is an abbreviation of biased cross-validation, while &quot;ucv&quot; means
unbiased cross-validation. &quot;SJ&quot;  implements the methods of Sheather &amp; Jones
(1991) to select the bandwidth using pilot estimation of derivatives.</p>
</td></tr>
<tr><td><code id="graph.mult.scaling_+3A_type">type</code></td>
<td>
<p>what type of plot should be drawn. The defaut value is '&quot;n&quot;',
which indicates that the points will not be plotted (i. e. only the labels
of the graphs will be plotted).</p>
</td></tr>
<tr><td><code id="graph.mult.scaling_+3A_main">main</code></td>
<td>
<p>title of the plot (default value is &quot;&quot;).</p>
</td></tr>
<tr><td><code id="graph.mult.scaling_+3A_...">...</code></td>
<td>
<p>additional plotting parameters. See 'plot' function from the
'graphics' package for the complete list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix in which each column corresponds to a coordinate and each
row corresponds to a graph (point). Then, each row gives the coordinates of
the points chosen to represent the Jensen-Shannon divergence between graphs.
</p>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G &lt;- list()
for (i in 1:5) {
  G[[i]] &lt;- igraph::sample_gnp(50, 0.5)
}
for (i in 6:10) {
  G[[i]] &lt;- igraph::sample_smallworld(1, 50, 8, 0.2)
}
for (i in 11:15) {
  G[[i]] &lt;- igraph::sample_pa(50, power = 1, directed = FALSE)
}
graph.mult.scaling(G)

</code></pre>

<hr>
<h2 id='graph.param.estimator'>Graph parameter estimator</h2><span id='topic+graph.param.estimator'></span>

<h3>Description</h3>

<p><code>graph.param.estimator</code> estimates the parameter that best approximates
the model to the observed graph according to the Graph Information Criterion
(GIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.param.estimator(
  G,
  model,
  parameters = NULL,
  eps = 0.01,
  bandwidth = "Silverman",
  eigenvalues = NULL,
  spectra = NULL,
  classic = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.param.estimator_+3A_g">G</code></td>
<td>
<p>the undirected graph (igraph type) or its adjacency matrix. The
adjacency matrix of an unweighted graph contains only 0s and 1s, while the
weighted graph may have nonnegative real values that correspond to the
weights of the edges.</p>
</td></tr>
<tr><td><code id="graph.param.estimator_+3A_model">model</code></td>
<td>
<p>either a string or a function:
</p>
<p>A string that indicates one of the following models: &quot;ER&quot; (Erdos-Renyi random
graph), &quot;GRG&quot; (geometric random graph), &quot;KR&quot; (k regular random graph), &quot;WS&quot;
(Watts-Strogatz model), and &quot;BA&quot; (Barabasi-Albert model).
</p>
<p>A function that returns a graph (represented by its adjacency matrix)
generated by a graph model. It must contain two arguments: the first one
corresponds to the graph size and the second to the parameter of the model.</p>
</td></tr>
<tr><td><code id="graph.param.estimator_+3A_parameters">parameters</code></td>
<td>
<p>numeric vector containing the values that that will be
considered for the parameter estimation. The 'graph.param.estimator' will
return the element of 'parameter' that minimizes the Kullback-Leiber divergence.
If the user does not provide the argument 'parameters', and 'model' is an
array, then the values considered for the parameter estimation are the
rownames converted to a numeric vector. If 'model' is a string, then
default values are used for the predefined models (&quot;ER&quot;, &quot;GRG&quot;, &quot;KR&quot;, &quot;WS&quot;,
and &quot;BA&quot;). The default 'parameter' argument corresponds to a sequence from
</p>
<p>0 to 1 with step 'eps' for the &quot;ER&quot; model (Erdos-Renyi random graph), in
which the parameter corresponds to the probability to connect a pair of
vertices;
</p>
<p>0 to sqrt(2) with step 'eps' for the &quot;GRG&quot; model (geometric random graph), in
which the parameter corresponds to the radius used to construct the geometric
graph in a unit square;
</p>
<p>0 to 'n' with step 'n*eps' for the &quot;KR&quot; model (k regular random graph), in
which the parameter of the model corresponds to the degree 'k' of a regular
graph;
</p>
<p>0 to 1 with step 'eps' for the &quot;WS&quot; model (Watts-Strogatz model), in which
the parameter corresponds to the probability to reconnect a vertex;
</p>
<p>and 0 to 3 with step 'eps' for the &quot;BA&quot; model (Barabasi-Albert model), in
which the parameter corresponds to the scaling exponent.</p>
</td></tr>
<tr><td><code id="graph.param.estimator_+3A_eps">eps</code></td>
<td>
<p>precision of the grid (default is 0.01) when 'classic' is TRUE.</p>
</td></tr>
<tr><td><code id="graph.param.estimator_+3A_bandwidth">bandwidth</code></td>
<td>
<p>string showing which criterion is used to choose the
bandwidth during the spectral density estimation. Choose between the
following criteria: &quot;Silverman&quot; (default), &quot;Sturges&quot;, &quot;bcv&quot;, &quot;ucv&quot; and &quot;SJ&quot;.
&quot;bcv&quot; is an abbreviation of biased cross-validation, while &quot;ucv&quot; means
unbiased cross-validation. &quot;SJ&quot;  implements the methods of Sheather &amp; Jones
(1991) to select the bandwidth using pilot estimation of derivatives.</p>
</td></tr>
<tr><td><code id="graph.param.estimator_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p>optional parameter. It contains the eigenvalues of matrix
G. Then, it can be used when the eigenvalues of G were previously computed.
If no value is passed, then the eigenvalues of G will be computed by
'graph.param.estimator'.</p>
</td></tr>
<tr><td><code id="graph.param.estimator_+3A_spectra">spectra</code></td>
<td>
<p>optional parameter containing the precomputed spectrum of the
model. It is a three-dimensional array in which the first dimension
corresponds to all parameters that will be explored in the grid, the second
dimension has the same size of the given graph, and the third one corresponds
to graphs randomly generated by the model. Thus, the position (i,j,k)
contains the j-th eigenvalue of the k-th graph generated with the i-th
parameter. The attribute 'rownames' of the array corresponds to the
parameters converted to string. If spectra is NULL (default), then 'model' is
used to generate random graphs and their spectra are computed automatically.</p>
</td></tr>
<tr><td><code id="graph.param.estimator_+3A_classic">classic</code></td>
<td>
<p>logical. If FALSE (default) parameter is estimated using
ternary search. If TRUE parameter is estimated using grid search.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>the parameter estimate. For the &quot;ER&quot;, &quot;GRG&quot;, &quot;KR&quot;, &quot;WS&quot;, and &quot;BA&quot;
models, the parameter corresponds to the probability to connect a pair of
vertices, the radius used to construct the geometric graph in a unit square,
the degree k of a regular graph, the probability to reconnect a vertex, and
the scaling exponent, respectively.</p>
</td></tr>
<tr><td><code>KLD</code></td>
<td>
<p>the Kullback-Leibler
divergence between the observed graph and the graph model with the estimated
parameter.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G &lt;- igraph::sample_gnp(n=50, p=0.5)

# Using a string to indicate the graph model
result1 &lt;- graph.param.estimator(G, "ER", eps=0.25)
result1

## Not run: 
# Using a function to describe the graph model
# Erdos-Renyi graph
set.seed(1)
model &lt;- function(n, p) {
  return(igraph::sample_gnp(n, p))
}
result2 &lt;- graph.param.estimator(G, model,  seq(0.2, 0.8, 0.1))
result2

## End(Not run)

</code></pre>

<hr>
<h2 id='sp.anogva'>Semi-Parametric Analysis Of Graph Variability (ANOGVA)</h2><span id='topic+sp.anogva'></span>

<h3>Description</h3>

<p><code>sp.anogva</code> statistically tests whether two or more graphs are
generated by the same model and set of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp.anogva(
  G,
  model,
  maxBoot = 500,
  spectra = NULL,
  eps = 0.01,
  classic = FALSE,
  bandwidth = "Silverman"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp.anogva_+3A_g">G</code></td>
<td>
<p>a list of undirected graphs (igraph type) or their adjacency
matrices. The adjacency matrix of an unweighted graph contains only 0s and
1s, while the weighted graph may have nonnegative real values that correspond
to the weights of the edges.</p>
</td></tr>
<tr><td><code id="sp.anogva_+3A_model">model</code></td>
<td>
<p>A string that indicates one of the following models: &quot;ER&quot;
(Erdos-Renyi random graph model), &quot;GRG&quot; (geometric random graph model), &quot;WS&quot;
(Watts-Strogatz random graph model), and &quot;BA&quot; (Barabasi-Albert random graph
model).</p>
</td></tr>
<tr><td><code id="sp.anogva_+3A_maxboot">maxBoot</code></td>
<td>
<p>integer indicating the number of bootstrap resamples (default
is 500).</p>
</td></tr>
<tr><td><code id="sp.anogva_+3A_spectra">spectra</code></td>
<td>
<p>optional parameter containing the precomputed spectrum of the
model. It is a three-dimensional array in which the first dimension
corresponds to all parameters that will be explored in the parameter
estimation, the second dimension has the same size of the given graph, and
the third one corresponds to graphs randomly generated by the model. Thus,
the position (i,j,k) contains the j-th eigenvalue of the k-th graph generated
with the i-th parameter. The attribute 'rownames' of the array corresponds to
the parameters converted to string. If spectra is NULL (default), then
model' is used to generate random graphs and their spectra are computed
automatically.</p>
</td></tr>
<tr><td><code id="sp.anogva_+3A_eps">eps</code></td>
<td>
<p>(default is 0.01) precision of the grid when 'classic' = TRUE.</p>
</td></tr>
<tr><td><code id="sp.anogva_+3A_classic">classic</code></td>
<td>
<p>logical. If FALSE (default) parameter is estimated using
ternary search, if TRUE parameter is estimated using grid search.</p>
</td></tr>
<tr><td><code id="sp.anogva_+3A_bandwidth">bandwidth</code></td>
<td>
<p>string showing which criterion is used to choose the
bandwidth during the spectral density estimation. Choose between the
following criteria: &quot;Silverman&quot; (default), &quot;Sturges&quot;, &quot;bcv&quot;, &quot;ucv&quot; and &quot;SJ&quot;.
&quot;bcv&quot; is an abbreviation of biased cross-validation, while &quot;ucv&quot; means
unbiased cross-validation. &quot;SJ&quot;  implements the methods of Sheather &amp; Jones
(1991) to select the bandwidth using pilot estimation of derivatives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>parameters</code></td>
<td>
<p>a vector containing the estimated parameters for each
graph.</p>
</td></tr>
<tr><td><code>F.value</code></td>
<td>
<p>the F statistic of the test.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Andre Fujita, Eduardo Silva Lira, Suzana de Siqueira Santos, Silvia Yumi
Bando, Gabriela Eleuterio Soares, Daniel Yasumasa Takahashi. A
semi-parametric statistical test to compare complex networks, Journal of
Complex Networks, cnz028, https://doi.org/10.1093/comnet/cnz028
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(42)
model &lt;- "ER"
G &lt;- list()

# Under H0
G[[1]] &lt;- igraph::sample_gnp(50, 0.5)
G[[2]] &lt;- igraph::sample_gnp(50, 0.5)
G[[3]] &lt;- igraph::sample_gnp(50, 0.5)
result1 &lt;- sp.anogva(G, model, maxBoot = 300)
result1

# Under H1
G[[1]] &lt;- igraph::sample_gnp(50, 0.5)
G[[2]] &lt;- igraph::sample_gnp(50, 0.55)
G[[3]] &lt;- igraph::sample_gnp(50, 0.5)
result2 &lt;- sp.anogva(G, model, maxBoot = 300)
result2

## End(Not run)

</code></pre>

<hr>
<h2 id='takahashi.test'>Test for the Jensen-Shannon divergence between graphs</h2><span id='topic+takahashi.test'></span>

<h3>Description</h3>

<p><code>takahashi.test</code> tests whether two sets of graphs were generated by the same
random graph model.
This bootstrap test is based on the Jensen-Shannon (JS) divergence between
graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>takahashi.test(G1, G2, maxBoot = 1000, bandwidth = "Silverman")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="takahashi.test_+3A_g1">G1</code></td>
<td>
<p>a list of undirected graphs (igraph type) or their adjacency
matrices. The adjacency matrix of an unweighted graph contains only 0s and
1s, while the weighted graph may have nonnegative real values that correspond
to the weights of the edges.</p>
</td></tr>
<tr><td><code id="takahashi.test_+3A_g2">G2</code></td>
<td>
<p>a list of undirected graphs (igraph type) or their adjacency
matrices. The adjacency matrix of an unweighted graph contains only 0s and
1s, while the weighted graph may have nonnegative real values that correspond
to the weights of the edges.</p>
</td></tr>
<tr><td><code id="takahashi.test_+3A_maxboot">maxBoot</code></td>
<td>
<p>integer indicating the number of bootstrap resamplings.</p>
</td></tr>
<tr><td><code id="takahashi.test_+3A_bandwidth">bandwidth</code></td>
<td>
<p>string showing which criterion is used to choose the
bandwidth during the spectral density estimation. Choose between the
following criteria: &quot;Silverman&quot; (default), &quot;Sturges&quot;, &quot;bcv&quot;, &quot;ucv&quot; and &quot;SJ&quot;.
&quot;bcv&quot; is an abbreviation of biased cross-validation, while &quot;ucv&quot; means
unbiased cross-validation. &quot;SJ&quot;  implements the methods of Sheather &amp; Jones
(1991) to select the bandwidth using pilot estimation of derivatives.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two lists of graphs, 'G1' and 'G2', 'takahashi.test' tests H0: &quot;JS
divergence between 'G1' and 'G2' is 0&quot; against H1: &quot;JS divergence between
'G1' and 'G2' is larger than 0&quot;.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>JSD</code></td>
<td>
<p>the Jensen-Shannon divergence between 'G1' and 'G2'.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G1 &lt;- G2 &lt;- list()
for (i in 1:20) {
  G1[[i]] &lt;- igraph::sample_gnp(n=50, p=0.5)
}
for (i in 1:20) {
  G2[[i]] &lt;- igraph::sample_gnp(n=50, p=0.51)
}
result &lt;- takahashi.test(G1, G2, maxBoot=100)
result

</code></pre>

<hr>
<h2 id='tang.test'>Tang hypothesis testing for random graphs.</h2><span id='topic+tang.test'></span>

<h3>Description</h3>

<p>Given two independent finite-dimensional random dot product graphs,
<code>tang.test</code> tests if they have generating latent positions that are drawn
from the same distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tang.test(G1, G2, dim, sigma = NULL, maxBoot = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tang.test_+3A_g1">G1</code></td>
<td>
<p>the first undirected graph to be compared. Must be an igraph
object.</p>
</td></tr>
<tr><td><code id="tang.test_+3A_g2">G2</code></td>
<td>
<p>the second undirected graph to be compared. Must be an igraph
object.</p>
</td></tr>
<tr><td><code id="tang.test_+3A_dim">dim</code></td>
<td>
<p>dimension of the adjacency spectral embedding.</p>
</td></tr>
<tr><td><code id="tang.test_+3A_sigma">sigma</code></td>
<td>
<p>a real value indicating the kernel bandwidth. If NULL (default)
the bandwidth is calculated by the method.</p>
</td></tr>
<tr><td><code id="tang.test_+3A_maxboot">maxBoot</code></td>
<td>
<p>integer indicating the number of bootstrap resamples
(default is 200).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>T</code></td>
<td>
<p>the value of the test.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tang, Minh, et al. &quot;A nonparametric two-sample hypothesis testing problem for
random graphs.&quot; Bernoulli 23.3 (2017): 1599-1630.
</p>
<p>Tang, Minh, et al. &quot;A semiparametric two-sample hypothesis testing problem
for random graphs.&quot; Journal of Computational and Graphical Statistics 26.2
(2017): 344-354.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

## test under H0
lpvs &lt;- matrix(rnorm(200), 20, 10)
lpvs &lt;- apply(lpvs, 2, function(x) { return (abs(x)/sqrt(sum(x^2))) })
G1 &lt;- igraph::sample_dot_product(lpvs)
G2 &lt;- igraph::sample_dot_product(lpvs)
D1 &lt;- tang.test(G1, G2, 5)
D1

## test under H1
lpvs2 &lt;- matrix(pnorm(200), 20, 10)
lpvs2 &lt;- apply(lpvs2, 2, function(x) { return (abs(x)/sqrt(sum(x^2))) })
G2 &lt;- suppressWarnings(igraph::sample_dot_product(lpvs2))
D2 &lt;- tang.test(G1, G2, 5)
D2

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
