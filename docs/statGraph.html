<!DOCTYPE html><html lang="en"><head><title>Help for package statGraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {statGraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anogva'><p>Analysis Of Graph Variability (ANOGVA)</p></a></li>
<li><a href='#GIC'><p>Graph Information Criterion (GIC)</p></a></li>
<li><a href='#graph.acf'><p>Autocorrelation Function Estimation for Graphs</p></a></li>
<li><a href='#graph.cem'><p>Graph Clustering Expectation-Maximization (gCEM)</p></a></li>
<li><a href='#graph.cor.test'><p>Test for Association / Correlation Between Paired Samples of Graphs</p></a></li>
<li><a href='#graph.dist'><p>Distance Matrix on a List of Graphs</p></a></li>
<li><a href='#graph.entropy'><p>Graph Spectral Entropy</p></a></li>
<li><a href='#graph.hclust'><p>Hierarchical Cluster Analysis on a List of Graphs</p></a></li>
<li><a href='#graph.kmeans'><p>K-means for Graphs</p></a></li>
<li><a href='#graph.model.selection'><p>Graph Model Selection</p></a></li>
<li><a href='#graph.mult.scaling'><p>Multidimensional Scaling of Graphs</p></a></li>
<li><a href='#graph.param.estimator'><p>Graph Parameter Estimator</p></a></li>
<li><a href='#graph.spectral.density'><p>Graph Spectral Density</p></a></li>
<li><a href='#graph.takahashi.test'><p>Test for the Jensen-Shannon Divergence Between Graphs</p></a></li>
<li><a href='#sp.anogva'><p>Semi-parametric Analysis of Graph Variability (SP-ANOGVA)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Methods for Graphs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andre Fujita &lt;andrefujita@usp.br&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0), stats, graphics</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, MASS, rARPACK, cluster, foreach, parallel, doParallel,
methods, mvtnorm</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains statistical methods to analyze graphs, such as graph parameter estimation, 
    model selection based on the Graph Information Criterion, statistical tests to discriminate two or more populations of graphs, 
    correlation between graphs, and clustering of graphs.
    References: Takahashi et al. (2012) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0049949">doi:10.1371/journal.pone.0049949</a>&gt;, Fujita et al. (2017) &lt;<a href="https://doi.org/10.3389%2Ffnins.2017.00066">doi:10.3389/fnins.2017.00066</a>&gt;,
    Fujita et al. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2016.11.016">doi:10.1016/j.csda.2016.11.016</a>&gt;, Fujita et al. (2019) &lt;<a href="https://doi.org/10.1093%2Fcomnet%2Fcnz028">doi:10.1093/comnet/cnz028</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.ime.usp.br/~fujita/software.html">https://www.ime.usp.br/~fujita/software.html</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-01</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-01 16:37:58 UTC; grover</td>
</tr>
<tr>
<td>Author:</td>
<td>Grover E. Castro Guzman [aut],
  Diogo R. da Costa [aut],
  Taiane C. Ramos [aut],
  Suzana S. Santos [aut],
  Eduardo S. Lira [aut],
  Andre Fujita [aut, cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-01 21:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anogva'>Analysis Of Graph Variability (ANOGVA)</h2><span id='topic+anogva'></span>

<h3>Description</h3>

<p><code>anogva</code> statistically tests whether two or more sets of graphs are generated
by the same random graph model. It is a generalization of the <code>takahashi.test</code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anogva(Graphs, labels, maxBoot = 1000, dist = "KL", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anogva_+3A_graphs">Graphs</code></td>
<td>
<p>a list of undirected graphs.
If each graph has the  attribute <code>eigenvalues</code> containing its
eigenvalues , such values will be used to
compute their spectral density.</p>
</td></tr>
<tr><td><code id="anogva_+3A_labels">labels</code></td>
<td>
<p>an array of integers indicating the labels of each graph.</p>
</td></tr>
<tr><td><code id="anogva_+3A_maxboot">maxBoot</code></td>
<td>
<p>integer indicating the number of bootstrap resamplings (default <code>1000</code>).</p>
</td></tr>
<tr><td><code id="anogva_+3A_dist">dist</code></td>
<td>
<p>string indicating if you want to use the 'KL' (default), 'JS' , 'L1' or 'L2'
distances. 'KL' means Kullback-Leibler divergence. 'JS' means Jensen-Shannon divergence.</p>
</td></tr>
<tr><td><code id="anogva_+3A_...">...</code></td>
<td>
<p>Other relevant parameters for <code><a href="#topic+graph.spectral.density">graph.spectral.density</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic:</code></td>
<td>
<p> the statistic of the test.</p>
</td></tr>
<tr><td><code>p.value:</code></td>
<td>
<p> the p-value of the test.</p>
</td></tr>
<tr><td><code>method:</code></td>
<td>
<p> a string indicating the used method.</p>
</td></tr>
<tr><td><code>data.name:</code></td>
<td>
<p>a string with the data's name(s).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Fujita, A., Vidal, M. C. and Takahashi, D. Y. (2017) A Statistical Method to
Distinguish Functional Brain Networks. _Front. Neurosci._, *11*, 66.
doi:10.3389/fnins.2017.00066.
</p>
<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
g1 &lt;- g2 &lt;- g3 &lt;- list()
for (i in 1:20) {
  g1[[i]] &lt;- igraph::sample_gnp(50, 0.50)
  g2[[i]] &lt;- igraph::sample_gnp(50, 0.50)
  g3[[i]] &lt;- igraph::sample_gnp(50, 0.52)
}
G &lt;- c(g1, g2, g3)
label &lt;- c(rep(1,20),rep(2,20),rep(3,20))
result &lt;- anogva(G, label, maxBoot=50)
result

</code></pre>

<hr>
<h2 id='GIC'>Graph Information Criterion (GIC)</h2><span id='topic+GIC'></span>

<h3>Description</h3>

<p><code>GIC</code> returns the Kullback-Leibler divergence, L1 or L2 distance between an
undirected graph and a given graph model using the exact or degree-based spectral densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GIC(Graph, model, p = NULL, dist = "KL", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GIC_+3A_graph">Graph</code></td>
<td>
<p>the undirected graph (igraph object).
If <code>Graph</code> has the  attribute <code>eigenvalues</code> containing
the eigenvalues of <code>Graph</code>, such values will be used to
compute its spectral density.</p>
</td></tr>
<tr><td><code id="GIC_+3A_model">model</code></td>
<td>
<p>either a list, a string, or a function describing a
graph model:
</p>
<p>A list that represents the spectral density of a model. It contains the
components 'x' and 'y', which are numeric vectors of the same size. The 'x'
component contains the points at which the density was computed and the 'y'
component contains the observed density.
</p>
<p>A string that indicates one of the following models: 'ER' (Erdos-Renyi random
graph), 'GRG' (geometric random graph), 'KR' (k regular random graph), 'WS'
(Watts-Strogatz model), and 'BA' (Barab√°si-Albert model). When the argument
<code>model</code> is a string, the user must also provide the model parameter by using
the argument <code>p</code>.
</p>
<p>A function that returns a graph (igraph object)
generated by a graph model. It must contain two arguments: the first one
corresponds to the graph size and the second to the parameter of the model.
The model parameter will be provided by the argument <code>p</code> of the <code>GIC</code>
function.</p>
</td></tr>
<tr><td><code id="GIC_+3A_p">p</code></td>
<td>
<p>the model parameter. The user must provide a valid parameter if the
argument <code>model</code> is a string or a function.
For the predefined models ('ER', 'GRG', 'KR', 'WS', and 'BA'), the parameter
the probability to connect a pair of vertices, for the 'ER' model
(Erdos-Renyi random graph);
</p>
<p>the radius used to construct the geometric graph in a unit square, for the
'GRG' model (geometric random graph);
</p>
<p>the degree <code>k</code> of a regular graph, for the 'KR' model (k regular random
graph);
</p>
<p>the probability to reconnect a vertex, for the 'WS' model (Watts-Strogatz
model);
</p>
<p>and the scaling exponent, for the 'BA' model (Barab√°si-Albert model).</p>
</td></tr>
<tr><td><code id="GIC_+3A_dist">dist</code></td>
<td>
<p>string indicating if you want to use the 'KL' (default), 'L1' or 'L2'
distances. 'KL' means Kullback-Leibler divergence.</p>
</td></tr>
<tr><td><code id="GIC_+3A_...">...</code></td>
<td>
<p>Other relevant parameters for <code><a href="#topic+graph.spectral.density">graph.spectral.density</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'statGraph' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method:</code></td>
<td>
<p> a string indicating the used method.</p>
</td></tr>
<tr><td><code>info:</code></td>
<td>
<p> a string showing details about the method.</p>
</td></tr>
<tr><td><code>data.name:</code></td>
<td>
<p> a string with the data's name(s).</p>
</td></tr>
<tr><td><code>value:</code></td>
<td>
<p> a real number corresponding to the Kullback-Leibler divergence, L1, or
L2 distance between the observed graph and the graph model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G &lt;- igraph::sample_gnp(n=50, p=0.5)

# Using a string to indicate the graph model
result1 &lt;- GIC(G, 'ER', 0.5)
result1

# Using a function to describe the graph model
# Erdos-Renyi graph
model &lt;- function(n, p) {
   return (igraph::sample_gnp(n, p))
}
result2 &lt;- GIC(G, model, 0.5)
result2

</code></pre>

<hr>
<h2 id='graph.acf'>Autocorrelation Function Estimation for Graphs</h2><span id='topic+graph.acf'></span>

<h3>Description</h3>

<p>The function <code>graph.acf</code> computes estimates of the autocorrelation
function for graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.acf(Graphs, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.acf_+3A_graphs">Graphs</code></td>
<td>
<p>a list of undirected graphs.
If each graph has the  attribute <code>eigenvalues</code> containing its
eigenvalues , such values will be used to
compute their spectral density.</p>
</td></tr>
<tr><td><code id="graph.acf_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) the graph.acf is plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class acf.
</p>


<h3>References</h3>

<p>Fujita, A., Takahashi, D. Y., Balardin, J. B., Vidal, M. C. and Sato, J. R.
(2017) Correlation between graphs with an application to brain network
analysis. _Computational Statistics &amp; Data Analysis_ *109*, 76-92.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G &lt;- list()
p &lt;- array(0, 100)
p[1:3] &lt;- rnorm(3)
for (t in 4:100) {
  p[t] &lt;- 0.5*p[t-3] + rnorm(1)
}
ma &lt;- max(p)
mi &lt;- min(p)
p &lt;- (p - mi)/(ma-mi)
for (t in 1:100) {
  G[[t]] &lt;- igraph::sample_gnp(100, p[t])
}
graph.acf(G, plot=TRUE)

</code></pre>

<hr>
<h2 id='graph.cem'>Graph Clustering Expectation-Maximization (gCEM)</h2><span id='topic+graph.cem'></span>

<h3>Description</h3>

<p><code>graph.cem</code> clusters graphs following an expectation-maximization algorithm based
on the Kullback-Leibler divergence between the spectral densities of the
graph and of the random graph model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.cem(Graphs, model, k, max_iter = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.cem_+3A_graphs">Graphs</code></td>
<td>
<p>a list of undirected graphs.
If each graph has the  attribute <code>eigenvalues</code> containing its
eigenvalues , such values will be used to
compute their spectral density.</p>
</td></tr>
<tr><td><code id="graph.cem_+3A_model">model</code></td>
<td>
<p>a string that indicates one of the following random graph
models: 'ER' (Erdos-Renyi random graph), 'GRG' (geometric random graph), 'KR'
(k regular graph), 'WS' (Watts-Strogatz model), and 'BA' (Barab√°si-Albert
model).</p>
</td></tr>
<tr><td><code id="graph.cem_+3A_k">k</code></td>
<td>
<p>an integer specifying the number of clusters.</p>
</td></tr>
<tr><td><code id="graph.cem_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of expectation-maximization steps to execute.</p>
</td></tr>
<tr><td><code id="graph.cem_+3A_...">...</code></td>
<td>
<p>Other relevant parameters for <code><a href="#topic+graph.param.estimator">graph.param.estimator</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'statGraph' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method:</code></td>
<td>
<p> a string indicating the used method.</p>
</td></tr>
<tr><td><code>info:</code></td>
<td>
<p> a string showing details about the method.</p>
</td></tr>
<tr><td><code>data.name:</code></td>
<td>
<p> a string with the data's name(s).</p>
</td></tr>
<tr><td><code>cluster:</code></td>
<td>
<p> a vector of the same length of <code>Graphs</code> containing the clusterization
labels.</p>
</td></tr>
<tr><td><code>parameters:</code></td>
<td>
<p> a vector containing the estimated parameters for the groups.
It has the length equals to <code>k</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Celeux, Gilles, and Gerard Govaert. 'Gaussian parsimonious clustering
models.' Pattern recognition 28.5 (1995): 781-793.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 set.seed(1)
 g &lt;- list()
 for(i in 1:2){
   g[[i]] &lt;- igraph::sample_gnp(n=10, p=0.5)
 }
 for(i in 3:4){
   g[[i]] &lt;- igraph::sample_gnp(n=10, p=1)
 }
 res &lt;- graph.cem(g, model='ER', k=2, max_iter=1,eps=0.1)
 res
 
</code></pre>

<hr>
<h2 id='graph.cor.test'>Test for Association / Correlation Between Paired Samples of Graphs</h2><span id='topic+graph.cor.test'></span>

<h3>Description</h3>

<p><code>graph.cor.test</code> tests for association between paired samples of graphs,
using Spearman's rho correlation coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.cor.test(Graphs1, Graphs2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.cor.test_+3A_graphs1">Graphs1</code></td>
<td>
<p>a list of undirected graphs.
If each graph has the  attribute <code>eigenvalues</code> containing its
eigenvalues , such values will be used to
compute their spectral density.</p>
</td></tr>
<tr><td><code id="graph.cor.test_+3A_graphs2">Graphs2</code></td>
<td>
<p>a list of undirected graphs.
If each graph has the  attribute <code>eigenvalues</code> containing its
eigenvalues , such values will be used to
compute their spectral density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic:</code></td>
<td>
<p> the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value:</code></td>
<td>
<p> the p-value of the test.</p>
</td></tr>
<tr><td><code>method:</code></td>
<td>
<p> a string indicating the used method.</p>
</td></tr>
<tr><td><code>data.name:</code></td>
<td>
<p> a string with the data's name(s).</p>
</td></tr>
<tr><td><code>estimates:</code></td>
<td>
<p> the estimated measure of association 'rho'.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Fujita, A., Takahashi, D. Y., Balardin, J. B., Vidal, M. C. and Sato, J. R.
(2017) Correlation between graphs with an application to brain network
analysis. _Computational Statistics &amp; Data Analysis_ *109*, 76-92.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)

set.seed(1)
G1 &lt;- G2 &lt;- list()

p &lt;- mvtnorm::rmvnorm(50, mean=c(0,0), sigma=matrix(c(1, 0.5, 0.5, 1), 2, 2))

ma &lt;- max(p)
mi &lt;- min(p)
p[,1] &lt;- (p[,1] - mi)/(ma - mi)
p[,2] &lt;- (p[,2] - mi)/(ma - mi)

for (i in 1:50) {
  G1[[i]] &lt;- igraph::sample_gnp(50, p[i,1])
  G2[[i]] &lt;- igraph::sample_gnp(50, p[i,2])
}
graph.cor.test(G1, G2)

</code></pre>

<hr>
<h2 id='graph.dist'>Distance Matrix on a List of Graphs</h2><span id='topic+graph.dist'></span>

<h3>Description</h3>

<p>Given a list of graphs, <code>graph.dist</code> builds a distance matrix
according to the Jensen-Shannon divergence, L2 norm, or L1 norm
between the spectral density of the graphs graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.dist(Graphs, dist = "JS", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.dist_+3A_graphs">Graphs</code></td>
<td>
<p>a list of undirected graphs.
If each graph has the  attribute <code>eigenvalues</code> containing its
eigenvalues , such values will be used to
compute their spectral density.</p>
</td></tr>
<tr><td><code id="graph.dist_+3A_dist">dist</code></td>
<td>
<p>string indicating if you want to use the 'JS' (default), 'L1' or 'L2'
distances. 'JS' means Jensen-Shannon divergence.</p>
</td></tr>
<tr><td><code id="graph.dist_+3A_...">...</code></td>
<td>
<p>Other relevant parameters for <code><a href="#topic+graph.spectral.density">graph.spectral.density</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
g &lt;- list()
for(i in 1:5){
  g[[i]] &lt;- igraph::sample_gnp(n=50, p=0.1)
}
for(i in 6:10){
  g[[i]] &lt;- igraph::sample_gnp(n=50, p=0.5)
}
for(i in 11:15){
 g[[i]] &lt;- igraph::sample_gnp(n=50, p=0.9)
}
graph.dist(g, dist = 'JS')


</code></pre>

<hr>
<h2 id='graph.entropy'>Graph Spectral Entropy</h2><span id='topic+graph.entropy'></span>

<h3>Description</h3>

<p><code>graph.entropy</code> returns the spectral entropy of an undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.entropy(Graph, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.entropy_+3A_graph">Graph</code></td>
<td>
<p>the undirected graph (igraph object).
If <code>Graph</code> has the  attribute <code>eigenvalues</code> containing
the eigenvalues of <code>Graph</code>, such values will be used to
compute its spectral density.</p>
</td></tr>
<tr><td><code id="graph.entropy_+3A_...">...</code></td>
<td>
<p>Other relevant parameters for <code><a href="#topic+graph.spectral.density">graph.spectral.density</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'statGraph' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method:</code></td>
<td>
<p> a string indicating the used method.</p>
</td></tr>
<tr><td><code>info:</code></td>
<td>
<p> a string showing details about the method.</p>
</td></tr>
<tr><td><code>data.name:</code></td>
<td>
<p> a string with the data's name(s).</p>
</td></tr>
<tr><td><code>entropy:</code></td>
<td>
<p> a real number corresponding to the graph spectral entropy.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G &lt;- igraph::sample_gnp(n=100, p=0.5)
entropy &lt;- graph.entropy(Graph = G)
entropy

</code></pre>

<hr>
<h2 id='graph.hclust'>Hierarchical Cluster Analysis on a List of Graphs</h2><span id='topic+graph.hclust'></span>

<h3>Description</h3>

<p>Given a list of graphs, <code>graph.hclust</code> builds a hierarchy of clusters
according to the Jensen-Shannon divergence between graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.hclust(Graphs, k = NULL, clus_method = "complete", dist = "JS", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.hclust_+3A_graphs">Graphs</code></td>
<td>
<p>a list of undirected graphs.
If each graph has the  attribute <code>eigenvalues</code> containing its
eigenvalues , such values will be used to
compute their spectral density.</p>
</td></tr>
<tr><td><code id="graph.hclust_+3A_k">k</code></td>
<td>
<p>the number of clusters. If NULL, it won't return the computed clustering.</p>
</td></tr>
<tr><td><code id="graph.hclust_+3A_clus_method">clus_method</code></td>
<td>
<p>the agglomeration method to be used. This should be (an
unambiguous abbreviation of) one of &rdquo;ward.D&rdquo;, &rdquo;ward.D2&rdquo;, &rdquo;single&rdquo;,
&rdquo;complete&rdquo;, &rdquo;average&rdquo; (= UPGMA), &rdquo;mcquitty&rdquo; (= WPGMA), &rdquo;median&rdquo;
(= WPGMC) or &rdquo;centroid&rdquo; (= UPGMC).</p>
</td></tr>
<tr><td><code id="graph.hclust_+3A_dist">dist</code></td>
<td>
<p>string indicating if you want to use the 'JS' (default), 'L1' or 'L2'
distances. 'JS' means Jensen-Shannon divergence.</p>
</td></tr>
<tr><td><code id="graph.hclust_+3A_...">...</code></td>
<td>
<p>Other relevant parameters for <code><a href="#topic+graph.spectral.density">graph.spectral.density</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'statGraph' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method:</code></td>
<td>
<p> a string indicating the used method.</p>
</td></tr>
<tr><td><code>info:</code></td>
<td>
<p> a string showing details about the method.</p>
</td></tr>
<tr><td><code>data.name:</code></td>
<td>
<p> a string with the data's name(s).</p>
</td></tr>
<tr><td><code>cluster:</code></td>
<td>
<p> a vector of the same length of <code>Graphs</code> containing the clusterization
labels.</p>
</td></tr>
<tr><td><code>hclust:</code></td>
<td>
<p> a 'hclust' object.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G &lt;- list()
for (i in 1:5) {
  G[[i]] &lt;- igraph::sample_gnp(50, 0.5)
}
for (i in 6:10) {
  G[[i]] &lt;- igraph::sample_smallworld(1, 50, 8, 0.2)
}
for (i in 11:15) {
  G[[i]] &lt;- igraph::sample_pa(50, power = 1, directed = FALSE)
}
graph.hclust(G, 3)

</code></pre>

<hr>
<h2 id='graph.kmeans'>K-means for Graphs</h2><span id='topic+graph.kmeans'></span>

<h3>Description</h3>

<p><code>graph.kmeans</code> clusters graphs following a k-means algorithm based on the
Jensen-Shannon divergence between the spectral densities of the graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.kmeans(Graphs, k, nstart = 2, dist = "JS", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.kmeans_+3A_graphs">Graphs</code></td>
<td>
<p>a list of undirected graphs.
If each graph has the  attribute <code>eigenvalues</code> containing its
eigenvalues , such values will be used to
compute their spectral density.</p>
</td></tr>
<tr><td><code id="graph.kmeans_+3A_k">k</code></td>
<td>
<p>an integer specifying the number of clusters.</p>
</td></tr>
<tr><td><code id="graph.kmeans_+3A_nstart">nstart</code></td>
<td>
<p>the number of trials of k-means clusterizations. The algorithm
returns the clusterization with the best silhouette.</p>
</td></tr>
<tr><td><code id="graph.kmeans_+3A_dist">dist</code></td>
<td>
<p>string indicating if you want to use the 'JS' (default), 'L1' or 'L2'
distances. 'JS' means Jensen-Shannon divergence.</p>
</td></tr>
<tr><td><code id="graph.kmeans_+3A_...">...</code></td>
<td>
<p>Other relevant parameters for <code><a href="#topic+graph.spectral.density">graph.spectral.density</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'statGraph' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method:</code></td>
<td>
<p> a string indicating the used method.</p>
</td></tr>
<tr><td><code>info:</code></td>
<td>
<p> a string showing details about the method.</p>
</td></tr>
<tr><td><code>data.name:</code></td>
<td>
<p> a string with the data's name(s).</p>
</td></tr>
<tr><td><code>cluster:</code></td>
<td>
<p> a vector of the same length of <code>Graphs</code> containing the clusterization
labels.</p>
</td></tr>
<tr><td><code>centers:</code></td>
<td>
<p>a list containing the centroids of each cluster.</p>
</td></tr>
</table>


<h3>References</h3>

<p>MacQueen, James. 'Some methods for classification and analysis of
multivariate observations.' Proceedings of the fifth Berkeley symposium on
mathematical statistics and probability. Vol. 1. No. 14. 1967.
</p>
<p>Lloyd, Stuart. 'Least squares quantization in PCM.' IEEE transactions on
information theory 28.2 (1982): 129-137.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
g &lt;- list()
for(i in 1:5){
  g[[i]] &lt;- igraph::sample_gnp(30, p=0.2)
}
for(i in 6:10){
  g[[i]] &lt;- igraph::sample_gnp(30, p=0.5)
}
res &lt;- graph.kmeans(g, k=2, nstart=2)
res

</code></pre>

<hr>
<h2 id='graph.model.selection'>Graph Model Selection</h2><span id='topic+graph.model.selection'></span>

<h3>Description</h3>

<p><code>graph.model.selection</code> selects the graph model that best approximates the
observed graph according to the Graph Information Criterion (GIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.model.selection(Graph, models = NULL, parameters = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.model.selection_+3A_graph">Graph</code></td>
<td>
<p>the undirected graph (igraph object).
If <code>Graph</code> has the  attribute <code>eigenvalues</code> containing
the eigenvalues of <code>Graph</code>, such values will be used to
compute its spectral density.</p>
</td></tr>
<tr><td><code id="graph.model.selection_+3A_models">models</code></td>
<td>
<p>either a vector of strings, or a list of functions:
</p>
<p>A vector of strings containing some of the following models: 'ER' (Erdos-Renyi
random graph), 'GRG' (geometric random graph), 'KR' (k regular random graph),
'WS' (Watts-Strogatz model), and 'BA' (Barab√°si-Albert model).
</p>
<p>A list of functions. Each function returns a graph (igraph object)
generated by a graph model and has two arguments: the graph
size and the model parameter, in this order.
</p>
<p>If the argument <code>models</code> is <code>NULL</code>, then the 'ER', 'WS', and 'BA' models will
be considered for the model selection.</p>
</td></tr>
<tr><td><code id="graph.model.selection_+3A_parameters">parameters</code></td>
<td>
<p>list of numeric vectors or list of lists. If a list of numeric vectors is given,
then each vector contains the values that will be considered for the parameter estimation of the
corresponding model. If a list of lists is given, then each list contains <code>lo</code> and <code>hi</code> elements
that indicate the model's parameter search interval &lt;<code>lo</code>,<code>hi</code>&gt;.
If the user does not provide the argument <code>parameters</code>, then default values
are used for the predefined models ('ER', 'GRG', 'KR', 'WS', and 'BA') as done in <code>graph.param.estimator</code>.</p>
</td></tr>
<tr><td><code id="graph.model.selection_+3A_...">...</code></td>
<td>
<p>Other relevant parameters for <code><a href="#topic+graph.param.estimator">graph.param.estimator</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'statGraph' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method:</code></td>
<td>
<p> a string indicating the used method.</p>
</td></tr>
<tr><td><code>info:</code></td>
<td>
<p> a string showing details about the method.</p>
</td></tr>
<tr><td><code>model:</code></td>
<td>
<p> the indice(s) or name(s) of the selected model(s), i. e. the
model(s) that minimize(s) the Graph Information Criterion (GIC).</p>
</td></tr>
<tr><td><code>estimates:</code></td>
<td>
<p> a matrix in which each row corresponds to a model, the
column 'param' corresponds to the parameter estimate, and the column 'GIC'
corresponds to the Graph Information Criterion (GIC), i. e. the
distance measure (Kullback-Leibler divergence by default) between the observed graph and the model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example using an igraph object as input data
set.seed(1)
G &lt;- igraph::sample_gnp(n=30, p=0.5)

# Using strings to indicate the graph models
result1 &lt;- graph.model.selection(G, models=c('ER', 'WS'), eps = 0.5)
result1


## Using functions to describe the graph models
# Erdos-Renyi graph
model1 &lt;- function(n, p) {
  return(igraph::sample_gnp(n, p))
}
# Watts-Strogatz small-world graph
model2 &lt;- function(n, pr, K=8) {
  return(igraph::sample_smallworld(1, n, K, pr))
}
parameters &lt;- list(seq(0.01, 0.99, 0.49), seq(0.01, 0.99, 0.49))
result2 &lt;- graph.model.selection(G, list(model1, model2), parameters)
result2


</code></pre>

<hr>
<h2 id='graph.mult.scaling'>Multidimensional Scaling of Graphs</h2><span id='topic+graph.mult.scaling'></span>

<h3>Description</h3>

<p><code>graph.mult.scaling</code> performs multidimensional scaling of graphs. It
takes the Jensen-Shannon divergence between graphs (JS) and uses the
<code>cmdscale</code> function from the <code>stats</code> package to obtain a set of points such
that the distances between the points are similar to JS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.mult.scaling(
  Graphs,
  plot = TRUE,
  type = "n",
  dist = "JS",
  main = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.mult.scaling_+3A_graphs">Graphs</code></td>
<td>
<p>a list of undirected graphs.
If each graph has the  attribute <code>eigenvalues</code> containing its
eigenvalues , such values will be used to
compute their spectral density.</p>
</td></tr>
<tr><td><code id="graph.mult.scaling_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) the points chosen to represent the
Jensen-Shannon divergence between graphs are plotted.</p>
</td></tr>
<tr><td><code id="graph.mult.scaling_+3A_type">type</code></td>
<td>
<p>what type of plot should be drawn. The default value is <code>'n'</code>,
which indicates that the points will not be plotted (i. e. only the labels
of the graphs will be plotted).</p>
</td></tr>
<tr><td><code id="graph.mult.scaling_+3A_dist">dist</code></td>
<td>
<p>string indicating if you want to use the 'JS' (default), 'L1' or 'L2'
distances. 'JS' means Jensen-Shannon divergence.</p>
</td></tr>
<tr><td><code id="graph.mult.scaling_+3A_main">main</code></td>
<td>
<p>title of the plot (default value is &rdquo;).</p>
</td></tr>
<tr><td><code id="graph.mult.scaling_+3A_...">...</code></td>
<td>
<p>additional parameters for <code><a href="#topic+graph.spectral.density">graph.spectral.density</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'statGraph' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method:</code></td>
<td>
<p> a string indicating the used method.</p>
</td></tr>
<tr><td><code>info:</code></td>
<td>
<p> a string showing details about the method.</p>
</td></tr>
<tr><td><code>data.name:</code></td>
<td>
<p> a string with the data's name(s).</p>
</td></tr>
<tr><td><code>values:</code></td>
<td>
<p> a matrix in which each column corresponds to a coordinate and each
row corresponds to a graph (point). Then, each row gives the coordinates of
the points chosen to represent the Jensen-Shannon divergence (by default), L1, or
L2 distance between graphs.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G &lt;- list()
for (i in 1:5) {
  G[[i]] &lt;- igraph::sample_gnp(50, 0.5)
}
for (i in 6:10) {
  G[[i]] &lt;- igraph::sample_smallworld(1, 50, 8, 0.2)
}
for (i in 11:15) {
  G[[i]] &lt;- igraph::sample_pa(50, power = 1, directed = FALSE)
}
graph.mult.scaling(G)

</code></pre>

<hr>
<h2 id='graph.param.estimator'>Graph Parameter Estimator</h2><span id='topic+graph.param.estimator'></span>

<h3>Description</h3>

<p><code>graph.param.estimator</code> estimates the parameter that best approximates
the model to the observed graph according to the Graph Information Criterion
(GIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.param.estimator(
  Graph,
  model,
  interval = NULL,
  eps = 0.01,
  search = "grid",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.param.estimator_+3A_graph">Graph</code></td>
<td>
<p>the undirected graph (igraph object).
If <code>Graph</code> has the  attribute 'eigenvalues' containing
the eigenvalues of <code>Graph</code>, such values will be used to
compute spectral density of the graph.</p>
</td></tr>
<tr><td><code id="graph.param.estimator_+3A_model">model</code></td>
<td>
<p>either a string or a function:
</p>
<p>A string that indicates one of the following models: 'ER' (Erdos-Renyi random
graph), 'GRG' (geometric random graph), 'KR' (k regular random graph), 'WS'
(Watts-Strogatz model), and 'BA' (Barab√°si-Albert model).
</p>
<p>A function that returns a graph (represented by its adjacency matrix)
generated by a graph model. It must contain two arguments: the first one
corresponds to the graph size and the second to the parameter of the model.</p>
</td></tr>
<tr><td><code id="graph.param.estimator_+3A_interval">interval</code></td>
<td>
<p>numeric vector containing the values that will be
considered for the parameter estimation, or a list containing 'lo' and 'hi'
that indicates the model's parameter search interval &lt;<code>lo</code>,<code>hi</code>&gt;.
The <code>graph.param.estimator</code> will return the element of 'parameter' that
minimizes the GIC.
If the user does not provide the argument <code>parameters</code>, and <code>model</code> is a string,
then default values are used for the predefined models ('ER', 'GRG', 'KR', 'WS',
and 'BA'). The default <code>parameter</code> argument corresponds to a sequence from
</p>
<p>0 to 1 with step <code>eps</code> for the 'ER' model (Erdos-Renyi random graph), in
which the parameter corresponds to the probability to connect a pair of
vertices;
</p>
<p>0 to sqrt(2) with step <code>eps</code> for the 'GRG' model (geometric random graph), in
which the parameter corresponds to the radius used to construct the geometric
graph in a unit square;
</p>
<p>0 to 'n' with step <code>n*eps</code> for the 'KR' model (k regular random graph), in
which the parameter of the model corresponds to the degree <code>k</code> of a regular
graph;
</p>
<p>0 to 1 with step <code>eps</code> for the 'WS' model (Watts-Strogatz model), in which
the parameter corresponds to the probability to reconnect a vertex;
</p>
<p>and 0 to 3 with step <code>eps</code> for the 'BA' model (Barab√°si-Albert model), in
which the parameter corresponds to the scaling exponent.</p>
</td></tr>
<tr><td><code id="graph.param.estimator_+3A_eps">eps</code></td>
<td>
<p>precision of the grid and ternary search (default is <code>0.01</code>).</p>
</td></tr>
<tr><td><code id="graph.param.estimator_+3A_search">search</code></td>
<td>
<p>string that indicates the search algorithm to find
the parameter with the smallest GIC. If 'grid' (default) parameter is
estimated using grid search, and only works when method is not 'fast'.
If 'ternary' parameter is estimated using ternary search.</p>
</td></tr>
<tr><td><code id="graph.param.estimator_+3A_...">...</code></td>
<td>
<p>Other relevant parameters for <code><a href="#topic+GIC">GIC</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'statGraph' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method:</code></td>
<td>
<p> a string indicating the used method.</p>
</td></tr>
<tr><td><code>info:</code></td>
<td>
<p> a string showing details about the method.</p>
</td></tr>
<tr><td><code>data.name:</code></td>
<td>
<p> a string with the data's name(s).</p>
</td></tr>
<tr><td><code>param:</code></td>
<td>
<p> the parameter estimate. For the 'ER', 'GRG', 'KR', 'WS', and 'BA'
models, the parameter corresponds to the probability to connect a pair of
vertices, the radius used to construct the geometric graph in a unit square,
the degree <code>k</code> of a regular graph, the probability to reconnect a vertex, and
the scaling exponent, respectively.</p>
</td></tr>
<tr><td><code>dist:</code></td>
<td>
<p> the distance between the observed graph and the graph model with the estimated
parameter.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G &lt;- igraph::sample_gnp(n=50, p=0.5)

# Using a string to indicate the graph model
result1 &lt;- graph.param.estimator(G, 'ER', eps=0.25)
result1


# Using a function to describe the graph model
# Erdos-Renyi graph
set.seed(1)
model &lt;- function(n, p) {
  return(igraph::sample_gnp(n, p))
}
result2 &lt;- graph.param.estimator(G, model,  seq(0.2, 0.8, 0.1))
result2



</code></pre>

<hr>
<h2 id='graph.spectral.density'>Graph Spectral Density</h2><span id='topic+graph.spectral.density'></span>

<h3>Description</h3>

<p><code>graph.spectral.density</code> returns the exact or degree-based spectral density
in the interval &lt;<code>from</code>,<code>to</code>&gt; by using <code>npoints</code> discretization points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.spectral.density(Graph, method = "diag", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.spectral.density_+3A_graph">Graph</code></td>
<td>
<p>the undirected graph (igraph object).
If <code>Graph</code> has the  attribute <code>eigenvalues</code> containing
the eigenvalues of <code>Graph</code>, such values will be used to
compute its spectral density.</p>
</td></tr>
<tr><td><code id="graph.spectral.density_+3A_method">method</code></td>
<td>
<p>String that specifies the method to obtain the spectral density. It can
take two possible values 'diag' (Default) and 'fast'. If 'diag' is used then
the exact spectral density is obtained, otherwise the degree-based spectral
density is obtained.</p>
</td></tr>
<tr><td><code id="graph.spectral.density_+3A_...">...</code></td>
<td>
<p>Other relevant parameters to obtain the spectral density such as <code>from</code>, <code>to</code>,
an <code>npoints</code>.  <code>from</code>, <code>to</code> specify  the lower and upper bound of the eigenvalues' support
(automatically computed if not given); and <code>npoints</code> is the number of discretization points (default <code>1024</code>) of
the interval &lt;<code>from</code>,<code>to</code>&gt;.
There are other parameters that depend on the value of the parameter <code>method</code>:
If <code>method='diag'</code>, then the parameter <code>bandwidth</code> can be used.
This parameter is a string that specifies the criterion to choose the
bandwidth during the spectral density estimation. Choose between the
following criteria: 'Silverman' (default), 'Sturges', 'bcv', 'ucv' and 'SJ'.
'bcv' is an abbreviation of biased cross-validation, while 'ucv' means
unbiased cross-validation. 'SJ'  implements the methods of Sheather &amp; Jones
(1991) to select the bandwidth using pilot estimation of derivatives.
Otherwise, if <code>method='fast'</code>, then the parameter <code>numCores</code> can be used. This parameter
specifies the number of cores (default <code>1</code>) to use for parallelization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'statGraph' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method:</code></td>
<td>
<p> a string indicating the used method.</p>
</td></tr>
<tr><td><code>info:</code></td>
<td>
<p> a string showing details about the method.</p>
</td></tr>
<tr><td><code>data.name:</code></td>
<td>
<p> a string with the data's name(s).</p>
</td></tr>
<tr><td><code>x:</code></td>
<td>
<p> a vector corresponding to the x axis coordinates of the density function.</p>
</td></tr>
<tr><td><code>y:</code></td>
<td>
<p> a vector corresponding to the y axis coordinates of the density function.</p>
</td></tr>
<tr><td><code>from:</code></td>
<td>
<p> a real number corresponding to the smallest value of the x axis.</p>
</td></tr>
<tr><td><code>to:</code></td>
<td>
<p> a real number corresponding to the largest value of the x axis.</p>
</td></tr>
</table>


<h3>References</h3>

<p>#' Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>
<p>Newman, M. E. J., Zhang, X., &amp; Nadakuditi, R. R. (2019).
Spectra of random networks with arbitrary degrees.
Physical Review E, 99(4), 042309.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G &lt;- igraph::sample_smallworld(dim = 1, size = 50, nei = 2, p = 0.2)

# Obtain the spectral density
density &lt;- graph.spectral.density(Graph = G)
density

</code></pre>

<hr>
<h2 id='graph.takahashi.test'>Test for the Jensen-Shannon Divergence Between Graphs</h2><span id='topic+graph.takahashi.test'></span>

<h3>Description</h3>

<p><code>graph.takahashi.test</code> tests whether two sets of graphs were generated by the same
random graph model.
This bootstrap test is based on the Jensen-Shannon (JS) divergence between
graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.takahashi.test(Graphs1, Graphs2, maxBoot = 1000, dist = "JS", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.takahashi.test_+3A_graphs1">Graphs1</code></td>
<td>
<p>a list of undirected Graphs.
If each graph has the  attribute <code>eigenvalues</code> containing its
eigenvalues , such values will be used to
compute their spectral density.</p>
</td></tr>
<tr><td><code id="graph.takahashi.test_+3A_graphs2">Graphs2</code></td>
<td>
<p>a list of undirected Graphs.
If each graph has the  attribute <code>eigenvalues</code> containing its
eigenvalues , such values will be used to
compute their spectral density.</p>
</td></tr>
<tr><td><code id="graph.takahashi.test_+3A_maxboot">maxBoot</code></td>
<td>
<p>integer indicating the number of bootstrap resamplings (default <code>1000</code>).</p>
</td></tr>
<tr><td><code id="graph.takahashi.test_+3A_dist">dist</code></td>
<td>
<p>string indicating if you want to use the 'JS' (default) , 'L1' or 'L2'
distances. 'JS' means Jensen-Shannon divergence.</p>
</td></tr>
<tr><td><code id="graph.takahashi.test_+3A_...">...</code></td>
<td>
<p>Other relevant parameters for <code><a href="#topic+graph.spectral.density">graph.spectral.density</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two lists of graphs, <code>Graphs1</code> and <code>Graphs2</code>, <code>graph.takahashi.test</code> tests H0: 'JS
divergence between <code>Graphs1</code> and <code>Graphs2</code> is <code>0</code>' against H1: 'JS divergence between
<code>Graphs1</code> and <code>Graphs2</code> is larger than <code>0</code>'.
</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic:</code></td>
<td>
<p> the value of the Jensen-Shannon divergence (default), L1 or L2 between 'Graphs1' and 'Graphs2'.</p>
</td></tr>
<tr><td><code>p.value:</code></td>
<td>
<p> the p-value of the test.</p>
</td></tr>
<tr><td><code>method:</code></td>
<td>
<p> a string indicating the used method.</p>
</td></tr>
<tr><td><code>data.name:</code></td>
<td>
<p> a string with the data's name(s).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Takahashi, D. Y., Sato, J. R., Ferreira, C. E. and Fujita A. (2012)
Discriminating Different Classes of Biological Networks by Analyzing the
Graph Spectra  Distribution. _PLoS ONE_, *7*, e49949.
doi:10.1371/journal.pone.0049949.
</p>
<p>Silverman, B. W. (1986) _Density Estimation_.  London: Chapman and Hall.
</p>
<p>Sturges, H. A. The Choice of a Class Interval. _J. Am. Statist. Assoc._,
*21*, 65-66.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
G1 &lt;- G2 &lt;- list()
for (i in 1:20) {
  G1[[i]] &lt;- igraph::sample_gnp(n=50, p=0.500)
}
for (i in 1:20) {
  G2[[i]] &lt;- igraph::sample_gnp(n=50, p=0.512)
}
result &lt;- graph.takahashi.test(G1, G2, maxBoot=500)
result

</code></pre>

<hr>
<h2 id='sp.anogva'>Semi-parametric Analysis of Graph Variability (SP-ANOGVA)</h2><span id='topic+sp.anogva'></span>

<h3>Description</h3>

<p><code>sp.anogva</code> statistically tests whether two or more graphs are
generated by the same model and set of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp.anogva(Graphs, model, maxBoot = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sp.anogva_+3A_graphs">Graphs</code></td>
<td>
<p>a list of undirected graphs.
If each graph has the  attribute <code>eigenvalues</code> containing its
eigenvalues , such values will be used to
compute their spectral density.</p>
</td></tr>
<tr><td><code id="sp.anogva_+3A_model">model</code></td>
<td>
<p>A string that indicates one of the following models: 'ER'
(Erdos-Renyi random graph model), 'GRG' (geometric random graph model), 'WS'
(Watts-Strogatz random graph model), and 'BA' (Barab√°si-Albert random graph
model).</p>
</td></tr>
<tr><td><code id="sp.anogva_+3A_maxboot">maxBoot</code></td>
<td>
<p>integer indicating the number of bootstrap resamples (default
is <code>500</code>).</p>
</td></tr>
<tr><td><code id="sp.anogva_+3A_...">...</code></td>
<td>
<p>Other relevant parameters for <code><a href="#topic+graph.param.estimator">graph.param.estimator</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic:</code></td>
<td>
<p> the F statistic of the test.</p>
</td></tr>
<tr><td><code>p.value:</code></td>
<td>
<p> the p-value of the test.</p>
</td></tr>
<tr><td><code>method:</code></td>
<td>
<p> a string indicating the used method.</p>
</td></tr>
<tr><td><code>data.name:</code></td>
<td>
<p> a string with the data's name(s).</p>
</td></tr>
<tr><td><code>estimates:</code></td>
<td>
<p> a vector containing the estimated parameters for each graph.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Andre Fujita, Eduardo Silva Lira, Suzana de Siqueira Santos, Silvia Yumi
Bando, Gabriela Eleuterio Soares, Daniel Yasumasa Takahashi. A
semi-parametric statistical test to compare complex networks, Journal of
Complex Networks, cnz028, https://doi.org/10.1093/comnet/cnz028
</p>
<p>Sheather, S. J. and Jones, M. C. (1991). A reliable data-based bandwidth
selection method for kernel density estimation.
_Journal of the Royal Statistical Society series B_, 53, 683-690.
http://www.jstor.org/stable/2345597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
model &lt;- 'ER'
G &lt;- list()

# Under H0
G[[1]] &lt;- igraph::sample_gnp(50, 0.5)
G[[2]] &lt;- igraph::sample_gnp(50, 0.5)
G[[3]] &lt;- igraph::sample_gnp(50, 0.5)
result1 &lt;- sp.anogva(G, model, maxBoot = 10,eps=0.1)
result1

# Under H1
G[[1]] &lt;- igraph::sample_gnp(50, 0.5)
G[[2]] &lt;- igraph::sample_gnp(50, 0.75)
G[[3]] &lt;- igraph::sample_gnp(50, 0.5)
result2 &lt;- sp.anogva(G, model, maxBoot = 10,eps=0.1)
result2



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
