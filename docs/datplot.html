<!DOCTYPE html><html><head><title>Help for package datplot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {datplot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Beazley'><p>Beazley (sample of 1000)</p></a></li>
<li><a href='#check.structure'><p>Check if the structure is compatible with [datsteps()]  (internal)</p></a></li>
<li><a href='#create.sub.objects'><p>Create sub-objects for each object in a dataframe (internal)</p></a></li>
<li><a href='#DAT_df'><p>datplot Testing data</p></a></li>
<li><a href='#datplot-package'><p>datplot: Preparation of Object Dating Ranges for Density Plots (Aoristic Analysis)</p></a></li>
<li><a href='#datsteps'><p>Create 'steps' of dates for each object in a data.frame</p></a></li>
<li><a href='#generate.stepsize'><p>Determine stepsize (internal)</p></a></li>
<li><a href='#get.histogramscale'><p>Scaling Factor for Combined Histogram Plots</p></a></li>
<li><a href='#get.probability'><p>Calculate the probability for each year and each dated object</p></a></li>
<li><a href='#get.step.sequence'><p>Calculate the sequence of dating steps</p></a></li>
<li><a href='#get.weights'><p>Calculate the weights for each dated object</p></a></li>
<li><a href='#Inscr_Bithynia'><p>Inscr_Bithynia</p></a></li>
<li><a href='#scaleweight'><p>Scales the content of a column</p></a></li>
<li><a href='#switch.dating'><p>Switch values where dating is in wrong order (internal)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Preparation of Object Dating Ranges for Density Plots (Aoristic
Analysis)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lisa Steinmann &lt;lisa.steinmann@rub.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Converting date ranges into dating 'steps' eases the
    visualization of changes in e.g. pottery consumption, style and other
    variables over time. This package provides tools to process and
    prepare data for visualization and employs the concept of aoristic
    analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lsteinmann/datplot">https://github.com/lsteinmann/datplot</a>,
<a href="https://lsteinmann.github.io/datplot/">https://lsteinmann.github.io/datplot/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lsteinmann/datplot/issues">https://github.com/lsteinmann/datplot/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, devtools, dplyr, forcats, ggplot2, ggridges, knitr,
reshape2, rmarkdown, stringr, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-18 13:59:29 UTC; l_steinmann</td>
</tr>
<tr>
<td>Author:</td>
<td>Lisa Steinmann <a href="https://orcid.org/0000-0002-2215-1243"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Barbora Weissova <a href="https://orcid.org/0000-0002-3297-6855"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-18 23:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='Beazley'>Beazley (sample of 1000)</h2><span id='topic+Beazley'></span>

<h3>Description</h3>

<p>A test dataset containing a data.frame how it should ideally be arranged
to work with datplot. Data are gathered from the Beazley Archive Pottery
Database (BAPD) &ndash; https://www.carc.ox.ac.uk/carc/pottery and
transformed to work with datplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Beazley)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 4 variables
</p>


<h3>Details</h3>


<ul>
<li><p> Identifier (Vase.Number in BAPD)
</p>
</li>
<li><p> Technique: Sample contains only red- or blackfigured objects
</p>
</li>
<li><p> DAT_min. Integer: lower range of the dating, BCE in negative numbers
</p>
</li>
<li><p> DAT_max. Integer: upper range of the dating, BCE in negative numbers
</p>
</li></ul>



<h3>Source</h3>

<p>https://www.carc.ox.ac.uk/carc/pottery
</p>

<hr>
<h2 id='check.structure'>Check if the structure is compatible with [datsteps()]  (internal)</h2><span id='topic+check.structure'></span>

<h3>Description</h3>

<p>Checks if the object passed to [datsteps()] can be used for
processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.structure(DAT_df, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.structure_+3A_dat_df">DAT_df</code></td>
<td>
<p>An object to check</p>
</td></tr>
<tr><td><code id="check.structure_+3A_verbose">verbose</code></td>
<td>
<p>TRUE / FALSE: Should the function issue additional
messages pointing to possible inconsistencies and notify of methods?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if object can be processed by [datsteps()], error / FALSE if not
</p>

<hr>
<h2 id='create.sub.objects'>Create sub-objects for each object in a dataframe (internal)</h2><span id='topic+create.sub.objects'></span>

<h3>Description</h3>

<p>Requires a list with named vectors as [datsteps()] will
hand to the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.sub.objects(DAT_list, stepsize, calc = "weight", cumulative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.sub.objects_+3A_dat_list">DAT_list</code></td>
<td>
<p>a list as prepared by [datsteps()]</p>
</td></tr>
<tr><td><code id="create.sub.objects_+3A_stepsize">stepsize</code></td>
<td>
<p>numeric, default is 1. Number of years that should be used
as an interval for creating dating steps.</p>
</td></tr>
<tr><td><code id="create.sub.objects_+3A_calc">calc</code></td>
<td>
<p>method of calculation to use;
can be either one of &quot;weight&quot; (default) or &quot;probability&quot;:
* &quot;weight&quot;: use the
[published original calculation](https://doi.org/10.1017/aap.2021.8)
for weights,
* &quot;probability&quot;: calculate year-wise probability instead (only reasonable
when 'stepsize = 1')</p>
</td></tr>
<tr><td><code id="create.sub.objects_+3A_cumulative">cumulative</code></td>
<td>
<p>FALSE (default), TRUE: add a column containing the
cumulative probability for each object (only reasonable when 'stepsize = 1',
and will automatically use probability calculation)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an expanded list of the same structure to be further processed by
[datsteps()] each object duplicated according to the number of steps required
</p>

<hr>
<h2 id='DAT_df'>datplot Testing data</h2><span id='topic+DAT_df'></span>

<h3>Description</h3>

<p>A test dataset containing a data.frame how it should ideally be arranged
to work with datplot. Data are not real and illustrate some common problems
such as lower and upper dating in the wrong columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DAT_df)
</code></pre>


<h3>Format</h3>

<p>A data frame with 5000 rows and 4 variables
</p>


<h3>Details</h3>


<ul>
<li><p> ID. Identifier of the Objects (has to be unique)
</p>
</li>
<li><p> var. Grouping variable, such as a Type or a Findspot
</p>
</li>
<li><p> DAT_min. Integer: lower range of the dating, BCE in negative numbers
</p>
</li>
<li><p> DAT_max. Integer: upper range of the dating, BCE in negative numbers
</p>
</li></ul>


<hr>
<h2 id='datplot-package'>datplot: Preparation of Object Dating Ranges for Density Plots (Aoristic Analysis)</h2><span id='topic+datplot'></span><span id='topic+datplot-package'></span>

<h3>Description</h3>

<p>Converting date ranges into dating 'steps' eases the visualization of changes in e.g. pottery consumption, style and other variables over time. This package provides tools to process and prepare data for visualization and employs the concept of aoristic analysis.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lisa Steinmann <a href="mailto:lisa.steinmann@rub.de">lisa.steinmann@rub.de</a> (<a href="https://orcid.org/0000-0002-2215-1243">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Barbora Weissova <a href="mailto:barbora.weissova@rub.de">barbora.weissova@rub.de</a> (<a href="https://orcid.org/0000-0002-3297-6855">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/lsteinmann/datplot">https://github.com/lsteinmann/datplot</a>
</p>
</li>
<li> <p><a href="https://lsteinmann.github.io/datplot/">https://lsteinmann.github.io/datplot/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/lsteinmann/datplot/issues">https://github.com/lsteinmann/datplot/issues</a>
</p>
</li></ul>


<hr>
<h2 id='datsteps'>Create 'steps' of dates for each object in a data.frame</h2><span id='topic+datsteps'></span>

<h3>Description</h3>

<p>This function transforms a data.frame of dated objects with associated data
to a new data.frame which contains a row for each dating 'step' for each
objects. Dating 'steps' can be single years (with 'stepsize = 1') or an
arbitrary number that will be used as a guideline for the interval.
It's expected that dates BCE are displayed as negative
values while dates CE are positive values. Ignoring this will cause
problems. If dates are provided in the wrong order in any number of
rows they will automatically be switched.
</p>
<p>The function along with a guide on how to use it and a case study is published
in [Steinmann &ndash; Weissova 2021](https://doi.org/10.1017/aap.2021.8).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datsteps(
  DAT_df,
  stepsize = 1,
  calc = "weight",
  cumulative = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datsteps_+3A_dat_df">DAT_df</code></td>
<td>
<p>a data.frame with 4 variables:
* 'ID' : An identifier for each row, e.g. an Inventory number (ideally character).
* 'group' : A grouping variable, such as type or context (ideally factor).
* 'DAT_min' : minimum dating (int/num), the minimum dating boundary for a
single object, i.e. the earliest year the object may be dated to.
* 'DAT_min' : maximum dating (int/num), the maximum dating boundary for a
single object, i.e. the latest year the object may be dated to.
The columns _must_ be in this order, column names are irrelevant; each row
_must_ correspond to one datable entity / object.</p>
</td></tr>
<tr><td><code id="datsteps_+3A_stepsize">stepsize</code></td>
<td>
<p>numeric, default is 1. Number of years that should be used
as an interval for creating dating steps.</p>
</td></tr>
<tr><td><code id="datsteps_+3A_calc">calc</code></td>
<td>
<p>method of calculation to use;
can be either one of &quot;weight&quot; (default) or &quot;probability&quot;:
* &quot;weight&quot;: use the
[published original calculation](https://doi.org/10.1017/aap.2021.8)
for weights,
* &quot;probability&quot;: calculate year-wise probability instead (only reasonable
when 'stepsize = 1')</p>
</td></tr>
<tr><td><code id="datsteps_+3A_cumulative">cumulative</code></td>
<td>
<p>FALSE (default), TRUE: add a column containing the
cumulative probability for each object (only reasonable when 'stepsize = 1',
and will automatically use probability calculation)</p>
</td></tr>
<tr><td><code id="datsteps_+3A_verbose">verbose</code></td>
<td>
<p>TRUE / FALSE: Should the function issue additional
messages pointing to possible inconsistencies and notify of methods?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an expanded data.frame in with each row represents a dating 'step'.
Added columns contain the value of each step, the 'weight' or 'probability'-
value for each step, and (if chosen) the cumulative probability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Inscr_Bithynia")
DAT_df &lt;- Inscr_Bithynia[, c("ID", "Location", "DAT_min", "DAT_max")]
DAT_df_steps &lt;- datsteps(DAT_df, stepsize = 25)
plot(density(DAT_df_steps$DAT_step))
</code></pre>

<hr>
<h2 id='generate.stepsize'>Determine stepsize (internal)</h2><span id='topic+generate.stepsize'></span>

<h3>Description</h3>

<p>Determines stepsize by selecting the absolute minimum value
between the upper and lower end of all dating ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.stepsize(DAT_mat, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.stepsize_+3A_dat_mat">DAT_mat</code></td>
<td>
<p>a matrix as prepared by [datsteps()], resp. a matrix witch
columns names 'datmin' and 'datmax' containing numeric/integer value of the
dating ranges.</p>
</td></tr>
<tr><td><code id="generate.stepsize_+3A_verbose">verbose</code></td>
<td>
<p>TRUE / FALSE: Should the function issue additional
messages pointing to possible inconsistencies and notify of methods?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value that can be used as minimal stepsize.
</p>


<h3>See Also</h3>

<p>[datsteps()]
</p>

<hr>
<h2 id='get.histogramscale'>Scaling Factor for Combined Histogram Plots</h2><span id='topic+get.histogramscale'></span>

<h3>Description</h3>

<p>Requires a data.frame as produced by [datsteps()] or a number as
DAT_df_steps. Calculates the value with which the y-axis of a density graph
should be multiplied by in order to be visible in the corresponding histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.histogramscale(DAT_df_steps, binwidth = "stepsize")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.histogramscale_+3A_dat_df_steps">DAT_df_steps</code></td>
<td>
<p>a data.frame as returned by [datsteps()]. (Will also
work with a single number and a vector.)</p>
</td></tr>
<tr><td><code id="get.histogramscale_+3A_binwidth">binwidth</code></td>
<td>
<p>the bandwidth to use for the density function and histogram.
Should equal the stepsize used to create the data.frame. If a data.frame as
returned by [datsteps()] is given, stepsize can be automatically assigned
using the corresponding attribute ('binwidth = &quot;stepsize&quot;')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value with which to scale the density curve to a histogram
plot so that both will be visible
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Inscr_Bithynia")
DAT_df &lt;- Inscr_Bithynia[, c("ID", "Location", "DAT_min", "DAT_max")]
DAT_df_steps &lt;- datsteps(DAT_df, stepsize = 25)
get.histogramscale(DAT_df_steps)

get.histogramscale(DAT_df_steps$DAT_step, binwidth = 20)
get.histogramscale(500, binwidth = 20)
</code></pre>

<hr>
<h2 id='get.probability'>Calculate the probability for each year and each dated object</h2><span id='topic+get.probability'></span>

<h3>Description</h3>

<p>Calculates the probability of each object being dated into
each year / timeslot from two vectors of minimum and maximum
dating. Returns a vector of probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.probability(DAT_min, DAT_max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.probability_+3A_dat_min">DAT_min</code></td>
<td>
<p>a numeric vector containing the minimum date of each object</p>
</td></tr>
<tr><td><code id="get.probability_+3A_dat_max">DAT_max</code></td>
<td>
<p>a numeric vector containing the maximum date of each object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of probabilities for each object being dated to any
single year within the timespan (lesser value means object is dated to
larger timespans, i.e. with less confidence).
</p>


<h3>See Also</h3>

<p>[datsteps()], [get.weights()]
</p>

<hr>
<h2 id='get.step.sequence'>Calculate the sequence of dating steps</h2><span id='topic+get.step.sequence'></span>

<h3>Description</h3>

<p>Produces an appropriate sequence of years between the minimum
and maximum dating.
</p>
<p>If they cannot be properly divided by the stepsize set
beforehand, either three values are generated for objects that are dated to
a range of more then 60
objects dated to a timespan of less or equal to 60
If they can be divided without residual, the normal sequence is returned.
If there is a residual, the stepsize is modified depending on how large the
residual is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.step.sequence(datmin = 0, datmax = 100, stepsize = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.step.sequence_+3A_datmin">datmin</code></td>
<td>
<p>numeric value of the minimum dating of one object</p>
</td></tr>
<tr><td><code id="get.step.sequence_+3A_datmax">datmax</code></td>
<td>
<p>numeric value of the maximum dating of one object</p>
</td></tr>
<tr><td><code id="get.step.sequence_+3A_stepsize">stepsize</code></td>
<td>
<p>the stepsize to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sequence of steps to be created by [create.sub.objects()]
</p>


<h3>See Also</h3>

<p>[datsteps()], [create.sub.objects()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>min_year &lt;- -494
max_year &lt;- -334
sequence &lt;- get.step.sequence(datmin = min_year, datmax = max_year, stepsize = 25)
sequence

min_year &lt;- 1
max_year &lt;- 100
sequence &lt;- get.step.sequence(datmin = min_year, datmax = max_year, stepsize = 25)
sequence
</code></pre>

<hr>
<h2 id='get.weights'>Calculate the weights for each dated object</h2><span id='topic+get.weights'></span>

<h3>Description</h3>

<p>Calculates the weights from two vectors of minimum and maximum
dating for each object. Returns a dataframe with the weight in the first
column and FALSE in the second if two rows have the same value in both
min and max dating. See [publication](https://doi.org/10.1017/aap.2021.8)
for information about how this is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.weights(DAT_min, DAT_max, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.weights_+3A_dat_min">DAT_min</code></td>
<td>
<p>a numeric vector containing the minimum date of each object</p>
</td></tr>
<tr><td><code id="get.weights_+3A_dat_max">DAT_max</code></td>
<td>
<p>a numeric vector containing the maximum date of each object</p>
</td></tr>
<tr><td><code id="get.weights_+3A_verbose">verbose</code></td>
<td>
<p>TRUE / FALSE: Should the function issue additional
messages pointing to possible inconsistencies and notify of methods?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of 'weight'-values for the datsteps-data.frame, that is a
quantification of how well the object is dated (lesser value means object
is dated to larger timespans, i.e. with less confidence)
</p>


<h3>See Also</h3>

<p>[datsteps()], [get.probability()]
</p>

<hr>
<h2 id='Inscr_Bithynia'>Inscr_Bithynia</h2><span id='topic+Inscr_Bithynia'></span>

<h3>Description</h3>

<p>The data set was gathered by Barbora Weissova and published
as part of her dissertation “Regional Economy, Settlement Patterns and the
Road System in Bithynia (4th Century BC - 6th Century AD). Spatial and
Quantitative Analysis.”.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Inscr_Bithynia
</code></pre>


<h3>Format</h3>

<p>A data frame with 2878 rows and 9 variables:
</p>

<dl>
<dt><code>ID</code></dt><dd><p>character COLUMN_DESCRIPTION</p>
</dd>
<dt><code>ikey</code></dt><dd><p>character ID at <a href="https://inscriptions.packhum.org/">https://inscriptions.packhum.org/</a>
/ <a href="https://edh-www.adw.uni-heidelberg.de/home">https://edh-www.adw.uni-heidelberg.de/home</a>, if available</p>
</dd>
<dt><code>Location</code></dt><dd><p>factor Findspot of the Inscription (City)</p>
</dd>
<dt><code>Source</code></dt><dd><p>character Corpus/Citation of the Inscription</p>
</dd>
<dt><code>Dating</code></dt><dd><p>character Original Chronological Assessment,
may contain inconsistencies</p>
</dd>
<dt><code>Language</code></dt><dd><p>factor Language of the Inscription,
can either be Latin, Greek, or both</p>
</dd>
<dt><code>uncertain_dating</code></dt><dd><p>logical TRUE if Dating is not certain,
FALSE if dating is certain</p>
</dd>
<dt><code>DAT_min</code></dt><dd><p>integer lower border of the dating timespan,
negative values for BCE, positive values for CE</p>
</dd>
<dt><code>DAT_max</code></dt><dd><p>integer upper border of the dating timespan,
negative values for BCE, positive values for CE</p>
</dd>
<dt><code>URL</code></dt><dd><p>Link to the inscription (if available) at
<a href="https://inscriptions.packhum.org/">https://inscriptions.packhum.org/</a> or
<a href="https://edh-www.adw.uni-heidelberg.de/home">https://edh-www.adw.uni-heidelberg.de/home</a></p>
</dd>
</dl>



<h3>Source</h3>

<p>Weissova, Barbora. 2019. “Regional Economy, Settlement Patterns and
the Road System in Bithynia (4th Century BC - 6th Century AD). Spatial and
Quantitative Analysis.” Dissertation, Berlin: Freie Universität Berlin.
<a href="https://refubium.fu-berlin.de/handle/fub188/23730">https://refubium.fu-berlin.de/handle/fub188/23730</a>,
partially after <a href="https://inscriptions.packhum.org/">https://inscriptions.packhum.org/</a>
</p>

<hr>
<h2 id='scaleweight'>Scales the content of a column</h2><span id='topic+scaleweight'></span>

<h3>Description</h3>

<p>Requires a data.frame with one variable and one value column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleweight(DAT_df, var = "all", val = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleweight_+3A_dat_df">DAT_df</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="scaleweight_+3A_var">var</code></td>
<td>
<p>index or name of the column that should be used
as the group variable, OR &quot;all&quot;</p>
</td></tr>
<tr><td><code id="scaleweight_+3A_val">val</code></td>
<td>
<p>index or name of the column that should be
scaled (has to be numeric)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same data.frame, with the scaled values in the specified column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Inscr_Bithynia")
DAT_df &lt;- Inscr_Bithynia[, c("ID", "Location", "DAT_min", "DAT_max")]
DAT_df_steps &lt;- datsteps(DAT_df, stepsize = 25)
DAT_df_scaled &lt;- scaleweight(DAT_df_steps, var = 2, val = 5)
</code></pre>

<hr>
<h2 id='switch.dating'>Switch values where dating is in wrong order (internal)</h2><span id='topic+switch.dating'></span>

<h3>Description</h3>

<p>Requires a data.frame with 2 numeric variables in the
3rd and 4th column: minimum date (int/numeric) and
maximum date (int/numeric) as used in [datsteps()].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch.dating(DAT_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switch.dating_+3A_dat_df">DAT_df</code></td>
<td>
<p>a data.frame with 4 variables in this order: ID, group,
minimum date (int/num), maximum date (int/num)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same data.frame with the dating values which were in wrong order
switched.
</p>


<h3>See Also</h3>

<p>[datsteps()]
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
