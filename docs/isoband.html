<!DOCTYPE html><html lang="en"><head><title>Help for package isoband</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {isoband}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#isoband-package'><p>isoband: Generate Isolines and Isobands from Regularly Spaced Elevation Grids</p></a></li>
<li><a href='#angle_halfcircle_bottom'><p>Standardize label angles</p></a></li>
<li><a href='#clip_lines'><p>Clip lines so they don't run into a set of boxes.</p></a></li>
<li><a href='#iso_to_sfg'><p>Convert isolines or isobands to sfg object</p></a></li>
<li><a href='#isobands'><p>Efficient calculation of isolines and isobands from elevation grid</p></a></li>
<li><a href='#isobands_grob'><p>Render isobands</p></a></li>
<li><a href='#isolines_grob'><p>Render labeled isolines</p></a></li>
<li><a href='#label_placer_minmax'><p>Set up a label placement strategy</p></a></li>
<li><a href='#label_placer_simple'><p>Generic label placement function</p></a></li>
<li><a href='#plot_iso'><p>Visualize a single isoband</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Generate Isolines and Isobands from Regularly Spaced Elevation
Grids</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.7</td>
</tr>
<tr>
<td>Description:</td>
<td>A fast C++ implementation to generate contour lines
    (isolines) and contour polygons (isobands) from regularly spaced grids
    containing elevation data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://isoband.r-lib.org">https://isoband.r-lib.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/isoband/issues">https://github.com/r-lib/isoband/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggplot2, knitr, magick, microbenchmark, rmarkdown, sf,
testthat, xml2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-19 20:10:02 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham <a href="https://orcid.org/0000-0003-4757-117X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Claus O. Wilke <a href="https://orcid.org/0000-0002-7470-9261"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (Original author),
  Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-20 10:00:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='isoband-package'>isoband: Generate Isolines and Isobands from Regularly Spaced Elevation Grids</h2><span id='topic+isoband'></span><span id='topic+isoband-package'></span>

<h3>Description</h3>

<p>A fast C++ implementation to generate contour lines (isolines) and contour polygons (isobands) from regularly spaced grids containing elevation data.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a> (<a href="https://orcid.org/0000-0003-4757-117X">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Claus O. Wilke <a href="mailto:wilke@austin.utexas.edu">wilke@austin.utexas.edu</a> (<a href="https://orcid.org/0000-0002-7470-9261">ORCID</a>) (Original author)
</p>
</li>
<li><p> Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://isoband.r-lib.org">https://isoband.r-lib.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/isoband/issues">https://github.com/r-lib/isoband/issues</a>
</p>
</li></ul>


<hr>
<h2 id='angle_halfcircle_bottom'>Standardize label angles</h2><span id='topic+angle_halfcircle_bottom'></span><span id='topic+angle_halfcircle_right'></span><span id='topic+angle_fixed'></span><span id='topic+angle_identity'></span>

<h3>Description</h3>

<p>Function factories that return functions to standardize rotation angles to specific angle ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle_halfcircle_bottom()

angle_halfcircle_right()

angle_fixed(theta = 0)

angle_identity()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angle_halfcircle_bottom_+3A_theta">theta</code></td>
<td>
<p>Fixed angle, in radians.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>angle_halfcircle_bottom()</code> standardizes angles to (-pi/2, pi/2].
</p>
<p><code>angle_halfcircle_right()</code> standardizes angles to (0, pi].
</p>
<p><code>angle_fixed()</code> sets all angles to a fixed value (0 by default).
</p>
<p><code>angle_identity()</code> does not modify any angles.
</p>

<hr>
<h2 id='clip_lines'>Clip lines so they don't run into a set of boxes.</h2><span id='topic+clip_lines'></span>

<h3>Description</h3>

<p>Clip lines so they don't run into a set of boxes. Useful for labeling isolines,
as it allows removal of line segments that would run into any text labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clip_lines(x, y, id, clip_boxes, asp = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clip_lines_+3A_x">x</code></td>
<td>
<p>Numeric vector of x coordinates</p>
</td></tr>
<tr><td><code id="clip_lines_+3A_y">y</code></td>
<td>
<p>Numeric vector of y coordinates</p>
</td></tr>
<tr><td><code id="clip_lines_+3A_id">id</code></td>
<td>
<p>Integer vector of id numbers indicating which lines are connected</p>
</td></tr>
<tr><td><code id="clip_lines_+3A_clip_boxes">clip_boxes</code></td>
<td>
<p>Data frame specifying the locations of boxes to clip to.
Should have five columns, named <code>x</code>, <code>y</code>, <code>width</code>, <code>height</code>, <code>theta</code>, which
specify the x and y positions of each box midpoint, as well as the box width,
box height, and box angle in radians. Each box is specified by one data
row.</p>
</td></tr>
<tr><td><code id="clip_lines_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio (width/height) of the target canvas. This is used to convert
widths to heights and vice versa for rotated boxes</p>
</td></tr>
</table>

<hr>
<h2 id='iso_to_sfg'>Convert isolines or isobands to sfg object</h2><span id='topic+iso_to_sfg'></span>

<h3>Description</h3>

<p>Convert isolines or isobands to an sf geometry collection (<code>sfg</code>) object. Further downstream
processing needs to happen via the sf package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso_to_sfg(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iso_to_sfg_+3A_x">x</code></td>
<td>
<p>The object to convert.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>iso_to_sfg()</code> is a generic that takes an object created by either <code><a href="#topic+isolines">isolines()</a></code>
or <code><a href="#topic+isobands">isobands()</a></code> and turns it into a simple features (sf) geometry collection. Importantly,
the isobanding algorithm can produce polygons that do not represent valid simple features. This
happens usually when the lower limit of an isoband is exactly equal to some data values (see
examples for a demonstration). This can be worked around either by slightly shifting the data
or band limits (e.g., round all data values and then shift them by a value smaller than the
rounding error) or by fixing the geometries using the function <code>st_make_valid()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("sf", quietly = TRUE)) {
library(sf)
library(ggplot2)

# Example 1: simple 5x5 matrix
m &lt;- matrix(c(0, 2, 2, 2, 0,
              0, 1, 0, 1, 0,
              0, 1, 0, 0, 0,
              0, 1, 0, 1, 0,
              0, 0, 0, 0, 0), 5, 5, byrow = TRUE)

z &lt;- isolines(1:ncol(m), nrow(m):1, m, c(0.5, 1.5))
lines &lt;- iso_to_sfg(z)
x &lt;- st_sf(level = names(lines), geometry = st_sfc(lines))
ggplot(x) + geom_sf(aes(color = level))

# Example 2: volcano dataset
m &lt;- volcano
b &lt;- isobands((1:ncol(m))/(ncol(m)+1), (nrow(m):1)/(nrow(m)+1), m,
              10*9:19, 10*10:20)
bands &lt;- iso_to_sfg(b)
x &lt;- st_sf(level = as.numeric(sub(":.*", "", names(bands))), geometry = st_sfc(bands))
ggplot(x) + geom_sf(aes(color = level, fill = level))

# Example 3: invalid simple features
m &lt;- matrix(c(1.5, 1.5, 1.5, 1.5, 0.6,
              0.5, 1.5, 1.5,   0,   0,
                0,   1,   0,   1,   1,
                0,   1,   0, 0.7,   0,
              0.9, 1.3, 1.8, 1.4, 0.4), 5, 5, byrow = TRUE)

raw &lt;- isobands(1:5, 5:1, m, levels_low = 0:1, levels_high = 1:2)
bands &lt;- iso_to_sfg(raw)

iso &lt;- st_sf(
  id = factor(1:length(bands)),
  geometry = st_sfc(bands)
)

# the geometries are not valid
st_is_valid(iso, reason = TRUE)
# this doesn't prevent us from plotting them
ggplot(iso, aes(fill = id)) + geom_sf()

# make all geometries valid, requires GEOS &gt;= 3.8.0
if (sf_extSoftVersion()["GEOS"] &gt;= "3.8.0") {
  iso2 &lt;- st_make_valid(iso)
  st_is_valid(iso2, reason=TRUE)
  # the plot should be unchanged
  ggplot(iso2, aes(fill = id)) + geom_sf()
}

# alternatively, if we shift all data values by a tiny
# amount (here, 1e-10) so they don't coincide with the band
# limits, no invalid geometries are generated.
raw &lt;- isobands(1:5, 5:1, m + 1e-10, levels_low = 0:1, levels_high = 1:2)
bands &lt;- iso_to_sfg(raw)
iso &lt;- st_sf(id = factor(1:length(bands)), geometry = st_sfc(bands))
st_is_valid(iso, reason = TRUE)
}
</code></pre>

<hr>
<h2 id='isobands'>Efficient calculation of isolines and isobands from elevation grid</h2><span id='topic+isobands'></span><span id='topic+isolines'></span>

<h3>Description</h3>

<p>Efficient calculation of isolines and isobands from elevation grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isobands(x, y, z, levels_low, levels_high)

isolines(x, y, z, levels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isobands_+3A_x">x</code></td>
<td>
<p>Numeric vector specifying the x locations of the grid points.</p>
</td></tr>
<tr><td><code id="isobands_+3A_y">y</code></td>
<td>
<p>Numeric vector specifying the y locations of the grid points.</p>
</td></tr>
<tr><td><code id="isobands_+3A_z">z</code></td>
<td>
<p>Numeric matrix specifying the elevation values for each grid point.</p>
</td></tr>
<tr><td><code id="isobands_+3A_levels_low">levels_low</code>, <code id="isobands_+3A_levels_high">levels_high</code></td>
<td>
<p>Numeric vectors of minimum/maximum z values
for which isobands should be generated. Any z values that are exactly
equal to a value in <code>levels_low</code> are considered part of the corresponding
isoband, but any z values that are exactly equal to a value in <code>levels_high</code>
are not considered part of the corresponding isoband. In other words, the
intervals specifying isobands are closed at their lower boundary and open
at their upper boundary.</p>
</td></tr>
<tr><td><code id="isobands_+3A_levels">levels</code></td>
<td>
<p>Numeric vector of z values for which isolines should be generated.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot_iso">plot_iso</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(grid)

#' # one simple connected shape
m &lt;- matrix(c(0, 0, 0, 0, 0, 0,
              0, 0, 0, 1, 1, 0,
              0, 0, 1, 1, 1, 0,
              0, 1, 1, 0, 0, 0,
              0, 0, 0, 1, 0, 0,
              0, 0, 0, 0, 0, 0), 6, 6, byrow = TRUE)

df_bands &lt;- isobands((1:ncol(m))/(ncol(m)+1), (nrow(m):1)/(nrow(m)+1), m, 0.5, 1.5)[[1]]
df_lines &lt;- isolines((1:ncol(m))/(ncol(m)+1), (nrow(m):1)/(nrow(m)+1), m, 0.5)[[1]]
g &lt;- expand.grid(x = (1:ncol(m))/(ncol(m)+1), y = (nrow(m):1)/(nrow(m)+1))
grid.newpage()
grid.points(g$x, g$y, default.units = "npc", pch = 19, size = unit(0.5, "char"))
grid.path(df_bands$x, df_bands$y, df_bands$id, gp = gpar(fill = "cornsilk", col = NA))
grid.polyline(df_lines$x, df_lines$y, df_lines$id)

# a similar plot can be generated with the plot_iso() function,
# which is useful for exploring how the algorithm works
plot_iso(m, 0.5, 1.5)

# NAs are ignored
m &lt;- matrix(c(NA, NA, NA, 0, 0, 0,
              NA, NA, NA, 1, 1, 0,
               0,  0,  1, 1, 1, 0,
               0,  1,  1, 0, 0, 0,
               0,  0,  0, 1, 0, 0,
               0,  0,  0, 0, 0, 0), 6, 6, byrow = TRUE)
plot_iso(m, 0.5, 1.5)

# two separate shapes
m &lt;- matrix(c(0, 0, 1, 1,
              0, 1, 1, 1,
              1, 1, 0, 0,
              0, 0, 0.8, 0), 4, 4, byrow = TRUE)
plot_iso(m, 0.5, 1.5)

# shape with hole
m &lt;- matrix(c(0, 0, 0, 0, 0, 0,
              0, 1, 1, 1, 1, 0,
              0, 1, 2, 2, 1, 0,
              0, 1, 2, 2, 1, 0,
              0, 1, 1, 1, 1, 0,
              0, 0, 0, 0, 0, 0), 6, 6, byrow = TRUE)
plot_iso(m, 0.5, 1.5)
</code></pre>

<hr>
<h2 id='isobands_grob'>Render isobands</h2><span id='topic+isobands_grob'></span>

<h3>Description</h3>

<p>This function generates a grid grob that represents isobands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isobands_grob(bands, gp = gpar(), units = "npc")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isobands_grob_+3A_bands">bands</code></td>
<td>
<p>Isobands, as produced by the <code><a href="#topic+isobands">isobands()</a></code> function.</p>
</td></tr>
<tr><td><code id="isobands_grob_+3A_gp">gp</code></td>
<td>
<p>Grid graphical parameters. Parameters are recycled among
the total number of bands drawn.</p>
</td></tr>
<tr><td><code id="isobands_grob_+3A_units">units</code></td>
<td>
<p>A character string specifying the units in which to
interpret the isobands coordinates. Defaults to <code>"npc"</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="#topic+isolines_grob">isolines_grob()</a></code> for drawing of isolines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(grid)

viridis_pal &lt;- colorRampPalette(
  c("#440154", "#414487", "#2A788E", "#22A884", "#7AD151", "#FDE725"),
  space = "Lab"
)

x &lt;- (1:ncol(volcano))/(ncol(volcano)+1)
y &lt;- (nrow(volcano):1)/(nrow(volcano)+1)
bands &lt;- isobands(x, y, volcano, 5*(18:38), 5*(19:39))

b &lt;- isobands_grob(
  bands,
  gp = gpar(col = "black", fill = viridis_pal(21), alpha = 0.5)
)

grid.newpage()
grid.draw(b)
</code></pre>

<hr>
<h2 id='isolines_grob'>Render labeled isolines</h2><span id='topic+isolines_grob'></span>

<h3>Description</h3>

<p>This function generates a grid grob that represents labeled isolines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isolines_grob(
  lines,
  gp = gpar(),
  breaks = NULL,
  labels = NULL,
  margin = unit(c(1, 1, 1, 1), "pt"),
  label_col = NULL,
  label_alpha = NULL,
  label_placer = label_placer_minmax(),
  units = "npc"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isolines_grob_+3A_lines">lines</code></td>
<td>
<p>Isolines, as produced by the <code><a href="#topic+isolines">isolines()</a></code> function.</p>
</td></tr>
<tr><td><code id="isolines_grob_+3A_gp">gp</code></td>
<td>
<p>Grid graphical parameters. Parameters applying to lines
(such as <code>col</code>, <code>lwd</code>, <code>lty</code>, etc.) are recycled among the total
number of lines drawn. Parameters applying only to labels (such
as <code>fontfamily</code>, <code>fontsize</code>) are recycled among the specified
breaks only. The two parameters <code>col</code> and <code>alpha</code> are also applied
to labels, unless overridden (see <code>label_col</code> and <code>label_alpha</code>),
but are matched to the corresponding lines.</p>
</td></tr>
<tr><td><code id="isolines_grob_+3A_breaks">breaks</code></td>
<td>
<p>Character vector specifying the isolines that should be
labeled. If <code>NULL</code>, labels all isolines.</p>
</td></tr>
<tr><td><code id="isolines_grob_+3A_labels">labels</code></td>
<td>
<p>Character vector specifying the labels for each break.
If <code>NULL</code>, uses the breaks as labels. The number of labels provided
must match the number of breaks provided.</p>
</td></tr>
<tr><td><code id="isolines_grob_+3A_margin">margin</code></td>
<td>
<p>Unit object of length 4 specifying the top, right, bottom,
and left margins around each text label. The same margins are applied
to all labels.</p>
</td></tr>
<tr><td><code id="isolines_grob_+3A_label_col">label_col</code></td>
<td>
<p>Color applied to labels. Can be used to override the
color provided in <code>gp</code>, in case labels and lines should have different
colors.</p>
</td></tr>
<tr><td><code id="isolines_grob_+3A_label_alpha">label_alpha</code></td>
<td>
<p>Alpha applied to labels. Can be used to override the
alpha value provided in <code>gp</code>, in case labels and lines should have
different alpha values.</p>
</td></tr>
<tr><td><code id="isolines_grob_+3A_label_placer">label_placer</code></td>
<td>
<p>Function that controls how labels are placed along
the isolines. Uses <code><a href="#topic+label_placer_minmax">label_placer_minmax()</a></code> by default.</p>
</td></tr>
<tr><td><code id="isolines_grob_+3A_units">units</code></td>
<td>
<p>A character string specifying the units in which to
interpret the isolines coordinates. Defaults to <code>"npc"</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="#topic+isobands_grob">isobands_grob()</a></code> for drawing of isobands. See <code><a href="#topic+label_placer_minmax">label_placer_minmax()</a></code> for
label placement strategies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(grid)

viridis_pal &lt;- colorRampPalette(
  c("#440154", "#414487", "#2A788E", "#22A884", "#7AD151", "#FDE725"),
  space = "Lab"
)

x &lt;- (1:ncol(volcano))/(ncol(volcano)+1)
y &lt;- (nrow(volcano):1)/(nrow(volcano)+1)
lines &lt;- isolines(x, y, volcano, 5*(19:38))
bands &lt;- isobands(x, y, volcano, 5*(18:38), 5*(19:39))

b &lt;- isobands_grob(
  bands,
  gp = gpar(col = NA, fill = viridis_pal(21), alpha = 0.4)
)
l &lt;- isolines_grob(
  lines, breaks = 20*(5:10),
  gp = gpar(
    lwd = c(.3, 1, .3, .3)
  )
)

grid.newpage()
grid.draw(b)
grid.draw(l)
</code></pre>

<hr>
<h2 id='label_placer_minmax'>Set up a label placement strategy</h2><span id='topic+label_placer_minmax'></span><span id='topic+label_placer_none'></span><span id='topic+label_placer_manual'></span><span id='topic+label_placer_middle'></span>

<h3>Description</h3>

<p>These functions set up various label placement strategies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_placer_minmax(
  placement = "tb",
  rot_adjuster = angle_halfcircle_bottom(),
  n = 2
)

label_placer_none()

label_placer_manual(breaks, x, y, theta)

label_placer_middle(rot_adjuster = angle_halfcircle_bottom())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_placer_minmax_+3A_placement">placement</code></td>
<td>
<p>String consisting of any combination of the letters
&quot;t&quot;, &quot;r&quot;, &quot;b&quot;, &quot;l&quot; indicating the placement of labels at the top,
to the right, at the bottom, to the left of the isoline.</p>
</td></tr>
<tr><td><code id="label_placer_minmax_+3A_rot_adjuster">rot_adjuster</code></td>
<td>
<p>Function that standardizes the rotation angles of the labels.
See e.g. <code><a href="#topic+angle_halfcircle_bottom">angle_halfcircle_bottom()</a></code>.</p>
</td></tr>
<tr><td><code id="label_placer_minmax_+3A_n">n</code></td>
<td>
<p>Size of the point neighborhood over which the rotation angle should be
calculated.</p>
</td></tr>
<tr><td><code id="label_placer_minmax_+3A_breaks">breaks</code></td>
<td>
<p>Character vector specifying the isolines to be labeled,
as in <code><a href="#topic+isolines_grob">isolines_grob()</a></code>.</p>
</td></tr>
<tr><td><code id="label_placer_minmax_+3A_x">x</code>, <code id="label_placer_minmax_+3A_y">y</code>, <code id="label_placer_minmax_+3A_theta">theta</code></td>
<td>
<p>Numeric vectors specifying the x and y positions and
angles (in radians) for each label corresponding to each break.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>label_placer_minmax()</code> places labels at the horizontal or vertical minima or maxima of
the respective isolines.
</p>
<p><code>label_placer_none()</code> places no labels at all.
</p>
<p><code>label_placer_manual()</code> places labels at manually defined locations.
</p>
<p><code>label_placer_middle()</code> places labels at the middle of each isoline.
</p>

<hr>
<h2 id='label_placer_simple'>Generic label placement function</h2><span id='topic+label_placer_simple'></span>

<h3>Description</h3>

<p>The simple label placer processes separate isolines independently and places
labels for each line using a placer function that does the actual placement work.
This label placer is not meant to be used by end users, but rather facilitates the
development of new label placers, such as <code><a href="#topic+label_placer_minmax">label_placer_minmax()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_placer_simple(lines, labels_data, placer_fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_placer_simple_+3A_lines">lines</code></td>
<td>
<p>Isolines object for which labels should be placed.</p>
</td></tr>
<tr><td><code id="label_placer_simple_+3A_labels_data">labels_data</code></td>
<td>
<p>A data frame containing information about which labels should
be placed.</p>
</td></tr>
<tr><td><code id="label_placer_simple_+3A_placer_fun">placer_fun</code></td>
<td>
<p>A function that takes an individual isoline plus its associated
break id as input and returns a data frame specifying label positions. The data
frame should have three columns called <code>x</code>, <code>y</code>, and <code>theta</code>. <code>x</code> and <code>y</code> specify
the label position, and <code>theta</code> specifies the label angle in radians. The data
frame can have multiple rows, which results in the same label being placed in
multiple locations.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_iso'>Visualize a single isoband</h2><span id='topic+plot_iso'></span>

<h3>Description</h3>

<p>This function visualizes a single isoband calculated from a matrix. It is mainly useful
for debugging and visualizing the isobanding algorithm. See <code><a href="#topic+isobands">isobands()</a></code> for more
examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_iso(
  m,
  vlo,
  vhi,
  fill_lo = "gray95",
  fill_mid = "gray50",
  fill_hi = "black",
  fill_band = "cornsilk",
  col_lo = "black",
  col_hi = "black",
  newpage = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_iso_+3A_m">m</code></td>
<td>
<p>input matrix</p>
</td></tr>
<tr><td><code id="plot_iso_+3A_vlo">vlo</code></td>
<td>
<p>lower cutoff for isobanding</p>
</td></tr>
<tr><td><code id="plot_iso_+3A_vhi">vhi</code></td>
<td>
<p>higher cutoff for isobanding</p>
</td></tr>
<tr><td><code id="plot_iso_+3A_fill_lo">fill_lo</code></td>
<td>
<p>fill color for points below the lower cutoff</p>
</td></tr>
<tr><td><code id="plot_iso_+3A_fill_mid">fill_mid</code></td>
<td>
<p>fill color for points between the two cutoffs</p>
</td></tr>
<tr><td><code id="plot_iso_+3A_fill_hi">fill_hi</code></td>
<td>
<p>fill color for points above the higher cutoff</p>
</td></tr>
<tr><td><code id="plot_iso_+3A_fill_band">fill_band</code></td>
<td>
<p>fill color for the isoband</p>
</td></tr>
<tr><td><code id="plot_iso_+3A_col_lo">col_lo</code></td>
<td>
<p>line color for lower cutoff</p>
</td></tr>
<tr><td><code id="plot_iso_+3A_col_hi">col_hi</code></td>
<td>
<p>line color for higher cutoff</p>
</td></tr>
<tr><td><code id="plot_iso_+3A_newpage">newpage</code></td>
<td>
<p>boolean, indicating whether <code>grid.newpage()</code> should
be called or not</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(0, 0, 0, 0, 0, 0,
              0, 2, 2, 2, 2, 0,
              0, 2, 0, 0, 2, 0,
              0, 2, 0, 0, 2, 0,
              0, 2, 2, 2, 2, 0,
              0, 0, 0, 0, 0, 0), 6, 6, byrow = TRUE)

plot_iso(m, 0.5, 1.5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
