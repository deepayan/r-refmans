<!DOCTYPE html><html><head><title>Help for package timsac</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {timsac}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Airpollution'><p>Airpollution Data</p></a></li>
<li><a href='#Amerikamaru'><p>Amerikamaru Data</p></a></li>
<li><a href='#armafit'><p>ARMA Model Fitting</p></a></li>
<li><a href='#auspec'><p>Power Spectrum</p></a></li>
<li><a href='#autcor'><p>Autocorrelation</p></a></li>
<li><a href='#autoarmafit'><p>Automatic ARMA Model Fitting</p></a></li>
<li><a href='#baysea'><p>Bayesian Seasonal Adjustment Procedure</p></a></li>
<li><a href='#bispec'><p>Bispectrum</p></a></li>
<li><a href='#bispecData'><p>Univariate Test Data</p></a></li>
<li><a href='#blocar'><p>Bayesian Method of Locally Stationary AR Model Fitting; Scalar Case</p></a></li>
<li><a href='#blomar'><p>Bayesian Method of Locally Stationary Multivariate AR Model Fitting</p></a></li>
<li><a href='#Blsallfood'><p>Blsallfood Data</p></a></li>
<li><a href='#bsubst'><p>Bayesian Type All Subset Analysis</p></a></li>
<li><a href='#Canadianlynx'><p>Time series of Canadian lynx data</p></a></li>
<li><a href='#canarm'><p>Canonical Correlation Analysis of Scalar Time Series</p></a></li>
<li><a href='#canoca'><p>Canonical Correlation Analysis of Vector Time Series</p></a></li>
<li><a href='#covgen'><p>Covariance Generation</p></a></li>
<li><a href='#decomp'><p>Time Series Decomposition (Seasonal Adjustment) by Square-Root Filter</p></a></li>
<li><a href='#exsar'><p>Exact Maximum Likelihood Method of Scalar AR Model Fitting</p></a></li>
<li><a href='#fftcor'><p>Auto And/Or Cross Correlations via FFT</p></a></li>
<li><a href='#fpeaut'><p>FPE Auto</p></a></li>
<li><a href='#fpec'><p>AR model Fitting for Control</p></a></li>
<li><a href='#LaborData'><p>Labor force Data</p></a></li>
<li><a href='#locarData'><p>Non-stationary Test Data</p></a></li>
<li><a href='#markov'><p>Maximum Likelihood Computation of Markovian Model</p></a></li>
<li><a href='#mfilter'><p>Linear Filtering on a Multivariate Time Series</p></a></li>
<li><a href='#mlocar'><p>Minimum AIC Method of Locally Stationary AR Model Fitting; Scalar Case</p></a></li>
<li><a href='#mlomar'><p>Minimum AIC Method of Locally Stationary Multivariate AR Model Fitting</p></a></li>
<li><a href='#mulbar'><p>Multivariate Bayesian Method of AR Model Fitting</p></a></li>
<li><a href='#mulcor'><p>Multiple Correlation</p></a></li>
<li><a href='#mulfrf'><p>Frequency Response Function (Multiple Channel)</p></a></li>
<li><a href='#mulmar'><p>Multivariate Case of Minimum AIC Method of AR Model Fitting</p></a></li>
<li><a href='#mulnos'><p>Relative Power Contribution</p></a></li>
<li><a href='#mulrsp'><p>Multiple Rational Spectrum</p></a></li>
<li><a href='#mulspe'><p>Multiple Spectrum</p></a></li>
<li><a href='#nonst'><p>Non-stationary Power Spectrum Analysis</p></a></li>
<li><a href='#nonstData'><p>Non-stationary Test Data</p></a></li>
<li><a href='#optdes'><p>Optimal Controller Design</p></a></li>
<li><a href='#optsim'><p>Optimal Control Simulation</p></a></li>
<li><a href='#perars'><p>Periodic Autoregression for a Scalar Time Series</p></a></li>
<li><a href='#plot.decomp'><p>Plot Trend, Seasonal, AR Components and Trading Day Factor</p></a></li>
<li><a href='#plot.specmx'><p>Plot Spectrum</p></a></li>
<li><a href='#Powerplant'><p>Power Plant Data</p></a></li>
<li><a href='#prdctr'><p>Prediction Program</p></a></li>
<li><a href='#raspec'><p>Rational Spectrum</p></a></li>
<li><a href='#sglfre'><p>Frequency Response Function (Single Channel)</p></a></li>
<li><a href='#simcon'><p>Optimal Controller Design and Simulation</p></a></li>
<li><a href='#thirmo'><p>Third Order Moments</p></a></li>
<li><a href='#timsac-package'>
<p>Time Series Analysis and Control Program Package</p></a></li>
<li><a href='#unibar'><p>Univariate Bayesian Method of AR Model Fitting</p></a></li>
<li><a href='#unimar'><p>Univariate Case of Minimum AIC Method of AR Model Fitting</p></a></li>
<li><a href='#wnoise'><p>White Noise Generator</p></a></li>
<li><a href='#xsarma'><p>Exact Maximum Likelihood Method of Scalar ARMA Model Fitting</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3.8-4</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series Analysis and Control Package</td>
</tr>
<tr>
<td>Author:</td>
<td>The Institute of Statistical Mathematics</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Masami Saga &lt;msaga@mtb.biglobe.ne.jp&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for statistical analysis, prediction and control of time
 series based mainly on Akaike and Nakagawa (1988) &lt;ISBN 978-90-277-2786-2&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>MailingList:</td>
<td>Please send bug reports to &lt;ismrp@grp.ism.ac.jp&gt;.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-29 09:54:20 UTC; msaga</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-30 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Airpollution'>Airpollution Data</h2><span id='topic+Airpollution'></span>

<h3>Description</h3>

<p>An airpollution data for testing <code><a href="#topic+perars">perars</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(Airpollution)
</code></pre>


<h3>Format</h3>

<p>A time series of 372 observations.
</p>


<h3>Source</h3>

<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>

<hr>
<h2 id='Amerikamaru'>Amerikamaru Data</h2><span id='topic+Amerikamaru'></span>

<h3>Description</h3>

<p>A multivariate non-stationary data for testing <code><a href="#topic+blomar">blomar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(Amerikamaru)
</code></pre>


<h3>Format</h3>

<p>A 2-dimensional array with 896 observations on 2 variables.
</p>

<table>
<tr>
 <td style="text-align: right;">
      [, 1] </td><td style="text-align: left;"> rudder</td>
</tr>
<tr>
 <td style="text-align: right;">
      [, 2] </td><td style="text-align: left;"> yawing
  </td>
</tr>

</table>



<h3>Source</h3>

<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>

<hr>
<h2 id='armafit'>ARMA Model Fitting</h2><span id='topic+armafit'></span>

<h3>Description</h3>

<p>Fit an ARMA model with specified order by using DAVIDON's algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  armafit(y, model.order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="armafit_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="armafit_+3A_model.order">model.order</code></td>
<td>
<p>a numerical vector of the form c(ar, ma) which gives
the order to be fitted successively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum likelihood estimates of the coefficients of a scalar ARMA model
</p>
<p style="text-align: center;"><code class="reqn">y(t) - a(1)y(t-1) -...- a(p)y(t-p) = u(t) - b(1)u(t-1) -...- b(q)u(t-q)</code>
</p>

<p>of a time series <code class="reqn">y(t)</code> are obtained by using DAVIDON's algorithm.
Pure autoregression is not allowed.
</p>


<h3>Value</h3>

<table>
<tr><td><code>arcoef</code></td>
<td>
<p>maximum likelihood estimates of AR coefficients.</p>
</td></tr>
<tr><td><code>macoef</code></td>
<td>
<p>maximum likelihood estimates of MA coefficients.</p>
</td></tr>
<tr><td><code>arstd</code></td>
<td>
<p>standard deviation (AR).</p>
</td></tr>
<tr><td><code>mastd</code></td>
<td>
<p>standard deviation (MA).</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>grad</code></td>
<td>
<p>final gradient.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1975) <em>Computer Science Monograph, No.5,
Timsac74, A Time Series Analysis and Control Program Package (1)</em>.
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "arima.sim" is a function in "stats".
# Note that the sign of MA coefficient is opposite from that in "timsac".
y &lt;- arima.sim(list(order=c(2,0,1), ar=c(0.64,-0.8), ma=-0.5), n = 1000)
z &lt;- armafit(y, model.order = c(2,1))
z$arcoef
z$macoef
</code></pre>

<hr>
<h2 id='auspec'>Power Spectrum</h2><span id='topic+auspec'></span>

<h3>Description</h3>

<p>Compute power spectrum estimates for two trigonometric windows of
Blackman-Tukey type by Goertzel method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auspec(y, lag = NULL, window = "Akaike", log = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auspec_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="auspec_+3A_lag">lag</code></td>
<td>
<p>maximum lag. Default is <code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code>
is the length of time series <code>y</code>.</p>
</td></tr>
<tr><td><code id="auspec_+3A_window">window</code></td>
<td>
<p>character string giving the definition of smoothing window.
Allowed strings are &quot;Akaike&quot; (default) or &quot;Hanning&quot;.</p>
</td></tr>
<tr><td><code id="auspec_+3A_log">log</code></td>
<td>
<p>logical. If <code>TRUE</code>, the spectrum <code>spec</code> is plotted as
log(<code>spec</code>).</p>
</td></tr>
<tr><td><code id="auspec_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), the spectrum <code>spec</code> is
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: right;">
    Hanning Window : </td><td style="text-align: left;"> a1(0)=0.5, </td><td style="text-align: left;"> a1(1)=a1(-1)=0.25, </td><td style="text-align: left;">
    a1(2)=a1(-2)=0</td>
</tr>
<tr>
 <td style="text-align: right;">
    Akaike Window  : </td><td style="text-align: left;"> a2(0)=0.625, </td><td style="text-align: left;"> a2(1)=a2(-1)=0.25, </td><td style="text-align: left;">
    a2(2)=a2(-2)=-0.0625
  </td>
</tr>

</table>



<h3>Value</h3>

<table>
<tr><td><code>spec</code></td>
<td>
<p>spectrum smoothing by '<code>window</code>'</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>test statistics.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control
of Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- arima.sim(list(order=c(2,0,0), ar=c(0.64,-0.8)), n = 200)
auspec(y, log = TRUE)
</code></pre>

<hr>
<h2 id='autcor'>Autocorrelation</h2><span id='topic+autcor'></span>

<h3>Description</h3>

<p>Estimate autocovariances and autocorrelations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autcor(y, lag = NULL, plot = TRUE, lag_axis = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autcor_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="autcor_+3A_lag">lag</code></td>
<td>
<p>maximum lag. Default is <code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code>
is the length of the time series <code>y</code>.</p>
</td></tr>
<tr><td><code id="autcor_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), autocorrelations are plotted.</p>
</td></tr>
<tr><td><code id="autcor_+3A_lag_axis">lag_axis</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) with plot = <code>TRUE</code>,
<code class="reqn">x</code>-axis is drawn.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>acov</code></td>
<td>
<p>autocovariances.</p>
</td></tr>
<tr><td><code>acor</code></td>
<td>
<p>autocorrelations (normalized covariances).</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>mean of <code>y</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control
of Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 for the normal distribution 
y &lt;- rnorm(200)
autcor(y, lag_axis = FALSE)

# Example 2 for the ARIMA model
y &lt;- arima.sim(list(order=c(2,0,0), ar=c(0.64,-0.8)), n = 200)
autcor(y, lag = 20)
</code></pre>

<hr>
<h2 id='autoarmafit'>Automatic ARMA Model Fitting</h2><span id='topic+autoarmafit'></span><span id='topic+print.autoarmafit'></span>

<h3>Description</h3>

<p>Provide an automatic ARMA model fitting procedure.
Models with various orders are fitted and the best choice is determined with
the aid of
the statistics AIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  autoarmafit(y, max.order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoarmafit_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="autoarmafit_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of AR order and MA order. Default is
<code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code> is the length of the time series
<code>y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum likelihood estimates of the coefficients of a scalar ARMA model
</p>
<p style="text-align: center;"><code class="reqn">y(t) - a(1)y(t-1) -...- a(p)y(t-p) = u(t) - b(1)u(t-1) -...- b(q)u(t-q)</code>
</p>

<p>of a time series <code class="reqn">y(t)</code> are obtained by using DAVIDON's variance algorithm.
Where <code class="reqn">p</code> is AR order, <code class="reqn">q</code> is MA order and <code class="reqn">u(t)</code> is a zero mean
white noise. Pure autoregression is not allowed.
</p>


<h3>Value</h3>

<table>
<tr><td><code>best.model</code></td>
<td>
<p>the best choice of ARMA coefficients.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>a list with components <code>arcoef</code> (Maximum likelihood
estimates of AR coefficients), <code>macoef</code> (Maximum likelihood estimates
of MA coefficients), <code>arstd</code> (AR standard deviation), <code>mastd</code>
(MA standard deviation), <code>v</code> (Innovation variance), <code>aic</code>
(AIC <code class="reqn">= n \log(det(v))+2(p+q)</code>) and <code>grad</code>
(Final gradient) in AIC increasing order.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1975) <em>Computer Science Monograph, No.5,
Timsac74, A Time Series Analysis and Control Program Package (1)</em>.
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "arima.sim" is a function in "stats".
# Note that the sign of MA coefficient is opposite from that in "timsac".
y &lt;- arima.sim(list(order=c(2,0,1),ar=c(0.64,-0.8),ma=-0.5), n = 1000)
autoarmafit(y)
</code></pre>

<hr>
<h2 id='baysea'>Bayesian Seasonal Adjustment Procedure</h2><span id='topic+baysea'></span>

<h3>Description</h3>

<p>Decompose a nonstationary time series into several possible components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  baysea(y, period = 12, span = 4, shift = 1, forecast = 0, trend.order = 2,
         seasonal.order = 1, year = 0, month = 1, out = 0, rigid = 1,
         zersum = 1, delta = 7, alpha = 0.01, beta = 0.01, gamma = 0.1,
         spec = TRUE, plot = TRUE, separate.graphics = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baysea_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="baysea_+3A_period">period</code></td>
<td>
<p>number of seasonals within a period.</p>
</td></tr>
<tr><td><code id="baysea_+3A_span">span</code></td>
<td>
<p>number of periods to be processed at one time.</p>
</td></tr>
<tr><td><code id="baysea_+3A_shift">shift</code></td>
<td>
<p>number of periods to be shifted to define the new span of data.</p>
</td></tr>
<tr><td><code id="baysea_+3A_forecast">forecast</code></td>
<td>
<p>length of forecast at the end of data.</p>
</td></tr>
<tr><td><code id="baysea_+3A_trend.order">trend.order</code></td>
<td>
<p>order of differencing of trend.</p>
</td></tr>
<tr><td><code id="baysea_+3A_seasonal.order">seasonal.order</code></td>
<td>
<p>order of differencing of seasonal. <code>seasonal.order</code>
is smaller than or equal to <code>span</code>.</p>
</td></tr>
<tr><td><code id="baysea_+3A_year">year</code></td>
<td>
<p>trading-day adjustment option. 
</p>

<table>
<tr>
 <td style="text-align: right;">
      = 0 : </td><td style="text-align: left;"> without trading day adjustment</td>
</tr>
<tr>
 <td style="text-align: right;">
      &gt; 0 : </td><td style="text-align: left;"> with trading day adjustment</td>
</tr>
<tr>
 <td style="text-align: right;">
     </td><td style="text-align: left;"> (the series is supposed to start at this <code>year</code>)
    </td>
</tr>

</table>
</td></tr>
<tr><td><code id="baysea_+3A_month">month</code></td>
<td>
<p>number of the month in which the series starts. If <code>year</code>=0
this parameter is ignored.</p>
</td></tr>
<tr><td><code id="baysea_+3A_out">out</code></td>
<td>
<p>outlier correction option.
</p>

<table>
<tr>
 <td style="text-align: right;">
      0 : </td><td style="text-align: left;"> without outlier detection</td>
</tr>
<tr>
 <td style="text-align: right;">
      1 : </td><td style="text-align: left;"> with outlier detection by marginal probability</td>
</tr>
<tr>
 <td style="text-align: right;">
      2 : </td><td style="text-align: left;"> with outlier detection by model selection
    </td>
</tr>

</table>
</td></tr>
<tr><td><code id="baysea_+3A_rigid">rigid</code></td>
<td>
<p>controls the rigidity of the seasonal component. more rigid
seasonal with larger than rigid.</p>
</td></tr>
<tr><td><code id="baysea_+3A_zersum">zersum</code></td>
<td>
<p>controls the sum of the seasonals within a period.</p>
</td></tr>
<tr><td><code id="baysea_+3A_delta">delta</code></td>
<td>
<p>controls the leap year effect.</p>
</td></tr>
<tr><td><code id="baysea_+3A_alpha">alpha</code></td>
<td>
<p>controls prior variance of initial trend.</p>
</td></tr>
<tr><td><code id="baysea_+3A_beta">beta</code></td>
<td>
<p>controls prior variance of initial seasonal.</p>
</td></tr>
<tr><td><code id="baysea_+3A_gamma">gamma</code></td>
<td>
<p>controls prior variance of initial sum of seasonal.</p>
</td></tr>
<tr><td><code id="baysea_+3A_spec">spec</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), estimate spectra of irregular
and differenced adjusted.</p>
</td></tr>
<tr><td><code id="baysea_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), plot <code>trend</code>, <code>adjust</code>,
<code>smoothed</code>, <code>season</code> and <code>irregular</code>.</p>
</td></tr>
<tr><td><code id="baysea_+3A_separate.graphics">separate.graphics</code></td>
<td>
<p>logical. If <code>TRUE</code>, a graphic device is opened
for each graphics display.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function realized a decomposition of time series <code>y</code> into the form
</p>
<p style="text-align: center;"><code class="reqn">y(t) = T(t) + S(t) + I(t) + TDC(t) + OCF(t)</code>
</p>

<p>where <code class="reqn">T(t)</code> is trend component, <code class="reqn">S(t)</code> is seasonal component,
<code class="reqn">I(t)</code> is irregular, <code class="reqn">TDC(t)</code> is trading day factor and <code class="reqn">OCF(t)</code>
is outlier correction factor. For the purpose of comparison of models the
criterion ABIC is defined
</p>
<p style="text-align: center;"><code class="reqn">ABIC = -2 \log(maximum\ likelihood\ of\ the\ model).</code>
</p>

<p>Smaller value of ABIC represents better fit.
</p>


<h3>Value</h3>

<table>
<tr><td><code>outlier</code></td>
<td>
<p>outlier correction factor.</p>
</td></tr>
<tr><td><code>trend</code></td>
<td>
<p>trend.</p>
</td></tr>
<tr><td><code>season</code></td>
<td>
<p>seasonal.</p>
</td></tr>
<tr><td><code>tday</code></td>
<td>
<p>trading day component if <code>year</code> &gt; 0.</p>
</td></tr>
<tr><td><code>irregular</code></td>
<td>
<p>= <code>y</code> - <code>trend</code> - <code>season</code> - <code>tday</code> -
<code>outlier</code>.</p>
</td></tr>
<tr><td><code>adjust</code></td>
<td>
<p>= <code>trend</code> - <code>irregular</code>.</p>
</td></tr>
<tr><td><code>smoothed</code></td>
<td>
<p>= <code>trend</code> + <code>season</code> + <code>tday</code>.</p>
</td></tr>
<tr><td><code>aveABIC</code></td>
<td>
<p>averaged ABIC.</p>
</td></tr>
<tr><td><code>irregular.spec</code></td>
<td>
<p>a list with components <code>acov</code> (autocovariances),
<code>acor</code> (normalized covariances), <code>mean</code>, <code>v</code> (innovation
variance), <code>aic</code> (AIC), <code>parcor</code> (partial autocorrelation) and
<code>rspec</code> (rational spectrum) of irregular if <code>spec</code> = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>adjusted.spec</code></td>
<td>
<p>a list with components <code>acov</code>, <code>acor</code>,
<code>mean</code>, <code>v</code>, <code>aic</code>, <code>parcor</code> and <code>rspec</code> of
differenced adjusted series if <code>spec</code> = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>differenced.trend</code></td>
<td>
<p>a list with components <code>acov</code>, <code>acor</code>,
<code>mean</code>, <code>v</code>, <code>aic</code> and <code>parcor</code> of differenced trend
series if <code>spec</code> = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>differenced.season</code></td>
<td>
<p>a list with components <code>acov</code>, <code>acor</code>,
<code>mean</code>, <code>v</code>, <code>aic</code> and <code>parcor</code> of differenced seasonal
series if <code>spec</code> = <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, T.Ozaki, M.Ishiguro, Y.Ogata, G.Kitagawa, Y-H.Tamura, E.Arahata,
K.Katsura and Y.Tamura (1985) <em>Computer Science Monograph, No.22,
Timsac84 Part 1</em>. The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LaborData)
baysea(LaborData, forecast = 12)
</code></pre>

<hr>
<h2 id='bispec'>Bispectrum</h2><span id='topic+bispec'></span>

<h3>Description</h3>

<p>Compute bi-spectrum using the direct Fourier transform of sample third order
moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bispec(y, lag = NULL, window = "Akaike", log = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bispec_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="bispec_+3A_lag">lag</code></td>
<td>
<p>maximum lag. Default is <code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code>
is the length of the time series <code>y</code>.</p>
</td></tr>
<tr><td><code id="bispec_+3A_window">window</code></td>
<td>
<p>character string giving the definition of smoothing window.
Allowed strings are &quot;Akaike&quot; (default) or &quot;Hanning&quot;.</p>
</td></tr>
<tr><td><code id="bispec_+3A_log">log</code></td>
<td>
<p>logical. If <code>TRUE</code>, the spectrum <code>pspec</code> is plotted as
<code class="reqn">log</code>(<code>pspec</code>).</p>
</td></tr>
<tr><td><code id="bispec_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), the spectrum <code>pspec</code> is
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: right;">
    Hanning Window : </td><td style="text-align: left;"> a1(0)=0.5,</td><td style="text-align: left;"> a1(1)=a1(-1)=0.25,</td><td style="text-align: left;">
    a1(2)=a1(-2)=0</td>
</tr>
<tr>
 <td style="text-align: right;">
    Akaike Window : </td><td style="text-align: left;"> a2(0)=0.625,</td><td style="text-align: left;"> a2(1)=a2(-1)=0.25,</td><td style="text-align: left;">
    a2(2)=a2(-2)=-0.0625
  </td>
</tr>

</table>



<h3>Value</h3>

<table>
<tr><td><code>pspec</code></td>
<td>
<p>power spectrum smoothed by '<code>window</code>'.</p>
</td></tr>
<tr><td><code>sig</code></td>
<td>
<p>significance.</p>
</td></tr>
<tr><td><code>cohe</code></td>
<td>
<p>coherence.</p>
</td></tr>
<tr><td><code>breal</code></td>
<td>
<p>real part of bispectrum.</p>
</td></tr>
<tr><td><code>bimag</code></td>
<td>
<p>imaginary part of bispectrum.</p>
</td></tr>
<tr><td><code>exval</code></td>
<td>
<p>approximate expected value of coherence under Gaussian assumption.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1975) <em>Computer Science Monograph, No.6,
Timsac74, A Time Series Analysis and Control Program Package (2)</em>.
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bispecData)
bispec(bispecData, lag = 30)
</code></pre>

<hr>
<h2 id='bispecData'>Univariate Test Data</h2><span id='topic+bispecData'></span>

<h3>Description</h3>

<p>A univariate data for testing <code><a href="#topic+bispec">bispec</a></code> and <code><a href="#topic+thirmo">thirmo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(bispecData)
</code></pre>


<h3>Format</h3>

<p>A time series of 1500 observations.
</p>


<h3>Source</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1976) <em>Computer Science Monograph, No.6,
Timsac74 A Time Series Analysis and Control Program Package (2)</em>.
The Institute of Statistical Mathematics.
</p>

<hr>
<h2 id='blocar'>Bayesian Method of Locally Stationary AR Model Fitting; Scalar Case</h2><span id='topic+blocar'></span>

<h3>Description</h3>

<p>Locally fit autoregressive models to non-stationary time series by a Bayesian
procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocar(y, max.order = NULL, span, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blocar_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="blocar_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of the order of AR model. Default is
<code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code> is the length of the time series
<code>y</code>.</p>
</td></tr>
<tr><td><code id="blocar_+3A_span">span</code></td>
<td>
<p>length of basic local span.</p>
</td></tr>
<tr><td><code id="blocar_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), spectrums <code>pspec</code> are
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic AR model of scalar time series <code class="reqn">y(t) (t=1, \ldots ,n)</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">y(t) = a(1)y(t-1) + a(2)y(t-2) +  \ldots + a(p)y(t-p) + u(t),</code>
</p>

<p>where <code class="reqn">p</code> is order of the model and <code class="reqn">u(t)</code> is Gaussian white noise
with mean <code class="reqn">0</code> and variance <code>v</code>. At each stage of modeling of locally
AR model, a two-step Bayesian procedure is applied
</p>

<table>
<tr>
 <td style="text-align: right;">
    1. </td><td style="text-align: left;"> Averaging of the models with different orders fitted to the newly
       obtained data.</td>
</tr>
<tr>
 <td style="text-align: right;">
    2. </td><td style="text-align: left;"> Averaging of the models fitted to the present and preceding spans.
  </td>
</tr>

</table>

<p>AIC of the model fitted to the new span is defined by
</p>
<p style="text-align: center;"><code class="reqn">AIC = ns \log( sd ) + 2k,</code>
</p>

<p>where <code class="reqn">ns</code> is the length of new data, <code class="reqn">sd</code> is innovation variance
and <code class="reqn">k</code> is the equivalent number of parameters, defined as the sum of
squares of the Bayesian weights. AIC of the model fitted to the preceding
spans are defined by
</p>
<p style="text-align: center;"><code class="reqn">AIC( j+1 ) = ns \log( sd(j) ) + 2,</code>
</p>

<p>where <code class="reqn">sd(j)</code> is the prediction error variance by the model fitted to
<code class="reqn">j</code> periods former span.
</p>


<h3>Value</h3>

<table>
<tr><td><code>var</code></td>
<td>
<p>variance.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>bweight</code></td>
<td>
<p>Bayesian weight.</p>
</td></tr>
<tr><td><code>pacoef</code></td>
<td>
<p>partial autocorrelation.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>coefficients ( average by the Bayesian weights ).</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>initial point of the data fitted to the current model.</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p>end point of the data fitted to the current model.</p>
</td></tr>
<tr><td><code>pspec</code></td>
<td>
<p>power spectrum.</p>
</td></tr>
</table>


<h3>References</h3>

<p>G.Kitagawa and H.Akaike (1978)
A Procedure for The Modeling of Non-Stationary Time Series.
Ann. Inst. Statist. Math., 30, B, 351&ndash;363.
</p>
<p>H.Akaike (1978)
A Bayesian Extension of the Minimum AIC Procedure of Autoregressive Model
Fitting. Research Memo. NO.126. The Institute of The Statistical Mathematics.
</p>
<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(locarData)
z &lt;- blocar(locarData, max.order = 10, span = 300)
z$arcoef
</code></pre>

<hr>
<h2 id='blomar'>Bayesian Method of Locally Stationary Multivariate AR Model Fitting</h2><span id='topic+blomar'></span><span id='topic+print.blomar'></span>

<h3>Description</h3>

<p>Locally fit multivariate autoregressive models to non-stationary time series
by a Bayesian procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  blomar(y, max.order = NULL, span)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blomar_+3A_y">y</code></td>
<td>
<p>A multivariate time series.</p>
</td></tr>
<tr><td><code id="blomar_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of the order of AR model, less than or equal to
<code class="reqn">n/2d</code> where <code class="reqn">n</code> is the length and <code class="reqn">d</code> is the dimension of the
time series <code>y</code>.
Default is <code class="reqn">min(2 \sqrt{n}, n/2d)</code>.</p>
</td></tr>
<tr><td><code id="blomar_+3A_span">span</code></td>
<td>
<p>length of basic local span. Let <code class="reqn">m</code> denote <code>max.order</code>,
if <code class="reqn">n-m-1</code> is less than or equal to <code>span</code> or <code class="reqn">n-m-1-</code><code>span</code>
is less than <code class="reqn">2md</code>, <code>span</code> is <code class="reqn">n-m</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic AR model is given by
</p>
<p style="text-align: center;"><code class="reqn">y(t) = A(1)y(t-1) + A(2)y(t-2) + \ldots + A(p)y(t-p) + u(t),</code>
</p>

<p>where <code class="reqn">p</code> is order of the AR model and <code class="reqn">u(t)</code> is innovation variance
<code>v</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mean</code></td>
<td>
<p>mean.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>variance.</p>
</td></tr>
<tr><td><code>bweight</code></td>
<td>
<p>Bayesian weight.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC with respect to the present data.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>AR coefficients. <code>arcoef[[m]][i,j,k]</code> shows the value of
<code class="reqn">i</code>-th row, <code class="reqn">j</code>-th column, <code class="reqn">k</code>-th order of <code class="reqn">m</code>-th model.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code>eaic</code></td>
<td>
<p>equivalent AIC of Bayesian model.</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>start point of the data fitted to the current model.</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p>end point of the data fitted to the current model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>G.Kitagawa and H.Akaike (1978)
A Procedure for the Modeling of Non-stationary Time Series.
Ann. Inst. Statist. Math., 30, B, 351&ndash;363.
</p>
<p>H.Akaike (1978)
A Bayesian Extension of The Minimum AIC Procedure of Autoregressive Model
Fitting. Research Memo. NO.126. The institute of Statistical Mathematics.
</p>
<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Amerikamaru)
blomar(Amerikamaru, max.order = 10, span = 300)
</code></pre>

<hr>
<h2 id='Blsallfood'>Blsallfood Data</h2><span id='topic+Blsallfood'></span>

<h3>Description</h3>

<p>The BLSALLFOOD data. (the Bureau of Labor Statistics, all employees in food industries, January 1967 - December 1979)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(Blsallfood)
</code></pre>


<h3>Format</h3>

<p>A time series of 156 observations.
</p>


<h3>Source</h3>

<p>H.Akaike, T.Ozaki, M.Ishiguro, Y.Ogata, G.Kitagawa, Y-H.Tamura, E.Arahata,
K.Katsura and Y.Tamura (1984) <em>Computer Science Monographs, Timsac-84
Part 1.</em> The Institute of Statistical Mathematics.
</p>

<hr>
<h2 id='bsubst'>Bayesian Type All Subset Analysis</h2><span id='topic+bsubst'></span>

<h3>Description</h3>

<p>Produce Bayesian estimates of time series models such as pure AR models, AR
models with non-linear terms, AR models with polynomial type mean value
functions, etc. The goodness of fit of a model is checked by the analysis of
several steps ahead prediction errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsubst(y, mtype, lag = NULL, nreg, reg = NULL, term.lag = NULL, cstep = 5,
       plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsubst_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="bsubst_+3A_mtype">mtype</code></td>
<td>
<p>model type. Allowed values are
</p>

<table>
<tr>
 <td style="text-align: right;">
      1 : </td><td style="text-align: left;"> autoregressive model,</td>
</tr>
<tr>
 <td style="text-align: right;">
      2 : </td><td style="text-align: left;"> polynomial type non-linear model (lag's read in),</td>
</tr>
<tr>
 <td style="text-align: right;">
      3 : </td><td style="text-align: left;"> polynomial type non-linear model (lag's automatically set),</td>
</tr>
<tr>
 <td style="text-align: right;">
      4 : </td><td style="text-align: left;"> AR-model with polynomial mean value function,</td>
</tr>
<tr>
 <td style="text-align: right;">
      5,6,7 : </td><td style="text-align: left;"> originally defined but omitted here.
    </td>
</tr>

</table>
</td></tr>
<tr><td><code id="bsubst_+3A_lag">lag</code></td>
<td>
<p>maximum time lag. Default is <code class="reqn">2 \sqrt{n}</code>, where
<code class="reqn">n</code> is the length of the time series <code>y</code>.</p>
</td></tr>
<tr><td><code id="bsubst_+3A_nreg">nreg</code></td>
<td>
<p>number of regressors.</p>
</td></tr>
<tr><td><code id="bsubst_+3A_reg">reg</code></td>
<td>
<p>specification of regressor (<code>mtype</code> = 2).<br />
<code class="reqn">i</code>-th regressor is defined by <code class="reqn">z(n-L1(i)) \times z(n-L2(i)) \times
    z(n-L3(i))</code>,
where <code class="reqn">L1(i)</code> is <code>reg(1,i)</code>, <code class="reqn">L2(i)</code> is <code>reg(2,i)</code> and
<code class="reqn">L3(i)</code> is <code>reg(3,i)</code>.
<code class="reqn">0</code>-lag term <code class="reqn">z(n-0)</code> is replaced by the constant <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="bsubst_+3A_term.lag">term.lag</code></td>
<td>
<p>maximum time lag specify the regressors
(<code class="reqn">L1(i),L2(i),L3(i)</code>) (i=1,...,<code>nreg</code>) (<code>mtype</code> = 3).
</p>

<table>
<tr>
 <td style="text-align: right;">
      term.lag[1] : </td><td style="text-align: left;"> maximum time lag of linear term</td>
</tr>
<tr>
 <td style="text-align: right;">
      term.lag[2] : </td><td style="text-align: left;"> maximum time lag of squared term</td>
</tr>
<tr>
 <td style="text-align: right;">
      term.lag[3] : </td><td style="text-align: left;"> maximum time lag of quadratic crosses term</td>
</tr>
<tr>
 <td style="text-align: right;">
      term.lag[4] : </td><td style="text-align: left;"> maximum time lag of cubic term</td>
</tr>
<tr>
 <td style="text-align: right;">
      term.lag[5] : </td><td style="text-align: left;"> maximum time lag of cubic cross term.
    </td>
</tr>

</table>
</td></tr>
<tr><td><code id="bsubst_+3A_cstep">cstep</code></td>
<td>
<p>prediction errors checking (up to <code>cstep</code>-steps ahead) is
requested. (<code>mtype</code> = 1, 2, 3).</p>
</td></tr>
<tr><td><code id="bsubst_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), <code>daic</code>, <code>perr</code> and
<code>peautcor</code> are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AR model is given by ( <code>mtype</code> = 2 )<br />
</p>
<p style="text-align: center;"><code class="reqn">y(t) = a(1)y(t-1) + ... + a(p)y(t-p) + u(t).</code>
</p>

<p>The non-linear model is given by ( <code>mtype</code> = 2, 3 )<br />
</p>
<p style="text-align: center;"><code class="reqn">y(t) = a(1)z(t,1) + a(2)z(t,2) + ... + a(p)z(t,p) + u(t).</code>
</p>

<p>Where <code class="reqn">p</code> is AR order and <code class="reqn">u(t)</code> is Gaussian white noise with mean
<code class="reqn">0</code> and variance <code class="reqn">v(p)</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ymean</code></td>
<td>
<p>mean of <code>y</code>.</p>
</td></tr>
<tr><td><code>yvar</code></td>
<td>
<p>variance of <code>y</code>.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC(m), (m=0,  ... <code>nreg</code>).</p>
</td></tr>
<tr><td><code>aicmin</code></td>
<td>
<p>minimum AIC.</p>
</td></tr>
<tr><td><code>daic</code></td>
<td>
<p>AIC(m)-<code>aicmin</code> (m=0, ... <code>nreg</code>).</p>
</td></tr>
<tr><td><code>order.maice</code></td>
<td>
<p>order of minimum AIC.</p>
</td></tr>
<tr><td><code>v.maice</code></td>
<td>
<p>innovation variance attained at <code>order.maice</code>.</p>
</td></tr>
<tr><td><code>arcoef.maice</code></td>
<td>
<p>AR coefficients attained at <code>order.maice</code>.</p>
</td></tr>
<tr><td><code>v.bay</code></td>
<td>
<p>residual variance of Bayesian model.</p>
</td></tr>
<tr><td><code>aic.bay</code></td>
<td>
<p>AIC of Bayesian model.</p>
</td></tr>
<tr><td><code>np.bay</code></td>
<td>
<p>equivalent number of parameters.</p>
</td></tr>
<tr><td><code>arcoef.bay</code></td>
<td>
<p>AR coefficients of Bayesian model.</p>
</td></tr>
<tr><td><code>ind.c</code></td>
<td>
<p>index of <code>parcor2</code> in order of increasing magnitude.</p>
</td></tr>
<tr><td><code>parcor2</code></td>
<td>
<p>square of partial correlations (normalized by multiplying N).</p>
</td></tr>
<tr><td><code>damp</code></td>
<td>
<p>binomial type damper.</p>
</td></tr>
<tr><td><code>bweight</code></td>
<td>
<p>final Bayesian weights of partial correlations.</p>
</td></tr>
<tr><td><code>parcor.bay</code></td>
<td>
<p>partial correlations of the Bayesian model.</p>
</td></tr>
<tr><td><code>eicmin</code></td>
<td>
<p>minimum EIC.</p>
</td></tr>
<tr><td><code>esum</code></td>
<td>
<p>whole subset regression models.</p>
</td></tr>
<tr><td><code>npmean</code></td>
<td>
<p>mean of number of parameter.</p>
</td></tr>
<tr><td><code>npmean.nreg</code></td>
<td>
<p>= <code>npmean</code> / <code>nreg</code>.</p>
</td></tr>
<tr><td><code>perr</code></td>
<td>
<p>prediction error.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>mean.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>variance.</p>
</td></tr>
<tr><td><code>skew</code></td>
<td>
<p>skewness.</p>
</td></tr>
<tr><td><code>peak</code></td>
<td>
<p>peakedness.</p>
</td></tr>
<tr><td><code>peautcor</code></td>
<td>
<p>autocorrelation function of 1-step ahead prediction error.</p>
</td></tr>
<tr><td><code>pspec</code></td>
<td>
<p>power spectrum (<code>mtype</code> = 1).</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canadianlynx)
Regressor &lt;- matrix(
     c( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 1, 3, 1, 2, 3,
        0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0, 1, 2, 2, 3, 1, 2, 3,
        0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0, 0, 0, 0, 0, 1, 2, 3 ),
     nrow = 3, ncol = 19, byrow = TRUE)
z &lt;- bsubst(Canadianlynx, mtype = 2, lag = 12, nreg = 19, Regressor)
z$arcoef.bay
</code></pre>

<hr>
<h2 id='Canadianlynx'>Time series of Canadian lynx data</h2><span id='topic+Canadianlynx'></span>

<h3>Description</h3>

<p>A time series of Canadian lynx data for testing <code><a href="#topic+unimar">unimar</a></code>,
<code><a href="#topic+unibar">unibar</a></code>, <code><a href="#topic+bsubst">bsubst</a></code> and <code><a href="#topic+exsar">exsar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(Canadianlynx)
</code></pre>


<h3>Format</h3>

<p>A time series of 114 observations.
</p>


<h3>Source</h3>

<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>

<hr>
<h2 id='canarm'>Canonical Correlation Analysis of Scalar Time Series</h2><span id='topic+canarm'></span>

<h3>Description</h3>

<p>Fit an ARMA model to stationary scalar time series through the analysis of
canonical correlations between the future and past sets of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canarm(y, lag = NULL, max.order = NULL, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canarm_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="canarm_+3A_lag">lag</code></td>
<td>
<p>maximum lag. Default is <code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code>
is the length of the time series <code>y</code>.</p>
</td></tr>
<tr><td><code id="canarm_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of AR order and MA order, must be less than or
equal to <code>lag</code>. Default is <code>lag</code>.</p>
</td></tr>
<tr><td><code id="canarm_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), <code>parcor</code> is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ARMA model of stationary scalar time series <code class="reqn">y(t) (t=1,...,n)</code> is
given by
</p>
<p style="text-align: center;"><code class="reqn">y(t) - a(1)y(t-1) - ...- a(p)y(t-p) = u(t) - b(1)u(t-1) - ... - b(q)u(t-q),</code>
</p>

<p>where <code class="reqn">p</code> is AR order and <code class="reqn">q</code> is MA order.
</p>


<h3>Value</h3>

<table>
<tr><td><code>arinit</code></td>
<td>
<p>AR coefficients of initial AR model fitting by the minimum AIC
procedure.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation vector.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>aicmin</code></td>
<td>
<p>minimum AIC.</p>
</td></tr>
<tr><td><code>order.maice</code></td>
<td>
<p>order of minimum AIC.</p>
</td></tr>
<tr><td><code>parcor</code></td>
<td>
<p>partial autocorrelation.</p>
</td></tr>
<tr><td><code>nc</code></td>
<td>
<p>total number of case.</p>
</td></tr>
<tr><td><code>future</code></td>
<td>
<p>number of present and future variables.</p>
</td></tr>
<tr><td><code>past</code></td>
<td>
<p>number of present and past variables.</p>
</td></tr>
<tr><td><code>cweight</code></td>
<td>
<p>future set canonical weight.</p>
</td></tr>
<tr><td><code>canocoef</code></td>
<td>
<p>canonical R.</p>
</td></tr>
<tr><td><code>canocoef2</code></td>
<td>
<p>R-squared.</p>
</td></tr>
<tr><td><code>chisquar</code></td>
<td>
<p>chi-square.</p>
</td></tr>
<tr><td><code>ndf</code></td>
<td>
<p>N.D.F.</p>
</td></tr>
<tr><td><code>dic</code></td>
<td>
<p>DIC.</p>
</td></tr>
<tr><td><code>dicmin</code></td>
<td>
<p>minimum DIC.</p>
</td></tr>
<tr><td><code>order.dicmin</code></td>
<td>
<p>order of minimum DIC.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>AR coefficients <code class="reqn">a(i) (i = 1,...,p)</code>.</p>
</td></tr>
<tr><td><code>macoef</code></td>
<td>
<p>MA coefficients <code class="reqn">b(i) (i = 1,...,q)</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1975) <em>Computer Science Monograph, No.5,
Timsac74, A Time Series Analysis and Control Program Package (1)</em>.
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "arima.sim" is a function in "stats".
# Note that the sign of MA coefficient is opposite from that in "timsac".
y &lt;- arima.sim(list(order=c(2,0,1), ar=c(0.64,-0.8), ma=c(-0.5)), n = 1000)
z &lt;- canarm(y, max.order = 30)
z$arcoef
z$macoef
</code></pre>

<hr>
<h2 id='canoca'>Canonical Correlation Analysis of Vector Time Series</h2><span id='topic+canoca'></span>

<h3>Description</h3>

<p>Analyze canonical correlation of a d-dimensional multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canoca(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canoca_+3A_y">y</code></td>
<td>
<p>a multivariate time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First AR model is fitted by the minimum AIC procedure. The results are used to
ortho-normalize the present and past variables. The present and future
variables are tested successively to decide on the dependence of their
predictors. When the last DIC (=chi-square - 2.0*N.D.F.) is negative the
predictor of the variable is decided to be linearly dependent on the
antecedents.
</p>


<h3>Value</h3>

<table>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>aicmin</code></td>
<td>
<p>minimum AIC.</p>
</td></tr>
<tr><td><code>order.maice</code></td>
<td>
<p>MAICE AR model order.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>autoregressive coefficients. <code>arcoef[i,j,k]</code> shows the
value of <code class="reqn">i</code>-th row, <code class="reqn">j</code>-th column, <code class="reqn">k</code>-th order.</p>
</td></tr>
<tr><td><code>nc</code></td>
<td>
<p>number of cases.</p>
</td></tr>
<tr><td><code>future</code></td>
<td>
<p>number of variable in the future set.</p>
</td></tr>
<tr><td><code>past</code></td>
<td>
<p>number of variables in the past set.</p>
</td></tr>
<tr><td><code>cweight</code></td>
<td>
<p>future set canonical weight.</p>
</td></tr>
<tr><td><code>canocoef</code></td>
<td>
<p>canonical R.</p>
</td></tr>
<tr><td><code>canocoef2</code></td>
<td>
<p>R-squared.</p>
</td></tr>
<tr><td><code>chisquar</code></td>
<td>
<p>chi-square.</p>
</td></tr>
<tr><td><code>ndf</code></td>
<td>
<p>N.D.F.</p>
</td></tr>
<tr><td><code>dic</code></td>
<td>
<p>DIC.</p>
</td></tr>
<tr><td><code>dicmin</code></td>
<td>
<p>minimum DIC.</p>
</td></tr>
<tr><td><code>order.dicmin</code></td>
<td>
<p>order of minimum DIC.</p>
</td></tr>
<tr><td><code>matF</code></td>
<td>
<p>the transition matrix <code class="reqn">F</code>.</p>
</td></tr>
<tr><td><code>vectH</code></td>
<td>
<p>structural characteristic vector <code class="reqn">H</code> of the canonical
Markovian representation.</p>
</td></tr>
<tr><td><code>matG</code></td>
<td>
<p>the estimate of the input matrix <code class="reqn">G</code>.</p>
</td></tr>
<tr><td><code>vectF</code></td>
<td>
<p>matrix <code class="reqn">F</code> in vector form.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1975) <em>Computer Science Monograph, No.5,
Timsac74, A Time Series Analysis and Control Program Package (1)</em>.
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar &lt;- array(0, dim = c(3,3,2))
ar[, , 1] &lt;- matrix(c(0.4,  0,   0.3,
                      0.2, -0.1, -0.5,
                      0.3,  0.1, 0), nrow = 3, ncol = 3, byrow= TRUE)
ar[, , 2] &lt;- matrix(c(0,  -0.3,  0.5,
                      0.7, -0.4,  1,
                      0,   -0.5,  0.3), nrow = 3, ncol = 3, byrow = TRUE)
x &lt;- matrix(rnorm(1000*3), nrow = 1000, ncol = 3)
y &lt;- mfilter(x, ar, "recursive")
z &lt;- canoca(y)
z$arcoef
</code></pre>

<hr>
<h2 id='covgen'>Covariance Generation</h2><span id='topic+covgen'></span>

<h3>Description</h3>

<p>Produce the Fourier transform of a power gain function in the form of an
autocovariance
sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  covgen(lag, f, gain, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covgen_+3A_lag">lag</code></td>
<td>
<p>desired maximum lag of covariance.</p>
</td></tr>
<tr><td><code id="covgen_+3A_f">f</code></td>
<td>
<p>frequency <code>f[i]</code> <code class="reqn">(i=1,...,k)</code>, where <code class="reqn">k</code> is the number
of data points. By definition <code>f[1]</code> = 0.0 and <code>f[k]</code> = 0.5,
<code>f[i]</code>'s are arranged in increasing order.</p>
</td></tr>
<tr><td><code id="covgen_+3A_gain">gain</code></td>
<td>
<p>power gain of the filter at the frequency <code>f[i]</code>.</p>
</td></tr>
<tr><td><code id="covgen_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), autocorrelations are plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>acov</code></td>
<td>
<p>autocovariance.</p>
</td></tr>
<tr><td><code>acor</code></td>
<td>
<p>autocovariance normalized.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1975) <em>Computer Science Monograph, No.5,
Timsac74, A Time Series Analysis and Control Program Package (1)</em>.
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spec &lt;- raspec(h = 100, var = 1, arcoef = c(0.64,-0.8), plot = FALSE)
covgen(lag = 100, f = 0:100/200, gain = spec)
</code></pre>

<hr>
<h2 id='decomp'>Time Series Decomposition (Seasonal Adjustment) by Square-Root Filter</h2><span id='topic+decomp'></span>

<h3>Description</h3>

<p>Decompose a nonstationary time series into several possible components by
square-root filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  decomp(y, trend.order = 2, ar.order = 2, seasonal.order = 1, 
         period = 1, log = FALSE, trade = FALSE, diff = 1,
         miss = 0, omax = 99999.9, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomp_+3A_y">y</code></td>
<td>
<p>a univariate time series with or without the tsp attribute.</p>
</td></tr>
<tr><td><code id="decomp_+3A_trend.order">trend.order</code></td>
<td>
<p>trend order (1, 2 or 3).</p>
</td></tr>
<tr><td><code id="decomp_+3A_ar.order">ar.order</code></td>
<td>
<p>AR order (less than 11, try 2 first).</p>
</td></tr>
<tr><td><code id="decomp_+3A_seasonal.order">seasonal.order</code></td>
<td>
<p>seasonal order (0, 1 or 2).</p>
</td></tr>
<tr><td><code id="decomp_+3A_period">period</code></td>
<td>
<p>number of seasons in one period. If the tsp attribute of
<code>y</code> is not <code>NULL</code>, <code>frequency(y)</code>.</p>
</td></tr>
<tr><td><code id="decomp_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, a log scale is in use.</p>
</td></tr>
<tr><td><code id="decomp_+3A_trade">trade</code></td>
<td>
<p>logical; if <code>TRUE</code>, the model including trading day effect
component is concidered, where <code>tsp(y)</code> is not null and 
<code>frequency(y)</code> is 4 or 12.</p>
</td></tr>
<tr><td><code id="decomp_+3A_diff">diff</code></td>
<td>
<p>numerical differencing (1 sided or 2 sided).</p>
</td></tr>
<tr><td><code id="decomp_+3A_miss">miss</code></td>
<td>
<p>missing value flag.
</p>

<table>
<tr>
 <td style="text-align: right;">
      = 0 : </td><td style="text-align: left;"> no consideration</td>
</tr>
<tr>
 <td style="text-align: right;">
      &gt; 0 : </td><td style="text-align: left;"> values which are greater than <code>omax</code> are treated as
            missing data</td>
</tr>
<tr>
 <td style="text-align: right;">
      &lt; 0 : </td><td style="text-align: left;"> values which are less than <code>omax</code> are treated as missing
            data
    </td>
</tr>

</table>
</td></tr>
<tr><td><code id="decomp_+3A_omax">omax</code></td>
<td>
<p>maximum or minimum data value (if <code>miss</code> &gt; 0 or <code>miss</code> &lt;
0).</p>
</td></tr>
<tr><td><code id="decomp_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), <code>trend</code>, <code>seasonal</code>,
<code>ar</code> and <code>trad</code> are plotted.</p>
</td></tr>
<tr><td><code id="decomp_+3A_...">...</code></td>
<td>
<p>graphical arguments passed to <code><a href="#topic+plot.decomp">plot.decomp</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Basic Model<br />
</p>
<p style="text-align: center;"><code class="reqn">y(t) = T(t) + AR(t) + S(t) + TD(t) + W(t)</code>
</p>

<p>where <code class="reqn">T(t)</code> is trend component, <code class="reqn">AR(t)</code> is AR process, <code class="reqn">S(t)</code> is
seasonal component, <code class="reqn">TD(t)</code> is trading day factor and <code class="reqn">W(t)</code> is
observational noise. <br />
</p>
<p>Component Models
</p>

<ul>
<li><p> Trend component  (trend.order m1)
</p>
<p><code class="reqn">m1 = 1 : T(t) = T(t-1) + v1(t)</code>
</p>
<p><code class="reqn">m1 = 2 : T(t) = 2T(t-1) - T(t-2) + v1(t)</code>
</p>
<p><code class="reqn">m1 = 3 : T(t) = 3T(t-1) - 3T(t-2) + T(t-2) + v1(t)</code>
</p>
</li>
<li><p> AR component  (ar.order m2)
</p>
<p><code class="reqn">AR(t) = a(1)AR(t-1) + \ldots + a(m2)AR(t-m2) + v2(t)</code><br />
</p>
</li>
<li><p> Seasonal component  (seasonal.order k, frequency f)
</p>
<p><code class="reqn">k=1 : S(t) = -S(t-1) - \ldots - S(t-f+1) + v3(t)</code><br />
<code class="reqn">k=2 : S(t) = -2S(t-1) - \ldots -f\ S(t-f+1) - \ldots - S(t-2f+2) + v3(t)</code><br />
</p>
</li>
<li><p> Trading day effect
</p>
<p><code class="reqn">TD(t) = b(1) TRADE(t,1) + \ldots + b(7) TRADE(t,7)</code>
</p>
<p>where <code class="reqn">TRADE(t,i)</code> is the number of <code class="reqn">i</code>-th days of the week in
<code class="reqn">t</code>-th data and <code class="reqn">b(1)\ +\ \ldots\ +\ b(7)\ =\ 0</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"decomp"</code>, which is a list with the following
components:
</p>
<table>
<tr><td><code>trend</code></td>
<td>
<p>trend component.</p>
</td></tr>
<tr><td><code>seasonal</code></td>
<td>
<p>seasonal component.</p>
</td></tr>
<tr><td><code>ar</code></td>
<td>
<p>AR process.</p>
</td></tr>
<tr><td><code>trad</code></td>
<td>
<p>trading day factor.</p>
</td></tr>
<tr><td><code>noise</code></td>
<td>
<p>observational noise.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>lkhd</code></td>
<td>
<p>likelihood.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>sigma^2.</p>
</td></tr>
<tr><td><code>tau1</code></td>
<td>
<p>system noise variances <code class="reqn">v1</code>.</p>
</td></tr>
<tr><td><code>tau2</code></td>
<td>
<p>system noise variances <code class="reqn">v2</code> or <code class="reqn">v3</code>.</p>
</td></tr>
<tr><td><code>tau3</code></td>
<td>
<p>system noise variances <code class="reqn">v3</code>.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>vector of AR coefficients.</p>
</td></tr>
<tr><td><code>tdf</code></td>
<td>
<p>trading day factor. <code>tdf(i)</code> (i=1,7) are from Sunday to
Saturday sequentially.</p>
</td></tr>
<tr><td><code>conv.y</code></td>
<td>
<p>Missing values are replaced by NA after the specified
logarithmic transformation..</p>
</td></tr>
</table>


<h3>References</h3>

<p>G.Kitagawa (1981) <em>A Nonstationary Time Series Model and Its Fitting by a
Recursive Filter</em> Journal of Time Series Analysis, Vol.2, 103-116.
</p>
<p>W.Gersch and G.Kitagawa (1983) <em>The prediction of time series with Trends
and Seasonalities</em> Journal of Business and Economic Statistics, Vol.1, 253-264.
</p>
<p>G.Kitagawa (1984)
<em>A smoothness priors-state space modeling of Time Series with Trend and
Seasonality</em> Journal of American Statistical Association, VOL.79, NO.386,
378-389.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Blsallfood)
y &lt;- ts(Blsallfood, start=c(1967,1), frequency=12)
z &lt;- decomp(y, trade = TRUE)
z$aic
z$lkhd
z$sigma2
z$tau1
z$tau2
z$tau3
</code></pre>

<hr>
<h2 id='exsar'>Exact Maximum Likelihood Method of Scalar AR Model Fitting</h2><span id='topic+exsar'></span>

<h3>Description</h3>

<p>Produce exact maximum likelihood estimates of the parameters of a scalar AR
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  exsar(y, max.order = NULL, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exsar_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="exsar_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of AR order. Default is <code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code> is the length of the time series <code>y</code>.</p>
</td></tr>
<tr><td><code id="exsar_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>daic</code> is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AR model is given by
</p>
<p style="text-align: center;"><code class="reqn">y(t) = a(1)y(t-1) + .... + a(p)y(t-p) + u(t)</code>
</p>

<p>where <code class="reqn">p</code> is AR order and <code class="reqn">u(t)</code> is a zero mean white noise.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mean</code></td>
<td>
<p>mean.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>variance.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>aicmin</code></td>
<td>
<p>minimum AIC.</p>
</td></tr>
<tr><td><code>daic</code></td>
<td>
<p>AIC-<code>aicmin</code>.</p>
</td></tr>
<tr><td><code>order.maice</code></td>
<td>
<p>order of minimum AIC.</p>
</td></tr>
<tr><td><code>v.maice</code></td>
<td>
<p>MAICE innovation variance.</p>
</td></tr>
<tr><td><code>arcoef.maice</code></td>
<td>
<p>MAICE AR coefficients.</p>
</td></tr>
<tr><td><code>v.mle</code></td>
<td>
<p>maximum likelihood estimates of innovation variance.</p>
</td></tr>
<tr><td><code>arcoef.mle</code></td>
<td>
<p>maximum likelihood estimates of AR coefficients.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canadianlynx)
z &lt;- exsar(Canadianlynx, max.order = 14)
z$arcoef.maice
z$arcoef.mle
</code></pre>

<hr>
<h2 id='fftcor'>Auto And/Or Cross Correlations via FFT</h2><span id='topic+fftcor'></span>

<h3>Description</h3>

<p>Compute auto and/or cross covariances and correlations via FFT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fftcor(y, lag = NULL, isw = 4, plot = TRUE, lag_axis = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftcor_+3A_y">y</code></td>
<td>
<p>data of channel X and Y (data of channel Y is given for <code>isw</code> =
2 or 4 only).</p>
</td></tr>
<tr><td><code id="fftcor_+3A_lag">lag</code></td>
<td>
<p>maximum lag. Default is <code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code>
is the length of the time series <code>y</code>.</p>
</td></tr>
<tr><td><code id="fftcor_+3A_isw">isw</code></td>
<td>
<p>numerical flag giving the type of computation.
</p>

<table>
<tr>
 <td style="text-align: right;">
      1 : </td><td style="text-align: left;"> auto-correlation of X (one-channel)</td>
</tr>
<tr>
 <td style="text-align: right;">
      2 : </td><td style="text-align: left;"> auto-correlations of X and Y (two-channel)</td>
</tr>
<tr>
 <td style="text-align: right;">
      4 : </td><td style="text-align: left;"> auto- and cross- correlations of X and Y (two-channel)
    </td>
</tr>

</table>
</td></tr>
<tr><td><code id="fftcor_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), cross-correlations are plotted.</p>
</td></tr>
<tr><td><code id="fftcor_+3A_lag_axis">lag_axis</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) with plot=TRUE, <code class="reqn">x</code>-axis
is drawn.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>acov</code></td>
<td>
<p>auto-covariance.</p>
</td></tr>
<tr><td><code>ccov12</code></td>
<td>
<p>cross-covariance.</p>
</td></tr>
<tr><td><code>ccov21</code></td>
<td>
<p>cross-covariance.</p>
</td></tr>
<tr><td><code>acor</code></td>
<td>
<p>auto-correlation.</p>
</td></tr>
<tr><td><code>ccor12</code></td>
<td>
<p>cross-correlation.</p>
</td></tr>
<tr><td><code>ccor21</code></td>
<td>
<p>cross-correlation.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>mean.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control
of Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
x &lt;- rnorm(200)
y &lt;- rnorm(200)
xy &lt;- array(c(x,y), dim = c(200,2))
fftcor(xy, lag_axis = FALSE)

# Example 2
xorg &lt;- rnorm(1003)
x &lt;- matrix(0, nrow = 1000, ncol = 2)
x[, 1] &lt;- xorg[1:1000]
x[, 2] &lt;- xorg[4:1003] + 0.5*rnorm(1000)
fftcor(x, lag = 20)
</code></pre>

<hr>
<h2 id='fpeaut'>FPE Auto</h2><span id='topic+fpeaut'></span>

<h3>Description</h3>

<p>Perform FPE(Final Prediction Error) computation for one-dimensional AR model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fpeaut(y, max.order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpeaut_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="fpeaut_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of model order. Default is
<code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code> is the length of the time series
<code>y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AR model is given by
</p>
<p style="text-align: center;"><code class="reqn">y(t) = a(1)y(t-1) + .... + a(p)y(t-p) + u(t)</code>
</p>

<p>where <code class="reqn">p</code> is AR order and <code class="reqn">u(t)</code> is a zero mean white noise.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ordermin</code></td>
<td>
<p>order of minimum FPE.</p>
</td></tr>
<tr><td><code>best.ar</code></td>
<td>
<p>AR coefficients with minimum FPE.</p>
</td></tr>
<tr><td><code>sigma2m</code></td>
<td>
<p>= <code>sigma2</code>(<code>ordermin</code>).</p>
</td></tr>
<tr><td><code>fpemin</code></td>
<td>
<p>minimum FPE.</p>
</td></tr>
<tr><td><code>rfpemin</code></td>
<td>
<p>minimum RFPE.</p>
</td></tr>
<tr><td><code>ofpe</code></td>
<td>
<p>OFPE.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>AR coefficients.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p><code class="reqn">\sigma^2.</code></p>
</td></tr>
<tr><td><code>fpe</code></td>
<td>
<p>FPE (Final Prediction Error).</p>
</td></tr>
<tr><td><code>rfpe</code></td>
<td>
<p>RFPE.</p>
</td></tr>
<tr><td><code>parcor</code></td>
<td>
<p>partial correlation.</p>
</td></tr>
<tr><td><code>chi2</code></td>
<td>
<p>chi-squared.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control
of Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- arima.sim(list(order=c(2,0,0), ar=c(0.64,-0.8)), n = 200)
fpeaut(y, max.order = 20)
</code></pre>

<hr>
<h2 id='fpec'>AR model Fitting for Control</h2><span id='topic+fpec'></span><span id='topic+print.fpec'></span>

<h3>Description</h3>

<p>Perform AR model fitting for control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fpec(y, max.order = NULL, control = NULL, manip = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpec_+3A_y">y</code></td>
<td>
<p>a multivariate time series.</p>
</td></tr>
<tr><td><code id="fpec_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of model order. Default is
<code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code> is the length of time series
<code>y</code>.</p>
</td></tr>
<tr><td><code id="fpec_+3A_control">control</code></td>
<td>
<p>controlled variables. Default is <code class="reqn">c(1:d)</code>, where <code class="reqn">d</code> is
the dimension of the time series <code>y</code>.</p>
</td></tr>
<tr><td><code id="fpec_+3A_manip">manip</code></td>
<td>
<p>manipulated variables. Default number of manipulated variable is
<code class="reqn">0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>cov</code></td>
<td>
<p>covariance matrix rearrangement.</p>
</td></tr>
<tr><td><code>fpec</code></td>
<td>
<p>FPEC (AR model fitting for control).</p>
</td></tr>
<tr><td><code>rfpec</code></td>
<td>
<p>RFPEC.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>ordermin</code></td>
<td>
<p>order of minimum FPEC.</p>
</td></tr>
<tr><td><code>fpecmin</code></td>
<td>
<p>minimum FPEC.</p>
</td></tr>
<tr><td><code>rfpecmin</code></td>
<td>
<p>minimum RFPEC.</p>
</td></tr>
<tr><td><code>aicmin</code></td>
<td>
<p>minimum AIC.</p>
</td></tr>
<tr><td><code>perr</code></td>
<td>
<p>prediction error covariance matrix.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>a set of coefficient matrices. <code>arcoef[i,j,k]</code> shows the
value of <code class="reqn">i</code>-th row, <code class="reqn">j</code>-th column, <code class="reqn">k</code>-th order.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control of
Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar &lt;- array(0, dim = c(3,3,2))
ar[, , 1] &lt;- matrix(c(0.4,  0,   0.3,
                      0.2, -0.1, -0.5,
                      0.3,  0.1, 0), nrow = 3, ncol = 3, byrow = TRUE)
ar[, , 2] &lt;- matrix(c(0,  -0.3,  0.5,
                      0.7, -0.4,  1,
                      0,   -0.5,  0.3), nrow = 3, ncol = 3, byrow = TRUE)
x &lt;- matrix(rnorm(200*3), nrow = 200, ncol = 3)
y &lt;- mfilter(x, ar, "recursive")
fpec(y, max.order = 10)
</code></pre>

<hr>
<h2 id='LaborData'>Labor force Data</h2><span id='topic+LaborData'></span>

<h3>Description</h3>

<p>Labor force U.S. unemployed 16 years or over (1972-1978) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(LaborData)
</code></pre>


<h3>Format</h3>

<p>A time series of 72 observations.
</p>


<h3>Source</h3>

<p>H.Akaike, T.Ozaki, M.Ishiguro, Y.Ogata, G.Kitagawa, Y-H.Tamura, E.Arahata,
K.Katsura and Y.Tamura (1985)
<em>Computer Science Monograph, No.22, Timsac84 Part 1.</em>
The Institute of Statistical Mathematics.
</p>

<hr>
<h2 id='locarData'>Non-stationary Test Data</h2><span id='topic+locarData'></span>

<h3>Description</h3>

<p>A non-stationary data for testing <code><a href="#topic+mlocar">mlocar</a></code> and <code><a href="#topic+blocar">blocar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(locarData)
</code></pre>


<h3>Format</h3>

<p>A time series of 1000 observations.
</p>


<h3>Source</h3>

<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>

<hr>
<h2 id='markov'>Maximum Likelihood Computation of Markovian Model</h2><span id='topic+markov'></span>

<h3>Description</h3>

<p>Compute maximum likelihood estimates of Markovian model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markov(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markov_+3A_y">y</code></td>
<td>
<p>a multivariate time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usually used with <code><a href="#topic+simcon">simcon</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>id</code></td>
<td>
<p><code>id[i]</code><code class="reqn">=1</code> means that the <code class="reqn">i</code>-th row of <code class="reqn">F</code>
contains free parameters.</p>
</td></tr>
<tr><td><code>ir</code></td>
<td>
<p><code>ir[i]</code> denotes the position of the last non-zero element
within the <code class="reqn">i</code>-th row of <code class="reqn">F</code>.</p>
</td></tr>
<tr><td><code>ij</code></td>
<td>
<p><code>ij[i]</code> denotes the position of the <code class="reqn">i</code>-th non-trivial row
within <code class="reqn">F</code>.</p>
</td></tr>
<tr><td><code>ik</code></td>
<td>
<p><code>ik[i]</code> denotes the number of free parameters within the
<code class="reqn">i</code>-th non-trivial row of <code class="reqn">F</code>.</p>
</td></tr>
<tr><td><code>grad</code></td>
<td>
<p>gradient vector.</p>
</td></tr>
<tr><td><code>matFi</code></td>
<td>
<p>initial estimate of the transition matrix <code class="reqn">F</code>.</p>
</td></tr>
<tr><td><code>matF</code></td>
<td>
<p>transition matrix <code class="reqn">F</code>.</p>
</td></tr>
<tr><td><code>matG</code></td>
<td>
<p>input matrix <code class="reqn">G</code>.</p>
</td></tr>
<tr><td><code>davvar</code></td>
<td>
<p>DAVIDON variance.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>AR coefficient matrices. <code>arcoef[i,j,k]</code> shows the value of
<code class="reqn">i</code>-th row, <code class="reqn">j</code>-th column, <code class="reqn">k</code>-th order.</p>
</td></tr>
<tr><td><code>impulse</code></td>
<td>
<p>impulse response matrices.</p>
</td></tr>
<tr><td><code>macoef</code></td>
<td>
<p>MA coefficient matrices. <code>macoef[i,j,k]</code> shows the value of
<code class="reqn">i</code>-th row, <code class="reqn">j</code>-th column, <code class="reqn">k</code>-th order.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1975) <em>Computer Science Monograph, No.5,
Timsac74, A Time Series Analysis and Control Program Package (1)</em>.
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(1000*2), nrow = 1000, ncol = 2)
ma &lt;- array(0, dim = c(2,2,2))
ma[, , 1] &lt;- matrix(c( -1.0,  0.0,
                        0.0, -1.0), nrow = 2, ncol = 2, byrow = TRUE)
ma[, , 2] &lt;- matrix(c( -0.2,  0.0,
                       -0.1, -0.3), nrow = 2, ncol = 2, byrow = TRUE)
y &lt;- mfilter(x, ma, "convolution")
ar &lt;- array(0, dim = c(2,2,3))
ar[, , 1] &lt;- matrix(c( -1.0,  0.0,
                        0.0, -1.0), nrow = 2, ncol = 2, byrow = TRUE)
ar[, , 2] &lt;- matrix(c( -0.5, -0.2,
                       -0.2, -0.5), nrow = 2, ncol = 2, byrow = TRUE)
ar[, , 3] &lt;- matrix(c( -0.3, -0.05,
                       -0.1, -0.30), nrow = 2, ncol = 2, byrow = TRUE)
z &lt;- mfilter(y, ar, "recursive")
markov(z)
</code></pre>

<hr>
<h2 id='mfilter'>Linear Filtering on a Multivariate Time Series</h2><span id='topic+mfilter'></span>

<h3>Description</h3>

<p>Applies linear filtering to a multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfilter(x, filter, method = c("convolution","recursive"), init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfilter_+3A_x">x</code></td>
<td>
<p>a multivariate (<code class="reqn">m</code>-dimensional, <code class="reqn">n</code> length) time series
<code class="reqn">x[n,m]</code>.</p>
</td></tr>
<tr><td><code id="mfilter_+3A_filter">filter</code></td>
<td>
<p>an array of filter coefficients. <code>filter[i,j,k]</code> shows the
value of <code class="reqn">i</code>-th row, <code class="reqn">j</code>-th column, <code class="reqn">k</code>-th order</p>
</td></tr>
<tr><td><code id="mfilter_+3A_method">method</code></td>
<td>
<p>either &quot;convolution&quot; or &quot;recursive&quot; (and can be abbreviated).
If &quot;convolution&quot; a moving average is used: if &quot;recursive&quot; an autoregression
is used. For convolution filters, the filter coefficients are for past value
only.</p>
</td></tr>
<tr><td><code id="mfilter_+3A_init">init</code></td>
<td>
<p>specifies the initial values of the time series just prior to the
start value, in reverse time order. The default is a set of zeros.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a multivariate version of &quot;filter&quot; function.
Missing values are allowed in '<code>x</code>' but not in '<code>filter</code>'
(where they would lead to missing values everywhere in the output).
Note that there is an implied coefficient <code class="reqn">1</code> at lag <code class="reqn">0</code> in the
recursive filter, which gives
</p>
<p style="text-align: center;"><code class="reqn">y[i,]' =x[,i]' + f[,,1] \times y[i-1,]' + ... +f[,,p] \times
 y[i-p,]',</code>
</p>

<p>No check is made to see if recursive filter is invertible: the output may
diverge if it is not. The convolution filter is
</p>
<p style="text-align: center;"><code class="reqn">y[i,]' = f[,,1] \times x[i,]' + ... + f[,,p] \times
 x[i-p+1,]'.</code>
</p>



<h3>Value</h3>

<p><code>mfilter</code> returns a time series object.
</p>


<h3>Note</h3>

<p>'<code>convolve(, type="filter")</code>' uses the FFT for computations and so may be
faster for long filters on univariate time series (and so the time alignment
is unclear), nor does it handle missing values. 'filter' is faster for a
filter of length 100 on a series 1000, for examples.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+convolve">convolve</a></code>, <code><a href="stats.html#topic+arima.sim">arima.sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#AR model simulation
ar &lt;- array(0, dim = c(3,3,2))
ar[, , 1] &lt;- matrix(c(0.4,  0,   0.3,
                      0.2, -0.1, -0.5,
                      0.3,  0.1, 0), nrow = 3, ncol = 3, byrow = TRUE)
ar[, , 2] &lt;- matrix(c(0,  -0.3,  0.5,
                      0.7, -0.4,  1,
                      0,   -0.5,  0.3), nrow = 3, ncol = 3, byrow = TRUE)
x &lt;- matrix(rnorm(100*3), nrow = 100, ncol = 3)
y &lt;- mfilter(x, ar, "recursive")

#Back to white noise
ma &lt;- array(0, dim = c(3,3,3))
ma[, , 1] &lt;- diag(3)
ma[, , 2] &lt;- -ar[, , 1]
ma[, , 3] &lt;- -ar[, , 2]
z &lt;- mfilter(y, ma, "convolution")
mulcor(z)

#AR-MA model simulation
x &lt;- matrix(rnorm(1000*2), nrow = 1000, ncol = 2)
ma &lt;- array(0, dim = c(2,2,2))
ma[, , 1] &lt;- matrix(c( -1.0,  0.0,
                        0.0, -1.0), nrow = 2, ncol = 2, byrow = TRUE)
ma[, , 2] &lt;- matrix(c( -0.2,  0.0,
                       -0.1, -0.3), nrow = 2, ncol = 2, byrow = TRUE)
y &lt;- mfilter(x, ma, "convolution")

ar &lt;- array(0, dim = c(2,2,3))
ar[, , 1] &lt;- matrix(c( -1.0,  0.0,
                        0.0, -1.0), nrow = 2, ncol = 2, byrow = TRUE)
ar[, , 2] &lt;- matrix(c( -0.5, -0.2,
                       -0.2, -0.5), nrow = 2, ncol = 2, byrow = TRUE)
ar[, , 3] &lt;- matrix(c( -0.3, -0.05,
                       -0.1, -0.30), nrow = 2, ncol = 2, byrow = TRUE)
z &lt;- mfilter(y, ar, "recursive")
</code></pre>

<hr>
<h2 id='mlocar'>Minimum AIC Method of Locally Stationary AR Model Fitting; Scalar Case</h2><span id='topic+mlocar'></span>

<h3>Description</h3>

<p>Locally fit autoregressive models to non-stationary time series by minimum AIC
procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mlocar(y, max.order = NULL, span, const = 0, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlocar_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="mlocar_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of the order of AR model. Default is
<code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code> is the length of the time series
<code>y</code>.</p>
</td></tr>
<tr><td><code id="mlocar_+3A_span">span</code></td>
<td>
<p>length of the basic local span.</p>
</td></tr>
<tr><td><code id="mlocar_+3A_const">const</code></td>
<td>
<p>integer. <code>0</code> denotes constant vector is not included as a
regressor and <code>1</code> denotes constant vector is included as the first
regressor.</p>
</td></tr>
<tr><td><code id="mlocar_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), spectrums <code>pspec</code> are
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data of length <code class="reqn">n</code> are divided into <code class="reqn">k</code> locally stationary spans,
</p>
<p style="text-align: center;"><code class="reqn">|&lt;-- n_1 --&gt;|&lt;-- n_2 --&gt;|&lt;-- n_3 --&gt;| ..... |&lt;-- n_k --&gt;|</code>
</p>

<p>where <code class="reqn">n_i</code> (<code class="reqn">i=1,\ldots,k</code>) denotes the number of
basic spans, each of length span, which constitute the <code class="reqn">i</code>-th locally
stationary span. At each local span, the process is represented by a
stationary autoregressive model.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mean</code></td>
<td>
<p>mean.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>variance.</p>
</td></tr>
<tr><td><code>ns</code></td>
<td>
<p>the number of local spans.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>order of the current model.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>AR coefficients of current model.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance of the current model.</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>initial point of the data fitted to the current model.</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p>end point of the data fitted to the current model.</p>
</td></tr>
<tr><td><code>pspec</code></td>
<td>
<p>power spectrum.</p>
</td></tr>
<tr><td><code>npre</code></td>
<td>
<p>data length of the preceding stationary block.</p>
</td></tr>
<tr><td><code>nnew</code></td>
<td>
<p>data length of the new block.</p>
</td></tr>
<tr><td><code>order.mov</code></td>
<td>
<p>order of the moving model.</p>
</td></tr>
<tr><td><code>v.mov</code></td>
<td>
<p>innovation variance of the moving model.</p>
</td></tr>
<tr><td><code>aic.mov</code></td>
<td>
<p>AIC of the moving model.</p>
</td></tr>
<tr><td><code>order.const</code></td>
<td>
<p>order of the constant model.</p>
</td></tr>
<tr><td><code>v.const</code></td>
<td>
<p>innovation variance of the constant model.</p>
</td></tr>
<tr><td><code>aic.const</code></td>
<td>
<p>AIC of the constant model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>G.Kitagawa and H.Akaike (1978)
A Procedure for The Modeling of Non-Stationary Time Series.
Ann. Inst. Statist. Math., 30, B, 351&ndash;363.
</p>
<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(locarData)
z &lt;- mlocar(locarData, max.order = 10, span = 300, const = 0)
z$arcoef
</code></pre>

<hr>
<h2 id='mlomar'>Minimum AIC Method of Locally Stationary Multivariate AR Model Fitting</h2><span id='topic+mlomar'></span><span id='topic+print.mlomar'></span>

<h3>Description</h3>

<p>Locally fit multivariate autoregressive models to non-stationary time series
by the minimum AIC procedure using the householder transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mlomar(y, max.order = NULL, span, const = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlomar_+3A_y">y</code></td>
<td>
<p>a multivariate time series.</p>
</td></tr>
<tr><td><code id="mlomar_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of the order of AR model, less than or equal to
<code class="reqn">n/2d</code> where <code class="reqn">n</code> is the length and <code class="reqn">d</code> is the dimension of the
time series <code>y</code>. Default is
<code class="reqn">min(2 \sqrt{n}, n/2d)</code>.</p>
</td></tr>
<tr><td><code id="mlomar_+3A_span">span</code></td>
<td>
<p>length of basic local span. Let <code class="reqn">m</code> denote <code>max.order</code>,
if <code class="reqn">n-m-1</code> is less than or equal to <code>span</code> or <code class="reqn">n-m-1-</code><code>span</code>
is less than <code class="reqn">2md+</code><code>const</code>, <code>span</code> is <code class="reqn">n-m</code>.</p>
</td></tr>
<tr><td><code id="mlomar_+3A_const">const</code></td>
<td>
<p>integer. '<code class="reqn">0</code>' denotes constant vector is not included as a
regressor and '<code class="reqn">1</code>' denotes constant vector is included as the first
regressor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data of length <code class="reqn">n</code> are divided into <code class="reqn">k</code> locally stationary spans,
</p>
<p style="text-align: center;"><code class="reqn">|&lt;-- n_1 --&gt;|&lt;-- n_2 --&gt;|&lt;-- n_3 --&gt;| ..... |&lt;-- n_k --&gt;|</code>
</p>

<p>where <code class="reqn">n_i</code> <code class="reqn">(i=1,\ldots,k)</code> denoted the number of
basic spans, each of length span, which constitute the <code class="reqn">i</code>-th locally
stationary span. At each local span, the process is represented by a
stationary autoregressive model.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mean</code></td>
<td>
<p>mean.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>variance.</p>
</td></tr>
<tr><td><code>ns</code></td>
<td>
<p>the number of local spans.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>order of the current model.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC of the current model.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>AR coefficient matrices of the current model.
<code>arcoef[[m]][i,j,k]</code> shows the value of <code class="reqn">i</code>-th row, <code class="reqn">j</code>-th
column, <code class="reqn">k</code>-th order of <code class="reqn">m</code>-th model.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance of the current model.</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>initial point of the data fitted to the current model.</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p>end point of the data fitted to the current model.</p>
</td></tr>
<tr><td><code>npre</code></td>
<td>
<p>data length of the preceding stationary block.</p>
</td></tr>
<tr><td><code>nnew</code></td>
<td>
<p>data length of the new block.</p>
</td></tr>
<tr><td><code>order.mov</code></td>
<td>
<p>order of the moving model.</p>
</td></tr>
<tr><td><code>aic.mov</code></td>
<td>
<p>AIC of the moving model.</p>
</td></tr>
<tr><td><code>order.const</code></td>
<td>
<p>order of the constant model.</p>
</td></tr>
<tr><td><code>aic.const</code></td>
<td>
<p>AIC of the constant model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>G.Kitagawa and H.Akaike (1978)
A Procedure for The Modeling of Non-Stationary Time Series.
Ann. Inst. Statist. Math., 30, B, 351&ndash;363.
</p>
<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Amerikamaru)
mlomar(Amerikamaru, max.order = 10, span = 300, const = 0)
</code></pre>

<hr>
<h2 id='mulbar'>Multivariate Bayesian Method of AR Model Fitting</h2><span id='topic+mulbar'></span>

<h3>Description</h3>

<p>Determine multivariate autoregressive models by a Bayesian procedure.
The basic least squares estimates of the parameters are obtained by the
householder transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mulbar(y, max.order = NULL, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mulbar_+3A_y">y</code></td>
<td>
<p>a multivariate time series.</p>
</td></tr>
<tr><td><code id="mulbar_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of the order of AR model, less than or equal to
<code class="reqn">n/2d</code> where <code class="reqn">n</code> is the length and <code class="reqn">d</code> is the dimension of the
time series <code>y</code>.
Default is <code class="reqn">min(2 \sqrt{n}, n/2d)</code>.</p>
</td></tr>
<tr><td><code id="mulbar_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>daic</code> is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic AIC is defined by
</p>
<p style="text-align: center;"><code class="reqn">AIC = n \log(det(v)) + 2k,</code>
</p>

<p>where <code class="reqn">n</code> is the number of data, <code class="reqn">v</code> is the estimate of innovation
variance matrix, <code class="reqn">det</code> is the determinant and <code class="reqn">k</code> is the number of
free parameters.
</p>
<p>Bayesian weight of the <code class="reqn">m</code>-th order model is defined by
</p>
<p style="text-align: center;"><code class="reqn">W(n) = const \times \frac{C(m)}{m+1},</code>
</p>

<p>where <code class="reqn">const</code> is the normalizing constant and
<code class="reqn">C(m)=\exp(-0.5 AIC(m))</code>. The Bayesian estimates of
partial autoregression coefficient matrices of forward and backward models are
obtained by <code class="reqn">(m = 1,\ldots,lag)</code>
</p>
<p style="text-align: center;"><code class="reqn">G(m) = G(m) D(m),</code>
</p>

<p style="text-align: center;"><code class="reqn">H(m) = H(m) D(m),</code>
</p>

<p>where the original <code class="reqn">G(m)</code> and <code class="reqn">H(m)</code> are the (conditional) maximum
likelihood estimates of the highest order coefficient matrices of forward and
backward AR models of order <code class="reqn">m</code> and <code class="reqn">D(m)</code> is defined by
</p>
<p style="text-align: center;"><code class="reqn">D(m) = W(m) + \ldots + W(lag).</code>
</p>

<p>The equivalent number of parameters for the Bayesian model is defined by
</p>
<p style="text-align: center;"><code class="reqn">ek = \{ D(1)^2 + \ldots + D(lag)^2 \} id + \frac{id(id+1)}{2}</code>
</p>

<p>where <code class="reqn">id</code> denotes dimension of the process.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mean</code></td>
<td>
<p>mean.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>variance.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>aicmin</code></td>
<td>
<p>minimum AIC.</p>
</td></tr>
<tr><td><code>daic</code></td>
<td>
<p>AIC-<code>aicmin</code>.</p>
</td></tr>
<tr><td><code>order.maice</code></td>
<td>
<p>order of minimum AIC.</p>
</td></tr>
<tr><td><code>v.maice</code></td>
<td>
<p>MAICE innovation variance.</p>
</td></tr>
<tr><td><code>bweight</code></td>
<td>
<p>Bayesian weights.</p>
</td></tr>
<tr><td><code>integra.bweight</code></td>
<td>
<p>integrated Bayesian Weights.</p>
</td></tr>
<tr><td><code>arcoef.for</code></td>
<td>
<p>AR coefficients (forward model). <code>arcoef.for[i,j,k]</code>
shows the value of <code class="reqn">i</code>-th row, <code class="reqn">j</code>-th column, <code class="reqn">k</code>-th order.</p>
</td></tr>
<tr><td><code>arcoef.back</code></td>
<td>
<p>AR coefficients (backward model). <code>arcoef.back[i,j,k]</code>
shows the value of <code class="reqn">i</code>-th row, <code class="reqn">j</code>-th column, <code class="reqn">k</code>-th order.</p>
</td></tr>
<tr><td><code>pacoef.for</code></td>
<td>
<p>partial autoregression coefficients (forward model).</p>
</td></tr>
<tr><td><code>pacoef.back</code></td>
<td>
<p>partial autoregression coefficients (backward model).</p>
</td></tr>
<tr><td><code>v.bay</code></td>
<td>
<p>innovation variance of the Bayesian model.</p>
</td></tr>
<tr><td><code>aic.bay</code></td>
<td>
<p>equivalent AIC of the Bayesian (forward) model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike (1978)
A Bayesian Extension of The Minimum AIC Procedure of Autoregressive Model
Fitting. Research Memo. NO.126, The Institute of Statistical Mathematics.
</p>
<p>G.Kitagawa and H.Akaike (1978)
A Procedure for The Modeling of Non-stationary Time Series.
Ann. Inst. Statist. Math., 30, B, 351&ndash;363.
</p>
<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Powerplant)
z &lt;- mulbar(Powerplant, max.order = 10)
z$pacoef.for
z$pacoef.back
</code></pre>

<hr>
<h2 id='mulcor'>Multiple Correlation</h2><span id='topic+mulcor'></span><span id='topic+print.mulcor'></span>

<h3>Description</h3>

<p>Estimate multiple correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mulcor(y, lag = NULL, plot = TRUE, lag_axis = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mulcor_+3A_y">y</code></td>
<td>
<p>a multivariate time series.</p>
</td></tr>
<tr><td><code id="mulcor_+3A_lag">lag</code></td>
<td>
<p>maximum lag. Default is <code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code>
is the length of the time series <code>y</code>.</p>
</td></tr>
<tr><td><code id="mulcor_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (default), correlations <code>cor</code> are plotted.</p>
</td></tr>
<tr><td><code id="mulcor_+3A_lag_axis">lag_axis</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) with plot=<code>TRUE</code>, <code class="reqn">x</code>-axis
is drawn.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>cov</code></td>
<td>
<p>covariances.</p>
</td></tr>
<tr><td><code>cor</code></td>
<td>
<p>correlations (normalized covariances).</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>mean.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control
of Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 
y &lt;- rnorm(1000)
dim(y) &lt;- c(500,2)
mulcor(y, lag_axis = FALSE)

# Example 2
xorg &lt;- rnorm(1003)
x &lt;- matrix(0, nrow = 1000, ncol = 2)
x[, 1] &lt;- xorg[1:1000]
x[, 2] &lt;- xorg[4:1003] + 0.5*rnorm(1000)
mulcor(x, lag = 20)
</code></pre>

<hr>
<h2 id='mulfrf'>Frequency Response Function (Multiple Channel)</h2><span id='topic+mulfrf'></span>

<h3>Description</h3>

<p>Compute multiple frequency response function, gain, phase, multiple coherency,
partial coherency and relative error statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> mulfrf(y, lag = NULL, iovar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mulfrf_+3A_y">y</code></td>
<td>
<p>a multivariate time series.</p>
</td></tr>
<tr><td><code id="mulfrf_+3A_lag">lag</code></td>
<td>
<p>maximum lag. Default is <code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code>
is the number of rows in <code>y</code>.</p>
</td></tr>
<tr><td><code id="mulfrf_+3A_iovar">iovar</code></td>
<td>
<p>input variables <code>iovar[i]</code> (<code class="reqn">i=1,k</code>) and output variable
<code>iovar[k+1]</code> (<code class="reqn">1 \le k \le d</code>),
where <code class="reqn">d</code> is the number of columns in <code>y</code>. Default is <code class="reqn">c(1:d)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>cospec</code></td>
<td>
<p>spectrum (complex).</p>
</td></tr>
<tr><td><code>freqr</code></td>
<td>
<p>frequency response function : real part.</p>
</td></tr>
<tr><td><code>freqi</code></td>
<td>
<p>frequency response function : imaginary part.</p>
</td></tr>
<tr><td><code>gain</code></td>
<td>
<p>gain.</p>
</td></tr>
<tr><td><code>phase</code></td>
<td>
<p>phase.</p>
</td></tr>
<tr><td><code>pcoh</code></td>
<td>
<p>partial coherency.</p>
</td></tr>
<tr><td><code>errstat</code></td>
<td>
<p>relative error statistics.</p>
</td></tr>
<tr><td><code>mcoh</code></td>
<td>
<p>multiple coherency.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control
of Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar &lt;- array(0, dim = c(3,3,2))
ar[, , 1] &lt;- matrix(c(0.4,  0,   0.3,
                      0.2, -0.1, -0.5,
                      0.3,  0.1, 0), nrow = 3, ncol = 3, byrow = TRUE)
ar[, , 2] &lt;- matrix(c(0,  -0.3,  0.5,
                      0.7, -0.4,  1,
                      0,   -0.5,  0.3), nrow = 3, ncol = 3, byrow = TRUE)
x &lt;- matrix(rnorm(200*3), nrow = 200, ncol = 3)
y &lt;- mfilter(x, ar, "recursive")
mulfrf(y, lag = 20)
</code></pre>

<hr>
<h2 id='mulmar'>Multivariate Case of Minimum AIC Method of AR Model Fitting</h2><span id='topic+mulmar'></span>

<h3>Description</h3>

<p>Fit a multivariate autoregressive model by the minimum AIC procedure.
Only the possibilities of zero coefficients at the beginning and end of the
model are considered. The least squares estimates of the parameters are
obtained by the householder transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mulmar(y, max.order = NULL, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mulmar_+3A_y">y</code></td>
<td>
<p>a multivariate time series.</p>
</td></tr>
<tr><td><code id="mulmar_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of the order of AR model, less than or equal to
<code class="reqn">n/2d</code> where <code class="reqn">n</code> is the length and <code class="reqn">d</code> is the dimension of the
time series <code>y</code>. Default is
<code class="reqn">min(2 \sqrt{n}, n/2d)</code>.</p>
</td></tr>
<tr><td><code id="mulmar_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>,
<code>daic[[1]]</code><code class="reqn">, \ldots , </code><code>daic[[d]]</code> are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate autoregressive model is defined by
</p>
<p style="text-align: center;"><code class="reqn">y(t) = A(1)y(t-1) + A(2)y(t-2) +\ldots+ A(p)y(t-p) + u(t),</code>
</p>

<p>where <code class="reqn">p</code> is order of the model and <code class="reqn">u(t)</code> is Gaussian white noise
with mean <code class="reqn">0</code> and variance matrix <code>matv</code>. AIC is defined by
</p>
<p style="text-align: center;"><code class="reqn">AIC = n \log(det(v)) + 2k,</code>
</p>

<p>where <code class="reqn">n</code> is the number of data, <code class="reqn">v</code> is the estimate of innovation
variance matrix, <code class="reqn">det</code> is the determinant and <code class="reqn">k</code> is the number of
free parameters.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mean</code></td>
<td>
<p>mean.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>variance.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>aicmin</code></td>
<td>
<p>minimum AIC.</p>
</td></tr>
<tr><td><code>daic</code></td>
<td>
<p>AIC-aicmin.</p>
</td></tr>
<tr><td><code>order.maice</code></td>
<td>
<p>order of minimum AIC.</p>
</td></tr>
<tr><td><code>v.maice</code></td>
<td>
<p>MAICE innovation variance.</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>number of parameters.</p>
</td></tr>
<tr><td><code>jnd</code></td>
<td>
<p>specification of <code class="reqn">i</code>-th regressor.</p>
</td></tr>
<tr><td><code>subregcoef</code></td>
<td>
<p>subset regression coefficients.</p>
</td></tr>
<tr><td><code>rvar</code></td>
<td>
<p>residual variance.</p>
</td></tr>
<tr><td><code>aicf</code></td>
<td>
<p>final estimate of AIC (<code class="reqn">=n\log</code>(<code>rvar</code>)<code class="reqn">+2</code><code>np</code>).</p>
</td></tr>
<tr><td><code>respns</code></td>
<td>
<p>instantaneous response.</p>
</td></tr>
<tr><td><code>regcoef</code></td>
<td>
<p>regression coefficients matrix.</p>
</td></tr>
<tr><td><code>matv</code></td>
<td>
<p>innovation variance matrix.</p>
</td></tr>
<tr><td><code>morder</code></td>
<td>
<p>order of the MAICE model.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>AR coefficients. <code>arcoef[i,j,k]</code> shows the value of
<code class="reqn">i</code>-th row, <code class="reqn">j</code>-th column, <code class="reqn">k-</code>th order.</p>
</td></tr>
<tr><td><code>aicsum</code></td>
<td>
<p>the sum of aicf.</p>
</td></tr>
</table>


<h3>References</h3>

<p>G.Kitagawa and H.Akaike (1978) A Procedure for The Modeling of Non-stationary
Time Series. Ann. Inst. Statist. Math., 30, B, 351&ndash;363.
</p>
<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
data(Powerplant)
z &lt;- mulmar(Powerplant, max.order = 10)
z$arcoef

# Example 2
ar &lt;- array(0, dim = c(3,3,2))
ar[, , 1] &lt;- matrix(c(0.4,  0,   0.3,
                      0.2, -0.1, -0.5,
                      0.3,  0.1, 0), nrow = 3, ncol = 3, byrow = TRUE)
ar[, , 2] &lt;- matrix(c(0,  -0.3,  0.5,
                      0.7, -0.4,  1,
                      0,   -0.5,  0.3), nrow = 3, ncol = 3,byrow = TRUE)
x &lt;- matrix(rnorm(200*3), nrow = 200, ncol = 3)
y &lt;- mfilter(x, ar, "recursive")
z &lt;- mulmar(y, max.order = 10)
z$arcoef
</code></pre>

<hr>
<h2 id='mulnos'>Relative Power Contribution</h2><span id='topic+mulnos'></span>

<h3>Description</h3>

<p>Compute relative power contributions in differential and integrated form,
assuming the orthogonality between noise sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mulnos(y, max.order = NULL, control = NULL, manip = NULL, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mulnos_+3A_y">y</code></td>
<td>
<p>a multivariate time series.</p>
</td></tr>
<tr><td><code id="mulnos_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of model order. Default is
<code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code> is the length of time series
<code>y</code>.</p>
</td></tr>
<tr><td><code id="mulnos_+3A_control">control</code></td>
<td>
<p>controlled variables. Default is <code class="reqn">c(1:d)</code>, where <code class="reqn">d</code> is
the dimension of the time series <code>y</code>.</p>
</td></tr>
<tr><td><code id="mulnos_+3A_manip">manip</code></td>
<td>
<p>manipulated variables. Default number of manipulated variable is
'<code class="reqn">0</code>'.</p>
</td></tr>
<tr><td><code id="mulnos_+3A_h">h</code></td>
<td>
<p>specify frequencies <code class="reqn">i/2</code><code>h</code> (<code class="reqn">i=0, \ldots ,</code><code>h</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>nperr</code></td>
<td>
<p>a normalized prediction error covariance matrix.</p>
</td></tr>
<tr><td><code>diffr</code></td>
<td>
<p>differential relative power contribution.</p>
</td></tr>
<tr><td><code>integr</code></td>
<td>
<p>integrated relative power contribution.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control
of Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar &lt;- array(0, dim = c(3,3,2))
ar[, , 1] &lt;- matrix(c(0.4,  0,   0.3,
                      0.2, -0.1, -0.5,
                      0.3,  0.1, 0), nrow = 3, ncol = 3, byrow = TRUE)
ar[, , 2] &lt;- matrix(c(0,  -0.3,  0.5,
                      0.7, -0.4,  1,
                      0,   -0.5,  0.3), nrow = 3, ncol = 3, byrow = TRUE)
x &lt;- matrix(rnorm(200*3), nrow = 200, ncol = 3)
y &lt;- mfilter(x, ar, "recursive")
mulnos(y, max.order = 10, h = 20)
</code></pre>

<hr>
<h2 id='mulrsp'>Multiple Rational Spectrum</h2><span id='topic+mulrsp'></span>

<h3>Description</h3>

<p>Compute rational spectrum for d-dimensional ARMA process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mulrsp(h, d, cov, ar = NULL, ma = NULL, log = FALSE, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mulrsp_+3A_h">h</code></td>
<td>
<p>specify frequencies <code class="reqn">i/2</code><code>h</code> (<code class="reqn">i=0,1,...,</code><code>h</code>).</p>
</td></tr>
<tr><td><code id="mulrsp_+3A_d">d</code></td>
<td>
<p>dimension of the observation vector.</p>
</td></tr>
<tr><td><code id="mulrsp_+3A_cov">cov</code></td>
<td>
<p>covariance matrix.</p>
</td></tr>
<tr><td><code id="mulrsp_+3A_ar">ar</code></td>
<td>
<p>coefficient matrix of autoregressive model. <code>ar[i,j,k]</code> shows
the value of <code class="reqn">i</code>-th row, <code class="reqn">j</code>-th column, <code class="reqn">k</code>-th order.</p>
</td></tr>
<tr><td><code id="mulrsp_+3A_ma">ma</code></td>
<td>
<p>coefficient matrix of moving average model. <code>ma[i,j,k]</code> shows
the value of <code class="reqn">i</code>-th row, <code class="reqn">j</code>-th column, <code class="reqn">k</code>-th order.</p>
</td></tr>
<tr><td><code id="mulrsp_+3A_log">log</code></td>
<td>
<p>logical. If <code>TRUE</code>, rational spectrums <code>rspec</code> are
plotted as <code class="reqn">log(</code><code>rspec</code><code class="reqn">)</code>.</p>
</td></tr>
<tr><td><code id="mulrsp_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>, rational spectrums <code>rspec</code> are
plotted.</p>
</td></tr>
<tr><td><code id="mulrsp_+3A_...">...</code></td>
<td>
<p>graphical arguments passed to <code><a href="#topic+plot.specmx">plot.specmx</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ARMA process :
</p>
<p style="text-align: center;"><code class="reqn">y(t) - A(1)y(t-1) -...- A(p)y(t-p) = u(t) - B(1)u(t-1) -...- B(q)u(t-q)</code>
</p>

<p>where <code class="reqn">u(t)</code> is a white noise with zero mean vector and covariance matrix
<code>cov</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>rspec</code></td>
<td>
<p>rational spectrum. An object of class <code>"specmx"</code>.</p>
</td></tr>
<tr><td><code>scoh</code></td>
<td>
<p>simple coherence.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control
of Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 for the normal distribution
xorg &lt;- rnorm(1003)
x &lt;- matrix(0, nrow = 1000, ncol = 2)
x[, 1] &lt;- xorg[1:1000]
x[, 2] &lt;- xorg[4:1003] + 0.5*rnorm(1000)
aaa &lt;- ar(x)
mulrsp(h = 20, d = 2, cov = aaa$var.pred, ar = aaa$ar)

# Example 2 for the AR model
ar &lt;- array(0, dim = c(3,3,2))
ar[, , 1] &lt;- matrix(c(0.4,  0,   0.3,
                      0.2, -0.1, -0.5,
                      0.3,  0.1, 0), nrow = 3, ncol = 3, byrow = TRUE)
ar[, , 2] &lt;- matrix(c(0,  -0.3,  0.5,
                      0.7, -0.4,  1,
                      0,   -0.5,  0.3), nrow = 3, ncol = 3, byrow = TRUE)
x &lt;- matrix(rnorm(200*3), nrow = 200, ncol = 3)
y &lt;- mfilter(x, ar, "recursive")
z &lt;- fpec(y, max.order = 10)
mulrsp(h = 20, d = 3, cov = z$perr, ar = z$arcoef)
</code></pre>

<hr>
<h2 id='mulspe'>Multiple Spectrum</h2><span id='topic+mulspe'></span><span id='topic+ptint.mulspe'></span>

<h3>Description</h3>

<p>Compute multiple spectrum estimates using Akaike window or Hanning window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mulspe(y, lag = NULL, window = "Akaike", plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mulspe_+3A_y">y</code></td>
<td>
<p>a multivariate time series with <code class="reqn">d</code> variables and <code class="reqn">n</code>
observations.</p>
</td></tr>
<tr><td><code id="mulspe_+3A_lag">lag</code></td>
<td>
<p>maximum lag. Default is <code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code>
is the number of observations.</p>
</td></tr>
<tr><td><code id="mulspe_+3A_window">window</code></td>
<td>
<p>character string giving the definition of smoothing window.
Allowed strings are &quot;Akaike&quot; (default) or &quot;Hanning&quot;.</p>
</td></tr>
<tr><td><code id="mulspe_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (default) spectrums are plotted as <code class="reqn">(d,d)</code>
matrix.
</p>

<table>
<tr>
 <td style="text-align: left;">
      Diagonal parts : </td><td style="text-align: left;"> Auto spectrums for each series.</td>
</tr>
<tr>
 <td style="text-align: left;">
      Lower triangular parts : </td><td style="text-align: left;"> Amplitude spectrums.</td>
</tr>
<tr>
 <td style="text-align: left;">
      Upper triangular part : </td><td style="text-align: left;"> Phase spectrums.
    </td>
</tr>

</table>
</td></tr>
<tr><td><code id="mulspe_+3A_...">...</code></td>
<td>
<p>graphical arguments passed to <code><a href="#topic+plot.specmx">plot.specmx</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: right;">
    Hanning Window : </td><td style="text-align: left;"> a1(0)=0.5, </td><td style="text-align: left;"> a1(1)=a1(-1)=0.25, </td><td style="text-align: left;">
    a1(2)=a1(-2)=0</td>
</tr>
<tr>
 <td style="text-align: right;">
    Akaike Window : </td><td style="text-align: left;"> a2(0)=0.625, </td><td style="text-align: left;"> a2(1)=a2(-1)=0.25, </td><td style="text-align: left;">
    a2(2)=a2(-2)=-0.0625
  </td>
</tr>

</table>



<h3>Value</h3>

<table>
<tr><td><code>spec</code></td>
<td>
<p>spectrum smoothing by '<code>window</code>'.</p>
</td></tr>
<tr><td><code>specmx</code></td>
<td>
<p>spectrum matrix. An object of class <code>"specmx"</code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
      On and lower diagonal : </td><td style="text-align: left;"> Real parts</td>
</tr>
<tr>
 <td style="text-align: left;">
      Upper diagonal : </td><td style="text-align: left;"> Imaginary parts
    </td>
</tr>

</table>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>test statistics.</p>
</td></tr>
<tr><td><code>coh</code></td>
<td>
<p>simple coherence by '<code>window</code>'.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control of
Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sgnl &lt;- rnorm(1003)
x &lt;- matrix(0, nrow = 1000, ncol = 2)
x[, 1] &lt;- sgnl[4:1003]
# x[i,2] = 0.9*x[i-3,1] + 0.2*N(0,1)
x[, 2] &lt;- 0.9*sgnl[1:1000] + 0.2*rnorm(1000)
mulspe(x, lag = 100, window = "Hanning")
</code></pre>

<hr>
<h2 id='nonst'>Non-stationary Power Spectrum Analysis</h2><span id='topic+nonst'></span>

<h3>Description</h3>

<p>Locally fit autoregressive models to non-stationary time series by AIC
criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonst(y, span, max.order = NULL, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonst_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="nonst_+3A_span">span</code></td>
<td>
<p>length of the basic local span.</p>
</td></tr>
<tr><td><code id="nonst_+3A_max.order">max.order</code></td>
<td>
<p>highest order of AR model. Default is
<code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code> is the length of the time series
<code>y</code>.</p>
</td></tr>
<tr><td><code id="nonst_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default), spectrums are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic AR model is given by
</p>
<p style="text-align: center;"><code class="reqn">y(t) = A(1)y(t-1) + A(2)y(t-2) +...+ A(p)y(t-p) + u(t),</code>
</p>

<p>where <code class="reqn">p</code> is order of the AR model and <code class="reqn">u(t)</code> is innovation variance.
AIC is defined by
</p>
<p style="text-align: center;"><code class="reqn">AIC = n \log(det(sd)) + 2k,</code>
</p>

<p>where <code class="reqn">n</code> is the length of data, <code class="reqn">sd</code> is the estimates of the
innovation variance and <code class="reqn">k</code> is the number of parameter.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ns</code></td>
<td>
<p>the number of local spans.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>AR coefficients.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>daic21</code></td>
<td>
<p>= AIC2 - AIC1.</p>
</td></tr>
<tr><td><code>daic</code></td>
<td>
<p>= <code>daic21</code><code class="reqn">/n</code> (<code class="reqn">n</code> is the length of the current
model).</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>start point of the data fitted to the current model.</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p>end point of the data fitted to the current model.</p>
</td></tr>
<tr><td><code>pspec</code></td>
<td>
<p>power spectrum.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1976) <em>Computer Science Monograph, No.6,
Timsac74 A Time Series Analysis and Control Program Package (2)</em>.
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Non-stationary Test Data
data(nonstData)
nonst(nonstData, span = 700, max.order = 49)
</code></pre>

<hr>
<h2 id='nonstData'>Non-stationary Test Data</h2><span id='topic+nonstData'></span>

<h3>Description</h3>

<p>A non-stationary data for testing <code><a href="#topic+nonst">nonst</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(nonstData)
</code></pre>


<h3>Format</h3>

<p>A time series of 2100 observations.
</p>


<h3>Source</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1976) <em>Computer Science Monograph, No.6,
Timsac74 A Time Series Analysis and Control Program Package (2)</em>.
The Institute of Statistical Mathematics.
</p>

<hr>
<h2 id='optdes'>Optimal Controller Design</h2><span id='topic+optdes'></span>

<h3>Description</h3>

<p>Compute optimal controller gain matrix for a quadratic criterion defined by
two positive definite matrices Q and R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optdes(y, max.order = NULL, ns, q, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optdes_+3A_y">y</code></td>
<td>
<p>a multivariate time series.</p>
</td></tr>
<tr><td><code id="optdes_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of model order. Default is
<code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code> is the length of the time series
<code>y</code>.</p>
</td></tr>
<tr><td><code id="optdes_+3A_ns">ns</code></td>
<td>
<p>number of D.P. stages.</p>
</td></tr>
<tr><td><code id="optdes_+3A_q">q</code></td>
<td>
<p>positive definite <code class="reqn">(m, m)</code> matrix <code class="reqn">Q</code>, where <code class="reqn">m</code> is the
number of controlled variables. A quadratic criterion is defined by <code class="reqn">Q</code>
and <code class="reqn">R</code>.</p>
</td></tr>
<tr><td><code id="optdes_+3A_r">r</code></td>
<td>
<p>positive definite <code class="reqn">(l, l)</code> matrix <code class="reqn">R</code>, where <code class="reqn">l</code> is the
number of manipulated variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>perr</code></td>
<td>
<p>prediction error covariance matrix.</p>
</td></tr>
<tr><td><code>trans</code></td>
<td>
<p>first <code class="reqn">m</code> columns of transition matrix, where <code class="reqn">m</code> is the
number of controlled variables.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>gamma matrix.</p>
</td></tr>
<tr><td><code>gain</code></td>
<td>
<p>gain matrix.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control
of Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Multivariate Example Data
ar &lt;- array(0, dim = c(3,3,2))
ar[, , 1] &lt;- matrix(c(0.4,  0,   0.3,
                      0.2, -0.1, -0.5,
                      0.3,  0.1, 0), nrow= 3, ncol= 3, byrow = TRUE)
ar[, , 2] &lt;- matrix(c(0,  -0.3,  0.5,
                      0.7, -0.4,  1,
                      0,   -0.5,  0.3), nrow= 3, ncol= 3, byrow = TRUE)
x &lt;- matrix(rnorm(200*3), nrow = 200, ncol = 3)
y &lt;- mfilter(x, ar, "recursive")
q.mat &lt;- matrix(c(0.16,0,0,0.09), nrow = 2, ncol = 2)
r.mat &lt;- as.matrix(0.001)
optdes(y, ns = 20, q = q.mat, r = r.mat)
</code></pre>

<hr>
<h2 id='optsim'>Optimal Control Simulation</h2><span id='topic+optsim'></span>

<h3>Description</h3>

<p>Perform optimal control simulation and evaluate the means and variances of the
controlled and manipulated variables X and Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  optsim(y, max.order = NULL, ns, q, r, noise = NULL, len, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optsim_+3A_y">y</code></td>
<td>
<p>a multivariate time series.</p>
</td></tr>
<tr><td><code id="optsim_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of model order. Default is <code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code> is the length of the time series <code>y</code>.</p>
</td></tr>
<tr><td><code id="optsim_+3A_ns">ns</code></td>
<td>
<p>number of steps of simulation.</p>
</td></tr>
<tr><td><code id="optsim_+3A_q">q</code></td>
<td>
<p>positive definite matrix <code class="reqn">Q</code>.</p>
</td></tr>
<tr><td><code id="optsim_+3A_r">r</code></td>
<td>
<p>positive definite matrix <code class="reqn">R</code>.</p>
</td></tr>
<tr><td><code id="optsim_+3A_noise">noise</code></td>
<td>
<p>noise. If not provided, Gaussian vector white noise with the
length <code>len</code> is generated.</p>
</td></tr>
<tr><td><code id="optsim_+3A_len">len</code></td>
<td>
<p>length of white noise record.</p>
</td></tr>
<tr><td><code id="optsim_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), controlled variables <code class="reqn">X</code>
and  manipulated variables <code class="reqn">Y</code> are plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>trans</code></td>
<td>
<p>first <code class="reqn">m</code> columns of transition matrix, where <code class="reqn">m</code> is the
number of controlled variables.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>gamma matrix.</p>
</td></tr>
<tr><td><code>gain</code></td>
<td>
<p>gain matrix.</p>
</td></tr>
<tr><td><code>convar</code></td>
<td>
<p>controlled variables <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code>manvar</code></td>
<td>
<p>manipulated variables <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code>xmean</code></td>
<td>
<p>mean of <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code>ymean</code></td>
<td>
<p>mean of <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code>xvar</code></td>
<td>
<p>variance of <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code>yvar</code></td>
<td>
<p>variance of <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code>x2sum</code></td>
<td>
<p>sum of <code class="reqn">X^2</code>.</p>
</td></tr>
<tr><td><code>y2sum</code></td>
<td>
<p>sum of <code class="reqn">Y^2</code>.</p>
</td></tr>
<tr><td><code>x2mean</code></td>
<td>
<p>mean of <code class="reqn">X^2</code>.</p>
</td></tr>
<tr><td><code>y2mean</code></td>
<td>
<p>mean of <code class="reqn">Y^2</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control of
Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Multivariate Example Data
ar &lt;- array(0, dim = c(3,3,2))
ar[, , 1] &lt;- matrix(c(0.4,  0,    0.3,
                      0.2, -0.1, -0.5,
                      0.3,  0.1, 0), nrow = 3, ncol = 3, byrow = TRUE)
ar[, , 2] &lt;- matrix(c(0,  -0.3,  0.5,
                      0.7, -0.4,  1,
                      0,   -0.5,  0.3), nrow = 3, ncol = 3, byrow = TRUE)
x &lt;- matrix(rnorm(200*3), nrow = 200, ncol = 3)
y &lt;- mfilter(x, ar, "recursive")
q.mat &lt;- matrix(c(0.16,0,0,0.09), nrow = 2, ncol = 2)
r.mat &lt;- as.matrix(0.001)
optsim(y, max.order = 10, ns = 20, q = q.mat, r = r.mat, len = 20)
</code></pre>

<hr>
<h2 id='perars'>Periodic Autoregression for a Scalar Time Series</h2><span id='topic+perars'></span><span id='topic+print.perars'></span>

<h3>Description</h3>

<p>This is the program for the fitting of periodic autoregressive models by the
method of least squares realized through householder transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  perars(y, ni, lag = NULL, ksw = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perars_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="perars_+3A_ni">ni</code></td>
<td>
<p>number of instants in one period.</p>
</td></tr>
<tr><td><code id="perars_+3A_lag">lag</code></td>
<td>
<p>maximum lag of periods. Default is
<code class="reqn">2 \sqrt{\code{ni}}</code>.</p>
</td></tr>
<tr><td><code id="perars_+3A_ksw">ksw</code></td>
<td>
<p>integer. '<code class="reqn">0</code>' denotes constant vector is not included as a
regressor and '<code class="reqn">1</code>' denotes constant vector is included as the first
regressor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Periodic autoregressive model
(<code class="reqn">i=1, \ldots, nd, j=1, \ldots,</code> <code>ni</code>) is defined
by
</p>
<p><code class="reqn">z(i,j) = y(ni(i-1)+j)</code>,
</p>
<p><code class="reqn">z(i,j) = c(j) + A(1,j,0)z(i,1) + \ldots + A(j-1,j,0)z(i,j-1) +
 A(1,j,1)z(i-1,1) + \ldots + A(ni,j,1)z(i-1,ni) + \ldots + u(i,j)</code>,
</p>
<p>where <code class="reqn">nd</code> is the number of periods, <code class="reqn">ni</code> is the number of instants in
one period and <code class="reqn">u(i,j)</code> is the Gaussian white noise. When <code>ksw</code> is
set to '<code class="reqn">0</code>', the constant term <code class="reqn">c(j)</code> is excluded.
</p>
<p>The statistics AIC is defined by
<code class="reqn">AIC = n \log(det(v)) + 2k</code>, where <code class="reqn">n</code> is the
length of data, <code class="reqn">v</code> is the estimate of the innovation variance matrix and
<code class="reqn">k</code> is the number of parameters. The outputs are the estimates of the
regression coefficients and innovation variance of the periodic AR model for
each instant.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mean</code></td>
<td>
<p>mean.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>variance.</p>
</td></tr>
<tr><td><code>subset</code></td>
<td>
<p>specification of i-th regressor (<code class="reqn">i=1, \ldots ,</code><code>ni</code>).</p>
</td></tr>
<tr><td><code>regcoef</code></td>
<td>
<p>regression coefficients.</p>
</td></tr>
<tr><td><code>rvar</code></td>
<td>
<p>residual variances.</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>number of parameters.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance matrix.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>AR coefficient matrices. <code>arcoef[i,,k]</code> shows <code class="reqn">i</code>-th
regressand of <code class="reqn">k</code>-th period former.</p>
</td></tr>
<tr><td><code>const</code></td>
<td>
<p>constant vector.</p>
</td></tr>
<tr><td><code>morder</code></td>
<td>
<p>order of the MAICE model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>M.Pagano (1978)
On Periodic and Multiple Autoregressions.
Ann. Statist., 6, 1310&ndash;1317.
</p>
<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Airpollution)
perars(Airpollution, ni = 6, lag = 2, ksw = 1)
</code></pre>

<hr>
<h2 id='plot.decomp'>Plot Trend, Seasonal, AR Components and Trading Day Factor</h2><span id='topic+plot.decomp'></span>

<h3>Description</h3>

<p>Plot trend component, seasonal component, AR component, noise and trading day
factor returned by <code><a href="#topic+decomp">decomp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'decomp'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.decomp_+3A_x">x</code></td>
<td>
<p>an object of class <code>"decomp"</code>.</p>
</td></tr>
<tr><td><code id="plot.decomp_+3A_...">...</code></td>
<td>
<p>further graphical parameters may also be supplied as arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.specmx'>Plot Spectrum</h2><span id='topic+plot.specmx'></span>

<h3>Description</h3>

<p>Plot spectrum returned by <code><a href="#topic+mulspe">mulspe</a></code> and <code><a href="#topic+mulrsp">mulrsp</a></code>.
On and lower diagonal are real parts, and upper diagonal are imaginary parts. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'specmx'
plot(x, plot.scale = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.specmx_+3A_x">x</code></td>
<td>
<p>An object of class <code>"specmx"</code>.</p>
</td></tr>
<tr><td><code id="plot.specmx_+3A_plot.scale">plot.scale</code></td>
<td>
<p>logical. IF <code>TRUE</code>, the common range of the
<code class="reqn">y</code>-axis is used.</p>
</td></tr>
<tr><td><code id="plot.specmx_+3A_...">...</code></td>
<td>
<p>further graphical parameters may also be supplied as arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='Powerplant'>Power Plant Data</h2><span id='topic+Powerplant'></span>

<h3>Description</h3>

<p>A Power plant data for testing <code><a href="#topic+mulbar">mulbar</a></code> and <code><a href="#topic+mulmar">mulmar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(Powerplant)
</code></pre>


<h3>Format</h3>

<p>A 2-dimensional array with 500 observations on 3 variables.
</p>

<table>
<tr>
 <td style="text-align: right;">
    [, 1] </td><td style="text-align: left;"> command </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 2] </td><td style="text-align: left;"> temperature </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 3] </td><td style="text-align: left;"> fuel
  </td>
</tr>

</table>



<h3>Source</h3>

<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>

<hr>
<h2 id='prdctr'>Prediction Program</h2><span id='topic+prdctr'></span><span id='topic+print.prdctr'></span>

<h3>Description</h3>

<p>Operate on a real record of a vector process and compute predicted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prdctr(y, r, s, h, arcoef, macoef = NULL, impulse = NULL, v, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prdctr_+3A_y">y</code></td>
<td>
<p>a univariate time series or a multivariate time series.</p>
</td></tr>
<tr><td><code id="prdctr_+3A_r">r</code></td>
<td>
<p>one step ahead prediction starting position <code class="reqn">R</code>.</p>
</td></tr>
<tr><td><code id="prdctr_+3A_s">s</code></td>
<td>
<p>long range forecast starting position <code class="reqn">S</code>.</p>
</td></tr>
<tr><td><code id="prdctr_+3A_h">h</code></td>
<td>
<p>maximum span of long range forecast <code class="reqn">H</code>.</p>
</td></tr>
<tr><td><code id="prdctr_+3A_arcoef">arcoef</code></td>
<td>
<p>AR coefficient matrices.</p>
</td></tr>
<tr><td><code id="prdctr_+3A_macoef">macoef</code></td>
<td>
<p>MA coefficient matrices.</p>
</td></tr>
<tr><td><code id="prdctr_+3A_impulse">impulse</code></td>
<td>
<p>impulse response matrices.</p>
</td></tr>
<tr><td><code id="prdctr_+3A_v">v</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code id="prdctr_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), the real data and predicted
values are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One step ahead Prediction starts at time <code class="reqn">R</code> and ends at time <code class="reqn">S</code>.
Prediction is continued without new observations until time <code class="reqn">S+H</code>.
Basic model is the autoregressive moving average model of <code class="reqn">y(t)</code> which is
given by
</p>
<p style="text-align: center;"><code class="reqn">y(t) - A(t)y(t-1) -...- A(p)y(t-p) = u(t) - B(1)u(t-1) -...- B(q)u(t-q),</code>
</p>

<p>where <code class="reqn">p</code> is AR order and <code class="reqn">q</code> is MA order.
</p>


<h3>Value</h3>

<table>
<tr><td><code>predct</code></td>
<td>
<p>predicted values : <code>predct[i]</code>
(<code>r</code><code class="reqn">\le i \le</code><code>s</code><code class="reqn">+</code><code>h</code>).</p>
</td></tr>
<tr><td><code>ys</code></td>
<td>
<p><code>predct[i]</code> - <code>y[i]</code> (<code>r</code><code class="reqn">\le i \le n</code>).</p>
</td></tr>
<tr><td><code>pstd</code></td>
<td>
<p><code>predct[i]</code> + (standard deviation) 
(<code>s</code><code class="reqn">\le i \le</code><code>s</code><code class="reqn">+</code><code>h</code>).</p>
</td></tr>
<tr><td><code>p2std</code></td>
<td>
<p><code>predct[i]</code> + 2*(standard deviation)
(<code>s</code><code class="reqn">\le i \le</code><code>s</code><code class="reqn">+</code><code>h</code>).</p>
</td></tr>
<tr><td><code>p3std</code></td>
<td>
<p><code>predct[i]</code> + 3*(standard deviation)
(<code>s</code><code class="reqn">\le i \le</code><code>s</code><code class="reqn">+</code><code>h</code>).</p>
</td></tr>
<tr><td><code>mstd</code></td>
<td>
<p><code>predct[i]</code> - (standard deviation)
(<code>s</code><code class="reqn">\le i \le</code><code>s</code><code class="reqn">+</code><code>h</code>).</p>
</td></tr>
<tr><td><code>m2std</code></td>
<td>
<p><code>predct[i]</code> - 2*(standard deviation)
(<code>s</code><code class="reqn">\le i \le</code><code>s</code><code class="reqn">+</code><code>h</code>).</p>
</td></tr>
<tr><td><code>m3std</code></td>
<td>
<p><code>predct[i]</code> - 3*(standard deviation)
(<code>s</code><code class="reqn">\le i \le</code><code>s</code><code class="reqn">+</code><code>h</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1975) <em>Computer Science Monograph, No.6,
Timsac74, A Time Series Analysis and Control Program Package (2)</em>.
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "arima.sim" is a function in "stats".
# Note that the sign of MA coefficient is opposite from that in "timsac".
y &lt;- arima.sim(list(order=c(2,0,1), ar=c(0.64,-0.8), ma=c(-0.5)), n = 1000)
y1 &lt;- y[1:900]
z &lt;- autoarmafit(y1)
ar &lt;- z$model[[1]]$arcoef
ma &lt;- z$model[[1]]$macoef
var &lt;- z$model[[1]]$v
y2 &lt;- y[901:990]
prdctr(y2, r = 50, s = 90, h = 10, arcoef = ar, macoef = ma, v = var)
</code></pre>

<hr>
<h2 id='raspec'>Rational Spectrum</h2><span id='topic+raspec'></span>

<h3>Description</h3>

<p>Compute power spectrum of ARMA process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  raspec(h, var, arcoef = NULL, macoef = NULL, log = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raspec_+3A_h">h</code></td>
<td>
<p>specify frequencies
<code class="reqn">i</code>/<code>2h</code> (<code class="reqn">i=0,1,\ldots,</code><code>h</code>).</p>
</td></tr>
<tr><td><code id="raspec_+3A_var">var</code></td>
<td>
<p>variance.</p>
</td></tr>
<tr><td><code id="raspec_+3A_arcoef">arcoef</code></td>
<td>
<p>AR coefficients.</p>
</td></tr>
<tr><td><code id="raspec_+3A_macoef">macoef</code></td>
<td>
<p>MA coefficients.</p>
</td></tr>
<tr><td><code id="raspec_+3A_log">log</code></td>
<td>
<p>logical. If <code>TRUE</code>, the spectrum is plotted as
log(<code>raspec</code>).</p>
</td></tr>
<tr><td><code id="raspec_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), the spectrum is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ARMA process :
</p>
<p style="text-align: center;"><code class="reqn">y(t) - a(1)y(t-1) - \ldots - a(p)y(t-p) = u(t) - b(1)u(t-1) - \ldots - b(q)u(t-q)</code>
</p>

<p>where <code class="reqn">p</code> is AR order, <code class="reqn">q</code> is MA order and <code class="reqn">u(t)</code> is a white noise
with zero mean and variance equal to <code>var</code>.
</p>


<h3>Value</h3>

<p><code>raspec</code> gives the rational spectrum.
</p>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control of
Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 for the AR model
raspec(h = 100, var = 1, arcoef = c(0.64,-0.8))

# Example 2 for the MA model
raspec(h = 20, var = 1, macoef = c(0.64,-0.8))
</code></pre>

<hr>
<h2 id='sglfre'>Frequency Response Function (Single Channel)</h2><span id='topic+sglfre'></span>

<h3>Description</h3>

<p>Compute 1-input,1-output frequency response function, gain, phase, coherency
and relative error statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sglfre(y, lag = NULL, invar, outvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sglfre_+3A_y">y</code></td>
<td>
<p>a multivariate time series.</p>
</td></tr>
<tr><td><code id="sglfre_+3A_lag">lag</code></td>
<td>
<p>maximum lag. Default <code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code> is
the length of the time series <code>y</code>.</p>
</td></tr>
<tr><td><code id="sglfre_+3A_invar">invar</code></td>
<td>
<p>within <code class="reqn">d</code> variables of the spectrum, <code>invar</code>-th
variable is taken as an input variable.</p>
</td></tr>
<tr><td><code id="sglfre_+3A_outvar">outvar</code></td>
<td>
<p>within <code class="reqn">d</code> variables of the spectrum, <code>outvar</code>-th
variable is taken as an output variable .</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>inspec</code></td>
<td>
<p>power spectrum (input).</p>
</td></tr>
<tr><td><code>outspec</code></td>
<td>
<p>power spectrum (output).</p>
</td></tr>
<tr><td><code>cspec</code></td>
<td>
<p>co-spectrum.</p>
</td></tr>
<tr><td><code>qspec</code></td>
<td>
<p>quad-spectrum.</p>
</td></tr>
<tr><td><code>gain</code></td>
<td>
<p>gain.</p>
</td></tr>
<tr><td><code>coh</code></td>
<td>
<p>coherency.</p>
</td></tr>
<tr><td><code>freqr</code></td>
<td>
<p>frequency response function : real part.</p>
</td></tr>
<tr><td><code>freqi</code></td>
<td>
<p>frequency response function : imaginary part.</p>
</td></tr>
<tr><td><code>errstat</code></td>
<td>
<p>relative error statistics.</p>
</td></tr>
<tr><td><code>phase</code></td>
<td>
<p>phase.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control
of Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar &lt;- array(0, dim = c(3,3,2))
ar[, , 1] &lt;- matrix(c(0.4,  0,   0.3,
                      0.2, -0.1, -0.5,
                      0.3,  0.1,  0), nrow = 3, ncol = 3, byrow = TRUE)
ar[, , 2] &lt;- matrix(c(0,  -0.3,  0.5,
                      0.7, -0.4,  1,
                      0,   -0.5,  0.3), nrow = 3, ncol = 3, byrow = TRUE)
x &lt;- matrix(rnorm(200*3), nrow = 200, ncol = 3)
y &lt;- mfilter(x, ar, "recursive")
sglfre(y, lag = 20, invar = 1, outvar = 2)
</code></pre>

<hr>
<h2 id='simcon'>Optimal Controller Design and Simulation</h2><span id='topic+simcon'></span>

<h3>Description</h3>

<p>Produce optimal controller gain and simulate the controlled process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simcon(span, len, r, arcoef, impulse, v, weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simcon_+3A_span">span</code></td>
<td>
<p>span of control performance evaluation.</p>
</td></tr>
<tr><td><code id="simcon_+3A_len">len</code></td>
<td>
<p>length of experimental observation.</p>
</td></tr>
<tr><td><code id="simcon_+3A_r">r</code></td>
<td>
<p>dimension of control input, less than or equal to <code class="reqn">d</code> (dimension
of a vector).</p>
</td></tr>
<tr><td><code id="simcon_+3A_arcoef">arcoef</code></td>
<td>
<p>matrices of autoregressive coefficients. <code>arcoef[i,j,k]</code>
shows the value of <code class="reqn">i</code>-th row, <code class="reqn">j</code>-th column, <code class="reqn">k</code>-th order.</p>
</td></tr>
<tr><td><code id="simcon_+3A_impulse">impulse</code></td>
<td>
<p>impulse response matrices.</p>
</td></tr>
<tr><td><code id="simcon_+3A_v">v</code></td>
<td>
<p>covariance matrix of innovation.</p>
</td></tr>
<tr><td><code id="simcon_+3A_weight">weight</code></td>
<td>
<p>weighting matrix of performance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic state space model is obtained from the autoregressive moving average
model of a vector process <code class="reqn">y(t)</code>;
</p>
<p style="text-align: center;"><code class="reqn">y(t) - A(1)y(t-1) -\ldots- A(p)y(t-p) = u(t) - B(1)u(t-1) -\ldots- B(p-1)u(t-p+1),</code>
</p>

<p>where <code class="reqn">A(i)</code> (<code class="reqn">i=1,\ldots,p</code>) are the autoregressive
coefficients of the ARMA representation of <code class="reqn">y(t)</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>gain</code></td>
<td>
<p>controller gain.</p>
</td></tr>
<tr><td><code>ave</code></td>
<td>
<p>average value of i-th component of <code>y</code>.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>variance.</p>
</td></tr>
<tr><td><code>std</code></td>
<td>
<p>standard deviation.</p>
</td></tr>
<tr><td><code>bc</code></td>
<td>
<p>sub matrices <code class="reqn">(pd,r)</code> of impulse response matrices, where <code class="reqn">p</code>
is the order of the process, <code class="reqn">d</code> is the dimension of the vector and
<code class="reqn">r</code> is the dimension of the control input.</p>
</td></tr>
<tr><td><code>bd</code></td>
<td>
<p>sub matrices <code class="reqn">(pd,d-r)</code> of impulse response matrices.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1975) <em>Computer Science Monograph, No.6,
Timsac74, A Time Series Analysis and Control Program Package (2)</em>.
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(1000*2), nrow = 1000, ncol = 2)
ma &lt;- array(0, dim = c(2,2,2))
ma[, , 1] &lt;- matrix(c( -1.0,  0.0,
                        0.0, -1.0), nrow = 2, ncol = 2, byrow = TRUE)
ma[, , 2] &lt;- matrix(c( -0.2,  0.0,
                       -0.1, -0.3), nrow = 2, ncol = 2, byrow = TRUE)
y &lt;- mfilter(x, ma, "convolution")

ar &lt;- array(0, dim = c(2,2,3))
ar[, , 1] &lt;- matrix(c( -1.0,  0.0,
                        0.0, -1.0), nrow = 2, ncol = 2, byrow = TRUE)
ar[, , 2] &lt;- matrix(c( -0.5, -0.2,
                       -0.2, -0.5), nrow = 2, ncol = 2, byrow = TRUE)
ar[, , 3] &lt;- matrix(c( -0.3, -0.05,
                       -0.1, -0.3), nrow = 2, ncol = 2, byrow = TRUE)
y &lt;- mfilter(y, ar, "recursive")

z &lt;- markov(y)
weight &lt;-  matrix(c(0.0002,  0.0,
                    0.0,     2.9 ), nrow = 2, ncol = 2, byrow = TRUE)
simcon(span = 50, len = 700, r = 1, z$arcoef, z$impulse, z$v, weight)
</code></pre>

<hr>
<h2 id='thirmo'>Third Order Moments</h2><span id='topic+thirmo'></span>

<h3>Description</h3>

<p>Compute the third order moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thirmo(y, lag = NULL, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thirmo_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="thirmo_+3A_lag">lag</code></td>
<td>
<p>maximum lag. Default is <code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code>
is the length of the time series <code>y</code>.</p>
</td></tr>
<tr><td><code id="thirmo_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), autocovariance <code>acor</code> is
plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>mean</code></td>
<td>
<p>mean.</p>
</td></tr>
<tr><td><code>acov</code></td>
<td>
<p>autocovariance.</p>
</td></tr>
<tr><td><code>acor</code></td>
<td>
<p>normalized covariance.</p>
</td></tr>
<tr><td><code>tmomnt</code></td>
<td>
<p>third order moments.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1975) <em>Computer Science Monograph, No.6,
Timsac74, A Time Series Analysis and Control Program Package (2)</em>.
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bispecData)
z &lt;- thirmo(bispecData, lag = 30)
z$tmomnt
</code></pre>

<hr>
<h2 id='timsac-package'>
Time Series Analysis and Control Program Package
</h2><span id='topic+timsac-package'></span><span id='topic+timsac'></span>

<h3>Description</h3>

<p>R functions for statistical analysis and control of time series.
</p>


<h3>Details</h3>

<p>This package provides functions for statistical analysis, prediction and control
of time series. The original TIMSAC (TIMe Series Analysis and Control) or
TIMSAC-72 was published in Akaike and Nakagawa (1972). After that, TIMSAC-74,
TIMSAC-78 and TIMSAC-84 were published as the TIMSAC series in Computer Science
Monograph.
</p>
<p>For overview of models and information criteria for model selection, see
<a href="../doc/timsac-guide_e.pdf">../doc/timsac-guide_e.pdf</a> or <a href="../doc/timsac-guide_j.pdf">../doc/timsac-guide_j.pdf</a>
(in Japanese).
</p>


<h3>References</h3>

<p>H.Akaike, E.Arahata and T.Ozaki (1975)
<em>Computer Science Monograph, No.5, Timsac74, A Time Series Analysis and
Control Program Package (1)</em>. The Institute of Statistical Mathematics.
</p>
<p>H.Akaike, E.Arahata and T.Ozaki (1975)
<em>Computer Science Monograph, No.6, Timsac74, A Time Series Analysis and
Control Program Package (2)</em>. The Institute of Statistical Mathematics.
</p>
<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>
<p>H.Akaike, T.Ozaki, M.Ishiguro, Y.Ogata, G.Kitagawa, Y-H.Tamura, E.Arahata,
K.Katsura and Y.Tamura (1985)
<em>Computer Science Monograph, No.22, Timsac84 Part 1</em>.
The Institute of Statistical Mathematics.
</p>
<p>H.Akaike and T.Nakagawa (1988)
<em>Statistical Analysis and Control of Dynamic Systems.</em>
Kluwer Academic publishers.
</p>

<hr>
<h2 id='unibar'>Univariate Bayesian Method of AR Model Fitting</h2><span id='topic+unibar'></span>

<h3>Description</h3>

<p>This program fits an autoregressive model by a Bayesian procedure.
The least squares estimates of the parameters are obtained by
the householder transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  unibar(y, ar.order = NULL, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unibar_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="unibar_+3A_ar.order">ar.order</code></td>
<td>
<p>order of the AR model. Default is
<code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code> is the length of the time series
<code>y</code>.</p>
</td></tr>
<tr><td><code id="unibar_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), <code>daic</code>, <code>pacoef</code> and
<code>pspec</code> are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AR model is given by
</p>
<p style="text-align: center;"><code class="reqn">y(t) = a(1)y(t-1) + \ldots + a(p)y(t-p) + u(t),</code>
</p>

<p>where <code class="reqn">p</code> is AR order and <code class="reqn">u(t)</code> is Gaussian white noise with mean
<code class="reqn">0</code> and variance <code class="reqn">v(p)</code>. The basic statistic AIC is defined by
</p>
<p style="text-align: center;"><code class="reqn">AIC = n\log(det(v)) + 2m,</code>
</p>

<p>where <code class="reqn">n</code> is the length of data, <code class="reqn">v</code> is the estimate of innovation
variance, and <code class="reqn">m</code> is the order of the model.
</p>
<p>Bayesian weight of the <code class="reqn">m</code>-th order model is defined by
</p>
<p style="text-align: center;"><code class="reqn">W(m) = CONST \times \frac{C(m)}{m+1},</code>
</p>

<p>where <code class="reqn">CONST</code> is the normalizing constant and
<code class="reqn">C(m)=\exp(-0.5AIC(m))</code>. The equivalent number of
free parameter for the Bayesian model is defined by
</p>
<p style="text-align: center;"><code class="reqn">ek = D(1)^2 + \ldots + D(k)^2 +1,</code>
</p>

<p>where <code class="reqn">D(j)</code> is defined by
<code class="reqn">D(j)=W(j) + \ldots + W(k)</code>.
<code class="reqn">m</code> in the definition of AIC is replaced by <code class="reqn">ek</code> to be define an
equivalent AIC for a Bayesian model.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mean</code></td>
<td>
<p>mean.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>variance.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>aicmin</code></td>
<td>
<p>minimum AIC.</p>
</td></tr>
<tr><td><code>daic</code></td>
<td>
<p>AIC-<code>aicmin</code>.</p>
</td></tr>
<tr><td><code>order.maice</code></td>
<td>
<p>order of minimum AIC.</p>
</td></tr>
<tr><td><code>v.maice</code></td>
<td>
<p>innovation variance attained at m=<code>order.maice</code>.</p>
</td></tr>
<tr><td><code>pacoef</code></td>
<td>
<p>partial autocorrelation coefficients (least squares estimate).</p>
</td></tr>
<tr><td><code>bweight</code></td>
<td>
<p>Bayesian Weight.</p>
</td></tr>
<tr><td><code>integra.bweight</code></td>
<td>
<p>integrated Bayesian weights.</p>
</td></tr>
<tr><td><code>v.bay</code></td>
<td>
<p>innovation variance of Bayesian model.</p>
</td></tr>
<tr><td><code>aic.bay</code></td>
<td>
<p>AIC of Bayesian model.</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>equivalent number of parameters.</p>
</td></tr>
<tr><td><code>pacoef.bay</code></td>
<td>
<p>partial autocorrelation coefficients of Bayesian model.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>AR coefficients of Bayesian model.</p>
</td></tr>
<tr><td><code>pspec</code></td>
<td>
<p>power spectrum.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike (1978) A Bayesian Extension of The Minimum AIC Procedure of
Autoregressive model Fitting. Research memo. No.126.
The Institute of Statistical Mathematics.
</p>
<p>G.Kitagawa and H.Akaike (1978) A Procedure for The Modeling of Non-Stationary
Time Series. Ann. Inst. Statist. Math., 30, B, 351&ndash;363.
</p>
<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canadianlynx)
z &lt;- unibar(Canadianlynx, ar.order = 20)
z$arcoef
</code></pre>

<hr>
<h2 id='unimar'>Univariate Case of Minimum AIC Method of AR Model Fitting</h2><span id='topic+unimar'></span>

<h3>Description</h3>

<p>This is the basic program for the fitting of autoregressive models of
successively higher by the method of least squares realized through
householder transformation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unimar(y, max.order = NULL, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unimar_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="unimar_+3A_max.order">max.order</code></td>
<td>
<p>upper limit of AR order. Default is <code class="reqn">2 \sqrt{n}</code>, where <code class="reqn">n</code> is the length of the time series <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code id="unimar_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>daic</code> is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AR model is given by
</p>
<p style="text-align: center;"><code class="reqn">y(t) = a(1)y(t-1) + \ldots + a(p)y(t-p) + u(t),</code>
</p>

<p>where <code class="reqn">p</code> is AR order and <code class="reqn">u(t)</code> is Gaussian white noise with mean
<code class="reqn">0</code> and variance <code class="reqn">v</code>. AIC is defined by
</p>
<p style="text-align: center;"><code class="reqn">AIC = n\log(det(v)) + 2k,</code>
</p>

<p>where <code class="reqn">n</code> is the length of data, <code class="reqn">v</code> is the estimates of the
innovation variance and <code class="reqn">k</code> is the number of parameter.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mean</code></td>
<td>
<p>mean.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>variance.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>innovation variance.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>aicmin</code></td>
<td>
<p>minimum AIC.</p>
</td></tr>
<tr><td><code>daic</code></td>
<td>
<p>AIC-<code>aicmin</code>.</p>
</td></tr>
<tr><td><code>order.maice</code></td>
<td>
<p>order of minimum AIC.</p>
</td></tr>
<tr><td><code>v.maice</code></td>
<td>
<p>innovation variance attained at <code>order.maice</code>.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>AR coefficients.</p>
</td></tr>
</table>


<h3>References</h3>

<p>G.Kitagawa and H.Akaike (1978) A Procedure For The Modeling of Non-Stationary
Time Series. Ann. Inst. Statist. Math.,30, B, 351&ndash;363.
</p>
<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canadianlynx)
z &lt;- unimar(Canadianlynx, max.order = 20)
z$arcoef
</code></pre>

<hr>
<h2 id='wnoise'>White Noise Generator</h2><span id='topic+wnoise'></span>

<h3>Description</h3>

<p>Generate approximately Gaussian vector white noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  wnoise(len, perr, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wnoise_+3A_len">len</code></td>
<td>
<p>length of white noise record.</p>
</td></tr>
<tr><td><code id="wnoise_+3A_perr">perr</code></td>
<td>
<p>prediction error.</p>
</td></tr>
<tr><td><code id="wnoise_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), white noises are plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>wnoise</code> gives white noises.
</p>


<h3>References</h3>

<p>H.Akaike and T.Nakagawa (1988) <em>Statistical Analysis and Control
of Dynamic Systems.</em> Kluwer Academic publishers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
wnoise(len = 100, perr = 1)

# Example 2
v &lt;- matrix(c(1,  0,  0,
              0,  2,  0,
              0,  0,  3), nrow = 3, ncol = 3, byrow = TRUE)
wnoise(len = 20, perr = v)
</code></pre>

<hr>
<h2 id='xsarma'>Exact Maximum Likelihood Method of Scalar ARMA Model Fitting</h2><span id='topic+xsarma'></span>

<h3>Description</h3>

<p>Produce exact maximum likelihood estimates of the parameters of a scalar ARMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  xsarma(y, arcoefi, macoefi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xsarma_+3A_y">y</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="xsarma_+3A_arcoefi">arcoefi</code></td>
<td>
<p>initial estimates of AR coefficients.</p>
</td></tr>
<tr><td><code id="xsarma_+3A_macoefi">macoefi</code></td>
<td>
<p>initial estimates of MA coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ARMA model is given by
</p>
<p style="text-align: center;"><code class="reqn">y(t) - a(1)y(t-1) - \ldots - a(p)y(t-p) = u(t) - b(1)u(t-1) - ... - b(q)u(t-q),</code>
</p>

<p>where <code class="reqn">p</code> is AR order, <code class="reqn">q</code> is MA order and <code class="reqn">u(t)</code> is a zero mean white noise.
</p>


<h3>Value</h3>

<table>
<tr><td><code>gradi</code></td>
<td>
<p>initial gradient.</p>
</td></tr>
<tr><td><code>lkhoodi</code></td>
<td>
<p>initial (-2)log likelihood.</p>
</td></tr>
<tr><td><code>arcoef</code></td>
<td>
<p>final estimates of AR coefficients.</p>
</td></tr>
<tr><td><code>macoef</code></td>
<td>
<p>final estimates of MA coefficients.</p>
</td></tr>
<tr><td><code>grad</code></td>
<td>
<p>final gradient.</p>
</td></tr>
<tr><td><code>alph.ar</code></td>
<td>
<p>final ALPH (AR part) at subroutine ARCHCK.</p>
</td></tr>
<tr><td><code>alph.ma</code></td>
<td>
<p>final ALPH (MA part) at subroutine ARCHCK.</p>
</td></tr>
<tr><td><code>lkhood</code></td>
<td>
<p>final (-2)log likelihood.</p>
</td></tr>
<tr><td><code>wnoise.var</code></td>
<td>
<p>white noise variance.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.Akaike (1978)
Covariance matrix computation of the state variable of a stationary Gaussian process.
Research Memo. No.139. The Institute of Statistical Mathematics.
</p>
<p>H.Akaike, G.Kitagawa, E.Arahata and F.Tada (1979)
<em>Computer Science Monograph, No.11, Timsac78.</em>
The Institute of Statistical Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "arima.sim" is a function in "stats".
# Note that the sign of MA coefficient is opposite from that in "timsac".
arcoef &lt;- c(1.45, -0.9)
macoef &lt;- c(-0.5)
y &lt;- arima.sim(list(order=c(2,0,1), ar=arcoef, ma=macoef), n = 100)
arcoefi &lt;- c(1.5, -0.8)
macoefi &lt;- c(0.0)
z &lt;- xsarma(y, arcoefi, macoefi)
z$arcoef
z$macoef
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
