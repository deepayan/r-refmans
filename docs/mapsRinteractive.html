<!DOCTYPE html><html><head><title>Help for package mapsRinteractive</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mapsRinteractive}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check'><p>check</p></a></li>
<li><a href='#e'><p>e</p></a></li>
<li><a href='#evaluate'><p>evaluate</p></a></li>
<li><a href='#even'><p>even</p></a></li>
<li><a href='#extentpolygon'><p>extentpolygon</p></a></li>
<li><a href='#fback'><p>fback</p></a></li>
<li><a href='#kth'><p>kth</p></a></li>
<li><a href='#mae'><p>mae</p></a></li>
<li><a href='#me'><p>me</p></a></li>
<li><a href='#mri'><p>mri</p></a></li>
<li><a href='#odd'><p>even</p></a></li>
<li><a href='#ordkrige'><p>ordkrige</p></a></li>
<li><a href='#r2'><p>r2</p></a></li>
<li><a href='#regkrige'><p>regkrige</p></a></li>
<li><a href='#reskrige'><p>reskrige</p></a></li>
<li><a href='#rmse'><p>rmse</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Local Adaptation and Evaluation of Raster Maps</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kristin Persson &lt;kristin.persson@slu.se&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Local adaptation and evaluation of maps of continuous attributes in raster format by use of point location data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=mapsRinteractive">https://CRAN.R-project.org/package=mapsRinteractive</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kriper0217/mapsRinteractive/issues">https://github.com/kriper0217/mapsRinteractive/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>terra, gstat</td>
</tr>
<tr>
<td>Suggests:</td>
<td>roxygen2, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-24 05:45:18 UTC; piikki</td>
</tr>
<tr>
<td>Author:</td>
<td>Kristin Persson [aut, cre, cph],
  Mats Soderstrom [ctb, cph],
  John Mutua [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-24 07:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check'>check</h2><span id='topic+check'></span>

<h3>Description</h3>

<p>Checks attributes, geometries and projections of spatial data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check(
  x = NULL,
  y = NULL,
  z = NULL,
  field = NULL,
  edge = 0,
  filter = 1,
  resolution = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_+3A_x">x</code></td>
<td>
<p>SpatRaster. Required. Must be have a defined Cartesian coordinate 
system. Data must be continuous. If more than one layer, the first layer 
will be used.</p>
</td></tr>
<tr><td><code id="check_+3A_y">y</code></td>
<td>
<p>SpatVector of polygons. Optional. Delineates the area within
which the raster layer shall be locally adapted and evaluated. If not provided,
the analyses will be performed within the intersect of the raster and the
sampled area. Must be have a defined Cartesian coordinate system (same as x).</p>
</td></tr>
<tr><td><code id="check_+3A_z">z</code></td>
<td>
<p>SpatVector of points Required. Must have at least one column
with numerical data and these data must be of the same entity and unit as x
(specify this column by argument: field). Must be have a defined Cartesian 
coordinate system (same as x).</p>
</td></tr>
<tr><td><code id="check_+3A_field">field</code></td>
<td>
<p>Character value. Required. Name of the column in
y with the data that shall be used to locally adapt and evaluate the raster.</p>
</td></tr>
<tr><td><code id="check_+3A_edge">edge</code></td>
<td>
<p>Numeric value. Optional. Specifies the width (unit of the 
coordinate reference system) of a buffer zone inside the edge of the polygon 
that is excluded from the analyses. Allowed values are within the closed range 
of 0-10000.</p>
</td></tr>
<tr><td><code id="check_+3A_filter">filter</code></td>
<td>
<p>Positive integer. Optional. No of cells in the side of a square
window for mean filtering of x. Filtering is done before any resampling
(see argument: resolution). Allowed values are within the closed range of 1-20.</p>
</td></tr>
<tr><td><code id="check_+3A_resolution">resolution</code></td>
<td>
<p>Positive numeric value. Optional. The resolution (m) to
which the imported raster shall be resampled before the adaptation. Allowed
values are within the closed range of 0.1-10000. In addition, a resolution that
means more than 1E+8 raster cells is not allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intended for checking data in functions of mapsRinteractive.
</p>


<h3>Value</h3>

<p>A list with checked and corrected data sets together with a vector of logged feedback.
</p>

<hr>
<h2 id='e'>e</h2><span id='topic+e'></span>

<h3>Description</h3>

<p>Calculates the Nash-Sutcliffe modelling efficiency (E)
from observed and predicted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e(observed, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e_+3A_observed">observed</code></td>
<td>
<p>Numeric vector of observed values</p>
</td></tr>
<tr><td><code id="e_+3A_predicted">predicted</code></td>
<td>
<p>Numeric vector of predicted values. The length shall be
the same as for observed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>E = 1 - sum(observed - predicted)/sum(observed - mean (observed))
</p>


<h3>Value</h3>

<p>The Nash-Sutcliffe modelling efficiency (E) calculated from observed and
predicted values.
</p>


<h3>References</h3>

<p>Nash, J. E., &amp; Sutcliffe, J. V. (1970). River flow forecasting
through conceptual models part Iâ€”A discussion of principles. Journal of
hydrology, 10(3), 282-290.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>o&lt;-1:5
p&lt;-c(2,2,4,3,5)
e(observed=o, predicted=p)

</code></pre>

<hr>
<h2 id='evaluate'>evaluate</h2><span id='topic+evaluate'></span>

<h3>Description</h3>

<p>Computes evaluation measures from observed and predicted data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate(df, observed, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_+3A_df">df</code></td>
<td>
<p>Data.frame. Required. A data.frame with observed and predicted data.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_observed">observed</code></td>
<td>
<p>Character value. Required. The  name of the column in df
with predicted data.The data must be of class numeric.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_predicted">predicted</code></td>
<td>
<p>Character value or vector. Required. The  names of the
column(s) in df with predicted data. The data  must be of class numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with evaluation statistics. For details, see mri function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df&lt;-data.frame(obs=1:9, pred=c(2, 9, 10, 8, 3, 4, 6, 12, 1))
e&lt;-evaluate(df, 'obs', 'pred')
print(e)

</code></pre>

<hr>
<h2 id='even'>even</h2><span id='topic+even'></span>

<h3>Description</h3>

<p>Checks whether an integer is even.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>even(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="even_+3A_x">x</code></td>
<td>
<p>Integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value (TRUE or FALSE). TRUE means that the value is even.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>even(3)

</code></pre>

<hr>
<h2 id='extentpolygon'>extentpolygon</h2><span id='topic+extentpolygon'></span>

<h3>Description</h3>

<p>Create a SpatVector of polygons from the extent of a spatial object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extentpolygon(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extentpolygon_+3A_x">x</code></td>
<td>
<p>A spatial object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If x is projected, the SpatVector will also be projected
</p>


<h3>Value</h3>

<p>SpatVector of polygons.
</p>

<hr>
<h2 id='fback'>fback</h2><span id='topic+fback'></span>

<h3>Description</h3>

<p>Prints feedback and adds it to a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fback(t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fback_+3A_t">t</code></td>
<td>
<p>Character string. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Character vector.
</p>

<hr>
<h2 id='kth'>kth</h2><span id='topic+kth'></span>

<h3>Description</h3>

<p>Identification of the kth highest/lowest value(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kth(
  x = NULL,
  k = 2,
  highest = TRUE,
  index = FALSE,
  unique = FALSE,
  multiple = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kth_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="kth_+3A_k">k</code></td>
<td>
<p>Positive integer. The order of the value to find. Default = 2,
which means that the next highest/lowest values is identified.</p>
</td></tr>
<tr><td><code id="kth_+3A_highest">highest</code></td>
<td>
<p>Logical. TRUE means that the kth highest value(s) is/are
identified. FALSE means that the kth lowest value(s) is/are identified.
Default = TRUE.</p>
</td></tr>
<tr><td><code id="kth_+3A_index">index</code></td>
<td>
<p>Logical. TRUE means that the index/indices of the kth highest/lowest
value(s) is/are returned. FALSE means that the kth highest/lowest value
itself is returned. If ties exist and argument multiple = TRUE, the returned value is a vector, else
it is a value. Default = FALSE.</p>
</td></tr>
<tr><td><code id="kth_+3A_unique">unique</code></td>
<td>
<p>Logical. TRUE means that duplicates are removed before the
identification of the kth highest/lowest value(s). Default=FALSE</p>
</td></tr>
<tr><td><code id="kth_+3A_multiple">multiple</code></td>
<td>
<p>Logical. TRUE means that, If ties exist a vector of
all values in x that are equal to the kth highest/lowest values is returned.
FALSE means that one random value from the vector of index values is
returned. Default=FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NA values are removed.
</p>


<h3>Value</h3>

<p>If index = FALSE: the kth highest/lowest value is returned.
</p>
<p>If index = TRUE: the index of the kth highest/lowest value (s) is/are
returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kth(x=1:20, k=3, highest=FALSE)

</code></pre>

<hr>
<h2 id='mae'>mae</h2><span id='topic+mae'></span>

<h3>Description</h3>

<p>Calculates the mean absolute error (MAE) from observed and
predicted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mae(observed, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mae_+3A_observed">observed</code></td>
<td>
<p>Numeric vector of observed values</p>
</td></tr>
<tr><td><code id="mae_+3A_predicted">predicted</code></td>
<td>
<p>Numeric vector of predicted values. The length shall be
the same as for observed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mae = mean(abs(observed - predicted))
</p>


<h3>Value</h3>

<p>The mean absolute error (MAE) calculated from the observed and the
predicted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>o&lt;-1:5
p&lt;-c(2,2,4,3,5)
mae(observed=o, predicted=p)

</code></pre>

<hr>
<h2 id='me'>me</h2><span id='topic+me'></span>

<h3>Description</h3>

<p>Calculates the mean error (ME) from observed and predicted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>me(observed, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="me_+3A_observed">observed</code></td>
<td>
<p>Numeric vector of observed values</p>
</td></tr>
<tr><td><code id="me_+3A_predicted">predicted</code></td>
<td>
<p>Numeric vector of predicted values. The length shall be
the same as for observed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ME = bias = mean(observed - predicted)
</p>


<h3>Value</h3>

<p>The mean error (ME) calculated from the observed and the predicted
values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>o&lt;-1:5
p&lt;-c(2,2,4,3,5)
me(observed=o, predicted=p)

</code></pre>

<hr>
<h2 id='mri'>mri</h2><span id='topic+mri'></span>

<h3>Description</h3>

<p>Local adaptation and evaluation of maps of continuous variables
in raster format by use of point location data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mri(
  x = NULL,
  y = NULL,
  z = NULL,
  field = NULL,
  edge = 0,
  filter = 1,
  resolution = NULL,
  md = "Sph",
  rg = NULL,
  ng = 0.1,
  check.data = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mri_+3A_x">x</code></td>
<td>
<p>SpatRaster. Required. Must be have a defined Cartesian coordinate 
system. Data must be continuous. If more than one layer, the first layer 
will be used.</p>
</td></tr>
<tr><td><code id="mri_+3A_y">y</code></td>
<td>
<p>SpatVector of polygons. Optional. Delineates the area within
which the raster layer shall be locally adapted and evaluated. If not provided,
the analyses will be performed within the intersect of the raster and the
sampled area. Must be have a defined Cartesian coordinate system (same as x).</p>
</td></tr>
<tr><td><code id="mri_+3A_z">z</code></td>
<td>
<p>SpatVector of points Required. Must have at least one column
with numerical data and these data must be of the same entity and unit as x
(specify this column by argument: field). Must be have a defined Cartesian 
coordinate system (same as x).</p>
</td></tr>
<tr><td><code id="mri_+3A_field">field</code></td>
<td>
<p>Character value. Required. Name of the column in
y with the data that shall be used to locally adapt and evaluate the raster.</p>
</td></tr>
<tr><td><code id="mri_+3A_edge">edge</code></td>
<td>
<p>Numeric value. Optional. Specifies the width (unit of the 
coordinate reference system) of a buffer zone inside the edge of the polygon 
that is excluded from the analyses. Allowed values are within the closed range 
of 0-10000.</p>
</td></tr>
<tr><td><code id="mri_+3A_filter">filter</code></td>
<td>
<p>Positive integer. Optional. No of cells in the side of a square
window for mean filtering of x. Filtering is done before any resampling
(see argument: resolution). Allowed values are within the closed range of 1-20.</p>
</td></tr>
<tr><td><code id="mri_+3A_resolution">resolution</code></td>
<td>
<p>Positive numeric value. Optional. The resolution (m) to
which the imported raster shall be resampled before the adaptation. Allowed
values are within the closed range of 0.1-10000. In addition, a resolution that
means more than 1E+8 raster cells is not allowed.</p>
</td></tr>
<tr><td><code id="mri_+3A_md">md</code></td>
<td>
<p>Character value. Optional. Variogram model type for the standardized
variograms used for ordinary kriging interpolation of observed data or residuals.
Variograms are generated by gstat::vgm. Default is &quot;Sph&quot; (spherical model).</p>
</td></tr>
<tr><td><code id="mri_+3A_rg">rg</code></td>
<td>
<p>Numeric value. Optional. Range of the standardized variograms used
for ordinary kriging interpolation of observed data or residuals. Variograms
are generated by gstat::vgm. If no rg is specified it will be set to half of
the square root of the mapping area: y (possibly shrinked by edge).</p>
</td></tr>
<tr><td><code id="mri_+3A_ng">ng</code></td>
<td>
<p>Numeric value. Optional. Nugget of the standardized variograms
used for ordinary kriging interpolation of observed data or residuals.
Variograms are  generated by gstat::vgm. The nugget is expressed as a fraction
of the sill. A ng = 0.1 means that the nugget is 10 percent of the sill. The sill
is by default equal to the variance of the data to be kriged (i.e the point
observations or the residuals). Allowed values of ng are within the closed
range of 0-1.</p>
</td></tr>
<tr><td><code id="mri_+3A_check.data">check.data</code></td>
<td>
<p>Logical value. Default is TRUE. Shall attributes, geometries and projections of
the input data (arguments x, y and z) be checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mri function is intended for local adaptation and evaluation
of raster maps with continuous variables. A SpatRaster and a SpatVector of point
data (same variable and unit as the raster) are required. A SpatVector of polygons
can optionally be used to delineate the area for local adaptation and evaluation.
</p>
<p>It is a requirement that all spatial objects (x, y and z) have the same projection.
The analyses require a Cartesian coordinate reference system. 
</p>
<p>Four maps are (created and) evaluated: the original raster map, a map
created solely based on the soil samples data (ordinary kriging using a standardized
variogram), two maps based on a combination of the raster data and the point
observations (regression kriging and residual kriging, both using standardized
variograms).
</p>
<p>The maps are evaluated by leave-one-out cross validation and a number of
evaluation measures are computed: the Nash-Sutcliffe modelling efficiency (E),
the mean absolute error (MAE; Janssen &amp; Heuberger, 1995), the coefficient of
determination of a linear regression between predicted and measured values (r2).
</p>
<p>The mapped area is the intersection between the original raster
map (argument: x), any provided SpatVector of polygons (argument: y) and the
buffered point locations. The buffer width is 1.5*(next largest distance) between
one point and its nearest neighbor).
</p>
<p>The mapsRInteractive algorithmns have been
described ad by Piikki et al.(2017) and Nijbroek et al. (2018), where more details
can be found .
</p>
<p>On error: check that required data are provided (arguments x, y, z and field),
check that all spatal datasets (arguments x, y, z) are projected, check that
they do overlap and check that the arguments edge, filter and resolution have
appropriate values.
</p>


<h3>Value</h3>

<p>A list with:
</p>
<p>1) 'maps'. A raster stack of the original raster map ('map'), the map,
created by ordinary kriging of observed data ('ordkrig'), by residual kriging
('reskrig') and by regression kriging ('regkrig').
</p>
<p>2) 'area'. SpatVector of the polygon delineating the
mapped area.
</p>
<p>3) 'pts'. SpatVector of point locations used for mapping,
i.e points falling within the mapped area, excluding points with NA values in
the observed values or the values extacted from the original map. The column names mean:
obs = observed values.
map = original map values.
ordkrig_cv = values from the leave-one-out cross validation of the ordinary kriging.
res = residuals (map - obs)
reskrig_cv = values from the leave-one-out cross validation of the residual kriging.
regpred = predicted values from the linear regression (obs = a*map + b)
regres = residuals (regpred - obs)
regkrig_cv = values from the leave-one-out cross validation of the regression kriging.
</p>
<p>4) 'evaluation'. a data.frame with evaluation statistics for the original map
and the leave-one-out cross-validation of the other mapping methods.
</p>
<p>5) 'feedback' a character vector with logged feedback on inputted and used data.
</p>


<h3>References</h3>

<p>Nijbroek, R., Piikki, K., SÃ¶derstrÃ¶m, M., Kempen, B., Turner,
K. G., Hengari, S., &amp; Mutua, J. (2018). Soil Organic Carbon Baselines for
Land Degradation Neutrality: Map Accuracy and Cost Tradeoffs with Respect to
Complexity in Otjozondjupa, Namibia. Sustainability, 10(5), 1610.
doi:10.3390/su10051610
</p>
<p>Piikki, K.,SÃ¶derstrÃ¶m, M., Stadig, H. 2017. Local adaptation of a national digital
soil map for use in precision agriculture. Adv. Anim. Biosci. 8, 430â€“432.
</p>
<p>Janssen, P.H.M.; Heuberger, P.S.C.1995. Calibration of process-oriented models.
Ecol. Model., 831, 55â€“66.
</p>
<p>Nash, J.E.; Sutcliffe, J.V. River flow forecasting through conceptual models
part Iâ€”A discussion of principles. J. Hydrol. 1970, 103, 282â€“290.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load package
require(terra)

#create a synthetic example raster dataset
rr1&lt;-rast(nrow=10, ncol=10, 
  vals= sample(1:4, 100, replace=TRUE), 
  crs=crs("EPSG:3857")
  )
rr2&lt;-disagg(rr1, 4, 'bilinear')

#create an example SpatVector of points
p&lt;-spatSample(x=rr1, size=30, values=TRUE, as.points=TRUE)

#do local evaluation and adaptation of the raster data based on the point data
m&lt;-mri(x = rr2, z = p, field ="lyr.1")

##check evaluation measures
print(m$evaluation)
plot(m$maps)
</code></pre>

<hr>
<h2 id='odd'>even</h2><span id='topic+odd'></span>

<h3>Description</h3>

<p>Checks whether an integer is odd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odd(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odd_+3A_x">x</code></td>
<td>
<p>Integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value (TRUE or FALSE). TRUE means that the value is odd.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>odd(3)

</code></pre>

<hr>
<h2 id='ordkrige'>ordkrige</h2><span id='topic+ordkrige'></span>

<h3>Description</h3>

<p>Regression kriging using a standardized variogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordkrige(
  x = NULL,
  y = NULL,
  z = NULL,
  field = NULL,
  edge = 0,
  filter = 1,
  resolution = NULL,
  md = "Sph",
  rg = NULL,
  ng = 0.1,
  check.data = TRUE,
  cross.validate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordkrige_+3A_x">x</code></td>
<td>
<p>SpatRaster. Required. Must be have a defined Cartesian coordinate 
system. Data must be continuous. If more than one layer, the first layer 
will be used.</p>
</td></tr>
<tr><td><code id="ordkrige_+3A_y">y</code></td>
<td>
<p>SpatVector of polygons. Optional. Delineates the area within
which the raster layer shall be locally adapted and evaluated. If not provided,
the analyses will be performed within the intersect of the raster and the
sampled area. Must be have a defined Cartesian coordinate system (same as x).</p>
</td></tr>
<tr><td><code id="ordkrige_+3A_z">z</code></td>
<td>
<p>SpatVector of points Required. Must have at least one column
with numerical data and these data must be of the same entity and unit as x
(specify this column by argument: field). Must be have a defined Cartesian 
coordinate system (same as x).</p>
</td></tr>
<tr><td><code id="ordkrige_+3A_field">field</code></td>
<td>
<p>Character value. Required. Name of the column in
y with the data that shall be used to locally adapt and evaluate the raster.</p>
</td></tr>
<tr><td><code id="ordkrige_+3A_edge">edge</code></td>
<td>
<p>Numeric value. Optional. Specifies the width (unit of the 
coordinate reference system) of a buffer zone inside the edge of the polygon 
that is excluded from the analyses. Allowed values are within the closed range 
of 0-10000.</p>
</td></tr>
<tr><td><code id="ordkrige_+3A_filter">filter</code></td>
<td>
<p>Positive integer. Optional. No of cells in the side of a square
window for mean filtering of x. Filtering is done before any resampling
(see argument: resolution). Allowed values are within the closed range of 1-20.</p>
</td></tr>
<tr><td><code id="ordkrige_+3A_resolution">resolution</code></td>
<td>
<p>Positive numeric value. Optional. The resolution (m) to
which the imported raster shall be resampled before the adaptation. Allowed
values are within the closed range of 0.1-10000. In addition, a resolution that
means more than 1E+8 raster cells is not allowed.</p>
</td></tr>
<tr><td><code id="ordkrige_+3A_md">md</code></td>
<td>
<p>Character value. Optional. Variogram model type for the standardized
variograms used for ordinary kriging interpolation of observed data or residuals.
Variograms are generated by gstat::vgm. Default is &quot;Sph&quot; (spherical model).</p>
</td></tr>
<tr><td><code id="ordkrige_+3A_rg">rg</code></td>
<td>
<p>Numeric value. Optional. Range of the standardized variograms used
for ordinary kriging interpolation of observed data or residuals. Variograms
are generated by gstat::vgm. If no rg is specified it will be set to half of
the square root of the mapping area: y (possibly shrinked by edge).</p>
</td></tr>
<tr><td><code id="ordkrige_+3A_ng">ng</code></td>
<td>
<p>Numeric value. Optional. Nugget of the standardized variograms
used for ordinary kriging interpolation of observed data or residuals.
Variograms are  generated by gstat::vgm. The nugget is expressed as a fraction
of the sill. A ng = 0.1 means that the nugget is 10 percent of the sill. The sill
is by default equal to the variance of the data to be kriged (i.e the point
observations or the residuals). Allowed values of ng are within the closed
range of 0-1.</p>
</td></tr>
<tr><td><code id="ordkrige_+3A_check.data">check.data</code></td>
<td>
<p>Logical value. Default is TRUE. Shall attributes, geometries and projections of
the input data (arguments x, y and z) be checked.</p>
</td></tr>
<tr><td><code id="ordkrige_+3A_cross.validate">cross.validate</code></td>
<td>
<p>Logical value. If TRUE, a leave-one-out cross-validation
is performed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the ordinary kriging function called by the mri function.
It uses a standardized semivariogram model and requires a raster template for which
predictions are made. For details, see documentation of the mri function.
</p>


<h3>Value</h3>

<p>A list with 1) a raster layer with predicted values and 2) a
SpatVector of points with predictions from a leave-one-out cross-
validation For details, see mri function.
</p>

<hr>
<h2 id='r2'>r2</h2><span id='topic+r2'></span>

<h3>Description</h3>

<p>Calculates the coefficient of determination (r2) for a linear
regression model between predicted values and observed values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2(observed, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r2_+3A_observed">observed</code></td>
<td>
<p>Numeric vector of observed values</p>
</td></tr>
<tr><td><code id="r2_+3A_predicted">predicted</code></td>
<td>
<p>Numeric vector of predicted values. The length shall be
the same as for observed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficient of determination (r2) for a linear regression model
between predicted values and observed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>o&lt;-1:5
p&lt;-c(2,2,4,3,5)
r2(observed=o, predicted=p)

</code></pre>

<hr>
<h2 id='regkrige'>regkrige</h2><span id='topic+regkrige'></span>

<h3>Description</h3>

<p>Regression kriging using a standardized variogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regkrige(
  x = NULL,
  y = NULL,
  z = NULL,
  field = NULL,
  edge = 0,
  filter = 1,
  resolution = NULL,
  md = "Sph",
  rg = NULL,
  ng = 0.1,
  check.data = TRUE,
  cross.validate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regkrige_+3A_x">x</code></td>
<td>
<p>SpatRaster. Required. Must be have a defined Cartesian coordinate 
system. Data must be continuous. If more than one layer, the first layer 
will be used.</p>
</td></tr>
<tr><td><code id="regkrige_+3A_y">y</code></td>
<td>
<p>SpatVector of polygons. Optional. Delineates the area within
which the raster layer shall be locally adapted and evaluated. If not provided,
the analyses will be performed within the intersect of the raster and the
sampled area. Must be have a defined Cartesian coordinate system (same as x).</p>
</td></tr>
<tr><td><code id="regkrige_+3A_z">z</code></td>
<td>
<p>SpatVector of points Required. Must have at least one column
with numerical data and these data must be of the same entity and unit as x
(specify this column by argument: field). Must be have a defined Cartesian 
coordinate system (same as x).</p>
</td></tr>
<tr><td><code id="regkrige_+3A_field">field</code></td>
<td>
<p>Character value. Required. Name of the column in
y with the data that shall be used to locally adapt and evaluate the raster.</p>
</td></tr>
<tr><td><code id="regkrige_+3A_edge">edge</code></td>
<td>
<p>Numeric value. Optional. Specifies the width (unit of the 
coordinate reference system) of a buffer zone inside the edge of the polygon 
that is excluded from the analyses. Allowed values are within the closed range 
of 0-10000.</p>
</td></tr>
<tr><td><code id="regkrige_+3A_filter">filter</code></td>
<td>
<p>Positive integer. Optional. No of cells in the side of a square
window for mean filtering of x. Filtering is done before any resampling
(see argument: resolution). Allowed values are within the closed range of 1-20.</p>
</td></tr>
<tr><td><code id="regkrige_+3A_resolution">resolution</code></td>
<td>
<p>Positive numeric value. Optional. The resolution (m) to
which the imported raster shall be resampled before the adaptation. Allowed
values are within the closed range of 0.1-10000. In addition, a resolution that
means more than 1E+8 raster cells is not allowed.</p>
</td></tr>
<tr><td><code id="regkrige_+3A_md">md</code></td>
<td>
<p>Character value. Optional. Variogram model type for the standardized
variograms used for ordinary kriging interpolation of observed data or residuals.
Variograms are generated by gstat::vgm. Default is &quot;Sph&quot; (spherical model).</p>
</td></tr>
<tr><td><code id="regkrige_+3A_rg">rg</code></td>
<td>
<p>Numeric value. Optional. Range of the standardized variograms used
for ordinary kriging interpolation of observed data or residuals. Variograms
are generated by gstat::vgm. If no rg is specified it will be set to half of
the square root of the mapping area: y (possibly shrinked by edge).</p>
</td></tr>
<tr><td><code id="regkrige_+3A_ng">ng</code></td>
<td>
<p>Numeric value. Optional. Nugget of the standardized variograms
used for ordinary kriging interpolation of observed data or residuals.
Variograms are  generated by gstat::vgm. The nugget is expressed as a fraction
of the sill. A ng = 0.1 means that the nugget is 10 percent of the sill. The sill
is by default equal to the variance of the data to be kriged (i.e the point
observations or the residuals). Allowed values of ng are within the closed
range of 0-1.</p>
</td></tr>
<tr><td><code id="regkrige_+3A_check.data">check.data</code></td>
<td>
<p>Logical value. Default is TRUE. Shall attributes, geometries and projections of
the input data (arguments x, y and z) be checked.</p>
</td></tr>
<tr><td><code id="regkrige_+3A_cross.validate">cross.validate</code></td>
<td>
<p>Logical value. If TRUE, a leave-one-out cross-validation
is performed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the ordinary kriging function called by the mri function.
It uses a standardized semivariogram model and requires a raster template for which
predictions are made. For details, see documentation of the mri function.
</p>


<h3>Value</h3>

<p>A list with 1) a raster layer with predicted values and 2) if
cross.validate=T, a SpatVector of points with predictions from a
leave-one-out cross-validation. For details, see mri function.
</p>

<hr>
<h2 id='reskrige'>reskrige</h2><span id='topic+reskrige'></span>

<h3>Description</h3>

<p>Regression kriging using a standardized variogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reskrige(
  x = NULL,
  y = NULL,
  z = NULL,
  field = NULL,
  edge = 0,
  filter = 1,
  resolution = NULL,
  md = "Sph",
  rg = NULL,
  ng = 0.1,
  check.data = TRUE,
  cross.validate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reskrige_+3A_x">x</code></td>
<td>
<p>SpatRaster. Required. Must be have a defined Cartesian coordinate 
system. Data must be continuous. If more than one layer, the first layer 
will be used.</p>
</td></tr>
<tr><td><code id="reskrige_+3A_y">y</code></td>
<td>
<p>SpatVector of polygons. Optional. Delineates the area within
which the raster layer shall be locally adapted and evaluated. If not provided,
the analyses will be performed within the intersect of the raster and the
sampled area. Must be have a defined Cartesian coordinate system (same as x).</p>
</td></tr>
<tr><td><code id="reskrige_+3A_z">z</code></td>
<td>
<p>SpatVector of points Required. Must have at least one column
with numerical data and these data must be of the same entity and unit as x
(specify this column by argument: field). Must be have a defined Cartesian 
coordinate system (same as x).</p>
</td></tr>
<tr><td><code id="reskrige_+3A_field">field</code></td>
<td>
<p>Character value. Required. Name of the column in
y with the data that shall be used to locally adapt and evaluate the raster.</p>
</td></tr>
<tr><td><code id="reskrige_+3A_edge">edge</code></td>
<td>
<p>Numeric value. Optional. Specifies the width (unit of the 
coordinate reference system) of a buffer zone inside the edge of the polygon 
that is excluded from the analyses. Allowed values are within the closed range 
of 0-10000.</p>
</td></tr>
<tr><td><code id="reskrige_+3A_filter">filter</code></td>
<td>
<p>Positive integer. Optional. No of cells in the side of a square
window for mean filtering of x. Filtering is done before any resampling
(see argument: resolution). Allowed values are within the closed range of 1-20.</p>
</td></tr>
<tr><td><code id="reskrige_+3A_resolution">resolution</code></td>
<td>
<p>Positive numeric value. Optional. The resolution (m) to
which the imported raster shall be resampled before the adaptation. Allowed
values are within the closed range of 0.1-10000. In addition, a resolution that
means more than 1E+8 raster cells is not allowed.</p>
</td></tr>
<tr><td><code id="reskrige_+3A_md">md</code></td>
<td>
<p>Character value. Optional. Variogram model type for the standardized
variograms used for ordinary kriging interpolation of observed data or residuals.
Variograms are generated by gstat::vgm. Default is &quot;Sph&quot; (spherical model).</p>
</td></tr>
<tr><td><code id="reskrige_+3A_rg">rg</code></td>
<td>
<p>Numeric value. Optional. Range of the standardized variograms used
for ordinary kriging interpolation of observed data or residuals. Variograms
are generated by gstat::vgm. If no rg is specified it will be set to half of
the square root of the mapping area: y (possibly shrinked by edge).</p>
</td></tr>
<tr><td><code id="reskrige_+3A_ng">ng</code></td>
<td>
<p>Numeric value. Optional. Nugget of the standardized variograms
used for ordinary kriging interpolation of observed data or residuals.
Variograms are  generated by gstat::vgm. The nugget is expressed as a fraction
of the sill. A ng = 0.1 means that the nugget is 10 percent of the sill. The sill
is by default equal to the variance of the data to be kriged (i.e the point
observations or the residuals). Allowed values of ng are within the closed
range of 0-1.</p>
</td></tr>
<tr><td><code id="reskrige_+3A_check.data">check.data</code></td>
<td>
<p>Logical value. Default is TRUE. Shall attributes, geometries and projections of
the input data (arguments x, y and z) be checked.</p>
</td></tr>
<tr><td><code id="reskrige_+3A_cross.validate">cross.validate</code></td>
<td>
<p>Logical value. If TRUE, a leave-one-out cross-validation
is performed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the ordinary kriging function called by the mri function.
It uses a standardized semivariogram model and requires a raster template for which
predictions are made. For details, see documentation of the mri function.
</p>


<h3>Value</h3>

<p>A list with 1) a raster layer with predicted values and 2) if
cross.validate=T, a SpatVector of points with predictions from a
leave-one-out cross-validation. For details, see mri function.
</p>

<hr>
<h2 id='rmse'>rmse</h2><span id='topic+rmse'></span>

<h3>Description</h3>

<p>Calculates the root mean square error (RMSE) from observed and
predicted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmse(observed, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmse_+3A_observed">observed</code></td>
<td>
<p>Numeric vector of observed values</p>
</td></tr>
<tr><td><code id="rmse_+3A_predicted">predicted</code></td>
<td>
<p>Numeric vector of predicted values. The length shall be
the same as for observed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>rmse = sqrt(mean((observed - predicted)^2))
</p>


<h3>Value</h3>

<p>The root mean square err or (RMSE) calculated from the observed and
the predicted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>o&lt;-1:5
p&lt;-c(2,2,4,3,5)
rmse(observed=o, predicted=p)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
