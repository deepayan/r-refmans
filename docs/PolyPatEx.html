<!DOCTYPE html><html lang="en"><head><title>Help for package PolyPatEx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PolyPatEx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PolyPatEx-package'><p>Polyploid paternity exclusion by allele matching.</p></a></li>
<li><a href='#convertToPhenot'><p>Convert a genotype allele dataset to a phenotype dataset</p></a></li>
<li><a href='#fixCSV'><p>Tidy a comma separated value (CSV) file</p></a></li>
<li><a href='#foreignAlleles'><p>Identify foreign alleles</p></a></li>
<li><a href='#FR_Genotype'><p>Example genotype allele dataset</p></a></li>
<li><a href='#genotPPE'><p>Simple paternity exclusion for genotype allele data</p></a></li>
<li><a href='#GF_Phenotype'><p>Example phenotype allele dataset</p></a></li>
<li><a href='#inputData'><p>Read in, check and preprocess the allele dataset</p></a></li>
<li><a href='#multilocusTypes'><p>Genotype summaries</p></a></li>
<li><a href='#phenotPPE'><p>Simple paternity exclusion for phenotype allele data</p></a></li>
<li><a href='#potentialFatherCounts'><p>Count potential fathers</p></a></li>
<li><a href='#potentialFatherIDs'><p>Identify potential fathers</p></a></li>
<li><a href='#preprocessData'><p>Check and preprocess an allele dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Paternity Exclusion in Autopolyploid Species</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-04-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Zwart</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Zwart &lt;Alec.Zwart@csiro.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to perform paternity exclusion via allele
    matching, in autopolyploid species having ploidy 4, 6, or 8. The
    marker data used can be genotype data (copy numbers known) or
    'allelic phenotype data' (copy numbers not known).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>gtools, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1.9000</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-04-11 05:18:15 UTC; zwa005</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-04-11 09:06:29</td>
</tr>
</table>
<hr>
<h2 id='PolyPatEx-package'>Polyploid paternity exclusion by allele matching.</h2><span id='topic+PolyPatEx-package'></span>

<h3>Description</h3>

<p>PolyPatEx provides functions to perform paternity exclusion
analysis in autopolyploid species having ploidy 4, 6, or 8.  The
package requires codominant marker data from two or more loci in a
monoecious or dioecious species.  The marker data can be
'genotypic' (copy numbers known) or 'phenotypic' (copy numbers not
known).  PolyPatEx can also perform exclusion on diploid (ploidy
2) <em>genotype</em> data.
</p>


<h3>Details</h3>

<p>Routines are provided to compare each progeny with its mother, and
then with the candidate fathers, to determine which candidates are
indeed capable of being fathers, on the basis of the allele sets
they display at each locus.
</p>
<p>PolyPatEx addresses the question - at a given locus, can the
candidate father provide a viable gamete given its allele set, and
given the possible paternal gametes indicated by the progeny's and
mother's allele sets?
</p>
<p>Note that PolyPatEx does not implement a probabilistic solution to
the exclusion problem, merely a simple comparative analysis based
on available alleles and their multiplicities.  Also note that
PolyPatEx is not optimised for very large marker datasets such as
SNP datasets, instead is suited to low density, high information
markers such as SSRs.
</p>


<h3>Author(s)</h3>

<p>Alexander Zwart (alec.zwart at csiro.au)
</p>

<hr>
<h2 id='convertToPhenot'>Convert a genotype allele dataset to a phenotype dataset</h2><span id='topic+convertToPhenot'></span>

<h3>Description</h3>

<p>Convert a 'genotypic' dataset (marker dosages known) to
a 'phenotypic' dataset (marker dosages not known, unique alleles
appear only once in each allele set).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertToPhenot(adata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertToPhenot_+3A_adata">adata</code></td>
<td>
<p>data frame: a genotypic allele dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the terminology used by the PolyPatEx package, a 'genotypic'
allele dataset is one where marker dosages are known, hence any
locus at which fewer than p (the ploidy) alleles are detected is
incomplete (and subsequently ignored by the genotype-specific
routines in this package). A 'phenotypic' allele dataset is one
where marker dosages are not known, hence individual alleles
appear only once in an allele set, and a complete allele set can
contain between <code class="reqn">1</code> and <code class="reqn">p</code> alleles.
</p>
<p><code>convertToPhenot</code> converts a genotypic dataset to a
phenotypic dataset, simply by removing any allele duplicates from
each allele set.  This is probably not something many will want to
do, since one loses considerable information in the process...
</p>


<h3>Value</h3>

<p>A data frame, containing the phenotypic form of the
original genotypic dataset.
</p>


<h3>Author(s)</h3>

<p>Alexander Zwart (alec.zwart at csiro.au)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the example dataset 'FR_Genotype':
data(FR_Genotype)

## Since we did not load this dataset using inputData(), we must
## first process it with preprocessData() before doing anything
## else:
gData &lt;- preprocessData(FR_Genotype,
                        numLoci=7,
                        ploidy=4,
                        dataType="genotype",
                        dioecious=TRUE,
                        mothersOnly=TRUE)

head(gData)  ## Checked and Cleaned version of FR_Genotype

pData &lt;- convertToPhenot(gData)

head(pData)
</code></pre>

<hr>
<h2 id='fixCSV'>Tidy a comma separated value (CSV) file</h2><span id='topic+fixCSV'></span>

<h3>Description</h3>

<p>Tidies up a Comma Separated Value (CSV) file, ensuring that each
row of the table in the file contains the same number of commas,
and no empty rows are left below the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixCSV(file, skip = 0, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixCSV_+3A_file">file</code></td>
<td>
<p>character: the name of the CSV file to be
&lsquo;fixed&rsquo;.</p>
</td></tr>
<tr><td><code id="fixCSV_+3A_skip">skip</code></td>
<td>
<p>integer: the number of lines in the CSV file to skip
before the header row of the table.  The skipped lines are copied
directly to the output file unchanged.  The default is
<code>skip=0</code>, implying that the header row is the first row of
the CSV file.</p>
</td></tr>
<tr><td><code id="fixCSV_+3A_overwrite">overwrite</code></td>
<td>
<p>logical: Write output to a separate,
&lsquo;FIXED&rsquo; file (<code>overwrite=FALSE</code>, the default), or
overwrite the original file (<code>overwrite=TRUE</code>)?  If
<code>overwrite=TRUE</code>, the original file is copied to a
<code>.BAK</code> file before being overwritten.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fixCSV</code> tidies up a Comma Separated Value (CSV) file
to ensure that the CSV file contains a strictly rectangular block
of data for input into R (ignoring any preliminary comment rows
via the <code>skip=</code> argument).
</p>
<p>CSV formatted files are a plain text file format for tabular data,
in which cell entries in the same row of a table are separated by
commas.  When such files are exported from other applications such
as spreadsheet software, the software has to decide whether any
empty cells to the right-hand side of, or below, the table or
spreadsheet should be represented by trailing commas in the CSV
file.  Such decisions can result in a &lsquo;ragged&rsquo; table in the
CSV file, in which some rows contain fewer commas (&lsquo;short
rows&rsquo;) or more commas (&lsquo;long rows&rsquo;) than others, or where
empty rows below the table are included as comma-only rows in the
CSV file.
</p>
<p>While R's <code><a href="utils.html#topic+read.table">read.table</a></code> and related functions can
sensibly extend short rows as needed, ragged tables in a CSV file
can still result in errors, unwanted empty rows (below the table)
or unwanted columns (to the right of the table) when the data is
loaded into R.
</p>
<p><code>fixCSV</code> reads in a specified CSV file and removes or adds
commas to rows, to ensure that each row in the body of the table
contains the same number of cells as the header row of the table.
Any empty rows below the table are also removed.  The resulting
table is then written back to file, either to a new file with
&lsquo;FIXED&rsquo; added to the filename (argument
<code>overwrite=FALSE</code>, the default) or overwriting the original
file (<code>overwrite=TRUE</code> - the original file is copied to a
<code>.BAK</code> file before being overwritten).
</p>
<p>Note that:
</p>

<ul>
<li><p> The table of data in the CSV file <em>must</em> contain a
header row of the correct length, since this row is used to
determine the correct number of columns for the table.  Note: if
this header row is too short, then subsequent rows will be
truncated to match the length of the header, so beware.
Misspecification of the <code>skip=</code> argument (see below) can
similarly lead to such corruption of the &lsquo;fixed&rsquo; file.
</p>
</li>
<li><p> In the header row, any trailing commas representing empty
cells to the right of the (non-empty) header entries are first
removed before determining the correct number of columns for the
table.  Thus the length of the header row (and hence the assumed
width of the entire table) is determined by the <em>right-most
non-empty cell</em> in the header row.
</p>
</li>
<li> <p><code>fixCSV</code> does not remove empty cells, rows or columns
within the interior (or on the left side) of the table - it is
concerned only with the right and bottom boundaries of the table.
</p>
</li>
<li><p> A <code>skip=</code> argument is included to tell <code>fixCSV</code> to
ignore the specified number of comment rows preceding the header
row.  Such rows are simply copied over into the output file
unchanged.  The default for this parameter is <code>skip=0</code>, so
that the first row in the data file is assumed to be the header
row. As noted above, misspecification of this argument can
seriously corrupt the output.
</p>
</li>
<li> <p><code>fixCSV</code> can overwrite your data file(s) (via
<code>overwrite=TRUE</code>), and althought it makes a backup of your
original file, you should still make sure that you have a separate
backup of your data file in a safe place before using this
function!  The author of this code takes no responsibility for any
data loss or corruption as a result of the use of this routine...
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alexander Zwart (alec.zwart at csiro.au)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## Assuming CSV file 'alleleDataFile.csv' exists in the current
## directory.  The following overwrites the CSV file - make sure
## you have a backup!

fixCSV("alleleDataFile.csv",overwrite=TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='foreignAlleles'>Identify foreign alleles</h2><span id='topic+foreignAlleles'></span>

<h3>Description</h3>

<p>Identify 'foreign' alleles (alleles present in progeny, but not in
parents or other non-parental adults).  Note that
<code>foreignAlleles</code> does <em>not</em> distinguish between
populations as indicated by the <code>popn</code> column of the allele
data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foreignAlleles(adata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="foreignAlleles_+3A_adata">adata</code></td>
<td>
<p>data frame: the preprocessed allele data set
returned by either <code><a href="#topic+inputData">inputData</a></code> or
<code><a href="#topic+preprocessData">preprocessData</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, containing two data frames.  Data frame
<code>byLocus</code> summarises the foreign alleles found at each locus.
Data frame <code>byProgenyLocus</code> summarises the same alleles by
progeny and locus.  In this latter data frame, the code
<code>P.missing</code> indicates no alleles were present in the progeny
at this locus.
</p>


<h3>Author(s)</h3>

<p>Alexander Zwart (alec.zwart at csiro.au)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the example dataset 'FR_Genotype':
data(FR_Genotype)

## Since we did not load this dataset using inputData(), we must
## first process it with preprocessData() before doing anything
## else:
gData &lt;- preprocessData(FR_Genotype,
                        numLoci=7,
                        ploidy=4,
                        dataType="genotype",
                        dioecious=TRUE,
                        mothersOnly=TRUE)

head(gData)  ## Checked and Cleaned version of FR_Genotype

fAlleles &lt;- foreignAlleles(gData)

## View foreign alleles detected at each locus:
fAlleles$byLocus

## View foreign alleles detected in each progeny, at each locus:
fAlleles$byProgenyLocus

## Both of these objects are data frames, hence can be written to file
## via, e.g., write.csv().
</code></pre>

<hr>
<h2 id='FR_Genotype'>Example genotype allele dataset</h2><span id='topic+FR_Genotype'></span>

<h3>Description</h3>

<p>Example genotype allele dataset - a dioecious tetraploid species,
seven loci observed.
</p>


<h3>Details</h3>

<p>The dataset is available in two forms - as a compressed data file
which can be loaded easily into R via the R <code><a href="utils.html#topic+data">data</a></code>
function, i.e., <code>data(FR_Genotype)</code>, and as a CSV
(Comma-Separated-Value, a plain text format) file, to provide an
example of the required CSV format.
</p>
<p>Note that a technicality of R's package building process requires
the use of <code>data</code> to load the data in the reference
help examples, whereas the user would generally invoke the
<code><a href="#topic+inputData">inputData</a></code> function to load their own data from file.
An example of the latter is demonstrated in the example section on
this page, but is not run.
</p>


<h3>Author(s)</h3>

<p>Alexander Zwart (alec.zwart at csiro.au)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## To locate this dataset in your filesystem, use:

gDataFile &lt;- system.file("extdata/FR_Genotype.csv",
                         package="PolyPatEx")
print(gDataFile)

## To load this file using PolyPatEx's 'inputData' function, use:

gData &lt;- inputData(gDataFile,
                  numLoci=7,
                  ploidy=4,
                  dataType="genotype",
                  dioecious=TRUE,
                  mothersOnly=TRUE)

## ...or use 'mothersOnly=FALSE' if you wish to retain
## non-maternal females in the dataset.

## gData now contains the checked and preprocessed allele dataset,
## ready to be passed to other PolyPatEx analysis functions.

## End(Not run)
</code></pre>

<hr>
<h2 id='genotPPE'>Simple paternity exclusion for genotype allele data</h2><span id='topic+genotPPE'></span>

<h3>Description</h3>

<p>Conduct a paternity exclusion analysis on a genotype dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genotPPE(adata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genotPPE_+3A_adata">adata</code></td>
<td>
<p>data frame: the preprocessed allele data set returned
by either <code><a href="#topic+inputData">inputData</a></code> or <code><a href="#topic+preprocessData">preprocessData</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>genotPPE</code> conducts a basic paternity exclusion analysis on
a genotype dataset.
</p>
<p>For the purposes of the PolyPatEx package, the term
&lsquo;genotype&rsquo; refers to forms of marker data where the allele
copy numbers (or multiplicities) are known - hence for a polyploid
species of ploidy <em>p</em>, there should be exactly <em>p</em>
alleles detected at each locus, some of which may be repeats of
the same allele state.  In PolyPatEx, no allowance is made for
undetected alleles in genotype data - allele sets having fewer
than <em>p</em> alleles present should have been reset to contain no
alleles by <code><a href="#topic+preprocessData">preprocessData</a></code>.
</p>
<p>For the above and other reasons, <code>genotPPE</code> should <b>NOT</b>
be applied to a dataset that has not been preprocessed by
<code><a href="#topic+preprocessData">preprocessData</a></code> (either by calling directly
<code><a href="#topic+preprocessData">preprocessData</a></code> on the data frame directly, or by
using <code><a href="#topic+inputData">inputData</a></code> to load the data from file).
</p>
<p>The genotype-based paternity analysis is based on simple
comparison of genotype allele sets between mother, progeny, and
candidate father.  The mother-progeny relationship is assumed to
be known.  For genotype data, should a progeny contain only
alleles also present in its mother, then a potential father is any
candidate that can provide a gamete compatible with the progeny's
genotype, given the mother's genotype.
</p>


<h3>Value</h3>

<p>A list whose components are described below.  The
components that are probably of primary interest to the user are
<code>adultTables$FLCount</code> and <code>adultTables$VLTotal</code>.  These
are likely to be large tables, so note that the functions
<code><a href="#topic+potentialFatherCounts">potentialFatherCounts</a></code> and
<code><a href="#topic+potentialFatherIDs">potentialFatherIDs</a></code> are available to usefully
summarise their content.
</p>
<p>The list returned by <code>genotPPE</code> contains two elements,
<code>progenyTables</code> and <code>adultTables</code>, each of which are
themselves lists.
</p>
<p>Element <code>adultTables</code> contains the following components:
</p>

<dl>
<dt><code>FLCount</code></dt><dd><p>Father Loci Count - a matrix, showing for
each progeny-candidate combination, the number of loci at which
the candidate matches (i.e., could have fathered) the progeny</p>
</dd>
<dt><code>VLTotal</code></dt><dd><p>Valid Loci Total - a matrix, showing for
each progeny-candidate combination, the total number of loci at
which a valid comparison between progeny and candidate could be
made.  (Missing allele sets, whether in the original data, or due
to progeny-mother mismatches found by
<code><a href="#topic+preprocessData">preprocessData</a></code>, can result in fewer loci at which
progeny-candidate (father) comparisons are possible.)</p>
</dd>
<dt><code>fatherSummaryTable</code></dt><dd><p>A matrix, combining the results
of <code>FLCount</code> and <code>VLTotal</code> (see above) for each
progeny-candidate combination in one table.  This is purely for
ease of viewing purposes, but note also the functions
<code><a href="#topic+potentialFatherCounts">potentialFatherCounts</a></code> and
<code><a href="#topic+potentialFatherIDs">potentialFatherIDs</a></code> which may provide more useful
summary output.</p>
</dd>
<dt><code>CPNotM.alleleArray</code></dt><dd><p>A 3D array containing the
alleles present in both candidate (father) and progeny, but not in
the progeny's mother (for each progeny/candidate/locus
combination)</p>
</dd>
<dt><code>CMP.alleleArray</code></dt><dd><p>A 3D array containing the alleles
present in candidate, progeny and progeny's mother (for each
progeny/candidate/locus combination)</p>
</dd>
<dt><code>simpleFatherArray</code></dt><dd><p>A 3D array indicating whether each
candidate is compatible with each progeny, for each locus</p>
</dd>
</dl>

<p><code>progenyTables</code> contains the following components:
</p>

<dl>
<dt><code>progenyStatusTable</code></dt><dd><p>A data frame, indicating the
status of the progeny / mother allele set comparison (for each
progeny, at each locus).</p>
</dd>
<dt><code>MP.alleleTable</code></dt><dd><p>A data frame containing the alleles
that are found in both mother's and progeny's allele sets (for
each progeny, at each locus)</p>
</dd>
<dt><code>PNotM.alleleTable</code></dt><dd><p>A data frame, containing the
alleles in the progeny's allele set, that are <em>not</em> present
in the mother's allele set(for each progeny, at each locus)</p>
</dd>
</dl>

<p>The status codes in <code>progenyTables$progenyStatusTable</code> are:
</p>

<dl>
<dt><code>"MAO"</code></dt><dd><p>Mother Alleles Only - the progeny contains
only alleles found also in the mother</p>
</dd>
<dt><code>"NMA"</code></dt><dd><p>Non-Mother Alleles - the progeny contains
alleles that are not found in the mother</p>
</dd>
<dt><code>"P.missing"</code></dt><dd><p>No comparison was possible at this locus
because the progeny's allele set was missing</p>
</dd>
<dt><code>"P.missing"</code></dt><dd><p>No comparison was possible at this locus
because the mother's allele set was missing</p>
</dd>
<dt><code>"PM.missing"</code></dt><dd><p>No comparison was possible at this
locus because both progeny's and mother's allele sets were
missing</p>
</dd>
</dl>

<p>Note that some of the <code>"P.missing"</code> or <code>"PM.missing"</code>
codes may have arisen due to progeny / mother mismatches found
(and corresponding progeny allele sets removed) by
<code><a href="#topic+preprocessData">preprocessData</a></code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Zwart (alec.zwart at csiro.au)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phenotPPE">phenotPPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the example dataset 'FR_Genotype':
data(FR_Genotype)

## Since we did not load this dataset using inputData(), we must
## first process it with preprocessData() before doing anything
## else:
gData &lt;- preprocessData(FR_Genotype,
                        numLoci=7,
                        ploidy=4,
                        dataType="genotype",
                        dioecious=TRUE,
                        mothersOnly=TRUE)

head(gData)  ## Checked and Cleaned version of FR_Genotype

gPPE &lt;- genotPPE(gData)  ## Perform the exclusion analyses

## gPPE is a large (and rather ugly!) data structure - see
## functions potentialFatherCounts() and potentialFatherIDs() for
## more useful output from the gPPE object.
</code></pre>

<hr>
<h2 id='GF_Phenotype'>Example phenotype allele dataset</h2><span id='topic+GF_Phenotype'></span>

<h3>Description</h3>

<p>Example &lsquo;phenotype&rsquo; allele dataset - a monoecious non-selfing
hexaploid species, seven loci observed.
</p>


<h3>Details</h3>

<p>The dataset is available in two forms - as a compressed data file
which can be loaded easily into R via the R <code><a href="utils.html#topic+data">data</a></code>
function, i.e., <code>data(FR_Genotype)</code>, and as a CSV
(Comma-Separated-Value, a plain text format) file, to provide an
example of the required CSV format.
</p>
<p>Note that a technicality of R's package building process requires
the use of <code>data</code> to load the data in the reference help
examples, whereas the user would generally invoke the
<code><a href="#topic+inputData">inputData</a></code> function to load their own data from file.
An example of the latter is demonstrated in the example section on
this page, but is not run.
</p>


<h3>Author(s)</h3>

<p>Alexander Zwart (alec.zwart at csiro.au)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## To locate this dataset in your filesystem, use:

pDataFile &lt;- system.file("extdata/GF_Phenotype.csv",
                         package="PolyPatEx")
print(pDataFile)

## To load this file using PolyPatEx's 'inputData' function use:

pData &lt;- inputData(pDataFile,
                  numLoci=7,
                  ploidy=6,
                  dataType="phenotype",
                  dioecious=FALSE,
                  selfCompatible=FALSE)

## pData now contains the checked and preprocessed allele dataset,
## ready to be passed to other PolyPatEx analysis functions.


## End(Not run)
</code></pre>

<hr>
<h2 id='inputData'>Read in, check and preprocess the allele dataset</h2><span id='topic+inputData'></span>

<h3>Description</h3>

<p>Read in an allele dataset from file, and return a checked and
preprocessed data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inputData(file, numLoci, ploidy, dataType, dioecious, selfCompatible = NULL,
  mothersOnly = NULL, lociMin = 1, matMismatches = 0, skip = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inputData_+3A_file">file</code></td>
<td>
<p>character: the name of the allele data file.</p>
</td></tr>
<tr><td><code id="inputData_+3A_numloci">numLoci</code></td>
<td>
<p>integer: the number of loci in the allele dataset.</p>
</td></tr>
<tr><td><code id="inputData_+3A_ploidy">ploidy</code></td>
<td>
<p>integer: the species' ploidy, one of <code>2</code>,
<code>4</code>, <code>6</code>, or <code>8</code>.</p>
</td></tr>
<tr><td><code id="inputData_+3A_datatype">dataType</code></td>
<td>
<p>character: either <code>"genotype"</code> or
<code>"phenotype"</code>.</p>
</td></tr>
<tr><td><code id="inputData_+3A_dioecious">dioecious</code></td>
<td>
<p>logical: is the species dioecious (<code>TRUE</code>)
or monoecious (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="inputData_+3A_selfcompatible">selfCompatible</code></td>
<td>
<p>logical: In monoecious species
(<code>dioecious=FALSE</code>), can individuals self-fertilise?  When
<code>dioecious=FALSE</code>, this argument may be left at its
default value of NULL - it will be set to <code>FALSE</code> by
<code>preprocessData</code>.</p>
</td></tr>
<tr><td><code id="inputData_+3A_mothersonly">mothersOnly</code></td>
<td>
<p>logical: in dioecious species, should females
without progeny present be removed from the dataset?  If
<code>dioecious=TRUE</code>, then <code>mothersOnly</code> must be set to
either <code>TRUE</code> or <code>FALSE</code>.  If <code>dioecious=FALSE</code>,
argument <code>mothersOnly</code> should be left at its default value of
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="inputData_+3A_locimin">lociMin</code></td>
<td>
<p>integer: the minimum number of loci in an
individual that must have alleles present for the individual (and
its progeny, if the individual is a mother) to be retained in the
dataset.  See the help for <code><a href="#topic+preprocessData">preprocessData</a></code> for more
on this parameter.</p>
</td></tr>
<tr><td><code id="inputData_+3A_matmismatches">matMismatches</code></td>
<td>
<p>an integer between 0 and <code>numLoci</code>-1,
being the maximum number of mismatching loci between mother and
offspring that are allowed before the offspring is removed from
the dataset.  The default value is 0.  If an offspring has fewer
than <code>matMismatches</code> loci that mismatch with its mother, the
offending loci are set to contain no alleles.</p>
</td></tr>
<tr><td><code id="inputData_+3A_skip">skip</code></td>
<td>
<p>integer: the number of lines in the CSV to skip
before the header row of the table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>inputData</code> reads in an allele dataset from the specified
file, then calls <code><a href="#topic+preprocessData">preprocessData</a></code> to perform a series
of data format checks and preprocessing steps before returning the
checked and preprocessed dataset as an R data frame.  The
reference information for <code><a href="#topic+preprocessData">preprocessData</a></code> contains
further information on the checks and preprocessing - it is
strongly recommended you read that information in addition to the
information below.
</p>
<p>The use of <code>inputData</code> is optional, if you wish to create or
load the allele dataset into R by other means. However, it is then
necessary to call <code><a href="#topic+preprocessData">preprocessData</a></code> on the data frame
prior to using any other analysis functions in this package.
Similarly, if you decide to change or manipulate the data frame
contents within R, you should call <code><a href="#topic+preprocessData">preprocessData</a></code>
again on the data frame prior to using any of the <span class="pkg">PolyPatEx</span>
analysis functions.  See the help for <code><a href="#topic+preprocessData">preprocessData</a></code>
for further details.
</p>
<p>Note that <code>inputData</code> strips leading or trailing spaces
(whitespace) from each entry in the allele dataset as it is read
in.  If you load your data by a means other than <code>inputData</code>,
you should ensure that you perform this step yourself, as
<code><a href="#topic+preprocessData">preprocessData</a></code> will not carry out this necessary
step.
</p>
<p>Note also that you should not use spaces in any of your allele
codes - PolyPatEx functions use spaces to separate allele codes as
they process the data - if allele codes already contains spaces,
errors will occur in this processing. If you need a separator, I
recommend using either &lsquo;code.&rsquo; (a period) or
&lsquo;code_&rsquo; (an underscore) rather than a space.
</p>
<p>Neither <code>inputData</code> (nor <code><a href="#topic+preprocessData">preprocessData</a></code>) will
alter the CSV file from which the data is loaded - they merely
return a checked and preprocessed version of your allele dataset
(in the form of an R data frame) within the R environment, ready
for use by other <span class="pkg">PolyPatEx</span> functions.
</p>
<p>To load the allele dataset into R, <code>inputData</code> calls R's
<code><a href="utils.html#topic+read.csv">read.csv</a></code> function with certain arguments specified.
These arguments make <code><a href="utils.html#topic+read.csv">read.csv</a></code> more stringent about
the precise format of the input datafile, requiring in particular
that each row of the CSV-formatted data file contain the correct
number of commas.  This is not always guaranteed when the CSV file
has been exported from spreadsheet software.  Should you get
&lsquo;Error in scan&rsquo; messages complaining about the number of
elements in a line of the input file, consider calling
<code><a href="#topic+fixCSV">fixCSV</a></code> on the data file, before calling
<code>inputData</code> again.  <code><a href="#topic+fixCSV">fixCSV</a></code> attempts to find and
correct such errors in a CSV file - see the help for this
function.  Note that if you specify the <code>skip</code> parameter in
a call to <code><a href="#topic+fixCSV">fixCSV</a></code>, you should use the same value for
this parameter in <code>inputData</code> to avoid an error.
</p>
<p>The various <span class="pkg">PolyPatEx</span> functions need to know the characteristics
of the dataset being analysed - these are specified in the
<code>inputData</code> or <code><a href="#topic+preprocessData">preprocessData</a></code> calls and are
invisibly attached to the allele data frame that is returned, for
use by other <span class="pkg">PolyPatEx</span> functions. The required characteristics
are:
</p>

<ul>
<li> <p><code>numLoci</code>: the number of loci in the dataset.
</p>
</li>
<li> <p><code>ploidy</code>: the ploidy <code class="reqn">p</code> of the species (currently
allowed to be 4, 6, or 8.  <code>ploidy</code> can also be 2, provided
<code>dataType="genotype"</code>).
</p>
</li>
<li> <p><code>dataType</code>: whether the data is genotypic (all <code class="reqn">p</code>
alleles at each locus are observed) or phenotypic (only the
distinct allele states at a locus are observed - alleles that
appear more than once in the genotype of a locus only appear once
in the phenotype).
</p>
</li>
<li> <p><code>dioecious</code>: whether the species is dioecious or
monoecious.
</p>
</li>
<li> <p><code>selfCompatible</code> whether a monoecious species is self
compatible (i.e., whether an individual can fertilise itself).
</p>
</li>
<li> <p><code>mothersOnly</code>: whether a dioecious dataset should
retain only adult females that are mothers of progeny in the
dataset.  If <code>dioecious=TRUE</code>, then <code>mothersOnly</code> must
be set to either <code>TRUE</code> or <code>FALSE</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame, containing the checked and pre-processed
allele data, ready for further analysis by other <span class="pkg">PolyPatEx</span>
functions.  All columns in the output data frame will be of mode
<code>character</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Zwart (alec.zwart at csiro.au)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## Obtain path to the example genotype data file
## 'FR_Genotype.csv'
gDataFile &lt;- system.file("extdata/FR_Genotype.csv",
                         package="PolyPatEx")
print(gDataFile)

gData &lt;- inputData(gDataFile,
                   numLoci=7,
                   ploidy=4,
                   dataType="genotype",
                   dioecious=TRUE,
                   mothersOnly=TRUE)

## ...or use 'mothersOnly=FALSE' if you wish to retain
## non-maternal females in the dataset.

## gData now contains the checked and preprocessed allele dataset,
## ready to be passed to other PolyPatEx analysis functions.

## In your own workflow, you would typically specify the path to
## your allele dataset directly - e.g. if the dataset
## myAlleleData.csv is on the Data subdirectory of the current R
## working directory (see R function setwd()), then:
##
## gData &lt;- inputData("Data/myAlleleData.csv",
##                    numLoci= etc etc etc...,


## End(Not run)
</code></pre>

<hr>
<h2 id='multilocusTypes'>Genotype summaries</h2><span id='topic+multilocusTypes'></span>

<h3>Description</h3>

<p>Return summaries of individual- and multi- locus genotypes for
adults and progeny.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multilocusTypes(adata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multilocusTypes_+3A_adata">adata</code></td>
<td>
<p>data frame: the checked and preprocessed dataset
returned by <code><a href="#topic+inputData">inputData</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>multilocusTypes</code> summarises the different genotypes
present at each locus in the dataset (separately for progeny and
adults), and across the loci (again, separately for progeny and
adults). <code>multilocusTypes</code> returns a list structure with
several elements.
</p>


<h3>Value</h3>

<p>A list structure, with the following components:
</p>

<dl>
<dt><code>uniqueProgenyTypes</code></dt><dd><p>A data frame containing, for each
locus, the distinct genotypes that are present in the progeny in
the dataset, and the numbers of progeny containing each genotype
at that locus.</p>
</dd>
<dt><code>numUniqueProgenyTypes</code></dt><dd><p>The number of unique genotypes
at each locus in the progeny in the dataset.</p>
</dd>
<dt><code>uniqueAdultTypes</code></dt><dd><p>A data frame containing, for each
locus, the distinct genotypes that are present in the adults in
the dataset, and the numbers of adults containing each genotype at
that locus.</p>
</dd>
<dt><code>numUniqueAdultTypes</code></dt><dd><p>The number of unique genotypes
at each locus in the adult set.</p>
</dd>
<dt><code>uniqueProgenyMLTypes</code></dt><dd><p>A data frame containing the
distinct genotypes <em>across all loci</em> that are present in the
progeny in the dataset, and the numbers of progeny containing each
multilocus genotype.</p>
</dd>
<dt><code>numUniqueProgenyMLTypes</code></dt><dd><p>The total number of progeny
multilocus genotypes.</p>
</dd>
<dt><code>uniqueAdultMLTypes</code></dt><dd><p>A data frame containing, the
distinct genotypes <em>across all loci</em> that are present in the
adults in the dataset, and the numbers of adults containing each
multilocus genotype.</p>
</dd>
<dt><code>numUniqueAdultMLTypes</code></dt><dd><p>The total number of adult
multilocus genotypes.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexander Zwart (alec.zwart at csiro.au)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the example dataset 'FR_Genotype':
data(FR_Genotype)

## Since we did not load this dataset using inputData(), we must
## first process it with preprocessData() before doing anything
## else:
gData &lt;- preprocessData(FR_Genotype,
                        numLoci=7,
                        ploidy=4,
                        dataType="genotype",
                        dioecious=TRUE,
                        mothersOnly=TRUE)

head(gData)  ## Checked and Cleaned version of FR_Genotype

mTypes &lt;- multilocusTypes(gData)

## mTypes is a list structure - individual components can be
## printed to the screen, or saved to file via, e.g. read.csv().

mTypes$numUniqueProgenyTypes

## Components of mTypes
names(mTypes)
</code></pre>

<hr>
<h2 id='phenotPPE'>Simple paternity exclusion for phenotype allele data</h2><span id='topic+phenotPPE'></span>

<h3>Description</h3>

<p>Conduct a paternity exclusion analysis on a phenotype dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenotPPE(adata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phenotPPE_+3A_adata">adata</code></td>
<td>
<p>data frame: the preprocessed allele data set
returned by either <code><a href="#topic+inputData">inputData</a></code> or
<code><a href="#topic+preprocessData">preprocessData</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>phenotPPE</code> conducts a basic paternity exclusion analysis on
a &lsquo;phenotype&rsquo; dataset.
</p>
<p>For the purposes of the PolyPatEx package, the term
&lsquo;phenotype&rsquo; refers to forms of marker data where the allele
dosages (or multiplicities) are not known - hence for a polyploid
species of ploidy <em>p</em>, a valid allele set may contain between
one and <em>p</em> alleles, which should all be distinct.  Any cases
of allele sets having duplicated alleles will have previously been
caught by <code><a href="#topic+preprocessData">preprocessData</a></code> (automatically called by
<code><a href="#topic+inputData">inputData</a></code>) and will have produced an error message,
requiring the user to remove any duplicated alleles (within allele
sets) in the original data file.
</p>
<p>For the above and other reasons, <code>phenotPPE</code> should
<b>NOT</b> be applied to a dataset that has not been preprocessed
by <code><a href="#topic+preprocessData">preprocessData</a></code> (either by calling
<code><a href="#topic+preprocessData">preprocessData</a></code> on the allele data frame directly, or
by loading the allele data into R using <code><a href="#topic+inputData">inputData</a></code>).
</p>


<h3>Value</h3>

<p>A list whose components are described below.  The
components that are probably of primary interest to the user are
<code>adultTables$FLCount</code> and <code>adultTables$VLTotal</code>.  These
are likely to be large tables, so note that the functions
<code><a href="#topic+potentialFatherCounts">potentialFatherCounts</a></code> and
<code><a href="#topic+potentialFatherIDs">potentialFatherIDs</a></code> are available to usefully
summarise their content.
</p>
<p>The list returned by <code>phenotPPE</code> contains two elements,
<code>progenyTables</code> and <code>adultTables</code>, each of which are
themselves lists.
</p>
<p><code>adultTables</code> contains the following components:
</p>

<dl>
<dt><code>FLCount</code></dt><dd><p>Father Loci Count - a matrix, showing for
each progeny-candidate combination, the number of loci at which
the candidate matches (i.e., could have fathered) the progeny</p>
</dd>
<dt><code>VLTotal</code></dt><dd><p>Valid Loci Total - a matrix, showing for
each progeny-candidate combination, the total number of loci at
which a valid comparison between progeny and candidate could be
made.  (Missing allele sets, whether in the original data, or due
to progeny-mother mismatches found by <code><a href="#topic+preprocessData">preprocessData</a></code>
can result in fewer loci at which progeny-candidate (father)
comparisons are possible.)</p>
</dd>
<dt><code>fatherSummaryTable</code></dt><dd><p>A matrix, combining the results
of <code>FLCount</code> and <code>VLTotal</code> (see above) for each
progeny-candidate combination in one table.  This is purely for
ease of viewing purposes, but note also the functions
<code><a href="#topic+potentialFatherCounts">potentialFatherCounts</a></code> and
<code><a href="#topic+potentialFatherIDs">potentialFatherIDs</a></code> which may provide more useful
summary output.</p>
</dd>
<dt><code>CPNotM.alleleArray</code></dt><dd><p>A 3D array containing the
alleles present in both candidate (father) and progeny, but not in
the progeny's mother (for each progeny/candidate/locus
combination)</p>
</dd>
<dt><code>CMP.alleleArray</code></dt><dd><p>A 3D array containing the alleles
present in candidate, progeny and progeny's mother (for each
progeny/candidate/locus combination)</p>
</dd>
<dt><code>simpleFatherArray</code></dt><dd><p>A 3D array indicating whether each
candidate is compatible with each progeny, for each locus</p>
</dd>
</dl>

<p><code>progenyTables</code> contains the following components:
</p>

<dl>
<dt><code>progenyStatusTable</code></dt><dd><p>A data frame, indicating the
status of the progeny / mother allele set comparison (for each
progeny, at each locus).</p>
</dd>
<dt><code>MP.alleleTable</code></dt><dd><p>A data frame containing the alleles
that are found in both mother's and progeny's allele sets (for
each progeny, at each locus)</p>
</dd>
<dt><code>PNotM.alleleTable</code></dt><dd><p>A data frame, containing the
alleles in the progeny's allele set, that are <em>not</em> present
in the mother's allele set(for each progeny, at each locus)</p>
</dd>
</dl>

<p>The status codes in <code>progenyTables$progenyStatusTable</code> are:
</p>

<dl>
<dt><code>"MAO"</code></dt><dd><p>Mother Alleles Only - the progeny contains
only alleles found also in the mother</p>
</dd>
<dt><code>"NMA"</code></dt><dd><p>Non-Mother Alleles - the progeny contains
alleles that are not found in the mother</p>
</dd>
<dt><code>"P.missing"</code></dt><dd><p>No comparison was possible at this locus
because the progeny's allele set was missing</p>
</dd>
<dt><code>"P.missing"</code></dt><dd><p>No comparison was possible at this locus
because the mother's allele set was missing</p>
</dd>
<dt><code>"PM.missing"</code></dt><dd><p>No comparison was possible at this
locus because both progeny's and mother's allele sets were
missing</p>
</dd>
</dl>

<p>Note that some of the <code>"P.missing"</code> or <code>"PM.missing"</code>
codes may have arisen due to progeny / mother mismatches found
(and corresponding progeny allele sets removed) by
<code><a href="#topic+preprocessData">preprocessData</a></code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Zwart (alec.zwart at csiro.au)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genotPPE">genotPPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the example dataset 'GF_Phenotype':
data(GF_Phenotype)

## Since we did not load this dataset using inputData(), we must
## first process it with preprocessData() before doing anything
## else:
pData &lt;- preprocessData(GF_Phenotype,
                        numLoci=7,
                        ploidy=6,
                        dataType="phenotype",
                        dioecious=FALSE,
                        selfCompatible=FALSE)

pPPE &lt;- phenotPPE(pData)

## pPPE is a large (and rather ugly!) data structure - see
## functions potentialFatherCounts() and potentialFatherIDs() for
## more useful output from the gPPE object.
</code></pre>

<hr>
<h2 id='potentialFatherCounts'>Count potential fathers</h2><span id='topic+potentialFatherCounts'></span>

<h3>Description</h3>

<p>Count the number of potential fathers detected for each progeny.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>potentialFatherCounts(dataset, mismatches = 0, VLTMin = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="potentialFatherCounts_+3A_dataset">dataset</code></td>
<td>
<p>list: a list structure previously output from
<code><a href="#topic+genotPPE">genotPPE</a></code> or <code><a href="#topic+phenotPPE">phenotPPE</a></code>.</p>
</td></tr>
<tr><td><code id="potentialFatherCounts_+3A_mismatches">mismatches</code></td>
<td>
<p>integer: the maximum allowed number of
mismatching loci between candidate and progeny, before the
candidate is rejected as a potential father.</p>
</td></tr>
<tr><td><code id="potentialFatherCounts_+3A_vltmin">VLTMin</code></td>
<td>
<p>integer: the  minimum number of &lsquo;valid&rsquo; loci
(loci at which a valid progeny-candidate comparison was possible)
required for a candidate to be considered as a potential father.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the output from <code><a href="#topic+genotPPE">genotPPE</a></code> or
<code><a href="#topic+phenotPPE">phenotPPE</a></code>,  <code>potentialFatherCounts</code> returns,
for each progeny, the number of candidates that are identified as
potential fathers.
</p>
<p>To decide whether a given candidate is a potential father to a
given progeny, <code>potentialFatherCounts</code> uses the quantities
FLCount (the number of loci at which a candidate can provide a
gamete compatible with the progeny) and VLTotal (the number of
loci at which a valid comparison was possible - &lsquo;valid&rsquo;
loci) that are returned by <code><a href="#topic+genotPPE">genotPPE</a></code> or
<code><a href="#topic+phenotPPE">phenotPPE</a></code>.
</p>
<p>For a candidate to be identified as a potential father of a
progeny, there are two criteria to be met:
</p>

<ol>
<li> <p><code>VLTotal &gt;= max(VLTMin,mismatches+1)</code>,
</p>
</li>
<li> <p><code>FLCount &gt;= VLTotal-mismatches</code>.
</p>
</li></ol>

<p>Here, <code>VLTmin</code> and <code>mismatches</code> are user-specified
parameters. <code>VLTmin</code> allows the user to ensure that a
candidate is only considered for potential fatherhood if a
sufficient number of valid loci were available for comparison.
<code>mismatches</code> allows the user to specify a maximum number of
allowed mismatching loci between progeny and candidate, before
the candidate is rejected as a potential father.  Hence the user
may wish to relax the condition that ALL valid loci must match for
a candidate to be regarded as a potential father to a progeny.
</p>


<h3>Value</h3>

<p>A data frame, containing columns <code>Progeny</code> (progeny
id), <code>Mother</code> (id of the progeny's mother) and
<code>potentialFatherCount</code> (the number of potential fathers found
for the given progeny, given the criteria described above).
</p>


<h3>Author(s)</h3>

<p>Alexander Zwart (alec.zwart at csiro.au)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the example dataset 'FR_Genotype':
data(FR_Genotype)

## Since we did not load this dataset using inputData(), we must
## first process it with preprocessData() before doing anything
## else:
gData &lt;- preprocessData(FR_Genotype,
                        numLoci=7,
                        ploidy=4,
                        dataType="genotype",
                        dioecious=TRUE,
                        mothersOnly=TRUE)

head(gData)  ## Checked and Cleaned version of FR_Genotype

gPPE &lt;- genotPPE(gData)  ## Perform the exclusion analyses

## Obtain counts of potential fathers of each seedling, allowing a
## single allele mismatch:
pFC &lt;- potentialFatherCounts(gPPE,mismatches=1,VLTMin=2)

## pFC can be viewed or written to file via, e.g. write.csv()
</code></pre>

<hr>
<h2 id='potentialFatherIDs'>Identify potential fathers</h2><span id='topic+potentialFatherIDs'></span>

<h3>Description</h3>

<p>Identify the potential fathers for each progeny.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>potentialFatherIDs(dataset, mismatches = 0, VLTMin = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="potentialFatherIDs_+3A_dataset">dataset</code></td>
<td>
<p>list: a list structure previously output from
<code><a href="#topic+genotPPE">genotPPE</a></code> or <code><a href="#topic+phenotPPE">phenotPPE</a></code>.</p>
</td></tr>
<tr><td><code id="potentialFatherIDs_+3A_mismatches">mismatches</code></td>
<td>
<p>integer: the maximum allowed number of
mismatching loci between candidate and progeny, before the
candidate is rejected as a potential father.  Default value is 0 -
i.e., no mismatches allowed.</p>
</td></tr>
<tr><td><code id="potentialFatherIDs_+3A_vltmin">VLTMin</code></td>
<td>
<p>integer: the minimum number of &lsquo;valid&rsquo; loci
(loci at which a valid progeny-candidate comparison was possible)
required for a candidate to be considered as a potential father.
Default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the output from <code><a href="#topic+genotPPE">genotPPE</a></code> or
<code><a href="#topic+phenotPPE">phenotPPE</a></code>, <code>potentialFatherIDs</code> returns, for
each progeny, the IDs of candidates that are identified as
potential fathers.
</p>
<p>To decide whether a given candidate is a potential father to a
given progeny, <code>potentialFatherIDs</code> uses the quantities
FLCount (the number of loci at which a candidate can provide a
gamete compatible with the progeny) and VLTotal (the number of
loci at which a valid comparison was possible - &lsquo;valid&rsquo;
loci) that are returned by <code><a href="#topic+genotPPE">genotPPE</a></code> or
<code><a href="#topic+phenotPPE">phenotPPE</a></code>.
</p>
<p>For a candidate to be identified as a potential father of a
progeny, there are two criteria to be met:
</p>

<ol>
<li> <p><code>VLTotal &gt;= max(VLTMin,mismatches+1)</code>,
</p>
</li>
<li> <p><code>FLCount &gt;= VLTotal-mismatches</code>.
</p>
</li></ol>

<p>Here, <code>VLTmin</code> and <code>mismatches</code> are user-specified
parameters. <code>VLTmin</code> allows the user to ensure that a
candidate is only considered for potential fatherhood if a
sufficient number of valid loci were available for comparison.
<code>mismatches</code> allows the user to specify a maximum number of
allowed mismatching loci between progeny and candidate, before
the candidate is rejected as a potential father.  Hence the user
may wish to relax the condition that ALL valid loci must match for
a candidate to be regarded as a potential father to a progeny.
</p>


<h3>Value</h3>

<p>A data frame, containing the columns <code>Progeny</code> (ID)
<code>Mother</code> (ID), <code>potentialFather</code> (ID or <code>None</code>)
<code>FLCount</code> and <code>VLTotal</code> (the <code>FLCount</code> and
<code>VLTotal</code> values for the given potential father).
</p>


<h3>Author(s)</h3>

<p>Alexander Zwart (alec.zwart at csiro.au)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the example dataset 'FR_Genotype':
data(FR_Genotype)

## Since we did not load this dataset using inputData(), we must
## first process it with preprocessData() before doing anything
## else:
gData &lt;- preprocessData(FR_Genotype,
                        numLoci=7,
                        ploidy=4,
                        dataType="genotype",
                        dioecious=TRUE,
                        mothersOnly=TRUE)

head(gData)  ## Checked and Cleaned version of FR_Genotype

gPPE &lt;- genotPPE(gData)  ## Perform the exclusion analyses

## Obtain IDs of potential fathers of each seedling, allowing a
## single allele mismatch:
pFI &lt;- potentialFatherIDs(gPPE,mismatches=1,VLTMin=2)

## pFC can be viewed or writted to file via, e.g. write.csv()
</code></pre>

<hr>
<h2 id='preprocessData'>Check and preprocess an allele dataset</h2><span id='topic+preprocessData'></span>

<h3>Description</h3>

<p>Check and preprocess the input allele data frame prior to
subsequent analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocessData(adata, numLoci, ploidy, dataType, dioecious,
  selfCompatible = NULL, mothersOnly = NULL, lociMin = 1,
  matMismatches = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preprocessData_+3A_adata">adata</code></td>
<td>
<p>data frame: an allele dataset.</p>
</td></tr>
<tr><td><code id="preprocessData_+3A_numloci">numLoci</code></td>
<td>
<p>integer: the number of loci in the allele dataset.</p>
</td></tr>
<tr><td><code id="preprocessData_+3A_ploidy">ploidy</code></td>
<td>
<p>integer: the species' ploidy, one of <code>2</code>,
<code>4</code>, <code>6</code>, or <code>8</code>.</p>
</td></tr>
<tr><td><code id="preprocessData_+3A_datatype">dataType</code></td>
<td>
<p>character: either <code>"genotype"</code> or
<code>"phenotype"</code>.</p>
</td></tr>
<tr><td><code id="preprocessData_+3A_dioecious">dioecious</code></td>
<td>
<p>logical: is the species dioecious or monoecious?</p>
</td></tr>
<tr><td><code id="preprocessData_+3A_selfcompatible">selfCompatible</code></td>
<td>
<p>logical: In monoecious species
(<code>dioecious=FALSE</code>), can individuals self-fertilise?  When
<code>dioecious=FALSE</code>, this argument may be left at its
default value of NULL - it will be set to <code>FALSE</code> by
<code>preprocessData</code>.</p>
</td></tr>
<tr><td><code id="preprocessData_+3A_mothersonly">mothersOnly</code></td>
<td>
<p>logical: in dioecious species, should females
without progeny present be removed from the dataset?  If
<code>dioecious=TRUE</code>, then <code>mothersOnly</code> must be set to
either <code>TRUE</code> or <code>FALSE</code>.  If <code>dioecious=FALSE</code>,
argument <code>mothersOnly</code> should be left at its default value of
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="preprocessData_+3A_locimin">lociMin</code></td>
<td>
<p>integer: the minimum number of loci in a individual
that must have alleles present for the individual (and its
progeny, if any) to be retained in the dataset (default 1).</p>
</td></tr>
<tr><td><code id="preprocessData_+3A_matmismatches">matMismatches</code></td>
<td>
<p>an integer between 0 and <code>numLoci</code>-1,
being the maximum number of mismatching alleles between mother and
offspring that are allowed before the offspring is removed from the
dataset.  The default value is 0.  If an offspring has fewer
than <code>matMismatches</code> loci that mismatch with its mother, the
offending loci are set to contain no alleles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code><a href="#topic+inputData">inputData</a></code> is used to load the allele data set
into R, then <code>preprocessData</code> will be called automatically on
the data frame before it is returned by <code><a href="#topic+inputData">inputData</a></code>.
However, if the user loads their data into R by some means other
than <code><a href="#topic+inputData">inputData</a></code>, then <code>preprocessData</code> MUST be
called on the data frame prior to using any other PolyPatEx
functions to analyse the allele data&mdash;<code>preprocessData</code>
performs a series of critical checks and preprocessing steps on
the data frame, without which other analysis functions in
PolyPatEx will fail.
</p>
<p>Note that <code><a href="#topic+inputData">inputData</a></code> strips leading or trailing
spaces (whitespace) from each entry in the allele dataset as it is
read in.  If you load your data by a means other than
<code><a href="#topic+inputData">inputData</a></code>, you should ensure that you perform this
step yourself, as <code>preprocessData</code> will not carry out this
necessary step.
</p>
<p>Note also that you should not use spaces in any of your allele
codes - PolyPatEx functions use spaces to separate allele codes as
they process the data - if allele codes already contains spaces,
errors will occur in this processing. If you need a separator, I
recommend using either &lsquo;code.&rsquo; (a period) or
&lsquo;code_&rsquo; (an underscore) rather than a space.
</p>
<p><code>preprocessData</code> first performs a number of simple checks on
the format and validity of the data set.  These checks look for
the presence of certain required columns and correct naming and
content of these columns.  <code>preprocessData</code> will usually stop
with an error message should the data fail these basic checks.
Correct the indicated problem in the CSV file or R allele data
frame, then call <code><a href="#topic+inputData">inputData</a></code> or <code>preprocessData</code>
again as appropriate.  If you use a spreadsheet to edit the CSV
file, don't forget that you may also need to call
<code><a href="#topic+fixCSV">fixCSV</a></code> on the CSV file, prior to calling
<code><a href="#topic+inputData">inputData</a></code> again.
</p>
<p>If the data is &lsquo;genotypic&rsquo; data PolyPatEx requires that all
<code class="reqn">p</code> alleles must be present in each allele set, where <code class="reqn">p</code>
is the species' ploidy.  If an allele set contains fewer than
<code class="reqn">p</code> alleles, then it is reset to contain no alleles and is
subsequently ignored by other PolyPatEx functions.  ID and locus
information is printed to the R terminal, to help the user locate
these cases in their original dataset.
</p>
<p>Further checks look for mismatches between progeny and their
mothers' allele sets at each locus&mdash;these are situations where a
progeny's allele set could not have arisen from any gamete that
the mother can provide.  When no more than <code>matMismatches</code>
mismatching loci occurs in a mother-progeny pair, the offending
allele sets in the progeny are reset to contain no alleles (we
term these &lsquo;missing&rsquo; allele sets).  When mismatches occur
in more than <code>matMismatches</code> loci, the progeny is removed
entirely from the dataset.  Information is printed to the R
terminal to assist the user in identifying the affected
individuals and loci&mdash;in particular, note that removal of several
(or all) of a single mother's progeny may indicate an error in the
mother's allele data, rather than in her progeny.
</p>
<p>After the mother/progeny mismatch check above, a subsequent check
removes individuals from the dataset that have fewer than
<code>lociMin</code> non-missing allele sets remaining.  The default
value for <code>lociMin</code> is 1&mdash;an individual must have at least
one non-missing locus to remain in the dataset.  If any mothers
are removed from the dataset at this stage, all of her progeny are
removed also.  Again, information about these removals is printed
to the R terminal.
</p>
<p>Note that in the data frame that is returned by
<code>preprocessData</code>, the alleles in each allele set (i.e,
corresponding to each locus) will be sorted into alphanumeric
order&mdash;this sort order is necessary for the correct operation of
other PolyPatEx routines, and should not be altered.
</p>
<p>PolyPatEx needs to know the characteristics of the dataset being
analysed.  These are specified in the <code><a href="#topic+inputData">inputData</a></code> or
<code>preprocessData</code> calls and are invisibly attached to the
allele data frame that is returned, for use by other PolyPatEx
functions. The required characteristics are:
</p>

<ul>
<li> <p><code>numLoci</code>: the number of loci in the dataset
</p>
</li>
<li> <p><code>ploidy</code>: the ploidy (<code class="reqn">p</code>) of the species
(currently allowed to be 4, 6, or 8.  <code>ploidy</code> can
also be 2, provided <code>dataType="genotype"</code>)
</p>
</li>
<li> <p><code>dataType</code>: whether the data is genotypic (all <code class="reqn">p</code>
alleles at each locus are observed) or phenotypic (only
the distinct allele states at a locus are observed -
alleles that appear more than once in the genotype of
a locus only appear once in the phenotype)
</p>
</li>
<li> <p><code>dioecious</code>: whether the species is dioecious
or monoecious
</p>
</li>
<li> <p><code>selfCompatible</code>: whether a monoecious species is
self compatible (i.e., whether an individual can
fertilise itself)
</p>
</li>
<li> <p><code>mothersOnly</code>: whether a dioecious dataset should
retain only adult females that are mothers of progeny
in the dataset.
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame, containing the checked and pre-processed
allele data, ready for further analysis by other <span class="pkg">PolyPatEx</span>
functions.  All columns in the returned data frame will be of mode
<code>character</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Zwart (alec.zwart at csiro.au)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## If using inputData to input the allele dataset from CSV file,
## preprocessData() is applied automatically before the dataset is
## returned by inputData().

## Otherwise, if the allele dataset is created or loaded into R
## by other means, such preprocessData() must be applied before
## other PolyPatEx analysis routines are applied:

## Using the example dataset 'GF_Phenotype':
data(GF_Phenotype)

## Since we did not load this dataset using inputData(), we must
## first process it with preprocessData() before doing anything
## else:
pData &lt;- preprocessData(GF_Phenotype,
                        numLoci=7,
                        ploidy=6,
                        dataType="phenotype",
                        dioecious=FALSE,
                        selfCompatible=FALSE)

head(pData)  ## Checked and Cleaned version of GF_Phenotype

## pData is now ready to be passed to other PolyPatEx analysis
## functions...
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
