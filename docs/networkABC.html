<!DOCTYPE html><html><head><title>Help for package networkABC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {networkABC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abc'><p>ABC algorithm for network reverse-engineering</p></a></li>
<li><a href='#clusteringCoefficient'><p>Calculate the clustering coefficient</p></a></li>
<li><a href='#localClusteringCoefficient'><p>Calculate the local clustering coefficient</p></a></li>
<li><a href='#netsimul'><p>Simulated network</p></a></li>
<li><a href='#network_gen'><p>Random scale-free network generation. This function is used intensively in the abc function.</p></a></li>
<li><a href='#networkABC'><p>networkABC</p></a></li>
<li><a href='#resabc'><p>Result of an ABC inference</p></a></li>
<li><a href='#showHp'><p>Plot for the hub probabilities</p></a></li>
<li><a href='#showNetwork'><p>Plot the final network.</p></a></li>
<li><a href='#showNp'><p>Plot for the neighbourhood probabilities</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Network Reverse Engineering with Approximate Bayesian
Computation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-18</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RColorBrewer, network, sna</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, markdown, rmarkdown</td>
</tr>
<tr>
<td>Author:</td>
<td>Frederic Bertrand <a href="https://orcid.org/0000-0002-0837-8281"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Myriam Maumy-Bertrand
    <a href="https://orcid.org/0000-0002-4615-1512"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Khadija Musayeva [ctb],
  Nicolas Jung [ctb],
  Université de Strasbourg [cph],
  CNRS [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frederic Bertrand &lt;frederic.bertrand@utt.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>We developed an inference tool based on approximate Bayesian computation to decipher network data and assess the strength of the inferred links between network's actors. It is a new multi-level approximate Bayesian computation (ABC) approach. At the first level, the method captures the global properties of the network, such as a scale-free structure and clustering coefficients, whereas the second level is targeted to capture local properties, including the probability of each couple of genes being linked. Up to now, Approximate Bayesian Computation (ABC) algorithms have been scarcely used in that setting and, due to the computational overhead, their application was limited to a small number of genes. On the contrary, our algorithm was made to cope with that issue and has low computational cost. It can be used, for instance, for elucidating gene regulatory network, which is an important step towards understanding the normal cell physiology and complex pathological phenotype. Reverse-engineering consists in using gene expressions over time or over different experimental conditions to discover the structure of the gene network in a targeted cellular process. The fact that gene expression data are usually noisy, highly correlated, and have high dimensionality explains the need for specific statistical methods to reverse engineer the underlying network. </td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Classification/MSC:</td>
<td>62E17, 62F15, 62J07, 62P10, 92C42</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fbertran.github.io/networkABC/">https://fbertran.github.io/networkABC/</a>,
<a href="https://github.com/fbertran/networkABC/">https://github.com/fbertran/networkABC/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fbertran/networkABC/issues/">https://github.com/fbertran/networkABC/issues/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-18 23:03:24 UTC; fbertran</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-19 00:02:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='abc'>ABC algorithm for network reverse-engineering</h2><span id='topic+abc'></span>

<h3>Description</h3>

<p>ABC algorithm for network reverse-engineering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abc(
  data,
  clust_coeffs = c(0.33, 0.66, 1),
  tolerance = NA,
  number_hubs = NA,
  iterations = 10,
  number_networks = 1000,
  hub_probs = NA,
  neighbour_probs = NA,
  is_probs = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abc_+3A_data">data</code></td>
<td>
<p>: Any microarray data in the form of a matrix (rows are genes and columns are time points)</p>
</td></tr>
<tr><td><code id="abc_+3A_clust_coeffs">clust_coeffs</code></td>
<td>
<p>: one dimensional array of size clust_size of clustering coefficients (these clustering coefficient are tested in the ABc algorithm).</p>
</td></tr>
<tr><td><code id="abc_+3A_tolerance">tolerance</code></td>
<td>
<p>: a real value based for the tolerance between  the generated networks and the reference network</p>
</td></tr>
<tr><td><code id="abc_+3A_number_hubs">number_hubs</code></td>
<td>
<p>: number of hubs in the network</p>
</td></tr>
<tr><td><code id="abc_+3A_iterations">iterations</code></td>
<td>
<p>: number of times to repeat ABC algorithm</p>
</td></tr>
<tr><td><code id="abc_+3A_number_networks">number_networks</code></td>
<td>
<p>: number of generated networks in each iteration of the ABC algorithm</p>
</td></tr>
<tr><td><code id="abc_+3A_hub_probs">hub_probs</code></td>
<td>
<p>: one-dimensional array of size number_genes for the each label to be in the role of a hub</p>
</td></tr>
<tr><td><code id="abc_+3A_neighbour_probs">neighbour_probs</code></td>
<td>
<p>: this is the matrix of neighbour probabilities of size number_nodes*number_nodes</p>
</td></tr>
<tr><td><code id="abc_+3A_is_probs">is_probs</code></td>
<td>
<p>: this needs to be set either to one (if you specify hub_probs and neighbour_probs) or to zero (if neither probabilities are specified). Warning: you should specify both hub_probs and neighbour_probs if is_probs is one. If is_prob is zero these arrays should simply indicate an array of a specified size..</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>M&lt;-matrix(rnorm(30),10,3)
result&lt;-abc(data=M)
</code></pre>

<hr>
<h2 id='clusteringCoefficient'>Calculate the clustering coefficient</h2><span id='topic+clusteringCoefficient'></span>

<h3>Description</h3>

<p>Calculate the clustering coefficient for an adjacency matrix. By default, the local clustering coefficient is calculated. From the PCIT package after it was archived on the CRAN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusteringCoefficient(adj, FUN = "localClusteringCoefficient", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusteringCoefficient_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix. Calculating the clustering coefficient only makes sense if some connections are zero i.e. no connection.</p>
</td></tr>
<tr><td><code id="clusteringCoefficient_+3A_fun">FUN</code></td>
<td>
<p>The function for calculating the clustering coefficient.</p>
</td></tr>
<tr><td><code id="clusteringCoefficient_+3A_...">...</code></td>
<td>
<p>Arguments to pass to FUN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The clustering coefficient(s) for the adjacency matrix.
</p>


<h3>Author(s)</h3>

<p>Nathan S. Watson-Haigh
</p>


<h3>See Also</h3>

<p><a href="#topic+localClusteringCoefficient">localClusteringCoefficient</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clusteringCoefficient(network_gen(50,.33)$network)
</code></pre>

<hr>
<h2 id='localClusteringCoefficient'>Calculate the local clustering coefficient</h2><span id='topic+localClusteringCoefficient'></span>

<h3>Description</h3>

<p>Calculate the local clustering coefficient for each node in an adjacency matrix. The clustering coefficient is defined as the proportion of existing connections from the total possible (Watts and Strogatz, 1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localClusteringCoefficient(adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localClusteringCoefficient_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix. Calculating the clustering coefficient only makes sense if some connections are zero i.e. no connection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of local clustering coefficients for each node/gene of the adjacency matrix.
</p>


<h3>Author(s)</h3>

<p>Nathan S. Watson-Haigh
</p>


<h3>References</h3>

<p>D.J. Watts and S.H. Strogatz. (1998) Collective dynamics of 'small-world' networks. Nature. 393(6684). 440-442.
</p>


<h3>See Also</h3>

<p><a href="#topic+clusteringCoefficient">clusteringCoefficient</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
localClusteringCoefficient(network_gen(50,.33)$network)
</code></pre>

<hr>
<h2 id='netsimul'>Simulated network</h2><span id='topic+netsimul'></span>

<h3>Description</h3>

<p>Result of the use of the <code>network_gen</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netsimul
</code></pre>


<h3>Format</h3>

<p>A list of three objects :
</p>

<dl>
<dt>number_genes</dt><dd><p>The number of genes in the network</p>
</dd>
<dt>clust_coef</dt><dd><p>The clustering coefficient</p>
</dd>
<dt>network</dt><dd><p>The simulated network</p>
</dd>
</dl>


<hr>
<h2 id='network_gen'>Random scale-free network generation. This function is used intensively in the abc function.</h2><span id='topic+network_gen'></span>

<h3>Description</h3>

<p>Generate random network topology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_gen(number_genes, clust_coef)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_gen_+3A_number_genes">number_genes</code></td>
<td>
<p>A number</p>
</td></tr>
<tr><td><code id="network_gen_+3A_clust_coef">clust_coef</code></td>
<td>
<p>A number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the number of of genes, the targeted clustering coefficient and the resulting network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_gen(10,1)
</code></pre>

<hr>
<h2 id='networkABC'>networkABC</h2><span id='topic+networkABC'></span>

<h3>Description</h3>

<p>An inference tool based on approximate Bayesian computations to decipher 
network data and assess the strength of their inferred links.
</p>


<h3>References</h3>

<p><em>networkABC: An inference tool for networks based on approximate Bayesian computation</em>, Myriam Maumy-Bertrand, Frédéric Bertrand, preprint.
</p>

<hr>
<h2 id='resabc'>Result of an ABC inference</h2><span id='topic+resabc'></span>

<h3>Description</h3>

<p>Result for the reverse engineering of a simulated Cascade network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resabc
</code></pre>


<h3>Format</h3>

<p>A list of 14 objects :
</p>

<dl>
<dt>data</dt><dd><p>: The microarray data used, rows are genes and columns are time points.)</p>
</dd>
<dt>ngenes</dt><dd><p>: The number of genes.)</p>
</dd>
<dt>ntimes</dt><dd><p>: The number of timepoints)</p>
</dd>
<dt>clust_size</dt><dd><p>: the size of clusters</p>
</dd>
<dt>clust_coeffs</dt><dd><p>: the clustering coefficient</p>
</dd>
<dt>tolerance</dt><dd><p>: the tolerance between the generated networks and the reference network</p>
</dd>
<dt>number_hubs</dt><dd><p>: number of hubs in the network</p>
</dd>
<dt>iterations</dt><dd><p>: number of times to repeat ABC algorithm</p>
</dd>
<dt>number_networks</dt><dd><p>: number of generated networks in each iteration of the ABC algorithm</p>
</dd>
<dt>hub_probs</dt><dd><p>: one-dimensional array of size number_genes for the each label to be in the role of a hub</p>
</dd>
<dt>neighbour_probs</dt><dd><p>: matrix of neighbour probabilities of size number_nodes*number_nodes</p>
</dd>
<dt>is_probs</dt><dd><p>: is equal to 1 since hub_probs and neighbour_probs were specified</p>
</dd>
</dl>


<hr>
<h2 id='showHp'>Plot for the hub probabilities</h2><span id='topic+showHp'></span>

<h3>Description</h3>

<p>Plot for the hub probabilities ; there is one probability for each node in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showHp(result)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showHp_+3A_result">result</code></td>
<td>
<p>: The result of the abc algorithm.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(resabc)
showHp(resabc)
</code></pre>

<hr>
<h2 id='showNetwork'>Plot the final network.</h2><span id='topic+showNetwork'></span>

<h3>Description</h3>

<p>Plot the final network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showNetwork(res, min_prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showNetwork_+3A_res">res</code></td>
<td>
<p>: The result of the abc algorithm.</p>
</td></tr>
<tr><td><code id="showNetwork_+3A_min_prob">min_prob</code></td>
<td>
<p>: numeric ; under this probabilitie value, the link between two genes is set to 0.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(resabc)
showNetwork(resabc,.2)
</code></pre>

<hr>
<h2 id='showNp'>Plot for the neighbourhood probabilities</h2><span id='topic+showNp'></span>

<h3>Description</h3>

<p>Plot for the neighbourhood probabilities ; there is one probability for each pair of node in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showNp(result)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showNp_+3A_result">result</code></td>
<td>
<p>: The result of the abc algorithm.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(resabc)
showNp(resabc)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
