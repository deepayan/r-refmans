<!DOCTYPE html><html><head><title>Help for package spuRs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spuRs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bisection'><p> A function of the bisection algorithm.</p></a></li>
<li><a href='#booking_clerkMC'><p> A function to simulate the harassed booking clerk Markov chain.</p></a></li>
<li><a href='#CMCSimulation'><p> A function to simulate a continuous time Markov chain.</p></a></li>
<li><a href='#fitDistances'><p> Function to fit a model to seed transect distance/count data.</p></a></li>
<li><a href='#fixedpoint'><p> A function of the fixed point algorithm.</p></a></li>
<li><a href='#fixedpoint_show'><p> A function of the fixed point algorithm.</p></a></li>
<li><a href='#kew'><p> 303 years of monthly rainfall data from Kew Gardens, London, U.K.</p></a></li>
<li><a href='#MCEstimation'><p> A function to estimate the transition matrix for a discrete time Markov chain.</p></a></li>
<li><a href='#MCSimulation'><p> A function to simulate a discrete time Markov chain.</p></a></li>
<li><a href='#mean.transectHolder'><p> Function to compute the mean dispersal distance along a transect</p>
of seed traps.</a></li>
<li><a href='#mean.trapTransect'><p> Function to compute the mean dispersal distance along a transect</p>
of seed traps.</a></li>
<li><a href='#newtonraphson'><p> A function of the Newton-Raphson algorithm.</p></a></li>
<li><a href='#newtonraphson_show'><p> A function of the Newton-Raphson algorithm, plotting the path.</p></a></li>
<li><a href='#prime'><p> Function to assess whether or not an integer is prime.</p></a></li>
<li><a href='#primesieve'><p> Function to identify all the primes in a vector of positive integers.</p></a></li>
<li><a href='#print.transectHolder'><p> Function to print a transectHolder object usefullly.</p></a></li>
<li><a href='#print.trapTransect'><p> Function to print a trapTransect object usefullly.</p></a></li>
<li><a href='#RK4adapt'><p> A function which uses the Fourth order Runge-Kutta method with adaptive step size to solve a system of ODE's.</p></a></li>
<li><a href='#sd.transectHolder'><p> Function to compute the sd dispersal distance along a transect</p>
of seed traps.</a></li>
<li><a href='#simulate.transectHolder'><p>Function to simulate a modelled seed rain from a transectHolder</p></a></li>
<li><a href='#transectHolder'><p> Function to construct an object representing a collection of</p>
trapTransect objects.</a></li>
<li><a href='#trapTransect'><p> Function to construct an object representing a transect of seedtraps.</p></a></li>
<li><a href='#treeg'><p> Grand fir tree growth data from northern and central Idaho, USA.</p></a></li>
<li><a href='#trees'><p> von Guttenberg Norway spruce tree measurement data</p></a></li>
<li><a href='#ufc'><p> Upper Flat Creek forest cruise tree data</p></a></li>
<li><a href='#ufc.plots'><p> Upper Flat Creek forest cruise plot data</p></a></li>
<li><a href='#vol.m3'><p> Function to compute the volume of a tree bole assuming a</p>
particular shape.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions and Datasets for "Introduction to Scientific
Programming and Simulation Using R"</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-05-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Owen Jones, Robert Maillardet, Andrew Robinson, Olga Borovkova, and Steven Carnie</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Robinson &lt;apro@unimelb.edu.au&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), MASS, lattice</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions and datasets from Jones, O.D., R. Maillardet, and A.P. Robinson.  2014.  An Introduction to Scientific Programming and Simulation, Using R. 2nd Ed. Chapman And Hall/CRC.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-05-21 02:47:00 UTC; andrewpr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-05-21 04:51:26 UTC</td>
</tr>
</table>
<hr>
<h2 id='bisection'> A function of the bisection algorithm. </h2><span id='topic+bisection'></span>

<h3>Description</h3>

<p>Applies the bisection algorithm to find x such that ftn(x) == x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bisection(ftn, x.l, x.r, tol = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bisection_+3A_ftn">ftn</code></td>
<td>
<p> the function.  </p>
</td></tr>
<tr><td><code id="bisection_+3A_x.l">x.l</code></td>
<td>
<p> is the lower starting point. </p>
</td></tr>
<tr><td><code id="bisection_+3A_x.r">x.r</code></td>
<td>
<p> is the upper starting point. </p>
</td></tr>
<tr><td><code id="bisection_+3A_tol">tol</code></td>
<td>
<p> distance of successive iterations at which algorithm
terminates. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume that <kbd>ftn</kbd> is a function of a single variable.
</p>


<h3>Value</h3>

<p>Returns the value of x at which ftn(x) == x.  If the function fails to
converge within <kbd>max.iter</kbd> iterations, returns <kbd>NULL</kbd>.
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+newtonraphson">newtonraphson</a></code>, <code><a href="#topic+fixedpoint">fixedpoint</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ftn5 &lt;- function(x) return(log(x)-exp(-x))
bisection(ftn5, 1, 2, tol = 1e-6)
</code></pre>

<hr>
<h2 id='booking_clerkMC'> A function to simulate the harassed booking clerk Markov chain. </h2><span id='topic+booking_clerkMC'></span>

<h3>Description</h3>

<p>Simulates the harassed booking clerk Markov chain with given arrival and service rates up to t.end. The state space is (C(t),X(t),Y(t)), where C(t) represents the status of the clerk, X(t) the number of people waiting, and Y(t) the number of calls waiting. C(t) is 0 if clerk is idle, 1 if clerk is serving a person and 2 if clerk is serving a call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>booking_clerkMC(personArrRate, 
                callArrRate,
                personServRate,
                callServRate,
                t.end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="booking_clerkMC_+3A_personarrrate">personArrRate</code></td>
<td>
<p> the person arrival rate.  </p>
</td></tr>
<tr><td><code id="booking_clerkMC_+3A_callarrrate">callArrRate</code></td>
<td>
<p> the call arrival rate. </p>
</td></tr>
<tr><td><code id="booking_clerkMC_+3A_personservrate">personServRate</code></td>
<td>
<p> the person service rate. </p>
</td></tr>
<tr><td><code id="booking_clerkMC_+3A_callservrate">callServRate</code></td>
<td>
<p> the call service rate. </p>
</td></tr>
<tr><td><code id="booking_clerkMC_+3A_t.end">t.end</code></td>
<td>
<p> the time of the time period to be simulated i.e. (0,t.end). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume that all given rates are finite and positive.
</p>


<h3>Value</h3>

<p>Returns the matrix (t.hist, state.hist) containing the realisation of the chain.
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>booking_clerkMC(3,6,5,8,1)
</code></pre>

<hr>
<h2 id='CMCSimulation'> A function to simulate a continuous time Markov chain. </h2><span id='topic+CMCSimulation'></span>

<h3>Description</h3>

<p>This function simulates a continuous time finite state space Markov chain with known rate matrix Q, state space 0,1,..,n and initial state i for the time period (0,T).  If plotflag is TRUE it also produces a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CMCSimulation(Q,i,Tend,plotflag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CMCSimulation_+3A_q">Q</code></td>
<td>
<p> the rate matrix.  </p>
</td></tr>
<tr><td><code id="CMCSimulation_+3A_i">i</code></td>
<td>
<p> the initial state. </p>
</td></tr>
<tr><td><code id="CMCSimulation_+3A_tend">Tend</code></td>
<td>
<p> the end of the simulation period (0,T). </p>
</td></tr>
<tr><td><code id="CMCSimulation_+3A_plotflag">plotflag</code></td>
<td>
<p>flag indicating if plot needed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume that <kbd>Q</kbd> is well defined rate matrix.
</p>


<h3>Value</h3>

<p>Returns the matrix (statehist,timehist) containing the realisation of the chain for the specified period.  The function also produces a plot of the realisation. \
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MCSimulation">MCSimulation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- matrix(c(-24,24,0, 2,-14,12, 0,4,-4), 
            nrow = 3, ncol = 3, byrow = TRUE)
CMCSimulation(Q,0,1)
</code></pre>

<hr>
<h2 id='fitDistances'> Function to fit a model to seed transect distance/count data. </h2><span id='topic+fitDistances'></span>

<h3>Description</h3>

<p>This function uses maximum likelihood to fit a nominated probability
density function to the data of a seedtrap transect holder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitDistances(x, family)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitDistances_+3A_x">x</code></td>
<td>
<p> an object of class transectHolder </p>
</td></tr>
<tr><td><code id="fitDistances_+3A_family">family</code></td>
<td>
<p> the nominated distribution, which must be one of those
distributions that can be fit by <kbd>fitdistr</kbd> of the MASS package. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the parameter estimates for the nominated family.
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+fitdistr">fitdistr</a></code>, <code><a href="#topic+trapTransect">trapTransect</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
s1 &lt;- trapTransect(distances = 1:4, seed.counts = c(4, 3, 2, 0))
allTraps &lt;- transectHolder(s1, family="Weibull")
fitDistances(allTraps, "exponential")
</code></pre>

<hr>
<h2 id='fixedpoint'> A function of the fixed point algorithm. </h2><span id='topic+fixedpoint'></span>

<h3>Description</h3>

<p>Applies the fixed point algorithm to find x such that ftn(x) == x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixedpoint(ftn, x0, tol = 1e-09, max.iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixedpoint_+3A_ftn">ftn</code></td>
<td>
<p> the function.  </p>
</td></tr>
<tr><td><code id="fixedpoint_+3A_x0">x0</code></td>
<td>
<p> is the initial guess at the fixed point. </p>
</td></tr>
<tr><td><code id="fixedpoint_+3A_tol">tol</code></td>
<td>
<p> distance of successive iterations at which algorithm terminates. </p>
</td></tr>
<tr><td><code id="fixedpoint_+3A_max.iter">max.iter</code></td>
<td>
<p> maximum number of iterations. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume that <kbd>ftn</kbd> is a function of a single variable.
</p>


<h3>Value</h3>

<p>Returns the value of x at which ftn(x) == x.  If the function fails to
converge within <kbd>max.iter</kbd> iterations, returns <kbd>NULL</kbd>.
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+newtonraphson">newtonraphson</a></code>, <code><a href="#topic+bisection">bisection</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ftn1 &lt;- function(x) return(exp(exp(-x)))
fixedpoint(ftn1, 2, tol = 1e-6)
</code></pre>

<hr>
<h2 id='fixedpoint_show'> A function of the fixed point algorithm. </h2><span id='topic+fixedpoint_show'></span>

<h3>Description</h3>

<p>Applies the fixed point algorithm to find x such that ftn(x) == x, and
plots the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixedpoint_show(ftn, x0, xmin = x0 - 1, xmax = x0 + 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixedpoint_show_+3A_ftn">ftn</code></td>
<td>
<p> the function. </p>
</td></tr>
<tr><td><code id="fixedpoint_show_+3A_x0">x0</code></td>
<td>
<p> is the initial guess at the fixed point. </p>
</td></tr>
<tr><td><code id="fixedpoint_show_+3A_xmin">xmin</code></td>
<td>
<p> ~~Describe <kbd>xmin</kbd> here~~ </p>
</td></tr>
<tr><td><code id="fixedpoint_show_+3A_xmax">xmax</code></td>
<td>
<p> ~~Describe <kbd>xmax</kbd> here~~ </p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume that <kbd>ftn</kbd> is a function of a single variable.
</p>


<h3>Value</h3>

<p>Returns the value of x at which ftn(x) == x.  If the function fails to
converge within <kbd>max.iter</kbd> iterations, returns <kbd>NULL</kbd>.
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixedpoint">fixedpoint</a></code></p>

<hr>
<h2 id='kew'> 303 years of monthly rainfall data from Kew Gardens, London, U.K.</h2><span id='topic+kew'></span>

<h3>Description</h3>

<p>The monthly rainfall at Kew Gardens, London, U.K., from 1697 to 1999, in
mm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kew)</code></pre>


<h3>Format</h3>

<p>A wide-format data frame with 303 observations.  Each month has its
own column.
</p>


<h3>Source</h3>

<p>Data obtained from the U.S. National Climatic Data Centre, Global
Historical Climatology Network data base (GHCN-Monthly Version 2, NB:
not Version 3)
<a href="https://www.ncdc.noaa.gov/ghcnm/">https://www.ncdc.noaa.gov/ghcnm/</a>.
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2014.  An Introduction
to Scientific Programming and Simulation, Using R.  2nd Ed. Chapman And Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kew)
</code></pre>

<hr>
<h2 id='MCEstimation'> A function to estimate the transition matrix for a discrete time Markov chain. </h2><span id='topic+MCEstimation'></span>

<h3>Description</h3>

<p>This function estimates the transition matrix for a discrete time Markov chain with state space 0,1,..,n given a realisation. The chain has n+1 states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCEstimation(statehist,n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCEstimation_+3A_statehist">statehist</code></td>
<td>
<p> the realisation of the chain.  </p>
</td></tr>
<tr><td><code id="MCEstimation_+3A_n">n</code></td>
<td>
<p> the highest numbered state. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume that the state space is 0,1,2...,n.  n is assumed known as it cannot be reliably infered from the realisation.
</p>


<h3>Value</h3>

<p>Returns the empirical transition matrix obtained by calculating the observed frequencies of actual transitions in the realisation.\
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MCSimulation">MCSimulation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(0.5,0.5,0,0,0.7,0.1,0.2,0,0,0.1,0.1,0.8,0,0,0.7,0.3),
            nrow = 4, ncol = 4, byrow = TRUE)
statehist&lt;-MCSimulation(P, 0, 3000)
MCEstimation(statehist, 3)
</code></pre>

<hr>
<h2 id='MCSimulation'> A function to simulate a discrete time Markov chain. </h2><span id='topic+MCSimulation'></span>

<h3>Description</h3>

<p>This function simulates a discrete time Markov chain with transition matrix P, state space 0,1,..,n and 
and initial state i for nsteps transitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCSimulation(P,i,nsteps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCSimulation_+3A_p">P</code></td>
<td>
<p> the transition matrix.  </p>
</td></tr>
<tr><td><code id="MCSimulation_+3A_i">i</code></td>
<td>
<p> the initial state. </p>
</td></tr>
<tr><td><code id="MCSimulation_+3A_nsteps">nsteps</code></td>
<td>
<p> the number of transitions to be simulated. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume that <kbd>P</kbd> is well defined transition matrix with rows summing to 1.
</p>


<h3>Value</h3>

<p>Returns the vector statehist containing the realisation of the chain for nsteps transitions.\
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+MCEstimation">MCEstimation</a></code>, <code><a href="#topic+CMCSimulation">CMCSimulation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(0.5,0.5,0,0,0.7,0.1,0.2,0,0,0.1,0.1,0.8,0,0,0.7,0.3),
            nrow = 4, ncol = 4, byrow = TRUE)
MCSimulation(P, 0, 250)
</code></pre>

<hr>
<h2 id='mean.transectHolder'> Function to compute the mean dispersal distance along a transect
of seed traps.</h2><span id='topic+mean.transectHolder'></span>

<h3>Description</h3>

<p> This function computes the mean dispersal distance along a
transect of seed traps.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class transectHolder 
## S3 method for class 'transectHolder'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.transectHolder_+3A_x">x</code></td>
<td>
<p>an object representing a transect of seed traps. </p>
</td></tr>
<tr><td><code id="mean.transectHolder_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> The mean seed dispersal distance is returned.  </p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transectHolder">transectHolder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
transect.1 &lt;- trapTransect(distances = 1:4,
                        seed.counts = c(4, 3, 2, 0))
transect.2 &lt;- trapTransect(distances = 1:3,
                        seed.counts = c(3, 2, 1))
transect.3 &lt;- trapTransect(distances=(1:5)/2,
                        seed.counts = c(3, 4, 2, 3, 1))
allTraps &lt;- transectHolder(transect.1, transect.2, transect.3,
                           family="Weibull")

mean(allTraps)

</code></pre>

<hr>
<h2 id='mean.trapTransect'> Function to compute the mean dispersal distance along a transect
of seed traps.</h2><span id='topic+mean.trapTransect'></span>

<h3>Description</h3>

<p> This function computes the mean dispersal distance along a
transect of seed traps.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class trapTransect 
## S3 method for class 'trapTransect'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.trapTransect_+3A_x">x</code></td>
<td>
<p>an object representing a transect of seed traps. </p>
</td></tr>
<tr><td><code id="mean.trapTransect_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> The mean seed dispersal distance is returned.  </p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trapTransect">trapTransect</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
s1 &lt;- trapTransect(distances = 1:4, seed.count = c(4, 3, 2, 0))
mean(s1)

</code></pre>

<hr>
<h2 id='newtonraphson'> A function of the Newton-Raphson algorithm. </h2><span id='topic+newtonraphson'></span>

<h3>Description</h3>

<p>Applies the Newton-Raphson algorithm to find x such that ftn(x)[1] == 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newtonraphson(ftn, x0, tol = 1e-09, max.iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newtonraphson_+3A_ftn">ftn</code></td>
<td>
<p> the function.  </p>
</td></tr>
<tr><td><code id="newtonraphson_+3A_x0">x0</code></td>
<td>
<p> is the initial guess at the fixed point. </p>
</td></tr>
<tr><td><code id="newtonraphson_+3A_tol">tol</code></td>
<td>
<p> distance of successive iterations at which algorithm terminates. </p>
</td></tr>
<tr><td><code id="newtonraphson_+3A_max.iter">max.iter</code></td>
<td>
<p> maximum number of iterations. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of x at which ftn(x)[1] == 0.  If the function fails to
converge within <kbd>max.iter</kbd> iterations, returns <kbd>NULL</kbd>.
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fixedpoint">fixedpoint</a></code>, <code><a href="#topic+bisection">bisection</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ftn4 &lt;- function(x) {
  # returns function value and its derivative at x
  fx &lt;- log(x) - exp(-x)
  dfx &lt;- 1/x + exp(-x)
  return(c(fx, dfx))
}
newtonraphson(ftn4, 2, 1e-6)
</code></pre>

<hr>
<h2 id='newtonraphson_show'> A function of the Newton-Raphson algorithm, plotting the path. </h2><span id='topic+newtonraphson_show'></span>

<h3>Description</h3>

<p>Applies the Newton-Raphson algorithm to find x such that ftn(x)[1] == 0,
and plots the trace of the estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newtonraphson_show(ftn, x0, xmin = x0 - 1, xmax = x0 + 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newtonraphson_show_+3A_ftn">ftn</code></td>
<td>
<p> the function. </p>
</td></tr>
<tr><td><code id="newtonraphson_show_+3A_x0">x0</code></td>
<td>
<p> the initial guess of the fixed point. </p>
</td></tr>
<tr><td><code id="newtonraphson_show_+3A_xmin">xmin</code></td>
<td>
<p> lower limit for plotting. </p>
</td></tr>
<tr><td><code id="newtonraphson_show_+3A_xmax">xmax</code></td>
<td>
<p> upper limit for plotting. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of x at which ftn(x)[1] == 0.  If the function fails to
converge within <kbd>max.iter</kbd> iterations, returns <kbd>NULL</kbd>.
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+newtonraphson">newtonraphson</a></code> </p>

<hr>
<h2 id='prime'> Function to assess whether or not an integer is prime. </h2><span id='topic+prime'></span>

<h3>Description</h3>

<p>An inefficient, brute-force algorithm to assess whether or not an integer is prime. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prime(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prime_+3A_n">n</code></td>
<td>
<p> The integer. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes that <code>n</code> is a positive integer.
</p>


<h3>Value</h3>

<p>The function returns a logical object that is TRUE if the integer is prime.
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009. An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+primesieve">primesieve</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>prime(10)
prime(7)
</code></pre>

<hr>
<h2 id='primesieve'> Function to identify all the primes in a vector of positive integers. </h2><span id='topic+primesieve'></span>

<h3>Description</h3>

<p>This function uses the Sieve of Eratosthenes to find all the primes less
than or equal to a given integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primesieve(sieved, unsieved)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="primesieve_+3A_sieved">sieved</code></td>
<td>
<p> Identified primes (empty vector for initialization) </p>
</td></tr>
<tr><td><code id="primesieve_+3A_unsieved">unsieved</code></td>
<td>
<p> Candidate integers </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes that <kbd>unsieved</kbd> is a vector of positive integers.
</p>


<h3>Value</h3>

<p>Returns a vector of primes sieved (selected) from the input vector.
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009. An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prime">prime</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>primesieve(c(), 2:200)

</code></pre>

<hr>
<h2 id='print.transectHolder'> Function to print a transectHolder object usefullly.</h2><span id='topic+print.transectHolder'></span>

<h3>Description</h3>

<p> This function prints the details of a transectHolder object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class transectHolder 
## S3 method for class 'transectHolder'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.transectHolder_+3A_x">x</code></td>
<td>
<p>An object representing a transect of seed traps. </p>
</td></tr>
<tr><td><code id="print.transectHolder_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p> The print function simply uses <kbd>str</kbd> on the transectHolder
object.  </p>


<h3>Value</h3>

<p>This function is called for its side-effect, which is to print the
object informatively.
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transectHolder">transectHolder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
transect.1 &lt;- trapTransect(distances = 1:4,
                        seed.counts = c(4, 3, 2, 0))
transect.2 &lt;- trapTransect(distances = 1:3,
                        seed.counts = c(3, 2, 1))
transect.3 &lt;- trapTransect(distances=(1:5)/2,
                        seed.counts = c(3, 4, 2, 3, 1))
allTraps &lt;- transectHolder(transect.1, transect.2, transect.3,
                           family="Weibull")
allTraps

</code></pre>

<hr>
<h2 id='print.trapTransect'> Function to print a trapTransect object usefullly.</h2><span id='topic+print.trapTransect'></span>

<h3>Description</h3>

<p> This function prints the details of a trapTransect object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class trapTransect 
## S3 method for class 'trapTransect'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.trapTransect_+3A_x">x</code></td>
<td>
<p>An object representing a transect of seed traps. </p>
</td></tr>
<tr><td><code id="print.trapTransect_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p> The print function simply uses <kbd>str</kbd> on the trapTransect
object.  </p>


<h3>Value</h3>

<p>This function is called for its side-effect, which is to print the
object informatively.
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trapTransect">trapTransect</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
s1 &lt;- trapTransect(distances = 1:4, seed.count = c(4, 3, 2, 0))
s1

</code></pre>

<hr>
<h2 id='RK4adapt'> A function which uses the Fourth order Runge-Kutta method with adaptive step size to solve a system of ODE's. </h2><span id='topic+RK4adapt'></span>

<h3>Description</h3>

<p>This function simulates a discrete time Markov chain with transition matrix P, state space 0,1,..,n and 
and initial state i for nsteps transitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RK4adapt(dydt, t0, y0, t1, h0 = 1, tol = 1e-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RK4adapt_+3A_dydt">dydt</code></td>
<td>
<p> a function giving the gradient of y(t).</p>
</td></tr>
<tr><td><code id="RK4adapt_+3A_t0">t0</code></td>
<td>
<p> initial value of t.</p>
</td></tr>
<tr><td><code id="RK4adapt_+3A_y0">y0</code></td>
<td>
<p>initial value of y(t).</p>
</td></tr>
<tr><td><code id="RK4adapt_+3A_t1">t1</code></td>
<td>
<p>system solved up to time t1.</p>
</td></tr>
<tr><td><code id="RK4adapt_+3A_h0">h0</code></td>
<td>
<p>initial step size</p>
</td></tr>
<tr><td><code id="RK4adapt_+3A_tol">tol</code></td>
<td>
<p> tolerance for adapting step size.</p>
</td></tr>
<tr><td><code id="RK4adapt_+3A_...">...</code></td>
<td>
<p>pass arguments to function dydt.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume that <kbd>P</kbd> is well defined transition matrix with rows summing to 1.
</p>


<h3>Value</h3>

<p>Returns a list with elements t, a vector giving times, and y, a matrix whose rows give the solution at successive times.
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LV &lt;- function(t=NULL, y, a, b, g, e, K=Inf)
  c(a*y[1]*(1 - y[1]/K) - b*y[1]*y[2], g*b*y[1]*y[2] - e*y[2])

xy &lt;- RK4adapt(LV, 0, c(100, 50), 200, 1, tol=1e-3, 
               a=0.05, K=Inf, b=0.0002, g=0.8, e=0.03)

par(mfrow = c(2,1))
plot(xy$y[,1], xy$y[,2], type='p', 
     xlab='prey', ylab='pred', main='RK4, adaptive h')
plot(xy$t, xy$y[,1], type='p', xlab='time', 
     ylab='prey circles pred triangles', main='RK4, adaptive h')
points(xy$t, xy$y[,2], pch=2)
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='sd.transectHolder'> Function to compute the sd dispersal distance along a transect
of seed traps.</h2><span id='topic+sd.transectHolder'></span>

<h3>Description</h3>

<p> This function computes the standard deviation of the
dispersal distances along a transect of seed traps.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>sd.transectHolder(transectHolder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd.transectHolder_+3A_transectholder">transectHolder</code></td>
<td>
<p>an object representing a transect of seed traps. </p>
</td></tr>
</table>


<h3>Value</h3>

<p> The standard deviation of the seed dispersal distances is returned.  </p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009.  An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transectHolder">transectHolder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
transect.1 &lt;- trapTransect(distances = 1:4,
                        seed.counts = c(4, 3, 2, 0))
transect.2 &lt;- trapTransect(distances = 1:3,
                        seed.counts = c(3, 2, 1))
transect.3 &lt;- trapTransect(distances=(1:5)/2,
                        seed.counts = c(3, 4, 2, 3, 1))
allTraps &lt;- transectHolder(transect.1, transect.2, transect.3,
                           family="Weibull")

mean(allTraps)

sd.transectHolder(allTraps)

</code></pre>

<hr>
<h2 id='simulate.transectHolder'>Function to simulate a modelled seed rain from a transectHolder </h2><span id='topic+simulate.transectHolder'></span>

<h3>Description</h3>

<p>This function simulates a two-dimensional seed rain
according to the model stored in a transectHolder object.  The angle
of the seed location from the parent plant is uniformly distributed on
[0, 2 pi).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class transectHolder 
## S3 method for class 'transectHolder'
simulate(object, nsim=1, seed=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.transectHolder_+3A_object">object</code></td>
<td>
<p> the transectHolder object for simulation </p>
</td></tr>
<tr><td><code id="simulate.transectHolder_+3A_nsim">nsim</code></td>
<td>
<p> the number of seeds to simulate. </p>
</td></tr>
<tr><td><code id="simulate.transectHolder_+3A_seed">seed</code></td>
<td>
<p> if not NULL, set the seed to this value before simulation.</p>
</td></tr>
<tr><td><code id="simulate.transectHolder_+3A_...">...</code></td>
<td>
<p> additional optional arguments (ignored here).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with <code>n</code> rows with the following components:
</p>
<table>
<tr><td><code>distances</code></td>
<td>
<p>seed distances to parent plant</p>
</td></tr>
<tr><td><code>angles</code></td>
<td>
<p>seed angles to parent plant, in radians</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>x-location of seed</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-location of seed</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009. An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transectHolder">transectHolder</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>transect.1 &lt;- trapTransect(distances = 1:4,
                        seed.counts = c(4, 3, 2, 0))
transect.2 &lt;- trapTransect(distances = 1:3,
                        seed.counts = c(3, 2, 1))
transect.3 &lt;- trapTransect(distances=(1:5)/2,
                        seed.counts = c(3, 4, 2, 3, 1))
allTraps &lt;- transectHolder(transect.1, transect.2, transect.3,
                           family="Weibull")
allTraps
simulate(allTraps, nsim=5, seed=123)
</code></pre>

<hr>
<h2 id='transectHolder'> Function to construct an object representing a collection of
trapTransect objects.
</h2><span id='topic+transectHolder'></span>

<h3>Description</h3>

<p>This function constructs a transectHolder object given a collection
of <code>trapTransect</code> objects and a nominated probability density
function to fit to the seed count profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transectHolder(..., family = "exponential")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transectHolder_+3A_...">...</code></td>
<td>
<p> one or more <code>trapTransect</code> objects </p>
</td></tr>
<tr><td><code id="transectHolder_+3A_family">family</code></td>
<td>
<p> the probability density function to fit to the distance
count profiles. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a constructor.
</p>
<p>The nominated distribution, which must be one of those distributions
that can be fit by <code>fitdistr</code> of the MASS package.  </p>


<h3>Value</h3>

<p>A transectHolder object, which is a list comprising
</p>
<table>
<tr><td><code>transects</code></td>
<td>
<p>a list one or more trapTransect objects,</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the name of the distribution to which the transect data
has been fit,</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>the estimated parameters for that distribution,</p>
</td></tr>
<tr><td><code>rng</code></td>
<td>
<p>the corresponding random number generator for simulations.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009. An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trapTransect">trapTransect</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>transect.1 &lt;- trapTransect(distances = 1:4,
                        seed.counts = c(4, 3, 2, 0))
transect.2 &lt;- trapTransect(distances = 1:3,
                        seed.counts = c(3, 2, 1))
transect.3 &lt;- trapTransect(distances=(1:5)/2,
                        seed.counts = c(3, 4, 2, 3, 1))
allTraps &lt;- transectHolder(transect.1, transect.2, transect.3,
                           family="Weibull")
allTraps
</code></pre>

<hr>
<h2 id='trapTransect'> Function to construct an object representing a transect of seedtraps. </h2><span id='topic+trapTransect'></span>

<h3>Description</h3>

<p> This function constructs a trapTransect object given a
vector of trap distances from the parent plant, a vector of trap seed
counts corresponding to the trap distances, and a single trap area.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> trapTransect(distances, seed.counts, trap.area = 0.0001) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trapTransect_+3A_distances">distances</code></td>
<td>
<p>A vector of trap distances from the parent plant.  </p>
</td></tr>
<tr><td><code id="trapTransect_+3A_seed.counts">seed.counts</code></td>
<td>
<p>A vector of seed counts in each trap.</p>
</td></tr>
<tr><td><code id="trapTransect_+3A_trap.area">trap.area</code></td>
<td>
<p>The surface area of each trap.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a constructor.
</p>


<h3>Value</h3>

<p>A trapTransect object, which is a list comprising three objects:
</p>
<table>
<tr><td><code>distances</code></td>
<td>
<p>A vector of trap distances from the parent plant.</p>
</td></tr>
<tr><td><code>seed.counts</code></td>
<td>
<p>A vector of seed counts in each trap.</p>
</td></tr>
<tr><td><code>trap.area</code></td>
<td>
<p>The surface area of each trap.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009. An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.trapTransect">mean.trapTransect</a></code>,  <code><a href="#topic+print.trapTransect">print.trapTransect</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- trapTransect(distances = 1:4, seed.counts = c(4, 3, 2, 0))
s1
mean(s1)
</code></pre>

<hr>
<h2 id='treeg'> Grand fir tree growth data from northern and central Idaho, USA.</h2><span id='topic+treeg'></span>

<h3>Description</h3>

<p>A sample of 66 grand fir (<em>Abies grandis</em>) trees was selected from
national forests around northern and central Idaho.  The trees were
selected to be dominant in their environment, with no visible evidence
of crown damage, forks, broken tops, etc.  For each tree the habitat
type and the national forest from which it came were recorded.  We have
data from nine national forests and six different habitat types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(treeg)</code></pre>


<h3>Format</h3>

<p>A data frame with 542 observations on the following 6 variables.
</p>

<dl>
<dt>tree.ID</dt><dd><p>Tree number.</p>
</dd>
<dt>forest</dt><dd><p>National forest number.</p>
</dd>
<dt>habitat</dt><dd><p>Habitat code (see Details).</p>
</dd>
<dt>dbh.in</dt><dd><p>Bole diameter at 1.37 m, in inches</p>
</dd>
<dt>height.ft</dt><dd><p>Tree height, in feet.</p>
</dd>
<dt>age</dt><dd><p>Age at which measurement was taken.</p>
</dd>
</dl>



<h3>Details</h3>

<p>For each tree the height, diameter and age were measured (age is
measured using tree rings), then the tree was split lengthways, which
allows you to determine the height and diameter of the tree at any
age.  In this instance height and diameter were recorded for the age the
tree was felled and then at ten year periods going back in time.  The
diameter of the tree was measured at a height of 1.37 m (4'6&rdquo;), which
is called <em>breast height</em> in forestry.  The height refers to the
height of the main trunk only.
</p>
<p>The habitats corresponding to codes 1 through 5 are: Ts/Pach; Ts/Op;
Th/Pach; AG/Pach and PA/Pach.  These codes refer to the climax tree
species, which is the most shade-tolerant species that can grow on the
site, and the dominant understorey plant, respectively.  Ts refers to
<em>Thuja plicata</em> and <em>Tsuga heterophylla</em>, Th refers to
just <em>Thuja plicata</em>, AG is <em>Abies grandis</em>, PA is
<em>Picea engelmanii</em> and <em>Abies lasiocarpa</em>, Pach is
<em>Pachistima myrsinites</em>, and Op is the nasty <em>Oplopanaz
horridurn</em>.  Grand fir is considered a major climax species for AG/Pach,
a major seral species for Th/Pach and PA/Pach, and a minor seral species
for Ts/Pach and Ts/Op.  Loosely speaking, a community is <em>seral</em>
if there is evidence that at least some of the species are temporary,
and <em>climax</em> if the community is self-regenerating (Daubenmire,
1952).
</p>


<h3>Source</h3>

<p> These data were kindly supplied by Dr Al Stage, Principal
Mensurationist (retired), USDA Forest Service Foresct Sciences
Laboratory, Moscow, ID, USA.  </p>


<h3>References</h3>

<p>R. Daubenmire, 1952. Forest Vegetation of Northern Idaho and Adjacent
Washington, and Its Bearing on Concepts of Vegetation Classification,
<em>Ecological Monographs</em> <b>22</b>, 301&ndash;330.
</p>
<p>A. R. Stage, 1963. A mathematical approach to polymorphic site index
curves for grand fir. <em>Forest Science</em> <b>9</b>, 167&ndash;180.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(treeg)
</code></pre>

<hr>
<h2 id='trees'> von Guttenberg Norway spruce tree measurement data </h2><span id='topic+trees'></span>

<h3>Description</h3>

<p>These are a subset of the von Guttenberg data, a set of measurements on
Norway spruce (<em>Picea abies</em> [L.] Karst) in several different
locations and site categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(trees)</code></pre>


<h3>Format</h3>

<p>A data frame with 1200 observations on the following 3 variables.
</p>

<dl>
<dt>ID</dt><dd><p>A factor identifying the tree by location, site,
and tree number.</p>
</dd>
<dt>Age</dt><dd><p>The age at which the tree was measured.</p>
</dd>
<dt>Vol</dt><dd><p>The bole volume of the tree, in cubic dm.</p>
</dd>
</dl>



<h3>Source</h3>

<p>These data were kindly provided by Professor Boris Zeide, University of
Arkanasa, Monticello, AK, USA, and are further documented in Zeide (1993).
</p>


<h3>References</h3>

<p>A.R. von Guttenberg.  1915.  Growth and yield of spruce in Hochgebirge.
Franz Deuticke, Wien. (In German)
</p>
<p>B. Zeide, 1993.  Analysis of growth equations.  <em>Forest Science</em>
<b>39</b> 594&ndash;616.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trees)
</code></pre>

<hr>
<h2 id='ufc'> Upper Flat Creek forest cruise tree data </h2><span id='topic+ufc'></span>

<h3>Description</h3>

<p>These are a subset of the tree measurement data from the
Upper Flat Creek unit of the University of Idaho Experimental
Forest, which was measured in 1991. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ufc)</code></pre>


<h3>Format</h3>

<p>A data frame with 336 observations on the following 5 variables.
</p>

<dl>
<dt>plot</dt><dd><p>plot label</p>
</dd>
<dt>tree</dt><dd><p>tree label</p>
</dd>
<dt>species</dt><dd><p>species kbd with levels <kbd>DF</kbd>, <kbd>GF</kbd>, <kbd>WC</kbd>, <kbd>WL</kbd></p>
</dd>
<dt>dbh.cm</dt><dd><p>tree diameter at 1.37 m. from the ground, measured in
centimetres.</p>
</dd>
<dt>height.m</dt><dd><p>tree height measured in metres</p>
</dd>
</dl>



<h3>Details</h3>

<p>The inventory was based on variable radius plots with 6.43 sq. m.
per ha. BAF (Basal Area Factor).  The forest stand was 121.5 ha.
This version of the data omits errors, trees with missing heights,
and uncommon species.  The four species are Douglas-fir, grand fir,
western red cedar, and western larch.
</p>


<h3>Source</h3>

<p>The data are provided courtesy of Harold Osborne and Ross
Appelgren of the University of Idaho Experimental Forest. 
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009. An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ufc.plots">ufc.plots</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ufc)
</code></pre>

<hr>
<h2 id='ufc.plots'> Upper Flat Creek forest cruise plot data </h2><span id='topic+ufc.plots'></span>

<h3>Description</h3>

<p>These are a subset of the plot measurement data from the
Upper Flat Creek unit of the University of Idaho Experimental
Forest, which was measured in 1991. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ufc.plots)</code></pre>


<h3>Format</h3>

<p>A data frame with 144 observations on the following 6 variables.
</p>

<dl>
<dt>plot</dt><dd><p>plot label</p>
</dd>
<dt>north.n</dt><dd><p>northerly plot count</p>
</dd>
<dt>east.n</dt><dd><p>easterly plot count</p>
</dd>
<dt>north</dt><dd><p>northerly coordinate</p>
</dd>
<dt>east</dt><dd><p>easterly coordinate</p>
</dd>
<dt>vol.m3.ha</dt><dd><p>total above-ground merchantable volume, in
cubic metres per hectare.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data are provided courtesy of Harold Osborne and Ross
Appelgren of the University of Idaho Experimental Forest. 
</p>


<h3>References</h3>

<p>Jones, O.D., R. Maillardet, and A.P. Robinson.  2009. An Introduction
to Scientific Programming and Simulation, Using R.  Chapman And Hall/CRC.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ufc">ufc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ufc.plots)
</code></pre>

<hr>
<h2 id='vol.m3'> Function to compute the volume of a tree bole assuming a
particular shape. </h2><span id='topic+vol.m3'></span>

<h3>Description</h3>

<p>This function computes the volume of a tree bole given its basal
diameter and length, assuming that the bole is a frustum of a
geometric solid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol.m3(dbh.cm, height.m, multiplier = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol.m3_+3A_dbh.cm">dbh.cm</code></td>
<td>
<p> basal diameter in cm. </p>
</td></tr>
<tr><td><code id="vol.m3_+3A_height.m">height.m</code></td>
<td>
<p> height in m. </p>
</td></tr>
<tr><td><code id="vol.m3_+3A_multiplier">multiplier</code></td>
<td>
<p> shape, expressed as a multiplier. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Commonly-used shapes are:
</p>

<ul>
<li><p>1/3 conoid
</p>
</li>
<li><p>1/2 second-degree parabaloid
</p>
</li>
<li><p>1 cylinder
</p>
</li></ul>



<h3>Value</h3>

<p>The volume is returned, in units of cubic metres.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vol.m3(30, 30)
vol.m3(30, 30, 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
