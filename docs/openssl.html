<!DOCTYPE html><html><head><title>Help for package openssl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {openssl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#openssl'><p>Toolkit for Encryption, Signatures and Certificates based on OpenSSL</p></a></li>
<li><a href='#aes_cbc'><p>Symmetric AES encryption</p></a></li>
<li><a href='#base64_encode'><p>Encode and decode base64</p></a></li>
<li><a href='#bcrypt_pbkdf'><p>Bcrypt PWKDF</p></a></li>
<li><a href='#bignum'><p>Big number arithmetic</p></a></li>
<li><a href='#cert_verify'><p>X509 certificates</p></a></li>
<li><a href='#curve25519'><p>Curve25519</p></a></li>
<li><a href='#ec_dh'><p>Diffie-Hellman Key Agreement</p></a></li>
<li><a href='#encrypt_envelope'><p>Envelope encryption</p></a></li>
<li><a href='#fingerprint'><p>OpenSSH fingerprint</p></a></li>
<li><a href='#hashing'><p>Vectorized hash/hmac functions</p></a></li>
<li><a href='#keygen'><p>Generate Key pair</p></a></li>
<li><a href='#my_key'><p>Default key</p></a></li>
<li><a href='#openssl_config'><p>OpenSSL Configuration Info</p></a></li>
<li><a href='#pkcs7_encrypt'><p>Encrypt/decrypt pkcs7 messages</p></a></li>
<li><a href='#rand_bytes'><p>Generate random bytes and numbers with OpenSSL</p></a></li>
<li><a href='#read_key'><p>Parsing keys and certificates</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rsa_encrypt'><p>Low-level RSA encryption</p></a></li>
<li><a href='#signature_create'><p>Signatures</p></a></li>
<li><a href='#ssl_ctx'><p>Hooks to manipulate the SSL context for curl requests</p></a></li>
<li><a href='#write_p12'><p>PKCS7 / PKCS12 bundles</p></a></li>
<li><a href='#write_pem'><p>Export key or certificate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Toolkit for Encryption, Signatures and Certificates Based on
OpenSSL</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Bindings to OpenSSL libssl and libcrypto, plus custom SSH key parsers.
    Supports RSA, DSA and EC curves P-256, P-384, P-521, and curve25519. Cryptographic
    signatures can either be created and verified manually or via x509 certificates. 
    AES can be used in cbc, ctr or gcm mode for symmetric encryption; RSA for asymmetric
    (public key) encryption or EC for Diffie Hellman. High-level envelope functions 
    combine RSA and AES for encrypting arbitrary sized data. Other utilities include key
    generators, hash functions (md5, sha1, sha256, etc), base64 encoder, a secure random
    number generator, and 'bignum' math methods for manually performing crypto 
    calculations on large multibyte integers.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jeroen.r-universe.dev/openssl">https://jeroen.r-universe.dev/openssl</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jeroen/openssl/issues">https://github.com/jeroen/openssl/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>OpenSSL &gt;= 1.0.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>askpass</td>
</tr>
<tr>
<td>Suggests:</td>
<td>curl, testthat (&ge; 2.1.0), digest, knitr, rmarkdown,
jsonlite, jose, sodium</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-25 17:30:46 UTC; jeroen</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeroen Ooms <a href="https://orcid.org/0000-0002-4035-0289"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Oliver Keyes [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeroen Ooms &lt;jeroen@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-25 19:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='openssl'>Toolkit for Encryption, Signatures and Certificates based on OpenSSL</h2><span id='topic+openssl'></span><span id='topic+openssl-package'></span>

<h3>Description</h3>

<p>Bindings to OpenSSL libssl and libcrypto, plus custom SSH <a href="#topic+read_key">pubkey</a>
parsers. Supports RSA, DSA and NIST curves P-256, P-384 and P-521. Cryptographic
<a href="#topic+signatures">signatures</a> can either be created and verified
manually or via x509 <a href="#topic+certificates">certificates</a>. The
<a href="#topic+aes_cbc">AES block cipher</a> is used in CBC mode for symmetric
encryption; RSA for <a href="#topic+rsa_encrypt">asymmetric (public key)</a>
encryption. High-level <a href="#topic+encrypt_envelope">envelope</a> methods
combine RSA and AES for encrypting arbitrary sized data. Other utilities include
<a href="#topic+keygen">key generators</a>, hash functions (<code><a href="#topic+hash">md5()</a></code>,
<code><a href="#topic+hash">sha1()</a></code>, <code><a href="#topic+hash">sha256()</a></code>, etc),
<code><a href="#topic+base64_encode">base64()</a></code> encoder, a secure <a href="#topic+rand_bytes">random number generator</a>,
and <code><a href="#topic+bignum">bignum()</a></code> math methods for manually performing crypto
calculations on large multibyte integers.
</p>


<h3>Author(s)</h3>

<p>Jeroen Ooms, Oliver Keyes
</p>

<hr>
<h2 id='aes_cbc'>Symmetric AES encryption</h2><span id='topic+aes_cbc'></span><span id='topic+aes_ctr_encrypt'></span><span id='topic+aes_ctr_decrypt'></span><span id='topic+aes_cbc_encrypt'></span><span id='topic+aes_cbc_decrypt'></span><span id='topic+aes_gcm_encrypt'></span><span id='topic+aes_gcm_decrypt'></span><span id='topic+aes_keygen'></span>

<h3>Description</h3>

<p>Low-level symmetric encryption/decryption using the AES block cipher in CBC mode.
The key is a raw vector, for example a hash of some secret. When no shared
secret is available, a random key can be used which is exchanged via an
asymmetric protocol such as RSA. See <code><a href="#topic+rsa_encrypt">rsa_encrypt()</a></code> for a worked example
or <code><a href="#topic+encrypt_envelope">encrypt_envelope()</a></code> for a high-level wrapper combining AES and RSA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aes_ctr_encrypt(data, key, iv = rand_bytes(16))

aes_ctr_decrypt(data, key, iv = attr(data, "iv"))

aes_cbc_encrypt(data, key, iv = rand_bytes(16))

aes_cbc_decrypt(data, key, iv = attr(data, "iv"))

aes_gcm_encrypt(data, key, iv = rand_bytes(12))

aes_gcm_decrypt(data, key, iv = attr(data, "iv"))

aes_keygen(length = 16)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aes_cbc_+3A_data">data</code></td>
<td>
<p>raw vector or path to file with data to encrypt or decrypt</p>
</td></tr>
<tr><td><code id="aes_cbc_+3A_key">key</code></td>
<td>
<p>raw vector of length 16, 24 or 32, e.g. the hash of a shared secret</p>
</td></tr>
<tr><td><code id="aes_cbc_+3A_iv">iv</code></td>
<td>
<p>raw vector of length 16 (aes block size) or NULL. The initialization vector
is not secret but should be random</p>
</td></tr>
<tr><td><code id="aes_cbc_+3A_length">length</code></td>
<td>
<p>how many bytes to generate. Usually 16 (128-bit) or 12 (92-bit) for <code>aes_gcm</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># aes-256 requires 32 byte key
passphrase &lt;- charToRaw("This is super secret")
key &lt;- sha256(passphrase)

# symmetric encryption uses same key for decryption
x &lt;- serialize(iris, NULL)
y &lt;- aes_cbc_encrypt(x, key = key)
x2 &lt;- aes_cbc_decrypt(y, key = key)
stopifnot(identical(x, x2))
</code></pre>

<hr>
<h2 id='base64_encode'>Encode and decode base64</h2><span id='topic+base64_encode'></span><span id='topic+base64_decode'></span>

<h3>Description</h3>

<p>Encode and decode binary data into a base64 string. Character vectors are
automatically collapsed into a single string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base64_encode(bin, linebreaks = FALSE)

base64_decode(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base64_encode_+3A_bin">bin</code></td>
<td>
<p>raw or character vector with data to encode into base64</p>
</td></tr>
<tr><td><code id="base64_encode_+3A_linebreaks">linebreaks</code></td>
<td>
<p>insert linebreaks in the base64 message to make it more readable</p>
</td></tr>
<tr><td><code id="base64_encode_+3A_text">text</code></td>
<td>
<p>string with base64 data to decode</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- charToRaw("foo = bar + 5")
message &lt;- base64_encode(input)
output &lt;- base64_decode(message)
identical(output, input)
</code></pre>

<hr>
<h2 id='bcrypt_pbkdf'>Bcrypt PWKDF</h2><span id='topic+bcrypt_pbkdf'></span>

<h3>Description</h3>

<p>Password based key derivation function with bcrypt. This is not
part of openssl. It is needed to parse private key files which are
encoded in the <a href="https://cvsweb.openbsd.org/src/usr.bin/ssh/PROTOCOL.key?annotate=HEAD">new openssh format</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcrypt_pbkdf(password, salt, rounds = 16L, size = 32L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcrypt_pbkdf_+3A_password">password</code></td>
<td>
<p>string or raw vector with password</p>
</td></tr>
<tr><td><code id="bcrypt_pbkdf_+3A_salt">salt</code></td>
<td>
<p>raw vector with (usually 16) bytes</p>
</td></tr>
<tr><td><code id="bcrypt_pbkdf_+3A_rounds">rounds</code></td>
<td>
<p>number of hashing rounds</p>
</td></tr>
<tr><td><code id="bcrypt_pbkdf_+3A_size">size</code></td>
<td>
<p>desired length of the output key</p>
</td></tr>
</table>

<hr>
<h2 id='bignum'>Big number arithmetic</h2><span id='topic+bignum'></span><span id='topic+bignum_mod_exp'></span><span id='topic+bignum_mod_inv'></span>

<h3>Description</h3>

<p>Basic operations for working with large integers. The <code>bignum</code>
function converts a positive integer, string or raw vector into a bignum type.
All basic <a href="base.html#topic+Arithmetic">Arithmetic</a> and <a href="base.html#topic+Comparison">Comparison</a> operators such as
<code>+</code>, <code>-</code>, <code>*</code>, <code>^</code>, <code>%%</code>, <code>%/%</code>, <code>==</code>,
<code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> are implemented for
bignum objects. The
<a href="https://en.wikipedia.org/wiki/Modular_exponentiation">Modular exponent</a>
(<code>a^b %% m</code>) can be calculated using <code><a href="#topic+bignum_mod_exp">bignum_mod_exp()</a></code>
when <code>b</code> is too large for calculating <code>a^b</code> directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bignum(x, hex = FALSE)

bignum_mod_exp(a, b, m)

bignum_mod_inv(a, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bignum_+3A_x">x</code></td>
<td>
<p>an integer, string (hex or dec) or raw vector</p>
</td></tr>
<tr><td><code id="bignum_+3A_hex">hex</code></td>
<td>
<p>set to TRUE to parse strings as hex rather than decimal notation</p>
</td></tr>
<tr><td><code id="bignum_+3A_a">a</code></td>
<td>
<p>bignum value for <code>(a^b %% m)</code></p>
</td></tr>
<tr><td><code id="bignum_+3A_b">b</code></td>
<td>
<p>bignum value for <code>(a^b %% m)</code></p>
</td></tr>
<tr><td><code id="bignum_+3A_m">m</code></td>
<td>
<p>bignum value for <code>(a^b %% m)</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># create a bignum
x &lt;- bignum(123L)
y &lt;- bignum("123456789123456789")
z &lt;- bignum("D41D8CD98F00B204E9800998ECF8427E", hex = TRUE)

# Basic arithmetic
div &lt;- z %/% y
mod &lt;- z %% y
z2 &lt;- div * y + mod
stopifnot(z2 == z)
stopifnot(div &lt; z)
</code></pre>

<hr>
<h2 id='cert_verify'>X509 certificates</h2><span id='topic+cert_verify'></span><span id='topic+certificates'></span><span id='topic+download_ssl_cert'></span><span id='topic+ca_bundle'></span>

<h3>Description</h3>

<p>Read, download, analyze and verify X.509 certificates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cert_verify(cert, root = ca_bundle())

download_ssl_cert(host = "localhost", port = 443, ipv4_only = FALSE)

ca_bundle()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cert_verify_+3A_cert">cert</code></td>
<td>
<p>certificate (or certificate-chain) to be verified. Must be cert or list or path.</p>
</td></tr>
<tr><td><code id="cert_verify_+3A_root">root</code></td>
<td>
<p>trusted pubkey or certificate(s) e.g. CA bundle.</p>
</td></tr>
<tr><td><code id="cert_verify_+3A_host">host</code></td>
<td>
<p>string: hostname of the server to connect to</p>
</td></tr>
<tr><td><code id="cert_verify_+3A_port">port</code></td>
<td>
<p>string or integer: port or protocol to use, e.g: <code>443</code> or <code>"https"</code></p>
</td></tr>
<tr><td><code id="cert_verify_+3A_ipv4_only">ipv4_only</code></td>
<td>
<p>do not use IPv6 connections</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+read_cert">read_cert</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Verify the r-project HTTPS cert
chain &lt;- download_ssl_cert("cran.r-project.org", 443)
print(chain)
cert_data &lt;- as.list(chain[[1]])
print(cert_data$pubkey)
print(cert_data$alt_names)
cert_verify(chain, ca_bundle())

# Write cert in PEM format
cat(write_pem(chain[[1]]))

</code></pre>

<hr>
<h2 id='curve25519'>Curve25519</h2><span id='topic+curve25519'></span><span id='topic+read_ed25519_key'></span><span id='topic+read_ed25519_pubkey'></span><span id='topic+read_x25519_key'></span><span id='topic+read_x25519_pubkey'></span><span id='topic+ed25519_sign'></span><span id='topic+ed25519_verify'></span><span id='topic+x25519_diffie_hellman'></span>

<h3>Description</h3>

<p>Curve25519 is a recently added low-level algorithm that can be used both for
diffie-hellman (called X25519) and for signatures (called ED25519). Note that
these functions are only available when building against version 1.1.1 or
newer of the openssl library. The same functions are also available in the
sodium R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ed25519_key(x)

read_ed25519_pubkey(x)

read_x25519_key(x)

read_x25519_pubkey(x)

ed25519_sign(data, key)

ed25519_verify(data, sig, pubkey)

x25519_diffie_hellman(key, pubkey)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve25519_+3A_x">x</code></td>
<td>
<p>a 32 byte raw vector with (pub)key data</p>
</td></tr>
<tr><td><code id="curve25519_+3A_data">data</code></td>
<td>
<p>raw vector with data to sign or verify</p>
</td></tr>
<tr><td><code id="curve25519_+3A_key">key</code></td>
<td>
<p>private key as returned by <code>read_ed25519_key</code> or <code>ed25519_keygen</code></p>
</td></tr>
<tr><td><code id="curve25519_+3A_sig">sig</code></td>
<td>
<p>raw vector of length 64 with signature as returned by <code>ed25519_sign</code></p>
</td></tr>
<tr><td><code id="curve25519_+3A_pubkey">pubkey</code></td>
<td>
<p>public key as returned by <code>read_ed25519_pubkey</code> or <code>key$pubkey</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a keypair
if(openssl_config()$x25519){
key &lt;- ed25519_keygen()
pubkey &lt;- as.list(key)$pubkey

# Sign message
msg &lt;- serialize(iris, NULL)
sig &lt;- ed25519_sign(msg, key)

# Verify the signature
ed25519_verify(msg, sig, pubkey)

# Diffie Hellman example:
key1 &lt;- x25519_keygen()
key2 &lt;- x25519_keygen()

# Both parties can derive the same secret
x25519_diffie_hellman(key1, key2$pubkey)
x25519_diffie_hellman(key2, key1$pubkey)

# Import/export sodium keys
rawkey &lt;- sodium::sig_keygen()
rawpubkey &lt;- sodium::sig_pubkey(rawkey)
key &lt;- read_ed25519_key(rawkey)
pubkey &lt;- read_ed25519_pubkey(rawpubkey)

# To get the raw key data back for use in sodium
as.list(key)$data
as.list(pubkey)$data
}
</code></pre>

<hr>
<h2 id='ec_dh'>Diffie-Hellman Key Agreement</h2><span id='topic+ec_dh'></span>

<h3>Description</h3>

<p>Key agreement is one-step method of creating a shared secret between two
peers. Both peers can independently derive the joined secret by combining
his or her private key with the public key from the peer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_dh(key = my_key(), peerkey, password = askpass)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_dh_+3A_key">key</code></td>
<td>
<p>your own private key</p>
</td></tr>
<tr><td><code id="ec_dh_+3A_peerkey">peerkey</code></td>
<td>
<p>the public key from your peer</p>
</td></tr>
<tr><td><code id="ec_dh_+3A_password">password</code></td>
<td>
<p>passed to <a href="#topic+read_key">read_key</a> for reading protected private keys</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently only Elliptic Curve Diffie Hellman (ECDH) is implemented.
</p>


<h3>References</h3>

<p><a href="https://wiki.openssl.org/index.php/EVP_Key_Agreement">https://wiki.openssl.org/index.php/EVP_Key_Agreement</a>,
<a href="https://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman">https://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Need two EC keypairs from the same curve
alice_key &lt;- ec_keygen("P-521")
bob_key &lt;- ec_keygen("P-521")

# Derive public keys
alice_pub &lt;- as.list(alice_key)$pubkey
bob_pub &lt;- as.list(bob_key)$pubkey

# Both peers can derive the (same) shared secret via each other's pubkey
ec_dh(alice_key, bob_pub)
ec_dh(bob_key, alice_pub)

## End(Not run)
</code></pre>

<hr>
<h2 id='encrypt_envelope'>Envelope encryption</h2><span id='topic+encrypt_envelope'></span><span id='topic+envelope'></span><span id='topic+decrypt_envelope'></span>

<h3>Description</h3>

<p>An <a href="https://wiki.openssl.org/index.php/EVP_Asymmetric_Encryption_and_Decryption_of_an_Envelope">envelope</a>
contains ciphertext along with an encrypted session key and optionally and initialization
vector. The <code><a href="#topic+encrypt_envelope">encrypt_envelope()</a></code> generates a random IV and session-key which is
used to encrypt the <code>data</code> with <code><a href="#topic+aes_cbc">AES()</a></code> stream cipher. The
session key itself is encrypted using the given RSA key (see <code><a href="#topic+rsa_encrypt">rsa_encrypt()</a></code>) and
stored or sent along with the encrypted data. Each of these outputs is required to decrypt
the data with the corresponding private key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encrypt_envelope(data, pubkey = my_pubkey())

decrypt_envelope(data, iv, session, key = my_key(), password)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encrypt_envelope_+3A_data">data</code></td>
<td>
<p>raw data vector or file path for message to be signed.
If <code>hash == NULL</code> then <code>data</code> must be a hash string or raw vector.</p>
</td></tr>
<tr><td><code id="encrypt_envelope_+3A_pubkey">pubkey</code></td>
<td>
<p>public key or file path. See <code><a href="#topic+read_pubkey">read_pubkey()</a></code>.</p>
</td></tr>
<tr><td><code id="encrypt_envelope_+3A_iv">iv</code></td>
<td>
<p>16 byte raw vector returned by <code>encrypt_envelope</code>.</p>
</td></tr>
<tr><td><code id="encrypt_envelope_+3A_session">session</code></td>
<td>
<p>raw vector with encrypted session key as returned by <code>encrypt_envelope</code>.</p>
</td></tr>
<tr><td><code id="encrypt_envelope_+3A_key">key</code></td>
<td>
<p>private key or file path. See <code><a href="#topic+read_key">read_key()</a></code>.</p>
</td></tr>
<tr><td><code id="encrypt_envelope_+3A_password">password</code></td>
<td>
<p>string or a function to read protected keys. See <code><a href="#topic+read_key">read_key()</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://wiki.openssl.org/index.php/EVP_Asymmetric_Encryption_and_Decryption_of_an_Envelope">https://wiki.openssl.org/index.php/EVP_Asymmetric_Encryption_and_Decryption_of_an_Envelope</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Requires RSA key
key &lt;- rsa_keygen()
pubkey &lt;- key$pubkey
msg &lt;- serialize(iris, NULL)

# Encrypt
out &lt;- encrypt_envelope(msg, pubkey)
str(out)

# Decrypt
orig &lt;- decrypt_envelope(out$data, out$iv, out$session, key)
stopifnot(identical(msg, orig))
</code></pre>

<hr>
<h2 id='fingerprint'>OpenSSH fingerprint</h2><span id='topic+fingerprint'></span>

<h3>Description</h3>

<p>Calculates the OpenSSH fingerprint of a public key. This value should
match what you get to see when connecting with SSH to a server. Note
that some other systems might use a different algorithm to derive a
(different) fingerprint for the same keypair.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fingerprint(key, hashfun = sha256)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fingerprint_+3A_key">key</code></td>
<td>
<p>a public or private key</p>
</td></tr>
<tr><td><code id="fingerprint_+3A_hashfun">hashfun</code></td>
<td>
<p>which hash function to use to calculate the fingerprint</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mykey &lt;- rsa_keygen()
pubkey &lt;- as.list(mykey)$pubkey
fingerprint(mykey)
fingerprint(pubkey)

# Some systems use other hash functions
fingerprint(pubkey, sha1)
fingerprint(pubkey, sha256)

# Other key types
fingerprint(dsa_keygen())
</code></pre>

<hr>
<h2 id='hashing'>Vectorized hash/hmac functions</h2><span id='topic+hashing'></span><span id='topic+sha1'></span><span id='topic+hash'></span><span id='topic+hmac'></span><span id='topic+mac'></span><span id='topic+sha224'></span><span id='topic+sha256'></span><span id='topic+sha384'></span><span id='topic+sha512'></span><span id='topic+sha2'></span><span id='topic+sha3'></span><span id='topic+md4'></span><span id='topic+md5'></span><span id='topic+blake2b'></span><span id='topic+blake2s'></span><span id='topic+ripemd160'></span><span id='topic+multihash'></span>

<h3>Description</h3>

<p>All hash functions either calculate a hash-digest for <code>key == NULL</code> or HMAC
(hashed message authentication code) when <code>key</code> is not <code>NULL</code>. Supported
inputs are binary (raw vector), strings (character vector) or a connection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sha1(x, key = NULL)

sha224(x, key = NULL)

sha256(x, key = NULL)

sha384(x, key = NULL)

sha512(x, key = NULL)

sha2(x, size = 256, key = NULL)

sha3(x, size = 256, key = NULL)

md4(x, key = NULL)

md5(x, key = NULL)

blake2b(x, key = NULL)

blake2s(x, key = NULL)

ripemd160(x, key = NULL)

multihash(x, algos = c("md5", "sha1", "sha256", "sha384", "sha512"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hashing_+3A_x">x</code></td>
<td>
<p>character vector, raw vector or connection object.</p>
</td></tr>
<tr><td><code id="hashing_+3A_key">key</code></td>
<td>
<p>string or raw vector used as the key for HMAC hashing</p>
</td></tr>
<tr><td><code id="hashing_+3A_size">size</code></td>
<td>
<p>must be equal to 224 256 384 or 512</p>
</td></tr>
<tr><td><code id="hashing_+3A_algos">algos</code></td>
<td>
<p>string vector with names of hashing algorithms</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most efficient way to calculate hashes is by using input <a href="base.html#topic+connections">connections</a>,
such as a <a href="base.html#topic+connections">file()</a> or <a href="base.html#topic+connections">url()</a> object.
In this case the hash is calculated streamingly, using almost no memory or disk space,
regardless of the data size. When using a connection input in the <a href="#topic+multihash">multihash</a>
function, the data is only read only once while streaming to multiple hash functions
simultaneously. Therefore several hashes are calculated simultanously, without the
need to store any data or download it multiple times.
</p>
<p>Functions are vectorized for the case of character vectors: a vector with <code>n</code>
strings returns <code>n</code> hashes. When passing a connection object, the contents will
be stream-hashed which minimizes the amount of required memory. This is recommended
for hashing files from disk or network.
</p>
<p>The sha2 family of algorithms (sha224, sha256, sha384 and sha512) is generally
recommended for sensitive information. While sha1 and md5 are usually sufficient for
collision-resistant identifiers, they are no longer considered secure for cryptographic
purposes.
</p>
<p>In applications where hashes should be irreversible (such as names or passwords) it is
often recommended to use a random <em>key</em> for HMAC hashing. This prevents attacks where
we can lookup hashes of common and/or short strings. See examples. A common special case
is adding a random salt to a large number of records to test for uniqueness within the
dataset, while simultaneously rendering the results incomparable to other datasets.
</p>
<p>The <code>blake2b</code> and <code>blake2s</code> algorithms are only available if your system has
libssl 1.1 or newer.
</p>


<h3>References</h3>

<p>Digest types: <a href="https://www.openssl.org/docs/man1.1.1/man1/openssl-dgst.html">https://www.openssl.org/docs/man1.1.1/man1/openssl-dgst.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Support both strings and binary
md5(c("foo", "bar"))
md5("foo", key = "secret")

hash &lt;- md5(charToRaw("foo"))
as.character(hash, sep = ":")

# Compare to digest
digest::digest("foo", "md5", serialize = FALSE)

# Other way around
digest::digest(cars, skip = 0)
md5(serialize(cars, NULL))

# Stream-verify from connections (including files)
myfile &lt;- system.file("CITATION")
md5(file(myfile))
md5(file(myfile), key = "secret")

## Not run: check md5 from: http://cran.r-project.org/bin/windows/base/old/3.1.1/md5sum.txt
md5(url("http://cran.r-project.org/bin/windows/base/old/3.1.1/R-3.1.1-win.exe"))
## End(Not run)

# Use a salt to prevent dictionary attacks
sha1("admin") # googleable
sha1("admin", key = "random_salt_value") #not googleable

# Use a random salt to identify duplicates while anonymizing values
sha256("john") # googleable
sha256(c("john", "mary", "john"), key = "random_salt_value")
</code></pre>

<hr>
<h2 id='keygen'>Generate Key pair</h2><span id='topic+keygen'></span><span id='topic+rsa_keygen'></span><span id='topic+dsa_keygen'></span><span id='topic+ec_keygen'></span><span id='topic+x25519_keygen'></span><span id='topic+ed25519_keygen'></span>

<h3>Description</h3>

<p>The <code>keygen</code> functions generate a random private key. Use <code>as.list(key)$pubkey</code>
to derive the corresponding public key. Use <a href="#topic+write_pem">write_pem</a> to save a private key
to a file, optionally with a password.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsa_keygen(bits = 2048)

dsa_keygen(bits = 1024)

ec_keygen(curve = c("P-256", "P-384", "P-521"))

x25519_keygen()

ed25519_keygen()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keygen_+3A_bits">bits</code></td>
<td>
<p>bitsize of the generated RSA/DSA key</p>
</td></tr>
<tr><td><code id="keygen_+3A_curve">curve</code></td>
<td>
<p>which NIST curve to use</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate keypair
key &lt;- rsa_keygen()
pubkey &lt;- as.list(key)$pubkey

# Write/read the key with a passphrase
write_pem(key, "id_rsa", password = "supersecret")
read_key("id_rsa", password = "supersecret")
unlink("id_rsa")
</code></pre>

<hr>
<h2 id='my_key'>Default key</h2><span id='topic+my_key'></span><span id='topic+my_pubkey'></span>

<h3>Description</h3>

<p>The default user key can be set in the <code>USER_KEY</code> variable and otherwise
is <code style="white-space: pre;">&#8288;~/.ssh/id_rsa&#8288;</code>. Note that on Windows we treat <code>~</code> as the windows user
home (and not the documents folder).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my_key()

my_pubkey()
</code></pre>


<h3>Details</h3>

<p>The <code>my_pubkey()</code> function looks for the public key by appending <code>.pub</code>
to the above key path. If this file does not exist, it reads the private key file
and automatically derives the corresponding pubkey. In the latter case the user
may be prompted for a passphrase if the private key is protected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set random RSA key as default
key &lt;- rsa_keygen()
write_pem(key, tmp &lt;- tempfile(), password = "")
rm(key)
Sys.setenv("USER_KEY" = tmp)

# Check the new keys
print(my_key())
print(my_pubkey())
</code></pre>

<hr>
<h2 id='openssl_config'>OpenSSL Configuration Info</h2><span id='topic+openssl_config'></span><span id='topic+fips_mode'></span>

<h3>Description</h3>

<p>Shows libssl version and configuration information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>openssl_config()

fips_mode()
</code></pre>


<h3>Details</h3>

<p>Note that the &quot;fips&quot; flag in <code>openssl_config</code> means that FIPS is
supported, but it does not mean that it is currently enforced. If
supported, it can be enabled in several ways, such as a kernel
option, or setting an environment variable <code>OPENSSL_FORCE_FIPS_MODE=1</code>.
The <code>fips_mode()</code> function shows if FIPS is currently enforced.
</p>

<hr>
<h2 id='pkcs7_encrypt'>Encrypt/decrypt pkcs7 messages</h2><span id='topic+pkcs7_encrypt'></span><span id='topic+pkcs7_decrypt'></span>

<h3>Description</h3>

<p>Encrypt or decrypt messages using PKCS7 smime format.
Note PKCS7 only supports RSA keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkcs7_encrypt(message, cert, pem = TRUE)

pkcs7_decrypt(input, key, der = is.raw(input))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkcs7_encrypt_+3A_message">message</code></td>
<td>
<p>text or raw vector with data to encrypt</p>
</td></tr>
<tr><td><code id="pkcs7_encrypt_+3A_cert">cert</code></td>
<td>
<p>the certificate with public key to use for encryption</p>
</td></tr>
<tr><td><code id="pkcs7_encrypt_+3A_pem">pem</code></td>
<td>
<p>convert output pkcs7 data to PEM format</p>
</td></tr>
<tr><td><code id="pkcs7_encrypt_+3A_input">input</code></td>
<td>
<p>file path or string with PEM or raw vector with p7b data</p>
</td></tr>
<tr><td><code id="pkcs7_encrypt_+3A_key">key</code></td>
<td>
<p>private key to decrypt data</p>
</td></tr>
<tr><td><code id="pkcs7_encrypt_+3A_der">der</code></td>
<td>
<p>assume input is in DER format (rather than PEM)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+encrypt_envelope">encrypt_envelope</a>
</p>

<hr>
<h2 id='rand_bytes'>Generate random bytes and numbers with OpenSSL</h2><span id='topic+rand_bytes'></span><span id='topic+rand_num'></span>

<h3>Description</h3>

<p>this set of functions generates random bytes or numbers from OpenSSL. This
provides a cryptographically secure alternative to R's default random number generator.
<code>rand_bytes</code> generates <code>n</code> random cryptographically secure bytes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand_bytes(n = 1)

rand_num(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand_bytes_+3A_n">n</code></td>
<td>
<p>number of random bytes or numbers to generate</p>
</td></tr>
</table>


<h3>References</h3>

<p>OpenSSL manual: <a href="https://www.openssl.org/docs/man1.1.1/man3/RAND_bytes.html">https://www.openssl.org/docs/man1.1.1/man3/RAND_bytes.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rnd &lt;- rand_bytes(10)
as.numeric(rnd)
as.character(rnd)
as.logical(rawToBits(rnd))

# bytes range from 0 to 255
rnd &lt;- rand_bytes(100000)
hist(as.numeric(rnd), breaks=-1:255)

# Generate random doubles between 0 and 1
rand_num(5)

# Use CDF to map [0,1] into random draws from a distribution
x &lt;- qnorm(rand_num(1000), mean=100, sd=15)
hist(x)

y &lt;- qbinom(rand_num(1000), size=10, prob=0.3)
hist(y)
</code></pre>

<hr>
<h2 id='read_key'>Parsing keys and certificates</h2><span id='topic+read_key'></span><span id='topic+read_pubkey'></span><span id='topic+read_cert'></span><span id='topic+read_cert_bundle'></span><span id='topic+read_pem'></span>

<h3>Description</h3>

<p>The <code>read_key</code> function (private keys) and <code>read_pubkey</code> (public keys)
support both SSH pubkey format and OpenSSL PEM format (base64 data with a <code>--BEGIN</code>
and <code>---END</code> header), and automatically convert where necessary. The functions assume
a single key per file except for <code>read_cert_bundle</code> which supports PEM files
with multiple certificates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_key(file, password = askpass, der = is.raw(file))

read_pubkey(file, der = is.raw(file))

read_cert(file, der = is.raw(file))

read_cert_bundle(file)

read_pem(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_key_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data (a string for
pem/ssh format, or a raw vector in der format)</p>
</td></tr>
<tr><td><code id="read_key_+3A_password">password</code></td>
<td>
<p>A string or callback function to read protected keys</p>
</td></tr>
<tr><td><code id="read_key_+3A_der">der</code></td>
<td>
<p>set to <code>TRUE</code> if <code>file</code> is in binary DER format</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most versions of OpenSSL support at least RSA, DSA and ECDSA keys. Certificates must
conform to the X509 standard.
</p>
<p>The <code>password</code> argument is needed when reading keys that are protected with a
passphrase. It can either be a string containing the passphrase, or a custom callback
function that will be called by OpenSSL to read the passphrase. The function should
take one argument (a string with a message) and return a string. The default is to
use <code>readline</code> which will prompt the user in an interactive R session.
</p>


<h3>Value</h3>

<p>An object of class <code>cert</code>, <code>key</code> or <code>pubkey</code> which holds the data
in binary DER format and can be decomposed using <code>as.list</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+download_ssl_cert">download_ssl_cert</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: # Read private key
key &lt;- read_key("~/.ssh/id_rsa")
str(key)

# Read public key
pubkey &lt;- read_pubkey("~/.ssh/id_rsa.pub")
str(pubkey)

# Read certificates
txt &lt;- readLines("https://curl.haxx.se/ca/cacert.pem")
bundle &lt;- read_cert_bundle(txt)
print(bundle)

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+askpass'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>askpass</dt><dd><p><code><a href="askpass.html#topic+askpass">askpass</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rsa_encrypt'>Low-level RSA encryption</h2><span id='topic+rsa_encrypt'></span><span id='topic+rsa'></span><span id='topic+encrypt'></span><span id='topic+rsa_decrypt'></span>

<h3>Description</h3>

<p>Asymmetric encryption and decryption with RSA. Because RSA can only encrypt messages
smaller than the size of the key, it is typically used only for exchanging a random
session-key. This session key is used to encipher arbitrary sized data via a stream
cipher such as <a href="#topic+aes_cbc">aes_cbc</a>. See <a href="#topic+encrypt_envelope">encrypt_envelope</a> or <a href="#topic+pkcs7_encrypt">pkcs7_encrypt</a> for a high-level
wrappers combining RSA and AES in this way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsa_encrypt(data, pubkey = my_pubkey())

rsa_decrypt(data, key = my_key(), password = askpass)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsa_encrypt_+3A_data">data</code></td>
<td>
<p>raw vector of max 245 bytes (for 2048 bit keys) with data to encrypt/decrypt</p>
</td></tr>
<tr><td><code id="rsa_encrypt_+3A_pubkey">pubkey</code></td>
<td>
<p>public key or file path. See <code><a href="#topic+read_pubkey">read_pubkey()</a></code>.</p>
</td></tr>
<tr><td><code id="rsa_encrypt_+3A_key">key</code></td>
<td>
<p>private key or file path. See <code><a href="#topic+read_key">read_key()</a></code>.</p>
</td></tr>
<tr><td><code id="rsa_encrypt_+3A_password">password</code></td>
<td>
<p>string or a function to read protected keys. See <code><a href="#topic+read_key">read_key()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate test keys
key &lt;- rsa_keygen()
pubkey &lt;- key$pubkey

# Encrypt data with AES
tempkey &lt;- rand_bytes(32)
iv &lt;- rand_bytes(16)
blob &lt;- aes_cbc_encrypt(system.file("CITATION"), tempkey, iv = iv)

# Encrypt tempkey using receivers public RSA key
ciphertext &lt;- rsa_encrypt(tempkey, pubkey)

# Receiver decrypts tempkey from private RSA key
tempkey &lt;- rsa_decrypt(ciphertext, key)
message &lt;- aes_cbc_decrypt(blob, tempkey, iv)
out &lt;- rawToChar(message)
</code></pre>

<hr>
<h2 id='signature_create'>Signatures</h2><span id='topic+signature_create'></span><span id='topic+signatures'></span><span id='topic+signature_verify'></span><span id='topic+ecdsa_parse'></span><span id='topic+ecdsa_write'></span>

<h3>Description</h3>

<p>Sign and verify a message digest. RSA supports both MD5 and SHA signatures
whereas DSA and EC keys only support SHA. ED25591 can sign any payload so you can
set <code>hash</code> to <code>NULL</code> to sign the raw input data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signature_create(data, hash = sha1, key = my_key(), password = askpass)

signature_verify(data, sig, hash = sha1, pubkey = my_pubkey())

ecdsa_parse(sig)

ecdsa_write(r, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signature_create_+3A_data">data</code></td>
<td>
<p>raw data vector or file path for message to be signed.
If <code>hash == NULL</code> then <code>data</code> must be a hash string or raw vector.</p>
</td></tr>
<tr><td><code id="signature_create_+3A_hash">hash</code></td>
<td>
<p>the digest function to use. Must be one of <code><a href="#topic+md5">md5()</a></code>,
<code><a href="#topic+sha1">sha1()</a></code>, <code><a href="#topic+sha256">sha256()</a></code>, <code><a href="#topic+sha512">sha512()</a></code> or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="signature_create_+3A_key">key</code></td>
<td>
<p>private key or file path. See <code><a href="#topic+read_key">read_key()</a></code>.</p>
</td></tr>
<tr><td><code id="signature_create_+3A_password">password</code></td>
<td>
<p>string or a function to read protected keys. See <code><a href="#topic+read_key">read_key()</a></code>.</p>
</td></tr>
<tr><td><code id="signature_create_+3A_sig">sig</code></td>
<td>
<p>raw vector or file path for the signature data.</p>
</td></tr>
<tr><td><code id="signature_create_+3A_pubkey">pubkey</code></td>
<td>
<p>public key or file path. See <code><a href="#topic+read_pubkey">read_pubkey()</a></code>.</p>
</td></tr>
<tr><td><code id="signature_create_+3A_r">r</code></td>
<td>
<p>bignum value for r parameter</p>
</td></tr>
<tr><td><code id="signature_create_+3A_s">s</code></td>
<td>
<p>bignum value for s parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ecdsa_parse</code> and <code>ecdsa_write</code> functions convert (EC)DSA signatures
between the conventional DER format and the raw <code style="white-space: pre;">&#8288;(r,s)&#8288;</code> bignum pair. Most
users won't need this, it is mostly here to support the JWT format (which does not
use DER).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a keypair
key &lt;- rsa_keygen()
pubkey &lt;- key$pubkey

# Sign a file
data &lt;- system.file("DESCRIPTION")
sig &lt;- signature_create(data, key = key)
stopifnot(signature_verify(data, sig, pubkey = pubkey))

# Sign raw data
data &lt;- serialize(iris, NULL)
sig &lt;- signature_create(data, sha256, key = key)
stopifnot(signature_verify(data, sig, sha256, pubkey = pubkey))

# Sign a hash
md &lt;- md5(data)
sig &lt;- signature_create(md, hash = NULL, key = key)
stopifnot(signature_verify(md, sig, hash = NULL, pubkey = pubkey))
#
# ECDSA example
data &lt;- serialize(iris, NULL)
key &lt;- ec_keygen()
pubkey &lt;- key$pubkey
sig &lt;- signature_create(data, sha256, key = key)
stopifnot(signature_verify(data, sig, sha256, pubkey = pubkey))

# Convert signature to (r, s) parameters and then back
params &lt;- ecdsa_parse(sig)
out &lt;- ecdsa_write(params$r, params$s)
identical(sig, out)
</code></pre>

<hr>
<h2 id='ssl_ctx'>Hooks to manipulate the SSL context for curl requests</h2><span id='topic+ssl_ctx'></span><span id='topic+ssl_ctx_add_cert_to_store'></span><span id='topic+ssl_ctx_set_verify_callback'></span><span id='topic+ssl_ctx_curl_version_match'></span>

<h3>Description</h3>

<p>These functions allow for manipulating the SSL context from inside the
<a href="https://curl.se/libcurl/c/CURLOPT_SSL_CTX_FUNCTION.html">CURLOPT_SSL_CTX_FUNCTION</a>
callback using the curl R package. Note that this is not fully portable and will
only work on installations that use matching versions of libssl (see details).
It is recommended to only use this locally and if what you need cannot be
accomplished using standard libcurl TLS options, e.g. those listed in
<code>curl::curl_options('ssl')</code> or <code>curl::curl_options('tls')</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssl_ctx_add_cert_to_store(ssl_ctx, cert)

ssl_ctx_set_verify_callback(ssl_ctx, cb)

ssl_ctx_curl_version_match()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssl_ctx_+3A_ssl_ctx">ssl_ctx</code></td>
<td>
<p>pointer object to the SSL context provided in the
ssl_ctx_function callback.</p>
</td></tr>
<tr><td><code id="ssl_ctx_+3A_cert">cert</code></td>
<td>
<p>certificate object, e.g from <a href="#topic+read_cert">read_cert</a> or <a href="#topic+download_ssl_cert">download_ssl_cert</a>.</p>
</td></tr>
<tr><td><code id="ssl_ctx_+3A_cb">cb</code></td>
<td>
<p>callback function with 1 parameter (the server certificate)
and which returns TRUE (for proceed) or FALSE (for abort).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Curl allows for setting an <a href="curl.html#topic+curl_options">option</a> called <code>ssl_ctx_function</code>:
this is a callback function that is triggered during the TLS initiation, before
any https connection has been made. This serves as a hook to let you manipulate
the TLS configuration (called <code>SSL_CTX</code> for historical reasons), in order to
control how to curl will validate the authenticity of server certificates for
upcoming TLS connections.
</p>
<p>Currently we provide 2 such functions: <a href="#topic+ssl_ctx_add_cert_to_store">ssl_ctx_add_cert_to_store</a> injects a
custom certificate into the trust-store of the current TLS connection. But
most flexibility is provided via <a href="#topic+ssl_ctx_set_verify_callback">ssl_ctx_set_verify_callback</a> which allows
you to override the function that is used by validate if a server certificate
should be trusted. The callback will receive one argument <code>cert</code> and has to
return <code>TRUE</code> or <code>FALSE</code> to decide if the cert should be trusted.
</p>
<p>By default libcurl re-uses connections, hence the cert validation is only
performed in the first request to a given host. Subsequent requests use the
already established TLS connection. For testing, it can be useful to set
<code>forbid_reuse</code> in order to make a new connection for each request, as done
in the examples below.
</p>


<h3>System compatibility</h3>

<p>Passing the SSL_CTX between the curl and openssl R packages only works if they
are linked to the same version of libssl. Use <a href="#topic+ssl_ctx_curl_version_match">ssl_ctx_curl_version_match</a>
to test if this is the case. On Debian / Ubuntu you need to build the R curl
package against <code>libcurl4-openssl-dev</code>, which is usually the case. On Windows
you would need to set <code>CURL_SSL_BACKEND=openssl</code> in your <code style="white-space: pre;">&#8288;~/.Renviron&#8288;</code> file.
On MacOS things are complicated because it uses LibreSSL instead of OpenSSL
by default. You can make it work by compiling the curl R package from source
against the homebrew version of curl and then then set <code>CURL_SSL_BACKEND=openssl</code>
in your <code style="white-space: pre;">&#8288;~/.Renviron&#8288;</code> file. If your curl and openssl R packages use different
versions of libssl, the examples may segfault due to ABI incompatibility of the
SSL_CTX structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example 1: accept your local snakeoil https cert
mycert &lt;- openssl::download_ssl_cert('localhost')[[1]]

# Setup the callback
h &lt;- curl::new_handle(ssl_ctx_function = function(ssl_ctx){
  ssl_ctx_add_cert_to_store(ssl_ctx, mycert)
}, verbose = TRUE, forbid_reuse = TRUE)

# Perform the request
req &lt;- curl::curl_fetch_memory('https://localhost', handle = h)

# Example 2 using a custom verify function
verify_cb &lt;- function(cert){
  id &lt;- cert$pubkey$fingerprint
  cat("Server cert from:", as.character(id), "\n")
  TRUE # always accept cert
}

h &lt;- curl::new_handle(ssl_ctx_function = function(ssl_ctx){
  ssl_ctx_set_verify_callback(ssl_ctx, verify_cb)
}, verbose = TRUE, forbid_reuse = TRUE)

# Perform the request
req &lt;- curl::curl_fetch_memory('https://localhost', handle = h)

## End(Not run)
</code></pre>

<hr>
<h2 id='write_p12'>PKCS7 / PKCS12 bundles</h2><span id='topic+write_p12'></span><span id='topic+pkcs12'></span><span id='topic+pfx'></span><span id='topic+write_p7b'></span><span id='topic+read_p12'></span><span id='topic+read_p7b'></span>

<h3>Description</h3>

<p>PKCS7 and PKCS12 are container formats for storing multiple certificates and/or keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_p12(
  key = NULL,
  cert = NULL,
  ca = NULL,
  name = NULL,
  password = NULL,
  path = NULL
)

write_p7b(ca, path = NULL)

read_p12(file, password = askpass)

read_p7b(file, der = is.raw(file))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_p12_+3A_key">key</code></td>
<td>
<p>a private key</p>
</td></tr>
<tr><td><code id="write_p12_+3A_cert">cert</code></td>
<td>
<p>certificate that matches <code>key</code></p>
</td></tr>
<tr><td><code id="write_p12_+3A_ca">ca</code></td>
<td>
<p>a list of certificates (the CA chain)</p>
</td></tr>
<tr><td><code id="write_p12_+3A_name">name</code></td>
<td>
<p>a friendly title for the bundle</p>
</td></tr>
<tr><td><code id="write_p12_+3A_password">password</code></td>
<td>
<p>string or function to set/get the password.</p>
</td></tr>
<tr><td><code id="write_p12_+3A_path">path</code></td>
<td>
<p>a file where to write the output to. If <code>NULL</code> the output is returned
as a raw vector.</p>
</td></tr>
<tr><td><code id="write_p12_+3A_file">file</code></td>
<td>
<p>path or raw vector with binary PKCS12 data to parse</p>
</td></tr>
<tr><td><code id="write_p12_+3A_der">der</code></td>
<td>
<p>set to TRUE for binary files and FALSE for PEM files</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PKCS#7 or P7B format is a container for one or more certificates. It can either
be stored in binary form or in a PEM file. P7B files are typically used to import
and export public certificates.
</p>
<p>The PKCS#12 or PFX format is a binary-only format for storing the server certificate,
any intermediate certificates, and the private key into a single encryptable file.
PFX files are usually found with the extensions .pfx and .p12. PFX files are typically
used to import and export certificates with their private keys.
</p>
<p>The PKCS formats also allow for including signatures and CRLs but this is quite rare
and these are currently ignored.
</p>

<hr>
<h2 id='write_pem'>Export key or certificate</h2><span id='topic+write_pem'></span><span id='topic+write_der'></span><span id='topic+write_pkcs1'></span><span id='topic+write_ssh'></span><span id='topic+write_openssh_pem'></span>

<h3>Description</h3>

<p>The <code>write_pem</code> functions exports a key or certificate to the standard
base64 PEM format. For private keys it is possible to set a password.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_pem(x, path = NULL, password = NULL)

write_der(x, path = NULL)

write_pkcs1(x, path = NULL, password = NULL)

write_ssh(pubkey, path = NULL)

write_openssh_pem(key, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_pem_+3A_x">x</code></td>
<td>
<p>a public/private key or certificate object</p>
</td></tr>
<tr><td><code id="write_pem_+3A_path">path</code></td>
<td>
<p>file to write to. If <code>NULL</code> it returns the output as a string.</p>
</td></tr>
<tr><td><code id="write_pem_+3A_password">password</code></td>
<td>
<p>string or callback function to set password (only applicable for
private keys).</p>
</td></tr>
<tr><td><code id="write_pem_+3A_pubkey">pubkey</code></td>
<td>
<p>a public key</p>
</td></tr>
<tr><td><code id="write_pem_+3A_key">key</code></td>
<td>
<p>a private key</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pkcs1 format is the old legacy format used by OpenSSH. PKCS1 does not
support the new ed25519 keys, for which you need <code>write_openssh_pem</code>.
For non-ssh clients, we recommend to simply use <code>write_pem</code> to export keys
and certs into the recommended formats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate RSA keypair
key &lt;- rsa_keygen()
pubkey &lt;- key$pubkey

# Write to output formats
write_ssh(pubkey)
write_pem(pubkey)
write_pem(key, password = "super secret")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
