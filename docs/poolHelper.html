<!DOCTYPE html><html><head><title>Help for package poolHelper</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {poolHelper}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculatePi'><p>Calculate population frequency at each SNP</p></a></li>
<li><a href='#computeReference'><p>Compute the number of reference reads over a matrix</p></a></li>
<li><a href='#errorHet'><p>Average absolute difference between expected heterozygosity</p></a></li>
<li><a href='#Expected_Het'><p>Compute expected heterozygosity within a population</p></a></li>
<li><a href='#ExpHet_site'><p>Compute expected heterozygosity per site</p></a></li>
<li><a href='#filterMinor'><p>Filter sites according to a minor-allele reads threshold</p></a></li>
<li><a href='#filterPool'><p>Filter Pool-seq data according to a minor-allele reads threshold</p></a></li>
<li><a href='#findMinor'><p>Define major and minor alleles</p></a></li>
<li><a href='#forcePool'><p>Randomly select the required number of loci from the pooled sequencing data</p></a></li>
<li><a href='#GetGenotypes'><p>Create genotypes from a output with haplotypes</p></a></li>
<li><a href='#getNumReadsR_vector'><p>Compute the number of reference reads</p></a></li>
<li><a href='#hap2geno'><p>Convert haplotypes to genotypes</p></a></li>
<li><a href='#haplo.fix'><p>Create invariable sites</p></a></li>
<li><a href='#Ifreqs'><p>Compute allele frequencies from genotypes</p></a></li>
<li><a href='#indProbs'><p>Probability of contribution of each individual</p></a></li>
<li><a href='#indReads'><p>Reads contributed by each individual</p></a></li>
<li><a href='#maeFreqs'><p>Average absolute difference between allele frequencies computed from</p>
genotypes and from Pool-seq data</a></li>
<li><a href='#maeHet'><p>Average absolute difference between the expected heterozygosity computed from</p>
genotypes and from Pool-seq data</a></li>
<li><a href='#maePool'><p>Average absolute difference between allele frequencies</p></a></li>
<li><a href='#mymae'><p>Average absolute difference between allele frequencies computed from</p>
genotypes supplied by the user and from Pool-seq data</a></li>
<li><a href='#numberReference'><p>Compute the number of reference reads at multiple loci</p></a></li>
<li><a href='#numberReferencePop'><p>Compute the number of reference reads for multiple populations</p></a></li>
<li><a href='#Pfreqs'><p>Compute allele frequencies from pooled sequencing data</p></a></li>
<li><a href='#pool2sync'><p>Create 'synchronized' file from Pool-seq data</p></a></li>
<li><a href='#pool2vcf'><p>Create VCF file from Pool-seq data</p></a></li>
<li><a href='#poolPops'><p>Create Pooled DNA sequencing data for multiple populations</p></a></li>
<li><a href='#poolProbs'><p>Probability of contribution of each pool</p></a></li>
<li><a href='#poolReads'><p>Reads contributed by each pool</p></a></li>
<li><a href='#popReads'><p>Compute number of reads for each individual and across all sites</p></a></li>
<li><a href='#popsReads'><p>Simulate total number of reads for multiple populations</p></a></li>
<li><a href='#remove_by_reads'><p>Apply a coverage-based filter over a list</p></a></li>
<li><a href='#remove_by_reads_matrix'><p>Apply a coverage-based filter to a matrix</p></a></li>
<li><a href='#removeSites'><p>Apply a minor allele reads threshold</p></a></li>
<li><a href='#run_scrm'><p>Simulate a single population</p></a></li>
<li><a href='#simPoolseq'><p>Simulate Pool-seq data</p></a></li>
<li><a href='#simReads'><p>Simulate coverage at a single locus</p></a></li>
<li><a href='#simulateCoverage'><p>Simulate total number of reads per site</p></a></li>
<li><a href='#splitMatrix'><p>Split matrix of genotypes</p></a></li>
<li><a href='#strg2sync'><p>Create sync string for a single SNP</p></a></li>
<li><a href='#strg2vcf'><p>Create vcf string for a single SNP</p></a></li>
<li><a href='#vcfinfo'><p>Create vcf table with relevant information</p></a></li>
<li><a href='#vcfloci'><p>Create vcf string for all SNPs in multiple loci</p></a></li>
<li><a href='#vcflocus'><p>Create vcf string for all SNPs in a single locus</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simulates Pooled Sequencing Genetic Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulates pooled sequencing data under a variety of conditions. 
    Also allows for the evaluation of the average absolute difference between allele frequencies 
    computed from genotypes and those computed from pooled data. 
    Carvalho et al., (2022) &lt;<a href="https://doi.org/10.1101%2F2023.01.20.524733">doi:10.1101/2023.01.20.524733</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>MCMCpack, Metrics, scrm, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/joao-mcarvalho/poolHelper">https://github.com/joao-mcarvalho/poolHelper</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/joao-mcarvalho/poolHelper/issues">https://github.com/joao-mcarvalho/poolHelper/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-29 12:25:30 UTC; jcarvalho</td>
</tr>
<tr>
<td>Author:</td>
<td>João Carvalho <a href="https://orcid.org/0000-0002-1728-0075"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Vítor Sousa [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>João Carvalho &lt;jgcarvalho@fc.ul.pt&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-29 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculatePi'>Calculate population frequency at each SNP</h2><span id='topic+calculatePi'></span>

<h3>Description</h3>

<p>The frequency at a given SNP is calculated according to: <code>pi = c/r</code>, where c
= number of minor-allele reads and r = total number of observed reads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculatePi(listPool, nLoci)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculatePi_+3A_listpool">listPool</code></td>
<td>
<p>a list containing the &quot;minor&quot; element, representing the
number of reads with the minor-allele and the &quot;total&quot; element that contains
information about the total number of reads. The list should also contain a
&quot;major&quot; entry with the information about reads containing the major-allele.
The output of the <code>poolPops</code> function should be used as input here.</p>
</td></tr>
<tr><td><code id="calculatePi_+3A_nloci">nLoci</code></td>
<td>
<p>an integer that represents the total number of independent loci
in the dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes as input a list that contains the number of reads with
the minor allele and the number of total reads per population at a given
site. The names of the respective elements of the list should be minor and
total. It works with lists containing just one set of minor and total reads,
corresponding to a single locus, and with lists where each entry contains a
different set of minor and total number of reads, corresponding to different
loci.
</p>


<h3>Value</h3>

<p>a list with two named entries
</p>
<table>
<tr><td><code>pi</code></td>
<td>
<p>a list with the allele frequencies of each population. Each list
entry is a matrix, corresponding to a different locus. Each row of a matrix
corresponds to a different population and each column to a different site.</p>
</td></tr>
<tr><td><code>pool</code></td>
<td>
<p>a list with three different entries: major, minor and total.
This list is similar to the one obtained with the <code><a href="#topic+findMinor">findMinor</a></code>
function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coverage at 5 SNPs for two populations, assuming 20x mean coverage
reads &lt;- simulateCoverage(mean = c(20, 20), variance = c(100, 100), nSNPs = 5, nLoci = 1)

# simulate the number of reads contributed by each individual
# for each population there are two pools, each with 5 individuals
indContribution &lt;- popsReads(list_np = rep(list(rep(5, 2)), 2), coverage = reads, pError = 5)

# set seed and create a random matrix of genotypes for the 20 individuals - 10 per population
set.seed(10)
genotypes &lt;- matrix(rpois(100, 0.5), nrow = 20)

# simulate the number of reference reads for the two populations
readsReference &lt;- numberReferencePop(genotypes = genotypes, indContribution = indContribution,
size = rep(list(rep(5, 2)), 2), error = 0.01)

# create Pooled DNA sequencing data for these two populations and for a single locus
pools &lt;- poolPops(nPops = 2, nLoci = 1, indContribution = indContribution,
readsReference = readsReference)

# define the major and minor alleles for this pool-seq data
# note that we have to select the first entry of the pools list
# because this function works for matrices
pools &lt;- findMinor(reference = pools$reference[[1]], alternative = pools$alternative[[1]],
coverage = pools$total[[1]])

# calculate population frequency at each SNP of this locus
calculatePi(listPool = pools, nLoci = 1)

</code></pre>

<hr>
<h2 id='computeReference'>Compute the number of reference reads over a matrix</h2><span id='topic+computeReference'></span>

<h3>Description</h3>

<p>This function works over all the rows and columns of a matrix and computes
the number of reads containing the reference allele at each site and for each
individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeReference(genotypes, indContribution, error)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeReference_+3A_genotypes">genotypes</code></td>
<td>
<p>is a matrix of genotypes. Each column of the matrix should
be a different site and each row a different individual. Genotypes should
be encoded as 0: reference homozygote, 1: heterozygote and 2: alternative
homozygote.</p>
</td></tr>
<tr><td><code id="computeReference_+3A_indcontribution">indContribution</code></td>
<td>
<p>is a matrix of individual contributions. Each row of
that matrix is a different individual and each column is a different site.
Thus, each entry of the matrix should contain the number of reads
contributed by that individual at that particular site.</p>
</td></tr>
<tr><td><code id="computeReference_+3A_error">error</code></td>
<td>
<p>a numeric value with error rate associated with the sequencing
and mapping process. This error rate is assumed to be symmetric:
error(reference -&gt; alternative) = error(alternative -&gt; reference). This
number should be between 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the number of reference allele reads contributed by
each individual. Each row of the matrix represents a different individual
and each column is a different site.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># probability of contribution for 10 individuals at 5 sites
probs &lt;- indProbs(np = 10, nSNPs = 5, pError = 5)

# simulate the number of reads contributed, assuming 20 coverage for each site
indContribution &lt;- indReads(np = 10, coverage = rep(20, 5), probs = probs)

# set seed and create a random matrix of genotypes
set.seed(10)
genotypes &lt;- matrix(rpois(50, 0.5), nrow = 10)

# simulate the number of reads with the reference allele
computeReference(genotypes = genotypes, indContribution = indContribution, error = 0.01)

</code></pre>

<hr>
<h2 id='errorHet'>Average absolute difference between expected heterozygosity</h2><span id='topic+errorHet'></span>

<h3>Description</h3>

<p>Calculates the average absolute difference between the expected
heterozygosity computed directly from genotypes and from pooled sequencing
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errorHet(
  nDip,
  nloci,
  pools,
  pError,
  sError,
  mCov,
  vCov,
  min.minor,
  minimum = NA,
  maximum = NA,
  theta = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errorHet_+3A_ndip">nDip</code></td>
<td>
<p>an integer representing the total number of diploid individuals
to simulate. Note that <code><a href="scrm.html#topic+scrm">scrm::scrm()</a></code> actually simulates haplotypes, so the
number of simulated haplotypes is double of this.</p>
</td></tr>
<tr><td><code id="errorHet_+3A_nloci">nloci</code></td>
<td>
<p>is an integer that represents how many independent loci should
be simulated.</p>
</td></tr>
<tr><td><code id="errorHet_+3A_pools">pools</code></td>
<td>
<p>a list with a vector containing the size (in number of diploid
individuals) of each pool. Thus, if a population was sequenced using a
single pool, the vector should contain only one entry. If a population was
sequenced using two pools, each with 10 individuals, this vector should
contain two entries and both will be 10.</p>
</td></tr>
<tr><td><code id="errorHet_+3A_perror">pError</code></td>
<td>
<p>an integer representing the value of the error associated with
DNA pooling. This value is related with the unequal contribution of both
individuals and pools towards the total number of reads observed for a
given population - the higher the value the more unequal are the individual
and pool contributions.</p>
</td></tr>
<tr><td><code id="errorHet_+3A_serror">sError</code></td>
<td>
<p>a numeric value with error rate associated with the sequencing
and mapping process. This error rate is assumed to be symmetric:
error(reference -&gt; alternative) = error(alternative -&gt; reference). This
number should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="errorHet_+3A_mcov">mCov</code></td>
<td>
<p>an integer that defines the mean depth of coverage to simulate.
Please note that this represents the mean coverage across all sites.</p>
</td></tr>
<tr><td><code id="errorHet_+3A_vcov">vCov</code></td>
<td>
<p>an integer that defines the variance of the depth of coverage
across all sites.</p>
</td></tr>
<tr><td><code id="errorHet_+3A_min.minor">min.minor</code></td>
<td>
<p>is an integer representing the minimum allowed number of
minor-allele reads. Sites that, across all populations, have less
minor-allele reads than this threshold will be removed from the data.</p>
</td></tr>
<tr><td><code id="errorHet_+3A_minimum">minimum</code></td>
<td>
<p>an optional integer representing the minimum coverage allowed.
Sites where the population has a depth of coverage below this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="errorHet_+3A_maximum">maximum</code></td>
<td>
<p>an optional integer representing the maximum coverage allowed.
Sites where the population has a depth of coverage above this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="errorHet_+3A_theta">theta</code></td>
<td>
<p>a value for the mutation rate assuming theta = 4Nu, where u is
the neutral mutation rate per locus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different combinations of parameters can be tested to check the effect of the
various parameters. The average absolute difference is computed with the
<a href="Metrics.html#topic+mae">mae</a> function, assuming the expected heterozygosity computed
directly from the genotypes as the <code>actual</code> input argument and the
expected heterozygosity from pooled data as the <code>predicted</code> input
argument.
</p>


<h3>Value</h3>

<p>a data.frame with columns detailing the number of diploid
individuals, the pool error, the number of pools, the number of individuals
per pool, the mean coverage, the variance of the coverage and the average
absolute difference between the expected heterozygosity computed from
genotypes and from pooled data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># single population sequenced with a single pool of 100 individuals
errorHet(nDip = 100, nloci = 10, pools = list(100), pError = 100, sError = 0.01,
mCov = 100, vCov = 250, min.minor = 2)

# single population sequenced with two pools, each with 50 individuals
errorHet(nDip = 100, nloci = 10, pools = list(c(50, 50)), pError = 100, sError = 0.01,
mCov = 100, vCov = 250, min.minor = 2)

# single population sequenced with two pools, each with 50 individuals
# removing sites with coverage below 10x or above 180x
errorHet(nDip = 100, nloci = 10, pools = list(c(50, 50)), pError = 100, sError = 0.01,
mCov = 100, vCov = 250, min.minor = 2, minimum = 10, maximum = 180)

</code></pre>

<hr>
<h2 id='Expected_Het'>Compute expected heterozygosity within a population</h2><span id='topic+Expected_Het'></span>

<h3>Description</h3>

<p>This functions calculates the value of the expected heterozygosity for each
SNP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Expected_Het(Pop_Pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Expected_Het_+3A_pop_pi">Pop_Pi</code></td>
<td>
<p>is a matrix or list of allele frequencies. When dealing with a
single locus, this input is a matrix and when dealing with multiple loci it
is a list. Each entry of that list is a matrix representing a different
locus. Each row of that matrix should correspond to a different population
and each column to a different SNP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if the input is a single matrix, the output will be a matrix where
each row represents a different population and each column is the expected
heterozygosity of a population at that site. If the input is a list, the
output will also be a list, with each entry corresponding to a different
locus. Each of those entries will be a matrix with different populations in
different rows and the expected heterozygosity of different sites at
different columns.
</p>

<hr>
<h2 id='ExpHet_site'>Compute expected heterozygosity per site</h2><span id='topic+ExpHet_site'></span>

<h3>Description</h3>

<p>Computes the expected heterozygosity for a given site.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpHet_site(geno_site)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpHet_site_+3A_geno_site">geno_site</code></td>
<td>
<p>is a vector where each entry contains the genotype for a
single individual, coded as 0,1,2 and using NA for the missing data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical value corresponding to the expected heterozygosity at
that site.
</p>

<hr>
<h2 id='filterMinor'>Filter sites according to a minor-allele reads threshold</h2><span id='topic+filterMinor'></span>

<h3>Description</h3>

<p>Removes sites from matrices with counts of reads. If a site has less
minor-allele reads than <code>min.minor</code> across all populations, that site is
removed from the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterMinor(reference, alternative, coverage, min.minor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterMinor_+3A_reference">reference</code></td>
<td>
<p>a matrix with the number of reads with the reference allele.
Each row should be a different population and each column a different site.</p>
</td></tr>
<tr><td><code id="filterMinor_+3A_alternative">alternative</code></td>
<td>
<p>a matrix with the number of reads with the alternative
allele. Each row should be a different population and each column a
different site.</p>
</td></tr>
<tr><td><code id="filterMinor_+3A_coverage">coverage</code></td>
<td>
<p>is a matrix of total coverage. Each row of the matrix should
be a different population and each column a different site. Thus, each
entry of the matrix contains the total number of observed reads for that
population at a given site.</p>
</td></tr>
<tr><td><code id="filterMinor_+3A_min.minor">min.minor</code></td>
<td>
<p>is an integer representing the minimum allowed number of
minor-allele reads. Sites that, across all populations, have less
minor-allele reads than this threshold will be removed from the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three named entries:
</p>
<table>
<tr><td><code>reference</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the number of reference allele reads. Each column represents a different site.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the number of alternative allele reads. Each column represents a different site.</p>
</td></tr>
<tr><td><code>total</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the total depth of coverage. Each column represents a different site.</p>
</td></tr>
</table>

<hr>
<h2 id='filterPool'>Filter Pool-seq data according to a minor-allele reads threshold</h2><span id='topic+filterPool'></span>

<h3>Description</h3>

<p>Removes sites from Pool-seq data. If a site has less minor-allele reads than
<code>min.minor</code> across all populations, that site is removed from the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterPool(pool, nloci, min.minor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterPool_+3A_pool">pool</code></td>
<td>
<p>a list containing the &quot;reference&quot; element, representing the
number of reads with the reference allele, the &quot;alternative&quot; element
representing the number of reads with the alternative allele and the
&quot;total&quot; element that contains information about the total number of reads.</p>
</td></tr>
<tr><td><code id="filterPool_+3A_nloci">nloci</code></td>
<td>
<p>an integer that represents the total number of independent loci
in the dataset.</p>
</td></tr>
<tr><td><code id="filterPool_+3A_min.minor">min.minor</code></td>
<td>
<p>is an integer representing the minimum allowed number of
minor-allele reads. Sites that, across all populations, have less
minor-allele reads than this threshold will be removed from the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three named entries:
</p>
<table>
<tr><td><code>reference</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the number of reference allele reads. Each column represents a different site.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the number of alternative allele reads. Each column represents a different site.</p>
</td></tr>
<tr><td><code>total</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the total depth of coverage. Each column represents a different site.</p>
</td></tr>
</table>

<hr>
<h2 id='findMinor'>Define major and minor alleles</h2><span id='topic+findMinor'></span>

<h3>Description</h3>

<p>This function checks which of the two simulated alleles (reference or
alternative) corresponds to the minor allele. This function can also be used
to remove sites according to a minor-allele reads threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findMinor(reference, alternative, coverage)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findMinor_+3A_reference">reference</code></td>
<td>
<p>is a matrix of reference allele reads. Each row of the
matrix should be a different population and each column a different site.
Thus, each entry of the matrix contains the number of observed reads with
the reference allele for that population at a given site.</p>
</td></tr>
<tr><td><code id="findMinor_+3A_alternative">alternative</code></td>
<td>
<p>is a matrix of alternative allele reads. Each row of the
matrix should be a different population and each column a different site.
Thus, each entry of the matrix contains the number of observed reads with
the alternative allele for that population at a given site.</p>
</td></tr>
<tr><td><code id="findMinor_+3A_coverage">coverage</code></td>
<td>
<p>is a matrix of total coverage. Each row of the matrix should
be a different population and each column a different site. Thus, each
entry of the matrix contains the total number of observed reads for that
population at a given site.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More precisely, this function counts the number of reads with the reference
or alternative allele at each site and then sets the minor allele as the
least frequent of the two. This is done across all populations and so the
major and minor alleles are defined at a global level. Then if the
<code>min.minor</code> input is not NA, sites where the number of minor allele reads,
across all populations, is below the user-defined threshold are removed.
</p>


<h3>Value</h3>

<p>a list with three names entries
</p>
<table>
<tr><td><code>major</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the number of major allele reads for each population. Each column
represents a different site and each row a different population.</p>
</td></tr>
<tr><td><code>minor</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the number of minor allele reads for each population. Each column
represents a different site and each row a different population.</p>
</td></tr>
<tr><td><code>total</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the coverage of each population. Each column represents a different site
and each row a different population.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coverage at 5 SNPs for two populations, assuming 20x mean coverage
reads &lt;- simulateCoverage(mean = c(20, 20), variance = c(100, 100), nSNPs = 5, nLoci = 1)

# simulate the number of reads contributed by each individual
# for each population there are two pools, each with 5 individuals
indContribution &lt;- popsReads(list_np = rep(list(rep(5, 2)), 2), coverage = reads, pError = 5)

# set seed and create a random matrix of genotypes for the 20 individuals - 10 per population
set.seed(10)
genotypes &lt;- matrix(rpois(100, 0.5), nrow = 20)

# simulate the number of reference reads for the two populations
readsReference &lt;- numberReferencePop(genotypes = genotypes, indContribution = indContribution,
size = rep(list(rep(5, 2)), 2), error = 0.01)

# create Pooled DNA sequencing data for these two populations and for a single locus
pools &lt;- poolPops(nPops = 2, nLoci = 1, indContribution = indContribution,
readsReference = readsReference)

# define the major and minor alleles for this Pool-seq data
# we have to select the first entry of the pools list because this function works for matrices
findMinor(reference = pools$reference[[1]], alternative = pools$alternative[[1]],
coverage = pools$total[[1]])

</code></pre>

<hr>
<h2 id='forcePool'>Randomly select the required number of loci from the pooled sequencing data</h2><span id='topic+forcePool'></span>

<h3>Description</h3>

<p>This function removes loci without polymorphic sites and then randomly
selects the required number of loci from a larger dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forcePool(nSims, pool, target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forcePool_+3A_nsims">nSims</code></td>
<td>
<p>is an integer representing how many types of simulations were
performed. The possible types of simulations include loci without barriers
against migration between divergent ecotypes, loci without migration from
the C towards the W ecotype, loci without migration from the W towards the
C ecotypes and loci where no migration occurs between divergent ecotypes.</p>
</td></tr>
<tr><td><code id="forcePool_+3A_pool">pool</code></td>
<td>
<p>a list containing the &quot;minor&quot; element, representing the number of
reads with the minor-allele and the &quot;total&quot; element that contains
information about the total number of Reads. The list should also contain a
&quot;major&quot; entry with the information about reads containing the major-allele.</p>
</td></tr>
<tr><td><code id="forcePool_+3A_target">target</code></td>
<td>
<p>is a vector with the required number of loci per category. If
extra loci were simulated, this vector informs how many loci of each
simulation type should be randomly selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If extra loci were simulated to try to have sufficient loci to keep the
required number of loci after filtering, then this function is used to remove
extra loci. This is done by randomly selecting the required number of loci
from the full contingent of extra simulated loci.
</p>


<h3>Value</h3>

<p>a list with three named entries
</p>
<table>
<tr><td><code>major</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the number of major allele reads for each population. Each column
represents a different site and each row a different population.</p>
</td></tr>
<tr><td><code>minor</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the number of minor allele reads for each population. Each column
represents a different site and each row a different population.</p>
</td></tr>
<tr><td><code>total</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the coverage of each population. Each column represents a different site
and each row a different population.</p>
</td></tr>
</table>

<hr>
<h2 id='GetGenotypes'>Create genotypes from a output with haplotypes</h2><span id='topic+GetGenotypes'></span>

<h3>Description</h3>

<p>This function applies the <code><a href="#topic+hap2geno">hap2geno</a></code> function to all entries of a
list. Each entry of that list is a different locus simulated with
<code><a href="scrm.html#topic+scrm">scrm::scrm()</a></code>. Thus, this function converts the haplotypes of all simulated
loci into genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetGenotypes(haplotypes, nDip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetGenotypes_+3A_haplotypes">haplotypes</code></td>
<td>
<p>a list of haplotypes obtained from the simulations done
with <code><a href="scrm.html#topic+scrm">scrm::scrm()</a></code>. Each entry of the list is a matrix that corresponds to
a given locus. At each matrix, each column is a different site and each row
is a different haplotype.</p>
</td></tr>
<tr><td><code id="GetGenotypes_+3A_ndip">nDip</code></td>
<td>
<p>an integer representing the total number of diploid individuals
to simulate. Note that this is the total number of diploid individuals and
not the number of individuals per population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of genotypes. Each entry of the list is a matrix corresponding
to a different locus. locus. At each matrix, each column is a different
site and each row is a different genotype
</p>

<hr>
<h2 id='getNumReadsR_vector'>Compute the number of reference reads</h2><span id='topic+getNumReadsR_vector'></span>

<h3>Description</h3>

<p>This function takes as input the total depth of coverage and computes how
many of those reads are reference allele reads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumReadsR_vector(genotype_v, readCount_v, error)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNumReadsR_vector_+3A_genotype_v">genotype_v</code></td>
<td>
<p>is a vector with the genotype of a given individual. Each
entry of the vector should be a different site. Genotypes should be encoded
as 0: reference homozygote, 1: heterozygote and 2: alternative homozygote.</p>
</td></tr>
<tr><td><code id="getNumReadsR_vector_+3A_readcount_v">readCount_v</code></td>
<td>
<p>is a vector with the number of reads contributed by the
same given individual. Each entry of that vector should be a different
site.</p>
</td></tr>
<tr><td><code id="getNumReadsR_vector_+3A_error">error</code></td>
<td>
<p>a numeric value with error rate associated with the sequencing
and mapping process. This error rate is assumed to be symmetric:
error(reference -&gt; alternative) = error(alternative -&gt; reference). This
number should be between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More precisely, this function computes the number of reference reads per site
for one individual, given the genotype of the individual at each site, the
total number of reads observed for the individual at that site and an error
rate.
</p>


<h3>Value</h3>

<p>a vector with the number of reference allele reads. Each entry of the
vector corresponds to a different individual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># number of reference allele reads for three individuals, each with 10x coverage
# one individual is homozygote for the reference allele (0), other is heterozygote (1)
# and the last is homozygote for the alternative allele (2)
getNumReadsR_vector(genotype_v = c(0,1,2), readCount_v = c(10, 10, 10), error = 0.01)

</code></pre>

<hr>
<h2 id='hap2geno'>Convert haplotypes to genotypes</h2><span id='topic+hap2geno'></span>

<h3>Description</h3>

<p>This function converts haplotypes simulated with <code><a href="scrm.html#topic+scrm">scrm::scrm()</a></code> into
genotypes by adding the entries on one row with the entries of the subsequent
row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hap2geno(haplo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hap2geno_+3A_haplo">haplo</code></td>
<td>
<p>a matrix of haplotypes obtained from the simulations done with
<code><a href="scrm.html#topic+scrm">scrm::scrm()</a></code>. Each column of the matrix is a different site and each row
is a different haplotype.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of genotypes with half the rows of the <code>haplo</code> matrix. Each
column of this matrix is a different site and each row is a different
genotype.
</p>

<hr>
<h2 id='haplo.fix'>Create invariable sites</h2><span id='topic+haplo.fix'></span>

<h3>Description</h3>

<p>This function applies a correction for the situations where <code><a href="scrm.html#topic+scrm">scrm::scrm()</a></code>
does not produce a single polymorphic site for a given locus. In this
situation, two artificial sites are created at that locus. All individuals
are assumed to be homozygous for the reference allele at those sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haplo.fix(haplotypes, nHap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haplo.fix_+3A_haplotypes">haplotypes</code></td>
<td>
<p>a list of haplotypes obtained from the simulations done
with <code><a href="scrm.html#topic+scrm">scrm::scrm()</a></code>. Each entry of the list is a matrix that corresponds to
a given locus. At each matrix, each column is a different site and each row
is a different haplotype.</p>
</td></tr>
<tr><td><code id="haplo.fix_+3A_nhap">nHap</code></td>
<td>
<p>an integer representing the total number of haplotypes simulated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of haplotypes identical to <code>haplotypes</code>, but without empty
loci.
</p>

<hr>
<h2 id='Ifreqs'>Compute allele frequencies from genotypes</h2><span id='topic+Ifreqs'></span>

<h3>Description</h3>

<p>Computes alternative allele frequencies from genotypes by dividing the total
number of alternative alleles by the total number of gene copies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ifreqs(nDip, genotypes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ifreqs_+3A_ndip">nDip</code></td>
<td>
<p>an integer representing the total number of diploid individuals
to simulate. Note that <code><a href="scrm.html#topic+scrm">scrm::scrm()</a></code> actually simulates haplotypes, so the
number of simulated haplotypes is double of this.</p>
</td></tr>
<tr><td><code id="Ifreqs_+3A_genotypes">genotypes</code></td>
<td>
<p>a list of simulated genotypes, where each entry is a matrix
corresponding to a different locus. At each matrix, each column is a
different SNP and each row is a different individual.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of allele frequencies. Each entry of the list corresponds to a
different locus.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genotypes &lt;- run_scrm(nDip = 10, nloci = 10)
Ifreqs(nDip = 10, genotypes)

</code></pre>

<hr>
<h2 id='indProbs'>Probability of contribution of each individual</h2><span id='topic+indProbs'></span>

<h3>Description</h3>

<p>This function computes the probability of contribution for each individual of
a given pool. Please note that this function works for a single pool and
should not be directly applied to situations where multiple pools were used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indProbs(np, nSNPs, pError)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indProbs_+3A_np">np</code></td>
<td>
<p>an integer specifying how many individuals were pooled.</p>
</td></tr>
<tr><td><code id="indProbs_+3A_nsnps">nSNPs</code></td>
<td>
<p>an integer indicating how many SNPs exist in the data.</p>
</td></tr>
<tr><td><code id="indProbs_+3A_perror">pError</code></td>
<td>
<p>an integer representing the value of the error associated with
DNA pooling. This value is related with the unequal individual contribution
towards the total number of reads contributed by a single pool - the higher
the value the more unequal are the individual contributions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the probabilities of contribution for each individual.
Each row represents a different individual and each column is a different
site.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># probability of contribution for 10 individuals at 5 sites
indProbs(np = 10, nSNPs = 5, pError = 100)

</code></pre>

<hr>
<h2 id='indReads'>Reads contributed by each individual</h2><span id='topic+indReads'></span>

<h3>Description</h3>

<p>This function simulates the contribution, in terms of reads, of each
individual of a given pool. Please note that this function works for a single
pool and should not be directly applied to situations where multiple pools
were used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indReads(np, coverage, probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indReads_+3A_np">np</code></td>
<td>
<p>an integer specifying how many individuals were pooled.</p>
</td></tr>
<tr><td><code id="indReads_+3A_coverage">coverage</code></td>
<td>
<p>a vector containing the total depth of coverage of a given
pool. Each entry of the vector represents a different site.</p>
</td></tr>
<tr><td><code id="indReads_+3A_probs">probs</code></td>
<td>
<p>a matrix containing the probability of contribution of each
individual. This matrix can be obtained with the <code>indProbs</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the number of reads contributed by each individual
towards the coverage of its pool. Each row of the matrix is a different
individual and each column a different site.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># probability of contribution for 10 individuals at 5 sites
probs &lt;- indProbs(np = 10, nSNPs = 5, pError = 100)

# simulate the number of reads contributed, assuming 10x coverage for each site
indReads(np = 10, coverage = rep(10, 5), probs = probs)

</code></pre>

<hr>
<h2 id='maeFreqs'>Average absolute difference between allele frequencies computed from
genotypes and from Pool-seq data</h2><span id='topic+maeFreqs'></span>

<h3>Description</h3>

<p>Calculates the average absolute difference between the allele frequencies
computed directly from genotypes and from pooled sequencing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maeFreqs(
  nDip,
  nloci,
  pError,
  sError,
  mCov,
  vCov,
  min.minor,
  minimum = NA,
  maximum = NA,
  theta = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maeFreqs_+3A_ndip">nDip</code></td>
<td>
<p>is an integer or a vector representing the total number of
diploid individuals to simulate. Note that <code><a href="scrm.html#topic+scrm">scrm::scrm()</a></code> actually
simulates haplotypes, so the number of simulated haplotypes is double of
this. If it is a vector, then each vector entry will be simulated
independently. For instance, if <code>nDip = c(100, 200)</code>, simulations will
be carried out for samples of 100 and 200 individuals.</p>
</td></tr>
<tr><td><code id="maeFreqs_+3A_nloci">nloci</code></td>
<td>
<p>is an integer that represents how many independent loci should
be simulated.</p>
</td></tr>
<tr><td><code id="maeFreqs_+3A_perror">pError</code></td>
<td>
<p>an integer or a vector representing the value of the error
associated with DNA pooling. This value is related with the unequal
contribution of both individuals and pools towards the total number of
reads observed for a given population - the higher the value the more
unequal are the individual and pool contributions. If it is a vector, then
each vector entry will be simulated independently.</p>
</td></tr>
<tr><td><code id="maeFreqs_+3A_serror">sError</code></td>
<td>
<p>a numeric value with error rate associated with the sequencing
and mapping process. This error rate is assumed to be symmetric:
error(reference -&gt; alternative) = error(alternative -&gt; reference). This
number should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="maeFreqs_+3A_mcov">mCov</code></td>
<td>
<p>an integer or a vector that defines the mean depth of coverage to
simulate. Please note that this represents the mean coverage across all
sites. If it is a vector, then each vector entry will be simulated
independently.</p>
</td></tr>
<tr><td><code id="maeFreqs_+3A_vcov">vCov</code></td>
<td>
<p>an integer or a vector that defines the variance of the depth of
coverage across all sites. If the <code>mCov</code> is a vector, then <code>vCov</code>
should also be a vector, with each entry corresponding to the variance of
the respective entry in the <code>mCov</code> vector. Thus, the first entry of
the <code>vCov</code> vector will be the variance associated with the first entry
of the <code>mCov</code> vector.</p>
</td></tr>
<tr><td><code id="maeFreqs_+3A_min.minor">min.minor</code></td>
<td>
<p>is an integer representing the minimum allowed number of
minor-allele reads. Sites that, across all populations, have less
minor-allele reads than this threshold will be removed from the data.</p>
</td></tr>
<tr><td><code id="maeFreqs_+3A_minimum">minimum</code></td>
<td>
<p>an optional integer representing the minimum coverage allowed.
Sites where the population has a depth of coverage below this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="maeFreqs_+3A_maximum">maximum</code></td>
<td>
<p>an optional integer representing the maximum coverage allowed.
Sites where the population has a depth of coverage above this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="maeFreqs_+3A_theta">theta</code></td>
<td>
<p>a value for the mutation rate assuming theta = 4Nu, where u is
the neutral mutation rate per locus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The average absolute difference is computed with the <a href="Metrics.html#topic+mae">mae</a>
function, assuming the frequencies computed directly from the genotypes as
the <code>actual</code> input argument and the frequencies from pooled data as the
<code>predicted</code> input argument.
</p>
<p>Note that this functions allows for different combinations of parameters.
Thus, the effect of different combinations of parameters on the average
absolute difference can be tested. For instance, it is possible to check what
is the effect of different coverages by including more than one value in the
<code>mCov</code> input argument. This function will run and compute the average
absolute difference for all combinations of the <code>nDip</code>, <code>pError</code>
and <code>mCov</code> input arguments. This function assumes that a single pool of
size <code>nDip</code> was used to sequence the population.
</p>


<h3>Value</h3>

<p>a data.frame with columns detailing the number of diploid
individuals, the pool error, the number of pools, the number of individuals
per pool, the mean coverage, the variance of the coverage and the average
absolute difference between the frequencies computed from genotypes and
from pooled data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a simple test with a simple combination of parameters
maeFreqs(nDip = 100, nloci = 10, pError = 100, sError = 0.01, mCov = 100, vCov = 200, min.minor = 1)

# effect of two different pool error values in conjugation with a fixed coverage and pool size
maeFreqs(nDip = 100, nloci = 10, pError = c(100, 200), sError = 0.01,
mCov = 100, vCov = 200, min.minor = 1)

# effect of two different pool error values in conjugation with a fixed pool size
# and two different coverages
maeFreqs(nDip = 100, nloci = 10, pError = c(100, 200), sError = 0.01,
mCov = c(100, 200), vCov = c(200, 500), min.minor = 1)

</code></pre>

<hr>
<h2 id='maeHet'>Average absolute difference between the expected heterozygosity computed from
genotypes and from Pool-seq data</h2><span id='topic+maeHet'></span>

<h3>Description</h3>

<p>Calculates the average absolute difference between the expected
heterozygosity computed directly from genotypes and from pooled sequencing
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maeHet(
  nDip,
  nloci,
  pError,
  sError,
  mCov,
  vCov,
  min.minor,
  minimum = NA,
  maximum = NA,
  theta = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maeHet_+3A_ndip">nDip</code></td>
<td>
<p>is an integer or a vector representing the total number of
diploid individuals to simulate. Note that <code><a href="scrm.html#topic+scrm">scrm::scrm()</a></code> actually
simulates haplotypes, so the number of simulated haplotypes is double of
this. If it is a vector, then each vector entry will be simulated
independently. For instance, if <code>nDip = c(100, 200)</code>, simulations will
be carried out for samples of 100 and 200 individuals.</p>
</td></tr>
<tr><td><code id="maeHet_+3A_nloci">nloci</code></td>
<td>
<p>is an integer that represents how many independent loci should
be simulated.</p>
</td></tr>
<tr><td><code id="maeHet_+3A_perror">pError</code></td>
<td>
<p>an integer or a vector representing the value of the error
associated with DNA pooling. This value is related with the unequal
contribution of both individuals and pools towards the total number of
reads observed for a given population - the higher the value the more
unequal are the individual and pool contributions. If it is a vector, then
each vector entry will be simulated independently.</p>
</td></tr>
<tr><td><code id="maeHet_+3A_serror">sError</code></td>
<td>
<p>a numeric value with error rate associated with the sequencing
and mapping process. This error rate is assumed to be symmetric:
error(reference -&gt; alternative) = error(alternative -&gt; reference). This
number should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="maeHet_+3A_mcov">mCov</code></td>
<td>
<p>an integer or a vector that defines the mean depth of coverage to
simulate. Please note that this represents the mean coverage across all
sites. If it is a vector, then each vector entry will be simulated
independently.</p>
</td></tr>
<tr><td><code id="maeHet_+3A_vcov">vCov</code></td>
<td>
<p>an integer or a vector that defines the variance of the depth of
coverage across all sites. If the <code>mCov</code> is a vector, then <code>vCov</code>
should also be a vector, with each entry corresponding to the variance of
the respective entry in the <code>mCov</code> vector. Thus, the first entry of
the <code>vCov</code> vector will be the variance associated with the first entry
of the <code>mCov</code> vector.</p>
</td></tr>
<tr><td><code id="maeHet_+3A_min.minor">min.minor</code></td>
<td>
<p>is an integer representing the minimum allowed number of
minor-allele reads. Sites that, across all populations, have less
minor-allele reads than this threshold will be removed from the data.</p>
</td></tr>
<tr><td><code id="maeHet_+3A_minimum">minimum</code></td>
<td>
<p>an optional integer representing the minimum coverage allowed.
Sites where the population has a depth of coverage below this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="maeHet_+3A_maximum">maximum</code></td>
<td>
<p>an optional integer representing the maximum coverage allowed.
Sites where the population has a depth of coverage above this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="maeHet_+3A_theta">theta</code></td>
<td>
<p>a value for the mutation rate assuming theta = 4Nu, where u is
the neutral mutation rate per locus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The average absolute difference is computed with the <a href="Metrics.html#topic+mae">mae</a>
function, assuming the expected heterozygosity computed directly from the
genotypes as the <code>actual</code> input argument and the expected heterozygosity
from pooled data as the <code>predicted</code> input argument.
</p>
<p>Note that this functions allows for different combinations of parameters.
Thus, the effect of different combinations of parameters on the average
absolute difference can be tested. For instance, it is possible to check what
is the effect of different coverages by including more than one value in the
<code>mCov</code> input argument. This function will run and compute the average
absolute difference for all combinations of the <code>nDip</code>, <code>pError</code>
and <code>mCov</code> input arguments. This function assumes that a single pool of
size <code>nDip</code> was used to sequence the population.
</p>


<h3>Value</h3>

<p>a data.frame with columns detailing the number of diploid
individuals, the pool error, the number of pools, the number of individuals
per pool, the mean coverage, the variance of the coverage and the average
absolute difference between the expected heterozygosity computed from
genotypes and from pooled data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a simple test with a simple combination of parameters
maeHet(nDip = 100, nloci = 10, pError = 100, sError = 0.01, mCov = 100, vCov = 200, min.minor = 1)

# effect of two different pool error values in conjugation with a fixed coverage and pool size
maeHet(nDip = 100, nloci = 10, pError = c(100, 200), sError = 0.01,
mCov = 100, vCov = 200, min.minor = 1)

# effect of two different pool error values in conjugation with a fixed pool size
# and two different coverages
maeHet(nDip = 100, nloci = 10, pError = c(100, 200), sError = 0.01,
mCov = c(100, 200), vCov = c(200, 500), min.minor = 1)

</code></pre>

<hr>
<h2 id='maePool'>Average absolute difference between allele frequencies</h2><span id='topic+maePool'></span>

<h3>Description</h3>

<p>Calculates the average absolute difference between the allele frequencies
computed directly from genotypes and from pooled sequencing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maePool(
  nDip,
  nloci,
  pools,
  pError,
  sError,
  mCov,
  vCov,
  min.minor,
  minimum = NA,
  maximum = NA,
  theta = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maePool_+3A_ndip">nDip</code></td>
<td>
<p>an integer representing the total number of diploid individuals
to simulate. Note that <code><a href="scrm.html#topic+scrm">scrm::scrm()</a></code> actually simulates haplotypes, so the
number of simulated haplotypes is double of this.</p>
</td></tr>
<tr><td><code id="maePool_+3A_nloci">nloci</code></td>
<td>
<p>is an integer that represents how many independent loci should
be simulated.</p>
</td></tr>
<tr><td><code id="maePool_+3A_pools">pools</code></td>
<td>
<p>a list with a vector containing the size (in number of diploid
individuals) of each pool. Thus, if a population was sequenced using a
single pool, the vector should contain only one entry. If a population was
sequenced using two pools, each with 10 individuals, this vector should
contain two entries and both will be 10.</p>
</td></tr>
<tr><td><code id="maePool_+3A_perror">pError</code></td>
<td>
<p>an integer representing the value of the error associated with
DNA pooling. This value is related with the unequal contribution of both
individuals and pools towards the total number of reads observed for a
given population - the higher the value the more unequal are the individual
and pool contributions.</p>
</td></tr>
<tr><td><code id="maePool_+3A_serror">sError</code></td>
<td>
<p>a numeric value with error rate associated with the sequencing
and mapping process. This error rate is assumed to be symmetric:
error(reference -&gt; alternative) = error(alternative -&gt; reference). This
number should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="maePool_+3A_mcov">mCov</code></td>
<td>
<p>an integer that defines the mean depth of coverage to simulate.
Please note that this represents the mean coverage across all sites.</p>
</td></tr>
<tr><td><code id="maePool_+3A_vcov">vCov</code></td>
<td>
<p>an integer that defines the variance of the depth of coverage
across all sites.</p>
</td></tr>
<tr><td><code id="maePool_+3A_min.minor">min.minor</code></td>
<td>
<p>is an integer representing the minimum allowed number of
minor-allele reads. Sites that, across all populations, have less
minor-allele reads than this threshold will be removed from the data.</p>
</td></tr>
<tr><td><code id="maePool_+3A_minimum">minimum</code></td>
<td>
<p>an optional integer representing the minimum coverage allowed.
Sites where the population has a depth of coverage below this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="maePool_+3A_maximum">maximum</code></td>
<td>
<p>an optional integer representing the maximum coverage allowed.
Sites where the population has a depth of coverage above this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="maePool_+3A_theta">theta</code></td>
<td>
<p>a value for the mutation rate assuming theta = 4Nu, where u is
the neutral mutation rate per locus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different combinations of parameters can be tested to check the effect of the
various parameters. The average absolute difference is computed with the
<a href="Metrics.html#topic+mae">mae</a> function, assuming the frequencies computed directly from
the genotypes as the <code>actual</code> input argument and the frequencies from
pooled data as the <code>predicted</code> input argument.
</p>


<h3>Value</h3>

<p>a data.frame with columns detailing the number of diploid
individuals, the pool error, the number of pools, the number of individuals
per pool, the mean coverage, the variance of the coverage and the average
absolute difference between the frequencies computed from genotypes and
from pooled data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># single population sequenced with a single pool of 100 individuals
maePool(nDip = 100, nloci = 10, pools = list(100), pError = 100, sError = 0.01,
mCov = 100, vCov = 250, min.minor = 2)

# single population sequenced with two pools, each with 50 individuals
maePool(nDip = 100, nloci = 10, pools = list(c(50, 50)), pError = 100, sError = 0.01,
mCov = 100, vCov = 250, min.minor = 2)

# single population sequenced with two pools, each with 50 individuals
# removing sites with coverage below 10x or above 180x
maePool(nDip = 100, nloci = 10, pools = list(c(50, 50)), pError = 100, sError = 0.01,
mCov = 100, vCov = 250, min.minor = 2, minimum = 10, maximum = 180)

</code></pre>

<hr>
<h2 id='mymae'>Average absolute difference between allele frequencies computed from
genotypes supplied by the user and from Pool-seq data</h2><span id='topic+mymae'></span>

<h3>Description</h3>

<p>Calculates the average absolute difference between the allele frequencies
computed directly from genotypes and from pooled sequencing data. The
genotypes used should be supplied by the user and can be simulated using
different software and under the demographic model of choice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mymae(
  genotypes,
  pools,
  pError,
  sError,
  mCov,
  vCov,
  min.minor,
  minimum = NA,
  maximum = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mymae_+3A_genotypes">genotypes</code></td>
<td>
<p>a list of genotypes, where each entry is a matrix
corresponding to a different locus. At each matrix, each column is a
different SNP and each row is a different individual. Genotypes should be
coded as 0, 1 or 2.</p>
</td></tr>
<tr><td><code id="mymae_+3A_pools">pools</code></td>
<td>
<p>a list with a vector containing the size (in number of diploid
individuals) of each pool. Thus, if a population was sequenced using a
single pool, the vector should contain only one entry. If a population was
sequenced using two pools, each with 10 individuals, this vector should
contain two entries and both will be 10.</p>
</td></tr>
<tr><td><code id="mymae_+3A_perror">pError</code></td>
<td>
<p>an integer representing the value of the error associated with
DNA pooling. This value is related with the unequal contribution of both
individuals and pools towards the total number of reads observed for a
given population - the higher the value the more unequal are the individual
and pool contributions.</p>
</td></tr>
<tr><td><code id="mymae_+3A_serror">sError</code></td>
<td>
<p>a numeric value with error rate associated with the sequencing
and mapping process. This error rate is assumed to be symmetric:
error(reference -&gt; alternative) = error(alternative -&gt; reference). This
number should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="mymae_+3A_mcov">mCov</code></td>
<td>
<p>an integer that defines the mean depth of coverage to simulate.
Please note that this represents the mean coverage across all sites.</p>
</td></tr>
<tr><td><code id="mymae_+3A_vcov">vCov</code></td>
<td>
<p>an integer that defines the variance of the depth of coverage
across all sites.</p>
</td></tr>
<tr><td><code id="mymae_+3A_min.minor">min.minor</code></td>
<td>
<p>is an integer representing the minimum allowed number of
minor-allele reads. Sites that, across all populations, have less
minor-allele reads than this threshold will be removed from the data.</p>
</td></tr>
<tr><td><code id="mymae_+3A_minimum">minimum</code></td>
<td>
<p>an optional integer representing the minimum coverage allowed.
Sites where the population has a depth of coverage below this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="mymae_+3A_maximum">maximum</code></td>
<td>
<p>an optional integer representing the maximum coverage allowed.
Sites where the population has a depth of coverage above this threshold are
removed from the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The average absolute difference is computed with the <a href="Metrics.html#topic+mae">mae</a>
function, assuming the frequencies computed directly from the genotypes as
the <code>actual</code> input argument and the frequencies from pooled data as the
<code>predicted</code> input argument.
</p>
<p>Note that this functions allows for different combinations of parameters.
Thus, the effect of different combinations of parameters on the average
absolute difference can be tested. For instance, it is possible to check what
is the effect of different coverages by including more than one value in the
<code>mCov</code> input argument. This function will run and compute the average
absolute difference for all combinations of the <code>pools</code>, <code>pError</code>
and <code>mCov</code> input arguments.
</p>


<h3>Value</h3>

<p>a data.frame with columns detailing the number of diploid
individuals, the pool error, the number of pools, the number of individuals
per pool, the mean coverage, the variance of the coverage and the average
absolute difference between the frequencies computed from genotypes and
from pooled data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 100 individuals sampled at a single locus
genotypes &lt;- run_scrm(nDip = 100, nloci = 1, theta = 5)
# compute the mean absolute error assuming a coverage of 100x and two pools of 50 individuals each
mymae(genotypes = genotypes, pools = list(c(50, 50)), pError = 100, sError = 0.001,
mCov = 100, vCov = 250, min.minor = 0)

# 10 individuals sampled at 5 different loci
genotypes &lt;- run_scrm(nDip = 10, nloci = 5, theta = 5)
# compute the mean absolute error assuming a coverage of 100x and one pool of 10 individuals
mymae(genotypes = genotypes, pools = list(10), pError = 100, sError = 0.001,
mCov = 100, vCov = 250, min.minor = 0)

</code></pre>

<hr>
<h2 id='numberReference'>Compute the number of reference reads at multiple loci</h2><span id='topic+numberReference'></span>

<h3>Description</h3>

<p>This function computes the number of reference reads over multiple loci and
for a single population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numberReference(genotypes, indContribution, error)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numberReference_+3A_genotypes">genotypes</code></td>
<td>
<p>is a list, where each entry corresponds to a different
locus. Each entry should be a matrix containing the genotypes (coded as 0,
1 or 2). Each column of that matrix should be a different site and each row
a different individual.</p>
</td></tr>
<tr><td><code id="numberReference_+3A_indcontribution">indContribution</code></td>
<td>
<p>either a list or a matrix (that the function will
convert to a list). Each list entry should be a matrix of individual
contributions.  Each row of that matrix is a different individual and each
column is a different site. Thus, each entry of the matrix should contain
the number of reads contributed by that individual at that particular site.</p>
</td></tr>
<tr><td><code id="numberReference_+3A_error">error</code></td>
<td>
<p>a numeric value with error rate associated with the sequencing
and mapping process. This error rate is assumed to be symmetric:
error(reference -&gt; alternative) = error(alternative -&gt; reference). This
number should be between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function will also work on a single locus, provided that the
input is in the list format.
</p>


<h3>Value</h3>

<p>a list with one entry per locus. Each of those entries is a matrix
with the number of reference allele reads contributed by each individual.
Each matrix row represents a different individual and each column is a
different site.
</p>

<hr>
<h2 id='numberReferencePop'>Compute the number of reference reads for multiple populations</h2><span id='topic+numberReferencePop'></span>

<h3>Description</h3>

<p>This function computes the number of reference reads over a single locus for
multiple populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numberReferencePop(genotypes, indContribution, size, error)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numberReferencePop_+3A_genotypes">genotypes</code></td>
<td>
<p>either a list with a single entry (one locus) or a matrix
(that the function will convert to a list) containing the genotypes (coded
as 0, 1 or 2). Each column of that matrix should be a different site and
each row a different individual.</p>
</td></tr>
<tr><td><code id="numberReferencePop_+3A_indcontribution">indContribution</code></td>
<td>
<p>a list where each entry contains the information for a
single population. Each entry should be a matrix, with as many rows as the
number of individuals of that population. Each row contains the number of
contributed reads for a given individual and across all sites.</p>
</td></tr>
<tr><td><code id="numberReferencePop_+3A_size">size</code></td>
<td>
<p>a list with one entry per population. Each entry should be a
vector containing the size (in number of diploid individuals) of each pool.
Thus, if a population was sequenced using a single pool, the vector should
contain only one entry. If a population was sequenced using two pools, each
with 10 individuals, this vector should contain two entries and both will
be 10.</p>
</td></tr>
<tr><td><code id="numberReferencePop_+3A_error">error</code></td>
<td>
<p>a numeric value with error rate associated with the sequencing
and mapping process. This error rate is assumed to be symmetric:
error(reference -&gt; alternative) = error(alternative -&gt; reference). This
number should be between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function will not work as intended if the input consists of
multiple loci.
</p>


<h3>Value</h3>

<p>a list with one entry per population. Each entry contains the number
of reference allele reads for the individuals of that population and for
that locus. Different individuals are in different rows and each columns
represents a different site.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coverage at 5 SNPs for two populations, assuming 20x mean coverage
reads &lt;- simulateCoverage(mean = c(20, 20), variance = c(100, 100), nSNPs = 5, nLoci = 1)

# simulate the number of reads contributed by each individual
# for each population there are two pools, each with 5 individuals
indContribution &lt;- popsReads(list_np = rep(list(rep(5, 2)), 2), coverage = reads, pError = 5)

# set seed and create a random matrix of genotypes for the 20 individuals - 10 per population
set.seed(10)
genotypes &lt;- matrix(rpois(100, 0.5), nrow = 20)

# simulate the number of reference reads for the two populations
numberReferencePop(genotypes = genotypes, indContribution = indContribution,
size = rep(list(rep(5, 2)), 2), error = 0.01)

</code></pre>

<hr>
<h2 id='Pfreqs'>Compute allele frequencies from pooled sequencing data</h2><span id='topic+Pfreqs'></span>

<h3>Description</h3>

<p>Computes the frequency of the alternative allele in Pool-seq data and removes
any site with too few minor-allele reads from both the pool frequencies and
the frequencies computed directly from genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pfreqs(reference, alternative, coverage, min.minor, ifreqs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pfreqs_+3A_reference">reference</code></td>
<td>
<p>a matrix with the number of reference allele reads. Each row
should be a different population and each column a different site.</p>
</td></tr>
<tr><td><code id="Pfreqs_+3A_alternative">alternative</code></td>
<td>
<p>a matrix with the number of alternative allele reads. Each
row should be a different population and each column a different site.</p>
</td></tr>
<tr><td><code id="Pfreqs_+3A_coverage">coverage</code></td>
<td>
<p>a matrix with the total coverage. Each row should be a
different population and each column a different site.</p>
</td></tr>
<tr><td><code id="Pfreqs_+3A_min.minor">min.minor</code></td>
<td>
<p>is an integer representing the minimum allowed number of
minor-allele reads. Sites that, across all populations, have less
minor-allele reads than this threshold will be removed from the data.</p>
</td></tr>
<tr><td><code id="Pfreqs_+3A_ifreqs">ifreqs</code></td>
<td>
<p>a vector of allele frequencies computed directly from the
genotypes where each entry corresponds to a different site.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The frequency at a given SNP is calculated according to: <code>pi = c/r</code>, where c
= number of alternative allele reads and r = total number of observed reads.
Additionally, if a site has less minor-allele reads than <code>min.minor</code>
across all populations, that site is removed from the data.
</p>


<h3>Value</h3>

<p>a list with two entries. The <code>ifreqs</code> entry contains the allele
frequencies computed directly from genotypes and <code>pfreqs</code> the allele
frequencies computed from pooled sequencing data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
# create a vector of allele frequencies
freqs &lt;- runif(20)
set.seed(10)
# create a matrix with the number of reads with the alternative allele
alternative &lt;- matrix(sample(x = c(0,5,10), size = 20, replace = TRUE), nrow = 1)
# create a matrix with the depth of coverage
coverage &lt;- matrix(sample(100:150, size = 20), nrow = 1)
# the number of reads with the reference allele is obtained by subtracting
# the number of alternative allele reads from the depth of coverage
reference &lt;- coverage - alternative
# compute allele frequencies from pooled sequencing data
Pfreqs(reference = reference, alternative = alternative, coverage = coverage,
min.minor = 2, ifreqs = freqs)

</code></pre>

<hr>
<h2 id='pool2sync'>Create 'synchronized' file from Pool-seq data</h2><span id='topic+pool2sync'></span>

<h3>Description</h3>

<p>Creates and saves a file with the information from Pool-seq data coded in the
'synchronized' format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool2sync(reference, alternative, file, pos = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool2sync_+3A_reference">reference</code></td>
<td>
<p>is a list where each entry corresponds to a different locus.
Each list entry is a vector with the number of reads with the reference
allele. Each entry of the vector corresponds to a different SNP. This list
can have a single entry if the data is comprised of a single locus.</p>
</td></tr>
<tr><td><code id="pool2sync_+3A_alternative">alternative</code></td>
<td>
<p>is a list where each entry corresponds to a different
locus. Each list entry is a vector with the number of reads with the
alternative allele. Each entry of the vector corresponds to a different
SNP. This list can have a single entry if the data is comprised of a single
locus.</p>
</td></tr>
<tr><td><code id="pool2sync_+3A_file">file</code></td>
<td>
<p>is a character string naming the file to write to.</p>
</td></tr>
<tr><td><code id="pool2sync_+3A_pos">pos</code></td>
<td>
<p>is an optional input (default is NULL). If the actual position of
the SNPs are known, they can be used as input here. When working with a
single locus, this should be a numeric vector with each entry corresponding
to the position of each SNP. If the data has multiple loci, this should be
a list where each entry is a numeric vector with the position of the SNPs
for a different locus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It starts by converting the number of reads with the <code>reference</code> allele
and the <code>alternative</code> allele to a
A-count:T-count:C-count:G-count:N-count:deletion-count string. Here, we
assume that the reference allele is always A and the alternative is always T.
</p>
<p>Then, this A-count:T-count:C-count:G-count:N-count:deletion-count string is
combined with other necessary information such as the chromosome of each SNP,
the position of the SNP and the reference character. This step creates a data
frame where each row corresponds to a different SNP.
</p>
<p>A <code>file</code> is then created and saved in the current working directory,
with the Pool-seq data coded in the 'synchronized' file format.
</p>


<h3>Value</h3>

<p>a file in the current working directory containing Pool-seq data in
the 'synchronized' format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate Pool-seq data for 100 individuals sampled at a single locus
genotypes &lt;- run_scrm(nDip = 100, nloci = 1, theta = 5)
# simulate Pool-seq data assuming a coverage of 100x and two pools of 50 individuals each
pool &lt;- simPoolseq(genotypes = genotypes, pools = c(50, 50), pError = 100, sError = 0.001,
mCov = 100, vCov = 250, min.minor = 0)
# create a 'synchronized' file of the simulated data - this will create a txt file
# pool2sync(reference = pool$reference, alternative = pool$alternative, file = "mysync.txt")

# simulate Pool-seq data for 10 individuals sampled at 5 loci
genotypes &lt;- run_scrm(nDip = 10, nloci = 5, theta = 5)
# simulate Pool-seq data assuming a coverage of 100x and a single pool of 10 individuals
pool &lt;- simPoolseq(genotypes = genotypes, pools = 10, pError = 100, sError = 0.001,
mCov = 100, vCov = 250, min.minor = 0)

# create a 'synchronized' file of the simulated data - this will create a txt file
# pool2sync(reference = pool$reference, alternative = pool$alternative, file = "mysync.txt")

</code></pre>

<hr>
<h2 id='pool2vcf'>Create VCF file from Pool-seq data</h2><span id='topic+pool2vcf'></span>

<h3>Description</h3>

<p>Creates and saves a file with the information from Pool-seq data coded in the
VCF format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool2vcf(reference, alternative, total, file, pos = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool2vcf_+3A_reference">reference</code></td>
<td>
<p>is a list where each entry corresponds to a different locus.
Each list entry is a vector with the number of reads with the reference
allele. Each entry of the vector corresponds to a different SNP. This list
can have a single entry if the data is comprised of a single locus.</p>
</td></tr>
<tr><td><code id="pool2vcf_+3A_alternative">alternative</code></td>
<td>
<p>is a list where each entry corresponds to a different
locus. Each list entry is a vector with the number of reads with the
alternative allele. Each entry of the vector corresponds to a different
SNP. This list can have a single entry if the data is comprised of a single
locus.</p>
</td></tr>
<tr><td><code id="pool2vcf_+3A_total">total</code></td>
<td>
<p>is a list where each entry corresponds to a different locus.
Each list entry is a vector with the total number of reads observed at each
SNP. Each entry of the vector corresponds to a different SNP. This list can
have a single entry if the data is comprised of a single locus.</p>
</td></tr>
<tr><td><code id="pool2vcf_+3A_file">file</code></td>
<td>
<p>is a character string naming the file to write to.</p>
</td></tr>
<tr><td><code id="pool2vcf_+3A_pos">pos</code></td>
<td>
<p>is an optional input (default is NULL). If the actual position of
the SNPs are known, they can be used as input here. When working with a
single locus, this should be a numeric vector with each entry corresponding
to the position of each SNP. If the data has multiple loci, this should be
a list where each entry is a numeric vector with the position of the SNPs
for a different locus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It starts by converting the number of reads with the <code>reference</code> allele,
the <code>alternative</code> allele and the <code>total</code> depth of coverage to a
R,A:DP string. R is the number of reads of the reference allele, A is the
number of reads of the alternative allele and DP is the total depth of
coverage.
</p>
<p>Then, this information coded as R,A:DP is combined with other necessary
information such as the chromosome of each SNP, the position of the SNP and
the quality of the genotype among others. This creates a data frame where
each row corresponds to a different SNP.
</p>
<p>A <code>file</code> is then created and saved in the current working directory,
with the header lines that go above the table in a VCF file. Finally, the
data frame is appended to that file.
</p>


<h3>Value</h3>

<p>a file in the current working directory containing Pool-seq data in
the VCF format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate Pool-seq data for 100 individuals sampled at a single locus
genotypes &lt;- run_scrm(nDip = 100, nloci = 1, theta = 5)
# simulate Pool-seq data assuming a coverage of 100x and two pools of 50 individuals each
pool &lt;- simPoolseq(genotypes = genotypes, pools = c(50, 50), pError = 100, sError = 0.001,
mCov = 100, vCov = 250, min.minor = 0)
# create a vcf file of the simulated data - this will create a txt file
# pool2vcf(reference = pool$reference, alternative = pool$alternative,
# total = pool$total, file = "myvcf.txt")

# simulate Pool-seq data for 10 individuals sampled at 5 loci
genotypes &lt;- run_scrm(nDip = 10, nloci = 5, theta = 5)
# simulate Pool-seq data assuming a coverage of 100x and a single pool of 10 individuals
pool &lt;- simPoolseq(genotypes = genotypes, pools = 10, pError = 100, sError = 0.001,
mCov = 100, vCov = 250, min.minor = 0)

# create a vcf file of the simulated data - this will create a txt file
# pool2vcf(reference = pool$reference, alternative = pool$alternative,
# total = pool$total, file = "myvcf.txt")

</code></pre>

<hr>
<h2 id='poolPops'>Create Pooled DNA sequencing data for multiple populations</h2><span id='topic+poolPops'></span>

<h3>Description</h3>

<p>This function combines the information for each individual of each population
into information at the population level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poolPops(nPops, nLoci, indContribution, readsReference)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poolPops_+3A_npops">nPops</code></td>
<td>
<p>An integer representing the total number of populations in the
dataset.</p>
</td></tr>
<tr><td><code id="poolPops_+3A_nloci">nLoci</code></td>
<td>
<p>An integer that represents the total number of independent loci
in the dataset.</p>
</td></tr>
<tr><td><code id="poolPops_+3A_indcontribution">indContribution</code></td>
<td>
<p>Either a list or a matrix (when dealing with a single
locus).</p>
</td></tr>
<tr><td><code id="poolPops_+3A_readsreference">readsReference</code></td>
<td>
<p>A list, where each entry contains the information for a
single locus. Each list entry should then have one separate entry per
population. Each of these entries should be a matrix, with each row
corresponding to a single individual and each column a different site.
Thus, each entry of the matrix contains the number of observed reads with
the reference allele for that individual at a given site. The output of the
<code>numberReference</code> or <code>numberReferencePop</code> functions should be the input
here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In other words, the information of all individuals in a given population is
combined into a single population value and this is done for the various
populations. In this situation, each entry of the <code>indContribution</code> and
<code>readsReference</code> lists should contain one entry per population - being, in
essence, a list within a list. Please note that this function is intended to
work for multiple populations and should not be used with a single
population.
</p>


<h3>Value</h3>

<p>a list with three names entries
</p>
<table>
<tr><td><code>reference</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix
with the number of reference allele reads for each population. Each column
represents a different site and each row a different population.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix
with the number of alternative allele reads for each population. Each
column represents a different site and each row a different population.</p>
</td></tr>
<tr><td><code>total</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the coverage of each population. Each column represents a different site
and each row a different population.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coverage at 5 SNPs for two populations, assuming 20x mean coverage
reads &lt;- simulateCoverage(mean = c(20, 20), variance = c(100, 100), nSNPs = 5, nLoci = 1)

# simulate the number of reads contributed by each individual
# for each population there are two pools, each with 5 individuals
indContribution &lt;- popsReads(list_np = rep(list(rep(5, 2)), 2), coverage = reads, pError = 5)

# set seed and create a random matrix of genotypes for the 20 individuals - 10 per population
set.seed(10)
genotypes &lt;- matrix(rpois(100, 0.5), nrow = 20)

# simulate the number of reference reads for the two populations
readsReference &lt;- numberReferencePop(genotypes = genotypes, indContribution = indContribution,
size = rep(list(rep(5, 2)), 2), error = 0.01)

# create Pooled DNA sequencing data for these two populations and for a single locus
poolPops(nPops = 2, nLoci = 1, indContribution = indContribution, readsReference = readsReference)

</code></pre>

<hr>
<h2 id='poolProbs'>Probability of contribution of each pool</h2><span id='topic+poolProbs'></span>

<h3>Description</h3>

<p>This function computes the probability of contribution of each pool towards
the total depth of coverage of a single population. If multiple pools where
used to sequence a single population, it is possible that some pools
contribute more than others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poolProbs(nPools, vector_np, nSNPs, pError)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poolProbs_+3A_npools">nPools</code></td>
<td>
<p>an integer indicating how many pools were used to sequence the
population.</p>
</td></tr>
<tr><td><code id="poolProbs_+3A_vector_np">vector_np</code></td>
<td>
<p>is a vector where each entry contains the number of diploid
individuals of a given pool. Thus, if a population was sequenced using two
pools, each with 10 individuals, this vector would contain two entries and
both will be 10.</p>
</td></tr>
<tr><td><code id="poolProbs_+3A_nsnps">nSNPs</code></td>
<td>
<p>an integer indicating how many SNPs exist in the data.</p>
</td></tr>
<tr><td><code id="poolProbs_+3A_perror">pError</code></td>
<td>
<p>an integer representing the value of the error associated with
DNA pooling. This value is related with the unequal pool contribution
towards the total number of reads of a population - the higher the value
the more unequal are the pool contributions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the probabilities of contribution for each pool. Each
row represents a different pool and each column is a different site.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># probability of contribution at 8 SNPs for 5 pools, each with 10 individuals
poolProbs(nPools = 5, vector_np = rep(10, 5), nSNPs = 8, pError = 50)

</code></pre>

<hr>
<h2 id='poolReads'>Reads contributed by each pool</h2><span id='topic+poolReads'></span>

<h3>Description</h3>

<p>This function simulates the contribution, in terms of reads, of each pool.
The number of reads contributed from all pools is equal to the total coverage
of the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poolReads(nPools, coverage, probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poolReads_+3A_npools">nPools</code></td>
<td>
<p>an integer indicating how many pools were used to sequence the
population.</p>
</td></tr>
<tr><td><code id="poolReads_+3A_coverage">coverage</code></td>
<td>
<p>a vector containing the total depth of coverage of the
population. Each entry of the vector represents a different site.</p>
</td></tr>
<tr><td><code id="poolReads_+3A_probs">probs</code></td>
<td>
<p>a matrix containing the probability of contribution of each pool
used to sequence the population. This matrix can be obtained with the
<code>poolProbs</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the number of reads contributed by each pool towards
the total coverage of the population. Each row of the matrix is a different
pool and each column a different site.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate the probability of contribution of each pool
probs &lt;- poolProbs(nPools = 5, vector_np = rep(10, 5), nSNPs = 8, pError = 50)

# simulate the number of reads contributed, assuming 10x coverage for each site
poolReads(nPools = 5, coverage = rep(10, 8), probs = probs)

</code></pre>

<hr>
<h2 id='popReads'>Compute number of reads for each individual and across all sites</h2><span id='topic+popReads'></span>

<h3>Description</h3>

<p>This function computes the contribution of each individual towards the total
coverage of a given population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popReads(vector_np, coverage, pError)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popReads_+3A_vector_np">vector_np</code></td>
<td>
<p>is a vector where each entry contains the number of diploid
individuals of a given pool. Thus, if a population was sequenced using two
pools, each with 10 individuals, this vector would contain two entries and
both will be 10.</p>
</td></tr>
<tr><td><code id="popReads_+3A_coverage">coverage</code></td>
<td>
<p>a vector containing the total depth of coverage of the
population. Each entry of the vector represents a different site.</p>
</td></tr>
<tr><td><code id="popReads_+3A_perror">pError</code></td>
<td>
<p>an integer representing the value of the error associated with
DNA pooling. This value is related with the unequal contribution of both
individuals and pools towards the total number of reads observed for a
given population - the higher the value the more unequal are the individual
and pool contributions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If multiple pools were used to sequence a population, this will compute the
contribution of each pool and then use that to calculate how many reads does
that pool contribute. Next, the probability of contribution of each
individual is computed and utilized to calculate the number of reads that
each individual contributes towards the total number of reads observed in the
corresponding pool.
</p>


<h3>Value</h3>

<p>a matrix with the number of reads contributed by each individual.
Each row of the matrix corresponds to a different individual and each
column to a different site.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate number of reads contributed by each individual towards the total population coverage
# assuming a coverage of 10x at 5 sites and two pools, each with 5 individuals
popReads(vector_np = c(5, 5), coverage = rep(10, 5), pError = 100)

</code></pre>

<hr>
<h2 id='popsReads'>Simulate total number of reads for multiple populations</h2><span id='topic+popsReads'></span>

<h3>Description</h3>

<p>Simulates the contribution of each individual towards the total coverage of
its population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsReads(list_np, coverage, pError)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsReads_+3A_list_np">list_np</code></td>
<td>
<p>is a list where each entry corresponds to a different
population. Each entry is a vector and each vector entry contains the
number of diploid individuals of a given pool. Thus, if a population was
sequenced using two pools, each with 10 individuals, this vector would
contain two entries and both will be 10.</p>
</td></tr>
<tr><td><code id="popsReads_+3A_coverage">coverage</code></td>
<td>
<p>a matrix containing the total depth of coverage of all
populations. Each row corresponds to a different population and each column
to a different site.</p>
</td></tr>
<tr><td><code id="popsReads_+3A_perror">pError</code></td>
<td>
<p>an integer representing the value of the error associated with
DNA pooling. This value is related with the unequal contribution of both
individuals and pools towards the total number of reads observed for a
given population - the higher the value the more unequal are the individual
and pool contributions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If multiple pools were used to sequence a population, this will compute the
contribution of each pool and then use that to calculate how many reads does
that pool contribute. Next, the probability of contribution of each
individual is computed and utilized to calculate the number of reads that
each individual contributes towards the total number of reads observed in the
corresponding pool. These steps will be performed for each population, thus
obtaining the number of reads contributed by each individual for each
population.
</p>


<h3>Value</h3>

<p>a list with one entry per population. Each entry represents the
number of reads contributed by each individual towards the total coverage
of its population. Different individuals correspond to different rows and
different sites to different columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate coverage for two populations sequenced at 10x at 5 sites
reads &lt;- simulateCoverage(mean = c(10, 10), variance = c(20, 20), nSNPs = 5, nLoci = 1)

# simulate the individual contribution towards that coverage
# assuming that the first population was sequenced using two pools of 5 individuals
# and the second using a single pool with 10 individuals
popsReads(list_np = list(c(5, 5), 10), coverage = reads, pError = 5)

</code></pre>

<hr>
<h2 id='remove_by_reads'>Apply a coverage-based filter over a list</h2><span id='topic+remove_by_reads'></span>

<h3>Description</h3>

<p>This function removes sites that have a coverage below a <code>minimum</code> value and
sites with a coverage above a <code>maximum</code> value. This is done over multiple
loci, assuming that each entry of the <code>reads</code> list is a different locus. If a
list of genotypes is also supplied, then those same sites are also removed
from each locus of the genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_by_reads(nLoci, reads, minimum, maximum, genotypes = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_by_reads_+3A_nloci">nLoci</code></td>
<td>
<p>an integer that represents how many independent loci were
simulated.</p>
</td></tr>
<tr><td><code id="remove_by_reads_+3A_reads">reads</code></td>
<td>
<p>a list with the total depth of coverage. Each entry of the list
should be a matrix corresponding to a different locus. Each row of that
matrix should be the coverage of a different population and each column a
different site.</p>
</td></tr>
<tr><td><code id="remove_by_reads_+3A_minimum">minimum</code></td>
<td>
<p>an integer representing the minimum coverage allowed. Sites
where any population has a depth of coverage below this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="remove_by_reads_+3A_maximum">maximum</code></td>
<td>
<p>an integer representing the maximum coverage allowed. Sites
where any population has a depth of coverage above this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="remove_by_reads_+3A_genotypes">genotypes</code></td>
<td>
<p>an optional list input with the genotypes. Each entry of the
list should be a matrix corresponding to a different locus. Each column of
the matrix should be a different site and each row a different individual.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the total depth of coverage similar to the <code>reads</code> input
argument but without sites where the coverage was below the <code>minimum</code> or
above the <code>maximum</code>. If the genotypes were included, a second list entry
will also be included in the output, containing the genotypes minus the
sites that were removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)

# simulate coverage for 10 locus
reads &lt;- simulateCoverage(mean = c(25, 25), variance = c(200, 200), nSNPs = 10, nLoci = 10)

# remove sites with coverage below 10x or above 100x
reads &lt;- remove_by_reads(nLoci = 10, reads = reads, minimum = 5, maximum = 100)
# notice that some locus no longer have 10 SNPs - those sites were removed
reads

</code></pre>

<hr>
<h2 id='remove_by_reads_matrix'>Apply a coverage-based filter to a matrix</h2><span id='topic+remove_by_reads_matrix'></span>

<h3>Description</h3>

<p>This function removes sites that have a coverage below a <code>minimum</code> value and
sites with a coverage above a <code>maximum</code> value. If a matrix of genotypes is
also supplied, then those same sites are also removed from that matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_by_reads_matrix(reads, minimum, maximum, genotypes = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_by_reads_matrix_+3A_reads">reads</code></td>
<td>
<p>a matrix with the total depth of coverage. Each row of the
matrix should be the coverage of a different population and each column a
different site.</p>
</td></tr>
<tr><td><code id="remove_by_reads_matrix_+3A_minimum">minimum</code></td>
<td>
<p>an integer representing the minimum coverage allowed. Sites
where any population has a depth of coverage below this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="remove_by_reads_matrix_+3A_maximum">maximum</code></td>
<td>
<p>an integer representing the maximum coverage allowed. Sites
where any population has a depth of coverage above this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="remove_by_reads_matrix_+3A_genotypes">genotypes</code></td>
<td>
<p>an optional matrix input with the genotypes. Each column of
the matrix should be a different site and each row a different individual.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the total depth of coverage minus the sites (i.e.
columns) where the coverage for any of the populations was below the
minimum or above the maximum. If genotypes were supplied, then the output
will be a list, with one entry per locus. Each entry will contain the
filtered coverage in the first entry and the genotypes, minus the removed
sites, in the second entry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)

# simulate coverage for a single locus - select the first entry to obtain a matrix
reads &lt;- simulateCoverage(mean = c(25, 25), variance = c(200, 200), nSNPs = 10, nLoci = 1)[[1]]

# check the coverage matrix
reads

# remove sites with coverage below 10x or above 100x
remove_by_reads_matrix(reads = reads, minimum = 10, maximum = 100)

</code></pre>

<hr>
<h2 id='removeSites'>Apply a minor allele reads threshold</h2><span id='topic+removeSites'></span>

<h3>Description</h3>

<p>Removes sites where the total number of minor-allele reads is below a certain
threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeSites(freqs, alternative, coverage, minor, min.minor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeSites_+3A_freqs">freqs</code></td>
<td>
<p>a vector of allele frequencies where each entry corresponds to a
different site.</p>
</td></tr>
<tr><td><code id="removeSites_+3A_alternative">alternative</code></td>
<td>
<p>a matrix with the number of reads with the alternative
allele. Each row should be a different population and each column a
different site.</p>
</td></tr>
<tr><td><code id="removeSites_+3A_coverage">coverage</code></td>
<td>
<p>a matrix with the total coverage. Each row should be a
different population and each column a different site.</p>
</td></tr>
<tr><td><code id="removeSites_+3A_minor">minor</code></td>
<td>
<p>a matrix with the number of minor-allele reads. Each row should
be a different population and each column a different site.</p>
</td></tr>
<tr><td><code id="removeSites_+3A_min.minor">min.minor</code></td>
<td>
<p>is an integer representing the minimum allowed number of
minor-allele reads. Sites that, across all populations, have less
minor-allele reads than this threshold will be removed from the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a site has less minor-allele reads than <code>min.minor</code> across all
populations, that site is removed from the data.
</p>


<h3>Value</h3>

<p>a list with three named entries:
</p>
<table>
<tr><td><code>freqs</code></td>
<td>
<p>is a vector with the allele frequencies minus the frequency of
the removed sites.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>is a matrix with the number of alternative-allele reads
per site, minus any removed sites.</p>
</td></tr>
<tr><td><code>coverage</code></td>
<td>
<p>is a matrix with the depth of coverage minus the coverage
of the removed sites.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># create a vector of allele frequencies
freqs &lt;- runif(20)

set.seed(10)
# create a matrix with the number of reads with the alternative allele
alternative &lt;- matrix(sample(x = c(0,5,10), size = 20, replace = TRUE), nrow = 1)
# create a matrix with the depth of coverage
coverage &lt;- matrix(sample(100:150, size = 20), nrow = 1)
# the number of reads with the reference allele is obtained by subtracting
# the number of alternative allele reads from the depth of coverage
reference &lt;- coverage - alternative

# find the minor allele at each site
minor &lt;- findMinor(reference = reference, alternative = alternative, coverage = coverage)
# keep only the matrix with the minor allele reads
minor &lt;- minor[["minor"]]

# remove sites where the number of minor-allele reads is below the threshold
removeSites(freqs = freqs, alternative = alternative, coverage = coverage,
minor = minor, min.minor = 2)

</code></pre>

<hr>
<h2 id='run_scrm'>Simulate a single population</h2><span id='topic+run_scrm'></span>

<h3>Description</h3>

<p>Simulates the evolution of biological sequences for a single population with
variable theta values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_scrm(nDip, nloci, theta = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_scrm_+3A_ndip">nDip</code></td>
<td>
<p>an integer representing the total number of diploid individuals
to simulate. Note that <code><a href="scrm.html#topic+scrm">scrm::scrm()</a></code> actually simulates haplotypes, so the
number of simulated haplotypes is double of this.</p>
</td></tr>
<tr><td><code id="run_scrm_+3A_nloci">nloci</code></td>
<td>
<p>is an integer that represents how many independent loci should
be simulated.</p>
</td></tr>
<tr><td><code id="run_scrm_+3A_theta">theta</code></td>
<td>
<p>a value for the mutation rate assuming theta = 4Nu, where u is
the neutral mutation rate per locus.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with genotypes. Each entry of the list corresponds to a
different locus. For each locus, the genotypes are in a matrix, with each
row representing a different individual and each column a different site.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>run_scrm(nDip = 100, nloci = 10)
run_scrm(nDip = 100, nloci = 10, theta = 5)

</code></pre>

<hr>
<h2 id='simPoolseq'>Simulate Pool-seq data</h2><span id='topic+simPoolseq'></span>

<h3>Description</h3>

<p>Simulates pooled sequencing data given a set of parameters and individual
genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPoolseq(
  genotypes,
  pools,
  pError,
  sError,
  mCov,
  vCov,
  min.minor,
  minimum = NA,
  maximum = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simPoolseq_+3A_genotypes">genotypes</code></td>
<td>
<p>a list of genotypes, where each entry is a matrix
corresponding to a different locus. At each matrix, each column is a
different SNP and each row is a different individual. Genotypes should be
coded as 0, 1 or 2.</p>
</td></tr>
<tr><td><code id="simPoolseq_+3A_pools">pools</code></td>
<td>
<p>a list with a vector containing the size (in number of diploid
individuals) of each pool. Thus, if a population was sequenced using a
single pool, the vector should contain only one entry. If a population was
sequenced using two pools, each with 10 individuals, this vector should
contain two entries and both will be 10.</p>
</td></tr>
<tr><td><code id="simPoolseq_+3A_perror">pError</code></td>
<td>
<p>an integer representing the value of the error associated with
DNA pooling. This value is related with the unequal contribution of both
individuals and pools towards the total number of reads observed for a
given population - the higher the value the more unequal are the individual
and pool contributions.</p>
</td></tr>
<tr><td><code id="simPoolseq_+3A_serror">sError</code></td>
<td>
<p>a numeric value with error rate associated with the sequencing
and mapping process. This error rate is assumed to be symmetric:
error(reference -&gt; alternative) = error(alternative -&gt; reference). This
number should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="simPoolseq_+3A_mcov">mCov</code></td>
<td>
<p>an integer that defines the mean depth of coverage to simulate.
Please note that this represents the mean coverage across all sites.</p>
</td></tr>
<tr><td><code id="simPoolseq_+3A_vcov">vCov</code></td>
<td>
<p>an integer that defines the mean depth of coverage to simulate.
Please note that this represents the mean coverage across all sites.</p>
</td></tr>
<tr><td><code id="simPoolseq_+3A_min.minor">min.minor</code></td>
<td>
<p>is an integer representing the minimum allowed number of
minor-allele reads. Sites that, across all populations, have less
minor-allele reads than this threshold will be removed from the data.</p>
</td></tr>
<tr><td><code id="simPoolseq_+3A_minimum">minimum</code></td>
<td>
<p>an optional integer representing the minimum coverage allowed.
Sites where the population has a depth of coverage below this threshold are
removed from the data.</p>
</td></tr>
<tr><td><code id="simPoolseq_+3A_maximum">maximum</code></td>
<td>
<p>an optional integer representing the maximum coverage allowed.
Sites where the population has a depth of coverage above this threshold are
removed from the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this functions allows for different combinations of parameters.
Thus, Pool-seq data can be simulated for a variety of parameters. For
instance, different mean depths of coverage can be used to simulate Pool-seq
data. It is also possible to simulate Pool-seq data using different pool
sizes (by changing the <code>pools</code> input) and different values of the
Pool-seq error parameter (<code>pError</code>).
</p>


<h3>Value</h3>

<p>a list with three named entries:
</p>
<table>
<tr><td><code>reference</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the number of reference allele reads. Each column represents a different site.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the number of alternative allele reads. Each column represents a different site.</p>
</td></tr>
<tr><td><code>total</code></td>
<td>
<p>a list with one entry per locus. Each entry is a matrix with
the total depth of coverage. Each column represents a different site.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># simulate Pool-seq data for 100 individuals sampled at a single locus
genotypes &lt;- run_scrm(nDip = 100, nloci = 1, theta = 5)
# simulate Pool-seq data assuming a coverage of 100x and two pools of 50 individuals each
simPoolseq(genotypes = genotypes, pools = c(50, 50), pError = 100, sError = 0.001,
mCov = 100, vCov = 250, min.minor = 0)

# simulate Pool-seq data for 10 individuals sampled at 5 loci
genotypes &lt;- run_scrm(nDip = 10, nloci = 5, theta = 5)
# simulate Pool-seq data assuming a coverage of 100x and a single pool of 10 individuals
simPoolseq(genotypes = genotypes, pools = 10, pError = 100, sError = 0.001,
mCov = 100, vCov = 250, min.minor = 0)

</code></pre>

<hr>
<h2 id='simReads'>Simulate coverage at a single locus</h2><span id='topic+simReads'></span>

<h3>Description</h3>

<p>Simulates the total number of reads, for each polymorphic site of a given
locus using a negative binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simReads(mean, variance, nSNPs = NA, genotypes = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simReads_+3A_mean">mean</code></td>
<td>
<p>an integer that defines the mean depth of coverage to simulate.
Please note that this represents the mean coverage across all sites. If a
vector is supplied instead, the function assumes that each entry of the
vector is the mean for a different population.</p>
</td></tr>
<tr><td><code id="simReads_+3A_variance">variance</code></td>
<td>
<p>an integer that defines the variance of the depth of coverage
across all sites. If a vector is supplied instead, the function assumes
that each entry of the vector is the variance for a different population.</p>
</td></tr>
<tr><td><code id="simReads_+3A_nsnps">nSNPs</code></td>
<td>
<p>an integer representing the number of polymorphic sites per
locus to simulate. This is an optional input but either this or the
<code>genotypes</code> matrix must be supplied.</p>
</td></tr>
<tr><td><code id="simReads_+3A_genotypes">genotypes</code></td>
<td>
<p>a matrix of simulated genotypes, where each column is a
different SNP and each row is a different individual. This is an optional
input but either this or the <code>nSNPs</code> must be supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The total number of reads is simulated with a negative binomial and according
to a user-defined mean depth of coverage and variance. This function is
intended to work with a matrix of genotypes, simulating the depth of coverage
for each site present in the genotypes. However, it can also be used to
simulate coverage distributions independent of genotypes, by choosing how
many sites should be simulated (with the <code>nSNPs</code> option).
</p>


<h3>Value</h3>

<p>a matrix with the total coverage per population and per site.
Different rows represent different populations and each column is a
different site.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coverage for one population at 10 sites
simReads(mean = 20, variance = 100, nSNPs = 10)

# simulate coverage at one locus with 10 SNPs for two populations:
# the first with 100x and the second with 50x
simReads(mean = c(100, 50), variance = c(250, 150), nSNPs = 10)

</code></pre>

<hr>
<h2 id='simulateCoverage'>Simulate total number of reads per site</h2><span id='topic+simulateCoverage'></span>

<h3>Description</h3>

<p>This function simulates the total number of reads, for each polymorphic site
using a negative binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateCoverage(mean, variance, nSNPs = NA, nLoci = NA, genotypes = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateCoverage_+3A_mean">mean</code></td>
<td>
<p>an integer that defines the mean depth of coverage to simulate.
Please note that this represents the mean coverage across all sites. If a
vector is supplied instead, the function assumes that each entry of the
vector is the mean for a different population.</p>
</td></tr>
<tr><td><code id="simulateCoverage_+3A_variance">variance</code></td>
<td>
<p>an integer that defines the variance of the depth of coverage
across all sites. If a vector is supplied instead, the function assumes
that each entry of the vector is the variance for a different population.</p>
</td></tr>
<tr><td><code id="simulateCoverage_+3A_nsnps">nSNPs</code></td>
<td>
<p>an integer representing the number of polymorphic sites per
locus to simulate. This is an optional input but either this or the
<code>genotypes</code> list must be supplied.</p>
</td></tr>
<tr><td><code id="simulateCoverage_+3A_nloci">nLoci</code></td>
<td>
<p>an optional integer that represents how many independent loci
should be simulated.</p>
</td></tr>
<tr><td><code id="simulateCoverage_+3A_genotypes">genotypes</code></td>
<td>
<p>a list of simulated genotypes, where each entry is a matrix
corresponding to a different locus. At each matrix, each column is a
different SNP and each row is a different individual. This is an optional
input but either this or the <code>nSNPs</code> must be supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The total number of reads is simulated with a negative binomial and according
to a user-defined mean depth of coverage and variance. This function is
intended to work with a list of genotypes, simulating the depth of coverage
for each site present in the genotypes. However, it can also be used to
simulate coverage distributions independent of genotypes, by choosing how
many loci to simulate (with the <code>nLoci</code> option) and choosing how many sites
per locus should be simulated (with the <code>nSNPs</code> option).
</p>


<h3>Value</h3>

<p>a list with the total coverage per population and per site. Each list
entry is a matrix corresponding to a different locus. For each matrix,
different rows represent different populations and each column is a
different site.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate 10 loci, each with 10 SNPs for a single population
simulateCoverage(mean = 100, variance = 250, nSNPs = 10, nLoci = 10)

# simulate 10 loci, each with 10 SNPs for two populations:
# the first with 100x and the second with 50x
simulateCoverage(mean = c(100, 50), variance = c(250, 150), nSNPs = 10, nLoci = 10)

# simulate coverage given a set of genotypes
# run scrm and obtain genotypes
genotypes &lt;- run_scrm(nDip = 100, nloci = 10)
# simulate coverage
simulateCoverage(mean = 50, variance = 200, genotypes = genotypes)

</code></pre>

<hr>
<h2 id='splitMatrix'>Split matrix of genotypes</h2><span id='topic+splitMatrix'></span>

<h3>Description</h3>

<p>This function splits a matrix into different list entries. The matrix is
split according to a set of row indexes defined by the <code>size</code> input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitMatrix(matrix, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitMatrix_+3A_matrix">matrix</code></td>
<td>
<p>is obviously a matrix, ideally one containing genotypes. Each
column of the matrix should be a different site and each row a different
individual.</p>
</td></tr>
<tr><td><code id="splitMatrix_+3A_size">size</code></td>
<td>
<p>a list with one entry per population. Each entry should be a
vector containing the size (in number of diploid individuals) of each pool.
Thus, if a population was sequenced using a single pool, the vector should
contain only one entry. If a population was sequenced using two pools, each
with 10 individuals, this vector should contain two entries and both will
be 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>size</code> input is utilized to create the index of the rows that go into the
different list entries. It specifies the size, in terms of number of
individuals, of each population.
</p>


<h3>Value</h3>

<p>a list with one entry per entry of the size input argument. Each
entry contains the information of the original matrix for the number of
individuals specified by the corresponding entry of the size input
argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)

# create a random matrix
mymatrix &lt;- matrix(round(runif(n = 50, min = 10, max = 25)), nrow = 10)

# split that matrix assuming 8 individuals in the first population and two in the second
splitMatrix(matrix = mymatrix, size = list(8, 2))

</code></pre>

<hr>
<h2 id='strg2sync'>Create sync string for a single SNP</h2><span id='topic+strg2sync'></span>

<h3>Description</h3>

<p>Creates a string with the information for a single SNP. The information is
coded as A-count:T-count:C-count:G-count:N-count:deletion-count. Note that we
assume that the reference allele is always A and the alternative is always T.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strg2sync(reference, alternative)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strg2sync_+3A_reference">reference</code></td>
<td>
<p>an integer representing the number of reads with the
reference allele.</p>
</td></tr>
<tr><td><code id="strg2sync_+3A_alternative">alternative</code></td>
<td>
<p>an integer representing the number of reads with the
alternative allele.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string coded as
A-count:T-count:C-count:G-count:N-count:deletion-count.
</p>

<hr>
<h2 id='strg2vcf'>Create vcf string for a single SNP</h2><span id='topic+strg2vcf'></span>

<h3>Description</h3>

<p>Creates a string with the information for a single SNP. The information is
coded as R,A:DP. R is the number of reads of the reference allele, A is the
number of reads of the alternative allele and DP is the total depth of
coverage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strg2vcf(reference, alternative, total)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strg2vcf_+3A_reference">reference</code></td>
<td>
<p>an integer representing the number of reads with the
reference allele</p>
</td></tr>
<tr><td><code id="strg2vcf_+3A_alternative">alternative</code></td>
<td>
<p>an integer representing the number of reads with the
alternative allele</p>
</td></tr>
<tr><td><code id="strg2vcf_+3A_total">total</code></td>
<td>
<p>an integer representing the total number of reads observed at
this SNP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string coded as R,A:DP.
</p>

<hr>
<h2 id='vcfinfo'>Create vcf table with relevant information</h2><span id='topic+vcfinfo'></span>

<h3>Description</h3>

<p>Creates a data frame in the VCF format for all SNPs and across all loci in
the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcfinfo(string, pos = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcfinfo_+3A_string">string</code></td>
<td>
<p>is a character vector or a list where each entry contains a
character vector for a different locus. Each entry of this character vector
contains the information for a single SNP coded as R,A:DP. The output of
the <code><a href="#topic+vcflocus">vcflocus</a></code> or <code><a href="#topic+vcfloci">vcfloci</a></code> is the intended input
here.</p>
</td></tr>
<tr><td><code id="vcfinfo_+3A_pos">pos</code></td>
<td>
<p>is an optional input (default is NULL). If the actual position of
the SNPs are known, they can be used as input here. When working with a
single locus, this should be a numeric vector with each entry corresponding
to the position of each SNP. If the data has multiple loci, this should be
a list where each entry is a numeric vector with the position of the SNPs
for a different locus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines the information coded as R,A:DP with other necessary
information such as the chromosome of each SNP, the position of the SNP and
the quality of the genotype among others. Note that in the character string,
R is the number of reads of the reference allele, A is the number of reads of
the alternative allele and DP is the total depth of coverage. Each row of the
data frame corresponds to a different SNP.
</p>


<h3>Value</h3>

<p>a data frame with 10 different columns
</p>
<table>
<tr><td><code>chr</code></td>
<td>
<p>Chromosome. Each locus is treated as different linkage group.</p>
</td></tr>
<tr><td><code>pos</code></td>
<td>
<p>Co-ordinate. The coordinate of the SNP.</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>
<p>Identifier.</p>
</td></tr>
<tr><td><code>REF</code></td>
<td>
<p>Reference allele. We assume that the reference allele is always
an A. Note that this is not necessarily the major allele.</p>
</td></tr>
<tr><td><code>ALT</code></td>
<td>
<p>Alternative allele. We assume that the alternative allele is always
a T.</p>
</td></tr>
<tr><td><code>QUAL</code></td>
<td>
<p>Quality score out of 100. We assume that this score is always
100.</p>
</td></tr>
<tr><td><code>FILTER</code></td>
<td>
<p>If this SNP passed quality filters.</p>
</td></tr>
<tr><td><code>INFO</code></td>
<td>
<p>Further information. Provides further information on the
variants.</p>
</td></tr>
<tr><td><code>FORMAT</code></td>
<td>
<p>Information about the following columns. This column tells us
how the number of reads is coded in the next column.</p>
</td></tr>
<tr><td><code>pop1</code></td>
<td>
<p>Number of reference-allele reads, alternative-allele reads and
total depth of coverage observed for this population at this SNP.</p>
</td></tr>
</table>

<hr>
<h2 id='vcfloci'>Create vcf string for all SNPs in multiple loci</h2><span id='topic+vcfloci'></span>

<h3>Description</h3>

<p>Creates a string with the information for all SNPs across multiple loci. The
information is coded as R,A:DP. R is the number of reads of the reference
allele, A is the number of reads of the alternative allele and DP is the
total depth of coverage. Each entry of the character string corresponds to a
different SNP and each entry of the list to a different locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcfloci(reference, alternative, total)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcfloci_+3A_reference">reference</code></td>
<td>
<p>is a list where each entry corresponds to a different locus.
Each list entry is a vector with the number of reads with the reference
allele. Each entry of the vector corresponds to a different SNP.</p>
</td></tr>
<tr><td><code id="vcfloci_+3A_alternative">alternative</code></td>
<td>
<p>is a list where each entry corresponds to a different
locus. Each list entry is a vector with the number of reads with the
alternative allele. Each entry of the vector corresponds to a different
SNP.</p>
</td></tr>
<tr><td><code id="vcfloci_+3A_total">total</code></td>
<td>
<p>is a list where each entry corresponds to a different locus.
Each list entry is a vector with the total number of reads observed at each
SNP. Each entry of the vector corresponds to a different SNP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>is a list where each entry corresponds to a different locus. Each
entry of the list is a character vector with as many entries as the number
of SNPs in the locus. Each entry of this character vector contains the
information for a single SNP coded as R,A:DP.
</p>

<hr>
<h2 id='vcflocus'>Create vcf string for all SNPs in a single locus</h2><span id='topic+vcflocus'></span>

<h3>Description</h3>

<p>Creates a string with the information for all SNPs. The information is coded
as R,A:DP. R is the number of reads of the reference allele, A is the number
of reads of the alternative allele and DP is the total depth of coverage.
Each entry of the character string corresponds to a different SNP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcflocus(reference, alternative, total)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcflocus_+3A_reference">reference</code></td>
<td>
<p>is a vector with the number of reads with the reference
allele. Each entry of the vector corresponds to a different SNP.</p>
</td></tr>
<tr><td><code id="vcflocus_+3A_alternative">alternative</code></td>
<td>
<p>is a vector with the number of reads with the alternative
allele. Each entry of the vector corresponds to a different SNP.</p>
</td></tr>
<tr><td><code id="vcflocus_+3A_total">total</code></td>
<td>
<p>is a vector with the total number of reads observed at each SNP.
Each entry of the vector corresponds to a different SNP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>is a character vector with as many entries as the number of SNPs in
the locus. Each entry of this character vector contains the information for
a single SNP coded as R,A:DP.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
