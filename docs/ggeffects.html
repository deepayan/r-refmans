<!DOCTYPE html><html><head><title>Help for package ggeffects</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggeffects}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.ggeffects'><p>Adjusted predictions from regression models</p></a></li>
<li><a href='#collapse_by_group'><p>Collapse raw data by random effect groups</p></a></li>
<li><a href='#efc'><p>Sample dataset from the EUROFAMCARE project</p></a></li>
<li><a href='#fish'><p>Sample data set</p></a></li>
<li><a href='#format.ggeffects'><p>Print and format ggeffects-objects</p></a></li>
<li><a href='#get_title'><p>Get titles and labels from data</p></a></li>
<li><a href='#install_latest'><p>Update latest ggeffects-version from R-universe (GitHub) or CRAN</p></a></li>
<li><a href='#johnson_neyman'><p>Spotlight-analysis: Create Johnson-Neyman confidence intervals and plots</p></a></li>
<li><a href='#lung2'><p>Sample data set</p></a></li>
<li><a href='#new_data'><p>Create a data frame from all combinations of predictor values</p></a></li>
<li><a href='#plot'><p>Plot ggeffects-objects</p></a></li>
<li><a href='#pool_comparisons'><p>Pool contrasts and comparisons from <code>test_predictions()</code></p></a></li>
<li><a href='#pool_predictions'><p>Pool Predictions or Estimated Marginal Means</p></a></li>
<li><a href='#predict_response'><p>Adjusted predictions and estimated marginal means from regression models</p></a></li>
<li><a href='#pretty_range'><p>Create a pretty sequence over a range of a vector</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#residualize_over_grid'><p>Compute partial residuals from a data grid</p></a></li>
<li><a href='#test_predictions'><p>(Pairwise) comparisons between predictions (marginal effects)</p></a></li>
<li><a href='#values_at'><p>Calculate representative values of a vector</p></a></li>
<li><a href='#vcov'><p>Calculate variance-covariance matrix for adjusted predictions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Create Tidy Data Frames of Marginal Effects for 'ggplot' from
Model Outputs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Lüdecke &lt;d.luedecke@uke.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute marginal effects and adjusted predictions from statistical
    models and returns the result as tidy data frames. These data frames are 
    ready to use with the 'ggplot2'-package. Effects and predictions can be 
    calculated for many different models. Interaction terms, splines and 
    polynomial terms are also supported. The main functions are ggpredict(), 
    ggemmeans() and ggeffect(). There is a generic plot()-method to plot the 
    results using 'ggplot2'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, insight (&ge; 0.19.8), stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AER, aod, bayestestR, betareg, brglm2, brms, broom, car,
carData, clubSandwich, datawizard (&ge; 0.9.0), effects (&ge;
4.2-2), emmeans (&ge; 1.8.9), fixest, gam, gamlss, gamm4, gee,
geepack, ggplot2, ggrepel, GLMMadaptive, glmmTMB (&ge; 1.1.7),
gridExtra, gt, haven, httr, jsonlite, knitr, lme4 (&ge; 1.1-35),
logistf, magrittr, margins, marginaleffects (&ge; 0.16.0), MASS,
Matrix, mice, MCMCglmm, mgcv, nestedLogit (&ge; 0.3.0), nlme,
nnet, ordinal, parameters, parsnip, patchwork, pscl, quantreg,
rmarkdown, rms, robustbase, rstanarm, rstantools, sandwich,
sdmTMB (&ge; 0.4.0), see, sjlabelled (&ge; 1.1.2), sjstats, survey,
survival, testthat, tibble, tinytable (&ge; 0.1.0), withr, VGAM</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://strengejacke.github.io/ggeffects/">https://strengejacke.github.io/ggeffects/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/strengejacke/ggeffects/issues/">https://github.com/strengejacke/ggeffects/issues/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-25 21:14:06 UTC; Daniel</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Lüdecke <a href="https://orcid.org/0000-0002-8895-3206"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Frederik Aust <a href="https://orcid.org/0000-0003-4900-788X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Sam Crawley <a href="https://orcid.org/0000-0002-7847-0411"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Mattan S. Ben-Shachar
    <a href="https://orcid.org/0000-0002-4287-4801"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Sean C. Anderson <a href="https://orcid.org/0000-0001-9563-1937"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-26 05:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.ggeffects'>Adjusted predictions from regression models</h2><span id='topic+as.data.frame.ggeffects'></span><span id='topic+ggaverage'></span><span id='topic+ggeffect'></span><span id='topic+ggemmeans'></span><span id='topic+ggpredict'></span>

<h3>Description</h3>

<p>The <strong>ggeffects</strong> package computes marginal means and adjusted predicted
values for the response, at the margin of specific values or levels from
certain model terms. The package is built around three core functions:
<code>predict_response()</code> (understanding results), <code>test_predictions()</code> (testing
results for statistically significant differences) and <code>plot()</code> (communicate
results).
</p>
<p>By default, adjusted predictions or marginal means are by returned on the
<em>response</em> scale, which is the easiest and most intuitive scale to interpret
the results. There are other options for specific models as well, e.g. with
zero-inflation component (see documentation of the <code>type</code>-argument). The
result is returned as consistent data frame, which is nicely printed by
default. <code>plot()</code> can be used to easily create figures.
</p>
<p>The main function to calculate marginal means and adjusted predictions is
<code>predict_response()</code>. In previous versions of <strong>ggeffects</strong>, the functions
<code>ggpredict()</code>, <code>ggemmeans()</code>, <code>ggeffect()</code> and <code>ggaverage()</code> were used to
calculate marginal means and adjusted predictions. These functions are still
available, but <code>predict_response()</code> as a &quot;wrapper&quot; around these functions is
the preferred way to do this now.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggeffects'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  ...,
  stringsAsFactors = FALSE,
  terms_to_colnames = FALSE
)

ggaverage(
  model,
  terms,
  ci_level = 0.95,
  type = "fixed",
  typical = "mean",
  condition = NULL,
  back_transform = TRUE,
  vcov_fun = NULL,
  vcov_type = NULL,
  vcov_args = NULL,
  weights = NULL,
  verbose = TRUE,
  ...
)

ggeffect(model, terms, ci_level = 0.95, verbose = TRUE, ci.lvl = ci_level, ...)

ggemmeans(
  model,
  terms,
  ci_level = 0.95,
  type = "fixed",
  typical = "mean",
  condition = NULL,
  back_transform = TRUE,
  interval = "confidence",
  verbose = TRUE,
  ci.lvl = ci_level,
  back.transform = back_transform,
  ...
)

ggpredict(
  model,
  terms,
  ci_level = 0.95,
  type = "fixed",
  typical = "mean",
  condition = NULL,
  back_transform = TRUE,
  ppd = FALSE,
  vcov_fun = NULL,
  vcov_type = NULL,
  vcov_args = NULL,
  interval,
  verbose = TRUE,
  ci.lvl = ci_level,
  back.transform = back_transform,
  vcov.fun = vcov_fun,
  vcov.type = vcov_type,
  vcov.args = vcov_args,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.ggeffects_+3A_x">x</code></td>
<td>
<p>An object of class <code>ggeffects</code>, as returned by <code>predict_response()</code>,
<code>ggpredict()</code>, <code>ggeffect()</code>, <code>ggaverage()</code> or <code>ggemmeans()</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row
names for the data frame.  Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_optional">optional</code></td>
<td>
<p>logical. If <code>TRUE</code>, setting row names and
converting column names (to syntactic names: see
<code><a href="base.html#topic+make.names">make.names</a></code>) is optional.  Note that all of <span class="rlang"><b>R</b></span>'s
<span class="pkg">base</span> package <code>as.data.frame()</code> methods use
<code>optional</code> only for column names treatment, basically with the
meaning of <code><a href="base.html#topic+data.frame">data.frame</a>(*, check.names = !optional)</code>.
See also the <code>make.names</code> argument of the <code>matrix</code> method.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_...">...</code></td>
<td>
<p>Arguments are passed down to <code>ggpredict()</code> (further down to <code>predict()</code>)
or <code>ggemmeans()</code> (and thereby to <code>emmeans::emmeans()</code>), If <code>type = "simulate"</code>,
<code>...</code> may also be used to set the number of simulation, e.g. <code>nsim = 500</code>.
When calling <code>ggeffect()</code>, further arguments passed down to <code>effects::Effect()</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical: should the character vector be converted
to a factor?</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_terms_to_colnames">terms_to_colnames</code></td>
<td>
<p>Logical, if <code>TRUE</code>, standardized column names (like
<code>"x"</code>, <code>"group"</code> or <code>"facet"</code>) are replaced by the variable names of the focal
predictors specified in <code>terms</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_model">model</code></td>
<td>
<p>A model object, or a list of model objects.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_terms">terms</code></td>
<td>
<p>Names of those terms from <code>model</code>, for which predictions should
be displayed (so called <em>focal terms</em>). Can be:
</p>

<ul>
<li><p> A character vector, specifying the names of the focal terms. This is the
preferred and probably most flexible way to specify focal terms, e.g.
<code>terms = "x [40:60]"</code>, to calculate predictions for the values 40 to 60.
</p>
</li>
<li><p> A list, where each element is a named vector, specifying the focal terms
and their values. This is the &quot;classical&quot; R way to specify focal terms,
e.g. <code>list(x = 40:60)</code>.
</p>
</li>
<li><p> A formula, e.g. <code>terms = ~ x + z</code>, which is internally converted to a
character vector. This is probably the least flexible way, as you cannot
specify representative values for the focal terms.
</p>
</li>
<li><p> A data frame representig a &quot;data grid&quot; or &quot;reference grid&quot;. Predictions
are then made for all combinations of the variables in the data frame.
</p>
</li></ul>

<p>At least one term is required to calculate effects for certain terms,
maximum length is four terms, where the second to fourth term indicate the
groups, i.e. predictions of first term are grouped at meaningful values or
levels of the remaining terms (see <code><a href="#topic+values_at">values_at()</a></code>). If <code>terms</code> is missing
or <code>NULL</code>, adjusted predictions for each model term are calculated (i.e.
each model term is used as single focal term). It is also possible to define
specific values for focal terms, at which adjusted predictions should be
calculated (see 'Details'). All remaining covariates that are not specified
in <code>terms</code> are held constant (see 'Details'). See also arguments <code>condition</code>
and <code>typical</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_ci_level">ci_level</code></td>
<td>
<p>Numeric, the level of the confidence intervals. Use
<code>ci_level = NA</code> if confidence intervals should not be calculated
(for instance, due to computation time). Typically, confidence intervals are
based on the returned standard errors for the predictions, assuming a t- or
normal distribution (based on the model and the available degrees of freedom,
i.e. roughly <code style="white-space: pre;">&#8288;+/- 1.96 * SE&#8288;</code>). See introduction of
<a href="https://strengejacke.github.io/ggeffects/articles/ggeffects.html">this vignette</a>
for more details.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_type">type</code></td>
<td>
<p>Character, indicating whether predictions should be conditioned
on specific model components or not. Consequently, most options only apply
for survival models, mixed effects models and/or models with zero-inflation
(and their Bayesian counter-parts); only exeption is <code>type = "simulate"</code>,
which is available for some other model classes as well (which respond to
<code>simulate()</code>).
</p>
<p><strong>Note:</strong> For <code>brmsfit</code>-models with zero-inflation component,
there is no <code>type = "zero_inflated"</code> nor <code>type = "zi_random"</code>; predicted
values for <code>MixMod</code>-models from <strong>GLMMadaptive</strong> with zero-inflation
component <em>always</em> condition on the zero-inflation part of the model (see
'Details').
</p>

<ul>
<li> <p><code>"fixed"</code> (or <code>"fe"</code> or <code>"count"</code>)
</p>
<p>Predicted values are conditioned on the fixed effects or conditional
model only (for mixed models: predicted values are on the population-level
and <em>confidence intervals</em> are returned, i.e. <code>re.form = NA</code> when calling
<code>predict()</code>). For instance, for models fitted with <code>zeroinfl</code> from <strong>pscl</strong>,
this would return the predicted mean from the count component (without
zero-inflation). For models with zero-inflation component, this type calls
<code>predict(..., type = "link")</code> (however, predicted values are
back-transformed to the response scale).
</p>
</li>
<li> <p><code>"fixed_ppd"</code>
</p>
<p>Only applies to <code>margin = "mean_reference"</code>, and only for Bayesian
models of class <code>stanreg</code> or <code>brmsfit</code>. Computes the posterior predictive
distribution. It is the same as setting <code>type = "fixed"</code> in combination with
<code>ppd = TRUE</code>.
</p>
</li>
<li> <p><code>"random"</code> (or <code>"re"</code>)
</p>
<p>This only applies to mixed models, and <code>type = "random"</code> does not condition
on the zero-inflation component of the model. <code>type = "random"</code> still
returns population-level predictions, however, conditioned on random effects
and considering individual level predictions, i.e. <code>re.form = NULL</code> when
calling <code>predict()</code>. This may affect the returned predicted values, depending
on whether <code>REML = TRUE</code> or <code>REML = FALSE</code> was used for model fitting.
Furthermore, unlike <code>type = "fixed"</code>, intervals also consider the uncertainty
in the variance parameters (the mean random effect variance, see <em>Johnson
et al. 2014</em> for details) and hence can be considered as <em>prediction intervals</em>.
For models with zero-inflation component, this type calls
<code>predict(..., type = "link")</code> (however, predicted values are back-transformed
to the response scale).
</p>
<p>To get predicted values for each level of the random effects groups, add the
name of the related random effect term to the <code>terms</code>-argument
(for more details, see
<a href="https://strengejacke.github.io/ggeffects/articles/introduction_effectsatvalues.html">this vignette</a>).
</p>
</li>
<li> <p><code>"random_ppd"</code>
</p>
<p>Only applies to <code>margin = "mean_reference"</code>,, and only for Bayesian
models of class <code>stanreg</code> or <code>brmsfit</code>. Computes the posterior predictive
distribution. It is the same as setting <code>type = "random"</code> in combination with
<code>ppd = TRUE</code>.
</p>
</li>
<li> <p><code>"zero_inflated"</code> (or <code>"fe.zi"</code> or <code>"zi"</code>)
</p>
<p>Predicted values are conditioned on the fixed effects and the zero-inflation
component. For instance, for models fitted with <code>zeroinfl</code>
from <strong>pscl</strong>, this would return the predicted response (<code>mu*(1-p)</code>)
and for <strong>glmmTMB</strong>, this would return the expected value <code>mu*(1-p)</code>
<em>without</em> conditioning on random effects (i.e. random effect variances
are not taken into account for the confidence intervals). For models with
zero-inflation component, this type calls <code>predict(..., type = "response")</code>.
See 'Details'.
</p>
</li>
<li> <p><code>"zi_random"</code> (or <code>"re.zi"</code> or <code>"zero_inflated_random"</code>)
</p>
<p>Predicted values are conditioned on the zero-inflation component and
take the random effects uncertainty into account. For models fitted with
<code>glmmTMB()</code>, <code>hurdle()</code> or <code>zeroinfl()</code>, this would return the
expected value <code>mu*(1-p)</code>. For <strong>glmmTMB</strong>, prediction intervals
also consider the uncertainty in the random effects variances. This
type calls <code>predict(..., type = "response")</code>. See 'Details'.
</p>
</li>
<li> <p><code>"zi_prob"</code> (or <code>"zi.prob"</code>)
</p>
<p>Predicted zero-inflation probability. For <strong>glmmTMB</strong> models with
zero-inflation component, this type calls <code>predict(..., type = "zlink")</code>;
models from <strong>pscl</strong> call <code>predict(..., type = "zero")</code> and for
<strong>GLMMadaptive</strong>, <code>predict(..., type = "zero_part")</code> is called.
</p>
</li>
<li> <p><code>"simulate"</code> (or <code>"sim"</code>)
</p>
<p>Predicted values and confidence resp. prediction intervals are
based on simulations, i.e. calls to <code>simulate()</code>. This type
of prediction takes all model uncertainty into account, including
random effects variances. Currently supported models are objects of
class <code>lm</code>, <code>glm</code>, <code>glmmTMB</code>, <code>wbm</code>, <code>MixMod</code>
and <code>merMod</code>. See <code>...</code> for details on number of simulations.
</p>
</li>
<li> <p><code>"survival"</code> and <code>"cumulative_hazard"</code> (or <code>"surv"</code> and <code>"cumhaz"</code>)
</p>
<p>Applies only to <code>coxph</code>-objects from the <strong>survial</strong>-package and
calculates the survival probability or the cumulative hazard of an event.
</p>
</li></ul>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_typical">typical</code></td>
<td>
<p>Character vector, naming the function to be applied to the
covariates (non-focal terms) over which the effect is &quot;averaged&quot;. The
default is <code>"mean"</code>. Can be <code>"mean"</code>, &quot;<code>weighted.mean</code>&quot;, <code>"median"</code>, <code>"mode"</code>
or <code>"zero"</code>, which call the corresponding R functions (except <code>"mode"</code>,
which calls an internal function to compute the most common value); <code>"zero"</code>
simply returns 0. By default, if the covariate is a factor, only <code>"mode"</code> is
applicable; for all other values (including the default, <code>"mean"</code>) the
reference level is returned. For character vectors, only the mode is returned.
You can use a named vector to apply different functions to integer, numeric and
categorical covariates, e.g. <code>typical = c(numeric = "median", factor = "mode")</code>.
If <code>typical</code> is <code>"weighted.mean"</code>, weights from the model are used. If no
weights are available, the function falls back to <code>"mean"</code>. <strong>Note</strong> that this
argument is ignored for <code>predict_response()</code>, because the <code>margin</code> argument
takes care of this.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_condition">condition</code></td>
<td>
<p>Named character vector, which indicates covariates that
should be held constant at specific values. Unlike <code>typical</code>, which
applies a function to the covariates to determine the value that is used
to hold these covariates constant, <code>condition</code> can be used to define
exact values, for instance <code>condition = c(covariate1 = 20, covariate2 = 5)</code>.
See 'Examples'.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_back_transform">back_transform</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default), predicted values
for log- or log-log transformed responses will be back-transformed to
original response-scale.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_vcov_fun">vcov_fun</code></td>
<td>
<p>Variance-covariance matrix used to compute uncertainty
estimates (e.g., for confidence intervals based on robust standard errors).
This argument accepts a covariance matrix, a function which returns a
covariance matrix, or a string which identifies the function to be used to
compute the covariance matrix.
</p>

<ul>
<li><p> A (variance-covariance) matrix
</p>
</li>
<li><p> A function which returns a covariance matrix (e.g., <code>stats::vcov()</code>)
</p>
</li>
<li><p> A string which indicates the estimation type for the heteroscedasticity-consistent
variance-covariance matrix, e.g. <code>vcov_fun = "HC0"</code>. Possible values are
<code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, and <code>"HC5"</code>, which
will then call the <code>vcovHC()</code>-function from the <strong>sandwich</strong> package, using
the specified type. Further possible values are <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, and <code>"CR3"</code>, which will call the <code>vcovCR()</code>-function from
the <strong>clubSandwich</strong> package.
</p>
</li>
<li><p> A string which indicates the name of the <code style="white-space: pre;">&#8288;vcov*()&#8288;</code>-function from the
<strong>sandwich</strong> or <strong>clubSandwich</strong> packages, e.g. <code>vcov_fun = "vcovCL"</code>,
which is used to compute (cluster) robust standard errors for predictions.
</p>
</li></ul>

<p>If <code>NULL</code>, standard errors (and confidence intervals) for predictions are
based on the standard errors as returned by the <code>predict()</code>-function.
<strong>Note</strong> that probably not all model objects that work with <code>ggpredict()</code>
are also supported by the <strong>sandwich</strong> or <strong>clubSandwich</strong> packages.
</p>
<p>See details in <a href="https://strengejacke.github.io/ggeffects/articles/practical_robustestimation.html">this vignette</a>.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_vcov_type">vcov_type</code></td>
<td>
<p>Character vector, specifying the estimation type for the
robust covariance matrix estimation (see <code>?sandwich::vcovHC</code>
or <code>?clubSandwich::vcovCR</code> for details). Only used when <code>vcov_fun</code> is a
character string indicating one of the functions from those packages.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_vcov_args">vcov_args</code></td>
<td>
<p>List of named vectors, used as additional arguments that
are passed down to <code>vcov_fun</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_weights">weights</code></td>
<td>
<p>Character vector, naming the weigthing variable in the data,
or a vector of weights (of same length as the number of observations in the
data). Only applies to <code>margin = "empirical"</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages or warnings.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_ci.lvl">ci.lvl</code>, <code id="as.data.frame.ggeffects_+3A_vcov.fun">vcov.fun</code>, <code id="as.data.frame.ggeffects_+3A_vcov.type">vcov.type</code>, <code id="as.data.frame.ggeffects_+3A_vcov.args">vcov.args</code>, <code id="as.data.frame.ggeffects_+3A_back.transform">back.transform</code></td>
<td>
<p>Deprecated arguments.
Please use <code>ci_level</code>, <code>vcov_fun</code>, <code>vcov_type</code>, <code>vcov_args</code> and <code>back_transform</code>
instead.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_interval">interval</code></td>
<td>
<p>Type of interval calculation, can either be <code>"confidence"</code>
(default) or <code>"prediction"</code>. May be abbreviated. Unlike <em>confidence intervals</em>,
<em>prediction intervals</em> include the residual variance (sigma^2) to account for
the uncertainty of predicted values. For mixed models, <code>interval = "prediction"</code>
is the default for <code>type = "random"</code>. When <code>type = "fixed"</code>, the default is
<code>interval = "confidence"</code>. Note that prediction intervals are not available
for all models, but only for models that work with <code><a href="insight.html#topic+get_sigma">insight::get_sigma()</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.ggeffects_+3A_ppd">ppd</code></td>
<td>
<p>Logical, if <code>TRUE</code>, predictions for Stan-models are based on the
posterior predictive distribution <code><a href="rstantools.html#topic+posterior_predict">rstantools::posterior_predict()</a></code>. If
<code>FALSE</code> (the default), predictions are based on posterior draws of the linear
predictor <code><a href="rstantools.html#topic+posterior_linpred">rstantools::posterior_linpred()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see <code>?predict_response</code> for details and examples.
</p>


<h3>Value</h3>

<p>A data frame (with <code>ggeffects</code> class attribute) with consistent data columns:
</p>

<ul>
<li> <p><code>"x"</code>: the values of the first term in <code>terms</code>, used as x-position in plots.
</p>
</li>
<li> <p><code>"predicted"</code>: the predicted values of the response, used as y-position in plots.
</p>
</li>
<li> <p><code>"std.error"</code>: the standard error of the predictions. <em>Note that the standard
errors are always on the link-scale, and not back-transformed for non-Gaussian
models!</em>
</p>
</li>
<li> <p><code>"conf.low"</code>: the lower bound of the confidence interval for the predicted values.
</p>
</li>
<li> <p><code>"conf.high"</code>: the upper bound of the confidence interval for the predicted values.
</p>
</li>
<li> <p><code>"group"</code>: the grouping level from the second term in <code>terms</code>, used as
grouping-aesthetics in plots.
</p>
</li>
<li> <p><code>"facet"</code>: the grouping level from the third term in <code>terms</code>, used to indicate
facets in plots.
</p>
<p>The estimated marginal means (or predicted values) are always on the
response scale!
</p>
<p>For proportional odds logistic regression (see <code>?MASS::polr</code>)
resp. cumulative link models (e.g., see <code>?ordinal::clm</code>),
an additional column <code>"response.level"</code> is returned, which indicates
the grouping of predictions based on the level of the model's response.
</p>
<p>Note that for convenience reasons, the columns for the intervals
are always named <code>"conf.low"</code> and <code>"conf.high"</code>, even though
for Bayesian models credible or highest posterior density intervals
are returned.
</p>
<p>There is an <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code> method for objects of class <code>ggeffects</code>,
which has an <code>terms_to_colnames</code> argument, to use the term names as column
names instead of the standardized names <code>"x"</code> etc.
</p>
</li></ul>


<hr>
<h2 id='collapse_by_group'>Collapse raw data by random effect groups</h2><span id='topic+collapse_by_group'></span>

<h3>Description</h3>

<p>This function extracts the raw data points (i.e. the data
that was used to fit the model) and &quot;averages&quot; (i.e. &quot;collapses&quot;) the
response variable over the levels of the grouping factor given in
<code>collapse_by</code>. Only works with mixed models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_by_group(grid, model, collapse_by = NULL, residuals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_by_group_+3A_grid">grid</code></td>
<td>
<p>A data frame representing the data grid, or an object of class
<code>ggeffects</code>, as returned by <code>predict_response()</code>.</p>
</td></tr>
<tr><td><code id="collapse_by_group_+3A_model">model</code></td>
<td>
<p>The model for which to compute partial residuals. The data grid
<code>grid</code> should match to predictors in the model.</p>
</td></tr>
<tr><td><code id="collapse_by_group_+3A_collapse_by">collapse_by</code></td>
<td>
<p>Name of the (random effects) grouping factor. Data is
collapsed by the levels of this factor.</p>
</td></tr>
<tr><td><code id="collapse_by_group_+3A_residuals">residuals</code></td>
<td>
<p>Logical, if <code>TRUE</code>, collapsed partial residuals instead
of raw data by the levels of the grouping factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with raw data points, averaged over the levels of
the given grouping factor from the random effects. The group level of
the random effect is saved in the column <code>"random"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggeffects)
data(efc, package = "ggeffects")
efc$e15relat &lt;- as.factor(efc$e15relat)
efc$c161sex &lt;- as.factor(efc$c161sex)
levels(efc$c161sex) &lt;- c("male", "female")
model &lt;- lme4::lmer(neg_c_7 ~ c161sex + (1 | e15relat), data = efc)
me &lt;- predict_response(model, terms = "c161sex")
head(attributes(me)$rawdata)
collapse_by_group(me, model, "e15relat")

</code></pre>

<hr>
<h2 id='efc'>Sample dataset from the EUROFAMCARE project</h2><span id='topic+efc'></span><span id='topic+efc_test'></span>

<h3>Description</h3>

<p>A SPSS sample data set, imported with the <code>sjlabelled::read_spss()</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach EFC-data
data(efc)

# Show structure
str(efc)

# show first rows
head(efc)
</code></pre>

<hr>
<h2 id='fish'>Sample data set</h2><span id='topic+fish'></span>

<h3>Description</h3>

<p>A sample data set, used in tests and some examples.
</p>

<hr>
<h2 id='format.ggeffects'>Print and format ggeffects-objects</h2><span id='topic+format.ggeffects'></span><span id='topic+print'></span><span id='topic+print.ggeffects'></span><span id='topic+print_md.ggeffects'></span><span id='topic+print_html.ggeffects'></span>

<h3>Description</h3>

<p>A generic print-method for <code>ggeffects</code>-objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggeffects'
format(
  x,
  variable_labels = FALSE,
  value_labels = FALSE,
  group_name = FALSE,
  row_header_separator = ", ",
  digits = 2,
  collapse_ci = FALSE,
  collapse_tables = FALSE,
  n,
  ...
)

## S3 method for class 'ggeffects'
print(x, group_name = TRUE, digits = 2, verbose = TRUE, ...)

## S3 method for class 'ggeffects'
print_md(x, group_name = TRUE, digits = 2, ...)

## S3 method for class 'ggeffects'
print_html(
  x,
  group_name = TRUE,
  digits = 2,
  theme = NULL,
  engine = c("tt", "gt"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.ggeffects_+3A_x">x</code></td>
<td>
<p>An object of class <code>ggeffects</code>, as returned by the functions
from this package.</p>
</td></tr>
<tr><td><code id="format.ggeffects_+3A_variable_labels">variable_labels</code></td>
<td>
<p>Logical, if <code>TRUE</code> variable labels are used as column
headers. If <code>FALSE</code>, variable names are used.</p>
</td></tr>
<tr><td><code id="format.ggeffects_+3A_value_labels">value_labels</code></td>
<td>
<p>Logical, if <code>TRUE</code>, value labels are used as values in
the table output. If <code>FALSE</code>, the numeric values or factor levels are used.</p>
</td></tr>
<tr><td><code id="format.ggeffects_+3A_group_name">group_name</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the name of further focal terms are
used in the sub-headings of the table. If <code>FALSE</code>, only the values of the
focal terms are used.</p>
</td></tr>
<tr><td><code id="format.ggeffects_+3A_row_header_separator">row_header_separator</code></td>
<td>
<p>Character, separator between the different
subgroups in the table output.</p>
</td></tr>
<tr><td><code id="format.ggeffects_+3A_digits">digits</code></td>
<td>
<p>Number of digits to print.</p>
</td></tr>
<tr><td><code id="format.ggeffects_+3A_collapse_ci">collapse_ci</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the columns with predicted values and
confidence intervals are collapsed into one column, e.g. <code style="white-space: pre;">&#8288;Predicted (95% CI)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="format.ggeffects_+3A_collapse_tables">collapse_tables</code></td>
<td>
<p>Logical, if <code>TRUE</code>, all tables are combined into one.
The tables are not split by further focal terms, but rather are added as
columns. Only works when there is more than one focal term.</p>
</td></tr>
<tr><td><code id="format.ggeffects_+3A_n">n</code></td>
<td>
<p>Number of rows to print per subgroup. If <code>NULL</code>, a default number
of rows is printed, depending on the number of subgroups.</p>
</td></tr>
<tr><td><code id="format.ggeffects_+3A_...">...</code></td>
<td>
<p>Further arguments passed down to <code><a href="#topic+format.ggeffects">format.ggeffects()</a></code>, some of
them are also passed down further to <code><a href="insight.html#topic+format_table">insight::format_table()</a></code> or
<code><a href="insight.html#topic+format_value">insight::format_value()</a></code>.</p>
</td></tr>
<tr><td><code id="format.ggeffects_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages.</p>
</td></tr>
<tr><td><code id="format.ggeffects_+3A_theme">theme</code></td>
<td>
<p>The theme to apply to the table. One of <code>"grid"</code>, <code>"striped"</code>,
<code>"bootstrap"</code>, or <code>"darklines"</code>.</p>
</td></tr>
<tr><td><code id="format.ggeffects_+3A_engine">engine</code></td>
<td>
<p>The engine to use for printing. One of <code>"tt"</code> (default) or <code>"gt"</code>.
<code>"tt"</code> uses the <em>tinytable</em> package, <code>"gt"</code> uses the <em>gt</em> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>format()</code> return a formatted data frame, <code>print()</code> prints a formatted
data frame printed to the console. <code>print_html()</code> returns a <code>tinytable</code>
object by default (unless changed with <code>engine = "gt"</code>), which is printed as
HTML, markdown or LaTeX table (depending on the context from which
<code>print_html()</code> is called, see <code><a href="tinytable.html#topic+tt">tinytable::tt()</a></code> for details).
</p>


<h3>Global Options to Customize Tables when Printing</h3>

<p>The <code>verbose</code> argument can be used to display or silence messages and
warnings. Furthermore, <code>options()</code> can be used to set defaults for the
<code>print()</code> and <code>print_html()</code> method. The following options are available,
which can simply be run in the console:
</p>

<ul>
<li> <p><code>ggeffects_ci_brackets</code>: Define a character vector of length two, indicating
the opening and closing parentheses that encompass the confidence intervals
values, e.g. <code>options(ggeffects_ci_brackets = c("[", "]"))</code>.
</p>
</li>
<li> <p><code>ggeffects_collapse_ci</code>: Logical, if <code>TRUE</code>, the columns with predicted
values (or contrasts) and confidence intervals are collapsed into one
column, e.g. <code>options(ggeffects_collapse_ci = TRUE)</code>.
</p>
</li>
<li> <p><code>ggeffects_collapse_p</code>: Logical, if <code>TRUE</code>, the columns with predicted
values (or contrasts) and p-values are collapsed into one column, e.g.
<code>options(ggeffects_collapse_p = TRUE)</code>. Note that p-values are replaced
by asterisk-symbols (stars) or empty strings when <code>ggeffects_collapse_p = TRUE</code>,
depending on the significance level.
</p>
</li>
<li> <p><code>ggeffects_collapse_tables</code>: Logical, if <code>TRUE</code>, multiple tables for
subgroups are combined into one table. Only works when there is more than
one focal term, e.g. <code>options(ggeffects_collapse_tables = TRUE)</code>.
</p>
</li>
<li> <p><code>ggeffects_output_format</code>: String, either <code>"text"</code>, <code>"markdown"</code> or <code>"html"</code>.
Defines the default output format from <code>predict_response()</code>. If <code>"html"</code>, a
formatted HTML table is created and printed to the view pane. <code>"markdown"</code>
creates a markdown-formatted table inside Rmarkdown documents, and prints
a text-format table to the console when used interactively. If <code>"text"</code> or
<code>NULL</code>, a formatted table is printed to the console, e.g.
<code>options(ggeffects_output_format = "html")</code>.
</p>
</li>
<li> <p><code>ggeffects_html_engine</code>: String, either <code>"tt"</code> or <code>"gt"</code>. Defines the default
engine to use for printing HTML tables. If <code>"tt"</code>, the <em>tinytable</em> package
is used, if <code>"gt"</code>, the <em>gt</em> package is used, e.g.
<code>options(ggeffects_html_engine = "gt")</code>.
</p>
</li></ul>

<p>Use <code style="white-space: pre;">&#8288;options(&lt;option_name&gt; = NULL)&#8288;</code> to remove the option.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(efc, package = "ggeffects")
fit &lt;- lm(barthtot ~ c12hour + e42dep, data = efc)

# default print
predict_response(fit, "e42dep")

# surround CI values with parentheses
print(predict_response(fit, "e42dep"), ci_brackets = c("(", ")"))
# you can also use `options(ggeffects_ci_brackets = c("[", "]"))`
# to set this globally

# collapse CI columns into column with predicted values
print(predict_response(fit, "e42dep"), collapse_ci = TRUE)

# include value labels
print(predict_response(fit, "e42dep"), value_labels = TRUE)

# include variable labels in column headers
print(predict_response(fit, "e42dep"), variable_labels = TRUE)

# include value labels and variable labels
print(predict_response(fit, "e42dep"), variable_labels = TRUE, value_labels = TRUE)

data(iris)
m &lt;- lm(Sepal.Length ~ Species * Petal.Length, data = iris)

# default print with subgroups
predict_response(m, c("Petal.Length", "Species"))

# omit name of grouping variable in subgroup table headers
print(predict_response(m, c("Petal.Length", "Species")), group_name = FALSE)

# collapse tables into one
print(predict_response(m, c("Petal.Length", "Species")), collapse_tables = TRUE, n = 3)

# increase number of digits
print(predict_response(fit, "e42dep"), digits = 5)

</code></pre>

<hr>
<h2 id='get_title'>Get titles and labels from data</h2><span id='topic+get_title'></span><span id='topic+get_x_title'></span><span id='topic+get_y_title'></span><span id='topic+get_legend_title'></span><span id='topic+get_legend_labels'></span><span id='topic+get_x_labels'></span><span id='topic+get_complete_df'></span>

<h3>Description</h3>

<p>Get variable and value labels from <code>ggeffects</code>-objects. <code>predict_response()</code>
saves information on variable names and value labels as additional attributes
in the returned data frame. This is especially helpful for labelled data
(see <strong>sjlabelled</strong>), since these labels can be used to set axis labels and
titles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_title(x, case = NULL)

get_x_title(x, case = NULL)

get_y_title(x, case = NULL)

get_legend_title(x, case = NULL)

get_legend_labels(x, case = NULL)

get_x_labels(x, case = NULL)

get_complete_df(x, case = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_title_+3A_x">x</code></td>
<td>
<p>An object of class <code>ggeffects</code>, as returned by any ggeffects-function;
for <code>get_complete_df()</code>, must be a list of <code>ggeffects</code>-objects.</p>
</td></tr>
<tr><td><code id="get_title_+3A_case">case</code></td>
<td>
<p>Desired target case. Labels will automatically converted into the
specified character case. See <code>?sjlabelled::convert_case</code> for more details
on this argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The titles or labels as character string, or <code>NULL</code>, if variables
had no labels; <code>get_complete_df()</code> returns the input list <code>x</code>
as single data frame, where the grouping variable indicates the
predicted values for each term.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggeffects)
library(ggplot2)
data(efc, package = "ggeffects")
efc$c172code &lt;- datawizard::to_factor(efc$c172code)
fit &lt;- lm(barthtot ~ c12hour + neg_c_7 + c161sex + c172code, data = efc)

mydf &lt;- predict_response(fit, terms = c("c12hour", "c161sex", "c172code"))

ggplot(mydf, aes(x = x, y = predicted, colour = group)) +
  stat_smooth(method = "lm") +
  facet_wrap(~facet, ncol = 2) +
  labs(
    x = get_x_title(mydf),
    y = get_y_title(mydf),
    colour = get_legend_title(mydf)
  )

# adjusted predictions, a list of data frames (one data frame per term)
eff &lt;- ggeffect(fit)
eff
get_complete_df(eff)

# adjusted predictions for education only, and get x-axis-labels
mydat &lt;- eff[["c172code"]]
ggplot(mydat, aes(x = x, y = predicted, group = group)) +
  stat_summary(fun = sum, geom = "line") +
  scale_x_discrete(labels = get_x_labels(mydat))

</code></pre>

<hr>
<h2 id='install_latest'>Update latest ggeffects-version from R-universe (GitHub) or CRAN</h2><span id='topic+install_latest'></span>

<h3>Description</h3>

<p>This function can be used to install the latest package version of <em>ggeffects</em>,
either the development version (from R-universe/GitHub) or the current
version from CRAN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_latest(
  source = c("development", "cran"),
  force = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_latest_+3A_source">source</code></td>
<td>
<p>Character. Either <code>"development"</code> or <code>"cran"</code>. If <code>"cran"</code>,
<em>ggeffects</em> will be installed from the default CRAN mirror returned by
<code>getOption("repos")['CRAN']</code>. If <code>"development"</code> (the default), <em>ggeffects</em>
is installed from the r-universe repository (<a href="https://strengejacke.r-universe.dev/">https://strengejacke.r-universe.dev/</a>).</p>
</td></tr>
<tr><td><code id="install_latest_+3A_force">force</code></td>
<td>
<p>Logical, if <code>FALSE</code>, the update will only be installed if a newer
version is available. Use <code>force=TRUE</code> to force installation, even if the
version number for the locally installed package is identical to the latest
development-version. Only applies when <code>source="development"</code>.</p>
</td></tr>
<tr><td><code id="install_latest_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# install latest development-version of ggeffects from the
# r-universe repository
install_latest()

</code></pre>

<hr>
<h2 id='johnson_neyman'>Spotlight-analysis: Create Johnson-Neyman confidence intervals and plots</h2><span id='topic+johnson_neyman'></span><span id='topic+spotlight_analysis'></span><span id='topic+plot.ggjohnson_neyman'></span>

<h3>Description</h3>

<p>Function conduct a spotlight-analysis to create so-called
Johnson-Neyman intervals. The <code>plot()</code> method can be used to visualize the
results of the Johnson-Neyman test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>johnson_neyman(x, precision = 500, p_adjust = NULL, ...)

spotlight_analysis(x, precision = 500, p_adjust = NULL, ...)

## S3 method for class 'ggjohnson_neyman'
plot(
  x,
  colors = c("#f44336", "#2196F3"),
  show_association = TRUE,
  show_rug = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="johnson_neyman_+3A_x">x</code></td>
<td>
<p>An object of class <code>ggeffects</code>, as returned by the functions
from this package.</p>
</td></tr>
<tr><td><code id="johnson_neyman_+3A_precision">precision</code></td>
<td>
<p>Number of values used for the range of the moderator variable
to calculate the Johnson-Neyman interval. This argument is passed down to
<code>pretty(..., n = precision)</code>. Usually, the default value of 500 is sufficient.
Increasing this value will result in a smoother plot and more accurate values
for the interval bounds, but can also slightly increase the computation time.</p>
</td></tr>
<tr><td><code id="johnson_neyman_+3A_p_adjust">p_adjust</code></td>
<td>
<p>Character vector, if not <code>NULL</code>, indicates the method to
adjust p-values. See <code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code> or <code><a href="stats.html#topic+p.adjust">stats::p.adjust.methods</a></code>
for details. Further possible adjustment methods are <code>"tukey"</code> or <code>"sidak"</code>,
and for <code>johnson_neyman()</code>, <code>"fdr"</code> (or <code>"bh"</code>) and <code>"esarey"</code> (or its
short-cut <code>"es"</code>) are available options. Some caution is necessary when
adjusting p-value for multiple comparisons. See also section <em>P-value adjustment</em>
below.</p>
</td></tr>
<tr><td><code id="johnson_neyman_+3A_...">...</code></td>
<td>
<p>Arguments passed down to <code><a href="#topic+test_predictions">test_predictions()</a></code> (and then probably
further to <code><a href="marginaleffects.html#topic+slopes">marginaleffects::slopes()</a></code>). See <code>?test_predictions</code> for further
details.</p>
</td></tr>
<tr><td><code id="johnson_neyman_+3A_colors">colors</code></td>
<td>
<p>Colors used for the plot. Must be a vector with two color
values. Only used if <code>show_association = TRUE</code>.</p>
</td></tr>
<tr><td><code id="johnson_neyman_+3A_show_association">show_association</code></td>
<td>
<p>Logical, if <code>TRUE</code>, highlights the range where values
of the moderator are positively or negtatively associated with the outcome.</p>
</td></tr>
<tr><td><code id="johnson_neyman_+3A_show_rug">show_rug</code></td>
<td>
<p>Logical, if <code>TRUE</code>, adds a rug with raw data of the moderator
variable to the plot. This helps visualizing its distribution.</p>
</td></tr>
<tr><td><code id="johnson_neyman_+3A_verbose">verbose</code></td>
<td>
<p>Show/hide printed message for plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Johnson-Neyman intervals help to understand where slopes are significant
in the context of interactions in regression models. Thus, the interval is only
useful if the model contains at least one interaction term. The function
accepts the results of a call to <code>predict_response()</code>. The <em>first</em> and the
<em>last</em> focal term used in the <code>terms</code> argument of <code>predict_response()</code> must
be numeric. The function will then test the slopes of the first focal terms
against zero, for different moderator values of the last focal term. If only
one numeric focal term is given, the function will create contrasts by levels
of the categorical focal term. Use <code>plot()</code> to create a plot of the results.
</p>
<p>To avoid misleading interpretations of the plot, we speak of &quot;positive&quot; and
&quot;negative&quot; associations, respectively, and &quot;no clear&quot; associations (instead
of &quot;significant&quot; or &quot;non-significant&quot;). This should prevent the user from
considering a non-significant range of values of the moderator as &quot;accepting
the null hypothesis&quot;.
</p>


<h3>Value</h3>

<p>A data frame including contrasts of the <code><a href="#topic+test_predictions">test_predictions()</a></code> for the
given interaction terms; for <code>plot()</code>, returns a Johnson-Neyman plot.
</p>


<h3>P-value adjustment for multiple comparisons</h3>

<p>Note that p-value adjustment for methods supported by <code>p.adjust()</code> (see also
<code>p.adjust.methods</code>), each row is considered as one set of comparisons, no
matter which <code>test</code> was specified. That is, for instance, when <code>test_predictions()</code>
returns eight rows of predictions (when <code>test = NULL</code>), and <code>p_adjust = "bonferroni"</code>,
the p-values are adjusted in the same way as if we had a test of pairwise
comparisons (<code>test = "pairwise"</code>) where eight rows of comparisons are
returned. For methods <code>"tukey"</code> or <code>"sidak"</code>, a rank adjustment is done
based on the number of combinations of levels from the focal predictors
in <code>terms</code>. Thus, the latter two methods may be useful for certain tests
only, in particular pairwise comparisons.
</p>
<p>For <code>johnson_neyman()</code>, the only available adjustment methods are <code>"fdr"</code>
(or <code>"bh"</code>) (<em>Benjamini &amp; Hochberg (1995)</em>) and <code>"esarey"</code> (or <code>"es"</code>)
(<em>Esarey and Sumner 2017</em>). These usually return similar results. The major
difference is that <code>"fdr"</code> can be slightly faster and more stable in edge
cases, however, confidence intervals are not updated. Only the p-values are
adjusted. <code>"esarey"</code> is slower, but confidence intervals are updated as well.
</p>


<h3>References</h3>

<p>Bauer, D. J., &amp; Curran, P. J. (2005). Probing interactions in fixed and
multilevel regression: Inferential and graphical techniques. Multivariate
Behavioral Research, 40(3), 373-400. doi: 10.1207/s15327906mbr4003_5
</p>
<p>Esarey, J., &amp; Sumner, J. L. (2017). Marginal effects in interaction models:
Determining and controlling the false positive rate. Comparative Political
Studies, 1–33. Advance online publication. doi: 10.1177/0010414017730080
</p>
<p>Johnson, P.O. &amp; Fay, L.C. (1950). The Johnson-Neyman technique, its theory
and application. Psychometrika, 15, 349-367. doi: 10.1007/BF02288864
</p>
<p>McCabe CJ, Kim DS, King KM. Improving Present Practices in the Visual Display
of Interactions. Advances in Methods and Practices in Psychological Science.
2018;1(2):147-165. doi:10.1177/2515245917746792
</p>
<p>Spiller, S. A., Fitzsimons, G. J., Lynch, J. G., &amp; McClelland, G. H. (2013).
Spotlights, Floodlights, and the Magic Number Zero: Simple Effects Tests in
Moderated Regression. Journal of Marketing Research, 50(2), 277–288.
doi:10.1509/jmr.12.0420
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(efc, package = "ggeffects")
efc$c172code &lt;- as.factor(efc$c172code)
m &lt;- lm(neg_c_7 ~ c12hour * barthtot * c172code, data = efc)

pr &lt;- predict_response(m, c("c12hour", "barthtot"))
johnson_neyman(pr)
plot(johnson_neyman(pr))

pr &lt;- predict_response(m, c("c12hour", "c172code", "barthtot"))
johnson_neyman(pr)
plot(johnson_neyman(pr))

# robust standard errors
if (requireNamespace("sandwich")) {
  johnson_neyman(pr, vcov = sandwich::vcovHC)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='lung2'>Sample data set</h2><span id='topic+lung2'></span>

<h3>Description</h3>

<p>A sample data set, used in tests and examples for survival models.
This dataset is originally included in the <span class="pkg">survival</span> package, but for
convenience reasons it is also available in this package.
</p>

<hr>
<h2 id='new_data'>Create a data frame from all combinations of predictor values</h2><span id='topic+new_data'></span><span id='topic+data_grid'></span>

<h3>Description</h3>

<p>Create a data frame for the &quot;newdata&quot;-argument that contains
all combinations of values from the terms in questions. Similar to
<code>expand.grid()</code>. The <code>terms</code>-argument accepts all shortcuts
for representative values as in <code>predict_response()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_data(model, terms, typical = "mean", condition = NULL, ...)

data_grid(model, terms, typical = "mean", condition = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_data_+3A_model">model</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="new_data_+3A_terms">terms</code></td>
<td>
<p>Character vector with the names of those terms from <code>model</code> for
which all combinations of values should be created. This argument works in
the same way as the <code>terms</code> argument in <code>predict_response()</code>. See also
<a href="https://strengejacke.github.io/ggeffects/articles/introduction_effectsatvalues.html">this vignette</a>.</p>
</td></tr>
<tr><td><code id="new_data_+3A_typical">typical</code></td>
<td>
<p>Character vector, naming the function to be applied to the
covariates (non-focal terms) over which the effect is &quot;averaged&quot;. The
default is <code>"mean"</code>. Can be <code>"mean"</code>, &quot;<code>weighted.mean</code>&quot;, <code>"median"</code>, <code>"mode"</code>
or <code>"zero"</code>, which call the corresponding R functions (except <code>"mode"</code>,
which calls an internal function to compute the most common value); <code>"zero"</code>
simply returns 0. By default, if the covariate is a factor, only <code>"mode"</code> is
applicable; for all other values (including the default, <code>"mean"</code>) the
reference level is returned. For character vectors, only the mode is returned.
You can use a named vector to apply different functions to integer, numeric and
categorical covariates, e.g. <code>typical = c(numeric = "median", factor = "mode")</code>.
If <code>typical</code> is <code>"weighted.mean"</code>, weights from the model are used. If no
weights are available, the function falls back to <code>"mean"</code>. <strong>Note</strong> that this
argument is ignored for <code>predict_response()</code>, because the <code>margin</code> argument
takes care of this.</p>
</td></tr>
<tr><td><code id="new_data_+3A_condition">condition</code></td>
<td>
<p>Named character vector, which indicates covariates that
should be held constant at specific values. Unlike <code>typical</code>, which
applies a function to the covariates to determine the value that is used
to hold these covariates constant, <code>condition</code> can be used to define
exact values, for instance <code>condition = c(covariate1 = 20, covariate2 = 5)</code>.
See 'Examples'.</p>
</td></tr>
<tr><td><code id="new_data_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing one row for each combination of values of the
supplied variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(efc, package = "ggeffects")
fit &lt;- lm(barthtot ~ c12hour + neg_c_7 + c161sex + c172code, data = efc)
new_data(fit, c("c12hour [meansd]", "c161sex"))

nd &lt;- new_data(fit, c("c12hour [meansd]", "c161sex"))
pr &lt;- predict(fit, type = "response", newdata = nd)
nd$predicted &lt;- pr
nd

# compare to
predict_response(fit, c("c12hour [meansd]", "c161sex"))

</code></pre>

<hr>
<h2 id='plot'>Plot ggeffects-objects</h2><span id='topic+plot'></span><span id='topic+plot.ggeffects'></span><span id='topic+theme_ggeffects'></span><span id='topic+show_pals'></span>

<h3>Description</h3>

<p>A generic plot-method for <code>ggeffects</code>-objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggeffects'
plot(
  x,
  show_ci = TRUE,
  ci_style = c("ribbon", "errorbar", "dash", "dot"),
  show_data = FALSE,
  show_residuals = FALSE,
  show_residuals_line = FALSE,
  data_labels = FALSE,
  limit_range = FALSE,
  collapse_group = FALSE,
  show_legend = TRUE,
  show_title = TRUE,
  show_x_title = TRUE,
  show_y_title = TRUE,
  case = NULL,
  colors = NULL,
  alpha = 0.15,
  dot_alpha = 0.35,
  jitter = NULL,
  dodge = 0.25,
  dot_size = NULL,
  line_size = NULL,
  use_theme = TRUE,
  log_y = FALSE,
  connect_lines = FALSE,
  facets,
  grid,
  one_plot = TRUE,
  verbose = TRUE,
  ci = show_ci,
  ci.style = ci_style,
  rawdata = show_data,
  add.data = show_data,
  residuals = show_residuals,
  residuals.line = show_residuals_line,
  label.data = data_labels,
  limit.range = limit_range,
  collapse.group = collapse_group,
  dot.alpha = dot_alpha,
  dot.size = dot_size,
  line.size = line_size,
  connect.lines = connect_lines,
  show.title = show_title,
  show.x.title = show_x_title,
  show.y.title = show_y_title,
  use.theme = use_theme,
  show.legend = show_legend,
  one.plot = one_plot,
  log.y = log_y,
  ...
)

theme_ggeffects(base_size = 11, base_family = "")

show_pals()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>An object of class <code>ggeffects</code>, as returned by the functions
from this package.</p>
</td></tr>
<tr><td><code id="plot_+3A_show_ci">show_ci</code></td>
<td>
<p>Logical, if <code>TRUE</code>, confidence bands (for continuous variables
at x-axis) resp. error bars (for factors at x-axis) are plotted.</p>
</td></tr>
<tr><td><code id="plot_+3A_ci_style">ci_style</code></td>
<td>
<p>Character vector, indicating the style of the confidence
bands. May be either <code>"ribbon"</code>, <code>"errorbar"</code>, <code>"dash"</code> or <code>"dot"</code>, to plot
a ribbon, error bars, or dashed or dotted lines as confidence bands.</p>
</td></tr>
<tr><td><code id="plot_+3A_show_data">show_data</code></td>
<td>
<p>Logical, if <code>TRUE</code>, a layer with raw data from response
by predictor on the x-axis, plotted as point-geoms, is added to the plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_show_residuals">show_residuals</code></td>
<td>
<p>Logical, if <code>TRUE</code>, a layer with partial residuals is
added to the plot. See vignette
<a href="https://cran.r-project.org/package=effects">Effect Displays with Partial Residuals</a>.
from <strong>effects</strong> for more details on partial residual plots.</p>
</td></tr>
<tr><td><code id="plot_+3A_show_residuals_line">show_residuals_line</code></td>
<td>
<p>Logical, if <code>TRUE</code>, a loess-fit line is added to the
partial residuals plot. Only applies if <code>residuals</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_data_labels">data_labels</code></td>
<td>
<p>Logical, if <code>TRUE</code> and row names in data are available,
data points will be labelled by their related row name.</p>
</td></tr>
<tr><td><code id="plot_+3A_limit_range">limit_range</code></td>
<td>
<p>Logical, if <code>TRUE</code>, limits the range of the prediction
bands to the range of the data.</p>
</td></tr>
<tr><td><code id="plot_+3A_collapse_group">collapse_group</code></td>
<td>
<p>For mixed effects models, name of the grouping variable
of random effects. If <code>collapse_group = TRUE</code>, data points &quot;collapsed&quot;
by the first random effect groups are added to the plot. Else, if
<code>collapse_group</code> is a name of a group factor, data is collapsed by
that specific random effect. See <code><a href="#topic+collapse_by_group">collapse_by_group()</a></code> for further
details.</p>
</td></tr>
<tr><td><code id="plot_+3A_show_legend">show_legend</code></td>
<td>
<p>Logical, shows or hides the plot legend.</p>
</td></tr>
<tr><td><code id="plot_+3A_show_title">show_title</code></td>
<td>
<p>Logical, shows or hides the plot title-</p>
</td></tr>
<tr><td><code id="plot_+3A_show_x_title">show_x_title</code></td>
<td>
<p>Logical, shows or hides the plot title for the x-axis.</p>
</td></tr>
<tr><td><code id="plot_+3A_show_y_title">show_y_title</code></td>
<td>
<p>Logical, shows or hides the plot title for the y-axis.</p>
</td></tr>
<tr><td><code id="plot_+3A_case">case</code></td>
<td>
<p>Desired target case. Labels will automatically converted into the
specified character case. See <code>?sjlabelled::convert_case</code> for more details
on this argument.</p>
</td></tr>
<tr><td><code id="plot_+3A_colors">colors</code></td>
<td>
<p>Character vector with color values in hex-format, valid
color value names (see <code>demo("colors")</code>) or a name of a
ggeffects-color-palette.
</p>
<p>Following options are valid for <code>colors</code>:
</p>

<ul>
<li><p> If not specified, the color brewer palette <code>"Set1"</code> will be used.
</p>
</li>
<li><p> If <code>"gs"</code>, a greyscale will be used.
</p>
</li>
<li><p> If <code>"bw"</code>, the plot is black/white and uses different line types to
distinguish groups.
</p>
</li>
<li><p> There are some pre-defined color-palettes in this package that can be used,
e.g. <code>colors = "metro"</code>. See <code><a href="#topic+show_pals">show_pals()</a></code> to show all available palettes.
</p>
</li>
<li><p> Else specify own color values or names as vector (e.g.
<code>colors = c("#f00000", "#00ff00")</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value for the confidence bands.</p>
</td></tr>
<tr><td><code id="plot_+3A_dot_alpha">dot_alpha</code></td>
<td>
<p>Alpha value for data points, when <code>show_data = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_jitter">jitter</code></td>
<td>
<p>Numeric, between 0 and 1. If not <code>NULL</code> and <code>show_data = TRUE</code>,
adds a small amount of random variation to the location of data points dots,
to avoid overplotting. Hence the points don't reflect exact values in the
data. May also be a numeric vector of length two, to add different
horizontal and vertical jittering. For binary outcomes, raw data is not
jittered by default to avoid that data points exceed the axis limits.</p>
</td></tr>
<tr><td><code id="plot_+3A_dodge">dodge</code></td>
<td>
<p>Value for offsetting or shifting error bars, to avoid overlapping.
Only applies, if a factor is plotted at the x-axis (in such cases, the
confidence bands are replaced by error bars automatically), or if
<code>ci_style = "errorbars"</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_dot_size">dot_size</code></td>
<td>
<p>Numeric, size of the point geoms.</p>
</td></tr>
<tr><td><code id="plot_+3A_line_size">line_size</code></td>
<td>
<p>Numeric, size of the line geoms.</p>
</td></tr>
<tr><td><code id="plot_+3A_use_theme">use_theme</code></td>
<td>
<p>Logical, if <code>TRUE</code>, a slightly tweaked version of ggplot's
minimal-theme, <code>theme_ggeffects()</code>, is applied to the plot. If <code>FALSE</code>, no
theme-modifications are applied.</p>
</td></tr>
<tr><td><code id="plot_+3A_log_y">log_y</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the y-axis scale is log-transformed.
This might be useful for binomial models with predicted probabilities on
the y-axis.</p>
</td></tr>
<tr><td><code id="plot_+3A_connect_lines">connect_lines</code></td>
<td>
<p>Logical, if <code>TRUE</code> and plot has point-geoms with
error bars (this is usually the case when the x-axis is discrete), points
of same groups will be connected with a line.</p>
</td></tr>
<tr><td><code id="plot_+3A_facets">facets</code>, <code id="plot_+3A_grid">grid</code></td>
<td>
<p>Logical, defaults to <code>TRUE</code> if <code>x</code> has a column named
<code>facet</code>, and defaults to <code>FALSE</code> if <code>x</code> has no such column. Set
<code>facets = TRUE</code> to wrap the plot into facets even for grouping variables
(see 'Examples'). <code>grid</code> is an alias for <code>facets</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_one_plot">one_plot</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> has a <code>panel</code> column (i.e. when
four <code>terms</code> were used), a single, integrated plot is produced.</p>
</td></tr>
<tr><td><code id="plot_+3A_verbose">verbose</code></td>
<td>
<p>Logical, toggle warnings and messages.</p>
</td></tr>
<tr><td><code id="plot_+3A_ci">ci</code>, <code id="plot_+3A_add.data">add.data</code>, <code id="plot_+3A_rawdata">rawdata</code>, <code id="plot_+3A_residuals">residuals</code>, <code id="plot_+3A_residuals.line">residuals.line</code>, <code id="plot_+3A_label.data">label.data</code>, <code id="plot_+3A_limit.range">limit.range</code>, <code id="plot_+3A_collapse.group">collapse.group</code>, <code id="plot_+3A_dot.alpha">dot.alpha</code>, <code id="plot_+3A_dot.size">dot.size</code>, <code id="plot_+3A_line.size">line.size</code>, <code id="plot_+3A_connect.lines">connect.lines</code>, <code id="plot_+3A_show.title">show.title</code>, <code id="plot_+3A_show.x.title">show.x.title</code>, <code id="plot_+3A_show.y.title">show.y.title</code>, <code id="plot_+3A_use.theme">use.theme</code>, <code id="plot_+3A_one.plot">one.plot</code>, <code id="plot_+3A_ci.style">ci.style</code>, <code id="plot_+3A_show.legend">show.legend</code>, <code id="plot_+3A_log.y">log.y</code></td>
<td>
<p>Deprecated
arguments. Use <code>show_ci</code>, <code>show_data</code>, <code>show_residuals</code>, <code>show_residuals_line</code>,
<code>data_labels</code>, <code>limit_range</code>, <code>collapse_group</code>, <code>dot_alpha</code>, <code>dot_size</code>,
<code>line_size</code>, <code>connect_lines</code>, <code>show_title</code>, <code>show_x_title</code>, <code>show_y_title</code>,
<code>use_theme</code>, <code>ci_style</code>, <code>show_legend</code>, <code>log_y</code> and <code>one_plot</code> instead.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Further arguments passed down to <code style="white-space: pre;">&#8288;ggplot::scale_y*()&#8288;</code>, to
control the appearance of the y-axis.</p>
</td></tr>
<tr><td><code id="plot_+3A_base_size">base_size</code></td>
<td>
<p>Base font size.</p>
</td></tr>
<tr><td><code id="plot_+3A_base_family">base_family</code></td>
<td>
<p>Base font family.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For proportional odds logistic regression (see <code>?MASS::polr</code>)
or cumulative link models in general, plots are automatically facetted
by <code>response.level</code>, which indicates the grouping of predictions based on
the level of the model's response.
</p>


<h3>Value</h3>

<p>A ggplot2-object.
</p>


<h3>Partial Residuals</h3>

<p>For <strong>generalized linear models</strong> (glms), residualized scores are
computed as <code>inv.link(link(Y) + r)</code> where <code>Y</code> are the predicted
values on the response scale, and <code>r</code> are the <em>working</em> residuals.
<br /><br />
For (generalized) linear <strong>mixed models</strong>, the random effect are also
partialled out.
</p>


<h3>Note</h3>

<p>Load <code>library(ggplot2)</code> and use <code>theme_set(theme_ggeffects())</code> to set
the <strong>ggeffects</strong>-theme as default plotting theme. You can then use further
plot-modifiers, e.g. from <strong>sjPlot</strong>, like <code>legend_style()</code> or <code>font_size()</code>
without losing the theme-modifications.
</p>
<p>There are pre-defined colour palettes in this package. Use <code><a href="#topic+show_pals">show_pals()</a></code>
to show all available colour palettes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sjlabelled)
data(efc)
efc$c172code &lt;- as_label(efc$c172code)
fit &lt;- lm(barthtot ~ c12hour + neg_c_7 + c161sex + c172code, data = efc)

dat &lt;- predict_response(fit, terms = "c12hour")
plot(dat)


# facet by group, use pre-defined color palette
dat &lt;- predict_response(fit, terms = c("c12hour", "c172code"))
plot(dat, facet = TRUE, colors = "hero")

# don't use facets, b/w figure, w/o confidence bands
dat &lt;- predict_response(fit, terms = c("c12hour", "c172code"))
plot(dat, colors = "bw", show_ci = FALSE)

# factor at x axis, plot exact data points and error bars
dat &lt;- predict_response(fit, terms = c("c172code", "c161sex"))
plot(dat)

# for three variables, automatic facetting
dat &lt;- predict_response(fit, terms = c("c12hour", "c172code", "c161sex"))
plot(dat)


# show all color palettes
show_pals()

</code></pre>

<hr>
<h2 id='pool_comparisons'>Pool contrasts and comparisons from <code>test_predictions()</code></h2><span id='topic+pool_comparisons'></span>

<h3>Description</h3>

<p>This function &quot;pools&quot; (i.e. combines) multiple <code>ggcomparisons</code> objects, returned
by <code><a href="#topic+test_predictions">test_predictions()</a></code>, in a similar fashion as <code><a href="mice.html#topic+pool">mice::pool()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_comparisons(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool_comparisons_+3A_x">x</code></td>
<td>
<p>A list of <code>ggcomparisons</code> objects, as returned by <code><a href="#topic+test_predictions">test_predictions()</a></code>.</p>
</td></tr>
<tr><td><code id="pool_comparisons_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Averaging of parameters follows Rubin's rules (<em>Rubin, 1987, p. 76</em>).
</p>


<h3>Value</h3>

<p>A data frame with pooled comparisons or contrasts of predictions.
</p>


<h3>References</h3>

<p>Rubin, D.B. (1987). Multiple Imputation for Nonresponse in Surveys. New York:
John Wiley and Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("nhanes2", package = "mice")
imp &lt;- mice::mice(nhanes2, printFlag = FALSE)
comparisons &lt;- lapply(1:5, function(i) {
  m &lt;- lm(bmi ~ age + hyp + chl, data = mice::complete(imp, action = i))
  test_predictions(m, "age")
})
pool_comparisons(comparisons)

</code></pre>

<hr>
<h2 id='pool_predictions'>Pool Predictions or Estimated Marginal Means</h2><span id='topic+pool_predictions'></span>

<h3>Description</h3>

<p>This function &quot;pools&quot; (i.e. combines) multiple <code>ggeffects</code> objects, in
a similar fashion as <code><a href="mice.html#topic+pool">mice::pool()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_predictions(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool_predictions_+3A_x">x</code></td>
<td>
<p>A list of <code>ggeffects</code> objects, as returned by <code><a href="#topic+predict_response">predict_response()</a></code>.</p>
</td></tr>
<tr><td><code id="pool_predictions_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Averaging of parameters follows Rubin's rules (<em>Rubin, 1987, p. 76</em>).
</p>


<h3>Value</h3>

<p>A data frame with pooled predictions.
</p>


<h3>References</h3>

<p>Rubin, D.B. (1987). Multiple Imputation for Nonresponse in Surveys. New York:
John Wiley and Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example for multiple imputed datasets
data("nhanes2", package = "mice")
imp &lt;- mice::mice(nhanes2, printFlag = FALSE)
predictions &lt;- lapply(1:5, function(i) {
  m &lt;- lm(bmi ~ age + hyp + chl, data = mice::complete(imp, action = i))
  predict_response(m, "age")
})
pool_predictions(predictions)

</code></pre>

<hr>
<h2 id='predict_response'>Adjusted predictions and estimated marginal means from regression models</h2><span id='topic+predict_response'></span>

<h3>Description</h3>

<p>The <strong>ggeffects</strong> package computes marginal means and adjusted predicted
values for the response, at the margin of specific values or levels from
certain model terms. The package is built around three core functions:
<code>predict_response()</code> (understanding results), <code>test_predictions()</code> (importance
of results) and <code>plot()</code> (communicate results).
</p>
<p>By default, adjusted predictions or marginal means are returned on the
<em>response</em> scale, which is the easiest and most intuitive scale to interpret
the results. There are other options for specific models as well, e.g. with
zero-inflation component (see documentation of the <code>type</code>-argument). The
result is returned as structured data frame, which is nicely printed by
default. <code>plot()</code> can be used to easily create figures.
</p>
<p>The main function to calculate marginal means and adjusted predictions is
<code>predict_response()</code>, which returns adjusted predictions, marginal means
or averaged counterfactual predictions depending on value of the
<code>margin</code>-argument.
</p>
<p>In previous versions of <strong>ggeffects</strong>, the functions <code>ggpredict()</code>, <code>ggemmeans()</code>,
<code>ggeffect()</code> and <code>ggaverage()</code> were used to calculate marginal means and
adjusted predictions. These functions are still available, but <code>predict_response()</code>
as a &quot;wrapper&quot; around these functions is the preferred way to calculate marginal
means and adjusted predictions now.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_response(
  model,
  terms,
  margin = "mean_reference",
  ci_level = 0.95,
  type = "fixed",
  condition = NULL,
  back_transform = TRUE,
  ppd = FALSE,
  vcov_fun = NULL,
  vcov_type = NULL,
  vcov_args = NULL,
  weights = NULL,
  interval,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_response_+3A_model">model</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_terms">terms</code></td>
<td>
<p>Names of those terms from <code>model</code>, for which predictions should
be displayed (so called <em>focal terms</em>). Can be:
</p>

<ul>
<li><p> A character vector, specifying the names of the focal terms. This is the
preferred and probably most flexible way to specify focal terms, e.g.
<code>terms = "x [40:60]"</code>, to calculate predictions for the values 40 to 60.
</p>
</li>
<li><p> A list, where each element is a named vector, specifying the focal terms
and their values. This is the &quot;classical&quot; R way to specify focal terms,
e.g. <code>list(x = 40:60)</code>.
</p>
</li>
<li><p> A formula, e.g. <code>terms = ~ x + z</code>, which is internally converted to a
character vector. This is probably the least flexible way, as you cannot
specify representative values for the focal terms.
</p>
</li>
<li><p> A data frame representig a &quot;data grid&quot; or &quot;reference grid&quot;. Predictions
are then made for all combinations of the variables in the data frame.
</p>
</li></ul>

<p><code>term</code> at least requires one variable name. The maximum length is four terms,
where the second to fourth term indicate the groups, i.e. predictions of first
term are grouped at meaningful values or levels of the remaining terms (see
<code><a href="#topic+values_at">values_at()</a></code>). It is also possible to define specific values for focal
terms, at which adjusted predictions should be calculated (see details below).
All remaining covariates that are not specified in <code>terms</code> are &quot;marginalized&quot;,
see the <code>margin</code> argument. See also argument <code>condition</code> to fix non-focal
terms to specific values.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_margin">margin</code></td>
<td>
<p>Character string, indicating how to marginalize over the
<em>non-focal</em> predictors, i.e. those variables that are <em>not</em> specified in
<code>terms</code>. Possible values are <code>"mean_reference"</code>, <code>"mean_mode"</code>,
<code>"marginalmeans"</code> and <code>"empirical"</code> (or <code>"counterfactual"</code>, aka average
&quot;counterfactual&quot; predictions). You can set a default-option for the <code>margin</code>
argument via <code>options()</code>, e.g. <code>options(ggeffects_margin = "empirical")</code>,
so you don't have to specify your preferred marginalization method each time
you call <code>predict_response()</code>. See details in the documentation below.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_ci_level">ci_level</code></td>
<td>
<p>Numeric, the level of the confidence intervals. Use
<code>ci_level = NA</code> if confidence intervals should not be calculated
(for instance, due to computation time). Typically, confidence intervals are
based on the returned standard errors for the predictions, assuming a t- or
normal distribution (based on the model and the available degrees of freedom,
i.e. roughly <code style="white-space: pre;">&#8288;+/- 1.96 * SE&#8288;</code>). See introduction of
<a href="https://strengejacke.github.io/ggeffects/articles/ggeffects.html">this vignette</a>
for more details.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_type">type</code></td>
<td>
<p>Character, indicating whether predictions should be conditioned
on specific model components or not. Consequently, most options only apply
for survival models, mixed effects models and/or models with zero-inflation
(and their Bayesian counter-parts); only exeption is <code>type = "simulate"</code>,
which is available for some other model classes as well (which respond to
<code>simulate()</code>).
</p>
<p><strong>Note 1:</strong> For <code>brmsfit</code>-models with zero-inflation component,
there is no <code>type = "zero_inflated"</code> nor <code>type = "zi_random"</code>; predicted
values for <code>MixMod</code>-models from <strong>GLMMadaptive</strong> with zero-inflation
component <em>always</em> condition on the zero-inflation part of the model (see
'Details').
</p>
<p><strong>Note 2:</strong> If <code>margin = "empirical"</code> (i.e. counterfactual predictions), the
<code>type</code> argument is handled differently. It is set to <code>"response"</code> by default,
and usually accepts all values from the <code>type</code>-argument of the model's respective
<code>predict()</code> method. E.g., passing a <code>glm</code> object would allow the options
<code>"response"</code>, <code>"link"</code>, and <code>"terms"</code>. Thus, the following options apply to
<code>predict_response()</code> when <code>margin</code> is <em>not</em> <code>"empirical"</code>, and are passed to
<code>ggpredict()</code> or <code>ggemmeans()</code>, respectively (depending on the value of <code>margin</code>):
</p>

<ul>
<li> <p><code>"fixed"</code> (or <code>"fe"</code> or <code>"count"</code>)
</p>
<p>Predicted values are conditioned on the fixed effects or conditional
model only (for mixed models: predicted values are on the population-level
and <em>confidence intervals</em> are returned, i.e. <code>re.form = NA</code> when calling
<code>predict()</code>). For instance, for models fitted with <code>zeroinfl</code> from <strong>pscl</strong>,
this would return the predicted mean from the count component (without
zero-inflation). For models with zero-inflation component, this type calls
<code>predict(..., type = "link")</code> (however, predicted values are
back-transformed to the response scale).
</p>
</li>
<li> <p><code>"fixed_ppd"</code>
</p>
<p>Only applies to <code>margin = "mean_reference"</code>, and only for Bayesian
models of class <code>stanreg</code> or <code>brmsfit</code>. Computes the posterior predictive
distribution. It is the same as setting <code>type = "fixed"</code> in combination with
<code>ppd = TRUE</code>.
</p>
</li>
<li> <p><code>"random"</code> (or <code>"re"</code>)
</p>
<p>This only applies to mixed models, and <code>type = "random"</code> does not condition
on the zero-inflation component of the model. <code>type = "random"</code> still
returns population-level predictions, however, conditioned on random effects
and considering individual level predictions, i.e. <code>re.form = NULL</code> when
calling <code>predict()</code>. This may affect the returned predicted values, depending
on whether <code>REML = TRUE</code> or <code>REML = FALSE</code> was used for model fitting.
Furthermore, unlike <code>type = "fixed"</code>, intervals also consider the uncertainty
in the variance parameters (the mean random effect variance, see <em>Johnson
et al. 2014</em> for details) and hence can be considered as <em>prediction intervals</em>.
For models with zero-inflation component, this type calls
<code>predict(..., type = "link")</code> (however, predicted values are back-transformed
to the response scale).
</p>
<p>To get predicted values for each level of the random effects groups, add the
name of the related random effect term to the <code>terms</code>-argument
(for more details, see
<a href="https://strengejacke.github.io/ggeffects/articles/introduction_effectsatvalues.html">this vignette</a>).
</p>
</li>
<li> <p><code>"random_ppd"</code>
</p>
<p>Only applies to <code>margin = "mean_reference"</code>,, and only for Bayesian
models of class <code>stanreg</code> or <code>brmsfit</code>. Computes the posterior predictive
distribution. It is the same as setting <code>type = "random"</code> in combination with
<code>ppd = TRUE</code>.
</p>
</li>
<li> <p><code>"zero_inflated"</code> (or <code>"fe.zi"</code> or <code>"zi"</code>)
</p>
<p>Predicted values are conditioned on the fixed effects and the zero-inflation
component. For instance, for models fitted with <code>zeroinfl</code>
from <strong>pscl</strong>, this would return the predicted response (<code>mu*(1-p)</code>)
and for <strong>glmmTMB</strong>, this would return the expected value <code>mu*(1-p)</code>
<em>without</em> conditioning on random effects (i.e. random effect variances
are not taken into account for the confidence intervals). For models with
zero-inflation component, this type calls <code>predict(..., type = "response")</code>.
See 'Details'.
</p>
</li>
<li> <p><code>"zi_random"</code> (or <code>"re.zi"</code> or <code>"zero_inflated_random"</code>)
</p>
<p>Predicted values are conditioned on the zero-inflation component and
take the random effects uncertainty into account. For models fitted with
<code>glmmTMB()</code>, <code>hurdle()</code> or <code>zeroinfl()</code>, this would return the
expected value <code>mu*(1-p)</code>. For <strong>glmmTMB</strong>, prediction intervals
also consider the uncertainty in the random effects variances. This
type calls <code>predict(..., type = "response")</code>. See 'Details'.
</p>
</li>
<li> <p><code>"zi_prob"</code> (or <code>"zi.prob"</code>)
</p>
<p>Predicted zero-inflation probability. For <strong>glmmTMB</strong> models with
zero-inflation component, this type calls <code>predict(..., type = "zlink")</code>;
models from <strong>pscl</strong> call <code>predict(..., type = "zero")</code> and for
<strong>GLMMadaptive</strong>, <code>predict(..., type = "zero_part")</code> is called.
</p>
</li>
<li> <p><code>"simulate"</code> (or <code>"sim"</code>)
</p>
<p>Predicted values and confidence resp. prediction intervals are
based on simulations, i.e. calls to <code>simulate()</code>. This type
of prediction takes all model uncertainty into account, including
random effects variances. Currently supported models are objects of
class <code>lm</code>, <code>glm</code>, <code>glmmTMB</code>, <code>wbm</code>, <code>MixMod</code>
and <code>merMod</code>. See <code>...</code> for details on number of simulations.
</p>
</li>
<li> <p><code>"survival"</code> and <code>"cumulative_hazard"</code> (or <code>"surv"</code> and <code>"cumhaz"</code>)
</p>
<p>Applies only to <code>coxph</code>-objects from the <strong>survial</strong>-package and
calculates the survival probability or the cumulative hazard of an event.
</p>
</li></ul>

<p>When <code>margin = "empirical"</code>, the <code>type</code> argument accepts all values from
the <code>type</code>-argument of the model's respective <code>predict()</code>-method.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_condition">condition</code></td>
<td>
<p>Named character vector, which indicates covariates that
should be held constant at specific values. Unlike <code>typical</code>, which
applies a function to the covariates to determine the value that is used
to hold these covariates constant, <code>condition</code> can be used to define
exact values, for instance <code>condition = c(covariate1 = 20, covariate2 = 5)</code>.
See 'Examples'.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_back_transform">back_transform</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default), predicted values
for log- or log-log transformed responses will be back-transformed to
original response-scale.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_ppd">ppd</code></td>
<td>
<p>Logical, if <code>TRUE</code>, predictions for Stan-models are based on the
posterior predictive distribution <code><a href="rstantools.html#topic+posterior_predict">rstantools::posterior_predict()</a></code>. If
<code>FALSE</code> (the default), predictions are based on posterior draws of the linear
predictor <code><a href="rstantools.html#topic+posterior_linpred">rstantools::posterior_linpred()</a></code>.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_vcov_fun">vcov_fun</code></td>
<td>
<p>Variance-covariance matrix used to compute uncertainty
estimates (e.g., for confidence intervals based on robust standard errors).
This argument accepts a covariance matrix, a function which returns a
covariance matrix, or a string which identifies the function to be used to
compute the covariance matrix.
</p>

<ul>
<li><p> A (variance-covariance) matrix
</p>
</li>
<li><p> A function which returns a covariance matrix (e.g., <code>stats::vcov()</code>)
</p>
</li>
<li><p> A string which indicates the estimation type for the heteroscedasticity-consistent
variance-covariance matrix, e.g. <code>vcov_fun = "HC0"</code>. Possible values are
<code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, and <code>"HC5"</code>, which
will then call the <code>vcovHC()</code>-function from the <strong>sandwich</strong> package, using
the specified type. Further possible values are <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, and <code>"CR3"</code>, which will call the <code>vcovCR()</code>-function from
the <strong>clubSandwich</strong> package.
</p>
</li>
<li><p> A string which indicates the name of the <code style="white-space: pre;">&#8288;vcov*()&#8288;</code>-function from the
<strong>sandwich</strong> or <strong>clubSandwich</strong> packages, e.g. <code>vcov_fun = "vcovCL"</code>,
which is used to compute (cluster) robust standard errors for predictions.
</p>
</li></ul>

<p>If <code>NULL</code>, standard errors (and confidence intervals) for predictions are
based on the standard errors as returned by the <code>predict()</code>-function.
<strong>Note</strong> that probably not all model objects that work with <code>ggpredict()</code>
are also supported by the <strong>sandwich</strong> or <strong>clubSandwich</strong> packages.
</p>
<p>See details in <a href="https://strengejacke.github.io/ggeffects/articles/practical_robustestimation.html">this vignette</a>.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_vcov_type">vcov_type</code></td>
<td>
<p>Character vector, specifying the estimation type for the
robust covariance matrix estimation (see <code>?sandwich::vcovHC</code>
or <code>?clubSandwich::vcovCR</code> for details). Only used when <code>vcov_fun</code> is a
character string indicating one of the functions from those packages.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_vcov_args">vcov_args</code></td>
<td>
<p>List of named vectors, used as additional arguments that
are passed down to <code>vcov_fun</code>.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_weights">weights</code></td>
<td>
<p>Character vector, naming the weigthing variable in the data,
or a vector of weights (of same length as the number of observations in the
data). Only applies to <code>margin = "empirical"</code>.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_interval">interval</code></td>
<td>
<p>Type of interval calculation, can either be <code>"confidence"</code>
(default) or <code>"prediction"</code>. May be abbreviated. Unlike <em>confidence intervals</em>,
<em>prediction intervals</em> include the residual variance (sigma^2) to account for
the uncertainty of predicted values. For mixed models, <code>interval = "prediction"</code>
is the default for <code>type = "random"</code>. When <code>type = "fixed"</code>, the default is
<code>interval = "confidence"</code>. Note that prediction intervals are not available
for all models, but only for models that work with <code><a href="insight.html#topic+get_sigma">insight::get_sigma()</a></code>.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages or warnings.</p>
</td></tr>
<tr><td><code id="predict_response_+3A_...">...</code></td>
<td>
<p>If <code>margin</code> is set to <code>"mean_reference"</code> or <code>"mean_mode"</code>, arguments
are passed down to <code>ggpredict()</code> (further down to <code>predict()</code>); for
<code>margin = "marginalmeans"</code>, further arguments passed down to <code>ggemmeans()</code> and
thereby to <code>emmeans::emmeans()</code>; if <code>margin = "empirical"</code>, further arguments are
passed down to <code>marginaleffects::avg_predictions()</code>. If <code>type = "simulate"</code>,
<code>...</code> may also be used to set the number of simulation, e.g. <code>nsim = 500</code>.
When calling <code>ggeffect()</code>, further arguments passed down to <code>effects::Effect()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame (with <code>ggeffects</code> class attribute) with consistent data columns:
</p>

<ul>
<li> <p><code>"x"</code>: the values of the first term in <code>terms</code>, used as x-position in plots.
</p>
</li>
<li> <p><code>"predicted"</code>: the predicted values of the response, used as y-position in plots.
</p>
</li>
<li> <p><code>"std.error"</code>: the standard error of the predictions. <em>Note that the standard
errors are always on the link-scale, and not back-transformed for non-Gaussian
models!</em>
</p>
</li>
<li> <p><code>"conf.low"</code>: the lower bound of the confidence interval for the predicted values.
</p>
</li>
<li> <p><code>"conf.high"</code>: the upper bound of the confidence interval for the predicted values.
</p>
</li>
<li> <p><code>"group"</code>: the grouping level from the second term in <code>terms</code>, used as
grouping-aesthetics in plots.
</p>
</li>
<li> <p><code>"facet"</code>: the grouping level from the third term in <code>terms</code>, used to indicate
facets in plots.
</p>
<p>The estimated marginal means (or predicted values) are always on the
response scale!
</p>
<p>For proportional odds logistic regression (see <code>?MASS::polr</code>)
resp. cumulative link models (e.g., see <code>?ordinal::clm</code>),
an additional column <code>"response.level"</code> is returned, which indicates
the grouping of predictions based on the level of the model's response.
</p>
<p>Note that for convenience reasons, the columns for the intervals
are always named <code>"conf.low"</code> and <code>"conf.high"</code>, even though
for Bayesian models credible or highest posterior density intervals
are returned.
</p>
<p>There is an <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code> method for objects of class <code>ggeffects</code>,
which has an <code>terms_to_colnames</code> argument, to use the term names as column
names instead of the standardized names <code>"x"</code> etc.
</p>
</li></ul>



<h3>Supported Models</h3>

<p>A list of supported models can be found at <a href="https://github.com/strengejacke/ggeffects">the package website</a>.
Support for models varies by marginalization method (the <code>margin</code> argument),
i.e. although <code>predict_response()</code> supports most models, some models are only
supported exclusively by one of the four downstream functions (<code>ggpredict()</code>,
<code>ggemmeans()</code>, <code>ggeffect()</code> or <code>ggaverage()</code>). This means that not all models
work for every <code>margin</code> option of <code>predict_response()</code>.
</p>


<h3>Holding covariates at constant values, or how to marginalize over the <em>non-focal</em> predictors</h3>

<p><code>predict_response()</code> is a wrapper around <code>ggpredict()</code>, <code>ggemmeans()</code> and
<code>ggaverage()</code>. Depending on the value of the <code>margin</code> argument,
<code>predict_response()</code> calls one of those functions. The <code>margin</code> argument
indicates how to marginalize over the <em>non-focal</em> predictors, i.e. those
variables that are <em>not</em> specified in <code>terms</code>. Possible values are:
</p>

<ul>
<li> <p><code>"mean_reference"</code> and <code>"mean_mode"</code>: For <code>"mean_reference"</code>, non-focal
predictors are set to their mean (numeric variables), reference level
(factors), or &quot;most common&quot; value (mode) in case of character vectors.
For <code>"mean_mode"</code>, non-focal predictors are set to their mean (numeric
variables) or mode (factors, or &quot;most common&quot; value in case of character
vectors).
</p>
<p>These predictons represent a rather &quot;theoretical&quot; view on your data,
which does not necessarily exactly reflect the characteristics of your
sample. It helps answer the question, &quot;What is the predicted value of the
response at meaningful values or levels of my focal terms for a 'typical'
observation in my data?&quot;, where 'typical' refers to certain characteristics
of the remaining predictors.
</p>
</li>
<li> <p><code>"marginalmeans"</code>: non-focal predictors are set to their mean (numeric
variables) or averaged over the levels or &quot;values&quot; for factors and
character vectors. Averaging over the factor levels of non-focal terms
computes a kind of &quot;weighted average&quot; for the values at which these terms
are hold constant. Thus, non-focal categorical terms are conditioned on
&quot;weighted averages&quot; of their levels.
</p>
<p>These predictions come closer to the sample, because all possible values
and levels of the non-focal predictors are taken  into account. It would
answer the question, &quot;What is the predicted value of the response at
meaningful values or levels of my focal terms for an 'average' observation
in my data?&quot;. It refers to randomly picking a subject of your sample and
the result you get on average.
</p>
</li>
<li> <p><code>"empirical"</code> (or <code>"counterfactual"</code>): non-focal predictors are averaged
over the observations in the sample. The response is predicted for each
subject in the data and predicted values are then averaged across all
subjects, aggregated/grouped by the focal terms. In particular, averaging
is applied to <em>counterfactual predictions</em> (Dickerman and Hernan 2020).
There is a more detailed description in
<a href="https://strengejacke.github.io/ggeffects/articles/technical_differencepredictemmeans.html">this vignette</a>.
</p>
<p>Counterfactual predictions are useful, insofar as the results can also
be transferred to other contexts. It answers the question, &quot;What is the
predicted value of the response at meaningful values or levels of my focal
terms for the 'average' observation in the population?&quot;. It does not only
refer to the actual data in your sample, but also &quot;what would be if&quot; we had
more data, or if we had data from a different population. This is where
&quot;counterfactual&quot; refers to.
</p>
</li></ul>

<p>You can set a default-option for the <code>margin</code> argument via <code>options()</code>, e.g.
<code>options(ggeffects_margin = "empirical")</code>, so you don't have to specify your
&quot;default&quot; marginalization method each time you call <code>predict_response()</code>.
Use <code>options(ggeffects_margin = NULL)</code> to remove that setting.
</p>
<p>The <code>condition</code> argument can be used to fix non-focal terms to specific
values.
</p>


<h3>Marginal Means and Adjusted Predictions at Specific Values</h3>

<p>Meaningful values of focal terms can be specified via the <code>terms</code> argument.
Specifying meaningful or representative values as string pattern is the
preferred way in the <strong>ggeffects</strong> package. However, it is also possible to
use a <code>list()</code> for the focal terms if prefer the &quot;classical&quot; R way, which is
described in <a href="https://strengejacke.github.io/ggeffects/articles/introduction_effectsatvalues.html">this vignette</a>.
</p>
<p>Indicating levels in square brackets allows for selecting only certain
groups or values resp. value ranges. The term name and the start of the
levels in brackets must be separated by a whitespace character, e.g.
<code>terms = c("age", "education [1,3]")</code>. Numeric ranges, separated with colon,
are also allowed: <code>terms = c("education", "age [30:60]")</code>. The stepsize for
ranges can be adjusted using <code>by</code>, e.g. <code>terms = "age [30:60 by=5]"</code>.
</p>
<p>The <code>terms</code> argument also supports the same shortcuts as the <code>values</code> argument
in <code>values_at()</code>. So <code>terms = "age [meansd]"</code> would return predictions for
the values one standard deviation below the mean age, the mean age and one SD
above the mean age. <code>terms = "age [quart2]"</code> would calculate predictions at
the value of the lower, median and upper quartile of age.
</p>
<p>Furthermore, it is possible to specify a function name. Values for predictions
will then be transformed, e.g. <code>terms = "income [exp]"</code>. This is useful when
model predictors were transformed for fitting the model and should be
back-transformed to the original scale for predictions. It is also possible
to define own functions (see
<a href="https://strengejacke.github.io/ggeffects/articles/introduction_effectsatvalues.html">this vignette</a>).
</p>
<p>Instead of a function, it is also possible to define the name of a variable
with specific values, e.g. to define a vector <code>v = c(1000, 2000, 3000)</code> and
then use <code>terms = "income [v]"</code>.
</p>
<p>You can take a random sample of any size with <code>sample=n</code>, e.g
<code>terms = "income [sample=8]"</code>, which will sample eight values from
all possible values of the variable <code>income</code>. This option is especially
useful for plotting predictions at certain levels of random effects
group levels, where the group factor has many levels that can be completely
plotted. For more details, see
<a href="https://strengejacke.github.io/ggeffects/articles/introduction_effectsatvalues.html">this vignette</a>.
</p>
<p>Finally, numeric vectors for which no specific values are given, a &quot;pretty range&quot;
is calculated (see <code><a href="#topic+pretty_range">pretty_range()</a></code>), to avoid memory allocation problems
for vectors with many unique values. If a numeric vector is specified as
second or third term (i.e. if this vector represents a grouping structure),
representative values (see <code><a href="#topic+values_at">values_at()</a></code>) are chosen (unless other values
are specified). If all values for a numeric vector should be used to compute
predictions, you may use e.g. <code>terms = "age [all]"</code>. See also package vignettes.
</p>
<p>To create a pretty range that should be smaller or larger than the default
range (i.e. if no specific values would be given), use the <code>n</code> tag, e.g.
<code>terms="age [n=5]"</code> or <code>terms="age [n=12]"</code>. Larger values for <code>n</code> return a
larger range of predicted values.
</p>


<h3>Bayesian Regression Models</h3>

<p><code>predict_response()</code> also works with <strong>Stan</strong>-models from the <strong>rstanarm</strong> or
<strong>brms</strong>-packages. The predicted values are the median value of all drawn
posterior samples. The confidence intervals for Stan-models are Bayesian
predictive intervals. By default (i.e. <code>ppd = FALSE</code>), the predictions are
based on <code><a href="rstantools.html#topic+posterior_linpred">rstantools::posterior_linpred()</a></code> and hence have some limitations:
the uncertainty of the error term is not taken into account. The recommendation
is to use the posterior predictive distribution (<code><a href="rstantools.html#topic+posterior_predict">rstantools::posterior_predict()</a></code>).
</p>


<h3>Zero-Inflated and Zero-Inflated Mixed Models with brms</h3>

<p>Models of class <code>brmsfit</code> always condition on the zero-inflation component,
if the model has such a component. Hence, there is no <code>type = "zero_inflated"</code>
nor <code>type = "zi_random"</code> for <code>brmsfit</code>-models, because predictions are based
on draws of the posterior distribution, which already account for the
zero-inflation part of the model.
</p>
<p><strong>Zero-Inflated and Zero-Inflated Mixed Models with glmmTMB</strong>
</p>
<p>If <code>model</code> is of class <code>glmmTMB</code>, <code>hurdle</code>, <code>zeroinfl</code> or <code>zerotrunc</code>, and
<code>margin</code> is <em>not</em> set to <code style="white-space: pre;">&#8288;"empirical&#8288;</code>,  simulations from a multivariate
normal distribution (see <code>?MASS::mvrnorm</code>) are drawn to calculate <code>mu*(1-p)</code>.
Confidence intervals are then based on quantiles of these results.
For <code>type = "zi_random"</code>, prediction intervals also take the uncertainty in
the random-effect paramters into account (see also <em>Brooks et al. 2017</em>,
pp.391-392 for details).
</p>
<p>An alternative for models fitted with <strong>glmmTMB</strong> that take all model
uncertainties into account are simulations based on <code>simulate()</code>, which
is used when <code>type = "simulate"</code> (see <em>Brooks et al. 2017</em>, pp.392-393 for
details).
</p>
<p>Finally, if <code>margin = "empirical"</code>, the returned predictions are already
conditioned on the zero-inflation part (and possible random effects) of the
model, thus these are most comparable to the <code>type = "simulate"</code> option. In
other words, if all model components should be taken into account for
predictions, you should consider using <code>margin = "empirical"</code>.
</p>


<h3>MixMod-models from GLMMadaptive</h3>

<p>Predicted values for the fixed effects component (<code>type = "fixed"</code> or
<code>type = "zero_inflated"</code>) are based on <code>predict(..., type = "mean_subject")</code>,
while predicted values for random effects components (<code>type = "random"</code> or
<code>type = "zi_random"</code>) are calculated with <code>predict(..., type = "subject_specific")</code>
(see <code>?GLMMadaptive::predict.MixMod</code> for details). The latter option
requires the response variable to be defined in the <code>newdata</code>-argument
of <code>predict()</code>, which will be set to its typical value (see
<code><a href="#topic+values_at">values_at()</a></code>).
</p>


<h3>Multinomial Models</h3>

<p><code>polr</code>, <code>clm</code> models, or more generally speaking, models with ordinal or
multinominal outcomes, have an additional column <code>response.level</code>, which
indicates with which level of the response variable the predicted values are
associated.
</p>


<h3>Note</h3>

<p><strong>Printing Results</strong>
</p>
<p>The <code>print()</code> method gives a clean output (especially for predictions by
groups), and indicates at which values covariates were held constant.
Furthermore, the <code>print()</code> method has several arguments to customize the
output. See <a href="https://strengejacke.github.io/ggeffects/articles/introduction_print.html">this vignette</a>
for details.
</p>
<p><strong>Limitations</strong>
</p>
<p>The support for some models, for example from package <strong>MCMCglmm</strong>, is
rather experimental and may fail for certain models. If you encounter
any errors, please file an issue <a href="https://github.com/strengejacke/ggeffects/issues">at Github</a>.
</p>


<h3>References</h3>


<ul>
<li><p> Brooks ME, Kristensen K, Benthem KJ van, Magnusson A, Berg CW, Nielsen A,
et al. glmmTMB Balances Speed and Flexibility Among Packages for Zero-inflated
Generalized Linear Mixed Modeling. The R Journal. 2017;9: 378-400.
</p>
</li>
<li><p> Johnson PC, O'Hara RB. 2014. Extension of Nakagawa &amp; Schielzeth's R2GLMM
to random slopes models. Methods Ecol Evol, 5: 944-946.
</p>
</li>
<li><p> Dickerman BA, Hernan, MA. Counterfactual prediction is not only for causal
inference. Eur J Epidemiol 35, 615–617 (2020).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(sjlabelled)
data(efc)
fit &lt;- lm(barthtot ~ c12hour + neg_c_7 + c161sex + c172code, data = efc)

predict_response(fit, terms = "c12hour")
predict_response(fit, terms = c("c12hour", "c172code"))
# more compact table layout for printing
out &lt;- predict_response(fit, terms = c("c12hour", "c172code", "c161sex"))
print(out, collapse_table = TRUE)

# specified as formula
predict_response(fit, terms = ~ c12hour + c172code + c161sex)

# only range of 40 to 60 for variable 'c12hour'
predict_response(fit, terms = "c12hour [40:60]")

# terms as named list
predict_response(fit, terms = list(c12hour = 40:60))

# covariate "neg_c_7" is held constant at a value of 11.84 (its mean value).
# To use a different value, use "condition"
predict_response(fit, terms = "c12hour [40:60]", condition = c(neg_c_7 = 20))

# to plot ggeffects-objects, you can use the 'plot()'-function.
# the following examples show how to build your ggplot by hand.


# plot predicted values, remaining covariates held constant
library(ggplot2)
mydf &lt;- predict_response(fit, terms = "c12hour")
ggplot(mydf, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.1)

# three variables, so we can use facets and groups
mydf &lt;- predict_response(fit, terms = c("c12hour", "c161sex", "c172code"))
ggplot(mydf, aes(x = x, y = predicted, colour = group)) +
  stat_smooth(method = "lm", se = FALSE) +
  facet_wrap(~facet, ncol = 2)

# select specific levels for grouping terms
mydf &lt;- predict_response(fit, terms = c("c12hour", "c172code [1,3]", "c161sex"))
ggplot(mydf, aes(x = x, y = predicted, colour = group)) +
  stat_smooth(method = "lm", se = FALSE) +
  facet_wrap(~facet) +
  labs(
    y = get_y_title(mydf),
    x = get_x_title(mydf),
    colour = get_legend_title(mydf)
  )

# level indication also works for factors with non-numeric levels
# and in combination with numeric levels for other variables
data(efc)
efc$c172code &lt;- sjlabelled::as_label(efc$c172code)
fit &lt;- lm(barthtot ~ c12hour + neg_c_7 + c161sex + c172code, data = efc)
predict_response(fit, terms = c("c12hour",
  "c172code [low level of education, high level of education]",
  "c161sex [1]"))

# when "terms" is a named list
predict_response(fit, terms = list(
  c12hour = seq(0, 170, 30),
  c172code = c("low level of education", "high level of education"),
  c161sex = 1)
)

# use categorical value on x-axis, use axis-labels, add error bars
dat &lt;- predict_response(fit, terms = c("c172code", "c161sex"))
ggplot(dat, aes(x, predicted, colour = group)) +
  geom_point(position = position_dodge(0.1)) +
  geom_errorbar(
    aes(ymin = conf.low, ymax = conf.high),
    position = position_dodge(0.1)
  ) +
  scale_x_discrete(breaks = 1:3, labels = get_x_labels(dat))

# 3-way-interaction with 2 continuous variables
data(efc)
# make categorical
efc$c161sex &lt;- as_factor(efc$c161sex)
fit &lt;- lm(neg_c_7 ~ c12hour * barthtot * c161sex, data = efc)
# select only levels 30, 50 and 70 from continuous variable Barthel-Index
dat &lt;- predict_response(fit, terms = c("c12hour", "barthtot [30,50,70]", "c161sex"))
ggplot(dat, aes(x = x, y = predicted, colour = group)) +
  stat_smooth(method = "lm", se = FALSE, fullrange = TRUE) +
  facet_wrap(~facet) +
  labs(
    colour = get_legend_title(dat),
    x = get_x_title(dat),
    y = get_y_title(dat),
    title = get_title(dat)
  )

# or with ggeffects' plot-method
plot(dat, ci = FALSE)


# predictions for polynomial terms
data(efc)
fit &lt;- glm(
  tot_sc_e ~ c12hour + e42dep + e17age + I(e17age^2) + I(e17age^3),
  data = efc,
  family = poisson()
)
predict_response(fit, terms = "e17age")

</code></pre>

<hr>
<h2 id='pretty_range'>Create a pretty sequence over a range of a vector</h2><span id='topic+pretty_range'></span>

<h3>Description</h3>

<p>Creates an evenly spaced, pretty sequence of numbers for a
range of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pretty_range(x, n = NULL, length = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pretty_range_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="pretty_range_+3A_n">n</code></td>
<td>
<p>Numeric value, indicating the size of how many values are used to
create a pretty sequence. If <code>x</code> has a large value range (&gt; 100),
<code>n</code> could be something between 1 to 5. If <code>x</code> has a rather
small amount of unique values, <code>n</code> could be something between
10 to 20. If <code>n = NULL</code>, <code>pretty_range()</code> automatically
tries to find a pretty sequence.</p>
</td></tr>
<tr><td><code id="pretty_range_+3A_length">length</code></td>
<td>
<p>Integer value, as alternative to <code>n</code>, defines the number of
intervals to be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with a range corresponding to the minimum and
maximum values of <code>x</code>. If <code>x</code> is missing, a function,
pre-programmed with <code>n</code> and <code>length</code> is returned. See examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
# pretty range for vectors with decimal points
pretty_range(iris$Petal.Length)

# pretty range for large range, increasing by 50
pretty_range(1:1000)

# increasing by 20
pretty_range(1:1000, n = 7)

# return 10 intervals
pretty_range(1:1000, length = 10)

# same result
pretty_range(1:1000, n = 2.5)

# function factory
range_n_5 &lt;- pretty_range(n = 5)
range_n_5(1:1000)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+print_html'></span><span id='topic+print_md'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>insight</dt><dd><p><code><a href="insight.html#topic+display">print_html</a></code>, <code><a href="insight.html#topic+display">print_md</a></code></p>
</dd>
</dl>

<hr>
<h2 id='residualize_over_grid'>Compute partial residuals from a data grid</h2><span id='topic+residualize_over_grid'></span><span id='topic+residualize_over_grid.data.frame'></span><span id='topic+residualize_over_grid.ggeffects'></span>

<h3>Description</h3>

<p>This function computes partial residuals based on a data grid,
where the data grid is usually a data frame from all combinations of factor
variables or certain values of numeric vectors. This data grid is usually used
as <code>newdata</code> argument in <code>predict()</code>, and can be created with
<code><a href="#topic+new_data">new_data()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residualize_over_grid(grid, model, ...)

## S3 method for class 'data.frame'
residualize_over_grid(grid, model, predictor_name, ...)

## S3 method for class 'ggeffects'
residualize_over_grid(grid, model, protect_names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residualize_over_grid_+3A_grid">grid</code></td>
<td>
<p>A data frame representing the data grid, or an object of class
<code>ggeffects</code>, as returned by <code>predict_response()</code>.</p>
</td></tr>
<tr><td><code id="residualize_over_grid_+3A_model">model</code></td>
<td>
<p>The model for which to compute partial residuals. The data grid
<code>grid</code> should match to predictors in the model.</p>
</td></tr>
<tr><td><code id="residualize_over_grid_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="residualize_over_grid_+3A_predictor_name">predictor_name</code></td>
<td>
<p>The name of the focal predictor, for which partial residuals
are computed.</p>
</td></tr>
<tr><td><code id="residualize_over_grid_+3A_protect_names">protect_names</code></td>
<td>
<p>Logical, if <code>TRUE</code>, preserves column names from the
<code>ggeffects</code> objects that is used as <code>grid</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with residuals for the focal predictor.
</p>


<h3>Partial Residuals</h3>

<p>For <strong>generalized linear models</strong> (glms), residualized scores are
computed as <code>inv.link(link(Y) + r)</code> where <code>Y</code> are the predicted
values on the response scale, and <code>r</code> are the <em>working</em> residuals.
<br /><br />
For (generalized) linear <strong>mixed models</strong>, the random effect are also
partialled out.
</p>


<h3>References</h3>

<p>Fox J, Weisberg S. Visualizing Fit and Lack of Fit in Complex Regression
Models with Predictor Effect Plots and Partial Residuals. Journal of Statistical
Software 2018;87.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggeffects)
set.seed(1234)
x &lt;- rnorm(200)
z &lt;- rnorm(200)
# quadratic relationship
y &lt;- 2 * x + x^2 + 4 * z + rnorm(200)

d &lt;- data.frame(x, y, z)
model &lt;- lm(y ~ x + z, data = d)

pr &lt;- predict_response(model, c("x [all]", "z"))
head(residualize_over_grid(pr, model))
</code></pre>

<hr>
<h2 id='test_predictions'>(Pairwise) comparisons between predictions (marginal effects)</h2><span id='topic+test_predictions'></span><span id='topic+hypothesis_test'></span><span id='topic+test_predictions.default'></span><span id='topic+test_predictions.ggeffects'></span>

<h3>Description</h3>

<p>Function to test differences of adjusted predictions for
statistical significance. This is usually called contrasts or (pairwise)
comparisons, or &quot;marginal effects&quot;. <code>hypothesis_test()</code> is an alias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_predictions(model, ...)

hypothesis_test(model, ...)

## Default S3 method:
test_predictions(
  model,
  terms = NULL,
  by = NULL,
  test = "pairwise",
  equivalence = NULL,
  scale = "response",
  p_adjust = NULL,
  df = NULL,
  ci_level = 0.95,
  collapse_levels = FALSE,
  verbose = TRUE,
  ci.lvl = ci_level,
  ...
)

## S3 method for class 'ggeffects'
test_predictions(
  model,
  by = NULL,
  test = "pairwise",
  equivalence = NULL,
  scale = "response",
  p_adjust = NULL,
  df = NULL,
  collapse_levels = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_predictions_+3A_model">model</code></td>
<td>
<p>A fitted model object, or an object of class <code>ggeffects</code>.</p>
</td></tr>
<tr><td><code id="test_predictions_+3A_...">...</code></td>
<td>
<p>Arguments passed down to <code><a href="#topic+data_grid">data_grid()</a></code> when creating the reference
grid and to <code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> resp. <code><a href="marginaleffects.html#topic+slopes">marginaleffects::slopes()</a></code>.
For instance, arguments <code>type</code> or <code>transform</code> can be used to back-transform
comparisons and contrasts to different scales. <code>vcov</code> can be used to
calculate heteroscedasticity-consistent standard errors for contrasts.
See examples at the bottom of
<a href="https://strengejacke.github.io/ggeffects/articles/introduction_comparisons_1.html">this vignette</a>
for further details. To define a heteroscedasticity-consistent
variance-covariance matrix, you can either use the same arguments as for
<code>predict_response()</code> etc., namely <code>vcov_fun</code>, <code>vcov_type</code> and <code>vcov_args</code>.
These are then transformed into a matrix and passed down to the <code>vcov</code>
argument in <em>marginaleffects</em>. Or you directly use the <code>vcov</code> argument. See
<code>?marginaleffects::slopes</code> for further details.</p>
</td></tr>
<tr><td><code id="test_predictions_+3A_terms">terms</code></td>
<td>
<p>Character vector with the names of the focal terms from <code>model</code>,
for which contrasts or comparisons should be displayed. At least one term
is required, maximum length is three terms. If the first focal term is numeric,
contrasts or comparisons for the <em>slopes</em> of this numeric predictor are
computed (possibly grouped by the levels of further categorical focal
predictors).</p>
</td></tr>
<tr><td><code id="test_predictions_+3A_by">by</code></td>
<td>
<p>Character vector specifying the names of predictors to condition on.
Hypothesis test is then carried out for focal terms by each level of <code>by</code>
variables. This is useful especially for interaction terms, where we want
to test the interaction within &quot;groups&quot;. <code>by</code> is only relevant for
categorical predictors.</p>
</td></tr>
<tr><td><code id="test_predictions_+3A_test">test</code></td>
<td>
<p>Hypothesis to test. By default, pairwise-comparisons are
conducted. See section <em>Introduction into contrasts and pairwise comparisons</em>.</p>
</td></tr>
<tr><td><code id="test_predictions_+3A_equivalence">equivalence</code></td>
<td>
<p>ROPE's lower and higher bounds. Should be <code>"default"</code> or
a vector of length two (e.g., <code>c(-0.1, 0.1)</code>). If <code>"default"</code>,
<code><a href="bayestestR.html#topic+rope_range">bayestestR::rope_range()</a></code> is used. Instead of using the <code>equivalence</code>
argument, it is also possible to call the <code>equivalence_test()</code> method
directly. This requires the <strong>parameters</strong> package to be loaded. When
using <code>equivalence_test()</code>, two more columns with information about the
ROPE coverage and decision on H0 are added. Furthermore, it is possible
to <code>plot()</code> the results from <code>equivalence_test()</code>. See
<code><a href="bayestestR.html#topic+equivalence_test">bayestestR::equivalence_test()</a></code> resp. <code><a href="parameters.html#topic+equivalence_test.lm">parameters::equivalence_test.lm()</a></code>
for details.</p>
</td></tr>
<tr><td><code id="test_predictions_+3A_scale">scale</code></td>
<td>
<p>Character string, indicating the scale on which the contrasts
or comparisons are represented. Can be one of:
</p>

<ul>
<li> <p><code>"response"</code> (default), which would return contrasts on the response
scale (e.g. for logistic regression, as probabilities);
</p>
</li>
<li> <p><code>"link"</code> to return contrasts on scale of the linear predictors
(e.g. for logistic regression, as log-odds);
</p>
</li>
<li> <p><code>"probability"</code> (or <code>"probs"</code>) returns contrasts on the probability scale,
which is required for some model classes, like <code>MASS::polr()</code>;
</p>
</li>
<li> <p><code>"oddsratios"</code> to return contrasts on the odds ratio scale (only applies
to logistic regression models);
</p>
</li>
<li> <p><code>"irr"</code> to return contrasts on the odds ratio scale (only applies to
count models);
</p>
</li>
<li><p> or a transformation function like <code>"exp"</code> or <code>"log"</code>, to return transformed
(exponentiated respectively logarithmic) contrasts; note that these
transformations are applied to the <em>response scale</em>.
</p>
</li></ul>

<p><strong>Note:</strong> If the <code>scale</code> argument is not supported by the provided <code>model</code>,
it is automaticaly changed to a supported scale-type (a message is printed
when <code>verbose = TRUE</code>).</p>
</td></tr>
<tr><td><code id="test_predictions_+3A_p_adjust">p_adjust</code></td>
<td>
<p>Character vector, if not <code>NULL</code>, indicates the method to
adjust p-values. See <code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code> or <code><a href="stats.html#topic+p.adjust">stats::p.adjust.methods</a></code>
for details. Further possible adjustment methods are <code>"tukey"</code> or <code>"sidak"</code>,
and for <code>johnson_neyman()</code>, <code>"fdr"</code> (or <code>"bh"</code>) and <code>"esarey"</code> (or its
short-cut <code>"es"</code>) are available options. Some caution is necessary when
adjusting p-value for multiple comparisons. See also section <em>P-value adjustment</em>
below.</p>
</td></tr>
<tr><td><code id="test_predictions_+3A_df">df</code></td>
<td>
<p>Degrees of freedom that will be used to compute the p-values and
confidence intervals. If <code>NULL</code>, degrees of freedom will be extracted from
the model using <code><a href="insight.html#topic+get_df">insight::get_df()</a></code> with <code>type = "wald"</code>.</p>
</td></tr>
<tr><td><code id="test_predictions_+3A_ci_level">ci_level</code></td>
<td>
<p>Numeric, the level of the confidence intervals.</p>
</td></tr>
<tr><td><code id="test_predictions_+3A_collapse_levels">collapse_levels</code></td>
<td>
<p>Logical, if <code>TRUE</code>, term labels that refer to identical
levels are no longer separated by &quot;-&quot;, but instead collapsed into a unique
term label (e.g., <code>"level a-level a"</code> becomes <code>"level a"</code>). See 'Examples'.</p>
</td></tr>
<tr><td><code id="test_predictions_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages and warnings.</p>
</td></tr>
<tr><td><code id="test_predictions_+3A_ci.lvl">ci.lvl</code></td>
<td>
<p>Deprecated, please use <code>ci_level</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing predictions (e.g. for <code>test = NULL</code>),
contrasts or pairwise comparisons of adjusted predictions or estimated
marginal means.
</p>


<h3>Introduction into contrasts and pairwise comparisons</h3>

<p>There are many ways to test contrasts or pairwise comparisons. A
detailed introduction with many (visual) examples is shown in
<a href="https://strengejacke.github.io/ggeffects/articles/introduction_comparisons_1.html">this vignette</a>.
</p>


<h3>P-value adjustment for multiple comparisons</h3>

<p>Note that p-value adjustment for methods supported by <code>p.adjust()</code> (see also
<code>p.adjust.methods</code>), each row is considered as one set of comparisons, no
matter which <code>test</code> was specified. That is, for instance, when <code>test_predictions()</code>
returns eight rows of predictions (when <code>test = NULL</code>), and <code>p_adjust = "bonferroni"</code>,
the p-values are adjusted in the same way as if we had a test of pairwise
comparisons (<code>test = "pairwise"</code>) where eight rows of comparisons are
returned. For methods <code>"tukey"</code> or <code>"sidak"</code>, a rank adjustment is done
based on the number of combinations of levels from the focal predictors
in <code>terms</code>. Thus, the latter two methods may be useful for certain tests
only, in particular pairwise comparisons.
</p>
<p>For <code>johnson_neyman()</code>, the only available adjustment methods are <code>"fdr"</code>
(or <code>"bh"</code>) (<em>Benjamini &amp; Hochberg (1995)</em>) and <code>"esarey"</code> (or <code>"es"</code>)
(<em>Esarey and Sumner 2017</em>). These usually return similar results. The major
difference is that <code>"fdr"</code> can be slightly faster and more stable in edge
cases, however, confidence intervals are not updated. Only the p-values are
adjusted. <code>"esarey"</code> is slower, but confidence intervals are updated as well.
</p>


<h3>Global Options to Customize Tables when Printing</h3>

<p>The <code>verbose</code> argument can be used to display or silence messages and
warnings. Furthermore, <code>options()</code> can be used to set defaults for the
<code>print()</code> and <code>print_html()</code> method. The following options are available,
which can simply be run in the console:
</p>

<ul>
<li> <p><code>ggeffects_ci_brackets</code>: Define a character vector of length two, indicating
the opening and closing parentheses that encompass the confidence intervals
values, e.g. <code>options(ggeffects_ci_brackets = c("[", "]"))</code>.
</p>
</li>
<li> <p><code>ggeffects_collapse_ci</code>: Logical, if <code>TRUE</code>, the columns with predicted
values (or contrasts) and confidence intervals are collapsed into one
column, e.g. <code>options(ggeffects_collapse_ci = TRUE)</code>.
</p>
</li>
<li> <p><code>ggeffects_collapse_p</code>: Logical, if <code>TRUE</code>, the columns with predicted
values (or contrasts) and p-values are collapsed into one column, e.g.
<code>options(ggeffects_collapse_p = TRUE)</code>. Note that p-values are replaced
by asterisk-symbols (stars) or empty strings when <code>ggeffects_collapse_p = TRUE</code>,
depending on the significance level.
</p>
</li>
<li> <p><code>ggeffects_collapse_tables</code>: Logical, if <code>TRUE</code>, multiple tables for
subgroups are combined into one table. Only works when there is more than
one focal term, e.g. <code>options(ggeffects_collapse_tables = TRUE)</code>.
</p>
</li>
<li> <p><code>ggeffects_output_format</code>: String, either <code>"text"</code>, <code>"markdown"</code> or <code>"html"</code>.
Defines the default output format from <code>predict_response()</code>. If <code>"html"</code>, a
formatted HTML table is created and printed to the view pane. <code>"markdown"</code>
creates a markdown-formatted table inside Rmarkdown documents, and prints
a text-format table to the console when used interactively. If <code>"text"</code> or
<code>NULL</code>, a formatted table is printed to the console, e.g.
<code>options(ggeffects_output_format = "html")</code>.
</p>
</li>
<li> <p><code>ggeffects_html_engine</code>: String, either <code>"tt"</code> or <code>"gt"</code>. Defines the default
engine to use for printing HTML tables. If <code>"tt"</code>, the <em>tinytable</em> package
is used, if <code>"gt"</code>, the <em>gt</em> package is used, e.g.
<code>options(ggeffects_html_engine = "gt")</code>.
</p>
</li></ul>

<p>Use <code style="white-space: pre;">&#8288;options(&lt;option_name&gt; = NULL)&#8288;</code> to remove the option.
</p>


<h3>References</h3>

<p>Esarey, J., &amp; Sumner, J. L. (2017). Marginal effects in interaction models:
Determining and controlling the false positive rate. Comparative Political
Studies, 1–33. Advance online publication. doi: 10.1177/0010414017730080
</p>


<h3>See Also</h3>

<p>There is also an <code>equivalence_test()</code> method in the <strong>parameters</strong>
package (<code><a href="parameters.html#topic+equivalence_test.lm">parameters::equivalence_test.lm()</a></code>), which can be used to
test contrasts or comparisons for practical equivalence. This method also
has a <code>plot()</code> method, hence it is possible to do something like:
</p>
<div class="sourceCode"><pre>library(parameters)
predict_response(model, focal_terms) |&gt;
  equivalence_test() |&gt;
  plot()
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>

data(efc)
efc$c172code &lt;- as.factor(efc$c172code)
efc$c161sex &lt;- as.factor(efc$c161sex)
levels(efc$c161sex) &lt;- c("male", "female")
m &lt;- lm(barthtot ~ c12hour + neg_c_7 + c161sex + c172code, data = efc)

# direct computation of comparisons
test_predictions(m, "c172code")

# passing a `ggeffects` object
pred &lt;- predict_response(m, "c172code")
test_predictions(pred)

# test for slope
test_predictions(m, "c12hour")

# interaction - contrasts by groups
m &lt;- lm(barthtot ~ c12hour + c161sex * c172code + neg_c_7, data = efc)
test_predictions(m, c("c161sex", "c172code"), test = NULL)

# interaction - pairwise comparisons by groups
test_predictions(m, c("c161sex", "c172code"))

# equivalence testing
test_predictions(m, c("c161sex", "c172code"), equivalence = c(-2.96, 2.96))

# equivalence testing, using the parameters package
pr &lt;- predict_response(m, c("c161sex", "c172code"))
parameters::equivalence_test(pr)

# interaction - collapse unique levels
test_predictions(m, c("c161sex", "c172code"), collapse_levels = TRUE)

# p-value adjustment
test_predictions(m, c("c161sex", "c172code"), p_adjust = "tukey")

# not all comparisons, only by specific group levels
test_predictions(m, "c172code", by = "c161sex")

# specific comparisons
test_predictions(m, c("c161sex", "c172code"), test = "b2 = b1")

# interaction - slope by groups
m &lt;- lm(barthtot ~ c12hour + neg_c_7 * c172code + c161sex, data = efc)
test_predictions(m, c("neg_c_7", "c172code"))

# Example: marginal effects -----------------------------
# -------------------------------------------------------
data(iris)
m &lt;- lm(Petal.Width ~ Petal.Length + Species, data = iris)

# we now want the marginal effects for "Species". We can calculate
# the marginal effect using the "margins" package
margins::margins(m, variables = "Species")

# we get the same marginal effect from the "marginaleffects" package
marginaleffects::avg_slopes(m, variables = "Species")

# finally, test_predictions() returns the same. while the previous results
# report the marginal effect compared to the reference level "setosa",
# test_predictions() returns the marginal effects for all pairwise comparisons
test_predictions(m, "Species")


</code></pre>

<hr>
<h2 id='values_at'>Calculate representative values of a vector</h2><span id='topic+values_at'></span><span id='topic+representative_values'></span>

<h3>Description</h3>

<p>This function calculates representative values of a vector,
like minimum/maximum values or lower, median and upper quartile etc.,
which can be used for numeric vectors to plot adjusted predictions at these
representative values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>values_at(x, values = "meansd")

representative_values(x, values = "meansd")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="values_at_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="values_at_+3A_values">values</code></td>
<td>
<p>Character vector, naming a pattern for which representative values
should be calculcated.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;"minmax": &#8288;</code>(default) minimum and maximum values (lower and upper bounds)
of the moderator are used to plot the interaction between independent
variable and moderator.
</p>
</li>
<li> <p><code>"meansd"</code>: uses the mean value of the moderator as well as one standard
deviation below and above mean value to plot the effect of the moderator
on the independent variable.
</p>
</li>
<li> <p><code>"zeromax"</code>: is similar to the <code>"minmax"</code> option, however, <code>0</code> is always
used as minimum value for the moderator. This may be useful for predictors
that don't have an empirical zero-value, but absence of moderation should
be simulated by using 0 as minimum.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"fivenum": &#8288;</code>calculates and uses the Tukey's five number summary (minimum,
lower-hinge, median, upper-hinge, maximum) of the moderator value.
</p>
</li>
<li> <p><code>"quart"</code>: calculates and uses the quartiles (lower, median and upper) of
the moderator value, <em>including</em> minimum and maximum value.
</p>
</li>
<li> <p><code>"quart2"</code>: calculates and uses the quartiles (lower, median and upper) of
the moderator value, <em>excluding</em> minimum and maximum value.
</p>
</li>
<li> <p><code>"terciles"</code>: calculates and uses the terciles (lower and upper third) of
the moderator value, <em>including</em> minimum and maximum value.
</p>
</li>
<li> <p><code>"terciles2"</code>: calculates and uses the terciles (lower and upper third)
of the moderator value, <em>excluding</em> minimum and maximum value.
</p>
</li>
<li> <p><code>"all"</code>: uses all values of the moderator variable. Note that this option
only applies to <code>type = "eff"</code>, for numeric moderator values.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length two or three, representing the required
values from <code>x</code>, like minimum/maximum value or mean and +/- 1 SD. If
<code>x</code> is missing, a function, pre-programmed with <code>n</code> and
<code>length</code> is returned. See examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
values_at(efc$c12hour)
values_at(efc$c12hour, "quart2")

mean_sd &lt;- values_at(values = "meansd")
mean_sd(efc$c12hour)
</code></pre>

<hr>
<h2 id='vcov'>Calculate variance-covariance matrix for adjusted predictions</h2><span id='topic+vcov'></span><span id='topic+vcov.ggeffects'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix for the predicted values from <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggeffects'
vcov(
  object,
  vcov_fun = NULL,
  vcov_type = NULL,
  vcov_args = NULL,
  vcov.fun = vcov_fun,
  vcov.type = vcov_type,
  vcov.args = vcov_args,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov_+3A_object">object</code></td>
<td>
<p>An object of class <code>"ggeffects"</code>, as returned by <code>predict_response()</code>.</p>
</td></tr>
<tr><td><code id="vcov_+3A_vcov_fun">vcov_fun</code></td>
<td>
<p>Variance-covariance matrix used to compute uncertainty
estimates (e.g., for confidence intervals based on robust standard errors).
This argument accepts a covariance matrix, a function which returns a
covariance matrix, or a string which identifies the function to be used to
compute the covariance matrix.
</p>

<ul>
<li><p> A (variance-covariance) matrix
</p>
</li>
<li><p> A function which returns a covariance matrix (e.g., <code>stats::vcov()</code>)
</p>
</li>
<li><p> A string which indicates the estimation type for the heteroscedasticity-consistent
variance-covariance matrix, e.g. <code>vcov_fun = "HC0"</code>. Possible values are
<code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, and <code>"HC5"</code>, which
will then call the <code>vcovHC()</code>-function from the <strong>sandwich</strong> package, using
the specified type. Further possible values are <code>"CR0"</code>, <code>"CR1"</code>, <code>"CR1p"</code>,
<code>"CR1S"</code>, <code>"CR2"</code>, and <code>"CR3"</code>, which will call the <code>vcovCR()</code>-function from
the <strong>clubSandwich</strong> package.
</p>
</li>
<li><p> A string which indicates the name of the <code style="white-space: pre;">&#8288;vcov*()&#8288;</code>-function from the
<strong>sandwich</strong> or <strong>clubSandwich</strong> packages, e.g. <code>vcov_fun = "vcovCL"</code>,
which is used to compute (cluster) robust standard errors for predictions.
</p>
</li></ul>

<p>If <code>NULL</code>, standard errors (and confidence intervals) for predictions are
based on the standard errors as returned by the <code>predict()</code>-function.
<strong>Note</strong> that probably not all model objects that work with <code>ggpredict()</code>
are also supported by the <strong>sandwich</strong> or <strong>clubSandwich</strong> packages.
</p>
<p>See details in <a href="https://strengejacke.github.io/ggeffects/articles/practical_robustestimation.html">this vignette</a>.</p>
</td></tr>
<tr><td><code id="vcov_+3A_vcov_type">vcov_type</code></td>
<td>
<p>Character vector, specifying the estimation type for the
robust covariance matrix estimation (see <code>?sandwich::vcovHC</code>
or <code>?clubSandwich::vcovCR</code> for details). Only used when <code>vcov_fun</code> is a
character string indicating one of the functions from those packages.</p>
</td></tr>
<tr><td><code id="vcov_+3A_vcov_args">vcov_args</code></td>
<td>
<p>List of named vectors, used as additional arguments that
are passed down to <code>vcov_fun</code>.</p>
</td></tr>
<tr><td><code id="vcov_+3A_vcov.fun">vcov.fun</code>, <code id="vcov_+3A_vcov.type">vcov.type</code>, <code id="vcov_+3A_vcov.args">vcov.args</code></td>
<td>
<p>Deprecated. Use <code>vcov_fun</code>, <code>vcov_type</code>
and <code>vcov_args</code> instead.</p>
</td></tr>
<tr><td><code id="vcov_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned matrix has as many rows (and columns) as possible combinations
of predicted values from the <code>predict_response()</code> call. For example, if there
are two variables in the <code>terms</code>-argument of <code>predict_response()</code> with 3 and 4
levels each, there will be 3*4 combinations of predicted values, so the returned
matrix has a 12x12 dimension. In short, <code>nrow(object)</code> is always equal to
<code>nrow(vcov(object))</code>. See also 'Examples'.
</p>


<h3>Value</h3>

<p>The variance-covariance matrix for the predicted values from <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
model &lt;- lm(barthtot ~ c12hour + neg_c_7 + c161sex + c172code, data = efc)
result &lt;- predict_response(model, c("c12hour [meansd]", "c161sex"))

vcov(result)

# compare standard errors
sqrt(diag(vcov(result)))
as.data.frame(result)

# only two predicted values, no further terms
# vcov() returns a 2x2 matrix
result &lt;- predict_response(model, "c161sex")
vcov(result)

# 2 levels for c161sex multiplied by 3 levels for c172code
# result in 6 combinations of predicted values
# thus vcov() returns a 6x6 matrix
result &lt;- predict_response(model, c("c161sex", "c172code"))
vcov(result)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
