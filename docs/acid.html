<!DOCTYPE html><html><head><title>Help for package acid</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {acid}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acid-package'>
<p>Analysing Conditional Income Distributions</p></a></li>
<li><a href='#arithmean.GB2'><p> Mean of the Generalised Beta Distribution of Second Kind</p></a></li>
<li><a href='#atkinson'><p> Atkinson Inequality Index</p></a></li>
<li><a href='#atkinson.den'><p>  Atkinson Index for an Income Distribution</p></a></li>
<li><a href='#atkinson.GB2'><p> Atkinson Index for a Generalised Beta Distribution of Second Kind</p></a></li>
<li><a href='#atkinson.md'><p>  Atkinson Index for a Mixture of Income Distributions</p></a></li>
<li><a href='#cdf.mix.dag'><p> Cumulative Density Function of Dagum Mixture Distribution</p></a></li>
<li><a href='#cdf.mix.LN'><p>  Cumulative Density Function of Log-Normal Mixture Distribution</p></a></li>
<li><a href='#coeffvar'><p>Coefficient of Variation</p></a></li>
<li><a href='#confband.kneib'><p> Simultaneous Confidence Bands</p></a></li>
<li><a href='#confband.pw'><p> Pointwise Confidence Bands</p></a></li>
<li><a href='#dat'>
<p>ACID Simulated Data</p></a></li>
<li><a href='#den.md'><p> Density for a Mixture of Income Distributions</p></a></li>
<li><a href='#dist.para.t'><p> Distributions and their Parameters</p></a></li>
<li><a href='#entropy'><p> Measures of the Generalised Entropy Family</p></a></li>
<li><a href='#entropy.GB2'><p>Entropy Measures for a Generalised Beta Distribution of Second Kind</p></a></li>
<li><a href='#entropy.md'><p>  Generalised Entropy Measure for a Mixture of Income Distributions</p></a></li>
<li><a href='#frac.ranks'><p> Fractional Ranks</p></a></li>
<li><a href='#gini'><p> Gini Coefficient</p></a></li>
<li><a href='#gini.Dag'><p> Gini Coefficient for the Dagum Distribution</p></a></li>
<li><a href='#gini.den'><p> Gini Coefficient for an Income Distribution</p></a></li>
<li><a href='#gini.gamma'><p> Gini Coefficient for the Gamma Distribution</p></a></li>
<li><a href='#gini.md'><p> Gini Coefficient for a Mixture of Income Distributions</p></a></li>
<li><a href='#ineq.md'><p> Three Inequality Measures for a Mixture of Income Distributions</p></a></li>
<li><a href='#km.GB2'><p> k-th Moment of the Generalised Beta Distribution of Second Kind</p></a></li>
<li><a href='#midks.plot'><p> Plot Comparing Parametric and Empirical Cumulative Density Functions</p></a></li>
<li><a href='#midks.test'><p> Kolmogorov-Smirnov Test assessing a Parametric Mixture for a Conditional Income Distribution</p></a></li>
<li><a href='#params'><p> Parameter estimators obtained from Structured Additive Distributional Regression</p></a></li>
<li><a href='#pens.parade'><p> Pen's Parade</p></a></li>
<li><a href='#polarisation.EGR'><p> Polarisation Measure from Esteban, Gradin and Ray (2007)</p></a></li>
<li><a href='#polarisation.ER'><p>  Polarisation Measure from Esteban and and Ray (1994)</p></a></li>
<li><a href='#pval.md'><p>  P-Value for a Mixture of Income Distributions</p></a></li>
<li><a href='#sadr.test'><p> Misspecification Test assessing a Parametric Conditional Income Distribution</p></a></li>
<li><a href='#sd.GB2'><p> Standard Deviation of the Generalised Beta Distribution of Second Kind</p></a></li>
<li><a href='#sgini'><p>  Single-parameter Gini Coefficient</p></a></li>
<li><a href='#sgini.den'><p>   Single-parameter Gini Coefficient for an Income Distribution</p></a></li>
<li><a href='#skewness.GB2'><p> Skewness of the Generalised Beta Distribution of Second Kind</p></a></li>
<li><a href='#theil.gamma'><p>  Theil Index for the Gamma Distribution</p></a></li>
<li><a href='#weighted.atkinson'><p>  Atkinson Inequality Index</p></a></li>
<li><a href='#weighted.coeffvar'><p> Coefficient of Variation</p></a></li>
<li><a href='#weighted.entropy'><p> Measures of the Generalised Entropy Family</p></a></li>
<li><a href='#weighted.gini'><p>  Gini Coefficient</p></a></li>
<li><a href='#weighted.moments'><p> Moments of a Random Variable</p></a></li>
<li><a href='#ysample.md'><p> Sampling Incomes from a Mixture of Income Distributions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysing Conditional Income Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-02-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Sohn</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Sohn &lt;asohn@uni-goettingen.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for the analysis of income distributions for subgroups of the population as defined by a set of variables like age, gender, region, etc. This entails a Kolmogorov-Smirnov test for a mixture distribution as well as functions for moments, inequality measures, entropy measures and polarisation measures of income distributions. This package thus aides the analysis of income inequality by offering tools for the exploratory analysis of income distributions at the disaggregated level. </td>
</tr>
<tr>
<td>Depends:</td>
<td>gamlss,gamlss.dist,Hmisc,stats,graphics,splines</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices,utils,datasets,methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ineq</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-02-01 06:36:11 UTC; admin</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-02-01 13:34:52</td>
</tr>
</table>
<hr>
<h2 id='acid-package'>
Analysing Conditional Income Distributions
</h2><span id='topic+acid-package'></span><span id='topic+acid'></span>

<h3>Description</h3>

<p>Functions for the analysis of income distributions for subgroups of the population as defined by a set of variables like age, gender, region, etc. 
This entails a Kolmogorov-Smirnov test for a mixture distribution as well as functions for moments, inequality measures, entropy measures and polarisation measures of income distributions. 
This package thus aides the analysis of income inequality by offering tools for the exploratory analysis of income distributions at the disaggregated level. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> acid</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-01-06</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code><a href="#topic+sadr.test">sadr.test</a></code>, 
<code><a href="#topic+polarisation.ER">polarisation.ER</a></code>,
<code><a href="#topic+gini.den">gini.den</a></code>  
</p>


<h3>Author(s)</h3>

<p>Alexander Sohn &lt;asohn@uni-goettingen.de&gt;
</p>


<h3>References</h3>

<p>Klein, N. and Kneib, T., Lang, S. and Sohn, A. (2015): 
Bayesian Structured Additive Distributional Regression with an Application to Regional Income Inequality in Germany, in: 
Annals of Applied Statistics, Vol. 9(2), pp. 1024-1052.
</p>
<p>Sohn, A., Klein, N. and Kneib. T. (2014): A New Semiparametric Approach to Analysing Conditional Income Distributions, in: SOEPpapers, No. 676.
</p>


<h3>See Also</h3>

 <p><code><a href="gamlss.html#topic+gamlss">gamlss</a></code>, <code><a href="ineq.html#topic+ineq">ineq</a></code>
</p>

<hr>
<h2 id='arithmean.GB2'> Mean of the Generalised Beta Distribution of Second Kind
</h2><span id='topic+arithmean.GB2'></span>

<h3>Description</h3>

<p> This function calculates the expectation of the Generalised Beta Distribution of Second Kind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arithmean.GB2(b, a, p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arithmean.GB2_+3A_b">b</code></td>
<td>
<p> the parameter b of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="arithmean.GB2_+3A_a">a</code></td>
<td>
<p> the parameter a of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="arithmean.GB2_+3A_p">p</code></td>
<td>
<p> the parameter p of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="arithmean.GB2_+3A_q">q</code></td>
<td>
<p> the parameter q of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the expectation.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p> Kleiber, C. and Kotz, S. (2003): Statistical Size Distributions in Economics and Actuarial Sciences, Wiley, Hoboken.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a.test&lt;- 4
b.test&lt;- 20000
p.test&lt;- 0.7
q.test&lt;- 1
alpha.test&lt;-1
GB2sample&lt;-rGB2(10000,b.test,a.test,p.test,q.test)
arithmean.GB2(b.test,a.test,p.test,q.test)
mean(GB2sample)
</code></pre>

<hr>
<h2 id='atkinson'> Atkinson Inequality Index
</h2><span id='topic+atkinson'></span>

<h3>Description</h3>

<p>  This function computes the Atkinson inequality index for a vector of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atkinson(x, epsilon = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atkinson_+3A_x">x</code></td>
<td>
<p>  a vector of observations.
</p>
</td></tr>
<tr><td><code id="atkinson_+3A_epsilon">epsilon</code></td>
<td>
<p> inequality aversion parameter as denoted by Atkinson (1970). The default is epsilon=1. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>  returns the selected Atkinson inequality index.
</p>


<h3>Author(s)</h3>

<p>  Alexander Sohn
</p>


<h3>References</h3>

<p> Atkinson, A.B. (1970): On the Measurment of Inequality, in: Journal of Economic Theory, Vol. 2(3), pp. 244-263.
</p>


<h3>See Also</h3>

 <p><code><a href="ineq.html#topic+ineq">ineq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(541, 1463, 2445, 3438, 4437, 5401, 6392, 8304, 11904, 22261)
atkinson(x)
</code></pre>

<hr>
<h2 id='atkinson.den'>  Atkinson Index for an Income Distribution
</h2><span id='topic+atkinson.den'></span>

<h3>Description</h3>

<p> This function approximates the Atkinson index for a distribution specified by a vector of densities and a corresponding income vector. A point mass at zero is allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atkinson.den(incs, dens, epsilon = 1, pm0 = NA, 
lower = NULL, upper = NULL, zero.approx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atkinson.den_+3A_incs">incs</code></td>
<td>
<p> a vector with income values.
</p>
</td></tr>
<tr><td><code id="atkinson.den_+3A_dens">dens</code></td>
<td>
<p> a vector with the corresponding densities.
</p>
</td></tr>
<tr><td><code id="atkinson.den_+3A_epsilon">epsilon</code></td>
<td>
<p>  inequality aversion parameter as denoted by Atkinson (1970). The default is epsilon=1. 
</p>
</td></tr>
<tr><td><code id="atkinson.den_+3A_pm0">pm0</code></td>
<td>
<p> the point mass for zero incomes. If not specified no point mass is assumed.
</p>
</td></tr>
<tr><td><code id="atkinson.den_+3A_lower">lower</code></td>
<td>
<p> the lower bound of the income range considered. 
</p>
</td></tr>
<tr><td><code id="atkinson.den_+3A_upper">upper</code></td>
<td>
<p> the upper bound of the income range considered.
</p>
</td></tr>
<tr><td><code id="atkinson.den_+3A_zero.approx">zero.approx</code></td>
<td>
<p> a scalar which replaces zero-incomes, such that the Atkinson index involving a logarithm return finite values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>AIM</code></td>
<td>
<p>the approximation of the selected Atkinson inequality measure.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>the inequality aversion parameter used.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>the approximated expected value of the distribution.</p>
</td></tr>
<tr><td><code>pm0</code></td>
<td>
<p>the point mass for zero incomes used.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>the lower bound of the income range considered used.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>the upper bound of the income range considered used.</p>
</td></tr>
<tr><td><code>zero.approx</code></td>
<td>
<p>the zero approximation used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p> Atkinson, A.B. (1970): On the Measurment of Inequality, in: Journal of Economic Theory, Vol. 2(3), pp. 244-263.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+atkinson">atkinson</a></code> , <code><a href="#topic+atkinson.md">atkinson.md</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## without point mass at zero
incs&lt;-seq(0,500,by=0.01)
dens&lt;-dLOGNO(incs,2,1)
plot(incs,dens,type="l",xlim=c(0,100))
atkinson.den(incs=incs,dens=dens,epsilon=1)$AIM
atkinson(rLOGNO(50000,2,1),epsilon=1)
atkinson.den(incs=incs,dens=dens,epsilon=0.5)$AIM
atkinson(rLOGNO(50000,2,1),epsilon=0.5)

## with point mass at zero
incs&lt;-c(seq(0,100,by=0.1),seq(100.1,1000,by=1),seq(1001,10000,by=10))
dens&lt;-dLOGNO(incs,2,1)/2
dens[1]&lt;-0.5
plot(incs,dens,type="l",ylim=c(0,max(dens[-1])),xlim=c(0,100))
#without zero approx zeros
atkinson.den(incs=incs,dens=dens,epsilon=1,pm0=0.5)$AIM
atkinson(c(rep(0,25000),rLOGNO(25000,2,1)),epsilon=1)
atkinson.den(incs=incs,dens=dens,epsilon=0.5,pm0=0.5)$AIM
atkinson(c(rep(0,25000),rLOGNO(25000,2,1)),epsilon=0.5)
#with zero approximation 
atkinson.den(incs=incs,dens=dens,epsilon=0.5,pm0=0.5,zero.approx=1)$AIM
atkinson(c(rep(1,25000),rLOGNO(25000,2,1)),epsilon=0.5)
atkinson.den(incs=incs,dens=dens,epsilon=1,pm0=0.5,zero.approx=0.01)$AIM
atkinson(c(rep(0.01,250000),rLOGNO(250000,2,1)),epsilon=1)

</code></pre>

<hr>
<h2 id='atkinson.GB2'> Atkinson Index for a Generalised Beta Distribution of Second Kind
</h2><span id='topic+atkinson.GB2'></span>

<h3>Description</h3>

<p> This function computes the Atkinson index (I(epsilon)) for Generalised Beta Distribution of Second Kind. 
The function is exact for the values epsilon=0, epsilon=1 and epsilon=2. 
For other values of epsilon, the function provides a numerical approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atkinson.GB2(b, a, p, q, epsilon = NULL, ylim = c(0, 1e+06), zeroapprox = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atkinson.GB2_+3A_b">b</code></td>
<td>
<p> the parameter b of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="atkinson.GB2_+3A_a">a</code></td>
<td>
<p>  the parameter a of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="atkinson.GB2_+3A_p">p</code></td>
<td>
<p>  the parameter p of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="atkinson.GB2_+3A_q">q</code></td>
<td>
<p>  the parameter q of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="atkinson.GB2_+3A_epsilon">epsilon</code></td>
<td>
<p> inequality aversion parameter as denoted by Atkinson (1970). The default is epsilon=1. 
</p>
</td></tr>
<tr><td><code id="atkinson.GB2_+3A_ylim">ylim</code></td>
<td>
<p> limits of the interval of y considered needed for the approximation of the entropy measure. The default is [0,1e+06].
</p>
</td></tr>
<tr><td><code id="atkinson.GB2_+3A_zeroapprox">zeroapprox</code></td>
<td>
<p> an approximation for zero needed for the approximation of the entropy measure. The default is 0.01.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>  returns the selected Atkinson inequality index.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p>Atkinson, A.B. (1970): On the Measurment of Inequality, in: Journal of Economic Theory, Vol. 2(3), pp. 244-263.
</p>
<p>Cowell, F.A. (2000): Measurement of Inequality, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 87-166, Elsevier, Amsterdam.
</p>


<h3>See Also</h3>

 <p><code><a href="ineq.html#topic+ineq">ineq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a.test&lt;- 4
b.test&lt;- 20000
p.test&lt;- 0.7
q.test&lt;- 1
epsilon.test&lt;-1
GB2sample&lt;-rGB2(1000,b.test,a.test,p.test,q.test)
atkinson.GB2(b.test,a.test,p.test,q.test,epsilon=epsilon.test,ylim=c(0,1e+07))
atkinson(GB2sample, epsilon.test)
</code></pre>

<hr>
<h2 id='atkinson.md'>  Atkinson Index for a Mixture of Income Distributions
</h2><span id='topic+atkinson.md'></span>

<h3>Description</h3>

<p>  This function uses Monte Carlo methods to estimate the Atkinson index for a mixture of two continuous income distributions and a point mass for zero-incomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atkinson.md(n, epsilon = 1, dist1, dist2, theta, p0, p1, p2, 
dist.para.table, zero.approx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atkinson.md_+3A_n">n</code></td>
<td>
<p> sample size used to estimate the Atkinson index.
</p>
</td></tr>
<tr><td><code id="atkinson.md_+3A_epsilon">epsilon</code></td>
<td>
<p>  inequality aversion parameter as denoted by Atkinson (1970). The default is epsilon=1. 
</p>
</td></tr>
<tr><td><code id="atkinson.md_+3A_dist1">dist1</code></td>
<td>
<p> character string with the name of the first continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="atkinson.md_+3A_dist2">dist2</code></td>
<td>
<p> character string with the name of the second continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="atkinson.md_+3A_theta">theta</code></td>
<td>
<p> vector with the parameters of dist1 and dist2. Order must be the same as in the functions for the distributions.
</p>
</td></tr>
<tr><td><code id="atkinson.md_+3A_p0">p0</code></td>
<td>
<p>  scalar with probability mass for the point mass.
</p>
</td></tr>
<tr><td><code id="atkinson.md_+3A_p1">p1</code></td>
<td>
<p> scalar with probability mass for dist1.
</p>
</td></tr>
<tr><td><code id="atkinson.md_+3A_p2">p2</code></td>
<td>
<p> scalar with probability mass for dist2.
</p>
</td></tr>
<tr><td><code id="atkinson.md_+3A_dist.para.table">dist.para.table</code></td>
<td>
<p> a table of the same form as <code><a href="#topic+dist.para.t">dist.para.t</a></code> with distribution name, function name and number of parameters.
</p>
</td></tr>
<tr><td><code id="atkinson.md_+3A_zero.approx">zero.approx</code></td>
<td>
<p> a scalar which replaces zero-incomes, such that the Atkinson index involving a logarithm return finite values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>AIM</code></td>
<td>
<p>the selected Atkinson inequality measure.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>the inequality aversion parameter used.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a vector with the simulated incomes to estimate the entropy measure.</p>
</td></tr>
<tr><td><code>y2</code></td>
<td>
<p>a vector with the zero-replaced simulated incomes to estimate the entropy measure.</p>
</td></tr>
<tr><td><code>zero.replace</code></td>
<td>
<p>a logical vector indicating whether a zero has been replaced.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector with the simulated group the observation was chosen from. 0 is the point mass, 1 dist1 and 2 dist2.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Sohn
</p>


<h3>References</h3>

<p> Atkinson, A.B. (1970): On the Measurment of Inequality, in: Journal of Economic Theory, Vol. 2(3), pp. 244-263.
</p>


<h3>See Also</h3>

 <p><code><a href="ineq.html#topic+ineq">ineq</a></code> , <code><a href="#topic+atkinson">atkinson</a></code> , <code><a href="#topic+atkinson.den">atkinson.den</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta&lt;-c(2,1,5,2)
x&lt;- c(rgamma(50000,2,1),rgamma(50000,5,2))
para&lt;-1

data(dist.para.t)
atkinson.md(10000,para,"gamma","gamma",theta,0,0.5,0.5,dist.para.t,zero.approx=1)$AIM
atkinson(x,1)

</code></pre>

<hr>
<h2 id='cdf.mix.dag'> Cumulative Density Function of Dagum Mixture Distribution
</h2><span id='topic+cdf.mix.dag'></span>

<h3>Description</h3>

<p> This function yields the cdf of a mixture distribution consisting of a point mass (at the lower end), a uniform distribution
(above the point mass and below the Dagum distribution) and a Dagum distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdf.mix.dag(q, pi0, thres0 = 0, pi1, thres1, mu, sigma, nu, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.mix.dag_+3A_q">q</code></td>
<td>
<p> a vector of quantiles.
</p>
</td></tr>
<tr><td><code id="cdf.mix.dag_+3A_pi0">pi0</code></td>
<td>
<p> the probability mass at thres0.
</p>
</td></tr>
<tr><td><code id="cdf.mix.dag_+3A_thres0">thres0</code></td>
<td>
<p> the location of the probability mass at the lower end of the distribution.
</p>
</td></tr>
<tr><td><code id="cdf.mix.dag_+3A_pi1">pi1</code></td>
<td>
<p> the probability mass of the uniform distribution. 
</p>
</td></tr>
<tr><td><code id="cdf.mix.dag_+3A_thres1">thres1</code></td>
<td>
<p> the upper bound of the uniform distribution. 
</p>
</td></tr>
<tr><td><code id="cdf.mix.dag_+3A_mu">mu</code></td>
<td>
<p> the parameter mu of the Dagum distribution as defined by the function GB2. 
</p>
</td></tr>
<tr><td><code id="cdf.mix.dag_+3A_sigma">sigma</code></td>
<td>
<p> the parameter sigma of the Dagum distribution as defined by the function GB2.
</p>
</td></tr>
<tr><td><code id="cdf.mix.dag_+3A_nu">nu</code></td>
<td>
<p> the parameter nu of the Dagum distribution as defined by the function GB2.
</p>
</td></tr>
<tr><td><code id="cdf.mix.dag_+3A_tau">tau</code></td>
<td>
<p> the parameter tau of the Dagum distribution as defined by the function GB2.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the cumulative density for the given quantiles.
</p>


<h3>Author(s)</h3>

<p>Alexander Sohn
</p>


<h3>References</h3>

 
<p>Sohn, A., Klein, N. and Kneib. T. (2014): A New Semiparametric Approach to Analysing Conditional Income Distributions, in: SOEPpapers, No. 676.
</p>


<h3>See Also</h3>

  <p><code><a href="gamlss.dist.html#topic+gamlss.dist">gamlss.dist</a></code> , <code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pi0.s&lt;-0.2
pi1.s&lt;-0.1
thres0.s&lt;-0
thres1.s&lt;-25000
mu.s&lt;-20000
sigma.s&lt;-5
nu.s&lt;-0.5
tau.s&lt;-1

cdf.mix.dag(50000,pi0.s,thres0.s,pi1.s,thres1.s,mu.s,sigma.s,nu.s,tau.s)
</code></pre>

<hr>
<h2 id='cdf.mix.LN'>  Cumulative Density Function of Log-Normal Mixture Distribution
</h2><span id='topic+cdf.mix.LN'></span>

<h3>Description</h3>

<p> This function yields the cdf of a mixture distribution consisting of a point mass (at the lower end), a uniform distribution
(above the point mass and below the log-normal distribution) and a log-normal distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdf.mix.LN(q, pi0, thres0 = 0, pi1, thres1, mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.mix.LN_+3A_q">q</code></td>
<td>
<p> a vector of quantiles.
</p>
</td></tr>
<tr><td><code id="cdf.mix.LN_+3A_pi0">pi0</code></td>
<td>
<p> the probability mass at thres0.
</p>
</td></tr>
<tr><td><code id="cdf.mix.LN_+3A_thres0">thres0</code></td>
<td>
<p>  the location of the probability mass at the lower end of the distribution.
</p>
</td></tr>
<tr><td><code id="cdf.mix.LN_+3A_pi1">pi1</code></td>
<td>
<p> the probability mass of the uniform distribution. 
</p>
</td></tr>
<tr><td><code id="cdf.mix.LN_+3A_thres1">thres1</code></td>
<td>
<p>  the upper bound of the uniform distribution.
</p>
</td></tr>
<tr><td><code id="cdf.mix.LN_+3A_mu">mu</code></td>
<td>
<p> the parameter mu of the Dagum distribution as defined by the function GB2.
</p>
</td></tr>
<tr><td><code id="cdf.mix.LN_+3A_sigma">sigma</code></td>
<td>
<p> the parameter sigma of the Dagum distribution as defined by the function GB2.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>  returns the cumulative density for the given quantiles.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

 
<p>Sohn, A., Klein, N., Kneib. T. (2014): A New Semiparametric Approach to Analysing Conditional Income Distributions, in: SOEPpapers, No. 676.
</p>


<h3>See Also</h3>

 <p><code><a href="gamlss.dist.html#topic+gamlss.dist">gamlss.dist</a></code> , <code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pi0.s&lt;-0.2
pi1.s&lt;-0.1
thres0.s&lt;-0
thres1.s&lt;-25000
mu.s&lt;-10
sigma.s&lt;-2

cdf.mix.LN(50000,pi0.s,thres0.s,pi1.s,thres1.s,mu.s,sigma.s)
</code></pre>

<hr>
<h2 id='coeffvar'>Coefficient of Variation
</h2><span id='topic+coeffvar'></span>

<h3>Description</h3>

<p>This function computes the Coefficient of Variation for a vector of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coeffvar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coeffvar_+3A_x">x</code></td>
<td>
<p> a vector of observations.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>cv</code></td>
<td>
<p>returns the coefficient of variation without bias correction.</p>
</td></tr>
<tr><td><code>bccv</code></td>
<td>
<p>returns the coefficient of variation with bias correction.</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Weighting is not properly accounted for in the sample adjustment of bccv!
</p>


<h3>Author(s)</h3>

<p>Alexander Sohn
</p>


<h3>References</h3>

<p>Atkinson, A.B. and Bourguignon, F. (2000): Income Distribution and Economics, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 1-86, Elsevier, Amsterdam.
</p>


<h3>See Also</h3>

<p><code><a href="ineq.html#topic+ineq">ineq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate vector (of incomes)
x &lt;- c(541, 1463, 2445, 3438, 4437, 5401, 6392, 8304, 11904, 22261)
coeffvar(x)
</code></pre>

<hr>
<h2 id='confband.kneib'> Simultaneous Confidence Bands
</h2><span id='topic+confband.kneib'></span>

<h3>Description</h3>

<p> This function computes simultaneous confidence bands for samples of the presumed distribution of the parameter estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confband.kneib(samples, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confband.kneib_+3A_samples">samples</code></td>
<td>
<p> matrix containing samples of the presumed distribution of the parameter estimator.
</p>
</td></tr>
<tr><td><code id="confband.kneib_+3A_level">level</code></td>
<td>
<p> the desired confidence level.
</p>
</td></tr>
</table>


<h3>Value</h3>

 
<table>
<tr><td><code>lower</code></td>
<td>
<p>a vector containing the lower bound of the confidence band.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>a vector containing the lower bound of the confidence band.</p>
</td></tr>
</table>


<h3>Note</h3>

<p> This function is taken from the work of T. Krivobokova, T. Kneib and G. Claeskens. 
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p> T. Krivobokova, T. Kneib, G. Claeskens (2010): Simultaneous Confidence Bands for Penalized Spline Estimators, in: Journal of the American Statistical Association, Vol. 105(490), pp.852-863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu&lt;-1:20
n&lt;-1000
mcmc&lt;-matrix(NA,n,20)
for(i in 1:20){
  mcmc[,i]&lt;- rnorm(n,mu[i],sqrt(i))
}

plot(mu,type="l",ylim=c(-10,30),lwd=3)
lines(confband.pw(mcmc)$lower,lty=2)
lines(confband.pw(mcmc)$upper,lty=2)
lines(confband.kneib(mcmc)$lower,lty=3)
lines(confband.kneib(mcmc)$upper,lty=3)

</code></pre>

<hr>
<h2 id='confband.pw'> Pointwise Confidence Bands
</h2><span id='topic+confband.pw'></span>

<h3>Description</h3>

<p> This function computes pointwise confidence bands for samples of the presumed distribution of the parameter estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confband.pw(samples, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confband.pw_+3A_samples">samples</code></td>
<td>
<p> matrix containing samples of the presumed distribution of the parameter estimator.
</p>
</td></tr>
<tr><td><code id="confband.pw_+3A_level">level</code></td>
<td>
<p> the desired confidence level.
</p>
</td></tr>
</table>


<h3>Value</h3>

 
<table>
<tr><td><code>lower</code></td>
<td>
<p>a vector containing the lower bound of the confidence band.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>a vector containing the lower bound of the confidence band.</p>
</td></tr>
</table>


<h3>Note</h3>

<p> This function is mainly derived from the work of T. Krivobokova, T. Kneib and G. Claeskens. 
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p> T. Krivobokova, T. Kneib, G. Claeskens (2010): Simultaneous Confidence Bands for Penalized Spline Estimators, in: Journal of the American Statistical Association, Vol. 105(490), pp.852-863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu&lt;-1:20
n&lt;-1000
mcmc&lt;-matrix(NA,n,20)
for(i in 1:20){
  mcmc[,i]&lt;- rnorm(n,mu[i],sqrt(i))
}

plot(mu,type="l",ylim=c(-10,30),lwd=3)
lines(confband.pw(mcmc)$lower,lty=2)
lines(confband.pw(mcmc)$upper,lty=2)
lines(confband.kneib(mcmc)$lower,lty=3)
lines(confband.kneib(mcmc)$upper,lty=3)

</code></pre>

<hr>
<h2 id='dat'>
ACID Simulated Data
</h2><span id='topic+dat'></span>

<h3>Description</h3>

<p> This is some simulated income data from a mixture model as used in Sohn et al (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dat)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 4
$ dag.para:'data.frame':	8 obs. of  1 variable:
..$ parameters: num [1:8] 0.2 0.1 0 25000 20000 5 0.5 1
$ dag.s   :'data.frame':	100 obs. of  3 variables:
..$ cat: int [1:100] 3 1 3 1 2 3 3 1 3 3 ...
..$ y  : num [1:100] 36410 0 58165 0 15034 ...
..$ w  : int [1:100] 1 1 1 2 1 3 2 1 1 1 ...
$ LN.para :'data.frame':	6 obs. of  1 variable:
..$ parameters: num [1:6] 0.2 0.1 0 25000 10 2
$ LN.s    :'data.frame':	100 obs. of  3 variables:
..$ cat: int [1:100] 3 3 1 3 3 3 3 3 3 3 ...
..$ y  : num [1:100] 29614 29549 0 33068 463941 ...
..$ w  : int [1:100] 1 2 1 1 1 1 1 2 1 1 ...
</p>


<h3>Details</h3>

<p> The data contains information on whether the person is unemployed (cat=1), precariously employed (cat=2) or in standard employment(cat=3), the corresponding parameters used to generate the truncated distribution - both for Log-normal and Dagum.
</p>


<h3>References</h3>

 
<p>Sohn, A., Klein, N., Kneib. T. (2014): A New Semiparametric Approach to Analysing Conditional Income Distributions, in: SOEPpapers, No. 676.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dat)
str(dat)
</code></pre>

<hr>
<h2 id='den.md'> Density for a Mixture of Income Distributions
</h2><span id='topic+den.md'></span>

<h3>Description</h3>

<p> This function computes the p-value for a mixture of two continuous income distributions and a point mass for zero-incomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>den.md(y, dist1, dist2, theta, p0, p1, p2, dist.para.table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="den.md_+3A_y">y</code></td>
<td>
<p> a vector with incomes. If a zero income is included, it must be the first element. 
</p>
</td></tr>
<tr><td><code id="den.md_+3A_dist1">dist1</code></td>
<td>
<p>character string with the name of the first continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="den.md_+3A_dist2">dist2</code></td>
<td>
<p>character string with the name of the second continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="den.md_+3A_theta">theta</code></td>
<td>
<p>vector with the parameters of dist1 and dist2. Order must be the same as in the functions for the distributions.
</p>
</td></tr>
<tr><td><code id="den.md_+3A_p0">p0</code></td>
<td>
<p>scalar with probability mass for the point mass.
</p>
</td></tr>
<tr><td><code id="den.md_+3A_p1">p1</code></td>
<td>
<p>scalar with probability mass for dist1.
</p>
</td></tr>
<tr><td><code id="den.md_+3A_p2">p2</code></td>
<td>
<p>scalar with probability mass for dist2.
</p>
</td></tr>
<tr><td><code id="den.md_+3A_dist.para.table">dist.para.table</code></td>
<td>
<p>a table of the same form as <code><a href="#topic+dist.para.t">dist.para.t</a></code> with distribution name, function name and number of parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the density for given values of y.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+ysample.md">ysample.md</a></code>, <code><a href="#topic+pval.md">pval.md</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dist.para.t)
ygrid&lt;-seq(0,20,by=0.1)#c(seq(0,1e5,by=100),seq(1.1e5,1e6,by=100000))
theta&lt;-c(5,1,10,1.5)
p0&lt;-0.2
p1&lt;-0.3
p2&lt;-0.5
n &lt;-100000
y.sim &lt;- ysample.md(n, "norm", "norm", theta, p0, p1, p2, dist.para.t)
den&lt;-den.md(ygrid,"norm", "norm", theta, 
              p0, p1, p2, dist.para.table=dist.para.t)
hist(y.sim,freq=FALSE)
#hist(y.sim,breaks=c(seq(0,1e5,by=100),seq(1.1e5,1e6,by=100000)),xlim=c(0,2e4),ylim=c(0,0.001))
lines(ygrid,den,col=2)
</code></pre>

<hr>
<h2 id='dist.para.t'> Distributions and their Parameters
</h2><span id='topic+dist.para.t'></span>

<h3>Description</h3>

<p> A data frame providing information on the number of parameters of distributions used for analysing conditional income distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dist.para.t)</code></pre>


<h3>Format</h3>

<p>A data frame with the following 3 variables.
</p>

<dl>
<dt><code>Distribution</code></dt><dd><p>name of the distribution.</p>
</dd>
<dt><code>dist</code></dt><dd><p>function of the distribution.</p>
</dd>
<dt><code>Parameters</code></dt><dd><p>the number of parameters for the distribution.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(dist.para.t)
dist.para.t
</code></pre>

<hr>
<h2 id='entropy'> Measures of the Generalised Entropy Family
</h2><span id='topic+entropy'></span>

<h3>Description</h3>

<p> This function computes the Measures of the Generalised Entropy Family for a vector of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(x, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_+3A_x">x</code></td>
<td>
<p> a vector of observations.
</p>
</td></tr>
<tr><td><code id="entropy_+3A_alpha">alpha</code></td>
<td>
<p> the parameter for the generalised entropy family of measures, denoted by alpha by Cowell (2000). Note that this parameter notation differs from the notation used in the ineq package.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the entropy measure.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p> Cowell, F.A. (2000): Measurement of Inequality, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 1-86, Elsevier, Amsterdam.
</p>


<h3>See Also</h3>

<p><code><a href="ineq.html#topic+ineq">ineq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate vector (of incomes)
x &lt;- c(541, 1463, 2445, 3438, 4437, 5401, 6392, 8304, 11904, 22261)
entropy(x)
</code></pre>

<hr>
<h2 id='entropy.GB2'>Entropy Measures for a Generalised Beta Distribution of Second Kind
</h2><span id='topic+entropy.GB2'></span>

<h3>Description</h3>

<p> This function computes four standard entropy measures from the generalised entropy class of inequality indices (I(alpha)) for Generalised Beta Distribution of Second Kind, 
namely the mean logarithmic deviation (I(0)), the Theil index (I(1)) as well as a bottom-sensitive index (I(-1)) and a top-sensitive index (I(2)). 
For other values of alpha, the function provides a numerical approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy.GB2(b, a, p, q, alpha = NULL, ylim = c(0, 1e+06), zeroapprox = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy.GB2_+3A_b">b</code></td>
<td>
<p> the parameter b of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="entropy.GB2_+3A_a">a</code></td>
<td>
<p> the parameter a of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="entropy.GB2_+3A_p">p</code></td>
<td>
<p> the parameter p of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="entropy.GB2_+3A_q">q</code></td>
<td>
<p> the parameter q of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="entropy.GB2_+3A_alpha">alpha</code></td>
<td>
<p> measure for the entropy measure as denoted by Cowell (2000). The default is alpha=1, i.e. the Theil Index. 
</p>
</td></tr>
<tr><td><code id="entropy.GB2_+3A_ylim">ylim</code></td>
<td>
<p> limits of the interval of y considered needed for the approximation of the entropy measure. The default is [0,1e+06].
</p>
</td></tr>
<tr><td><code id="entropy.GB2_+3A_zeroapprox">zeroapprox</code></td>
<td>
<p> an approximation for zero needed for the approximation of the entropy measure. The default is 0.01.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the selected entropy measure.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p> Kleiber, C. and Kotz, S. (2003): Statistical Size Distributions in Economics and Actuarial Sciences, Wiley, Hoboken.
</p>
<p>Cowell, F.A. (2000): Measurement of Inequality, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 87-166, Elsevier, Amsterdam.
</p>
<p>Jenkins, S.P. (2009): Distributionally-Sensitive Inequality Indices and the GB2 Income Distribution, in: Review of Income and Wealth, Vol. 55(2), pp.392-398.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a.test&lt;- 4
b.test&lt;- 20000
p.test&lt;- 0.7
q.test&lt;- 1
alpha.test&lt;-1
GB2sample&lt;-rGB2(1000,b.test,a.test,p.test,q.test)
entropy.GB2(b.test,a.test,p.test,q.test,alpha=alpha.test,ylim=c(0,1e+07))
entropy(GB2sample, alpha.test)
</code></pre>

<hr>
<h2 id='entropy.md'>  Generalised Entropy Measure for a Mixture of Income Distributions
</h2><span id='topic+entropy.md'></span>

<h3>Description</h3>

<p> This function uses Monte Carlo methods to estimate an entropy measure for a mixture of two continuous income distributions and a point mass for zero-incomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy.md(n, alpha = 1, dist1, dist2, theta, 
p0, p1, p2, dist.para.table, zero.approx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy.md_+3A_n">n</code></td>
<td>
<p> sample size used to estimate the entropy measure.
</p>
</td></tr>
<tr><td><code id="entropy.md_+3A_alpha">alpha</code></td>
<td>
<p> the parameter for the generalised entropy family of measures, denoted by alpha by Cowell (2000). Note that this parameter notation differs from the notation used in the ineq package.
</p>
</td></tr>
<tr><td><code id="entropy.md_+3A_dist1">dist1</code></td>
<td>
<p> character string with the name of the first continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="entropy.md_+3A_dist2">dist2</code></td>
<td>
<p> character string with the name of the second continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="entropy.md_+3A_theta">theta</code></td>
<td>
<p> vector with the parameters of dist1 and dist2. Order must be the same as in the functions for the distributions.
</p>
</td></tr>
<tr><td><code id="entropy.md_+3A_p0">p0</code></td>
<td>
<p>  scalar with probability mass for the point mass.
</p>
</td></tr>
<tr><td><code id="entropy.md_+3A_p1">p1</code></td>
<td>
<p> scalar with probability mass for dist1.
</p>
</td></tr>
<tr><td><code id="entropy.md_+3A_p2">p2</code></td>
<td>
<p> scalar with probability mass for dist2.
</p>
</td></tr>
<tr><td><code id="entropy.md_+3A_dist.para.table">dist.para.table</code></td>
<td>
<p> a table of the same form as <code><a href="#topic+dist.para.t">dist.para.t</a></code> with distribution name, function name and number of parameters.
</p>
</td></tr>
<tr><td><code id="entropy.md_+3A_zero.approx">zero.approx</code></td>
<td>
<p> a scalar which replaces zero-incomes (and negative incomes), such that entropy measures involving a logarithm return finite values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>entropy</code></td>
<td>
<p>the estimated entropy measure.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the entropy parameter used.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a vector with the simulated incomes to estimate the entropy measure.</p>
</td></tr>
<tr><td><code>y2</code></td>
<td>
<p>a vector with the zero-replaced simulated incomes to estimate the entropy measure.</p>
</td></tr>
<tr><td><code>zero.replace</code></td>
<td>
<p>a logical vector indicating whether a zero has been replaced.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector with the simulated group the observation was chosen from. 0 is the point mass, 1 dist1 and 2 dist2.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Sohn
</p>


<h3>References</h3>

<p>Cowell, F.A. (2000): Measurement of Inequality, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 87-166, Elsevier, Amsterdam.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dist.para.t">dist.para.t</a></code>, <code><a href="#topic+entropy">entropy</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
theta&lt;-c(2,1,5,2)
x&lt;- c(rgamma(500,2,1),rgamma(500,5,2))
para&lt;-1
entropy(x,para)
data(dist.para.t)
entropy.md(100,para,"gamma","gamma",theta,0,0.5,0.5,dist.para.t,zero.approx=1)$entropy
</code></pre>

<hr>
<h2 id='frac.ranks'> Fractional Ranks
</h2><span id='topic+frac.ranks'></span>

<h3>Description</h3>

<p> This function computes fractional ranks which are required for the S-Gini coefficient. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frac.ranks(x, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frac.ranks_+3A_x">x</code></td>
<td>
<p> a vector with sorted income values.
</p>
</td></tr>
<tr><td><code id="frac.ranks_+3A_w">w</code></td>
<td>
<p> a vector of weights.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the fractional ranks.
</p>


<h3>Author(s)</h3>

<p>Alexander Sohn
</p>


<h3>References</h3>

<p>van Kerm, P. (2009): sgini - Generalized Gini and Concentration coefficients (with factor decomposition) in Stata', CEPS/INSTEAD, Differdange, Luxembourg. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sgini">sgini</a></code>  ,  <code><a href="#topic+sgini.den">sgini.den</a></code>
</p>

<hr>
<h2 id='gini'> Gini Coefficient
</h2><span id='topic+gini'></span>

<h3>Description</h3>

<p> This function computes the Gini coefficient for a vector of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gini_+3A_x">x</code></td>
<td>
<p> a vector of observations.
</p>
</td></tr>
</table>


<h3>Value</h3>

 
<table>
<tr><td><code>Gini</code></td>
<td>
<p>the Gini coefficient for the sample.</p>
</td></tr>
<tr><td><code>bcGini</code></td>
<td>
<p>the bias-corrected Gini coefficient for the sample.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p>Cowell, F.A. (2000): Measurement of Inequality, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 87-166, Elsevier, Amsterdam.
</p>


<h3>See Also</h3>

<p><code><a href="ineq.html#topic+ineq">ineq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate vector (of incomes)
x &lt;- c(541, 1463, 2445, 3438, 4437, 5401, 6392, 8304, 11904, 22261)
gini(x)
</code></pre>

<hr>
<h2 id='gini.Dag'> Gini Coefficient for the Dagum Distribution
</h2><span id='topic+gini.Dag'></span>

<h3>Description</h3>

<p> This function computes the Gini coefficient for the Dagum Distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini.Dag(a, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gini.Dag_+3A_a">a</code></td>
<td>
<p> the parameter a of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="gini.Dag_+3A_p">p</code></td>
<td>
<p> the parameter p of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the Gini coefficient.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p>Cowell, F.A. (2000): Measurement of Inequality, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 1-86, Elsevier, Amsterdam.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gini">gini</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a.test&lt;- 4
b.test&lt;- 20000
p.test&lt;- 0.7
alpha.test&lt;-1
GB2sample&lt;-rGB2(10000,b.test,a.test,p.test,1)
gini.Dag(a.test,p.test)
gini(GB2sample)
</code></pre>

<hr>
<h2 id='gini.den'> Gini Coefficient for an Income Distribution
</h2><span id='topic+gini.den'></span>

<h3>Description</h3>

<p>  This function approximates the Gini coefficient for a distribution specified by a vector of densities and a corresponding income vector. A point mass at zero is allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini.den(incs, dens, pm0 = NA, 
lower = NULL, upper = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gini.den_+3A_incs">incs</code></td>
<td>
<p>  a vector with sorted income values.
</p>
</td></tr>
<tr><td><code id="gini.den_+3A_dens">dens</code></td>
<td>
<p> a vector with the corresponding densities.
</p>
</td></tr>
<tr><td><code id="gini.den_+3A_pm0">pm0</code></td>
<td>
<p> the point mass for zero incomes. If not specified no point mass is assumed.
</p>
</td></tr>
<tr><td><code id="gini.den_+3A_lower">lower</code></td>
<td>
<p> the lower bound of the income range considered. 
</p>
</td></tr>
<tr><td><code id="gini.den_+3A_upper">upper</code></td>
<td>
<p> the upper bound of the income range considered.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Gini</code></td>
<td>
<p>the approximation of the Gini coefficient.</p>
</td></tr>
<tr><td><code>pm0</code></td>
<td>
<p>the point mass for zero incomes used.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>the lower bound of the income range considered used.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>the upper bound of the income range considered used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Sohn
</p>


<h3>References</h3>

<p>Cowell, F.A. (2000): Measurement of Inequality, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 1-86, Elsevier, Amsterdam.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weighted.gini">weighted.gini</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu&lt;-2
sigma&lt;-1
incs&lt;-c(seq(0,500,by=0.01),seq(501,50000,by=1))
dens&lt;-dLOGNO(incs,mu,sigma)
plot(incs,dens,type="l",xlim=c(0,100))
gini.den(incs=incs,dens=dens)$Gini
gini(rLOGNO(5000000,mu,sigma))$Gini
2*pnorm(sigma/sqrt(2))-1 #theoretical Gini
</code></pre>

<hr>
<h2 id='gini.gamma'> Gini Coefficient for the Gamma Distribution
</h2><span id='topic+gini.gamma'></span>

<h3>Description</h3>

<p> This function computes the Gini coefficient for the gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini.gamma(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gini.gamma_+3A_p">p</code></td>
<td>
<p> the shape parameter p of the gamma distribution as defined by Kleiber and Kotz (2003).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the Gini coefficient.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p>Cowell, F.A. (2000): Measurement of Inequality, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 1-86, Elsevier, Amsterdam.
</p>
<p>Kleiber, C. and Kotz, S. (2003): Statistical Size Distributions in Economics and Actuarial Sciences, Wiley, Hoboken.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gini">gini</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shape.test &lt;- 5
scale.test  &lt;- 50000
y &lt;- rgamma(10000,shape=shape.test,scale=scale.test)
gini(y)
gini.gamma(shape.test)

</code></pre>

<hr>
<h2 id='gini.md'> Gini Coefficient for a Mixture of Income Distributions 
</h2><span id='topic+gini.md'></span>

<h3>Description</h3>

<p> This function uses Monte Carlo methods to estimate the Gini coefficient for a mixture of two continuous income distributions and a point mass for zero-incomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini.md(n, dist1, dist2, theta, 
p0, p1, p2, dist.para.table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gini.md_+3A_n">n</code></td>
<td>
<p> sample size used to estimate the gini coefficient.
</p>
</td></tr>
<tr><td><code id="gini.md_+3A_dist1">dist1</code></td>
<td>
<p> character string with the name of the first continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="gini.md_+3A_dist2">dist2</code></td>
<td>
<p> character string with the name of the second continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="gini.md_+3A_theta">theta</code></td>
<td>
<p> vector with the parameters of dist1 and dist2. Order must be the same as in the functions for the distributions.
</p>
</td></tr>
<tr><td><code id="gini.md_+3A_p0">p0</code></td>
<td>
<p> scalar with probability mass for the point mass.
</p>
</td></tr>
<tr><td><code id="gini.md_+3A_p1">p1</code></td>
<td>
<p> scalar with probability mass for dist1.
</p>
</td></tr>
<tr><td><code id="gini.md_+3A_p2">p2</code></td>
<td>
<p> scalar with probability mass for dist2.
</p>
</td></tr>
<tr><td><code id="gini.md_+3A_dist.para.table">dist.para.table</code></td>
<td>
<p> a table of the same form as <code><a href="#topic+dist.para.t">dist.para.t</a></code> with distribution name, function name and number of parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>gini</code></td>
<td>
<p>the estimated Gini coefficient.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a vector with the simulated incomes to estimate the Gini coefficient.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector with the simulated group the observation was chosen from. 0 is the point mass, 1 dist1 and 2 dist2.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Sohn
</p>


<h3>References</h3>

<p>Cowell, F.A. (2000): Measurement of Inequality, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 87-166, Elsevier, Amsterdam.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dist.para.t">dist.para.t</a></code>, <code><a href="#topic+gini">gini</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
theta&lt;-c(2,1,5,2)
x&lt;- c(rnorm(500,2,1),rnorm(500,5,2))
gini(x)$Gini
data(dist.para.t)
gini.md(1000,"norm","norm",theta,0,0.5,0.5,dist.para.t)$gini
</code></pre>

<hr>
<h2 id='ineq.md'> Three Inequality Measures for a Mixture of Income Distributions
</h2><span id='topic+ineq.md'></span>

<h3>Description</h3>

<p> This function uses Monte Carlo methods to estimate an the mean logarithmic deviation, the Theil Index and the Gini Coefficient for a mixture of two continuous income distributions and a point mass for zero-incomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ineq.md(n, dist1, dist2, theta, 
p0, p1, p2, dist.para.table, zero.approx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ineq.md_+3A_n">n</code></td>
<td>
<p> sample size used to estimate the gini coefficient.
</p>
</td></tr>
<tr><td><code id="ineq.md_+3A_dist1">dist1</code></td>
<td>
<p>character string with the name of the first continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="ineq.md_+3A_dist2">dist2</code></td>
<td>
<p>character string with the name of the second continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="ineq.md_+3A_theta">theta</code></td>
<td>
<p>vector with the parameters of dist1 and dist2. Order must be the same as in the functions for the distributions.
</p>
</td></tr>
<tr><td><code id="ineq.md_+3A_p0">p0</code></td>
<td>
<p>scalar with probability mass for the point mass.
</p>
</td></tr>
<tr><td><code id="ineq.md_+3A_p1">p1</code></td>
<td>
<p>scalar with probability mass for dist1.
</p>
</td></tr>
<tr><td><code id="ineq.md_+3A_p2">p2</code></td>
<td>
<p> scalar with probability mass for dist2.
</p>
</td></tr>
<tr><td><code id="ineq.md_+3A_dist.para.table">dist.para.table</code></td>
<td>
<p>a table of the same form as <code><a href="#topic+dist.para.t">dist.para.t</a></code> with distribution name, function name and number of parameters.
</p>
</td></tr>
<tr><td><code id="ineq.md_+3A_zero.approx">zero.approx</code></td>
<td>
<p> a scalar which replaces zero-incomes (and negative incomes), such that entropy measures involving a logarithm return finite values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>MLD</code></td>
<td>
<p>the estimated mean logarithmic deviation.</p>
</td></tr>
<tr><td><code>Theil</code></td>
<td>
<p>the estimated Theil index.</p>
</td></tr>
<tr><td><code>Gini</code></td>
<td>
<p>the estimated Gini coefficient.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a vector with the simulated incomes to estimate the entropy measure.</p>
</td></tr>
<tr><td><code>y2</code></td>
<td>
<p>a vector with the zero-replaced simulated incomes to estimate the entropy measure.</p>
</td></tr>
<tr><td><code>zero.replace</code></td>
<td>
<p>a logical vector indicating whether a zero has been replaced.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector with the simulated group the observation was chosen from. 0 is the point mass, 1 dist1 and 2 dist2.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Sohn
</p>


<h3>References</h3>

<p>Cowell, F.A. (2000): Measurement of Inequality, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 87-166, Elsevier, Amsterdam.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dist.para.t">dist.para.t</a></code>, <code><a href="#topic+gini">gini</a></code>, <code><a href="#topic+entropy">entropy</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
theta&lt;-c(0,1,5,2)
x&lt;- c(rgamma(500,2,1),rgamma(500,5,2))
entropy(x,0)
entropy(x,1)
gini(x)$Gini
data(dist.para.t)
im&lt;-ineq.md(100,"gamma","gamma",theta,0,0.5,0.5,dist.para.t,zero.approx=1)
im$MLD
im$Theil
im$Gini
</code></pre>

<hr>
<h2 id='km.GB2'> k-th Moment of the Generalised Beta Distribution of Second Kind
</h2><span id='topic+km.GB2'></span>

<h3>Description</h3>

<p> Calculates the k-th moment of the Generalised Beta Distribution of Second Kind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>km.GB2(b, a, p, q, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="km.GB2_+3A_b">b</code></td>
<td>
<p> the parameter b of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="km.GB2_+3A_a">a</code></td>
<td>
<p> the parameter a of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="km.GB2_+3A_p">p</code></td>
<td>
<p> the parameter p of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="km.GB2_+3A_q">q</code></td>
<td>
<p> the parameter q of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="km.GB2_+3A_k">k</code></td>
<td>
<p> order of the moment desired.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the k-th moment.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p> Kleiber, C. and Kotz, S. (2003): Statistical Size Distributions in Economics and Actuarial Sciences, Wiley, Hoboken.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a.test&lt;- 4
b.test&lt;- 20000
p.test&lt;- 0.7
q.test&lt;- 1
alpha.test&lt;-1
GB2sample&lt;-rGB2(10000,b.test,a.test,p.test,q.test)
km.GB2(b.test,a.test,p.test,q.test,k=1)
mean(GB2sample)
</code></pre>

<hr>
<h2 id='midks.plot'> Plot Comparing Parametric and Empirical Cumulative Density Functions
</h2><span id='topic+midks.plot'></span>

<h3>Description</h3>

<p> This function plots a graph entailing the empirical cdf and the parametrically specified cdf composed of a mixture distribution either by cdf.mix.dag or cdf.mix.LN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midks.plot(x.seq, y, dist, w.emp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midks.plot_+3A_x.seq">x.seq</code></td>
<td>
<p> the sequence on the x-axis for which the parametric distribution is plotted.
</p>
</td></tr>
<tr><td><code id="midks.plot_+3A_y">y</code></td>
<td>
<p> a vector of observed incomes.
</p>
</td></tr>
<tr><td><code id="midks.plot_+3A_dist">dist</code></td>
<td>
<p> a function specifying the parametric cdf.
</p>
</td></tr>
<tr><td><code id="midks.plot_+3A_w.emp">w.emp</code></td>
<td>
<p> the weights of the observations contained in y.
</p>
</td></tr>
<tr><td><code id="midks.plot_+3A_...">...</code></td>
<td>
<p> arguments to be passed to dist.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Alexander sohn
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+midks.test">midks.test</a></code>,<code><a href="#topic+cdf.mix.dag">cdf.mix.dag</a></code> ,<code><a href="#topic+cdf.mix.LN">cdf.mix.LN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parameter values
pi0.s&lt;-0.2
pi1.s&lt;-0.1
thres0.s&lt;-0
thres1.s&lt;-25000
mu.s&lt;-20000
sigma.s&lt;-5
nu.s&lt;-0.5
tau.s&lt;-1
x.seq&lt;-seq(0,200000,by=1000)

# generate sample
n&lt;-100
s&lt;-as.data.frame(matrix(NA,n,3))
names(s)&lt;-c("cat","y","w")
s[,1]&lt;-sample(1:3,n,replace=TRUE,prob=c(pi0.s,pi1.s,1-pi0.s-pi1.s))
s[,3]&lt;-rep(1,n)
for(i in 1:n){
  if(s$cat[i]==1){s$y[i]&lt;-0
  }else if(s$cat[i]==2){s$y[i]&lt;-runif(1,thres0.s,thres1.s)
  }else s$y[i]&lt;-rGB2(1,mu=mu.s,sigma=sigma.s,nu=nu.s,tau=tau.s)+thres1.s
}
# display
midks.plot(x.seq,s$y,dist=cdf.mix.dag,pi0=pi0.s,thres0=thres0.s,pi1=pi1.s,
thres1=thres1.s,mu=mu.s,sigma=sigma.s,nu=nu.s,tau=tau.s)


</code></pre>

<hr>
<h2 id='midks.test'> Kolmogorov-Smirnov Test assessing a Parametric Mixture for a Conditional Income Distribution
</h2><span id='topic+midks.test'></span>

<h3>Description</h3>

<p> This function performs a Kolmogorov-Smirnov test for a parametrically specified cdf composed of a mixture distribution either by cdf.mix.dag or cdf.mix.LN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midks.test(x, y, ..., w = NULL, pmt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midks.test_+3A_x">x</code></td>
<td>
<p> a vector of observed incomes.
</p>
</td></tr>
<tr><td><code id="midks.test_+3A_y">y</code></td>
<td>
<p> a function specifying the parametric cdf.
</p>
</td></tr>
<tr><td><code id="midks.test_+3A_...">...</code></td>
<td>
<p> arguments to be passed to y.
</p>
</td></tr>
<tr><td><code id="midks.test_+3A_w">w</code></td>
<td>
<p> the weights of the observations contained in y.
</p>
</td></tr>
<tr><td><code id="midks.test_+3A_pmt">pmt</code></td>
<td>
<p> point mass threshold equivalent to thres0 in y. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>statistic</code></td>
<td>
<p> returns the test statistic.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> returns the methodology - currently always One-sample KS-test.</p>
</td></tr>
<tr><td><code>diffpm</code></td>
<td>
<p> the difference of the probability for the point mass.</p>
</td></tr>
<tr><td><code>diff1</code></td>
<td>
<p> the upper difference between for the continuous part of the cdfs.</p>
</td></tr>
<tr><td><code>diff2</code></td>
<td>
<p> the lower difference between for the continuous part of the cdfs.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>  Alexander Sohn
</p>


<h3>References</h3>

<p>Sohn, A., Klein, N. and Kneib. T. (2014): A New Semiparametric Approach to Analysing Conditional Income Distributions, in: SOEPpapers, No. 676.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parameter values
pi0.s&lt;-0.2
pi1.s&lt;-0.1
thres0.s&lt;-0
thres1.s&lt;-25000
mu.s&lt;-20000
sigma.s&lt;-5
nu.s&lt;-0.5
tau.s&lt;-1

# generate sample
n&lt;-100
s&lt;-as.data.frame(matrix(NA,n,3))
names(s)&lt;-c("cat","y","w")
s[,1]&lt;-sample(1:3,n,replace=TRUE,prob=c(pi0.s,pi1.s,1-pi0.s-pi1.s))
s[,3]&lt;-rep(1,n)
for(i in 1:n){
  if(s$cat[i]==1){s$y[i]&lt;-0
  }else if(s$cat[i]==2){s$y[i]&lt;-runif(1,thres0.s,thres1.s)
  }else s$y[i]&lt;-rGB2(1,mu=mu.s,sigma=sigma.s,nu=nu.s,tau=tau.s)+thres1.s
}

# midks.test
midks.test(s$y,cdf.mix.dag,pi0=pi0.s,thres0=thres0.s,pi1=pi1.s,thres1=thres1.s,mu=mu.s,
sigma=sigma.s,nu=nu.s,tau=tau.s,w=s$w,pmt=thres0.s)$statistic

</code></pre>

<hr>
<h2 id='params'> Parameter estimators obtained from Structured Additive Distributional Regression
</h2><span id='topic+params'></span>

<h3>Description</h3>

<p> A list containing parameter estimates as obtained from Structured Additive Distributional Regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(params)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 16
$ mcmcsize : num 1000
$ ages     : int [1:40] 21 22 23 24 25 26 27 28 29 30 ...
$ unems    : num [1:23] 0 1 2 3 4 5 6 7 8 9 ...
$ educlvls : num [1:2] -1 1
$ bulas    : chr [1:16] &quot;SH&quot; &quot;HH&quot; &quot;NDS&quot; &quot;Bremen&quot; ...
$ aft.v    : num [1:3447] 4.85 6.5 5.92 5.76 6.05 ...
$ bft.v    : num [1:3447] 78169 65520 47184 58763 46188 ...
$ cft.v    : num [1:3447] 1.177 0.299 0.818 0.522 0.836 ...
$ mupt.v   : num [1:3447] 10.21 9.46 9.66 9.77 9.68 ...
$ sigmapt.v: num [1:3447] 1.07 1.25 1.85 1.21 1.74 ...
$ muemp.v  : num [1:3447] 3.25 2.68 2.08 3.53 2.43 ...
$ muunemp.v: num [1:3447] -2.691 -0.813 -1.919 -1.542 -1.765 ...
$ punemp.v : num [1:3447] 0.0658 0.3104 0.1314 0.18 0.1496 ...
$ pemp.v   : num [1:3447] 0.934 0.69 0.869 0.82 0.85 ...
$ pft.v    : num [1:3447] 0.898 0.644 0.77 0.796 0.78 ...
$ ppt.v    : num [1:3447] 0.0359 0.0452 0.0987 0.024 0.0706 ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(params)
str(params)
## maybe str(params) ; plot(params) ...
</code></pre>

<hr>
<h2 id='pens.parade'> Pen's Parade
</h2><span id='topic+pens.parade'></span>

<h3>Description</h3>

<p> This function plots Pen's parade.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pens.parade(x, bodies = TRUE, feet = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pens.parade_+3A_x">x</code></td>
<td>
<p> a vector of observed incomes.
</p>
</td></tr>
<tr><td><code id="pens.parade_+3A_bodies">bodies</code></td>
<td>
<p> a logical value indicating whether lines, i.e. the bodies, should be drawn.
</p>
</td></tr>
<tr><td><code id="pens.parade_+3A_feet">feet</code></td>
<td>
<p> a numeric value indicating where the lines originate.
</p>
</td></tr>
<tr><td><code id="pens.parade_+3A_...">...</code></td>
<td>
<p> additional arguments passed to the plot function.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p> Atkinson, A.B. (1975): The Economics of Inequality, Cleardon Press, Oxford.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a.test&lt;- 4
b.test&lt;- 20000
p.test&lt;- 0.7
q.test&lt;- 1
alpha.test&lt;-1
GB2sample&lt;-rGB2(100,b.test,a.test,p.test,q.test)
pens.parade( GB2sample)
</code></pre>

<hr>
<h2 id='polarisation.EGR'> Polarisation Measure from Esteban, Gradin and Ray (2007)
</h2><span id='topic+polarisation.EGR'></span>

<h3>Description</h3>

<p> This function computes the polarisation measure proposed in Esteban, Gradin and Ray (2007) 
which accounts for deviations from an n-spike representation of strata in society. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polarisation.EGR(alpha, beta, rho, y, f = NULL, dist = NULL, 
weights = NULL, pm0 = NA, lower = NULL, upper = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polarisation.EGR_+3A_alpha">alpha</code></td>
<td>
<p> a scalar containing the alpha parameter from Esteban and Ray (1994) on the sensitivity to polarisation.
</p>
</td></tr>
<tr><td><code id="polarisation.EGR_+3A_beta">beta</code></td>
<td>
<p> a scalar containing the beta parameter from Esteban, Gradin and Ray (2007) on the weight assigned to the error in the n-spike representation. 
</p>
</td></tr>
<tr><td><code id="polarisation.EGR_+3A_rho">rho</code></td>
<td>
<p> a dataframe with the group means in the first column and their respective population shares in the second. 
The groups need to be exogenously defined. 
</p>
<p>Note: the two columns should be named <code>means</code> and <code>shares</code> respectively. Otherwise a warning will appear. 
</p>
</td></tr>
<tr><td><code id="polarisation.EGR_+3A_y">y</code></td>
<td>
<p> a vector of incomes. If f is NULL and dist is NULL, this includes all incomes of all observations in the sample, 
i.e. all observations comprising the aggregate distribution. 
If either f or dist is not NULL, then this gives the incomes where the density is evaluated.
</p>
</td></tr>
<tr><td><code id="polarisation.EGR_+3A_f">f</code></td>
<td>
<p> a vector of user-defined densities of the aggregate distribution for the given incomes in y. 
</p>
</td></tr>
<tr><td><code id="polarisation.EGR_+3A_dist">dist</code></td>
<td>
<p> character string with the name of the distribution used. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="polarisation.EGR_+3A_weights">weights</code></td>
<td>
<p> an optional vector of weights to be used in the fitting process. Should be NULL or a numeric vector. If non-NULL, observations in y are weighted accordingly.
</p>
</td></tr>
<tr><td><code id="polarisation.EGR_+3A_pm0">pm0</code></td>
<td>
<p> the point mass for zero incomes used in the gini.den function. If not specified no point mass is assumed.
</p>
</td></tr>
<tr><td><code id="polarisation.EGR_+3A_lower">lower</code></td>
<td>
<p> the lower bound of the income range considered used in the gini.den function. 
</p>
</td></tr>
<tr><td><code id="polarisation.EGR_+3A_upper">upper</code></td>
<td>
<p> the upper bound of the income range considered used in the gini.den function. 
</p>
</td></tr>
<tr><td><code id="polarisation.EGR_+3A_...">...</code></td>
<td>
<p> arguments to be passed to the distribution function used, e.g. mean and sd for the normal distribution. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>P</code></td>
<td>
<p>the polarisation measure proposed by Esteban, Gradin and Ray (2007).</p>
</td></tr>
<tr><td><code>PG</code></td>
<td>
<p>the adjusted polarisation measure proposed by Gradin (2000).</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the alpha parameter used.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the beta parameter used.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the distribution option used, i.e. whether only y, f or dist was used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p>Esteban, J. and Ray, D. (1994): On the Measurment of Polarization, in: Econometrica, Vol. 62(4), pp. 819-851.
</p>
<p>Esteban, J., Gradin, C. and Ray, D. (2007): Extensions of a Measure of Polarization, with an Application to the Income Distribution of five OECD Countries.
</p>
<p>Gradin, C. (2000): Polarization by Sub-populations in Spain, 1973-91, in Review of Income and Wealth, Vol. 46(4), pp.457-474.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polarisation.ER">polarisation.ER</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example 1
y&lt;-rnorm(1000,5,0.5)
y&lt;-sort(y)
m.y&lt;-mean(y)
sd.y&lt;-sd(y)
y1&lt;-y[1:(length(y)/4)]
m.y1&lt;-mean(y1)
sd.y1&lt;-sd(y1)
y2&lt;-y[(length(y)/4+1):length(y)]
m.y2&lt;-mean(y2)
sd.y2&lt;-sd(y2)
means&lt;-c(m.y1,m.y2)
share1&lt;- length(y1)/length(y)
share2&lt;- length(y2)/length(y)
shares&lt;- c(share1,share2)
rho&lt;-data.frame(means=means,shares=shares)
alpha&lt;-1
beta&lt;-1
den&lt;-density(y)
polarisation.ER(alpha,rho,comp=FALSE)
polarisation.EGR(alpha,beta,rho,y)$P
polarisation.EGR(alpha,beta,rho,y=den$x,f=den$y)$P
polarisation.EGR(alpha,beta,rho,y=seq(0,10,by=0.1),dist="norm",
mean=m.y,sd=sd.y)$P
polarisation.EGR(alpha,beta,rho,y=seq(0,10,by=0.1),dist="norm",
mean=m.y,sd=sd.y)$PG

## example 2
y1&lt;-rnorm(100,5,1)
y2&lt;-rnorm(100,1,0.1)
y &lt;- c(y1,y2)
m.y1&lt;-mean(y1)
sd.y1&lt;-sd(y1)
m.y2&lt;-mean(y2)
sd.y2&lt;-sd(y2)
means&lt;-c(m.y1,m.y2)
share1&lt;- length(y1)/length(y)
share2&lt;- length(y2)/length(y)
shares&lt;- c(share1,share2)
rho&lt;-data.frame(means=means,shares=shares)
alpha&lt;-1
beta&lt;-1
polarisation.EGR(alpha,beta,rho,y=seq(0,10,by=0.1),dist="norm",
                 mean=c(m.y1,m.y2),sd=c(sd.y1,sd.y2))$P

</code></pre>

<hr>
<h2 id='polarisation.ER'>  Polarisation Measure from Esteban and and Ray (1994)
</h2><span id='topic+polarisation.ER'></span>

<h3>Description</h3>

<p> This function computes the polarisation measure proposed in Esteban and and Ray (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polarisation.ER(alpha, rho, comp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polarisation.ER_+3A_alpha">alpha</code></td>
<td>
<p> a scalar containing the alpha parameter from Esteban and Ray (1994) on the sensitivity to polarisation.
</p>
</td></tr>
<tr><td><code id="polarisation.ER_+3A_rho">rho</code></td>
<td>
<p> a dataframe with the group means in the first column and their respective population shares in the second. 
The groups need to be exogenously defined. 
</p>
<p>Note: the two columns should be named <code>means</code> and &rdquo;shares&rdquo; respectively. Otherwise a warning will appear. 
</p>
</td></tr>
<tr><td><code id="polarisation.ER_+3A_comp">comp</code></td>
<td>
<p> logical; if TRUE, all components pf p_i^(a+alpha)*p_j*abs(y_i-y_j)
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>P</code></td>
<td>
<p>the polarisation measure proposed by Esteban and Ray (1994).</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>the means stored in rho.</p>
</td></tr>
<tr><td><code>shares</code></td>
<td>
<p>the shares stored in rho..</p>
</td></tr>
<tr><td><code>ERcomp</code></td>
<td>
<p>if comp is TRUE, the components aggregated in P.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>   Alexander Sohn
</p>


<h3>References</h3>

<p>Esteban, J. and Ray, D. (1994): On the Measurment of Polarization, in: Econometrica, Vol. 62(4), pp. 819-851.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+polarisation.EGR">polarisation.EGR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>means&lt;-rnorm(10)+5
shares&lt;-  rep(1,length(means))
shares&lt;-shares/sum(shares)
rho&lt;-data.frame(means=means,shares=shares)
alpha&lt;-1
polarisation.ER(alpha,rho,comp=FALSE)
</code></pre>

<hr>
<h2 id='pval.md'>  P-Value for a Mixture of Income Distributions
</h2><span id='topic+pval.md'></span>

<h3>Description</h3>

<p> This function computes the p-value for a mixture of two continuous income distributions and a point mass for zero-incomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval.md(y, dist1, dist2, theta, p0, p1, p2, dist.para.table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pval.md_+3A_y">y</code></td>
<td>
<p> a vector with incomes. If a zero income is included, it must be the first element. 
</p>
</td></tr>
<tr><td><code id="pval.md_+3A_dist1">dist1</code></td>
<td>
<p>character string with the name of the first continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="pval.md_+3A_dist2">dist2</code></td>
<td>
<p>character string with the name of the second continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="pval.md_+3A_theta">theta</code></td>
<td>
<p>vector with the parameters of dist1 and dist2. Order must be the same as in the functions for the distributions.
</p>
</td></tr>
<tr><td><code id="pval.md_+3A_p0">p0</code></td>
<td>
<p>scalar with probability mass for the point mass.
</p>
</td></tr>
<tr><td><code id="pval.md_+3A_p1">p1</code></td>
<td>
<p>scalar with probability mass for dist1.
</p>
</td></tr>
<tr><td><code id="pval.md_+3A_p2">p2</code></td>
<td>
<p>scalar with probability mass for dist2.
</p>
</td></tr>
<tr><td><code id="pval.md_+3A_dist.para.table">dist.para.table</code></td>
<td>
<p>a table of the same form as <code><a href="#topic+dist.para.t">dist.para.t</a></code> with distribution name, function name and number of parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the p-value.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ysample.md">ysample.md</a></code>, <code><a href="#topic+den.md">den.md</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dist.para.t)
ygrid&lt;-seq(0,1e5,by=1000)
theta&lt;-c(5,1,10,3)
p0&lt;-0.2
p1&lt;-0.3
p2&lt;-0.5
n &lt;-10000
y.sim &lt;- ysample.md(n, "LOGNO", "LOGNO", theta, p0, p1, p2, dist.para.t)
pval&lt;-pval.md(ygrid,"LOGNO", "LOGNO", theta, 
              p0, p1, p2, dist.para.table=dist.para.t)
mean(y.sim&lt;=ygrid[10])
pval[10]
</code></pre>

<hr>
<h2 id='sadr.test'> Misspecification Test assessing a Parametric Conditional Income Distribution
</h2><span id='topic+sadr.test'></span>

<h3>Description</h3>

<p> This function performs a misspecificaton test for a parametrically specified cdf estimated by (Bayesian) Structured Additive Distributional Regression. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sadr.test(data, y.pos = NULL, dist1, dist2, params.m, mcmc = TRUE, mcmc.params.a,
 ygrid, bsrep = 10, n.startvals = 300, dist.para.table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sadr.test_+3A_data">data</code></td>
<td>
<p> a dataframe including dependent variable and all explanatory variables. 
</p>
</td></tr>
<tr><td><code id="sadr.test_+3A_y.pos">y.pos</code></td>
<td>
<p> an integer indicating the position of the dependent variable in the dataframe. 
</p>
</td></tr>
<tr><td><code id="sadr.test_+3A_dist1">dist1</code></td>
<td>
<p> character string with the name of the first continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="sadr.test_+3A_dist2">dist2</code></td>
<td>
<p>  character string with the name of the second continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="sadr.test_+3A_params.m">params.m</code></td>
<td>
<p> a matrix with the estimated parameter values (in colums) for each individual (in rows). The order of the parameters must be as follows: parameters for the first distribution, parameters for the second distribution, probability of zero income, probability of dist1, probability of dist2 and probability of dist1 given employment/non-zero income.
</p>
</td></tr>
<tr><td><code id="sadr.test_+3A_mcmc">mcmc</code></td>
<td>
<p> logical; if TRUE, uncertainty as provided by the MCMC samples is considered.
</p>
</td></tr>
<tr><td><code id="sadr.test_+3A_mcmc.params.a">mcmc.params.a</code></td>
<td>
<p> an array, with the mcmc samples for all the parameters specified by structured additive distributional regression. In the first dimension should be the MCMC realisations, in the second dimension the individuals and in the third the parameters. The order of the parameters must be as follows: parameters for the first distribution, parameters for the second distribution, probability of zero income, probability of dist1, probability of dist2 and probability of dist1 given employment/non-zero income.
</p>
</td></tr>
<tr><td><code id="sadr.test_+3A_ygrid">ygrid</code></td>
<td>
<p> vector yielding the grid on which the cdf is specified.
</p>
</td></tr>
<tr><td><code id="sadr.test_+3A_bsrep">bsrep</code></td>
<td>
<p> integer giving the number of bootstrap repitions in order to determine the distributions of the test statistics under the null.
</p>
</td></tr>
<tr><td><code id="sadr.test_+3A_n.startvals">n.startvals</code></td>
<td>
<p> integer giving the maximum number of observations used to estimate the test statistic.
</p>
</td></tr>
<tr><td><code id="sadr.test_+3A_dist.para.table">dist.para.table</code></td>
<td>
<p> a table of the same form as <code><a href="#topic+dist.para.t">dist.para.t</a></code> with distribution name, function name and number of parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>teststat.ks</code></td>
<td>
<p> Kolmogorov-Smirnov test statistic.</p>
</td></tr>
<tr><td><code>pval.ks</code></td>
<td>
<p> p-value based on the Kolmogorov-Smirnov test statistic.</p>
</td></tr>
<tr><td><code>teststat.cvm</code></td>
<td>
<p> Cramer-von-Mises test statistic.</p>
</td></tr>
<tr><td><code>pval.cvm</code></td>
<td>
<p> p-value based on the Cramer-von-Mises test statistic.</p>
</td></tr>
<tr><td><code>test</code></td>
<td>
<p> type cdf considered for the test.</p>
</td></tr>
<tr><td><code>param.distributions</code></td>
<td>
<p> parametric distributions assumed for dist1 and dist2.</p>
</td></tr>
<tr><td><code>teststat.ks.bs</code></td>
<td>
<p> bootstrap results of Kolmogorov-Smirnov test statistic under null.</p>
</td></tr>
<tr><td><code>teststat.cvm.bs</code></td>
<td>
<p> bootstrap results of Cramer-von-Mises test statistic under null.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p>Rothe, C. and Wied, D. (2013): Misspecification Testing in a Class of Conditional Distributional Models, in: Journal of the American Statistical Association, Vol. 108(501), pp.314-324.
</p>
<p>Sohn, A. (forthcoming): Scars from the Past and Future Earning Distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ### functions not run - take considerable time!
# 
# library(acid)
# data(dist.para.t)
# data(params)
# ### example one - two normals, no mcmc
# dist1&lt;-"norm"
# dist2&lt;-"norm"
# ## generating data
# set.seed(1234)
# n&lt;-1000
# sigma&lt;-0.1
# X.theta&lt;-c(1,10,1,10)
# X.gen&lt;-function(n,paras){
#   X&lt;-matrix(c(round(runif(n,paras[1],paras[2])),round(runif(n,paras[3],
#             paras[4]))),ncol=2)
#   return(X)
# }
# X &lt;- X.gen(n,X.theta)
# beta.mu1   &lt;- 1
# beta.sigma1&lt;- 0.1
# beta.mu2   &lt;- 2
# beta.sigma2&lt;- 0.1
# pi0        &lt;- 0.3
# pi01       &lt;- 0.8
# pi1        &lt;- (1-pi0)*pi01
# pi2        &lt;- 1-pi0-pi1
# 
# params.m&lt;-matrix(NA,n,8)
# params.m[,1]&lt;-(0+beta.mu1)*X[,1]
# params.m[,2]&lt;-(0+beta.sigma1)*X[,1]
# params.m[,3]&lt;-(0+beta.mu2)*X[,2]
# params.m[,4]&lt;-(0+beta.sigma2)*X[,2]
# params.m[,5]&lt;-pi0
# params.m[,6]&lt;-pi1
# params.m[,7]&lt;-pi2
# params.m[,8]&lt;-pi01
# 
# params.mF&lt;-matrix(NA,n,8)
# params.mF[,1]&lt;-(10+beta.mu1)*X[,1]
# params.mF[,2]&lt;-(0+beta.sigma1)*X[,1]
# params.mF[,3]&lt;-(0+beta.mu2)*X[,2]
# params.mF[,4]&lt;-(2+beta.sigma2)*X[,2]
# params.mF[,5]&lt;-pi0
# params.mF[,6]&lt;-pi1
# params.mF[,7]&lt;-pi2
# params.mF[,8]&lt;-pi01
# # starting repititions
# reps&lt;-30
# tsreps1T&lt;-rep(NA,reps)
# tsreps2T&lt;-rep(NA,reps)
# tsreps1F&lt;-rep(NA,reps)
# tsreps2F&lt;-rep(NA,reps)
# sys.t&lt;-Sys.time()
# for(r in 1:reps){
#   Y &lt;- rep(NA,n)
#   for(i in 1:n){
#     Y[i] &lt;- ysample.md(1,dist1,dist2,theta=params.m[i,1:4],params.m[i,5],
#     params.m[i,6],params.m[i,7],dist.para.t)
#   }
#   dat&lt;-cbind(Y,X)
#   y.pos&lt;-1
#   ygrid&lt;-seq(min(Y),round(max(Y)*1.2,-1),by=1)  
#   tsT&lt;-sadr.test(data=dat,y.pos=NULL,dist1="norm",dist2="norm",
#   params.m=params.m,mcmc=FALSE,mcmc.params=NA,ygrid=ygrid, bsrep=100,
#   n.startvals=30000,dist.para.table=dist.para.t)
#   tsreps1T[r]&lt;-tsT$pval.ks
#   tsreps2T[r]&lt;-tsT$pval.cvm
#   tsF&lt;-sadr.test(data=dat,y.pos=NULL,dist1="norm",dist2="norm",
#   params.m=params.mF,mcmc=FALSE,mcmc.params=NA,ygrid=ygrid, bsrep=100,
#   n.startvals=30000,dist.para.table=dist.para.t)
#   tsreps1F[r]&lt;-tsF$pval.ks
#   tsreps2F[r]&lt;-tsF$pval.cvm
# }
# time.taken&lt;-Sys.time()-sys.t
# time.taken
# cbind(tsreps1T,tsreps2T,tsreps1F,tsreps2F)
# 
# data(dist.para.t)
# data(params)
# 
# ### example two - Dagum and log-normal - no mcmc
# ##putting list elements from params into matrix form for params.m
# params.m&lt;-matrix(NA,length(params$aft.v),6+4)
# params.m[,1]&lt;-params[[which(names(params)=="bft.v")]]
# params.m[,2]&lt;-params[[which(names(params)=="aft.v")]]
# params.m[,3]&lt;-params[[which(names(params)=="cft.v")]]
# params.m[,4]&lt;-1
# params.m[,5]&lt;-params[[which(names(params)=="mupt.v")]]
# params.m[,6]&lt;-params[[which(names(params)=="sigmapt.v")]]
# params.m[,7]&lt;-params[[which(names(params)=="punemp.v")]]
# params.m[,8]&lt;-params[[which(names(params)=="pft.v")]]
# params.m[,9]&lt;-params[[which(names(params)=="ppt.v")]]
# params.m[,10]&lt;-params[[which(names(params)=="pemp.v")]]
# 
# set.seed(123)
# reps&lt;-30
# tsreps1T&lt;-rep(NA,reps)
# tsreps2T&lt;-rep(NA,reps)
# tsreps1F&lt;-rep(NA,reps)
# tsreps2F&lt;-rep(NA,reps)
# sys.t&lt;-Sys.time()
# for(r in 1:reps){ 
#   ## creates variables under consideration and dimnames
#   n  &lt;- dim(params.m)[1]
#   mcmcsize&lt;-params$mcmcsize
#   ages &lt;- params$ages
#   unems &lt;- params$unems
#   educlvls &lt;- params$educlvls
#   OW &lt;- params$OW
#   ## simulate two samples
#   ages.s &lt;- sample(ages,n,replace=TRUE)
#   unems.s&lt;- sample(unems,n,replace=TRUE)
#   edu.s  &lt;- sample(c(-1,1),n,replac=TRUE)
#   OW.s   &lt;- sample(c(-1,1),n,replac=TRUE)
#   y.sim&lt;-rep(NA,n)
#   p.sel&lt;-sample(1:dim(params.m)[1],n)
#   for(i in 1:n){
#     p&lt;-p.sel[i]
#     #p&lt;-sample(1:n,1) #select a random individual
#     y.sim[i]&lt;-ysample.md(1,"GB2","LOGNO",
#                          theta=c(params$bft.v[p],params$aft.v[p],
#                                  params$cft.v[p],1,
#                                  params$mupt.v[p],params$sigmapt.v[p]),
#                          params$punemp.v[p],params$pft.v[p],params$ppt.v[p],
#                          dist.para.t)
#   }
#   dat&lt;-cbind(y.sim,ages.s,unems.s,edu.s,OW.s)
#   y.simF&lt;- rnorm(n,mean(y.sim),sd(y.sim))
#   y.simF[y.simF&lt;0]&lt;-0
#   datF&lt;-dat
#   datF[,1]&lt;-y.simF
#   ygrid &lt;- seq(0,1e6,by=1000) #quantile(y,taus)
#   ##executing test
#   tsT&lt;-sadr.test(data=dat,y.pos=NULL,dist1="GB2",dist2="LOGNO",params.m=
#                  params.m[p.sel,],mcmc=FALSE,mcmc.params=NA,ygrid=ygrid, 
#                  bsrep=100,n.startvals=30000,dist.para.table=dist.para.t)
#   tsreps1T[r]&lt;-tsT$pval.ks
#   tsreps2T[r]&lt;-tsT$pval.cvm
#   tsF&lt;-sadr.test(data=datF,y.pos=NULL,dist1="GB2",dist2="LOGNO",
#                  params.m=params.m[p.sel,],mcmc=FALSE,mcmc.params=NA,
#                  ygrid=ygrid, 
#                  bsrep=100,n.startvals=30000,dist.para.table=dist.para.t)
#   tsreps1F[r]&lt;-tsF$pval.ks
#   tsreps2F[r]&lt;-tsF$pval.cvm
# }
# time.taken&lt;-Sys.time()-sys.t
# time.taken
# cbind(tsreps1T,tsreps2T,tsreps1F,tsreps2F)
# 
# 
# 
# 
# 
# ### example three - two normals, with mcmc
# set.seed(1234)
# n&lt;-1000 #no of observations
# m&lt;-100 #no of mcmc samples
# sigma&lt;-0.1
# X.theta&lt;-c(1,10,1,10)
# #without weights
# X.gen&lt;-function(n,paras){
#   X&lt;-matrix(c(round(runif(n,paras[1],paras[2])),round(runif(n,paras[3],
#             paras[4]))),ncol=2)
#   return(X)
# }
# X &lt;- X.gen(n,X.theta)
# 
# beta.mu1   &lt;- 1
# beta.sigma1&lt;- 0.1
# beta.mu2   &lt;- 2
# beta.sigma2&lt;- 0.1
# pi0        &lt;- 0.3
# pi01       &lt;- 0.8
# pi1        &lt;- (1-pi0)*pi01
# pi2        &lt;- 1-pi0-pi1
# 
# mcmc.params.a&lt;-array(NA,dim=c(m,n,8))
# mcmc.params.a[,,1]&lt;-(0+beta.mu1+rnorm(m,0,beta.mu1/10))%*%t(X[,1]) 
      #assume sd of mcmc as 10% of parameter value
# mcmc.params.a[,,2]&lt;-(0+beta.sigma1+rnorm(m,0,beta.sigma1/10))%*%t(X[,1]) 
      #must not be negative!, may be for other seed!
# mcmc.params.a[,,3]&lt;-(0+beta.mu2+rnorm(m,0,beta.mu2/10))%*%t(X[,2])
# mcmc.params.a[,,4]&lt;-(0+beta.sigma2+rnorm(m,0,beta.sigma2/10))%*%t(X[,2]) 
      #must not be negative!, may be for other seed!
# mcmc.params.a[,,5]&lt;-(pi0+rnorm(m,0,pi0/10))%*%t(rep(1,n))
# mcmc.params.a[,,8]&lt;-(pi01+rnorm(m,0,pi01/10))%*%t(rep(1,n))
# mcmc.params.a[,,6]&lt;-(1-mcmc.params.a[,,5])*mcmc.params.a[,,8]
# mcmc.params.a[,,7]&lt;-1-mcmc.params.a[,,5]-mcmc.params.a[,,6]
# 
# params.m&lt;-apply(mcmc.params.a,MARGIN=c(2,3),FUN=quantile,probs=0.5)
# 
# mcmc.params.aF&lt;-array(NA,dim=c(m,n,8))
# mcmc.params.aF[,,1]&lt;-(10+beta.mu1+rnorm(m,0,beta.mu1/10))%*%t(X[,1]) 
      #assume sd of mcmc as 10% of parameter value
# mcmc.params.aF[,,2]&lt;-(0+beta.sigma1+rnorm(m,0,beta.sigma1/10))%*%t(X[,1]) 
      #must not be negative!, may be for other seed!
# mcmc.params.aF[,,3]&lt;-(0+beta.mu2+rnorm(m,0,beta.mu2/10))%*%t(X[,2])
# mcmc.params.aF[,,4]&lt;-(2+beta.sigma2+rnorm(m,0,beta.sigma2/10))%*%t(X[,2]) 
      #must not be negative!, may be for other seed!
# mcmc.params.aF[,,5]&lt;-(pi0+rnorm(m,0,pi0/10))%*%t(rep(1,n))
# mcmc.params.aF[,,8]&lt;-(pi01+rnorm(m,0,pi01/10))%*%t(rep(1,n))
# mcmc.params.aF[,,6]&lt;-(1-mcmc.params.aF[,,5])*mcmc.params.aF[,,8]
# mcmc.params.aF[,,7]&lt;-1-mcmc.params.aF[,,5]-mcmc.params.aF[,,6]
# 
# params.mF&lt;-apply(mcmc.params.aF,MARGIN=c(2,3),FUN=quantile,probs=0.5)
# 
# reps&lt;-30
# tsreps1T&lt;-rep(NA,reps)
# tsreps2T&lt;-rep(NA,reps)
# tsreps1F&lt;-rep(NA,reps)
# tsreps2F&lt;-rep(NA,reps)
# sys.t&lt;-Sys.time()
# for(r in 1:reps){
#   Y &lt;- rep(NA,n)
#   for(i in 1:n){
#     Y[i] &lt;- ysample.md(1,dist1,dist2,theta=params.m[i,1:4],params.m[i,5],
#                        params.m[i,6],params.m[i,7],dist.para.t)
#   }  
#   dat&lt;-cbind(Y,X)
#   y.pos&lt;-1
#   ygrid&lt;-seq(min(Y),round(max(Y)*1.2,-1),by=1)  
#   tsT&lt;-sadr.test(data=dat,y.pos=NULL,dist1="norm",dist2="norm",params.m=
#                  params.m,mcmc=TRUE,mcmc.params=mcmc.params.a,ygrid=ygrid, 
#                  bsrep=100,n.startvals=30000,dist.para.table=dist.para.t)
#   tsreps1T[r]&lt;-tsT$pval.ks
#   tsreps2T[r]&lt;-tsT$pval.cvm
#   tsF&lt;-sadr.test(data=dat,y.pos=NULL,dist1="norm",dist2="norm",
#                  params.m=params.mF,mcmc=TRUE,mcmc.params=mcmc.params.aF,
#                  ygrid=ygrid, bsrep=100,n.startvals=30000,
#                  dist.para.table=dist.para.t)
#   tsreps1F[r]&lt;-tsF$pval.ks
#   tsreps2F[r]&lt;-tsF$pval.cvm
#   #c(ts$teststat.ks,ts$teststat.cvm)
#   #c(ts$pval.ks,ts$pval.cvm)
#   
# }
# time.taken&lt;-Sys.time()-sys.t
# time.taken
# cbind(tsreps1T,tsreps2T,tsreps1F,tsreps2F)
# 
# 
# 
# ### example four - two normals, with mcmc and slight deviation from truth 
#     in true params
# library(acid)
# data(dist.para.t)
# data(params)
# dist1&lt;-"norm"
# dist2&lt;-"norm"
# 
# set.seed(1234)
# n&lt;-1000 #no of observations
# m&lt;-100 #no of mcmc samples
# sigma&lt;-0.1
# X.theta&lt;-c(1,10,1,10)
# #without weights
# X.gen&lt;-function(n,paras){
#   X&lt;-matrix(c(round(runif(n,paras[1],paras[2])),round(runif(n,paras[3],
#             paras[4]))),ncol=2)
#   return(X)
# }
# X &lt;- X.gen(n,X.theta)
# 
# beta.mu1   &lt;- 1
# beta.sigma1&lt;- 0.1
# beta.mu2   &lt;- 2
# beta.sigma2&lt;- 0.1
# pi0        &lt;- 0.3
# pi01       &lt;- 0.8
# pi1        &lt;- (1-pi0)*pi01
# pi2        &lt;- 1-pi0-pi1
# 
# mcmc.params.a&lt;-array(NA,dim=c(m,n,8))
# mcmc.params.a[,,1]&lt;-(beta.mu1/10+beta.mu1+rnorm(m,0,beta.mu1/10))%*%t(X[,1]) 
       #assume sd of mcmc as 10% of parameter value
# mcmc.params.a[,,2]&lt;-(0+beta.sigma1+rnorm(m,0,beta.sigma1/10))%*%t(X[,1]) 
       #must not be negative!, may be for other seed!
# mcmc.params.a[,,3]&lt;-(0+beta.mu2+rnorm(m,0,beta.mu2/10))%*%t(X[,2])
# mcmc.params.a[,,4]&lt;-(beta.sigma2/10+beta.sigma2+rnorm(m,0,
#                      beta.sigma2/10))%*%t(X[,2]) 
       #must not be negative!, may be for other seed!
# mcmc.params.a[,,5]&lt;-(pi0+rnorm(m,0,pi0/10))%*%t(rep(1,n))
# mcmc.params.a[,,8]&lt;-(pi01+rnorm(m,0,pi01/10))%*%t(rep(1,n))
# mcmc.params.a[,,6]&lt;-(1-mcmc.params.a[,,5])*mcmc.params.a[,,8]
# mcmc.params.a[,,7]&lt;-1-mcmc.params.a[,,5]-mcmc.params.a[,,6]
# 
# params.m&lt;-apply(mcmc.params.a,MARGIN=c(2,3),FUN=quantile,probs=0.5)
# 
# mcmc.params.aF&lt;-array(NA,dim=c(m,n,8))
# mcmc.params.aF[,,1]&lt;-(10+beta.mu1+rnorm(m,0,beta.mu1/10))%*%t(X[,1]) 
       #assume sd of mcmc as 10% of parameter value
# mcmc.params.aF[,,2]&lt;-(0+beta.sigma1+rnorm(m,0,beta.sigma1/10))%*%t(X[,1]) 
       #must not be negative!, may be for other seed!
# mcmc.params.aF[,,3]&lt;-(0+beta.mu2+rnorm(m,0,beta.mu2/10))%*%t(X[,2])
# mcmc.params.aF[,,4]&lt;-(2+beta.sigma2+rnorm(m,0,beta.sigma2/10))%*%t(X[,2]) 
       #must not be negative!, may be for other seed!
# mcmc.params.aF[,,5]&lt;-(pi0+rnorm(m,0,pi0/10))%*%t(rep(1,n))
# mcmc.params.aF[,,8]&lt;-(pi01+rnorm(m,0,pi01/10))%*%t(rep(1,n))
# mcmc.params.aF[,,6]&lt;-(1-mcmc.params.aF[,,5])*mcmc.params.aF[,,8]
# mcmc.params.aF[,,7]&lt;-1-mcmc.params.aF[,,5]-mcmc.params.aF[,,6]
# 
# params.mF&lt;-apply(mcmc.params.aF,MARGIN=c(2,3),FUN=quantile,probs=0.5)
# 
# reps&lt;-30
# tsreps1T&lt;-rep(NA,reps)
# tsreps2T&lt;-rep(NA,reps)
# tsreps1F&lt;-rep(NA,reps)
# tsreps2F&lt;-rep(NA,reps)
# sys.t&lt;-Sys.time()
# for(r in 1:reps){
#   Y &lt;- rep(NA,n)
#   for(i in 1:n){
#     Y[i] &lt;- ysample.md(1,dist1,dist2,theta=params.m[i,1:4],params.m[i,5],
#                        params.m[i,6],params.m[i,7],dist.para.t)
#   }
#   
#   dat&lt;-cbind(Y,X)
#   y.pos&lt;-1
#   ygrid&lt;-seq(min(Y),round(max(Y)*1.2,-1),by=1)  
#   tsT&lt;-sadr.test(data=dat,y.pos=NULL,dist1="norm",dist2="norm",
#                  params.m=params.m,mcmc=TRUE,mcmc.params=mcmc.params.a,
#                  ygrid=ygrid, bsrep=100,n.startvals=30000,
#                  dist.para.table=dist.para.t)
#   tsreps1T[r]&lt;-tsT$pval.ks
#   tsreps2T[r]&lt;-tsT$pval.cvm
#   tsF&lt;-sadr.test(data=dat,y.pos=NULL,dist1="norm",dist2="norm",
#                  params.m=params.mF,mcmc=TRUE,mcmc.params=mcmc.params.aF,
#                  ygrid=ygrid, bsrep=100,n.startvals=30000,
#                  dist.para.table=dist.para.t)
#   tsreps1F[r]&lt;-tsF$pval.ks
#   tsreps2F[r]&lt;-tsF$pval.cvm
#   #c(ts$teststat.ks,ts$teststat.cvm)
#   #c(ts$pval.ks,ts$pval.cvm)
#   
# }
# time.taken&lt;-Sys.time()-sys.t
# time.taken
# cbind(tsreps1T,tsreps2T,tsreps1F,tsreps2F)



</code></pre>

<hr>
<h2 id='sd.GB2'> Standard Deviation of the Generalised Beta Distribution of Second Kind
</h2><span id='topic+sd.GB2'></span>

<h3>Description</h3>

<p> This function calculates the standard deviation of the Generalised Beta Distribution of Second Kind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd.GB2(b, a, p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd.GB2_+3A_b">b</code></td>
<td>
<p> the parameter b of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="sd.GB2_+3A_a">a</code></td>
<td>
<p> the parameter a of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="sd.GB2_+3A_p">p</code></td>
<td>
<p> the parameter p of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="sd.GB2_+3A_q">q</code></td>
<td>
<p> the parameter q of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the standard deviation.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p> Kleiber, C. and Kotz, S. (2003): Statistical Size Distributions in Economics and Actuarial Sciences, Wiley, Hoboken.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a.test&lt;- 4
b.test&lt;- 20000
p.test&lt;- 0.7
q.test&lt;- 1
alpha.test&lt;-1
GB2sample&lt;-rGB2(10000,b.test,a.test,p.test,q.test)
sd.GB2(b.test,a.test,p.test,q.test)
sd(GB2sample)
</code></pre>

<hr>
<h2 id='sgini'>  Single-parameter Gini Coefficient
</h2><span id='topic+sgini'></span>

<h3>Description</h3>

<p>  This function computes the Single-parameter Gini coefficient (a.k.a. generalised Gini coefficient or extended Gini coefficient) for a vector of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgini(x, nu = 2, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgini_+3A_x">x</code></td>
<td>
<p> a vector of observations.
</p>
</td></tr>
<tr><td><code id="sgini_+3A_nu">nu</code></td>
<td>
<p> a scalar entailing the parameter that tunes the degree of the policy maker's aversion to inequality. See Yaari, 1988 for details.
</p>
</td></tr>
<tr><td><code id="sgini_+3A_w">w</code></td>
<td>
<p> a vector of weights.
</p>
</td></tr>
</table>


<h3>Value</h3>

 
<table>
<tr><td><code>Gini</code></td>
<td>
<p>the Gini coefficient for the sample.</p>
</td></tr>
<tr><td><code>bcGini</code></td>
<td>
<p>the bias-corrected Gini coefficient for the sample.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p>van Kerm, P. (2009): sgini - Generalized Gini and Concentration coefficients (with factor decomposition) in Stata', CEPS/INSTEAD, Differdange, Luxembourg. 
</p>
<p>Yaari, M.E. (1988): A Controversal Proposal Concerning Inequality Measurement, Journal of Economic Theory, Vol. 44, pp. 381-397.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(100,10,1)
gini(x)$Gini
sgini(x,nu=2)$Gini
</code></pre>

<hr>
<h2 id='sgini.den'>   Single-parameter Gini Coefficient for an Income Distribution
</h2><span id='topic+sgini.den'></span>

<h3>Description</h3>

<p>  This function approximates the Single-parameter Gini coefficient for a distribution specified by a vector of densities and a corresponding income vector. A point mass at zero is allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgini.den(incs, dens, nu = 2, pm0 = NA, lower = NULL, upper = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgini.den_+3A_incs">incs</code></td>
<td>
<p>  a vector with sorted income values.
</p>
</td></tr>
<tr><td><code id="sgini.den_+3A_dens">dens</code></td>
<td>
<p>  a vector with the corresponding densities.
</p>
</td></tr>
<tr><td><code id="sgini.den_+3A_nu">nu</code></td>
<td>
<p>  a scalar entailing the parameter that tunes the degree of the policy maker's aversion to inequality. See Yaari, 1988 for details.
</p>
</td></tr>
<tr><td><code id="sgini.den_+3A_pm0">pm0</code></td>
<td>
<p>   the point mass for zero incomes. If not specified no point mass is assumed.
</p>
</td></tr>
<tr><td><code id="sgini.den_+3A_lower">lower</code></td>
<td>
<p>  the lower bound of the income range considered. 
</p>
</td></tr>
<tr><td><code id="sgini.den_+3A_upper">upper</code></td>
<td>
<p> the upper bound of the income range considered.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Gini</code></td>
<td>
<p>the approximation of the Gini coefficient.</p>
</td></tr>
<tr><td><code>pm0</code></td>
<td>
<p>the point mass for zero incomes used.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>the lower bound of the income range considered used.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>the upper bound of the income range considered used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Sohn
</p>


<h3>References</h3>

<p>van Kerm, P. (2009): sgini - Generalized Gini and Concentration coefficients (with factor decomposition) in Stata', CEPS/INSTEAD, Differdange, Luxembourg. 
</p>
<p>Yaari, M.E. (1988): A Controversal Proposal Concerning Inequality Measurement, Journal of Economic Theory, Vol. 44, pp. 381-397.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gini">gini</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## without point mass
set.seed(123)
x &lt;- rnorm(1000,10,1)
incs &lt;- seq(1,20,length.out=1000)
dens &lt;- dnorm(incs,10,1)
lower=NULL;upper=NULL;pm0&lt;-NA
gini(x)$Gini
sgini(x,nu=2)$Gini
sgini.den(incs,dens)$Gini


## with point mass
set.seed(123)
x &lt;- c(rep(0,1000),rnorm(1000,10,1))
incs &lt;- c(0,seq(1,20,length.out=1000))
dens &lt;- c(0.5,dnorm(incs[-1],10,1)/2)
gini(x)$Gini
sgini(x,nu=2)$Gini
sgini.den(incs,dens,pm = 0.5)$Gini
 </code></pre>

<hr>
<h2 id='skewness.GB2'> Skewness of the Generalised Beta Distribution of Second Kind
</h2><span id='topic+skewness.GB2'></span>

<h3>Description</h3>

<p> This function calculates the skewness of the Generalised Beta Distribution of Second Kind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewness.GB2(b, a, p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skewness.GB2_+3A_b">b</code></td>
<td>
<p> the parameter b of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="skewness.GB2_+3A_a">a</code></td>
<td>
<p> the parameter a of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="skewness.GB2_+3A_p">p</code></td>
<td>
<p> the parameter p of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
<tr><td><code id="skewness.GB2_+3A_q">q</code></td>
<td>
<p> the parameter q of the Dagum distribution as defined by Kleiber and Kotz (2003). 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the skewness.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p> Kleiber, C. and Kotz, S. (2003): Statistical Size Distributions in Economics and Actuarial Sciences, Wiley, Hoboken.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a.test&lt;- 4
b.test&lt;- 20000
p.test&lt;- 0.7
q.test&lt;- 1
alpha.test&lt;-1
GB2sample&lt;-rGB2(10000,b.test,a.test,p.test,q.test)
skewness.GB2(b.test,a.test,p.test,q.test)
#require(e1071)
#skewness(GB2sample)#note that this estimation is highly unstable even for larger sample sizes.
</code></pre>

<hr>
<h2 id='theil.gamma'>  Theil Index for the Gamma Distribution
</h2><span id='topic+theil.gamma'></span>

<h3>Description</h3>

<p>  This function computes the Theil index for the gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theil.gamma(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theil.gamma_+3A_p">p</code></td>
<td>
<p> the shape parameter p of the gamma distribution as defined by Kleiber and Kotz (2003).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the Theil index.
</p>


<h3>Author(s)</h3>

<p>  Alexander Sohn
</p>


<h3>References</h3>

<p>  Cowell, F.A. (2000): Measurement of Inequality, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 1-86, Elsevier, Amsterdam.
</p>
<p>Kleiber, C. and Kotz, S. (2003): Statistical Size Distributions in Economics and Actuarial Sciences, Wiley, Hoboken.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+entropy">entropy</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shape.test &lt;- 5
scale.test  &lt;- 50000
y &lt;- rgamma(10000,shape=shape.test,scale=scale.test)
entropy(y,1)
theil.gamma(shape.test)

</code></pre>

<hr>
<h2 id='weighted.atkinson'>  Atkinson Inequality Index
</h2><span id='topic+weighted.atkinson'></span>

<h3>Description</h3>

<p>  This function computes the Atkinson inequality index for a vector of observations with corresponding weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.atkinson(x, w = NULL, epsilon = 1, wscale = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.atkinson_+3A_x">x</code></td>
<td>
<p> a vector of observations.
</p>
</td></tr>
<tr><td><code id="weighted.atkinson_+3A_w">w</code></td>
<td>
<p>  a vector of weights. If 
</p>
</td></tr>
<tr><td><code id="weighted.atkinson_+3A_epsilon">epsilon</code></td>
<td>
<p> inequality aversion parameter as denoted by Atkinson (1970). The default is epsilon=1. 
</p>
</td></tr>
<tr><td><code id="weighted.atkinson_+3A_wscale">wscale</code></td>
<td>
<p> a scale by which the weights are adjusted such that can be rounded to natural numbers. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the selected Atkinson inequality index.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p>  Atkinson, A.B. (1970): On the Measurment of Inequality, in: Journal of Economic Theory, Vol. 2(3), pp. 244-263.
</p>


<h3>See Also</h3>

 <p><code><a href="ineq.html#topic+ineq">ineq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(541, 1463, 2445, 3438, 4437, 5401, 6392, 8304, 11904, 22261)
w &lt;- sample(1:2,length(x),replace=TRUE)
weighted.atkinson(x,w)
</code></pre>

<hr>
<h2 id='weighted.coeffvar'> Coefficient of Variation
</h2><span id='topic+weighted.coeffvar'></span>

<h3>Description</h3>

<p> This function computes the Coefficient of Variation for a vector of observations and corresponding weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.coeffvar(x, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.coeffvar_+3A_x">x</code></td>
<td>
<p> a vector of observations.
</p>
</td></tr>
<tr><td><code id="weighted.coeffvar_+3A_w">w</code></td>
<td>
<p> a vector of weights.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>cv</code></td>
<td>
<p>returns the coefficient of variation without bias correction.</p>
</td></tr>
<tr><td><code>bccv</code></td>
<td>
<p>returns the coefficient of variation with bias correction.</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Weighting is not properly accounted for in the sample adjustment of bccv!
</p>


<h3>Author(s)</h3>

<p>Alexander Sohn
</p>


<h3>References</h3>

<p>Atkinson, A.B. and Bourguignon, F. (2000): Income Distribution and Economics, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 1-86, Elsevier, Amsterdam.
</p>


<h3>See Also</h3>

<p><code><a href="ineq.html#topic+ineq">ineq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate vector (of incomes)
x &lt;- c(541, 1463, 2445, 3438, 4437, 5401, 6392, 8304, 11904, 22261)
w &lt;- sample(1:10,length(x), replace=TRUE)
weighted.coeffvar(x,w)
</code></pre>

<hr>
<h2 id='weighted.entropy'> Measures of the Generalised Entropy Family
</h2><span id='topic+weighted.entropy'></span>

<h3>Description</h3>

<p> This function computes the Measures of the Generalised Entropy Family for a vector of observations with corresponding weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.entropy(x, w = NULL, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.entropy_+3A_x">x</code></td>
<td>
<p> a vector of observations.
</p>
</td></tr>
<tr><td><code id="weighted.entropy_+3A_w">w</code></td>
<td>
<p> a vector of weights.
</p>
</td></tr>
<tr><td><code id="weighted.entropy_+3A_alpha">alpha</code></td>
<td>
<p> the parameter for the generalised entropy family of measures, denoted by alpha by Cowell (2000). Note that this parameter notation differs from the notation used in the ineq package.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>  returns the entropy measure.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>References</h3>

<p>Cowell, F.A. (2000): Measurement of Inequality, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 1-86, Elsevier, Amsterdam.
</p>


<h3>See Also</h3>

<p><code><a href="ineq.html#topic+ineq">ineq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate vector (of incomes)
x &lt;- c(541, 1463, 2445, 3438, 4437, 5401, 6392, 8304, 11904, 22261)
w &lt;- sample(1:2,length(x),replace=TRUE)
weighted.entropy(x,w)
</code></pre>

<hr>
<h2 id='weighted.gini'>  Gini Coefficient
</h2><span id='topic+weighted.gini'></span>

<h3>Description</h3>

<p> This function computes the Gini coefficient for a vector of observations with corresponding weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.gini(x, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.gini_+3A_x">x</code></td>
<td>
<p> a vector of observations.
</p>
</td></tr>
<tr><td><code id="weighted.gini_+3A_w">w</code></td>
<td>
<p> a vector of weights.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the Gini coefficient.
</p>


<h3>Author(s)</h3>

<p>Alexander Sohn
</p>


<h3>References</h3>

<p>Cowell, F.A. (2000): Measurement of Inequality, in: Atkinson and Bourguignon (eds.), Handbook of Income Distribution, pp. 1-86, Elsevier, Amsterdam.
</p>


<h3>See Also</h3>

<p><code><a href="ineq.html#topic+ineq">ineq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate vector (of incomes)
x &lt;- c(541, 1463, 2445, 3438, 4437, 5401, 6392, 8304, 11904, 22261)
w &lt;- sample(1:2,length(x),replace=TRUE)
weighted.gini(x,w)
</code></pre>

<hr>
<h2 id='weighted.moments'> Moments of a Random Variable
</h2><span id='topic+weighted.moments'></span>

<h3>Description</h3>

<p> This functions calculates the first three moments as well as mean, standard deviation and skewness for a vector of observations with corresponding weights. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.moments(x, w8 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.moments_+3A_x">x</code></td>
<td>
<p> a vector of observations.
</p>
</td></tr>
<tr><td><code id="weighted.moments_+3A_w8">w8</code></td>
<td>
<p> a vector of weights.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>fm</code></td>
<td>
<p>returns the first moment.</p>
</td></tr>
<tr><td><code>weighted.mean</code></td>
<td>
<p>returns the mean.</p>
</td></tr>
<tr><td><code>sm</code></td>
<td>
<p>returns the second moment.</p>
</td></tr>
<tr><td><code>weighted.sd</code></td>
<td>
<p>returns the uncorrected (population) standard deviation.</p>
</td></tr>
<tr><td><code>wtd.sd</code></td>
<td>
<p>returns the sample-size corrected standard deviation estimate.</p>
</td></tr>
<tr><td><code>tm</code></td>
<td>
<p>returns the third moment.</p>
</td></tr>
<tr><td><code>w.skew.SAS</code></td>
<td>
<p>returns the skewness estimate as implemented in SAS.</p>
</td></tr>
<tr><td><code>w.skew.Stata</code></td>
<td>
<p>returns the skewness estimate as implemented in Stata.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>See Also</h3>

 <p><code><a href="Hmisc.html#topic+wtd.var">wtd.var</a></code>
</p>

<hr>
<h2 id='ysample.md'> Sampling Incomes from a Mixture of Income Distributions
</h2><span id='topic+ysample.md'></span>

<h3>Description</h3>

<p> This function samples incomes from a mixture of two continuous income distributions and a point mass for zero-incomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ysample.md(n, dist1, dist2, theta, p0, p1, p2, dist.para.table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ysample.md_+3A_n">n</code></td>
<td>
<p> number of observations.
</p>
</td></tr>
<tr><td><code id="ysample.md_+3A_dist1">dist1</code></td>
<td>
<p>character string with the name of the first continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="ysample.md_+3A_dist2">dist2</code></td>
<td>
<p>character string with the name of the second continuous distribution used. Must be listed in dist.para.table. Must be equivalent to the respective function of that distribution, e.g. norm for the normal distribution.
</p>
</td></tr>
<tr><td><code id="ysample.md_+3A_theta">theta</code></td>
<td>
<p>vector with the parameters of dist1 and dist2. Order must be the same as in the functions for the distributions.
</p>
</td></tr>
<tr><td><code id="ysample.md_+3A_p0">p0</code></td>
<td>
<p>scalar with probability mass for the point mass.
</p>
</td></tr>
<tr><td><code id="ysample.md_+3A_p1">p1</code></td>
<td>
<p>scalar with probability mass for dist1.
</p>
</td></tr>
<tr><td><code id="ysample.md_+3A_p2">p2</code></td>
<td>
<p>scalar with probability mass for dist2.
</p>
</td></tr>
<tr><td><code id="ysample.md_+3A_dist.para.table">dist.para.table</code></td>
<td>
<p>a table of the same form as <code><a href="#topic+dist.para.t">dist.para.t</a></code> with distribution name, function name and number of parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns the sample of observations.
</p>


<h3>Author(s)</h3>

<p> Alexander Sohn
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+pval.md">pval.md</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dist.para.t)
ygrid&lt;-seq(0,1e5,by=1000)
theta&lt;-c(5,1,10,3)
p0&lt;-0.2
p1&lt;-0.3
p2&lt;-0.5
n &lt;-10
ysample.md(n, "LOGNO", "LOGNO", theta, p0, p1, p2, dist.para.t)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
