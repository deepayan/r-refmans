<!DOCTYPE html><html><head><title>Help for package broom.mixed</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {broom.mixed}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.extractEffects'><p>Internal function to extract the fixed or random effects from an <code>MCMCglmm</code> object</p></a></li>
<li><a href='#assert_dependency'><p>check if a package is available and return informative message otherwise</p></a></li>
<li><a href='#augment.ranef.mer'><p>Augmentation for random effects (for caterpillar plots etc.)</p></a></li>
<li><a href='#brms_tidiers'><p>Tidying methods for a brms model</p></a></li>
<li><a href='#compact'><p>Remove NULL items in a vector or list</p></a></li>
<li><a href='#fixef.MCMCglmm'><p>Extract fixed effects from an <code>MCMCglmm</code> object</p></a></li>
<li><a href='#gamlss_tidiers'><p>Tidying methods for gamlss objects</p></a></li>
<li><a href='#get_methods'><p>Retrieve all method/class combinations currently provided by the broom.mixed package</p></a></li>
<li><a href='#glmmadmb_tidiers'><p>Tidying methods for glmmADMB models</p></a></li>
<li><a href='#glmmTMB_tidiers'><p>Tidying methods for glmmTMB models</p></a></li>
<li><a href='#insert_NAs'><p>insert a row of NAs into a data frame wherever another data frame has NAs</p></a></li>
<li><a href='#lme4_tidiers'><p>Tidying methods for mixed effects models</p></a></li>
<li><a href='#mediation_tidiers'><p>Tidying methods for mediation analyses involving mixed effects models</p></a></li>
<li><a href='#nlme_tidiers'><p>Tidying methods for mixed effects models</p></a></li>
<li><a href='#paramNamesMCMCglmm'><p>Extract the parameter names from an <code>MCMCglmm</code> object</p></a></li>
<li><a href='#ranef.MCMCglmm'><p>Extract random effects from an <code>MCMCglmm</code> object</p></a></li>
<li><a href='#ranefLevels'><p>Extract the levels of factors used for random effects in <code>MCMCglmm</code> objects</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rstanarm_tidiers'><p>Tidying methods for an rstanarm model</p></a></li>
<li><a href='#stdranef'><p>Extract standard deviation of &quot;random&quot; effects from an <code>MCMCglmm</code> object</p></a></li>
<li><a href='#tidy.lqmm'><p>Tidying methods for lqmm models (EXPERIMENTAL)</p></a></li>
<li><a href='#tidy.MCMCglmm'><p>Tidying methods for MCMC (Stan, JAGS, etc.) fits</p></a></li>
<li><a href='#tidy.TMB'><p>Tidying methods for TMB models</p></a></li>
<li><a href='#tidy.varFunc'><p>Tidy variance structure for the <code>nlme</code> package.</p></a></li>
<li><a href='#unrowname'><p>strip rownames from an object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tidying Methods for Mixed Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.9.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Bolker &lt;bolker@mcmaster.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Convert fitted objects from various R mixed-model packages
    into tidy data frames along the lines of the 'broom' package.
    The package provides three
    S3 generics for each model: tidy(), which summarizes a model's statistical findings such as
    coefficients of a regression; augment(), which adds columns to the original
    data such as predictions, residuals and cluster assignments; and glance(), which
    provides a one-row summary of model-level statistics.</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, coda, dplyr, forcats, methods, nlme, purrr, stringr,
tibble, tidyr, furrr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>brms, dotwhisker, knitr, testthat, gamlss, gamlss.data,
ggplot2, GLMMadaptive, glmmADMB, glmmTMB, lmerTest, lme4,
Matrix, MCMCglmm, mediation, mgcv, pander, pbkrtest, posterior,
rstan, rstanarm, rstantools, R2jags, TMB, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bbolker/broom.mixed">https://github.com/bbolker/broom.mixed</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bbolker/broom.mixed/issues">https://github.com/bbolker/broom.mixed/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="http://bbolker.github.io/drat">http://bbolker.github.io/drat</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-31 23:17:41 UTC; bolker</td>
</tr>
<tr>
<td>Author:</td>
<td>Ben Bolker <a href="https://orcid.org/0000-0002-2127-0443"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  David Robinson [aut],
  Dieter Menne [ctb],
  Jonah Gabry [ctb],
  Paul Buerkner [ctb],
  Christopher Hua [ctb],
  William Petry <a href="https://orcid.org/0000-0002-5230-5987"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Joshua Wiley <a href="https://orcid.org/0000-0002-0271-6702"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Patrick Kennedy [ctb],
  Eduard Sz√∂cs <a href="https://orcid.org/0000-0001-5376-1194"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (BASF SE),
  Indrajeet Patil [ctb],
  Vincent Arel-Bundock
    <a href="https://orcid.org/0000-0003-2042-7063"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Bill Denney [ctb],
  Cory Brunson [ctb],
  Joe Wasserman <a href="https://orcid.org/0000-0002-9705-1853"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Alexey Stukalov [ctb],
  Matthieu Bruneaux [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-01 08:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='.extractEffects'>Internal function to extract the fixed or random effects from an <code>MCMCglmm</code> object</h2><span id='topic+.extractEffects'></span>

<h3>Description</h3>

<p>Extracts the fixed or random effects portions from an MCMCglmm object.
Note for the random, these are the estimates themselves,
not the variability in the estimates. The <code>use</code> options let you
get either just the posterior mean or all the posterior samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extractEffects(
  object,
  use = c("all", "mean"),
  which = c("fixed", "random"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".extractEffects_+3A_object">object</code></td>
<td>
<p>An <code>MCMCglmm</code> object</p>
</td></tr>
<tr><td><code id=".extractEffects_+3A_use">use</code></td>
<td>
<p>A character string indicating whether to return &ldquo;all&rdquo; the
posterior samples (the default) or only the &ldquo;mean&rdquo; of them.</p>
</td></tr>
<tr><td><code id=".extractEffects_+3A_which">which</code></td>
<td>
<p>A character string indicating whether to return the
&ldquo;fixed&rdquo; (the default) or &ldquo;random&rdquo; effects.</p>
</td></tr>
<tr><td><code id=".extractEffects_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the posterior samples or means for the fixed or random effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixef.MCMCglmm">fixef.MCMCglmm</a></code>, <code><a href="#topic+ranef.MCMCglmm">ranef.MCMCglmm</a></code>
</p>

<hr>
<h2 id='assert_dependency'>check if a package is available and return informative message otherwise</h2><span id='topic+assert_dependency'></span>

<h3>Description</h3>

<p>check if a package is available and return informative message otherwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_dependency(library_name)
</code></pre>

<hr>
<h2 id='augment.ranef.mer'>Augmentation for random effects (for caterpillar plots etc.)</h2><span id='topic+augment.ranef.mer'></span>

<h3>Description</h3>

<p>Augmentation for random effects (for caterpillar plots etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ranef.mer'
augment(x, ci.level = 0.9, reorder = TRUE, order.var = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.ranef.mer_+3A_x">x</code></td>
<td>
<p>ranef (conditional mode) information from an lme4 fit, using <code>ranef(.,condVar=TRUE)</code></p>
</td></tr>
<tr><td><code id="augment.ranef.mer_+3A_ci.level">ci.level</code></td>
<td>
<p>level for confidence intervals</p>
</td></tr>
<tr><td><code id="augment.ranef.mer_+3A_reorder">reorder</code></td>
<td>
<p>reorder levels by conditional mode values?</p>
</td></tr>
<tr><td><code id="augment.ranef.mer_+3A_order.var">order.var</code></td>
<td>
<p>numeric or character: which variable to use for ordering levels?</p>
</td></tr>
<tr><td><code id="augment.ranef.mer_+3A_...">...</code></td>
<td>
<p>additional arguments (unused: for generic consistency)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("lme4")) {
   load(system.file("extdata","lme4_example.rda",package="broom.mixed"))
   rr &lt;- ranef(lmm1,condVar=TRUE)
   aa &lt;- broom::augment(rr)
   ## Q-Q plot:
   if (require(ggplot2) &amp;&amp; require(dplyr)) {
      g0 &lt;- ggplot(aa,aes(estimate,qq,xmin=lb,xmax=ub))+
          geom_errorbarh(height=0)+
          geom_point()+facet_wrap(~variable,scale="free_x")
      ## regular caterpillar plot:
      g1 &lt;- ggplot(aa,aes(estimate,level,xmin=lb,xmax=ub))+
         geom_errorbarh(height=0)+
         geom_vline(xintercept=0,lty=2)+
         geom_point()+facet_wrap(~variable,scale="free_x")
      ## emphasize extreme values
      aa2 &lt;- group_by(aa,grp,level)
      aa3 &lt;- mutate(aa2, keep=any(estimate/std.error&gt;2))
      ## Update caterpillar plot with extreme levels highlighted
      ##  (highlight all groups with *either* extreme intercept *or*
      ##   extreme slope)
      ggplot(aa3, aes(estimate,level,xmin=lb,xmax=ub,colour=factor(keep)))+
         geom_errorbarh(height=0)+
         geom_vline(xintercept=0,lty=2)+
         geom_point()+facet_wrap(~variable,scale="free_x")+
         scale_colour_manual(values=c("black","red"), guide=FALSE)
   }
}
</code></pre>

<hr>
<h2 id='brms_tidiers'>Tidying methods for a brms model</h2><span id='topic+brms_tidiers'></span><span id='topic+tidy.brmsfit'></span><span id='topic+glance.brmsfit'></span><span id='topic+augment.brmsfit'></span>

<h3>Description</h3>

<p>These methods tidy the estimates from
<code><a href="brms.html#topic+brmsfit-class">brmsfit-objects</a></code>
(fitted model objects from the <span class="pkg">brms</span> package) into a summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmsfit'
tidy(
  x,
  parameters = NA,
  effects = c("fixed", "ran_pars"),
  robust = FALSE,
  conf.int = TRUE,
  conf.level = 0.95,
  conf.method = c("quantile", "HPDinterval"),
  rhat = FALSE,
  ess = FALSE,
  fix.intercept = TRUE,
  exponentiate = FALSE,
  ...
)

## S3 method for class 'brmsfit'
glance(x, looic = FALSE, ...)

## S3 method for class 'brmsfit'
augment(x, data = stats::model.frame(x), newdata = NULL, se.fit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brms_tidiers_+3A_x">x</code></td>
<td>
<p>Fitted model object from the <span class="pkg">brms</span> package. See
<code><a href="brms.html#topic+brmsfit-class">brmsfit-class</a></code>.</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_parameters">parameters</code></td>
<td>
<p>Names of parameters for which a summary should be
returned, as given by a character vector or regular expressions.
If <code>NA</code> (the default) summarized parameters are specified
by the <code>effects</code> argument.</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_effects">effects</code></td>
<td>
<p>A character vector including one or more of <code>"fixed"</code>,
<code>"ran_vals"</code>, or <code>"ran_pars"</code>.
See the Value section for details.</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_robust">robust</code></td>
<td>
<p>Whether to use median and median absolute deviation of
the posterior distribution, rather
than mean and standard deviation, to derive point estimates and uncertainty</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_conf.int">conf.int</code></td>
<td>
<p>If <code>TRUE</code> columns for the lower (<code>conf.low</code>)
and upper bounds (<code>conf.high</code>) of posterior uncertainty intervals are included.</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_conf.level">conf.level</code></td>
<td>
<p>Defines the range of the posterior uncertainty conf.int,
such that <code>100 * conf.level</code>% of the parameter's posterior distributio
lies within the corresponding interval.
Only used if <code>conf.int = TRUE</code>.</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_conf.method">conf.method</code></td>
<td>
<p>method for computing confidence intervals
(&quot;quantile&quot; or &quot;HPDinterval&quot;)</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_rhat">rhat</code></td>
<td>
<p>whether to calculate the *Rhat* convergence metric
(<code>FALSE</code> by default)</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_ess">ess</code></td>
<td>
<p>whether to calculate the *effective sample size* (ESS) convergence metric
(<code>FALSE</code> by default)</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_fix.intercept">fix.intercept</code></td>
<td>
<p>rename &quot;Intercept&quot; parameter to &quot;(Intercept)&quot;, to match
behaviour of other model types?</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_exponentiate">exponentiate</code></td>
<td>
<p>whether to exponentiate the fixed-effect coefficient estimates and confidence intervals (common for logistic regression); if <code>TRUE</code>, also scales the standard errors by the exponentiated coefficient, transforming them to the new scale</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_...">...</code></td>
<td>
<p>Extra arguments, not used</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_looic">looic</code></td>
<td>
<p>Should the LOO Information Criterion (and related info) be
included? See <code><a href="rstan.html#topic+loo.stanfit">loo.stanfit</a></code> for details. (This
can be slow for models fit to large datasets.)</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_newdata">newdata</code></td>
<td>
<p>new data frame</p>
</td></tr>
<tr><td><code id="brms_tidiers_+3A_se.fit">se.fit</code></td>
<td>
<p>return standard errors of fit?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All tidying methods return a <code>data.frame</code> without rownames.
The structure depends on the method chosen.
</p>
<p>When <code>parameters = NA</code>, the <code>effects</code> argument is used
to determine which parameters to summarize.
</p>
<p>Generally, <code>tidy.brmsfit</code> returns
one row for each coefficient, with at least three columns:
</p>
<table>
<tr><td><code>term</code></td>
<td>
<p>The name of the model parameter.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>A point estimate of the coefficient (mean or median).</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>A standard error for the point estimate (sd or mad).</p>
</td></tr>
</table>
<p>When <code>effects = "fixed"</code>, only population-level
effects are returned.
</p>
<p>When <code>effects = "ran_vals"</code>, only group-level effects are returned.
In this case, two additional columns are added:
</p>
<table>
<tr><td><code>group</code></td>
<td>
<p>The name of the grouping factor.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>The name of the level of the grouping factor.</p>
</td></tr>
</table>
<p>Specifying <code>effects = "ran_pars"</code> selects the
standard deviations and correlations of the group-level parameters.
</p>
<p>If <code>conf.int = TRUE</code>, columns for the <code>lower</code> and
<code>upper</code> bounds of the posterior conf.int computed.
</p>


<h3>Note</h3>

<p>The names &lsquo;fixed&rsquo;, &lsquo;ran_pars&rsquo;, and &lsquo;ran_vals&rsquo;
(corresponding to &quot;non-varying&quot;, &quot;hierarchical&quot;, and &quot;varying&quot; respectively
in previous versions of the package), while technically inappropriate in
a Bayesian setting where &quot;fixed&quot; and &quot;random&quot; effects are not well-defined,
are used for compatibility with other (frequentist) mixed model types.
</p>
<p>At present, the components of parameter estimates are separated by parsing the column names of <code>as_draws</code> (e.g. <code>r_patient[1,Intercept]</code> for the random effect on the intercept for patient 1, or <code>b_Trt1</code> for the fixed effect <code>Trt1</code>. We try to detect underscores in parameter names and warn, but detection may be imperfect.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+brms">brms</a></code>, <code><a href="brms.html#topic+brmsfit-class">brmsfit-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## original model
 ## Not run: 
    brms_crossedRE &lt;- brm(mpg ~ wt + (1|cyl) + (1+wt|gear), data = mtcars,
           iter = 500, chains = 2)
 
## End(Not run)
 
   ## too slow for CRAN (&gt;5 seconds)
   ## load stored object
   load(system.file("extdata", "brms_example.rda", package="broom.mixed"))

   fit &lt;- brms_crossedRE
   tidy(fit)
   tidy(fit, parameters = "^sd_", conf.int = FALSE)
   tidy(fit, effects = "fixed", conf.method="HPDinterval")
   tidy(fit, effects = "ran_vals")
   tidy(fit, effects = "ran_pars", robust = TRUE)
   if (require("posterior")) {
     tidy(fit, effects = "ran_pars", rhat = TRUE, ess = TRUE)
   }
   # glance method
   glance(fit)
   ## this example will give a warning that it should be run with
   ## reloo=TRUE; however, doing this will fail
   ## because the \code{fit} object has been stripped down to save space
   suppressWarnings(glance(fit, looic = TRUE, cores = 1))
   head(augment(fit))


</code></pre>

<hr>
<h2 id='compact'>Remove NULL items in a vector or list</h2><span id='topic+compact'></span>

<h3>Description</h3>

<p>Remove NULL items in a vector or list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compact(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compact_+3A_x">x</code></td>
<td>
<p>a vector or list</p>
</td></tr>
</table>

<hr>
<h2 id='fixef.MCMCglmm'>Extract fixed effects from an <code>MCMCglmm</code> object</h2><span id='topic+fixef.MCMCglmm'></span>

<h3>Description</h3>

<p>Function designed to extract the fixed effects from an
<code>MCMCglmm</code> model object. Can either extract all samples from the
fixed effects posteriors or return the posterior means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCMCglmm'
fixef(object, use = c("all", "mean"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef.MCMCglmm_+3A_object">object</code></td>
<td>
<p>An <code>MCMCglmm</code> model object to extract the effects from</p>
</td></tr>
<tr><td><code id="fixef.MCMCglmm_+3A_use">use</code></td>
<td>
<p>A character string indicating whether to extract
all posterior samples or the mean of the posteriors. Defaults to
&quot;all&quot;.</p>
</td></tr>
<tr><td><code id="fixef.MCMCglmm_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the worker function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the fixed effects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ranef.MCMCglmm">ranef.MCMCglmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # a simple MCMCglmm model
  data(PlodiaPO)
  m &lt;- MCMCglmm(PO ~ 1, random= ~ FSfamily, data=PlodiaPO, verbose=FALSE)

  # only extract average fixed effects
  fixef(m, use = "mean")

  # histogram of posterior samples of fixed effects
  hist(fixef(m))
  # matches the mean
  rowMeans(fixef(m))

## End(Not run)
</code></pre>

<hr>
<h2 id='gamlss_tidiers'>Tidying methods for gamlss objects</h2><span id='topic+gamlss_tidiers'></span><span id='topic+tidy.gamlss'></span>

<h3>Description</h3>

<p>Tidying methods for &quot;gamlss&quot; objects from the gamlss package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamlss'
tidy(x, quick = FALSE, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlss_tidiers_+3A_x">x</code></td>
<td>
<p>A &quot;gamlss&quot; object</p>
</td></tr>
<tr><td><code id="gamlss_tidiers_+3A_quick">quick</code></td>
<td>
<p>Whether to perform a fast version, and return only the coefficients</p>
</td></tr>
<tr><td><code id="gamlss_tidiers_+3A_conf.int">conf.int</code></td>
<td>
<p>whether to return confidence intervals</p>
</td></tr>
<tr><td><code id="gamlss_tidiers_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for CI</p>
</td></tr>
<tr><td><code id="gamlss_tidiers_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>confint.gamlss</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>All tidying methods return a data.frame without rownames, whose
structure depends on the method chosen.
</p>
<p>A tibble with one row for each coefficient, containing columns:
</p>
<table>
<tr><td><code>parameter</code></td>
<td>
<p>type of coefficient being estimated: <code>mu</code>, <code>sigma</code>, <code>nu</code>, or <code>tau</code></p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>term in the model being estimated and tested</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>estimated coefficient</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>standard error</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>t-statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>two-sided p-value</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("gamlss", quietly = TRUE) &amp;&amp;
    requireNamespace("gamlss.data", quietly = TRUE)) {
    data(abdom, package="gamlss.data")
    ## Not run: 
         mod &lt;- gamlss(y~pb(x), sigma.fo=~pb(x), family=BCT,
                       data=abdom, method=mixed(1,20))
    
## End(Not run)
    ## load stored object
    mod &lt;- readRDS(system.file("extdata", "gamlss_example.rds",
                   package="broom.mixed"))
    tidy(mod)
}

</code></pre>

<hr>
<h2 id='get_methods'>Retrieve all method/class combinations currently provided by the broom.mixed package</h2><span id='topic+get_methods'></span>

<h3>Description</h3>

<p>Retrieve all method/class combinations currently provided by the broom.mixed package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_methods()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>print(get_methods(), n = Inf)
</code></pre>

<hr>
<h2 id='glmmadmb_tidiers'>Tidying methods for glmmADMB models</h2><span id='topic+glmmadmb_tidiers'></span><span id='topic+glmmADMB_tidiers'></span><span id='topic+tidy.glmmadmb'></span><span id='topic+augment.glmmadmb'></span><span id='topic+glance.glmmadmb'></span>

<h3>Description</h3>

<p>These methods tidy the coefficients of <code>glmmADMB</code> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmadmb'
tidy(
  x,
  effects = c("fixed", "ran_pars"),
  component = "cond",
  scales = NULL,
  ran_prefix = NULL,
  conf.int = FALSE,
  conf.level = 0.95,
  conf.method = "Wald",
  ...
)

## S3 method for class 'glmmadmb'
augment(x, data = stats::model.frame(x), newdata, ...)

## S3 method for class 'glmmadmb'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmmadmb_tidiers_+3A_x">x</code></td>
<td>
<p>An object of class <code>glmmadmb</code>
<code>glmer</code>, or <code>nlmer</code></p>
</td></tr>
<tr><td><code id="glmmadmb_tidiers_+3A_effects">effects</code></td>
<td>
<p>A character vector including one or more of &quot;fixed&quot; (fixed-effect parameters), &quot;ran_pars&quot; (variances and covariances or standard deviations and correlations of random effect terms) or &quot;ran_vals&quot; (conditional modes/BLUPs/latent variable estimates)</p>
</td></tr>
<tr><td><code id="glmmadmb_tidiers_+3A_component">component</code></td>
<td>
<p>Which component(s) to report for (e.g., conditional, zero-inflation, dispersion: at present only works for &quot;cond&quot;)</p>
</td></tr>
<tr><td><code id="glmmadmb_tidiers_+3A_scales">scales</code></td>
<td>
<p>scales on which to report the variables: for random effects, the choices are &lsquo;&quot;sdcor&quot;&rsquo; (standard deviations and correlations: the default if <code>scales</code> is <code>NULL</code>) or &lsquo;&quot;varcov&quot;&rsquo; (variances and covariances). <code>NA</code> means no transformation, appropriate e.g. for fixed effects; inverse-link transformations (exponentiation
or logistic) are not yet implemented, but may be in the future.</p>
</td></tr>
<tr><td><code id="glmmadmb_tidiers_+3A_ran_prefix">ran_prefix</code></td>
<td>
<p>a length-2 character vector specifying the strings to use as prefixes for self- (variance/standard deviation) and cross- (covariance/correlation) random effects terms</p>
</td></tr>
<tr><td><code id="glmmadmb_tidiers_+3A_conf.int">conf.int</code></td>
<td>
<p>whether to include a confidence interval</p>
</td></tr>
<tr><td><code id="glmmadmb_tidiers_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for CI</p>
</td></tr>
<tr><td><code id="glmmadmb_tidiers_+3A_conf.method">conf.method</code></td>
<td>
<p>method for computing confidence intervals (see <code><a href="lme4.html#topic+confint.merMod">confint.merMod</a></code>)</p>
</td></tr>
<tr><td><code id="glmmadmb_tidiers_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
<tr><td><code id="glmmadmb_tidiers_+3A_data">data</code></td>
<td>
<p>original data this was fitted on; if not given this will
attempt to be reconstructed</p>
</td></tr>
<tr><td><code id="glmmadmb_tidiers_+3A_newdata">newdata</code></td>
<td>
<p>new data to be used for prediction; optional</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the modeling was performed with <code>na.action = "na.omit"</code>
(as is the typical default), rows with NA in the initial data are omitted
entirely from the augmented data frame. When the modeling was performed
with <code>na.action = "na.exclude"</code>, one should provide the original data
as a second argument, at which point the augmented data will contain those
rows (typically with NAs in place of the new columns). If the original data
is not provided to <code>augment</code> and <code>na.action = "na.exclude"</code>, a
warning is raised and the incomplete rows are dropped.
</p>


<h3>Value</h3>

<p>All tidying methods return a <code>tbl_df</code> without rownames.
The structure depends on the method chosen.
</p>
<p><code>tidy</code> returns one row for each estimated effect, either
with groups depending on the <code>effects</code> parameter.
It contains the columns
</p>
<table>
<tr><td><code>group</code></td>
<td>
<p>the group within which the random effect is being estimated: <code>NA</code> for fixed effects</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>level within group (<code>NA</code> except for modes)</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>term being estimated</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>estimated coefficient</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>standard error</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>t- or Z-statistic (<code>NA</code> for modes)</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value computed from t-statistic (may be missing/NA)</p>
</td></tr>
</table>
<p><code>augment</code> returns one row for each original observation,
with columns (each prepended by a .) added. Included are the columns
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>predicted values</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>residuals</p>
</td></tr>
<tr><td><code>.fixed</code></td>
<td>
<p>predicted values with no random effects</p>
</td></tr>
</table>
<p>Also added for &quot;merMod&quot; objects, but not for &quot;mer&quot; objects,
are values from the response object within the model (of type
<code>lmResp</code>, <code>glmResp</code>, <code>nlsResp</code>, etc). These include <code>".mu",
".offset", ".sqrtXwt", ".sqrtrwt", ".eta"</code>.
</p>
<p><code>glance</code> returns one row with the columns
</p>
<table>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated residual variance</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the data's log-likelihood under the model</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike Information Criterion</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>the Bayesian Information Criterion</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>deviance</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="stats.html#topic+na.action">na.action</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("glmmADMB") &amp;&amp; require("lme4")) {
    ## original model
    ## Not run: 
        data("sleepstudy", package="lme4")
        lmm1 &lt;- glmmadmb(Reaction ~ Days + (Days | Subject), sleepstudy,
                         family="gaussian")
    
## End(Not run)
    ## load stored object
    load(system.file("extdata","glmmADMB_example.rda",package="broom.mixed"))
    tidy(lmm1, effects = "fixed")
    tidy(lmm1, effects = "fixed", conf.int=TRUE)
    ## tidy(lmm1, effects = "fixed", conf.int=TRUE, conf.method="profile")
    ## tidy(lmm1, effects = "ran_vals", conf.int=TRUE)
    head(augment(lmm1, sleepstudy))
    glance(lmm1)

    glmm1 &lt;- glmmadmb(cbind(incidence, size - incidence) ~ period + (1 | herd),
                  data = cbpp, family = "binomial")
    tidy(glmm1)
    tidy(glmm1, effects = "fixed")
    head(augment(glmm1, cbpp))
    glance(glmm1)

}
</code></pre>

<hr>
<h2 id='glmmTMB_tidiers'>Tidying methods for glmmTMB models</h2><span id='topic+glmmTMB_tidiers'></span><span id='topic+tidy.glmmTMB'></span><span id='topic+augment.glmmTMB'></span><span id='topic+glance.glmmTMB'></span>

<h3>Description</h3>

<p>These methods tidy the coefficients of mixed effects models, particularly
responses of the <code>merMod</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
tidy(
  x,
  effects = c("ran_pars", "fixed"),
  component = c("cond", "zi"),
  scales = NULL,
  ran_prefix = NULL,
  conf.int = FALSE,
  conf.level = 0.95,
  conf.method = "Wald",
  exponentiate = FALSE,
  ...
)

## S3 method for class 'glmmTMB'
augment(x, data = stats::model.frame(x), newdata = NULL, ...)

## S3 method for class 'glmmTMB'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmmTMB_tidiers_+3A_x">x</code></td>
<td>
<p>An object of class <code>merMod</code>, such as those from <code>lmer</code>,
<code>glmer</code>, or <code>nlmer</code></p>
</td></tr>
<tr><td><code id="glmmTMB_tidiers_+3A_effects">effects</code></td>
<td>
<p>A character vector including one or more of &quot;fixed&quot; (fixed-effect parameters), &quot;ran_pars&quot; (variances and covariances or standard deviations and correlations of random effect terms) or &quot;ran_vals&quot; (conditional modes/BLUPs/latent variable estimates)</p>
</td></tr>
<tr><td><code id="glmmTMB_tidiers_+3A_component">component</code></td>
<td>
<p>which component to extract (e.g. <code>cond</code> for conditional effects (i.e., traditional fixed effects); <code>zi</code> for zero-inflation model; <code>disp</code> for dispersion model</p>
</td></tr>
<tr><td><code id="glmmTMB_tidiers_+3A_scales">scales</code></td>
<td>
<p>scales on which to report the variables: for random effects, the choices are &lsquo;&quot;sdcor&quot;&rsquo; (standard deviations and correlations: the default if <code>scales</code> is <code>NULL</code>) or &lsquo;&quot;varcov&quot;&rsquo; (variances and covariances). <code>NA</code> means no transformation, appropriate e.g. for fixed effects; inverse-link transformations (exponentiation
or logistic) are not yet implemented, but may be in the future.</p>
</td></tr>
<tr><td><code id="glmmTMB_tidiers_+3A_ran_prefix">ran_prefix</code></td>
<td>
<p>a length-2 character vector specifying the strings to use as prefixes for self- (variance/standard deviation) and cross- (covariance/correlation) random effects terms</p>
</td></tr>
<tr><td><code id="glmmTMB_tidiers_+3A_conf.int">conf.int</code></td>
<td>
<p>whether to include a confidence interval</p>
</td></tr>
<tr><td><code id="glmmTMB_tidiers_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for CI</p>
</td></tr>
<tr><td><code id="glmmTMB_tidiers_+3A_conf.method">conf.method</code></td>
<td>
<p>method for computing confidence intervals (see <code><a href="lme4.html#topic+confint.merMod">confint.merMod</a></code>)</p>
</td></tr>
<tr><td><code id="glmmTMB_tidiers_+3A_exponentiate">exponentiate</code></td>
<td>
<p>whether to exponentiate the fixed-effect coefficient estimates and confidence intervals (common for logistic regression); if <code>TRUE</code>, also scales the standard errors by the exponentiated coefficient, transforming them to the new scale</p>
</td></tr>
<tr><td><code id="glmmTMB_tidiers_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
<tr><td><code id="glmmTMB_tidiers_+3A_data">data</code></td>
<td>
<p>original data this was fitted on; if not given this will
attempt to be reconstructed</p>
</td></tr>
<tr><td><code id="glmmTMB_tidiers_+3A_newdata">newdata</code></td>
<td>
<p>new data to be used for prediction; optional</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the modeling was performed with <code>na.action = "na.omit"</code>
(as is the typical default), rows with NA in the initial data are omitted
entirely from the augmented data frame. When the modeling was performed
with <code>na.action = "na.exclude"</code>, one should provide the original data
as a second argument, at which point the augmented data will contain those
rows (typically with NAs in place of the new columns). If the original data
is not provided to <code>augment</code> and <code>na.action = "na.exclude"</code>, a
warning is raised and the incomplete rows are dropped.
</p>


<h3>Value</h3>

<p>All tidying methods return a <code>tibble</code>.
The structure depends on the method chosen.
</p>
<p><code>tidy</code> returns one row for each estimated effect, either
with groups depending on the <code>effects</code> parameter.
It contains the columns
</p>
<table>
<tr><td><code>group</code></td>
<td>
<p>the group within which the random effect is being estimated: <code>NA</code> for fixed effects</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>level within group (<code>NA</code> except for modes)</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>term being estimated</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>estimated coefficient</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>standard error</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>t- or Z-statistic (<code>NA</code> for modes)</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value computed from t-statistic (may be missing/NA)</p>
</td></tr>
</table>
<p><code>augment</code> returns one row for each original observation,
with columns (each prepended by a .) added. Included are the columns
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>predicted values</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>residuals</p>
</td></tr>
<tr><td><code>.fixed</code></td>
<td>
<p>predicted values with no random effects</p>
</td></tr>
</table>
<p><code>glance</code> returns one row with the columns
</p>
<table>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated residual variance</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the data's log-likelihood under the model</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike Information Criterion</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>the Bayesian Information Criterion</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>deviance</p>
</td></tr>
</table>


<h3>Note</h3>

<p>zero-inflation parameters (including the intercept) are reported
on the logit scale
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+na.action">na.action</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("glmmTMB") &amp;&amp; require("lme4")
    ## &amp;&amp;
    ## make sure package versions are OK
    ## checkDepPackageVersion(dep_pkg = "TMB",
    ##                       this_pkg = "glmmTMB",
    ##                        warn = FALSE) &amp;&amp;
    ## checkDepPackageVersion(dep_pkg = "Matrix",
    ##                       this_pkg = "TMB",
    ##                      warn = FALSE)
)
{
    data("sleepstudy",package="lme4")
    ## original model:
    ## Not run: 
        lmm1 &lt;- glmmTMB(Reaction ~ Days + (Days | Subject), sleepstudy)
    
## End(Not run)
    ## load stored object
    L &lt;- load(system.file("extdata","glmmTMB_example.rda",package="broom.mixed"))
    for (obj in L) {
       assign(obj, glmmTMB::up2date(get(obj)))
    }
    tidy(lmm1)
    tidy(lmm1, effects = "fixed")
    tidy(lmm1, effects = "fixed", conf.int=TRUE)
    tidy(lmm1, effects = "fixed", conf.int=TRUE, conf.method="uniroot")
    ## FIX: tidy(lmm1, effects = "ran_vals", conf.int=TRUE)
    head(augment(lmm1, sleepstudy))
    glance(lmm1)

    ## original model:
    ##  glmm1 &lt;- glmmTMB(incidence/size ~ period + (1 | herd),
    ##                  data = cbpp, family = binomial, weights=size)
    tidy(glmm1)
    tidy(glmm1, effects = "fixed")
    tidy(glmm1, effects = "fixed", exponentiate=TRUE)
    tidy(glmm1, effects = "fixed", conf.int=TRUE, exponentiate=TRUE)
    head(augment(glmm1, cbpp))
    head(augment(glmm1, cbpp, type.residuals="pearson"))
    glance(glmm1)
## Not run: 
    ## profile CIs - a little bit slower but more accurate
    tidy(glmm1, effects = "fixed", conf.int=TRUE, exponentiate=TRUE, conf.method="profile")

## End(Not run)
}
</code></pre>

<hr>
<h2 id='insert_NAs'>insert a row of NAs into a data frame wherever another data frame has NAs</h2><span id='topic+insert_NAs'></span>

<h3>Description</h3>

<p>insert a row of NAs into a data frame wherever another data frame has NAs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_NAs(x, original)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_NAs_+3A_x">x</code></td>
<td>
<p>data frame that has one row for each non-NA row in original</p>
</td></tr>
<tr><td><code id="insert_NAs_+3A_original">original</code></td>
<td>
<p>data frame with NAs</p>
</td></tr>
</table>

<hr>
<h2 id='lme4_tidiers'>Tidying methods for mixed effects models</h2><span id='topic+lme4_tidiers'></span><span id='topic+glance.allFit'></span><span id='topic+tidy.allFit'></span><span id='topic+tidy.merMod'></span><span id='topic+tidy.rlmerMod'></span><span id='topic+augment.merMod'></span><span id='topic+glance.merMod'></span>

<h3>Description</h3>

<p>These methods tidy the coefficients of <code>lme4::lmer</code> and <code>lme4::glmer</code>
models (i.e., <code>merMod</code> objects). Methods are also provided for <code>allFit</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merMod'
tidy(
  x,
  effects = c("ran_pars", "fixed"),
  scales = NULL,
  exponentiate = FALSE,
  exponentiate_ran_coefs = FALSE,
  ran_prefix = NULL,
  conf.int = FALSE,
  conf.level = 0.95,
  conf.method = "Wald",
  ddf.method = NULL,
  profile = NULL,
  debug = FALSE,
  ...
)

## S3 method for class 'rlmerMod'
tidy(
  x,
  effects = c("ran_pars", "fixed"),
  scales = NULL,
  exponentiate = FALSE,
  exponentiate_ran_coefs = FALSE,
  ran_prefix = NULL,
  conf.int = FALSE,
  conf.level = 0.95,
  conf.method = "Wald",
  ddf.method = NULL,
  profile = NULL,
  debug = FALSE,
  ...
)

## S3 method for class 'merMod'
augment(x, data = stats::model.frame(x), newdata, ...)

## S3 method for class 'merMod'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lme4_tidiers_+3A_x">x</code></td>
<td>
<p>An object of class <code>merMod</code>, such as those from <code>lmer</code>,
<code>glmer</code>, or <code>nlmer</code></p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_effects">effects</code></td>
<td>
<p>A character vector including one or more of &quot;fixed&quot; (fixed-effect parameters); &quot;ran_pars&quot; (variances and covariances or standard deviations and correlations of random effect terms); &quot;ran_vals&quot; (conditional modes/BLUPs/latent variable estimates); or &quot;ran_coefs&quot; (predicted parameter values for each group, as returned by <code><a href="lme4.html#topic+coef.merMod">coef.merMod</a></code>)</p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_scales">scales</code></td>
<td>
<p>scales on which to report the variables: for random effects, the choices are &lsquo;&quot;sdcor&quot;&rsquo; (standard deviations and correlations: the default if <code>scales</code> is <code>NULL</code>) or &lsquo;&quot;vcov&quot;&rsquo; (variances and covariances). <code>NA</code> means no transformation, appropriate e.g. for fixed effects.</p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_exponentiate">exponentiate</code></td>
<td>
<p>whether to exponentiate the fixed-effect coefficient estimates and confidence intervals (common for logistic regression); if <code>TRUE</code>, also scales the standard errors by the exponentiated coefficient, transforming them to the new scale</p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_exponentiate_ran_coefs">exponentiate_ran_coefs</code></td>
<td>
<p>whether to exponentiate the predicted paramater values for each group</p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_ran_prefix">ran_prefix</code></td>
<td>
<p>a length-2 character vector specifying the strings to use as prefixes for self- (variance/standard deviation) and cross- (covariance/correlation) random effects terms</p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_conf.int">conf.int</code></td>
<td>
<p>whether to include a confidence interval</p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for CI</p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_conf.method">conf.method</code></td>
<td>
<p>method for computing confidence intervals (see <code>lme4::confint.merMod</code>)</p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_ddf.method">ddf.method</code></td>
<td>
<p>the method for computing the degrees of freedom and t-statistics (only applicable when using the <span class="pkg">lmerTest</span> package: see <code><a href="lmerTest.html#topic+summary.lmerModLmerTest">summary.lmerModLmerTest</a></code></p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_profile">profile</code></td>
<td>
<p>pre-computed profile object, for speed when using <code>conf.method="profile"</code></p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_debug">debug</code></td>
<td>
<p>print debugging output?</p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_...">...</code></td>
<td>
<p>Additional arguments (passed to <code>confint.merMod</code> for <code>tidy</code>; <code>augment_columns</code> for <code>augment</code>; ignored for <code>glance</code>)</p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_data">data</code></td>
<td>
<p>original data this was fitted on; if not given this will
attempt to be reconstructed</p>
</td></tr>
<tr><td><code id="lme4_tidiers_+3A_newdata">newdata</code></td>
<td>
<p>new data to be used for prediction; optional</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the modeling was performed with <code>na.action = "na.omit"</code>
(as is the typical default), rows with NA in the initial data are omitted
entirely from the augmented data frame. When the modeling was performed
with <code>na.action = "na.exclude"</code>, one should provide the original data
as a second argument, at which point the augmented data will contain those
rows (typically with NAs in place of the new columns). If the original data
is not provided to <code>augment</code> and <code>na.action = "na.exclude"</code>, a
warning is raised and the incomplete rows are dropped.
</p>


<h3>Value</h3>

<p>All tidying methods return a <code>data.frame</code> without rownames.
The structure depends on the method chosen.
</p>
<p><code>tidy</code> returns one row for each estimated effect, either
with groups depending on the <code>effects</code> parameter.
It contains the columns
</p>
<table>
<tr><td><code>group</code></td>
<td>
<p>the group within which the random effect is being estimated: <code>"fixed"</code> for fixed effects</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>level within group (<code>NA</code> except for modes)</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>term being estimated</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>estimated coefficient</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>standard error</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>t- or Z-statistic (<code>NA</code> for modes)</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value computed from t-statistic (may be missing/NA)</p>
</td></tr>
</table>
<p><code>augment</code> returns one row for each original observation,
with columns (each prepended by a .) added. Included are the columns
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>predicted values</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>residuals</p>
</td></tr>
<tr><td><code>.fixed</code></td>
<td>
<p>predicted values with no random effects</p>
</td></tr>
</table>
<p>Also added for &quot;merMod&quot; objects, but not for &quot;mer&quot; objects,
are values from the response object within the model (of type
<code>lmResp</code>, <code>glmResp</code>, <code>nlsResp</code>, etc). These include <code>".mu",
".offset", ".sqrtXwt", ".sqrtrwt", ".eta"</code>.
</p>
<p><code>glance</code> returns one row with the columns
</p>
<table>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated residual variance</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the data's log-likelihood under the model</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike Information Criterion</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>the Bayesian Information Criterion</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>deviance</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="stats.html#topic+na.action">na.action</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("lme4")) {
    ## original model
    ## Not run: 
        lmm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
    
## End(Not run)
    ## load stored object
    load(system.file("extdata", "lme4_example.rda", package="broom.mixed"))
    (tt &lt;- tidy(lmm1))
    tidy(lmm1, effects = "fixed")
    tidy(lmm1, effects = "fixed", conf.int=TRUE)
    tidy(lmm1, effects = "fixed", conf.int=TRUE, conf.method="profile")
    ## lmm1_prof &lt;- profile(lmm1) # generated by extdata/runexamples
    tidy(lmm1, conf.int=TRUE, conf.method="profile", profile=lmm1_prof)
    ## conditional modes (group-level deviations from population-level estimate)
    tidy(lmm1, effects = "ran_vals", conf.int=TRUE)
    ## coefficients (group-level estimates)
    (rcoef1 &lt;- tidy(lmm1, effects = "ran_coefs"))
    if (require(tidyr) &amp;&amp; require(dplyr)) {
       ## reconstitute standard coefficient-by-level table
       spread(rcoef1,key=term,value=estimate)
       ## split ran_pars into type + term; sort fixed/sd/cor
       (tt %&gt;% separate(term,c("type","term"),sep="__",fill="left")
           %&gt;% arrange(!is.na(type),desc(type)))
    }
    head(augment(lmm1, sleepstudy))
    glance(lmm1)

    glmm1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
                  data = cbpp, family = binomial)
    tidy(glmm1)
    tidy(glmm1,exponentiate=TRUE)
    tidy(glmm1, effects = "fixed")
    ## suppress warning about influence.merMod
    head(suppressWarnings(augment(glmm1, cbpp)))
    glance(glmm1)

    startvec &lt;- c(Asym = 200, xmid = 725, scal = 350)
    nm1 &lt;- nlmer(circumference ~ SSlogis(age, Asym, xmid, scal) ~ Asym|Tree,
                  Orange, start = startvec)
    ## suppress warnings about var-cov matrix ...
    op &lt;- options(warn=-1)
    tidy(nm1)
    tidy(nm1, effects = "fixed")
    options(op)
    head(augment(nm1, Orange))
    glance(nm1)
    detach("package:lme4")
}
if (require("lmerTest")) {
   lmm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
   tidy(lmm1)
   glance(lmm1)
   detach("package:lmerTest")  # clean up
}
</code></pre>

<hr>
<h2 id='mediation_tidiers'>Tidying methods for mediation analyses involving mixed effects models</h2><span id='topic+mediation_tidiers'></span><span id='topic+tidy.mediate.mer'></span>

<h3>Description</h3>

<p>These methods tidy the coefficients of <code>mediation::mediate</code> output
(i.e., <code>mediate.mer</code> objects) when <code>lme4::lmer</code> and
<code>lme4::glmer</code> models (i.e., <code>merMod</code> objects) provide the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mediate.mer'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mediation_tidiers_+3A_x">x</code></td>
<td>
<p>an object of class <code>mediate.mer</code>, as from <code>mediate</code> using
<code>lmer</code>, <code>glmer</code>, or <code>nlmer</code> models</p>
</td></tr>
<tr><td><code id="mediation_tidiers_+3A_conf.int">conf.int</code></td>
<td>
<p>whether to include a confidence interval</p>
</td></tr>
<tr><td><code id="mediation_tidiers_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for CI</p>
</td></tr>
<tr><td><code id="mediation_tidiers_+3A_...">...</code></td>
<td>
<p>additional arguments (unused: for generic consistency)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All tidying methods return a <code>data.frame</code> without rownames. The
structure depends on the method chosen.
</p>
<p><code>tidy</code> returns one row for each estimated effect:
first the mediated effect in the control and treatment groups, respectively,
then the direct effect in each group.
It contains the columns
</p>
<table>
<tr><td><code>term</code></td>
<td>
<p>term being estimated</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>estimated coefficient</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>standard error</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value computed from t-statistic (may be missing/NA)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="mediation.html#topic+mediate">mediate</a></code>, <code><a href="broom.html#topic+tidy.mediate">tidy.mediate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("lme4") &amp;&amp; require("mediation")) {
    ## Borrowed from \code{help(mediation::mediate)}:
    ## Not run: 
        ## Varying intercept for mediator 
        mod_m &lt;- glmer(job_dich ~ treat + econ_hard + (1 | educ), 
                       family = binomial(link = "probit"), data = jobs)
        ## Varying intercept and slope for outcome
        mod_y &lt;- glmer(work1 ~ treat + job_dich + econ_hard + (1 + treat | occp),
                       family = binomial(link = "probit"), data = jobs)
        ## Output based on mediator group ("educ")
        mod_med &lt;- mediate(mod_m, mod_y, treat = "treat", 
                           mediator = "job_dich", sims=50, group.out="educ")
    
## End(Not run)
    ## Load stored objects
    load(system.file("extdata", "mediation_example.rda", package="broom.mixed"))
    ## Tidy outputs
    tidy(mod_m)
    tidy(mod_y)
    tidy(mod_med)
}
</code></pre>

<hr>
<h2 id='nlme_tidiers'>Tidying methods for mixed effects models</h2><span id='topic+nlme_tidiers'></span><span id='topic+tidy.lme'></span><span id='topic+augment.lme'></span><span id='topic+glance.lme'></span><span id='topic+tidy.gls'></span><span id='topic+augment.gls'></span>

<h3>Description</h3>

<p>These methods tidy the coefficients of mixed effects models
of the <code>lme</code> class from functions of the <code>nlme</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
tidy(
  x,
  effects = c("var_model", "ran_pars", "fixed"),
  scales = NULL,
  conf.int = FALSE,
  conf.level = 0.95,
  ...
)

## S3 method for class 'lme'
augment(x, data = x$data, newdata, ...)

## S3 method for class 'lme'
glance(x, ...)

## S3 method for class 'gls'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'gls'
augment(x, data = nlme::getData(x), newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlme_tidiers_+3A_x">x</code></td>
<td>
<p>An object of class <code>lme</code>, such as those from <code>lme</code>
or <code>nlme</code></p>
</td></tr>
<tr><td><code id="nlme_tidiers_+3A_effects">effects</code></td>
<td>
<p>One or more of &quot;var_model&quot;, &quot;ran_pars&quot;, &quot;fixed&quot;, &quot;ran_vals&quot;,
and/or &quot;ran_coefs&quot;.</p>
</td></tr>
<tr><td><code id="nlme_tidiers_+3A_scales">scales</code></td>
<td>
<p>scales on which to report the variables: for random effects, the choices are &lsquo;&quot;sdcor&quot;&rsquo; (standard deviations and correlations: the default if <code>scales</code> is <code>NULL</code>) or &lsquo;&quot;vcov&quot;&rsquo; (variances and covariances). <code>NA</code> means no transformation, appropriate e.g. for fixed effects.</p>
</td></tr>
<tr><td><code id="nlme_tidiers_+3A_conf.int">conf.int</code></td>
<td>
<p>whether to include a confidence interval</p>
</td></tr>
<tr><td><code id="nlme_tidiers_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for CI</p>
</td></tr>
<tr><td><code id="nlme_tidiers_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
<tr><td><code id="nlme_tidiers_+3A_data">data</code></td>
<td>
<p>original data this was fitted on; if not given this will
attempt to be reconstructed</p>
</td></tr>
<tr><td><code id="nlme_tidiers_+3A_newdata">newdata</code></td>
<td>
<p>new data to be used for prediction; optional</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the modeling was performed with <code>na.action = "na.omit"</code>
(as is the typical default), rows with NA in the initial data are omitted
entirely from the augmented data frame. When the modeling was performed
with <code>na.action = "na.exclude"</code>, one should provide the original data
as a second argument, at which point the augmented data will contain those
rows (typically with NAs in place of the new columns). If the original data
is not provided to <code>augment</code> and <code>na.action = "na.exclude"</code>, a
warning is raised and the incomplete rows are dropped.
</p>


<h3>Value</h3>

<p>All tidying methods return a <code>data.frame</code> without rownames.
The structure depends on the method chosen.
</p>
<p><code>tidy</code> returns one row for each estimated effect, either
random or fixed depending on the <code>effects</code> parameter. If
<code>effects = "ran_vals"</code> (or <code>"ran_pars"</code>), it contains the columns
</p>
<table>
<tr><td><code>group</code></td>
<td>
<p>the group within which the random effect is being estimated</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>level within group</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>term being estimated</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>estimated coefficient</p>
</td></tr>
<tr><td><code>estimated</code></td>
<td>
<p>This column is only included if some parameters are fixed.
TRUE if the residual error is estimated and FALSE if the residual error
is fixed.</p>
</td></tr>
</table>
<p>If <code>effects="fixed"</code>, <code>tidy</code> returns the columns
</p>
<table>
<tr><td><code>term</code></td>
<td>
<p>fixed term being estimated</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>estimate of fixed effect</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>standard error</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>t-statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value computed from t-statistic</p>
</td></tr>
</table>
<p>If <code>effects="var_model"</code> (the <code>weights</code> argument to the model),
<code>tidy</code> returns the columns defined in the help for <code>tidy.varFunc</code>.
</p>
<p><code>augment</code> returns one row for each original observation,
with columns (each prepended by a .) added. Included are the columns
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>predicted values</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>residuals</p>
</td></tr>
<tr><td><code>.fixed</code></td>
<td>
<p>predicted values with no random effects</p>
</td></tr>
</table>
<p><code>glance</code> returns one row with the columns
</p>
<table>
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated residual variance</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the data's log-likelihood under the model</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike Information Criterion</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>the Bayesian Information Criterion</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>returned as NA. To quote Brian Ripley on R-help
<a href="https://stat.ethz.ch/pipermail/r-help/2006-May/104744.html">https://stat.ethz.ch/pipermail/r-help/2006-May/104744.html</a>,
&quot;McCullagh &amp; Nelder (1989) would be the authorative [sic] reference, but the 1982
first edition manages to use 'deviance' in three separate senses on one
page.&quot; </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="stats.html#topic+na.action">na.action</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("nlme") &amp;&amp; require("lme4")) {
    data("sleepstudy", package="lme4")
    ## original model
    ## Not run: 
         lmm1 &lt;- lme(Reaction ~ Days, random=~ Days|Subject, sleepstudy)
    
## End(Not run)
    ## load stored object
    load(system.file("extdata","nlme_example.rda", package="broom.mixed"))
    tidy(lmm1)
    tidy(lmm1, effects = "fixed")
    tidy(lmm1, conf.int = TRUE)
    tidy(lmm1, conf.int = TRUE, conf.level = 0.8)
    tidy(lmm1, effects = "ran_pars")
    tidy(lmm1, effects = "ran_vals")
    tidy(lmm1, effects = "ran_coefs")
    head(augment(lmm1, sleepstudy))
    glance(lmm1)

    startvec &lt;- c(Asym = 200, xmid = 725, scal = 350)
    nm1 &lt;- nlme(circumference ~ SSlogis(age, Asym, xmid, scal),
                  data = Orange,
                  fixed = Asym + xmid + scal ~1,
                  random = Asym ~1,
                  start = startvec)
    tidy(nm1)
    tidy(nm1, effects = "fixed")
    head(augment(nm1, Orange))
    glance(nm1)

    gls1 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
                         correlation = corAR1(form = ~ 1 | Mare))
    tidy(gls1)
    glance(gls1)
    head(augment(gls1))
}

</code></pre>

<hr>
<h2 id='paramNamesMCMCglmm'>Extract the parameter names from an <code>MCMCglmm</code> object</h2><span id='topic+paramNamesMCMCglmm'></span>

<h3>Description</h3>

<p>Simple function to extract the fixed and random effects
parameter names from an <code>MCMCglmm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramNamesMCMCglmm(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramNamesMCMCglmm_+3A_object">object</code></td>
<td>
<p>An <code>MCMCglmm</code> object</p>
</td></tr>
<tr><td><code id="paramNamesMCMCglmm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table>
<tr><td><code>fixed</code></td>
<td>
<p>A character vector of the fixed effects parameter names</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p>A character vector of the random effects parameter names</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fixef.MCMCglmm">fixef.MCMCglmm</a></code>, <code><a href="#topic+ranef.MCMCglmm">ranef.MCMCglmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # a simple MCMCglmm model
  if (require(MCMCglmm)) {
     data(PlodiaPO)
     m &lt;- MCMCglmm(PO ~ 1, random = ~ FSfamily, data = PlodiaPO, verbose=FALSE, pr=TRUE)
  }
  # extract the parameter names
  paramNamesMCMCglmm(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='ranef.MCMCglmm'>Extract random effects from an <code>MCMCglmm</code> object</h2><span id='topic+ranef.MCMCglmm'></span>

<h3>Description</h3>

<p>Function designed to extract the random effects from an
<code>MCMCglmm</code> model object. Can either extract all samples from the
random effects posteriors or return the posterior means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCMCglmm'
ranef(object, use = c("all", "mean"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef.MCMCglmm_+3A_object">object</code></td>
<td>
<p>An <code>MCMCglmm</code> model object to extract the effects from</p>
</td></tr>
<tr><td><code id="ranef.MCMCglmm_+3A_use">use</code></td>
<td>
<p>A character string indicating whether to extract
all posterior samples or the mean of the posteriors. Defaults to
&quot;all&quot;.</p>
</td></tr>
<tr><td><code id="ranef.MCMCglmm_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the worker function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the fixed effects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixef.MCMCglmm">fixef.MCMCglmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # a simple MCMCglmm model
  data(PlodiaPO)
  m &lt;- MCMCglmm(PO ~ 1, random= ~ FSfamily, data=PlodiaPO, pr=TRUE, verbose=FALSE)

  # only extract average fixed effects
  head(ranef(m, use = "mean"))

  # histogram of posterior samples of fixed effects
  hist(ranef(m)[1, ])
  # matches the mean
  rowMeans(ranef(m)[1:6, ])

## End(Not run)
</code></pre>

<hr>
<h2 id='ranefLevels'>Extract the levels of factors used for random effects in <code>MCMCglmm</code> objects</h2><span id='topic+ranefLevels'></span>

<h3>Description</h3>

<p>Extract the levels of factors used for random effects in <code>MCMCglmm</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranefLevels(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranefLevels_+3A_object">object</code></td>
<td>
<p>An <code>MCMCglmm</code> model object</p>
</td></tr>
<tr><td><code id="ranefLevels_+3A_data">data</code></td>
<td>
<p>The dataset used for the model</p>
</td></tr>
<tr><td><code id="ranefLevels_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+paramNamesMCMCglmm">paramNamesMCMCglmm</a></code>, <code><a href="#topic+ranef.MCMCglmm">ranef.MCMCglmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # a simple MCMCglmm model
  data(PlodiaPO)
  m &lt;- MCMCglmm(PO ~ 1, random = ~ FSfamily, data = PlodiaPO, verbose=FALSE)

  # extract the random effects levels
  ranefLevels(m, PlodiaPO)

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+glance'></span><span id='topic+augment'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>broom</dt><dd><p><code><a href="broom.html#topic+reexports">augment</a></code>, <code><a href="broom.html#topic+reexports">glance</a></code>, <code><a href="broom.html#topic+reexports">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rstanarm_tidiers'>Tidying methods for an rstanarm model</h2><span id='topic+rstanarm_tidiers'></span><span id='topic+tidy.stanreg'></span><span id='topic+glance.stanreg'></span>

<h3>Description</h3>

<p>These methods tidy the estimates from <code>rstanarm</code> fits
(<code>stan_glm</code>, <code>stan_glmer</code>, etc.)
into a summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanreg'
tidy(
  x,
  effects = "fixed",
  conf.int = FALSE,
  conf.level = 0.9,
  conf.method = c("quantile", "HPDinterval"),
  exponentiate = FALSE,
  ...
)

## S3 method for class 'stanreg'
glance(x, looic = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstanarm_tidiers_+3A_x">x</code></td>
<td>
<p>Fitted model object from the <span class="pkg">rstanarm</span> package. See
<code><a href="rstanarm.html#topic+stanreg-objects">stanreg-objects</a></code>.</p>
</td></tr>
<tr><td><code id="rstanarm_tidiers_+3A_effects">effects</code></td>
<td>
<p>A character vector including one or more of <code>"fixed"</code>,
<code>"ran_vals"</code>, or <code>"ran_pars"</code>.
See the Value section for details.</p>
</td></tr>
<tr><td><code id="rstanarm_tidiers_+3A_conf.int">conf.int</code></td>
<td>
<p>If <code>TRUE</code> columns for the lower (<code>conf.low</code>) and upper (<code>conf.high</code>) bounds of the
<code>100*prob</code>% posterior uncertainty intervals are included. See
<code><a href="rstantools.html#topic+posterior_interval">posterior_interval</a></code> for details.</p>
</td></tr>
<tr><td><code id="rstanarm_tidiers_+3A_conf.level">conf.level</code></td>
<td>
<p>See <code><a href="rstantools.html#topic+posterior_interval">posterior_interval</a></code>.</p>
</td></tr>
<tr><td><code id="rstanarm_tidiers_+3A_conf.method">conf.method</code></td>
<td>
<p>method for computing confidence intervals
(&quot;quantile&quot; or &quot;HPDinterval&quot;)</p>
</td></tr>
<tr><td><code id="rstanarm_tidiers_+3A_exponentiate">exponentiate</code></td>
<td>
<p>whether to exponentiate the fixed-effect coefficient estimates and confidence intervals (common for logistic regression); if <code>TRUE</code>, also scales the standard errors by the exponentiated coefficient, transforming them to the new scale</p>
</td></tr>
<tr><td><code id="rstanarm_tidiers_+3A_...">...</code></td>
<td>
<p>For <code>glance</code>, if <code>looic=TRUE</code>, optional arguments to
<code><a href="rstan.html#topic+loo.stanfit">loo.stanfit</a></code>.</p>
</td></tr>
<tr><td><code id="rstanarm_tidiers_+3A_looic">looic</code></td>
<td>
<p>Should the LOO Information Criterion (and related info) be
included? See <code><a href="rstan.html#topic+loo.stanfit">loo.stanfit</a></code> for details. (This
can be slow for models fit to large datasets.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All tidying methods return a <code>data.frame</code> without rownames.
The structure depends on the method chosen.
</p>
<p>When <code>effects="fixed"</code> (the default), <code>tidy.stanreg</code> returns
one row for each coefficient, with three columns:
</p>
<table>
<tr><td><code>term</code></td>
<td>
<p>The name of the corresponding term in the model.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>A point estimate of the coefficient (posterior median).</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>A standard error for the point estimate based on
<code><a href="stats.html#topic+mad">mad</a></code>. See the <em>Uncertainty estimates</em> section in
<code><a href="rstanarm.html#topic+print.stanreg">print.stanreg</a></code> for more details.</p>
</td></tr>
</table>
<p>For models with group-specific parameters (e.g., models fit with
<code><a href="rstanarm.html#topic+stan_glmer">stan_glmer</a></code>), setting <code>effects="ran_vals"</code>
selects the group-level parameters instead of the non-varying regression
coefficients. Addtional columns are added indicating the <code>level</code> and
<code>group</code>. Specifying <code>effects="ran_pars"</code> selects the
standard deviations and (for certain models) correlations of the group-level
parameters.
</p>
<p>Setting <code>effects="auxiliary"</code> will select parameters other than those
included by the other options. The particular parameters depend on which
<span class="pkg">rstanarm</span> modeling function was used to fit the model. For example, for
models fit using <code><a href="rstanarm.html#topic+stan_glm">stan_glm</a></code> the overdispersion
parameter is included if <code>effects="aux"</code>, for
<code><a href="rstanarm.html#topic+stan_lm">stan_lm</a></code> the auxiliary parameters include the residual
SD, R^2, and log(fit_ratio), etc.
</p>
<p><code>glance</code> returns one row with the columns
</p>
<table>
<tr><td><code>algorithm</code></td>
<td>
<p>The algorithm used to fit the model.</p>
</td></tr>
<tr><td><code>pss</code></td>
<td>
<p>The posterior sample size (except for models fit using
optimization).</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>The number of observations used to fit the model.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The square root of the estimated residual variance, if
applicable. If not applicable (e.g., for binomial GLMs), <code>sigma</code> will
be given the value <code>1</code> in the returned object.</p>
</td></tr>
</table>
<p>If <code>looic=TRUE</code>, then the following additional columns are also
included:
</p>
<table>
<tr><td><code>looic</code></td>
<td>
<p>The LOO Information Criterion.</p>
</td></tr>
<tr><td><code>elpd_loo</code></td>
<td>
<p>The expected log predictive density (<code>elpd_loo = -2 *
  looic</code>).</p>
</td></tr>
<tr><td><code>p_loo</code></td>
<td>
<p>The effective number of parameters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="rstan.html#topic+summary+2Cstanfit-method">summary,stanfit-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("rstanarm")) {
## Not run: 
#'     ## original models
  fit &lt;- stan_glmer(mpg ~ wt + (1|cyl) + (1+wt|gear), data = mtcars,
                      iter = 500, chains = 2)
  fit2 &lt;- stan_glmer((mpg&gt;20) ~ wt + (1 | cyl) + (1 + wt | gear),
                    data = mtcars,
                    family = binomial,
                    iter = 500, chains = 2
  
## End(Not run)
## load example data
  load(system.file("extdata", "rstanarm_example.rda", package="broom.mixed"))

  # non-varying ("population") parameters
  tidy(fit, conf.int = TRUE, conf.level = 0.5)
  tidy(fit, conf.int = TRUE, conf.method = "HPDinterval", conf.level = 0.5)

  #  exponentiating (in this case, from log-odds to odds ratios)
  (tidy(fit2, conf.int = TRUE, conf.level = 0.5)
          |&gt; dplyr::filter(term != "(Intercept)")
  )
  (tidy(fit2, conf.int = TRUE, conf.level = 0.5, exponentiate = TRUE)
          |&gt; dplyr::filter(term != "(Intercept)")
  )

  # hierarchical sd &amp; correlation parameters
  tidy(fit, effects = "ran_pars")

  # group-specific deviations from "population" parameters
  tidy(fit, effects = "ran_vals")

  # glance method
   glance(fit)
  ## Not run: 
     glance(fit, looic = TRUE, cores = 1)
  
## End(Not run)
} ## if require("rstanarm")
</code></pre>

<hr>
<h2 id='stdranef'>Extract standard deviation of &quot;random&quot; effects from an <code>MCMCglmm</code> object</h2><span id='topic+stdranef'></span>

<h3>Description</h3>

<p>Function designed to extract the standard deviation of the
random effects from an <code>MCMCglmm</code> model object.
Note that this is not the same as the posterior distribution of
(co)variance matrices. It is based on the posterior distribution
of the random effects. This also means it requires <code>pr=TRUE</code>
to be set in the model for the information to be saved. Can optionally
return standard deviation of random effects after back transforming to
the response metric. Currently probabilities, but only for ordinal family
models (<code>family="ordinal"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdranef(object, which, type = c("lp", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdranef_+3A_object">object</code></td>
<td>
<p>An <code>MCMCglmm</code> model object to extract the effects from</p>
</td></tr>
<tr><td><code id="stdranef_+3A_which">which</code></td>
<td>
<p>A list of random effects to extract or their numeric positions
If there are two numbers in a list, effects are simulataneous.</p>
</td></tr>
<tr><td><code id="stdranef_+3A_type">type</code></td>
<td>
<p>A character string indicating whether to calculate the standard
deviation on the linear predictor metric, &lsquo;lp&rsquo; or
response, &lsquo;response&rsquo;.</p>
</td></tr>
<tr><td><code id="stdranef_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class postMCMCglmmRE with means (<code>M</code>) and individual estimates (<code>Data</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # a simple MCMCglmm model
  data(PlodiaPO)
  PlodiaPO &lt;- within(PlodiaPO, {
    PO2 &lt;- cut(PO, quantile(PO, c(0, .33, .66, 1)))
    plate &lt;- factor(plate)
  })

  m &lt;- MCMCglmm(PO2 ~ 1, random = ~ FSfamily + plate,
    family = "ordinal", data = PlodiaPO,
    prior = list(
      R = list(V = 1, fix = 1),
      G = list(
        G1 = list(V = 1, nu = .002),
        G2 = list(V = 1, nu = .002)
      )
    ), verbose=FALSE, thin=1, pr=TRUE)

  # summary of the model
  summary(m)

  # examples of extracting standard deviations of
  # different random effects on the linear predictor metric
  # or after transformation to probabilities (only for ordinal)
  stdranef(m, which = list(1), type = "lp")
  stdranef(m, which = list(2), type = "lp")
  stdranef(m, which = list(1, 2, c(1, 2)), type = "lp")
  stdranef(m, type = "lp")

  ## error because no 3rd random effect
  #stdranef(m, which = list(1, 2, 3), type = "lp")

  stdranef(m, which = list("FSfamily", "plate"), type = "lp")

  # mean standard deviations on the probability metric
  # also the full distributions, if desired in the Data slot.
  res &lt;- stdranef(m, type = "response")
  res$M # means
  hist(res$Data$FSfamily[, 1]) # histogram

## End(Not run)
</code></pre>

<hr>
<h2 id='tidy.lqmm'>Tidying methods for lqmm models (EXPERIMENTAL)</h2><span id='topic+tidy.lqmm'></span><span id='topic+glance.lqmm'></span>

<h3>Description</h3>

<p>These methods, suggested by
David Luke Thiessen on <a href="https://stackoverflow.com/questions/72514230/is-it-possible-to-use-lqmm-with-a-mira-object">Stack Exchange</a>, provide support for linear quantile mixed models. They have not been carefully tested - please
check output carefully and report problems!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lqmm'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'lqmm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.lqmm_+3A_x">x</code></td>
<td>
<p>An object of class <code>merMod</code>, such as those from <code>lmer</code>,
<code>glmer</code>, or <code>nlmer</code></p>
</td></tr>
<tr><td><code id="tidy.lqmm_+3A_conf.int">conf.int</code></td>
<td>
<p>whether to include a confidence interval</p>
</td></tr>
<tr><td><code id="tidy.lqmm_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for CI</p>
</td></tr>
<tr><td><code id="tidy.lqmm_+3A_...">...</code></td>
<td>
<p>Additional arguments (passed to <code>confint.merMod</code> for <code>tidy</code>; <code>augment_columns</code> for <code>augment</code>; ignored for <code>glance</code>)</p>
</td></tr>
</table>

<hr>
<h2 id='tidy.MCMCglmm'>Tidying methods for MCMC (Stan, JAGS, etc.) fits</h2><span id='topic+tidy.MCMCglmm'></span><span id='topic+mcmc_tidiers'></span><span id='topic+tidyMCMC'></span><span id='topic+tidy.rjags'></span><span id='topic+tidy.stanfit'></span><span id='topic+tidy.mcmc'></span><span id='topic+tidy.mcmc.list'></span>

<h3>Description</h3>

<p>Tidying methods for MCMC (Stan, JAGS, etc.) fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MCMCglmm'
tidy(x, effects = c("fixed", "ran_pars"), scales = NULL, ...)

tidyMCMC(
  x,
  pars,
  robust = FALSE,
  conf.int = FALSE,
  conf.level = 0.95,
  conf.method = c("quantile", "HPDinterval"),
  drop.pars = c("lp__", "deviance"),
  rhat = FALSE,
  ess = FALSE,
  index = FALSE,
  ...
)

## S3 method for class 'rjags'
tidy(
  x,
  robust = FALSE,
  conf.int = FALSE,
  conf.level = 0.95,
  conf.method = "quantile",
  ...
)

## S3 method for class 'stanfit'
tidy(
  x,
  pars,
  robust = FALSE,
  conf.int = FALSE,
  conf.level = 0.95,
  conf.method = c("quantile", "HPDinterval"),
  drop.pars = c("lp__", "deviance"),
  rhat = FALSE,
  ess = FALSE,
  index = FALSE,
  ...
)

## S3 method for class 'mcmc'
tidy(
  x,
  pars,
  robust = FALSE,
  conf.int = FALSE,
  conf.level = 0.95,
  conf.method = c("quantile", "HPDinterval"),
  drop.pars = c("lp__", "deviance"),
  rhat = FALSE,
  ess = FALSE,
  index = FALSE,
  ...
)

## S3 method for class 'mcmc.list'
tidy(
  x,
  pars,
  robust = FALSE,
  conf.int = FALSE,
  conf.level = 0.95,
  conf.method = c("quantile", "HPDinterval"),
  drop.pars = c("lp__", "deviance"),
  rhat = FALSE,
  ess = FALSE,
  index = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.MCMCglmm_+3A_x">x</code></td>
<td>
<p>a model fit to be converted to a data frame</p>
</td></tr>
<tr><td><code id="tidy.MCMCglmm_+3A_effects">effects</code></td>
<td>
<p>which effects (fixed, random, etc.) to return</p>
</td></tr>
<tr><td><code id="tidy.MCMCglmm_+3A_scales">scales</code></td>
<td>
<p>scales on which to report results</p>
</td></tr>
<tr><td><code id="tidy.MCMCglmm_+3A_...">...</code></td>
<td>
<p>mostly unused; for <code>tidy.MCMCglmm</code>, these represent options
passed through to <code>tidy.mcmc</code> (e.g. <code>robust</code>, <code>conf.int</code>, <code>conf.method</code>, ...)</p>
</td></tr>
<tr><td><code id="tidy.MCMCglmm_+3A_pars">pars</code></td>
<td>
<p>(character) specification of which parameters to include</p>
</td></tr>
<tr><td><code id="tidy.MCMCglmm_+3A_robust">robust</code></td>
<td>
<p>use mean and standard deviation (if FALSE) or median and mean absolute deviation (if TRUE) to compute point estimates and uncertainty?</p>
</td></tr>
<tr><td><code id="tidy.MCMCglmm_+3A_conf.int">conf.int</code></td>
<td>
<p>(logical) include confidence interval?</p>
</td></tr>
<tr><td><code id="tidy.MCMCglmm_+3A_conf.level">conf.level</code></td>
<td>
<p>probability level for CI</p>
</td></tr>
<tr><td><code id="tidy.MCMCglmm_+3A_conf.method">conf.method</code></td>
<td>
<p>method for computing confidence intervals
(&quot;quantile&quot; or &quot;HPDinterval&quot;)</p>
</td></tr>
<tr><td><code id="tidy.MCMCglmm_+3A_drop.pars">drop.pars</code></td>
<td>
<p>Parameters not to include in the output (such
as log-probability information)</p>
</td></tr>
<tr><td><code id="tidy.MCMCglmm_+3A_rhat">rhat</code>, <code id="tidy.MCMCglmm_+3A_ess">ess</code></td>
<td>
<p>(logical) include Rhat and/or effective sample size estimates?</p>
</td></tr>
<tr><td><code id="tidy.MCMCglmm_+3A_index">index</code></td>
<td>
<p>Add index column, remove index from term. For example,
<code>term a[13]</code> becomes <code>term a</code> and <code>index 13</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("MCMCglmm")) {
  ## original model
  ## Not run: 
      mm0 &lt;- MCMCglmm(Reaction ~ Days,
                 random = ~Subject, data = sleepstudy,
                 nitt=4000,
                 pr = TRUE
             )
   
## End(Not run)
   ## load stored object
   load(system.file("extdata","MCMCglmm_example.rda",
                                     package="broom.mixed"))
   tidy(mm0)
   tidy(mm1)
   tidy(mm2)
   tail(tidy(mm0,effects="ran_vals"))
}

# Using example from "RStan Getting Started"
# https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started

model_file &lt;- system.file("extdata", "8schools.stan", package = "broom.mixed")
schools_dat &lt;- list(J = 8,
                    y = c(28,  8, -3,  7, -1,  1, 18, 12),
                    sigma = c(15, 10, 16, 11,  9, 11, 10, 18))
## original model
## Not run: 
    set.seed(2015)
    rstan_example &lt;- rstan::stan(file = model_file, data = schools_dat,
                         iter = 1000, chains = 2, save_dso = FALSE)

## End(Not run)
if (require(rstan)) {
   ## load stored object
   rstan_example &lt;- readRDS(system.file("extdata", "rstan_example.rds", package = "broom.mixed"))
   tidy(rstan_example)
   tidy(rstan_example, conf.int = TRUE, pars = "theta")
   td_mean &lt;- tidy(rstan_example, conf.int = TRUE)
   td_median &lt;- tidy(rstan_example, conf.int = TRUE, robust = TRUE)
   
   if (require(dplyr) &amp;&amp; require(ggplot2)) {
       tds &lt;- (dplyr::bind_rows(list(mean=td_mean, median=td_median), .id="method")
          %&gt;% mutate(type=ifelse(grepl("^theta",term),"theta",
            ifelse(grepl("^eta",term),"eta",
                  "other")))
      )

     ggplot(tds, aes(estimate, term)) +
      geom_errorbarh(aes(xmin = conf.low, xmax = conf.high),height=0) +
      geom_point(aes(color = method))+
      facet_wrap(~type,scale="free",ncol=1)
 } ## require(dplyr,ggplot2)
} ## require(rstan)
if (require(R2jags)) {
   ## see help("jags",package="R2jags")
   ## and  example("jags",package="R2jags")
   ## for details
   ## load stored object
   R2jags_example &lt;- readRDS(system.file("extdata", "R2jags_example.rds", package = "broom.mixed"))
   tidy(R2jags_example)
   tidy(R2jags_example, conf.int=TRUE, conf.method="quantile")
}

</code></pre>

<hr>
<h2 id='tidy.TMB'>Tidying methods for TMB models</h2><span id='topic+tidy.TMB'></span>

<h3>Description</h3>

<p>Tidying methods for TMB models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TMB'
tidy(
  x,
  effects = c("fixed", "random"),
  conf.int = FALSE,
  conf.level = 0.95,
  conf.method = c("wald", "uniroot", "profile"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.TMB_+3A_x">x</code></td>
<td>
<p>An object of class <code>TMB</code> (you may need to use
<code>class(obj) &lt;- "TMB"</code> on your results from TMB)</p>
</td></tr>
<tr><td><code id="tidy.TMB_+3A_effects">effects</code></td>
<td>
<p>which effects should be returned?</p>
</td></tr>
<tr><td><code id="tidy.TMB_+3A_conf.int">conf.int</code></td>
<td>
<p>whether to include a confidence interval</p>
</td></tr>
<tr><td><code id="tidy.TMB_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for CI</p>
</td></tr>
<tr><td><code id="tidy.TMB_+3A_conf.method">conf.method</code></td>
<td>
<p>method for computing confidence intervals</p>
</td></tr>
<tr><td><code id="tidy.TMB_+3A_...">...</code></td>
<td>
<p>additional arguments passed to confint function (tmbroot, tmbprofile)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("TMB")) {

    ## Not run: 
       runExample("simple",thisR=TRUE)
       class(obj) &lt;- "TMB"
       tidy(obj,conf.int=TRUE,conf.method="wald")
    
## End(Not run)
    ## Not run: tidy(obj,conf.int=TRUE,conf.method="uniroot")
    ## Not run: tidy(obj,conf.int=TRUE,conf.method="profile")
}
</code></pre>

<hr>
<h2 id='tidy.varFunc'>Tidy variance structure for the <code>nlme</code> package.</h2><span id='topic+tidy.varFunc'></span><span id='topic+tidy.varComb'></span>

<h3>Description</h3>

<p>Returns a tibble with the following columns:
</p>

<dl>
<dt>group</dt><dd><p>type of varFunc, along with the right hand side of the formula
in parentheses e.g. <code>"varExp(age | Sex)"</code>.</p>
</dd>
<dt>term</dt><dd><p>terms included in the formula of the variance model, specifically
the names of the coefficients.  If the value is fixed, it will be appended
with <code>" ; fixed"</code>.</p>
</dd>
<dt>estimate</dt><dd><p>estimated coefficient</p>
</dd>
<dt>estimated</dt><dd><p>This column is only included if some parameters are fixed.
TRUE if the parameter is estimated and FALSE if the parameter is fixed.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varFunc'
tidy(x, ...)

## S3 method for class 'varComb'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.varFunc_+3A_x">x</code></td>
<td>
<p>An object of class <code>varFunc</code>, such as those used as the
<code>weights</code> argument from the <code>nlme</code> package</p>
</td></tr>
<tr><td><code id="tidy.varFunc_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the <code>varFunc</code> is uninitialized or has no parameters, the
function will return an empty tibble.  Otherwise, it will return a tibble with
names described in the details section.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require("nlme")) {
ChickWeight_arbitrary_group &lt;- datasets::ChickWeight
ChickWeight_arbitrary_group$group_arb_n &lt;-
  1 + (
    as.integer(ChickWeight_arbitrary_group$Chick) &gt;
    median(as.integer(ChickWeight_arbitrary_group$Chick))
  )
ChickWeight_arbitrary_group$group_arb &lt;- c("low", "high")[ChickWeight_arbitrary_group$group_arb_n]

fit_with_fixed &lt;-
  lme(
    weight ~ Diet * Time,
    random = ~Time | Chick,
    data =ChickWeight_arbitrary_group,
    weights=varIdent(fixed=c("low"=5), form=~1|group_arb)
  )
# Show all parameters
tidy(fit_with_fixed)
# Exclude fixed parameters
tidy(fit_with_fixed) %&gt;%
  filter(across(any_of("estimated"), ~.x))
}

## End(Not run)
</code></pre>

<hr>
<h2 id='unrowname'>strip rownames from an object</h2><span id='topic+unrowname'></span>

<h3>Description</h3>

<p>strip rownames from an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unrowname(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unrowname_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
