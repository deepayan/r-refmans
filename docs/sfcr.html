<!DOCTYPE html><html><head><title>Help for package sfcr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sfcr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.abort_if_dup'><p>Abort if duplicated variables</p></a></li>
<li><a href='#.abort_typo_code'><p>Abort if typo on the codes of columns</p></a></li>
<li><a href='#.abort_water_leakc'><p>Abort if column validation is not fulfilled</p></a></li>
<li><a href='#.abort_water_leakr'><p>Abort if row validation is not fulfilled</p></a></li>
<li><a href='#.add_time_stamps'><p>Find dependencies and order the equations</p></a></li>
<li><a href='#.add_time2'><p>Find dependencies and order the equations</p></a></li>
<li><a href='#.all_equal'><p>Check if all values in x are equal</p></a></li>
<li><a href='#.args_to_row'><p>Take arguments and make them a row of a tibble</p></a></li>
<li><a href='#.broyden_solver'><p>Broyden solver algorithm</p></a></li>
<li><a href='#.check_external_consistency'><p>Check shocks for length consistency and warn about risks of using exogenous series</p></a></li>
<li><a href='#.check_shock_consistency'><p>Check shocks for length consistency and warn about risks of using exogenous series</p></a></li>
<li><a href='#.check_symmetry'><p>Check that symmetry condition is valid and fulfill missing entries</p></a></li>
<li><a href='#.eq_as_tb'><p>Split the formulae into a <code>tibble</code> with the left-hand side and</p>
right-hand side as columns</a></li>
<li><a href='#.extend_baseline_matrix'><p>Extend a baseline matrix</p></a></li>
<li><a href='#.fill_rows_and_cols'><p>Fill all possible rows and columns and validate</p></a></li>
<li><a href='#.find_blocks'><p>Find blocks of independent equations (wrapper around <code>igraph</code> functions)</p></a></li>
<li><a href='#.find_names'><p>Find names for display matrix</p></a></li>
<li><a href='#.get_matrix'><p>Get numeric matrix for evaluation from balance-sheet or</p>
transactions-flow matrices</a></li>
<li><a href='#.is_equal'><p>Check if two values are equal</p></a></li>
<li><a href='#.make_matrix'><p>Make the underlying matrix that will be modified in place by the solvers</p></a></li>
<li><a href='#.prep_broyden'><p>Prep equations for Broyden and Newton solvers</p></a></li>
<li><a href='#.prep_equations'><p>Re-wrote the equations with the correct matrix syntax that will be used to evaluate</p>
the expressions inside the Gauss Seidel algorithm</a></li>
<li><a href='#.pvar'><p>Pattern replacement var</p></a></li>
<li><a href='#.pvarlag'><p>Pattern replacement lag</p></a></li>
<li><a href='#.return_loops'><p>Find cyclical nodes</p></a></li>
<li><a href='#.scan_cols'><p>Scan columns to fill whenever there's only one value missing.</p></a></li>
<li><a href='#.scan_rows'><p>Scan rows to fill whenever there's only one value missing.</p></a></li>
<li><a href='#.sfcr_broyden'><p>Broyden solver wrapper</p></a></li>
<li><a href='#.sfcr_eqs_check'><p>Check for missing endogenous variables</p></a></li>
<li><a href='#.sfcr_find_adjacency'><p>Find adjacency matrix for a system of equations</p></a></li>
<li><a href='#.sfcr_find_order'><p>Place the equations in the correct order for estimation</p></a></li>
<li><a href='#.sfcr_gauss_seidel'><p>Gauss Seidel algorithm</p></a></li>
<li><a href='#.sfcr_make_scenario_matrix'><p>Make matrix for scenario calculations</p></a></li>
<li><a href='#.sfcr_newton'><p>Newton-Raphson solver implemented with <code>rootSolve::multiroot()</code></p></a></li>
<li><a href='#.to_latex_style'><p>Transform entries into latex style</p></a></li>
<li><a href='#.validate_matrix'><p>Validate a balance-sheet or transactions-flow matrix on the simulated data</p></a></li>
<li><a href='#.validate_scan'><p>Check that the portfolio matrix respect the horizontal and vertical</p>
adding-up constraints</a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#abortifnot'><p>Abort if not</p></a></li>
<li><a href='#new_sfcr_mlt'><p>sfcr_mlt constructor</p></a></li>
<li><a href='#new_sfcr_mlt_set'><p>sfcr_mlt_set constructor</p></a></li>
<li><a href='#new_sfcr_mlt_shock'><p>sfcr_mlt_shock constructor</p></a></li>
<li><a href='#new_sfcr_set'><p>sfcr_set constructor</p></a></li>
<li><a href='#new_sfcr_tbl'><p>new_sfcr_tbl constructor</p></a></li>
<li><a href='#sfcr_baseline'><p>Simulate the baseline scenario of a stock-flow consistent model</p></a></li>
<li><a href='#sfcr_dag_blocks'><p>Create a <code>tbl_graph</code> object blocks and cycles information</p></a></li>
<li><a href='#sfcr_dag_blocks_plot'><p>Plot the DAG with blocks and cycles information</p></a></li>
<li><a href='#sfcr_dag_cycles'><p>Create a <code>tbl_graph</code> object with cycles information</p></a></li>
<li><a href='#sfcr_dag_cycles_plot'><p>Plot the DAG with cycles information</p></a></li>
<li><a href='#sfcr_expand'><p>Expand variables to implement sensitivity analysis</p></a></li>
<li><a href='#sfcr_get_blocks'><p>Get block structure of a <code>sfcr_tbl</code> object</p></a></li>
<li><a href='#sfcr_get_matrix'><p>Get Matrix form of <code>sfcr_tbl</code> object</p></a></li>
<li><a href='#sfcr_matrix'><p>Create balance-sheet or transactions-flow matrices</p></a></li>
<li><a href='#sfcr_matrix_display'><p>Print matrix to screen</p></a></li>
<li><a href='#sfcr_multis'><p>Simulate multiple SFC models at the same time</p></a></li>
<li><a href='#sfcr_portfolio'><p>Find a valid matrix of portfolio parameters</p></a></li>
<li><a href='#sfcr_random'><p>Generate random sequences inside <code>sfcr_set()</code></p></a></li>
<li><a href='#sfcr_sankey'><p>Plot Sankey's diagram representation of transactions-flow matrix</p></a></li>
<li><a href='#sfcr_scenario'><p>Add scenarios to a <code>sfcr</code> model.</p></a></li>
<li><a href='#sfcr_set'><p>Define the formulas of the model</p></a></li>
<li><a href='#sfcr_set_index'><p>Get names of endogenous vars and their index</p></a></li>
<li><a href='#sfcr_shock'><p>Create shock(s) to add to a <code>sfcr_scenario()</code>.</p></a></li>
<li><a href='#sfcr_validate'><p>Validate a transactions-flow or balance-sheet matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simulate Stock-Flow Consistent Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines to write, simulate, and validate stock-flow consistent (SFC) models. The accounting structure of SFC models are described in Godley and Lavoie (2007, ISBN:978-1-137-08599-3). The algorithms implemented to solve the models (Gauss-Seidel and Broyden) are described in Kinsella and O'Shea (2010) &lt;<a href="https://doi.org/10.2139%2Fssrn.1729205">doi:10.2139/ssrn.1729205</a>&gt; and Peressini and Sullivan (1988, ISBN:0-387-96614-5).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/joaomacalos/sfcr">https://github.com/joaomacalos/sfcr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/joaomacalos/sfcr/issues">https://github.com/joaomacalos/sfcr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.0.2), expm (&ge; 0.999.5), forcats (&ge; 0.5.0),
igraph (&ge; 1.2.6), kableExtra (&ge; 1.3.1), magrittr (&ge; 1.5),
purrr (&ge; 0.3.4), Rdpack (&ge; 2.1), rootSolve (&ge; 1.8.2.1),
rlang (&ge; 0.4.7), tibble (&ge; 3.0.3), tidyr (&ge; 1.1.2),
tidyselect (&ge; 1.1.0), stringr (&ge; 1.4.0), utils, vctrs (&ge;
0.3.5), Rcpp (&ge; 1.0.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggraph, ggplot2, grDevices, knitr, pkgdown, rmarkdown,
RColorBrewer, testthat (&ge; 2.3.2), tidygraph, tidyverse,
networkD3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-11 07:46:08 UTC; JouJo</td>
</tr>
<tr>
<td>Author:</td>
<td>Joao Macalos <a href="https://orcid.org/0000-0001-6050-6394"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joao Macalos &lt;joaomacalos@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-11 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.abort_if_dup'>Abort if duplicated variables</h2><span id='topic+.abort_if_dup'></span>

<h3>Description</h3>

<p>Abort if duplicated variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.abort_if_dup(dups)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".abort_if_dup_+3A_dups">dups</code></td>
<td>
<p>name(s) of offending variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.abort_typo_code'>Abort if typo on the codes of columns</h2><span id='topic+.abort_typo_code'></span>

<h3>Description</h3>

<p>Abort if typo on the codes of columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.abort_typo_code(nms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".abort_typo_code_+3A_nms">nms</code></td>
<td>
<p>Incorrect codes detected</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.abort_water_leakc'>Abort if column validation is not fulfilled</h2><span id='topic+.abort_water_leakc'></span>

<h3>Description</h3>

<p>Abort if column validation is not fulfilled
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.abort_water_leakc(c2names, which)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".abort_water_leakc_+3A_c2names">c2names</code></td>
<td>
<p>Names of offending columns</p>
</td></tr>
<tr><td><code id=".abort_water_leakc_+3A_which">which</code></td>
<td>
<p>Balance-sheet or transactions-flow matrix?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.abort_water_leakr'>Abort if row validation is not fulfilled</h2><span id='topic+.abort_water_leakr'></span>

<h3>Description</h3>

<p>Abort if row validation is not fulfilled
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.abort_water_leakr(r2names, which)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".abort_water_leakr_+3A_r2names">r2names</code></td>
<td>
<p>Names of offending rows</p>
</td></tr>
<tr><td><code id=".abort_water_leakr_+3A_which">which</code></td>
<td>
<p>Balance-sheet or transactions-flow matrix?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.add_time_stamps'>Find dependencies and order the equations</h2><span id='topic+.add_time_stamps'></span>

<h3>Description</h3>

<p>Find dependencies and order the equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.add_time_stamps(eq_as_tb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".add_time_stamps_+3A_eq_as_tb">eq_as_tb</code></td>
<td>
<p>A tibble generated with <code>.eq_as_tb()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.add_time2'>Find dependencies and order the equations</h2><span id='topic+.add_time2'></span>

<h3>Description</h3>

<p>Find dependencies and order the equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.add_time2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".add_time2_+3A_x">x</code></td>
<td>
<p>A vector to modify</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.all_equal'>Check if all values in x are equal</h2><span id='topic+.all_equal'></span>

<h3>Description</h3>

<p>Check if all values in x are equal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.all_equal(x, tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".all_equal_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id=".all_equal_+3A_tol">tol</code></td>
<td>
<p>Tolerance to declare equality</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.args_to_row'>Take arguments and make them a row of a tibble</h2><span id='topic+.args_to_row'></span>

<h3>Description</h3>

<p>Take arguments and make them a row of a tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.args_to_row(arg, tb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".args_to_row_+3A_arg">arg</code></td>
<td>
<p>The arguments to transform</p>
</td></tr>
<tr><td><code id=".args_to_row_+3A_tb">tb</code></td>
<td>
<p>The Tibble that will receive the rows</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.broyden_solver'>Broyden solver algorithm</h2><span id='topic+.broyden_solver'></span>

<h3>Description</h3>

<p>Broyden solver algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.broyden_solver(.x0, .fn, max_ite, tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".broyden_solver_+3A_.x0">.x0</code></td>
<td>
<p>Vector with initial guess for x.</p>
</td></tr>
<tr><td><code id=".broyden_solver_+3A_.fn">.fn</code></td>
<td>
<p>A function containing the system of equations.</p>
</td></tr>
<tr><td><code id=".broyden_solver_+3A_max_ite">max_ite</code></td>
<td>
<p>Maximum number of iterations allowed</p>
</td></tr>
<tr><td><code id=".broyden_solver_+3A_tol">tol</code></td>
<td>
<p>A numeric value indicating the accepted tolerance to declare convergence.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Check https://www.math.usm.edu/lambers/mat419/lecture11.pdf for a quick reference
on the algorithm.
</p>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.check_external_consistency'>Check shocks for length consistency and warn about risks of using exogenous series</h2><span id='topic+.check_external_consistency'></span>

<h3>Description</h3>

<p>This function makes two checks:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_external_consistency(external, periods = periods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".check_external_consistency_+3A_external">external</code></td>
<td>
<p>An .eq_as_tb() tibble with external variables.</p>
</td></tr>
<tr><td><code id=".check_external_consistency_+3A_periods">periods</code></td>
<td>
<p>The periods of the baseline model.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> The exogenous variable is a constant that is repeated over time;
</p>
</li>
<li><p> The exogenous variable has exactly the same length as the shock.
</p>
</li></ol>

<p>Furthermore, it throws a warning that using exogenous series in a shock can lead to unexpected
behavior if the length of the shock is not the same as the periods in the scenario.
</p>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.check_shock_consistency'>Check shocks for length consistency and warn about risks of using exogenous series</h2><span id='topic+.check_shock_consistency'></span>

<h3>Description</h3>

<p>This function executes two checks and issues one warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_shock_consistency(shock, periods = periods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".check_shock_consistency_+3A_shock">shock</code></td>
<td>
<p>A sfcr_shock object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, it checks that the start of the shock is not negative and that the end
of the shock is not bigger than the number of periods in the scenario.
</p>
<p>Secondly, it checks for consistency on the length of the shocks added to the scenario.
Only two types of exogenous variables are allowed:
</p>

<ol>
<li><p> The exogenous variable is a constant that is repeated over time;
</p>
</li>
<li><p> The exogenous variable has exactly the same length as the shock.
</p>
</li></ol>

<p>Furthermore, it throws a warning that using exogenous series in a shock can lead to unexpected
behavior if the length of the shock is not the same as the periods in the scenario.
</p>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.check_symmetry'>Check that symmetry condition is valid and fulfill missing entries</h2><span id='topic+.check_symmetry'></span>

<h3>Description</h3>

<p>Check that symmetry condition is valid and fulfill missing entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_symmetry(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".check_symmetry_+3A_m">m</code></td>
<td>
<p>A square matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.eq_as_tb'>Split the formulae into a <code>tibble</code> with the left-hand side and
right-hand side as columns</h2><span id='topic+.eq_as_tb'></span>

<h3>Description</h3>

<p>Split the formulae into a <code>tibble</code> with the left-hand side and
right-hand side as columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.eq_as_tb(equations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".eq_as_tb_+3A_equations">equations</code></td>
<td>
<p>list of equations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.extend_baseline_matrix'>Extend a baseline matrix</h2><span id='topic+.extend_baseline_matrix'></span>

<h3>Description</h3>

<p>This function is called if a scenario is to be created that just
continues with the baseline specification. It is useful to create
a benchmark model to compare new scenarios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extend_baseline_matrix(baseline, periods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".extend_baseline_matrix_+3A_baseline">baseline</code></td>
<td>
<p>A baseline model</p>
</td></tr>
<tr><td><code id=".extend_baseline_matrix_+3A_periods">periods</code></td>
<td>
<p>The total number of periods to run the model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.fill_rows_and_cols'>Fill all possible rows and columns and validate</h2><span id='topic+.fill_rows_and_cols'></span>

<h3>Description</h3>

<p>Fill all possible rows and columns and validate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.fill_rows_and_cols(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".fill_rows_and_cols_+3A_m">m</code></td>
<td>
<p>A square matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.find_blocks'>Find blocks of independent equations (wrapper around <code>igraph</code> functions)</h2><span id='topic+.find_blocks'></span>

<h3>Description</h3>

<p>Find blocks of independent equations (wrapper around <code>igraph</code> functions)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.find_blocks(adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".find_blocks_+3A_adj">adj</code></td>
<td>
<p>Adjacency matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.find_names'>Find names for display matrix</h2><span id='topic+.find_names'></span>

<h3>Description</h3>

<p>Clean cells to display in latex format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.find_names(matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".find_names_+3A_matrix">matrix</code></td>
<td>
<p>A balance-sheet or transactions-flow matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.get_matrix'>Get numeric matrix for evaluation from balance-sheet or
transactions-flow matrices</h2><span id='topic+.get_matrix'></span>

<h3>Description</h3>

<p>Get numeric matrix for evaluation from balance-sheet or
transactions-flow matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_matrix(mtrx, bl1, bl2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".get_matrix_+3A_mtrx">mtrx</code></td>
<td>
<p>Balance-sheet or transactions-flow matrix</p>
</td></tr>
<tr><td><code id=".get_matrix_+3A_bl1">bl1</code></td>
<td>
<p>calls from baseline model</p>
</td></tr>
<tr><td><code id=".get_matrix_+3A_bl2">bl2</code></td>
<td>
<p>external from baseline model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.is_equal'>Check if two values are equal</h2><span id='topic+.is_equal'></span>

<h3>Description</h3>

<p>Check if two values are equal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.is_equal(x, y, tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".is_equal_+3A_x">x</code>, <code id=".is_equal_+3A_y">y</code></td>
<td>
<p>numeric values</p>
</td></tr>
<tr><td><code id=".is_equal_+3A_tol">tol</code></td>
<td>
<p>Tolerance to declare equality</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.make_matrix'>Make the underlying matrix that will be modified in place by the solvers</h2><span id='topic+.make_matrix'></span>

<h3>Description</h3>

<p>Make the underlying matrix that will be modified in place by the solvers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.make_matrix(equations, external, periods, initial = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".make_matrix_+3A_equations">equations</code></td>
<td>
<p>Prepared equations.</p>
</td></tr>
<tr><td><code id=".make_matrix_+3A_external">external</code></td>
<td>
<p>Exogenous and parameters as tibble.</p>
</td></tr>
<tr><td><code id=".make_matrix_+3A_periods">periods</code></td>
<td>
<p>Total number of rows.</p>
</td></tr>
<tr><td><code id=".make_matrix_+3A_initial">initial</code></td>
<td>
<p>Initial values, if supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.prep_broyden'>Prep equations for Broyden and Newton solvers</h2><span id='topic+.prep_broyden'></span>

<h3>Description</h3>

<p>Prep equations for Broyden and Newton solvers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.prep_broyden(.block)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".prep_broyden_+3A_.block">.block</code></td>
<td>
<p>Blocks of equations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.prep_equations'>Re-wrote the equations with the correct matrix syntax that will be used to evaluate
the expressions inside the Gauss Seidel algorithm</h2><span id='topic+.prep_equations'></span>

<h3>Description</h3>

<p>Re-wrote the equations with the correct matrix syntax that will be used to evaluate
the expressions inside the Gauss Seidel algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.prep_equations(ordered_eqs, external)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".prep_equations_+3A_ordered_eqs">ordered_eqs</code></td>
<td>
<p>ordered equations after passing through <code>.sfcr_find_order()</code> function.</p>
</td></tr>
<tr><td><code id=".prep_equations_+3A_external">external</code></td>
<td>
<p>Tibble of exogenous values and parameters, already separated with
<code>.eq_as_tb()</code> function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.pvar'>Pattern replacement var</h2><span id='topic+.pvar'></span>

<h3>Description</h3>

<p>Pattern replacement var
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pvar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".pvar_+3A_x">x</code></td>
<td>
<p>vector of variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.pvarlag'>Pattern replacement lag</h2><span id='topic+.pvarlag'></span>

<h3>Description</h3>

<p>Pattern replacement lag
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pvarlag(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".pvarlag_+3A_x">x</code></td>
<td>
<p>vector of variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.return_loops'>Find cyclical nodes</h2><span id='topic+.return_loops'></span>

<h3>Description</h3>

<p>Find cyclical nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.return_loops(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".return_loops_+3A_m">m</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See Networks: an introduction from M.E.J. Newman, 2010, p. 136-139
for a reference on this algorithm.
</p>

<hr>
<h2 id='.scan_cols'>Scan columns to fill whenever there's only one value missing.</h2><span id='topic+.scan_cols'></span>

<h3>Description</h3>

<p>Scan columns to fill whenever there's only one value missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.scan_cols(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".scan_cols_+3A_m">m</code></td>
<td>
<p>A square matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.scan_rows'>Scan rows to fill whenever there's only one value missing.</h2><span id='topic+.scan_rows'></span>

<h3>Description</h3>

<p>Scan rows to fill whenever there's only one value missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.scan_rows(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".scan_rows_+3A_m">m</code></td>
<td>
<p>A square matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.sfcr_broyden'>Broyden solver wrapper</h2><span id='topic+.sfcr_broyden'></span>

<h3>Description</h3>

<p>Broyden solver wrapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sfcr_broyden(m, equations, periods, max_ite, tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sfcr_broyden_+3A_m">m</code></td>
<td>
<p>The initialized matrix obtained with <code>.make_matrix()</code>.</p>
</td></tr>
<tr><td><code id=".sfcr_broyden_+3A_equations">equations</code></td>
<td>
<p>Prepared equations with <code>.prep_equations()</code>.</p>
</td></tr>
<tr><td><code id=".sfcr_broyden_+3A_periods">periods</code></td>
<td>
<p>Total number of rows (periods) in the model.</p>
</td></tr>
<tr><td><code id=".sfcr_broyden_+3A_max_ite">max_ite</code></td>
<td>
<p>Maximum number of iterations allowed per block per period.</p>
</td></tr>
<tr><td><code id=".sfcr_broyden_+3A_tol">tol</code></td>
<td>
<p>Tolerance accepted to determine convergence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the Broyden method to solve the cyclical
blocks of equations.
</p>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.sfcr_eqs_check'>Check for missing endogenous variables</h2><span id='topic+.sfcr_eqs_check'></span>

<h3>Description</h3>

<p>Check for missing endogenous variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sfcr_eqs_check(m, equations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sfcr_eqs_check_+3A_m">m</code></td>
<td>
<p>The initialized matrix obtained with <code>.make_matrix()</code>.</p>
</td></tr>
<tr><td><code id=".sfcr_eqs_check_+3A_equations">equations</code></td>
<td>
<p>Prepared equations with <code>.prep_equations()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.sfcr_find_adjacency'>Find adjacency matrix for a system of equations</h2><span id='topic+.sfcr_find_adjacency'></span>

<h3>Description</h3>

<p>Find adjacency matrix for a system of equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sfcr_find_adjacency(equations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sfcr_find_adjacency_+3A_equations">equations</code></td>
<td>
<p>A system of equations already time stamped</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.sfcr_find_order'>Place the equations in the correct order for estimation</h2><span id='topic+.sfcr_find_order'></span>

<h3>Description</h3>

<p>Place the equations in the correct order for estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sfcr_find_order(equations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sfcr_find_order_+3A_equations">equations</code></td>
<td>
<p>Equations supplied by the user.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create an adjacency matrix and apply
<code>.find_blocks()</code> function to identify the blocks
of independent equations.
</p>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.sfcr_gauss_seidel'>Gauss Seidel algorithm</h2><span id='topic+.sfcr_gauss_seidel'></span>

<h3>Description</h3>

<p>Gauss Seidel algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sfcr_gauss_seidel(m, equations, periods, max_ite, tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sfcr_gauss_seidel_+3A_m">m</code></td>
<td>
<p>The initialized matrix obtained with <code>.make_matrix()</code>.</p>
</td></tr>
<tr><td><code id=".sfcr_gauss_seidel_+3A_equations">equations</code></td>
<td>
<p>Prepared equations with <code>.prep_equations()</code>.</p>
</td></tr>
<tr><td><code id=".sfcr_gauss_seidel_+3A_periods">periods</code></td>
<td>
<p>Total number of rows (periods) in the model.</p>
</td></tr>
<tr><td><code id=".sfcr_gauss_seidel_+3A_max_ite">max_ite</code></td>
<td>
<p>Maximum number of iterations allowed per block per period.</p>
</td></tr>
<tr><td><code id=".sfcr_gauss_seidel_+3A_tol">tol</code></td>
<td>
<p>Tolerance accepted to determine convergence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm simulates the model by recursion by using
nested for loops. At each round of iteration, the values calculated
are compared to the previous values. If the difference is below
a tolerance value set by the user, the round of calculations have converged
and the algorithm jump to the next block of equations.
</p>
<p>The algorithm modifies a matrix in place to optimize its performance.
</p>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.sfcr_make_scenario_matrix'>Make matrix for scenario calculations</h2><span id='topic+.sfcr_make_scenario_matrix'></span>

<h3>Description</h3>

<p>Make matrix for scenario calculations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sfcr_make_scenario_matrix(baseline, scenario, periods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sfcr_make_scenario_matrix_+3A_baseline">baseline</code></td>
<td>
<p>a model calculated with the <code>sfcr_sim()</code> function</p>
</td></tr>
<tr><td><code id=".sfcr_make_scenario_matrix_+3A_scenario">scenario</code></td>
<td>
<p>a List holding the different scenarios</p>
</td></tr>
<tr><td><code id=".sfcr_make_scenario_matrix_+3A_periods">periods</code></td>
<td>
<p>The total number of periods in the model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates the base matrix that is going to be
modified in place by the different solvers.
</p>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.sfcr_newton'>Newton-Raphson solver implemented with <code>rootSolve::multiroot()</code></h2><span id='topic+.sfcr_newton'></span>

<h3>Description</h3>

<p>Newton-Raphson solver implemented with <code>rootSolve::multiroot()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sfcr_newton(m, equations, periods, max_ite, tol, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sfcr_newton_+3A_m">m</code></td>
<td>
<p>The initialized matrix obtained with <code>.make_matrix()</code>.</p>
</td></tr>
<tr><td><code id=".sfcr_newton_+3A_equations">equations</code></td>
<td>
<p>Prepared equations with <code>.prep_equations()</code>.</p>
</td></tr>
<tr><td><code id=".sfcr_newton_+3A_periods">periods</code></td>
<td>
<p>Total number of rows (periods) in the model.</p>
</td></tr>
<tr><td><code id=".sfcr_newton_+3A_max_ite">max_ite</code></td>
<td>
<p>Maximum number of iterations allowed per block per period.</p>
</td></tr>
<tr><td><code id=".sfcr_newton_+3A_tol">tol</code></td>
<td>
<p>Tolerance accepted to determine convergence.</p>
</td></tr>
<tr><td><code id=".sfcr_newton_+3A_...">...</code></td>
<td>
<p>Extra parameters to pass to <code>rootSolve::multiroot()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the Newton-Raphson method to solve the cyclical
blocks of equations. It relies on the <code>multiroot()</code> function from <code>rootSolve</code>.
</p>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.to_latex_style'>Transform entries into latex style</h2><span id='topic+.to_latex_style'></span>

<h3>Description</h3>

<p>Transform entries into latex style
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.to_latex_style(matrix, nms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".to_latex_style_+3A_matrix">matrix</code></td>
<td>
<p>a balance-sheet or transactions-flow matrix</p>
</td></tr>
<tr><td><code id=".to_latex_style_+3A_nms">nms</code></td>
<td>
<p>Cleaned names with <code>.find_names()</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.validate_matrix'>Validate a balance-sheet or transactions-flow matrix on the simulated data</h2><span id='topic+.validate_matrix'></span>

<h3>Description</h3>

<p>Validate a balance-sheet or transactions-flow matrix on the simulated data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.validate_matrix(mtrx, m, which = "tfm", tol, rtol = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".validate_matrix_+3A_mtrx">mtrx</code></td>
<td>
<p>A balance-sheet or transactions-flow matrix</p>
</td></tr>
<tr><td><code id=".validate_matrix_+3A_m">m</code></td>
<td>
<p>A baseline model in matrix format &ndash; get from attributes or with
<code>sfcr_get_matrix()</code> function.</p>
</td></tr>
<tr><td><code id=".validate_matrix_+3A_which">which</code></td>
<td>
<p>A balance-sheet or a transactions-flow matrix?</p>
</td></tr>
<tr><td><code id=".validate_matrix_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence</p>
</td></tr>
<tr><td><code id=".validate_matrix_+3A_rtol">rtol</code></td>
<td>
<p>Relative tolerance?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='.validate_scan'>Check that the portfolio matrix respect the horizontal and vertical
adding-up constraints</h2><span id='topic+.validate_scan'></span>

<h3>Description</h3>

<p>Check that the portfolio matrix respect the horizontal and vertical
adding-up constraints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.validate_scan(m, which)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".validate_scan_+3A_m">m</code></td>
<td>
<p>A square matrix</p>
</td></tr>
<tr><td><code id=".validate_scan_+3A_which">which</code></td>
<td>
<p>Rows or columns?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='abortifnot'>Abort if not</h2><span id='topic+abortifnot'></span>

<h3>Description</h3>

<p>Abort if not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abortifnot(cnd, message = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abortifnot_+3A_cnd">cnd</code></td>
<td>
<p>Condition to be evaluated.</p>
</td></tr>
<tr><td><code id="abortifnot_+3A_message">message</code></td>
<td>
<p>Message to display if condition is false.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='new_sfcr_mlt'>sfcr_mlt constructor</h2><span id='topic+new_sfcr_mlt'></span>

<h3>Description</h3>

<p>sfcr_mlt constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_sfcr_mlt(multis, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_sfcr_mlt_+3A_multis">multis</code></td>
<td>
<p>A list with multiple <code>sfcr_tbl</code></p>
</td></tr>
<tr><td><code id="new_sfcr_mlt_+3A_fixed">fixed</code></td>
<td>
<p>The fixed argument</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='new_sfcr_mlt_set'>sfcr_mlt_set constructor</h2><span id='topic+new_sfcr_mlt_set'></span>

<h3>Description</h3>

<p>sfcr_mlt_set constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_sfcr_mlt_set(x, original)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_sfcr_mlt_set_+3A_x">x</code></td>
<td>
<p>A expanded list of sfcr_set's</p>
</td></tr>
<tr><td><code id="new_sfcr_mlt_set_+3A_original">original</code></td>
<td>
<p>the original sfcr_set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='new_sfcr_mlt_shock'>sfcr_mlt_shock constructor</h2><span id='topic+new_sfcr_mlt_shock'></span>

<h3>Description</h3>

<p>sfcr_mlt_shock constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_sfcr_mlt_shock(x, original)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_sfcr_mlt_shock_+3A_x">x</code></td>
<td>
<p>A expanded list of sfcr_shock's</p>
</td></tr>
<tr><td><code id="new_sfcr_mlt_shock_+3A_original">original</code></td>
<td>
<p>the original sfcr_shock</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='new_sfcr_set'>sfcr_set constructor</h2><span id='topic+new_sfcr_set'></span>

<h3>Description</h3>

<p>sfcr_set constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_sfcr_set(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_sfcr_set_+3A_list">list</code></td>
<td>
<p>A list</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='new_sfcr_tbl'>new_sfcr_tbl constructor</h2><span id='topic+new_sfcr_tbl'></span>

<h3>Description</h3>

<p>new_sfcr_tbl constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_sfcr_tbl(tbl, matrix, calls, external)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_sfcr_tbl_+3A_tbl">tbl</code></td>
<td>
<p>A tibble</p>
</td></tr>
<tr><td><code id="new_sfcr_tbl_+3A_matrix">matrix</code></td>
<td>
<p>a Matrix</p>
</td></tr>
<tr><td><code id="new_sfcr_tbl_+3A_calls">calls</code></td>
<td>
<p>Calls tibble</p>
</td></tr>
<tr><td><code id="new_sfcr_tbl_+3A_external">external</code></td>
<td>
<p>Vector with external names</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='sfcr_baseline'>Simulate the baseline scenario of a stock-flow consistent model</h2><span id='topic+sfcr_baseline'></span>

<h3>Description</h3>

<p>The <code>sfcr_baseline()</code> function is used to simulate a SFC model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_baseline(
  equations,
  external,
  periods,
  initial = NULL,
  hidden = NULL,
  max_iter = 350,
  .hidden_tol = 0.1,
  tol = 1e-08,
  method = "Broyden",
  rhtol = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_baseline_+3A_equations">equations</code></td>
<td>
<p>A <code>sfcr_set</code> containing all the equations of the model to be simulated. The equations
must be written with the R formula syntax, with the left-hand side separated from the right-hand side
by a twiddle <code>~</code>.</p>
</td></tr>
<tr><td><code id="sfcr_baseline_+3A_external">external</code>, <code id="sfcr_baseline_+3A_initial">initial</code></td>
<td>
<p>A <code>sfcr_set</code> of external variables (exogenous and parameters) or of initial
values. They should be written as equations using the R syntax.</p>
</td></tr>
<tr><td><code id="sfcr_baseline_+3A_periods">periods</code></td>
<td>
<p>A number specifying the total number of periods of the model to be simulated.</p>
</td></tr>
<tr><td><code id="sfcr_baseline_+3A_hidden">hidden</code></td>
<td>
<p>Named object that identify the two variables that make the hidden equality
in the SFC model, e.g., <code>c("H_h" = "H_s")</code>. Defaults to NULL.
If <code>hidden</code> is supplied, the model will evaluate if the hidden equation is satisfied.</p>
</td></tr>
<tr><td><code id="sfcr_baseline_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum iterations allowed per period.</p>
</td></tr>
<tr><td><code id="sfcr_baseline_+3A_.hidden_tol">.hidden_tol</code></td>
<td>
<p>Error tolerance to accept the equality of the hidden equation. Defaults to 1.
In growth models, computational errors might buildup in the hidden equation, which renders any absolute
comparison inadequate. For such models, please turn <code>rhtol</code> to <code>TRUE</code>, and set the value
of <code>.hidden_tol</code> accordingly. See details for further information.</p>
</td></tr>
<tr><td><code id="sfcr_baseline_+3A_tol">tol</code></td>
<td>
<p>Tolerance accepted to determine convergence.</p>
</td></tr>
<tr><td><code id="sfcr_baseline_+3A_method">method</code></td>
<td>
<p>The method to use to find a solution. Defaults to &quot;Broyden&quot;.</p>
</td></tr>
<tr><td><code id="sfcr_baseline_+3A_rhtol">rhtol</code></td>
<td>
<p>A logical argument that defines whether the a relative measure is used to evaluate
the hidden equation or not. Defaults to <code>FALSE</code>, i.e., a absolute measure is used.</p>
</td></tr>
<tr><td><code id="sfcr_baseline_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass to <code>rootSolve::multiroot()</code> function if &quot;Newton&quot; method
is selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of a <code>sfcr_baseline()</code> is a <code>sfcr_tbl</code>. The only difference between
a <code>sfcr_tbl</code> and a standard <code>tbl_df</code> is that the former has two extra attributes:
<code>matrix</code> and <code>call</code>. The <code>matrix</code> attribute, for example, can be accessed by
calling <code>attributes(sfcr_sim_object)$matrix</code>.
It is possible to see, in the matrix, the number of iterations required to calculate each
block of equations in the model.
The <code>call</code> attribute shows the blocks of equations and preserve the call that are used
internally.
</p>
<p>The <code>equations</code>, <code>exogenous</code>, and <code>parameters</code> arguments must be written
with the R formula syntax, i.e., the left-hand side of each item is separated to the
right-hand side by a twiddle. Variables that represent lags of endogenous or exogenous
variables must be followed by <code>[-1]</code>. See examples for details on the syntax.
</p>
<p>Before solving the system of equations, two consecutive depth-first searches identify
and order the blocks of independent equations in the system. The system is then solved
sequentially, i.e., the variables that depend only on lagged or exogenous values are evaluated
first, and then the variables that depends on these variables, etc. The solving algorithms
are only applied to the blocks of mutually dependent equations. The great <code>igraph</code>
package is used to implement the two consecutive depth-first searches.
</p>

<ul>
<li><p> Methods:
</p>
</li></ul>

<p>The <code>sfcr</code> package provides three algorithms to solve the blocks of cyclical equations:
the Gauss-Seidel algorithm, the Broyden algorithm, and the Newton-Raphson algorithm. The
default method is &quot;Broyden&quot; as it tends to be fastest one.
</p>
<p>See (Kinsella and OShea 2010) for details on the Gauss-Seidel algorithm and
(Peressini et al. 1988) for details on the Broyden and Newton-Raphson
algorithms.
</p>
<p>The &quot;Broyden&quot; algorithm uses the <code>rootSolve::jacobian.full()</code> function to get the
initial Jacobian matrix, and compiled code from <code>RcppArmadillo</code> to invert the
jacobians. See also https://www.math.usm.edu/lambers/mat419/lecture11.pdf.
</p>
<p>The Gauss Seidel algorithm is implemented as described by (Kinsella and OShea 2010).
Finally, the &quot;Newton&quot; method uses the <code>rootSolve::multiroot()</code> function to solve the system.
</p>

<ul>
<li><p> Hidden equation:
</p>
</li></ul>

<p>One of the defining aspects of a SFC model is its water tight accounting. One way
to check whether the model was correctly defined is to see if the hidden (redundant)
equation is satisfied after the model is simulated. In stationary models, an absolute
comparison should suffice as the model converges to a stationary state. However,
growth models converge to a stable growth rate where stocks are perpetually increasing.
It is inadequate to use a absolute comparison in such models. In these cases, the
<code>rhtol</code> argument (&quot;relative hidden tolerance&quot;) must be set to <code>TRUE</code> in order
to perform a relative comparison. The relative comparison evaluates the numerical
discrepancy in the hidden equation as a ratio of one of its elements. For example,
if <code>hidden = c("Bbs" = "Bbd")</code>, the hidden equation will be evaluated according to
the following steps:
</p>

<ol>
<li> <p><code>d = (Bbs - Bbd)</code>
</p>
</li>
<li> <p><code>isTRUE(d/Bbs &lt; .hidden_tol)</code>
</p>
</li></ol>

<p>In general, the <code>.hidden_tol</code> argument should be set to a small number (e.g. 1e-6).
The function will check that this proportion remains the same for all simulated periods.
</p>


<h3>Value</h3>

<p>A <code>sfcr_tbl</code>.
</p>


<h3>Author(s)</h3>

<p>João Macalós, <a href="mailto:joaomacalos@gmail.com">joaomacalos@gmail.com</a>
</p>


<h3>References</h3>

<p>Kinsella S, OShea T (2010).
&ldquo;Solution and Simulation of Large Stock Flow Consistent Monetary Production Models via the Gauss Seidel Algorithm.&rdquo;
<em>SSRN Electronic Journal</em>.
doi: <a href="https://doi.org/10.2139/ssrn.1729205">10.2139/ssrn.1729205</a>, <a href="https://doi.org/10.2139/ssrn.1729205">https://doi.org/10.2139/ssrn.1729205</a>.
Peressini AL, Sullivan FE, Uhl JJ (1988).
<em>The Mathematics of Nonlinear Programming</em>.
Springer-Verlag, Berlin, Heidelberg.
ISBN 0387966145.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eqs &lt;- sfcr_set(
  TXs ~ TXd,
  YD ~ W * Ns - TXs,
  Cd ~ alpha1 * YD + alpha2 * Hh[-1],
  Hh ~ YD - Cd + Hh[-1],
  Ns ~ Nd,
  Nd ~ Y / W,
  Cs ~ Cd,
  Gs ~ Gd,
  Y ~ Cs + Gs,
  TXd ~ theta * W * Ns,
  Hs ~ Gd - TXd + Hs[-1]
)

external &lt;- sfcr_set(Gd ~ 20, W ~ 1, alpha1 ~ 0.6, alpha2 ~ 0.4, theta ~ 0.2)

# Periods is set to 10 to run faster. A usual model should run at
# least 50 periods to find a steady state
sfcr_baseline(equations = eqs, external = external, periods = 10)

</code></pre>

<hr>
<h2 id='sfcr_dag_blocks'>Create a <code>tbl_graph</code> object blocks and cycles information</h2><span id='topic+sfcr_dag_blocks'></span>

<h3>Description</h3>

<p>Create a <code>tbl_graph</code> object blocks and cycles information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_dag_blocks(equations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_dag_blocks_+3A_equations">equations</code></td>
<td>
<p>A <code>sfcr_set</code> containing all the equations of the model to be simulated. The equations
must be written with the R formula syntax, with the left-hand side separated from the right-hand side
by a twiddle <code>~</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a <code>tbl_graph</code> with information about
the blocks and cycles attached to it. This object can then be used to
plot the DAG of the model.
</p>


<h3>Value</h3>

<p>A <code>tbl_graph</code>
</p>


<h3>Author(s)</h3>

<p>João Macalós, <a href="mailto:joaomacalos@gmail.com">joaomacalos@gmail.com</a>
</p>

<hr>
<h2 id='sfcr_dag_blocks_plot'>Plot the DAG with blocks and cycles information</h2><span id='topic+sfcr_dag_blocks_plot'></span>

<h3>Description</h3>

<p>Plot the DAG with blocks and cycles information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_dag_blocks_plot(equations, title = NULL, size = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_dag_blocks_plot_+3A_equations">equations</code></td>
<td>
<p>A <code>sfcr_set</code> containing all the equations of the model to be simulated. The equations
must be written with the R formula syntax, with the left-hand side separated from the right-hand side
by a twiddle <code>~</code>.</p>
</td></tr>
<tr><td><code id="sfcr_dag_blocks_plot_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="sfcr_dag_blocks_plot_+3A_size">size</code></td>
<td>
<p>Size of the points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a <code>tbl_graph</code> with information about
the cycles attached to it. This object can then be used to
plot the DAG of the model.
</p>


<h3>Value</h3>

<p>A <code>tbl_graph</code>
</p>


<h3>Author(s)</h3>

<p>João Macalós, <a href="mailto:joaomacalos@gmail.com">joaomacalos@gmail.com</a>
</p>

<hr>
<h2 id='sfcr_dag_cycles'>Create a <code>tbl_graph</code> object with cycles information</h2><span id='topic+sfcr_dag_cycles'></span>

<h3>Description</h3>

<p>Create a <code>tbl_graph</code> object with cycles information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_dag_cycles(equations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_dag_cycles_+3A_equations">equations</code></td>
<td>
<p>A <code>sfcr_set</code> containing all the equations of the model to be simulated. The equations
must be written with the R formula syntax, with the left-hand side separated from the right-hand side
by a twiddle <code>~</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a <code>tbl_graph</code> with information about
the cycles attached to it. This object can then be used to
plot the DAG of the model.
</p>


<h3>Value</h3>

<p>A <code>tbl_graph</code>
</p>


<h3>Author(s)</h3>

<p>João Macalós, <a href="mailto:joaomacalos@gmail.com">joaomacalos@gmail.com</a>
</p>

<hr>
<h2 id='sfcr_dag_cycles_plot'>Plot the DAG with cycles information</h2><span id='topic+sfcr_dag_cycles_plot'></span>

<h3>Description</h3>

<p>Plot the DAG with cycles information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_dag_cycles_plot(equations, title = NULL, size = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_dag_cycles_plot_+3A_equations">equations</code></td>
<td>
<p>A <code>sfcr_set</code> containing all the equations of the model to be simulated. The equations
must be written with the R formula syntax, with the left-hand side separated from the right-hand side
by a twiddle <code>~</code>.</p>
</td></tr>
<tr><td><code id="sfcr_dag_cycles_plot_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="sfcr_dag_cycles_plot_+3A_size">size</code></td>
<td>
<p>Size of the points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='sfcr_expand'>Expand variables to implement sensitivity analysis</h2><span id='topic+sfcr_expand'></span>

<h3>Description</h3>

<p>The <code>sfcr_expand()</code> function is a s3 <strong>generic</strong> that takes
a list of external objects and returns a expanded set of these lists.
It has methods for <code>sfcr_set</code> objects and for <code>sfcr_shock</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_expand(x, variable, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_expand_+3A_x">x</code></td>
<td>
<p>A external set created with <code>sfcr_set()</code> or
a shock set created with <code>sfcr_shock()</code></p>
</td></tr>
<tr><td><code id="sfcr_expand_+3A_variable">variable</code></td>
<td>
<p>the name of variable to be expanded.</p>
</td></tr>
<tr><td><code id="sfcr_expand_+3A_values">values</code></td>
<td>
<p>a vector containing the new values of the external or
shock variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two available methods for the <code>sfcr_expand()</code> function:
</p>

<ul>
<li> <p><code>sfcr_set</code>:
Takes a <code>sfcr_set</code> object with <strong>external</strong> variables and creates
a list of sets that inherits all the aspects of the <code>x</code> set supplied
but set the values of the <code>variable</code> to the each element of <code>value</code>.
The output is a <code>sfcr_mlt_set</code> object.
</p>
</li>
<li> <p><code>sfcr_shock</code>:
Takes a <code>sfcr_shock</code> object and creates a list of shocks that inherits
all the aspects of the <code>x</code> shock but set the <code>values</code> of the
<code>variable</code> to each element of <code>value</code>. The output of this
method is a <code>sfcr_mlt_shock</code> object.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>João Macalós
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. Expand a external set:
external &lt;- sfcr_set(G_d ~ 20, W ~ 1, alpha1 ~ 0.6, alpha2 ~ 0.4, theta ~ 0.2)
sfcr_expand(external, alpha2, c(0.1, 0.2))

# 2. Expand a shock:
shock &lt;- sfcr_shock(variables = sfcr_set(alpha1 ~ 0.8), start = 5, end = 50)
sfcr_expand(shock, alpha1, c(0.7, 0.8, 0.9))

</code></pre>

<hr>
<h2 id='sfcr_get_blocks'>Get block structure of a <code>sfcr_tbl</code> object</h2><span id='topic+sfcr_get_blocks'></span>

<h3>Description</h3>

<p>Get block structure of a <code>sfcr_tbl</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_get_blocks(sfcr_tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_get_blocks_+3A_sfcr_tbl">sfcr_tbl</code></td>
<td>
<p>A <code>sfcr_tbl</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='sfcr_get_matrix'>Get Matrix form of <code>sfcr_tbl</code> object</h2><span id='topic+sfcr_get_matrix'></span>

<h3>Description</h3>

<p>Get Matrix form of <code>sfcr_tbl</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_get_matrix(sfcr_tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_get_matrix_+3A_sfcr_tbl">sfcr_tbl</code></td>
<td>
<p>A <code>sfcr_tbl</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='sfcr_matrix'>Create balance-sheet or transactions-flow matrices</h2><span id='topic+sfcr_matrix'></span>

<h3>Description</h3>

<p>Create balance-sheet or transactions-flow matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_matrix(columns, codes, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_matrix_+3A_columns">columns</code></td>
<td>
<p>Vector containing the name of the columns in the matrix.</p>
</td></tr>
<tr><td><code id="sfcr_matrix_+3A_codes">codes</code></td>
<td>
<p>A vector containing the abbreviation of the
column names that is going to be used as a reference to
build the rows. They must be provided in the same order
as the <code>columns</code>.</p>
</td></tr>
<tr><td><code id="sfcr_matrix_+3A_...">...</code></td>
<td>
<p>Vectors that fill the rows of the matrix.
The first element of each vector <strong>must</strong> be the name of the
row in the respective matrix. The remaining elements of the vector
must be name-value pairs that exactly matches the <code>codes</code> argument.
See the examples for further details.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function can be used to generate a transactions-
flow matrix as well as a balance-sheet matrix. If the user
wishes to validate these matrices with the simulated data,
please pay attention to the following details:
</p>

<ul>
<li><p> Transactions-flow Matrix:
In the transactions-flow matrix, the <code>sum</code> column is
going to be generated automatically by the validation
function. Please do not add it by hand.
</p>
</li>
<li><p> Balance-sheet Matrix:
In the balance-sheet matrix, it might be the case that some
rows do not sum to zero. Therefore, the user must supply
by hand the non-zero values of the <code>sum</code> column.
This column should always be the last column of the matrix
and should always be named as &quot;Sum&quot;. If there's no column
named as &quot;Sum&quot;, it will be generated automatically by the
validation function with all entries equal to zero.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>João Macalós, <a href="mailto:joaomacalos@gmail.com">joaomacalos@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Balance-sheet matrix

bs_pc &lt;- sfcr_matrix(
  columns = c("Households", "Firms", "Government", "Central bank", "sum"),
  codes = c("h", "f", "g", "cb", "s"),
  r1 = c("Money", h = "+Hh", cb = "-Hs"),
  r2 = c("Bills", h = "+Bh", g = "-Bs", cb = "+Bcb"),
  r3 = c("Balance", h = "-V", g = "+V")
)


# Transactions-flow matrix
tfm_pc &lt;- sfcr_matrix(
  columns = c("Households", "Firms", "Government", "CB current", "CB capital"),
  codes = c("h", "f", "g", "cbc", "cbk"),
  c("Consumption", h = "-C", f = "+C"),
  c("Govt. Expenditures", f = "+G", g = "-G"),
  c("Income", h = "+Y", f = "-Y"),
  c("Int. payments", h = "+r[-1] * Bh[-1]", g = "-r[-1] * Bs[-1]", cbc = "+r[-1] * Bcb[-1]"),
  c("CB profits", g = "+r[-1] * Bcb[-1]", cbc = "-r[-1] * Bcb[-1]"),
  c("Taxes", h = "-TX", g = "+TX"),
  c("Ch. Money", h = "-(Hh - Hh[-1])", cbk = "+(Hs - Hs[-1])"),
  c("Ch. Bills", h = "-(Bh - Bh[-1])", g = "+(Bs - Bs[-1])", cbk = "-(Bcb - Bcb[-1])")
)
</code></pre>

<hr>
<h2 id='sfcr_matrix_display'>Print matrix to screen</h2><span id='topic+sfcr_matrix_display'></span>

<h3>Description</h3>

<p>Print matrix to screen
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_matrix_display(matrix, which = "tfm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_matrix_display_+3A_matrix">matrix</code></td>
<td>
<p>A balance sheet or transactions-flow matrix</p>
</td></tr>
<tr><td><code id="sfcr_matrix_display_+3A_which">which</code></td>
<td>
<p>A character string for the matrix. Is it a balance-sheet or
a transactions-flow matrix? here are two options:
<code>"bs"</code> for balance-sheet matrices, and <code>"tfm"</code> for transactions-
flow matrices. The default is <code>"tfm"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a matrix as input and generate a <code>kableExtra</code>
table with math symbols displayed in latex style.
</p>


<h3>Note</h3>

<p>This function converts the math expressions used to build the <code>sfcr_matrix</code>
into a latex format, but cannot add modifications to it. The user is
invited to explore the source code and the <code>kableExtra</code> package in order to
personalize his/her own matrices.
</p>


<h3>Author(s)</h3>

<p>João Macalós
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Balance-sheet matrix

bs_insout &lt;- sfcr_matrix(
  columns = c("Households", "Firms", "Government", "Central bank", "Banks", "Sum"),
  codes = c("h", "f", "g", "cb", "b", "s"),
  r1 = c("Inventories", f = "+INV", s = "+INV"),
  r2 = c("HPM", h = "+Hhd", cb = "-Hs", b = "+Hbd"),
  r3 = c("Advances", cb = "+As", b = "-Ad"),
  r4 = c("Checking deposits", h = "+M1h", b = "-M1s"),
  r5 = c("Time deposits", h = "+M2h", b = "-M2s"),
  r6 = c("Bills", h = "+Bhh", g = "-Bs", cb = "+Bcb", b = "+Bbd"),
  r7 = c("Bonds", h = "+BLh * pbl", g = "-BLs * pbl"),
  r8 = c("Loans", f = "-Ld", b = "+Ls"),
  r9 = c("Balance", h = "-V", f = 0, g = "+GD", cb = 0, b = 0, s = "-INV")
)

sfcr_matrix_display(bs_insout, "bs")
</code></pre>

<hr>
<h2 id='sfcr_multis'>Simulate multiple SFC models at the same time</h2><span id='topic+sfcr_multis'></span>

<h3>Description</h3>

<p>The <code>sfcr_multis()</code> function is used to simulate multiple models
at the same time, returning a list of <code>sfcr_tbl</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_multis(expanded, fixed, periods, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_multis_+3A_expanded">expanded</code></td>
<td>
<p>A <code>sfcr_mlt_set</code>, <code>sfcr_mlt_shock</code>, or a
<code>sfcr_mlt</code> object.</p>
</td></tr>
<tr><td><code id="sfcr_multis_+3A_fixed">fixed</code></td>
<td>
<p>A <code>sfcr_set</code>, <code>sfcr_tbl</code>, or <code>sfcr_shock</code> object.</p>
</td></tr>
<tr><td><code id="sfcr_multis_+3A_periods">periods</code></td>
<td>
<p>A number specifying the total number of periods of the model to be simulated.</p>
</td></tr>
<tr><td><code id="sfcr_multis_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the underlying implementation of the
<code>sfcr_baseline()</code> or <code>sfcr_scenario()</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sfcr_multis()</code> function takes an <code>expanded</code> object and
a <code>fixed</code> to simulate multiple models that will share the content
of <code>fixed</code> but vary on the <code>expanded</code>.
</p>
<p>This function is a <strong>generic</strong>, which means that its implementation
depends on the class of the <code>expanded</code> argument.
</p>
<p>The available methods for the <code>sfcr_multis()</code> function depends
on the <code>expanded</code> argument. There are three possible methods:
</p>

<ul>
<li> <p><code>sfcr_mlt_set</code>:
When the <code>sfcr_multis()</code> takes an <code>sfcr_mlt_set</code> class
as the input of <code>expanded</code>, it must take a list of equations of
the <code>sfcr_set</code> class as the <code>fixed</code> input. This method
simulates many baseline models that accept the same set of equations
and vary on the external variables supplied with the <code>expanded</code>
argument.
</p>
</li>
<li> <p><code>sfcr_mlt_shock</code>:
When the <code>sfcr_multis()</code> takes an <code>sfcr_mlt_shock</code> class
as the input of <code>expanded</code>, it must also take an object of
<code>sfcr_tbl</code> class as the input of <code>fixed</code>. It will simulate
multiple scenario models that takes the same baseline model
and diverge on the content of the multiple shocks provided with the
<code>expanded</code> argument that are applied to it.
</p>
</li>
<li> <p><code>sfcr_mlt</code>:
When the <code>sfcr_multis()</code> function takes a <code>sfcr_mlt</code> class
object as the input of the <code>expanded</code> argument, a <code>sfcr_shock</code>
object must be supplied with the <code>fixed</code> argument. This method
simulates multiple scenario models that applies the same shock to a
varying number of baseline models.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>João Macalós
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eqs &lt;- sfcr_set(
  TX_s ~ TX_d,
  YD ~ W * N_s - TX_s,
  C_d ~ alpha1 * YD + alpha2 * H_h[-1],
  H_h ~ YD - C_d + H_h[-1],
  N_s ~ N_d,
  N_d ~ Y / W,
  C_s ~ C_d,
  G_s ~ G_d,
  Y ~ C_s + G_s,
  TX_d ~ theta * W * N_s,
  H_s ~ G_d - TX_d + H_s[-1]
)

external &lt;- sfcr_set(G_d ~ 20, W ~ 1, alpha1 ~ 0.6, alpha2 ~ 0.4, theta ~ 0.2)

shock &lt;- sfcr_shock(
  variables = sfcr_set(
    alpha2 ~ 0.3
  ),
  start = 1,
  end = 3
)

baseline &lt;- sfcr_baseline(eqs, external, periods = 5)

# Example 1: Many external sets, 1 set of equations:
expanded1 &lt;- sfcr_expand(external, alpha1, c(0.7, 0.8))
multis1 &lt;- sfcr_multis(expanded = expanded1, fixed = eqs, periods = 5)

# Example 2: Many shocks, 1 baseline model:
expanded2 &lt;- sfcr_expand(shock, alpha2, c(0.1, 0.2))
multis2 &lt;- sfcr_multis(expanded = expanded2, fixed = baseline, periods = 5)

# Example 3: Many baseline models, 1 shock:
multis3 &lt;- sfcr_multis(expanded = multis1, fixed = shock, periods = 5)

</code></pre>

<hr>
<h2 id='sfcr_portfolio'>Find a valid matrix of portfolio parameters</h2><span id='topic+sfcr_portfolio'></span>

<h3>Description</h3>

<p>The <code>sfcr_portfolio()</code> function calculates a valid matrix of portfolio
parameters by applying the symmetry condition and then filling the missing
rows accordingly to the vertical and horizontal adding-up constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_portfolio(m, known)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_portfolio_+3A_m">m</code></td>
<td>
<p>A matrix of parameter names</p>
</td></tr>
<tr><td><code id="sfcr_portfolio_+3A_known">known</code></td>
<td>
<p>A named vector of known parameters. One entry for each symmetry
condition is enough to find a valid matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates only the values of the rates of return matrix, i.e.,
the internal matrix. The adding-up constraint number 1, that calculates the
share of assets in the net wealth and the impact of regular income to wealth
ratio must be calculated separately.
</p>
<p>If supplied with insufficient parameters, the function will return a
matrix with NA values.
</p>
<p>This function requires at least (n^2 - n)/2 known parameters to find a valid portfolio
matrix, where n is the number of rows/columns. This is achieved by setting known parameters
outside the diagonal and not on symmetrical entries, i.e., not lambda12 and lambda21, for
example.
</p>


<h3>Author(s)</h3>

<p>João Macalós
</p>


<h3>Examples</h3>

<pre><code class='language-R'>j1 &lt;- matrix(paste0("lambda", c(11:14, 21:24, 31:34, 41:44)), ncol = 4, nrow = 4, byrow = TRUE)
j2 &lt;- c(lambda12 = 0, lambda13 = 0, lambda14 = 0, lambda23 = -15, lambda24 = -15, lambda34 = -15)

sfcr_portfolio(j1, j2)

</code></pre>

<hr>
<h2 id='sfcr_random'>Generate random sequences inside <code>sfcr_set()</code></h2><span id='topic+sfcr_random'></span>

<h3>Description</h3>

<p>This function can only be used inside <code>sfcr_set()</code> when generating variables.
It smartly guesses the length of the <code>sfcr_baseline()</code> model or of the
<code>sfcr_shock()</code> that it is inserted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_random(.f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_random_+3A_.f">.f</code></td>
<td>
<p>This argument accepts three options: &quot;rnorm&quot;, &quot;rbinom&quot;, and &quot;runif&quot;,
and implement the respective functions from the built-in <code>stats</code> package.</p>
</td></tr>
<tr><td><code id="sfcr_random_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to the <code>stats</code> generator functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random normal series to pass along an endogenous series
# Example taken from model PC EXT 2.
sfcr_set(
    Ra ~ sfcr_random("rnorm", mean=0, sd=0.05)
)

</code></pre>

<hr>
<h2 id='sfcr_sankey'>Plot Sankey's diagram representation of transactions-flow matrix</h2><span id='topic+sfcr_sankey'></span>

<h3>Description</h3>

<p>Plot Sankey's diagram representation of transactions-flow matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_sankey(tfm, baseline, when = "start")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_sankey_+3A_tfm">tfm</code></td>
<td>
<p>A transactions-flow matrix</p>
</td></tr>
<tr><td><code id="sfcr_sankey_+3A_baseline">baseline</code></td>
<td>
<p>A baseline model</p>
</td></tr>
<tr><td><code id="sfcr_sankey_+3A_when">when</code></td>
<td>
<p>When the Sankey's diagram should be evaluated?
</p>

<ul>
<li><p> &quot;start&quot;: Fifth and fourth periods.
</p>
</li>
<li><p> &quot;end&quot;: last two periods of the simulation (stationary state).
</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='sfcr_scenario'>Add scenarios to a <code>sfcr</code> model.</h2><span id='topic+sfcr_scenario'></span>

<h3>Description</h3>

<p>Add scenarios to a <code>sfcr</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_scenario(
  baseline,
  scenario,
  periods,
  max_iter = 350,
  tol = 1e-10,
  method = "Broyden",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_scenario_+3A_baseline">baseline</code></td>
<td>
<p>A model generated with the <code>sfcr_baseline()</code> function.</p>
</td></tr>
<tr><td><code id="sfcr_scenario_+3A_scenario">scenario</code></td>
<td>
<p>Either a shock created with <code>sfcr_shock()</code>, a list of shocks,
or <code>NULL</code>. If <code>scenario = NULL</code>, the model will just extend the baseline
model.</p>
</td></tr>
<tr><td><code id="sfcr_scenario_+3A_periods">periods</code></td>
<td>
<p>A number specifying the total number of periods of the model to be simulated.</p>
</td></tr>
<tr><td><code id="sfcr_scenario_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum iterations allowed per period.</p>
</td></tr>
<tr><td><code id="sfcr_scenario_+3A_tol">tol</code></td>
<td>
<p>Tolerance accepted to determine convergence.</p>
</td></tr>
<tr><td><code id="sfcr_scenario_+3A_method">method</code></td>
<td>
<p>The method to use to find a solution. Defaults to &quot;Broyden&quot;.</p>
</td></tr>
<tr><td><code id="sfcr_scenario_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass to <code>rootSolve::multiroot()</code> function if &quot;Newton&quot; method
is selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Add scenario(s) to a model generated with <code>sfcr_baseline()</code> functions.
</p>
<p>This function inherits the block structure from the steady state model. See
<code><a href="#topic+sfcr_baseline">sfcr_baseline</a></code> for further details on the algorithms.
</p>


<h3>Author(s)</h3>

<p>João Macalós, <a href="mailto:joaomacalos@gmail.com">joaomacalos@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfcr_baseline">sfcr_baseline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eqs &lt;- sfcr_set(
  TX_s ~ TX_d,
  YD ~ W * N_s - TX_s,
  C_d ~ alpha1 * YD + alpha2 * H_h[-1],
  H_h ~ YD - C_d + H_h[-1],
  N_s ~ N_d,
  N_d ~ Y / W,
  C_s ~ C_d,
  G_s ~ G_d,
  Y ~ C_s + G_s,
  TX_d ~ theta * W * N_s,
  H_s ~ G_d - TX_d + H_s[-1]
)

external &lt;- sfcr_set(G_d ~ 20, W ~ 1, alpha1 ~ 0.6, alpha2 ~ 0.4, theta ~ 0.2)

# t is set to 10 to run faster. A usual model should run at least 50 periods to find a steady state
steady_state &lt;- sfcr_baseline(eqs, external, periods = 10)

# Increase G_d from 20 to 30 between periods 5 and 10
shock1 &lt;- sfcr_shock(sfcr_set(G_d ~ 30), 5, 10)

sfcr_scenario(steady_state, scenario = list(shock1), 10)

# Increase W to 2, alpha2 to 0.5, and decrease theta to 0.15
shock2 &lt;- sfcr_shock(
  variables = sfcr_set(
  W ~ 2,
  alpha2 ~ 0.5,
  theta ~ 0.15
  ),
  start = 5,
  end = 10)

sfcr_scenario(steady_state, list(shock2), 10)


</code></pre>

<hr>
<h2 id='sfcr_set'>Define the formulas of the model</h2><span id='topic+sfcr_set'></span>

<h3>Description</h3>

<p>The <code>sfcr_set()</code> function is used to create the lists of equations,
external variables, initial values, and also to modify the variables inside
the <code>sfcr_shock()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_set(..., exclude = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_set_+3A_...">...</code></td>
<td>
<p>The formulas used to define the equations and external
values of the system</p>
</td></tr>
<tr><td><code id="sfcr_set_+3A_exclude">exclude</code></td>
<td>
<p>One or more indices of equations to be excluded. The
correct indices can be found with <code>sfcr_set_index()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a S3 generic that applicable to only two inputs: <code>formula</code> and
<code>sfcr_set</code>. It is used to create a new set of equations or to modify an existing
one.
</p>
<p>Therefore, the equations must be written using the R formula syntax, i.e., the left-hand
side of each equation is separated from the right-hand side with a <code>~</code> (&quot;twiddle&quot;)
instead of a <code>=</code>.
</p>
<p>Furthermore, the <code>sfcr_set()</code> function recognizes two symbols that are not
native to R language: <code>[-1]</code>, and <code>d()</code>.
</p>

<ul>
<li><p> If a variable defined with <code>sfcr_set()</code> is followed by <code>[-1]</code>, it will
be recognized as a lagged variable.
</p>
</li>
<li><p> If a variable is defined inside <code>d()</code>, the <code>sfcr</code> engines will transform
them into a first difference equation. For example, <code>d(Hh)</code> is internally transformed
into <code>(Hh - Hh[-1])</code>.
</p>
</li></ul>

<p>Random variables can be created using the <code>sfcr_random()</code> function. See
<code><a href="#topic+sfcr_random">sfcr_random</a></code> for further details.
</p>


<h3>Author(s)</h3>

<p>João Macalós
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Endogenous set
equations &lt;- sfcr_set(
  TXs ~ TXd,
  YD ~ W * Ns - TXs,
  Cd ~ alpha1 * YD + alpha2 * Hh[-1],
  Hh ~ YD - Cd + Hh[-1],
  Ns ~ Nd,
  Nd ~ Y / W,
  Cs ~ Cd,
  Gs ~ Gd,
  Y ~ Cs + Gs,
  TXd ~ theta * W * Ns,
  Hs ~ Gd - TXd + Hs[-1]
  )

# Exogenous set
exogenous &lt;- sfcr_set(alpha1 ~ 0.8, alpha2 ~ 0.15)

# Modify an existing set
equations2 &lt;- sfcr_set(equations, Hh ~ Hh[-1] + d(Hs), exclude = 4)

# Add normal random variable
sfcr_set(Ra ~ sfcr_random("rnorm", mean=10, sd=2))

</code></pre>

<hr>
<h2 id='sfcr_set_index'>Get names of endogenous vars and their index</h2><span id='topic+sfcr_set_index'></span>

<h3>Description</h3>

<p>The <code>sfcr_set_index()</code> function takes a list of equations as its input and returns
a tibble containing the name of the variable on the left-hand side of the equations
and their position in the equations list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_set_index(eqs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_set_index_+3A_eqs">eqs</code></td>
<td>
<p>A list of equations created with <code>sfcr_set()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function aims to facilitate locating a specific equation in the list in order to
modify the list of equations.
</p>
<p>To add random variation to endogenous variables, use <code>sfcr_random()</code>.
</p>


<h3>Author(s)</h3>

<p>João Macalós
</p>

<hr>
<h2 id='sfcr_shock'>Create shock(s) to add to a <code>sfcr_scenario()</code>.</h2><span id='topic+sfcr_shock'></span>

<h3>Description</h3>

<p>Create shock(s) to add to a <code>sfcr_scenario()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_shock(variables, start, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_shock_+3A_variables">variables</code></td>
<td>
<p>A <code>sfcr_set()</code> with formula(e) containing the name of the variable(s)
that will be shocked on the left-hand side and their new values on the right-
hand side.
</p>
<p>It is possible to add exogenous series a shock instead of constant variables.
However, the length of such series must be exactly the same as the period of the shock (i.e.,
the difference between start and end).</p>
</td></tr>
<tr><td><code id="sfcr_shock_+3A_start">start</code></td>
<td>
<p>An integer indicating the period when the shock takes place.</p>
</td></tr>
<tr><td><code id="sfcr_shock_+3A_end">end</code></td>
<td>
<p>An integer indicating the period when the shock ends.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>João Macalós, <a href="mailto:joaomacalos@gmail.com">joaomacalos@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfcr_shock(
 variables = sfcr_set(G_d ~ 30, W ~ 1.5),
 start = 5,
 end = 66)

sfcr_shock(
 variables = sfcr_set(G_d ~ seq(30, 40, length.out=62)),
 start = 5,
 end = 66)

</code></pre>

<hr>
<h2 id='sfcr_validate'>Validate a transactions-flow or balance-sheet matrix</h2><span id='topic+sfcr_validate'></span>

<h3>Description</h3>

<p>This function validates a transactions-flow or balance-sheet
matrix with the simulated data obtained with <code>sfcr_baseline()</code>
function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfcr_validate(matrix, baseline, which, tol = 1, rtol = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfcr_validate_+3A_matrix">matrix</code></td>
<td>
<p>A transactions-flow or balance sheet matrix</p>
</td></tr>
<tr><td><code id="sfcr_validate_+3A_baseline">baseline</code></td>
<td>
<p>A baseline model.</p>
</td></tr>
<tr><td><code id="sfcr_validate_+3A_which">which</code></td>
<td>
<p>Either &quot;bs&quot; (balance-sheet matrix) or &quot;tfm&quot; (transactions-flow matrix).</p>
</td></tr>
<tr><td><code id="sfcr_validate_+3A_tol">tol</code></td>
<td>
<p>A numerical value indicating the absolute accepted discrepancy accepted
to validate whether the rows and columns are equal to their expected values.</p>
</td></tr>
<tr><td><code id="sfcr_validate_+3A_rtol">rtol</code></td>
<td>
<p>A logical value indicating whether relative discrepancies should be
evaluated. It defaults to <code>FALSE</code>. Stationary models should pass the test using
a absolute level while growth models might need a relative validation since computational
discrepancies tend to get larger with the model. See details for further information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relative discrepancy is calculated differently if we are dealing with a
transactions-flow matrix or with a balance-sheet matrix. If <code>which</code> is set to <code>tfm</code>,
the sum of the row/column is evaluated against the sum of the positive entries of that row/column.
</p>
<p>For example, in a transactions-flow matrix with three entries in the &quot;change in the stock of bills&quot;
row (-Delta (Bhd), + Delta (Bs), and + Delta (Bbd)), the discrepancy d = Delta Bs - Delta Bhd - Delta Bbd
is evaluated against Delta Bs, i.e., the row is validated if d/Delta Bs &lt; tol.
</p>
<p>In a balance-sheet matrix, all the rows/columns that sum to zero are validated exactly as
in a transactions-flow matrix. The exception to this rule is when there is a expected value. In this case,
the discrepancy is evaluated as a proportion of the expected. value
</p>
<p>To prevent unnecessary calculations, a absolute check with tolerance defined as 1e-3 is executed
prior to this evaluation.
</p>
<p>The absolute discrepancy set with <code>tol</code> should be enough to validate
a stationary SFC Model.
</p>


<h3>Author(s)</h3>

<p>João Macalós
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
