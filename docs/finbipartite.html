<!DOCTYPE html><html><head><title>Help for package finbipartite</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {finbipartite}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#learn_bipartite_graph_nie'><p>Laplacian matrix of a k-component bipartite graph via Nie's method</p>
</p>
<p>Computes the Laplacian matrix of a bipartite graph on the basis of an observed similarity matrix.</p></a></li>
<li><a href='#learn_connected_bipartite_graph_pgd'><p>Laplacian matrix of a connected bipartite graph with Gaussian data</p>
</p>
<p>Computes the Laplacian matrix of a bipartite graph on the basis of an observed data matrix.</p></a></li>
<li><a href='#learn_heavy_tail_bipartite_graph_pgd'><p>Laplacian matrix of a connected bipartite graph with heavy-tailed data</p>
</p>
<p>Computes the Laplacian matrix of a bipartite graph on the basis of an observed data matrix</p>
whose distribution is assumed to be Student-t.</a></li>
<li><a href='#learn_heavy_tail_kcomp_bipartite_graph'><p>Laplacian matrix of a k-component bipartite graph with heavy-tailed data</p>
</p>
<p>Computes the Laplacian matrix of a k-component bipartite graph on the basis of an observed data matrix</p>
whose distribution is assumed to be Student-t.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Learning Bipartite Graphs: Heavy Tails and Multiple Components</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-02</td>
</tr>
<tr>
<td>Description:</td>
<td>Learning bipartite and k-component bipartite graphs from financial
     datasets. This package contains implementations of the algorithms described
     in the paper: Cardoso JVM, Ying J, and Palomar DP (2022).
     <a href="https://openreview.net/pdf?id=WNSyF9qZaMd">https://openreview.net/pdf?id=WNSyF9qZaMd</a>
     "Learning bipartite graphs: heavy tails and multiple components,
     Advances in Neural Informations Processing Systems" (NeurIPS).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/convexfi/bipartite/">https://github.com/convexfi/bipartite/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/convexfi/bipartite/issues">https://github.com/convexfi/bipartite/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>spectralGraphTopology, quadprog</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, stats, progress, mvtnorm, CVXR</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, igraph,</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-21 03:43:22 UTC; mirca</td>
</tr>
<tr>
<td>Author:</td>
<td>Ze Vinicius [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ze Vinicius &lt;jvmirca@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-22 14:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='learn_bipartite_graph_nie'>Laplacian matrix of a k-component bipartite graph via Nie's method
Computes the Laplacian matrix of a bipartite graph on the basis of an observed similarity matrix.</h2><span id='topic+learn_bipartite_graph_nie'></span>

<h3>Description</h3>

<p>Laplacian matrix of a k-component bipartite graph via Nie's method
</p>
<p>Computes the Laplacian matrix of a bipartite graph on the basis of an observed similarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>learn_bipartite_graph_nie(
  S,
  r,
  q,
  k,
  learning_rate = 1e-04,
  eta = 1,
  maxiter = 1000,
  reltol = 1e-06,
  verbose = TRUE,
  record_objective = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learn_bipartite_graph_nie_+3A_s">S</code></td>
<td>
<p>a p x p similarity matrix, where p is the number of nodes in the graph.</p>
</td></tr>
<tr><td><code id="learn_bipartite_graph_nie_+3A_r">r</code></td>
<td>
<p>number of nodes in the objects set.</p>
</td></tr>
<tr><td><code id="learn_bipartite_graph_nie_+3A_q">q</code></td>
<td>
<p>number of nodes in the classes set.</p>
</td></tr>
<tr><td><code id="learn_bipartite_graph_nie_+3A_k">k</code></td>
<td>
<p>number of components of the graph.</p>
</td></tr>
<tr><td><code id="learn_bipartite_graph_nie_+3A_learning_rate">learning_rate</code></td>
<td>
<p>gradient descent parameter.</p>
</td></tr>
<tr><td><code id="learn_bipartite_graph_nie_+3A_eta">eta</code></td>
<td>
<p>rank constraint hyperparameter.</p>
</td></tr>
<tr><td><code id="learn_bipartite_graph_nie_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="learn_bipartite_graph_nie_+3A_reltol">reltol</code></td>
<td>
<p>relative tolerance as a convergence criteria.</p>
</td></tr>
<tr><td><code id="learn_bipartite_graph_nie_+3A_verbose">verbose</code></td>
<td>
<p>whether or not to show a progress bar during the iterations.</p>
</td></tr>
<tr><td><code id="learn_bipartite_graph_nie_+3A_record_objective">record_objective</code></td>
<td>
<p>whether or not to record the objective function value during iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing possibly the following elements:
</p>
<table>
<tr><td><code>laplacian</code></td>
<td>
<p>estimated Laplacian matrix</p>
</td></tr>
<tr><td><code>adjacency</code></td>
<td>
<p>estimated adjacency matrix</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>estimated graph weights matrix</p>
</td></tr>
<tr><td><code>maxiter</code></td>
<td>
<p>number of iterations taken to reach convergence</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>boolean flag to indicate whether or not the optimization converged</p>
</td></tr>
<tr><td><code>obj_fun</code></td>
<td>
<p>objective function value per iteration</p>
</td></tr>
</table>


<h3>References</h3>

<p>Feiping Nie, Xiaoqian Wang, Cheng Deng, Heng Huang.
&quot;Learning A Structured Optimal Bipartite Graph for Co-Clustering&quot;.
Advances in Neural Information Processing Systems (NIPS 2017)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(finbipartite)
library(igraph)
set.seed(42)
r &lt;- 50
q &lt;- 5
p &lt;- r + q

bipartite &lt;- sample_bipartite(r, q, type="Gnp", p = 1, directed=FALSE)
# randomly assign edge weights to connected nodes
E(bipartite)$weight &lt;- 1
Lw &lt;- as.matrix(laplacian_matrix(bipartite))
B &lt;- -Lw[1:r, (r+1):p]
B[,] &lt;- runif(length(B))
B &lt;- B / rowSums(B)
# utils functions
from_B_to_laplacian &lt;- function(B) {
  A &lt;- from_B_to_adjacency(B)
  return(diag(rowSums(A)) - A)
}

from_B_to_adjacency &lt;- function(B) {
  r &lt;- nrow(B)
  q &lt;- ncol(B)
  zeros_rxr &lt;- matrix(0, r, r)
  zeros_qxq &lt;- matrix(0, q, q)
  return(rbind(cbind(zeros_rxr, B), cbind(t(B), zeros_qxq)))
}
Ltrue &lt;- from_B_to_laplacian(B)
X &lt;- MASS::mvrnorm(100*p, rep(0, p), MASS::ginv(Ltrue))
S &lt;- cov(X)
bipartite_graph &lt;- learn_bipartite_graph_nie(S = S,
                                             r = r,
                                             q = q,
                                             k = 1,
                                             learning_rate = 5e-1,
                                             eta = 0,
                                             verbose=FALSE)
</code></pre>

<hr>
<h2 id='learn_connected_bipartite_graph_pgd'>Laplacian matrix of a connected bipartite graph with Gaussian data
Computes the Laplacian matrix of a bipartite graph on the basis of an observed data matrix.</h2><span id='topic+learn_connected_bipartite_graph_pgd'></span>

<h3>Description</h3>

<p>Laplacian matrix of a connected bipartite graph with Gaussian data
</p>
<p>Computes the Laplacian matrix of a bipartite graph on the basis of an observed data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>learn_connected_bipartite_graph_pgd(
  S,
  r,
  q,
  init = "naive",
  learning_rate = 1e-04,
  maxiter = 1000,
  reltol = 1e-05,
  verbose = TRUE,
  record_objective = FALSE,
  backtrack = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learn_connected_bipartite_graph_pgd_+3A_s">S</code></td>
<td>
<p>a p x p covariance matrix, where p is the number of nodes in the graph.</p>
</td></tr>
<tr><td><code id="learn_connected_bipartite_graph_pgd_+3A_r">r</code></td>
<td>
<p>number of nodes in the objects set.</p>
</td></tr>
<tr><td><code id="learn_connected_bipartite_graph_pgd_+3A_q">q</code></td>
<td>
<p>number of nodes in the classes set.</p>
</td></tr>
<tr><td><code id="learn_connected_bipartite_graph_pgd_+3A_init">init</code></td>
<td>
<p>string denoting how to compute the initial graph.</p>
</td></tr>
<tr><td><code id="learn_connected_bipartite_graph_pgd_+3A_learning_rate">learning_rate</code></td>
<td>
<p>gradient descent parameter.</p>
</td></tr>
<tr><td><code id="learn_connected_bipartite_graph_pgd_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="learn_connected_bipartite_graph_pgd_+3A_reltol">reltol</code></td>
<td>
<p>relative tolerance as a convergence criteria.</p>
</td></tr>
<tr><td><code id="learn_connected_bipartite_graph_pgd_+3A_verbose">verbose</code></td>
<td>
<p>whether or not to show a progress bar during the iterations.</p>
</td></tr>
<tr><td><code id="learn_connected_bipartite_graph_pgd_+3A_record_objective">record_objective</code></td>
<td>
<p>whether or not to record the objective function value during iterations.</p>
</td></tr>
<tr><td><code id="learn_connected_bipartite_graph_pgd_+3A_backtrack">backtrack</code></td>
<td>
<p>whether or not to optimize the learning rate via backtracking.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing possibly the following elements:
</p>
<table>
<tr><td><code>laplacian</code></td>
<td>
<p>estimated Laplacian matrix</p>
</td></tr>
<tr><td><code>adjacency</code></td>
<td>
<p>estimated adjacency matrix</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>estimated graph weights matrix</p>
</td></tr>
<tr><td><code>maxiter</code></td>
<td>
<p>number of iterations taken to reach convergence</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>boolean flag to indicate whether or not the optimization converged</p>
</td></tr>
<tr><td><code>lr_seq</code></td>
<td>
<p>learning rate value per iteration</p>
</td></tr>
<tr><td><code>obj_seq</code></td>
<td>
<p>objective function value per iteration</p>
</td></tr>
<tr><td><code>elapsed_time</code></td>
<td>
<p>time taken per iteration until convergence is reached</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(finbipartite)
library(igraph)
set.seed(42)
r &lt;- 50
q &lt;- 5
p &lt;- r + q

bipartite &lt;- sample_bipartite(r, q, type="Gnp", p = 1, directed=FALSE)
# randomly assign edge weights to connected nodes
E(bipartite)$weight &lt;- 1
Lw &lt;- as.matrix(laplacian_matrix(bipartite))
B &lt;- -Lw[1:r, (r+1):p]
B[,] &lt;- runif(length(B))
B &lt;- B / rowSums(B)
# utils functions
from_B_to_laplacian &lt;- function(B) {
  A &lt;- from_B_to_adjacency(B)
  return(diag(rowSums(A)) - A)
}

from_B_to_adjacency &lt;- function(B) {
  r &lt;- nrow(B)
  q &lt;- ncol(B)
  zeros_rxr &lt;- matrix(0, r, r)
  zeros_qxq &lt;- matrix(0, q, q)
  return(rbind(cbind(zeros_rxr, B), cbind(t(B), zeros_qxq)))
}
Ltrue &lt;- from_B_to_laplacian(B)
X &lt;- MASS::mvrnorm(100*p, rep(0, p), MASS::ginv(Ltrue))
S &lt;- cov(X)
bipartite_graph &lt;- learn_connected_bipartite_graph_pgd(S = S,
                                                       r = r,
                                                       q = q,
                                                       verbose=FALSE)
</code></pre>

<hr>
<h2 id='learn_heavy_tail_bipartite_graph_pgd'>Laplacian matrix of a connected bipartite graph with heavy-tailed data
Computes the Laplacian matrix of a bipartite graph on the basis of an observed data matrix
whose distribution is assumed to be Student-t.</h2><span id='topic+learn_heavy_tail_bipartite_graph_pgd'></span>

<h3>Description</h3>

<p>Laplacian matrix of a connected bipartite graph with heavy-tailed data
</p>
<p>Computes the Laplacian matrix of a bipartite graph on the basis of an observed data matrix
whose distribution is assumed to be Student-t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>learn_heavy_tail_bipartite_graph_pgd(
  X,
  r,
  q,
  nu = 2.001,
  learning_rate = 1e-04,
  maxiter = 1000,
  reltol = 1e-05,
  init = "default",
  verbose = TRUE,
  record_objective = FALSE,
  backtrack = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learn_heavy_tail_bipartite_graph_pgd_+3A_x">X</code></td>
<td>
<p>a n x p data matrix, where p is the number of nodes in the graph and n is the number of observations.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_bipartite_graph_pgd_+3A_r">r</code></td>
<td>
<p>number of nodes in the objects set.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_bipartite_graph_pgd_+3A_q">q</code></td>
<td>
<p>number of nodes in the classes set.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_bipartite_graph_pgd_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom of the Student-t distribution.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_bipartite_graph_pgd_+3A_learning_rate">learning_rate</code></td>
<td>
<p>gradient descent parameter.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_bipartite_graph_pgd_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_bipartite_graph_pgd_+3A_reltol">reltol</code></td>
<td>
<p>relative tolerance as a convergence criteria.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_bipartite_graph_pgd_+3A_init">init</code></td>
<td>
<p>string denoting how to compute the initial graph or a r x q matrix with initial graph weights.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_bipartite_graph_pgd_+3A_verbose">verbose</code></td>
<td>
<p>whether or not to show a progress bar during the iterations.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_bipartite_graph_pgd_+3A_record_objective">record_objective</code></td>
<td>
<p>whether or not to record the objective function value during iterations.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_bipartite_graph_pgd_+3A_backtrack">backtrack</code></td>
<td>
<p>whether or not to optimize the learning rate via backtracking.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing possibly the following elements:
</p>
<table>
<tr><td><code>laplacian</code></td>
<td>
<p>estimated Laplacian matrix</p>
</td></tr>
<tr><td><code>adjacency</code></td>
<td>
<p>estimated adjacency matrix</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>estimated graph weights matrix</p>
</td></tr>
<tr><td><code>maxiter</code></td>
<td>
<p>number of iterations taken to reach convergence</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>boolean flag to indicate whether or not the optimization converged</p>
</td></tr>
<tr><td><code>lr_seq</code></td>
<td>
<p>learning rate value per iteration</p>
</td></tr>
<tr><td><code>obj_seq</code></td>
<td>
<p>objective function value per iteration</p>
</td></tr>
<tr><td><code>elapsed_time</code></td>
<td>
<p>time taken per iteration until convergence is reached</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(finbipartite)
library(igraph)
set.seed(42)
r &lt;- 50
q &lt;- 5
p &lt;- r + q

bipartite &lt;- sample_bipartite(r, q, type="Gnp", p = 1, directed=FALSE)
# randomly assign edge weights to connected nodes
E(bipartite)$weight &lt;- 1
Lw &lt;- as.matrix(laplacian_matrix(bipartite))
B &lt;- -Lw[1:r, (r+1):p]
B[,] &lt;- runif(length(B))
B &lt;- B / rowSums(B)
# utils functions
from_B_to_laplacian &lt;- function(B) {
  A &lt;- from_B_to_adjacency(B)
  return(diag(rowSums(A)) - A)
}

from_B_to_adjacency &lt;- function(B) {
  r &lt;- nrow(B)
  q &lt;- ncol(B)
  zeros_rxr &lt;- matrix(0, r, r)
  zeros_qxq &lt;- matrix(0, q, q)
  return(rbind(cbind(zeros_rxr, B), cbind(t(B), zeros_qxq)))
}
Ltrue &lt;- from_B_to_laplacian(B)
X &lt;- MASS::mvrnorm(100*p, rep(0, p), MASS::ginv(Ltrue))
bipartite_graph &lt;- learn_heavy_tail_bipartite_graph_pgd(X = X,
                                                        r = r,
                                                        q = q,
                                                        nu = 1e2,
                                                        verbose=FALSE)
</code></pre>

<hr>
<h2 id='learn_heavy_tail_kcomp_bipartite_graph'>Laplacian matrix of a k-component bipartite graph with heavy-tailed data
Computes the Laplacian matrix of a k-component bipartite graph on the basis of an observed data matrix
whose distribution is assumed to be Student-t.</h2><span id='topic+learn_heavy_tail_kcomp_bipartite_graph'></span>

<h3>Description</h3>

<p>Laplacian matrix of a k-component bipartite graph with heavy-tailed data
</p>
<p>Computes the Laplacian matrix of a k-component bipartite graph on the basis of an observed data matrix
whose distribution is assumed to be Student-t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>learn_heavy_tail_kcomp_bipartite_graph(
  X,
  r,
  q,
  k,
  nu = 2.001,
  rho = 1,
  learning_rate = 1e-04,
  maxiter = 1000,
  reltol = 1e-05,
  init = "default",
  verbose = TRUE,
  record_objective = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learn_heavy_tail_kcomp_bipartite_graph_+3A_x">X</code></td>
<td>
<p>a n x p data matrix, where p is the number of nodes in the graph and n is the number of observations.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_kcomp_bipartite_graph_+3A_r">r</code></td>
<td>
<p>number of nodes in the objects set.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_kcomp_bipartite_graph_+3A_q">q</code></td>
<td>
<p>number of nodes in the classes set.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_kcomp_bipartite_graph_+3A_k">k</code></td>
<td>
<p>number of components of the graph.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_kcomp_bipartite_graph_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom of the Student-t distribution.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_kcomp_bipartite_graph_+3A_rho">rho</code></td>
<td>
<p>ADMM hyperparameter.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_kcomp_bipartite_graph_+3A_learning_rate">learning_rate</code></td>
<td>
<p>gradient descent parameter.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_kcomp_bipartite_graph_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_kcomp_bipartite_graph_+3A_reltol">reltol</code></td>
<td>
<p>relative tolerance as a convergence criteria.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_kcomp_bipartite_graph_+3A_init">init</code></td>
<td>
<p>string denoting how to compute the initial graph or a r x q matrix with initial graph weights.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_kcomp_bipartite_graph_+3A_verbose">verbose</code></td>
<td>
<p>whether or not to show a progress bar during the iterations.</p>
</td></tr>
<tr><td><code id="learn_heavy_tail_kcomp_bipartite_graph_+3A_record_objective">record_objective</code></td>
<td>
<p>whether or not to record the objective function value during iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing possibly the following elements:
</p>
<table>
<tr><td><code>laplacian</code></td>
<td>
<p>estimated Laplacian matrix</p>
</td></tr>
<tr><td><code>adjacency</code></td>
<td>
<p>estimated adjacency matrix</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>estimated graph weights matrix</p>
</td></tr>
<tr><td><code>maxiter</code></td>
<td>
<p>number of iterations taken to reach convergence</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>boolean flag to indicate whether or not the optimization converged</p>
</td></tr>
<tr><td><code>dual_residual</code></td>
<td>
<p>dual residual value per iteration</p>
</td></tr>
<tr><td><code>primal_residual</code></td>
<td>
<p>primal residual value per iteration</p>
</td></tr>
<tr><td><code>aug_lag</code></td>
<td>
<p>augmented Lagrangian value per iteration</p>
</td></tr>
<tr><td><code>rho_seq</code></td>
<td>
<p>constraint relaxation hyperparameter value per iteration</p>
</td></tr>
<tr><td><code>elapsed_time</code></td>
<td>
<p>time taken per iteration until convergence is reached</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(finbipartite)
library(igraph)
set.seed(42)
r &lt;- 50
q &lt;- 5
p &lt;- r + q

bipartite &lt;- sample_bipartite(r, q, type="Gnp", p = 1, directed=FALSE)
# randomly assign edge weights to connected nodes
E(bipartite)$weight &lt;- 1
Lw &lt;- as.matrix(laplacian_matrix(bipartite))
B &lt;- -Lw[1:r, (r+1):p]
B[,] &lt;- runif(length(B))
B &lt;- B / rowSums(B)
# utils functions
from_B_to_laplacian &lt;- function(B) {
  A &lt;- from_B_to_adjacency(B)
  return(diag(rowSums(A)) - A)
}

from_B_to_adjacency &lt;- function(B) {
  r &lt;- nrow(B)
  q &lt;- ncol(B)
  zeros_rxr &lt;- matrix(0, r, r)
  zeros_qxq &lt;- matrix(0, q, q)
  return(rbind(cbind(zeros_rxr, B), cbind(t(B), zeros_qxq)))
}
Ltrue &lt;- from_B_to_laplacian(B)
X &lt;- MASS::mvrnorm(100*p, rep(0, p), MASS::ginv(Ltrue))
bipartite_graph &lt;- learn_heavy_tail_kcomp_bipartite_graph(X = X,
                                                          r = r,
                                                          q = q,
                                                          k = 1,
                                                          nu = 1e2,
                                                          verbose=FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
