<!DOCTYPE html><html><head><title>Help for package RProtoBuf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RProtoBuf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RProtoBuf-package'><p>R Interface to the Protocol Buffers API</p></a></li>
<li><a href='#add-methods'><p>add elements of a repeated field of a message</p></a></li>
<li><a href='#ArrayInputStream-class'><p>Class &quot;ArrayInputStream&quot;</p></a></li>
<li><a href='#ArrayInputStream-methods'><p>Creates an ArrayInputStream</p></a></li>
<li><a href='#ArrayOutputStream-class'><p>Class &quot;ArrayOutputStream&quot;</p></a></li>
<li><a href='#ArrayOutputStream-methods'><p>Creates an ArrayOutputStream</p></a></li>
<li><a href='#as.list.Message'>
<p>Grab the protocol buffer message as an R list</p></a></li>
<li><a href='#asMessage'>
<p>coerce an object to a protobuf message</p></a></li>
<li><a href='#BackUp-methods'><p>Backs up a number of bytes from a stream</p></a></li>
<li><a href='#ByteCount-methods'><p>The number of bytes read/written since the object was created</p></a></li>
<li><a href='#bytesize-methods'><p>The number of bytes taken by a message</p></a></li>
<li><a href='#clear-methods'><p>Clear a field or all fields of the message and set them to their default values</p></a></li>
<li><a href='#clone-methods'><p>Clone protocol buffer messages</p></a></li>
<li><a href='#completion'>
<p>Completion support for protocol buffer messages and descriptors</p></a></li>
<li><a href='#ConnectionInputStream-class'><p>Class &quot;ConnectionInputStream&quot;</p></a></li>
<li><a href='#ConnectionInputStream-methods'><p>Creates an ConnectionInputStream</p></a></li>
<li><a href='#ConnectionOutputStream-class'><p>Class &quot;ConnectionOutputStream&quot;</p></a></li>
<li><a href='#ConnectionOutputStream-methods'><p>Creates an ConnectionOutputStream</p></a></li>
<li><a href='#containing_type-methods'><p>Gets the message type descriptor that contains a descriptor</p></a></li>
<li><a href='#Descriptor-class'><p>Class &quot;Descriptor&quot;</p></a></li>
<li><a href='#descriptor-methods'><p>Get the descriptor of a message</p></a></li>
<li><a href='#enum_type_count-methods'><p>The number of enum types</p></a></li>
<li><a href='#enum_type-methods'><p>Extract an enum type descriptor for a nested type</p></a></li>
<li><a href='#EnumDescriptor-class'><p>Class &quot;EnumDescriptor&quot;</p></a></li>
<li><a href='#EnumValueDescriptor-class'><p>Class &quot;EnumValueDescriptor&quot;</p></a></li>
<li><a href='#fetch-methods'><p>Fetch content of a repeated field</p></a></li>
<li><a href='#field_count-methods'><p>The number of fields</p></a></li>
<li><a href='#field-methods'><p>Extract a field descriptor</p></a></li>
<li><a href='#FieldDescriptor-class'><p>Class &quot;FieldDescriptor&quot;</p></a></li>
<li><a href='#FileDescriptor-class'><p>Class &quot;FileDescriptor&quot;</p></a></li>
<li><a href='#fileDescriptor-methods'><p>gets the file descriptor of an object</p></a></li>
<li><a href='#FileInputStream-class'><p>Class &quot;FileInputStream&quot;</p></a></li>
<li><a href='#FileInputStream-methods'><p>Creates an FileInputStream</p></a></li>
<li><a href='#FileOutputStream-class'><p>Class &quot;FileOutputStream&quot;</p></a></li>
<li><a href='#FileOutputStream-methods'><p>Creates an FileOutputStream</p></a></li>
<li><a href='#GetErrno-methods'><p>Get the error number for an I/O error</p></a></li>
<li><a href='#has-methods'><p>Indicates if an object has the given field set</p></a></li>
<li><a href='#is_extension-methods'><p>Indicates if a field descriptor is an extension</p></a></li>
<li><a href='#isInitialized-methods'><p>Indicates if a protocol buffer message is initialized</p></a></li>
<li><a href='#label-methods'><p>Gets the label of a field</p></a></li>
<li><a href='#merge-methods'><p>Merge two messages of the same type</p></a></li>
<li><a href='#Message-class'><p>Class &quot;Message&quot;</p></a></li>
<li><a href='#MethodDescriptor-class'><p>Class &quot;MethodDescriptor&quot;</p></a></li>
<li><a href='#name'><p>Name or full name of a descriptor</p></a></li>
<li><a href='#nested_type_count-methods'><p>The number of fields</p></a></li>
<li><a href='#nested_type-methods'><p>Extract a message type descriptor for a nested type</p></a></li>
<li><a href='#Next-methods'><p>Obtains a chunk of data from the stream</p></a></li>
<li><a href='#number-methods'><p>Gets the declared tag number of a field</p></a></li>
<li><a href='#P'><p>Protocol Buffer descriptor importer</p></a></li>
<li><a href='#read-methods'><p>Read a protocol buffer message from a connection</p></a></li>
<li><a href='#readASCII-methods'><p>read a message in ASCII format</p></a></li>
<li><a href='#readJSON-methods'><p>read a message in JSON format</p></a></li>
<li><a href='#readProtoFiles'><p>protocol buffer descriptor importer</p></a></li>
<li><a href='#serialize_pb'><p>Serialize R object to Protocol Buffer Message.</p></a></li>
<li><a href='#ServiceDescriptor-class'><p>Class &quot;ServiceDescriptor&quot;</p></a></li>
<li><a href='#set-methods'><p>set a subset of values of a repeated field of a message</p></a></li>
<li><a href='#SetCloseOnDelete-methods'><p>set the close on delete behavior</p></a></li>
<li><a href='#size-methods'><p>Size of a message field</p></a></li>
<li><a href='#sizegets'><p>Set the size of a field</p></a></li>
<li><a href='#Skip-methods'><p>Skips a number of bytes</p></a></li>
<li><a href='#swap-methods'><p>swap elements of a repeated field of a message</p></a></li>
<li><a href='#type-methods'><p>Gets the type or the C++ type of a field</p></a></li>
<li><a href='#with.Message'>
<p>with and within methods for protocol buffer messages</p></a></li>
<li><a href='#ZeroCopyInputStream-class'><p>Virtual Class &quot;ZeroCopyInputStream&quot;</p></a></li>
<li><a href='#ZeroCopyOutputStream-class'><p>Virtual Class &quot;ZeroCopyOutputStream&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.4.22</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Romain Francois, Dirk Eddelbuettel, Murray Stokely and Jeroen Ooms</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dirk Eddelbuettel &lt;edd@debian.org&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>R Interface to the 'Protocol Buffers' 'API' (Version 2 or 3)</td>
</tr>
<tr>
<td>Description:</td>
<td>Protocol Buffers are a way of encoding structured data in an
 efficient yet extensible format. Google uses Protocol Buffers for almost all
 of its internal 'RPC' protocols and file formats.  Additional documentation
 is available in two included vignettes one of which corresponds to our 'JSS'
 paper (2016, &lt;<a href="https://doi.org/10.18637%2Fjss.v071.i02">doi:10.18637/jss.v071.i02</a>&gt;. A sufficiently recent version of
 'Protocol Buffers' library is required; currently version 3.3.0 from 2017
 is the stated minimum.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, tools, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>ProtoBuf libraries and compiler version 3.3.0 or
later; On Debian/Ubuntu these can be installed as
libprotoc-dev, libprotobuf-dev and protobuf-compiler, while on
Fedora/CentOS protobuf-devel and protobuf-compiler are needed.
A C++17 compiler is required as well.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eddelbuettel/rprotobuf/issues">https://github.com/eddelbuettel/rprotobuf/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/eddelbuettel/rprotobuf">https://github.com/eddelbuettel/rprotobuf</a>,
<a href="https://dirk.eddelbuettel.com/code/rprotobuf.html">https://dirk.eddelbuettel.com/code/rprotobuf.html</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-20 13:44:18 UTC; edd</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-21 13:42:45 UTC</td>
</tr>
</table>
<hr>
<h2 id='RProtoBuf-package'>R Interface to the Protocol Buffers API</h2><span id='topic+RProtoBuf-package'></span><span id='topic+RProtoBuf'></span>

<h3>Description</h3>

<p>Protocol Buffers are a way of encoding structured data in an
efficient yet extensible format. Google uses Protocol Buffers for almost all
of its internal RPC protocols and file formats.
</p>
<p>This package provides R API to create, manipulate, parse and serialize
protocol buffer messages from R
</p>


<h3>Author(s)</h3>

<p>Romain Francois, Dirk Eddelbuettel, Murray Stokely and Jeroen Ooms.</p>


<h3>References</h3>

<p><a href="https://github.com/eddelbuettel/rprotobuf">https://github.com/eddelbuettel/rprotobuf</a></p>


<h3>See Also</h3>

<p><a href="#topic+Message-class">Message</a> for some examples</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# an example proto file
system.file( "proto", "addressbook.proto", package = "RProtoBuf" )

# create a message of type AddressBook, defined in the example proto file
demo( "addressbook", package = "RProtoBuf" )

# using R binary connections and files to read and write messages
demo( "io", package = "RProtoBuf" )

# more documentation in the vignette
vignette( "RProtoBuf", package = "RProtoBuf" )

## End(Not run)
</code></pre>

<hr>
<h2 id='add-methods'>add elements of a repeated field of a message</h2><span id='topic+add'></span><span id='topic+add-methods'></span><span id='topic+add+2CMessage-method'></span>

<h3>Description</h3>

<p>Add elements to a repeated field of a message.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Message")</code></dt><dd><p>add elements to a repeated field of a message</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>unitest.proto.file &lt;- system.file("tinytest", "data", "unittest.proto",
				  package = "RProtoBuf" )
readProtoFiles(file = unitest.proto.file)

test &lt;- new(protobuf_unittest.TestAllTypes)
test$add("repeated_int32", 1)
test$add("repeated_int32", 2:10)
test$repeated_int32
</code></pre>

<hr>
<h2 id='ArrayInputStream-class'>Class &quot;ArrayInputStream&quot;  </h2><span id='topic+ArrayInputStream-class'></span>

<h3>Description</h3>

<p>A <a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a> backed by an in-memory array of bytes</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by the <a href="#topic+ArrayInputStream">ArrayInputStream</a> function
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p> External pointer to the <code>google::protobuf::io::ArrayInputStream</code> C++ object</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>See <a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a>
</p>


<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>References</h3>

<p> The <code>ArrayInputStream</code> class from the protobuf C++ library.</p>


<h3>See Also</h3>

<p><a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a> for methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- ArrayInputStream(as.raw(0:10))
stream$ReadRaw(5)

stringsstream &lt;- ArrayInputStream(as.raw(c(0x74, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67)))
stringsstream$ReadString(7)

intstream &lt;- ArrayInputStream(as.raw(c(0x9e, 0xa7, 0x05)))
intstream$ReadVarint32()
</code></pre>

<hr>
<h2 id='ArrayInputStream-methods'>Creates an ArrayInputStream</h2><span id='topic+ArrayInputStream'></span><span id='topic+ArrayInputStream-methods'></span><span id='topic+ArrayInputStream+2Craw+2Cmissing-method'></span><span id='topic+ArrayInputStream+2Craw+2Cinteger-method'></span><span id='topic+ArrayInputStream+2Craw+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Constructor for <a href="#topic+ArrayInputStream-class">ArrayInputStream</a> objects
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(payload = "raw", block_size = "missing" )</code></dt><dd><p>Creates a <a href="#topic+ArrayInputStream-class">ArrayInputStream</a> using the raw vector as the payload of the stream</p>
</dd>
<dt><code>signature(payload = "raw", block_size = "integer" )</code></dt><dd><p>Creates a <a href="#topic+ArrayInputStream-class">ArrayInputStream</a> ... same with block size. </p>
</dd>
<dt><code>signature(payload = "raw", block_size = "numeric" )</code></dt><dd><p>Creates a <a href="#topic+ArrayInputStream-class">ArrayInputStream</a> ... same with block size. </p>
</dd>
</dl>

<hr>
<h2 id='ArrayOutputStream-class'>Class &quot;ArrayOutputStream&quot;  </h2><span id='topic+ArrayOutputStream-class'></span>

<h3>Description</h3>

<p>A <a href="#topic+ZeroCopyOutputStream-class">ZeroCopyOutputStream</a> backed by an in-memory array of bytes</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by the <a href="#topic+ArrayOutputStream">ArrayOutputStream</a> function
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p> External pointer to the <code>google::protobuf::io::ArrayOutputStream</code> C++ object</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ZeroCopyOutputStream-class">ZeroCopyOutputStream</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>See <a href="#topic+ZeroCopyOutputStream-class">ZeroCopyOutputStream</a>
</p>


<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>References</h3>

<p> The <code>ArrayOutputStream</code> class from the protobuf C++ library.</p>


<h3>See Also</h3>

<p><a href="#topic+ZeroCopyOutputStream-class">ZeroCopyOutputStream</a> for methods
</p>

<hr>
<h2 id='ArrayOutputStream-methods'>Creates an ArrayOutputStream</h2><span id='topic+ArrayOutputStream'></span><span id='topic+ArrayOutputStream-methods'></span><span id='topic+ArrayOutputStream+2Cinteger+2Cmissing-method'></span><span id='topic+ArrayOutputStream+2Cinteger+2Cinteger-method'></span><span id='topic+ArrayOutputStream+2Cinteger+2Cnumeric-method'></span><span id='topic+ArrayOutputStream+2Cnumeric+2Cmissing-method'></span><span id='topic+ArrayOutputStream+2Cnumeric+2Cinteger-method'></span><span id='topic+ArrayOutputStream+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Constructor for <a href="#topic+ArrayOutputStream-class">ArrayOutputStream</a> objects
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(size = "integer", block_size = "missing" )</code></dt><dd><p>Creates a <a href="#topic+ArrayOutputStream-class">ArrayOutputStream</a> using of the given size</p>
</dd>
<dt><code>signature(size = "integer", block_size = "integer" )</code></dt><dd><p>Creates a <a href="#topic+ArrayOutputStream-class">ArrayOutputStream</a> ... same with block size. </p>
</dd>
<dt><code>signature(size = "integer", block_size = "numeric" )</code></dt><dd><p>Creates a <a href="#topic+ArrayOutputStream-class">ArrayOutputStream</a> ... same with block size. </p>
</dd>
<dt><code>signature(size = "numeric", block_size = "missing" )</code></dt><dd><p>Creates a <a href="#topic+ArrayOutputStream-class">ArrayOutputStream</a> using of the given size</p>
</dd>
<dt><code>signature(size = "numeric", block_size = "integer" )</code></dt><dd><p>Creates a <a href="#topic+ArrayOutputStream-class">ArrayOutputStream</a> ... same with block size. </p>
</dd>
<dt><code>signature(size = "numeric", block_size = "numeric" )</code></dt><dd><p>Creates a <a href="#topic+ArrayOutputStream-class">ArrayOutputStream</a> ... same with block size. </p>
</dd>
</dl>

<hr>
<h2 id='as.list.Message'>
Grab the protocol buffer message as an R list
</h2><span id='topic+as.list.Message'></span><span id='topic+as.list.Descriptor'></span><span id='topic+as.list.EnumDescriptor'></span><span id='topic+as.list.FileDescriptor'></span><span id='topic+as.list.ServiceDescriptor'></span>

<h3>Description</h3>

<p>Utility to grab the protocol buffer message as 
an R list, with one item per field. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Message'
as.list(x, ...)
## S3 method for class 'Descriptor'
as.list(x, ...)
## S3 method for class 'EnumDescriptor'
as.list(x, ...)
## S3 method for class 'FileDescriptor'
as.list(x, ...)
## S3 method for class 'ServiceDescriptor'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.Message_+3A_x">x</code></td>
<td>
<p>A protocol buffer message, instance of <a href="#topic+Message-class">Message</a>, 
or a protocol message descriptor, instance of <a href="#topic+Descriptor-class">Descriptor</a> </p>
</td></tr>
<tr><td><code id="as.list.Message_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For messages, a list of the content of the fields is 
returned.
</p>
<p>For message type descriptors, a list containing
nested type descriptors (<a href="#topic+Descriptor-class">Descriptor</a> objects),
enum type descriptors (<a href="#topic+EnumDescriptor-class">EnumDescriptor</a> objects),
then field descriptors (<a href="#topic+FieldDescriptor-class">FieldDescriptor</a> objects) in that order.
</p>
<p>For enum descriptors, a named list of the enumerated values.
</p>
<p>For file descriptors, a named list of descriptors defined in the
specified file descriptor.
</p>
<p>For service descriptors, ...
</p>


<h3>Author(s)</h3>

<p>Romain Francois &lt;francoisromain@free.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Person &lt;- P( "tutorial.Person" )
romain &lt;- new( Person, email = "francoisromain@free.fr", id = 1 )
as.list( romain )
as.list( Person )
as.list( Person$PhoneType)
</code></pre>

<hr>
<h2 id='asMessage'>
coerce an object to a protobuf message
</h2><span id='topic+asMessage'></span>

<h3>Description</h3>

<p>coerce an object to the <a href="#topic+Message-class">Message</a> class. 
This is a short-hand to the <a href="methods.html#topic+as">as</a> method with the 
<code>Class</code> argument set to &quot;Message&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asMessage(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asMessage_+3A_x">x</code></td>
<td>
<p>object to coerce to a protobuf message</p>
</td></tr>
<tr><td><code id="asMessage_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="methods.html#topic+as">as</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="#topic+Message-class">Message</a> object
</p>


<h3>Author(s)</h3>

<p>Romain Francois &lt;francoisromain@free.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># coerce a message type descriptor to a message
asMessage( tutorial.Person )

# coerce a enum descriptor
asMessage( tutorial.Person.PhoneType )

# coerce a field descriptor
asMessage( tutorial.Person$email )

# coerce a file descriptor 
asMessage( fileDescriptor( tutorial.Person ) )
</code></pre>

<hr>
<h2 id='BackUp-methods'>Backs up a number of bytes from a stream</h2><span id='topic+BackUp'></span><span id='topic+BackUp-methods'></span>

<h3>Description</h3>

<p>Backs up a number of bytes from a stream
</p>


<h3>See Also</h3>

<p><a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a> implements BackUp.
</p>

<hr>
<h2 id='ByteCount-methods'>The number of bytes read/written since the object was created</h2><span id='topic+ByteCount'></span><span id='topic+ByteCount-methods'></span>

<h3>Description</h3>

<p>The number of bytes read/written since the object was created
</p>


<h3>See Also</h3>

<p><a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a> implements ByteCount.
</p>

<hr>
<h2 id='bytesize-methods'>The number of bytes taken by a message </h2><span id='topic+bytesize'></span><span id='topic+bytesize-methods'></span><span id='topic+bytesize+2CMessage-method'></span>

<h3>Description</h3>

<p>The number of bytes taken by a <a href="#topic+Message-class">Message</a>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Message")</code></dt><dd><p> The number of bytes the message would take when serialized </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>	message &lt;- new( tutorial.Person, name = "dddd", email = "eeeeeee", id = 1 )
	bytesize( message )
	
</code></pre>

<hr>
<h2 id='clear-methods'>Clear a field or all fields of the message and set them to their default values</h2><span id='topic+clear'></span><span id='topic+clear-methods'></span><span id='topic+clear+2CMessage+2Ccharacter-method'></span><span id='topic+clear+2CMessage+2Cinteger-method'></span><span id='topic+clear+2CMessage+2Cmissing-method'></span><span id='topic+clear+2CMessage+2Cnumeric-method'></span><span id='topic+clear+2CMessage+2Craw-method'></span>

<h3>Description</h3>

<p>Clear one field or all fields of the message and set them to their default values
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Message", field = "missing")</code></dt><dd><p>Clear all fields of the message and set them to their default values </p>
</dd>
<dt><code>signature(object = "Message", field = "character")</code></dt><dd><p> Clear the field identified by its name </p>
</dd>
<dt><code>signature(object = "Message", field = "integer")</code></dt><dd><p> Clear the field identified by its tag number </p>
</dd>
<dt><code>signature(object = "Message", field = "numeric")</code></dt><dd><p> Clear the field identified by its tag number </p>
</dd>
<dt><code>signature(object = "Message", field = "raw")</code></dt><dd><p> Clear the field identified by its tag number</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>	message &lt;- new( tutorial.Person, name = "dddd", email = "eeeeeee", id = 1 )
	writeLines( as.character( message ) )
	clear( message )
	# clear works also as a pseudo method :
	message$clear() 
	
	writeLines( as.character( message ) )
	
	# clear single fields
	message &lt;- new( tutorial.Person, name = "dddd", email = "eeeeeee", id = 1 )
	message$clear( "name" )
	writeLines( as.character( message ) )
	
</code></pre>

<hr>
<h2 id='clone-methods'>Clone protocol buffer messages</h2><span id='topic+clone'></span><span id='topic+clone-methods'></span><span id='topic+clone+2CMessage-method'></span>

<h3>Description</h3>

<p>Generic &quot;clone&quot; function and associated 
method for <a href="#topic+Message-class">Message</a> objects 
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Message")</code></dt><dd><p> clone the message </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example proto file supplied with this package
proto.file &lt;- system.file( "proto", "addressbook.proto", package = "RProtoBuf" )

# reading a proto file and creating the descriptor
Person &lt;- P( "tutorial.Person", file = proto.file )

## End(Not run)


# creating a prototype message from the descriptor
sheep &lt;- new( Person, email = "francoisromain@free.fr", id = 2 )

# cloning the sheep
newsheep &lt;- clone( sheep )

# clone and update at once
newsheep &lt;- clone( sheep, id = 3 )

# this can also be used as a pseudo method
sheep$clone()
sheep$clone( id = 3 )
</code></pre>

<hr>
<h2 id='completion'>
Completion support for protocol buffer messages and descriptors
</h2><span id='topic+.DollarNames.Message'></span><span id='topic+.DollarNames.Descriptor'></span><span id='topic+.DollarNames.EnumDescriptor'></span><span id='topic+.DollarNames.FieldDescriptor'></span><span id='topic+.DollarNames.FileDescriptor'></span><span id='topic+.DollarNames.ServiceDescriptor'></span><span id='topic+.DollarNames.MethodDescriptor'></span><span id='topic+.DollarNames.ZeroCopyInputStream'></span><span id='topic+.DollarNames.ZeroCopyOutputStream'></span>

<h3>Description</h3>

<p>These functions support completion of protocol buffer
messages and descriptors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Message'
.DollarNames(x, pattern = "")
## S3 method for class 'Descriptor'
.DollarNames(x, pattern = "")
## S3 method for class 'EnumDescriptor'
.DollarNames(x, pattern = "")
## S3 method for class 'FieldDescriptor'
.DollarNames(x, pattern = "")
## S3 method for class 'FileDescriptor'
.DollarNames(x, pattern = "")
## S3 method for class 'ServiceDescriptor'
.DollarNames(x, pattern = "")
## S3 method for class 'MethodDescriptor'
.DollarNames(x, pattern = "")
## S3 method for class 'ZeroCopyInputStream'
.DollarNames(x, pattern = "")
## S3 method for class 'ZeroCopyOutputStream'
.DollarNames(x, pattern = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="completion_+3A_x">x</code></td>
<td>
<p>message (<a href="#topic+Message-class">Message</a>) or descriptor (<a href="#topic+Descriptor-class">Descriptor</a>) </p>
</td></tr>
<tr><td><code id="completion_+3A_pattern">pattern</code></td>
<td>
<p>filter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector containing potential completions. 
</p>
<p>For <a href="#topic+Message-class">Message</a> objects, completions are 
the fields of the message and a set of pseudo methods (&quot;has&quot;)
</p>
<p>For <a href="#topic+EnumDescriptor-class">EnumDescriptor</a> objects, completions
are the names of the possible constants
</p>
<p>For <a href="#topic+Descriptor-class">Descriptor</a> objects, completions
are the names of the fields, enum types and nested message types
defined in the associated message type. 
</p>
<p>For <a href="#topic+FileDescriptor-class">FileDescriptor</a> objects, completions
are the names of the top-level descriptors (message, enum or service)
contained in the associated file, or pseudo methods.
</p>


<h3>Author(s)</h3>

<p>Romain Francois &lt;francoisromain@free.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating a prototype message from the descriptor
p &lt;- new( tutorial.Person )

.DollarNames( p )
.DollarNames( tutorial.Person )
# but this is usually used with the &lt;TAB&gt; expansion on the command line
# &lt;TAB&gt; means "press the TAB key"
# p$&lt;TAB&gt;
# Person$&lt;TAB&gt;

</code></pre>

<hr>
<h2 id='ConnectionInputStream-class'>Class &quot;ConnectionInputStream&quot;  </h2><span id='topic+ConnectionInputStream-class'></span>

<h3>Description</h3>

<p>A <a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a> reading from a binary R connection</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by the <a href="#topic+ConnectionInputStream">ConnectionInputStream</a> function 
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p> External pointer to the <code>rprotobuf::ConnectionInputStream</code> C++ object</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>See <a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a>
</p>


<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>References</h3>

<p> The internal C++ class <code>ConnectionInputStream</code> </p>


<h3>See Also</h3>

<p><a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a> for methods
</p>

<hr>
<h2 id='ConnectionInputStream-methods'>Creates an ConnectionInputStream</h2><span id='topic+ConnectionInputStream'></span><span id='topic+ConnectionInputStream-methods'></span><span id='topic+ConnectionInputStream+2Cconnection-method'></span>

<h3>Description</h3>

<p>Constructor for <a href="#topic+ConnectionInputStream-class">ConnectionInputStream</a> objects
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object="connection")</code></dt><dd><p>Creates a <a href="#topic+ConnectionInputStream-class">ConnectionInputStream</a> reading from the given R binary connection.</p>
</dd>
</dl>

<hr>
<h2 id='ConnectionOutputStream-class'>Class &quot;ConnectionOutputStream&quot;  </h2><span id='topic+ConnectionOutputStream-class'></span>

<h3>Description</h3>

<p>A <a href="#topic+ZeroCopyOutputStream-class">ZeroCopyOutputStream</a> writing to a binary R connection</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by the <a href="#topic+ConnectionOutputStream">ConnectionOutputStream</a> function 
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p> External pointer to the <code>rprotobuf::ConnectionOutputStream</code> C++ object</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ZeroCopyOutputStream-class">ZeroCopyOutputStream</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>See <a href="#topic+ZeroCopyOutputStream-class">ZeroCopyOutputStream</a>
</p>


<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>References</h3>

<p> The internal C++ class <code>ConnectionOutputStream</code> </p>


<h3>See Also</h3>

<p><a href="#topic+ZeroCopyOutputStream-class">ZeroCopyOutputStream</a> for methods
</p>

<hr>
<h2 id='ConnectionOutputStream-methods'>Creates an ConnectionOutputStream</h2><span id='topic+ConnectionOutputStream'></span><span id='topic+ConnectionOutputStream-methods'></span><span id='topic+ConnectionOutputStream+2Cconnection-method'></span>

<h3>Description</h3>

<p>Constructor for <a href="#topic+ConnectionOutputStream-class">ConnectionOutputStream</a> objects
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object="connection")</code></dt><dd>
<p>Creates a <a href="#topic+ConnectionOutputStream-class">ConnectionOutputStream</a> writing to the given R binary connection.</p>
</dd>
</dl>

<hr>
<h2 id='containing_type-methods'>Gets the message type descriptor that contains a descriptor</h2><span id='topic+containing_type'></span><span id='topic+containing_type-methods'></span>

<h3>Description</h3>

<p>Gets a <a href="#topic+Descriptor-class">Descriptor</a> describing the message type 
that contains the descriptor. 
</p>


<h3>See Also</h3>

<p>The method is implemented for these classes : 
<a href="#topic+Descriptor-class">Descriptor</a>, <a href="#topic+EnumDescriptor-class">EnumDescriptor</a>, 
<a href="#topic+FieldDescriptor-class">FieldDescriptor</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Containing type of a field is the message descriptor
tutorial.Person$id$containing_type()

# No containing type for the top-level message descriptor.
tutorial.Person$containing_type()
</code></pre>

<hr>
<h2 id='Descriptor-class'>Class &quot;Descriptor&quot; </h2><span id='topic+Descriptor-class'></span><span id='topic+as.character+2CDescriptor-method'></span><span id='topic++24+3C-+2CDescriptor-method'></span><span id='topic++24+2CDescriptor-method'></span><span id='topic+new+2CDescriptor-method'></span><span id='topic+show+2CDescriptor-method'></span><span id='topic+toString+2CDescriptor-method'></span><span id='topic+containing_type+2CDescriptor-method'></span><span id='topic+field_count+2CDescriptor-method'></span><span id='topic+nested_type_count+2CDescriptor-method'></span><span id='topic+enum_type_count+2CDescriptor-method'></span><span id='topic+field+2CDescriptor-method'></span><span id='topic+nested_type+2CDescriptor-method'></span><span id='topic+enum_type+2CDescriptor+2CANY+2CANY-method'></span><span id='topic++5B+5B+2CDescriptor-method'></span><span id='topic+names+2CDescriptor-method'></span><span id='topic+length+2CDescriptor-method'></span>

<h3>Description</h3>

<p> full descriptive information about a protocol buffer
message type. This is a thin wrapper around the
C++ class <code>Descriptor</code></p>


<h3>Objects from the Class</h3>

<p>Objects are usually created by calls to the <code><a href="#topic+P">P</a></code>
function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p>external pointer holding a <code>Descriptor</code> object </p>
</dd>
<dt><code>type</code>:</dt><dd><p>full name of the corresponding message type</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.character</dt><dd><p><code>signature(x = "Descriptor")</code>:
returns the debug string of the descriptor.
This is retrieved by a call to the <code>DebugString</code>
method of the Descriptor object.  </p>
</dd>
<dt>toString</dt><dd><p><code>signature(x = "Descriptor")</code>: same as <code>as.character</code> </p>
</dd>
<dt>$</dt><dd><p><code>signature(x = "Descriptor")</code>: retrieves a
descriptor for a member of the message type. This can
either be another &quot;Descriptor&quot; instance describing
a nested type, or a <a href="#topic+EnumDescriptor-class">EnumDescriptor</a> object
describing an enum type, or a <a href="#topic+FieldDescriptor-class">FieldDescriptor</a>
object describing a field of the message</p>
</dd>
<dt>new</dt><dd><p><code>signature(Class = "Descriptor")</code>: creates
a prototype message (<a href="#topic+Message-class">Message</a>) of this
descriptor</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Descriptor")</code>:
simple information</p>
</dd>
<dt>containing_type</dt><dd><p><code>signature(object = "Descriptor")</code> : returns a descriptor of the message type that contains this message descriptor, or <code>NULL</code> if this is a top-level message type.</p>
</dd>
<dt>field_count</dt><dd><p><code>signature(object = "Descriptor")</code> : The number of fields of this message type. </p>
</dd>
<dt>nested_type_count</dt><dd><p><code>signature(object = "Descriptor")</code> : The number of nested types of this message type. </p>
</dd>
<dt>enum_type_count</dt><dd><p><code>signature(object = "Descriptor")</code> : The number of enum types of this message type. </p>
</dd>
<dt>field</dt><dd><p><code>signature(object = "Descriptor")</code> : extract a field descriptor from a descriptor.
Exactly one argument of <code>index</code>, <code>number</code> or <code>name</code> has to be used.
If <code>index</code> is used, the field descriptor is retrieved by
position, using the <code>field</code> method of the <code>google::protobuf::Descriptor</code> C++ class.
If <code>number</code> is used, the field descriptor is retrieved using
the tag number, with the <code>FindFieldByNumber</code> C++ method.
If <code>name</code> is used, the field descriptor is retrieved by name
using the <code>FindFieldByName</code>
</p>
</dd>
<dt>nested_type</dt><dd><p><code>signature(object = "Descriptor")</code> :
extracts a message type descriptor that is nested
in this descriptor.
Exactly one argument of <code>index</code> of <code>name</code> has to be used.
If <code>index</code> is used, the nested type will be retrieved
using its position with the <code>nested_type</code> method
of the <code>google::protobuf::Descriptor</code> C++ class.
If <code>name</code> is used, the nested type will be retrieved
using its name, with the <code>FindNestedTypeByName</code> C++ method
</p>
</dd>
<dt>enum_type</dt><dd><p><code>signature(object = "Descriptor")</code> :
extracts an enum type descriptor that is contained
in this descriptor.
Exactly one argument of <code>index</code> of <code>name</code> has to be used.
If <code>index</code> is used, the enum type will be retrieved
using its position with the <code>enum_type</code> method
of the <code>google::protobuf::Descriptor</code> C++ class.
If <code>name</code> is used, the enum type will be retrieved
using its name, with the <code>FindEnumTypeByName</code> C++ method
</p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "Descriptor")</code>: extracts a field identified by its name or declared tag number</p>
</dd>
<dt>names</dt><dd><p><code>signature(x = "Descriptor")</code> : extracts names of this descriptor</p>
</dd>
<dt>length</dt><dd><p><code>signature(x = "Descriptor")</code> : extracts length of this descriptor</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>See Also</h3>

<p>the <code><a href="#topic+P">P</a></code> function creates &quot;Descriptor&quot; messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example proto file supplied with this package
proto.file &lt;- system.file( "proto", "addressbook.proto", package = "RProtoBuf" )
# reading a proto file and creating the descriptor
Person &lt;- P( "tutorial.Person", file = proto.file )

## End(Not run)


# enum type
Person$PhoneType

# nested type
Person$PhoneNumber

# field
Person$email

# use this descriptor to create a message
new( Person )
</code></pre>

<hr>
<h2 id='descriptor-methods'>Get the descriptor of a message</h2><span id='topic+descriptor'></span><span id='topic+descriptor-methods'></span><span id='topic+descriptor+2CMessage-method'></span>

<h3>Description</h3>

<p>Get the <a href="#topic+Descriptor-class">Descriptor</a> associated
with a <a href="#topic+Message-class">Message</a>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Message")</code></dt><dd><p> Get the descriptor of the message, as a <a href="#topic+Descriptor-class">Descriptor</a> instance </p>
</dd>
</dl>

<hr>
<h2 id='enum_type_count-methods'>The number of enum types</h2><span id='topic+enum_type_count'></span><span id='topic+enum_type_count-methods'></span>

<h3>Description</h3>

<p>The number of enum types
</p>


<h3>See Also</h3>

<p>The method is implemented for the <a href="#topic+Descriptor-class">Descriptor</a> class
</p>

<hr>
<h2 id='enum_type-methods'>Extract an enum type descriptor for a nested type</h2><span id='topic+enum_type'></span><span id='topic+enum_type-methods'></span>

<h3>Description</h3>

<p>Extract a <a href="#topic+EnumDescriptor-class">EnumDescriptor</a> contained in a 
<a href="#topic+Descriptor-class">Descriptor</a>
</p>


<h3>See Also</h3>

<p>The method is implemented for the <a href="#topic+Descriptor-class">Descriptor</a> class
</p>

<hr>
<h2 id='EnumDescriptor-class'>Class &quot;EnumDescriptor&quot;  </h2><span id='topic+EnumDescriptor-class'></span><span id='topic+show+2CEnumDescriptor-method'></span><span id='topic+has+2CEnumDescriptor-method'></span><span id='topic+as.character+2CEnumDescriptor-method'></span><span id='topic+toString+2CEnumDescriptor-method'></span><span id='topic++24+2CEnumDescriptor-method'></span><span id='topic+containing_type+2CEnumDescriptor-method'></span><span id='topic+length+2CEnumDescriptor-method'></span><span id='topic+value_count'></span><span id='topic+value_count-methods'></span><span id='topic+value_count+2CEnumDescriptor-method'></span><span id='topic+value'></span><span id='topic+value-methods'></span><span id='topic+value+2CEnumDescriptor-method'></span><span id='topic++5B+5B+2CEnumDescriptor-method'></span><span id='topic+names+2CEnumDescriptor-method'></span>

<h3>Description</h3>

<p> R representation of an enum descriptor. This 
is a thin wrapper around the <code>EnumDescriptor</code> c++ class. </p>


<h3>Objects from the Class</h3>

<p>Objects of this class are typically retrieved as members of 
<a href="#topic+Descriptor-class">Descriptor</a> objects
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p>external pointer to the <code>EnumDescriptor</code> instance</p>
</dd>
<dt><code>name</code>:</dt><dd><p> simple name of the enum </p>
</dd>
<dt><code>full_name</code>:</dt><dd><p>fully qualified name </p>
</dd>
<dt><code>type</code>:</dt><dd><p>fully qualified name of the type that contains this enumeration</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "EnumDescriptor")</code>: small information </p>
</dd>
<dt>as.character</dt><dd><p><code>signature(x = "EnumDescriptor")</code>: 
returns the debug string of the enum descriptor. 
This is retrieved by a call to the <code>DebugString</code>
method of the EnumDescriptor object.  </p>
</dd>
<dt>toString</dt><dd><p><code>signature(x = "EnumDescriptor")</code>: same as <code>as.character</code> </p>
</dd>
<dt>$</dt><dd><p><code>signature(x = "EnumDescriptor")</code>: get the 
number associated with the name</p>
</dd>
<dt>has</dt><dd><p><code>signature(object = "EnumDescriptor")</code>: indicate if
the given name is a constant present in this enum.</p>
</dd>
<dt>containing_type</dt><dd><p><code>signature(object = "EnumDescriptor")</code> : returns a <a href="#topic+Descriptor-class">Descriptor</a> of the message type that contains this enum descriptor, or NULL if this is a top level enum descriptor.</p>
</dd>
<dt>length</dt><dd><p><code>signature(x = "EnumDescriptor")</code> : number of constants in this enum.</p>
</dd>
<dt>value_count</dt><dd><p><code>signature(object = "EnumDescriptor")</code> : number of constants in this enum.</p>
</dd>
<dt>value</dt><dd><p><code>signature(object = "EnumDescriptor")</code> : extracts an <a href="#topic+EnumValueDescriptor-class">EnumValueDescriptor</a>.
Exactly one argument of <code>index</code>, <code>number</code> or <code>name</code> has to be 
used.
If <code>index</code> is used, the enum value descriptor is retrieved
by position, using the <code>value</code> method of the C++ class. 
If <code>number</code> is used, the enum value descriptor is retrieved
using the value of the constant, using the <code>FindValueByNumber</code>
C++ method. 
If <code>name</code> is used, the enum value descriptor is retrieved
using the name of the constant, using the <code>FindValueByName</code>
C++ method.
</p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "EnumDescriptor")</code>: extracts field identified by its name or declared tag number</p>
</dd>
<dt>names</dt><dd><p><code>signature(x = "EnumDescriptor")</code> : extracts names of this enum</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>References</h3>

<p> The <code>EnumDescriptor</code> C++ class </p>


<h3>See Also</h3>

<p>The <a href="#topic+Descriptor-class">Descriptor</a> class</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example proto file supplied with this package
proto.file &lt;- system.file( "proto", "addressbook.proto", package = "RProtoBuf" ) 

# reading a proto file and creating the descriptor
Person &lt;- P( "tutorial.Person", file = proto.file )

## End(Not run)

# enum type
Person$PhoneType

has(Person$PhoneType, "MOBILE")
has(Person$PhoneType, "HOME")
has(Person$PhoneType, "WORK")

has(Person$PhoneType, "FOOBAR")

length(Person$PhoneType)
</code></pre>

<hr>
<h2 id='EnumValueDescriptor-class'>Class &quot;EnumValueDescriptor&quot;  </h2><span id='topic+EnumValueDescriptor-class'></span><span id='topic+show+2CEnumValueDescriptor-method'></span><span id='topic+as.character+2CEnumValueDescriptor-method'></span><span id='topic+toString+2CEnumValueDescriptor-method'></span><span id='topic++24+2CEnumValueDescriptor-method'></span><span id='topic+name+2CEnumValueDescriptor-method'></span><span id='topic+number+2CEnumValueDescriptor-method'></span><span id='topic+enum_type+2CEnumValueDescriptor+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p> R representation of an enum value descriptor. This
is a thin wrapper around the <code>EnumValueDescriptor</code> c++ class. </p>


<h3>Objects from the Class</h3>

<p>Objects of this class are typically retrieved with the
<code>value</code> method of the <a href="#topic+EnumDescriptor-class">EnumDescriptor</a> class
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p>external pointer to the <code>EnumValueDescriptor</code> instance</p>
</dd>
<dt><code>name</code>:</dt><dd><p> simple name of the enum </p>
</dd>
<dt><code>full_name</code>:</dt><dd><p>fully qualified name </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "EnumValueDescriptor")</code>: small information </p>
</dd>
<dt>as.character</dt><dd><p><code>signature(x = "EnumValueDescriptor")</code>:
returns the debug string of the enum descriptor.
This is retrieved by a call to the <code>DebugString</code>
method of the EnumDescriptor object.  </p>
</dd>
<dt>toString</dt><dd><p><code>signature(x = "EnumValueDescriptor")</code>: same as <code>as.character</code> </p>
</dd>
<dt>$</dt><dd><p><code>signature(x = "EnumValueDescriptor")</code>: invoke pseudo
methods </p>
</dd>
<dt>name</dt><dd><p><code>signature(object = "EnumValueDescriptor", full = "logical")</code>:
return the name of this enum constant.</p>
</dd>
<dt>number</dt><dd><p><code>signature(object = "EnumValueDescriptor")</code>:
return the numeric value of this enum constant.</p>
</dd>
<dt>enum_type</dt><dd><p><code>signature(object = "EnumDescriptor")</code> : retrieves the <a href="#topic+EnumDescriptor-class">EnumDescriptor</a> related to this value descriptor.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example proto file supplied with this package
proto.file &lt;- system.file( "proto", "addressbook.proto", package = "RProtoBuf" )
# reading a proto file and creating the descriptor
Person &lt;- P( "tutorial.Person", file = proto.file )

## End(Not run)

# enum type
Person$PhoneType

# enum value type
value(Person$PhoneType, 1)

name(value(Person$PhoneType, 1))
name(value(Person$PhoneType, 1), TRUE)

number(value(Person$PhoneType, number=1))

enum_type(value(Person$PhoneType, number=1))
</code></pre>

<hr>
<h2 id='fetch-methods'>Fetch content of a repeated field</h2><span id='topic+fetch'></span><span id='topic+fetch-methods'></span><span id='topic+fetch+2CMessage-method'></span>

<h3>Description</h3>

<p>Fetch content of a repeated field of a message
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Message")</code></dt><dd><p>Fetch content of a message repeated field</p>
</dd>
</dl>

<hr>
<h2 id='field_count-methods'>The number of fields</h2><span id='topic+field_count'></span><span id='topic+field_count-methods'></span>

<h3>Description</h3>

<p>The number of fields 
</p>


<h3>See Also</h3>

<p>The method is implemented for the <a href="#topic+Descriptor-class">Descriptor</a> class
</p>

<hr>
<h2 id='field-methods'>Extract a field descriptor</h2><span id='topic+field'></span><span id='topic+field-methods'></span>

<h3>Description</h3>

<p>Extract a <a href="#topic+FieldDescriptor-class">FieldDescriptor</a> from a 
<a href="#topic+Descriptor-class">Descriptor</a>
</p>


<h3>See Also</h3>

<p>The method is implemented for the <a href="#topic+Descriptor-class">Descriptor</a> class
</p>

<hr>
<h2 id='FieldDescriptor-class'>Class &quot;FieldDescriptor&quot;</h2><span id='topic+FieldDescriptor-class'></span><span id='topic+show+2CFieldDescriptor-method'></span><span id='topic++24+2CFieldDescriptor-method'></span><span id='topic+as.character+2CFieldDescriptor-method'></span><span id='topic+toString+2CFieldDescriptor-method'></span><span id='topic+containing_type+2CFieldDescriptor-method'></span><span id='topic+is_extension+2CFieldDescriptor-method'></span><span id='topic+number+2CFieldDescriptor-method'></span><span id='topic+type+2CFieldDescriptor-method'></span><span id='topic+cpp_type+2CFieldDescriptor-method'></span><span id='topic+label+2CFieldDescriptor-method'></span><span id='topic+is_required'></span><span id='topic+is_optional'></span><span id='topic+is_repeated'></span><span id='topic+is_required-methods'></span><span id='topic+is_optional-methods'></span><span id='topic+is_repeated-methods'></span><span id='topic+is_required+2CFieldDescriptor-method'></span><span id='topic+is_optional+2CFieldDescriptor-method'></span><span id='topic+is_repeated+2CFieldDescriptor-method'></span><span id='topic+has_default_value'></span><span id='topic+has_default_value-methods'></span><span id='topic+has_default_value+2CFieldDescriptor-method'></span><span id='topic+default_value'></span><span id='topic+default_value-methods'></span><span id='topic+default_value+2CFieldDescriptor-method'></span><span id='topic+message_type'></span><span id='topic+message_type-methods'></span><span id='topic+message_type+2CFieldDescriptor-method'></span><span id='topic+enum_type+2CFieldDescriptor+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>R representation of message type field descriptor. 
This is a thin wrapper around the C++ class <code>FieldDescriptor</code> </p>


<h3>Objects from the Class</h3>

<p>Objects typically are retrieved from <a href="#topic+FieldDescriptor-class">FieldDescriptor</a>
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p>external pointer to the <code>FieldDescriptor</code> c++ object </p>
</dd>
<dt><code>name</code>:</dt><dd><p> name of the field within the message type </p>
</dd>
<dt><code>full_name</code>:</dt><dd><p>Fully qualified name of the field</p>
</dd>
<dt><code>type</code>:</dt><dd><p>Fully qualified name of the type that contains this field </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "FieldDescriptor")</code>: small description </p>
</dd>
<dt>as.character</dt><dd><p><code>signature(x = "FieldDescriptor")</code>: 
returns the debug string of the field descriptor. 
This is retrieved by a call to the <code>DebugString</code>
method of the FieldDescriptor object.  </p>
</dd>
<dt>toString</dt><dd><p><code>signature(x = "FieldDescriptor")</code>: same as <code>as.character</code> </p>
</dd>
<dt>$</dt><dd><p><code>signature(x = "FieldDescriptor")</code>: used to invoke pseudo methods </p>
</dd>
<dt>containing_type</dt><dd><p><code>signature(object = "FieldDescriptor")</code> : returns a <a href="#topic+Descriptor-class">Descriptor</a> of the message type that contains this field descriptor.</p>
</dd>
<dt>is_extension</dt><dd><p><code>signature(object = "FieldDescriptor")</code> : indicates if this is an extension.</p>
</dd>
<dt>number</dt><dd><p><code>signature(object = "FieldDescriptor")</code> : gets the declared tag number of this field.</p>
</dd>
<dt>type</dt><dd><p><code>signature(object = "FieldDescriptor")</code> : type of this field.</p>
</dd>
<dt>cpp_type</dt><dd><p><code>signature(object = "FieldDescriptor")</code> : c++ type of this field.</p>
</dd>
<dt>label</dt><dd><p><code>signature(object = "FieldDescriptor")</code> : label of this field.</p>
</dd>
<dt>is_required</dt><dd><p><code>signature(object = "FieldDescriptor")</code> : is this field required.</p>
</dd>
<dt>is_optional</dt><dd><p><code>signature(object = "FieldDescriptor")</code> : is this field optional.</p>
</dd>
<dt>is_repeated</dt><dd><p><code>signature(object = "FieldDescriptor")</code> : is this field repeated.</p>
</dd>
<dt>has_default_value</dt><dd><p><code>signature(object = "FieldDescriptor")</code> : indicates if this field has a default value.</p>
</dd>
<dt>default_value</dt><dd><p><code>signature(object = "FieldDescriptor")</code> : the default value of this field.</p>
</dd>
<dt>message_type</dt><dd><p><code>signature(object = "FieldDescriptor")</code> : the <a href="#topic+Descriptor-class">Descriptor</a> for the associated message type. Generates an error if this field is not a message type field.</p>
</dd>
<dt>enum_type</dt><dd><p><code>signature(object = "FieldDescriptor")</code> : the <a href="#topic+EnumDescriptor-class">EnumDescriptor</a> for the associated enum type.Generates an error if this field is not an enum type field </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>References</h3>

<p> The <code>FieldDescriptor</code> C++ class </p>


<h3>See Also</h3>

<p><a href="#topic+Descriptor-class">Descriptor</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example proto file supplied with this package
proto.file &lt;- system.file( "proto", "addressbook.proto", package = "RProtoBuf" ) 

# reading a proto file and creating the descriptor
Person &lt;- P( "tutorial.Person", file = proto.file )

## End(Not run)


# field descriptor object
Person$email

# debug string
as.character( Person$email )

# or as a pseudo method
Person$email$as.character()

Person$email$is_required()
Person$email$is_optional()
Person$email$is_repeated()

Person$email$has_default_value()
Person$email$default_value()

Person$email$is_extension()

# Get the default values
has_default_value(Person$id)
has_default_value(Person$email)
has_default_value(Person$phone)
default_value(Person$id)
default_value(Person$email)
default_value(Person$phone)

# Get the types of field descriptors
type(Person$id)
type(Person$id, as.string=TRUE)
cpp_type(Person$email)
cpp_type(Person$email, TRUE)

# Get the label of a field descriptor
label(Person$id)
label(Person$email)
label(Person$phone)
label(Person$id, TRUE)
label(Person$email, TRUE)
label(Person$phone, TRUE)
LABEL_OPTIONAL
LABEL_REQUIRED
LABEL_REPEATED

# Test if a field is optional
is_optional(Person$id)
is_optional(Person$email)
is_optional(Person$phone)

# Test if a field is repeated
is_repeated(Person$id)
is_repeated(Person$email)
is_repeated(Person$phone)

# Test if a field is required
is_required(Person$id)
is_required(Person$email)
is_required(Person$phone)

# Return the class of a message field
message_type(Person$phone)
</code></pre>

<hr>
<h2 id='FileDescriptor-class'>Class &quot;FileDescriptor&quot;</h2><span id='topic+FileDescriptor-class'></span><span id='topic+as.character+2CFileDescriptor-method'></span><span id='topic+toString+2CFileDescriptor-method'></span><span id='topic++24+2CFileDescriptor-method'></span><span id='topic+show+2CFileDescriptor-method'></span><span id='topic+name+2CFileDescriptor-method'></span>

<h3>Description</h3>

<p>Class &quot;FileDescriptor&quot;</p>


<h3>Objects from the Class</h3>

<p>Objects are usually created using the <code><a href="#topic+fileDescriptor">fileDescriptor</a></code> method
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p>external pointer to a <code>google::protobuf::FileDescriptor</code> C++ object </p>
</dd>
<dt><code>package</code>:</dt><dd><p>the package name defined in the file, e.g. 'tutorial'.</p>
</dd>
<dt><code>filename</code>:</dt><dd><p>the filename of this FileDescriptor</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>$</dt><dd><p><code>signature(x = "FileDescriptor")</code>: used to invoke a pseudo method of the
file descriptor or get a top level message, enum or service descriptor</p>
</dd>
<dt>toString</dt><dd><p><code>signature(x = "FileDescriptor" )</code> : gets the debug string</p>
</dd>
<dt>as.character</dt><dd><p><code>signature(x = "FileDescriptor" )</code> : gets the debug string</p>
</dd>
<dt>show</dt><dd><p><code>signature(x = "FileDescriptor" )</code> : prints small text</p>
</dd>
<dt>name</dt><dd><p><code>signature(object = "FileDescriptor" )</code> : name of the file</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>See Also</h3>

<p><a href="#topic+Descriptor-class">Descriptor</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example proto file supplied with this package
desc &lt;- P("tutorial.Person")
person &lt;- new(desc)

person$fileDescriptor()
name(person$fileDescriptor())
# [1] "addressbook.proto"
as.character(person$fileDescriptor())
</code></pre>

<hr>
<h2 id='fileDescriptor-methods'>gets the file descriptor of an object</h2><span id='topic+fileDescriptor'></span><span id='topic+fileDescriptor-methods'></span><span id='topic+fileDescriptor+2CDescriptor-method'></span><span id='topic+fileDescriptor+2CMessage-method'></span><span id='topic+fileDescriptor+2CEnumDescriptor-method'></span><span id='topic+fileDescriptor+2CFieldDescriptor-method'></span><span id='topic+fileDescriptor+2CServiceDescriptor-method'></span><span id='topic+fileDescriptor+2CMethodDescriptor-method'></span>

<h3>Description</h3>

<p>Gets the file descriptor of an object
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Descriptor")</code></dt><dd><p> retrieves the file descriptor associated with this descriptor</p>
</dd>
<dt><code>signature(object = "Message")</code></dt><dd><p> retrieves the file descriptor associated with the descriptor of this message </p>
</dd>
<dt><code>signature(object = "EnumDescriptor")</code></dt><dd><p> retrieves the file descriptor associated with the enum descriptor </p>
</dd>
<dt><code>signature(object = "FieldDescriptor")</code></dt><dd><p> retrieves the file descriptor associated with the field descriptor </p>
</dd>
<dt><code>signature(object = "ServiceDescriptor")</code></dt><dd><p> retrieves the file descriptor associated with the service descriptor </p>
</dd>
<dt><code>signature(object = "MethodDescriptor")</code></dt><dd><p> retrieves the file descriptor associated with the method descriptor </p>
</dd>
</dl>

<hr>
<h2 id='FileInputStream-class'>Class &quot;FileInputStream&quot;  </h2><span id='topic+FileInputStream-class'></span><span id='topic+close+2CFileInputStream-method'></span><span id='topic+GetErrno+2CFileInputStream-method'></span><span id='topic+SetCloseOnDelete+2CFileInputStream-method'></span>

<h3>Description</h3>

<p>A <a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a> reading from a file</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by the <a href="#topic+FileInputStream">FileInputStream</a> function
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p> External pointer to the <code>google::protobuf::io::FileInputStream</code> C++ object</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>close</dt><dd><p><code>signature(con="FileInputStream")</code>:
Flushes any buffers and closes the underlying file.
Returns false if an error occurs during the process; use <code>GetErrno</code> to examine the error
</p>
</dd>
<dt>GetErrno</dt><dd><p><code>signature(object="FileInputStream")</code>:
If an I/O error has occurred on this file descriptor, this is the errno from that error.
Otherwise, this is zero. Once an error occurs, the stream is broken and all subsequent operations will fail.
</p>
</dd>
<dt>SetCloseOnDelete</dt><dd><p><code>signature(object="FileInputStream")</code>:
set the close on delete behavior.
</p>
</dd>
</dl>

<p>See <a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a> for inherited methods
</p>


<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>References</h3>

<p> The <code>FileInputStream</code> class from the protobuf C++ library.</p>


<h3>See Also</h3>

<p><a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a> for methods
</p>

<hr>
<h2 id='FileInputStream-methods'>Creates an FileInputStream</h2><span id='topic+FileInputStream'></span><span id='topic+FileInputStream-methods'></span><span id='topic+FileInputStream+2Ccharacter+2Cinteger+2Clogical-method'></span>

<h3>Description</h3>

<p>Constructor for <a href="#topic+FileInputStream-class">FileInputStream</a> objects
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(filename = "character", block_size = "logical", close.on.delete = "logical" )</code></dt><dd><p>Creates a <a href="#topic+FileInputStream-class">FileInputStream</a> reading from the given file.</p>
</dd>
</dl>

<hr>
<h2 id='FileOutputStream-class'>Class &quot;FileOutputStream&quot;  </h2><span id='topic+FileOutputStream-class'></span><span id='topic+close+2CFileOutputStream-method'></span><span id='topic+flush+2CFileOutputStream-method'></span><span id='topic+GetErrno+2CFileOutputStream-method'></span><span id='topic+SetCloseOnDelete+2CFileOutputStream-method'></span>

<h3>Description</h3>

<p>A <a href="#topic+ZeroCopyOutputStream-class">ZeroCopyOutputStream</a> reading from a file</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by the <a href="#topic+FileOutputStream">FileOutputStream</a> function
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p> External pointer to the <code>google::protobuf::io::FileOutputStream</code> C++ object</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ZeroCopyOutputStream-class">ZeroCopyOutputStream</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>close</dt><dd><p><code>signature(con="FileOutputStream")</code>:
Flushes any buffers and closes the underlying file.
Returns false if an error occurs during the process; use <code>GetErrno</code> to examine the error
</p>
</dd>
<dt>flush</dt><dd><p><code>signature(con="FileOutputStream")</code>:
Flushes FileOutputStream's buffers but does not close the underlying file
</p>
</dd>
<dt>GetErrno</dt><dd><p><code>signature(object="FileInputStream")</code>:
If an I/O error has occurred on this file descriptor, this is the errno from that error.
Otherwise, this is zero. Once an error occurs, the stream is broken and all subsequent operations will fail.
</p>
</dd>
<dt>SetCloseOnDelete</dt><dd><p><code>signature(object="FileOutputStream")</code>:
set the close on delete behavior.
</p>
</dd>
</dl>

<p>See <a href="#topic+ZeroCopyOutputStream-class">ZeroCopyOutputStream</a> for inherited methods
</p>


<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>References</h3>

<p> The <code>FileOutputStream</code> class from the protobuf C++ library.</p>


<h3>See Also</h3>

<p><a href="#topic+ZeroCopyOutputStream-class">ZeroCopyOutputStream</a> for methods
</p>

<hr>
<h2 id='FileOutputStream-methods'>Creates an FileOutputStream</h2><span id='topic+FileOutputStream'></span><span id='topic+FileOutputStream-methods'></span><span id='topic+FileOutputStream+2Ccharacter+2Cinteger+2Clogical-method'></span>

<h3>Description</h3>

<p>Constructor for <a href="#topic+FileOutputStream-class">FileOutputStream</a> objects
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(filename = "character", block_size = "logical", close.on.delete = "logical" )</code></dt><dd><p>Creates a <a href="#topic+FileOutputStream-class">FileOutputStream</a> writing to the given file.</p>
</dd>
</dl>

<hr>
<h2 id='GetErrno-methods'>Get the error number for an I/O error</h2><span id='topic+GetErrno'></span><span id='topic+GetErrno-methods'></span>

<h3>Description</h3>

<p>If an I/O error has occurred on this file descriptor, 
this is the errno from that error
</p>


<h3>Methods</h3>

<p>See classes <a href="#topic+FileInputStream-class">FileInputStream</a> and 
<a href="#topic+FileOutputStream-class">FileOutputStream</a> for implementations.
</p>

<hr>
<h2 id='has-methods'>Indicates if an object has the given field set</h2><span id='topic+has'></span><span id='topic+has-methods'></span><span id='topic+has+2CMessage-method'></span>

<h3>Description</h3>

<p>This generic method, currently implemented
for <a href="#topic+Message-class">Message</a> and <a href="#topic+EnumDescriptor-class">EnumDescriptor</a> indicates if the
message or enum descriptor has the given field set. 
</p>
<p>For messages and non-repeated fields, a call to the <code>HasField</code>
method of the corresponding <code>Message</code> is issued.
</p>
<p>For messages and repeated fields, a call to the <code>FieldSize</code>
method is issued, and the message is declared to have 
the field if the size is greater than 0.
</p>
<p><code>NULL</code> is returned if the descriptor for the message does not
contain the given field at all.
</p>
<p>For EnumDescriptors, a boolean value indicates if the given name is
present in the enum definition.
</p>


<h3>Methods</h3>


<dl>
<dt>has</dt><dd><p><code>signature(object = "Message")</code>:
Indicates if the message has a given field.</p>
</dd>
<dt>has</dt><dd><p><code>signature(object = "EnumDescriptor")</code>:
Indicates if the EnumDescriptor has a given named element.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>unitest.proto.file &lt;- system.file("tinytest", "data", "unittest.proto",
				  package = "RProtoBuf" )
readProtoFiles(file = unitest.proto.file)

test &lt;- new(protobuf_unittest.TestAllTypes)
test$has("optional_int32")
# FALSE
test$add("repeated_int32", 1:10)
test$has("repeated_int32")
# TRUE
test$has("nonexistant")
# NULL

has(protobuf_unittest.TestAllTypes$NestedEnum, "FOO")
has(protobuf_unittest.TestAllTypes$NestedEnum, "BAR")
has(protobuf_unittest.TestAllTypes$NestedEnum, "XXX")
</code></pre>

<hr>
<h2 id='is_extension-methods'>Indicates if a field descriptor is an extension</h2><span id='topic+is_extension'></span><span id='topic+is_extension-methods'></span>

<h3>Description</h3>

<p>Indicates if a field descriptor is an extension
</p>


<h3>See Also</h3>

<p>The method is implemented for the <a href="#topic+FieldDescriptor-class">FieldDescriptor</a> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Person &lt;- P( "tutorial.Person" )
is_extension(Person$id)
</code></pre>

<hr>
<h2 id='isInitialized-methods'>Indicates if a protocol buffer message is initialized</h2><span id='topic+isInitialized'></span><span id='topic+isInitialized-methods'></span><span id='topic+isInitialized+2CMessage-method'></span>

<h3>Description</h3>

<p>Indicates if a <a href="#topic+Message-class">Message</a> is 
initialized. A message is initialized if all its 
required fields are set.
</p>


<h3>Methods</h3>


<dl>
<dt><code> signature(object = "Message")</code></dt><dd><p> is the message initialized</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>message &lt;- new( tutorial.Person, name = "" )
isInitialized( message ) # FALSE (id is not set)
message$isInitialized()  # FALSE

message &lt;- new( tutorial.Person, name = "", id = 2 )
isInitialized( message ) # TRUE
message$isInitialized()  # TRUE

</code></pre>

<hr>
<h2 id='label-methods'>Gets the label of a field</h2><span id='topic+label'></span><span id='topic+label-methods'></span><span id='topic+LABEL_OPTIONAL'></span><span id='topic+LABEL_REQUIRED'></span><span id='topic+LABEL_REPEATED'></span>

<h3>Description</h3>

<p>Gets the label of a field (optional, required, or repeated).
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="label-methods_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+FieldDescriptor-class">FieldDescriptor</a> object.</p>
</td></tr>
<tr><td><code id="label-methods_+3A_as.string">as.string</code></td>
<td>
<p>If true, print a string representation of the type.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The method is implemented for the <a href="#topic+FieldDescriptor-class">FieldDescriptor</a> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
proto.file &lt;- system.file( "proto", "addressbook.proto", package = "RProtoBuf" )
Person &lt;- P( "tutorial.Person", file = proto.file )

## End(Not run)


label(Person$id)
label(Person$email)
label(Person$phone)
label(Person$id, TRUE)
label(Person$email, TRUE)
label(Person$phone, TRUE)
LABEL_OPTIONAL
LABEL_REQUIRED
LABEL_REPEATED
</code></pre>

<hr>
<h2 id='merge-methods'>Merge two messages of the same type</h2><span id='topic+merge+2CMessage+2CMessage-method'></span>

<h3>Description</h3>

<p>Merge two <a href="#topic+Message-class">Message</a> objects
of the same type.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "Message", y = "Message")</code></dt><dd><p> merge two messages of the same type </p>
</dd>
</dl>


<h3>Errors</h3>

<p>An error of class &quot;IncompatibleType&quot; is thrown if 
the two messages are not of the same message type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m1 &lt;- new( tutorial.Person, email = "francoisromain@free.fr" )
m2 &lt;- new( tutorial.Person, id = 5 )
m3 &lt;- merge( m1, m2 )
writeLines( as.character( m1 ) )
writeLines( as.character( m2 ) )
writeLines( as.character( m3 ) )

</code></pre>

<hr>
<h2 id='Message-class'>Class &quot;Message&quot; </h2><span id='topic+Message-class'></span><span id='topic+as.character+2CMessage-method'></span><span id='topic++24+3C-+2CMessage-method'></span><span id='topic++24+2CMessage-method'></span><span id='topic++5B+5B+2CMessage-method'></span><span id='topic++5B+5B+3C-+2CMessage-method'></span><span id='topic+serialize+2CMessage-method'></span><span id='topic+show+2CMessage-method'></span><span id='topic+update+2CMessage-method'></span><span id='topic+length+2CMessage-method'></span><span id='topic+names+2CMessage-method'></span><span id='topic+str+2CMessage-method'></span><span id='topic+toString+2CMessage-method'></span><span id='topic+toJSON'></span><span id='topic+toJSON+2CMessage-method'></span><span id='topic+identical+2CMessage+2CMessage-method'></span><span id='topic++3D+3D+2CMessage+2CMessage-method'></span><span id='topic++21+3D+2CMessage+2CMessage-method'></span><span id='topic+all.equal+2CMessage+2CMessage-method'></span><span id='topic+getExtension+2CMessage-method'></span><span id='topic+setExtension+2CMessage-method'></span><span id='topic+getExtension'></span><span id='topic+setExtension'></span>

<h3>Description</h3>

<p>R representation of protocol buffer messages. This is a thin wrapper
around the <code>Message</code> c++ class that holds the actual message
as an external pointer.
</p>


<h3>Objects from the Class</h3>

<p>Objects are typically created by the <code>new</code> function invoked
on a <a href="#topic+Descriptor-class">Descriptor</a> object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p>external pointer to the c++ <code>Message</code> object</p>
</dd>
<dt><code>type</code>:</dt><dd><p>fully qualified name of the message type</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.character</dt><dd><p><code>signature(x = "Message")</code>: returns the debug string of the message.
This is built from a call to the <code>DebugString</code> method of the <code>Message</code> object</p>
</dd>
<dt>toString</dt><dd><p><code>signature(x = "Message")</code>: same as <code>as.character</code> </p>
</dd>
<dt>toTextFormat</dt><dd><p><code>signature(x = "Message")</code>: returns the TextFormat of the message.
This is built from a call to <code>TextFormat::PrintToString</code> with the <code>Message</code> object</p>
</dd>
<dt>toDebugString</dt><dd><p><code>signature(x = "Message")</code>: same as <code>as.character</code> </p>
</dd>
<dt>toJSON</dt><dd><p><code>signature(x = "Message")</code>: returns the JSON representation of the message.
This is built from a call to the
<code>google::protobuf::util::MessageToJsonString</code> method and
accepts two arguments <code>preserve_proto_field_names</code> - if FALSE (the default) convert field names to camelCase
<code>always_print_primitive_fields</code> - whether to return the default
value for missing primitive fields (default false)</p>
</dd>
<dt>$&lt;-</dt><dd><p><code>signature(x = "Message")</code>: set the value of a field of the message. </p>
</dd>
<dt>$</dt><dd><p><code>signature(x = "Message")</code>: gets the value of a field.
Primitive types are brought back to R as R objects of the closest matching R type.
Messages are brought back as instances of the <code>Message</code> class.</p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "Message")</code>: extracts a field identified by its name or declared tag number </p>
</dd>
<dt>[[&lt;-</dt><dd><p><code>signature(x = "Message")</code>: replace the value of a field identified by its name or declared tag number </p>
</dd>
<dt>serialize</dt><dd><p><code>signature(object = "Message")</code>: serialize a message. If the
&quot;connection&quot; argument is <code>NULL</code>, the payload of the message is returned as a raw vector,
if the &quot;connection&quot; argument is a binary writable connection, the payload is written into the
connection. If &quot;connection&quot; is a character vector, the message is sent to
the file (in binary format). </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Message")</code>: displays a short text about the message </p>
</dd>
<dt>update</dt><dd><p><code>signature(object = "Message")</code>: set several fields of the message at once </p>
</dd>
<dt>length</dt><dd><p><code>signature(x = "Message")</code>: The number of fields actually contained in the message.
A field counts in these two situations: the field is repeated and the field size is greater than 0,
the field is not repeated and the message has the field.</p>
</dd>
<dt>setExtension</dt><dd><p><code>signature(object = "Message")</code>: set an
extension field of the Message.</p>
</dd>
<dt>getExtension</dt><dd><p><code>signature(object = "Message")</code>: get the
value of an extension field of the Message.</p>
</dd>
<dt>str</dt><dd><p><code>signature(object = "Message")</code>: displays the structure of the message </p>
</dd>
<dt>identical</dt><dd><p><code>signature(x = "Message", y = "Message")</code>: Test if two messages are exactly identical </p>
</dd>
<dt>==</dt><dd><p><code>signature(e1 = "Message", e2 = "Message")</code>: Same as <code>identical</code> </p>
</dd>
<dt>!=</dt><dd><p><code>signature(e1 = "Message", e2 = "Message")</code>: Negation of <code>identical</code> </p>
</dd>
<dt>all.equal</dt><dd><p><code>signature(e1 = "Message", e2 = "Message")</code>: Test near equality </p>
</dd>
<dt>names</dt><dd><p><code>signature(x = "Message")</code>: extracts the names of the message. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>References</h3>

<p>The <code>Message</code> class from the C++ proto library.</p>


<h3>See Also</h3>

<p><code><a href="#topic+P">P</a></code> creates objects of class <a href="#topic+Descriptor-class">Descriptor</a> that
can be used to create messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example proto file supplied with this package
proto.file &lt;- system.file( "proto", "addressbook.proto", package = "RProtoBuf" )

# reading a proto file and creating the descriptor
Person &lt;- P( "tutorial.Person", file = proto.file )

## End(Not run)


PhoneNumber &lt;- P( "tutorial.Person.PhoneNumber" )

# creating a prototype message from the descriptor
p &lt;- new( Person )
p$email # not set, returns default value
p$id    # not set, returns default value
as.character( p ) # empty
has( p, "email" ) # is the "email" field set
has( p, "phone" ) # is the "email" field set
length( p )       # number of fields actually set

# update several fields at once
romain &lt;- update( new( Person ),
	email = "francoisromain@free.fr",
	id = 1,
	name = "Romain Francois",
	phone = new( PhoneNumber , number = "+33(0)...", type = "MOBILE" )
	)

# supply parameters to the constructor
dirk &lt;- new( Person,
	email = "edd@debian.org",
	id = 2,
	name = "Dirk Eddelbuettel" )
# update the phone repeated field with a list of PhoneNumber messages
dirk$phone &lt;- list(
	new( PhoneNumber , number = "+01...", type = "MOBILE" ),
	new( PhoneNumber , number = "+01...", type = "HOME" ) )

# with/within style
saptarshi &lt;- within( new(Person), {
	id &lt;- 3
	name &lt;- "Saptarshi Guha"
	email &lt;- "saptarshi.guha@gmail.com"
} )

# make an addressbook
book &lt;- new( tutorial.AddressBook, person = list( romain, dirk, saptarshi ) )

# serialize the message to a file
tf &lt;- tempfile( )
serialize( book, tf )

# the payload of the message
serialize( book, NULL )

# read the file into a new message
m &lt;- tutorial.AddressBook$read( tf )
writeLines( as.character( m ) )
sapply( m$person, function(p) p$name )
</code></pre>

<hr>
<h2 id='MethodDescriptor-class'>Class &quot;MethodDescriptor&quot;</h2><span id='topic+MethodDescriptor-class'></span><span id='topic+as.character+2CMethodDescriptor-method'></span><span id='topic+toString+2CMethodDescriptor-method'></span><span id='topic++24+2CMethodDescriptor-method'></span><span id='topic++24+3C-+2CMethodDescriptor-method'></span><span id='topic+input_type'></span><span id='topic+input_type-methods'></span><span id='topic+input_type+2CMethodDescriptor-method'></span><span id='topic+output_type'></span><span id='topic+output_type-methods'></span><span id='topic+output_type+2CMethodDescriptor-method'></span>

<h3>Description</h3>

<p>R representation of Service Descriptors</p>


<h3>Objects from the Class</h3>

<p>TODO
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p>External pointer to a <code>google::protobuf::MethodDescriptor</code> C++ object </p>
</dd>
<dt><code>name</code>:</dt><dd><p>fully qualified name of the method</p>
</dd>
<dt><code>service</code>:</dt><dd><p>fully qualified name of the service that defines this method</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.character</dt><dd><p><code>signature(x = "MethodDescriptor")</code>: debug string of the method </p>
</dd>
<dt>toString</dt><dd><p><code>signature(x = "MethodDescriptor")</code>: debug string of the method</p>
</dd>
<dt>$</dt><dd><p><code>signature(x = "MethodDescriptor")</code>: ... </p>
</dd>
<dt>$&lt;-</dt><dd><p><code>signature(x = "MethodDescriptor")</code>: ... </p>
</dd>
<dt>input_type</dt><dd><p><code>signature(object = "MethodDescriptor")</code>: the <a href="#topic+Descriptor-class">Descriptor</a> of the input type of the method</p>
</dd>
<dt>output_type</dt><dd><p><code>signature(object = "MethodDescriptor")</code>: the <a href="#topic+Descriptor-class">Descriptor</a> of the output type of the method </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>

<hr>
<h2 id='name'>Name or full name of a descriptor</h2><span id='topic+name'></span><span id='topic+name-methods'></span><span id='topic+name+2CDescriptor-method'></span><span id='topic+name+2CFieldDescriptor-method'></span><span id='topic+name+2CEnumDescriptor-method'></span><span id='topic+name+2CServiceDescriptor-method'></span><span id='topic+name+2CMethodDescriptor-method'></span>

<h3>Description</h3>

<p>name or full name of a descriptor
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Descriptor")</code></dt><dd><p> ... </p>
</dd>
<dt><code>signature(object = "FieldDescriptor")</code></dt><dd><p> ... </p>
</dd>
<dt><code>signature(object = "EnumDescriptor")</code></dt><dd><p> ... </p>
</dd>
<dt><code>signature(object = "ServiceDescriptor")</code></dt><dd><p> ... </p>
</dd>
<dt><code>signature(object = "MethodDescriptor")</code></dt><dd><p> ... </p>
</dd>
</dl>

<hr>
<h2 id='nested_type_count-methods'>The number of fields</h2><span id='topic+nested_type_count'></span><span id='topic+nested_type_count-methods'></span>

<h3>Description</h3>

<p>The number of fields 
</p>


<h3>See Also</h3>

<p>The method is implemented for the <a href="#topic+Descriptor-class">Descriptor</a> class
</p>

<hr>
<h2 id='nested_type-methods'>Extract a message type descriptor for a nested type</h2><span id='topic+nested_type'></span><span id='topic+nested_type-methods'></span>

<h3>Description</h3>

<p>Extract a <a href="#topic+Descriptor-class">Descriptor</a> nested in another 
<a href="#topic+Descriptor-class">Descriptor</a>
</p>


<h3>See Also</h3>

<p>The method is implemented for the <a href="#topic+Descriptor-class">Descriptor</a> class
</p>

<hr>
<h2 id='Next-methods'>Obtains a chunk of data from the stream</h2><span id='topic+Next'></span><span id='topic+Next-methods'></span>

<h3>Description</h3>

<p>Obtains a chunk of data from the stream
</p>


<h3>See Also</h3>

<p><a href="#topic+ZeroCopyInputStream-class">ZeroCopyInputStream</a> implements Next.
</p>

<hr>
<h2 id='number-methods'>Gets the declared tag number of a field</h2><span id='topic+number'></span><span id='topic+number-methods'></span>

<h3>Description</h3>

<p>Gets the declared tag number of a field
</p>


<h3>See Also</h3>

<p>The method is implemented for <a href="#topic+FieldDescriptor-class">FieldDescriptor</a> and
<a href="#topic+EnumValueDescriptor-class">EnumValueDescriptor</a> classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
proto.file &lt;- system.file( "proto", "addressbook.proto", package = "RProtoBuf" )
Person &lt;- P( "tutorial.Person", file = proto.file )

## End(Not run)


number(Person$id)
number(Person$email)
as.character(Person)

number(value(tutorial.Person$PhoneType, name="HOME"))
</code></pre>

<hr>
<h2 id='P'>Protocol Buffer descriptor importer</h2><span id='topic+P'></span>

<h3>Description</h3>

<p>The <code>P</code> function searches for a protocol message
descriptor in the descriptor pool.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>P(type, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="P_+3A_type">type</code></td>
<td>
<p>Fully qualified type name of the protocol buffer or extension</p>
</td></tr>
<tr><td><code id="P_+3A_file">file</code></td>
<td>
<p>optional proto file. If given, the definition
contained in the file is first registered with the 
pool of message descriptors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+Descriptor-class">Descriptor</a> for message types or
<a href="#topic+FieldDescriptor-class">FieldDescriptor</a> for extensions.  An error is generated otherwise.
</p>


<h3>Author(s)</h3>

<p>Romain Francois &lt;francoisromain@free.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
proto.file &lt;- system.file( "proto", "addressbook.proto", package = "RProtoBuf" ) 
Person &lt;- P( "tutorial.Person", file = proto.file )

## End(Not run)


cat(as.character( Person ))
</code></pre>

<hr>
<h2 id='read-methods'>Read a protocol buffer message from a connection</h2><span id='topic+read'></span><span id='topic+read-methods'></span><span id='topic+read+2CDescriptor+2Ccharacter-method'></span><span id='topic+read+2CDescriptor+2Craw-method'></span><span id='topic+read+2CDescriptor+2CANY-method'></span>

<h3>Description</h3>

<p>Read a <a href="#topic+Message-class">Message</a> from a 
connection using its associated <a href="#topic+Descriptor-class">Descriptor</a>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(descriptor = "Descriptor", input = "character")</code></dt><dd><p> Read the message from a file </p>
</dd>
<dt><code>signature(descriptor = "Descriptor")</code></dt><dd><p> Read from a binary connection.  </p>
</dd>
<dt><code>signature(descriptor = "Descriptor", input = "raw")</code></dt><dd><p> Read the message from a raw vector </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># example file that contains a "tutorial.AddressBook" message
book &lt;- system.file( "examples", "addressbook.pb", package = "RProtoBuf" )

# read the message
message &lt;- read( tutorial.AddressBook, book )

# or using the pseudo method 
message &lt;- tutorial.AddressBook$read( book )

# write its debug string
writeLines( as.character( message ) )

# grab the name of each person
sapply( message$person, function(p) p$name )

# read from a binary file connection
f &lt;- file( book, open = "rb" )
message2 &lt;- read( tutorial.AddressBook, f )
close( f )

# read from a message payload (raw vector)
payload &lt;- readBin( book, raw(0), 5000 )
message3 &lt;- tutorial.AddressBook$read( payload )



</code></pre>

<hr>
<h2 id='readASCII-methods'>read a message in ASCII format</h2><span id='topic+readASCII'></span><span id='topic+readASCII-methods'></span><span id='topic+readASCII+2CDescriptor+2CANY-method'></span><span id='topic+readASCII+2CDescriptor+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Method to read a Message in ASCII format
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(descriptor = "Descriptor", input = "ANY")</code></dt><dd>
<p>Read the message from a connection (file, etc ...)
</p>
</dd>
<dt><code>signature(descriptor = "Descriptor", input = "character")</code></dt><dd>
<p>Read the message directly from the character string
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example file that contains a "tutorial.AddressBook" message
book &lt;- system.file( "examples", "addressbook.pb", package = "RProtoBuf" )

# read the message
message &lt;- read( tutorial.AddressBook, book )

# Output in text format to a temporary file
out.file &lt;- tempfile()
writeLines( as.character(message), file(out.file))

# Verify that we can read back in the message from a text file.
message2 &lt;- readASCII( tutorial.AddressBook, file(out.file, "rb"))

# Verify that we can read back in the message from an unopened file.
message3 &lt;- readASCII( tutorial.AddressBook, file(out.file))

\dontshow{
stopifnot( identical( message, message2) )
}

## End(Not run)
</code></pre>

<hr>
<h2 id='readJSON-methods'>read a message in JSON format</h2><span id='topic+readJSON'></span><span id='topic+readJSON-methods'></span><span id='topic+readJSON+2CDescriptor+2CANY-method'></span><span id='topic+readJSON+2CDescriptor+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Method to read a Message in JSON format
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(descriptor = "Descriptor", input = "ANY")</code></dt><dd>
<p>Read the message from a connection (file, etc ...)
</p>
</dd>
<dt><code>signature(descriptor = "Descriptor", input = "character")</code></dt><dd>
<p>Read the message directly from the character string
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example file that contains a "tutorial.AddressBook" message
book &lt;- system.file( "examples", "addressbook.pb", package = "RProtoBuf" )

# read the message
message &lt;- read( tutorial.AddressBook, book )

# Output in text format to a temporary file
out.file &lt;- tempfile()
writeLines( message$toJSON(), file(out.file))

# Verify that we can read back in the message from a text file.
message2 &lt;- readJSON( tutorial.AddressBook, file(out.file, "rb"))

# Verify that we can read back in the message from an unopened file.
message3 &lt;- readJSON( tutorial.AddressBook, file(out.file))

\dontshow{
stopifnot( identical( message, message2) )
}

## End(Not run)
</code></pre>

<hr>
<h2 id='readProtoFiles'>protocol buffer descriptor importer</h2><span id='topic+readProtoFiles'></span><span id='topic+readProtoFiles2'></span><span id='topic+resetDescriptorPool'></span>

<h3>Description</h3>

<p>Imports proto files into the descriptor pool that 
is then used by the <code>P</code> function to resolve
message type names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  readProtoFiles(files, dir, package="RProtoBuf", pattern="\\.proto$", lib.loc=NULL)
  readProtoFiles2(files, dir=".", pattern="\\.proto$", recursive=FALSE, protoPath=getwd())
  resetDescriptorPool()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readProtoFiles_+3A_files">files</code></td>
<td>
<p>Proto files</p>
</td></tr>
<tr><td><code id="readProtoFiles_+3A_dir">dir</code></td>
<td>
<p>Directory. If <code>files</code> is not specified, files
with the &quot;proto&quot; extension in the <code>dir</code> directory 
are imported</p>
</td></tr>
<tr><td><code id="readProtoFiles_+3A_package">package</code></td>
<td>
<p>R package name. If <code>files</code> and <code>dir</code> are
missing, &quot;proto&quot; files in the &quot;proto&quot; directory of the 
package tree are imported.</p>
</td></tr>
<tr><td><code id="readProtoFiles_+3A_pattern">pattern</code></td>
<td>
<p>A filename pattern to match proto files when using <code>dir</code>.</p>
</td></tr>
<tr><td><code id="readProtoFiles_+3A_recursive">recursive</code></td>
<td>
<p>Whether to descend recursively into <code>dir</code>.</p>
</td></tr>
<tr><td><code id="readProtoFiles_+3A_lib.loc">lib.loc</code></td>
<td>
<p>Library location.</p>
</td></tr>
<tr><td><code id="readProtoFiles_+3A_protopath">protoPath</code></td>
<td>
<p>Search path for proto file imports.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>readProtoFiles2</code> is different from <code>readProtoFiles</code> to be
consistent with the behavior of <code>protoc</code> command line tool in
being explicit about the search path for proto import statements. In addition,
we also require that both <code>files</code> and <code>dir</code> arguments are
interpreted relative to <code>protoPath</code>, so that there is consistency in
future imports of the same files through import statements of other proto
files.
</p>
<p><code>resetDescriptorPool</code> clears all imported proto definitions.
</p>


<h3>Value</h3>

<p><code>NULL</code>, invisibly.</p>


<h3>Author(s)</h3>

<p>Romain Francois &lt;francoisromain@free.fr&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+P">P</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# from a package
readProtoFiles(package = "RProtoBuf")

# from a directory
proto.dir &lt;- system.file("proto", package = "RProtoBuf")
readProtoFiles(dir = proto.dir)

# set of files
proto.files &lt;- list.files(proto.dir, full.names = TRUE)
readProtoFiles(proto.files)

## End(Not run)
</code></pre>

<hr>
<h2 id='serialize_pb'>Serialize R object to Protocol Buffer Message.</h2><span id='topic+can_serialize_pb'></span><span id='topic+serialize_pb'></span><span id='topic+unserialize_pb'></span>

<h3>Description</h3>

<p>Serializes R objects to a general purpose protobuf message using the same
<code>rexp.proto</code> descriptor and mapping between R objects and protobuf
mesages as RHIPE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serialize_pb(object, connection, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serialize_pb_+3A_object">object</code></td>
<td>
<p>R object to serialize</p>
</td></tr>
<tr><td><code id="serialize_pb_+3A_connection">connection</code></td>
<td>
<p>passed on to  <code><a href="base.html#topic+serialize">serialize</a></code></p>
</td></tr>
<tr><td><code id="serialize_pb_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to  <code><a href="base.html#topic+serialize">serialize</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clients need both the message and the <code>rexp.proto</code> descriptor to parse
serialized R objects. The latter is included in the the package installation
<code>proto</code> directory: <code>system.file(package="RProtoBuf", "proto/rexp.proto")</code>
</p>
<p>The following storage types are natively supported by the descriptor:
<code>character</code>, <code>raw</code>, <code>double</code>, <code>complex</code>, <code>integer</code>,
<code>list</code>, and <code>NULL</code>. Objects with other storage types, such as
functions, environments, S4 classes, etc, are serialized using base R
<code><a href="base.html#topic+serialize">serialize</a></code> and stored in the proto <code>native</code> type.
Missing values, attributes and numeric precision will be preserved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>msg &lt;- tempfile();
serialize_pb(iris, msg);
obj &lt;- unserialize_pb(msg);
identical(iris, obj);

</code></pre>

<hr>
<h2 id='ServiceDescriptor-class'>Class &quot;ServiceDescriptor&quot;</h2><span id='topic+ServiceDescriptor-class'></span><span id='topic+as.character+2CServiceDescriptor-method'></span><span id='topic+toString+2CServiceDescriptor-method'></span><span id='topic+show+2CServiceDescriptor-method'></span><span id='topic++24+2CServiceDescriptor-method'></span><span id='topic++5B+5B+2CServiceDescriptor-method'></span><span id='topic+length+2CServiceDescriptor-method'></span><span id='topic+method_count'></span><span id='topic+method_count-methods'></span><span id='topic+method_count+2CServiceDescriptor-method'></span><span id='topic+method'></span><span id='topic+method-methods'></span><span id='topic+method+2CServiceDescriptor-method'></span>

<h3>Description</h3>

<p>R representation of Service Descriptors</p>


<h3>Objects from the Class</h3>

<p>TODO
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p>External pointer to a <code>google::protobuf::ServiceDescriptor</code> C++ object </p>
</dd>
<dt><code>name</code>:</dt><dd><p>fully qualified name of the service </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.character</dt><dd><p><code>signature(x = "ServiceDescriptor")</code>: debug string of the service </p>
</dd>
<dt>toString</dt><dd><p><code>signature(x = "ServiceDescriptor")</code>: debug string of the service</p>
</dd>
<dt>show</dt><dd><p><code>signature(x = "ServiceDescriptor")</code>: ... </p>
</dd>
<dt>$</dt><dd><p><code>signature(x = "ServiceDescriptor")</code>: invoke pseudo methods or retrieve
method descriptors contained in this service descriptor. </p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "ServiceDescriptor")</code>: extracts methods
descriptors contained in this service descriptor</p>
</dd>
<dt>length</dt><dd><p><code>signature(x = "ServiceDescriptor")</code>: number of <a href="#topic+MethodDescriptor-class">MethodDescriptor</a> </p>
</dd>
<dt>method_count</dt><dd><p><code>signature(x = "ServiceDescriptor")</code>: number of <a href="#topic+MethodDescriptor-class">MethodDescriptor</a> </p>
</dd>
<dt>method</dt><dd><p><code>signature(x = "ServiceDescriptor")</code>: retrieves a <a href="#topic+MethodDescriptor-class">MethodDescriptor</a> </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>

<hr>
<h2 id='set-methods'>set a subset of values of a repeated field of a message</h2><span id='topic+set'></span><span id='topic+set-methods'></span><span id='topic+set+2CMessage-method'></span>

<h3>Description</h3>

<p>set a subset of values of a repeated field of a message
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Message")</code></dt><dd><p>set a subset of values of a repeated field of a message</p>
</dd>
</dl>

<hr>
<h2 id='SetCloseOnDelete-methods'>set the close on delete behavior</h2><span id='topic+SetCloseOnDelete'></span><span id='topic+SetCloseOnDelete-methods'></span>

<h3>Description</h3>

<p>By default, the file descriptor is not closed when a stream is destroyed, 
use <code>SetCloseOnDelete( stream, TRUE ) </code> to change that.
</p>


<h3>Methods</h3>

<p>See classes <a href="#topic+FileInputStream-class">FileInputStream</a> and 
<a href="#topic+FileOutputStream-class">FileOutputStream</a> for implementations.
</p>

<hr>
<h2 id='size-methods'>Size of a message field</h2><span id='topic+size'></span><span id='topic+size-methods'></span><span id='topic+size+2CMessage-method'></span>

<h3>Description</h3>

<p>The number of object currently in a given field of a protocol buffer
message. 
</p>
<p>For non repeated fields, the size is 1 if the message has the field, 0 otherwise. 
</p>
<p>For repeated fields, the size is the number of objects in the array.
</p>
<p>For repeated fields, the size can also be assigned to in order to shrink
or grow the vector.  Numeric types are given a default value of 0 when
the new size is greater than the existing size.  Character types are
given a default value of &quot;&quot;.  Growing a repeated field in this way is
not supported for message, group, and enum types.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Message")</code></dt><dd><p>Number of objects in a message field</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>unitest.proto.file &lt;- system.file("tinytest", "data", "unittest.proto",
				  package = "RProtoBuf" )
readProtoFiles(file = unitest.proto.file)

test &lt;- new(protobuf_unittest.TestAllTypes)
test$size("optional_int32")

test$add("repeated_int32", 1:10)
test$size("repeated_int32")
test$repeated_int32

size(test, "repeated_int32") &lt;- 5
test$repeated_int32

size(test, "repeated_int32") &lt;- 15
test$repeated_int32
</code></pre>

<hr>
<h2 id='sizegets'>Set the size of a field</h2><span id='topic+size+3C-'></span><span id='topic+size+3C--methods'></span><span id='topic+size+3C-+2CMessage-method'></span>

<h3>Description</h3>

<p>Sets the size of a repeated field.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Message")</code></dt><dd><p> sets the size of a message field </p>
</dd>
</dl>

<hr>
<h2 id='Skip-methods'>Skips a number of bytes</h2><span id='topic+Skip'></span><span id='topic+Skip-methods'></span>

<h3>Description</h3>

<p>Skips a number of bytes
</p>

<hr>
<h2 id='swap-methods'>swap elements of a repeated field of a message</h2><span id='topic+swap'></span><span id='topic+swap-methods'></span><span id='topic+swap+2CMessage-method'></span>

<h3>Description</h3>

<p>swap elements of a repeated field of a message.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Message")</code></dt><dd><p>swap elements of a repeated field of a message</p>
</dd>
</dl>


<h3>References</h3>

<p>See the <code>SwapElements</code> of the <code>Reflection</code> class, part of the protobuf library.</p>

<hr>
<h2 id='type-methods'>Gets the type or the C++ type of a field</h2><span id='topic+type'></span><span id='topic+type-methods'></span><span id='topic+cpp_type'></span><span id='topic+cpp_type-methods'></span><span id='topic+TYPE_DOUBLE'></span><span id='topic+TYPE_FLOAT'></span><span id='topic+TYPE_INT64'></span><span id='topic+TYPE_UINT64'></span><span id='topic+TYPE_INT32'></span><span id='topic+TYPE_FIXED64'></span><span id='topic+TYPE_FIXED32'></span><span id='topic+TYPE_BOOL'></span><span id='topic+TYPE_STRING'></span><span id='topic+TYPE_GROUP'></span><span id='topic+TYPE_MESSAGE'></span><span id='topic+TYPE_BYTES'></span><span id='topic+TYPE_UINT32'></span><span id='topic+TYPE_ENUM'></span><span id='topic+TYPE_SFIXED32'></span><span id='topic+TYPE_SFIXED64'></span><span id='topic+TYPE_SINT32'></span><span id='topic+TYPE_SINT64'></span><span id='topic+CPPTYPE_INT32'></span><span id='topic+CPPTYPE_INT64'></span><span id='topic+CPPTYPE_UINT32'></span><span id='topic+CPPTYPE_UINT64'></span><span id='topic+CPPTYPE_DOUBLE'></span><span id='topic+CPPTYPE_FLOAT'></span><span id='topic+CPPTYPE_BOOL'></span><span id='topic+CPPTYPE_ENUM'></span><span id='topic+CPPTYPE_STRING'></span><span id='topic+CPPTYPE_MESSAGE'></span>

<h3>Description</h3>

<p>Gets the type or the C++ type of a field
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="type-methods_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+FieldDescriptor-class">FieldDescriptor</a> object.</p>
</td></tr>
<tr><td><code id="type-methods_+3A_as.string">as.string</code></td>
<td>
<p>If true, print a string representation of the type.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The method is implemented for the <a href="#topic+FieldDescriptor-class">FieldDescriptor</a> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
proto.file &lt;- system.file( "proto", "addressbook.proto", package = "RProtoBuf" )
Person &lt;- P( "tutorial.Person", file = proto.file )

## End(Not run)

type(Person$id)
type(Person$id, as.string=TRUE)
cpp_type(Person$email)
cpp_type(Person$email, TRUE)
</code></pre>

<hr>
<h2 id='with.Message'>
with and within methods for protocol buffer messages
</h2><span id='topic+with.Message'></span><span id='topic+within.Message'></span>

<h3>Description</h3>

<p>Convenience wrapper that allow getting and setting 
fields of protocol buffer messages from within the object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Message'
with(data, expr, ...)
## S3 method for class 'Message'
within(data, expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with.Message_+3A_data">data</code></td>
<td>
<p>A protocol buffer message, instance of <a href="#topic+Message-class">Message</a> </p>
</td></tr>
<tr><td><code id="with.Message_+3A_expr">expr</code></td>
<td>
<p>R expression to evaluate</p>
</td></tr>
<tr><td><code id="with.Message_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expression is evaluated in an environment 
that allows to set and get fields of the message
</p>
<p>The fields of the message are mapped to active bindings
(see <a href="base.html#topic+makeActiveBinding">makeActiveBinding</a>) so that they can be accessed
and modified from within the environment. 
</p>


<h3>Value</h3>

<p><code>with</code> returns the value of the expression and 
<code>within</code> returns the <code>data</code> argument.
</p>


<h3>Author(s)</h3>

<p>Romain Francois &lt;francoisromain@free.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
proto.file &lt;- system.file( "proto", "addressbook.proto", package = "RProtoBuf" ) 
Person &lt;- P( "tutorial.Person", file = proto.file )

## End(Not run)

romain &lt;- within( new( Person ), {
	email &lt;- "francoisromain@free.fr"
	id &lt;- 10L
} )
</code></pre>

<hr>
<h2 id='ZeroCopyInputStream-class'>Virtual Class &quot;ZeroCopyInputStream&quot; </h2><span id='topic+ZeroCopyInputStream-class'></span><span id='topic+Skip+2CZeroCopyInputStream-method'></span><span id='topic+ByteCount+2CZeroCopyInputStream-method'></span><span id='topic+BackUp+2CZeroCopyInputStream-method'></span><span id='topic+Next+2CZeroCopyInputStream+2Cmissing-method'></span><span id='topic++24+2CZeroCopyInputStream-method'></span><span id='topic+ReadRaw'></span><span id='topic+ReadRaw-methods'></span><span id='topic+ReadRaw+2CZeroCopyInputStream+2Cinteger-method'></span><span id='topic+ReadRaw+2CZeroCopyInputStream+2Cnumeric-method'></span><span id='topic+ReadString'></span><span id='topic+ReadString-methods'></span><span id='topic+ReadString+2CZeroCopyInputStream+2Cinteger-method'></span><span id='topic+ReadString+2CZeroCopyInputStream+2Cnumeric-method'></span><span id='topic+ReadVarint32'></span><span id='topic+ReadVarint32-methods'></span><span id='topic+ReadVarint32+2CZeroCopyInputStream-method'></span><span id='topic+ReadLittleEndian32'></span><span id='topic+ReadLittleEndian32-methods'></span><span id='topic+ReadLittleEndian32+2CZeroCopyInputStream-method'></span><span id='topic+ReadLittleEndian64'></span><span id='topic+ReadLittleEndian64-methods'></span><span id='topic+ReadLittleEndian64+2CZeroCopyInputStream-method'></span><span id='topic+ReadVarint64'></span><span id='topic+ReadVarint64-methods'></span><span id='topic+ReadVarint64+2CZeroCopyInputStream-method'></span>

<h3>Description</h3>

<p>R wrapper for the ZeroCopyInputStream c++ class</p>


<h3>Objects from the Class</h3>

<p>This is a virtual class
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p>external pointer to the <code>google::protobuf::io::ZeroCopyInputStream</code> object</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>$</dt><dd><p><code>signature(x="ZeroCopyInputStream")</code>: invokes a method</p>
</dd>
<dt>Next</dt><dd><p><code>signature(object="ZeroCopyInputStream")</code>: Get a number of bytes from the stream as a raw vector. </p>
</dd>
<dt>Skip</dt><dd><p><code>signature(object="ZeroCopyInputStream")</code>: skip a number of bytes</p>
</dd>
<dt>BackUp</dt><dd><p><code>signature(object="ZeroCopyInputStream")</code>: Backs up a number of bytes, so that the next call to <code>Next</code> returns data again that was already returned by the last call to <code>Next</code>.</p>
</dd>
<dt>ByteCount</dt><dd><p><code>signature(object="ZeroCopyInputStream")</code>: Returns the total number of bytes read since this object was created. </p>
</dd>
<dt>ReadRaw</dt><dd><p><code>signature(object="ZeroCopyInputStream", size = "integer")</code>: read raw bytes from the stream</p>
</dd>
<dt>ReadRaw</dt><dd><p><code>signature(object="ZeroCopyInputStream", size = "numeric")</code>: read raw bytes from the stream</p>
</dd>
<dt>ReadString</dt><dd><p><code>signature(object="ZeroCopyInputStream", size = "integer")</code>: same as <code>ReadRaw</code> but formats the result as a string</p>
</dd>
<dt>ReadString</dt><dd><p><code>signature(object="ZeroCopyInputStream", size = "numeric")</code>: same as <code>ReadRaw</code> but formats the result as a string</p>
</dd>
<dt>ReadVarint32</dt><dd><p><code>signature(object="ZeroCopyInputStream")</code>: Read an unsigned integer with Varint encoding, truncating to 32 bits. </p>
</dd>
<dt>ReadLittleEndian32</dt><dd><p><code>signature(object="ZeroCopyInputStream")</code>: Read a 32-bit little-endian integer.  </p>
</dd>
<dt>ReadLittleEndian64</dt><dd><p><code>signature(object="ZeroCopyInputStream")</code>: Read a 64-bit little-endian integer. In R the value is stored as a <code>double</code> which looses some precision (no other way) </p>
</dd>
<dt>ReadVarint64</dt><dd><p><code>signature(object="ZeroCopyInputStream")</code>: Read a 64-bit integer with varint encoding. In R the value is stored as a <code>double</code> which looses some precision (no other way) </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>References</h3>

<p>The <code>google::protobuf::io::ZeroCopyInputStream</code> C++ class.</p>


<h3>See Also</h3>

<p>TODO: add classes that extend</p>

<hr>
<h2 id='ZeroCopyOutputStream-class'>Virtual Class &quot;ZeroCopyOutputStream&quot; </h2><span id='topic+ZeroCopyOutputStream-class'></span><span id='topic+ByteCount+2CZeroCopyOutputStream-method'></span><span id='topic+BackUp+2CZeroCopyOutputStream-method'></span><span id='topic+Next+2CZeroCopyOutputStream+2Craw-method'></span><span id='topic++24+2CZeroCopyOutputStream-method'></span><span id='topic+WriteRaw'></span><span id='topic+WriteRaw-methods'></span><span id='topic+WriteRaw+2CZeroCopyOutputStream+2Craw-method'></span><span id='topic+WriteString'></span><span id='topic+WriteString-methods'></span><span id='topic+WriteString+2CZeroCopyOutputStream+2Ccharacter-method'></span><span id='topic+WriteLittleEndian32'></span><span id='topic+WriteLittleEndian32-methods'></span><span id='topic+WriteLittleEndian32+2CZeroCopyOutputStream+2Cinteger-method'></span><span id='topic+WriteLittleEndian32+2CZeroCopyOutputStream+2Cnumeric-method'></span><span id='topic+WriteLittleEndian32+2CZeroCopyOutputStream+2Craw-method'></span><span id='topic+WriteLittleEndian64'></span><span id='topic+WriteLittleEndian64-methods'></span><span id='topic+WriteLittleEndian64+2CZeroCopyOutputStream+2Cinteger-method'></span><span id='topic+WriteLittleEndian64+2CZeroCopyOutputStream+2Cnumeric-method'></span><span id='topic+WriteLittleEndian64+2CZeroCopyOutputStream+2Craw-method'></span><span id='topic+WriteVarint32'></span><span id='topic+WriteVarint32-methods'></span><span id='topic+WriteVarint32+2CZeroCopyOutputStream+2Cinteger-method'></span><span id='topic+WriteVarint32+2CZeroCopyOutputStream+2Cnumeric-method'></span><span id='topic+WriteVarint32+2CZeroCopyOutputStream+2Craw-method'></span><span id='topic+WriteVarint64'></span><span id='topic+WriteVarint64-methods'></span><span id='topic+WriteVarint64+2CZeroCopyOutputStream+2Cinteger-method'></span><span id='topic+WriteVarint64+2CZeroCopyOutputStream+2Cnumeric-method'></span><span id='topic+WriteVarint64+2CZeroCopyOutputStream+2Craw-method'></span>

<h3>Description</h3>

<p>R wrapper for the ZeroCopyOutputStream c++ class</p>


<h3>Objects from the Class</h3>

<p>This is a virtual class
</p>


<h3>Slots</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p>external pointer to the <code>google::protobuf::io::ZeroCopyOutputStream</code> object</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>$</dt><dd><p><code>signature(x="ZeroCopyOutputStream")</code>: invokes a method</p>
</dd>
<dt>Next</dt><dd><p><code>signature(object="ZeroCopyOutputStream", payload = "raw" )</code>: push the raw vector into the stream. Returns the number of bytes actually written.</p>
</dd>
<dt>BackUp</dt><dd><p><code>signature(object="ZeroCopyOutputStream")</code>: Backs up a number of bytes, so that the end of the last buffer returned by <code>Next</code> is not actually written.</p>
</dd>
<dt>ByteCount</dt><dd><p><code>signature(object="ZeroCopyOutputStream")</code>: Returns the total number of bytes written since this object was created. </p>
</dd>
<dt>WriteRaw</dt><dd><p><code>signature(object="ZeroCopyOuputStream")</code>, payload = &quot;raw&quot;: write the raw bytes to the stream</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Romain Francois &lt;francoisromain@free.fr&gt; </p>


<h3>References</h3>

<p>The <code>google::protobuf::io::ZeroCopyOutputStream</code> C++ class.</p>


<h3>See Also</h3>

<p>TODO: add classes that extend</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
