<!DOCTYPE html><html><head><title>Help for package sidier</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sidier}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alignExample'><p>example alignment #1 ('DNAbin' class)</p></a></li>
<li><a href='#assign.whole.taxo'><p>Get taxonomy described in sequence names</p></a></li>
<li><a href='#barcode.gap'><p>Barcode gap identification</p></a></li>
<li><a href='#barcode.quality'><p>Estimates of barcode quality</p></a></li>
<li><a href='#barcode.summary'><p>Summary of the inter- and intraspecific distances</p></a></li>
<li><a href='#BARRIEL'><p>Indel distances following Barriel method</p></a></li>
<li><a href='#colour.scheme'><p>internal function for node colour scheme</p></a></li>
<li><a href='#compare.dist'><p>Threshold to discriminate species comparing intra- and interspecific distance distributions</p></a></li>
<li><a href='#distance.comb'>
<p>Distance matrices combination</p></a></li>
<li><a href='#double.plot'><p>Haplotype and population networks including mutations and haplotype frequencies.</p></a></li>
<li><a href='#ex_alignment1'><p>example alignment #1</p></a></li>
<li><a href='#ex_BLAST'><p>example BLAST output</p></a></li>
<li><a href='#ex_Coords'><p>example coordinates</p></a></li>
<li><a href='#Example_Spatial.plot_Alignment'><p>example alignment #1 (fasta format)</p></a></li>
<li><a href='#FIFTH'><p>Indel distances following the fifth state rationale</p></a></li>
<li><a href='#filter.whole.taxo'><p>Get consensus taxonomy</p></a></li>
<li><a href='#FilterHaplo'><p>Filter haplotypes by occurrence</p></a></li>
<li><a href='#FindHaplo'><p>Find equal haplotypes</p></a></li>
<li><a href='#genbank.sp.names'><p>Species names from genbank accessions</p></a></li>
<li><a href='#get.majority.taxo'><p>Get majority taxonomy for a sequence</p></a></li>
<li><a href='#GetHaplo'><p>Get sequences of unique haplotypes</p></a></li>
<li><a href='#HapPerPop'><p>Returns the number of haplotypes per population.</p></a></li>
<li><a href='#inter.intra.plot'><p>Histogram of the intra- and interspecific distances</p></a></li>
<li><a href='#MCIC'><p>Modified Complex Indel Coding as distance matrix</p></a></li>
<li><a href='#mergeNodes'><p>Merges nodes showing distance values equal to zero</p></a></li>
<li><a href='#mutation.network'><p>Haplotype network depiction including mutations</p></a></li>
<li><a href='#mutationSummary'>
<p>Summary of observed mutations</p></a></li>
<li><a href='#NINA.thr'><p>No Isolated Nodes Allowed network</p></a></li>
<li><a href='#nt.gap.comb'><p>substitution and indel distance combinations</p></a></li>
<li><a href='#perc.thr'><p>Percolation threshold network</p></a></li>
<li><a href='#pie.network'><p>Population network depiction including haplotype frequencies</p></a></li>
<li><a href='#pop.dist'><p>Distances among populations</p></a></li>
<li><a href='#rule'><p>Threshold to discriminate species.</p></a></li>
<li><a href='#SIC'><p>Indel distances following the Simple Index Coding method</p></a></li>
<li><a href='#sidier-package'><p>SIDIER: Substitution and Indel Distances to Infer Evolutionary Relationships</p></a></li>
<li><a href='#simplify.network'><p>Network showing modules as nodes</p></a></li>
<li><a href='#simuEvolution'>
<p>Simulate sequences evolution</p></a></li>
<li><a href='#single.network'><p> Plot a network given a threshold</p></a></li>
<li><a href='#single.network.module'><p>Get modules and network given a threshold</p></a></li>
<li><a href='#spatial.plot'><p>spatial plot of populations</p></a></li>
<li><a href='#zero.thr'><p>Zero distance networks</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Substitution and Indel Distances to Infer Evolutionary
Relationships</td>
</tr>
<tr>
<td>Version:</td>
<td>4.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-06-25</td>
</tr>
<tr>
<td>Author:</td>
<td>A. Jesus Muñoz Pajares</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>A.J. Muñoz-Pajares &lt;ajesusmp@ugr.es&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, network, igraph, gridBase, grid, ggmap, ggplot2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Evolutionary reconstruction based on substitutions and insertion-deletion (indels) analyses in a distance-based framework.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-25 11:22:27 UTC; ajesusmp</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-25 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alignExample'>example alignment #1 ('DNAbin' class)</h2><span id='topic+alignExample'></span>

<h3>Description</h3>

<p>object of class 'DNAbin' to test some function within this package</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ex_alignment1)</code></pre>


<h3>Details</h3>

<p>Because fasta file examples are not automatically loaded into R environment, 'ex_alignment1' function generates a fasta file (named Example_Spatial.plot_Alignment) that is stored as a 'DNAbin' object named alignExample
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>See Also</h3>

<p><code><a href="#topic+ex_alignment1">ex_alignment1</a></code>, <code><a href="#topic+Example_Spatial.plot_Alignment">Example_Spatial.plot_Alignment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data(ex_alignment1) # this will read a fasta file with the name 'alignExample'
# alignExample
</code></pre>

<hr>
<h2 id='assign.whole.taxo'>Get taxonomy described in sequence names</h2><span id='topic+assign.whole.taxo'></span>

<h3>Description</h3>

<p>Assign taxonomy to every line in a BLAST output using the information provided in the name of the subject sequences (stitle)</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign.whole.taxo(BLAST)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign.whole.taxo_+3A_blast">BLAST</code></td>
<td>
<p>data.frame containing the output of a BLAST analysis. The first column must be the name of the sequences matching the queries and must contain information on the taxonomy of the subject sequences. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected input data.frame must contain information about
taxonomy in the first column. Additional information is accepted if separated
by &quot;|&quot;, but taxonomy 
must be the last bit of information. Taxonomical information must be provided for kingdom,
phylum, class, order, family, genus, and species, each separated
by &quot;;&quot; and identified by a letter as follows: 
</p>
<p>optionalTEXT | optionalTEXT | k__kingdomName;p__phylumName;c__className; o__orderName;f__familyName;g__genusName;s__speciesName
</p>
<p>This is the typical format of sequence names in several databases. Thus a BLAST output using any of these databases will automatically
produce the desired format.
</p>


<h3>Value</h3>

<p>a data.frame contining all the information provided in the input data.frame and seven additional columns containing the name of kingdom, phylum, class, order, family, genus, and species for this sequence
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter.whole.taxo">filter.whole.taxo</a>, and <a href="#topic+get.majority.taxo">get.majority.taxo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(ex_BLAST)
# TAXO &lt;- assign.whole.taxo(ex_BLAST)
</code></pre>

<hr>
<h2 id='barcode.gap'>Barcode gap identification 
</h2><span id='topic+barcode.gap'></span>

<h3>Description</h3>

<p>Identifies barcode gaps based on representing intra- and interspecific distances. Species above the 1:1 line are considered to show a barcode gap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barcode.gap(summary=NULL,stat.intra="max",stat.inter="min",
xlab=NULL, ylab=NULL, legend=TRUE, lab.nodes="nogap")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barcode.gap_+3A_summary">summary</code></td>
<td>

<p>a list produced by <code><a href="#topic+barcode.summary">barcode.summary</a></code>. From this list, the maximum intraspecific and the minimum interspecific distances per species are represented. To use any other intra- and interspecific distance, use the &quot;inter&quot; and &quot;intra&quot; options.
</p>
</td></tr>
<tr><td><code id="barcode.gap_+3A_stat.intra">stat.intra</code></td>
<td>
<p>a string, the inter-specific statistic used to estimate the quotient interspecific/intraspecific. Accepted values are &quot;max&quot;, &quot;min&quot;, &quot;median&quot;, and &quot;mean&quot;
</p>
</td></tr>
<tr><td><code id="barcode.gap_+3A_stat.inter">stat.inter</code></td>
<td>
<p>a string, the inter-specific statistic used to estimate the quotient interspecific/intraspecific. Accepted values are &quot;max&quot;, &quot;min&quot;, &quot;median&quot;, and &quot;mean&quot;.
</p>
</td></tr>
<tr><td><code id="barcode.gap_+3A_xlab">xlab</code></td>
<td>

<p>a string, the x-axis label
</p>
</td></tr>
<tr><td><code id="barcode.gap_+3A_ylab">ylab</code></td>
<td>

<p>a string, the y-axis label
</p>
</td></tr>
<tr><td><code id="barcode.gap_+3A_legend">legend</code></td>
<td>

<p>a logic, to show information about species showing and lacking barcode within the plot
</p>
</td></tr>
<tr><td><code id="barcode.gap_+3A_lab.nodes">lab.nodes</code></td>
<td>

<p>a string to select the name of species to be represented in the plot: &quot;gap&quot; to represent species showing barcode gap; &quot;nogap&quot; to represent species lacking barcode gap; &quot;all&quot; for representing all species names. Other value will represent no names.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table>
<tr><td><code>no.barcode.gap</code></td>
<td>
<p>a matrix containing the name of the species lacking barcode gap and their mean intra- and interspecific distances.
</p>
</td></tr>
<tr><td><code>barcode.gap</code></td>
<td>
<p>a matrix containing the name of the species showing barcode gap and their mean intra- and interspecific distances.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A.J. Muñoz-Pajares
</p>


<h3>See Also</h3>

<p><code><a href="#topic+barcode.summary">barcode.summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# my.dist&lt;-matrix(abs(rnorm(100)),ncol=10,
# dimnames=list(paste("sp",rep(1:5,2),sep=""),
# paste("sp",rep(1:5,2),sep="")))
# my.dist&lt;-as.matrix(as.dist(my.dist))
# sum&lt;-barcode.summary(my.dist)
# barcode.gap(sum)

</code></pre>

<hr>
<h2 id='barcode.quality'>Estimates of barcode quality
</h2><span id='topic+barcode.quality'></span>

<h3>Description</h3>

<p>Provides several estimates of the quality of a barcode classification, comparing network modules with attributed species names  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barcode.quality(dismat=NA,threshold=NA,refer2max=FALSE,save.file=FALSE,
modFileName="Modules_summary.txt",verbose=FALSE,output="list")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barcode.quality_+3A_dismat">dismat</code></td>
<td>

<p>a matrix containing the pairwise genetic distances between individual sequences
</p>
</td></tr> 
<tr><td><code id="barcode.quality_+3A_threshold">threshold</code></td>
<td>

<p>a numeric between 0 and 1, is the value of the maximum distance to be represented as a link in the network
</p>
</td></tr>
<tr><td><code id="barcode.quality_+3A_refer2max">refer2max</code></td>
<td>

<p>a logic, &quot;TRUE&quot; to refer the threshold value to the maximum distance in the input matrix (e.g., a value of 0.32 will represent a link between nodes showing distances equal or lower than 32% of the maximum distance found in the distance matrix). &quot;FALSE&quot; to refer the threshold to a specific value (e.g., a value of 0.32 will represent a link between nodes showing distances equal or lower than 0.32, regardless the maximum distance found in the distance matrix).
</p>
</td></tr>
<tr><td><code id="barcode.quality_+3A_save.file">save.file</code></td>
<td>

<p>a logic, &quot;TRUE&quot; to save the summary of network modules, attributing every individual to a module.
</p>
</td></tr>
<tr><td><code id="barcode.quality_+3A_modfilename">modFileName</code></td>
<td>

<p>if save.file=TRUE, a string: the name of the file containing the summary of network modules.
</p>
</td></tr>
<tr><td><code id="barcode.quality_+3A_verbose">verbose</code></td>
<td>

<p>a logic, &quot;TRUE&quot; to obtain a complete report of the quality estimation (see details).
</p>
</td></tr>
<tr><td><code id="barcode.quality_+3A_output">output</code></td>
<td>

<p>if verbose=TRUE, a string controlling the type of object produced for the output, being either &quot;matrix&quot; or &quot;list&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that the species names reflect the &quot;real&quot; taxonomic status and compare these names with the modules obtained in the network analysis. The quality is evaluated using different estimators: 
</p>
<p style="text-align: center;"><code class="reqn">Accuracy= \frac{T_{+} + T_{-}}{T_{+} + T_{-} + F_{+} + F_{-}}</code>
</p>

<p style="text-align: center;"><code class="reqn">Precision= \frac{T_{+}}{T_{+} + F_{+}}</code>
</p>

<p style="text-align: center;"><code class="reqn">Fscore= \frac{T_{+}}{T_{+} + F_{+} + F_{-}}</code>
</p>

<p style="text-align: center;"><code class="reqn">Qvalue = \frac{1}{N}\sum_{1}^{N}\frac{S_{link}}{S_{all}+S_{unlink}}</code>
</p>

<p>where T+ is the number of true positives (number of sequences with the same species name and classified in the same module); T- is the number of true negatives (number of sequences with different species name and classified in different modules); F+ represents false positive (number of sequences with different species name classified in the same module); F- is the number of false negative (number of sequences with the same species name classified in different modules); N is the number of nodes in the network, Slink is the number of nodes of the same species connected to the node i; Sunlink is the number of nodes of the same species belonging to a different module; and Sall is the number of all possible connections to other nodes of the same species.
</p>


<h3>Value</h3>

<p>If verbose is set to &quot;FALSE&quot;, a matrix with the estimators of the barcode quality. If verbose is set to &quot;TRUE&quot;, either a matrix or a list (depending on the output option selected) containing the following elements:
</p>
<table>
<tr><td><code>Number.of.modules</code></td>
<td>
<p>Number of modules found in the network analysis.</p>
</td></tr>
<tr><td><code>Number.of.species.per.module</code></td>
<td>
<p>A matrix containing: The number of species classified in only one module (N.sp.mod.1); the maximum number of species found in a module (N.sp.mod.MAX); and the mean number of species found per module (N.sp.mod.MED).</p>
</td></tr><tr><td><code>Number.of.species</code></td>
<td>
<p>The number of species defined for the analysis.</p>
</td></tr>
<tr><td><code>Number.of.modules.per.species</code></td>
<td>
<p>A matrix containing: The number of modules composed of only one species (N.mod.sp.1); the maximum number of modules containing the same species; the mean number of modules containing the same species.</p>
</td></tr>
<tr><td><code>Number.of.modules.fitting.defined.species</code></td>
<td>
<p>The number of modules containing only one species but all the individuals of this species.</p>
</td></tr>
<tr><td><code>Quality.estimates</code></td>
<td>
<p>A matrix containing the Qvalue, Accuracy, Precision and Fscore of the barcode classification.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A.J. Muñoz-Pajares
</p>


<h3>Examples</h3>

<pre><code class='language-R'># my.dist&lt;-matrix(abs(rnorm(100)),ncol=10,
# dimnames=list(paste("sp",rep(1:5,2),sep=""),
# paste("sp",rep(1:5,2),sep="")))
# my.dist&lt;-as.matrix(as.dist(my.dist))
# 
# barcode.quality(dismat=my.dist,threshold=0.2,refer2max=FALSE,save.file=TRUE,
# modFileName="Modules_summary.txt",verbose=FALSE,output="list")
</code></pre>

<hr>
<h2 id='barcode.summary'>Summary of the inter- and intraspecific distances
</h2><span id='topic+barcode.summary'></span>

<h3>Description</h3>

<p>For every species, provides the minimum, maximum, mean and median values of inter- and intraspecific distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barcode.summary(dismat=NULL,save.distances=FALSE,folder.name="distance_matrices")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barcode.summary_+3A_dismat">dismat</code></td>
<td>

<p>a symmetric matrix containing the pairwise genetic distances between individual sequences
</p>
</td></tr>
<tr><td><code id="barcode.summary_+3A_save.distances">save.distances</code></td>
<td>

<p>a logic, &quot;TRUE&quot; to save the pairwise distances estimated per species (one file per species)
</p>
</td></tr>
<tr><td><code id="barcode.summary_+3A_folder.name">folder.name</code></td>
<td>

<p>a string, if save.distance=TRUE, the name of the folder to save distances
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table>
<tr><td><code>Intraspecific</code></td>
<td>
<p>a matrix containing information about the intraspecific distances.
</p>
</td></tr>
<tr><td><code>Interspecific</code></td>
<td>
<p>a matrix containing information about the interspecific distances.
</p>
</td></tr>
</table>
<p>In both cases, the information provided is the minimum, maximum, median, mean, first and third quartile values.
</p>


<h3>Author(s)</h3>

<p>A.J. Muñoz-Pajares
</p>


<h3>See Also</h3>

<p><code><a href="#topic+barcode.gap">barcode.gap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# my.dist&lt;-matrix(abs(rnorm(100)),ncol=10,
# dimnames=list(paste("sp",rep(1:5,2),sep=""),
# paste("sp",rep(1:5,2),sep="")))
# my.dist&lt;-as.matrix(as.dist(my.dist))
# barcode.summary(my.dist)

</code></pre>

<hr>
<h2 id='BARRIEL'>Indel distances following Barriel method
</h2><span id='topic+BARRIEL'></span>

<h3>Description</h3>

<p>This function codifies gapped positions in a sequence alignment following the rationale of the method described by Barriel (1994). Based on the yielded indel coding matrix, this function also computes a pairwise indel distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BARRIEL(inputFile = NA, align = NA, saveFile = TRUE,
outnameDist = paste(inputFile, "IndelDistanceBarriel.txt",
sep = "_"), outnameCode = paste(inputFile, "Barriel_coding.txt",
 sep = "_"), addExtremes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BARRIEL_+3A_inputfile">inputFile</code></td>
<td>

<p>the name of the fasta file to be analysed. Alternatively you can provide the name of a &quot;DNAbin&quot; class alignment stored in memory using the &quot;align&quot; option.
</p>
</td></tr>
<tr><td><code id="BARRIEL_+3A_align">align</code></td>
<td>

<p>the name of the &quot;DNAbin&quot; alignment to be analysed. See &quot;?read.dna&quot; in the ape  package for details about reading alignments. Alternatively you can provide the name of the file containing the alignment in fasta format using the &quot;inputFile&quot; option.
</p>
</td></tr>
<tr><td><code id="BARRIEL_+3A_savefile">saveFile</code></td>
<td>

<p>a logical; if TRUE (default), it produces two output text files containing the distance matrix and the codified indel positions.
</p>
</td></tr>
<tr><td><code id="BARRIEL_+3A_outnamedist">outnameDist</code></td>
<td>

<p>if &quot;saveFile&quot; is set to TRUE (default), contains the name of the distance output file.
</p>
</td></tr>
<tr><td><code id="BARRIEL_+3A_outnamecode">outnameCode</code></td>
<td>

<p>if &quot;saveFile&quot; is set to TRUE (default), contains the name of the indel coding output file.
</p>
</td></tr>
<tr><td><code id="BARRIEL_+3A_addextremes">addExtremes</code></td>
<td>

<p>a logical; if TRUE, additional nucleotide sites are included in both extremes of the alignment. This will allow estimating distances for alignments showing gaps in terminal positions, but see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to estimate this distance matrix using only the unique sequences in the
alignment. Repeated sequences increase computation time but do not provide additional 
information (because they produce duplicated rows and columns in the final distance matrix).
</p>
<p>It is of critical importance to correctly identify indels homology in the provided alignment.
For this reason, addExtremes is set to false by default, and computation may not be done
unless flanking regions are homologous.
</p>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table>
<tr><td><code>indel coding matrix</code></td>
<td>
<p>Describes the initial and final site of each gap and its presence or absence per sequence.
</p>
</td></tr>
<tr><td><code>distance matrix</code></td>
<td>
<p>Contains genetic distances based on comparing indel presence/absence between sequences.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A.J. Muñoz-Pajares
</p>


<h3>References</h3>

<p>Barriel, V., 1994. Molecular phylogenies and how to code insertion/
deletion events. Life Sci. 317, 693-701, cited and described by
Simmons, M.P., Müller, K. &amp; Norton, A.P. (2007)
The relative performance of indel-coding methods in simulations.
Molecular Phylogenetics and Evolution, 44, 724–740.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCIC">MCIC</a></code>, <code><a href="#topic+SIC">SIC</a></code>, <code><a href="#topic+FIFTH">FIFTH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# cat("&gt;Population1_sequence1",
# "A-AGGGTC-CT---G",
# "&gt;Population1_sequence2",
# "TAA---TCGCT---G",
# "&gt;Population1_sequence3",
# "TAAGGGTCGCT---G",
# "&gt;Population1_sequence4",
# "TAA---TCGCT---G",
# "&gt;Population2_sequence1",
# "TTACGGTCG---TTG",
# "&gt;Population2_sequence2",
# "TAA---TCG---TTG",
# "&gt;Population2_sequence3",
# "TAA---TCGCTATTG",
# "&gt;Population2_sequence4",
# "TTACGGTCG---TTG",
# "&gt;Population3_sequence1",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence2",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence3",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence4",
# "TTA---TCG---TAG",
#      file = "ex3.fas", sep = "\n")
# 
# library(ape)
# BARRIEL(align=read.dna("ex3.fas",format="fasta"), saveFile = FALSE)
# 
# # Analysing the same dataset, but using only unique sequences:
# uni&lt;-GetHaplo(inputFile="ex3.fas",saveFile=FALSE)
# BARRIEL(align=uni, saveFile = FALSE)
</code></pre>

<hr>
<h2 id='colour.scheme'>internal function for node colour scheme</h2><span id='topic+colour.scheme'></span>

<h3>Description</h3>

<p>This function is called during network representations to set node colours. If the number of colours defined by user do not match with the number of elements, the algorithm provide a default set of colours.</p>


<h3>Usage</h3>

<pre><code class='language-R'>colour.scheme(def=NA, N=NA, colors=c("green2","red","yellow","blue","DarkOrchid1",
"gray51","chocolate","cyan4","saddle brown","aquamarine","chartreuse","chocolate1",
"DarkOrchid3","gray18","gold","DarkOrchid4","green4","gray29", "sienna3","tan1","blue4",
"limegreen","gray73","bisque3","deeppink","red4","OliveDrab4","gray95", "salmon",
"DeepPink4","green yellow","gray4","hot pink","pink2","dark orange","gold3"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colour.scheme_+3A_def">def</code></td>
<td>
<p>a vector containing the set of colours defined by user</p>
</td></tr>
<tr><td><code id="colour.scheme_+3A_n">N</code></td>
<td>
<p>a numeric representing the number of elements to be coloured</p>
</td></tr>
<tr><td><code id="colour.scheme_+3A_colors">colors</code></td>
<td>
<p>a vector with default colours to be used if 'def' is different from 'N'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the number of elements is higher than the number of colours (35 by default), colours are randomly selected.
</p>


<h3>Value</h3>

<p>a vector of strings representing 'N' colours 
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>Examples</h3>

<pre><code class='language-R'># colour.scheme(def=c("blue","red"),N=4)
# Colors&lt;-colour.scheme(def=c("blue","red"),N=4,colors=c("black","gray33","gray66","orange","red"))
# plot(c(1:4),col=Colors,pch=16)
# 
# #Given 10 individuals classified into three groups,
# #this will provide the colour for each individual:
# group&lt;-c(1,1,1,2,2,2,1,2,3,3) # defining groups
# colour.scheme(N=length(unique(group)))[group]
# 
</code></pre>

<hr>
<h2 id='compare.dist'>Threshold to discriminate species comparing intra- and interspecific distance distributions
</h2><span id='topic+compare.dist'></span>

<h3>Description</h3>

<p>This function implements the Lefebure's method to quantify the overlap between two distributions and to determine the best threshold value to discriminate them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare.dist(distr1=NULL,distr2=NULL,N=50,
normalize=TRUE,main=NA,col1="gray",col2="black",
col.border1="gray",col.border2="black",
col.line1="gray",col.line2="black",
Ylab=c("Abundance","Abundance","Success"),
Xlab=c("data1","data2","Threshold"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.dist_+3A_distr1">distr1</code></td>
<td>

<p>a matrix containing the pairwise genetic distances between individual sequences
</p>
</td></tr>
<tr><td><code id="compare.dist_+3A_distr2">distr2</code></td>
<td>

<p>a vector containing the minimum and maximum value in the x-axis
</p>
</td></tr>
<tr><td><code id="compare.dist_+3A_n">N</code></td>
<td>

<p>a numeric, the number of categories for the x-axis.
</p>
</td></tr>
<tr><td><code id="compare.dist_+3A_normalize">normalize</code></td>
<td>

<p>a logic, &quot;TRUE&quot; to display percentage and &quot;FALSE&quot; for number of occurrences in the Y axis.
</p>
</td></tr>
<tr><td><code id="compare.dist_+3A_main">main</code></td>
<td>

<p>a vector with two elements containing the main titles of both plots.
</p>
</td></tr>
<tr><td><code id="compare.dist_+3A_col1">col1</code></td>
<td>
<p>a string, the color to fill the histogram for distribution 1</p>
</td></tr>
<tr><td><code id="compare.dist_+3A_col2">col2</code></td>
<td>
<p>a string, the color to fill the histogram for distribution 2</p>
</td></tr>
<tr><td><code id="compare.dist_+3A_col.border1">col.border1</code></td>
<td>
<p>a string, the color for the border around the histogram for distribution 1</p>
</td></tr>
<tr><td><code id="compare.dist_+3A_col.border2">col.border2</code></td>
<td>
<p>a string, the color for the border around the histogram for distribution 2</p>
</td></tr>
<tr><td><code id="compare.dist_+3A_col.line1">col.line1</code></td>
<td>
<p>a string, the color for the line representing distribution 1</p>
</td></tr>
<tr><td><code id="compare.dist_+3A_col.line2">col.line2</code></td>
<td>
<p>a string, the color for the line representing distribution 2</p>
</td></tr>
<tr><td><code id="compare.dist_+3A_ylab">Ylab</code></td>
<td>

<p>a three strings vector containing the labels of Y axes for the three plots to be represented.
</p>
</td></tr>
<tr><td><code id="compare.dist_+3A_xlab">Xlab</code></td>
<td>

<p>a three strings vector containing the labels of X axes for the three plots to be represented
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated threshold and its success of identification.
</p>


<h3>Author(s)</h3>

<p>A.J. Muñoz-Pajares
</p>


<h3>References</h3>

<p>Lefébure T, Douady CJ, Gouy M, Gibert J (2006). Relationship between morphological taxonomy and molecular divergence within Crustacea: Proposal of a molecular threshold to help species delimitation. Mol Phylogenet Evol 40: 435–447. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ## Weak overlap
# intra&lt;-rnorm(mean=0.08,sd=0.04,n=100)
# inter&lt;-rnorm(mean=0.38,sd=0.10,n=1000)
# intra[intra&lt;0]&lt;-0
# inter[inter&lt;0]&lt;-0
# compare.dist(distr1=intra,distr2=inter,N=50)
# 
# # Strong overlap
# distr1&lt;-rnorm(5000,mean=0.25,sd=0.070)
# distr2&lt;-rnorm(5000,mean=0.31,sd=0.075)
# N&lt;-50
# compare.dist(distr1,distr2,N)
# 
</code></pre>

<hr>
<h2 id='distance.comb'>
Distance matrices combination
</h2><span id='topic+distance.comb'></span>

<h3>Description</h3>

<p>This function allows combining distance matrices. The weight of each matrix must be defined by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance.comb(matrices = NA, alphas = NA, method = "Corrected",
saveFile = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance.comb_+3A_matrices">matrices</code></td>
<td>

<p>a vector of strings containing the names of the matrices to be combined</p>
</td></tr>
<tr><td><code id="distance.comb_+3A_alphas">alphas</code></td>
<td>

<p>a vector of numerics containing the weight of each matrix. By default, combination is done giving the same same weight to all matrices.</p>
</td></tr>
<tr><td><code id="distance.comb_+3A_method">method</code></td>
<td>

<p>a string defining whether each distance matrix must be divided by its maximum value before the combination (&quot;Corrected&quot;) or not (&quot;Uncorrected&quot;). Consequently, if the &quot;Corrected&quot; method is chosen, both matrices will range between 0 and 1 before being combined.
</p>
</td></tr>
<tr><td><code id="distance.comb_+3A_savefile">saveFile</code></td>
<td>

<p>a logical; if TRUE (default), the output matrix is saved a text file.
</p>
</td></tr>
<tr><td><code id="distance.comb_+3A_na.rm">na.rm</code></td>
<td>

<p>a logical; if TRUE, missing values are removed before the computation proceeds.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matrices do not require to contain rows in the same order. The algorithm will search and combine rows of matrices with identical names. If row names of any input matrix are not defined, the algorithm will combine rows in order.</p>


<h3>Value</h3>

<p>A matrix containing the weighted combination of the original matrices</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares
</p>


<h3>See Also</h3>

<p>nt.gap.comb
</p>


<h3>Examples</h3>

<pre><code class='language-R'># mat1&lt;-matrix(rep(1,16),ncol=4)
# mat2&lt;-matrix(rep(2,16),ncol=4)
# mat3&lt;-matrix(rep(3,16),ncol=4)
# mat4&lt;-matrix(rep(6,16),ncol=4)
# mat5&lt;-matrix(c(rep(1,4),rep(3,4),rep(1,4),rep(1,4)),ncol=4)
# mat6&lt;-matrix(c(rep(1,4),rep(4,4),rep(4,4),rep(4,4)),ncol=4)
# mat7&lt;-mat6
# colnames(mat5)&lt;-c("a","b","c","d")
# colnames(mat6)&lt;-c("b","a","c","d")
# row.names(mat5)&lt;-c("a","b","c","d")
# row.names(mat6)&lt;-c("b","a","c","d")
# 
# # Matrices with information about the same elements (a-d)
# # but in different order, are automatically
# # sorted before combination....
# 
# distance.comb(matrices=c("mat5","mat6"),saveFile=FALSE,method="Uncorrected")
# 
# # ... but this is not possible if any of the matrices lack row names:
# 
# distance.comb(matrices=c("mat5","mat7"),saveFile=FALSE,method="Uncorrected")
# 
# # More examples:
# distance.comb(matrices=c("mat1","mat2","mat3","mat4"),alphas=rep(0.25,4),
# saveFile=FALSE,method="Uncorrected")
# 
# distance.comb(matrices=c("mat1","mat2","mat3","mat4"),alphas=rep(0.25,4),
# saveFile=FALSE,method="Corrected")
# 
# distance.comb(matrices=c("mat1","mat2","mat3","mat4"),alphas=c(0.66,0.33,0,0),
# saveFile=FALSE,method="Uncorrected")
# 
# distance.comb(matrices=c("mat1","mat2","mat3","mat6"),alphas=c(0.66,0.33,0,0),
# saveFile=FALSE,method="Uncorrected")
</code></pre>

<hr>
<h2 id='double.plot'>Haplotype and population networks including mutations and haplotype frequencies.</h2><span id='topic+double.plot'></span>

<h3>Description</h3>

<p>This function makes a double plot by dividing the active device into two parts. The left part is used to represent the input alignment as a haplotypic network displaying mutations. The right part is used to represent the same input alignment as a population network displaying nodes as pie charts.</p>


<h3>Usage</h3>

<pre><code class='language-R'>double.plot(align = NA, indel.method = "MCIC",
substitution.model = "raw",pairwise.deletion = TRUE,
network.method.mut = "percolation", network.method.pie = "percolation",
range = seq(0, 1, 0.01), addExtremes = FALSE, alpha.mut = "info",
alpha.pie = "info", combination.method.mut = "Corrected",
combination.method.pie = "Corrected", na.rm.row.col.mut = FALSE,
na.rm.row.col.pie = FALSE, save.distance.mut = FALSE,
save.distance.name.mut = "DistanceMatrix_threshold_Mutations.txt",
save.distance.pie = FALSE, save.distance.name.pie =
"DistanceMatrix_threshold_Pies.txt", modules=FALSE,
modules.col=NA, bgcol = NA, label.col.mut = "black",
label.col.pie = "black", label.mut = NA,label.pie = NA,
label.sub.str.mut = NA,label.sub.str.pie = NA, colInd = "red",
colSust = "black", lwd.mut = 1, InScale=1, SuScale=1, lwd.edge = 1.5,
cex.mut = 1, cex.label.mut = 1, cex.label.pie = 1, cex.vertex = 1,
main=c("Haplotypes","Populations"),
NameIniPopulations = NA, NameEndPopulations = NA, NameIniHaplotypes = NA,
NameEndHaplotypes = NA, cex.pie = 1, HaplosNames = NA, offset.label = 1.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="double.plot_+3A_align">align</code></td>
<td>
<p>a 'DNAbin' object; the alignment to be analysed. See &quot;read.dna&quot; in the ape package for details about reading alignments.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_indel.method">indel.method</code></td>
<td>
<p>a sting; the method to define indel events in your alignment. The available methods are:
</p>
<p>-&quot;MCIC&quot;: (Default) Estimates indel events following the rationale of the Modified Complex Indel Coding (Muller, 2006).
</p>
<p>-&quot;SIC&quot;: Estimates indel events following the rationale of Simmons and Ochoterrena (2001).
</p>
<p>-&quot;FIFTH&quot;: Estimates indel events following the rationale of the fifth state: each gap within the alignment is treated
as an independent mutation event.
</p>
<p>-&quot;BARRIEL&quot;: Estimates indel events following the rationale of Barriel (1994): singleton gaps are not taken into account.
</p>
</td></tr>
<tr><td><code id="double.plot_+3A_substitution.model">substitution.model</code></td>
<td>
<p>a string; the substitution evolutionary model to estimate the distance matrix. By default is set to &quot;raw&quot; and
estimates the pairwise proportion of variant sites. See the evolutionary models available using ?dist.dna from the ape package.
</p>
</td></tr>
<tr><td><code id="double.plot_+3A_pairwise.deletion">pairwise.deletion</code></td>
<td>
<p>a logical; if TRUE (default) substitutions found in regions being a gap in other sequences will account
for the distance matrix. If FALSE, sites being a gap in at least one sequence will be removed before distance estimation.
</p>
</td></tr>
<tr><td><code id="double.plot_+3A_network.method.mut">network.method.mut</code></td>
<td>
<p>a string; the method to build the haplotypic network. The available methods are:
</p>
<p>-&quot;percolation&quot;: computes a network using the percolation network method following Rozenfeld et al. (2008).
See ?perc.thr for details
</p>
<p>-&quot;NINA&quot;: computes a network using the No Isolation Nodes Allowed method. See ?NINA.thr for details.
</p>
<p>-&quot;zero&quot;: computes a network connecting all nodes showing distances equal to zero. See ?zero.thr for details.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_network.method.pie">network.method.pie</code></td>
<td>
<p>a string; the method to build the population network. The available methods are the same than for 'network.method.mut'</p>
</td></tr>
<tr><td><code id="double.plot_+3A_range">range</code></td>
<td>
<p>a numeric vector between 0 and 1, is the range of thresholds (referred to the maximum distance in the input matrix) to be screened (by default, 101 values from 0 to 1). This option is used for &quot;percolation&quot; and &quot;NINA&quot; network methods and ignored for &quot;zero&quot; method.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_addextremes">addExtremes</code></td>
<td>
<p>a logical; if TRUE, additional nucleotide sites are included in both extremes of the alignment. This will allow estimating distances for alignments showing gaps in terminal positions. This option is used for &quot;SIC&quot;, &quot;FIFTH&quot; and &quot;BARRIEL&quot; indel methods and ignored for &quot;MCIC&quot; method.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_alpha.mut">alpha.mut</code></td>
<td>
<p>a numeric between 0 and 1, is the weight given to the indel genetic distance matrix in the combination to represent the haplotypic network. By definition, the weight of the substitution genetic matrix is the complementary value (i.e., 1-alpha). The value &quot;info&quot; (default) will use the proportion of informative substitutions per informative indel event as weight. It is also possible to define multiple weights to estimate different combinations.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_alpha.pie">alpha.pie</code></td>
<td>
<p>a numeric between 0 and 1, is the weight given to the indel genetic distance matrix in the combination to represent the population network. By definition, the weight of the substitution genetic matrix is the complementary value (i.e., 1-alpha). The value &quot;info&quot; (default) will use the proportion of informative substitutions per informative indel event as weight. It is also possible to define multiple weights to estimate different combinations.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_combination.method.mut">combination.method.mut</code></td>
<td>
<p>a string defining whether each distance matrix must be divided by its maximum value before the combination (&quot;Corrected&quot;) or not (&quot;Uncorrected&quot;). Consequently, if the &quot;Corrected&quot; method is chosen, both matrices will range between 0 and 1 before being combined. This option affects the haplotype network depiction.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_combination.method.pie">combination.method.pie</code></td>
<td>
<p>a string defining whether each distance matrix must be divided by its maximum value before the combination (&quot;Corrected&quot;) or not (&quot;Uncorrected&quot;). Consequently, if the &quot;Corrected&quot; method is chosen, both matrices will range between 0 and 1 before being combined. This option affects the population network depiction.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_na.rm.row.col.mut">na.rm.row.col.mut</code></td>
<td>
<p>a logical; if TRUE, distance matrix missing values are removed.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_na.rm.row.col.pie">na.rm.row.col.pie</code></td>
<td>
<p>a logical; if TRUE, distance matrix missing values are removed.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_save.distance.mut">save.distance.mut</code></td>
<td>
<p>a logical; if TRUE, the distance matrix used to build the haplotypic network will be saved as a file.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_save.distance.name.mut">save.distance.name.mut</code></td>
<td>
<p>a string; if save.distance.mut=TRUE, it defines the name of the file to be saved.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_save.distance.pie">save.distance.pie</code></td>
<td>
<p>a logical; if TRUE, the distance matrix used to build the population network will be saved as a file.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_save.distance.name.pie">save.distance.name.pie</code></td>
<td>
<p>a string; if save.distance.pie=TRUE, it defines the name of the file to be saved.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_modules">modules</code></td>
<td>
<p>a logical. If TRUE, nodes colours are set according to modules in the network of haplotypes.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_modules.col">modules.col</code></td>
<td>
<p>(if modules=TRUE) a vector of strings defining the colour of nodes belonging to different modules in the network. If 'NA' (or there are less colours than haplotypes), colours are automatically selected.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_bgcol">bgcol</code></td>
<td>
<p>a vector of strings; the colour of the background for each node in the haplotypic network. The same colours will be used to represent haplotypes in the population network. If set to 'NA' (default), colours are automatically defined.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_label.col.mut">label.col.mut</code></td>
<td>
<p>a vector of strings; the colour of labels for each node in the haplotypic network. Can be equal for all nodes (if only one colour is defined) or customized (if several colours are defined).</p>
</td></tr>
<tr><td><code id="double.plot_+3A_label.col.pie">label.col.pie</code></td>
<td>
<p>a vector of strings; the colour of labels for each node in the population network. Can be equal for all nodes (if only one colour is defined) or customized (if several colours are defined).</p>
</td></tr>
<tr><td><code id="double.plot_+3A_label.mut">label.mut</code></td>
<td>
<p>a vector of strings; labels for each node in the haplotypic network. By default are the sequence names. (See &quot;substr&quot; function in base package to automatically reduce name lengths)</p>
</td></tr>
<tr><td><code id="double.plot_+3A_label.pie">label.pie</code></td>
<td>
<p>a vector of strings; labels for each node in the population network. By default are the sequence names. (See &quot;substr&quot; function in base package to automatically reduce name lengths)</p>
</td></tr>
<tr><td><code id="double.plot_+3A_label.sub.str.mut">label.sub.str.mut</code></td>
<td>
<p>a vector of two numerics; if node labels are a substring of sequence names, these two numbers represent the initial and final character of the string to be represented in the haplotypic network. See Example for details.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_label.sub.str.pie">label.sub.str.pie</code></td>
<td>
<p>a vector of two numerics; if node labels are a substring of sequence names, these two numbers represent the initial and final character of the string to be represented in the population network. See Example for details.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_colind">colInd</code></td>
<td>
<p>a strings; the color used to represent indels.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_colsust">colSust</code></td>
<td>
<p>a strings; the color used to represent substitutions.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_lwd.mut">lwd.mut</code></td>
<td>
<p>a numeric; the width of the line (marks perpendicular to the edge line) representing mutations (1 by default).</p>
</td></tr>
<tr><td><code id="double.plot_+3A_inscale">InScale</code></td>
<td>
<p>a numeric; the number of indels each mark represents. By default is set to 1 (that is, 1 mark= 1 indel). If set to 10, then 1 mark=10 indels. In that case, if there are 25 indels in a given edge it is represented by three marks (being one of them half width than the other two).</p>
</td></tr>
<tr><td><code id="double.plot_+3A_suscale">SuScale</code></td>
<td>
<p>a numeric; the number of substitutions each mark represents. By default is set to 1 (that is, 1 mark= 1 substitution). If set to 10, then 1 mark=10 substitutions In that case, if there are 25 substitutions in a given edge it is represented by three marks (being one of them half width than the other two).</p>
</td></tr>
<tr><td><code id="double.plot_+3A_lwd.edge">lwd.edge</code></td>
<td>
<p>a numeric; the width of the edge linking nodes (1.5 by default).</p>
</td></tr>
<tr><td><code id="double.plot_+3A_cex.mut">cex.mut</code></td>
<td>
<p>a numeric; the length of the line (perpendicular to the edge line) representing mutations (1 by default).</p>
</td></tr>
<tr><td><code id="double.plot_+3A_cex.label.mut">cex.label.mut</code></td>
<td>
<p>a numeric; the size of the node labels in the haplotypic network.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_cex.label.pie">cex.label.pie</code></td>
<td>
<p>a numeric; the size of the node labels in the population network.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_cex.vertex">cex.vertex</code></td>
<td>
<p>a numeric; the size of the nodes in the haplotypic network.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_main">main</code></td>
<td>
<p>a vector with two elements defining the title for the left and right plots, respectively. Alternatively, may be set to &quot;summary&quot; to display the main options selected for representing the networks. Finally, if set to &quot;&quot;, the algorithm will show no title for any network.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_nameinipopulations">NameIniPopulations</code></td>
<td>
<p>a numeric; Position of the initial character of population names within sequence names. If 'NA' (default), it is set to 1.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_nameendpopulations">NameEndPopulations</code></td>
<td>
<p>a numeric; Position of the last character of population names within sequence names. If 'NA' (default), it is set to the first &quot;_&quot; character in the sequences name.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_nameinihaplotypes">NameIniHaplotypes</code></td>
<td>
<p>a numeric; Position of the initial character of haplotype names within sequence names. If 'NA' (default), haplotype names are defined by the algorithm and the value is set accordingly.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_nameendhaplotypes">NameEndHaplotypes</code></td>
<td>
<p>a numeric; Position of the last character of haplotype names within sequence names. If 'NA' (default), haplotype names are defined by the algorithm and the value is set accordingly.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_cex.pie">cex.pie</code></td>
<td>
<p>a numeric; the size of the nodes in the population network.</p>
</td></tr>
<tr><td><code id="double.plot_+3A_haplosnames">HaplosNames</code></td>
<td>
<p>a sting; the name of the haplotypes (if different from default: H1...Hn)</p>
</td></tr>
<tr><td><code id="double.plot_+3A_offset.label">offset.label</code></td>
<td>
<p>a numeric, the separation between node and label.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>References</h3>

<p>Barriel, V., 1994. Molecular phylogenies and how to code insertion/
deletion events. Life Sci. 317, 693-701, cited and described by
Simmons, M.P., Müller, K. &amp; Norton, A.P. (2007)
The relative performance of indel-coding methods in simulations.
Molecular Phylogenetics and Evolution, 44, 724–740.
</p>
<p>Muller K. (2006). Incorporating information from length-mutational events into phylogenetic analysis. Molecular Phylogenetics and Evolution, 38, 667-676.
</p>
<p>Rozenfeld AF, Arnaud-Haond S, Hernandez-Garcia E, Eguiluz VM, Serrao EA, Duarte CM. (2008). Network analysis identifies weak and strong links in a metapopulation system. Proceedings of the National Academy of Sciences,105, 18824-18829.
</p>
<p>Simmons, M.P. &amp; Ochoterena, H. (2000). Gaps as Characters in Sequence-Based
Phylogenetic Analyses. Systematic Biology, 49, 369-381.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutation.network">mutation.network</a></code>, <code><a href="#topic+pie.network">pie.network</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># cat("&gt;Population1_sequence1",
# "TTATAAAATCTA----TAGC",
# "&gt;Population1_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population1_sequence3",
# "TTATAAAAATTA----TAGC",
# "&gt;Population1_sequence4",
# "TAAT----TCTA----TAAC",
# "&gt;Population2_sequence1",
# "TTAT----TCGAGGGGTAGC",
# "&gt;Population2_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population2_sequence3",
# "TTATAAAA--------TAGC",
# "&gt;Population2_sequence4",
# "TTAT----TCGAGGGGTAGC",
# "&gt;Population3_sequence1",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence2",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence3",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence4",
# "TTAT----TCGA----TAGC",
#      file = "ex2.fas", sep = "\n")
# library(ape)

# Double plot (computation time may exceed 5 seconds)
#double.plot(align=read.dna(file="ex2.fas",format="fasta"))

# Other options
#data(ex_alignment1) # this will read a fasta file with the name 'alignExample'
#double.plot(alignExample,label.sub.str.mut=c(7,9))
#double.plot(alignExample,label.sub.str.mut=c(7,9),InScale=3,SuScale=2,lwd.mut=1.5)
</code></pre>

<hr>
<h2 id='ex_alignment1'>example alignment #1</h2><span id='topic+ex_alignment1'></span>

<h3>Description</h3>

<p>This function will generate an example alignment to test some function within this package</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ex_alignment1)</code></pre>


<h3>Details</h3>

<p>Because fasta file examples are not automatically loaded into R environment, 'ex_alignment1' function generates a fasta file (named Example_Spatial.plot_Alignment) that is stored as a 'DNAbin' object named alignExample
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>See Also</h3>

<p><code><a href="#topic+alignExample">alignExample</a></code>, <code><a href="#topic+Example_Spatial.plot_Alignment">Example_Spatial.plot_Alignment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(ex_alignment1) # this will read a fasta file with the name 'alignExample'
# alignExample
</code></pre>

<hr>
<h2 id='ex_BLAST'>example BLAST output</h2><span id='topic+ex_BLAST'></span>

<h3>Description</h3>

<p>BLAST output</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ex_BLAST)</code></pre>


<h3>Value</h3>

<p>a four columns data.frame containing the qseqid (as character, not as factor!), evalue, percentage of identity and query coverage, respectively.</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(ex_BLAST)
# ex_BLAST
</code></pre>

<hr>
<h2 id='ex_Coords'>example coordinates</h2><span id='topic+ex_Coords'></span>

<h3>Description</h3>

<p>Geographic coordinates of populatons to test some function within this package</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ex_Coords)</code></pre>


<h3>Value</h3>

<p>a three columns matrix containing the population name, longitude and latitude, respectively.</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(ex_Coords)
# ex_Coords
</code></pre>

<hr>
<h2 id='Example_Spatial.plot_Alignment'>example alignment #1 (fasta format)</h2><span id='topic+Example_Spatial.plot_Alignment'></span>

<h3>Description</h3>

<p>fasta sequences alignment to test some function within this package</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ex_alignment1)</code></pre>


<h3>Details</h3>

<p>Because fasta file examples are not automatically loaded into R environment, 'ex_alignment1' function generates a fasta file (named Example_Spatial.plot_Alignment) that is stored as a 'DNAbin' object named alignExample
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>See Also</h3>

<p><code><a href="#topic+ex_alignment1">ex_alignment1</a></code>, <code><a href="#topic+alignExample">alignExample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(ex_alignment1) # this will read a fasta file with the name 'alignExample'
# alignExample
</code></pre>

<hr>
<h2 id='FIFTH'>Indel distances following the fifth state rationale
</h2><span id='topic+FIFTH'></span>

<h3>Description</h3>

<p>This function computes an indel distance matrix following the rationale of the fifth state. For that, each gap within the alignment is treated as an independent mutation event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIFTH(inputFile = NA, align = NA, saveFile = TRUE,
outname = paste(inputFile,"IndelDistanceFifthState.txt",
 sep = "_"), addExtremes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FIFTH_+3A_inputfile">inputFile</code></td>
<td>

<p>the name of the fasta file to be analysed. Alternatively you can provide the name of a &quot;DNAbin&quot; class alignment stored in memory using the &quot;align&quot; option.
</p>
</td></tr>
<tr><td><code id="FIFTH_+3A_align">align</code></td>
<td>

<p>the name of the alignment to be analysed. See &quot;read.dna&quot; in ape  package for details about reading alignments. Alternatively you can provide the name of the file containing the alignment in fasta format using the &quot;inputFile&quot; option.
</p>
</td></tr>
<tr><td><code id="FIFTH_+3A_savefile">saveFile</code></td>
<td>

<p>a logical; if TRUE (default), it produces an output text file containing the resulting distance matrix.
</p>
</td></tr>
<tr><td><code id="FIFTH_+3A_outname">outname</code></td>
<td>

<p>if &quot;saveFile&quot; is set to TRUE (default), contains the name of the output file.
</p>
</td></tr>
<tr><td><code id="FIFTH_+3A_addextremes">addExtremes</code></td>
<td>

<p>a logical; if TRUE, additional nucleotide sites are included in both extremes of the alignment. This will allow estimating distances for alignments showing gaps in terminal positions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to estimate this distance matrix using only the unique sequences in the
alignment. Repeated sequences increase computation time but do not provide additional 
information (because they produce duplicated rows and columns in the final distance matrix).
</p>
<p>It is of critical importance to correctly identify indels homology in the provided alignment.
For this reason, addExtremes is set to false by default, and computation may not be done
unless flanking regions were homologous.
</p>


<h3>Value</h3>

<p>A matrix containing the genetic distances estimated as indels pairwise differences.
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BARRIEL">BARRIEL</a></code>, <code><a href="#topic+MCIC">MCIC</a></code>, <code><a href="#topic+SIC">SIC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# # This will generate an example file in your working directory:
# cat("&gt;Population1_sequence1",
# "A-AGGGTC-CT---G",
# "&gt;Population1_sequence2",
# "TAA---TCGCT---G",
# "&gt;Population1_sequence3",
# "TAAGGGTCGCT---G",
# "&gt;Population1_sequence4",
# "TAA---TCGCT---G",
# "&gt;Population2_sequence1",
# "TTACGGTCG---TTG",
# "&gt;Population2_sequence2",
# "TAA---TCG---TTG",
# "&gt;Population2_sequence3",
# "TAA---TCGCTATTG",
# "&gt;Population2_sequence4",
# "TTACGGTCG---TTG",
# "&gt;Population3_sequence1",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence2",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence3",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence4",
# "TTA---TCG---TAG",
#      file = "ex3.fas", sep = "\n")
# 
# # Reading the alignment directly from file and saving no output file:
# library(ape)
# FIFTH (align=read.dna("ex3.fas",format="fasta"), saveFile = FALSE)
# 
# # Analysing the same dataset, but using only unique sequences:
# uni&lt;-GetHaplo(inputFile="ex3.fas",saveFile=FALSE)
# FIFTH (align=uni, saveFile = FALSE)
</code></pre>

<hr>
<h2 id='filter.whole.taxo'>Get consensus taxonomy</h2><span id='topic+filter.whole.taxo'></span>

<h3>Description</h3>

<p>Given the taxonomy of multiple BLAST hits for a query sequence, provides the most likely tanoxomy for the query sequence taking BLAST percentage of identity values into account</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.whole.taxo(whole.taxo)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.whole.taxo_+3A_whole.taxo">whole.taxo</code></td>
<td>
<p>data.frame containing BLAST results and taxonomy information. Can be produced by <code><a href="#topic+assign.whole.taxo">assign.whole.taxo</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected input data.frame must contain information about BLAST hits (particularly, a &quot;pident&quot; column with the percentage of identity) and seven additional columns containing the name of kingdom, phylum, class, order, family, genus, and species for every subject sequence.
</p>
<p>Depending on the &quot;pident&quot; value, taxonomy for the subject sequence will be retained until species (if pident&gt;=97), genus (97&gt;pident&gt;=90), family  (90&gt;pident&gt;=85), order (85&gt;pident&gt;=80), family (80&gt;pident&gt;=75), or class (75&gt;pident&gt;=0). For taxonomic levels showing pident lower that these thresholds, &quot;low_pident&quot; is returned.
</p>


<h3>Value</h3>

<p>a data.frame contining all the information provided in the input data.frame and seven additional columns containing the name of kingdom, phylum, class, order, family, genus, and species for this sequence after filtering by BLAST percentage of identity.
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.majority.taxo">get.majority.taxo</a>,<a href="#topic+assign.whole.taxo">assign.whole.taxo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data(ex_BLAST)
#TAXO &lt;- assign.whole.taxo(ex_BLAST)
#FILT_TAXO &lt;- filter.whole.taxo(TAXO)
</code></pre>

<hr>
<h2 id='FilterHaplo'>Filter haplotypes by occurrence</h2><span id='topic+FilterHaplo'></span>

<h3>Description</h3>

<p>Provides a subset of a original alignment composed only of haplotypes showing the range of occurrences provided</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterHaplo(inputFile=NA, align=NA, Nmin=0, Nmax=NULL,
 saveFile=FALSE, outname="FilterHaplo.txt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterHaplo_+3A_inputfile">inputFile</code></td>
<td>
<p>the name of a sequence alignment file in fasta format to be analysed. Alternatively you can provide the name of a &quot;DNAbin&quot; class alignment stored in memory using the &quot;align&quot; option.
</p>
</td></tr>
<tr><td><code id="FilterHaplo_+3A_align">align</code></td>
<td>
<p>the name of the &quot;DNAbin&quot; alignment to be analysed. See &quot;?read.dna&quot; in the ape  package for details about reading alignments. Alternatively you can provide the name of the file containing the alignment in fasta format using the &quot;inputFile&quot; option.
</p>
</td></tr>
<tr><td><code id="FilterHaplo_+3A_nmin">Nmin</code></td>
<td>
<p>Minimum occurrence of an haplotype to be included in the subset</p>
</td></tr>
<tr><td><code id="FilterHaplo_+3A_nmax">Nmax</code></td>
<td>
<p>Maximum occurrence of an haplotype to be included in the subset</p>
</td></tr>
<tr><td><code id="FilterHaplo_+3A_savefile">saveFile</code></td>
<td>
<p>a logical; if TRUE (default), function output is saved as a text file in fasta format
</p>
</td></tr>
<tr><td><code id="FilterHaplo_+3A_outname">outname</code></td>
<td>
<p>if &quot;saveFile&quot; is set to TRUE (default), contains the name of the output file.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>Examples</h3>

<pre><code class='language-R'># cat("&gt;Population1_sequence1",
# "TTATAAAATCTA----TAGC",
# "&gt;Population1_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population1_sequence3",
# "TTATAAAAATTA----TAGC",
# "&gt;Population1_sequence4",
# "TAAT----TCTA----TAAC",
# "&gt;Population2_sequence1",
# "TTAT----TCGA----TAGC",
# "&gt;Population2_sequence2",
# "TTAT----TCGA----TAGC",
# "&gt;Population2_sequence3",
# "TTAT----TCGA----TAGC",
# "&gt;Population2_sequence4",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence1",
# "TTAT----TCGAGGGGTAGC",
# "&gt;Population3_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population3_sequence3",
# "TTATAAAA--------TAGC",
# "&gt;Population3_sequence4",
# "TTAT----TCGAGGGGTAGC",
#      file = "ex2.fas", sep = "\n")
# library(ape)
# example&lt;-read.dna(file="ex2.fas",format="fasta")
# 
# # Exclude unique haplotypes
# FilterHaplo(align=example,Nmin=2)
# 
# # Include only unique haplotypes
# FilterHaplo(align=example,Nmax=1)
# 
# # Filter haplotypes appearing between 2 and 4 times
# FilterHaplo(align=example,Nmax=4,Nmin=2)
</code></pre>

<hr>
<h2 id='FindHaplo'>Find equal haplotypes
</h2><span id='topic+FindHaplo'></span>

<h3>Description</h3>

<p>This function assigns the same name to equal haplotypes in a sequence alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindHaplo(inputFile = NA, align = NA,
saveFile = TRUE, outname = "FindHaplo.txt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindHaplo_+3A_inputfile">inputFile</code></td>
<td>
<p>the name of a sequence alignment file in fasta format to be analysed. Alternatively you can provide the name of a &quot;DNAbin&quot; class alignment stored in memory using the &quot;align&quot; option.
</p>
</td></tr>
<tr><td><code id="FindHaplo_+3A_align">align</code></td>
<td>
<p>the name of the &quot;DNAbin&quot; alignment to be analysed. See &quot;?read.dna&quot; in the ape  package for details about reading alignments. Alternatively you can provide the name of the file containing the alignment in fasta format using the &quot;inputFile&quot; option.
</p>
</td></tr>
<tr><td><code id="FindHaplo_+3A_savefile">saveFile</code></td>
<td>
<p>a logical; if TRUE (default), function output is saved as a text file.
</p>
</td></tr>
<tr><td><code id="FindHaplo_+3A_outname">outname</code></td>
<td>
<p>if &quot;saveFile&quot; is set to TRUE (default), contains the name of the output file (&quot;FindHaplo.txt&quot; by default).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm identifies identical sequences even if they are wrongly aligned (see example).</p>


<h3>Value</h3>

<p>A two columns matrix containing the original sequence name and the haplotype name assigned to each sequence in the input alignment.
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetHaplo">GetHaplo</a></code>, <code><a href="#topic+HapPerPop">HapPerPop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 
# 	#generating an alignment file:
# cat("&gt;Population1_sequence1",
# "TTATAGGTAGCTTCGATATTG",
# "&gt;Population2_sequence1",
# "TTA---GTAGCTTCGAAATTG",
# "&gt;Population3_sequence1",
# "TTA---GTA---TCG---TAG",
# "&gt;Population4_sequence1",
# "TTATAGGTA---TCG---TTG",
# "&gt;Population5_sequence1",
# "TTA------------AAATTG",
# file = "ex1.fas", sep = "\n")
# 
# 	 # Reading the alignment directly from file:
# 	 FindHaplo(inputFile="ex1.fas") 
# 
# 	 # Reading the alignment from an object:
# library(ape)
# example1&lt;-read.dna(file="ex1.fas",format="fasta")
# FindHaplo(align=example1)
# 
# 	#generating a new alignment file with identical sequences wrongly aligned:
# cat("&gt;Pop1_seq1",
# "TTATTCTA--------TAGC",
# "&gt;Pop1_seq2",
# "TTAT----TCTA----TAGC",
# "&gt;Pop1_seq3",
# "TAAT----TCTA------AC",
#      file = "ex2.2.fas", sep = "\n")
# 
# # Note that seq1 and seq2 are equal, but the alignment is different.
# # However, this function identifies seq1 and seq2 as identical:
# FindHaplo(inputFile="ex2.2.fas")
# 
</code></pre>

<hr>
<h2 id='genbank.sp.names'>Species names from genbank accessions
</h2><span id='topic+genbank.sp.names'></span>

<h3>Description</h3>

<p>Given a set of sequences in fasta format, this function extract the species names of every accession.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genbank.sp.names(sequences)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genbank.sp.names_+3A_sequences">sequences</code></td>
<td>

<p>a DNAbin object containing all the information of genbank accesions as sequence names.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a DNAbin object with genus and species as sequence names.
</p>


<h3>Author(s)</h3>

<p>A.J. Muñoz-Pajares
</p>

<hr>
<h2 id='get.majority.taxo'>Get majority taxonomy for a sequence</h2><span id='topic+get.majority.taxo'></span>

<h3>Description</h3>

<p>Given filtered taxonomy of multiple BLAST hits, provides the consensus taxonomy for every query sequence</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.majority.taxo(filtered.taxo,verbose=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.majority.taxo_+3A_filtered.taxo">filtered.taxo</code></td>
<td>
<p>a data.frame containing (at least) the output of a BLAST analysis and the filtered taxonomy for every subject sequence. This format is produced by <code><a href="#topic+filter.whole.taxo">filter.whole.taxo</a></code></p>
</td></tr>
<tr><td><code id="get.majority.taxo_+3A_verbose">verbose</code></td>
<td>
<p>a logical, if TRUE details on the calculation are shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected input data.frame must contain information about filtered taxonomy for every subject sequence and a unique code for every query sequence. 
</p>
<p>Nonmeaningful names (including &quot;unidentified&quot;, &quot;sp&quot;, &quot;low_pident&quot;) are coerced to &quot;Uninformative&quot;.
</p>
<p>The output dataframe includes a column with a summary of the alternative classifications found for taxonomy at every level. For example: &quot;10|10|10|10|10|10|9+1&quot; means that all 10 matches have identical taxonomy up to genus, but two species has been identified, being the taxonomy of 9 of the subject sequences identical and different from the remaining subject.
</p>


<h3>Value</h3>

<p>a data.frame with the followin columns: &quot;qseqid&quot;, the unique identifier of every original query sequence; seven columns containing the filtered taxonomy (&quot;kingdom.final&quot;, &quot;phylum.final&quot;, &quot;class.final&quot;, &quot;order.final&quot;, &quot;family.final&quot;, &quot;genus.final&quot;, and &quot;species.final&quot;); &quot;values&quot;: The frequency of the different taxonomical names provides for every level, separated by &quot;|&quot; (see details).  
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter.whole.taxo">filter.whole.taxo</a>,<a href="#topic+assign.whole.taxo">assign.whole.taxo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(ex_BLAST)
# TAXO &lt;- assign.whole.taxo(ex_BLAST)
# FILT_TAXO &lt;- filter.whole.taxo(TAXO)
# MAJ_TAXO &lt;- get.majority.taxo(TAXO)
</code></pre>

<hr>
<h2 id='GetHaplo'>Get sequences of unique haplotypes
</h2><span id='topic+GetHaplo'></span>

<h3>Description</h3>

<p>This function returns the subset of unique sequences composing a given alignment. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetHaplo(inputFile = NA, align = NA, saveFile = TRUE,
outname = "Haplotypes.txt", format = "fasta",
seqsNames = NA, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetHaplo_+3A_inputfile">inputFile</code></td>
<td>
<p>the name of a sequence alignment file in fasta format to be analysed. Alternatively you can provide the name of a &quot;DNAbin&quot; class alignment stored in memory using the &quot;align&quot; option.
</p>
</td></tr>
<tr><td><code id="GetHaplo_+3A_align">align</code></td>
<td>
<p>the name of the &quot;DNAbin&quot; alignment to be analysed. See &quot;?read.dna&quot; in the ape  package for details about reading alignments. Alternatively you can provide the name of the file containing the alignment in fasta format using the &quot;inputFile&quot; option.
</p>
</td></tr>
<tr><td><code id="GetHaplo_+3A_savefile">saveFile</code></td>
<td>
<p>a logical; if TRUE (default), function output is saved as a text file
</p>
</td></tr>
<tr><td><code id="GetHaplo_+3A_outname">outname</code></td>
<td>
<p>if &quot;saveFile&quot; is set to TRUE (default), contains the name of the output file (&quot;Haplotypes.txt&quot; by default).
</p>
</td></tr>
<tr><td><code id="GetHaplo_+3A_format">format</code></td>
<td>
<p>format of the DNA sequences to be saved: &quot;interleaved&quot;, &quot;sequential&quot;, or &quot;fasta&quot; (default). See &quot;write.dna&quot; in ape  package for details.
</p>
</td></tr>
<tr><td><code id="GetHaplo_+3A_seqsnames">seqsNames</code></td>
<td>
<p>names for each DNA sequence saved: Three choices are possible: if n unique sequences are found, &quot;Inf.Hap&quot; assigns names from H1 to Hn (according to input order). The second option is to define a vector containing n names. By default, input sequence names are used.</p>
</td></tr>
<tr><td><code id="GetHaplo_+3A_silent">silent</code></td>
<td>
<p>a logical; if TRUE (default), it prints the number of unique sequences found and the name of the output file.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm identifies identical sequences even if they are wrongly aligned (see example).
</p>


<h3>Value</h3>

<p>A file containing unique sequences from the input file.
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FindHaplo">FindHaplo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 	#generating an alignment file:
# cat("&gt;Population1_sequence1",
# "TTATAAAATCTA----TAGC",
# "&gt;Population1_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population1_sequence3",
# "TTATAAAAATTA----TAGC",
# "&gt;Population1_sequence4",
# "TAAT----TCTA----TAAC",
# "&gt;Population2_sequence1",
# "TTAT----TCGAGGGGTAGC",
# "&gt;Population2_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population2_sequence3",
# "TTATAAAA--------TAGC",
# "&gt;Population2_sequence4",
# "TTAT----TCGAGGGGTAGC",
# "&gt;Population3_sequence1",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence2",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence3",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence4",
# "TTAT----TCGA----TAGC",
#      file = "ex2.fas", sep = "\n")
# 
# # Getting unique haplotypes reading the alignment from a file and setting
# #haplotype names:
# 	GetHaplo(inputFile="ex2.fas",outname="ex2_unique.fas",seqsNames=
# c("HaploK001","HaploK002","HaploS001","HaploR001","HaploR002","HaploR003"))
# # Reading the alignment from an object and using original sequence names:
#     library(ape)
#     example2 &lt;- read.dna("ex2.fas", format = "fasta")
# 	GetHaplo(align=example2,outname="Haplotypes_DefaultNames.txt")
# # Reading the alignment from an object and using new haplotype names:
# 	GetHaplo(align=example2,outname="Haplotypes_sequentialNames.txt",
# seqsNames="Inf.Hap")
# 
# 
# 	#generating a new alignment file with identical sequences wrongly alined:
# cat("&gt;Pop1_seq1",
# "TTATTCTA--------TAGC",
# "&gt;Pop1_seq2",
# "TTAT----TCTA----TAGC",
# "&gt;Pop1_seq3",
# "TAAT----TCTA------AC",
#      file = "ex2.2.fas", sep = "\n")
# 
# # Note that seq1 and seq2 are equal, but the alignment is different.
# # However, this function identifies seq1 and seq2 as identical:
# 	a&lt;-GetHaplo(inputFile="ex2.2.fas",saveFile=FALSE)
# 
</code></pre>

<hr>
<h2 id='HapPerPop'>Returns the number of haplotypes per population.
</h2><span id='topic+HapPerPop'></span>

<h3>Description</h3>

<p>Given a two column matrix, this function returns the number of haplotypes per population (weighted matrix) and the presence/absence of haplotypes per population (interaction matrix). The input matrix must contain one row per individual. The first column must contain the population name, while the second must contain the name of the haplotypes. This input matrix can be obtained using the &quot;FindHaplo&quot; function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HapPerPop(inputFile = NA, sep = " ", input = NA, header = FALSE,
NameIniPopulations = NA, NameEndPopulations = NA, saveFile = TRUE,
Wname = NA, Iname = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HapPerPop_+3A_inputfile">inputFile</code></td>
<td>
<p>the name of the file containing the two columns input matrix. Alternatively you can provide the name of a matrix stored in memory using the &quot;input&quot; option.
</p>
</td></tr>
<tr><td><code id="HapPerPop_+3A_sep">sep</code></td>
<td>
<p>the character separating columns in the input matrix (space, by default).
</p>
</td></tr>
<tr><td><code id="HapPerPop_+3A_input">input</code></td>
<td>
<p>the two columns input matrix stored in memory. Alternatively you can provide the name of the file containing the input matrix using the &quot;inputFile&quot; option.
</p>
</td></tr>
<tr><td><code id="HapPerPop_+3A_header">header</code></td>
<td>
<p>a logical value indicating whether the input matrix contains the names of the variables as its first line. (Default=FALSE).
</p>
</td></tr>
<tr><td><code id="HapPerPop_+3A_nameinipopulations">NameIniPopulations</code></td>
<td>
<p>Position within the input matrix rownames of the initial character referring population name. This option is useful if names contained in the first column includes more information than the population name (e.g., marker name, individual details...).
</p>
</td></tr>
<tr><td><code id="HapPerPop_+3A_nameendpopulations">NameEndPopulations</code></td>
<td>
<p>Position within the input matrix rownames of the last character referring population name. This option is useful if names contained in the first column includes more information than the population name (e.g., marker name, individual details...).
</p>
</td></tr>
<tr><td><code id="HapPerPop_+3A_savefile">saveFile</code></td>
<td>
<p>a logical; if TRUE (default), the two ouput matrices computed are saved as two different text files.</p>
</td></tr>
<tr><td><code id="HapPerPop_+3A_wname">Wname</code></td>
<td>
<p>the name given to the output weighted matrix file.
</p>
</td></tr>
<tr><td><code id="HapPerPop_+3A_iname">Iname</code></td>
<td>

<p>the name given to the output interaction matrix file
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both NameIniPopulations and NameEndPopulations are not defined, the names contained in the input matrix first column are used as population identifiers.</p>


<h3>Value</h3>

<p>A list containing two matrices:
</p>
<table>
<tr><td><code>Weighted</code></td>
<td>
<p>The first matrix (named weighted matrix) contains the abundance of each haplotype per population, represented by the number of haplotypes (columns) found per population (rows). </p>
</td></tr>
<tr><td><code>Interaction</code></td>
<td>
<p>The second matrix (named interaction matrix) contains information about the presence or absence of each haplotype (columns) per population (rows) represented by 1 or 0, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FindHaplo">FindHaplo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# cat("Sequence.Name Haplotype.Name",
# "Population1 H1",
# "Population1 H2",
# "Population1 H3",
# "Population1 H2",
# "Population2 H4",
# "Population2 H5",
# "Population2 H6",
# "Population2 H4",
# "Population3 H7",
# "Population3 H7",
# "Population3 H7",
# "Population3 H7",
#      file = "3_FindHaplo_Example2_modified.txt", sep = "\n")
# 
# # Reading the alignment directly from file:
# 	HapPerPop(inputFile="3_FindHaplo_Example2_modified.txt",header=TRUE,
# saveFile=FALSE)
# 
# cat("Sequence.Name Haplotype.Name",
# "Population1id1 H1",
# "Population1id2 H2",
# "Population1id3 H3",
# "Population1id4 H2",
# "Population2id1 H4",
# "Population2id2 H5",
# "Population2id3 H6",
# "Population2id4 H4",
# "Population3id1 H7",
# "Population3id2 H7",
# "Population3id3 H7",
# "Population3id4 H7",
#      file = "4_FindHaplo_Example2_modified.txt", sep = "\n")
# 
# # Reading the alignment directly from file. First column includes population
# # and individual names. Consequently, 12 populations are considered:
# 	HapPerPop(inputFile="4_FindHaplo_Example2_modified.txt",header=TRUE,
# saveFile=FALSE)
# 
# # Population names within the input matrix first column goes from 
# # character 1 to 11. Now 3 populations are considered:
# 	HapPerPop(inputFile="4_FindHaplo_Example2_modified.txt",header=TRUE,
# saveFile=FALSE,NameIniPopulations=1, NameEndPopulations=11)
# 
# # If population names are set from character 1 to 3, all samples would
# # be treated as a single population
# 	HapPerPop(inputFile="4_FindHaplo_Example2_modified.txt",header=TRUE,
# saveFile=FALSE,NameIniPopulations=1, NameEndPopulations=3)
# 
# # Reading the alignment directly from file, displaying only the 
# # weighted matrix:
# 	HapPerPop(inputFile="4_FindHaplo_Example2_modified.txt",header=TRUE,
# saveFile=FALSE,NameIniPopulations=1, NameEndPopulations=11)[[1]]
# 
# # Reading the alignment from an object and saving the two computed
# # distance matrices:
# 	FH&lt;-read.table("3_FindHaplo_Example2_modified.txt",header=TRUE)
# 	HapPerPop(input=FH,header=TRUE,saveFile=FALSE)
# 
## End(Not run)
</code></pre>

<hr>
<h2 id='inter.intra.plot'>Histogram of the intra- and interspecific distances
</h2><span id='topic+inter.intra.plot'></span>

<h3>Description</h3>

<p>Plot histogram for inter and intra-specific distances together</p>


<h3>Usage</h3>

<pre><code class='language-R'>inter.intra.plot(dismat=NA, xlim=NULL,ylim=NULL,
intra.col="gray",intra.density=0,intra.n=30,plot="N",
inter.col="black",inter.density=0,inter.n=30,legend=TRUE,
main="",xlab="Genetic distances",ylab=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inter.intra.plot_+3A_dismat">dismat</code></td>
<td>

<p>a symmetric matrix containing the pairwise genetic distances between individual sequences.
</p>
</td></tr>
<tr><td><code id="inter.intra.plot_+3A_xlim">xlim</code></td>
<td>

<p>a vector containing the minimum and maximum value in the x-axis
</p>
</td></tr>
<tr><td><code id="inter.intra.plot_+3A_ylim">ylim</code></td>
<td>

<p>a vector containing the minimum and maximum value in the y-axis
</p>
</td></tr>
<tr><td><code id="inter.intra.plot_+3A_intra.col">intra.col</code></td>
<td>

<p>the colour for the intraspecific distance distribution
</p>
</td></tr>
<tr><td><code id="inter.intra.plot_+3A_intra.density">intra.density</code></td>
<td>

<p>a numeric, the density of shading lines for the intraspecific distance distribution
</p>
</td></tr>
<tr><td><code id="inter.intra.plot_+3A_intra.n">intra.n</code></td>
<td>

<p>a numeric, the number of categories to represent in the intraspecific distance distribution
</p>
</td></tr>
<tr><td><code id="inter.intra.plot_+3A_plot">plot</code></td>
<td>

<p>a string, &quot;freq&quot; to represent frequency values in the y-axis and &quot;N&quot; for number of occurrences
</p>
</td></tr>
<tr><td><code id="inter.intra.plot_+3A_inter.col">inter.col</code></td>
<td>

<p>the colour for the interspecific distance distribution
</p>
</td></tr>
<tr><td><code id="inter.intra.plot_+3A_inter.density">inter.density</code></td>
<td>

<p>a numeric, the density of shading lines for the interspecific distance distribution
</p>
</td></tr>
<tr><td><code id="inter.intra.plot_+3A_inter.n">inter.n</code></td>
<td>

<p>a numeric, the number of categories to represent in the interspecific distance distribution
</p>
</td></tr>
<tr><td><code id="inter.intra.plot_+3A_legend">legend</code></td>
<td>

<p>a logic, &quot;TRUE&quot; to show plot legend
</p>
</td></tr>
<tr><td><code id="inter.intra.plot_+3A_main">main</code></td>
<td>

<p>a string containing the title of the plot
</p>
</td></tr>
<tr><td><code id="inter.intra.plot_+3A_xlab">xlab</code></td>
<td>

<p>a string with the label of the x-axis
</p>
</td></tr>
<tr><td><code id="inter.intra.plot_+3A_ylab">ylab</code></td>
<td>

<p>a string with the label of the x-axis
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table>
<tr><td><code>Intraspecific</code></td>
<td>
<p>a vector containing all the intraspecific distances.
</p>
</td></tr>
<tr><td><code>Interspecific</code></td>
<td>
<p>a vector containing all the interspecific distances.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A.J. Muñoz-Pajares
</p>


<h3>Examples</h3>

<pre><code class='language-R'># # Generating a distance matrix:
# 
# my.mat&lt;-matrix(nrow=100,ncol=100,
# dimnames=list(paste("sp",rep(1:2,50),
# sep=""),paste("sp",rep(1:2,50),sep="")))
# L&lt;-my.mat[seq(1,nrow(my.mat),2),seq(1,ncol(my.mat),2)]
# my.mat[seq(1,nrow(my.mat),2),seq(1,ncol(my.mat),2)]&lt;-rnorm(0.15,n=L,sd=0.01)
# my.mat[seq(2,nrow(my.mat),2),seq(2,ncol(my.mat),2)]&lt;-rnorm(0.15,n=L,sd=0.01)
# my.mat[seq(1,nrow(my.mat),2),seq(2,ncol(my.mat),2)]&lt;-rnorm(0.3,n=L,sd=0.04)
# my.mat[seq(2,nrow(my.mat),2),seq(1,ncol(my.mat),2)]&lt;-rnorm(0.3,n=L,sd=0.04)
# #Converting to symmetric
# my.mat&lt;-as.matrix(as.dist(my.mat))  
# inter.intra.plot(dismat=my.mat)
# inter.intra.plot(dismat=my.mat,intra.n=10)
# inter.intra.plot(dismat=my.mat,plot="Freq",intra.n=10)
</code></pre>

<hr>
<h2 id='MCIC'>Modified Complex Indel Coding as distance matrix
</h2><span id='topic+MCIC'></span>

<h3>Description</h3>

<p>This function computes an indel distance matrix following the rationale of the Modified Complex Indel Coding (Muller, 2006) to estimate transition matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCIC(inputFile = NA, align = NA, saveFile = TRUE, outname =
paste(inputFile, "IndelDistanceMatrixMullerMod.txt"), silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCIC_+3A_inputfile">inputFile</code></td>
<td>
<p>the name of the fasta file to be analysed. Alternatively you can provide the name of a &quot;DNAbin&quot; class alignment stored in memory using the &quot;align&quot; option.
</p>
</td></tr>
<tr><td><code id="MCIC_+3A_align">align</code></td>
<td>
<p>the name of the alignment to be analysed. See &quot;read.dna&quot; in ape  package for details about reading alignments. Alternatively you can provide the name of the file containing the alignment in fasta format using the &quot;inputFile&quot; option.
</p>
</td></tr>
<tr><td><code id="MCIC_+3A_savefile">saveFile</code></td>
<td>
<p>a logical; if TRUE (default), function output is saved as a text file.
</p>
</td></tr>
<tr><td><code id="MCIC_+3A_outname">outname</code></td>
<td>
<p>if &quot;saveFile&quot; is set to TRUE (default), contains the name of the output file.
</p>
</td></tr>
<tr><td><code id="MCIC_+3A_silent">silent</code></td>
<td>
<p>a logical; if FALSE (default), it prints the number of unique
sequences found and the name of the output file.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to estimate this distance matrix using only the unique sequences in the
alignment. Repeated sequences increase computation time but do not provide additional 
information (because they produce duplicated rows and columns in the final distance matrix).
</p>


<h3>Value</h3>

<p>A matrix containing the genetic distances estimated as indels pairwise differences.
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares
</p>


<h3>References</h3>

<p>Muller K. (2006). Incorporating information from length-mutational events into phylogenetic analysis. Molecular Phylogenetics and Evolution, 38, 667-676.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# # This will generate an example file in your working directory:
# cat("&gt;Population1_sequence1",
# "A-AGGGTC-CT---G",
# "&gt;Population1_sequence2",
# "TAA---TCGCT---G",
# "&gt;Population1_sequence3",
# "TAAGGGTCGCT---G",
# "&gt;Population1_sequence4",
# "TAA---TCGCT---G",
# "&gt;Population2_sequence1",
# "TTACGGTCG---TTG",
# "&gt;Population2_sequence2",
# "TAA---TCG---TTG",
# "&gt;Population2_sequence3",
# "TAA---TCGCTATTG",
# "&gt;Population2_sequence4",
# "TTACGGTCG---TTG",
# "&gt;Population3_sequence1",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence2",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence3",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence4",
# "TTA---TCG---TAG",
#      file = "ex3.fas", sep = "\n")
# 
# # Reading the alignment directly from file and saving no output file:
# MCIC (input="ex3.fas", saveFile = FALSE)
# 
# # Analysing the same dataset, but using only unique sequences:
# uni&lt;-GetHaplo(inputFile="ex3.fas",saveFile=FALSE)
# MCIC (align=uni, saveFile = FALSE)
# 
</code></pre>

<hr>
<h2 id='mergeNodes'>Merges nodes showing distance values equal to zero</h2><span id='topic+mergeNodes'></span>

<h3>Description</h3>

<p>This function returns a new distance matrix merging rows (and columns) showing distance values equal to zero. It also deals with missing data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeNodes(dis, na.rm.row.col = FALSE, save.distance = FALSE,
save.distance.name = "Merged_Distance.txt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeNodes_+3A_dis">dis</code></td>
<td>
<p>the input distance matrix</p>
</td></tr>
<tr><td><code id="mergeNodes_+3A_na.rm.row.col">na.rm.row.col</code></td>
<td>
<p>a logical; if TRUE, missing values are removed before the computation proceeds.</p>
</td></tr>
<tr><td><code id="mergeNodes_+3A_save.distance">save.distance</code></td>
<td>
<p>a logical; if TRUE, the new distance matrix will be saved in a file.</p>
</td></tr>
<tr><td><code id="mergeNodes_+3A_save.distance.name">save.distance.name</code></td>
<td>
<p>a string; if save.distance is set to TRUE, it defines the name of the file to be saved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some circumstances you may get distance matrices showing off-diagonal zeros. In such cases you may consider that the
existence of these off-diagonal zeros suggests that some of the groups you defined (e.g., populations) are not genetically different.
Thus, you must re-define groups to get a matrix composed only by different  groups using the 'mergeNodes' function and 
estimate a percolation network using the 'perc.thr' function. On the other hand, you may consider that, despite the off-
diagonal zeros, the groups you defined are actually different. In that case you may not be able to estimate a 
percolation threshold, but you can represent the original distance matrix using the 'NINA.thr' or the 'zero.thr' functions.
</p>
<p><strong>'mergeNodes'</strong> select all rows (and columns) showing a distance equal to zero and generates a new row (and column). The distance between the new merged and the remaining rows (or columns) in the matrix is estimated as the arithmetic mean of the selected elements. The biological interpretation of the new matrix could be hard if the original matrix shows a large number of off-diagonal zeros.
</p>
<p>'perc.thr' estimates a threshold to represent a distance matrix as a network. To estimate this threshold, the algorithm represents as a link all distances lower than a range of thresholds (by default, select 101 values from 0 to 1), defined as the percentage of the maximum distance in the input matrix. For each threshold a network is built and the number of clusters (that is, the number of isolated groups of nodes) in the network is also estimated. Finally, the algorithm selects the lower threshold connecting a higher number of nodes. Note that the resulting network may show isolated nodes if it is necessary to represent a large number of links to connect a low number of nodes.
</p>
<p>'NINA.thr' is identical to 'perc.thr', but, in the last step, the algorithm selects the lower threshold connecting all nodes in a single cluster. The information provided by this function may be limited if the original distance matrix shows high variation.
</p>
<p>'zero.thr' represents as a link only distances equal to zero. The information provided by this function may be limited if the original matrix shows few off-diagonal zeros.
</p>


<h3>Value</h3>

<p>a distance matrix with merged rows and columns</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>See Also</h3>

<p><code><a href="#topic+NINA.thr">NINA.thr</a></code>, <code><a href="#topic+zero.thr">zero.thr</a></code>, <code><a href="#topic+perc.thr">perc.thr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#EXAMPLE 1: FEW OFF-DIAGONAL ZEROS

#Generating a distance matrix:
Dis1&lt;-matrix(c(
0.00,0.77,0.28,0.94,0.17,0.14,0.08,0.49,0.64,0.01,
0.77,0.00,0.12,0.78,0.97,0.02,0.58,0.09,0.36,0.33,
0.28,0.12,0.00,0.70,0.73,0.06,0.50,0.79,0.80,0.94,
0.94,0.78,0.70,0.00,0.00,0.78,0.04,0.42,0.25,0.85,
0.17,0.97,0.73,0.00,0.00,0.30,0.55,0.12,0.68,0.99,
0.14,0.02,0.06,0.78,0.30,0.00,0.71,1.00,0.64,0.88,
0.08,0.58,0.50,0.04,0.55,0.71,0.00,0.35,0.84,0.76,
0.49,0.09,0.79,0.42,0.12,1.00,0.35,0.00,0.56,0.81,
0.64,0.36,0.80,0.25,0.68,0.64,0.84,0.56,0.00,0.62,
0.01,0.33,0.94,0.85,0.99,0.88,0.76,0.81,0.62,0.00),ncol=10)
colnames(Dis1)&lt;-c(paste("Pop",c(1:10),sep=""))
row.names(Dis1)&lt;-colnames(Dis1)

# No percolation threshold can be found.
#perc.thr(Dis1)

# #Check Dis1 and merge populations showing distances equal to zero:
# Dis1
# Dis1_Merged&lt;-mergeNodes(dis=Dis1)
# #Check the merged matrix. A new "population" has been
# #defined merging populations 4 and 5.
# #Distances between the merged and the remaining populations are estimated as the arithmetic mean.
# Dis1_Merged
# # It is now possible to estimate a percolation threshold
# perc.thr(dis=Dis1_Merged,ptPDF=FALSE, estimPDF=FALSE, estimOutfile=FALSE) 

# EXAMPLE 2: TOO MANY OFF-DIAGONAL ZEROS
# #Generating a distance matrix:
# Dis2&lt;-matrix(c(
# 0.00,0.77,0.28,0.00,0.17,0.14,0.00,0.49,0.64,0.01,
# 0.77,0.00,0.12,0.00,0.97,0.02,0.00,0.09,0.36,0.33,
# 0.28,0.12,0.00,0.70,0.73,0.06,0.50,0.79,0.00,0.94,
# 0.00,0.00,0.70,0.00,0.00,0.78,0.04,0.00,0.00,0.00,
# 0.17,0.97,0.73,0.00,0.00,0.30,0.55,0.12,0.00,0.00,
# 0.14,0.02,0.06,0.78,0.30,0.00,0.71,1.00,0.64,0.00,
# 0.00,0.00,0.50,0.04,0.55,0.71,0.00,0.35,0.84,0.00,
# 0.49,0.09,0.79,0.00,0.12,1.00,0.35,0.00,0.56,0.81,
# 0.64,0.36,0.00,0.00,0.00,0.64,0.84,0.56,0.00,0.62,
# 0.01,0.33,0.94,0.00,0.00,0.00,0.00,0.81,0.62,0.00),ncol=10)
# colnames(Dis2)&lt;-c(paste("Pop",c(1:10),sep=""))
# row.names(Dis2)&lt;-colnames(Dis2)
# 
# # No percolation threshold can be found
# #perc.thr(Dis2)
# 
# #Check Dis2 and merge populations showing distances equal to zero:
# Dis2
# Dis2_Merged&lt;-mergeNodes(dis=Dis2)
# 
# #Check the merged matrix. Many new "populations" have been defined
# #and both the new matrix and the resulting network are difficult
# #to interpret:
# Dis2_Merged
# perc.thr(dis=Dis2_Merged,ptPDF=FALSE, estimPDF=FALSE, estimOutfile=FALSE) 
# 
# #Instead of percolation network, representing zeros
# #as the lowest values may be informative:
# zero.thr(dis=Dis2,ptPDF=FALSE)
# 
# # Adjusting sizes and showing modules:
# zero.thr(dis=Dis2,ptPDF=FALSE,cex.label=0.8,cex.vertex=1.2,modules=TRUE)
# 
# #In the previous example, the 'zero.thr' method is unuseful: 
# zero.thr(dis=Dis1,ptPDF=FALSE)
# 
# #In both cases, the 'No Isolation Nodes Allowed' method yields an informative matrix:
# NINA.thr(dis=Dis1,modules=TRUE)
# NINA.thr(dis=Dis2,modules=TRUE)
</code></pre>

<hr>
<h2 id='mutation.network'>Haplotype network depiction including mutations</h2><span id='topic+mutation.network'></span>

<h3>Description</h3>

<p>This function represents an alignment as a network and displays mutations (substitutions and indels) as marks in edges.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutation.network(align = NA, indel.method = "MCIC",
substitution.model = "raw", pairwise.deletion = TRUE,
network.method = "percolation", range = seq(0, 1, 0.01),
merge.dist.zero=TRUE, addExtremes = FALSE, alpha = "info",
combination.method = "Corrected", na.rm.row.col = FALSE,
modules = FALSE, moduleCol = NA,
modFileName = "Modules_summary.txt", save.distance = FALSE,
save.distance.name = "DistanceMatrix_threshold.txt",
silent = FALSE, bgcol = "white", label.col = "black",
label = NA, label.sub.str = NA, colInd = "red",
colSust = "black", lwd.mut = 1, lwd.edge = 1.5,
cex.mut = 1, cex.label = 1, cex.vertex = 1, main = "",
InScale = 1, SuScale = 1, legend = NA, legend.bty = "o",
legend.pos="bottomright", large.range = FALSE, pies = FALSE,
NameIniPopulations = NA, NameEndPopulations = NA,
NameIniHaplotypes = NA, NameEndHaplotypes = NA, 
HaplosNames = NA,verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutation.network_+3A_align">align</code></td>
<td>
<p>a 'DNAbin' object; the alignment to be analysed. See &quot;read.dna&quot; in the ape package for details about reading alignments.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_indel.method">indel.method</code></td>
<td>
<p>a sting; the method to define indel events in your alignments. The available methods are:
</p>
<p>-&quot;MCIC&quot;: (Default) Estimates indel events following the rationale of the Modified Complex Indel Coding (Muller, 2006).
</p>
<p>-&quot;SIC&quot;: Estimates indel events following the rationale of Simmons and Ochoterrena (2000).
</p>
<p>-&quot;FIFTH&quot;: Estimates indel events following the rationale of the fifth state: each gap within the alignment is treated
as an independent mutation event.
</p>
<p>-&quot;BARRIEL&quot;: Estimates indel events following the rationale of Barriel (1994): singleton gaps are not taken into account.
</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_substitution.model">substitution.model</code></td>
<td>
<p>a string; the substitution evolutionary model to estimate the distance matrix. By default is set to &quot;raw&quot; and
estimates the pairwise proportion of variant sites. See the evolutionary models available using ?dist.dna from the ape package.
</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_pairwise.deletion">pairwise.deletion</code></td>
<td>
<p>a logical; if TRUE (default) substitutions found in regions being a gap in other sequences will account
for the distance matrix. If FALSE, sites being a gap in at least one sequence will be removed before distance estimation.
</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_network.method">network.method</code></td>
<td>
<p>a string; the method to build the network. The available methods are:
</p>
<p>-&quot;percolation&quot;: computes a network using the percolation network method following Rozenfeld et al. (2008).
See ?perc.thr for details
</p>
<p>-&quot;NINA&quot;: computes a network using the No Isolation Nodes Allowed method. See ?NINA.thr for details.
</p>
<p>-&quot;zero&quot;: computes a network connecting all nodes showing distances equal to zero. See ?zero.thr for details.
</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_range">range</code></td>
<td>
<p>a numeric vector between 0 and 1, is the range of thresholds (referred to the maximum distance in the input matrix) to be screened (by default, 101 values from 0 to 1). This option is used for &quot;percolation&quot; and &quot;NINA&quot; network methods and ignored for &quot;zero&quot; method.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_merge.dist.zero">merge.dist.zero</code></td>
<td>
<p>a logical; if TRUE, nodes showing a distance equal to zero are merged using the mergeNodes() function</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_addextremes">addExtremes</code></td>
<td>
<p>a logical; if TRUE, additional nucleotide sites are included in both extremes of the alignment. This will allow estimating distances for alignments showing gaps in terminal positions. This option is used for &quot;SIC&quot;, &quot;FIFTH&quot; and &quot;BARRIEL&quot; indel methods and ignored for &quot;MCIC&quot; method.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_alpha">alpha</code></td>
<td>
<p>a numeric between 0 and 1, is the weight given to the indel genetic distance matrix for the combination. By definition, the weight of the substitution genetic matrix is the complementary value (i.e., 1-alpha). The value &quot;info&quot; (default) will use the proportion of informative substitutions per informative indel event as weight. It is also possible to define multiple weights to estimate different combinations.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_combination.method">combination.method</code></td>
<td>
<p>a string defining whether each distance matrix must be divided by its maximum value before the combination (&quot;Corrected&quot;) or not (&quot;Uncorrected&quot;). Consequently, if the &quot;Corrected&quot; method is chosen, both matrices will range between 0 and 1 before being combined.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_na.rm.row.col">na.rm.row.col</code></td>
<td>
<p>a logical; if TRUE, distance matrix missing values are removed.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_modules">modules</code></td>
<td>
<p>a logical, If TRUE, nodes belonging to different modules are represented as different colours (defined by 'moduleCol'). Modules (defined as subsets of nodes that conform densely connected subgraphs) are estimated by means of random walks (see 'igraph' package for details).</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_modulecol">moduleCol</code></td>
<td>
<p>(if modules=TRUE) a vector of strings defining the colour of nodes belonging to different modules in the network. If 'NA' (or there are less colours than haplotypes), colours are automatically selected</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_modfilename">modFileName</code></td>
<td>
<p>(if modules=TRUE) a string, the name of the file to be generated containing a summary of module results (sequence name, module, and colour in network)</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_save.distance">save.distance</code></td>
<td>
<p>a logical; if FALSE (default), the distance matrix used for computation is saved in a file</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_save.distance.name">save.distance.name</code></td>
<td>
<p>if save.distace=TRUE, a string defining the file name</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_silent">silent</code></td>
<td>
<p>a logical; if FALSE (default), displays a list containing the number of indels and substitutions represented in the network.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_bgcol">bgcol</code></td>
<td>
<p>a vector of strings; the colour of the background for each node in the network. Can be equal for all nodes (if only one colour is defined), customized (if several colours are defined), or can represent different modules (see &quot;modules&quot; option). If set to 'NA' (default) or if less colours than haplotypes are defined, colours are automatically selected.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_label.col">label.col</code></td>
<td>
<p>a vector of strings; the colour of labels for each node in the network. Can be equal for all nodes (if only one colour is defined) or customized (if several colours are defined).</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_label">label</code></td>
<td>
<p>a vector of strings; labels for each node. By default are the sequence names. (See 'label.sub.str' to automatically reduce name lengths)</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_label.sub.str">label.sub.str</code></td>
<td>
<p>a vector of two numerics; if node labels are a substring of sequence names, these two numbers represent the initial and final character of the string to be represented. See Example for details.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_lwd.edge">lwd.edge</code></td>
<td>
<p>a numeric; the width of the edge linking nodes (1.5 by default).</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_colind">colInd</code></td>
<td>
<p>a strings; the colour used to represent indels (red by default).</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_colsust">colSust</code></td>
<td>
<p>a strings; the colour used to represent substitutions (black by default).</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_lwd.mut">lwd.mut</code></td>
<td>
<p>a numeric; the width of the line (perpendicular to the edge line) representing mutations (1 by default).</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_cex.mut">cex.mut</code></td>
<td>
<p>a numeric; the length of the line (perpendicular to the edge line) representing mutations (1 by default).</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_cex.vertex">cex.vertex</code></td>
<td>
<p>a numeric; the size of the nodes.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_cex.label">cex.label</code></td>
<td>
<p>a numeric; the size of the node labels.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_main">main</code></td>
<td>
<p>if set to &quot;summary&quot; the main options selected for representing the network are displayed in title. The default value (&quot;&quot;) shows no title for the network.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_inscale">InScale</code></td>
<td>
<p>a numeric; the number of indels each mark represents. By default is set to 1 (that is, 1 mark= 1 indel). If set to 10, then 1 mark=10 indels. In that case, if there are 25 indels in a given edge it is represented by three marks (being one of them half width than the other two).</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_suscale">SuScale</code></td>
<td>
<p>a numeric; the number of substitutions each mark represents. By default is set to 1 (that is, 1 mark= 1 substitution). If set to 10, then 1 mark=10 substitutions In that case, if there are 25 substitutions in a given edge it is represented by three marks (being one of them half width than the other two).</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_legend">legend</code></td>
<td>
<p>a logic; if TRUE, plots a legend representing the scale of marks (that is, the number of mutations represented by a mark).</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_legend.bty">legend.bty</code></td>
<td>
<p>a letter; the type of box to be drawn around the legend. The allowed values are 'o' (default, producing a four-sides box) and 'n' (producing no box).</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_legend.pos">legend.pos</code></td>
<td>
<p>a string, defines legend position (&quot;bottomright&quot; by default). Other possible values are: ‘&quot;bottomright&quot;’, ‘&quot;bottom&quot;’, ‘&quot;bottomleft&quot;’, ‘&quot;left&quot;’, ‘&quot;topleft&quot;’, ‘&quot;top&quot;’, ‘&quot;topright&quot;’, ‘&quot;right&quot;’ and ‘&quot;center&quot;’.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_large.range">large.range</code></td>
<td>
<p>a logic, TRUE for representing node size according to three categories: haplotypes appearing less than 10 times, between 10 and 100 times and more than 100 times</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_pies">pies</code></td>
<td>
<p>a logic, TRUE for representing nodes as pies and FALSE for representing nodes as points</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_nameinipopulations">NameIniPopulations</code></td>
<td>
<p>a numeric; Position of the initial character of population names within sequence names. If not provided, it is set to 1. It is used only if NameEndPopulations is also defined.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_nameendpopulations">NameEndPopulations</code></td>
<td>
<p>a numeric; Position of the last character of population names within sequence names. If not provided, it is set to the first &quot;_&quot; character in the sequences name. It is used only if NameIniPopulations is also defined.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_nameinihaplotypes">NameIniHaplotypes</code></td>
<td>
<p>a numeric; Position of the initial character of haplotype names within sequence names. If not provided, haplotype names are given and the value is set accordingly. It is used only if NameEndHaplotypes is also defined.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_nameendhaplotypes">NameEndHaplotypes</code></td>
<td>
<p>a numeric; Position of the last character of haplotype names within sequence names. If not provided, haplotype names are given and the value is set accordingly. It is used only if NameIniHaplotypes is also defined.</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_haplosnames">HaplosNames</code></td>
<td>
<p>a sting; the name of the haplotypes (if different from default: H1...Hn)</p>
</td></tr>
<tr><td><code id="mutation.network_+3A_verbose">verbose</code></td>
<td>
<p>a logical, if TRUE details on the calculation are shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Despite the large list of options, the only mandatory option for this function is the alignment to be represented. The remaining options can be classified into four groups:
</p>
<p>1- options defining the computation of both indel and substitution distances (indel.method, substitution.model, pairwise.deletion).
</p>
<p>2- options defining the combination of these two distance matrices (alpha, combination.method, na.rm.row.col, addExtremes, save.distance, save.distance.name).
</p>
<p>3- options defining the computation of the network (network.method, range).
</p>
<p>4- options customizing the resulting network (modules, moduleCol, modFileName, bgcol, label.col, label, label.sub.str, colInd, colSust, lwd.mut, lwd.edge, cex.mut, cex.label, cex.vertex, main).
</p>
<p>Although the 'indel.method' option affect both the distance estimation and the number of mutations represented in the network, the 'substitution.model' and 'pairwise.deletion' options only affect the distance matrix computation. The number of substitutuions represented in the network are always estimated using the &quot;N&quot; model and the pairwise deletion of indels.</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>References</h3>

<p>Barriel, V., 1994. Molecular phylogenies and how to code insertion/
deletion events. Life Sci. 317, 693-701, cited and described by
Simmons, M.P., Müller, K. &amp; Norton, A.P. (2007)
The relative performance of indel-coding methods in simulations.
Molecular Phylogenetics and Evolution, 44, 724–740.
</p>
<p>Muller K. (2006). Incorporating information from length-mutational events
into phylogenetic analysis. Molecular Phylogenetics and Evolution, 38, 667-676.
</p>
<p>Paradis, E., Claude, J. &amp; Strimmer, K. (2004). APE: analyses of phylogenetics
and evolution in R language. Bioinformatics, 20, 289-290.
</p>
<p>Rozenfeld AF, Arnaud-Haond S, Hernandez-Garcia E, Eguiluz VM, Serrao EA, Duarte CM. (2008). Network analysis identifies weak and strong links in a metapopulation system. Proceedings of the National Academy of Sciences,105, 18824-18829.
</p>
<p>Simmons, M.P. &amp; Ochoterena, H. (2000). Gaps as Characters in Sequence-Based
Phylogenetic Analyses. Systematic Biology, 49, 369-381.
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+plot.network">plot.network</a></code>, <code><a href="#topic+double.plot">double.plot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># cat("&gt;Population1_sequence1",
# "TTATAAAATCTA----TAGC",
# "&gt;Population1_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population1_sequence3",
# "TTATAAAAATTA----TAGC",
# "&gt;Population1_sequence4",
# "TAAT----TCTA----TAAC",
# "&gt;Population2_sequence1",
# "TTAT----TCGAGGGGTAGC",
# "&gt;Population2_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population2_sequence3",
# "TTATAAAA--------TAGC",
# "&gt;Population2_sequence4",
# "TTAT----TCGAGGGGTAGC",
# "&gt;Population3_sequence1",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence2",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence3",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence4",
# "TTAT----TCGA----TAGC",
#      file = "ex2.fas", sep = "\n")
# 
# library(ape)
# 
# #Network with default options
# mutation.network (align=read.dna(file="ex2.fas",format="fasta"))
# 
# #Using more options:
# mutation.network (align=read.dna(file="ex2.fas",format="fasta"),modules=TRUE)
# 
# #A more complex alignment
# data(ex_alignment1) # this will read a fasta file with the name 'alignExample'
# mutation.network (align=alignExample,modules=TRUE,
# InScale=2, SuScale=2,legend=TRUE,lwd.mut=1.8)
# 
</code></pre>

<hr>
<h2 id='mutationSummary'>
Summary of observed mutations
</h2><span id='topic+mutationSummary'></span>

<h3>Description</h3>

<p>This function computes the number of substitutions and indels observed in a given alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutationSummary(align, addExtremes = FALSE, output = "brief")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutationSummary_+3A_align">align</code></td>
<td>

<p>the name of the &quot;DNAbin&quot; alignment to be analysed. See &quot;?read.dna&quot; in the ape  package for details about reading alignments.</p>
</td></tr>
<tr><td><code id="mutationSummary_+3A_addextremes">addExtremes</code></td>
<td>

<p>a logical; if TRUE, additional nucleotide sites are included in both extremes of the alignment. This will allow estimating distances for alignments showing gaps in terminal positions.</p>
</td></tr>
<tr><td><code id="mutationSummary_+3A_output">output</code></td>
<td>
<p>a string; defines the kind of output. Two values are accepted:
- &quot;brief&quot; (default) produces an output showing the number of mutations (sites and events).
- &quot;detailed&quot; produces an output showing the number of mutations (sites and events), the position of each mutation, and the state of these sites per sequence (A, T, C, G or - for substitutions and 1 or 0 for indels).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>Sites</code></td>
<td>
<p>A matrix containing: the number of sites per sequence (Length); the number of constant and variable sites; the number of singletons and informative sites.</p>
</td></tr>
<tr><td><code>Events</code></td>
<td>
<p>A matrix containing: the number of substitution (singletons, informative, and total) and indel (singletons, informative, and total) events</p>
</td></tr>
<tr><td><code>Constants.Alignment</code></td>
<td>
<p>A matrix showing constant sites in the alignment (Only shown if output==&quot;detailed&quot;).</p>
</td></tr>
<tr><td><code>Variables.Alignment</code></td>
<td>
<p>A matrix showing variable sites in the alignment (Only shown if output==&quot;detailed&quot;).</p>
</td></tr>
<tr><td><code>Singletons.Alignment</code></td>
<td>
<p>A matrix showing singleton sites in the alignment (Only shown if output==&quot;detailed&quot;).</p>
</td></tr>
<tr><td><code>Inforatives.Alignment</code></td>
<td>
<p>A matrix showing informative sites in the alignment (Only shown if output==&quot;detailed&quot;).</p>
</td></tr>
<tr><td><code>Substitutions</code></td>
<td>
<p>A matrix showing substitution sites in the alignment (Only shown if output==&quot;detailed&quot;).</p>
</td></tr>
<tr><td><code>Subst.Single</code></td>
<td>
<p>A matrix showing singleton substitution sites in the alignment (Only shown if output==&quot;detailed&quot;).</p>
</td></tr>
<tr><td><code>Subst.Info</code></td>
<td>
<p>A matrix showing informative substitution sites in the alignment (Only shown if output==&quot;detailed&quot;).</p>
</td></tr>
<tr><td><code>Gaps</code></td>
<td>
<p>A matrix showing gap sites in the alignment (Only shown if output==&quot;detailed&quot;).</p>
</td></tr>
<tr><td><code>Gaps.Single</code></td>
<td>
<p>A matrix showing singleton gap sites in the alignment (Only shown if output==&quot;detailed&quot;).</p>
</td></tr>
<tr><td><code>Gaps.Info</code></td>
<td>
<p>A matrix showing informative gap sites in the alignment (Only shown if output==&quot;detailed&quot;).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>Examples</h3>

<pre><code class='language-R'># cat("&gt;Population1_sequence1",
# "A-AGGGTC-CT---G",
# "&gt;Population1_sequence2",
# "TAA---TCGCT---G",
# "&gt;Population1_sequence3",
# "TAAGGGTCGCT---G",
# "&gt;Population1_sequence4",
# "TAA---TCGCT---G",
# "&gt;Population2_sequence1",
# "TTACGGTCG---TTG",
# "&gt;Population2_sequence2",
# "TAA---TCG---TTG",
# "&gt;Population2_sequence3",
# "TAA---TCGCTATTG",
# "&gt;Population2_sequence4",
# "TTACGGTCG---TTG",
# "&gt;Population3_sequence1",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence2",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence3",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence4",
# "TTA---TCG---TAG",
#      file = "ex3.fas", sep = "\n")
# 
# # Reading the alignment directly from file and saving no output file:
# library(ape)
# mutationSummary (align=read.dna("ex3.fas",format="fasta"))
# mutationSummary (align=read.dna("ex3.fas",format="fasta"),output="detailed")
# 
# #A more complex alignment
# data(ex_alignment1) # this will read a fasta file with the name 'alignExample'
# mutationSummary(align=alignExample,addExtremes=TRUE)
# 
</code></pre>

<hr>
<h2 id='NINA.thr'>No Isolated Nodes Allowed network</h2><span id='topic+NINA.thr'></span>

<h3>Description</h3>

<p>Given a distance matrix, this function computes a network connecting all nodes with the minimum number of links.</p>


<h3>Usage</h3>

<pre><code class='language-R'>NINA.thr(dis, range = seq(0, 1, 0.01), ptPDF = TRUE,
ptPDFname = "NINA_Network.pdf", estimPDF = TRUE,
estimPDFname = "NINA.ThresholdEstimation.pdf",
estimOutfile = TRUE, cex.label = 1, cex.vertex = 1,
estimOutName = "NINA.ThresholdEstimation.txt",
appendOutfile = TRUE, plotALL = FALSE, bgcol = "white",
label.col = "black", label = colnames(dis), modules = FALSE,
moduleCol = NA, modFileName = "Modules_summary.txt", ncs = 4,
na.rm.row.col = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NINA.thr_+3A_dis">dis</code></td>
<td>
<p>the input distance matrix</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_range">range</code></td>
<td>
<p>a numeric vector between 0 and 1, is the range of thresholds (referred to the maximum distance in the input matrix) to be screened (by default, 101 values from 0 to 1).</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_ptpdf">ptPDF</code></td>
<td>
<p>a logical, must the resulting network be saved as a pdf file?</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_ptpdfname">ptPDFname</code></td>
<td>
<p>if ptPDF=TRUE, the name of the pdf file containing the network to be saved (&quot;NINA_Network.pdf&quot;, by default)</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_estimoutfile">estimOutfile</code></td>
<td>
<p>a logical, must the value of &lt;s&gt; for each threshold (NINA threshold estimation) be saved as a text file?</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_estimoutname">estimOutName</code></td>
<td>
<p>if estimOutfile=TRUE (default), contains the name of the text file containing the NINA threshold estimation (&quot;PercThr Estimation.txt&quot; by default).</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_appendoutfile">appendOutfile</code></td>
<td>
<p>a logical, if estimOutfile=TRUE, it defines whether results must be appended to an existing file with the same name (TRUE) or the existing file must be replaced (FALSE).</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_estimpdf">estimPDF</code></td>
<td>
<p>a logical, must the NINA threshold estimation plot be saved as a pdf file?</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_estimpdfname">estimPDFname</code></td>
<td>
<p>if estimPDF=TRUE (default), defines the name of the pdf file containing the NINA threshold estimation plot (by default).</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_cex.label">cex.label</code></td>
<td>
<p>a numeric; the size of the node labels.</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_cex.vertex">cex.vertex</code></td>
<td>
<p>a numeric; the size of the nodes.</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_plotall">plotALL</code></td>
<td>
<p>a logical, must all the networks calculated during the NINA threshold estimation (defined by &quot;range&quot; option) be saved as different pdf files? (FALSE, by default). If TRUE, for each value defined in threshold, one pdf file is generated.</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_bgcol">bgcol</code></td>
<td>
<p>the colour of the background for each node in the network. Can be equal for all nodes (if only one colour is defined), customized (if several colours are defined), or can represent different modules (see &quot;modules&quot; option).</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_label.col">label.col</code></td>
<td>
<p>vector of strings defining the colour of labels for each node in the network. Can be equal for all nodes (if only one colour is defined) or customized (if several colours are defined).</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_label">label</code></td>
<td>
<p>vector of strings, labels for each node. By default are the column names of the distance matrix (dis). (See substr function in base package to automatically set a string subset from column names).</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_modules">modules</code></td>
<td>
<p>a logical, If TRUE, nodes belonging to different modules are represented as different colours (defined by 'moduleCol'). Modules (defined as subsets of nodes that conform densely connected subgraphs) are estimated by means of random walks (see 'igraph' package for details).</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_modulecol">moduleCol</code></td>
<td>
<p>(if modules=TRUE) a vector of strings defining the colour of nodes belonging to different modules in the network. If 'NA' (or there are less colours than haplotypes), colours are automatically selected</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_modfilename">modFileName</code></td>
<td>
<p>(if modules=TRUE) the name of a generated file containing a summary of module results</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_ncs">ncs</code></td>
<td>
<p>a numeric; number of decimal places to display threshold in plot title.</p>
</td></tr>
<tr><td><code id="NINA.thr_+3A_na.rm.row.col">na.rm.row.col</code></td>
<td>
<p>a logical; if TRUE, missing values are removed before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some circumstances you may get distance matrices showing off-diagonal zeros. In such cases you may consider that the
existence of these off-diagonal zeros suggests that some of the groups you defined (e.g., populations) are not genetically different.
Thus, you must re-define groups to get a matrix composed only by different  groups using the 'mergeNodes' function and 
estimate a percolation network using the 'perc.thr' function. On the other hand, you may consider that, despite the off-
diagonal zeros, the groups you defined are actually different. In that case you may not be able to estimate a 
percolation threshold, but you can represent the original distance matrix using the 'NINA.thr' or the 'zero.thr' functions.
</p>
<p>'mergeNodes' select all rows (and columns) showing a distance equal to zero and generates a new row (and column). The distance between the new merged and the remaining rows (or columns) in the matrix is estimated as the arithmetic mean of the selected elements. The biological interpretation of the new matrix could be hard if the original matrix shows a large number of off-diagonal zeros.
</p>
<p>'perc.thr' estimates a threshold to represent a distance matrix as a network. To estimate this threshold, the algorithm represents as a link all distances lower than a range of thresholds (by default, select 101 values from 0 to 1), defined as the percentage of the maximum distance in the input matrix. For each threshold a network is built and the number of clusters (that is, the number of isolated groups of nodes) in the network is also estimated. Finally, the algorithm selects the lower threshold connecting a higher number of nodes. Note that the resulting network may show isolated nodes if it is necessary to represent a large number of links to connect a low number of nodes.
</p>
<p><strong>'NINA.thr'</strong> is identical to 'perc.thr', but, in the last step, the algorithm selects the lower threshold connecting all nodes in a single cluster. The information provided by this function may be limited if the original distance matrix shows high variation.
</p>
<p>'zero.thr' represents as a link only distances equal to zero. The information provided by this function may be limited if the original matrix shows few off-diagonal zeros.
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>See Also</h3>

<p><code><a href="#topic+mergeNodes">mergeNodes</a></code>, <code><a href="#topic+zero.thr">zero.thr</a></code>, <code><a href="#topic+perc.thr">perc.thr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#EXAMPLE 1: FEW OFF-DIAGONAL ZEROS
#Generating a distance matrix:
Dis1&lt;-matrix(c(
0.00,0.77,0.28,0.94,0.17,0.14,0.08,0.49,0.64,0.01,
0.77,0.00,0.12,0.78,0.97,0.02,0.58,0.09,0.36,0.33,
0.28,0.12,0.00,0.70,0.73,0.06,0.50,0.79,0.80,0.94,
0.94,0.78,0.70,0.00,0.00,0.78,0.04,0.42,0.25,0.85,
0.17,0.97,0.73,0.00,0.00,0.30,0.55,0.12,0.68,0.99,
0.14,0.02,0.06,0.78,0.30,0.00,0.71,1.00,0.64,0.88,
0.08,0.58,0.50,0.04,0.55,0.71,0.00,0.35,0.84,0.76,
0.49,0.09,0.79,0.42,0.12,1.00,0.35,0.00,0.56,0.81,
0.64,0.36,0.80,0.25,0.68,0.64,0.84,0.56,0.00,0.62,
0.01,0.33,0.94,0.85,0.99,0.88,0.76,0.81,0.62,0.00),ncol=10)
colnames(Dis1)&lt;-c(paste("Pop",c(1:10),sep=""))
row.names(Dis1)&lt;-colnames(Dis1)

# No percolation threshold can be found.
#perc.thr(Dis1)

#Check Dis1 and merge populations showing distances equal to zero:
# Dis1
# Dis1_Merged&lt;-mergeNodes(dis=Dis1)
#Check the merged matrix. A new "population" has been defined merging populations 4 and 5.
#Distances between the merged and the remaining populations are estimated as the arithmetic mean.
# Dis1_Merged
# It is now possible to estimate a percolation threshold
# perc.thr(dis=Dis1_Merged,ptPDF=FALSE, estimPDF=FALSE, estimOutfile=FALSE) 

# EXAMPLE 2: TOO MANY OFF-DIAGONAL ZEROS
#Generating a distance matrix:
# Dis2&lt;-matrix(c(
# 0.00,0.77,0.28,0.00,0.17,0.14,0.00,0.49,0.64,0.01,
# 0.77,0.00,0.12,0.00,0.97,0.02,0.00,0.09,0.36,0.33,
# 0.28,0.12,0.00,0.70,0.73,0.06,0.50,0.79,0.00,0.94,
# 0.00,0.00,0.70,0.00,0.00,0.78,0.04,0.00,0.00,0.00,
# 0.17,0.97,0.73,0.00,0.00,0.30,0.55,0.12,0.00,0.00,
# 0.14,0.02,0.06,0.78,0.30,0.00,0.71,1.00,0.64,0.00,
# 0.00,0.00,0.50,0.04,0.55,0.71,0.00,0.35,0.84,0.00,
# 0.49,0.09,0.79,0.00,0.12,1.00,0.35,0.00,0.56,0.81,
# 0.64,0.36,0.00,0.00,0.00,0.64,0.84,0.56,0.00,0.62,
# 0.01,0.33,0.94,0.00,0.00,0.00,0.00,0.81,0.62,0.00),ncol=10)
# colnames(Dis2)&lt;-c(paste("Pop",c(1:10),sep=""))
# row.names(Dis2)&lt;-colnames(Dis2)
# 
# # No percolation threshold can be found
# #perc.thr(Dis2)
# 
# #Check Dis2 and merge populations showing distances equal to zero:
# Dis2
# Dis2_Merged&lt;-mergeNodes(dis=Dis2)
# 
# #Check the merged matrix. Many new "populations" have been defined
# #and both the new matrix and the resulting network
# #are difficult to interpret:
# Dis2_Merged
# perc.thr(dis=Dis2_Merged,ptPDF=FALSE, estimPDF=FALSE, estimOutfile=FALSE) 
# 
# #Instead of percolation network, representing zeros as the lowest values
# #may be informative:
# zero.thr(dis=Dis2,ptPDF=FALSE)
# # Adjusting sizes and showing modules:
# zero.thr(dis=Dis2,ptPDF=FALSE,cex.label=0.8,cex.vertex=1.2,modules=TRUE)
# 
# #In the previous example, the 'zero.thr' method is unuseful: 
# zero.thr(dis=Dis1,ptPDF=FALSE)
# 
# #In both cases, the 'No Isolation Nodes Allowed' method
# #yields an informative matrix:
# NINA.thr(dis=Dis1)
# NINA.thr(dis=Dis2)
</code></pre>

<hr>
<h2 id='nt.gap.comb'>substitution and indel distance combinations</h2><span id='topic+nt.gap.comb'></span>

<h3>Description</h3>

<p>This function obtains a lineal combination from two original matrices. The weight of each matrix in the combination must be defined. If it is a range of values, several matrices are computed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nt.gap.comb(DISTnuc = NA, DISTgap = NA, alpha = seq(0, 1, 0.1),
method = "Corrected", saveFile = TRUE, align = NA, silent = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nt.gap.comb_+3A_distnuc">DISTnuc</code></td>
<td>
<p>a matrix containing substitution genetic distances. See &quot;dist.dna&quot; in &quot;ape&quot; package.</p>
</td></tr>
<tr><td><code id="nt.gap.comb_+3A_distgap">DISTgap</code></td>
<td>
<p>a matrix containing indel genetic distances.</p>
</td></tr>
<tr><td><code id="nt.gap.comb_+3A_alpha">alpha</code></td>
<td>
<p>a numeric between 0 and 1, is the weight given to the indel genetic distance matrix in the combination. By definition, the weight of the substitution genetic matrix is the complementary value (i.e., 1-alpha). The value &quot;info&quot; will use the proportion of informative substitutions per informative indel event as weight. It is also possible to define multiple weights to estimate different combinations (See examples to obtain 11 corrected combined matrices using a range of alpha values).</p>
</td></tr>
<tr><td><code id="nt.gap.comb_+3A_method">method</code></td>
<td>
<p>a string defining whether each distance matrix must be divided by its maximum value before the combination (&quot;Corrected&quot;) or not (&quot;Uncorrected&quot;). Consequently, if the &quot;Corrected&quot; method is chosen, both matrices will range between 0 and 1 before to be combined.</p>
</td></tr>
<tr><td><code id="nt.gap.comb_+3A_savefile">saveFile</code></td>
<td>
<p>a logical; if TRUE (default), each output matrix is saved in a different text file.</p>
</td></tr>
<tr><td><code id="nt.gap.comb_+3A_align">align</code></td>
<td>
<p>if alpha=&quot;info&quot; must contain the name of the alignment to be analysed. See &quot;read.dna&quot; in ape package for details about reading alignments.</p>
</td></tr>
<tr><td><code id="nt.gap.comb_+3A_silent">silent</code></td>
<td>
<p>a logical; if FALSE (default), it prints the number of unique sequences found and the name of the output file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If &quot;alpha&quot; is a single value, this function generates a data frame containing the estimated combination of substitution and indel distance matrices. If &quot;alpha&quot; is a vector of values, this function generates a list of data frames.
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCIC">MCIC</a></code>,<code><a href="#topic+BARRIEL">BARRIEL</a></code>,<code><a href="#topic+SIC">SIC</a></code>,<code><a href="#topic+FIFTH">FIFTH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># cat("&gt;Population1_sequence1",
# "TTATAAAATCTA----TAGC",
# "&gt;Population1_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population1_sequence3",
# "TTATAAAAATTA----TAGC",
# "&gt;Population1_sequence4",
# "TAAT----TCTA----TAAC",
# "&gt;Population2_sequence1",
# "TTAT----TCGAGGGGTAGC",
# "&gt;Population2_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population2_sequence3",
# "TTATAAAA--------TAGC",
# "&gt;Population2_sequence4",
# "TTAT----TCGAGGGGTAGC",
# "&gt;Population3_sequence1",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence2",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence3",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence4",
# "TTAT----TCGA----TAGC",
#      file = "ex2.fas", sep = "\n")
# 
#  # Estimating indel distances after reading the alignment from file:
# distGap&lt;-MCIC(input="ex2.fas",saveFile=FALSE)
#  # Estimating substitution distances after reading the alignment from file:
# library(ape)
# align&lt;-read.dna(file="ex2.fas",format="fasta")
# dist.nt&lt;-dist.dna(align,model="raw",pairwise.deletion=TRUE)
# DISTnt&lt;-as.matrix(dist.nt)
#  # Obtaining 11 corrected combined matrices using a range of alpha values:
# nt.gap.comb(DISTgap=distGap, alpha=seq(0,1,0.1), method="Corrected", 
# saveFile=FALSE, DISTnuc=DISTnt)
#  # Obtaining the arithmetic mean of both matrices using both the corrected
#  # and the uncorrected methods.
# nt.gap.comb(DISTgap=distGap, alpha=0.5, method="Uncorrected", saveFile=FALSE,
#  DISTnuc=DISTnt)
#  # Obtaining a range of combinations...
# Range01&lt;-nt.gap.comb(DISTgap=distGap, alpha=seq(0,1,0.1), method="Uncorrected",
#  saveFile=FALSE, DISTnuc=DISTnt)
#  # ...and displaying the arithmetic mean (alpha=0.5 is the element number 6
#  # in the resulting data frame):
# Range01[[6]]
</code></pre>

<hr>
<h2 id='perc.thr'>Percolation threshold network</h2><span id='topic+perc.thr'></span>

<h3>Description</h3>

<p>This function computes the percolation network following Rozenfeld et al. (2008), as described in Muñoz-Pajares (2013).</p>


<h3>Usage</h3>

<pre><code class='language-R'>perc.thr(dis, range = seq(0, 1, 0.01), ptPDF = TRUE,
ptPDFname = "PercolatedNetwork.pdf", estimPDF = TRUE,
estimPDFname = "PercThr Estimation.pdf", estimOutfile = TRUE,
estimOutName = "PercThresholdEstimation.txt", cex.label = 1,
cex.vertex = 1, appendOutfile = TRUE, plotALL = FALSE,
bgcol = "white", label.col = "black", label = colnames(dis),
modules = FALSE, moduleCol = NA, modFileName = "Modules_summary.txt",
ncs = 4, na.rm.row.col = FALSE, merge = FALSE,save.distance = FALSE,
save.distance.name = "DistanceMatrix_Perc.thr.txt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perc.thr_+3A_dis">dis</code></td>
<td>
<p>the distance matrix to be represented</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_range">range</code></td>
<td>
<p>a numeric vector between 0 and 1, is the range of thresholds (referred to the maximum distance in a matrix) to be screened (by default, 101 values from 0 to 1).</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_ptpdf">ptPDF</code></td>
<td>
<p>a logical, must the percolated network be saved as a pdf file?</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_ptpdfname">ptPDFname</code></td>
<td>
<p>if ptPDF=TRUE, the name of the pdf file containing the percolation network to be saved (&quot;PercolatedNetwork.pdf&quot;, by default)</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_estimpdf">estimPDF</code></td>
<td>
<p>a logical, must the percolation threshold estimation be saved as a pdf file?</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_estimpdfname">estimPDFname</code></td>
<td>
<p>if estimPDF=TRUE (default), defines the name of the pdf file containing the percolation threshold estimation (&quot;PercThr Estimation.pdf&quot; by default).</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_estimoutfile">estimOutfile</code></td>
<td>
<p>a logical, must the value of &lt;s&gt; for each threshold be saved as a text file?</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_estimoutname">estimOutName</code></td>
<td>
<p>if estimOutfile=TRUE (default), contains the name of the text file containing the percolation threshold estimation (&quot;PercThr Estimation.txt&quot; by default).</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_cex.label">cex.label</code></td>
<td>
<p>a numeric; the size of the node labels.</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_cex.vertex">cex.vertex</code></td>
<td>
<p>a numeric; the size of the nodes.</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_appendoutfile">appendOutfile</code></td>
<td>
<p>a logical, if estimOutfile=TRUE, it defines whether results must be appended to an existing file with the same name (TRUE) or the existing file must be replaced (FALSE).</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_plotall">plotALL</code></td>
<td>
<p>a logical, must all the networks calculated during the percolation threshold estimation (defined by &quot;range&quot; option) be saved as different pdf files? (FALSE, by default). If TRUE, for each value defined in threshold, one file is generated.</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_bgcol">bgcol</code></td>
<td>
<p>the colour of the background for each node in the network. Can be equal for all nodes (if only one colour is defined), customized (if several colours are defined), or can represent different modules (see &quot;modules&quot; option).</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_label.col">label.col</code></td>
<td>
<p>the colour of labels for each node in the network. Can be equal for all nodes (if only one colour is defined) or customized (if several colours are defined).</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_label">label</code></td>
<td>
<p>a vector of strings, labels for each node. By default are the column names of the distance matrix (dis). (See &quot;substr&quot; function in base package to automatically reduce name lengths).</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_modules">modules</code></td>
<td>
<p>a logical, must nodes belonging to different modules be represented as different colours?</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_modulecol">moduleCol</code></td>
<td>
<p>(if modules=TRUE) a vector of strings defining the colour of nodes belonging to different modules in the network. If 'NA' (or there are less colours than haplotypes), colours are automatically selected.</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_modfilename">modFileName</code></td>
<td>
<p>(if modules=TRUE) the name of the file to be generated containing a summary of module results (sequence name, module, and colour in network)</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_ncs">ncs</code></td>
<td>
<p>a numeric; number of decimal places to display threshold in plot title.</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_na.rm.row.col">na.rm.row.col</code></td>
<td>
<p>a logical; if TRUE, missing values are removed before the computation proceeds.</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_merge">merge</code></td>
<td>
<p>a logical, if TRUE, merges rows (and columns) showing distance values equal to zero.</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_save.distance">save.distance</code></td>
<td>
<p>a logical; if TRUE, the new distance matrix will be saved in a file.</p>
</td></tr>
<tr><td><code id="perc.thr_+3A_save.distance.name">save.distance.name</code></td>
<td>
<p>a string; if save.distance is set to TRUE, it defines the name of the file to be saved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, percolation threshold is estimated with an accuracy of 0.01, but it may be increased by setting the decimal places in threshold function (e.g., range=seq(0,1,0.0001)). However, it may strongly increase computation times (in this example, it is required to estimate 100,001 instead of 101 networks). It is also possible to increase accuracy with a low increase in computation time by repeating the process and increasing decimal places only in a range close to a previously estimated percolation threshold. For example, if the estimated percolation threshold is 0.48, it is possible to define a second round using range=seq(0.47,0.49,0.0001), which provide an accurary of 0.0001 estimating only 201 networks.
</p>
<p>'perc.thr' estimates a threshold to represent a distance matrix as a network. To estimate this threshold, the algorithm represents as a link all distances lower than a range of thresholds (by default, select 101 values from 0 to 1), defined as the percentage of the maximum distance in the input matrix. For each threshold a network is built and the number of clusters (that is, the number of isolated groups of nodes) in the network is also estimated. Finally, the algorithm selects the lower threshold connecting a higher number of nodes. Note that the resulting network may show isolated nodes if it is necessary to represent a large number of links to connect a low number of nodes.
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>References</h3>

<p>Rozenfeld AF, Arnaud-Haond S, Hernandez-Garcia E, Eguiluz VM, Serrao EA, Duarte CM. (2008). Network analysis identifies weak and strong links in a metapopulation system. Proceedings of the National Academy of Sciences,105, 18824-18829.
</p>
<p>Muñoz-Pajares, A.J. (2013). SIDIER: substitution and indel distances to infer evolutionary relationships. Methods in Ecology and Evolution, 4, 1195-1200</p>


<h3>See Also</h3>

<p><code><a href="#topic+single.network">single.network</a></code>, <code><a href="#topic+NINA.thr">NINA.thr</a></code>, <code><a href="#topic+zero.thr">zero.thr</a></code>, <code><a href="#topic+mergeNodes">mergeNodes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># cat("&gt;Population1_sequence1",
# "TTATAAAATCTA----TAGC",
# "&gt;Population1_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population1_sequence3",
# "TTATAAAAATTA----TAGC",
# "&gt;Population1_sequence4",
# "TAAT----TCTA----TAAC",
# "&gt;Population2_sequence1",
# "TTAT----TCGAGGGGTAGC",
# "&gt;Population2_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population2_sequence3",
# "TTATAAAA--------TAGC",
# "&gt;Population2_sequence4",
# "TTAT----TCGAGGGGTAGC",
# "&gt;Population3_sequence1",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence2",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence3",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence4",
# "TTAT----TCGA----TAGC",
#      file = "ex2.fas", sep = "\n")
# 
#  # Estimating indel distances after reading the alignment from file:
# distGap&lt;-MCIC(input="ex2.fas",saveFile=FALSE)
#  # Estimating substitution distances after reading the alignment from file:
# library(ape)
# align&lt;-read.dna(file="ex2.fas",format="fasta")
# dist.nt &lt;-dist.dna(align,model="raw",pairwise.deletion=TRUE)
# DISTnt&lt;-as.matrix(dist.nt)
# 
# 
#  # Obtaining the arithmetic mean of both matrices using the corrected method:
# CombinedDistance&lt;-nt.gap.comb(DISTgap=distGap, alpha=0.5, method="Corrected",
# saveFile=FALSE, DISTnuc=DISTnt)
#  # Estimating the percolation threshold of the combined distance, modifying
#  # labels:
# perc.thr(dis=CombinedDistance,label=paste(substr(row.names(
# CombinedDistance),11,11),substr(row.names(CombinedDistance),21,21),sep="-"))
# 
#  # The same network showing different modules as different colours
#  # (randomly selected):
# perc.thr(dis=as.data.frame(CombinedDistance),label=paste(substr(row.names(
# as.data.frame(CombinedDistance)),11,11),substr(row.names(as.data.frame(
# CombinedDistance)),21,21),sep="-"), modules=TRUE)
# 
#  # The same network showing different modules as different colours
#  # (defined by user):
# perc.thr(dis=as.data.frame(CombinedDistance),label=paste(substr(row.names(
# as.data.frame(CombinedDistance)),11,11),substr(row.names(as.data.frame(
# CombinedDistance)),21,21),sep="-"), modules=TRUE,moduleCol=c("pink",
# "lightblue","lightgreen"))
#  

</code></pre>

<hr>
<h2 id='pie.network'>Population network depiction including haplotype frequencies</h2><span id='topic+pie.network'></span>

<h3>Description</h3>

<p>This function represents an alignment as a population network and displays nodes as pie charts where haplotype frequencies are proportional to the area depicted in different colours.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pie.network(align = NA, indel.method = "MCIC", substitution.model = "raw",
pairwise.deletion = TRUE, network.method = "percolation",
range = seq(0, 1, 0.01), addExtremes = FALSE, alpha = "info",
combination.method = "Corrected", na.rm.row.col = FALSE,
NameIniPopulations = NA, NameEndPopulations = NA, NameIniHaplotypes = NA,
NameEndHaplotypes = NA, save.distance = FALSE,
save.distance.name = "DistanceMatrix_threshold.txt",
pop.distance.matrix = NULL, Haplos = NULL, HaplosPerPop = NULL,
col.pie = NA, label.col = "black", label = NA, label.sub.str = NA,
cex.label = 1, cex.pie = 1, main = "", HaplosNames = NA,
offset.label = 1.5, pie.size = "equal", coord = NULL, get.coord = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pie.network_+3A_align">align</code></td>
<td>
<p>a 'DNAbin' object; the alignment to be analysed. See &quot;read.dna&quot; in the ape package for details about reading alignments. Other inputs are available: Use a distance matrix instead an alignment using the 'align' option or provide a list of haplotypes and frequencies per population using 'Haplos' and 'HapPerPop' options
</p>
</td></tr>
<tr><td><code id="pie.network_+3A_indel.method">indel.method</code></td>
<td>
<p>a sting; the method to define indel events in your alignments. The available methods are:
</p>
<p>-&quot;MCIC&quot;: (Default) Estimates indel events following the rationale of the Modified Complex Indel Coding (Muller, 2006).
</p>
<p>-&quot;SIC&quot;: Estimates indel events following the rationale of Simmons and Ochoterrena (2000).
</p>
<p>-&quot;FIFTH&quot;: Estimates indel events following the rationale of the fifth state: each gap within the alignment is treated
as an independent mutation event.
</p>
<p>-&quot;BARRIEL&quot;: Estimates indel events following the rationale of Barriel (1994): singleton gaps are not taken into account.
</p>
</td></tr>
<tr><td><code id="pie.network_+3A_substitution.model">substitution.model</code></td>
<td>
<p>a string; the substitution evolutionary model to estimate the distance matrix. By default is set to &quot;raw&quot; and
estimates the pairwise proportion of variant sites. See the evolutionary models available using ?dist.dna from the ape package.
</p>
</td></tr>
<tr><td><code id="pie.network_+3A_pairwise.deletion">pairwise.deletion</code></td>
<td>
<p>a logical; if TRUE (default) substitutions found in regions being a gap in other sequences will account
for the distance matrix. If FALSE, sites being a gap in at least one sequence will be removed before distance estimation.
</p>
</td></tr>
<tr><td><code id="pie.network_+3A_network.method">network.method</code></td>
<td>
<p>a string; the method to build the network. The available methods are:
</p>
<p>-&quot;percolation&quot;: computes a network using the percolation network method following Rozenfeld et al. (2008).
See ?perc.thr for details
</p>
<p>-&quot;NINA&quot;: computes a network using the No Isolation Nodes Allowed method. See ?NINA.thr for details.
</p>
<p>-&quot;zero&quot;: computes a network connecting all nodes showing distances equal to zero. See ?zero.thr for details.
</p>
</td></tr>
<tr><td><code id="pie.network_+3A_range">range</code></td>
<td>
<p>a numeric vector between 0 and 1, is the range of thresholds (referred to the maximum distance in the input matrix) to be screened (by default, 101 values from 0 to 1). This option is used for &quot;percolation&quot; and &quot;NINA&quot; network methods and ignored for &quot;zero&quot; method.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_addextremes">addExtremes</code></td>
<td>
<p>a logical; if TRUE, additional nucleotide sites are included in both extremes of the alignment. This will allow estimating distances for alignments showing gaps in terminal positions. This option is used for &quot;SIC&quot;, &quot;FIFTH&quot; and &quot;BARRIEL&quot; indel methods and ignored for &quot;MCIC&quot; method.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_alpha">alpha</code></td>
<td>
<p>a numeric between 0 and 1, is the weight given to the indel genetic distance matrix in the combination. By definition, the weight of the substitution genetic matrix is the complementary value (i.e., 1-alpha). The value &quot;info&quot; will use the proportion of informative substitutions per informative indel event as weight. It is also possible to define multiple weights to estimate different combinations.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_combination.method">combination.method</code></td>
<td>
<p>a string defining whether each distance matrix must be divided by its maximum value before the combination (&quot;Corrected&quot;) or not (&quot;Uncorrected&quot;). Consequently, if the &quot;Corrected&quot; method is chosen (default option), both matrices are corrected to range between 0 and 1 before being combined.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_na.rm.row.col">na.rm.row.col</code></td>
<td>
<p>a logical; if TRUE, removes rows and columns showing missing values within the distance matrix.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_nameinipopulations">NameIniPopulations</code></td>
<td>
<p>a numeric; Position of the initial character of population names within sequence names. If not provided, it is set to 1. It is used only if NameEndPopulations is also defined.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_nameendpopulations">NameEndPopulations</code></td>
<td>
<p>a numeric; Position of the last character of population names within sequence names. If not provided, it is set to the first &quot;_&quot; character in the sequences name. It is used only if NameIniPopulations is also defined.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_nameinihaplotypes">NameIniHaplotypes</code></td>
<td>
<p>a numeric; Position of the initial character of haplotype names within sequence names. If not provided, haplotype names are given and the value is set accordingly. It is used only if NameEndHaplotypes is also defined.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_nameendhaplotypes">NameEndHaplotypes</code></td>
<td>
<p>a numeric; Position of the last character of haplotype names within sequence names. If not provided, haplotype names are given and the value is set accordingly. It is used only if NameIniHaplotypes is also defined.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_save.distance">save.distance</code></td>
<td>
<p>a logical; if TRUE, the distance matrix used to build the network will be saved as a file.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_save.distance.name">save.distance.name</code></td>
<td>
<p>a string; if save.distance=TRUE, the name of the file to be saved.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_pop.distance.matrix">pop.distance.matrix</code></td>
<td>
<p>a matrix containing the population distances. Alternatively, it can be estimated from a given sequence alignment using 'align'. Alternatively, you can provide a list of haplotypes and frequencies using 'Haplos' and 'HapPerPop'</p>
</td></tr>
<tr><td><code id="pie.network_+3A_haplos">Haplos</code></td>
<td>
<p>a two columns matrix containing sequence names and haplotype names as reported by  <code><a href="#topic+FindHaplo">FindHaplo</a></code>. Alternatively, you can define an input alignment using 'align' or a distance matrix using 'pop.distance.matrix'.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_haplosperpop">HaplosPerPop</code></td>
<td>
<p>a matrix containing the number of haplotypes found per population, as reported by <code><a href="#topic+HapPerPop">HapPerPop</a></code> (Weighted matrix).Alternatively, you can define an input alignment using 'align' or a distance matrix using 'pop.distance.matrix'.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_col.pie">col.pie</code></td>
<td>
<p>a vector of strings; the colour to represent each haplotype. If 'NA' (or there are less colours than haplotyes), colours are automatically selected.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_label.col">label.col</code></td>
<td>
<p>a vector of strings; the colour of labels for each node in the network. Can be equal for all nodes (if only one colour is defined) or customized (if several colours are defined).</p>
</td></tr>
<tr><td><code id="pie.network_+3A_label">label</code></td>
<td>
<p>a vector of strings; labels for each node. By default are the sequence names. (See &quot;substr&quot; function in base package to automatically reduce name lengths)</p>
</td></tr>
<tr><td><code id="pie.network_+3A_label.sub.str">label.sub.str</code></td>
<td>
<p>a vector of two numerics; if node labels are a substring of sequence names, these two numbers represent the initial and final character of the string to be represented. See Example for details.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_cex.label">cex.label</code></td>
<td>
<p>a numeric; the size of the node labels.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_cex.pie">cex.pie</code></td>
<td>
<p>a numeric; the size of the nodes (pie charts).</p>
</td></tr>
<tr><td><code id="pie.network_+3A_main">main</code></td>
<td>
<p>a sting; if set to &quot;summary&quot; the main options selected for representing the network are displayed in title. The default value (&quot;&quot;) shows no title for the network.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_haplosnames">HaplosNames</code></td>
<td>
<p>a sting; the name of the haplotypes (if different from default: H1...Hn)</p>
</td></tr>
<tr><td><code id="pie.network_+3A_offset.label">offset.label</code></td>
<td>
<p>a numeric; the separation between node and label.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_pie.size">pie.size</code></td>
<td>
<p>a string to define the ratio of pies representing populations. Possible values are: &quot;equal&quot; (default) to give the same size to all pies; &quot;radius&quot; to make the pie radius proportional to the population sample size; &quot;area&quot; to make the pie area proportional to the population sample size; or &quot;points&quot; to display simple vertices instead of pies representing haplotypes per population.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_coord">coord</code></td>
<td>
<p>a two columns matrix containing coordinates where each haplotypes must be represented.</p>
</td></tr>
<tr><td><code id="pie.network_+3A_get.coord">get.coord</code></td>
<td>
<p>a logical, TRUE to obtain coordinates of nodes within the network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to use equal length names with population and individual names separated by '_' (e.g., Pop01_id001...Pop23_id107) and set population (both, NameIniPopulations and NameEndPopulations,) and haplotype (both, NameIniHaplotypes and NameIniHaplotypes) identifiers accordingly. If any of these identifiers is not provided, the algorithm will behave as follows:
</p>
<p>-If only haplotype name identifiers are defined, population names are assumed between character 1 and the first symbol '_' in sequences name.
</p>
<p>-If only population name identifiers are defined, haplotype are automatically found and named using the 'HapPerPop' function.
</p>
<p>-If both are not defined, population names are assumed between character 1 and the first symbol '_' in sequences name and haplotypes are automatically found and named using the 'HapPerPop' function.
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>References</h3>

<p>Barriel, V., 1994. Molecular phylogenies and how to code insertion/
deletion events. Life Sci. 317, 693-701, cited and described by
Simmons, M.P., Müller, K. &amp; Norton, A.P. (2007)
The relative performance of indel-coding methods in simulations.
Molecular Phylogenetics and Evolution, 44, 724–740.
</p>
<p>Muller K. (2006). Incorporating information from length-mutational events
into phylogenetic analysis. Molecular Phylogenetics and Evolution, 38, 667-676.
</p>
<p>Paradis, E., Claude, J. &amp; Strimmer, K. (2004). APE: analyses of phylogenetics
and evolution in R language. Bioinformatics, 20, 289-290.
</p>
<p>Rozenfeld AF, Arnaud-Haond S, Hernandez-Garcia E, Eguiluz VM, Serrao EA, Duarte CM. (2008). Network analysis identifies weak and strong links in a metapopulation system. Proceedings of the National Academy of Sciences,105, 18824-18829.
</p>
<p>Simmons, M.P. &amp; Ochoterena, H. (2000). Gaps as Characters in Sequence-Based
Phylogenetic Analyses. Systematic Biology, 49, 369-381.
</p>


<h3>See Also</h3>

<p>mutation.network, double.plot</p>


<h3>Examples</h3>

<pre><code class='language-R'># cat("&gt;Population1_sequence1",
# "TTATAAAATCTA----TAGC",
# "&gt;Population1_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population1_sequence3",
# "TTATAAAAATTA----TAGC",
# "&gt;Population1_sequence4",
# "TAAT----TCTA----TAAC",
# "&gt;Population2_sequence1",
# "TTAT----TCGA----TAGC",
# "&gt;Population2_sequence2",
# "TTAT----TCGA----TAGC",
# "&gt;Population2_sequence3",
# "TTAT----TCGA----TAGC",
# "&gt;Population2_sequence4",
# "TTAT----TCGA----TAGC",
# "&gt;Population3_sequence1",
# "TTAT----TCGAGGGGTAGC",
# "&gt;Population3_sequence2",
# "TAAT----TCTA----TAAC",
# "&gt;Population3_sequence3",
# "TTATAAAA--------TAGC",
# "&gt;Population3_sequence4",
# "TTAT----TCGAGGGGTAGC",
#      file = "ex2.fas", sep = "\n")
# library(ape)
# example&lt;-read.dna(file="ex2.fas",format="fasta")
# 
# # The input format is recognized, and names identifiers can be omitted:
# 	 pie.network(align=example)
# 
# # Is identical to:
# 	 pie.network(align=example, NameIniPopulations=1,NameEndPopulations=11)
# 
# # Using different colours:
# 	 pie.network(align=example, NameIniPopulations=1,NameEndPopulations=11,
# 	 col.pie=c("red","blue","pink","orange","black","grey"))
# 
# # col.pie is omitted if less colours than haplotypes are defined:
# 	 pie.network(align=example, NameIniPopulations=1,NameEndPopulations=11,
# 	 col.pie=c("red","blue","pink"))
# 
# # and also if more colours than haplotypes are defined:
# 	  pie.network(align=example, NameIniPopulations=1,NameEndPopulations=11,
# 	 col.pie=c("red","blue","green","purple","pink","orange","gray"))
# 
</code></pre>

<hr>
<h2 id='pop.dist'>Distances among populations
</h2><span id='topic+pop.dist'></span>

<h3>Description</h3>

<p>This function computes the population pairwise distance matrix based on the frequency of haplotypes per population and the haplotypes pairwise distance matrix. It is mandatory to define haplotype and population names in the input file. See example for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop.dist(DistFile = NA, distances = NA, HaploFile = NA, Haplos = NA,
 outType = "O", logfile = TRUE, saveFile = TRUE, NameIniPopulations
 = NA, NameEndPopulations = NA, NameIniHaplotypes = NA,
 NameEndHaplotypes = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.dist_+3A_distfile">DistFile</code></td>
<td>
<p>the name of the file containing the distance matrix among haplotypes to be analysed. Alternatively, you can define a distance matrix stored in memory using 'distances'.
</p>
</td></tr>
<tr><td><code id="pop.dist_+3A_distances">distances</code></td>
<td>
<p>the distance matrix among haplotypes (stored in memory) to be analysed. Alternatively, you can define the name of a file containing the distance matrix using 'DistFile'.
</p>
</td></tr>
<tr><td><code id="pop.dist_+3A_haplofile">HaploFile</code></td>
<td>
<p>the name of the file containing the matrix with the number of haplotypes found per population (see 'HapPerPop' to obtain this matrix). Alternatively, you can define a matrix stored in memory using 'Haplos'.
</p>
</td></tr>
<tr><td><code id="pop.dist_+3A_haplos">Haplos</code></td>
<td>
<p>the name of the matrix (stored in memory) containing the number of haplotypes found per population (see 'HapPerPop' to obtain this matrix). Alternatively, you can define the name of a file containing the matrix using 'HaplosFile'.
</p>
</td></tr>
<tr><td><code id="pop.dist_+3A_outtype">outType</code></td>
<td>
<p>a string; the format of output matrix. &quot;L&quot; for lower diagonal hemi-matrix; &quot;7&quot; for upper diagonal hemi-matrix; &quot;O&quot; for both hemi-matrices (default).
</p>
</td></tr>
<tr><td><code id="pop.dist_+3A_logfile">logfile</code></td>
<td>
<p>a logical; if TRUE (default), it saves a file containing the names of the matrices used for computation (inputDist and HaploFile).
</p>
</td></tr>
<tr><td><code id="pop.dist_+3A_savefile">saveFile</code></td>
<td>
<p>a logical; if TRUE (default), function output is saved as a text file.
</p>
</td></tr>
<tr><td><code id="pop.dist_+3A_nameinipopulations">NameIniPopulations</code></td>
<td>
<p>a numeric indicating the position of the initial character of population names within the individual name in the matrix containing the number of haplotypes found per population (see example for details).
</p>
</td></tr>
<tr><td><code id="pop.dist_+3A_nameendpopulations">NameEndPopulations</code></td>
<td>
<p>a numeric indicating the position of the last character of population names within the individual name in the matrix containing the number of haplotypes found per population (see example for details). If NA (default), NameIniPopulations and NameEndPopulations are set to use the 'Haplos' (or HaploFile) matrix row names as population names.
</p>
</td></tr>
<tr><td><code id="pop.dist_+3A_nameinihaplotypes">NameIniHaplotypes</code></td>
<td>
<p>a numeric indicating the position of the initial character of haplotype names within the individual name in the distance matrix (see example for details).
</p>
</td></tr>
<tr><td><code id="pop.dist_+3A_nameendhaplotypes">NameEndHaplotypes</code></td>
<td>
<p>a numeric indicating the position of the last character of haplotype names within the individual name in the distance matrix (see example for details). If NA (default), NameIniHaplotypes and NameEndHaplotypes are set to use the 'distances' (or DistFile) matrix row names as haplotype names.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each element in the population distance matrix is calculated as the arithmetic mean of the distances among all the sequences sampled in the two compared populations, as follows:
</p>
<p style="text-align: center;"><code class="reqn">dist(i,j) = \frac{\sum_{k=1}^{m}{\sum_{l=1}^{n}{dist(H_{ki},H_{lj})}}}{m*n}</code>
</p>

<p>where <em>dist(i,j)</em> represents the distance between populations <em>i</em> and <em>j</em>, <em>m</em> and <em>n</em> are the number of sequences in populations <em>i</em> and <em>j</em>, respectively, and <em>dist(H_ki,H_lj)</em> is the distance between the <em>k-th</em> sequence found in population <em>i</em> and the <em>l-th</em> sequence found in population <em>j</em>. 
</p>


<h3>Value</h3>

<p>A matrix containing the genetic distances among populations, based on the haplotype distances and their frequencies per populations.
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares
</p>


<h3>Examples</h3>

<pre><code class='language-R'># cat(" H1 H2 H3 H4 H5",
# "Population1 1 2 1 0 0",
# "Population2 0 0 0 4 1",
# "Population3 0 1 0 0 3",
#      file = "4_Example3_HapPerPop_Weighted.txt", sep = "\n")
# 
# 
# cat("H1 H2 H3 H4 H5",
# "H1 0 1 2 3 1",
# "H2 1 0 3 4 2",
# "H3 2 3 0 1 1",
# "H4 3 4 1 0 2",
# "H5 1 2 1 2 0",
#      file = "4_Example3_IndelDistanceMatrixMullerMod.txt", sep = "\n")
#      example3_2 &lt;- read.table("4_Example3_IndelDistanceMatrixMullerMod.txt"
# ,header=TRUE)
# 
# # Checking row names to estimate NameIniHaplotypes,NameEndHaplotypes:
#  row.names(read.table(file="4_Example3_IndelDistanceMatrixMullerMod.txt"))
# ## [1] "H1" "H2" "H3" "H4" "H5" NameIniHaplotypes=1. NameEndHaplotypes=2
# # Checking row names to estimate NameIniPopulations, and NameEndPopulations
#  row.names(read.table(file="4_Example3_HapPerPop_Weighted.txt"))
# ## [1] "Population1" "Population2" "Population3"
# ## NameIniPopulations=1 NameEndPopulations =11
# 
# # Reading files. Distance matrix must contain haplotype names. Abundance
# # matrix must contain both, haplotype and population names:
# 
# pop.dist (DistFile="4_Example3_IndelDistanceMatrixMullerMod.txt", 
# HaploFile="4_Example3_HapPerPop_Weighted.txt", outType="O",
# NameIniHaplotypes=1,NameEndHaplotypes=2,NameIniPopulations=1,
# NameEndPopulations=11)

</code></pre>

<hr>
<h2 id='rule'>Threshold to discriminate species.
</h2><span id='topic+rule'></span>

<h3>Description</h3>

<p>Threshold to discriminate species showing a ratio interspecific/intraspecific distances higher than a given value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rule(summary=NULL,rule=NULL,stat.intra="max",
stat.inter="min",pch.intra=16, pch.inter=16,
pch.out=21,col.intra="gray",col.inter="black",
col.out="black",label=F)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rule_+3A_summary">summary</code></td>
<td>

<p>a list produced by <code><a href="#topic+barcode.summary">barcode.summary</a></code>. From this list, the maximum intraspecific and the minimu interspecific distances per species are represented. To use any other intra- and interspecific distance, use the &quot;inter&quot; and &quot;intra&quot; options.
</p>
</td></tr>
<tr><td><code id="rule_+3A_rule">rule</code></td>
<td>

<p>a numeric. Only species showing interspecific distances higher than 'rule' times the intraspecific distances will be considered for threshold estimation.
</p>
</td></tr>
<tr><td><code id="rule_+3A_stat.intra">stat.intra</code></td>
<td>
<p>a string, the inter-specific statistic used to estimate the quotient interspecific/intraspecific. Accepted values are &quot;max&quot;, &quot;min&quot;, &quot;median&quot;, and &quot;mean&quot;
</p>
</td></tr>
<tr><td><code id="rule_+3A_stat.inter">stat.inter</code></td>
<td>
<p>a string, the inter-specific statistic used to estimate the quotient interspecific/intraspecific. Accepted values are &quot;max&quot;, &quot;min&quot;, &quot;median&quot;, and &quot;mean&quot;.
</p>
</td></tr>
<tr><td><code id="rule_+3A_pch.intra">pch.intra</code></td>
<td>
<p>Either an integer or single character defining the symbol to be used for intraspecific distances. Only species showing a ratio interspecific/intraspecific higher than the value defined by 'rule' are affected by 'pch.intra'.
</p>
</td></tr>
<tr><td><code id="rule_+3A_pch.inter">pch.inter</code></td>
<td>
<p>Either an integer or single character defining the symbol to be used for interspecific distances Only species showing a ratio interspecific/intraspecific higher than the value defined by 'rule' are affected by 'pch.inter'.
</p>
</td></tr>
<tr><td><code id="rule_+3A_pch.out">pch.out</code></td>
<td>
<p>Either an integer or single character defining the symbol to be used for species showing a ratio interspecific/intraspecific lower than the value defined by 'rule'.
</p>
</td></tr>
<tr><td><code id="rule_+3A_col.intra">col.intra</code></td>
<td>
<p>Either an integer or string defining the colour for intraspecific distances showing a ratio interspecific/intraspecific higher than the value defined by 'rule'.
</p>
</td></tr>
<tr><td><code id="rule_+3A_col.inter">col.inter</code></td>
<td>
<p>Either an integer or string defining the colour for interspecific distances showing a ratio interspecific/intraspecific higher than the value defined by 'rule'.
</p>
</td></tr>
<tr><td><code id="rule_+3A_col.out">col.out</code></td>
<td>
<p>Either an integer or string defining the colour forspecies showing a ratio interspecific/intraspecific lower than the value defined by 'rule'.
</p>
</td></tr>
<tr><td><code id="rule_+3A_label">label</code></td>
<td>
<p>a string to set node labels on those species showing a ratio interspecific/intraspecific higher than the value defined (&quot;rule&quot;), on species showing a ratio interspecific/intraspecific higher than the value defined (&quot;norule&quot;), on all species (&quot;all&quot;). Any other value will produce no lable 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table>
<tr><td><code>Intraspecific</code></td>
<td>
<p>a matrix containing information about the intraspecific distances.
</p>
</td></tr>
<tr><td><code>Interspecific</code></td>
<td>
<p>a matrix containing information about the interspecific distances.
</p>
</td></tr>
</table>
<p>In both cases, the information provided is the minimum, maximum, median, mean, first and third quartile values.
</p>


<h3>Author(s)</h3>

<p>A.J. Muñoz-Pajares
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.dist&lt;-matrix(c(0,0.3,0.24,0.45,0.23,0.01,0.11,0.34,0.64,0.34,
0.3,0,0.32,0.75,0.65,0.53,0.012,0.52,0.15,0.52,0.24,0.32,
0,0.92,0.36,0.62,0.85,0.008,0.82,0.65,0.45,0.75,0.92,0,
0.22,0.56,0.74,0.46,0.005,0.73,0.23,0.65,0.36,0.22,0,
0.34,0.24,0.42,0.35,0.009,0.01,0.53,0.62,0.56,0.34,0,
0.23,0.73,0.23,0.63,0.11,0.012,0.85,0.74,0.24,0.23,0,
0.25,0.63,0.54,0.34,0.52,0.008,0.46,0.42,0.73,0.25,0,
0.32,0.41,0.64,0.15,0.82,0.005,0.35,0.23,0.63,0.32,0,
0.23,0.34,0.52,0.65,0.73,0.009,0.63,0.54,0.41,0.23,0),
ncol=10,dimnames=list(paste("sp",rep(1:5,2),sep=""),
paste("sp",rep(1:5,2),sep="")))

# rule(barcode.summary(my.dist),rule=10)
</code></pre>

<hr>
<h2 id='SIC'>Indel distances following the Simple Index Coding method
</h2><span id='topic+SIC'></span>

<h3>Description</h3>

<p>This function codifies gapped positions in a sequence alignment following the rationale of the method described by Simmons and Ochoterrena (2000). Based on the yielded indel coding matrix, this function also computes a pairwise indel distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SIC(inputFile = NA, align = NA, saveFile = TRUE,
outnameDist=paste(inputFile,"IndelDistanceSIC.txt",
sep = "_"), outnameCode = paste(inputFile,
"SIC_coding.txt", sep = "_"), addExtremes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SIC_+3A_inputfile">inputFile</code></td>
<td>

<p>the name of the fasta file to be analysed. Alternatively you can provide the name of a &quot;DNAbin&quot; class alignment stored in memory using the &quot;align&quot; option.
</p>
</td></tr>
<tr><td><code id="SIC_+3A_align">align</code></td>
<td>

<p>the name of the alignment to be analysed. See &quot;read.dna&quot; in ape  package for details about reading alignments. Alternatively you can provide the name of the file containing the alignment in fasta format using the &quot;inputFile&quot; option.
</p>
</td></tr>
<tr><td><code id="SIC_+3A_savefile">saveFile</code></td>
<td>

<p>a logical; if TRUE (default), it produces two output text files containing the distance matrix and the codified indel positions.
</p>
</td></tr>
<tr><td><code id="SIC_+3A_outnamedist">outnameDist</code></td>
<td>

<p>if &quot;saveFile&quot; is set to TRUE (default), contains the name of the distance output file.
</p>
</td></tr>
<tr><td><code id="SIC_+3A_outnamecode">outnameCode</code></td>
<td>

<p>if &quot;saveFile&quot; is set to TRUE (default), contains the name of the indel coding output file.
</p>
</td></tr>
<tr><td><code id="SIC_+3A_addextremes">addExtremes</code></td>
<td>

<p>a logical; if TRUE, additional nucleotide sites are included in both extremes of the alignment. This will allow estimating distances for alignments showing gaps in terminal positions, but see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to estimate this distance matrix using only the unique sequences in the
alignment. Repeated sequences increase computation time but do not provide additional 
information (because they produce duplicated rows and columns in the final distance matrix).
</p>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table>
<tr><td><code>indel coding matrix</code></td>
<td>
<p>Describes the initial and final site of each gap and its presence or absence per sequence.
</p>
</td></tr>
<tr><td><code>distance matrix</code></td>
<td>
<p>Contains genetic distances based on comparing indel presence/absence between sequences.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares
</p>


<h3>References</h3>

<p>Simmons, M.P. &amp; Ochoterena, H. (2000). Gaps as Characters in Sequence-Based
Phylogenetic Analyses. Systematic Biology, 49, 369-381.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BARRIEL">BARRIEL</a></code>, <code><a href="#topic+MCIC">MCIC</a></code>, <code><a href="#topic+FIFTH">FIFTH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# # This will generate an example file in your working directory:
# cat("&gt;Population1_sequence1",
# "A-AGGGTC-CT---G",
# "&gt;Population1_sequence2",
# "TAA---TCGCT---G",
# "&gt;Population1_sequence3",
# "TAAGGGTCGCT---G",
# "&gt;Population1_sequence4",
# "TAA---TCGCT---G",
# "&gt;Population2_sequence1",
# "TTACGGTCG---TTG",
# "&gt;Population2_sequence2",
# "TAA---TCG---TTG",
# "&gt;Population2_sequence3",
# "TAA---TCGCTATTG",
# "&gt;Population2_sequence4",
# "TTACGGTCG---TTG",
# "&gt;Population3_sequence1",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence2",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence3",
# "TTA---TCG---TAG",
# "&gt;Population3_sequence4",
# "TTA---TCG---TAG",
#      file = "ex3.fas", sep = "\n")
# library(ape)
# SIC (align=read.dna("ex3.fas",format="fasta"), saveFile = FALSE)
# 
# # Analysing the same dataset, but using only unique sequences:
# uni&lt;-GetHaplo(inputFile="ex3.fas",saveFile=FALSE)
# SIC (align=uni, saveFile = FALSE)
</code></pre>

<hr>
<h2 id='sidier-package'>SIDIER: Substitution and Indel Distances to Infer Evolutionary Relationships</h2><span id='topic+sidier-package'></span><span id='topic+sidier'></span>

<h3>Description</h3>

<p>Package for evolutionary reconstruction and bar code analyses based on substitutions and insertion-deletion (indels) in a distance-based framework.</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> sidier</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Substitution and Indel Distances to Infer Evolutionary
Relationships</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 4.1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-06-25</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> A. Jesus Muñoz Pajares</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> A.J. Muñoz-Pajares &lt;ajesusmp@ugr.es&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> ape, network, igraph, gridBase, grid, ggmap, ggplot2</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Evolutionary reconstruction based on substitutions and insertion-deletion (indels) analyses in a distance-based framework.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
BARRIEL                 Indel distances following Barriel method
Example_Spatial.plot_Alignment
                        example alignment #1 (fasta format)
FIFTH                   Indel distances following the fifth state
                        rationale
FilterHaplo             Filter haplotypes by occurrence
FindHaplo               Find equal haplotypes
GetHaplo                Get sequences of unique haplotypes
HapPerPop               Returns the number of haplotypes per
                        population.
MCIC                    Modified Complex Indel Coding as distance
                        matrix
NINA.thr                No Isolated Nodes Allowed network
SIC                     Indel distances following the Simple Index
                        Coding method
alignExample            example alignment #1 ('DNAbin' class)
assign.whole.taxo       Get taxonomy described in sequence names
barcode.gap             Barcode gap identification
barcode.quality         Estimates of barcode quality
barcode.summary         Summary of the inter- and intraspecific
                        distances
colour.scheme           internal function for node colour scheme
compare.dist            Threshold to discriminate species comparing
                        intra- and interspecific distance distributions
distance.comb           Distance matrices combination
double.plot             Haplotype and population networks including
                        mutations and haplotype frequencies.
ex_BLAST                example BLAST output
ex_Coords               example coordinates
ex_alignment1           example alignment #1
filter.whole.taxo       Get consensus taxonomy
genbank.sp.names        Species names from genbank accessions
get.majority.taxo       Get majority taxonomy for a sequence
inter.intra.plot        Histogram of the intra- and interspecific
                        distances
mergeNodes              Merges nodes showing distance values equal to
                        zero
mutation.network        Haplotype network depiction including mutations
mutationSummary         Summary of observed mutations
nt.gap.comb             substitution and indel distance combinations
perc.thr                Percolation threshold network
pie.network             Population network depiction including
                        haplotype frequencies
pop.dist                Distances among populations
rule                    Threshold to discriminate species.
sidier-package          SIDIER: Substitution and Indel Distances to
                        Infer Evolutionary Relationships
simplify.network        Network showing modules as nodes
simuEvolution           Simulate sequences evolution
single.network          Plot a network given a threshold
single.network.module   Get modules and network given a threshold
spatial.plot            spatial plot of populations
zero.thr                Zero distance networks
</pre>
<p>Functions can be classified according to the following groups:
</p>
<p>- <em>Barcode analysis</em>:
<code><a href="#topic+barcode.gap">barcode.gap</a></code>; 
<code><a href="#topic+barcode.quality">barcode.quality</a></code>; 
<code><a href="#topic+barcode.summary">barcode.summary</a></code>; 
<code><a href="#topic+compare.dist">compare.dist</a></code>; 
<code><a href="#topic+genbank.sp.names">genbank.sp.names</a></code>; 
<code><a href="#topic+inter.intra.plot">inter.intra.plot</a></code>; 
<code><a href="#topic+rule">rule</a></code>. 
</p>
<p>- <em>Example files</em>:
<code><a href="#topic+alignExample">alignExample</a></code>; 
<code><a href="#topic+Example_Spatial.plot_Alignment">Example_Spatial.plot_Alignment</a></code>; 
<code><a href="#topic+ex_alignment1">ex_alignment1</a></code>; 
<code><a href="#topic+ex_Coords">ex_Coords</a></code>.
</p>
<p>- <em>Indel coding methods</em>:
<code><a href="#topic+BARRIEL">BARRIEL</a></code>; 
<code><a href="#topic+FIFTH">FIFTH</a></code>; 
<code><a href="#topic+MCIC">MCIC</a></code>; 
<code><a href="#topic+SIC">SIC</a></code>.
</p>
<p>- <em>Matrix/network manipulation</em>:
<code><a href="#topic+distance.comb">distance.comb</a></code>; 
<code><a href="#topic+mergeNodes">mergeNodes</a></code>; 
<code><a href="#topic+nt.gap.comb">nt.gap.comb</a></code>; 
<code><a href="#topic+simplify.network">simplify.network</a></code>.
</p>
<p>- <em>Network-from-distance methods</em>:
<code><a href="#topic+NINA.thr">NINA.thr</a></code>; 
<code><a href="#topic+perc.thr">perc.thr</a></code>; 
<code><a href="#topic+zero.thr">zero.thr</a></code>; 
<code><a href="#topic+single.network">single.network</a></code>; 
<code><a href="#topic+single.network.module">single.network.module</a></code>.
</p>
<p>- <em>Network visualization</em>:
<code><a href="#topic+mutation.network">mutation.network</a></code>; 
<code><a href="#topic+pie.network">pie.network</a></code>; 
<code><a href="#topic+double.plot">double.plot</a></code>; 
<code><a href="#topic+colour.scheme">colour.scheme</a></code>; 
<code><a href="#topic+spatial.plot">spatial.plot</a></code>.
</p>
<p>- <em>Sequence/haplotype analysis</em>:
<code><a href="#topic+FilterHaplo">FilterHaplo</a></code>; 
<code><a href="#topic+FindHaplo">FindHaplo</a></code>; 
<code><a href="#topic+GetHaplo">GetHaplo</a></code>; 
<code><a href="#topic+HapPerPop">HapPerPop</a></code>; 
<code><a href="#topic+mutationSummary">mutationSummary</a></code>; 
<code><a href="#topic+pop.dist">pop.dist</a></code>; 
<code><a href="#topic+simuEvolution">simuEvolution</a></code>.
</p>


<h3>Author(s)</h3>

<p>A. Jesus Muñoz Pajares
</p>
<p>Maintainer: A.J. Muñoz-Pajares &lt;ajesusmp@ugr.es&gt;
</p>


<h3>References</h3>

<p>Muñoz-Pajares, A. J. (2013). SIDIER: substitution and indel distances to infer evolutionary relationships. Methods in Ecology and Evolution 4, 1195-1200. doi: 10.1111/2041-210X.12118
</p>

<hr>
<h2 id='simplify.network'>Network showing modules as nodes</h2><span id='topic+simplify.network'></span>

<h3>Description</h3>

<p>This function modifies node coordinates to allow a clearer depiction of complex networks. Nodes are moved along the axis connecting the original position to the module centroid. The magnitude of such movement is defined by user.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify.network(node.names=NA,modules=NA,coordinates=NA,network=NA,
shift = 0.5,max.lwd.edge =2,min.lwd.edge =1,max.vertex.size=4,
min.vertex.size=2,label.size=1/2.5,bgcol="white",main="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify.network_+3A_node.names">node.names</code></td>
<td>
<p>a vector containing the names of nodes</p>
</td></tr>
<tr><td><code id="simplify.network_+3A_modules">modules</code></td>
<td>
<p>a vector containing the module assigned to each node</p>
</td></tr>
<tr><td><code id="simplify.network_+3A_coordinates">coordinates</code></td>
<td>
<p>a two columns matrix containing the X and Y coordinates of each node in the original network</p>
</td></tr>
<tr><td><code id="simplify.network_+3A_network">network</code></td>
<td>
<p>a matrix describing the original network. Can be either a 0/1 matrix or a weighted matrix. Row names must contain node names.</p>
</td></tr>
<tr><td><code id="simplify.network_+3A_shift">shift</code></td>
<td>
<p>a numeric defining the magnitude of node shift,limited between 0 (coinciding with the original location) and 1 (coinciding with the module centroid location).</p>
</td></tr>
<tr><td><code id="simplify.network_+3A_max.lwd.edge">max.lwd.edge</code></td>
<td>
<p>if shift=1,a numeric defining the line width for the maximum number of connections between modules</p>
</td></tr>
<tr><td><code id="simplify.network_+3A_min.lwd.edge">min.lwd.edge</code></td>
<td>
<p>if shift=1,a numeric defining the line width for the minimum number of connections between modules</p>
</td></tr>
<tr><td><code id="simplify.network_+3A_max.vertex.size">max.vertex.size</code></td>
<td>
<p>if shift=1,a numeric defining the size of the node representing the largest module</p>
</td></tr>
<tr><td><code id="simplify.network_+3A_min.vertex.size">min.vertex.size</code></td>
<td>
<p>if shift=1,a numeric defining the size of the node representing the smallest module</p>
</td></tr>
<tr><td><code id="simplify.network_+3A_label.size">label.size</code></td>
<td>
<p>a numeric defining the size of node labels,referred to its particular node size</p>
</td></tr>
<tr><td><code id="simplify.network_+3A_bgcol">bgcol</code></td>
<td>
<p>a vector of strings representing the background colour for each node</p>
</td></tr>
<tr><td><code id="simplify.network_+3A_main">main</code></td>
<td>
<p>a string,the title for the plot (no title by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'shift=1',all nodes belonging to a module are represented as a single node depicted in the module centroid. In that case,node size is proportional to the number of element in this module and edge widths are proportional to the number of connections found between modules.</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>Examples</h3>

<pre><code class='language-R'># 
# inputMatrix&lt;-matrix(c(1,1,1,1.2,2,1,0.8,1,3,2,1.2,1,4,2,2,2.2,
#  5,3,1.8,2,6,3,2.2,2,7,3,1.7,2.1,8,3,2.2,2.2),ncol=4,byrow=TRUE)
# colnames(inputMatrix)&lt;-c("node","module","x","y")
# 
# network&lt;-matrix(c(1,1,0,0,1,1,0,0,1,1,1,0,0,0,0,0,0,
#   1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,
#   1,1,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,
#   0,1,1,1,1),ncol=8)
# colnames(network)&lt;-c(1:8)
# row.names(network)&lt;-c(1:8)
# 
# i1&lt;-0
# simplify.network(node.names=inputMatrix[,1],modules=inputMatrix[,2],
# coordinates=inputMatrix[,3:4],network=network,shift = i1,
# bgcol=c("red","red","blue","blue","green","green","green","green"),
# main=paste("shift=",i1))
# 
# i1&lt;-0.5
# simplify.network(node.names=inputMatrix[,1],modules=inputMatrix[,2],
# coordinates=inputMatrix[,3:4],network=network,shift = i1,
# bgcol=c("red","red","blue","blue","green","green","green","green"),
# main=paste("shift=",i1))
# 
# i1&lt;-1.0
# simplify.network(node.names=inputMatrix[,1],modules=inputMatrix[,2],
# coordinates=inputMatrix[,3:4],network=network,shift = i1,
# bgcol=c("red","red","blue","blue","green","green","green","green"),
# main=paste("shift=",i1))
# 
# network&lt;-as.matrix(as.dist(matrix(sample(c(1,0),10000,replace=TRUE),ncol=100)))
# inputMatrix&lt;-matrix(nrow=100,ncol=4)
# inputMatrix[,1]&lt;-1:100
# inputMatrix[,2]&lt;-c(rep(1,30),rep(2,20),rep(3,20),rep(4,20),rep(5,10))
# inputMatrix[,3]&lt;-c(
# sample(seq(-40,0,0.01),30,rep=TRUE),
# sample(seq(-40,0,0.01),20,rep=TRUE),
# sample(seq(0,40,0.01),20,rep=TRUE),
# sample(seq(0,40,0.01),20,rep=TRUE),
# sample(seq(-20,20,0.01),10,rep=TRUE))
# inputMatrix[,4]&lt;-c(
# sample(seq(0,40,0.01),30,rep=TRUE),
# sample(seq(-40,0,0.01),20,rep=TRUE),
# sample(seq(0,40,0.01),20,rep=TRUE),
# sample(seq(-40,0,0.01),20,rep=TRUE),
# sample(seq(-20,20,0.01),10,rep=TRUE))
# cols&lt;-c("red","green","yellow","blue","turquoise")
# 
# simplify.network(node.names=inputMatrix[,1],network=network,shift=0,
# coordinates=inputMatrix[,3:4],modules=inputMatrix[,2],bgcol=cols[inputMatrix[,2]])
# 
# simplify.network(node.names=inputMatrix[,1],network=network,shift=1,
# coordinates=inputMatrix[,3:4],modules=inputMatrix[,2],bgcol=cols[inputMatrix[,2]])
# 
</code></pre>

<hr>
<h2 id='simuEvolution'>
Simulate sequences evolution
</h2><span id='topic+simuEvolution'></span>

<h3>Description</h3>

<p>This function simulates the evolution of a set of sequences. It is necessary to define evolution topology, substitution rate, indel rate and insertion/deletion rate in a matrix (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuEvolution(input, seqL, iLength, nReplicates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simuEvolution_+3A_input">input</code></td>
<td>

<p>Matrix defining evolution topology and mutation rates.
</p>
</td></tr>
<tr><td><code id="simuEvolution_+3A_seql">seqL</code></td>
<td>

<p>Length of the simulated sequences.
</p>
</td></tr>
<tr><td><code id="simuEvolution_+3A_ilength">iLength</code></td>
<td>

<p>Length of indel mutations.
</p>
</td></tr>
<tr><td><code id="simuEvolution_+3A_nreplicates">nReplicates</code></td>
<td>

<p>Number of independent sequence sets to be simulated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evolution details must be provided in a file consisting in five columns separated by spaces. The first two columns define topology by indicating the ancestor and the derived sequence, respectively. The remaining columns provide rates for substitutions and indels as well as the ratio between insertions and deletions.
The simulation is performed over the complete alignment. To test the effect of alignment method over the simulated sequences it will be necessary to degap the yielded sequences.
</p>


<h3>Value</h3>

<p>For each replicate, two files are generated: one containing the alignment with all the generated sequences and the other containing only tips sequences (i.e., sequences that are not the ancestor of any other sequence).
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Generating matrix defining evolution:
Input&lt;-matrix(c(1,rep(2:8,2),2:16,rep(0.03,15),rep(0.008,15),rep(0.5,15)),ncol=5)
#Simulating 2 replicates of the evolutionary process:
# simuEvolution(input=Input, seqL=1000, iLength=20, nReplicates=2)
</code></pre>

<hr>
<h2 id='single.network'> Plot a network given a threshold
</h2><span id='topic+single.network'></span>

<h3>Description</h3>

<p>This function plots a network connecting nodes showing distances equal or lower than the defined threshold value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single.network(dis, threshold = NA, ptPDF = TRUE, ptPDFname = "Network.pdf",
bgcol = "white", label.col = "black", label = colnames(dis), modules = FALSE,
moduleCol = NA, modFileName = "Modules_summary.txt", na.rm.row.col = FALSE,

cex.vertex = 1, plot = TRUE, get.coord = FALSE, refer2max = TRUE

)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single.network_+3A_dis">dis</code></td>
<td>
<p>the distance matrix to be represented</p>
</td></tr>
<tr><td><code id="single.network_+3A_threshold">threshold</code></td>
<td>
<p>a numeric between 0 and 1, is the value of the maximum distance to be considered as a link. This value is referred to the maximum distance in the input matrix (e.g., a value of 0.32 will represent a link between nodes showing distances equal or lower than 32% of the maximum distance found in the distance matrix).</p>
</td></tr>
<tr><td><code id="single.network_+3A_ptpdf">ptPDF</code></td>
<td>
<p>a logical, must the percolation network be saved as a pdf file?</p>
</td></tr>
<tr><td><code id="single.network_+3A_ptpdfname">ptPDFname</code></td>
<td>
<p>if ptPDF=TRUE, the name of the pdf file containing the percolation network to be saved (&quot;percolationNetwork.pdf&quot;, by default)</p>
</td></tr>
<tr><td><code id="single.network_+3A_bgcol">bgcol</code></td>
<td>
<p>string defining the colour of the background for each node in the network. Can be equal for all nodes (if only one colour is defined), customized (if several colours are defined), or can represent different modules (see modules option).</p>
</td></tr>
<tr><td><code id="single.network_+3A_label.col">label.col</code></td>
<td>
<p>vector of strings defining the colour of labels for each node in the network. Can be equal for all nodes (if only one colour is defined) or customized (if several colours are defined).</p>
</td></tr>
<tr><td><code id="single.network_+3A_label">label</code></td>
<td>
<p>vector of strings, labels for each node. By default are the column names of the distance matrix (dis). (See substr function in base package to automatically reduce name lengths).</p>
</td></tr>
<tr><td><code id="single.network_+3A_modules">modules</code></td>
<td>
<p>a logical, must nodes belonging to different modules be represented as different colours?</p>
</td></tr>
<tr><td><code id="single.network_+3A_modulecol">moduleCol</code></td>
<td>
<p>(if modules=TRUE) vector of strings, defining the colour of nodes belonging to different modules in the network.</p>
</td></tr>
<tr><td><code id="single.network_+3A_modfilename">modFileName</code></td>
<td>
<p>(if modules=TRUE) the name of a generated file containing a summary of module results</p>
</td></tr>
<tr><td><code id="single.network_+3A_na.rm.row.col">na.rm.row.col</code></td>
<td>
<p>a logical; if TRUE, missing values are removed before the computation proceeds.</p>
</td></tr>
<tr><td><code id="single.network_+3A_cex.vertex">cex.vertex</code></td>
<td>
<p>a numeric, the size of vertex</p>
</td></tr>
<tr><td><code id="single.network_+3A_plot">plot</code></td>
<td>
<p>a logical, TRUE to plot the inferred network</p>
</td></tr>
<tr><td><code id="single.network_+3A_get.coord">get.coord</code></td>
<td>
<p>a logical, TRUE to obtain coordinates of nodes within the network</p>
</td></tr>
<tr><td><code id="single.network_+3A_refer2max">refer2max</code></td>
<td>
<p>a logic, &quot;TRUE&quot; to refer the threshold value to the maximum distance in the input matrix (e.g., a value of 0.32 will represent a link between nodes showing distances equal or lower than 32% of the maximum distance found in the distance matrix). &quot;FALSE&quot; to refer the threshold to a specific value (e.g., a value of 0.32 will represent a link between nodes showing distances equal or lower than 0.32, regardless the maximum distance found in the distance matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>See Also</h3>

<p><code><a href="#topic+perc.thr">perc.thr</a></code>, <code><a href="#topic+NINA.thr">NINA.thr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#generating distance matrix:
dis&lt;-matrix(nrow=12,c(0.0000,0.5000,0.1875,0.5000,0.6250,0.5000,0.2500,0.6250,
0.3750,0.3750,0.3750,0.3750,0.5000,0.0000,0.7500,0.0000,0.6250,0.0000,0.8750,
0.6250,0.3750,0.3750,0.3750,0.3750,0.1875,0.7500,0.0000,0.7500,0.8750,0.7500,
0.2500,0.8750,0.6250,0.6250,0.6250,0.6250,0.5000,0.0000,0.7500,0.0000,0.6250,
0.0000,0.8750,0.6250,0.3750,0.3750,0.3750,0.3750,0.6250,0.6250,0.8750,0.6250,
0.0000,0.6250,0.5000,0.0000,0.2500,0.2500,0.2500,0.2500,0.5000,0.0000,0.7500,
0.0000,0.6250,0.0000,0.8750,0.6250,0.3750,0.3750,0.3750,0.3750,0.2500,0.8750,
0.2500,0.8750,0.5000,0.8750,0.0000,0.5000,0.5000,0.5000,0.5000,0.5000,0.6250,
0.6250,0.8750,0.6250,0.0000,0.6250,0.5000,0.0000,0.2500,0.2500,0.2500,0.2500,
0.3750,0.3750,0.6250,0.3750,0.2500,0.3750,0.5000,0.2500,0.0000,0.0000,0.0000,
0.0000,0.3750,0.3750,0.6250,0.3750,0.2500,0.3750,0.5000,0.2500,0.0000,0.0000,
0.0000,0.0000,0.3750,0.3750,0.6250,0.3750,0.2500,0.3750,0.5000,0.2500,0.0000,
0.0000,0.0000,0.0000,0.3750,0.3750,0.6250,0.3750,0.2500,0.3750,0.5000,0.2500,
0.0000,0.0000,0.0000,0.0000))
row.names(dis)&lt;-c("Population1_sequence1","Population1_sequence2",
"Population1_sequence3","Population1_sequence4","Population2_sequence1",
"Population2_sequence2","Population2_sequence3","Population2_sequence4",
"Population3_sequence1","Population3_sequence2","Population3_sequence3",
"Population3_sequence4")
colnames(dis)&lt;-row.names(dis)

#Representing distances equal or lower than 37% of the maximum distance:
# single.network(dis=dis,threshold=0.37,label=paste(substr(row.names(dis),11,11),
# substr(row.names(dis),21,21),sep="-"))

</code></pre>

<hr>
<h2 id='single.network.module'>Get modules and network given a threshold
</h2><span id='topic+single.network.module'></span>

<h3>Description</h3>

<p>Gets details on modules and connections in the network connecting nodes showing distances equal or lower than the defined threshold value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single.network.module(dis,threshold=NA,refer2max=TRUE,out="module",
save.file=FALSE,modFileName="Modules_summary.txt")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single.network.module_+3A_dis">dis</code></td>
<td>
<p>the distance matrix to be represented</p>
</td></tr>
<tr><td><code id="single.network.module_+3A_threshold">threshold</code></td>
<td>
<p>a numeric between 0 and 1, is the value of the maximum distance to be considered as a link. This value is referred to the maximum distance in the input matrix (e.g., a value of 0.32 will represent a link between nodes showing distances equal or lower than 32% of the maximum distance found in the distance matrix).</p>
</td></tr>
<tr><td><code id="single.network.module_+3A_refer2max">refer2max</code></td>
<td>

<p>a logic, &quot;TRUE&quot; to refer the threshold value to the maximum distance in the input matrix (e.g., a value of 0.32 will represent a link between nodes showing distances equal or lower than 32% of the maximum distance found in the distance matrix). &quot;FALSE&quot; to refer the threshold to a specific value (e.g., a value of 0.32 will represent a link between nodes showing distances equal or lower than 0.32, regardless the maximum distance found in the distance matrix).
</p>
</td></tr>
<tr><td><code id="single.network.module_+3A_out">out</code></td>
<td>
<p>a string, the type of output, &quot;module&quot; to get a matrix with two columns giving each sequence name and the module it belongs to, and &quot;network&quot; to get a square matrix representing connection (1) or lack of connection (0) between sequences in the network.</p>
</td></tr>
<tr><td><code id="single.network.module_+3A_save.file">save.file</code></td>
<td>

<p>a logic, &quot;TRUE&quot; to save the summary of network modules, attributing every individual to a module.
</p>
</td></tr>
<tr><td><code id="single.network.module_+3A_modfilename">modFileName</code></td>
<td>
<p>(if modules=TRUE) the name of a generated file containing a summary of module results</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>See Also</h3>

<p><code><a href="#topic+perc.thr">perc.thr</a></code>, <code><a href="#topic+NINA.thr">NINA.thr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#generating distance matrix:
dis&lt;-matrix(nrow=12,c(0.0000,0.5000,0.1875,0.5000,0.6250,0.5000,0.2500,0.6250,
0.3750,0.3750,0.3750,0.3750,0.5000,0.0000,0.7500,0.0000,0.6250,0.0000,0.8750,
0.6250,0.3750,0.3750,0.3750,0.3750,0.1875,0.7500,0.0000,0.7500,0.8750,0.7500,
0.2500,0.8750,0.6250,0.6250,0.6250,0.6250,0.5000,0.0000,0.7500,0.0000,0.6250,
0.0000,0.8750,0.6250,0.3750,0.3750,0.3750,0.3750,0.6250,0.6250,0.8750,0.6250,
0.0000,0.6250,0.5000,0.0000,0.2500,0.2500,0.2500,0.2500,0.5000,0.0000,0.7500,
0.0000,0.6250,0.0000,0.8750,0.6250,0.3750,0.3750,0.3750,0.3750,0.2500,0.8750,
0.2500,0.8750,0.5000,0.8750,0.0000,0.5000,0.5000,0.5000,0.5000,0.5000,0.6250,
0.6250,0.8750,0.6250,0.0000,0.6250,0.5000,0.0000,0.2500,0.2500,0.2500,0.2500,
0.3750,0.3750,0.6250,0.3750,0.2500,0.3750,0.5000,0.2500,0.0000,0.0000,0.0000,
0.0000,0.3750,0.3750,0.6250,0.3750,0.2500,0.3750,0.5000,0.2500,0.0000,0.0000,
0.0000,0.0000,0.3750,0.3750,0.6250,0.3750,0.2500,0.3750,0.5000,0.2500,0.0000,
0.0000,0.0000,0.0000,0.3750,0.3750,0.6250,0.3750,0.2500,0.3750,0.5000,0.2500,
0.0000,0.0000,0.0000,0.0000))
row.names(dis)&lt;-c("Population1_sequence1","Population1_sequence2",
"Population1_sequence3","Population1_sequence4","Population2_sequence1",
"Population2_sequence2","Population2_sequence3","Population2_sequence4",
"Population3_sequence1","Population3_sequence2","Population3_sequence3",
"Population3_sequence4")
colnames(dis)&lt;-row.names(dis)

# #Representing distances equal or lower than 37% of the maximum distance:
# single.network.module(dis=dis,threshold=0.37)
# single.network.module(dis=dis,threshold=0.37,out="network")
# 
# # Compare these outputs with:
# single.network(dis=dis,threshold=0.37,label=paste(substr(row.names(dis),11,11),
# substr(row.names(dis),21,21),sep="-"))
</code></pre>

<hr>
<h2 id='spatial.plot'>spatial plot of populations</h2><span id='topic+spatial.plot'></span>

<h3>Description</h3>

<p>This function estimates the phylogeographic relationships among populations, displaying nodes according to geographic coordinates on maps.</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.plot(dis=NULL, align=NA, X=NULL, Y=NULL, indel.method="MCIC",
substitution.model="raw", pairwise.deletion=TRUE, alpha="info",
combination.method="Corrected", na.rm.row.col=FALSE, addExtremes=FALSE,
NameIniPopulations=NA, NameEndPopulations=NA, NameIniHaplotypes=NA,
NameEndHaplotypes=NA, HaplosNames=NA, save.distance=FALSE,
save.distance.name="DistanceMatrix_threshold.txt",
network.method="percolation", range=seq(0,1,0.01), modules=FALSE,
moduleCol=NA, modFileName="Modules_summary.txt", bgcol="white",
label.col="black", label=NA, label.sub.str=NA, label.pos= "b",
cex.label=1,cex.vertex=1,vertex.size="equal", plot.edges=TRUE,
lwd.edge=1,to.ggmap=FALSE, plot.ggmap=FALSE, zoom.ggmap=6,
maptype.ggmap="satellite", label.size.ggmap=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial.plot_+3A_dis">dis</code></td>
<td>
<p>a matrix; the distance matrix to be analysed. Alternatively, you can define an alignment using 'align' option.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_align">align</code></td>
<td>
<p>a 'DNAbin' object; the alignment to be analysed. See &quot;read.dna&quot; in the ape package for details about reading alignments. Alternatively, you can define a distance matrix using the 'dis' option.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_x">X</code></td>
<td>
<p>a vector; longitude for each population</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_y">Y</code></td>
<td>
<p>a vector; latitude for each population</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_indel.method">indel.method</code></td>
<td>
<p>a sting; the method to define indel events in your alignments. The available methods are:
</p>
<p>-&quot;MCIC&quot;: (Default) Estimates indel events following the rationale of the Modified Complex Indel Coding (Muller, 2006).
</p>
<p>-&quot;SIC&quot;: Estimates indel events following the rationale of Simmons and Ochoterrena (2000).
</p>
<p>-&quot;FIFTH&quot;: Estimates indel events following the rationale of the fifth state: each gap within the alignment is treated
as an independent mutation event.
</p>
<p>-&quot;BARRIEL&quot;: Estimates indel events following the rationale of Barriel (1994): singleton gaps are not taken into account.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_substitution.model">substitution.model</code></td>
<td>
<p>a string; the substitution evolutionary model to estimate the distance matrix. By default is set to &quot;raw&quot; and
estimates the pairwise proportion of variant sites. See the evolutionary models available using ?dist.dna from the ape package.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_pairwise.deletion">pairwise.deletion</code></td>
<td>
<p>a logical; if TRUE (default) substitutions found in regions being a gap in other sequences will account
for the distance matrix. If FALSE, sites being a gap in at least one sequence will be removed before distance estimation.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_network.method">network.method</code></td>
<td>
<p>a string; the method to build the network. The available methods are:
</p>
<p>-&quot;percolation&quot;: computes a network using the percolation network method following Rozenfeld et al. (2008).
See ?perc.thr for details
</p>
<p>-&quot;NINA&quot;: computes a network using the No Isolation Nodes Allowed method. See ?NINA.thr for details.
</p>
<p>-&quot;zero&quot;: computes a network connecting all nodes showing distances equal to zero. See ?NINA.thr for details.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_range">range</code></td>
<td>
<p>a numeric vector between 0 and 1, is the range of thresholds (referred to the maximum distance in the input matrix) to be screened (by default, 101 values from 0 to 1). This option is used for &quot;percolation&quot; and &quot;NINA&quot; network methods and ignored for &quot;zero&quot; method.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_addextremes">addExtremes</code></td>
<td>
<p>a logical; if TRUE, additional nucleotide sites are included in both extremes of the alignment. This will allow estimating distances for alignments showing gaps in terminal positions. This option is used for &quot;SIC&quot;, &quot;FIFTH&quot; and &quot;BARRIEL&quot; indel methods and ignored for &quot;MCIC&quot; method.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_alpha">alpha</code></td>
<td>
<p>a numeric between 0 and 1, is the weight given to the indel genetic distance matrix in the combination. By definition, the weight of the substitution genetic matrix is the complementary value (i.e., 1-alpha). The value &quot;info&quot; will use the proportion of informative substitutions per informative indel event as weight. It is also possible to define multiple weights to estimate different combinations.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_combination.method">combination.method</code></td>
<td>
<p>a string defining whether each distance matrix must be divided by its maximum value before the combination (&quot;Corrected&quot;) or not (&quot;Uncorrected&quot;). Consequently, if the &quot;Corrected&quot; method is chosen, both matrices will range between 0 and 1 before being combined.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_na.rm.row.col">na.rm.row.col</code></td>
<td>
<p>a logical; if TRUE, distance matrix missing values are removed.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_modules">modules</code></td>
<td>
<p>a logical, If TRUE, nodes belonging to different modules are represented as different colours (defined by 'moduleCol').</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_modulecol">moduleCol</code></td>
<td>
<p>(if modules=TRUE) a vector of strings defining the colour of nodes belonging to different modules in the network. If 'NA' (or there are less colours than haplotyes), colours are automatically selected</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_modfilename">modFileName</code></td>
<td>
<p>(if modules=TRUE) a string, the name of the file to be generated containing a summary of module results (sequence name, module, and colour in network)</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_save.distance">save.distance</code></td>
<td>
<p>a logical; if TRUE, the distance matrix used to build the network will be saved as a file.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_save.distance.name">save.distance.name</code></td>
<td>
<p>a string; if save.distance=TRUE, it defines the name of the file to be saved.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_bgcol">bgcol</code></td>
<td>
<p>a vector of strings; the colour of the background for each node in the network. Can be equal for all nodes (if only one colour is defined), customized (if several colours are defined), or can represent different modules (see &quot;modules&quot; option). If set to 'NA' (default) or if less colours than haplotyes are defined, colours are automatically selected.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_label.col">label.col</code></td>
<td>
<p>a vector of strings; the colour of labels for each node in the network. Can be equal for all nodes (if only one colour is defined) or customized (if several colours are defined).</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_label">label</code></td>
<td>
<p>a vector of strings; labels for each node. By default are the sequence names. (See &quot;substr&quot; function in base package to automatically reduce name lengths)</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_label.sub.str">label.sub.str</code></td>
<td>
<p>a vector of two numerics; if node labels are a sub-string of sequence names, these two numbers represent the initial and final character of the string to be represented. See Example for details.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_label.pos">label.pos</code></td>
<td>
<p>a sting; position for vertex labels regarding vertex position (do not affect the ggmap output). Possible values are: &quot;b&quot; or &quot;below&quot; (default), &quot;a&quot; or &quot;above&quot;; &quot;l&quot; or &quot;left&quot;; &quot;r&quot; or &quot;right&quot; and &quot;c&quot; or &quot;centre&quot;</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_lwd.edge">lwd.edge</code></td>
<td>
<p>a numeric; the width of the edge linking nodes (1.5 by default).</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_cex.label">cex.label</code></td>
<td>
<p>a numeric; the size of the node labels.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_cex.vertex">cex.vertex</code></td>
<td>
<p>a numeric; the size of the nodes.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_nameinipopulations">NameIniPopulations</code></td>
<td>
<p>a numeric; Position of the initial character of population names within sequence names. If not provided, it is set to 1. It is used only if NameEndPopulations is also defined.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_nameendpopulations">NameEndPopulations</code></td>
<td>
<p>a numeric; Position of the last character of population names within sequence names. If not provided, it is set to the first &quot;_&quot; character in the sequences name. It is used only if NameIniPopulations is also defined.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_nameinihaplotypes">NameIniHaplotypes</code></td>
<td>
<p>a numeric; Position of the initial character of haplotype names within sequence names. If not provided, haplotype names are given and the value is set accordingly. It is used only if NameEndHaplotypes is also defined.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_nameendhaplotypes">NameEndHaplotypes</code></td>
<td>
<p>a numeric; Position of the last character of haplotype names within sequence names. If not provided, haplotype names are given and the value is set accordingly. It is used only if NameIniHaplotypes is also defined.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_plot.edges">plot.edges</code></td>
<td>
<p>a logical; must the edges connecting nodes be potted?</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_haplosnames">HaplosNames</code></td>
<td>
<p>a sting; the name of the haplotypes (if different from default: H1...Hn)</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_to.ggmap">to.ggmap</code></td>
<td>
<p>a logical; if TRUE, the algorithm generates a list with information required to represent the resulting network using ggmap (see details).</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_plot.ggmap">plot.ggmap</code></td>
<td>
<p>a logical; if TRUE, populations (and edges producing a network if 'plot.edges' is set to TRUE) are represented within a map automatically downloaded according the population coordinates.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_zoom.ggmap">zoom.ggmap</code></td>
<td>
<p>a numeric; sets the zoom of the map (higher values mean deeper zoom)</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_maptype.ggmap">maptype.ggmap</code></td>
<td>
<p>a string; types of maps implemented by 'ggplot' are: &quot;terrain&quot;, &quot;satellite&quot;, &quot;roadmap&quot;, &quot;hybrid&quot;, &quot;toner&quot;, and &quot;watercolor&quot;)</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_label.size.ggmap">label.size.ggmap</code></td>
<td>
<p>a numeric; controls the labe size in the ggplot</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_vertex.size">vertex.size</code></td>
<td>
<p>a string to define the ratio of vertices representing populations. Possible values are: &quot;equal&quot; (default) to give the same size to all vertices; or &quot;area&quot; to make the vertex area proportional to the population sample size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Despite the large list of options, the only mandatory options for this function are the geographic coordinates ('X' and 'Y' options) of the studied populations and either the alignment or the distance matrix ('align' or 'dis', respectively). The remaining options can be classified into five groups:
</p>
<p>1- options defining the computation of both indel and substitution distances (indel.method, substitution.model, pairwise.deletion).
</p>
<p>2- options defining the combination of these two distance matrices (alpha, combination.method, na.rm.row.col, addExtremes, NameIniPopulations, NameEndPopulations, NameIniHaplotypes, NameEndHaplotypes, HaplosNames, save.distance, save.distance.name).
</p>
<p>3- options defining the computation of the network (network.method, range).
</p>
<p>4- options customizing the resulting network (modules, moduleCol, modFileName, bgcol, label.col, label, label.sub.str, cex.label, cex.vertex, vertex.size, plot.edges, lwd.edge).
</p>
<p>5- options dealing with map representation (to.ggmap, plot.ggmap, zoom.ggmap, maptype.ggmap, label.size.ggmap).
</p>
<p>Although the 'indel.method' option affects both the distance estimation and the number of mutations represented in the network, the 'substitution.model' and 'pairwise.deletion' options only affect the distance matrix computation. 
</p>
<p>This function provides limited options for representing of the resulting population network within a map using the 'ggmap' package. To take advantage of the additional options implemented in ggmap, the 'to.ggmap' option generates a list with the following information:
</p>
<p>1- location: centroid of the population coordinates (required to center the map)
</p>
<p>2- colours: the colour to represent each population (useful, for example to represent modules)
</p>
<p>3- coordinates: the geographic coordinates of the studied populations
</p>
<p>4- network: the resulting population network, represented as a 1/0 matrix
</p>
<p>5- links: a two column matrix representing the edges within the resulting network. Each row provides information on the two elements that are connected by a link.
</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>References</h3>

<p>Barriel, V., 1994. Molecular phylogenies and how to code insertion/
deletion events. Life Sci. 317, 693-701, cited and described by
Simmons, M.P., Müller, K. &amp; Norton, A.P. (2007)
The relative performance of indel-coding methods in simulations.
Molecular Phylogenetics and Evolution, 44, 724–740.
</p>
<p>Muller K. (2006). Incorporating information from length-mutational events
into phylogenetic analysis. Molecular Phylogenetics and Evolution, 38, 667-676.
</p>
<p>Paradis, E., Claude, J. &amp; Strimmer, K. (2004). APE: analyses of phylogenetics
and evolution in R language. Bioinformatics, 20, 289-290.
</p>
<p>Rozenfeld AF, Arnaud-Haond S, Hernandez-Garcia E, Eguiluz VM, Serrao EA, Duarte CM. (2008). Network analysis identifies weak and strong links in a metapopulation system. Proceedings of the National Academy of Sciences,105, 18824-18829.
</p>
<p>Simmons, M.P. &amp; Ochoterena, H. (2000). Gaps as Characters in Sequence-Based
Phylogenetic Analyses. Systematic Biology, 49, 369-381.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# library(ggplot2)
# data(ex_Coords)
# data(ex_alignment1) # this will read a fasta file with the name 'alignExample'

# A simple plot of the population network using geographic coordinates:
# spatial.plot (align=alignExample,X=ex_Coords[,2],Y=ex_Coords[,3])

# Changing vertex names and location:
# spatial.plot (align=alignExample,X=ex_Coords[,2],Y=ex_Coords[,3],
# cex.vertex=2,label=c(1:8),label.pos="c",modules=TRUE)

# Plotting network on a map:
# Uncomment the lines below. It would take more than 5 seconds to run
# spatial.plot (align=alignExample,X=ex_Coords[,2],Y=ex_Coords[,3],
# cex.vertex=2,label=c(1:8),modules=TRUE, plot.ggmap=TRUE)

# Displaying only population coordinates (sampling desing).
# Uncomment the lines below. It would take more than 5 seconds to run
# spatial.plot (align=alignExample,X=ex_Coords[,2],Y=ex_Coords[,3],
# cex.vertex=2,label=c(1:8), plot.ggmap=TRUE,plot.edges=FALSE,
# bgcol=c("red","orange","green4","green1","yellow","brown","blue","purple"))



</code></pre>

<hr>
<h2 id='zero.thr'>Zero distance networks</h2><span id='topic+zero.thr'></span>

<h3>Description</h3>

<p>Given a distance matrix, this function computes a network connecting nodes showing distances equal to zero.</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero.thr(dis,ptPDF=TRUE,ptPDFname="zero_Network.pdf",cex.label=1,cex.vertex=1,
bgcol="white",label.col="black",label=colnames(dis),modules=FALSE,moduleCol=NA,
modFileName="Modules_summary.txt",ncs=4,na.rm.row.col=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero.thr_+3A_dis">dis</code></td>
<td>
<p>the input distance matrix</p>
</td></tr>
<tr><td><code id="zero.thr_+3A_ptpdf">ptPDF</code></td>
<td>
<p>a logical, must the resulting network be saved as a pdf file?</p>
</td></tr>
<tr><td><code id="zero.thr_+3A_ptpdfname">ptPDFname</code></td>
<td>
<p>if ptPDF=TRUE, the name of the pdf file containing the resulting network to be saved (&quot;zero_Network.pdf&quot;, by default)</p>
</td></tr>
<tr><td><code id="zero.thr_+3A_cex.label">cex.label</code></td>
<td>
<p>a numeric; the size of the node labels.</p>
</td></tr>
<tr><td><code id="zero.thr_+3A_cex.vertex">cex.vertex</code></td>
<td>
<p>a numeric; the size of the nodes.</p>
</td></tr>
<tr><td><code id="zero.thr_+3A_bgcol">bgcol</code></td>
<td>
<p>the background colour for each node in the network. Can be equal for all nodes (if only one colour is defined), customized (if several colours are defined), or can represent different modules (see &quot;modules&quot; option).
</p>
</td></tr>
<tr><td><code id="zero.thr_+3A_label.col">label.col</code></td>
<td>
<p>vector of strings defining the colour of labels for each node in the network. Can be equal for all nodes (if only one colour is defined) or customized (if several colours are defined).
</p>
</td></tr>
<tr><td><code id="zero.thr_+3A_label">label</code></td>
<td>
<p>vector of strings, labels for each node. By default are the column names of the distance matrix (dis). (See the 'substr' function in base package to automatically reduce name lengths).
</p>
</td></tr>
<tr><td><code id="zero.thr_+3A_modules">modules</code></td>
<td>
<p>a logical, must nodes belonging to different modules be represented with different colours? If TRUE, a text file containing information on modules for each node is also produced.
</p>
</td></tr>
<tr><td><code id="zero.thr_+3A_modulecol">moduleCol</code></td>
<td>
<p>(if modules=TRUE) a vector of strings, defining the colour of nodes belonging to different modules in the network. If 'NA' or less colours than modules are defined, colours are automatically defined.</p>
</td></tr>
<tr><td><code id="zero.thr_+3A_modfilename">modFileName</code></td>
<td>
<p>(if modules=TRUE) the name of the text file containing a summary of module results
</p>
</td></tr>
<tr><td><code id="zero.thr_+3A_ncs">ncs</code></td>
<td>
<p>a numeric; number of decimal places to display threshold in plot title.</p>
</td></tr>
<tr><td><code id="zero.thr_+3A_na.rm.row.col">na.rm.row.col</code></td>
<td>
<p>a logical; if TRUE, missing values are removed before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some circumstances you may get distance matrices showing off-diagonal zeros. In such cases you may consider that the
existence of these off-diagonal zeros suggests that some of the groups you defined (e.g., populations) are not genetically different.
Thus, you must re-define groups to get a matrix composed only by different  groups using the 'mergeNodes' function and 
estimate a percolation network using the 'perc.thr' function. On the other hand, you may consider that, despite the off-
diagonal zeros, the groups you defined are actually different. In that case you may not be able to estimate a 
percolation threshold, but you can represent the original distance matrix using the 'NINA.thr' or the 'zero.thr' functions.
</p>
<p>'mergeNodes' select all rows (and columns) showing a distance equal to zero and generates a new row (and column). The distance between the new merged and the remaining rows (or columns) in the matrix is estimated as the arithmetic mean of the selected elements. The biological interpretation of the new matrix could be hard if the original matrix shows a large number of off-diagonal zeros.
</p>
<p>'perc.thr' estimates a threshold to represent a distance matrix as a network. To estimate this threshold, the algorithm represents as a link all distances lower than a range of thresholds (by default, select 101 values from 0 to 1), defined as the percentage of the maximum distance in the input matrix. For each threshold a network is built and the number of clusters (that is, the number of isolated groups of nodes) in the network is also estimated. Finally, the algorithm selects the lower threshold connecting a higher number of nodes. Note that the resulting network may show isolated nodes if it is necessary to represent a large number of links to connect a low number of nodes.
</p>
<p>'NINA.thr' is identical to 'perc.thr', but, in the last step, the algorithm selects the lower threshold connecting all nodes in a single cluster. The information provided by this function may be limited if the original distance matrix shows high variation.
</p>
<p><strong>'zero.thr'</strong> represents as a link only distances equal to zero. The information provided by this function may be limited if the original matrix shows few off-diagonal zeros.
</p>


<h3>Value</h3>

<p>A network connecting nodes showing a distance equal to zero.</p>


<h3>Author(s)</h3>

<p>A. J. Muñoz-Pajares</p>


<h3>See Also</h3>

<p><code><a href="#topic+NINA.thr">NINA.thr</a></code>, <code><a href="#topic+perc.thr">perc.thr</a></code>, <code><a href="#topic+mergeNodes">mergeNodes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#EXAMPLE 1: FEW OFF-DIAGONAL ZEROS
#Generating a distance matrix:
Dis1&lt;-matrix(c(
0.00,0.77,0.28,0.94,0.17,0.14,0.08,0.49,0.64,0.01,
0.77,0.00,0.12,0.78,0.97,0.02,0.58,0.09,0.36,0.33,
0.28,0.12,0.00,0.70,0.73,0.06,0.50,0.79,0.80,0.94,
0.94,0.78,0.70,0.00,0.00,0.78,0.04,0.42,0.25,0.85,
0.17,0.97,0.73,0.00,0.00,0.30,0.55,0.12,0.68,0.99,
0.14,0.02,0.06,0.78,0.30,0.00,0.71,1.00,0.64,0.88,
0.08,0.58,0.50,0.04,0.55,0.71,0.00,0.35,0.84,0.76,
0.49,0.09,0.79,0.42,0.12,1.00,0.35,0.00,0.56,0.81,
0.64,0.36,0.80,0.25,0.68,0.64,0.84,0.56,0.00,0.62,
0.01,0.33,0.94,0.85,0.99,0.88,0.76,0.81,0.62,0.00),ncol=10)
colnames(Dis1)&lt;-c(paste("Pop",c(1:10),sep=""))
row.names(Dis1)&lt;-colnames(Dis1)

# No percolation threshold can be found.
#perc.thr(Dis1)

#Check Dis1 and merge populations showing distances equal to zero:
Dis1
Dis1_Merged&lt;-mergeNodes(dis=Dis1)
#Check the merged matrix. A new "population" has been defined merging populations 4 and 5.
#Distances between the merged and the remaining populations are estimated as the arithmetic mean.
Dis1_Merged
# It is now possible to estimate a percolation threshold
perc.thr(dis=Dis1_Merged,ptPDF=FALSE, estimPDF=FALSE, estimOutfile=FALSE) 

# EXAMPLE 2: TOO MANY OFF-DIAGONAL ZEROS
#Generating a distance matrix:
Dis2&lt;-matrix(c(
0.00,0.77,0.28,0.00,0.17,0.14,0.00,0.49,0.64,0.01,
0.77,0.00,0.12,0.00,0.97,0.02,0.00,0.09,0.36,0.33,
0.28,0.12,0.00,0.70,0.73,0.06,0.50,0.79,0.00,0.94,
0.00,0.00,0.70,0.00,0.00,0.78,0.04,0.00,0.00,0.00,
0.17,0.97,0.73,0.00,0.00,0.30,0.55,0.12,0.00,0.00,
0.14,0.02,0.06,0.78,0.30,0.00,0.71,1.00,0.64,0.00,
0.00,0.00,0.50,0.04,0.55,0.71,0.00,0.35,0.84,0.00,
0.49,0.09,0.79,0.00,0.12,1.00,0.35,0.00,0.56,0.81,
0.64,0.36,0.00,0.00,0.00,0.64,0.84,0.56,0.00,0.62,
0.01,0.33,0.94,0.00,0.00,0.00,0.00,0.81,0.62,0.00),ncol=10)
colnames(Dis2)&lt;-c(paste("Pop",c(1:10),sep=""))
row.names(Dis2)&lt;-colnames(Dis2)

# # No percolation threshold can be found
# #perc.thr(Dis2)
# 
# #Check Dis2 and merge populations showing distances equal to zero:
# Dis2
# Dis2_Merged&lt;-mergeNodes(dis=Dis2)
# 
# #Check the merged matrix. Many new "populations" have been defined and both the new
# #matrix and the resulting network are difficult to interpret:
# Dis2_Merged
# perc.thr(dis=Dis2_Merged,ptPDF=FALSE, estimPDF=FALSE, estimOutfile=FALSE) 
# 
# #Instead of percolation network, representing zeros as the lowest values may be informative:
# zero.thr(dis=Dis2,ptPDF=FALSE)
# # Adjusting sizes and showing modules:
# zero.thr(dis=Dis2,ptPDF=FALSE,cex.label=0.8,cex.vertex=1.2,modules=TRUE)
# 
# #In the previous example, the 'zero.thr' method is unuseful: 
# zero.thr(dis=Dis1,ptPDF=FALSE)
# 
# #In both cases, the 'No Isolation Nodes Allowed' method yields an informative matrix:
# NINA.thr(dis=Dis1)
# NINA.thr(dis=Dis2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
