<!DOCTYPE html><html><head><title>Help for package MultiGroupSequential</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MultiGroupSequential}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calgsp1'><p>Calculate group-sequential p-values for one hypothesis</p></a></li>
<li><a href='#calgspn'><p>Calculate group-sequential p-values for multiple hypotheses</p></a></li>
<li><a href='#checkcrit'><p>Check critical values</p></a></li>
<li><a href='#findcrit'><p>Calculate critical values</p></a></li>
<li><a href='#graphical'><p>Graphical procedure</p></a></li>
<li><a href='#hochbergd'><p>Hochberg procedure</p></a></li>
<li><a href='#hommeld'><p>Hommel procedure</p></a></li>
<li><a href='#inftocor'><p>Transform information fractions into correlation matrix</p></a></li>
<li><a href='#MultiGroupSequential-package'><p>MultiGroupSequential: Group-Sequential Procedures with Multiple Hypotheses</p></a></li>
<li><a href='#seqgspgx'><p>Sequential graphical procedure based on group-sequential p-values</p></a></li>
<li><a href='#seqgsphh'><p>Sequential generalized Hochberg and Hommel procedures based on group-sequential p-values</p></a></li>
<li><a href='#seqmbgx'><p>Maurer-Bretz sequential graphical approach</p></a></li>
<li><a href='#seqqvalhh'><p>Sequential generalized Hochberg and Hommel procedures based on q-values</p></a></li>
<li><a href='#spendingfun'><p>Calculate alpha spending function</p></a></li>
<li><a href='#updategraph'><p>Update graph</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Group-Sequential Procedures with Multiple Hypotheses</td>
</tr>
<tr>
<td>Description:</td>
<td>It is often challenging to strongly control the family-wise type-1 error rate in the group-sequential trials with multiple endpoints (hypotheses). The inflation of type-1 error rate comes from two sources (S1) repeated testing individual hypothesis and (S2) simultaneous testing multiple hypotheses. The 'MultiGroupSequential' package is intended to help researchers to tackle this challenge. The procedures provided include the sequential procedures described in Luo and Quan (2023) &lt;<a href="https://doi.org/10.1080%2F19466315.2023.2191989">doi:10.1080/19466315.2023.2191989</a>&gt; and the graphical procedure proposed by Maurer and Bretz (2013) &lt;<a href="https://doi.org/10.1080%2F19466315.2013.807748">doi:10.1080/19466315.2013.807748</a>&gt;. Luo and Quan (2013) describes three procedures, and the functions to implement these procedures are (1) seqgspgx() implements a sequential graphical procedure based on the group-sequential p-values; (2) seqgsphh() implements a sequential Hochberg/Hommel procedure based on the group-sequential p-values; and (3) seqqvalhh() implements a sequential Hochberg/Hommel procedure based on the q-values. In addition, seqmbgx() implements the sequential graphical procedure described in Maurer and Bretz (2013).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, OpenMx, hommel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-09 13:49:24 UTC; I0527518</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiaodong Luo [aut, cre],
  Hui Quan [ctb],
  Sanofi [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiaodong Luo &lt;Xiaodong.Luo@sanofi.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-09 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calgsp1'>Calculate group-sequential p-values for one hypothesis</h2><span id='topic+calgsp1'></span>

<h3>Description</h3>

<p><code>calgsp1()</code> calculates the group-sequential p-values for one hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calgsp1(
  sx = qnorm(1 - c(0.03, 0.04, 0.01)),
  scrit = qnorm(1 - c(0.01, 0.02, 0.025)),
  salpha = c(0.01, 0.02, 0.025),
  smatrix = diag(3),
  sided = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calgsp1_+3A_sx">sx</code></td>
<td>
<p>Numeric vector of test statistics, assumed to be multivariate
normal with variance 1 and correlation matrix given by <code>smatrix</code>.</p>
</td></tr>
<tr><td><code id="calgsp1_+3A_scrit">scrit</code></td>
<td>
<p>Numeric vector of sequece of critical values for the test
statistics in <code>sx</code>. It should be computed beforehand. Must have the same
length as <code>sx</code>.</p>
</td></tr>
<tr><td><code id="calgsp1_+3A_salpha">salpha</code></td>
<td>
<p>Numeric vector of cumulative alpha levels for the test
statistics in <code>sx</code>. Must have the same length as <code>sx</code>.</p>
</td></tr>
<tr><td><code id="calgsp1_+3A_smatrix">smatrix</code></td>
<td>
<p>Matrix with the correlation matrix of the test statistics <code>sx</code>.</p>
</td></tr>
<tr><td><code id="calgsp1_+3A_sided">sided</code></td>
<td>
<p>Integer scalar indicating the side of the test:
</p>

<ul>
<li> <p><code>-1</code>: Reject if test statistic is smaller than or equal to the critical value (one-sided)
</p>
</li>
<li> <p><code>1</code>: Reject if test statistic is greater or equal to the critical value (one-sided)
</p>
</li>
<li> <p><code>0</code>: Reject if the absolute value of the test statistic is greater than the critical value (two-sided)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the group-sequential p-values.
</p>


<h3>Author(s)</h3>

<p>Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calgsp1(
  sx = qnorm(1 - c(0.03, 0.04, 0.01)),
  scrit = qnorm(1 - c(0.01, 0.02, 0.025)),
  salpha = c(0.01, 0.02, 0.025),
  smatrix = diag(3),
  sided = 1
)
</code></pre>

<hr>
<h2 id='calgspn'>Calculate group-sequential p-values for multiple hypotheses</h2><span id='topic+calgspn'></span>

<h3>Description</h3>

<p><code>calgspn()</code> calculates the group-sequential p-values for multiple hypotheses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calgspn(
  xm = qnorm(matrix(rep(c(0.03, 0.04, 0.01), times = 2), ncol = 3, nrow = 2)),
  alpham = matrix(rep(c(0.02, 0.03, 0.05), each = 2), ncol = 3, nrow = 2),
  critm = matrix(rep(qnorm(c(0.02, 0.03, 0.05)), each = 2), ncol = 3, nrow = 2),
  matrix.list = list(diag(3), diag(3)),
  sided = rep(-1, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calgspn_+3A_xm">xm</code></td>
<td>
<p>Matrix of test statistics for hypotheses (in row) and each
interim (in column).</p>
</td></tr>
<tr><td><code id="calgspn_+3A_alpham">alpham</code></td>
<td>
<p>Matrix of cumulative alpha levels for the test statistics <code>xm</code>.
Must have the same dimensions as <code>xm</code>. For each row, alpha levels must be</p>
</td></tr>
<tr><td><code id="calgspn_+3A_critm">critm</code></td>
<td>
<p>Matrix of critical values for the test statistics in <code>xm</code>. It
should be computed beforehand. Must have the same dimensions as <code>xm</code>.</p>
</td></tr>
<tr><td><code id="calgspn_+3A_matrix.list">matrix.list</code></td>
<td>
<p>List of correlation matrices corresponding to each
hypothesis.</p>
</td></tr>
<tr><td><code id="calgspn_+3A_sided">sided</code></td>
<td>
<p>Integer vector indicating the side of the test:
</p>

<ul>
<li> <p><code>-1</code>: Reject if test statistic is smaller than or equal to the critical value (one-sided)
</p>
</li>
<li> <p><code>1</code>: Reject if test statistic is greater or equal to the critical value (one-sided)
</p>
</li>
<li> <p><code>0</code>: Reject if the absolute value of the test statistic is greater than the critical value (two-sided)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List with element <code>pm</code> containing the group-sequential p-values.
</p>


<h3>Author(s)</h3>

<p>Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calgspn(
  xm = qnorm(matrix(rep(c(0.03,0.04,0.01),times=2),ncol=3,nrow=2)),
  alpham = matrix(rep(c(0.02,0.03,0.05),each=2),ncol=3,nrow=2),
  critm = matrix(rep(qnorm(c(0.02,0.03,0.05)),each=2),ncol=3,nrow=2),
  matrix.list = list(diag(3),diag(3)),
  sided = rep(-1,2)
)
</code></pre>

<hr>
<h2 id='checkcrit'>Check critical values</h2><span id='topic+checkcrit'></span>

<h3>Description</h3>

<p><code>checkcrit()</code> is a helper function that checks if the critical values
are valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkcrit(
  scrit = qnorm(c(0.01, 0.02, 0.025)),
  salpha = c(0.01, 0.02, 0.025),
  smatrix = diag(3),
  sided = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkcrit_+3A_scrit">scrit</code></td>
<td>
<p>Numeric vector of critical values.</p>
</td></tr>
<tr><td><code id="checkcrit_+3A_salpha">salpha</code></td>
<td>
<p>Numeric vector of cumulative alpha levels.</p>
</td></tr>
<tr><td><code id="checkcrit_+3A_smatrix">smatrix</code></td>
<td>
<p>General correlation matrix.</p>
</td></tr>
<tr><td><code id="checkcrit_+3A_sided">sided</code></td>
<td>
<p>Integer vector indicating the side of the test:
</p>

<ul>
<li> <p><code>-1</code>: Reject if test statistic is smaller than or equal to the critical value (one-sided)
</p>
</li>
<li> <p><code>1</code>: Reject if test statistic is greater or equal to the critical value (one-sided)
</p>
</li>
<li> <p><code>0</code>: Reject if the absolute value of the test statistic is greater than the critical value (two-sided)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List with:
</p>

<ul>
<li> <p><code>crit.value</code>: Critical values
</p>
</li>
<li> <p><code>salpha</code>: Cumulative alpha levels passed to <code>salpha</code> argument
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>checkcrit(
  scrit = qnorm(c(0.01, 0.02, 0.025)),
  salpha = c(0.01, 0.02, 0.025),
  smatrix = diag(3),
  sided = 1
)
</code></pre>

<hr>
<h2 id='findcrit'>Calculate critical values</h2><span id='topic+findcrit'></span>

<h3>Description</h3>

<p><code>findcirt()</code> calculates the critical values in the general correlation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findcrit(
  salpha = c(0.01, 0.02, 0.025),
  smatrix = diag(3),
  sided = 1,
  tol = 1e-10,
  alpha.tol = 1e-11
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findcrit_+3A_salpha">salpha</code></td>
<td>
<p>Numeric vector of cumulative alpha levels.</p>
</td></tr>
<tr><td><code id="findcrit_+3A_smatrix">smatrix</code></td>
<td>
<p>General correlation matrix.</p>
</td></tr>
<tr><td><code id="findcrit_+3A_sided">sided</code></td>
<td>
<p>Integer vector indicating the side of the test:
</p>

<ul>
<li> <p><code>-1</code>: Reject if test statistic is smaller than or equal to the critical value (one-sided)
</p>
</li>
<li> <p><code>1</code>: Reject if test statistic is greater or equal to the critical value (one-sided)
</p>
</li>
<li> <p><code>0</code>: Reject if the absolute value of the test statistic is greater than the critical value (two-sided)
</p>
</li></ul>
</td></tr>
<tr><td><code id="findcrit_+3A_tol">tol</code></td>
<td>
<p>Numeric scalar with the tolerance level for computing
critical values.</p>
</td></tr>
<tr><td><code id="findcrit_+3A_alpha.tol">alpha.tol</code></td>
<td>
<p>Numeric scalar. If the alpha increment is less than this,
the critical value is set to a large number determined by <code>alpha.tol</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with element <code>crit.value</code> containing the obtained critical values.
</p>


<h3>Author(s)</h3>

<p>Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>findcrit(
  salpha = c(0.01, 0.02, 0.025),
  smatrix = diag(3),
  sided = 1,
  tol = 1e-10,
  alpha.tol = 1e-11
)
</code></pre>

<hr>
<h2 id='graphical'>Graphical procedure</h2><span id='topic+graphical'></span>

<h3>Description</h3>

<p><code>graphical()</code> performs graphical procedure to test multiple hypotheses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphical(
  p = c(0.01, 0.04, 0.03),
  W = c(0.5, 0.25, 0.25),
  G = rbind(c(0, 1, 0), c(0, 0, 1), c(1, 0, 0)),
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphical_+3A_p">p</code></td>
<td>
<p>Numeric vector of p-values for the hypotheses.</p>
</td></tr>
<tr><td><code id="graphical_+3A_w">W</code></td>
<td>
<p>Numeric vector of weigths of the graph. Must have the same length
as <code>p</code>.</p>
</td></tr>
<tr><td><code id="graphical_+3A_g">G</code></td>
<td>
<p>Matrix of the transition matrix of the graph.</p>
</td></tr>
<tr><td><code id="graphical_+3A_alpha">alpha</code></td>
<td>
<p>Numeric scalar with the overall type-1 error rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a single element containing a vector indicating whether
hypotheses are rejected (<code>1</code>) or not (<code>0</code>).
</p>


<h3>Author(s)</h3>

<p>Kaiyuan Hua, Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graphical(p = c(0.02, 0.03, 0.01))
</code></pre>

<hr>
<h2 id='hochbergd'>Hochberg procedure</h2><span id='topic+hochbergd'></span>

<h3>Description</h3>

<p><code>hochbergd()</code> computes the Hochberg procedure with different alphas
for different endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hochbergd(pvalues, alpha, epsilon = 1e-10, precision = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hochbergd_+3A_pvalues">pvalues</code></td>
<td>
<p>Numeric vector of p-values from different endpoints.</p>
</td></tr>
<tr><td><code id="hochbergd_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector of alpha values for the different endpoints.
Vector must be same length as <code>pvalues</code>.</p>
</td></tr>
<tr><td><code id="hochbergd_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric scalar indicating the lower bound for alpha.</p>
</td></tr>
<tr><td><code id="hochbergd_+3A_precision">precision</code></td>
<td>
<p>Integer scalar of the desired number of digits to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with element named <code>decisions</code> containing an index of rejected
hypotheses.
</p>


<h3>Author(s)</h3>

<p>Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hochbergd(
  pvalues = runif(5),
  alpha = seq(0.01, 0.025, len = 5),
  epsilon = 1.0e-10,
  precision = 10
)
</code></pre>

<hr>
<h2 id='hommeld'>Hommel procedure</h2><span id='topic+hommeld'></span>

<h3>Description</h3>

<p><code>hommeld()</code> implement the Hommel procedure with different alphas for
different endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hommeld(pvalues, alpha, epsilon = 1e-10, precision = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hommeld_+3A_pvalues">pvalues</code></td>
<td>
<p>Numeric vector of p-values from different endpoints.</p>
</td></tr>
<tr><td><code id="hommeld_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector of alpha values for the different endpoints.
Vector must be same length as <code>pvalues</code>.</p>
</td></tr>
<tr><td><code id="hommeld_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric scalar indicating the lower bound for alpha.</p>
</td></tr>
<tr><td><code id="hommeld_+3A_precision">precision</code></td>
<td>
<p>Integer scalar of the desired number of digits to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The package <a href="https://cran.r-project.org/package=hommel">hommel</a>
can handle Hommel procedure with different alpha's for different endpoints,
the function <code>hommeld()</code> is just a wrapper of <code><a href="hommel.html#topic+hommel-function">hommel::hommel()</a></code>.
</p>


<h3>Value</h3>

<p>List with element named <code>decisions</code> containing an index of rejected
hypotheses.
</p>


<h3>Author(s)</h3>

<p>Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hommeld(
  pvalues = runif(5),
  alpha = seq(0.01, 0.025, len = 5),
  epsilon = 1.0e-10,
  precision = 10
)
</code></pre>

<hr>
<h2 id='inftocor'>Transform information fractions into correlation matrix</h2><span id='topic+inftocor'></span>

<h3>Description</h3>

<p><code>inftocor()</code> transforms information (fractions) into correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inftocor(ir = c(0.2, 0.5, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inftocor_+3A_ir">ir</code></td>
<td>
<p>Numeric vector of the sequence of information fractions. All
elements should be between 0 and 1 with the last one being exactly 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with an element named <code>cor</code> for the correlation matrix.
</p>


<h3>Author(s)</h3>

<p>Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inftocor(ir = c(0.2, 0.5, 1.0))
</code></pre>

<hr>
<h2 id='MultiGroupSequential-package'>MultiGroupSequential: Group-Sequential Procedures with Multiple Hypotheses</h2><span id='topic+MultiGroupSequential'></span><span id='topic+MultiGroupSequential-package'></span>

<h3>Description</h3>

<p>It is often challenging to strongly control the family-wise type-1 error rate in the group-sequential trials with multiple endpoints (hypotheses). The inflation of type-1 error rate comes from two sources (S1) repeated testing individual hypothesis and (S2) simultaneous testing multiple hypotheses. The 'MultiGroupSequential' package is intended to help researchers to tackle this challenge. The procedures provided include the sequential procedures described in Luo and Quan (2023) <a href="https://doi.org/10.1080/19466315.2023.2191989">doi:10.1080/19466315.2023.2191989</a> and the graphical procedure proposed by Maurer and Bretz (2013) <a href="https://doi.org/10.1080/19466315.2013.807748">doi:10.1080/19466315.2013.807748</a>. Luo and Quan (2013) describes three procedures, and the functions to implement these procedures are (1) seqgspgx() implements a sequential graphical procedure based on the group-sequential p-values; (2) seqgsphh() implements a sequential Hochberg/Hommel procedure based on the group-sequential p-values; and (3) seqqvalhh() implements a sequential Hochberg/Hommel procedure based on the q-values. In addition, seqmbgx() implements the sequential graphical procedure described in Maurer and Bretz (2013).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Xiaodong Luo <a href="mailto:Xiaodong.Luo@sanofi.com">Xiaodong.Luo@sanofi.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Hui Quan [contributor]
</p>
</li>
<li><p> Sanofi [copyright holder]
</p>
</li></ul>



<h3>References</h3>

<p>Xiaodong Luo &amp; Hui Quan (2023) Some Multiplicity Adjustment
Procedures for Clinical Trials with Sequential Design and Multiple Endpoints,
Statistics in Biopharmaceutical Research,
DOI: 10.1080/19466315.2023.2191989.
</p>
<p>Willi Maurer &amp; Frank Bretz (2013) Multiple Testing in Group
Sequential Trials Using Graphical Approaches,
Statistics in Biopharmaceutical Research, 5:4, 311-320,
DOI: 10.1080/19466315.2013.807748
</p>

<hr>
<h2 id='seqgspgx'>Sequential graphical procedure based on group-sequential p-values</h2><span id='topic+seqgspgx'></span>

<h3>Description</h3>

<p><code>seqgspgx()</code> implements the sequential graphical procedure for multiple
hypotheses based on group-sequential p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqgspgx(
  pm = matrix(rep(c(0.03, 0.04, 0.01), times = 2), ncol = 3, nrow = 2),
  alpha = 0.025,
  W = c(0.6, 0.4),
  G = rbind(c(0, 1), c(1, 0))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqgspgx_+3A_pm">pm</code></td>
<td>
<p>Numeric matrix of group-sequential p-values for different
hypotheses (in row) at different times (in column).</p>
</td></tr>
<tr><td><code id="seqgspgx_+3A_alpha">alpha</code></td>
<td>
<p>Numeric scalar of the overall family-wise error rate.</p>
</td></tr>
<tr><td><code id="seqgspgx_+3A_w">W</code></td>
<td>
<p>Numeric vector of the weights of the graph.</p>
</td></tr>
<tr><td><code id="seqgspgx_+3A_g">G</code></td>
<td>
<p>Numeric transition matrix of the graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements
</p>

<ul>
<li> <p><code>rejected</code>: the index set of rejected hypotheses
</p>
</li>
<li> <p><code>decisionsm</code>: rejection decision for each endpoint (row) at each timepoint
(column)
</p>
</li>
<li> <p><code>cumdecisionsm</code>: cumulative rejection decision for each endpoint (row) at
each timepoint (column)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seqgspgx(
  pm = matrix(rep(c(0.03, 0.04, 0.01), times = 2), ncol = 3, nrow = 2),
  alpha = 0.025,
  W = c(0.6, 0.4),
  G = rbind(c(0, 1), c(1, 0))
)
</code></pre>

<hr>
<h2 id='seqgsphh'>Sequential generalized Hochberg and Hommel procedures based on group-sequential p-values</h2><span id='topic+seqgsphh'></span>

<h3>Description</h3>

<p><code>seqgsphh()</code> implements the sequential Generalized Hochberg and Hommel
procedures based on group-sequential p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqgsphh(
  pm = matrix(rep(c(0.03, 0.04, 0.01), times = 2), ncol = 3, nrow = 2),
  alpha = 0.025,
  epsilon = 1e-10,
  precision = 10,
  method = "Hochberg"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqgsphh_+3A_pm">pm</code></td>
<td>
<p>Numeric matrix of group-sequential p-values for different
hypotheses (in row) at different times (in column).</p>
</td></tr>
<tr><td><code id="seqgsphh_+3A_alpha">alpha</code></td>
<td>
<p>Numeric scalar of the overall family-wise error rate.</p>
</td></tr>
<tr><td><code id="seqgsphh_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric scalar indicating the lower bound for <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="seqgsphh_+3A_precision">precision</code></td>
<td>
<p>Integer scalar for precision of the values, obsolete for
backward compatibility.</p>
</td></tr>
<tr><td><code id="seqgsphh_+3A_method">method</code></td>
<td>
<p>&quot;Hochberg&quot; or &quot;Hommel&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements
</p>

<ul>
<li> <p><code>rejected</code>: the index set of rejected hypotheses
</p>
</li>
<li> <p><code>decisionsm</code>: rejection decision for each endpoint (row) at each timepoint
(column)
</p>
</li>
<li> <p><code>cumdecisionsm</code>: cumulative rejection decision for each endpoint (row) at
each timepoint (column)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pm &lt;- matrix(rep(c(0.03, 0.04, 0.01), times = 2), ncol = 3, nrow = 2)
seqgsphh(pm = pm, alpha = 0.025, method = "Hochberg")
seqgsphh(pm = pm, alpha = 0.025, method = "Hommel")
</code></pre>

<hr>
<h2 id='seqmbgx'>Maurer-Bretz sequential graphical approach</h2><span id='topic+seqmbgx'></span>

<h3>Description</h3>

<p><code>seqmbgx()</code> conducts group-sequential testing for multiple hypotheses based
on Maurer-Bretz approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqmbgx(
  xm = qnorm(matrix(rep(c(0.03, 0.04, 0.01), times = 4), ncol = 3, nrow = 4)),
  informationm = matrix(rep(c(0.4, 0.8, 1), each = 4), ncol = 3, nrow = 4),
  spending = rep("OBF", 4),
  param.spending = rep(1, 4),
  alpha = 0.025,
  sided = -1,
  W = c(0.5, 0.5, 0, 0),
  G = rbind(c(0, 0, 1, 0), c(0, 0, 0, 1), c(0, 1, 0, 0), c(1, 0, 0, 0)),
  tol = 1e-10,
  retrospective = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqmbgx_+3A_xm">xm</code></td>
<td>
<p>Numeric matrix of test statistics for each endpoint (in row) and
each time point (in column).</p>
</td></tr>
<tr><td><code id="seqmbgx_+3A_informationm">informationm</code></td>
<td>
<p>Numeric matrix of information fractions for the
statistics <code>xm</code>.</p>
</td></tr>
<tr><td><code id="seqmbgx_+3A_spending">spending</code></td>
<td>
<p>Character vector for the type(s) of the spending function for
each endpoint.</p>
</td></tr>
<tr><td><code id="seqmbgx_+3A_param.spending">param.spending</code></td>
<td>
<p>parameter in the spending function</p>
</td></tr>
<tr><td><code id="seqmbgx_+3A_alpha">alpha</code></td>
<td>
<p>overall family-wise error rate</p>
</td></tr>
<tr><td><code id="seqmbgx_+3A_sided">sided</code></td>
<td>
<p>Integer scalar indicating the side of the test:
</p>

<ul>
<li> <p><code>-1</code>: Reject if test statistic is smaller than or equal to the critical value (one-sided)
</p>
</li>
<li> <p><code>1</code>: Reject if test statistic is greater or equal to the critical value (one-sided)
</p>
</li>
<li> <p><code>0</code>: Reject if the absolute value of the test statistic is greater than the critical value (two-sided)
</p>
</li></ul>
</td></tr>
<tr><td><code id="seqmbgx_+3A_w">W</code></td>
<td>
<p>Numeric vector of the weights of the graph.</p>
</td></tr>
<tr><td><code id="seqmbgx_+3A_g">G</code></td>
<td>
<p>Numeric transition matrix of the graph.</p>
</td></tr>
<tr><td><code id="seqmbgx_+3A_tol">tol</code></td>
<td>
<p>Numeric scalar of tolerance level for computing the critical
values.</p>
</td></tr>
<tr><td><code id="seqmbgx_+3A_retrospective">retrospective</code></td>
<td>
<p>Integer scalar with the following potential values
</p>

<ul>
<li> <p><code>0</code>: (default) only compares the current test statistic with the updated
critical value;
</p>
</li>
<li> <p><code>1</code>: compares all the test statistics up to the current one with the updated
critical values.
</p>
</li></ul>

<p>Even though retrospectively looking at the values is statistically valid
in terms of control the type-1 error, not retrospectively looking at the
past comparisons avoids the dilemma of retrospectively increasing the alpha
level for the un-rejected hypothesis in the past.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements
</p>

<ul>
<li> <p><code>Hrej</code>: rejected hypotheses
</p>
</li>
<li> <p><code>rejected</code>: the index set of rejected hypotheses
</p>
</li>
<li> <p><code>decisionsm</code>: rejection decision for each endpoint (row) at each timepoint (column)
</p>
</li>
<li> <p><code>cumdecisionsm</code>: cumulative rejection decision for each endpoint (row) at
each timepoint (column)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seqmbgx(
  xm = qnorm(matrix(rep(c(0.03, 0.04, 0.01), times = 4), ncol = 3, nrow = 4)),
  informationm = matrix(rep(c(0.4, 0.8, 1), each = 4), ncol = 3, nrow = 4),
  spending = rep("OBF", 4),
  param.spending = rep(1, 4),
  alpha = 0.025,
  W = c(0.5, 0.5, 0, 0),
  G = rbind(c(0, 0, 1, 0), c(0, 0, 0, 1), c(0, 1, 0, 0), c(1, 0, 0, 0)),
  retrospective = 0
)
</code></pre>

<hr>
<h2 id='seqqvalhh'>Sequential generalized Hochberg and Hommel procedures based on q-values</h2><span id='topic+seqqvalhh'></span>

<h3>Description</h3>

<p>Sequential generalized Hochberg and Hommel procedures based on q-values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqqvalhh(
  pm = matrix(rep(c(0.03, 0.04, 0.01), times = 2), ncol = 3, nrow = 2),
  alpham = matrix(rep(c(0.02, 0.03, 0.05), each = 2), ncol = 3, nrow = 2),
  epsilon = 1e-10,
  precision = 10,
  method = "Hochberg"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqqvalhh_+3A_pm">pm</code></td>
<td>
<p>Matrix of group-sequential p-values for different hypotheses (in row)
at different times (in column).</p>
</td></tr>
<tr><td><code id="seqqvalhh_+3A_alpham">alpham</code></td>
<td>
<p>Matrix of alpha spending corresponding to the p-values <code>pm</code>.
For each row, alpha levels must be non-decreasing.</p>
</td></tr>
<tr><td><code id="seqqvalhh_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric scalar indicating the lower bound for alpha.</p>
</td></tr>
<tr><td><code id="seqqvalhh_+3A_precision">precision</code></td>
<td>
<p>Integer scalar for precision of the values, obsolete for
backward compatibility.</p>
</td></tr>
<tr><td><code id="seqqvalhh_+3A_method">method</code></td>
<td>
<p>Character scalar &quot;Hochberg&quot; or &quot;Hommel&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements
</p>

<ul>
<li> <p><code>rejected</code>: the index set of rejected hypotheses
</p>
</li>
<li> <p><code>decisionsm</code>: rejection decision for each endpoint (row) at each
timepoint (column)
</p>
</li>
<li> <p><code>cumdecisionsm</code>: cumulative rejection decision for each endpoint (row) at
each timepoint (column);
</p>
</li>
<li> <p><code>alphaused</code>: alpha levels actually used for each endpoint (row) at each
timepoint (column).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pm &lt;- matrix(rep(c(0.03, 0.04, 0.01), times = 2), ncol = 3, nrow = 2)
alpham &lt;- matrix(rep(c(0.02, 0.03, 0.05), each = 2), ncol = 3, nrow = 2)
seqqvalhh(pm = pm, alpham = alpham, method = "Hochberg")
seqqvalhh(pm = pm, alpham = alpham, method = "Hommel")
</code></pre>

<hr>
<h2 id='spendingfun'>Calculate alpha spending function</h2><span id='topic+spendingfun'></span>

<h3>Description</h3>

<p><code>spendingfun()</code> calculates the alpha spending function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spendingfun(alpha, fractions = seq(0.2, 1, by = 0.2), family = "OBF", rho = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spendingfun_+3A_alpha">alpha</code></td>
<td>
<p>Numeric scalar of the overall alpha to be spent.</p>
</td></tr>
<tr><td><code id="spendingfun_+3A_fractions">fractions</code></td>
<td>
<p>Numeric vector of the sequence of  information fractions.
All elements should be between 0 and 1 with the last one being exactly 1.</p>
</td></tr>
<tr><td><code id="spendingfun_+3A_family">family</code></td>
<td>
<p>Character scalar for the family of spending functions, one of
<code>"OBF"</code>, <code>"pocock"</code>, <code>"power"</code>.</p>
</td></tr>
<tr><td><code id="spendingfun_+3A_rho">rho</code></td>
<td>
<p>Numeric scalar of auxiliary parameter for O'Brien-Fleming and
power family.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>"OBF"</code>: O'Brien-Fleming family; <code class="reqn">2\{1-\Phi(\Phi^{-1}(1-\alpha/2)/t^{\rho/2})\}</code>;
</p>
</li>
<li> <p><code>"pocock"</code>: Pocock family; <code class="reqn">\alpha \log\{1+(e-1)*t\}</code>;
</p>
</li>
<li> <p><code>"power"</code>: Power family; <code class="reqn">\alpha*t^{\rho}</code>
</p>
</li></ul>

<p>Note that the OBF and Pocock spending functions are not the originally
proposed ones, they are the modified ones that closely resemble the original
versions. That being said, you might still see some differences.
</p>


<h3>Value</h3>

<p>List with an element named <code>aseq</code> for the alpha spending sequence.
</p>


<h3>Author(s)</h3>

<p>Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spendingfun(
  alpha = 0.025,
  fractions = seq(0.2, 1, by = 0.2),
  family = "OBF",
  rho = 1
)
</code></pre>

<hr>
<h2 id='updategraph'>Update graph</h2><span id='topic+updategraph'></span>

<h3>Description</h3>

<p><code>updategraph()</code> updates the graph when only a subset of original hypotheses
is concerned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updategraph(
  S1 = c(2, 3),
  W0 = c(0.5, 0.5, 0, 0),
  G0 = rbind(c(0, 0, 1, 0), c(0, 0, 0, 1), c(0, 1, 0, 0), c(1, 0, 0, 0)),
  S0 = seq(1, length(W0), by = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updategraph_+3A_s1">S1</code></td>
<td>
<p>Integer indices of the subset of hypotheses, S1 must be a non-empty
subset of <code>S0</code> and must be sorted increasingly.</p>
</td></tr>
<tr><td><code id="updategraph_+3A_w0">W0</code></td>
<td>
<p>Numeric vector for the initial weights of the graph.</p>
</td></tr>
<tr><td><code id="updategraph_+3A_g0">G0</code></td>
<td>
<p>Numeric matrix of dimesion <code>length(W0)</code> by <code>length(W0)</code> for the
initial transition matrix of the graph.</p>
</td></tr>
<tr><td><code id="updategraph_+3A_s0">S0</code></td>
<td>
<p>Integer indices for the set of hypotheses from 1 to length of <code>W0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following elements
</p>

<ul>
<li> <p><code>S1</code>: Integer indices the same as the input <code>S1</code>.
</p>
</li>
<li> <p><code>W1</code>: Numeric vector for weights of the updated graph.
</p>
</li>
<li> <p><code>G1</code>: Numeric transition of the updated graph.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Xiaodong Luo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## We can use the function to produce a closed testing tree
## A function to create power set
powerset &lt;- function(x) {
  sets &lt;- lapply(1:(length(x)), function(i) combn(x, i, simplify = FALSE))
  unlist(sets, recursive = FALSE)
}

n &lt;- 3    # number of hypotheses
pn &lt;- 2^n-1
pset &lt;- powerset(seq(1, n, by = 1))    # create the power set
df &lt;- data.frame(matrix(ncol = 1+n, nrow = 0))    # create the dataset
colnames(df) &lt;- c("Test", paste0("H", seq(1, n, by = 1), sep = ""))

W0 &lt;- c(1/3, 1/3, 1/3)    # the weights of the graph
m &lt;- rbind(H1 = c(0, 1/2, 1/2),
           H2 = c(1/2, 0, 1/2),
           H3 = c(1/2, 1/2, 0))
G0 &lt;- matrix(m, nrow = 3, ncol = 3)    # the transition matrix of the graph

for (j in 1:pn){
    abc &lt;- updategraph(S1 = pset[[j]], W0 = W0, G0 = G0)
    temp &lt;- rep("-", n)
    temp[pset[[j]]] &lt;- abc$W1
    temp &lt;- c(paste(pset[[j]], collapse = ""), temp)
    df[j, ] &lt;- temp
}
df    # the dataframe lists the closed testing tree
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
