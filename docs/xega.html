<!DOCTYPE html><html><head><title>Help for package xega</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xega}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#booleanGrammar'><p>A constant function with a boolean grammar.</p></a></li>
<li><a href='#compileBNF'><p>Compile a BNF.</p></a></li>
<li><a href='#lau15'><p>The problem environment lau15</p></a></li>
<li><a href='#NewEnvXOR'><p>Generate the problem environment EnvXOR</p></a></li>
<li><a href='#Parabola2D'><p>Problem environment for a 2-dimensional quadratic parabola</p></a></li>
<li><a href='#Parabola2DEarly'><p>Problem environment for a 2-dimensional quadratic parabola.</p></a></li>
<li><a href='#sgXCrossoverFactory'><p>Factory for configuring a gene dependent Crossover function.</p></a></li>
<li><a href='#sgXDecodeGeneFactory'><p>Factory for configuring a gene dependent DecodeGene function.</p></a></li>
<li><a href='#sgXGeneMapFactory'><p>Factory for configuring a gene dependent geneMap function.</p></a></li>
<li><a href='#sgXInitGeneFactory'><p>Factory for configuring a gene dependent InitGene function.</p></a></li>
<li><a href='#sgXMutationFactory'><p>Factory for configuring a gene dependent Mutation function.</p></a></li>
<li><a href='#sgXReplicationFactory'><p>Factory for configuring a gene dependent Replication function.</p></a></li>
<li><a href='#xega'><p>Package xega</p></a></li>
<li><a href='#xegaReRun'><p>Run an evolutionary or genetic algorithm</p>
with the same configuration as in the previous run.</a></li>
<li><a href='#xegaRun'><p>Run an evolutionary or genetic algorithm for a problem environment</p>
which contains a function to optimize.</a></li>
<li><a href='#xegaVersion'><p>About this version.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Extended Evolutionary and Genetic Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>
        Implementation of a scalable, highly configurable, and 
        e(x)tended architecture for (e)volutionary and (g)enetic (a)lgorithms.
        Multiple representations (binary, real-coded, permutation, and 
        derivation-tree), a rich collection of genetic operators, 
        as well as an extended processing pipeline are provided 
        for genetic algorithms (Goldberg, D. E. (1989, ISBN:0-201-15767-5)),
        differential evolution (Price, Kenneth V., Storn, Rainer M. and Lampinen, Jouni A. (2005)
        &lt;<a href="https://doi.org/10.1007%2F3-540-31306-0">doi:10.1007/3-540-31306-0</a>&gt;), simulated annealing (Aarts, E., and Korst, J.
        (1989, ISBN:0-471-92146-7)), grammar-based genetic programming 
        (Geyer-Schulz (1997, ISBN:978-3-7908-0830-X)), and grammatical evolution 
        (Ryan, C., O'Neill, M., and Collins, J. J. (2018) &lt;<a href="https://doi.org/10.1007%2F978-3-319-78717-6">doi:10.1007/978-3-319-78717-6</a>&gt;).
        All algorithms reuse basic adaptive mechanisms for performance optimization.
        Sequential or parallel execution (on multi-core machines, 
        local clusters, and high performance computing environments) 
        is available for all algorithms. See 
        <a href="https://github.com/ageyerschulz/xega/tree/main/examples/executionModel">https://github.com/ageyerschulz/xega/tree/main/examples/executionModel</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://github.com/ageyerschulz/xega&amp;gt;">https://github.com/ageyerschulz/xega&gt;</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), parallelly</td>
</tr>
<tr>
<td>Imports:</td>
<td>xegaSelectGene, xegaBNF, xegaDerivationTrees, xegaGaGene,
xegaGpGene, xegaGeGene, xegaDfGene, xegaPermGene,
xegaPopulation</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-19 10:25:55 UTC; dj2333</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Geyer-Schulz
    <a href="https://orcid.org/0009-0000-5237-3579"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Geyer-Schulz &lt;Andreas.Geyer-Schulz@kit.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-20 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='booleanGrammar'>A constant function with a boolean grammar.</h2><span id='topic+booleanGrammar'></span>

<h3>Description</h3>

<p>For the distribution of examples of BNF in grammars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>booleanGrammar()
</code></pre>


<h3>Details</h3>

<p>Imported from package xegaBNF for use in examples.
</p>


<h3>Value</h3>

<p>A named list with $filename and  $BNF,
the grammar of a boolean grammar with two variables.
</p>


<h3>See Also</h3>

<p>Other Grammar: 
<code><a href="#topic+compileBNF">compileBNF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>booleanGrammar()
</code></pre>

<hr>
<h2 id='compileBNF'>Compile a BNF.</h2><span id='topic+compileBNF'></span>

<h3>Description</h3>

<p><code>compileBNF()</code> produces a context-free grammar
from its specification of in Backus-Naur form (BNF).
Warning: No error checking implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compileBNF(g, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compileBNF_+3A_g">g</code></td>
<td>
<p>A character string with a BNF.</p>
</td></tr>
<tr><td><code id="compileBNF_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. TRUE: Show progress. Default: FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A grammar consists of the symbol table <code>ST</code>, the production
table <code>PT</code>, the start symbol <code>Start</code>,
and the short production
table <code>SPT</code>. An example BNF is provided 
by <code>booleanGrammar()</code>.
</p>
<p>The function performs the following steps:
</p>

<ol>
<li><p> Make the symbol table. 
</p>
</li>
<li><p> Make the production table.
</p>
</li>
<li><p> Extract the start symbol.
</p>
</li>
<li><p> Compile a short production table.
</p>
</li>
<li><p> Return the grammar.</p>
</li></ol>

<p>For a full documentation, see &lt;https://CRAN.R-project.org/package=xegaBNF&gt;
</p>


<h3>Value</h3>

<p>A grammar object (list) with the attributes
<code>name</code> (the filename of the grammar),
<code>ST</code> (symbol table),
<code>PT</code> (production table),
<code>Start</code> (the start symbol of the grammar),
and <code>SPT</code> (the short production table).
</p>


<h3>See Also</h3>

<p>Other Grammar: 
<code><a href="#topic+booleanGrammar">booleanGrammar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
g$ST
g$PT
g$Start
g$SPT
</code></pre>

<hr>
<h2 id='lau15'>The problem environment lau15</h2><span id='topic+lau15'></span>

<h3>Description</h3>

<p>15 abstract cities for which a traveling salesman solution is sought.
Solution: A path with a length of 291.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lau15
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 12.
</p>


<h3>References</h3>

<p>Lau, H. T. (1986):
<em>Combinatorial Heuristic Algorithms in FORTRAN</em>.
Springer, 1986.
&lt;doi:10.1007/978-3-642-61649-5&gt;
</p>


<h3>See Also</h3>

<p>Other Problem Environment: 
<code><a href="#topic+NewEnvXOR">NewEnvXOR</a>()</code>,
<code><a href="#topic+Parabola2DEarly">Parabola2DEarly</a></code>,
<code><a href="#topic+Parabola2D">Parabola2D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>names(lau15)
lau15$genelength()
</code></pre>

<hr>
<h2 id='NewEnvXOR'>Generate the problem environment EnvXOR</h2><span id='topic+NewEnvXOR'></span>

<h3>Description</h3>

<p><code>NewEnvXOR()</code> generates the problem environment
for the XOR-Problem.
</p>
<p>The problem environment provides an abstract interface
to the simple genetic programming algorithm.
<code>ProblemEnv$f(parm)</code> defines the function we want to optimize.
</p>
<p>A problem environment is a function factory with the following
elements:
</p>

<ol>
<li>
<p><code>name()</code>   a string with the name of the environment
</p>
</li>
<li>
<p><code>ProblemEnv$f(word)</code>
function with word a word of the language (as text string).
</p>
</li></ol>

<p>Should be provided by the user as standard R-file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewEnvXOR()
</code></pre>


<h3>Value</h3>

<p>The problem environment:
</p>

<ul>
<li> <p><code>$name</code>: The name of the problem environment.
</p>
</li>
<li> <p><code>$f</code>:    The fitness function. 
For this environment number of correct test cases 
(correct function)
and the inverse of the number of terminal symbols
(boolean function with small number of elements). 
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Problem Environment: 
<code><a href="#topic+Parabola2DEarly">Parabola2DEarly</a></code>,
<code><a href="#topic+Parabola2D">Parabola2D</a></code>,
<code><a href="#topic+lau15">lau15</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EnvXOR&lt;-NewEnvXOR()
EnvXOR$name()
a2&lt;-"OR(OR(D1, D2), (AND(NOT(D1), NOT(D2))))"
a3&lt;-"OR(OR(D1, D2), AND(D1, D2))"
a4&lt;-"AND(OR(D1,D2),NOT(AND(D1,D2)))"
gp4&lt;-"(AND(AND(OR(D2,D1),NOT(AND(D1,D2))),(OR(D2,D1))))"
EnvXOR$f(a2)
EnvXOR$f(a3)
EnvXOR$f(a4)
EnvXOR$f(gp4)

</code></pre>

<hr>
<h2 id='Parabola2D'>Problem environment for a 2-dimensional quadratic parabola</h2><span id='topic+Parabola2D'></span>

<h3>Description</h3>

<p>Problem environment for finding maxima and minima
of a 2-dimensional quadratic parabola.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Parabola2D
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 8.
</p>


<h3>Value</h3>

<p>A named list 
</p>

<ul>
<li> <p><code>$name()</code>: Returns the name of the problem environment.
</p>
</li>
<li> <p><code>$bitlength()</code>: The vector of the 
bitlengths of the parameters.  
</p>
</li>
<li> <p><code>$genelength()</code>: The number of bits of a gene.  
</p>
</li>
<li> <p><code>$lb()</code>:         The vector of lower bounds 
of the parameters. 
</p>
</li>
<li> <p><code>$ub()</code>:  The vector of upper bounds of the parameters. 
</p>
</li>
<li> <p><code>$f(parm)</code>:   The implementation of the function of the
quadratic parabola. 
</p>

<ul>
<li> <p><code>parm</code>:  A 2-element vector of reals.
</p>
</li>
<li><p> Returns the value of the function.
</p>
</li></ul>

</li>
<li> <p><code>$describe()</code>:   Returns the description of 
the problem environment.
</p>
</li>
<li> <p><code>$solution()</code>:   The solutions (maxima/minima) of the 
problem environment (if known). 
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Problem Environment: 
<code><a href="#topic+NewEnvXOR">NewEnvXOR</a>()</code>,
<code><a href="#topic+Parabola2DEarly">Parabola2DEarly</a></code>,
<code><a href="#topic+lau15">lau15</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>names(Parabola2D)
Parabola2D$name()
Parabola2D$describe()
Parabola2D$bitlength()
Parabola2D$genelength()
Parabola2D$lb()
Parabola2D$ub()
Parabola2D$f
Parabola2D$f(c(2.2, -1.37))
Parabola2D$solution()
Parabola2D$solution()$minimum
Parabola2D$solution()$minpoints
Parabola2D$solution()$maximum
Parabola2D$solution()$maxpoints
</code></pre>

<hr>
<h2 id='Parabola2DEarly'>Problem environment for a 2-dimensional quadratic parabola.</h2><span id='topic+Parabola2DEarly'></span>

<h3>Description</h3>

<p>An example of a problem environment with an 
early termination condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Parabola2DEarly
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 9.
</p>


<h3>Value</h3>

<p>A problem environment (see <a href="#topic+Parabola2D">Parabola2D</a>).
<code>Parabola2DEarly$terminate(solution, lF)</code> 
is a test function which returns true if the <code>solution</code> 
is in an epsilon environment of a known solution. 
To invoke this function, use <code>Run( ..., early=TRUE, ...)</code>.
The epsilon which determines 
the length of the interval as a fraction
of the known optimal solution is configured by  
e.g. <code>Run( ..., terminationEps=0.001, ...)</code>.
</p>


<h3>See Also</h3>

<p>Other Problem Environment: 
<code><a href="#topic+NewEnvXOR">NewEnvXOR</a>()</code>,
<code><a href="#topic+Parabola2D">Parabola2D</a></code>,
<code><a href="#topic+lau15">lau15</a></code>
</p>

<hr>
<h2 id='sgXCrossoverFactory'>Factory for configuring a gene dependent Crossover function.</h2><span id='topic+sgXCrossoverFactory'></span>

<h3>Description</h3>

<p><code>sgXCrossoverFactory()</code> selects 
</p>

<ol>
<li><p> the algorithm specific crossover factory and 
</p>
</li>
<li><p> the method in this factory. 
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>sgXCrossoverFactory(algorithm = "sga", method = "CrossGene")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgXCrossoverFactory_+3A_algorithm">algorithm</code></td>
<td>
<p>Specifies algorithm. 
Available: &quot;sga&quot;, &quot;sgde&quot;, &quot;sgperm&quot;, &quot;sge&quot;, sgp&quot;. 
Default: &quot;sga&quot;.</p>
</td></tr>
<tr><td><code id="sgXCrossoverFactory_+3A_method">method</code></td>
<td>
<p>Crossover method.  Algorithm (gene representation) 
dependent. Default: <code>Crossgene()</code>. 
Must be available in the gene specific 
crossover factories.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available methods for each algorithm are: 
</p>

<ul>
<li><p> &quot;sga&quot;: 
&quot;Cross2Gene&quot;, &quot;UCross2Gene&quot;, &quot;UPCross2Gene&quot;,
&quot;CrossGene&quot;, &quot;UCrossGene&quot;, &quot;UPCrossGene&quot;.
</p>
</li>
<li><p> &quot;sge&quot;: 
&quot;Cross2Gene&quot;, &quot;UCross2Gene&quot;, &quot;UPCross2Gene&quot;,
&quot;CrossGene&quot;, &quot;UCrossGene&quot;, &quot;UPCrossGene&quot;.
</p>
</li>
<li><p> &quot;sgp&quot;: 
&quot;CrossGene&quot;, &quot;Cross2Gene&quot;.
</p>
</li>
<li><p> &quot;sgde&quot;: 
&quot;CrossGene&quot;, &quot;UCrossGene&quot;, &quot;UPCrossGene&quot;.
</p>
</li>
<li><p> &quot;sgperm&quot;: 
&quot;CrossGene&quot;, &quot;Cross2Gene&quot;.
</p>
</li></ul>



<h3>Value</h3>

<p>Crossover Crossover function from the crossover factory of 
the selected package.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+sgXDecodeGeneFactory">sgXDecodeGeneFactory</a>()</code>,
<code><a href="#topic+sgXGeneMapFactory">sgXGeneMapFactory</a>()</code>,
<code><a href="#topic+sgXInitGeneFactory">sgXInitGeneFactory</a>()</code>,
<code><a href="#topic+sgXMutationFactory">sgXMutationFactory</a>()</code>,
<code><a href="#topic+sgXReplicationFactory">sgXReplicationFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sgXCrossoverFactory(algorithm="sga", method="CrossGene")

</code></pre>

<hr>
<h2 id='sgXDecodeGeneFactory'>Factory for configuring a gene dependent DecodeGene function.</h2><span id='topic+sgXDecodeGeneFactory'></span>

<h3>Description</h3>

<p>A gene specific decoder must be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgXDecodeGeneFactory(algorithm = "sga", method = "DecodeGene")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgXDecodeGeneFactory_+3A_algorithm">algorithm</code></td>
<td>
<p>&quot;sga&quot;, &quot;sgde&quot;, &quot;sgperm&quot;, &quot;sge&quot;, sgp&quot;. Default: &quot;sga&quot;.</p>
</td></tr>
<tr><td><code id="sgXDecodeGeneFactory_+3A_method">method</code></td>
<td>
<p>Method. Default: &quot;DecodeGene&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Decode function for the selected algorithm from the correct package.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+sgXCrossoverFactory">sgXCrossoverFactory</a>()</code>,
<code><a href="#topic+sgXGeneMapFactory">sgXGeneMapFactory</a>()</code>,
<code><a href="#topic+sgXInitGeneFactory">sgXInitGeneFactory</a>()</code>,
<code><a href="#topic+sgXMutationFactory">sgXMutationFactory</a>()</code>,
<code><a href="#topic+sgXReplicationFactory">sgXReplicationFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sgXDecodeGeneFactory(algorithm="sgperm", method="DecodeGene")

</code></pre>

<hr>
<h2 id='sgXGeneMapFactory'>Factory for configuring a gene dependent geneMap function.</h2><span id='topic+sgXGeneMapFactory'></span>

<h3>Description</h3>

<p>The geneMap function depends on the gene representation and
the algorithm selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgXGeneMapFactory(algorithm = "sga", method = "Bin2Dec")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgXGeneMapFactory_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm. 
Available: &quot;sga&quot;, &quot;sgde&quot;, &quot;sgperm&quot;, &quot;sge&quot;, sgp&quot;. 
Default: &quot;sga&quot;.</p>
</td></tr>
<tr><td><code id="sgXGeneMapFactory_+3A_method">method</code></td>
<td>
<p>The GeneMap method. The choices depend on the 
<code>algorithm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods available for the different algorithms are:
</p>

<ul>
<li><p> &quot;sga&quot;: &quot;Bin2Dec&quot;, &quot;Gray2Dec&quot;, &quot;Identity&quot;, &quot;Permutation&quot;.
</p>
</li>
<li><p> &quot;sgde&quot;: &quot;Identity&quot;.
</p>
</li>
<li><p> &quot;sgperm&quot;: &quot;Identity&quot;. The gene map function is not used in 
the decoder.
</p>
</li>
<li><p> &quot;sgp&quot;: &quot;Identity&quot;. The gene map function is not used in 
the decoder.
</p>
</li>
<li><p> &quot;sge&quot;: &quot;Mod&quot; or &quot;Bucket&quot;.
</p>
</li></ul>



<h3>Value</h3>

<p>GeneMap function for the selected algorithm from the correct package.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+sgXCrossoverFactory">sgXCrossoverFactory</a>()</code>,
<code><a href="#topic+sgXDecodeGeneFactory">sgXDecodeGeneFactory</a>()</code>,
<code><a href="#topic+sgXInitGeneFactory">sgXInitGeneFactory</a>()</code>,
<code><a href="#topic+sgXMutationFactory">sgXMutationFactory</a>()</code>,
<code><a href="#topic+sgXReplicationFactory">sgXReplicationFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sgXGeneMapFactory(algorithm="sga", method="Bin2Dec")

</code></pre>

<hr>
<h2 id='sgXInitGeneFactory'>Factory for configuring a gene dependent InitGene function.</h2><span id='topic+sgXInitGeneFactory'></span>

<h3>Description</h3>

<p>Factory for configuring a gene dependent InitGene function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgXInitGeneFactory(algorithm = "sga", method = "InitGene")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgXInitGeneFactory_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm. 
Available: &quot;sga&quot;, &quot;sgde&quot;, &quot;sgperm&quot;, &quot;sge&quot;, sgp&quot;. 
Default: &quot;sga&quot;.</p>
</td></tr>
<tr><td><code id="sgXInitGeneFactory_+3A_method">method</code></td>
<td>
<p>Method. Default: &quot;InitGene&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>InitGene function from the correct package.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+sgXCrossoverFactory">sgXCrossoverFactory</a>()</code>,
<code><a href="#topic+sgXDecodeGeneFactory">sgXDecodeGeneFactory</a>()</code>,
<code><a href="#topic+sgXGeneMapFactory">sgXGeneMapFactory</a>()</code>,
<code><a href="#topic+sgXMutationFactory">sgXMutationFactory</a>()</code>,
<code><a href="#topic+sgXReplicationFactory">sgXReplicationFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sgXInitGeneFactory(algorithm="sgperm")

</code></pre>

<hr>
<h2 id='sgXMutationFactory'>Factory for configuring a gene dependent Mutation function.</h2><span id='topic+sgXMutationFactory'></span>

<h3>Description</h3>

<p><code>sgXMutationFactory()</code> selects 
</p>

<ol>
<li><p> the algorithm specific crossover factory and 
</p>
</li>
<li><p> the method in this factory. 
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>sgXMutationFactory(algorithm = "sga", method = "MutateGene")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgXMutationFactory_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm. 
Available: &quot;sga&quot;, &quot;sgde&quot;, &quot;sgperm&quot;, &quot;sge&quot;, sgp&quot;. 
Default: &quot;sga&quot;.</p>
</td></tr>
<tr><td><code id="sgXMutationFactory_+3A_method">method</code></td>
<td>
<p>Method. Available methods are package-dependent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available methods for each factory are:
</p>

<ul>
<li><p> &quot;sga&quot;: &quot;MutateGene&quot;, &quot;IVM&quot;.
</p>
</li>
<li><p> &quot;sge&quot;: &quot;MutateGene&quot;, &quot;IVM&quot;.
</p>
</li>
<li><p> &quot;sgp&quot;: &quot;MutateGene&quot;.
</p>
</li>
<li><p> &quot;sgde&quot;: &quot;MutateGeneDE&quot;.
</p>
</li>
<li><p> &quot;sgperm&quot;: &quot;MutateGeneOrderBased&quot;, 
&quot;MutateGenekInversion&quot;, &quot;MutateGene2Opt&quot;, &quot;MutateGenekOptLK&quot;,
&quot;MutateGeneGreedy&quot;, &quot;MutateGeneBestGreedy&quot;, &quot;MutateGeneMix&quot;.
</p>
</li></ul>



<h3>Value</h3>

<p>MutateGene Function for the selected  algorithm 
from the correct package.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+sgXCrossoverFactory">sgXCrossoverFactory</a>()</code>,
<code><a href="#topic+sgXDecodeGeneFactory">sgXDecodeGeneFactory</a>()</code>,
<code><a href="#topic+sgXGeneMapFactory">sgXGeneMapFactory</a>()</code>,
<code><a href="#topic+sgXInitGeneFactory">sgXInitGeneFactory</a>()</code>,
<code><a href="#topic+sgXReplicationFactory">sgXReplicationFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sgXMutationFactory(algorithm="sga", method="MutateGene")

</code></pre>

<hr>
<h2 id='sgXReplicationFactory'>Factory for configuring a gene dependent Replication function.</h2><span id='topic+sgXReplicationFactory'></span>

<h3>Description</h3>

<p>Factory for configuring a gene dependent Replication function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgXReplicationFactory(algorithm = "sga", method = "Kid1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgXReplicationFactory_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm. 
Available: &quot;sga&quot;, &quot;sgde&quot;, &quot;sgperm&quot;, &quot;sge&quot;, sgp&quot;. 
Default: &quot;sga&quot;.</p>
</td></tr>
<tr><td><code id="sgXReplicationFactory_+3A_method">method</code></td>
<td>
<p>Method. 
</p>
<p>Options are package-dependent:
</p>

<ul>
<li><p> &quot;sga&quot;, &quot;sgperm&quot;, &quot;sge&quot;, sgp&quot;: 
&quot;Kid1&quot;, &quot;Kid2&quot;.
</p>
</li>
<li><p> &quot;sgde&quot;: 
&quot;DE&quot;.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A replication function for the algorithm from the correct package.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+sgXCrossoverFactory">sgXCrossoverFactory</a>()</code>,
<code><a href="#topic+sgXDecodeGeneFactory">sgXDecodeGeneFactory</a>()</code>,
<code><a href="#topic+sgXGeneMapFactory">sgXGeneMapFactory</a>()</code>,
<code><a href="#topic+sgXInitGeneFactory">sgXInitGeneFactory</a>()</code>,
<code><a href="#topic+sgXMutationFactory">sgXMutationFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sgXReplicationFactory(algorithm="sgp", method="Kid1")

</code></pre>

<hr>
<h2 id='xega'>Package xega</h2><span id='topic+xega'></span>

<h3>Description</h3>

<p>The main program of the e(x)tended (e)volutionary and  (g)enetic (a)lgorithm
(xega) package.
</p>


<h3>Layers (in top-down direction)</h3>

 
<ol>
<li> <p><strong>Top-level main programs</strong>
(Package <code>xega</code>): 
<code>RunGA()</code>, <code>ReRun()</code>
</p>
</li>
<li> <p><strong>Population level operations - independent of representation</strong>
(Package <code>xegaPopulation</code>):
The population layer consists of functions for initializing,
logging, observing, evaluating a population of genes,
as well as of computing the next population.
</p>
</li>
<li> <p><strong>Gene level operations - representation-dependent</strong>.
</p>

<ol>
<li> 
<p><strong>Binary representation</strong> (Package <code>xegaGaGene</code>):
Initialization of random binary genes, 
several gene maps for binary genes, 
several mutation operators, 
several crossover operators with 1 and 2 kids, 
replication pipelines for 1 and 2 kids, 
and, last but not least, function factories for configuration. 
</p>
</li>
<li> <p><strong>Real-coded genes</strong> (Package <code>xegaDfGene</code>).
</p>
</li>
<li> <p><strong>Permutation genes</strong> (Package <code>xegaPermGene</code>).
</p>
</li>
<li> <p><strong>Derivation-tree genes</strong> (Package <code>xegaGpGene</code>).
</p>
</li>
<li> <p><strong>Binary genes with a grammar-driven decoder</strong>
(Package <code>xegaGeGene</code>). 
</p>
</li></ol>

</li>
<li> <p><strong>Gene level operations - independent of representation</strong>
(Package <code>selectGene</code>):
Functions for static and adaptive fitness scaling,  
gene selection, and gene evaluation
as well as for the measurement of performance and for configuration.
</p>
</li></ol>



<h3>Early Termination</h3>

<p>A problem environment may implement a function 
<code>terminate(solution)</code> which returns TRUE 
if the <code>solution</code> meets a condition for early 
termination.
</p>


<h3>Parallel and Distributed Execution</h3>

<p>Parallel and distributed execution is supported for
several combinations of hard- and software architectures
by overloading the <code>lapply()</code>-function used in the 
evaluation of a fitness function for a population of genes
with a parallel version with the abstract interface:
</p>
<p><code>parallelApply(pop, EvalGene, lF)</code>
</p>
<p>where <code>pop</code> is a list of genes, <code>EvalGene</code> the evaluation 
function for the fitness of a gene, and <code>lF</code> the local function
configuration of the algorithm.
</p>
<p>The several implementations of a <code>parallelApply()</code> function 
are provided. The implementations use
</p>

<ul>
<li><p> the function <code>parallel::mclapply()</code> for multicore 
parallelization by the fork mechanism of Unix-based operating systems 
on a single machine.
</p>
</li>
<li><p> the function <code>parallel::parLapply()</code> for socket connections
on a single or multiple machines on the Internet.
</p>
</li>
<li><p> the function <code>future.apply::future_lapply()</code> for 
asynchronous parallelization based on future packages.
</p>
</li></ul>

<p>In addition, user-defined parallel apply functions can be provided.
Example scripts for using the <code>Rmpi::mpi.parLapply()</code> function
of the <code>Rmpi</code> package are provided for a HPC environment with Slurm
as well as on a notebook.
</p>


<h3>The Architecture of the xegaX-Packages</h3>

<p>The xegaX-packages are a family of R-packages which implement 
e(x)tended (e)volutionary and (g)enetic (a)lgorithms (xega).  
The architecture has 3 layers, 
namely the user interface layer,
the population layer, and the gene layer: 
</p>

<ul>
<li>
<p>The user interface layer (package <code>xega</code>
&lt;https://CRAN.R-project.org/package=xega&gt; 
) provides a function call interface and configuration support
for several algorithms: genetic algorithms (sga), 
permutation-based genetic algorithms (sgPerm), 
derivation free algorithms as e.g. differential evolution (sgde), 
grammar-based genetic programming (sgp) and grammatical evolution
(sge). 
</p>
</li>
<li>
<p>The population layer (package <code>xegaPopulation</code>
&lt;https://CRAN.R-project.org/package=xegaPopulation&gt; 
) contains
population related functionality as well as support for 
population statistics dependent adaptive mechanisms and 
for parallelization.
</p>
</li>
<li> 
<p>The gene layer is split in a representation independent and 
a representation dependent part:
</p>

<ol>
<li> 
<p>The representation indendent part 
(package <code>xegaSelectGene</code>
&lt;https://CRAN.R-project.org/package=xegaSelectGene&gt; 
)
is responsible for variants of selection operators, evaluation 
strategies for genes, as well as profiling and timing capabilities.        
</p>
</li>
<li> 
<p>The representation dependent part consists of the following packages: 
</p>

<ul>
<li> <p><code>xegaGaGene</code> 
&lt;https://CRAN.R-project.org/package=xegaGaGene&gt; 
for binary coded genetic algorithms.
</p>
</li>
<li> <p><code>xegaPermGene</code> 
&lt;https://CRAN.R-project.org/package=xegaPermGene&gt; 
for permutation-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaDfGene</code> 
&lt;https://CRAN.R-project.org/package=xegaDfGene&gt; 
for derivation free algorithms as e.g. 
differential evolution.
</p>
</li>
<li> <p><code>xegaGpGene</code> 
&lt;https://CRAN.R-project.org/package=xegaGpGene&gt; 
for grammar-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaGeGene</code> 
&lt;https://CRAN.R-project.org/package=xegaGaGene&gt; 
for grammatical evolution algorithms.
</p>
</li></ul>

<p>The packages <code>xegaDerivationTrees</code> and <code>xegaBNF</code> support
the packages <code>xegaGpGene</code> and <code>xegaGeGene</code>:
</p>

<ul>
<li> <p><code>xegaBNF</code> 
&lt;https://CRAN.R-project.org/package=xegaBNF&gt; 
essentially provides a grammar compiler and
</p>
</li>
<li> 
<p><code>xegaDerivationTrees</code> 
&lt;https://CRAN.R-project.org/package=xegaDerivationTrees&gt; 
an abstract data type for derivation trees.
</p>
</li></ul>

</li></ol>
</li></ul>



<h3>Copyright</h3>

<p>(c) 2023 Andreas Geyer-Schulz
</p>


<h3>License</h3>

<p>MIT
</p>


<h3>URL</h3>

<p>https://github.com/ageyerschulz/xega
</p>


<h3>Installation</h3>

<p>From CRAN by <code>install.packages('xega')</code>
</p>


<h3>Author(s)</h3>

<p>Andreas Geyer-Schulz
</p>

<hr>
<h2 id='xegaReRun'>Run an evolutionary or genetic algorithm 
with the same configuration as in the previous run.</h2><span id='topic+xegaReRun'></span>

<h3>Description</h3>

<p><code>xegaReRun()</code> runs a simple genetic algorithm with 
the same configuration as in the run specified by the 
list element <code>$GAconfig</code> of the solution of 
a simple genetic algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaReRun(solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaReRun_+3A_solution">solution</code></td>
<td>
<p>The solution of a 
previous run of <code>xegaRun()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xegaReRun()</code> does not capture the configuration for 
parallel/distributed processing for the execution model
&quot;FutureApply&quot;, because the user defines the configuration
before calling <code>xegaRun()</code>. 
</p>
<p>If <code>executionModel</code> matches neither <code>"Sequential"</code> nor <code>"MultiCore"</code>
or <code>!is.null(uParApply)==TRUE</code>,   
a warning is printed, and the previous solution is returned.
</p>


<h3>Value</h3>

<p>A list of 
</p>

<ol>
<li>
<p><code>$popStat</code>: A matrix with 
mean, min, Q1, median, Q3, max, var, mad
of population fitness as columns:
i-th row for i-th each generation.
</p>
</li>
<li>
<p><code>$solution</code>: With fields 
<code>$solution$fitness</code>, 
<code>$solution$value</code>,  
<code>$solution$genotype</code>, and  
</p>
</li>
<li>
<p><code>$GAconfig</code>: The configuration of the GA used by <code>xegaReRun()</code>.
</p>
</li>
<li>
<p><code>$GAenv</code>:  Attribute value list of GAconfig.
</p>
</li>
<li> <p><code>$timer</code>: An attribute value list with 
the time used (in seconds) in the main blocks of the GA:
tUsed, tInit, tNext, tEval, tObserve, and tSummary.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other Main Program: 
<code><a href="#topic+xegaRun">xegaRun</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-xegaRun(Parabola2D, max=FALSE, algorithm="sga", generations=10, popsize=20, verbose=1)
b&lt;-xegaReRun(a)
seqApply&lt;-function(pop, EvalGene, lF) {lapply(pop, EvalGene, lF)}
c&lt;-xegaRun(Parabola2D, max=FALSE, algorithm="sga", uParApply=seqApply)
b&lt;-xegaReRun(c)

</code></pre>

<hr>
<h2 id='xegaRun'>Run an evolutionary or genetic algorithm for a problem environment 
which contains a function to optimize.</h2><span id='topic+xegaRun'></span>

<h3>Description</h3>

<p><code>Run</code> runs an evolutionary or genetic algorithm 
whose type is selected by <code>algorithm</code>. Available
algorithms are:
</p>

<ol>
<li> <p><code>"sga"</code>:    Genetic algorithm with binary genes.
</p>
</li>
<li> <p><code>"sgde"</code>:   Differential evolution with real genes.
</p>
</li>
<li> <p><code>"sgperm"</code>: Genetic algorithm with permutation genes. 
</p>
</li>
<li> <p><code>"sgp"</code>:    Grammar-based genetic programming with 
derivation-tree genes.
</p>
</li>
<li> <p><code>"sge"</code>:    Grammatical evolution (genetic algorithm 
with binary genes and a grammar-driven
decoder.
</p>
</li></ol>

<p>The choice of the algorithm determines the gene-dependent 
configuration options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaRun(
  penv,
  grammar = NULL,
  max = TRUE,
  algorithm = "sga",
  popsize = 100,
  generations = 20,
  crossrate = 0.2,
  mutrate = 1,
  elitist = TRUE,
  replay = 0,
  maxdepth = 7,
  maxtrials = 5,
  codons = 25,
  codonBits = 0,
  codonPrecision = "LCM",
  maxPBias = 0.01,
  evalmethod = "EvalGeneU",
  reportEvalErrors = TRUE,
  genemap = "Bin2Dec",
  crossrate2 = 0.3,
  ivcrossrate = "Const",
  crossover = "Cross2Gene",
  uCrossSwap = 0.2,
  mincrossdepth = 1,
  maxcrossdepth = 7,
  ivmutrate = "Const",
  mutrate2 = 1,
  bitmutrate = 0.005,
  bitmutrate2 = 0.01,
  maxmutdepth = 3,
  minmutinsertiondepth = 1,
  maxmutinsertiondepth = 7,
  lambda = 0.05,
  max2opt = 100,
  scalefactor1 = 0.9,
  scalefactor2 = 0.3,
  scalefactor = "Const",
  cutoffFit = 0.5,
  mutation = "MutateGene",
  replication = "Kid2",
  offset = 1,
  eps = 0.01,
  tournamentSize = 2,
  selectionBias = 1.5,
  maxTSR = 1.5,
  selection = "SUS",
  mateselection = "SUS",
  selectionContinuation = TRUE,
  scaling = "NoScaling",
  scalingThreshold = 0,
  scalingExp = 1,
  scalingExp2 = 1,
  rdmWeight = 1,
  drMax = 2,
  drMin = 0.5,
  dispersionMeasure = "var",
  scalingDelay = 1,
  accept = "All",
  alpha = 0.99,
  beta = 2,
  cooling = "ExponentialMultiplicative",
  coolingPower = 1,
  temp0 = 40,
  tempN = 0.01,
  verbose = 1,
  logevals = FALSE,
  allsolutions = FALSE,
  early = FALSE,
  terminationEps = 0.01,
  cores = NA,
  executionModel = "Sequential",
  uParApply = NULL,
  Cluster = NULL,
  profile = FALSE,
  batch = FALSE,
  path = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaRun_+3A_penv">penv</code></td>
<td>
<p>Problem environment.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_grammar">grammar</code></td>
<td>
<p>A compiled grammar object. Default: NULL.
Example: <code>compileBNF(booleanGrammar())</code></p>
</td></tr>
<tr><td><code id="xegaRun_+3A_max">max</code></td>
<td>
<p>If <code>TRUE</code> then Maximize! Default: TRUE.
Used in functions <code>EvalGeneDet</code>, <code>EvalGeneStoch</code>,
<code>EvalGeneU</code>, and <code>EvalGeneR</code> 
of package <code>xegaSelectGene</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_algorithm">algorithm</code></td>
<td>
<p>Specifies the algorithm class dependend 
on gene representation:
</p>

<ul>
<li><p> &quot;sga&quot;: Binary representation (Default).
</p>
</li>
<li><p> &quot;sgde&quot;: Real representation. 
E.g. Differential evolution.
</p>
</li>
<li><p> &quot;sgperm&quot;: Permutation representation.
</p>
</li>
<li><p> &quot;sge&quot;: Binary representation. 
Grammatical evolution.    
(Not yet variable length.)
</p>
</li>
<li><p> &quot;sgp&quot;: Derivation tree representation. 
Grammar Based Genetic Programming.
</p>
</li></ul>
</td></tr>
<tr><td><code id="xegaRun_+3A_popsize">popsize</code></td>
<td>
<p>Population size. Default: 100.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_generations">generations</code></td>
<td>
<p>Number of generations. Default: 20.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_crossrate">crossrate</code></td>
<td>
<p>Probability of applying crossover operator. Default: 0.20.
(Global parameter)</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_mutrate">mutrate</code></td>
<td>
<p>Probability of applying mutation operator. Default: 1.0.
(Global parameter)</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_elitist">elitist</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, 
then keep best solution in population.
Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_replay">replay</code></td>
<td>
<p>Integer. If <code>replay&gt;0</code> then use <code>replay</code> 
as seed of random number generator and  
store it for exact repetition of run.
Default: 0.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_maxdepth">maxdepth</code></td>
<td>
<p>The maximal depth of a derivation tree. Default: 7. (<code>"sgp"</code>).</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_maxtrials">maxtrials</code></td>
<td>
<p>Maximal number of trials of finding subtrees with same root symbol.
Default: 5. (<code>sgp</code>).</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_codons">codons</code></td>
<td>
<p>The maximal number of codons of derivations on a gene. 
Default: 25. (<code>"sge"</code>).</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_codonbits">codonBits</code></td>
<td>
<p>The number of bits of a codon.
Default: 0. (<code>"sge"</code>).</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_codonprecision">codonPrecision</code></td>
<td>
<p>Specify the method to set the number of bits of a
codon (<code>"sge"</code>):  
</p>

<ul>
<li><p> &quot;Min&quot;: Sufficient to code the maximal number 
of choices of production rules for 
a non-terminal.
</p>
</li>
<li><p> &quot;LCM&quot;: Contains the least common multiple 
of the prime factors of the number of 
choices of production rules for all 
non-terminals.
</p>
</li>
<li><p> &quot;MaxPBias&quot;: The computed precision guarantees
that the choice rule bias for a non-terminal
is below <code>maxPBias</code>. 
</p>
</li></ul>

<p>Argument of function factory 
<code>xegaGePrecisionFactory</code> in package <code>xegaGeGene</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_maxpbias">maxPBias</code></td>
<td>
<p>The threshold of the choice rule bias. 
Default: <code>0.01</code>. (<code>sge</code>&quot;).</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_evalmethod">evalmethod</code></td>
<td>
<p>Specifies the method of function evaluation:
</p>
 
<ul>
<li><p>  &quot;EvalGeneU&quot;: The function is always evaluated. (Default)
</p>
</li>
<li><p>  &quot;EvalGeneR&quot;: The function is always evaluated. 
Repairs of the gene by the decoder are 
possible.
</p>
</li>
<li><p>  &quot;Deterministic&quot;: The function is evaluated only once.
</p>
</li>
<li><p>  &quot;Stochastic&quot;: The expected function value and its 
variance are incrementally updated.
</p>
</li></ul>

<p>Argument of function factory 
<code>EvalGeneFactory</code> in package xegaSelectGene.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_reportevalerrors">reportEvalErrors</code></td>
<td>
<p>Report errors in the evaluation 
of fitness functions. Default: TRUE.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_genemap">genemap</code></td>
<td>
<p>Gene map for decoding. Default: &quot;Bin2Dec&quot;.
The default value works only for algorithm &quot;sga&quot;.
Used as <code>method</code> argument of the function factory
<code>sgXGeneMapFactory</code> of package <code>xega</code>.
</p>
<p>Available available options determined by 
<code>algorithm</code>:
</p>

<ul>
<li><p> &quot;sga&quot;: Binary representation (Default).
</p>

<ul>
<li><p> &quot;Bin2Dec&quot;: For real parameter vectors. 
</p>
</li>
<li><p> &quot;Gray2Dec&quot;: For real parameter vectors.
</p>
</li>
<li><p> &quot;Identity&quot;: For 0/1 parameter vectors.
</p>
</li>
<li><p> &quot;Permutation&quot;: For permutations.
</p>
</li></ul>

<p>See the function factory 
<code>xegaGaGeneMapFactory</code> in package <code>xegaGaGene</code>.
</p>
</li>
<li><p> &quot;sgp&quot;: Derivation tree. 
Gene map is not used, but must be specified.
We use <code>xegaGaGene::xegaGaGeneMapFactory</code> 
with <code>method="Identity"</code>.
</p>
</li>
<li><p> &quot;sge&quot;: Binary representation (Default).
How are genes decoded?
</p>

<ul>
<li><p> &quot;Mod&quot;: The modulo rule.
</p>
</li>
<li><p> &quot;Bucket&quot;: The bucket rule (with the mLCM). 
Problem: Mapping <code>1: 2^k</code> to <code>1:mLCMG</code>.
</p>
</li></ul>

<p>See the function factory 
<code>xegaGeGeneMapFactory</code> in package <code>xegaGeGene</code>.
</p>
</li>
<li><p> &quot;sgde&quot;: Real coded gene.
We use <code>xegaDfGene::xegaDfGeneMapFactory</code> 
with <code>method="Identity"</code>.
Function used: <code>xegaDfGene::xegaDfGeneMapIdentity</code>
</p>
</li>
<li><p> &quot;sgperm&quot;: Permutation gene.
Gene map is not used, but must be specified.
We use <code>xegaDfGene::xegaDfGeneMapFactory</code> 
with <code>method="Identity"</code>.
Function used: <code>xegaDfGene::xegaDfGeneMapIdentity</code>
</p>
</li></ul>
<p> # end of genemap</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_crossrate2">crossrate2</code></td>
<td>
<p>Crossover rate for genes with below 
&ldquo;average&rdquo; fitness. 
Probability of applying crossover operator 
for genes with a &ldquo;below average&rdquo; fitness.
Default: 0.30. 
(Global parameter)</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_ivcrossrate">ivcrossrate</code></td>
<td>
<p>Specifies the method of determining the crossover rate.
</p>

<ul>
<li> 
<p>&quot;Const&quot; Constant crossover rate. 
The probability of applying the crossover operator
is constant for the whole run of the algorithm.
Default: &quot;Const&quot;.
</p>
</li>
<li><p> &quot;IV&quot; Individually variable crossover rate.
The crossrate of a gene is determined by the following threshold
rule: 
If the fitness of the gene is higher than 
<code>lF$CutoffFit()*</code> <code>lF$CBestFitness()</code> then 
<code>lF$CrossRate1()</code> else <code>lF$CrossRate2()</code>
is used.
</p>
</li></ul>
 
<p>Argument of function factory 
<code>CrossRateFactory</code> in package <code>xegaPopulation</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_crossover">crossover</code></td>
<td>
<p>Crossover method. Default: &quot;CrossGene&quot;.
The choice of crossover methods depends on the 
setting of the argument <code>algorithm</code>.
Used as the <code>method</code> argument in function factory
<code>sgXCrossoverFactory</code> of package <code>xega</code>.
</p>

<ul>
<li> <p><code>algorithm="sga"</code>:
<code>crossover</code> is  argument of function factory 
<code>xegaGaCrossoverFactory</code> in package <code>xegaGaGene</code>.
</p>

<ul>
<li><p> Crossover operators with 1 kid:
</p>

<ul>
<li><p> &quot;CrossGene&quot;  one-point crossover. 
</p>
</li>
<li><p> &quot;UCrossGene&quot; uniform crossover.
</p>
</li>
<li><p> &quot;UPCrossgene&quot; parameterized uniform crossover.
Local parameter: <code>uCrossSwap</code>.
</p>
</li></ul>

</li>
<li><p> Crossover operators with 2 kids:
</p>

<ul>
<li><p> &quot;Cross2Gene&quot;  one-point crossover. 
</p>
</li>
<li><p> &quot;UCross2Gene&quot; uniform crossover.
</p>
</li>
<li><p> &quot;UPCross2gene&quot; parameterized uniform crossover.
Local parameter: <code>uCrossSwap</code>.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><code>algorithm="sgp"</code>:
<code>crossover</code> is  argument of function factory 
<code>xegaGpCrossoverFactory</code> in package <code>xegaGpGene</code>.
</p>

<ul>
<li><p> Crossover operators with 1 kid:
</p>

<ul>
<li><p> &quot;CrossGene&quot;  position based one-point crossover. 
</p>
</li></ul>

</li>
<li><p> Crossover operators with 2 kids:
</p>

<ul>
<li><p> &quot;Cross2Gene&quot; position based one-point crossover. 
</p>
</li></ul>

</li></ul>

</li>
<li> <p><code>algorithm="sge"</code>:
We use the factory <code>xegaGaCrossoverFactory</code>.
</p>
<p>(Adpatation needed for variable-length binary
representation.)
</p>
</li>
<li> <p><code>algorithm="sgde"</code>:
<code>crossover</code> is  argument of function factory 
<code>xegaDfCrossoverFactory</code> in package <code>xegaDfGene</code>.
</p>

<ul>
<li><p> Crossover operators with 1 kid:
</p>

<ul>
<li><p> &quot;CrossGene&quot;  one-point crossover  (of reals)
</p>
</li>
<li><p> &quot;UCrossGene&quot; uniform crossover  (of reals)
</p>
</li>
<li><p> &quot;UPCrossGene&quot; parametrized 
uniform crossover  (of reals).
Local parameter: <code>uCrossSwap</code>.
</p>
</li></ul>

</li>
<li><p> Crossover operators with 2 kids: Not implemented.
</p>
</li></ul>

</li>
<li> <p><code>algorithm="sgperm"</code>:
<code>crossover</code> is  argument of function factory 
<code>xegaPermCrossoverFactory</code> in package <code>xegaPermGene</code>.
</p>

<ul>
<li><p> Crossover operators with 1 kid:
</p>

<ul>
<li><p> &quot;CrossGene&quot;  position based one-point crossover. 
</p>
</li></ul>

</li>
<li><p> Crossover operators with 2 kids:
</p>

<ul>
<li><p> &quot;Cross2Gene&quot; position based one-point crossover. 
</p>
</li></ul>

</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="xegaRun_+3A_ucrossswap">uCrossSwap</code></td>
<td>
<p>The fraction of positions swapped in the
parametrized uniform crossover operator.
A local crossover parameter.
Default: 0.2. (<code>"sga"</code> and <code>"sgde"</code>). 
Used in packages <code>xegaGaGene</code> and <code>xegaDfGene</code>
for functions 
<code>xegaGaUPCross2Gene</code>,
<code>xegaDfUPCross2Gene</code>,
<code>xegaGaUPCrossGene</code>, and
<code>xegaDfUPCrossGene</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_mincrossdepth">mincrossdepth</code></td>
<td>
<p>minimal depth of exchange nodes (roots of subtrees
swapped by crossover). (<code>"sgp"</code>).</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_maxcrossdepth">maxcrossdepth</code></td>
<td>
<p>Maximal depth of exchange nodes (roots of subtrees
swapped by crossover). (<code>"sgp"</code>).
Used in package <code>xegaGpGene</code> functions 
<code>xegaGpCrossGene</code> and <code>xegaGpCross2Gene</code>
in package xegaGpGene.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_ivmutrate">ivmutrate</code></td>
<td>
<p>&quot;Const&quot; or &quot;IV&quot; (individually variable). 
Default: &quot;Const&quot;.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_mutrate2">mutrate2</code></td>
<td>
<p>Mutation rate. Default: 1.0.
(Global parameter).</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_bitmutrate">bitmutrate</code></td>
<td>
<p>Bit mutation rate. Default: 0.005.
A local mutation parameter. (<code>"sga"</code> and <code>"sge"</code>).
Used in package <code>xegaGaGene</code> functions 
<code>MutateGene</code>
<code>IVAdaptiveMutateGene</code></p>
</td></tr>
<tr><td><code id="xegaRun_+3A_bitmutrate2">bitmutrate2</code></td>
<td>
<p>Bit mutation rate for genes
with &ldquo;below average&rdquo; fitness. Default: 0.01.
A local mutation parameter. (<code>"sga"</code> and <code>"sge"</code>).
Used in package <code>xegaGaGene</code> functions 
<code>IVAdaptiveMutateGene</code></p>
</td></tr>
<tr><td><code id="xegaRun_+3A_maxmutdepth">maxmutdepth</code></td>
<td>
<p>Maximal depth of a derivation tree inserted 
by mutation. Default: 3. (<code>"sgp"</code>).</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_minmutinsertiondepth">minmutinsertiondepth</code></td>
<td>
<p>Minimal depth at which an insertion tree
is inserted. Default: 1. (<code>"sgp"</code>).</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_maxmutinsertiondepth">maxmutinsertiondepth</code></td>
<td>
<p>Maximal depth at which an insertion tree
is inserted. Default: 7. (<code>"sgp"</code>).
Used in package <code>xegaGpGene</code> function
<code>xegaGpMutateGene</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_lambda">lambda</code></td>
<td>
<p>Decay rate. Default: 0.05.
A local mutation parameter. (<code>"sgperm"</code>).
Used in package <code>xegaPermGene</code> function
<code>xegaPermMutateGenekInversion</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_max2opt">max2opt</code></td>
<td>
<p>Maximal number of trials to find
an improvement by a random edge exchange 
in a permutation. Default: <code>100</code>. (<code>"sgperm"</code>).
Used in package <code>xegaPermGene</code> function
<code>xegaPermMutateGene2Opt</code>.
and  <code>xegaPermMutateGeneOptLK</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_scalefactor1">scalefactor1</code></td>
<td>
<p>Scale factor for differential mutation operator (Default: 0.9). (<code>"sgde"</code>).</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_scalefactor2">scalefactor2</code></td>
<td>
<p>Scale factor for differential mutation operator (Default: 0.2). (<code>"sgde"</code>).</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_scalefactor">scalefactor</code></td>
<td>
<p>Method for setting scale factor (<code>"sgde"</code>):
</p>

<ul>
<li><p> &quot;Const&quot;:  constant scale factor. 
</p>
</li>
<li><p> &quot;Uniform&quot;: a random scale factor in 0.000001 to 1.0.
</p>
</li></ul>
</td></tr>
<tr><td><code id="xegaRun_+3A_cutofffit">cutoffFit</code></td>
<td>
<p>Cutoff for fitness.      Default: 0.5. (<code>"sga"</code> and <code>"sge"</code>).
Used in package <code>xegaGaGene</code> function
<code>IVAdaptiveMutateGene</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_mutation">mutation</code></td>
<td>
<p>Label specifies mutation method
dependend on <code>algorithm</code>. Default: &quot;MutateGene&quot;.
The (global) probability of calling a mutation method
is specified by <code>mutrate</code> and <code>mutrate2</code>.
Used as <code>method</code> argument of function factory 
<code>sgXMutationFactory</code> package <code>xega</code>. 
</p>

<ul>
<li> <p><code>algorithm="sga"</code>:
<code>mutation</code> is  argument of function factory 
<code>xegaGaMutationFactory</code> in package <code>xegaGaGene</code>.
</p>

<ul>
<li><p> &quot;MutateGene&quot;: Bitwise mutation. 
Local parameter: <code>bitmutrate</code>.
Function used: <code>xegaGaGene::xegaGaMutateGene</code>.
</p>
</li>
<li><p> &quot;IVM&quot;: Invividually variable mutation.
Intuitively we know that 
bad genes need higher mutation rates.
Good genes have a fitness which is 
above a threshold fitness. The threshold
is determined as a percentage of the 
current best fitness in the population.
The percentage is set by the parameter 
<code>cutoffFit</code>. 
Local parameters: <code>bitmutrate</code> for good genes.
<code>bitmutrate2</code> for bad genes.
<code>bitmutrate2</code> should be higher then 
<code>bitmutrate</code>.
</p>
</li></ul>

</li>
<li> <p><code>algorithm="sgp"</code>:
<code>mutation</code> is  argument of function factory 
<code>xegaGpMutationFactory</code> in package <code>xegaGpGene</code>.
</p>

<ul>
<li><p> &quot;MutateGene&quot;: Random insertion of 
a random derivation tree. 
Local parameter: <code>maxmutdepth</code>.
Function used: <code>xegaGpGene::xegaGpMutateGene</code>.
</p>
</li></ul>

</li>
<li> <p><code>algorithm="sge"</code>:
<code>mutation</code> is  argument of function factory 
<code>xegaGaMutationFactory</code>.
Nothing specific to grammatical evolution implemented.
</p>
</li>
<li> <p><code>algorithm="sgde"</code>:
<code>mutation</code> is  argument of function factory 
<code>xegaDfMutationFactory</code> in package <code>xegaDfGene</code>.
</p>

<ul>
<li><p> &quot;MutateGene&quot;: Add the scaled difference 
of the parameters of two randomly selected
to a gene.
Local parameters: Choice of function for 
<code>scalefactor</code> as well as
<code>scalefactor1</code>  
and <code>scalefactor2</code>.
Function used: <code>xegaDfGene::xegaDfMutateGeneDE</code>.
</p>
</li></ul>

</li>
<li> <p><code>algorithm="sgperm"</code>:
<code>mutation</code> is  argument of function factory 
<code>xegaPermMutationFactory</code> in package <code>xegaPermGene</code>.
</p>

<ul>
<li><p> &quot;MutateGene&quot;: 
Function used: <code>xegaPermGene::xegaPermMutateGeneOrderBased</code>.
</p>
</li>
<li><p> &quot;MutateGeneOrderBased&quot;: See &quot;MutateGene&quot;. 
</p>
</li>
<li><p> &quot;MutateGenekInversion&quot;: 
Function used: <code>xegaPermGene::xegaPermMutateGenekInversion</code>.
</p>
</li>
<li><p> &quot;MutateGene2Opt&quot;: 
Function used: <code>xegaPermGene::xegaPermMutateGene2Opt</code>.
</p>
</li>
<li><p> &quot;MutateGenekOptLK&quot;: 
Function used: <code>xegaPermGene::xegaPermMutateGenekOptLK</code>.
</p>
</li>
<li><p> &quot;MutateGeneGreedy&quot;: 
Function used: <code>xegaPermGene::xegaPermMutateGeneGreedy</code>.
</p>
</li>
<li><p> &quot;MutateGeneBestGreedy&quot;: 
Function used: <code>xegaPermGene::xegaPermMutateGeneBestGreedy</code>.
</p>
</li>
<li><p> &quot;MutateGeneMix&quot;: 
Function used: <code>xegaPermGene::xegaPermMutateMix</code>.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="xegaRun_+3A_replication">replication</code></td>
<td>
<p>&quot;Kid1&quot; or &quot;Kid2&quot;. Default: &quot;Kid1&quot;.
For algorithms &quot;sga&quot;, &quot;sgPerm&quot;, &quot;sgp&quot;, and &quot;sge&quot;:
&quot;Kid1&quot; means a crossover operator with one kid,
&quot;Kid2&quot; means a crossover operator with two kids.
</p>
<p>For algorithm &quot;sgde&quot;, <code>replication</code> must be 
set to &quot;DE&quot;.
</p>
<p>Used as the <code>method</code> argument of the 
function factory <code>sgXReplicationFactory</code> 
of package <code>xega</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_offset">offset</code></td>
<td>
<p>Offset used in proportional selection. Default: 1. 
Used in the following functions of package <code>xegaSelectGene</code>: 
<code>ScaleFitness</code>,
<code>PropFitOnLn</code>,
<code>PropFit</code>,
<code>PropFitM</code>,
<code>PropFitDiffOnLn</code>,
<code>PropFitDiff</code>,
<code>SUS</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_eps">eps</code></td>
<td>
<p>Epsilon in proportional 
fitness difference selection. Default: 0.01.
Used in package <code>xegaSelectGene</code> function
<code>PropFitDiffM</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_tournamentsize">tournamentSize</code></td>
<td>
<p>Tournament size. Default: 2. 
Used in package <code>xegaSelectGene</code> functions
<code>SelectTournament</code>,
<code>SelectSTournament</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_selectionbias">selectionBias</code></td>
<td>
<p>(&gt; 1.0). Controls selection pressure for 
Whitley's linear rank selection
with selective pressure. Default: 1.5. Near 1.0: almost
uniform selection.
Used in package <code>xegaSelectGene</code> function
<code>SelectLRSelective</code>,</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_maxtsr">maxTSR</code></td>
<td>
<p>Controls selection pressure for 
Grefenstette and Baker's linear rank selection 
method. Should be higher than 1.0 and lower equal 2.0.
Default: 1.5.
Used in package <code>xegaSelectGene</code> function
<code>SelectLinearRankTSR</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_selection">selection</code></td>
<td>
<p>Selection method for first parent of crossover. 
Default: &quot;SUS&quot;.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_mateselection">mateselection</code></td>
<td>
<p>Selection method for second parent of crossover. 
Default: &quot;SUS&quot;. 
</p>
<p>Available selection methods for selection method of a parent:
</p>

<ul>
<li><p> Uniform random selection: &quot;Uniform&quot;.
</p>
</li>
<li><p> Uniform random selection without replacement: &quot;UniformP&quot;.
</p>
</li>
<li><p> Proportional to fitness: 
&quot;ProportionalOnln&quot; (fastest), &quot;Proportional&quot;, &quot;ProportionalM&quot;,
</p>
</li>
<li><p> Proportional to fitness differences: 
&quot;PropFitDiffOnln&quot; (fastest), &quot;PropfitDiff&quot;, &quot;PropfitDiffM&quot;,
</p>
</li>
<li><p> Stochastic universal sampling: &quot;SUS&quot;, 
</p>
</li>
<li><p> Tournament selection: &quot;Duel&quot; (fastest), &quot;Tournament&quot;, &quot;STournament&quot;,  
</p>
</li>
<li><p> Rank selection: &quot;LRSelective&quot; (fastest), &quot;LRTSR&quot;.
</p>
</li></ul>

<p>Argument of function factory 
<code>SelectGeneFactory</code> in package <code>xegaSelectGene</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_selectioncontinuation">selectionContinuation</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, 
precomputes selection indices for next generation once and
transforms selection function to index lookup continuation.
Default: <code>TRUE</code>.
Used in package <code>xegaPopulation</code> function <code>xegaNextPopulation</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_scaling">scaling</code></td>
<td>
<p>Scaling method. Default: &quot;NoScaling&quot;.
Available scaling methods: 
</p>

<ul>
<li><p> &quot;NoScaling&quot;, 
</p>
</li>
<li><p> &quot;ConstantScaling&quot; (Static), 
</p>
</li>
<li><p> &quot;ThresholdScaling&quot; (Dynamic), 
</p>
</li>
<li><p> &quot;ContinuousScaling&quot; (Dynamic).
</p>
</li></ul>

<p>Argument of function factory 
<code>ScalingFactory</code> in package <code>xegaSelectGene</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_scalingthreshold">scalingThreshold</code></td>
<td>
<p>Numerical constant. Default: 0.0.
If  ratio of dispersion measures is in 
[(1-scalingThreshold), 1+scalingThreshold)], 
fitness is not scaled.
Used in package <code>xegaSelectGene</code> function
<code>ThresholdScaleFitness</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_scalingexp">scalingExp</code></td>
<td>
<p>Scaling exponent <code>k</code> in <code>fit^k</code>.
With &quot;ConstantScaling&quot;: 0 =&lt; k. 
With &quot;ThresholdScaling&quot;: 1 &lt; k. (Default: 1)
Used in package <code>xegaSelectGene</code>, functions
<code>ScalingFitness</code>,
<code>ThresholdScaleFitness</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_scalingexp2">scalingExp2</code></td>
<td>
<p>Scaling exponent 
for &quot;ThresholdScaling&quot;: 0 &lt;= k &lt;1. (Default:1)
Used in package <code>xegaSelectGene</code> function
<code>ThresholdScaleFitness</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_rdmweight">rdmWeight</code></td>
<td>
<p>Numerical constant. Default: 1.0. Weight of 
ratio of dispersion measures in continuous scaling.
Used in package <code>xegaSelectGene</code> function
<code>ContinuousScaleFitness</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_drmax">drMax</code></td>
<td>
<p>Maximal allowable dispersion ratio. Default: 2.0.
Used in package <code>xegaSelectGene</code> function
<code>DispersionRatio</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_drmin">drMin</code></td>
<td>
<p>Minimal allowable dispersion ratio. Default: 0.5.
Used in package <code>xegaSelectGene</code> function
<code>DispersionRatio</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_dispersionmeasure">dispersionMeasure</code></td>
<td>
<p>Dispersion measure used for computation of the
ratio of dispersion measures for dynamic scaling methods.
Default: &quot;var&quot;.
Available dispersion measures: 
&quot;var, &quot;std&quot;, &quot;mad&quot;, &quot;cv&quot;, &quot;range&quot;, &quot;iqr&quot;.
Argument of function factory 
<code>DispersionMeasureFactory</code> in package <code>xegaSelectGene</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_scalingdelay">scalingDelay</code></td>
<td>
<p>The ratio of dispersion measures compares the current
population dispersion at t with the population dispersion 
at t-scalingdelay. Default: 1.
Used in package <code>xegaSelectGene</code> function
<code>DispersionRatio</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_accept">accept</code></td>
<td>
<p>Acceptance rule for new gene. Default: &quot;All&quot;.
</p>

<ul>
<li><p> &quot;All&quot;  function <code>AcceptNewGene</code> 
</p>
</li>
<li><p> &quot;Best&quot;  function <code>AcceptBest</code> 
</p>
</li>
<li><p> &quot;Metropolis&quot; function <code>AcceptMetropolis</code>.
The behavior of this acceptance rule depends on:
</p>

<ol>
<li><p> The distance between the fitness values.
The larger the distance the larger the drop 
in acceptance probability.
</p>
</li>
<li> <p><code>alpha</code> is <code>1</code> minus the discount rate of the cooling
schedule. <code>alpha</code> is in <code>[0, 1]</code>.
The smaller <code>alpha</code> the faster the drop 
in temperatur and thus acceptance probability.
</p>
</li>
<li> <p><code>beta</code> a constant. The larger <code>beta</code>
the faster the drop in acceptance probability.
</p>
</li>
<li> <p><code>temperature</code> the starting value of the 
temperature. Must be higher than the number of 
generations.
</p>
</li></ol>

</li>
<li><p> &quot;IVMetropolis&quot; function <code>AcceptIVMetropolis</code>.
The behavior of this acceptance rule is qualitatively the same as that 
of the Metropolis acceptance rule above.
The acceptance rule is adaptive by a correction of the temperature
in proportion to the difference between the fitness of the current best and
the fitness of the gene considered.
</p>
</li></ul>

<p>Argument of function factory 
<code>AcceptFactory</code> in package <code>xegaPopulation</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_alpha">alpha</code></td>
<td>
<p><code>1</code> minus the  discount rate for temperature. (Default: 0.99).
(Used in cooling schedule at the end of main GA-loop.)</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_beta">beta</code></td>
<td>
<p>Constant in Metropolis acceptance rule. (Default: 2.0).
(Used in Metroplis acceptance rule.)</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_cooling">cooling</code></td>
<td>
<p>Cooling schedule for temperature. (Default: &quot;ExponentialMultiplicative&quot;)
</p>

<ul>
<li><p> &quot;ExponentialMultiplicative&quot; calls <code>ExponentialMultiplicativeCooling</code>
</p>
</li>
<li><p> &quot;LogarithmicMultiplicative&quot; calls <code>LogarithmicMultiplicativeCooling</code>
</p>
</li>
<li><p> &quot;PowerMultiplicative&quot; calls <code>PowerMultiplicativeCooling</code>
</p>
</li>
<li><p> &quot;PowerAdditive&quot; calls <code>PowerAdditiveCooling</code>
</p>
</li>
<li><p> &quot;ExponentialAdditive&quot; calls <code>ExponentialAdditiveCooling</code>
</p>
</li>
<li><p> &quot;TrigonometricAdditive&quot; calls <code>TrigonometricAdditiveCooling</code>
</p>
</li></ul>

<p>Argument of function factory 
<code>CoolingFactory</code> in package <code>xegaPopulation</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_coolingpower">coolingPower</code></td>
<td>
<p>Exponent for PowerMultiplicative cooling schedule. 
(Default: 1. This is called linear multiplicative cooling.)</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_temp0">temp0</code></td>
<td>
<p>Starting value of temperature (Default: 40).
(Used in Metroplis acceptance rule. Updated in cooling schedule.)</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_tempn">tempN</code></td>
<td>
<p>Final value of temperature (Default: 0.01).
(Used in Metroplis acceptance rule. Updated in cooling schedule.)</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_verbose">verbose</code></td>
<td>
<p>The value of <code>verbose</code> (Default: 1) controls the
information displayed:
</p>

<ol>
<li> <p><code>== 0</code>: Nothing is displayed.
</p>
</li>
<li> <p><code>== 1</code>: 1 point per generation.
</p>
</li>
<li> <p><code>&gt; 1</code>: Max(fit), number of solutions, indices.
</p>
</li>
<li> <p><code>&gt; 2</code>: and population fitness statistics.
</p>
</li>
<li> <p><code>&gt; 3</code>: and fitness, value of phenotype, 
and phenotype.
</p>
</li>
<li> <p><code>&gt; 4</code>: and str(genotype). 
</p>
</li></ol>
</td></tr>
<tr><td><code id="xegaRun_+3A_logevals">logevals</code></td>
<td>
<p>Boolean.
If <code>TRUE</code> then log all evaluations and their parameters 
in the file
<code>xegaEvalLog&lt;time stamp&gt;.rds</code>. Default: FALSE.
</p>
<p><code>log&lt;-readRDS(xegaEvalLog&lt;time stamp&gt;.rds)</code> reads the log.
The format of a row of <code>log</code> is &lt;fitness&gt; &lt;parameters&gt;.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_allsolutions">allsolutions</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, then return all best solutions.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_early">early</code></td>
<td>
<p>Boolean. If FALSE (Default), ignore code for 
early termination. 
See <a href="#topic+Parabola2DEarly">Parabola2DEarly</a>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_terminationeps">terminationEps</code></td>
<td>
<p>Fraction of known optimal solution
for computing termination interval. Default: 0.01
See <a href="#topic+Parabola2DEarly">Parabola2DEarly</a>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_cores">cores</code></td>
<td>
<p>Number of cores used for multi core parallel execution.
(Default: NA. NA means that the number of cores 
is set by <code>parallelly:availableCores()</code> 
if the execution model is &quot;MultiCore&quot;.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_executionmodel">executionModel</code></td>
<td>
<p>Execution model of fitness function evaluation.
Available:
</p>

<ul>
<li><p> &quot;Sequential&quot;: <code>base::lapply</code> is used.
</p>
</li>
<li><p> &quot;MultiCore&quot;:  <code>parallel::mclapply</code> is used.
</p>
</li>
<li><p> &quot;FutureApply&quot;:  
<code>future.apply::future_lapply</code> is used.
</p>
</li>
<li><p> &quot;Cluster&quot;:  Requires a proper configuration of the cluster.
</p>
</li></ul>

<p>Default: &quot;Sequential&quot;.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_uparapply">uParApply</code></td>
<td>
<p>A user defined parallel apply function
(e.g. for Rmpi). If specified, overrides 
settings for <code>executionModel</code>. 
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_cluster">Cluster</code></td>
<td>
<p>A cluster object generated by 
<code>parallel::makeCluster()</code> or
<code>parallelly::makeCluster()</code>.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_profile">profile</code></td>
<td>
<p>Boolean. 
If <code>TRUE</code> measures execution time and counts number of executions
to main components of genetic algorithms. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_batch">batch</code></td>
<td>
<p>Boolean.
If <code>TRUE</code> then save result in file
<code>xegaResult&lt;time stamp&gt;.rds</code>. Default: FALSE</p>
</td></tr>
<tr><td><code id="xegaRun_+3A_path">path</code></td>
<td>
<p>Path. Default: <code>""</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm expects a problem environment <code>penv</code> which is a 
named list with at least the following functions:
</p>

<ul>
<li> <p><code>$name()</code>:      The name of the problem environment.
</p>
</li>
<li> <p><code>$f(parm, gene=0, lF=0)</code>:   The function to optimize.
The parameters gene and lF are provided
for future extensions.
</p>
</li></ul>

<p>Additional parameters needed depend on the algorithm 
and the problem environment. 
For example, for binary genes for function optimization,    
additional elements must be provided:
</p>

<ul>
<li> <p><code>$bitlength()</code>: The vector of the 
bitlengths of the parameters.  
</p>
</li>
<li> <p><code>$genelength()</code>: The number of bits of a gene.  
</p>
</li>
<li> <p><code>$lb()</code>:         The vector of lower bounds 
of the parameters. 
</p>
</li>
<li> <p><code>$ub()</code>:  The vector of upper bounds of the parameters. 
</p>
</li></ul>



<h3>Value</h3>

<p>Result object. A named list of 
</p>

<ol>
<li>
<p><code>$popStat</code>: A matrix with mean, min, Q1, median, Q3, max,
variance, and median absolute deviation
of population fitness as columns:
i-th row for the measures of the i-th generation.
</p>
</li>
<li> 
<p><code>$fit</code>: Fitness vector if <code>generations&lt;=1</code> else: NULL.
</p>
</li>
<li>
<p><code>$solution</code>: Named list with fields 
</p>

<ul>
<li>
<p><code>$solution$name</code>:    Name of problem environment. 
</p>
</li>
<li>
<p><code>$solution$fitness</code>: Fitness value of the best solution.
</p>
</li>
<li>
<p><code>$solution$value</code>:   The evaluated best gene.
</p>
</li>
<li>
<p><code>$solution$numberofsolutions</code>: 
Number of solutions with the same fitness. 
</p>
</li>
<li>
<p><code>$solution$genotype</code>:     The gene a genetic code. 
</p>
</li>
<li>
<p><code>$solution$phenotype</code>:    The decoded gene.
</p>
</li>
<li>
<p><code>$solution$phenotypeValue</code>:   The   value of the
function of the parameters of the solution.
</p>
</li>
<li> 
<p><code>$solution$evalFail</code>: Number of failures or fitness evaluations
</p>
</li>
<li>
<p>and, if configured, 
<code>$solution$allgenotypes</code>, as well as 
<code>$solution$allphenotypes</code>.
</p>
</li></ul>

</li>
<li>
<p><code>$GAconfig</code>: For rerun with <code>xegaReRun()</code>.
</p>
</li>
<li>
<p><code>$GAenv</code>: Attribute value list of GAconfig.
</p>
</li>
<li> <p><code>$timer</code>: An attribute value list with 
the time used (in seconds) in the main blocks of the GA:
tUsed, tInit, tNext, tEval, tObserve, and tSummary.
</p>
</li></ol>



<h3>Problem Specification</h3>

<p>The problem specification consists of 
</p>
 
<ul>
<li> <p><code>penv</code>: The problem environment. 
</p>
</li>
<li> <p><code>max</code>:  Maximize? Boolean. Default: <code>TRUE</code>.
</p>
</li>
<li> <p><code>grammar</code>: A grammar object. For the algorithms <code>"sgp"</code> and <code>"sge"</code>.   
</p>
</li></ul>



<h3>Basic Parameters</h3>

<p>The main parameters of a &ldquo;standard&rdquo; genetic algorithm are:
</p>

<ul>
<li> <p><code>popsize</code>:     Population size.
</p>
</li>
<li> <p><code>generations</code>: Number of generations.
</p>
</li>
<li> <p><code>crossrate</code>:   Constant probability of one-point crossover.
</p>
</li>
<li> <p><code>mutrate</code>:     Constant probability of mutation.
</p>
</li></ul>

<p><code>crossrate</code> and <code>mutrate</code> specify the probability of 
applying the genetic operators crossover and mutation to a gene.
</p>
<p>Two more parameters are important:
</p>

<ul>
<li> <p><code>elitist</code>: Boolean. If <code>TRUE</code> (default), the fittest gene always survives.
</p>
</li>
<li> <p><code>replay</code>:  Integer. If <code>0</code> (default), a random seed of the random number generator is chosen.
For exact replications of a run of a genetic algorithm, set replay to a positive integer.
</p>
</li></ul>



<h3>Global and Local Parameters</h3>

<p>However, when using uniform crossover instead of one-point crossover, 
an additional parameter which specifies the probability of taking a bit 
from the first parent becomes necessary. 
Therefore, we distinguish between global and local operator parameters:
</p>

<ol>
<li><p> Global operator parameters: 
The probabilities of applying a crossover (<code>crossrate</code>) or 
a mutation operator (<code>mutrate</code>) to a gene.
</p>
</li>
<li><p> Local operator parameters: 
E.g. the per bit probability of mutation or the probability
of taking a bit from parent 1 for the uniform crossover operator.
Local operator parameters affect only 
the genetic operator which needs them.
</p>
</li></ol>

<p>There exist several advantages of this classification of parameters:
</p>

<ul>
<li><p> For the formal analysis of the behavior of the algorithms, 
we achieve a division in two parts: The equations of the 
global parameters with operator specific expressions as plug-ins. 
</p>
</li>
<li><p> For empirically finding parameterizations for problem classes, 
we propose to fix local parameters at reasonable values
(e.g. based on biological evidence) and 
and conditional on this optimize the (few) remaining global 
parameters.
</p>
</li>
<li><p> For parallelization specialized 
gene processing pipelines can be built and more efficiently executed, 
because the global parameters <code>crossrate</code> and <code>mutrate</code> decide 
which genes survive 
</p>

<ol>
<li><p> unchanged, 
</p>
</li>
<li><p> mutated, 
</p>
</li>
<li><p> crossed, and 
</p>
</li>
<li><p> crossed as well as mutated. 
</p>
</li></ol>
</li></ul>

<p>To mimic a classic genetic algorithm with crossover and bit mutation rate, 
the probability of applying the mutation operator to a gene 
should be set to <code>1</code>.
</p>


<h3>Global Adaptive Mechanisms</h3>

<p>The adaptive mechanisms described in the following are based on threshold
rules which determine how a parameter of the genetic operator is adapted.
The threshold conditions are based on population statistics: 
</p>
<p><strong>Adaptive Scaling.</strong> For adaptive scaling, select a dynamic scaling method,
e.g. <code>scaling="ThresholdScaling"</code>.
A high selection pressure decreases the dispersion in the population.
The parameter <code>scalingThreshold</code> is a numerical parameter which defines    
an interval from <code>1-scalingThreshold</code> to <code>1+scalingThreshold</code>:
</p>

<ol>
<li><p> If the RDM is in this interval, the fitness function is not scaled. 
</p>
</li>
<li><p> If the RDM is larger than the upper bound of the interval, 
the constant <code>scalingExp</code> which is higher than <code>1</code> is chosen for the scaling function.
This implements the rule: If the dispersion has increased, increase the selection pressure.  
</p>
</li>
<li><p> If the RDM is smaller than the lower bound of the interval, 
the constant <code>scalingExp2</code> which is smaller than <code>1</code> is chosen for the scaling function.
This implements the rule: If the dispersion has decreased, increase the selection pressure.  
</p>
</li></ol>

<p>The dispersion measure is computed as ratio of the dispersion measure at <code>t</code> relative to the 
dispersion measure at <code>t-scalingDelay</code>. 
The default dispersion measure is the variance of the population fitness (<code>dispersionMeasure="var"</code>). 
However, other dispersion measures (&quot;std&quot;, &quot;mad&quot;, &quot;cv&quot;, &quot;range&quot;, &quot;iqr&quot;) can be configured.  
</p>
<p>Another adaptive scaling method is continuous scaling (<code>scaling="ContinuousScaling"</code>).
The scaling exponent is adapted by a weighted ratio of dispersion measures. The weight 
of the exponent is set by <code>rdmWeight=1.1</code>, its default is <code>1.0</code>. Since the ratio 
of dispersion measures may be quite unstable, the default limits for the ratio are <code>drMin=0.5</code> 
and <code>drMax=2.0</code>. 
</p>
<p><strong>Individually Variable Mutation and Crossover Probabilities</strong>
</p>
<p>The rationale of individually variable mutation and crossover rates is that selected genes 
with a low fitness should be changed by a genetic operator with a higher probability. 
This increases the chance of survival of the gene because of the chance of a fitness increase through  
crossover or mutation.
</p>
<p>Select an adaptive genetic operator rate:
For the crossover rate, <code>ivcrossrate="IV"</code>. For the mutation rate, <code>ivmutrate="IV"</code>.
</p>
<p>If the fitness of a gene is higher than <code>cutoffFit</code> times the current best fitness, 
the crossover rate is <code>crossrate</code> else the crossover rate is <code>crossrate2</code>.
</p>
<p>If the fitness of a gene is higher than <code>cutoffFit</code> times the current best fitness, 
the mutation rate is <code>mutrate</code> else the mutation rate is <code>mutrate2</code>.
</p>


<h3>The Initialization of a Population</h3>

<p>For the algorithms &quot;sga&quot;, &quot;sgde&quot;, and &quot;sgperm&quot; the information needed for
initialization is the length of the gene in bits, in parameters, and in
the number of symbols of a permutation. 
For &quot;sgp&quot;, the depth bound gives an upper limit for the 
program which can be represented by a derivation tree.
For &quot;sge&quot;, a codon is an integer for selecting a production rule.
The number of bits of a genes is <code>codons*codonBits</code>. 
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Algorithm</strong></td><td style="text-align: left;"> </td><td style="text-align: left;"> <strong>Parameters</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>&quot;sga&quot;</strong></td><td style="text-align: left;"> Number of bits.  </td><td style="text-align: left;"> <code>penv$genelength()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>&quot;sgde&quot;</strong></td><td style="text-align: left;"> Number of parameters. </td><td style="text-align: left;"> 
                    <code>length(penv$bitlength()</code>, 
                    <code>penv$lb()</code>, <code>penv$ub()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>&quot;sgperm&quot;</strong></td><td style="text-align: left;"> Number of symbols. </td><td style="text-align: left;"> <code>penv$genelength()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>&quot;sgp&quot;</strong></td><td style="text-align: left;"> Depth bound of derivation tree. </td><td style="text-align: left;"> <code>maxdepth</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>&quot;sge&quot;</strong></td><td style="text-align: left;"> Number of codons and 
   </td><td style="text-align: left;"><code>codons</code>, <code>codonBits</code>,
                  <code>codonPrecision</code>, <code>maxPBias</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> number of bits of a codon. </td><td style="text-align: left;">
</td>
</tr>

</table>



<h3>The Pipeline of Genetic Operators</h3>

<p>The pipeline of genetic operators merges the pipeline of a genetic algorithm with the pipeline of 
evolutionary algorithms and simulated annealing by adding an acceptance step: 
</p>

<ul>
<li><p> For evolutionary algorithms,
the acceptance rule <code>accept="Best"</code> means that the fitter gene out of a parent and its kid survives
(is copied into the next generation).
</p>
</li>
<li><p> For genetic algorithms the acceptance rule <code>accept="All"</code> means that always the kid survives.
</p>
</li>
<li><p> For simulated annealing the acceptance rule <code>accept="Metropolis"</code> 
means that the survival probability of a kid with a fitness
worse than its parent decreases as the number of generations executed increases. 
</p>
</li></ul>

<p>Proper configuration of the pipeline allows the configuration of new algorithm variants which mix elements
of genetic, evolutionary, and simulated annealing algorithms.
</p>
<p>The following table gives a working standard configuration of the pipeline of the genetic operators for each 
of the five algorithms:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Step/Algorithm</strong></td><td style="text-align: center;"><strong>&quot;sga&quot;</strong></td><td style="text-align: center;"><strong>&quot;sgde&quot;</strong></td><td style="text-align: center;"><strong>&quot;sgperm&quot;</strong></td><td style="text-align: center;"><strong>&quot;sgp&quot;</strong></td><td style="text-align: center;"><strong>&quot;sge&quot;</strong></td>
</tr>
<tr>
 <td style="text-align: left;"> 
(next) Scaling         </td><td style="text-align: center;"> NoScaling    </td><td style="text-align: center;"> NoScaling     </td><td style="text-align: center;"> NoScaling       </td><td style="text-align: center;"> NoScaling    </td><td style="text-align: center;"> NoScaling    </td>
</tr>
<tr>
 <td style="text-align: left;">
(next) Selection       </td><td style="text-align: center;">  SUS         </td><td style="text-align: center;">  UniformP     </td><td style="text-align: center;"> SUS             </td><td style="text-align: center;">   SUS        </td><td style="text-align: center;">  SUS         </td>
</tr>
<tr>
 <td style="text-align: left;">
(next) Replication     </td><td style="text-align: center;">  Kid2        </td><td style="text-align: center;">    DE         </td><td style="text-align: center;">   Kid2          </td><td style="text-align: center;">   Kid2       </td><td style="text-align: center;">  Kid2        </td>
</tr>
<tr>
 <td style="text-align: left;">
(next) Crossover       </td><td style="text-align: center;">  Cross2Gene  </td><td style="text-align: center;">  UCrossGene   </td><td style="text-align: center;">  Cross2Gene     </td><td style="text-align: center;"> Cross2Gene   </td><td style="text-align: center;"> Cross2Gene   </td>
</tr>
<tr>
 <td style="text-align: left;">
(next) Mutation        </td><td style="text-align: center;">  MutateGene  </td><td style="text-align: center;">  MutateGeneDE </td><td style="text-align: center;">  MutateGene     </td><td style="text-align: center;"> MutateGene   </td><td style="text-align: center;"> MutateGene   </td>
</tr>
<tr>
 <td style="text-align: left;">
(next) Acceptance      </td><td style="text-align: center;">    All       </td><td style="text-align: center;">   Best        </td><td style="text-align: center;">   All           </td><td style="text-align: center;">    All       </td><td style="text-align: center;">   All        </td>
</tr>
<tr>
 <td style="text-align: left;"> 
(eval) Decoder         </td><td style="text-align: center;">   Bin2Dec    </td><td style="text-align: center;"> Identity      </td><td style="text-align: center;"> Identity        </td><td style="text-align: center;">     -        </td><td style="text-align: center;">   Mod        </td>
</tr>
<tr>
 <td style="text-align: left;">
(eval) Evaluation      </td><td style="text-align: center;">  EvalGeneU   </td><td style="text-align: center;"> EvalGeneU     </td><td style="text-align: center;"> EvalGeneU       </td><td style="text-align: center;">  EvalGeneU   </td><td style="text-align: center;"> EvalGeneU 
</td>
</tr>

</table>



<h3>Scaling</h3>

<p>In genetic algorithms scaling of the fitness functions has the purpose of increasing or decreasing 
the selection pressure. Two classes of scaling methods are available:
</p>

<ul>
<li><p> Constant scaling methods.
</p>

<ul>
<li><p> No scaling (configured by <code>scaling="NoScaling"</code>).
</p>
</li>
<li><p> Constant scaling (configured by <code>scaling="ConstantScaling"</code>).
Depends on scaling exponent <code>scalingExp</code>. 
</p>
</li></ul>

</li>
<li><p> Adaptive scaling methods.
</p>
      
<ul>
<li><p> Threshold scaling (configured by <code>scaling="ThresholdScaling"</code>).
It is configured with the scaling exponents <code>scalingExp</code> and <code>scalingExp2</code>, 
and the scaling threshold <code>scalingThreshold</code>.
It uses a threshold rule about the change of a dispersion measure 
of the population fitness <code>lF$RDM()</code> 
to choose the scaling exponent:
</p>

<ul>
<li> <p><code>lF$RDM()&gt;1+scalingThreshold</code>: The scaling exponent is <code>scalingExp</code> 
which should be greater than <code>1</code>. 
Rationale: Increase selection pressure to reduce dispersion of fitness.
</p>
</li>
<li> <p><code>lF$RDM()&lt;1-scalingThreshold</code>: The scaling exponent is <code>scalingExp2</code> 
which should be lower than <code>1</code>.
Rationale: Decrease selection pressure to increase dispersion of fitness.
</p>
</li>
<li><p> Else: Scaling exponent is <code>1</code>. Fitness is not scaled.  
</p>
</li></ul>

</li>
<li><p> Continuous scaling (configured by <code>scaling="ContinuousScaling"</code>).
The ratio of the dispersion measures <code>lF$RDM()</code> is 
greater than 1 if the dispersion increased in the last generation and 
less than 1 if the dispersion decreased in the last generation. 
The scaling exponent is the product of the ratio of the 
dispersion measures <code>lF$RDM()</code> with the 
weight <code>rdmWeight</code>. 
</p>
</li></ul>

</li></ul>

<p>The change of the dispersion measure of the population fitness is measured by the function <code>lF$RDM()</code>
(RDM means (R)atio of (D)ispersion (M)easure). This function depends on
</p>

<ul>
<li><p> the choice of a dispersion measure of the population fitness <code>dispersionMeasure</code>. 
The variance is the default (<code>dispersionMeasure="var"</code>).
The following dispersion measure of the population fitness are avalaible:
Variance (<code>"var"</code>), 
standard deviation (<code>"std"</code>), 
median absolute deviation (<code>"mad"</code>), 
coefficient of variation (<code>"cv"</code>), 
range (<code>"range"</code>), 
inter quartile range (<code>"iqr"</code>). 
</p>
</li>
<li><p> the scaling delay <code>scalingDelay</code>. The default is <code>scalingDelay=1</code>. 
This means the ratio of the variance of the fitness of the population at time t 
and the variance of the fitness of the population at time t-1 is computed.
</p>
</li>
<li><p> the upper and lower bounds of the ratio of dispersion measures. 
</p>
</li>
<li><p> Dispersion ratios may have extreme fluctuations: The parameters <code>drMax</code> and <code>drMin</code>  
define upper and lower bounds of the ratio of dispersion measures. 
The defaults are <code>drMax=2</code> and <code>drMin=1</code>.
</p>
</li></ul>

<p>See package <code>xegaSelectGene</code> &lt;https://CRAN.R-project.org/package=xegaSelectGene&gt;
</p>


<h3>Selection</h3>

<p>Selection operators determine which genes are chosen for the replication process for the next generation.
Selection operators are configured by <code>selection</code> and <code>mateselection</code> 
(the 2nd parent for crossover). The default operator is stochastic universal selection 
for both parents (configured by <code>selection="SUS"</code> and <code>mateselection="SUS"</code>).  
The following operators are implemented:
</p>

<ul>
<li><p> Uniform random selection with replacement (configured by <code>"Uniform"</code>).
Needed for simulating uniform random mating behavior, computer experiments without
selection pressure, for computing random search solutions as naive benchmarks.
</p>
</li>
<li><p> Uniform random selection without replacement (configured by <code>"UniformP"</code>).
Needed for differential evolution.
</p>
</li>
<li><p> Selection proportional to fitness 
(in <code>O(n)</code> by <code>"SelectPropFit"</code>, in <code>O(n*log(n))</code> by <code>"SelectPropFitOnln"</code>, 
and in <code>O(n^2)</code> by <code>"SelectPropFitM"</code>).  
<code>offset</code> configures the shift of the fitness vector if <code>min(fit)=&lt;0</code>.
</p>
</li>
<li><p> Selection proportional to fitness differences
(in <code>O(n)</code> by <code>"SelectPropFitDiff"</code>, in <code>O(n*log(n))</code> by <code>"SelectPropFitDiffOnln"</code>, 
and in <code>O(n^2)</code> by <code>"SelectPropFitDiffM"</code>). 
Even the worst gene should have a minimal chance of survival: <code>eps</code> is added to the 
fitness difference vector. This also guarantees numerical stability for populations 
in which all genes have the same fitness. 
</p>
</li>
<li><p> Deterministic tournament selection of <code>k</code> genes (configured by <code>"Tournament"</code>).  
The tournament size is configured by <code>tournamentSize</code>.
Selection pressure increases with tournament size. 
The worst <code>k-1</code> genes of a population never survive.
</p>
</li>
<li><p> Deterministic tournament selection of <code>2</code> genes (configured by <code>"Duel"</code>).  
</p>
</li>
<li><p> Stochastic tournament selection of <code>k</code> genes (configured by <code>"STournament"</code>).  
The tournament size is configured by <code>tournamentSize</code>.
</p>
</li>
<li><p> Linear rank selection with selective pressure (configured by <code>"LRSelective"</code>). 
The selection bias which regulates the selection pressure 
is configured by <code>selectionBias</code> 
(should be between <code>1.0</code> (uniform selection) and <code>2.0</code>). 
</p>
</li>
<li><p> Linear rank selection with interpolated target sampling rates (configured by <code>"LRTSR"</code>).
The maximal target sampling rate is configured by <code>maxTSR</code> 
(should be between <code>1</code> and <code>2</code>).
</p>
</li>
<li><p> Stochastic universal sampling (configured by <code>"SUS"</code>).
</p>
</li></ul>

<p>If <code>selectionContinuation=TRUE</code> then selection functions are computed exactly once 
per generation. They are transformed into lookup-functions which deliver the index of selected genes by 
indexing a vector of integers.
</p>
<p>See package <code>xegaSelectGene</code> &lt;https://CRAN.R-project.org/package=xegaSelectGene&gt;
</p>


<h3>Replication</h3>

<p>For genetic algorithms (&quot;sga&quot;, &quot;sgp&quot;, sgperm&quot;, and &quot;sge&quot;) 
in the replication process of a gene the crossover operator may 
by configured to produce one new gene (<code>replication="Kid1"</code>)  
or two new genes (<code>replication="Kid2"</code>). The first version  
looses genetic information in the crossover operation, whereas the second version 
retains the genetic material in the population.
There is a dependency between <code>replication</code> and <code>crossover</code>:
<code>"Kid2"</code> requires a crossover operator which produces two kids.
The replication method is configured by the function  
<code>xegaGaReplicationFactory()</code> of package <code>xegaGaGene</code>.
</p>
<p>Note that only the function <code>xegaGaReplicateGene</code> of <code>xegaGaGene</code> 
(configured with <code>replication="Kid1"</code>) implements a genetic operator pipeline
with an acceptance rule. 
</p>
<p>For differential evolution (algorithm &quot;sgde&quot;), <code>replication="DE"</code> 
must be configured.
The replication method for differential evolution is configured by the function  
<code>xegaDfReplicationFactory()</code> of package <code>xegaDfGene</code>.
It implements a configurable acceptance rule. For classic differential evolution, 
use <code>accept="Best"</code>.
</p>


<h3>Crossover</h3>

<p>The table below summarizes the available crossover operators of the current version.
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Algorithm:</strong> </td><td style="text-align: left;"> <strong>&quot;sga&quot;</strong> and <strong>&quot;sge&quot;</strong>  </td><td style="text-align: left;"> <strong>Package:</strong>   </td><td style="text-align: left;">  <strong>xegaGaGene</strong>  </td><td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
 Kids </td><td style="text-align: left;"> Name  </td><td style="text-align: left;"> Function </td><td style="text-align: left;"> crossover=  </td><td style="text-align: left;"> Influenced by</td>
</tr>
<tr>
 <td style="text-align: left;">
 (2 kids)  </td><td style="text-align: left;"> 1-Point              </td><td style="text-align: left;">  xegaGaCross2Gene()            </td><td style="text-align: left;"> "Cross2Gene"   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> Uniform              </td><td style="text-align: left;">  xegaGaUCross2Gene()           </td><td style="text-align: left;"> "UCross2Gene"  </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> Parametrized Uniform </td><td style="text-align: left;"> xegaGaUPCross2Gene()           </td><td style="text-align: left;"> "UPCross2Gene" </td><td style="text-align: left;"> ucrossSwap </td>
</tr>
<tr>
 <td style="text-align: left;">
 (1 kid)   </td><td style="text-align: left;"> 1-Point              </td><td style="text-align: left;"> xegaGaCrossGene()              </td><td style="text-align: left;"> "CrossGene"   </td><td style="text-align: left;">           </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> Uniform              </td><td style="text-align: left;"> xegaGaUCrossGene()             </td><td style="text-align: left;"> "UCrossGene"  </td><td style="text-align: left;">      </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> Parametrized Uniform </td><td style="text-align: left;">  xegaGaUPCrossGene()           </td><td style="text-align: left;"> "UPCrossGene" </td><td style="text-align: left;"> ucrossSwap  </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>Algorithm:</strong>  </td><td style="text-align: left;"> <strong>&quot;sgde&quot;</strong> </td><td style="text-align: left;"> <strong>Package:</strong>    </td><td style="text-align: left;"> <strong>xegaDfGene</strong>  </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 (1 kid)   </td><td style="text-align: left;"> 1-Point              </td><td style="text-align: left;">  xegaDfCrossGene()             </td><td style="text-align: left;"> "CrossGene"   </td><td style="text-align: left;">           </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> Uniform              </td><td style="text-align: left;">  xegaDfCrossGene()             </td><td style="text-align: left;"> "UCrossGene"  </td><td style="text-align: left;">      </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> Parametrized Uniform </td><td style="text-align: left;">  xegaDfUPCrossGene()           </td><td style="text-align: left;"> "UPCrossGene" </td><td style="text-align: left;"> ucrossSwap  </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>Algorithm:</strong>  </td><td style="text-align: left;"> <strong>&quot;sgperm&quot;</strong> </td><td style="text-align: left;"> <strong>Package:</strong>    </td><td style="text-align: left;"> <strong>xegaPermGene</strong>   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 (2 kids)  </td><td style="text-align: left;"> Position-Based       </td><td style="text-align: left;">  xegaPermCross2Gene()          </td><td style="text-align: left;"> "Cross2Gene"   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 (1 kid)   </td><td style="text-align: left;"> Position-Based       </td><td style="text-align: left;">  xegaPermCrossGene()           </td><td style="text-align: left;"> "CrossGene"   </td><td style="text-align: left;">           </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>Algorithm:</strong>  </td><td style="text-align: left;"> <strong>&quot;sgp&quot;</strong> </td><td style="text-align: left;"> <strong>Package:</strong>    </td><td style="text-align: left;"> <strong>xegaGpGene</strong>    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 (2 kids)  </td><td style="text-align: left;"> of Derivation Trees  </td><td style="text-align: left;">  xegaGpAllCross2Gene()       </td><td style="text-align: left;"> "Cross2Gene" or </td><td style="text-align: left;"> maxcrossdepth, </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;">                      </td><td style="text-align: left;">                              </td><td style="text-align: left;"> "All2Cross2Gene" </td><td style="text-align: left;"> maxdepth, </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;">                      </td><td style="text-align: left;">                              </td><td style="text-align: left;">                  </td><td style="text-align: left;"> and maxtrials </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> of Depth-Filtered    </td><td style="text-align: left;">  xegaGpFilterCross2Gene()    </td><td style="text-align: left;"> "FilterCross2Gene" </td><td style="text-align: left;"> maxcrossdepth,</td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> Derivation Trees     </td><td style="text-align: left;">                              </td><td style="text-align: left;">                    </td><td style="text-align: left;"> mincrossdepth, </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;">                      </td><td style="text-align: left;">                              </td><td style="text-align: left;">                    </td><td style="text-align: left;"> maxdepth, </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;">                      </td><td style="text-align: left;">                              </td><td style="text-align: left;">                    </td><td style="text-align: left;"> and maxtrials </td>
</tr>
<tr>
 <td style="text-align: left;">
 (1 kid)   </td><td style="text-align: left;"> of Derivation Trees  </td><td style="text-align: left;">  xegaGpAllCrossGene()       </td><td style="text-align: left;"> "CrossGene" </td><td style="text-align: left;"> maxcrossdepth, </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;">                      </td><td style="text-align: left;">                              </td><td style="text-align: left;">            </td><td style="text-align: left;"> maxdepth, </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;">                      </td><td style="text-align: left;">                              </td><td style="text-align: left;">            </td><td style="text-align: left;"> and maxtrials </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> of Depth-Filtered    </td><td style="text-align: left;">  xegaGpFilterCrossGene()    </td><td style="text-align: left;"> "FilterCrossGene" </td><td style="text-align: left;"> maxcrossdepth, </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;"> Derivation Trees     </td><td style="text-align: left;">                              </td><td style="text-align: left;">                    </td><td style="text-align: left;"> mincrossdepth, </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;">                      </td><td style="text-align: left;">                              </td><td style="text-align: left;">                    </td><td style="text-align: left;"> maxdepth, </td>
</tr>
<tr>
 <td style="text-align: left;">
           </td><td style="text-align: left;">                      </td><td style="text-align: left;">                              </td><td style="text-align: left;">                    </td><td style="text-align: left;"> and maxtrials </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Mutation</h3>

<p>The table below summarizes the available mutation operators of the current version.
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Algorithm:</strong> </td><td style="text-align: left;"> <strong>&quot;sga&quot;</strong> and <strong>&quot;sge&quot;</strong>  </td><td style="text-align: left;"> <strong>Package:</strong>   </td><td style="text-align: left;">  <strong>xegaGaGene</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
 Name  </td><td style="text-align: left;"> Function </td><td style="text-align: left;"> mutation=  </td><td style="text-align: left;"> Influenced by</td>
</tr>
<tr>
 <td style="text-align: left;">
 Bit Mutation         </td><td style="text-align: left;">  xegaGaMutateGene()            </td><td style="text-align: left;"> "MutateGene"   </td><td style="text-align: left;"> bitmutrate </td>
</tr>
<tr>
 <td style="text-align: left;">
 Individually        </td><td style="text-align: left;">  xegaGaIVAdaptiveMutateGene()  </td><td style="text-align: left;"> "IVM"  </td><td style="text-align: left;"> bitmutrate,     </td>
</tr>
<tr>
 <td style="text-align: left;">
 Variable Bit        </td><td style="text-align: left;">                                </td><td style="text-align: left;">        </td><td style="text-align: left;"> bitmutrate2,     </td>
</tr>
<tr>
 <td style="text-align: left;">
 Mutation            </td><td style="text-align: left;">                                </td><td style="text-align: left;">        </td><td style="text-align: left;">  and cutoffFit     </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>Algorithm:</strong>  </td><td style="text-align: left;"> <strong>&quot;sgde&quot;</strong> </td><td style="text-align: left;"> <strong>Package:</strong>    </td><td style="text-align: left;"> <strong>xegaDfGene</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
 Differential </td><td style="text-align: left;">  xegaDfMutateGeneDE()             </td><td style="text-align: left;"> "MutateGene" or   </td><td style="text-align: left;"> lF$ScaleFactor() </td>
</tr>
<tr>
 <td style="text-align: left;">
 Evolution Mutation             </td><td style="text-align: left;">                                     </td><td style="text-align: left;"> "MutateGeneDe"    </td><td style="text-align: left;"> (Configurable)   </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>Algorithm:</strong> </td><td style="text-align: left;"> <strong>&quot;sgperm&quot;</strong> </td><td style="text-align: left;"> <strong>Package:</strong>    </td><td style="text-align: left;"> <strong>xegaPermGene</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
 Generalized Order  </td><td style="text-align: left;">  xegaPermMutateGeneOrderBased()          </td><td style="text-align: left;"> "MutateGene"             </td><td style="text-align: left;"> bitmutrate </td>
</tr>
<tr>
 <td style="text-align: left;">
 Based Mutation     </td><td style="text-align: left;">                                </td><td style="text-align: left;"> "MutateGeneOrderBased"   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 k Inversion  </td><td style="text-align: left;">  xegaPermMutateGenekInversion()          </td><td style="text-align: left;"> "MutateGenekInversion" </td><td style="text-align: left;"> lambda </td>
</tr>
<tr>
 <td style="text-align: left;">
 Mutation     </td><td style="text-align: left;">                                </td><td style="text-align: left;">          </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 2-Opt Mutation </td><td style="text-align: left;">  xegaPermMutateGene2Opt()          </td><td style="text-align: left;"> "MutateGene2Opt" </td><td style="text-align: left;"> max2opt </td>
</tr>
<tr>
 <td style="text-align: left;">
 k-Opt LK Mutation </td><td style="text-align: left;">  xegaPermMutateGenekOptLK()          </td><td style="text-align: left;"> "MutateGenekOptLK" </td><td style="text-align: left;"> max2opt </td>
</tr>
<tr>
 <td style="text-align: left;">
 (Lin-Kernighan)     </td><td style="text-align: left;">                                </td><td style="text-align: left;">          </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 Greedy Path  </td><td style="text-align: left;">  xegaPermMutateGeneGreedy()          </td><td style="text-align: left;"> "MutateGeneGreedy" </td><td style="text-align: left;"> lambda </td>
</tr>
<tr>
 <td style="text-align: left;">
 Mutation     </td><td style="text-align: left;">                                </td><td style="text-align: left;">          </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 Best Greedy Path  </td><td style="text-align: left;">  xegaPermMutateGeneBestGreedy()          </td><td style="text-align: left;"> "MutateGeneBestGreedy" </td><td style="text-align: left;"> lambda </td>
</tr>
<tr>
 <td style="text-align: left;">
 Mutation     </td><td style="text-align: left;">                                </td><td style="text-align: left;">          </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 Random Mutation  </td><td style="text-align: left;">  xegaPermMutateMix()          </td><td style="text-align: left;"> "MutateGeneMix" </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
 Operator     </td><td style="text-align: left;">                                </td><td style="text-align: left;">          </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>Algorithm:</strong>  </td><td style="text-align: left;"> <strong>&quot;sgp&quot;</strong> </td><td style="text-align: left;"> <strong>Package:</strong>    </td><td style="text-align: left;"> <strong>xegaGpGene</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
 Derivation Tree  </td><td style="text-align: left;">  xegaGpMutateAllGene()       </td><td style="text-align: left;"> "MutateGene" or </td><td style="text-align: left;"> maxmutdepth </td>
</tr>
<tr>
 <td style="text-align: left;">
 Mutation         </td><td style="text-align: left;">                              </td><td style="text-align: left;"> "MutateAllGene" </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
 Filtered Derivation   </td><td style="text-align: left;">  xegaGpMutateGeneFilter()       </td><td style="text-align: left;"> "MutateFilterGene" </td><td style="text-align: left;"> maxmutdepth, </td>
</tr>
<tr>
 <td style="text-align: left;">
 Tree Mutation         </td><td style="text-align: left;">                              </td><td style="text-align: left;">                 </td><td style="text-align: left;">  minmutinsertiondepth, </td>
</tr>
<tr>
 <td style="text-align: left;">
                      </td><td style="text-align: left;">                              </td><td style="text-align: left;">                 </td><td style="text-align: left;">  and maxmutinsertiondepth </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Acceptance</h3>

<p>Acceptance rules are extensions of genetic and evolutionary algorithms 
which to the best of my knowledge have their origin in simulated annealing.  
An acceptance rule compares the fitness value of a modified gene with the 
fitness value of its parent and determines which of the two genes is passed
into the next population.
</p>
<p>An acceptance rule is only executed as part of the genetic operator pipeline, if 
<code>replicate="Kid1"</code> or <code>replicate="DE"</code>.
</p>
<p>Two classes of acceptance rules are provided: 
</p>

<ul>
<li><p> Simple acceptance rules.   
</p>

<ul>
<li><p> Accept the new gene unconditionally (configured by <code>accept="All"</code>).
The new gene is always passed to the next population. 
Choose the rule for configuring a classic genetic algorithm.
(The default). 
</p>
</li>
<li><p> Accept only best gene (configured by <code>accept="Best"</code>).
This acceptance rule guarantees an increasing fitness curve over the run 
of the algorithm. For example, classic differential evolution uses this acceptance rule.
</p>
</li></ul>

</li>
<li><p> Configurable acceptance rules. 
The rules always accept a new gene with a fitness improvement. 
They also accept a new gene with a lower fitness with a probability which depends 
on the fitness difference of the old and the new gene 
and a temperature parameter which is reduced over the algorithm 
run by a configurable cooling schedule. 
</p>

<ul>
<li><p> The Metropolis acceptance rule (configured by <code>accept="Metropolis"</code>). 
The larger the parameter <code>beta</code> is set, the faster the drop in acceptance probability. 
</p>
</li>
<li><p> The individually adaptive Metropolis acceptance rule (configured by <code>accept="IVMetropolis"</code>). 
The larger the parameter <code>beta</code> is set, the faster the drop in acceptance probability. 
Individually adaptive means that the temperature is corrected. The correction (increase) of temperature 
depends on the difference between the fitness of the currently known best solution and the 
and the fitness of the new gene.
</p>
</li></ul>

</li></ul>

<p>The cooling schedule updates the temperature parameter at the end of the main loop.
The following cooling schedules are available:
</p>
 
<ul>
<li><p> Exponential multiplicative cooling (configured by <code>cooling="ExponentialMultiplicative"</code>).
Depends on the discount factor <code>alpha</code> 
and the start temperature <code>temp0</code>.
</p>
</li>
<li><p> Logarithmic multiplicative cooling (configured by <code>cooling="LogarithmicMultiplicative"</code>).
Depends on the scaling factor <code>alpha</code> 
and the start temperature <code>temp0</code>.
</p>
</li>
<li><p> Power multiplicative cooling (configured by <code>cooling="PowerMultiplicative"</code>).
Depends on the scaling factor <code>alpha</code>, 
the cooling power exponent <code>coolingPower</code>, 
and the start temperature <code>temp0</code>.
</p>
</li>
<li><p> Power additive cooling (configured by <code>cooling="PowerAdditive"</code>).
Depends on the number of generations <code>generations</code>, 
the cooling power exponent <code>coolingPower</code>, 
the start temperature <code>temp0</code>, and the final temperature <code>tempN</code>.
</p>
</li>
<li><p> Exponential additive cooling (configured by <code>cooling="ExponentialAdditive"</code>).
Depends on the number of generations <code>generations</code>, the 
start temperature <code>temp0</code>, and the final temperature <code>tempN</code>.
</p>
</li>
<li><p> Trigonometric additive cooling (configured by <code>cooling="TrigonometricAdditive"</code>).
Depends on the number of generations <code>generations</code>, the 
start temperature <code>temp0</code>, and the final temperature <code>tempN</code>.
</p>
</li></ul>

<p>See package <code>xegaPopulation</code> &lt;https://CRAN.R-project.org/package=xegaPopulation&gt;
</p>


<h3>Decoder</h3>

<p>Decoders are algorithm and task dependent. Their implementation often makes use of a gene map. 
The table below summarizes the available decoders 
and gene maps of the current version.
</p>

<table>
<tr>
 <td style="text-align: left;">
Algorithm:          </td><td style="text-align: center;"><strong>&quot;sga&quot;</strong>          </td><td style="text-align: center;"><strong>&quot;sgde&quot;</strong>         </td><td style="text-align: center;"><strong>&quot;sgperm&quot;</strong>     </td>
</tr>
<tr>
 <td style="text-align: left;"> 
In package:         </td><td style="text-align: center;"> xegaGaGene             </td><td style="text-align: center;"> xegaDfGene             </td><td style="text-align: center;"> xegaPermGene         </td>
</tr>
<tr>
 <td style="text-align: left;">
Decoder:            </td><td style="text-align: center;"> xegaGaDecodeGene()     </td><td style="text-align: center;"> xegaDfDecodeGene()     </td><td style="text-align: center;"> xegaPermDecodeGene() </td>
</tr>
<tr>
 <td style="text-align: left;">
Gene map factories: </td><td style="text-align: center;"> xegaGaGeneMapFactory() </td><td style="text-align: center;"> xegaDfGeneMapFactory() </td><td style="text-align: center;"> (Not configurable)   </td>
</tr>
<tr>
 <td style="text-align: left;">
Method              </td><td style="text-align: center;"> "Bin2Dec"               </td><td style="text-align: center;"> "Identity"             </td><td style="text-align: center;">                      </td>
</tr>
<tr>
 <td style="text-align: left;">
Method              </td><td style="text-align: center;"> "Gray2Dec"              </td><td style="text-align: center;">                        </td><td style="text-align: center;">                      </td>
</tr>
<tr>
 <td style="text-align: left;">
Method              </td><td style="text-align: center;"> "Identity"              </td><td style="text-align: center;">                        </td><td style="text-align: center;">                      </td>
</tr>
<tr>
 <td style="text-align: left;">
Method              </td><td style="text-align: center;"> "Permutation"           </td><td style="text-align: center;">                        </td><td style="text-align: center;">                      </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: left;">
Algorithm:          </td><td style="text-align: center;"> <strong>&quot;sgp&quot;</strong>     </td><td style="text-align: center;"><strong>&quot;sge&quot;</strong>          </td>
</tr>
<tr>
 <td style="text-align: left;"> 
In package:         </td><td style="text-align: center;"> xegaGpGene         </td><td style="text-align: center;"> xegaGeGene             </td>
</tr>
<tr>
 <td style="text-align: left;">
Decoder:            </td><td style="text-align: center;"> xegaGpDecodeGene() </td><td style="text-align: center;"> xegaGeDecodeGene()     </td>
</tr>
<tr>
 <td style="text-align: left;">
Gene map factories: </td><td style="text-align: center;"> (Not configurable) </td><td style="text-align: center;"> xegaGeGeneMapFactory() </td>
</tr>
<tr>
 <td style="text-align: left;">
Method              </td><td style="text-align: center;">                    </td><td style="text-align: center;"> "Mod"                  </td>
</tr>
<tr>
 <td style="text-align: left;">
Method              </td><td style="text-align: center;">                    </td><td style="text-align: center;"> "Buck"                 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Evaluation</h3>

<p>The method of evaluation of a gene is configured by
<code>evalmethod</code>: &quot;EvalGeneU&quot; means that the function is always executed,
&quot;Deterministic&quot; evaluates a gene only once, and &quot;Stochastic&quot; incrementally updates mean and 
variance of a stochastic function. 
If <code>reportEvalErrors==TRUE</code>, evaluation failures are reported. However, for grammatical  
evolution without gene repair this should be set to <code>FALSE</code>. 
See package <code>xegaSelectGene</code> &lt;https://CRAN.R-project.org/package=xegaSelectGene&gt;
</p>


<h3>Distributed and Parallel Processing</h3>

<p>The current scope of parallelization is the parallel evaluation of genes (the steps marked with (eval) in the 
genetic operator pipeline. This strategy is less efficient for differential evolution and permutation-based genetic
algorithms because of the embedding of repeated evaluations into genetic operators. 
</p>
<p>In general, distributed and parallel processing requires a sequence of three steps:  
</p>

<ol>
<li><p> Configure and start the distributed or parallel infrastructure.
</p>
</li>
<li><p> Distribute processing and collect results. 
In a evolutionary or genetic algorithm the architectural pattern used for implementation 
coarse-grained parallelism by parallel evaluation of the fitness of the genes of a population
is the master/worker pattern. In principle, the <code>lapply()</code>-function for evaluating a population 
of genes is replaced by a parallel version. 
</p>
</li>
<li><p> Stop the distributed or parallel infrastructure.
</p>
</li></ol>

<p>For evolutionary and genetic algorithm, the second step is controlled by two parameters, 
namely <code>executionModel</code> and <code>uParApply</code>:
</p>

<ol>
<li><p> If <code>uParApply=NULL</code>, then <code>executionModel</code> provides four ways of evaluating the 
fitness of a population of genes:
</p>

<ol>
<li> <p><code>executionModel="Sequential"</code>: The apply function used is <code>base::lapply()</code>. (Default).
</p>
</li>
<li> <p><code>executionModel="MultiCore"</code>:  The apply function used is <code>parallel::mclapply()</code>.
If the number of cores is not specied by <code>cores</code>, the number of available cores 
is determined by <code>parallelly::availableCores()</code>. 
</p>
</li>
<li> <p><code>executionModel="FutureApply"</code>:  The apply function used is <code>future.apply::future_lapply()</code>.
The parallel/distributed model depends on a proper <code>future::plan()</code> statement. 
</p>
</li>
<li> <p><code>executionModel="Cluster"</code>:  The apply function used is <code>parallel::parLapply()</code>.
The information about the configuration of the computing cluster (master, port, list of workers)
must be provided by <code>Cluster=cl</code> where 
<code>cl&lt;-parallel::makeClusterPSOCK( rep(localhost, 5))</code>
generates the cluster object and starts the R processes (of 5 workers in the same machine).  
</p>
</li></ol>

</li>
<li><p> Assume that a user-defined parallel apply function has been defined and called <code>UPARAPPLY</code>. 
By setting <code>uParApply=UPARAPPLY</code>, the <code>lapply()</code> function used is <code>UPARAPPLY()</code>. 
This overrides the specification by <code>executionModel</code>. For example,
parallelization via the MPI interface can be achieved by providing a user-defined parallel 
<code>lapply()</code> function which is implemented by a user-defined function whose function body 
is the line <code>Rmpi::mpi.parLapply( pop, FUN=EvalGene, lF=lF)</code>.
</p>
</li></ol>

<p>See package <code>xegaPopulation</code>  &lt;https://CRAN.R-project.org/package=xegaPopulation&gt; 
</p>
<p><strong>Acknowledgment.</strong>The author acknowledges support by the state of Baden-Württemberg through bwHPC.
</p>


<h3>Reporting</h3>

 
<ul>
<li> <p><code>verbose</code> controls the information reported on the screen. 
If <code>verbose</code> is <code>1</code>, then one dot is printed per generation to the console.
</p>
</li>
<li> <p><code>reportEvalErrors=TRUE</code> reports the output of errors of fitness function evaluations 
to the console. Grammatical evolution (algorithm &quot;sge&quot;) routinely attempts to evaluate 
incomplete derivation trees. This leads to an evaluation error of the fitness function. 
</p>
</li>
<li> <p><code>profile=TRUE</code> measures the time spent in executing the main blocks of the algorithm:
<code>InitPopulation()</code>, <code>NextPopulation()</code>, <code>EvalPopulation()</code>, 
<code>ObservePopulation()</code>, and <code>SummaryPopulation()</code>. The measurements are stored in the
named list <code>$timer</code> of the result object of the algorithm. 
</p>
</li>
<li> <p><code>allSolutions=TRUE</code> collects all solutions with the same fitness value. 
The lists of the genotypes and phenotypes of these solutions are stored 
in <code>$solution$allgenotypes</code> and <code>$allphenotypes</code> of the result object of the algorithm.
</p>
</li>
<li> <p><code>batch=TRUE</code> writes the result object and <code>logevals=TRUE</code> writes a list of all evaluated genes
to a <code>rds</code>-file in the current directory. <code>path</code> allows to write the <code>rds</code>-files  
into another directory. The existence of the directory specified by <code>path</code> is not checked.
<code>batch=TRUE</code> combined with <code>verbose=TRUE</code> should be used in batch environments on 
HPC environments.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Main Program: 
<code><a href="#topic+xegaReRun">xegaReRun</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-xegaRun(penv=Parabola2D, generations=10, popsize=20, verbose=0)
b&lt;-xegaRun(penv=Parabola2D, algorithm="sga", generations=10, max=FALSE, 
   verbose=1, replay=5, profile=TRUE)
c&lt;-xegaRun(penv=Parabola2D, max=FALSE, algorithm="sgde", 
   popsize=20, generations=50, 
   mutation="MutateGeneDE", scalefactor="Uniform", crossover="UCrossGene", 
   genemap="Identity", replication="DE", 
   selection="UniformP", mateselection="UniformP", accept="Best")
envXOR&lt;-NewEnvXOR()
BG&lt;-compileBNF(booleanGrammar())
d&lt;-xegaRun(penv=envXOR, grammar=BG, algorithm="sgp",  
   generations=5, popsize=20, verbose=0)
e&lt;-xegaRun(penv=envXOR, grammar=BG, algorithm="sge", genemap="Mod",  
   generations=5, popsize=20, reportEvalErrors=FALSE, verbose=1)
f&lt;-xegaRun(penv=lau15, max=FALSE, algorithm="sgperm", 
   genemap="Identity", mutation="MutateGeneMix")

</code></pre>

<hr>
<h2 id='xegaVersion'>About this version.</h2><span id='topic+xegaVersion'></span>

<h3>Description</h3>

<p>About this version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaVersion(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaVersion_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (Default), print 
package information and version number to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Version number (invisible).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xegaVersion()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
