<!DOCTYPE html><html><head><title>Help for package modQR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {modQR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compContourM1/2u'><p>Directional Regression Quantile Computation</p></a></li>
<li><a href='#evalContour'><p>Evaluating Convex Polytopes</p></a></li>
<li><a href='#getCharSTM1u'><p>Computing Some Overall Characteristics in <code>compContourM1u</code></p></a></li>
<li><a href='#getCharSTM2u'><p>Computing Some Overall Characteristics in <code>compContourM2u</code></p></a></li>
<li><a href='#getCTechSTM1/2u'><p>Getting the List of Options CTechST for <code>compContourM1/2u</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-03</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple-Output Directional Quantile Regression</td>
</tr>
<tr>
<td>Author:</td>
<td>Miroslav Šiman [aut],
  Pavel Boček [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pavel Boček &lt;bocek@utia.cas.cz&gt;</td>
</tr>
<tr>
<td>Copyright:</td>
<td>The Institute of Information Theory and Automation of the
Czech Academy of Sciences, Pod Vodarenskou vezi 4, CZ-18208
Prague 8, Czech Republic, email: utia@utia.cas.cz, phone: +420
266 053 111</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains basic tools for performing 
  multiple-output quantile regression and computing
  regression quantile contours by means of directional
  regression quantiles. In the location case, one can thus
  obtain halfspace depth contours in two to six dimensions.
  Hallin, M., Paindaveine, D. and Šiman, M. (2010)
  Multivariate quantiles and multiple-output regression quantiles:
  from L1 optimization to halfspace depth. Annals of Statistics 38, 635-669
  For more references about the method, see Help pages.</td>
</tr>
<tr>
<td>Classification/MSC:</td>
<td>62H05, 62J99, 62G08, 65C60</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.5.0), lpSolve (&ge; 5.6.1), geometry (&ge; 0.3-1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>addItem.R findItem.R delItem.R addRow.R findRow.R checkArray.R
checkCTechSTu.R getCTechSTM1u.R getCTechSTM2u.R getCharSTM1u.R
getCharSTM2u.R findOptimalBasisM1FromScratch.R
findOptimalBasisM2FromScratch.R compContourM1u.R
compContourM2u.R evalContour.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-03 07:25:32 UTC; bocek</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-11 12:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='compContourM1+2F2u'>Directional Regression Quantile Computation</h2><span id='topic+compContourM1u'></span><span id='topic+compContourM2u'></span><span id='topic+compContourM1+2F2u'></span>

<h3>Description</h3>

<p>The functions <code>compContourM1u</code> and <code>compContourM2u</code> 
may be used to obtain not only directional regression quantiles 
for <em>all</em> directions, but also some related overall 
statistics.  Their output may also be used for the evaluation 
of the corresponding regression quantile regions by means of 
<code><a href="#topic+evalContour">evalContour</a></code>.  The functions use different 
methods and algorithms, namely <code>compContourM1u</code> is based 
on [01] and [06] and <code>compContourM2u</code> results from [03] 
and [07].  The corresponding regression quantile regions are 
nevertheless virtually the same.  See all the references below 
for further details and possible applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compContourM1u(Tau = 0.2, YMat = NULL, XMat = NULL, CTechST = NULL)
compContourM2u(Tau = 0.2, YMat = NULL, XMat = NULL, CTechST = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compContourM1+2B2F2u_+3A_tau">Tau</code></td>
<td>
<p>the quantile level in (0, 0.5).</p>
</td></tr>
<tr><td><code id="compContourM1+2B2F2u_+3A_ymat">YMat</code></td>
<td>
<p>the N x M response matrix with two to six 
columns, <code>N &gt; M+P-1</code>.  
Each row corresponds to one observation.</p>
</td></tr>
<tr><td><code id="compContourM1+2B2F2u_+3A_xmat">XMat</code></td>
<td>
<p>the N x P design matrix including the (first) 
intercept column. The default NULL value 
corresponds to the unit vector of the right 
length.  
Each row corresponds to one observation.</p>
</td></tr>
<tr><td><code id="compContourM1+2B2F2u_+3A_ctechst">CTechST</code></td>
<td>
<p>the (optional) list with some parameters 
influencing the computation and its output.  
Its default value can be generated by 
method-dependent <code><a href="#topic+getCTechSTM1+2F2u">getCTechSTM1/2u</a></code> 
and then modified by the user before its use 
in <code>compContourM1/2u</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally, the performance of the functions deteriorates with 
increasing Tau, N, M, and P as for their reliability and 
time requirements. Nevertheless, they should work fine 
at least for two-dimensional problems 
up to N = 10000 and P = 10, 
for three-dimensional problems
up to N = 500 and P = 5,
and for four-dimensional problems
up to N = 150 and P = 3. 
</p>
<p>Furthemore, common problems related to the computation 
can fortunately be prevented or overcome easily.  
</p>
<p><b>Bad data</b> - the computation may fail if the processed 
data points are in a bad configuration (i.e., if they are not 
in general position or if they would lead to a quantile 
hyperplane with at least one zero coefficient), which mostly 
happens when discrete-valued/rounded/repeated observations, 
dummy variables or bad random number generators are employed.  
Such problems can often be prevented if one perturbs the data 
with a random noise of a reasonably small magnitude before the 
computation, splits the model into separate or independent 
submodels, cleverly uses affine equivariance, or replaces 
a few identical observations with a copy of them weighted 
by the total number of their occurrences.  
</p>
<p><b>Bad Tau</b> - the computation may fail for a finite number of 
problematic quantile levels, e.g., if Tau is an integer multiple 
of 1/N in the location case with unit weights (when the sample 
quantiles are not uniquely defined).  Such a situation may occur 
easily for Tau's with only a few decimal digits or in a 
fractional form, especially when the number of observations 
changes automatically during the computation.  The problem 
can be fixed easily by perturbing Tau with a sufficiently small 
number in the right direction, which should not affect the 
resulting regression quantile contours although it may slightly 
change the other output.  The strategy is also adopted 
by <code>compContourM1/2u</code>, but only in the location case and 
with a warning output message explaining it.  
</p>
<p><b>Bad scale</b> - the computation may fail easily for badly 
scaled data.  That is to say that the functionality has been 
heavily tested only for the observations coming from 
a centered unit hypercube.  Nevertheless, you can always 
change the units of measurements or employ full affine 
equivariance to avoid all the troubles.  Similar problems 
may also arise when properly scaled data are used with highly 
non-uniform weights, which frequently happens in local(ly) 
polynomial regression.  Then the weights can be rescaled 
in a suitable way and the observations with virtually zero 
weights can be excluded from the computation.  
</p>
<p><b>Bad expectations</b> - the computation and its output need 
not meet false expectations.  Every user should be aware of 
the facts that the computation may take a long time or fail 
even for moderately sized three-dimensional data sets, that the 
<code>HypMat</code> component is not always present in the list 
<code>COutST$CharST</code> by default, and that the sample regression
quantile contours can be not only empty, but also unbounded and 
crossing one another in the general regression case.  
</p>
<p><b>Bad interpretation</b> - the output results may be easily 
interpreted misleadingly or erroneously.  That is to say that 
the quantile level Tau is not linked to the probability 
content of the sample (regression) Tau-quantile region in 
any straightforward way.  Furthermore, any meaningful 
parametric quantile regression model should include 
as regressors not only the variables influencing the 
trend, but also all those affecting the dispersion 
of the multivariate responses.  Even then the cuts 
of the resulting regression quantile contours parallel 
to the response space cannot be safely interpreted 
as conditional multivariate quantiles except for 
some very special cases.  Nevertheless, such a 
conclusion could somehow be warranted in case of 
nonparametric multiple-output quantile regression; see [09].  
</p>


<h3>Value</h3>

<p>Both compContourM1u and compContourM2u may display some 
auxiliary information regarding the computation on the screen 
(if <code>CTechST$ReportI</code> = 1) or store their in-depth
output (determined by <code>CTechST$BriefOutputI</code>) in the output
files (if <code>CTechST$OutSaveI</code> = 1) with
the filenames beginning with the string contained in 
<code>CTechST$OutFilePrefS</code>, followed by the file number
padded with zeros to form six digits 
and by the extension &lsquo;<span class="file">.dqo</span>&rsquo;, respectively.  The first 
output file produced by <code>compContourM1u</code> would 
thus be named &lsquo;<span class="file">DQOutputM1_000001.dqo</span>&rsquo;.
</p>
<p>Both compContourM1u and compContourM2u always return 
a list with the same components. Their interpretation is 
also the same (except for CharST that itself contains some 
components that are method-specific):
</p>
<table>
<tr><td><code>CharST</code></td>
<td>
<p>the list with some default or 
user-defined output.  
The default one is provided 
by function <code><a href="#topic+getCharSTM1u">getCharSTM1u</a></code> 
for <code>compContourM1u</code> and by 
function <code><a href="#topic+getCharSTM2u">getCharSTM2u</a></code> 
for <code>compContourM2u</code>.  
A user-defined function generating 
its own output can be employed instead 
by changing <code>CTechST$getCharST</code>.</p>
</td></tr>
<tr><td><code>CTechSTMsgS</code></td>
<td>
<p>the (possibly empty) string that informs 
about the problems with input <code>CTechST</code>.</p>
</td></tr>
<tr><td><code>ProbSizeMsgS</code></td>
<td>
<p>the (possibly empty) string that warns 
if the input problem is very large.</p>
</td></tr>
<tr><td><code>TauMsgS</code></td>
<td>
<p>the (possibly empty) string that announces 
an internal perturbation of <code>Tau</code>.</p>
</td></tr>
<tr><td><code>CompErrMsgS</code></td>
<td>
<p>the (possibly empty) string that decribes 
the error interrupting the computation.</p>
</td></tr>
<tr><td><code>NDQFiles</code></td>
<td>
<p>the counter of (possible) output files, 
i.e., as if <code>CTechST$OutSaveI</code> = 1.</p>
</td></tr>
<tr><td><code>NumB</code></td>
<td>
<p>the counter of (not necessarily distinct) optimal 
bases considered.</p>
</td></tr>
<tr><td><code>PosVec</code></td>
<td>
<p>the vector of length N that desribes 
the position of individual (regression) 
observations with respect to the 
exact (regression) Tau-quantile 
contour.  
The identification is reliable only after a 
successful computation.  
<code>PosVec[i]</code> = 0/1/2 if the <code>i</code>-th 
observation is in/on/out of the contour.  
If <code>compContourM2u</code> is used with 
<code>CTechST$SkipRedI</code> = 1, then <code>PosVec</code>
correctly detects only all the outer observations.</p>
</td></tr>
<tr><td><code>MaxLWidth</code></td>
<td>
<p>the maximum width of one layer of the 
internal algorithm.</p>
</td></tr>
<tr><td><code>NIniNone</code></td>
<td>
<p>the number of trials when the initial 
solution could not be found at all.</p>
</td></tr>
<tr><td><code>NIniBad</code></td>
<td>
<p>the number of trials when the found 
initial solution did not have 
the right number of clearly nonzero 
coordinates.</p>
</td></tr>
<tr><td><code>NSkipCone</code></td>
<td>
<p>the number of skipped cones (where 
an interior point could not be found).</p>
</td></tr>
</table>
<p>If <code>CTechST.CubRegWiseI</code> = 1, then the last four 
components are calculated over all the individual 
orthants.
</p>


<h3>References</h3>

<p>[01] Hallin, M., Paindaveine, D. and Šiman, M. (2010)
Multivariate quantiles and multiple-output regression quantiles:
from L1 optimization to halfspace depth.
<em>Annals of Statistics</em> <b>38</b>, 635&ndash;669.
</p>
<p>[02] Hallin, M., Paindaveine, D. and Šiman, M. (2010)
Rejoinder (to [01]).
<em>Annals of Statistics</em> <b>38</b>, 694&ndash;703.
</p>
<p>[03] Paindaveine, D. and Šiman, M. (2011)
On directional multiple-output quantile regression.
<em>Journal of Multivariate Analysis</em> <b>102</b>, 193&ndash;212.
</p>
<p>[04] Šiman, M. (2011)
On exact computation of some statistics based on projection
pursuit in a general regression context.
<em>Communications in Statistics - Simulation and Computation</em> <b>40</b>, 948&ndash;956.
</p>
<p>[05] McKeague, I. W., López-Pintado, S., Hallin, M. and Šiman, M. (2011)
Analyzing growth trajectories.
<em>Journal of Developmental Origins of Health and Disease</em> <b>2</b>, 322&ndash;329.
</p>
<p>[06] Paindaveine, D. and Šiman, M. (2012)
Computing multiple-output regression quantile regions.
<em>Computational Statistics &amp; Data Analysis</em> <b>56</b>, 840&ndash;853.
</p>
<p>[07] Paindaveine, D. and Šiman, M. (2012)
Computing multiple-output regression quantile regions
from projection quantiles.
<em>Computational Statistics</em> <b>27</b>, 29&ndash;49.
</p>
<p>[08] Šiman, M. (2014)
Precision index in the multivariate context.
<em>Communications in Statistics - Theory and Methods</em> <b>43</b>, 377&ndash;387.
</p>
<p>[09] Hallin, M., Lu, Z., Paindaveine, D. and Šiman, M. (2015)
Local bilinear multiple-output quantile/depth regression.
<em>Bernoulli</em> <b>21</b>, 1435&ndash;1466.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##computing all directional 0.15-quantiles of 199 random points
##uniformly distributed in the unit square centered at zero
##- preparing the input
Tau  &lt;- 0.15
XMat &lt;- matrix(1, 199, 1)
YMat &lt;- matrix(runif(2*199, -0.5, 0.5), 199, 2)
##- Method 1:
COutST &lt;- compContourM1u(Tau, YMat, XMat)
##- Method 2:
COutST &lt;- compContourM2u(Tau, YMat, XMat)
</code></pre>

<hr>
<h2 id='evalContour'>Evaluating Convex Polytopes</h2><span id='topic+evalContour'></span>

<h3>Description</h3>

<p>Given the system of inequalities <code>AAMat%*%ZVec &lt;= BBVec</code> 
describing a convex polytope/contour with an interior point 
<code>IPVec</code> in the Euclidean space of dimension two to six, this 
function identifies all nonredundant constraints and computes 
some characteristics of the resulting convex polytope such as 
its vertices, facets, volume and surface area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalContour(AAMat, BBVec = NULL, IPVec = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalContour_+3A_aamat">AAMat</code></td>
<td>
<p>the constraints matrix from the system 
of inequalities defining the convex polytope.  
It should be a numeric matrix with two to six 
columns.</p>
</td></tr>
<tr><td><code id="evalContour_+3A_bbvec">BBVec</code></td>
<td>
<p>the right-hand side from the system of 
inequalities defining the convex polytope.  
It should be a numeric column vector 
of the same length as the first column 
of <code>AAMat</code>.</p>
</td></tr>
<tr><td><code id="evalContour_+3A_ipvec">IPVec</code></td>
<td>
<p>an interior point of the investigated convex 
polytope.  This argument can be omitted or set 
equal to a numeric column vector of the same 
length as the first row of <code>AAMat</code>.  
If <code>IPVec</code> is <code>NULL</code> or if given 
<code>IPVec</code> does not lie well 
inside the convex contour, then a 
well-positioned interior point is searched for 
internally, which may slow down the computation 
and make it less reliable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is included to be used for evaluating 
(regression) quantile contours or their cuts.  
</p>
<p>In fact, the function analyzes not the polytope 
itself, but its regularized intersection with 
the zero-centered hypercube of the edge length 
2 000 that is employed as an artificial bounding 
box to avoid the problems with unbounded contours.  
The regularization consists of rounding the vertices 
(i.e., all of their coordinates) of such 
an intersection to the seventh decimal digit and of 
considering only the polytope determined by all 
the distinct rounded vertices for the final analysis.  
</p>


<h3>Value</h3>

<p>evalContour returns a list with the following components 
describing the resulting convex polytope:  
</p>
<table>
<tr><td><code>Status</code></td>
<td>

<p>0 - OK.
</p>
<p>2 - the contour seems virtually empty.
</p>
<p>3 - the search for a well-positioned interior 
point <code>IPVec</code> failed.
</p>
<p>4 - the number of input parameters is too low.
</p>
<p>5 - <code>AAMat</code> is not a numeric matrix with two to six 
columns.
</p>
<p>6 - <code>BBVec</code> is not a numeric column vector of 
the right length.
</p>
<p>7 - <code>IPVec</code> is not a numeric column vector of 
the right length.
</p>
</td></tr>
<tr><td><code>TVVMat</code></td>
<td>
<p>the matrix with clearly distinct contour 
vertices (in rows).</p>
</td></tr>
<tr><td><code>TKKMat</code></td>
<td>
<p>the matrix with clearly distinct elementary 
facets (in rows).  
Each row contains the indices of the rows 
of <code>TVVMat</code> where the facet vertices are stored.  
Each facet has the same number of vertices 
equal to the number of columns of <code>AAMat</code>.  
See also <code>help(convhulln)</code> for 
the meaning of <code>TKKMat</code>.</p>
</td></tr>
<tr><td><code>NumF</code></td>
<td>
<p>the number of clearly distinct contour facets.</p>
</td></tr>
<tr><td><code>NumV</code></td>
<td>
<p>the number of clearly distinct contour vertices.</p>
</td></tr>
<tr><td><code>Vol</code></td>
<td>
<p>the volume of the contour (the area in 2D).</p>
</td></tr>
<tr><td><code>Area</code></td>
<td>
<p>the surface area of the contour (the 
circumference in 2D and the surface in 3D).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##- a simple example using a tilted zero-centered square 
AAMat &lt;- rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1))
BBVec &lt;- c(1, 1, 1, 1)
IPVec &lt;- c(0, 0)
CST &lt;- evalContour(AAMat, BBVec, IPVec)
print(CST)

##- computing and evaluating the 0.15-quantile contour of 199 
##random points uniformly distributed in the unit square 
##centered at zero
Tau  &lt;- 0.15
YMat &lt;- matrix(runif(2*199, -0.5, 0.5), 199, 2)
C &lt;- compContourM1u(Tau, YMat)
CST &lt;- evalContour(-C$CharST$HypMat[,1:2], -C$CharST$HypMat[,3])
print(CST)

##See also the examples ExampleA to ExampleE for some 
##more elaborate ways of computing, evaluating and 
##plotting the (regression) quantile contours.
</code></pre>

<hr>
<h2 id='getCharSTM1u'>Computing Some Overall Characteristics in <code>compContourM1u</code></h2><span id='topic+getCharSTM1u'></span>

<h3>Description</h3>

<p>The function computes some overall characteristics 
of directional regression quantiles in the output 
of <code><a href="#topic+compContourM1u">compContourM1u</a></code>, namely the list 
<code>COutST$CharST</code>.  It makes possible
to obtain some useful information without saving 
any file on the disk, and it can be easily modified 
by the users according to their wishes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCharSTM1u(Tau, N, M, P, BriefDQMat, CharST, IsFirst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCharSTM1u_+3A_tau">Tau</code></td>
<td>
<p>the quantile level in (0, 0.5).</p>
</td></tr>
<tr><td><code id="getCharSTM1u_+3A_n">N</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code id="getCharSTM1u_+3A_m">M</code></td>
<td>
<p>the dimension of responses.</p>
</td></tr>
<tr><td><code id="getCharSTM1u_+3A_p">P</code></td>
<td>
<p>the dimension of regressors including the intercept.</p>
</td></tr>
<tr><td><code id="getCharSTM1u_+3A_briefdqmat">BriefDQMat</code></td>
<td>
<p>the method-specific matrix containing 
the rows of a potential individual output 
file corresponding to 
<code>CTechST$BriefOutputI</code> = 1. See
the details below.</p>
</td></tr> 
<tr><td><code id="getCharSTM1u_+3A_charst">CharST</code></td>
<td>
<p>the output list, updated with each run 
of the function.</p>
</td></tr>
<tr><td><code id="getCharSTM1u_+3A_isfirst">IsFirst</code></td>
<td>
<p>the indicator equal to one in the 
first run of <code>getCharSTM1u</code> 
(when <code>CharST</code> is initialized) 
and equal to zero otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called inside <code><a href="#topic+compContourM1u">compContourM1u</a></code>.  
First, it is called with 
<code>BriefDQMat</code> = <code>NULL</code>, 
<code>CharST</code> = <code>NULL</code> and
<code>IsFirst</code> = 1 to initialize 
the output list <code>CharST</code>, and then 
it is called with <code>IsFirst</code> = 0 
successively for the content of each potential 
output file corresponding to 
<code>CTechST$BriefOutputI</code> = 1, i.e., even if
the output file(s) are not stored on the disk owing to 
<code>CTechST$OutSaveI</code> = 0.
</p>
<p>It still remains to describe in detail the content of possible 
output files, describing the optimal conic segmentation of 
the directional space that lies behind the optimization 
problem involved.  
</p>
<p>If <code>CTechST$BriefOutputI</code> = 1, then the rows of such
files are vectors of length <code>1+1+M+M+P+1</code> of the form 
<code>c(ConeID, Nu, UVec, BDVec, ADVec, LambdaD)</code> where 
</p>

<dl>
<dt>ConeID</dt><dd><p>is the number/order of the cone related to the 
line.  If <code>M</code> &gt; 2, then a cone can appear in 
the output repeatedly (under different numbers).</p>
</dd>
<dt>Nu</dt><dd><p>is the number of corresponding negative residuals.</p>
</dd>
<dt>UVec</dt><dd><p>is a normalized vector of the cone.  
It is usually its vertex direction but it may 
also be its interior vector pointing to a vertex 
of the artificial intersection of the cone with 
the bounding box <code>[-1,1]^M</code>.  The 
max normalization is used if the breadth-first 
search algorithm is employed and the L2 
normalization is used in the other case (when 
<code>M</code> = 2 and <code>CTechST$D2SpecI</code> = 1).</p>
</dd>
<dt>BDVec</dt><dd><p>is the vector <code>c(b_1,...,b_M)</code>, i.e., 
the constant vector denominator of <code>BVec</code>, 
where 
<code>BVec</code> = <code>BDVec/(t(BDVec)%*%UVec)</code>.</p>
</dd>
<dt>ADVec</dt><dd><p>is the vector <code>c(a_1,...,a_P)</code>, i.e., 
the constant vector denominator of <code>AVec</code>, 
where
<code>AVec</code> = <code>ADVec/(t(BDVec)%*%UVec)</code>.</p>
</dd>
<dt>LambdaD</dt><dd><p>is the constant scalar denominator of 
<code>Lambda</code> = <code>LambdaD/(t(BDVec)%*%UVec)</code>.</p>
</dd>
</dl>

<p>Recall that <code>c(BVec, AVec)</code> stands for the coefficients 
of the regression quantile hyperplane associated with 
<code>UVec</code> and that <code>Lambda</code> denotes the Lagrange 
multiplier equal to the optimal value <code>Psi</code> of the objective 
function for that direction.  
</p>
<p>If <code>CTechST$BriefOutputI</code> = 0, then the rows of the
potential output file(s) are longer 
(of length <code>1+1+M+M+P+1+(P+M-1)*M+(P+M-1)</code>) 
because they contain two more vectors appended at the end.  
The rows are of the form 
<code>c(ConeID, Nu, UVec, BDVec, ADVec, LambdaD, vec(VUMat), IZ)</code> 
where 
</p>

<dl>
<dt>VUMat</dt><dd><p>is the matrix for computing the multiplier vector 
<code>MuR0Vec</code> associated with zero residuals, 
<code>MuR0Vec</code> 
= <code>(VUMat%*%UVec)/(t(BDVec)%*%UVec)</code>.  
That is to say that all directions from the 
interior of the cone result in the regression 
<code>Tau</code>-quantile hyperplanes containing 
the same <code>P+M-1</code> observations because all 
such hyperplanes are the same up to a scaling 
factor multiplying their coefficients.</p>
</dd> 
<dt>IZ</dt><dd><p>is the vector containing original indices of the 
<code>M+P-1</code> observations with zero residuals 
for all directions from the interior of the cone.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>getCharSTM1u</code> returns a list with the following 
components:
</p>
<table>
<tr><td><code>NUESkip</code></td>
<td>
<p>the number of (skipped) directions (and 
corresponding hyperplanes) artificially 
induced by intersecting the cones with 
the <code>[-1,1]^M</code> bounding box.</p>
</td></tr>
<tr><td><code>NAZSkip</code></td>
<td>
<p>the number of (skipped) hyperplanes (and 
corresponding directions) not counted in NUESkip 
and with at least one coordinate of 
<code>AVec</code> zero.</p>
</td></tr>
<tr><td><code>NBZSkip</code></td>
<td>
<p>the number of (skipped) hyperplanes (and 
corresponding directions) not counted in NUESkip 
and with at least one coordinate of 
<code>BVec</code> zero.</p>
</td></tr>
<tr><td><code>HypMat</code></td>
<td>
<p>(for <code>M &gt; 4</code>) the component is missing  <br />
(for <code>M &lt;= 4</code>) the matrix with <code>M + P</code>
columns containing (in rows) all the distinct 
regression Tau-quantile hyperplane 
coefficients <code>c(BVec, AVec)</code> normalized 
with <code>|BVec|</code>, rounded to the eighth 
decimal digit, and sorted lexicographically.  
This matrix can be used for the computation 
of the regression <code>Tau</code>-quantile contour.</p>
</td></tr>
<tr><td><code>CharMaxMat</code></td>
<td>
<p>the matrix with the (slightly rounded) maxima 
of certain directional regression Tau-quantile 
characteristics over all remaining vertex 
directions.  <br />
If <code>P</code> = 1, then <code>CharMaxMat</code> has 
only three rows: <br />
<code>c(UVec, max(|BVec|))</code>, <br />
<code>c(UVec, max(Lambda))</code>, and <br />
<code>c(UVec, max(Lambda/|BVec|))</code>, <br />
respectively.  <br />
If <code>P</code> &gt; 1, then the rows of 
<code>CharMaxMat</code> are as follows: <br />
<code>c(UVec, max(|BVec|))</code>, <br />
<code>c(UVec, max(Lambda))</code>, <br />
<code>c(UVec, max(Lambda/|BVec|))</code>, <br />
<code>c(UVec, max(|c(a_2,...,a_P)|))</code>, <br />
<code>c(UVec, max(|c(a_2,...,a_P)|/|BVec|))</code>, <br />
<code>c(UVec, max(|a_2|))</code>, <br />
<code>c(UVec, max(|a_2|/|BVec|))</code>, <br />
<code>...</code>, <br />
<code>c(UVec, max(|a_P|))</code>, and <br />
<code>c(UVec, max(|a_P|/|BVec|))</code>, <br />
respectively.  If <code>P</code> = 2, 
then the last two rows are missing for not 
being included twice.
</p>
</td></tr>
<tr><td><code>CharMinMat</code></td>
<td>
<p>the matrix with the (slightly rounded) minima 
of certain directional regression Tau-quantile 
characteristics over all remaining vertex 
directions.  <br />
If <code>P</code> = 1, then <code>CharMinMat</code> has 
only three rows: <br />
<code>c(UVec, min(|BVec|))</code>, <br />
<code>c(UVec, min(Lambda))</code>, and <br />
<code>c(UVec, min(Lambda/|BVec|))</code>, <br />
respectively.  <br />
If <code>P</code> &gt; 1, then <code>CharMinMat</code> 
has five rows: <br /> 
<code>c(UVec, min(|BVec|))</code>, <br />
<code>c(UVec, min(Lambda))</code>, <br />
<code>c(UVec, min(Lambda/|BVec|))</code>, <br />
<code>c(UVec, min(|c(a_2,...,a_P)|))</code>, and <br />
<code>c(UVec, min(|c(a_2,...,a_P)|/|BVec|))</code>, <br />
respectively.</p>
</td></tr>
</table>
<p>Note that <code>||</code> symbolizes the Euclidean norm, 
and that the vertices (<code>UVec</code>) in the rows of 
<code>CharMaxMat</code> and <code>CharMinMat</code> are generally 
different and denote (one of) the direction(s) where 
the row maximum or minimum is attained.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Run print(getCharSTM1u) to examine the default setting.
</code></pre>

<hr>
<h2 id='getCharSTM2u'>Computing Some Overall Characteristics in <code>compContourM2u</code></h2><span id='topic+getCharSTM2u'></span>

<h3>Description</h3>

<p>The function computes some overall characteristics 
of directional regression quantiles in the output 
of <code><a href="#topic+compContourM2u">compContourM2u</a></code>, namely the list 
<code>COutST$CharST</code>.  It makes possible
to obtain some useful information without saving 
any file on the disk, and it can be easily modified 
by the users according to their wishes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCharSTM2u(Tau, N, M, P, BriefDQMat, CharST, IsFirst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCharSTM2u_+3A_tau">Tau</code></td>
<td>
<p>the quantile level in (0, 0.5).</p>
</td></tr>
<tr><td><code id="getCharSTM2u_+3A_n">N</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code id="getCharSTM2u_+3A_m">M</code></td>
<td>
<p>the dimension of responses.</p>
</td></tr>
<tr><td><code id="getCharSTM2u_+3A_p">P</code></td>
<td>
<p>the dimension of regressors including the intercept.</p>
</td></tr>
<tr><td><code id="getCharSTM2u_+3A_briefdqmat">BriefDQMat</code></td>
<td>
<p>the method-specific matrix containing 
the rows of a potential individual output 
file corresponding to 
<code>CTechST$BriefOutputI</code> = 1. See
the details below.</p>
</td></tr>
<tr><td><code id="getCharSTM2u_+3A_charst">CharST</code></td>
<td>
<p>the output list, updated with each run 
of the function.</p>
</td></tr>
<tr><td><code id="getCharSTM2u_+3A_isfirst">IsFirst</code></td>
<td>
<p>the indicator equal to one in the 
first run of <code>getCharSTM2u</code> 
(when <code>CharST</code> is initialized) 
and equal to zero otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called inside <code><a href="#topic+compContourM2u">compContourM2u</a></code>.  
First, it is called with 
<code>BriefDQMat</code> = <code>NULL</code>, 
<code>CharST</code> = <code>NULL</code> and 
<code>IsFirst</code> = 1 to initialize 
the output list <code>CharST</code>, and then 
it is called with <code>IsFirst</code> = 0 
successively for the content of each potential 
output file corresponding to 
<code>CTechST$BriefOutputI</code> = 1, i.e., even if
the output file(s) are not stored on the disk owing to 
<code>CTechST$OutSaveI</code> = 0.
</p>
<p>It still remains to describe in detail the content of possible 
output files, describing the optimal conic segmentation of 
the directional space that lies behind the optimization 
problem involved.  
</p>
<p>If <code>CTechST$BriefOutputI</code> = 1, then the rows of such
files are vectors of length <code>1+1+M+P*M+M</code> of the form 
<code>c(ConeID, Nu, UVec, vec(ACOMat), MuBRow)</code> where 
</p>

<dl>
<dt>ConeID</dt><dd><p>is the number/order of the cone related to the 
line.  If <code>M</code> &gt; 2, then a cone can appear in 
the output repeatedly (under different numbers).</p>
</dd>
<dt>Nu</dt><dd><p>is the number of negative residuals corresponding 
to the interior directions of the cone.</p>
</dd>
<dt>UVec</dt><dd><p>is a normalized vector of the cone.  
It is usually its vertex direction but it may 
also be its interior vector pointing to a vertex 
of the artificial intersection of the cone with 
the bounding box <code>[-1,1]^M</code>.  The 
max normalization is used if the breadth-first 
search algorithm is employed and the L2 
normalization is used in the other case (when 
<code>M</code> = 2 and <code>CTechST$D2SpecI</code> = 1).</p>
</dd>
<dt>ACOMat</dt><dd><p>is the matrix describing <code>AVec</code>, 
<code>AVec</code> = <code>ACOMat%*%UVec</code>.</p>
</dd>
<dt>MuBRow</dt><dd><p>is the constant vector of the Lagrange 
multipliers corresponding to <code>BVec</code>. 
Its inner product with <code>UVec</code> is equal 
to the optimal value <code>Psi</code> of the objective 
function for that direction.</p>
</dd>
</dl>

<p>Recall that <code>c(BVec, AVec)</code> stands for the coefficients 
of the regression quantile hyperplane associated with 
<code>UVec</code> and always <code>BVec</code> = <code>UVec</code>.  
</p>
<p>If <code>CTechST$BriefOutputI</code> = 0, then the rows of the
potential output file(s) are longer 
(of length <code>1+1+P*M+M+P+P</code>) 
because they contain two more vectors appended at the end.  
The rows are of the form 
<code>c(ConeID, Nu, UVec, vec(ACOMat), MuBRow, MuR0Row, IZ)</code> 
where 
</p>

<dl>
<dt>MuRORow</dt><dd><p>is the constant vector of the Lagrange 
multipliers corresponding to zero residuals 
associated with the interior of the cone.  
That is to say that all directions 
from the interior of the cone result in the 
regression <code>Tau</code>-quantile hyperplanes 
containing the same <code>P</code> observations.</p>
</dd> 
<dt>IZ</dt><dd><p>is the vector containing original indices of the 
<code>P</code> observations with zero residuals
for all directions from the interior of the cone.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>getCharSTM2u</code> returns a list with the following 
components:
</p>
<table>
<tr><td><code>NUESkip</code></td>
<td>
<p>the number of (skipped) directions (and 
corresponding hyperplanes) artificially 
induced by intersecting the cones with 
the <code>[-1,1]^M</code> bounding box</p>
</td></tr>
<tr><td><code>NAZSkip</code></td>
<td>
<p>the number of (skipped) hyperplanes (and 
corresponding directions) not counted in NUESkip 
and with at least one coordinate of 
<code>AVec</code> zero.</p>
</td></tr>
<tr><td><code>NBZSkip</code></td>
<td>
<p>the number of (skipped) hyperplanes (and 
corresponding directions) not counted in NUESkip 
and with at least one coordinate of 
<code>BVec</code> zero.</p>
</td></tr>
<tr><td><code>HypMat</code></td>
<td>
<p>(for <code>M &gt; 4</code>) the component is missing  <br />
(for <code>M &lt;= 4</code>) the matrix with <code>M + P</code> 
columns containing (in rows) all the distinct 
regression Tau-quantile hyperplane 
coefficients <code>c(BVec, AVec)</code> 
rounded to the eighth decimal digit and 
sorted lexicographically.  
This matrix can be used for the computation 
of the regression <code>Tau</code>-quantile contour.</p>
</td></tr>
<tr><td><code>CharMaxMat</code></td>
<td>
<p>the matrix with the (slightly rounded) maxima 
of certain directional regression Tau-quantile 
characteristics over all remaining vertex 
directions.  <br />
If <code>P</code> = 1, then <code>CharMaxMat</code> has 
only two rows: <br /> 
<code>c(UVec, max(Psi))</code>, and <br />
<code>c(UVec, max(|MuBRow|))</code>, <br />
respectively.  <br />
If <code>P</code> &gt; 1, then the rows of 
<code>CharMaxMat</code> are as follows: <br /> 
<code>c(UVec, max(|Psi|))</code>, <br />
<code>c(UVec, max(MuBRow))</code>, <br />
<code>c(UVec, max(|c(a_2,...,a_P)|))</code>, <br />
<code>c(UVec, max(|a_2|))</code>, <br />
<code>...</code>, <br />
<code>c(UVec, max(|a_P|))</code>, <br />
respectively.  If <code>P</code> = 2, 
then the last row is missing for not 
being included twice. 
</p>
</td></tr>
<tr><td><code>CharMinMat</code></td>
<td>
<p>the matrix with the (slightly rounded) minima 
of certain directional regression Tau-quantile 
characteristics over all remaining vertex 
directions.  <br />
If <code>P</code> = 1, then <code>CharMinMat</code> has 
only two rows: <br /> 
<code>c(UVec, min(Psi))</code>, and <br />
<code>c(UVec, min(|MuBRow|))</code>, <br />
respectively.  <br />
If <code>P</code> &gt; 1, then <code>CharMinMat</code> 
has three rows: <br /> 
<code>c(UVec, min(Psi))</code>, <br />
<code>c(UVec, min(|MuBRow|))</code>, and <br />
<code>c(UVec, min(|c(a_2,...,a_P)|))</code>, <br />
respectively.</p>
</td></tr>
</table>
<p>Note that <code>||</code> symbolizes the Euclidean norm, 
and that the vertices (<code>UVec</code>) in the rows of 
<code>CharMaxMat</code> and <code>CharMinMat</code> are generally 
different and denote (one of) the direction(s) where 
the row maximum or minimum is attained.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Run print(getCharSTM2u) to examine the default setting.
</code></pre>

<hr>
<h2 id='getCTechSTM1+2F2u'>Getting the List of Options CTechST for <code>compContourM1/2u</code></h2><span id='topic+getCTechSTM1u'></span><span id='topic+getCTechSTM2u'></span><span id='topic+getCTechSTM1+2F2u'></span>

<h3>Description</h3>

<p>The functions <code>getCTechSTM1u</code> and <code>getCTechSTM2u</code> 
set the default list of options CTechST for computing 
all the directional (regression) quantiles by means of 
<code><a href="#topic+compContourM1u">compContourM1u</a></code> and <code><a href="#topic+compContourM2u">compContourM2u</a></code>, 
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCTechSTM1u()
getCTechSTM2u()
</code></pre>


<h3>Arguments</h3>

<p>none
</p>


<h3>Details</h3>

<p>Fortunately, the default list of options usually 
leads to a satisfactory performance in all but very large 
problems.</p>


<h3>Value</h3>

<p>Both <code>getCTechSTM1u</code> and <code>getCTechSTM2u</code> produce 
a list with a few components whose default values are stated 
below after the equality sign.  
</p>
<p>The components <code>OutFilePrefS</code> and <code>getCharST</code> 
are initialized in a method-specific way.  
</p>
<p>The components <code>CubRegWiseI</code>, <code>ArchAllFI</code>, 
and <code>SkipRedI</code> are relevant only if <code>D2SpecI</code> 
is zero or if the dimension of directions/responses is 
higher than two, i.e., if the breadth-first search algorithm 
is used.  
</p>
<p>Most of the components are generated by both functions.  
Nevertheless, the component <code>SkipRedI</code> is only generated 
by <code>getCTechSTM2u</code> and used by 
<code><a href="#topic+compContourM2u">compContourM2u</a></code>.  
</p>
<p>The output components are as follows:  
</p>
<table>
<tr><td><code>ReportI</code></td>
<td>
<p>= 0; if some information (such as the progress 
of computation) is displayed on the screen (1) 
or not (0).  
The display mode may slightly slow down the 
computation, especially when the dimension of 
responses is higher than two.  
On the other hand, it shows the new value of the 
quantile level (Tau) (if the input one has been 
changed internally), the initial L2-normed 
directional vector used (<code>U0Vec</code>), the 
number of failures to find an initial solution 
(<code>NNotFound</code>), the number of found initial 
solutions not having the right number of clearly 
nonzero coordinates (<code>NBad</code>), and also the 
width of each layer of the breadth-first search 
algorithm if it is employed.</p>
</td></tr>
<tr><td><code>OutSaveI</code></td>
<td>
<p>= 0; if the detailed output is stored in 
file(s) into the working directory (1) or 
not (0).  The file output seems necessary only 
for very large problems if some information 
about individual cones has to be recorded 
(such as all the regression quantile 
hyperplanes used for the regression 
quantile contour computation).</p>
</td></tr>
<tr><td><code>D2SpecI</code></td>
<td>
<p>= 1; this option is relevant only for bivariate 
directions/responses and determines if the cones 
are visited counter-clockwise (1) or by means of 
the breadth-first search algorithm as in the 
general case (0).  The default option (1) leads 
to a more precise and reliable computation than 
the other.</p>
</td></tr>
<tr><td><code>BriefOutputI</code></td>
<td>
<p>= 1; if the brief (1) or verbose (0) 
output is prepared by 
<code><a href="#topic+compContourM1+2F2u">compContourM1/2u</a></code>.  
Even the default option (1) is sufficient 
for almost all common applications.  
See also <code><a href="#topic+getCharSTM1u">getCharSTM1u</a></code> and 
<code><a href="#topic+getCharSTM2u">getCharSTM2u</a></code> for the 
description of the possible 
method-specific file output in both cases.</p>
</td></tr>
<tr><td><code>CubRegWiseI</code></td>
<td>
<p>= 1; if the directional space is divided 
into orthants investigated separately (1) 
or not (0).  
On the one hand, the default option (1) 
splits the problem into smaller ones.  
On the other hand, it also generates 
some artificial cones with at least one 
facet in the orthant borders.</p>
</td></tr>
<tr><td><code>ArchAllFI</code></td>
<td>
<p>= 1; if all the past cone facet 
identifiers (1) or only those from the last 
few layers (0) are stored during the computation.  
The default option (1) makes the computation 
more likely to terminate successfully than 
the other.  Unfortunately, it is also slower 
and more memory demanding.  If the dimension 
of responses is higher than three, then 
<code>ArchAllFI</code> = 1 is considered internally 
by <code><a href="#topic+compContourM1+2F2u">compContourM1/2u</a></code> no matter 
what the input <code>CTechST</code> actually says.</p>
</td></tr>
<tr><td><code>SkipRedI</code></td>
<td>
<p>= 0; if the information should be skipped (1) 
or stored (0) also from the cones with all 
non-artificial facets already known (such cones 
are redundant/irrelevant with probability one 
if only all the quantile regression 
hyperplanes necessary for the quantile contour 
computation are required from 
<code><a href="#topic+compContourM2u">compContourM2u</a></code>).  
The skipping makes the output smaller but 
maybe also slightly less reliable.  It also 
affects the reliability of the information 
regarding the inner points; see 
<code><a href="#topic+compContourM2u">compContourM2u</a></code>.</p>
</td></tr>
<tr><td><code>OutFilePrefS</code></td>
<td>
<p>= &lsquo;DQOutputM1_&rsquo;/&lsquo;DQOutputM2_&rsquo;; 
the prefix of possible output 
file name(s).</p>
</td></tr>
<tr><td><code>getCharST</code></td>
<td>
<p>= getCharSTM1u/getCharSTM2u; the function 
computing some overall characteristics that 
can be replaced with a user-defined one.  
See <code><a href="#topic+getCharSTM1u">getCharSTM1u</a></code> and 
<code><a href="#topic+getCharSTM2u">getCharSTM2u</a></code> for the default 
choices.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##- a typical use of getCTechSTM1u: 
##computing all directional 0.01-quantiles of 49 random points 
##(uniformly distributed in the unit cube centered at zero) 
##after changing the default settings 
Tau  &lt;- 0.01
XMat &lt;- matrix(1, 49, 1)
YMat &lt;- matrix(runif(3*49, -0.5, 0.5), 49, 3)
CTechST &lt;- getCTechSTM1u()
CTechST$ReportI &lt;- 1
COutST &lt;- compContourM1u(Tau, YMat, XMat, CTechST)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
